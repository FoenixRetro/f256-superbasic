
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Sat Nov 26 15:45:43 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	MaxLineSize+1
.057b					numberBuffer:
>057b							.fill 	34
.059d					decimalBuffer:
>059d							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 35 a9	jsr $a935			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt display
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 99 8e	jsr $8e99			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 80 b8	jsr $b880			jsr 	SNDCommand
.8019	20 2e 89	jsr $892e			jsr 	NewProgram 					; erase current program
.801c	20 d2 82	jsr $82d2			jsr 	BackloadProgram
.801f	4c 6a 8a	jmp $8a6a			jmp 	CommandRun
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	52 65 6c 65 61 73 65 20			.text "Release Alpha 6 (26-Nov-22). "
>804b	41 6c 70 68 61 20 36 20 28 32 36 2d 4e 6f 76 2d
>805b	32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>8060	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8063					AssembleGroup1:
.8063	a9 ff		lda #$ff			lda 	#$FF
.8065	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8068	80 02		bra $806c			bra 	AsmGroup12
.806a					AssembleGroup2:
.806a	a9 00		lda #$00			lda 	#$00
.806c					AsmGroup12:
.806c	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.806f	68		pla				pla 								; pop the return address to access the information following.
.8070	fa		plx				plx
.8071	20 f8 80	jsr $80f8			jsr 	AccessParameters 			; get opcode and save as base
.8074	8d 24 04	sta $0424			sta 	BaseOpcode
.8077	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.807a	d0 08		bne $8084			bne 	_AG12HaveMask
.807c	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.807e	20 00 81	jsr $8100			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8081	8d 25 04	sta $0425			sta 	ModeMask
.8084					_AG12HaveMask:
.8084	20 34 82	jsr $8234			jsr 	TypeAndCalculateOperand 	; get zero page type
.8087	da		phx				phx 								; save found address mode
.8088	20 64 81	jsr $8164			jsr 	AssembleModeX
.808b	fa		plx				plx  								; restore address mode
.808c	b0 0b		bcs $8099			bcs 	_AG12Exit
.808e	20 9a 80	jsr $809a			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8091	20 64 81	jsr $8164			jsr 	AssembleModeX
.8094	b0 03		bcs $8099			bcs 	_AG12Exit
.8096	4c c5 9e	jmp $9ec5			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8099					_AG12Exit:
.8099	60		rts				rts
.809a					PromoteToAbsolute:
.809a	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.809c	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.809e	f0 19		beq $80b9			beq 	_PTADo
.80a0	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80a2	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80a4	f0 13		beq $80b9			beq 	_PTADo
.80a6	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80a8	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80aa	f0 0d		beq $80b9			beq 	_PTADo
.80ac	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80ae	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b0	f0 07		beq $80b9			beq 	_PTADo
.80b2	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80b4	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80b6	f0 01		beq $80b9			beq 	_PTADo
.80b8	60		rts				rts
.80b9					_PTADo:
.80b9	aa		tax				tax
.80ba	60		rts				rts
.80bb					AssembleGroup3:
.80bb	68		pla				pla 								; get parameters, which is just the opcode.
.80bc	fa		plx				plx
.80bd	20 f8 80	jsr $80f8			jsr 	AccessParameters 			; get and output opcode
.80c0	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.80c3	20 98 82	jsr $8298			jsr 	CalculateOperand 			; get a 16 bit operand
.80c6	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80c8	38		sec				sec
.80c9	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80cc	48		pha				pha 								; LSB in A
.80cd	a5 60		lda $60				lda 	NSMantissa1
.80cf	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80d2	aa		tax				tax 								; MSB in X
.80d3	68		pla				pla
.80d4	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80d5	69 7f		adc #$7f			adc 	#$7F
.80d7	90 01		bcc $80da			bcc 	_AG3NoCarry
.80d9	e8		inx				inx
.80da					_AG3NoCarry:
.80da	38		sec				sec 								; fix back and write out anyways.
.80db	e9 80		sbc #$80			sbc 	#$80
.80dd	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.80e0	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80e2	f0 0a		beq $80ee			beq 	_AG3Exit
.80e4	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.80e7	29 01		and #$01			and 	#1
.80e9	f0 03		beq $80ee			beq 	_AG3Exit
.80eb	4c ca 9e	jmp $9eca			jmp 	RangeError 					; no, branch is out of range
.80ee					_AG3Exit:
.80ee	60		rts				rts
.80ef					AssembleGroup4:
.80ef	68		pla				pla 								; pop address
.80f0	fa		plx				plx
.80f1	20 f8 80	jsr $80f8			jsr 	AccessParameters 			; access and get first
.80f4	20 10 81	jsr $8110			jsr 	AssemblerWriteByte 			; output it.
.80f7	60		rts				rts
.80f8					AccessParameters:
.80f8	8d 21 04	sta $0421			sta 	ParamStart
.80fb	8e 22 04	stx $0422			stx 	ParamStart+1
.80fe	a9 01		lda #$01			lda 	#1
.8100					GetParameter:
.8100	5a		phy				phy
.8101	a8		tay				tay
.8102	ad 21 04	lda $0421			lda 	ParamStart
.8105	85 36		sta $36				sta 	zTemp0
.8107	ad 22 04	lda $0422			lda 	ParamStart+1
.810a	85 37		sta $37				sta 	zTemp0+1
.810c	b1 36		lda ($36),y			lda 	(zTemp0),y
.810e	7a		ply				ply
.810f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.8110					AssemblerWriteByte:
.8110	48		pha			pha
.8111	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8114	29 02		and #$02		and 	#2
.8116	f0 1b		beq $8133		beq 	_AWBNoPrint
.8118	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.811b	20 4e 81	jsr $814e		jsr 	PrintHex
.811e	ad 1e 04	lda $041e		lda		AssemblerAddress
.8121	20 4e 81	jsr $814e		jsr 	PrintHex
.8124	a9 20		lda #$20		lda 	#' '
.8126	20 c1 a6	jsr $a6c1		jsr 	EXTPrintCharacter
.8129	68		pla			pla 									; print byte
.812a	48		pha			pha
.812b	20 4e 81	jsr $814e		jsr 	PrintHex
.812e	a9 0d		lda #$0d		lda 	#13
.8130	20 c1 a6	jsr $a6c1		jsr 	EXTPrintCharacter
.8133					_AWBNoPrint:
.8133	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8136	85 36		sta $36			sta 	zTemp0
.8138	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.813b	f0 0e		beq $814b		beq 	_AWBRange
.813d	85 37		sta $37			sta 	zTemp0+1
.813f	68		pla			pla 									; write byte out
.8140	92 36		sta ($36)		sta 	(zTemp0)
.8142	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8145	d0 03		bne $814a		bne 	_AWBNoCarry
.8147	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.814a					_AWBNoCarry:
.814a	60		rts			rts
.814b					_AWBRange:
.814b	4c ca 9e	jmp $9eca		jmp 	RangeError
.814e					PrintHex:
.814e	48		pha				pha
.814f	4a		lsr a				lsr 	a
.8150	4a		lsr a				lsr 	a
.8151	4a		lsr a				lsr 	a
.8152	4a		lsr a				lsr 	a
.8153	20 57 81	jsr $8157			jsr 	_PrintNibble
.8156	68		pla				pla
.8157					_PrintNibble:
.8157	29 0f		and #$0f			and 	#15
.8159	c9 0a		cmp #$0a			cmp 	#10
.815b	90 02		bcc $815f			bcc 	_NoShift
.815d	69 06		adc #$06			adc 	#6
.815f					_NoShift:
.815f	69 30		adc #$30			adc 	#48
.8161	4c c1 a6	jmp $a6c1			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8164					AssembleModeX:
.8164	5a		phy				phy
.8165	ad 23 04	lda $0423			lda 	IsGroup1
.8168	f0 17		beq $8181			beq 	_AMXGroup2
.816a	8a		txa				txa 							; is it in group # 1
.816b	29 40		and #$40			and 	#AM_ISG1
.816d	f0 4d		beq $81bc			beq 	_AMXFail 				; no, give up.
.816f	8a		txa				txa 							; get back.
.8170	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8172	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8174	d0 22		bne $8198			bne 	_AMXHaveInfo
.8176	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8179	c9 81		cmp #$81			cmp 	#$81
.817b	f0 3f		beq $81bc			beq 	_AMXFail
.817d	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.817f	80 17		bra $8198			bra 	_AMXHaveInfo 			; odd design decision there.
.8181					_AMXGroup2:
.8181	8a		txa				txa 							; is it in group 2 ?
.8182	29 20		and #$20			and 	#AM_ISG2
.8184	f0 36		beq $81bc			beq 	_AMXFail 				; no, give up.
.8186	8a		txa				txa 							; get the offset into Y
.8187	29 1f		and #$1f			and 	#$1F
.8189	4a		lsr a				lsr 	a 						; make it 0-7.
.818a	4a		lsr a				lsr  	a
.818b	a8		tay				tay
.818c	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.818f					_AMXCheckOkay:
.818f	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.8190	88		dey				dey
.8191	10 fc		bpl $818f			bpl 	_AMXCheckOkay
.8193	90 27		bcc $81bc			bcc 	_AMXFail 				; not allowed.
.8195	8a		txa				txa  							; get mask back
.8196	29 1f		and #$1f			and 	#$1F
.8198					_AMXHaveInfo:
.8198	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.819a	10 04		bpl $81a0			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.819c	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.819e	d0 1c		bne $81bc			bne 	_AMXFail
.81a0					_AMXAnySize:
.81a0	18		clc				clc 							; add offset to the base opcode
.81a1	6d 24 04	adc $0424			adc 	BaseOpcode
.81a4					_AMXOutputCode:
.81a4	20 10 81	jsr $8110			jsr 	AssemblerWriteByte 		; write the opcode out.
.81a7	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81a9	f0 0e		beq $81b9			beq 	_AMXExit
.81ab	a5 58		lda $58				lda 	NSMantissa0 				; write LSB operand
.81ad	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.81b0	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81b2	30 05		bmi $81b9			bmi 	_AMXExit
.81b4	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.81b6	20 10 81	jsr $8110			jsr 	AssemblerWriteByte
.81b9					_AMXExit:
.81b9	7a		ply				ply
.81ba	38		sec				sec
.81bb	60		rts				rts
.81bc					_AMXFail:
.81bc	a0 00		ldy #$00			ldy 	#0
.81be					_AMXCheckOddities:
.81be	8a		txa				txa
.81bf	d9 e6 81	cmp $81e6,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81c2	d0 15		bne $81d9			bne 	_AMXCONext
.81c4	b9 e4 81	lda $81e4,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81c7	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81ca	d0 0d		bne $81d9			bne 	_AMXCONext
.81cc	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81ce	10 04		bpl $81d4			bpl 	_AMXCONotZero
.81d0	a5 60		lda $60				lda 	NSMantissa1
.81d2	d0 05		bne $81d9			bne 	_AMXCONext
.81d4					_AMXCONotZero:
.81d4	b9 e5 81	lda $81e5,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81d7	80 cb		bra $81a4			bra 	_AMXOutputCode 			; and assemble it
.81d9					_AMXCONext:
.81d9	c8		iny				iny
.81da	c8		iny				iny
.81db	c8		iny				iny
.81dc	b9 e4 81	lda $81e4,y			lda 	ExtraOpcode+0,y 		; end of table
.81df	d0 dd		bne $81be			bne 	_AMXCheckOddities
.81e1					_AMXCOFail:
.81e1	7a		ply				ply
.81e2	18		clc				clc
.81e3	60		rts				rts
.81e4					ExtraOpcode:
>81e4	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81e7	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81ea	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81ed	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81f0	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>81f3	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>81f6	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>81f9	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>81fc	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>81ff	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8202	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8203					LabelHere:
.8203	c8		iny				iny 								; skip .
.8204	a2 00		ldx #$00			ldx 	#0 							; get a term
.8206	20 8e 97	jsr $978e			jsr 	EvaluateTerm 				; get a term
.8209	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.820b	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.820d	d0 22		bne $8231			bne 	_ALType
.820f	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8211	85 36		sta $36				sta 	zTemp0
.8213	b5 60		lda $60,x			lda 	NSMantissa1,x
.8215	85 37		sta $37				sta 	zTemp0+1
.8217	5a		phy				phy 								; copy address in.
.8218	a0 01		ldy #$01			ldy 	#1
.821a	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.821d	92 36		sta ($36)			sta 	(zTemp0)
.821f	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8222	91 36		sta ($36),y			sta 	(zTemp0),y
.8224	c8		iny				iny
.8225	a9 00		lda #$00			lda 	#0
.8227	91 36		sta ($36),y			sta 	(zTemp0),y
.8229	c8		iny				iny
.822a	91 36		sta ($36),y			sta 	(zTemp0),y
.822c	c8		iny				iny
.822d	91 36		sta ($36),y			sta 	(zTemp0),y
.822f	7a		ply				ply
.8230	60		rts				rts
.8231					_ALType:
.8231	4c cf 9e	jmp $9ecf			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8234					TypeAndCalculateOperand:
.8234	b1 30		lda ($30),y			lda 	(codePtr),y
.8236	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8238	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.823a	f0 5b		beq $8297			beq 	_TACOExit
.823c	c9 80		cmp #$80			cmp 	#KWC_EOL
.823e	f0 57		beq $8297			beq 	_TACOExit
.8240	c8		iny				iny
.8241	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8243	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8245	f0 51		beq $8298			beq 	CalculateOperand
.8247	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8249	f0 1f		beq $826a			beq 	_TACOIndirect
.824b	88		dey				dey 								; undo get of first character
.824c	20 98 82	jsr $8298			jsr 	CalculateOperand 			; get operand
.824f	b1 30		lda ($30),y			lda 	(codePtr),y
.8251	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8253	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8255	d0 40		bne $8297			bne 	_TACOExit
.8257	c8		iny				iny
.8258	20 a2 82	jsr $82a2			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.825b	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.825d	c9 58		cmp #$58			cmp 	#'X'
.825f	f0 36		beq $8297			beq 	_TACOExit
.8261	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8263	c9 59		cmp #$59			cmp 	#'Y'
.8265	f0 30		beq $8297			beq 	_TACOExit
.8267					_TACOSyntax:
.8267	4c c5 9e	jmp $9ec5			jmp 	SyntaxError
.826a					_TACOIndirect:
.826a	20 98 82	jsr $8298			jsr 	CalculateOperand 			; get the operand
.826d	b1 30		lda ($30),y			lda 	(codePtr),y
.826f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8271	f0 17		beq $828a			beq 	_TACOIndX
.8273	20 27 8e	jsr $8e27			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8276	b1 30		lda ($30),y			lda 	(codePtr),y
.8278	a2 d1		ldx #$d1			ldx 	#AM_IND
.827a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.827c	d0 19		bne $8297			bne 	_TACOExit
.827e	c8		iny				iny
.827f	20 a2 82	jsr $82a2			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8282	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8284	d0 e1		bne $8267			bne 	_TACOSyntax
.8286	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8288	80 0d		bra $8297			bra 	_TACOExit
.828a					_TACOIndX:
.828a	c8		iny				iny
.828b	20 a2 82	jsr $82a2			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.828e	c9 58		cmp #$58			cmp 	#'X' 						; check X
.8290	d0 d5		bne $8267			bne 	_TACOSyntax
.8292	20 27 8e	jsr $8e27			jsr 	CheckRightBracket			; check )
.8295	a2 c0		ldx #$c0			ldx 	#AM_INDX
.8297					_TACOExit:
.8297	60		rts				rts
.8298					CalculateOperand:
.8298	48		pha				pha
.8299	da		phx				phx
.829a	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.829c	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger
.829f	fa		plx				plx
.82a0	68		pla				pla
.82a1	60		rts				rts
.82a2					TACOCheckXY:
.82a2	b1 30		lda ($30),y			lda 	(codePtr),y
.82a4	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82a6	c9 40		cmp #$40			cmp 	#$40
.82a8	d0 21		bne $82cb			bne 	_TCXYFail
.82aa	b1 30		lda ($30),y			lda 	(codePtr),y
.82ac	18		clc				clc
.82ad	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82af	85 37		sta $37				sta 	zTemp0+1
.82b1	c8		iny				iny
.82b2	b1 30		lda ($30),y			lda 	(codePtr),y
.82b4	c8		iny				iny
.82b5	85 36		sta $36				sta 	zTemp0
.82b7	5a		phy				phy 								; save position
.82b8	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82ba	b1 36		lda ($36),y			lda 	(zTemp0),y
.82bc	d0 0c		bne $82ca			bne 	_TCXYPopFail
.82be	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82c0	b1 36		lda ($36),y			lda 	(zTemp0),y
.82c2	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82c4	f0 08		beq $82ce			beq 	_TCXYFound
.82c6	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82c8	f0 04		beq $82ce			beq 	_TCXYFound
.82ca					_TCXYPopFail:
.82ca	7a		ply				ply
.82cb					_TCXYFail:
.82cb	a9 00		lda #$00			lda 	#0
.82cd	60		rts				rts
.82ce					_TCXYFound:
.82ce	7a		ply				ply 								; restore position
.82cf	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82d2					BackloadProgram:
.82d2	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82d4	a9 19		lda #$19			lda 	#_BLLoad & $FF
.82d6	20 99 8e	jsr $8e99			jsr 	PrintStringXA
.82d9	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82db	8d ad 05	sta $05ad			sta 	0+BackLoadPointer
.82de	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82e0	8d ae 05	sta $05ae			sta 	1+BackLoadPointer
.82e3	a9 ff		lda #$ff			lda 	#$FF
.82e5	8d fa ff	sta $fffa			sta 	$FFFA
.82e8					_BPLoop:
.82e8	a2 ff		ldx #$ff			ldx 	#$FF
.82ea	20 2e 83	jsr $832e			jsr 	BLReadByte 					; read a byte
.82ed	c9 00		cmp #$00			cmp 	#0
.82ef	f0 21		beq $8312			beq 	_BPExit 					; if 0 exit
.82f1	30 1f		bmi $8312			bmi 	_BPExit 					; if -ve exit
.82f3					_BPCopy:
.82f3	e8		inx				inx  								; copy byte into the lineBuffer
.82f4	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.82f7	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.82fa	20 2e 83	jsr $832e			jsr 	BLReadByte 					; read next byte
.82fd	30 0a		bmi $8309			bmi 	_BPEndLine 					; -ve = EOL
.82ff	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8301	d0 02		bne $8305			bne 	_BPNotTab
.8303	a9 20		lda #$20			lda 	#' '
.8305					_BPNotTab:
.8305	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8307	b0 ea		bcs $82f3			bcs 	_BPCopy 					; until a control character, should be 13 received.
.8309					_BPEndLine:
.8309	20 ff b4	jsr $b4ff			jsr 	TokeniseLine 				; tokenise the line.
.830c	ea		nop				nop
.830d	20 45 83	jsr $8345			jsr 	EditProgramCode
.8310	80 d6		bra $82e8			bra 	_BPLoop
.8312					_BPExit:
.8312	9c fa ff	stz $fffa			stz 	$FFFA
.8315	20 00 84	jsr $8400			jsr 	ClearCommand 				; clear variables etc.
.8318	60		rts				rts
.8319					_BLLoad:
>8319	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8321	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.832e					BLReadByte:
.832e	ad ad 05	lda $05ad			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8331	85 36		sta $36				sta 	zTemp0
.8333	ad ae 05	lda $05ae			lda 	BackLoadPointer+1
.8336	85 37		sta $37				sta 	zTemp0+1
.8338	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.833a	ee ad 05	inc $05ad			inc 	BackLoadPointer 			; bump pointer
.833d	d0 03		bne $8342			bne 	_BLNoCarry
.833f	ee ae 05	inc $05ae			inc 	BackLoadPointer+1
.8342					_BLNoCarry:
.8342	c9 00		cmp #$00			cmp 	#0
.8344	60		rts				rts
.05ad					BackLoadPointer:
>05ad							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8345					EditProgramCode:
.8345	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line.
.8348	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.834b	20 b3 a4	jsr $a4b3			jsr 	MemorySearch
.834e	90 05		bcc $8355			bcc 	_EPCNoDelete 				; reached the end don't delete
.8350	d0 03		bne $8355			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8352	20 d8 a3	jsr $a3d8			jsr 	MemoryDeleteLine 			; delete the line
.8355					_EPCNoDelete:
.8355	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty
.8358	c9 80		cmp #$80			cmp 	#KWC_EOL
.835a	f0 0d		beq $8369			beq 	_EPCNoInsert
.835c	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist.
.835f	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8362	20 b3 a4	jsr $a4b3			jsr 	MemorySearch
.8365	18		clc				clc 								; insert at this point.
.8366	20 0f a4	jsr $a40f			jsr 	MemoryInsertLine 			; insert the line
.8369					_EPCNoInsert:
.8369	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.836a					WarmStart:
.836a	a2 ff		ldx #$ff			ldx 	#$FF
.836c	9a		txs				txs
.836d	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour
.836f	20 c1 a6	jsr $a6c1			jsr 	EXTPrintCharacter
.8372	20 4f a8	jsr $a84f			jsr 	EXTInputLine 				; get line to lineBuffer
.8375	20 ff b4	jsr $b4ff			jsr 	TokeniseLine 				; tokenise the line
.8378	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number ?
.837b	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.837e	d0 17		bne $8397			bne 	_WSEditCode 				; if so,edit code.
.8380	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.8383	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.8385	85 30		sta $30				sta 	codePtr
.8387	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8389	85 31		sta $31				sta 	codePtr+1
.838b	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.838e	c9 80		cmp #$80			cmp 	#KWC_EOL
.8390	f0 d8		beq $836a			beq 	WarmStart
.8392	20 7c 8a	jsr $8a7c			jsr 	RUNCodePointerLine 			; execute that line.
.8395	80 d3		bra $836a			bra 	WarmStart
.8397					_WSEditCode:
.8397	20 45 83	jsr $8345			jsr 	EditProgramCode
.839a	20 00 84	jsr $8400			jsr 	ClearCommand
.839d	80 cb		bra $836a			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.839f					AssembleCommand:
.839f	a2 00		ldx #$00			ldx 	#0
.83a1	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger 		; start address
.83a4	a5 58		lda $58				lda 	NSMantissa0
.83a6	8d 1e 04	sta $041e			sta 	AssemblerAddress
.83a9	a5 60		lda $60				lda 	NSMantissa1
.83ab	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.83ae	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.83b1	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; options
.83b4	a5 58		lda $58				lda 	NSMantissa0
.83b6	8d 20 04	sta $0420			sta 	AssemblerControl
.83b9	60		rts				rts
.83ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83bb					AssertCommand:
.83bb	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83bd	20 ba 9c	jsr $9cba			jsr 	EvaluateInteger 			; the assert test
.83c0	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; exit if result is non zero.
.83c3	d0 05		bne $83ca			bne 	_ACExit
.83c5	a9 0a		lda #$0a		lda	#10
.83c7	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.83ca					_ACExit:
.83ca	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83cb					CallCommand:
.83cb	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83cd	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger
.83d0					_CCClear
.83d0	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83d1	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero 					; these are optional sequentially.
.83d4	e0 04		cpx #$04			cpx 	#4
.83d6	d0 f8		bne $83d0			bne 	_CCClear
.83d8	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83da					_CCCParam:
.83da	b1 30		lda ($30),y			lda 	(codePtr),y
.83dc	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83de	d0 09		bne $83e9			bne 	_CCCRun6502
.83e0	c8		iny				iny 								; skip comma
.83e1	e8		inx				inx	 								; next level
.83e2	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83e5	e0 03		cpx #$03			cpx 	#3
.83e7	90 f1		bcc $83da			bcc 	_CCCParam 					; done all 3 ?
.83e9					_CCCRun6502:
.83e9	5a		phy				phy 								; save position
.83ea	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.83ec	85 37		sta $37				sta 	zTemp0+1
.83ee	a5 58		lda $58				lda 	NSMantissa0
.83f0	85 36		sta $36				sta 	zTemp0
.83f2	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.83f4	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.83f6	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.83f8	20 fd 83	jsr $83fd			jsr 	_CCCZTemp0 					; call zTemp0
.83fb	7a		ply				ply 								; restore position and exit
.83fc	60		rts				rts
.83fd					_CCCZTemp0:
.83fd	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.8400					ClearCommand:
.8400	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8402	85 36		sta $36				sta 	0+zTemp0
.8404	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.8406	85 37		sta $37				sta 	1+zTemp0
.8408					_ClearZeroLoop:
.8408	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.840a	f0 24		beq $8430			beq 	_ClearZeroEnd
.840c	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.840e	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8410					_ClearOneVariable:
.8410	91 36		sta ($36),y			sta 	(zTemp0),y
.8412	c8		iny				iny
.8413	c0 08		cpy #$08			cpy 	#8
.8415	d0 f9		bne $8410			bne 	_ClearOneVariable
.8417	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8419	b1 36		lda ($36),y			lda 	(zTemp0),y
.841b	c9 18		cmp #$18			cmp 	#NSTProcedure
.841d	d0 04		bne $8423			bne 	_ClearNotProcedure
.841f	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8421	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8423					_ClearNotProcedure:
.8423	18		clc				clc 								; go to the next variable
.8424	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8426	65 36		adc $36				adc 	zTemp0
.8428	85 36		sta $36				sta 	zTemp0
.842a	90 dc		bcc $8408			bcc 	_ClearZeroLoop
.842c	e6 37		inc $37				inc 	zTemp0+1
.842e	80 d8		bra $8408			bra 	_ClearZeroLoop
.8430					_ClearZeroEnd:
.8430	18		clc				clc
.8431	a5 36		lda $36				lda 	zTemp0
.8433	69 01		adc #$01			adc 	#1
.8435	8d 0c 04	sta $040c			sta 	lowMemPtr
.8438	a5 37		lda $37				lda 	zTemp0+1
.843a	69 00		adc #$00			adc 	#0
.843c	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.843f	20 ef a5	jsr $a5ef			jsr 	StackReset
.8442	20 55 a6	jsr $a655			jsr 	StringSystemInitialise
.8445	20 cd 8c	jsr $8ccd			jsr 	ProcedureScan
.8448	20 2b 8a	jsr $8a2b			jsr 	Command_Restore
.844b	9c 1e 04	stz $041e			stz 	AssemblerAddress
.844e	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.8451	9c 20 04	stz $0420			stz 	AssemblerControl
.8454	20 75 99	jsr $9975			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8457	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8458					ClearScreen:
.8458	5a		phy				phy
.8459	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.845b	20 c1 a6	jsr $a6c1			jsr 	EXTPrintCharacter
.845e	7a		ply				ply
.845f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8460					Command_Data:
.8460	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8462	a2 80		ldx #$80			ldx 	#KWC_EOL
.8464	20 1f 8d	jsr $8d1f			jsr 	ScanForward
.8467	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8468					DimCommand:
.8468	b1 30		lda ($30),y			lda 	(codePtr),y
.846a	29 c0		and #$c0			and 	#$C0
.846c	c9 40		cmp #$40			cmp 	#$40
.846e	d0 7a		bne $84ea			bne 	_DCSyntax
.8470	b1 30		lda ($30),y			lda 	(codePtr),y
.8472	18		clc				clc
.8473	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8475	85 3f		sta $3f				sta 	zaTemp+1
.8477	c8		iny				iny
.8478	b1 30		lda ($30),y			lda 	(codePtr),y
.847a	c8		iny				iny
.847b	85 3e		sta $3e				sta 	zaTemp
.847d	5a		phy				phy
.847e	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8480	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8482	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8484	c9 18		cmp #$18			cmp 	#NSTProcedure
.8486	f0 62		beq $84ea			beq 	_DCSyntax
.8488	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.848a	29 04		and #$04			and 	#NSBIsArray
.848c	f0 64		beq $84f2			beq 	_DCType
.848e	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8490	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8492	d0 59		bne $84ed			bne 	_DCRedefine
.8494	7a		ply				ply
.8495	20 f5 84	jsr $84f5			jsr 	_DCGetSize 				; get array size, check it.
.8498	5a		phy				phy
.8499	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.849b	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.849d	7a		ply				ply 							; is there a second (e.g. ,x)
.849e	b1 30		lda ($30),y			lda 	(codePtr),y
.84a0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84a2	d0 0a		bne $84ae			bne 	_DCOneDimension
.84a4	c8		iny				iny 							; skip comma
.84a5	20 f5 84	jsr $84f5			jsr 	_DCGetSize 				; get 2nd array size
.84a8	5a		phy				phy
.84a9	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84ab	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84ad	7a		ply				ply
.84ae					_DCOneDimension:
.84ae	5a		phy				phy 							; save position
.84af	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84b1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b3	aa		tax				tax
.84b4	c8		iny				iny
.84b5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b7	e8		inx				inx 							; bump them.
.84b8	1a		inc a				inc 	a
.84b9	20 f8 9c	jsr $9cf8			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84bc	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84be	29 e0		and #$e0			and 	#$E0
.84c0	d0 23		bne $84e5			bne 	_DCSize
.84c2	a0 02		ldy #$02			ldy 	#2 						; get base type
.84c4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84c6	20 03 85	jsr $8503			jsr 	ScaleByBaseType 		; scale by base type
.84c9	a5 36		lda $36				lda 	zTemp0
.84cb	a6 37		ldx $37				ldx 	zTemp0+1
.84cd	20 37 99	jsr $9937			jsr 	AllocateXABytes 		; allocate memory
.84d0	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84d2	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84d4	c8		iny				iny
.84d5	8a		txa				txa
.84d6	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84d8	7a		ply				ply 							; get position back
.84d9	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 		; check )
.84dc	b1 30		lda ($30),y			lda 	(codePtr),y
.84de	c8		iny				iny 							; consume in case
.84df	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84e1	f0 85		beq $8468			beq 	DimCommand
.84e3	88		dey				dey 							; undo consume
.84e4	60		rts				rts
.84e5					_DCSize:
.84e5	a9 16		lda #$16		lda	#22
.84e7	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.84ea					_DCSyntax:
.84ea	4c c5 9e	jmp $9ec5			jmp 	SyntaxError
.84ed					_DCRedefine:
.84ed	a9 15		lda #$15		lda	#21
.84ef	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.84f2					_DCType:
.84f2	4c cf 9e	jmp $9ecf			jmp 	TypeError
.84f5					_DCGetSize:
.84f5	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84f7	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 	; get array dimension
.84fa	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84fc	f0 e7		beq $84e5			beq 	_DCSize
.84fe	c9 fe		cmp #$fe			cmp 	#254
.8500	f0 e3		beq $84e5			beq 	_DCSize
.8502	60		rts				rts
.8503					ScaleByBaseType:
.8503	29 10		and #$10			and 	#NSBIsString 			; is it string
.8505	d0 19		bne $8520			bne 	_SBBTString
.8507	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8509	48		pha				pha
.850a	a5 36		lda $36				lda 	zTemp0
.850c	48		pha				pha
.850d	06 36		asl $36				asl 	zTemp0 					; x 2
.850f	26 37		rol $37				rol 	zTemp0+1
.8511	06 36		asl $36				asl 	zTemp0 					; x 4
.8513	26 37		rol $37				rol 	zTemp0+1
.8515	68		pla				pla 							; add stacked value = x 5
.8516	65 36		adc $36				adc 	zTemp0
.8518	85 36		sta $36				sta 	zTemp0
.851a	68		pla				pla
.851b	65 37		adc $37				adc 	zTemp0+1
.851d	85 37		sta $37				sta 	zTemp0+1
.851f	60		rts				rts
.8520					_SBBTString:
.8520	06 36		asl $36				asl 	zTemp0
.8522	26 37		rol $37				rol 	zTemp0+1
.8524	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8525					EndCommand:
.8525	4c 6a 83	jmp $836a			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8528					ForCommand:
.8528	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.852a	20 8a a5	jsr $a58a			jsr 	StackOpen
.852d	a2 00		ldx #$00			ldx 	#0
.852f	20 8e 97	jsr $978e			jsr 	EvaluateTerm
.8532	b5 50		lda $50,x			lda 	NSStatus,x
.8534	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8536	d0 47		bne $857f			bne		_FCError
.8538	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.853a	20 37 8e	jsr $8e37			jsr 	CheckNextA
.853d	e8		inx				inx
.853e	20 ba 9c	jsr $9cba			jsr 	EvaluateInteger 			; <from> in +1
.8541	b1 30		lda ($30),y			lda 	(codePtr),y
.8543	c8		iny				iny 								; consume it
.8544	48		pha				pha 								; save on stack for later
.8545	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8547	f0 04		beq $854d			beq 	_FCNoSyntax
.8549	c9 ce		cmp #$ce			cmp 	#KWD_TO
.854b	d0 35		bne $8582			bne 	_FCSyntaxError
.854d					_FCNoSyntax:
.854d	e8		inx				inx
.854e	20 ba 9c	jsr $9cba			jsr 	EvaluateInteger
.8551	20 ce a5	jsr $a5ce			jsr 	STKSaveCodePosition 		; save loop back position
.8554	68		pla				pla 								; restore DOWNTO or TO
.8555	5a		phy				phy 								; save Y on the stack
.8556	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8558	f0 02		beq $855c			beq 	_FCNotDownTo
.855a	a9 02		lda #$02			lda 	#2
.855c					_FCNotDownTo:
.855c	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.855d	a0 10		ldy #$10			ldy 	#16
.855f	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8561	a0 06		ldy #$06			ldy 	#6
.8563	a5 58		lda $58				lda 	NSMantissa0
.8565	91 34		sta ($34),y			sta 	(basicStack),y
.8567	a5 60		lda $60				lda 	NSMantissa1
.8569	c8		iny				iny
.856a	91 34		sta ($34),y			sta 	(basicStack),y
.856c	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.856e	a2 01		ldx #$01			ldx 	#1
.8570	20 85 85	jsr $8585			jsr 	FCIntegerToStack
.8573	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8575	a2 02		ldx #$02			ldx 	#2
.8577	20 85 85	jsr $8585			jsr 	FCIntegerToStack
.857a	20 a0 85	jsr $85a0			jsr 	CopyIndexToReference
.857d	7a		ply				ply 								; restore position
.857e	60		rts				rts
.857f					_FCError:
.857f	4c cf 9e	jmp $9ecf			jmp 	TypeError
.8582					_FCSyntaxError:
.8582	4c c5 9e	jmp $9ec5			jmp 	SyntaxError
.8585					FCIntegerToStack:
.8585	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8587	10 03		bpl $858c			bpl	 	_FCNotNegative
.8589	20 16 9d	jsr $9d16			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.858c					_FCNotNegative:
.858c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.858e	91 34		sta ($34),y			sta 	(basicStack),y
.8590	c8		iny				iny
.8591	b5 60		lda $60,x			lda 	NSMantissa1,x
.8593	91 34		sta ($34),y			sta 	(basicStack),y
.8595	c8		iny				iny
.8596	b5 68		lda $68,x			lda 	NSMantissa2,x
.8598	91 34		sta ($34),y			sta 	(basicStack),y
.859a	c8		iny				iny
.859b	b5 70		lda $70,x			lda 	NSMantissa3,x
.859d	91 34		sta ($34),y			sta 	(basicStack),y
.859f	60		rts				rts
.85a0					CopyIndexToReference:
.85a0	5a		phy				phy
.85a1	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85a3	38		sec				sec 								; (because we copy from offset 8)
.85a4	b1 34		lda ($34),y			lda 	(basicStack),y
.85a6	e9 08		sbc #$08			sbc 	#8
.85a8	85 36		sta $36				sta 	zTemp0
.85aa	c8		iny				iny
.85ab	b1 34		lda ($34),y			lda 	(basicStack),y
.85ad	e9 00		sbc #$00			sbc 	#0
.85af	85 37		sta $37				sta 	zTemp0+1
.85b1	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85b3	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85b5	b1 34		lda ($34),y			lda 	(basicStack),y
.85b7	0a		asl a				asl 	a 							; into carry
.85b8	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85ba	90 14		bcc $85d0			bcc 	_CITRNormal
.85bc	38		sec				sec
.85bd					_CITRNegative:
.85bd	a9 00		lda #$00			lda 	#0
.85bf	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85c1	91 36		sta ($36),y			sta 	(zTemp0),y
.85c3	c8		iny				iny
.85c4	ca		dex				dex
.85c5	d0 f6		bne $85bd			bne 	_CITRNegative
.85c7	88		dey				dey 								; look at MSB of mantissa
.85c8	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85ca	09 80		ora #$80			ora 	#$80
.85cc	91 36		sta ($36),y			sta 	(zTemp0),y
.85ce	7a		ply				ply
.85cf	60		rts				rts
.85d0					_CITRNormal:
.85d0	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85d2	91 36		sta ($36),y			sta 	(zTemp0),y
.85d4	c8		iny				iny
.85d5	ca		dex				dex
.85d6	d0 f8		bne $85d0			bne 	_CITRNormal
.85d8	7a		ply				ply 								; and exit.
.85d9	60		rts				rts
.85da					NextCommand:
.85da	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85dc	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85de	20 b6 a5	jsr $a5b6			jsr 	StackCheckFrame
.85e1	5a		phy				phy
.85e2	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85e4	b1 34		lda ($34),y			lda 	(basicStack),y
.85e6	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85e8	30 02		bmi $85ec			bmi 	_NCStepNeg
.85ea	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85ec					_NCStepNeg:
.85ec	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85ee	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85f0	18		clc				clc
.85f1					_NCBump:
.85f1	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85f3	91 34		sta ($34),y			sta 	(basicStack),y
.85f5	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85f7	c8		iny				iny 								; next byte
.85f8	ca		dex				dex 								; do four times
.85f9	d0 f6		bne $85f1			bne 	_NCBump
.85fb	20 a0 85	jsr $85a0			jsr		CopyIndexToReference		; copy it to the reference variable.
.85fe	a0 10		ldy #$10			ldy 	#16 						; get step count again
.8600	b1 34		lda ($34),y			lda 	(basicStack),y
.8602	0a		asl a				asl 	a 							; sign bit to carry
.8603	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8605	85 38		sta $38				sta 	zTemp1
.8607	90 02		bcc $860b			bcc 	_NCCompRev 					; use if step is +ve
.8609	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.860b					_NCCompRev:
.860b	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.860d	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.860f	85 39		sta $39				sta 	zTemp1+1
.8611	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8613	38		sec				sec
.8614					_NCCompare:
.8614	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8616	b1 34		lda ($34),y			lda 	(basicStack),y
.8618	a4 39		ldy $39				ldy 	zTemp1+1
.861a	f1 34		sbc ($34),y			sbc 	(basicStack),y
.861c	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.861e	e6 39		inc $39				inc 	zTemp1+1
.8620	ca		dex				dex 								; do it 4 times.
.8621	d0 f1		bne $8614			bne 	_NCCompare
.8623	50 02		bvc $8627			bvc 	_NCNoOverflow 				; convert to signed comparison
.8625	49 80		eor #$80			eor 	#$80
.8627					_NCNoOverflow:
.8627	7a		ply				ply 								; restore Y position
.8628	0a		asl a				asl 	a 							; is bit 7 set.
.8629	90 04		bcc $862f			bcc 	_NCLoopback 				; if no , >= so loop back
.862b	20 a8 a5	jsr $a5a8			jsr 	StackClose 					; exit the loop
.862e	60		rts				rts
.862f					_NCLoopBack:
.862f	20 df a5	jsr $a5df			jsr 	STKLoadCodePosition 		; loop back
.8632	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8633					Command_GOSUB:
.8633	a2 00		ldx #$00			ldx 	#0
.8635	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8638	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.863a	20 8a a5	jsr $a58a			jsr 	StackOpen 					; create frame
.863d	20 ce a5	jsr $a5ce			jsr 	STKSaveCodePosition 		; save current position
.8640	4c 56 86	jmp $8656			jmp 	GotoStackX
.8643					Command_RETURN:
.8643	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8645	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8647	20 b6 a5	jsr $a5b6			jsr 	StackCheckFrame
.864a	20 df a5	jsr $a5df			jsr 	STKLoadCodePosition 		; restore code position
.864d	20 a8 a5	jsr $a5a8			jsr 	StackClose
.8650	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8651					GotoCommand:
.8651	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8653	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger
.8656					GotoStackX:
.8656	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8658	48		pha				pha 								; it is slightly inefficient, just in cases.
.8659	b5 58		lda $58,x			lda 	NSMantissa0,x
.865b	fa		plx				plx
.865c	20 b3 a4	jsr $a4b3			jsr 	MemorySearch 				; transfer to line number AX.
.865f	90 05		bcc $8666			bcc 	_GotoError 					; not found, off end.
.8661	d0 03		bne $8666			bne 	_GotoError 					; not found exactly
.8663	4c 75 8a	jmp $8a75			jmp 	RunNewLine 					; and go straight to new line code.
.8666					_GotoError:
.8666	a9 0d		lda #$0d		lda	#13
.8668	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.866b					IfCommand:
.866b	a2 00		ldx #$00			ldx 	#0 							; If what.
.866d	20 9b 9c	jsr $9c9b			jsr 	EvaluateNumber
.8670	b1 30		lda ($30),y			lda 	(codePtr),y
.8672	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8674	d0 0a		bne $8680			bne 	_IFStructured
.8676	c8		iny				iny 								; consume THEN
.8677	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; is it zero
.867a	f0 01		beq $867d			beq 	_IfFail 					; if fail, go to next line
.867c	60		rts				rts 								; if THEN just continue
.867d					_IfFail:
.867d	4c 5d 8a	jmp $8a5d			jmp 	EOLCommand
.8680					_IfStructured:
.8680	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; is it zero
.8683	d0 07		bne $868c			bne 	_IfExit 					; if not, then continue normally.
.8685	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8687	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8689	20 1f 8d	jsr $8d1f			jsr 	ScanForward 				; and run from there/
.868c					_IfExit:
.868c	60		rts				rts
.868d					ElseCode:
.868d	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.868f	aa		tax				tax 								; so just go to the structure exit
.8690	20 1f 8d	jsr $8d1f			jsr 	ScanForward
.8693	60		rts				rts
.8694					EndIf:
.8694	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8695					Command_Input:
.8695	a9 ff		lda #$ff			lda 	#$FF
.8697	8d 28 04	sta $0428			sta 	IsInputFlag
.869a	80 03		bra $869f			bra 	Command_IP_Main
.869c					Command_Print:
.869c	9c 28 04	stz $0428			stz 	IsInputFlag
.869f					Command_IP_Main:
.869f	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86a0					_CPLoop:
.86a0	08		php				php 								; save last action flag
.86a1	b1 30		lda ($30),y			lda 	(codePtr),y
.86a3	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86a5	f0 54		beq $86fb			beq 	_CPExit
.86a7	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86a9	f0 50		beq $86fb			beq 	_CPExit
.86ab	68		pla				pla 								; throw last action flag
.86ac	b1 30		lda ($30),y			lda 	(codePtr),y
.86ae	c8		iny				iny
.86af	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86b1	f0 45		beq $86f8			beq 	_CPContinueWithSameLine
.86b3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86b5	f0 3c		beq $86f3			beq 	_CPTab
.86b7	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86b9	f0 34		beq $86ef			beq 	_CPNewLine
.86bb	88		dey				dey 								; undo the get.
.86bc	20 42 93	jsr $9342			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86bf	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.86c1	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86c3	f0 0d		beq $86d2			beq 	_CPIsValue
.86c5	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.86c8	f0 05		beq $86cf			beq 	_CPIsPrint
.86ca	20 04 87	jsr $8704			jsr 	CIInputValue 				; input a value to the reference
.86cd	80 20		bra $86ef			bra 	_CPNewLine
.86cf					_CPIsPrint:
.86cf	20 07 96	jsr $9607			jsr 	Dereference
.86d2					_CPIsValue:
.86d2	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.86d4	29 10		and #$10			and 	#NSBIsString
.86d6	f0 09		beq $86e1			beq 	_CPNumber
.86d8	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.86da	a5 58		lda $58				lda 	NSMantissa0
.86dc	20 67 87	jsr $8767			jsr 	CPPrintStringXA
.86df	80 be		bra $869f			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86e1					_CPNumber:
.86e1	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86e3	20 82 9b	jsr $9b82			jsr 	ConvertNumberToString 		; convert to string
.86e6	a2 05		ldx #$05			ldx 	#DecimalBuffer >> 8
.86e8	a9 9d		lda #$9d			lda 	#DecimalBuffer & $FF
.86ea	20 67 87	jsr $8767			jsr 	CPPrintStringXA
.86ed	80 b0		bra $869f			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86ef					_CPNewLine:
.86ef	a9 0d		lda #$0d			lda 	#13
.86f1	80 02		bra $86f5			bra 	_CPPrintChar
.86f3					_CPTab:
.86f3	a9 09		lda #$09			lda 	#9 							; print TAB
.86f5					_CPPrintChar:
.86f5	20 7a 87	jsr $877a			jsr 	CPPrintVector
.86f8					_CPContinueWithSameLine:
.86f8	38		sec				sec 								; loop round with carry set, which
.86f9	80 a5		bra $86a0			bra 	_CPLoop 					; will inhibit final CR
.86fb					_CPExit:
.86fb	28		plp				plp 								; get last action flag
.86fc	b0 05		bcs $8703			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.86fe	a9 0d		lda #$0d			lda 	#13 						; print new line
.8700	20 7a 87	jsr $877a			jsr 	CPPrintVector
.8703					_CPExit2:
.8703	60		rts				rts
.8704					CIInputValue:
.8704	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8706					_CIInputLine:
.8706	20 7d 87	jsr $877d			jsr 	CPInputVector 				; get key
.8709	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.870b	f0 1f		beq $872c			beq 	_CIHaveValue
.870d	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.870f	f0 11		beq $8722			beq 	_CIBackspace
.8711	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8713	90 f1		bcc $8706			bcc 	_CIInputLine
.8715	e0 50		cpx #$50			cpx 	#80 						; max length
.8717	b0 ed		bcs $8706			bcs 	_CIInputLine
.8719	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.871c	e8		inx				inx
.871d	20 7a 87	jsr $877a			jsr 	CPPrintVector 				; echo it.
.8720	80 e4		bra $8706			bra 	_CIInputLine
.8722					_CIBackSpace:
.8722	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8724	f0 e0		beq $8706			beq 	_CIInputLine
.8726	20 7a 87	jsr $877a			jsr 	CPPrintVector 				; echo it.
.8729	ca		dex				dex
.872a	80 da		bra $8706			bra 	_CIInputLine
.872c					_CIHaveValue:
.872c	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.872f	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8731	29 10		and #$10			and 	#NSBIsString
.8733	f0 17		beq $874c			beq 	_CIAssignNumber 			; assign a number
.8735	a2 01		ldx #$01			ldx 	#1
.8737	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8739	95 58		sta $58,x			sta 	NSMantissa0,x
.873b	a9 05		lda #$05			lda 	#lineBuffer >> 8
.873d	95 60		sta $60,x			sta 	NSMantissa1,x
.873f	74 68		stz $68,x			stz 	NSMantissa2,x
.8741	74 70		stz $70,x			stz 	NSMantissa3,x
.8743	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8745	95 50		sta $50,x			sta  	NSStatus,x
.8747	ca		dex				dex 								; X = 0
.8748	20 b9 87	jsr $87b9			jsr 	AssignVariable
.874b	60		rts				rts
.874c					_CIAssignNumber:
.874c	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.874e	85 36		sta $36				sta 	zTemp0
.8750	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8752	85 37		sta $37				sta 	zTemp0+1
.8754	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8756	20 04 9b	jsr $9b04			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8759	90 07		bcc $8762			bcc 	_CIIsOkay
.875b	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.875d	20 7a 87	jsr $877a			jsr 	CPPrintVector
.8760	80 a2		bra $8704			bra 	CIInputValue
.8762					_CIIsOkay:
.8762	ca		dex				dex 								; X = 0
.8763	20 b9 87	jsr $87b9			jsr 	AssignVariable
.8766	60		rts				rts
.8767					CPPrintStringXA:
.8767	5a		phy				phy
.8768	86 37		stx $37				stx 	zTemp0+1
.876a	85 36		sta $36				sta 	zTemp0
.876c	a0 00		ldy #$00			ldy 	#0
.876e					_PSXALoop:
.876e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8770	f0 06		beq $8778			beq 	_PSXAExit
.8772	20 7a 87	jsr $877a			jsr 	CPPrintVector
.8775	c8		iny				iny
.8776	80 f6		bra $876e			bra 	_PSXALoop
.8778					_PSXAExit:
.8778	7a		ply				ply
.8779	60		rts				rts
.877a					CPPrintVector:
.877a	4c c1 a6	jmp $a6c1			jmp 	EXTPrintCharacter
.877d					CPInputVector:
.877d	4c 57 a9	jmp $a957			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8780					LetCommand:
.8780	a2 00		ldx #$00			ldx 	#0
.8782	b1 30		lda ($30),y			lda 	(codePtr),y
.8784	c9 10		cmp #$10			cmp 	#KWD_AT
.8786	d0 14		bne $879c			bne 	_LCStandard
.8788	c8		iny				iny 								; skip equal
.8789	20 8e 97	jsr $978e			jsr 	EvaluateTerm 				; get a number
.878c	20 07 96	jsr $9607			jsr 	Dereference 				; dereference it
.878f	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.8791	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8793	95 50		sta $50,x			sta 	NSStatus,x
.8795	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8797	d0 0f		bne $87a8			bne 	_LCMain
.8799	4c cf 9e	jmp $9ecf			jmp 	TypeError 					; was a reference before.
.879c					_LCStandard:
.879c	ad 2c 93	lda $932c			lda 	PrecedenceLevel+"*"			; precedence > this
.879f	20 46 93	jsr $9346			jsr 	EvaluateExpressionAtPrecedence
.87a2	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array
.87a4	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87a6	f0 0e		beq $87b6			beq 	_LetGoProc 					; it's a procedure call.
.87a8					_LCMain:
.87a8	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87aa	20 37 8e	jsr $8e37			jsr 	CheckNextA
.87ad	e8		inx				inx 								; RHS
.87ae	20 92 9c	jsr $9c92			jsr 	EvaluateValue
.87b1	ca		dex				dex
.87b2	20 b9 87	jsr $87b9			jsr 	AssignVariable
.87b5	60		rts				rts
.87b6					_LetGoProc:
.87b6	4c 38 89	jmp $8938			jmp 	CallProcedure
.87b9					AssignVariable:
.87b9	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.87bb	48		pha				pha 								; save a copy
.87bc	55 51		eor $51,x			eor 	NSStatus+1,x
.87be	29 10		and #$10			and 	#NSBIsString
.87c0	d0 0b		bne $87cd			bne 	_ASError
.87c2	68		pla				pla 								; get back
.87c3	29 10		and #$10			and 	#NSBIsString 				; check type
.87c5	d0 03		bne $87ca			bne 	_ASString
.87c7	4c 45 95	jmp $9545			jmp 	AssignNumber
.87ca					_ASString:
.87ca	4c a3 95	jmp $95a3			jmp 	AssignString
.87cd					_ASError:
.87cd	4c cf 9e	jmp $9ecf			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87d0					Command_List:
.87d0	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.87d3	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87d5	64 64		stz $64				stz 	NSMantissa1+4
.87d7	a9 ff		lda #$ff			lda 	#$FF
.87d9	85 5f		sta $5f				sta 	NSMantissa0+7
.87db	85 67		sta $67				sta 	NSMantissa1+7
.87dd	b1 30		lda ($30),y			lda 	(codePtr),y
.87df	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87e1	f0 1a		beq $87fd			beq 	_CLSecond
.87e3	20 5c 88	jsr $885c			jsr 	CLIsDigit 					; if not digit, list all
.87e6	b0 20		bcs $8808			bcs 	_CLStart
.87e8	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.87ea	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger
.87ed	b1 30		lda ($30),y			lda 	(codePtr),y
.87ef	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87f1	f0 0a		beq $87fd			beq 	_CLSecond 					; if so go get it
.87f3	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.87f5	85 5f		sta $5f				sta 	NSMantissa0+7
.87f7	a5 64		lda $64				lda 	NSMantissa1+4
.87f9	85 67		sta $67				sta 	NSMantissa1+7
.87fb	80 0b		bra $8808			bra 	_CLStart
.87fd					_CLSecond:
.87fd	c8		iny				iny 								; consume comma
.87fe	20 5c 88	jsr $885c			jsr 	CLIsDigit 					; digit found
.8801	b0 05		bcs $8808			bcs 	_CLStart 					; if not, continue listing
.8803	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8805	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger
.8808					_CLStart
.8808	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.880a	85 30		sta $30				sta 	codePtr
.880c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.880e	85 31		sta $31				sta 	codePtr+1
.8810					_CLLoop:
.8810	20 77 a9	jsr $a977			jsr 	EXTBreakCheck 				; break check
.8813	f0 33		beq $8848			beq 	_CLExit
.8815	b2 30		lda ($30)			lda 	(codePtr)
.8817	f0 2f		beq $8848			beq 	_CLExit
.8819	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.881b	20 4b 88	jsr $884b			jsr 	CLCompareLineNo
.881e	90 1b		bcc $883b			bcc 	_CLNext
.8820	a2 07		ldx #$07			ldx 	#7
.8822	20 4b 88	jsr $884b			jsr 	CLCompareLineNo
.8825	f0 02		beq $8829			beq 	_CLDoThisOne
.8827	b0 12		bcs $883b			bcs 	_CLNext
.8829					_CLDoThisOne:
.8829	20 82 8d	jsr $8d82			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.882c	20 c1 b2	jsr $b2c1			jsr 	ListConvertLine 			; convert line into token Buffer
.882f	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8831	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8833	20 99 8e	jsr $8e99			jsr 	PrintStringXA
.8836	a9 0d		lda #$0d			lda 	#13 						; new line
.8838	20 c1 a6	jsr $a6c1			jsr 	EXTPrintCharacter
.883b					_CLNext:
.883b	18		clc				clc
.883c	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.883e	65 30		adc $30				adc 	codePtr
.8840	85 30		sta $30				sta 	codePtr
.8842	90 02		bcc $8846			bcc 	_CREExit
.8844	e6 31		inc $31				inc 	codePtr+1 					; carry
.8846					_CREExit:
.8846	80 c8		bra $8810			bra 	_CLLoop
.8848					_CLExit:
.8848	4c 6a 83	jmp $836a			jmp 	WarmStart
.884b					CLCompareLineNo:
.884b	38		sec				sec
.884c	a0 01		ldy #$01			ldy 	#1
.884e	b1 30		lda ($30),y			lda 	(codePtr),y
.8850	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8852	85 36		sta $36				sta 	zTemp0
.8854	c8		iny				iny
.8855	b1 30		lda ($30),y			lda 	(codePtr),y
.8857	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.8859	05 36		ora $36				ora 	zTemp0
.885b	60		rts				rts
.885c					CLIsDigit:
.885c	b1 30		lda ($30),y			lda 	(codePtr),y
.885e	c9 30		cmp #$30			cmp 	#"0"
.8860	90 03		bcc $8865			bcc	 	_CLIDExitFalse
.8862	c9 3a		cmp #$3a			cmp 	#"9"+1
.8864	60		rts				rts
.8865					_CLIDExitFalse:
.8865	38		sec				sec
.8866	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8867					Command_LOCAL:
.8867	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8869	20 75 88	jsr $8875			jsr 	LocaliseNextTerm 			; convert term to a local.
.886c	b1 30		lda ($30),y			lda 	(codePtr),y
.886e	c8		iny				iny
.886f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8871	f0 f4		beq $8867			beq 	Command_LOCAL
.8873	88		dey				dey 								; unpick pre-get
.8874	60		rts				rts
.8875					LocaliseNextTerm:
.8875	20 8e 97	jsr $978e			jsr 	EvaluateTerm 				; evaluate the term
.8878	b5 50		lda $50,x			lda 	NSStatus,x
.887a	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.887c	f0 5c		beq $88da			beq		_LNTError
.887e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8880	85 36		sta $36				sta 	zTemp0
.8882	b5 60		lda $60,x			lda 	NSMantissa1,x
.8884	85 37		sta $37				sta  	zTemp0+1
.8886	b5 50		lda $50,x			lda 	NSStatus,x
.8888	29 10		and #$10			and 	#NSBIsString
.888a	d0 1e		bne $88aa			bne 	_LNTPushString
.888c	5a		phy				phy
.888d	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.888f					_LNTPushNumLoop:
.888f	b1 36		lda ($36),y			lda		(zTemp0),y
.8891	20 68 a5	jsr $a568			jsr 	StackPushByte
.8894	c8		iny				iny
.8895	c0 05		cpy #$05			cpy 	#5
.8897	d0 f6		bne $888f			bne 	_LNTPushNumLoop
.8899	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.889b	20 68 a5	jsr $a568			jsr 	StackPushByte
.889e	a5 37		lda $37				lda 	zTemp0+1
.88a0	20 68 a5	jsr $a568			jsr 	StackPushByte
.88a3	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88a5	20 68 a5	jsr $a568			jsr 	StackPushByte
.88a8	7a		ply				ply
.88a9	60		rts				rts
.88aa					_LNTPushString:
.88aa	5a		phy				phy
.88ab	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88ad	85 38		sta $38				sta 	zTemp1
.88af	a0 01		ldy #$01			ldy 	#1
.88b1	b1 36		lda ($36),y			lda 	(zTemp0),y
.88b3	85 39		sta $39				sta 	zTemp1+1
.88b5	a0 00		ldy #$00			ldy 	#0 							; output string
.88b7	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88b9	f0 0a		beq $88c5			beq 	_LNTStringOut
.88bb					_LNTPushStrLoop:
.88bb	b1 38		lda ($38),y			lda 	(zTemp1),y
.88bd	f0 06		beq $88c5			beq 	_LNTStringOut
.88bf	20 68 a5	jsr $a568			jsr 	StackPushByte
.88c2	c8		iny				iny
.88c3	80 f6		bra $88bb			bra 	_LNTPushStrLoop
.88c5					_LNTStringOut:
.88c5	98		tya				tya									; output length
.88c6	20 68 a5	jsr $a568			jsr 	StackPushByte
.88c9	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.88cb	20 68 a5	jsr $a568			jsr 	StackPushByte
.88ce	b5 60		lda $60,x			lda 	NSMantissa1,x
.88d0	20 68 a5	jsr $a568			jsr 	StackPushByte
.88d3	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.88d5	20 68 a5	jsr $a568			jsr 	StackPushByte
.88d8	7a		ply				ply
.88d9	60		rts				rts
.88da					_LNTError:
.88da	4c c5 9e	jmp $9ec5			jmp 	SyntaxError
.88dd					LocalPopValue:
.88dd	20 81 a5	jsr $a581			jsr 	StackPopByte
.88e0	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.88e2	d0 17		bne $88fb			bne 	_LPVString
.88e4	20 81 a5	jsr $a581			jsr 	StackPopByte 				; address
.88e7	85 37		sta $37				sta 	zTemp0+1
.88e9	20 81 a5	jsr $a581			jsr 	StackPopByte
.88ec	85 36		sta $36				sta 	zTemp0
.88ee	5a		phy				phy
.88ef	a0 04		ldy #$04			ldy 	#4 							; copy back
.88f1					_LPVNumberCopy:
.88f1	20 81 a5	jsr $a581			jsr 	StackPopByte
.88f4	91 36		sta ($36),y			sta 	(zTemp0),y
.88f6	88		dey				dey
.88f7	10 f8		bpl $88f1			bpl 	_LPVNumberCopy
.88f9	7a		ply				ply 								; and complete
.88fa	60		rts				rts
.88fb					_LPVString:
.88fb	20 81 a5	jsr $a581			jsr 	StackPopByte 				; address of record => zTemp0
.88fe	85 37		sta $37				sta 	zTemp0+1
.8900	20 81 a5	jsr $a581			jsr 	StackPopByte
.8903	85 36		sta $36				sta 	zTemp0
.8905	5a		phy				phy
.8906	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8908	85 38		sta $38				sta 	zTemp1
.890a	a0 01		ldy #$01			ldy 	#1
.890c	b1 36		lda ($36),y			lda 	(zTemp0),y
.890e	85 39		sta $39				sta 	zTemp1+1
.8910	20 81 a5	jsr $a581			jsr 	StackPopByte 				; # to get => y
.8913	a8		tay				tay
.8914	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8916	f0 0e		beq $8926			beq 	_LPVStringCopied
.8918	a9 00		lda #$00			lda 	#0 							; NULL on end
.891a	91 38		sta ($38),y			sta 	(zTemp1),y
.891c					_LPVStringCopy:
.891c	88		dey				dey
.891d	30 07		bmi $8926			bmi 	_LPVStringCopied
.891f	20 81 a5	jsr $a581			jsr 	StackPopByte
.8922	91 38		sta ($38),y			sta 	(zTemp1),y
.8924	80 f6		bra $891c			bra 	_LPVStringCopy
.8926					_LPVStringCopied:
.8926	fa		plx				plx
.8927	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8928					NewCommand:
.8928	20 2e 89	jsr $892e			jsr 	NewProgram 					; does the actual NEW.
.892b	4c 6a 83	jmp $836a			jmp 	WarmStart 					; and warm starts straight away.
.892e					NewProgram:
.892e	20 95 a4	jsr $a495			jsr 	MemoryNew
.8931	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8934	20 00 84	jsr $8400			jsr 	ClearCommand 				; clear everything.
.8937	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8938					CallProcedure:
.8938	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.893a	b1 30		lda ($30),y			lda 	(codePtr),y
.893c	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.893e	f0 0c		beq $894c			beq 	_CPEndParam
.8940					_CPParamLoop:
.8940	20 92 9c	jsr $9c92			jsr 	EvaluateValue 				; get parameter onto stack
.8943	e8		inx				inx 								; bump next stack
.8944	b1 30		lda ($30),y			lda 	(codePtr),y
.8946	c8		iny				iny
.8947	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8949	f0 f5		beq $8940			beq 	_CPParamLoop
.894b	88		dey				dey 								; unpick.
.894c					_CPEndParam:
.894c	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.894f	c8		iny				iny									; skip right bracket
.8950	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8952	20 8a a5	jsr $a58a			jsr 	StackOpen
.8955	20 ce a5	jsr $a5ce			jsr 	STKSaveCodePosition 		; save loop position
.8958	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.895a	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.895c	a5 60		lda $60				lda 	NSMantissa1
.895e	85 37		sta $37				sta 	zTemp0+1
.8960	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8962	b2 36		lda ($36)			lda 	(zTemp0)
.8964	85 30		sta $30				sta 	safePtr
.8966	b1 36		lda ($36),y			lda 	(zTemp0),y
.8968	85 31		sta $31				sta 	safePtr+1
.896a	c8		iny				iny
.896b	b1 36		lda ($36),y			lda 	(zTemp0),y
.896d	85 32		sta $32				sta 	safePtr+2
.896f	c8		iny				iny
.8970	b1 36		lda ($36),y			lda 	(zTemp0),y
.8972	85 33		sta $33				sta 	safePtr+3
.8974	c8		iny				iny 								; get Y offset -> Y
.8975	b1 36		lda ($36),y			lda 	(zTemp0),y
.8977	a8		tay				tay
.8978	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.897a	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check no parameters at the start
.897d	f0 13		beq $8992			beq 	_ParamExit 					; if so, exit.
.897f					_ParamExtract:
.897f	ca		dex				dex 								; put a local term on the level before
.8980	20 75 88	jsr $8875			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8983	20 b9 87	jsr $87b9			jsr 	AssignVariable 				; assign stacked value to the variable.
.8986	e8		inx				inx 								; advance to next parameter to do.
.8987	e8		inx				inx
.8988	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.898b	f0 05		beq $8992			beq 	_ParamExit
.898d	20 2f 8e	jsr $8e2f			jsr 	CheckComma 					; comma seperating parameters
.8990	80 ed		bra $897f			bra 	_ParamExtract
.8992					_ParamExit:
.8992	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; check )
.8995	60		rts				rts 								; and continue from here
.8996					Command_ENDPROC:
.8996	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8998	a2 14		ldx #$14			ldx 	#ERRID_PROC
.899a	20 b6 a5	jsr $a5b6			jsr 	StackCheckFrame
.899d	20 df a5	jsr $a5df			jsr 	STKLoadCodePosition 		; restore code position
.89a0	20 a8 a5	jsr $a5a8			jsr 	StackClose
.89a3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89a4					Command_Read:
.89a4	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89a6	20 8e 97	jsr $978e			jsr 	EvaluateTerm
.89a9	b5 50		lda $50,x			lda 	NSStatus,x
.89ab	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89ad	f0 4a		beq $89f9			beq 	_CRSyntax 					; check reference (bit 0)
.89af	20 42 8a	jsr $8a42			jsr 	SwapDataCodePtrs 			; swap code and data
.89b2	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89b5	d0 20		bne $89d7			bne 	_CRContinueData
.89b7					_CRKeepSearching:
.89b7	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89b9	aa		tax				tax
.89ba	20 1f 8d	jsr $8d1f			jsr 	ScanForward
.89bd	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.89bf	f0 16		beq $89d7			beq 	_CRHaveData 				; found it
.89c1	18		clc				clc
.89c2	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.89c4	65 30		adc $30				adc 	codePtr
.89c6	85 30		sta $30				sta 	codePtr
.89c8	90 02		bcc $89cc			bcc 	_CREExit
.89ca	e6 31		inc $31				inc 	codePtr+1 					; carry
.89cc					_CREExit:
.89cc	a0 03		ldy #$03			ldy 	#3 							; start of line.
.89ce	b2 30		lda ($30)			lda 	(codePtr)
.89d0	d0 e5		bne $89b7			bne 	_CRKeepSearching
.89d2	a9 0b		lda #$0b		lda	#11
.89d4	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.89d7					_CRHaveData:
.89d7					_CRContinueData:
.89d7	a2 01		ldx #$01			ldx 	#1
.89d9	20 92 9c	jsr $9c92			jsr 	EvaluateValue 				; evaluate value into slot # 1
.89dc	ca		dex				dex
.89dd	20 b9 87	jsr $87b9			jsr		AssignVariable 				; do the assignment
.89e0	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data
.89e3	b1 30		lda ($30),y			lda 	(codePtr),y
.89e5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.89e7	d0 04		bne $89ed			bne 	_CRSwapBack
.89e9	c8		iny				iny 								; consume comma
.89ea	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.89ed					_CRSwapBack:
.89ed	20 42 8a	jsr $8a42			jsr 	SwapDataCodePtrs			; swap them back.
.89f0	b1 30		lda ($30),y			lda 	(codePtr),y
.89f2	c8		iny				iny
.89f3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.89f5	f0 ad		beq $89a4			beq 	Command_Read 				; if so go round again.
.89f7	88		dey				dey 								; unpick get.
.89f8	60		rts				rts
.89f9					_CRSyntax:
.89f9	4c c5 9e	jmp $9ec5			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.89fc					RemCommand:
.89fc	b1 30		lda ($30),y			lda 	(codePtr),y
.89fe	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a00	d0 06		bne $8a08			bne 	_RMExit
.8a02	c8		iny				iny 								; point to offset
.8a03	98		tya				tya 								; A = offset position
.8a04	38		sec				sec 								; add size +1 hence SEC
.8a05	71 30		adc ($30),y			adc 	(codePtr),y
.8a07	a8		tay				tay 								; make current position.
.8a08					_RMExit:
.8a08	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a09					Command_REPEAT:
.8a09	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a0b	20 8a a5	jsr $a58a			jsr 	StackOpen
.8a0e	20 ce a5	jsr $a5ce			jsr 	STKSaveCodePosition 		; save loop position
.8a11	60		rts				rts
.8a12					Command_UNTIL:
.8a12	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a14	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a16	20 b6 a5	jsr $a5b6			jsr 	StackCheckFrame
.8a19	a2 00		ldx #$00			ldx 	#0
.8a1b	20 9b 9c	jsr $9c9b			jsr 	EvaluateNumber 				; work out the number
.8a1e	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; check if zero
.8a21	f0 04		beq $8a27			beq 	_CULoopBack 				; if so keep looping
.8a23	20 a8 a5	jsr $a5a8			jsr 	StackClose		 			; return
.8a26	60		rts				rts
.8a27					_CULoopBack:
.8a27	20 df a5	jsr $a5df			jsr 	STKLoadCodePosition 		; loop back
.8a2a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a2b					Command_Restore:
.8a2b	20 42 8a	jsr $8a42			jsr 	SwapDataCodePtrs 			; swap code and data
.8a2e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a30	85 30		sta $30				sta 	codePtr
.8a32	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a34	85 31		sta $31				sta 	codePtr+1
.8a36	20 42 8a	jsr $8a42			jsr 	SwapDataCodePtrs 			; put them back
.8a39	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a3b	8d 1b 04	sta $041b			sta 	dataPointer+4
.8a3e	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8a41	60		rts				rts
.8a42					SwapDataCodePtrs:
.8a42	da		phx				phx
.8a43	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a45					_SDCPLoop:
.8a45	b5 30		lda $30,x			lda 	safePtr,x
.8a47	48		pha				pha
.8a48	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8a4b	95 30		sta $30,x			sta 	safePtr,x
.8a4d	68		pla				pla
.8a4e	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8a51	ca		dex				dex
.8a52	10 f1		bpl $8a45			bpl 	_SDCPLoop
.8a54	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8a57	8c 1b 04	sty $041b			sty 	dataPointer+4
.8a5a	a8		tay				tay
.8a5b	fa		plx				plx
.8a5c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a5d					EOLCommand:
.8a5d	18		clc				clc
.8a5e	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a60	65 30		adc $30				adc 	codePtr
.8a62	85 30		sta $30				sta 	codePtr
.8a64	90 02		bcc $8a68			bcc 	_CREExit
.8a66	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a68					_CREExit:
.8a68	80 0b		bra $8a75			bra 	RunNewLine
.8a6a					CommandRUN:
.8a6a	20 00 84	jsr $8400			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a6d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a6f	85 30		sta $30				sta 	codePtr
.8a71	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a73	85 31		sta $31				sta 	codePtr+1
.8a75					RUNNewLine:
.8a75	b2 30		lda ($30)			lda 	(codePtr)
.8a77	f0 72		beq $8aeb			beq 	CRNoProgram         		; no then END.
.8a79	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a7b	9a		txs				txs
.8a7c					RUNCodePointerLine:
.8a7c	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a7e					_CRIncMainLoop:
.8a7e	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8a81	d0 19		bne $8a9c			bne 	_CRNoBreakCheck
.8a83	20 77 a9	jsr $a977			jsr 	EXTBreakCheck 				; break check
.8a86	f0 5e		beq $8ae6			beq 	_CRBreak
.8a88	64 01		stz $01				stz 	1 							; access I/O Page 0
.8a8a	38		sec				sec 								; calculate timer - LastTick
.8a8b	ad 59 d6	lda $d659			lda 	$D659
.8a8e	aa		tax				tax 								; saving timer in X
.8a8f	ed af 05	sbc $05af			sbc 	LastTick
.8a92	c9 03		cmp #$03			cmp 	#3
.8a94	90 06		bcc $8a9c			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8a96	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.8a99	20 0d b9	jsr $b90d			jsr 	TickHandler 				; go do the code.
.8a9c					_NoFireTick:
.8a9c					_CRNoBreakCheck:
.8a9c	c8		iny				iny
.8a9d					_CRMainLoop:
.8a9d	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8aa0	b1 30		lda ($30),y			lda 	(codePtr),y
.8aa2	10 10		bpl $8ab4			bpl 	_CRNotKeyword
.8aa4	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8aa6	b0 04		bcs $8aac			bcs 	_CRIsKeyword
.8aa8	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8aaa	b0 34		bcs $8ae0			bcs		_CRSyntaxError
.8aac					_CRIsKeyword:
.8aac	c8		iny				iny 								; consume command
.8aad	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8aae	aa		tax				tax 								; put in X for vector jump
.8aaf	20 e3 8a	jsr $8ae3			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8ab2	80 e9		bra $8a9d			bra 	_CRMainLoop 				; and loop round
.8ab4					_CRNotKeyword:
.8ab4	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8ab6	f0 c6		beq $8a7e			beq 	_CRIncMainLoop
.8ab8	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8aba	90 05		bcc $8ac1			bcc 	_CRNotVariable
.8abc					_CRGoLet:
.8abc	20 80 87	jsr $8780			jsr 	LetCommand
.8abf	80 dc		bra $8a9d			bra 	_CRMainLoop
.8ac1					_CRNotVariable:
.8ac1	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8ac3	f0 f7		beq $8abc			beq 	_CRGoLet
.8ac5	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8ac7	f0 f3		beq $8abc			beq 	_CRGoLet
.8ac9	c9 21		cmp #$21			cmp 	#KWD_PLING
.8acb	f0 ef		beq $8abc			beq 	_CRGoLet
.8acd	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8acf	f0 09		beq $8ada			beq 	_CRGoRem
.8ad1	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8ad3	d0 0b		bne $8ae0			bne 	_CRSyntaxError
.8ad5	20 03 82	jsr $8203			jsr 	LabelHere
.8ad8	80 c3		bra $8a9d			bra 	_CRMainLoop
.8ada					_CRGoRem:
.8ada	c8		iny				iny
.8adb	20 fc 89	jsr $89fc			jsr 	RemCommand
.8ade	80 bd		bra $8a9d			bra 	_CRMainLoop
.8ae0					_CRSyntaxError:
.8ae0	4c c5 9e	jmp $9ec5			jmp 	SyntaxError
.8ae3					_CRCallVector0:
.8ae3	7c 82 8b	jmp ($8b82,x)			jmp 	(VectorSet0,x)
.8ae6					_CRBreak:
.8ae6	a9 01		lda #$01		lda	#1
.8ae8	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.8aeb					CRNoProgram:
.8aeb	4c 25 85	jmp $8525			jmp 	EndCommand
.8aee					Shift1Command:
.8aee	b1 30		lda ($30),y			lda 	(codePtr),y
.8af0	c8		iny				iny
.8af1	0a		asl a				asl 	a
.8af2	aa		tax				tax
.8af3	7c 20 8c	jmp ($8c20,x)			jmp 	(VectorSet1,x)
.8af6					Shift2Command:
.8af6	b1 30		lda ($30),y			lda 	(codePtr),y
.8af8	c8		iny				iny
.8af9	0a		asl a				asl 	a
.8afa	aa		tax				tax
.8afb	7c 40 8c	jmp ($8c40,x)			jmp 	(VectorSet2,x)
.8afe					Unused1:
.8afe					Unused2:
.8afe					Unused3:
.8afe					Unused4:
.8afe	4c c5 9e	jmp $9ec5			jmp 	SyntaxError
>8b01							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b02					VectorSetPunc:
>8b02	f8 90					.word	ShiftLeft                        ; $00 <<
>8b04	e3 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8b06	d9 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8b08	c5 9e					.word	SyntaxError                      ; $03 !!3
>8b0a	c5 9e					.word	SyntaxError                      ; $04 ><
>8b0c	ed 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b0e	fb 90					.word	ShiftRight                       ; $06 >>
>8b10	c5 9e					.word	SyntaxError                      ; $07 !!7
>8b12	c5 9e					.word	SyntaxError                      ; $08 !!8
>8b14	c5 9e					.word	SyntaxError                      ; $09 !!9
>8b16	c5 9e					.word	SyntaxError                      ; $0a !!10
>8b18	c5 9e					.word	SyntaxError                      ; $0b !!11
>8b1a	c5 9e					.word	SyntaxError                      ; $0c !!12
>8b1c	c5 9e					.word	SyntaxError                      ; $0d !!13
>8b1e	c5 9e					.word	SyntaxError                      ; $0e !!14
>8b20	c5 9e					.word	SyntaxError                      ; $0f !!15
>8b22	c5 9e					.word	SyntaxError                      ; $10 @
>8b24	c5 9e					.word	SyntaxError                      ; $11 !!17
>8b26	c5 9e					.word	SyntaxError                      ; $12 !!18
>8b28	c5 9e					.word	SyntaxError                      ; $13 [
>8b2a	a4 8f					.word	IntegerDivide                    ; $14 \
>8b2c	c5 9e					.word	SyntaxError                      ; $15 ]
>8b2e	36 92					.word	EorInteger                       ; $16 ^
>8b30	c5 9e					.word	SyntaxError                      ; $17 _
>8b32	c5 9e					.word	SyntaxError                      ; $18 `
>8b34	c5 9e					.word	SyntaxError                      ; $19 !!25
>8b36	c5 9e					.word	SyntaxError                      ; $1a !!26
>8b38	c5 9e					.word	SyntaxError                      ; $1b {
>8b3a	01 92					.word	OraInteger                       ; $1c |
>8b3c	c5 9e					.word	SyntaxError                      ; $1d }
>8b3e	c5 9e					.word	SyntaxError                      ; $1e ~
>8b40	c5 9e					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b42	c5 9e					.word	SyntaxError                      ; $20
>8b44	6b 92					.word	WordIndirect                     ; $21 !
>8b46	c5 9e					.word	SyntaxError                      ; $22 "
>8b48	c5 9e					.word	SyntaxError                      ; $23 #
>8b4a	c5 9e					.word	SyntaxError                      ; $24 $
>8b4c	e5 8f					.word	IntegerModulus                   ; $25 %
>8b4e	cc 91					.word	AndInteger                       ; $26 &
>8b50	c5 9e					.word	SyntaxError                      ; $27 '
>8b52	c5 9e					.word	SyntaxError                      ; $28 (
>8b54	c5 9e					.word	SyntaxError                      ; $29 )
>8b56	53 90					.word	MulInteger                       ; $2a *
>8b58	6e 91					.word	AddInteger                       ; $2b +
>8b5a	c5 9e					.word	SyntaxError                      ; $2c ,
>8b5c	a7 91					.word	SubInteger                       ; $2d -
>8b5e	c5 9e					.word	SyntaxError                      ; $2e .
>8b60	25 94					.word	FDivideCommand                   ; $2f /
>8b62	c5 9e					.word	SyntaxError                      ; $30 0
>8b64	c5 9e					.word	SyntaxError                      ; $31 1
>8b66	c5 9e					.word	SyntaxError                      ; $32 2
>8b68	c5 9e					.word	SyntaxError                      ; $33 3
>8b6a	c5 9e					.word	SyntaxError                      ; $34 4
>8b6c	c5 9e					.word	SyntaxError                      ; $35 5
>8b6e	c5 9e					.word	SyntaxError                      ; $36 6
>8b70	c5 9e					.word	SyntaxError                      ; $37 7
>8b72	c5 9e					.word	SyntaxError                      ; $38 8
>8b74	c5 9e					.word	SyntaxError                      ; $39 9
>8b76	c5 9e					.word	SyntaxError                      ; $3a :
>8b78	c5 9e					.word	SyntaxError                      ; $3b ;
>8b7a	c5 8e					.word	BinaryCompareLess                ; $3c <
>8b7c	bb 8e					.word	BinaryCompareEqual               ; $3d =
>8b7e	cf 8e					.word	BinaryCompareGreater             ; $3e >
>8b80	8d 92					.word	ByteIndirect                     ; $3f ?
.8b82					VectorSet0:
>8b82	5d 8a					.word	EOLCommand                       ; $80 !0:EOF
>8b84	ee 8a					.word	Shift1Command                    ; $81 !1:SH1
>8b86	f6 8a					.word	Shift2Command                    ; $82 !2:SH2
>8b88	0a 99					.word	AbsUnary                         ; $83 ABS(
>8b8a	18 99					.word	AllocUnary                       ; $84 ALLOC(
>8b8c	88 99					.word	AscUnary                         ; $85 ASC(
>8b8e	33 9b					.word	ChrUnary                         ; $86 CHR$(
>8b90	15 a3					.word	UnaryEvent                       ; $87 EVENT(
>8b92	b7 8e					.word	UnaryFalse                       ; $88 FALSE
>8b94	95 99					.word	FracUnary                        ; $89 FRAC(
>8b96	b1 a2					.word	UnaryHit                         ; $8a HIT(
>8b98	aa 99					.word	IntUnary                         ; $8b INT(
>8b9a	f2 9a					.word	IsValUnary                       ; $8c ISVAL(
>8b9c	99 a3					.word	UnaryJoyB                        ; $8d JOYB(
>8b9e	72 a3					.word	UnaryJoyX                        ; $8e JOYX(
>8ba0	75 a3					.word	UnaryJoyY                        ; $8f JOYY(
>8ba2	06 9c					.word	Unary_Left                       ; $90 LEFT$(
>8ba4	bb 99					.word	LenUnary                         ; $91 LEN(
>8ba6	d9 99					.word	Unary_Max                        ; $92 MAX(
>8ba8	28 9c					.word	Unary_Mid                        ; $93 MID$(
>8baa	d5 99					.word	Unary_Min                        ; $94 MIN(
>8bac	24 9a					.word	Unary_Not                        ; $95 NOT(
>8bae	e6 a4					.word	UnaryPlaying                     ; $96 PLAYING(
>8bb0	37 9a					.word	Unary_Random                     ; $97 RANDOM(
>8bb2	13 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8bb4	54 9a					.word	Unary_Rnd                        ; $99 RND(
>8bb6	ca 9a					.word	SgnUnary                         ; $9a SGN(
>8bb8	45 9b					.word	SpcUnary                         ; $9b SPC(
>8bba	60 9b					.word	Unary_Str                        ; $9c STR$(
>8bbc	bf a3					.word	UnaryTimer                       ; $9d TIMER(
>8bbe	ac 8e					.word	UnaryTrue                        ; $9e TRUE
>8bc0	e8 9a					.word	ValUnary                         ; $9f VAL(
>8bc2	28 85					.word	ForCommand                       ; $a0 FOR
>8bc4	6b 86					.word	IfCommand                        ; $a1 IF
>8bc6	fe 8a					.word	Unused1                          ; $a2 PROC
>8bc8	09 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8bca	95 8d					.word	Command_WHILE                    ; $a4 WHILE
>8bcc	94 86					.word	EndIf                            ; $a5 ENDIF
>8bce	96 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8bd0	da 85					.word	NextCommand                      ; $a7 NEXT
>8bd2	fe 8a					.word	Unused4                          ; $a8 THEN
>8bd4	12 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8bd6	b6 8d					.word	Command_WEND                     ; $aa WEND
>8bd8	c5 9e					.word	SyntaxError                      ; $ab BY
>8bda	cb 83					.word	CallCommand                      ; $ac CALL
>8bdc	65 a0					.word	CircleCommand                    ; $ad CIRCLE
>8bde	00 84					.word	ClearCommand                     ; $ae CLEAR
>8be0	58 84					.word	ClearScreen                      ; $af CLS
>8be2	c5 9e					.word	SyntaxError                      ; $b0 COLOR
>8be4	c5 9e					.word	SyntaxError                      ; $b1 COLOUR
>8be6	60 84					.word	Command_Data                     ; $b2 DATA
>8be8	68 84					.word	DimCommand                       ; $b3 DIM
>8bea	fe 8a					.word	Unused3                          ; $b4 DOWNTO
>8bec	8d 86					.word	ElseCode                         ; $b5 ELSE
>8bee	c5 9e					.word	SyntaxError                      ; $b6 FROM
>8bf0	84 a2					.word	GfxCommand                       ; $b7 GFX
>8bf2	33 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8bf4	51 86					.word	GotoCommand                      ; $b9 GOTO
>8bf6	c5 9e					.word	SyntaxError                      ; $ba HERE
>8bf8	8e a0					.word	ImageCommand                     ; $bb IMAGE
>8bfa	95 86					.word	Command_Input                    ; $bc INPUT
>8bfc	80 87					.word	LetCommand                       ; $bd LET
>8bfe	e0 a0					.word	LineCommand                      ; $be LINE
>8c00	67 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c02	c5 9e					.word	SyntaxError                      ; $c0 OFF
>8c04	c5 9e					.word	SyntaxError                      ; $c1 ON
>8c06	c5 9e					.word	SyntaxError                      ; $c2 OUTLINE
>8c08	d5 a2					.word	PaletteCommand                   ; $c3 PALETTE
>8c0a	d9 a0					.word	PlotCommand                      ; $c4 PLOT
>8c0c	9c 86					.word	Command_Print                    ; $c5 PRINT
>8c0e	a4 89					.word	Command_Read                     ; $c6 READ
>8c10	61 a0					.word	RectangleCommand                 ; $c7 RECT
>8c12	fc 89					.word	RemCommand                       ; $c8 REM
>8c14	43 86					.word	Command_RETURN                   ; $c9 RETURN
>8c16	c5 9e					.word	SyntaxError                      ; $ca SOLID
>8c18	02 a5					.word	SoundCommand                     ; $cb SOUND
>8c1a	70 a0					.word	SpriteCommand                    ; $cc SPRITE
>8c1c	aa a0					.word	TextCommand                      ; $cd TEXT
>8c1e	fe 8a					.word	Unused2                          ; $ce TO
.8c20					VectorSet1:
>8c20	c5 9e					.word	SyntaxError                      ; $80 !0:EOF
>8c22	c5 9e					.word	SyntaxError                      ; $81 !1:SH1
>8c24	c5 9e					.word	SyntaxError                      ; $82 !2:SH2
>8c26	9f 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c28	bb 83					.word	AssertCommand                    ; $84 ASSERT
>8c2a	24 a2					.word	BitmapCtrl                       ; $85 BITMAP
>8c2c	25 85					.word	EndCommand                       ; $86 END
>8c2e	b6 a3					.word	GoCommand                        ; $87 GO
>8c30	d0 87					.word	Command_List                     ; $88 LIST
>8c32	ad a3					.word	LoadCommand                      ; $89 LOAD
>8c34	28 89					.word	NewCommand                       ; $8a NEW
>8c36	2b 8a					.word	Command_Restore                  ; $8b RESTORE
>8c38	6a 8a					.word	CommandRUN                       ; $8c RUN
>8c3a	69 a2					.word	SpritesCtrl                      ; $8d SPRITES
>8c3c	c8 8c					.word	StopCommand                      ; $8e STOP
>8c3e	c4 8d					.word	WhoCommand                       ; $8f WHO
.8c40					VectorSet2:
>8c40	c5 9e					.word	SyntaxError                      ; $80 !0:EOF
>8c42	c5 9e					.word	SyntaxError                      ; $81 !1:SH1
>8c44	c5 9e					.word	SyntaxError                      ; $82 !2:SH2
>8c46	84 9d					.word	Assemble_adc                     ; $83 ADC
>8c48	7c 9d					.word	Assemble_and                     ; $84 AND
>8c4a	98 9d					.word	Assemble_asl                     ; $85 ASL
>8c4c	02 9e					.word	Assemble_bcc                     ; $86 BCC
>8c4e	06 9e					.word	Assemble_bcs                     ; $87 BCS
>8c50	0e 9e					.word	Assemble_beq                     ; $88 BEQ
>8c52	c5 9d					.word	Assemble_bit                     ; $89 BIT
>8c54	f6 9d					.word	Assemble_bmi                     ; $8a BMI
>8c56	0a 9e					.word	Assemble_bne                     ; $8b BNE
>8c58	f2 9d					.word	Assemble_bpl                     ; $8c BPL
>8c5a	12 9e					.word	Assemble_bra                     ; $8d BRA
>8c5c	16 9e					.word	Assemble_brk                     ; $8e BRK
>8c5e	fa 9d					.word	Assemble_bvc                     ; $8f BVC
>8c60	fe 9d					.word	Assemble_bvs                     ; $90 BVS
>8c62	1e 9e					.word	Assemble_clc                     ; $91 CLC
>8c64	72 9e					.word	Assemble_cld                     ; $92 CLD
>8c66	32 9e					.word	Assemble_cli                     ; $93 CLI
>8c68	62 9e					.word	Assemble_clv                     ; $94 CLV
>8c6a	90 9d					.word	Assemble_cmp                     ; $95 CMP
>8c6c	d9 9d					.word	Assemble_cpx                     ; $96 CPX
>8c6e	d4 9d					.word	Assemble_cpy                     ; $97 CPY
>8c70	b6 9d					.word	Assemble_dec                     ; $98 DEC
>8c72	6e 9e					.word	Assemble_dex                     ; $99 DEX
>8c74	4a 9e					.word	Assemble_dey                     ; $9a DEY
>8c76	80 9d					.word	Assemble_eor                     ; $9b EOR
>8c78	bb 9d					.word	Assemble_inc                     ; $9c INC
>8c7a	7e 9e					.word	Assemble_inx                     ; $9d INX
>8c7c	6a 9e					.word	Assemble_iny                     ; $9e INY
>8c7e	ed 9d					.word	Assemble_jmp                     ; $9f JMP
>8c80	e8 9d					.word	Assemble_jsr                     ; $a0 JSR
>8c82	8c 9d					.word	Assemble_lda                     ; $a1 LDA
>8c84	b1 9d					.word	Assemble_ldx                     ; $a2 LDX
>8c86	cf 9d					.word	Assemble_ldy                     ; $a3 LDY
>8c88	a2 9d					.word	Assemble_lsr                     ; $a4 LSR
>8c8a	82 9e					.word	Assemble_nop                     ; $a5 NOP
>8c8c	78 9d					.word	Assemble_ora                     ; $a6 ORA
>8c8e	2e 9e					.word	Assemble_pha                     ; $a7 PHA
>8c90	1a 9e					.word	Assemble_php                     ; $a8 PHP
>8c92	76 9e					.word	Assemble_phx                     ; $a9 PHX
>8c94	36 9e					.word	Assemble_phy                     ; $aa PHY
>8c96	3e 9e					.word	Assemble_pla                     ; $ab PLA
>8c98	22 9e					.word	Assemble_plp                     ; $ac PLP
>8c9a	8a 9e					.word	Assemble_plx                     ; $ad PLX
>8c9c	46 9e					.word	Assemble_ply                     ; $ae PLY
>8c9e	9d 9d					.word	Assemble_rol                     ; $af ROL
>8ca0	a7 9d					.word	Assemble_ror                     ; $b0 ROR
>8ca2	2a 9e					.word	Assemble_rti                     ; $b1 RTI
>8ca4	3a 9e					.word	Assemble_rts                     ; $b2 RTS
>8ca6	94 9d					.word	Assemble_sbc                     ; $b3 SBC
>8ca8	26 9e					.word	Assemble_sec                     ; $b4 SEC
>8caa	86 9e					.word	Assemble_sed                     ; $b5 SED
>8cac	42 9e					.word	Assemble_sei                     ; $b6 SEI
>8cae	88 9d					.word	Assemble_sta                     ; $b7 STA
>8cb0	7a 9e					.word	Assemble_stp                     ; $b8 STP
>8cb2	ac 9d					.word	Assemble_stx                     ; $b9 STX
>8cb4	ca 9d					.word	Assemble_sty                     ; $ba STY
>8cb6	c0 9d					.word	Assemble_stz                     ; $bb STZ
>8cb8	5e 9e					.word	Assemble_tax                     ; $bc TAX
>8cba	5a 9e					.word	Assemble_tay                     ; $bd TAY
>8cbc	e3 9d					.word	Assemble_trb                     ; $be TRB
>8cbe	de 9d					.word	Assemble_tsb                     ; $bf TSB
>8cc0	66 9e					.word	Assemble_tsx                     ; $c0 TSX
>8cc2	4e 9e					.word	Assemble_txa                     ; $c1 TXA
>8cc4	56 9e					.word	Assemble_txs                     ; $c2 TXS
>8cc6	52 9e					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8cc8					StopCommand:
.8cc8	a9 08		lda #$08		lda	#8
.8cca	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8ccd					ProcedureScan:
.8ccd	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ccf	85 30		sta $30				sta 	codePtr
.8cd1	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8cd3	85 31		sta $31				sta 	codePtr+1
.8cd5					_PSLoop:
.8cd5	b2 30		lda ($30)			lda 	(codePtr)
.8cd7	f0 42		beq $8d1b			beq 	_PSExit
.8cd9	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8cdb	b1 30		lda ($30),y			lda 	(codePtr),y
.8cdd	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8cdf	d0 2d		bne $8d0e			bne 	_PSNext
.8ce1	c8		iny				iny 								; get the address of the record to zTemp0 and
.8ce2	b1 30		lda ($30),y			lda 	(codePtr),y
.8ce4	29 c0		and #$c0			and 	#$C0
.8ce6	c9 40		cmp #$40			cmp 	#$40
.8ce8	d0 32		bne $8d1c			bne 	_PSSyntax
.8cea	b1 30		lda ($30),y			lda 	(codePtr),y
.8cec	18		clc				clc
.8ced	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8cef	85 37		sta $37				sta 	zTemp0+1
.8cf1	c8		iny				iny 								; LSB
.8cf2	b1 30		lda ($30),y			lda 	(codePtr),y
.8cf4	85 36		sta $36				sta 	zTemp0
.8cf6	c8		iny				iny 								; character after variable call.
.8cf7	98		tya				tya 								; save Y offset at +7
.8cf8	a0 07		ldy #$07			ldy 	#7
.8cfa	91 36		sta ($36),y			sta 	(zTemp0),y
.8cfc	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8cfe	a0 02		ldy #$02			ldy 	#2
.8d00	91 36		sta ($36),y			sta 	(zTemp0),y
.8d02	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d04					_PSCopy:
.8d04	b5 30		lda $30,x			lda 	safePtr,x
.8d06	c8		iny				iny
.8d07	91 36		sta ($36),y			sta 	(zTemp0),y
.8d09	e8		inx				inx
.8d0a	e0 04		cpx #$04			cpx 	#4
.8d0c	d0 f6		bne $8d04			bne 	_PSCopy
.8d0e					_PSNext:
.8d0e	18		clc				clc
.8d0f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d11	65 30		adc $30				adc 	codePtr
.8d13	85 30		sta $30				sta 	codePtr
.8d15	90 02		bcc $8d19			bcc 	_CREExit
.8d17	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d19					_CREExit:
.8d19	80 ba		bra $8cd5			bra 	_PSLoop
.8d1b					_PSExit:
.8d1b	60		rts				rts
.8d1c					_PSSyntax:
.8d1c	4c c5 9e	jmp $9ec5			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d1f					ScanForward:
.8d1f	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d21	86 37		stx $37				stx 	zTemp0+1
.8d23	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d25					_ScanLoop:
.8d25	b1 30		lda ($30),y			lda 	(codePtr),y
.8d27	c8		iny				iny
.8d28	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d2a	d0 0e		bne $8d3a			bne 	_ScanGoNext
.8d2c	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d2e	f0 04		beq $8d34			beq 	_ScanMatch
.8d30	c5 37		cmp $37				cmp 	zTemp0+1
.8d32	d0 06		bne $8d3a			bne 	_ScanGoNext
.8d34					_ScanMatch:
.8d34	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d36	d0 01		bne $8d39			bne 	_ScanNotEndEOL
.8d38	88		dey				dey
.8d39					_ScanNotEndEOL:
.8d39	60		rts				rts
.8d3a					_ScanGoNext:
.8d3a	20 3f 8d	jsr $8d3f			jsr  	ScanForwardOne
.8d3d	80 e6		bra $8d25			bra 	_ScanLoop
.8d3f					ScanForwardOne:
.8d3f	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d41	90 3e		bcc $8d81			bcc 	_SFWExit
.8d43	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d45	90 18		bcc $8d5f			bcc 	_ScanSkipOne
.8d47	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d49	b0 2f		bcs $8d7a			bcs 	_ScanSkipData
.8d4b	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d4d	90 32		bcc $8d81			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d4f	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d51	b0 2e		bcs $8d81			bcs 	_SFWExit
.8d53	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d55	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d57	b0 28		bcs $8d81			bcs 	_SFWExit
.8d59	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d5b	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8d5d	80 22		bra $8d81			bra 	_SFWExit
.8d5f					_ScanSkipOne:
.8d5f	c8		iny				iny 								; consume the extra one.
.8d60	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8d62	d0 1d		bne $8d81			bne 	_SFWExit
.8d64	18		clc				clc
.8d65	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d67	65 30		adc $30				adc 	codePtr
.8d69	85 30		sta $30				sta 	codePtr
.8d6b	90 02		bcc $8d6f			bcc 	_CREExit
.8d6d	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d6f					_CREExit:
.8d6f	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8d71	b2 30		lda ($30)			lda 	(codePtr)
.8d73	d0 0c		bne $8d81			bne 	_SFWExit 					; if not zero, more to scan
.8d75	a9 13		lda #$13		lda	#19
.8d77	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.8d7a					_ScanSkipData:
.8d7a	88		dey				dey 								; point at data token
.8d7b	c8		iny				iny 								; point to offset
.8d7c	98		tya				tya 								; A = offset position
.8d7d	38		sec				sec 								; add size +1 hence SEC
.8d7e	71 30		adc ($30),y			adc 	(codePtr),y
.8d80	a8		tay				tay 								; make current position.
.8d81					_SFWExit:
.8d81	60		rts				rts
.8d82					ScanGetCurrentLineStep:
.8d82	64 38		stz $38				stz 	zTemp1
.8d84	a0 03		ldy #$03			ldy 	#3
.8d86					_SGCLSLoop:
.8d86	b1 30		lda ($30),y			lda 	(codePtr),y
.8d88	c8		iny				iny
.8d89	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d8b	f0 05		beq $8d92			beq 	_SGCLSExit
.8d8d	20 3f 8d	jsr $8d3f			jsr 	ScanForwardOne
.8d90	80 f4		bra $8d86			bra 	_SGCLSLoop
.8d92					_SGCLSExit:
.8d92	a5 38		lda $38				lda 	zTemp1
.8d94	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8d95					Command_WHILE:
.8d95	5a		phy				phy 								; save position of the test
.8d96	a2 00		ldx #$00			ldx 	#0
.8d98	20 9b 9c	jsr $9c9b			jsr 	EvaluateNumber 				; work out the number
.8d9b	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; check if zero
.8d9e	f0 0e		beq $8dae			beq 	_WHExitLoop 				; if so exit the loop
.8da0	98		tya				tya 								; position *after* test.
.8da1	7a		ply				ply 								; restore position before test, at WHILE
.8da2	88		dey				dey
.8da3	48		pha				pha 								; push after test on the stack
.8da4	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8da6	20 8a a5	jsr $a58a			jsr 	StackOpen
.8da9	20 ce a5	jsr $a5ce			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8dac	7a		ply				ply 								; restore the position *after* the test
.8dad	60		rts				rts
.8dae					_WHExitLoop:
.8dae	68		pla				pla 								; throw post loop position
.8daf	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8db1	aa		tax				tax
.8db2	20 1f 8d	jsr $8d1f			jsr 	ScanForward
.8db5	60		rts				rts
.8db6					Command_WEND:
.8db6	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8db8	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8dba	20 b6 a5	jsr $a5b6			jsr 	StackCheckFrame
.8dbd	20 df a5	jsr $a5df			jsr 	STKLoadCodePosition 		; loop back
.8dc0	20 a8 a5	jsr $a5a8			jsr 	StackClose		 			; erase the frame
.8dc3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8dc4					WhoCommand:
.8dc4	a2 8d		ldx #$8d			ldx 	#(_WHOMessage >> 8)
.8dc6	a9 cc		lda #$cc			lda 	#(_WHOMessage & $FF)
.8dc8	20 99 8e	jsr $8e99			jsr 	PrintStringXA
.8dcb	60		rts				rts
.8dcc					_WHOMessage:
>8dcc	81						.byte 	$81
>8dcd	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8dd5	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8de2	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8dea	20 41 6c 6c 61 69 72 65 0d
>8df3	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8dfb	4f 62 65 72 72 65 75 74 65 72 0d
>8e06	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8e0e	62 73 6f 6e 0d
>8e13	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8e1b	65 69 6e 67 61 72 74 6e 65 72 0d
>8e26	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8e27					CheckRightBracket:
.8e27	b1 30		lda ($30),y			lda 	(codePtr),y
.8e29	c8		iny				iny
.8e2a	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8e2c	d0 0f		bne $8e3d			bne 	CNAFail
.8e2e	60		rts				rts
.8e2f					CheckComma:
.8e2f	b1 30		lda ($30),y			lda 	(codePtr),y
.8e31	c8		iny				iny
.8e32	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8e34	d0 07		bne $8e3d			bne 	CNAFail
.8e36	60		rts				rts
.8e37					CheckNextA:
.8e37	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8e39	d0 02		bne $8e3d			bne 	CNAFail
.8e3b	c8		iny				iny 								; skip character
.8e3c	60		rts				rts 								; and exit
.8e3d					CNAFail:
.8e3d	4c c5 9e	jmp $9ec5			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8e40					ErrorHandler:
.8e40	a8		tay				tay 								; find the error text
.8e41	f0 49		beq $8e8c			beq 	_EHEnd
.8e43	a2 00		ldx #$00			ldx 	#0
.8e45	a9 de		lda #$de			lda 	#((ErrorText) & $FF)
.8e47	85 36		sta $36				sta 	0+zTemp0
.8e49	a9 9e		lda #$9e			lda 	#((ErrorText) >> 8)
.8e4b	85 37		sta $37				sta 	1+zTemp0
.8e4d					_EHFind:
.8e4d	88		dey				dey 								; found the error text ?
.8e4e	f0 0e		beq $8e5e			beq 	_EHFound
.8e50					_EHFindZero:
.8e50	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e52	e6 36		inc $36				inc 	zTemp0
.8e54	d0 02		bne $8e58			bne 	_EHFNoCarry
.8e56	e6 37		inc $37				inc 	zTemp0+1
.8e58					_EHFNoCarry:
.8e58	c9 00		cmp #$00			cmp 	#0
.8e5a	d0 f4		bne $8e50			bne 	_EHFindZero
.8e5c	80 ef		bra $8e4d			bra 	_EHFind
.8e5e					_EHFound:
.8e5e	a5 36		lda $36				lda 	zTemp0 						; print message
.8e60	a6 37		ldx $37				ldx 	zTemp0+1
.8e62	20 99 8e	jsr $8e99			jsr 	PrintStringXA
.8e65	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8e67	b1 30		lda ($30),y			lda 	(codePtr),y
.8e69	d0 05		bne $8e70			bne 	_EHAtMsg
.8e6b	c8		iny				iny
.8e6c	b1 30		lda ($30),y			lda 	(codePtr),y
.8e6e	f0 17		beq $8e87			beq 	_EHCREnd
.8e70					_EHAtMsg:
.8e70	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8e72	a9 8f		lda #$8f			lda 	#_AtMsg & $FF
.8e74	20 99 8e	jsr $8e99			jsr 	PrintStringXA
.8e77	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8e79	b1 30		lda ($30),y			lda 	(codePtr),y
.8e7b	48		pha				pha
.8e7c	c8		iny				iny
.8e7d	b1 30		lda ($30),y			lda 	(codePtr),y
.8e7f	aa		tax				tax
.8e80	68		pla				pla
.8e81	20 af 92	jsr $92af			jsr 	LCLConvertInt16 				; convert XA to string
.8e84	20 99 8e	jsr $8e99			jsr 	PrintStringXA 				; and print it.
.8e87					_EHCREnd:
.8e87	a9 0d		lda #$0d			lda 	#13 						; new line
.8e89	20 c1 a6	jsr $a6c1			jsr 	EXTPrintCharacter
.8e8c					_EHEnd:
.8e8c	4c 6a 83	jmp $836a			jmp 	WarmStart
>8e8f	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8e97	20 00
.8e99					PrintStringXA:
.8e99	5a		phy				phy
.8e9a	86 37		stx $37				stx 	zTemp0+1
.8e9c	85 36		sta $36				sta 	zTemp0
.8e9e	a0 00		ldy #$00			ldy 	#0
.8ea0					_PSXALoop:
.8ea0	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ea2	f0 06		beq $8eaa			beq 	_PSXAExit
.8ea4	20 c1 a6	jsr $a6c1			jsr 	EXTPrintCharacter
.8ea7	c8		iny				iny
.8ea8	80 f6		bra $8ea0			bra 	_PSXALoop
.8eaa					_PSXAExit:
.8eaa	7a		ply				ply
.8eab	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8eac					UnaryTrue:
.8eac	fa		plx				plx
.8ead					ReturnTrue:
.8ead	a9 01		lda #$01			lda 	#1  						; set to 1
.8eaf	20 4f 9d	jsr $9d4f			jsr 	NSMSetByte
.8eb2	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8eb4	95 50		sta $50,x			sta 	NSStatus,x
.8eb6	60		rts				rts
.8eb7					UnaryFalse:
.8eb7	fa		plx				plx
.8eb8					ReturnFalse:
.8eb8	4c 4d 9d	jmp $9d4d			jmp 	NSMSetZero 					; set it all to zero
.8ebb					BinaryCompareEqual:
.8ebb	fa		plx				plx
.8ebc	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode
.8ebf	c9 00		cmp #$00			cmp 	#0
.8ec1	f0 ea		beq $8ead			beq 	ReturnTrue
.8ec3	80 f3		bra $8eb8			bra 	ReturnFalse
.8ec5					BinaryCompareLess:
.8ec5	fa		plx				plx
.8ec6	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode
.8ec9	c9 ff		cmp #$ff			cmp 	#$FF
.8ecb	f0 e0		beq $8ead			beq 	ReturnTrue
.8ecd	80 e9		bra $8eb8			bra 	ReturnFalse
.8ecf					BinaryCompareGreater:
.8ecf	fa		plx				plx
.8ed0	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode
.8ed3	c9 01		cmp #$01			cmp 	#1
.8ed5	f0 d6		beq $8ead			beq 	ReturnTrue
.8ed7	80 df		bra $8eb8			bra 	ReturnFalse
.8ed9					BinaryCompareNotEqual:
.8ed9	fa		plx				plx
.8eda	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode
.8edd	c9 00		cmp #$00			cmp 	#0
.8edf	d0 cc		bne $8ead			bne 	ReturnTrue
.8ee1	80 d5		bra $8eb8			bra 	ReturnFalse
.8ee3					BinaryCompareLessEqual:
.8ee3	fa		plx				plx
.8ee4	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode
.8ee7	c9 01		cmp #$01			cmp 	#1
.8ee9	d0 c2		bne $8ead			bne 	ReturnTrue
.8eeb	80 cb		bra $8eb8			bra 	ReturnFalse
.8eed					BinaryCompareGreaterEqual:
.8eed	fa		plx				plx
.8eee	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode
.8ef1	c9 ff		cmp #$ff			cmp 	#$FF
.8ef3	d0 b8		bne $8ead			bne 	ReturnTrue
.8ef5	80 c1		bra $8eb8			bra 	ReturnFalse
.8ef7					CompareBaseCode:
.8ef7	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; make both values if references.
.8efa	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8efc	15 51		ora $51,x			ora 	NSStatus+1,x
.8efe	29 10		and #$10			and 	#NSTString
.8f00	d0 37		bne $8f39			bne 	_CBCString 					; if so do string code, which will check if both.
.8f02	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8f04	15 79		ora $79,x			ora 	NSExponent+1,x
.8f06	d0 34		bne $8f3c			bne 	_CBCFloat
.8f08	b5 50		lda $50,x			lda 	NSStatus,x
.8f0a	15 51		ora $51,x			ora 	NSStatus+1,x
.8f0c	29 08		and #$08			and 	#NSTFloat
.8f0e	d0 2c		bne $8f3c			bne 	_CBCFloat
.8f10	20 3f 8f	jsr $8f3f			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8f13	e8		inx				inx
.8f14	20 3f 8f	jsr $8f3f			jsr 	CompareFixMinusZero
.8f17	ca		dex				dex
.8f18	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8f1a	55 51		eor $51,x			eor 	NSStatus+1,x
.8f1c	10 0a		bpl $8f28			bpl 	_CDCSameSign
.8f1e	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8f20	30 14		bmi $8f36			bmi 	_CBCLess 					; return $FF
.8f22					_CBCGreater:
.8f22	a9 01		lda #$01			lda 	#1
.8f24	60		rts				rts
.8f25					_CBCEqual:
.8f25	a9 00		lda #$00			lda 	#0
.8f27	60		rts				rts
.8f28					_CDCSameSign:
.8f28	20 54 91	jsr $9154			jsr 	SubTopTwoStack 				; unsigned subtract
.8f2b	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; or the mantissa together
.8f2e	f0 f5		beq $8f25			beq 	_CBCEqual 					; -0 == 0
.8f30	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8f32	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8f34	10 ec		bpl $8f22			bpl 	_CBCGreater
.8f36					_CBCLess:
.8f36	a9 ff		lda #$ff			lda 	#$FF
.8f38	60		rts				rts
.8f39					_CBCString:
.8f39	4c c5 90	jmp $90c5			jmp 	CompareStrings
.8f3c					_CBCFloat:
.8f3c	4c 0f 94	jmp $940f			jmp 	CompareFloat
.8f3f					CompareFixMinusZero:
.8f3f	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero
.8f42	d0 02		bne $8f46			bne 	_CFXMZNotZero
.8f44	74 50		stz $50,x			stz 	NSStatus,x
.8f46					_CFXMZNotZero:
.8f46	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f47					StringConcat:
.8f47	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.8f49	35 51		and $51,x			and 	NSStatus+1,x
.8f4b	29 18		and #$18			and 	#NSBTypeMask
.8f4d	c9 10		cmp #$10			cmp 	#NSTString
.8f4f	d0 50		bne $8fa1			bne		_SCType
.8f51	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f53	e8		inx				inx
.8f54	20 72 8f	jsr $8f72			jsr 	_SCSetupZ0 					; setup for second
.8f57	20 7b 8f	jsr $8f7b			jsr 	_SCLengthZ0 				; length for second
.8f5a	ca		dex				dex
.8f5b	20 72 8f	jsr $8f72			jsr 	_SCSetupZ0 					; setup for first
.8f5e	20 7b 8f	jsr $8f7b			jsr 	_SCLengthZ0 				; length for first
.8f61	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.8f63	20 79 a6	jsr $a679			jsr 	StringTempAllocate
.8f66	20 92 8f	jsr $8f92			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8f69	e8		inx				inx
.8f6a	20 72 8f	jsr $8f72			jsr 	_SCSetupZ0 					; copy second out
.8f6d	20 92 8f	jsr $8f92			jsr 	_SCCopy
.8f70	ca		dex				dex
.8f71	60		rts				rts
.8f72					_SCSetupZ0:
.8f72	b5 58		lda $58,x			lda 	NSMantissa0,x
.8f74	85 36		sta $36				sta 	zTemp0
.8f76	b5 60		lda $60,x			lda 	NSMantissa1,x
.8f78	85 37		sta $37				sta 	zTemp0+1
.8f7a	60		rts				rts
.8f7b					_SCLengthZ0:
.8f7b	5a		phy				phy
.8f7c	a0 00		ldy #$00			ldy 	#0
.8f7e					_SCLenLoop:
.8f7e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f80	f0 0e		beq $8f90			beq 	_SCLExit
.8f82	c8		iny				iny
.8f83	e6 38		inc $38				inc 	zTemp1
.8f85	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.8f87	c9 fd		cmp #$fd			cmp 	#253
.8f89	d0 f3		bne $8f7e			bne		_SCLenLoop
.8f8b	a9 09		lda #$09		lda	#9
.8f8d	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.8f90					_SCLExit:
.8f90	7a		ply				ply
.8f91	60		rts				rts
.8f92					_SCCopy:
.8f92	5a		phy				phy
.8f93	a0 00		ldy #$00			ldy 	#0
.8f95					_SCCopyLoop:
.8f95	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f97	f0 06		beq $8f9f			beq 	_SCCExit
.8f99	20 b2 a6	jsr $a6b2			jsr 	StringTempWrite
.8f9c	c8		iny				iny
.8f9d	80 f6		bra $8f95			bra 	_SCCopyLoop
.8f9f					_SCCExit:
.8f9f	7a		ply				ply
.8fa0	60		rts				rts
.8fa1					_SCType:
.8fa1	4c cf 9e	jmp $9ecf			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8fa4					IntegerDivide:
.8fa4	fa		plx				plx
.8fa5	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.8fa7	15 51		ora $51,x			ora 	NSStatus+1,x
.8fa9	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8faa	0a		asl a				asl 	a
.8fab	10 05		bpl $8fb2			bpl 	_NotRef
.8fad	48		pha				pha
.8fae	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fb1	68		pla				pla
.8fb2					_NotRef:
.8fb2	0a		asl a				asl 	a
.8fb3	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8fb5	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fb7	15 79		ora $79,x			ora 	NSExponent+1,x
.8fb9	f0 03		beq $8fbe			beq 	_IntegerCode 				; if clear, then we have two integers
.8fbb	4c cf 9e	jmp $9ecf			jmp 	TypeError 					; anything else, type mismatch.
.8fbe					_IntegerCode:
.8fbe	20 d8 8f	jsr $8fd8			jsr 	CheckDivideZero 			; do div zero check
.8fc1	20 0a 90	jsr $900a			jsr 	Int32Divide 				; do the division
.8fc4	20 bb 90	jsr $90bb			jsr 	CalculateSign 				; calculate result sign
.8fc7					NSMCopyPlusTwoToZero:
.8fc7	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8fc9	95 58		sta $58,x			sta 	NSMantissa0,x
.8fcb	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.8fcd	95 60		sta $60,x			sta 	NSMantissa1,x
.8fcf	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.8fd1	95 68		sta $68,x			sta 	NSMantissa2,x
.8fd3	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.8fd5	95 70		sta $70,x			sta 	NSMantissa3,x
.8fd7	60		rts				rts
.8fd8					CheckDivideZero:
.8fd8	e8		inx				inx
.8fd9	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero
.8fdc	f0 02		beq $8fe0			beq 	_CDVError
.8fde	ca		dex				dex
.8fdf	60		rts				rts
.8fe0					_CDVError:
.8fe0	a9 03		lda #$03		lda	#3
.8fe2	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.8fe5					IntegerModulus:
.8fe5	fa		plx				plx
.8fe6	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.8fe8	15 51		ora $51,x			ora 	NSStatus+1,x
.8fea	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8feb	0a		asl a				asl 	a
.8fec	10 05		bpl $8ff3			bpl 	_NotRef
.8fee	48		pha				pha
.8fef	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8ff2	68		pla				pla
.8ff3					_NotRef:
.8ff3	0a		asl a				asl 	a
.8ff4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8ff6	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8ff8	15 79		ora $79,x			ora 	NSExponent+1,x
.8ffa	f0 03		beq $8fff			beq 	_IntegerCode 				; if clear, then we have two integers
.8ffc	4c cf 9e	jmp $9ecf			jmp 	TypeError 					; anything else, type mismatch.
.8fff					_IntegerCode:
.8fff					IntegerModulusNoCheck:
.8fff	20 d8 8f	jsr $8fd8			jsr 	CheckDivideZero 			; do div zero check
.9002	20 0a 90	jsr $900a			jsr 	Int32Divide 				; do the division
.9005	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9007	56 50		lsr $50,x			lsr 	NSStatus,x
.9009	60		rts				rts
.900a					Int32Divide:
.900a	48		pha				pha 								; save AXY
.900b	5a		phy				phy
.900c	20 30 9d	jsr $9d30			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.900f	20 49 9d	jsr $9d49			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.9012	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.9014					_I32DivideLoop:
.9014	e8		inx				inx
.9015	e8		inx				inx
.9016	20 5c 9d	jsr $9d5c			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.9019	ca		dex				dex
.901a	ca		dex				dex
.901b	20 5d 9d	jsr $9d5d			jsr 	NSMRotateLeft
.901e	20 49 90	jsr $9049			jsr 	DivideCheckSubtract 		; check if subtract possible
.9021	90 02		bcc $9025			bcc 	_I32DivideNoCarryIn
.9023	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9025					_I32DivideNoCarryIn:
.9025	88		dey				dey 								; loop round till division completed.
.9026	d0 ec		bne $9014			bne 	_I32DivideLoop
.9028	7a		ply				ply 								; restore AXY and exit
.9029	68		pla				pla
.902a	60		rts				rts
.902b					Int32ShiftDivide:
.902b	48		pha				pha 								; save AY
.902c	5a		phy				phy
.902d	e8		inx				inx 								; clear S[X+2]
.902e	e8		inx				inx
.902f	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero
.9032	ca		dex				dex
.9033	ca		dex				dex
.9034	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9036					_I32SDLoop:
.9036	20 49 90	jsr $9049			jsr 	DivideCheckSubtract 		; check if subtract possible
.9039	e8		inx				inx
.903a	e8		inx				inx
.903b	20 5d 9d	jsr $9d5d			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.903e	ca		dex				dex
.903f	ca		dex				dex
.9040	20 5d 9d	jsr $9d5d			jsr 	NSMRotateLeft
.9043	88		dey				dey 	 							; do 31 times
.9044	d0 f0		bne $9036			bne 	_I32SDLoop
.9046	7a		ply				ply 								; restore AY and exit
.9047	68		pla				pla
.9048	60		rts				rts
.9049					DivideCheckSubtract:
.9049	20 54 91	jsr $9154			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.904c	b0 04		bcs $9052			bcs 	_DCSExit 					; if carry set, then could do, exit
.904e	20 3a 91	jsr $913a			jsr 	AddTopTwoStack 				; add it back in
.9051	18		clc				clc 								; and return False
.9052					_DCSExit:
.9052	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9053					MulInteger:
.9053	fa		plx				plx
.9054	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9056	15 51		ora $51,x			ora 	NSStatus+1,x
.9058	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9059	0a		asl a				asl 	a
.905a	10 05		bpl $9061			bpl 	_NotRef
.905c	48		pha				pha
.905d	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9060	68		pla				pla
.9061					_NotRef:
.9061	0a		asl a				asl 	a 							; put MSB of type into A:7
.9062	30 09		bmi $906d			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9064	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9066	15 79		ora $79,x			ora 	NSExponent+1,x
.9068	f0 06		beq $9070			beq 	_IntegerCode 				; if clear, then we have two integers
.906a	4c d1 94	jmp $94d1			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.906d					_StringData:
.906d	4c d9 9e	jmp $9ed9			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9070					_IntegerCode:
.9070	20 7d 90	jsr $907d			jsr 	MultiplyShort
.9073	c9 00		cmp #$00			cmp 	#0
.9075	f0 05		beq $907c			beq 	_MIExit
.9077	a9 04		lda #$04		lda	#4
.9079	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.907c					_MIExit:
.907c	60		rts				rts
.907d					MultiplyShort:
.907d	5a		phy				phy 								; save Y
.907e	20 30 9d	jsr $9d30			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9081	20 49 9d	jsr $9d49			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9084	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9086					_I32MLoop:
.9086	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9088	15 62		ora $62,x			ora 	NSMantissa1+2,x
.908a	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.908c	15 72		ora $72,x			ora 	NSMantissa3+2,x
.908e	f0 25		beq $90b5			beq 	_I32MExit 					; exit if zero
.9090	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9092	29 01		and #$01			and 	#1
.9094	f0 0d		beq $90a3			beq 	_I32MNoAdd
.9096	20 3a 91	jsr $913a			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9099	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.909b	10 06		bpl $90a3			bpl 	_I32MNoAdd
.909d					_I32ShiftRight:
.909d	20 66 9d	jsr $9d66			jsr 	NSMShiftRight 				; shift S[X] right
.90a0	c8		iny				iny 								; increment shift count
.90a1	80 09		bra $90ac			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.90a3					_I32MNoAdd:
.90a3	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.90a5	70 f6		bvs $909d			bvs 	_I32ShiftRight 				; instead.
.90a7	e8		inx				inx
.90a8	20 5c 9d	jsr $9d5c			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.90ab	ca		dex				dex
.90ac					_I32MShiftUpper:
.90ac	e8		inx				inx 								; shift S[X+2] right
.90ad	e8		inx				inx
.90ae	20 66 9d	jsr $9d66			jsr 	NSMShiftRight
.90b1	ca		dex				dex
.90b2	ca		dex				dex
.90b3	80 d1		bra $9086			bra 	_I32MLoop 					; try again.
.90b5					_I32MExit:
.90b5	20 bb 90	jsr $90bb			jsr 	CalculateSign
.90b8	98		tya				tya 								; shift in A
.90b9	7a		ply				ply 								; restore Y and exit
.90ba	60		rts				rts
.90bb					CalculateSign:
.90bb	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.90bd	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.90bf	55 51		eor $51,x			eor 	NSStatus+1,x
.90c1	0a		asl a				asl 	a 							; shift bit 7 into carry
.90c2	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.90c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.90c5					CompareStrings:
.90c5	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.90c7	35 51		and $51,x			and 	NSStatus+1,x
.90c9	29 10		and #$10			and 	#NSBIsString
.90cb	f0 28		beq $90f5			beq 	_CSTypeError
.90cd	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.90cf	85 36		sta $36				sta 	zTemp0
.90d1	b5 60		lda $60,x			lda 	NSMantissa1,x
.90d3	85 37		sta $37				sta 	zTemp0+1
.90d5	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.90d7	85 38		sta $38				sta 	zTemp1
.90d9	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.90db	85 39		sta $39				sta 	zTemp1+1
.90dd	5a		phy				phy 								; save Y so we can access strings
.90de	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.90e0					_CSLoop:
.90e0	c8		iny				iny
.90e1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.90e3	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.90e5	d0 06		bne $90ed			bne 	_CSDifferent
.90e7	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.90e9	d0 f5		bne $90e0			bne 	_CSLoop 					; still comparing
.90eb					_CSExit:
.90eb	7a		ply				ply 								; reached end, return zero in A from EOS
.90ec	60		rts				rts
.90ed					_CSDifferent:
.90ed	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.90ef	90 fa		bcc $90eb			bcc		_CSExit
.90f1	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.90f3	80 f6		bra $90eb			bra 	_CSExit
.90f5					_CSTypeError:
.90f5	4c cf 9e	jmp $9ecf			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.90f8					ShiftLeft:
.90f8	38		sec				sec 								; common code, carry determines which way.
.90f9	80 01		bra $90fc			bra 	ShiftMain
.90fb					ShiftRight:
.90fb	18		clc				clc
.90fc					ShiftMain:
.90fc	fa		plx				plx 								; restore X
.90fd	08		php				php 								; save direction
.90fe	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9100	15 51		ora $51,x			ora 	NSStatus+1,x
.9102	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9103	0a		asl a				asl 	a
.9104	10 05		bpl $910b			bpl 	_NotRef
.9106	48		pha				pha
.9107	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.910a	68		pla				pla
.910b					_NotRef:
.910b	0a		asl a				asl 	a
.910c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.910e	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9110	15 79		ora $79,x			ora 	NSExponent+1,x
.9112	f0 03		beq $9117			beq 	_IntegerCode 				; if clear, then we have two integers
.9114	4c cf 9e	jmp $9ecf			jmp 	TypeError 					; anything else, type mismatch.
.9117					_IntegerCode:
.9117	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.9119	29 e0		and #$e0			and 	#$E0
.911b	15 61		ora $61,x			ora 	NSMantissa1+1,x
.911d	15 69		ora $69,x			ora 	NSMantissa2+1,x
.911f	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9121	d0 12		bne $9135			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9123					_SMLoop:
.9123	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9125	30 11		bmi $9138			bmi 	_SMExit 					; exit if done.
.9127	28		plp				plp 								; restore direction setting
.9128	08		php				php
.9129	90 05		bcc $9130			bcc 	_SMRight
.912b	20 5c 9d	jsr $9d5c			jsr 	NSMShiftLeft 				; shift left if CS
.912e	80 f3		bra $9123			bra 	_SMLoop
.9130					_SMRight:
.9130	20 66 9d	jsr $9d66			jsr 	NSMShiftRight 				; shift right if CC
.9133	80 ee		bra $9123			bra 	_SMLoop
.9135					_SMExit0:
.9135	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero 					; return zero.
.9138					_SMExit:
.9138	28		plp				plp 								; throw direction
.9139	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.913a					AddTopTwoStack:
.913a	18		clc				clc
.913b	b5 58		lda $58,x			lda		NSMantissa0,x
.913d	75 59		adc $59,x			adc 		NSMantissa0+1,x
.913f	95 58		sta $58,x			sta 	NSMantissa0,x
.9141	b5 60		lda $60,x			lda		NSMantissa1,x
.9143	75 61		adc $61,x			adc 		NSMantissa1+1,x
.9145	95 60		sta $60,x			sta 	NSMantissa1,x
.9147	b5 68		lda $68,x			lda		NSMantissa2,x
.9149	75 69		adc $69,x			adc 		NSMantissa2+1,x
.914b	95 68		sta $68,x			sta 	NSMantissa2,x
.914d	b5 70		lda $70,x			lda		NSMantissa3,x
.914f	75 71		adc $71,x			adc 		NSMantissa3+1,x
.9151	95 70		sta $70,x			sta 	NSMantissa3,x
.9153	60		rts				rts
.9154					SubTopTwoStack:
.9154	38		sec				sec
.9155	b5 58		lda $58,x			lda		NSMantissa0,x
.9157	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9159	95 58		sta $58,x			sta 	NSMantissa0,x
.915b	b5 60		lda $60,x			lda		NSMantissa1,x
.915d	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.915f	95 60		sta $60,x			sta 	NSMantissa1,x
.9161	b5 68		lda $68,x			lda		NSMantissa2,x
.9163	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.9165	95 68		sta $68,x			sta 	NSMantissa2,x
.9167	b5 70		lda $70,x			lda		NSMantissa3,x
.9169	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.916b	95 70		sta $70,x			sta 	NSMantissa3,x
.916d	60		rts				rts
.916e					AddInteger:
.916e	fa		plx				plx
.916f	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9171	15 51		ora $51,x			ora 	NSStatus+1,x
.9173	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9174	0a		asl a				asl 	a
.9175	10 05		bpl $917c			bpl 	_NotRef
.9177	48		pha				pha
.9178	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.917b	68		pla				pla
.917c					_NotRef:
.917c	0a		asl a				asl 	a 							; put MSB of type into A:7
.917d	30 09		bmi $9188			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.917f	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9181	15 79		ora $79,x			ora 	NSExponent+1,x
.9183	f0 06		beq $918b			beq 	_IntegerCode 				; if clear, then we have two integers
.9185	4c 81 93	jmp $9381			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9188					_StringData:
.9188	4c 47 8f	jmp $8f47			jmp 	StringConcat							; at least one string - don't know both are strings.
.918b					_IntegerCode:
.918b					AddCode:
.918b	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.918d	55 51		eor $51,x			eor 	NSStatus+1,x
.918f	10 a9		bpl $913a			bpl 	AddTopTwoStack
.9191	20 54 91	jsr $9154			jsr 	SubTopTwoStack 				; do a physical subtraction
.9194	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9196	10 07		bpl $919f			bpl 	_AddExit
.9198	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.919a	95 50		sta $50,x			sta 	NSStatus,x
.919c	20 16 9d	jsr $9d16			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.919f					_AddExit:
.919f	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; check for -0
.91a2	d0 02		bne $91a6			bne 	_AddNonZero
.91a4	74 50		stz $50,x			stz 	NSStatus,x
.91a6					_AddNonZero:
.91a6	60		rts				rts
.91a7					SubInteger:
.91a7	fa		plx				plx
.91a8	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91aa	15 51		ora $51,x			ora 	NSStatus+1,x
.91ac	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91ad	0a		asl a				asl 	a
.91ae	10 05		bpl $91b5			bpl 	_NotRef
.91b0	48		pha				pha
.91b1	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91b4	68		pla				pla
.91b5					_NotRef:
.91b5	0a		asl a				asl 	a 							; put MSB of type into A:7
.91b6	30 09		bmi $91c1			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91b8	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91ba	15 79		ora $79,x			ora 	NSExponent+1,x
.91bc	f0 06		beq $91c4			beq 	_IntegerCode 				; if clear, then we have two integers
.91be	4c 86 93	jmp $9386			jmp 	FloatingPointSub 							; otherwise at least one float.
.91c1					_StringData:
.91c1	4c d9 9e	jmp $9ed9			jmp 	NotDoneError							; at least one string - don't know both are strings.
.91c4					_IntegerCode:
.91c4	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.91c6	49 80		eor #$80			eor 	#$80
.91c8	95 51		sta $51,x			sta 	NSStatus+1,x
.91ca	80 bf		bra $918b			bra 	AddCode 					; and do the same code as add.
.91cc					AndInteger:
.91cc	fa		plx				plx
.91cd	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91cf	15 51		ora $51,x			ora 	NSStatus+1,x
.91d1	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91d2	0a		asl a				asl 	a
.91d3	10 05		bpl $91da			bpl 	_NotRef
.91d5	48		pha				pha
.91d6	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91d9	68		pla				pla
.91da					_NotRef:
.91da	0a		asl a				asl 	a
.91db	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91dd	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91df	15 79		ora $79,x			ora 	NSExponent+1,x
.91e1	f0 03		beq $91e6			beq 	_IntegerCode 				; if clear, then we have two integers
.91e3	4c cf 9e	jmp $9ecf			jmp 	TypeError 					; anything else, type mismatch.
.91e6					_IntegerCode:
.91e6	b5 58		lda $58,x			lda		NSMantissa0,x
.91e8	35 59		and $59,x			and 		NSMantissa0+1,x
.91ea	95 58		sta $58,x			sta 	NSMantissa0,x
.91ec	b5 60		lda $60,x			lda		NSMantissa1,x
.91ee	35 61		and $61,x			and 		NSMantissa1+1,x
.91f0	95 60		sta $60,x			sta 	NSMantissa1,x
.91f2	b5 68		lda $68,x			lda		NSMantissa2,x
.91f4	35 69		and $69,x			and 		NSMantissa2+1,x
.91f6	95 68		sta $68,x			sta 	NSMantissa2,x
.91f8	b5 70		lda $70,x			lda		NSMantissa3,x
.91fa	35 71		and $71,x			and 		NSMantissa3+1,x
.91fc	95 70		sta $70,x			sta 	NSMantissa3,x
.91fe	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9200	60		rts				rts
.9201					OraInteger:
.9201	fa		plx				plx
.9202	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9204	15 51		ora $51,x			ora 	NSStatus+1,x
.9206	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9207	0a		asl a				asl 	a
.9208	10 05		bpl $920f			bpl 	_NotRef
.920a	48		pha				pha
.920b	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.920e	68		pla				pla
.920f					_NotRef:
.920f	0a		asl a				asl 	a
.9210	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9212	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9214	15 79		ora $79,x			ora 	NSExponent+1,x
.9216	f0 03		beq $921b			beq 	_IntegerCode 				; if clear, then we have two integers
.9218	4c cf 9e	jmp $9ecf			jmp 	TypeError 					; anything else, type mismatch.
.921b					_IntegerCode:
.921b	b5 58		lda $58,x			lda		NSMantissa0,x
.921d	15 59		ora $59,x			ora 		NSMantissa0+1,x
.921f	95 58		sta $58,x			sta 	NSMantissa0,x
.9221	b5 60		lda $60,x			lda		NSMantissa1,x
.9223	15 61		ora $61,x			ora 		NSMantissa1+1,x
.9225	95 60		sta $60,x			sta 	NSMantissa1,x
.9227	b5 68		lda $68,x			lda		NSMantissa2,x
.9229	15 69		ora $69,x			ora 		NSMantissa2+1,x
.922b	95 68		sta $68,x			sta 	NSMantissa2,x
.922d	b5 70		lda $70,x			lda		NSMantissa3,x
.922f	15 71		ora $71,x			ora 		NSMantissa3+1,x
.9231	95 70		sta $70,x			sta 	NSMantissa3,x
.9233	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9235	60		rts				rts
.9236					EorInteger:
.9236	fa		plx				plx
.9237	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9239	15 51		ora $51,x			ora 	NSStatus+1,x
.923b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.923c	0a		asl a				asl 	a
.923d	10 05		bpl $9244			bpl 	_NotRef
.923f	48		pha				pha
.9240	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9243	68		pla				pla
.9244					_NotRef:
.9244	0a		asl a				asl 	a
.9245	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9247	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9249	15 79		ora $79,x			ora 	NSExponent+1,x
.924b	f0 03		beq $9250			beq 	_IntegerCode 				; if clear, then we have two integers
.924d	4c cf 9e	jmp $9ecf			jmp 	TypeError 					; anything else, type mismatch.
.9250					_IntegerCode:
.9250	b5 58		lda $58,x			lda		NSMantissa0,x
.9252	55 59		eor $59,x			eor 		NSMantissa0+1,x
.9254	95 58		sta $58,x			sta 	NSMantissa0,x
.9256	b5 60		lda $60,x			lda		NSMantissa1,x
.9258	55 61		eor $61,x			eor 		NSMantissa1+1,x
.925a	95 60		sta $60,x			sta 	NSMantissa1,x
.925c	b5 68		lda $68,x			lda		NSMantissa2,x
.925e	55 69		eor $69,x			eor 		NSMantissa2+1,x
.9260	95 68		sta $68,x			sta 	NSMantissa2,x
.9262	b5 70		lda $70,x			lda		NSMantissa3,x
.9264	55 71		eor $71,x			eor 		NSMantissa3+1,x
.9266	95 70		sta $70,x			sta 	NSMantissa3,x
.9268	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.926a	60		rts				rts
.926b					WordIndirect:
.926b	fa		plx				plx
.926c	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.926e	15 51		ora $51,x			ora 	NSStatus+1,x
.9270	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9271	0a		asl a				asl 	a
.9272	10 05		bpl $9279			bpl 	_NotRef
.9274	48		pha				pha
.9275	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9278	68		pla				pla
.9279					_NotRef:
.9279	0a		asl a				asl 	a
.927a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.927c	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.927e	15 79		ora $79,x			ora 	NSExponent+1,x
.9280	f0 03		beq $9285			beq 	_IntegerCode 				; if clear, then we have two integers
.9282	4c cf 9e	jmp $9ecf			jmp 	TypeError 					; anything else, type mismatch.
.9285					_IntegerCode:
.9285	20 8b 91	jsr $918b			jsr 	AddCode 					; add the two values
.9288	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.928a	95 50		sta $50,x			sta 	NSStatus,x
.928c	60		rts				rts
.928d					ByteIndirect:
.928d	fa		plx				plx
.928e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9290	15 51		ora $51,x			ora 	NSStatus+1,x
.9292	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9293	0a		asl a				asl 	a
.9294	10 05		bpl $929b			bpl 	_NotRef
.9296	48		pha				pha
.9297	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.929a	68		pla				pla
.929b					_NotRef:
.929b	0a		asl a				asl 	a
.929c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.929e	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92a0	15 79		ora $79,x			ora 	NSExponent+1,x
.92a2	f0 03		beq $92a7			beq 	_IntegerCode 				; if clear, then we have two integers
.92a4	4c cf 9e	jmp $9ecf			jmp 	TypeError 					; anything else, type mismatch.
.92a7					_IntegerCode:
.92a7	20 8b 91	jsr $918b			jsr 	AddCode 					; add the two values
.92aa	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.92ac	95 50		sta $50,x			sta 	NSStatus,x
.92ae	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.92af					LCLConvertInt16:
.92af	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.92b1	86 60		stx $60				stx 	NSMantissa1
.92b3	64 68		stz $68				stz 	NSMantissa2
.92b5	64 70		stz $70				stz 	NSMantissa3
.92b7	64 50		stz $50				stz 	NSStatus 					; positive integer
.92b9	a2 00		ldx #$00			ldx 	#0 							; stack level
.92bb	a9 0a		lda #$0a			lda 	#10 						; base
.92bd	80 00		bra $92bf			bra 	ConvertInt32
.92bf					ConvertInt32:
.92bf	5a		phy				phy
.92c0	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.92c2	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.92c4	10 08		bpl $92ce			bpl 	_CI32NotNeg
.92c6	48		pha				pha
.92c7	a9 2d		lda #$2d			lda 	#'-'
.92c9	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.92cc	c8		iny				iny
.92cd	68		pla				pla
.92ce					_CI32NotNeg:
.92ce	20 dc 92	jsr $92dc			jsr 	_CI32DivideConvert 			; recursive conversion
.92d1	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.92d3	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.92d6	7a		ply				ply
.92d7	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.92d9	a9 7b		lda #$7b			lda 	#NumberBuffer & $FF
.92db	60		rts				rts
.92dc					_CI32DivideConvert:
.92dc	e8		inx				inx 								; write to next slot up
.92dd	20 4f 9d	jsr $9d4f			jsr 	NSMSetByte
.92e0	ca		dex				dex
.92e1	20 0a 90	jsr $900a			jsr 	Int32Divide 				; divide
.92e4	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.92e6	48		pha				pha
.92e7	20 c7 8f	jsr $8fc7			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.92ea	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; is it zero ?
.92ed	f0 05		beq $92f4			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.92ef	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.92f1	20 dc 92	jsr $92dc			jsr 	_CI32DivideConvert 			; and recusrively call.
.92f4					_CI32NoRecurse:
.92f4	68		pla				pla 								; remainder
.92f5	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.92f7	90 02		bcc $92fb			bcc 	_CI32NotHex
.92f9	69 26		adc #$26			adc 	#6+32
.92fb					_CI32NotHex:
.92fb	69 30		adc #$30			adc 	#48
.92fd	99 7b 05	sta $057b,y			sta 	NumberBuffer,y 				; write out and exit
.9300	c8		iny				iny
.9301	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9302					PrecedenceLevel:
>9302	04					.byte	 4	; $00 <<
>9303	02					.byte	 2	; $01 <=
>9304	02					.byte	 2	; $02 <>
>9305	00					.byte	 0	; $03 !!3
>9306	00					.byte	 0	; $04 ><
>9307	02					.byte	 2	; $05 >=
>9308	04					.byte	 4	; $06 >>
>9309	00					.byte	 0	; $07 !!7
>930a	00					.byte	 0	; $08 !!8
>930b	00					.byte	 0	; $09 !!9
>930c	00					.byte	 0	; $0a !!10
>930d	00					.byte	 0	; $0b !!11
>930e	00					.byte	 0	; $0c !!12
>930f	00					.byte	 0	; $0d !!13
>9310	00					.byte	 0	; $0e !!14
>9311	00					.byte	 0	; $0f !!15
>9312	00					.byte	 0	; $10 @
>9313	00					.byte	 0	; $11 !!17
>9314	00					.byte	 0	; $12 !!18
>9315	00					.byte	 0	; $13 [
>9316	04					.byte	 4	; $14 \
>9317	00					.byte	 0	; $15 ]
>9318	01					.byte	 1	; $16 ^
>9319	00					.byte	 0	; $17 _
>931a	00					.byte	 0	; $18 `
>931b	00					.byte	 0	; $19 !!25
>931c	00					.byte	 0	; $1a !!26
>931d	00					.byte	 0	; $1b {
>931e	01					.byte	 1	; $1c |
>931f	00					.byte	 0	; $1d }
>9320	00					.byte	 0	; $1e ~
>9321	00					.byte	 0	; $1f [7m<7F>[m
>9322	00					.byte	 0	; $20
>9323	05					.byte	 5	; $21 !
>9324	00					.byte	 0	; $22 "
>9325	00					.byte	 0	; $23 #
>9326	05					.byte	 5	; $24 $
>9327	04					.byte	 4	; $25 %
>9328	01					.byte	 1	; $26 &
>9329	00					.byte	 0	; $27 '
>932a	00					.byte	 0	; $28 (
>932b	00					.byte	 0	; $29 )
>932c	04					.byte	 4	; $2a *
>932d	03					.byte	 3	; $2b +
>932e	00					.byte	 0	; $2c ,
>932f	03					.byte	 3	; $2d -
>9330	00					.byte	 0	; $2e .
>9331	04					.byte	 4	; $2f /
>9332	00					.byte	 0	; $30 0
>9333	00					.byte	 0	; $31 1
>9334	00					.byte	 0	; $32 2
>9335	00					.byte	 0	; $33 3
>9336	00					.byte	 0	; $34 4
>9337	00					.byte	 0	; $35 5
>9338	00					.byte	 0	; $36 6
>9339	00					.byte	 0	; $37 7
>933a	00					.byte	 0	; $38 8
>933b	00					.byte	 0	; $39 9
>933c	00					.byte	 0	; $3a :
>933d	00					.byte	 0	; $3b ;
>933e	02					.byte	 2	; $3c <
>933f	02					.byte	 2	; $3d =
>9340	02					.byte	 2	; $3e >
>9341	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9342					EvaluateExpressionAt0:
.9342	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9344					EvaluateExpression:
.9344	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9346					EvaluateExpressionAtPrecedence:
.9346	48		pha				pha 								; save precedence level
.9347	20 8e 97	jsr $978e			jsr 	EvaluateTerm 				; evaluate term into level X.
.934a	68		pla				pla 								; restore precedence level.
.934b					_EXPRLoop:
.934b	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.934d	b1 30		lda ($30),y			lda 	(codePtr),y
.934f	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9351	b0 25		bcs $9378			bcs 	_EXPRExit
.9353	da		phx				phx 								; read the operator precedence
.9354	aa		tax				tax
.9355	bd 02 93	lda $9302,x			lda 	PrecedenceLevel,x
.9358	fa		plx				plx
.9359	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.935b	f0 1b		beq $9378			beq 	_EXPRExit
.935d	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.935f	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9361	c5 37		cmp $37				cmp 	zTemp0+1
.9363	b0 13		bcs $9378			bcs		_EXPRExit 					; if current >= operator exit
.9365	48		pha				pha 								; save current precedence.
.9366	b1 30		lda ($30),y			lda 	(codePtr),y
.9368	c8		iny				iny
.9369	48		pha				pha
.936a	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.936c	e8		inx				inx 								; work out the right hand side.
.936d	20 46 93	jsr $9346			jsr 	EvaluateExpressionAtPrecedence
.9370	ca		dex				dex
.9371	68		pla				pla 								; get operator, call the code.
.9372	20 7b 93	jsr $937b			jsr 	_EXPRCaller
.9375	68		pla				pla 								; restore precedence level
.9376	80 d3		bra $934b			bra 	_EXPRLoop 					; and go round.
.9378					_EXPRExit:
.9378	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.937a	60		rts				rts
.937b					_EXPRCaller:
.937b	da		phx				phx 								; save on stack, first thing is to restore it
.937c	0a		asl a				asl 	a 							; double so can use vectors into X
.937d	aa		tax				tax
.937e	7c 02 8b	jmp ($8b02,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9381					FloatingPointAdd:
.9381	20 f7 94	jsr $94f7			jsr 	FloatPrepare 				; prepare for floats
.9384	80 09		bra $938f			bra 	FloatAdd
.9386					FloatingPointSub:
.9386	20 f7 94	jsr $94f7			jsr 	FloatPrepare 				; prepare for floats
.9389					FloatSubtract:
.9389	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.938b	49 80		eor #$80			eor 	#$80
.938d	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.938f					FloatAdd:
.938f	48		pha				pha
.9390	5a		phy				phy
.9391	20 06 95	jsr $9506			jsr 	NSNormalise 				; normalise S[X]
.9394	f0 51		beq $93e7			beq 	_FAReturn1
.9396	e8		inx				inx 								; normalise S[X+1]
.9397	20 06 95	jsr $9506			jsr 	NSNormalise
.939a	ca		dex				dex
.939b	c9 00		cmp #$00			cmp 	#0
.939d	f0 60		beq $93ff			beq 	_FAExit 					; if so, just return A
.939f	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.93a1	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.93a3	f0 18		beq $93bd			beq 	_FAExponentsEqual
.93a5	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.93a7	a8		tay				tay
.93a8	38		sec				sec 								; do a signed comparison of the exponents.
.93a9	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.93ab	50 02		bvc $93af			bvc 	_FANoSignedChange
.93ad	49 80		eor #$80			eor 	#$80
.93af					_FANoSignedChange:
.93af	29 80		and #$80			and 	#$80
.93b1	10 02		bpl $93b5			bpl 	_FAHaveMax
.93b3	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.93b5					_FAHaveMax:
.93b5	20 02 94	jsr $9402			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.93b8	e8		inx				inx
.93b9	20 02 94	jsr $9402			jsr 	_FAShiftToExponent
.93bc	ca		dex				dex
.93bd					_FAExponentsEqual:
.93bd	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.93bf	55 51		eor $51,x			eor 	NSStatus+1,x
.93c1	30 0e		bmi $93d1			bmi 	_FADifferentSigns
.93c3	20 3a 91	jsr $913a			jsr 	AddTopTwoStack 				; do the add of the mantissae
.93c6	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.93c8	10 35		bpl $93ff			bpl 	_FAExit 					; if no, we are done.
.93ca	20 66 9d	jsr $9d66			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.93cd	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.93cf	80 2e		bra $93ff			bra 	_FAExit
.93d1					_FADifferentSigns:
.93d1	20 54 91	jsr $9154			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.93d4	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.93d6	10 06		bpl $93de			bpl 	_FACheckZero 				; if no, check for -0
.93d8	20 0f 9d	jsr $9d0f			jsr 	NSMNegate 					; netate result
.93db	20 16 9d	jsr $9d16			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.93de					_FACheckZero:
.93de	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero	 				; check for -0
.93e1	d0 1c		bne $93ff			bne 	_FAExit
.93e3	74 50		stz $50,x			stz 	NSStatus,x
.93e5	80 18		bra $93ff			bra 	_FAExit
.93e7					_FAReturn1:
.93e7	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.93e9	95 58		sta $58,x			sta 	NSMantissa0,x
.93eb	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.93ed	95 60		sta $60,x			sta 	NSMantissa1,x
.93ef	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.93f1	95 68		sta $68,x			sta 	NSMantissa2,x
.93f3	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.93f5	95 70		sta $70,x			sta 	NSMantissa3,x
.93f7	b5 79		lda $79,x			lda 	NSExponent+1,x
.93f9	95 78		sta $78,x			sta 	NSExponent,x
.93fb	b5 51		lda $51,x			lda 	NSStatus+1,x
.93fd	95 50		sta $50,x			sta 	NSStatus,x
.93ff					_FAExit:
.93ff	7a		ply				ply
.9400	68		pla				pla
.9401	60		rts				rts
.9402					_FAShiftToExponent:
.9402					_FAShiftToExponent2:
.9402	98		tya				tya 								; compare Y to exponent
.9403	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9405	f0 07		beq $940e			beq 	_FASEExit 					; exit if so.
.9407	20 66 9d	jsr $9d66			jsr 	NSMShiftRight	 			; shift the mantissa right
.940a	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.940c	80 f4		bra $9402			bra 	_FAShiftToExponent2
.940e					_FASEExit:
.940e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.940f					CompareFloat:
.940f	20 89 93	jsr $9389			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9412	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9414	29 f8		and #$f8			and 	#$F8
.9416	15 68		ora $68,x			ora 	NSMantissa2,x
.9418	15 70		ora $70,x			ora 	NSMantissa3,x
.941a	f0 08		beq $9424			beq 	_FCExit 					; zero, so approximately identical
.941c	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.941e	34 50		bit $50,x			bit 	NSStatus,x
.9420	10 02		bpl $9424			bpl 	_FCExit
.9422					_FCNegative:
.9422	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9424					_FCExit:
.9424	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9425					FDivideCommand:
.9425	fa		plx				plx	 								; restore stack position
.9426	20 f7 94	jsr $94f7			jsr 	FloatPrepare 				; prepare for floats
.9429					FloatDivide:
.9429	48		pha				pha
.942a	e8		inx				inx
.942b	20 06 95	jsr $9506			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.942e	ca		dex				dex
.942f	c9 00		cmp #$00			cmp 	#0
.9431	f0 1d		beq $9450			beq 	_FDZero
.9433	20 06 95	jsr $9506			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9436	f0 16		beq $944e			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9438	20 2b 90	jsr $902b			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.943b	20 c7 8f	jsr $8fc7			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.943e	20 06 95	jsr $9506			jsr		NSNormalise 				; renormalise
.9441	20 bb 90	jsr $90bb			jsr 	CalculateSign 				; calculate result sign
.9444	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.9446	38		sec				sec
.9447	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9449	38		sec				sec
.944a	e9 1e		sbc #$1e			sbc 	#30
.944c	95 78		sta $78,x			sta 	NSExponent,x
.944e					_FDExit:
.944e	68		pla				pla
.944f	60		rts				rts
.9450					_FDZero:
.9450	a9 03		lda #$03		lda	#3
.9452	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9455					FloatFractionalPart:
.9455	5a		phy				phy
.9456	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9458	29 7f		and #$7f			and 	#$7F
.945a	95 50		sta $50,x			sta 	NSStatus,x
.945c	20 06 95	jsr $9506			jsr 	NSNormalise
.945f	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9461	38		sec				sec
.9462	e9 e0		sbc #$e0			sbc 	#$E0
.9464	90 29		bcc $948f			bcc 	_FFPExit 					; already fractional
.9466	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9468	b0 22		bcs $948c			bcs 	_FFPZero
.946a	a8		tay				tay 								; put count to do in Y
.946b	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.946d	20 91 94	jsr $9491			jsr 	_FFPPartial
.9470	95 70		sta $70,x			sta 	NSMantissa3,x
.9472	b5 68		lda $68,x			lda 	NSMantissa2,x
.9474	20 91 94	jsr $9491			jsr 	_FFPPartial
.9477	95 68		sta $68,x			sta 	NSMantissa2,x
.9479	b5 60		lda $60,x			lda 	NSMantissa1,x
.947b	20 91 94	jsr $9491			jsr 	_FFPPartial
.947e	95 60		sta $60,x			sta 	NSMantissa1,x
.9480	b5 58		lda $58,x			lda 	NSMantissa0,x
.9482	20 91 94	jsr $9491			jsr 	_FFPPartial
.9485	95 58		sta $58,x			sta 	NSMantissa0,x
.9487	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; zeroed check.
.948a	d0 03		bne $948f			bne 	_FFPExit
.948c					_FFPZero:
.948c	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero
.948f					_FFPExit:
.948f	7a		ply				ply
.9490	60		rts				rts
.9491					_FFPPartial:
.9491	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9493	f0 17		beq $94ac			beq 	_FFFPPExit
.9495	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9497	b0 0c		bcs $94a5			bcs 	_FFFPPWholeByte
.9499	5a		phy				phy
.949a					_FFFPPLeft:
.949a	0a		asl a				asl 	a
.949b	88		dey				dey
.949c	d0 fc		bne $949a			bne 	_FFFPPLeft
.949e	7a		ply				ply
.949f					_FFFPPRight:
.949f	4a		lsr a				lsr 	a
.94a0	88		dey				dey
.94a1	d0 fc		bne $949f			bne 	_FFFPPRight
.94a3	80 07		bra $94ac			bra 	_FFFPPExit
.94a5					_FFFPPWholeByte:
.94a5	98		tya				tya 								; subtract 8 from count
.94a6	38		sec				sec
.94a7	e9 08		sbc #$08			sbc 	#8
.94a9	a8		tay				tay
.94aa	a9 00		lda #$00			lda 	#0 							; and clear all
.94ac					_FFFPPExit:
.94ac	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.94ad					FloatIntegerPart:
.94ad	48		pha				pha
.94ae	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.94b0	f0 1d		beq $94cf			beq 	_FIPExit 					; if so do nothing
.94b2	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; is it zero ?
.94b5	f0 15		beq $94cc			beq 	_FIPZero 					; if so return zero.
.94b7	20 06 95	jsr $9506			jsr 	NSNormalise 				; normalise
.94ba	f0 10		beq $94cc			beq 	_FIPZero 					; normalised to zero, exit zero
.94bc					_FIPShift:
.94bc	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.94be	10 07		bpl $94c7			bpl 	_FIPCheckZero
.94c0	20 66 9d	jsr $9d66			jsr 	NSMShiftRight 				; shift mantissa right
.94c3	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.94c5	80 f5		bra $94bc			bra 	_FIPShift
.94c7					_FIPCheckZero:
.94c7	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; avoid -0 problem
.94ca	d0 03		bne $94cf			bne 	_FIPExit 					; set to zero if mantissa zero.
.94cc					_FIPZero:
.94cc	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero
.94cf					_FIPExit:
.94cf	68		pla				pla
.94d0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.94d1					FloatingPointMultiply:
.94d1	20 f7 94	jsr $94f7			jsr 	FloatPrepare 				; prepare for floats
.94d4					FloatMultiply:
.94d4	48		pha				pha
.94d5	20 06 95	jsr $9506			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94d8	f0 18		beq $94f2			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94da	e8		inx				inx
.94db	20 06 95	jsr $9506			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94de	ca		dex				dex
.94df	c9 00		cmp #$00			cmp 	#0
.94e1	f0 0c		beq $94ef			beq 	_FDSetZero
.94e3	20 7d 90	jsr $907d			jsr 	MultiplyShort 				; calculate the result.
.94e6	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.94e8	18		clc				clc
.94e9	75 79		adc $79,x			adc 	NSExponent+1,x
.94eb	95 78		sta $78,x			sta 	NSExponent,x
.94ed	80 03		bra $94f2			bra 	_FDExit
.94ef					_FDSetZero:
.94ef	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero 					; return 0
.94f2					_FDExit:
.94f2	20 06 95	jsr $9506			jsr 	NSNormalise 				; normalise the result
.94f5	68		pla				pla
.94f6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.94f7					FloatPrepare:
.94f7	20 02 96	jsr $9602			jsr 	DereferenceTopTwo 			; dereference the top two values
.94fa	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats
.94fc	15 51		ora $51,x			ora 	NSStatus+1,x
.94fe	29 10		and #$10			and 	#NSBIsString
.9500	d0 01		bne $9503			bne 	_FDType
.9502	60		rts				rts
.9503					_FDType:
.9503	4c cf 9e	jmp $9ecf			jmp 	TypeError
.9506					NSNormalise:
.9506	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.9508	29 80		and #$80			and 	#$80
.950a	09 08		ora #$08			ora 	#NSTFloat
.950c	95 50		sta $50,x			sta 	NSStatus,x
.950e	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; if zero exit
.9511	d0 07		bne $951a			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.9513	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9515	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.9517	a9 00		lda #$00			lda 	#0 							; set Z flag
.9519	60		rts				rts
.951a					_NSNormaliseOptimise:
.951a	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.951c	d0 19		bne $9537			bne 	_NSNormaliseLoop
.951e	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.9520	30 15		bmi $9537			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9522	95 70		sta $70,x			sta 	NSMantissa3,x
.9524	b5 60		lda $60,x			lda 	NSMantissa1,x
.9526	95 68		sta $68,x			sta 	NSMantissa2,x
.9528	b5 58		lda $58,x			lda 	NSMantissa0,x
.952a	95 60		sta $60,x			sta 	NSMantissa1,x
.952c	74 58		stz $58,x			stz 	NSMantissa0,x
.952e	b5 78		lda $78,x			lda 	NSExponent,x
.9530	38		sec				sec
.9531	e9 08		sbc #$08			sbc 	#8
.9533	95 78		sta $78,x			sta 	NSExponent,x
.9535	80 e3		bra $951a			bra 	_NSNormaliseOptimise
.9537					_NSNormaliseLoop:
.9537	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9539	70 07		bvs $9542			bvs 	_NSNExit 					; exit if so with Z flag clear
.953b	20 5c 9d	jsr $9d5c			jsr 	NSMShiftLeft 				; shift mantissa left
.953e	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.9540	80 f5		bra $9537			bra 	_NSNormaliseLoop
.9542					_NSNExit:
.9542	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9544	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9545					AssignNumber:
.9545	5a		phy				phy
.9546	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9548	85 36		sta $36				sta 	zTemp0
.954a	b5 60		lda $60,x			lda 	NSMantissa1,x
.954c	85 37		sta $37				sta 	zTemp0+1
.954e	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9550	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9552	95 50		sta $50,x			sta 	NSStatus,x
.9554	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9556	c9 08		cmp #$08			cmp 	#NSTFloat
.9558	f0 24		beq $957e			beq 	_ANFloat
.955a	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.955c	f0 03		beq $9561			beq		_ANNotFloat
.955e	4c ca 9e	jmp $9eca			jmp 	RangeError
.9561					_ANNotFloat:
.9561	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.9563	29 03		and #$03			and 	#3
.9565	d0 05		bne $956c			bne 	_ANByteWord
.9567	20 89 95	jsr $9589			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.956a	80 1b		bra $9587			bra 	_ANExit
.956c					_ANByteWord:
.956c	48		pha				pha 								; save count
.956d	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.956f	92 36		sta ($36)			sta 	(zTemp0)
.9571	68		pla				pla
.9572	c9 01		cmp #$01			cmp	 	#1
.9574	f0 11		beq $9587			beq 	_ANExit
.9576	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9578	a0 01		ldy #$01			ldy 	#1
.957a	91 36		sta ($36),y			sta 	(zTemp0),y
.957c	80 09		bra $9587			bra 	_ANExit
.957e					_ANFloat:
.957e	20 89 95	jsr $9589			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9581	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9583	a0 04		ldy #$04			ldy 	#4
.9585	91 36		sta ($36),y			sta 	(zTemp0),y
.9587					_ANExit:
.9587	7a		ply				ply
.9588	60		rts				rts
.9589					_ANCopy4PackSign:
.9589	a0 03		ldy #$03			ldy 	#3
.958b	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.958d	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.958f	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9591	91 36		sta ($36),y			sta 	(zTemp0),y
.9593	88		dey				dey
.9594	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9596	91 36		sta ($36),y			sta 	(zTemp0),y
.9598	88		dey				dey
.9599	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.959b	91 36		sta ($36),y			sta 	(zTemp0),y
.959d	88		dey				dey
.959e	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.95a0	91 36		sta ($36),y			sta 	(zTemp0),y
.95a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95a3					AssignString:
.95a3	5a		phy				phy
.95a4	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.95a6	85 38		sta $38				sta 	zTemp1
.95a8	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.95aa	85 39		sta $39				sta 	zTemp1+1
.95ac	b5 58		lda $58,x			lda 	NSMantissa0,x
.95ae	85 36		sta $36				sta 	zTemp0
.95b0	b5 60		lda $60,x			lda 	NSMantissa1,x
.95b2	85 37		sta $37				sta 	zTemp0+1
.95b4	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.95b6	b1 36		lda ($36),y			lda 	(zTemp0),y
.95b8	f0 23		beq $95dd			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.95ba	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.95bb	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.95bd	e9 02		sbc #$02			sbc 	#2
.95bf	85 3c		sta $3c				sta 	zsTemp
.95c1	a0 01		ldy #$01			ldy 	#1
.95c3	b1 36		lda ($36),y			lda 	(zTemp0),y
.95c5	e9 00		sbc #$00			sbc 	#0
.95c7	85 3d		sta $3d				sta 	zsTemp+1
.95c9	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.95cb					_ASGetLength:
.95cb	c8		iny				iny
.95cc	b1 38		lda ($38),y			lda 	(zTemp1),y
.95ce	d0 fb		bne $95cb			bne 	_ASGetLength
.95d0	98		tya				tya 								; is this length <= current length
.95d1	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.95d3	90 1e		bcc $95f3			bcc 	_ASCopyString
.95d5	f0 1c		beq $95f3			beq 	_ASCopyString
.95d7	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.95d9	a0 01		ldy #$01			ldy 	#1
.95db	91 3c		sta ($3c),y			sta 	(zsTemp),y
.95dd					_ASNewStringRequired:
.95dd	e8		inx				inx 								; concrete the new string.
.95de	20 fc a5	jsr $a5fc			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.95e1	ca		dex				dex
.95e2	18		clc				clc
.95e3	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.95e5	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.95e7	92 36		sta ($36)			sta 	(zTemp0)
.95e9	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.95eb	69 00		adc #$00			adc 	#0
.95ed	a0 01		ldy #$01			ldy 	#1
.95ef	91 36		sta ($36),y			sta 	(zTemp0),y
.95f1	80 0d		bra $9600			bra 	_ASExit
.95f3					_ASCopyString:
.95f3	a0 00		ldy #$00			ldy 	#0
.95f5					_ASCopyLoop:
.95f5	b1 38		lda ($38),y			lda 	(zTemp1),y
.95f7	c8		iny				iny
.95f8	c8		iny				iny
.95f9	91 3c		sta ($3c),y			sta 	(zsTemp),y
.95fb	88		dey				dey
.95fc	c9 00		cmp #$00			cmp 	#0
.95fe	d0 f5		bne $95f5			bne 	_ASCopyLoop
.9600					_ASExit:
.9600	7a		ply				ply
.9601	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9602					DereferenceTopTwo:
.9602	e8		inx				inx
.9603	20 07 96	jsr $9607			jsr 	Dereference 				; deref x+1
.9606	ca		dex				dex  								; falls through to deref x
.9607					Dereference:
.9607	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.9609	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.960b	f0 48		beq $9655			beq 	_DRFExit 					; not a reference, so exit.
.960d	5a		phy				phy
.960e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9610	85 36		sta $36				sta 	zTemp0
.9612	b5 60		lda $60,x			lda 	NSMantissa1,x
.9614	85 37		sta $37				sta 	zTemp0+1
.9616	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.9618	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.961a	95 58		sta $58,x			sta 	NSMantissa0,x
.961c	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.961e	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9620	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9622	f0 0e		beq $9632			beq 	_DRFDereferenceTwo
.9624	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9626	f0 2f		beq $9657			beq 	_DRFFull
.9628	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.962a	29 03		and #$03			and 	#3
.962c	f0 29		beq $9657			beq 	_DRFFull 					; the whole word
.962e	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9630	f0 06		beq $9638			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9632					_DRFDereferenceTwo:
.9632	a0 01		ldy #$01			ldy 	#1
.9634	b1 36		lda ($36),y			lda 	(zTemp0),y
.9636	95 60		sta $60,x			sta 	NSMantissa1,x
.9638					_DRFClear23:
.9638	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.963a	74 70		stz $70,x			stz 	NSMantissa3,x
.963c	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.963e	29 18		and #$18			and 	#NSBTypeMask
.9640	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9642	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9644	d0 0e		bne $9654			bne 	_DRFNotString
.9646	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9648	15 60		ora $60,x			ora 	NSMantissa1,x
.964a	d0 08		bne $9654			bne 	_DRFNotString
.964c	a9 56		lda #$56			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.964e	95 58		sta $58,x			sta 	NSMantissa0,X
.9650	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.9652	95 60		sta $60,x			sta 	NSMantissa1,X
.9654					_DRFNotString
.9654	7a		ply				ply 								; restore Y and exit
.9655					_DRFExit:
.9655	60		rts				rts
.9656					_DRFNullString:
>9656	00						.byte 	0
.9657					_DRFFull:
.9657	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9659	b1 36		lda ($36),y			lda 	(zTemp0),y
.965b	95 60		sta $60,x			sta 	NSMantissa1,x
.965d	c8		iny				iny
.965e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9660	95 68		sta $68,x			sta 	NSMantissa2,x
.9662	c8		iny				iny
.9663	b1 36		lda ($36),y			lda 	(zTemp0),y
.9665	95 70		sta $70,x			sta 	NSMantissa3,x
.9667	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.9669	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.966b	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.966d	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.966f	f0 05		beq $9676			beq 	_DRFNoExponent
.9671	c8		iny				iny 								; if not, read the exponent as well.
.9672	b1 36		lda ($36),y			lda 	(zTemp0),y
.9674	95 78		sta $78,x			sta 	NSExponent,x
.9676					_DRFNoExponent:
.9676	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9678	10 0a		bpl $9684			bpl 	_DRFExit2 					; if not, then exit.
.967a	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.967c	95 70		sta $70,x			sta 	NSMantissa3,x
.967e	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9680	09 80		ora #$80			ora 	#NSBIsNegative
.9682	95 50		sta $50,x			sta 	NSStatus,x
.9684					_DRFExit2:
.9684	7a		ply				ply
.9685	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9686					EncodeNumberStart:
.9686	38		sec				sec
.9687	80 01		bra $968a			bra 	EncodeNumberContinue+1
.9689					EncodeNumberContinue:
.9689	18		clc				clc
.968a					EncodeNumber:
.968a	08		php				php 								; save reset flag.
.968b	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.968d	f0 12		beq $96a1			beq 	_ENIsOkay
.968f	c9 30		cmp #$30			cmp 	#"0"
.9691	90 04		bcc $9697			bcc 	_ENBadNumber
.9693	c9 3a		cmp #$3a			cmp 	#"9"+1
.9695	90 0a		bcc $96a1			bcc 	_ENIsOkay
.9697					_ENBadNumber:
.9697	28		plp				plp 								; throw saved reset
.9698	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.969b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.969d	f0 7b		beq $971a			beq 	_ENConstructFinal
.969f					_ENFail:
.969f	18		clc				clc 								; not allowed
.96a0	60		rts				rts
.96a1					_ENIsOkay:
.96a1	28		plp				plp 								; are we restarting
.96a2	90 15		bcc $96b9			bcc 	_ENNoRestart
.96a4					_ENStartEncode:
.96a4	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.96a6	f0 0c		beq $96b4			beq 	_ENFirstDP
.96a8	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.96aa	20 4f 9d	jsr $9d4f			jsr 	NSMSetByte 					; in single byte mode.
.96ad	a9 01		lda #$01			lda 	#ESTA_Low
.96af					_ENExitChange:
.96af	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.96b2	38		sec				sec
.96b3	60		rts				rts
.96b4					_ENFirstDP:
.96b4	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero 					; clear integer part
.96b7	80 3c		bra $96f5			bra 	_ESTASwitchFloat			; go straight to float and exi
.96b9					_ENNoRestart:
.96b9	48		pha				pha 								; save digit or DP on stack.
.96ba	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.96bd	c9 01		cmp #$01			cmp 	#ESTA_Low
.96bf	f0 09		beq $96ca			beq  	_ESTALowState
.96c1	c9 02		cmp #$02			cmp 	#ESTA_High
.96c3	f0 26		beq $96eb			beq 	_ESTAHighState
.96c5	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96c7	f0 38		beq $9701			beq 	_ESTADecimalState
>96c9	db						.byte 	$DB 						; causes a break in the emulator
.96ca					_ESTALowState:
.96ca	68		pla				pla 								; get value back
.96cb	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.96cd	f0 26		beq $96f5			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.96cf	29 0f		and #$0f			and 	#15 						; make digit
.96d1	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.96d4	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.96d6	0a		asl a				asl 	a
.96d7	0a		asl a				asl 	a
.96d8	75 58		adc $58,x			adc 	NSMantissa0,x
.96da	0a		asl a				asl 	a
.96db	6d 06 04	adc $0406			adc 	DigitTemp
.96de	95 58		sta $58,x			sta 	NSMantissa0,x
.96e0	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.96e2	90 05		bcc $96e9			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.96e4	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.96e6	8d 05 04	sta $0405			sta 	EncodeState
.96e9					_ESTANoSwitch:
.96e9	38		sec				sec
.96ea	60		rts				rts
.96eb					_ESTAHighState:
.96eb	68		pla				pla 								; get value back
.96ec	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.96ee	f0 05		beq $96f5			beq 	_ESTASwitchFloat
.96f0	20 4e 97	jsr $974e			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.96f3	38		sec				sec
.96f4	60		rts				rts
.96f5					_ESTASwitchFloat:
.96f5	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.96f8	e8		inx				inx 								; zero the decimal additive.
.96f9	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero
.96fc	ca		dex				dex
.96fd	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.96ff	80 ae		bra $96af			bra 	_ENExitChange
.9701					_ESTADecimalState:
.9701	68		pla				pla 								; digit.
.9702	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9704	f0 99		beq $969f			beq 	_ENFail
.9706	e8		inx				inx 								; put digit into fractional part of X+1
.9707	20 4e 97	jsr $974e			jsr 	ESTAShiftDigitIntoMantissa
.970a	ca		dex				dex
.970b	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.970e	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.9711	c9 0b		cmp #$0b			cmp 	#11
.9713	f0 02		beq $9717			beq 	_ESTADSFail
.9715	38		sec				sec
.9716	60		rts				rts
.9717					_ESTADSFail:
.9717	4c ca 9e	jmp $9eca			jmp 	RangeError
.971a					_ENConstructFinal:
.971a	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.971d	f0 2d		beq $974c			beq 	_ENCFExit 					; no decimals
.971f	5a		phy				phy
.9720	0a		asl a				asl 	a 							; x 4 and CLC
.9721	0a		asl a				asl 	a
.9722	6d 07 04	adc $0407			adc 	DecimalCount
.9725	a8		tay				tay
.9726	b9 89 9e	lda $9e89,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9729	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.972b	b9 8a 9e	lda $9e8a,y			lda 	DecimalScalarTable-5+1,y
.972e	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9730	b9 8b 9e	lda $9e8b,y			lda 	DecimalScalarTable-5+2,y
.9733	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9735	b9 8c 9e	lda $9e8c,y			lda 	DecimalScalarTable-5+3,y
.9738	95 72		sta $72,x			sta 	NSMantissa3+2,x
.973a	b9 8d 9e	lda $9e8d,y			lda 	DecimalScalarTable-5+4,y
.973d	95 7a		sta $7a,x			sta 	NSExponent+2,x
.973f	a9 08		lda #$08			lda 	#NSTFloat
.9741	95 52		sta $52,x			sta 	NSStatus+2,x
.9743	7a		ply				ply
.9744	e8		inx				inx 								; multiply decimal const by decimal scalar
.9745	20 d4 94	jsr $94d4			jsr 	FloatMultiply
.9748	ca		dex				dex
.9749	20 8f 93	jsr $938f			jsr 	FloatAdd 					; add to integer part.
.974c					_ENCFExit:
.974c	18		clc				clc 								; reject the digit.
.974d	60		rts				rts
.974e					ESTAShiftDigitIntoMantissa:
.974e	29 0f		and #$0f			and 	#15 						; save digit
.9750	48		pha				pha
.9751	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9753	48		pha				pha
.9754	b5 68		lda $68,x			lda 	NSMantissa2,x
.9756	48		pha				pha
.9757	b5 60		lda $60,x			lda 	NSMantissa1,x
.9759	48		pha				pha
.975a	b5 58		lda $58,x			lda 	NSMantissa0,x
.975c	48		pha				pha
.975d	20 5c 9d	jsr $9d5c			jsr 	NSMShiftLeft 				; x 2
.9760	20 5c 9d	jsr $9d5c			jsr 	NSMShiftLeft 				; x 4
.9763	18		clc				clc 								; pop mantissa and add
.9764	68		pla				pla
.9765	75 58		adc $58,x			adc 	NSMantissa0,x
.9767	95 58		sta $58,x			sta 	NSMantissa0,x
.9769	68		pla				pla
.976a	75 60		adc $60,x			adc 	NSMantissa1,x
.976c	95 60		sta $60,x			sta 	NSMantissa1,x
.976e	68		pla				pla
.976f	75 68		adc $68,x			adc 	NSMantissa2,x
.9771	95 68		sta $68,x			sta 	NSMantissa2,x
.9773	68		pla				pla
.9774	75 70		adc $70,x			adc 	NSMantissa3,x
.9776	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9778	20 5c 9d	jsr $9d5c			jsr 	NSMShiftLeft 				; x 10
.977b	68		pla				pla 								; add digit
.977c	18		clc				clc
.977d	75 58		adc $58,x			adc 	NSMantissa0,x
.977f	95 58		sta $58,x			sta 	NSMantissa0,x
.9781	90 0a		bcc $978d			bcc 	_ESTASDExit
.9783	f6 60		inc $60,x			inc 	NSMantissa1,x
.9785	d0 06		bne $978d			bne 	_ESTASDExit
.9787	f6 68		inc $68,x			inc 	NSMantissa2,x
.9789	d0 02		bne $978d			bne 	_ESTASDExit
.978b	f6 70		inc $70,x			inc 	NSMantissa3,x
.978d					_ESTASDExit:
.978d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.978e					EvaluateTerm:
.978e	b1 30		lda ($30),y			lda 	(codePtr),y
.9790	30 18		bmi $97aa			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9792	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9794	b0 6c		bcs $9802			bcs 	_ETVariable
.9796	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9798	90 6b		bcc $9805			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.979a	c9 3a		cmp #$3a			cmp 	#'9'+1
.979c	b0 67		bcs $9805			bcs 	_ETPuncUnary
.979e	20 86 96	jsr $9686			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.97a1					_ETNumber:
.97a1	c8		iny				iny 								; keep encoding until we have the numbers
.97a2	b1 30		lda ($30),y			lda 	(codePtr),y
.97a4	20 89 96	jsr $9689			jsr 	EncodeNumberContinue
.97a7	b0 f8		bcs $97a1			bcs 	_ETNumber 					; go back if accepted.
.97a9	60		rts				rts
.97aa					_ETCheckUnary:
.97aa	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.97ac	f0 3f		beq $97ed			beq 	_ETString
.97ae	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.97b0	f0 12		beq $97c4			beq 	_ETHexConstant
.97b2	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.97b4	90 0b		bcc $97c1			bcc 	_ETSyntaxError
.97b6	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.97b8	b0 07		bcs $97c1			bcs 	_ETSyntaxError
.97ba	da		phx				phx 								; push X on the stack
.97bb	0a		asl a				asl 	a 							; put vector x 2 into X
.97bc	aa		tax				tax
.97bd	c8		iny				iny 								; consume unary function token
.97be	7c 82 8b	jmp ($8b82,x)			jmp 	(VectorSet0,x) 				; and do it.
.97c1					_ETSyntaxError:
.97c1	4c c5 9e	jmp $9ec5			jmp 	SyntaxError
.97c4					_ETHexConstant:
.97c4	c8		iny				iny 								; skip #
.97c5	c8		iny				iny 								; skip count
.97c6	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero 					; clear result
.97c9					_ETHLoop:
.97c9	b1 30		lda ($30),y			lda 	(codePtr),y
.97cb	c8		iny				iny 								; and consume
.97cc	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.97ce	f0 1c		beq $97ec			beq 	_ETHExit
.97d0	48		pha				pha 								; save on stack.
.97d1	20 5c 9d	jsr $9d5c			jsr 	NSMShiftLeft 				; x 2
.97d4	20 5c 9d	jsr $9d5c			jsr 	NSMShiftLeft 				; x 4
.97d7	20 5c 9d	jsr $9d5c			jsr 	NSMShiftLeft 				; x 8
.97da	20 5c 9d	jsr $9d5c			jsr 	NSMShiftLeft 				; x 16
.97dd	68		pla				pla 								; ASCII
.97de	c9 41		cmp #$41			cmp 	#'A'
.97e0	90 02		bcc $97e4			bcc 	_ETHNotChar
.97e2	e9 07		sbc #$07			sbc 	#7
.97e4					_ETHNotChar:
.97e4	29 0f		and #$0f			and 	#15 						; digit now
.97e6	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.97e8	95 58		sta $58,x			sta 	NSMantissa0,x
.97ea	80 dd		bra $97c9			bra 	_ETHLoop 					; go round.
.97ec					_ETHExit:
.97ec	60		rts				rts
.97ed					_ETString:
.97ed	c8		iny				iny 								; look at length
.97ee	b1 30		lda ($30),y			lda 	(codePtr),y
.97f0	48		pha				pha
.97f1	c8		iny				iny 								; first character
.97f2	20 a2 a4	jsr $a4a2			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.97f5	68		pla				pla 								; restore count and save
.97f6	85 36		sta $36				sta 	zTemp0
.97f8	98		tya				tya 								; add length to Y to skip it.
.97f9	18		clc				clc
.97fa	65 36		adc $36				adc 	zTemp0
.97fc	a8		tay				tay
.97fd	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.97ff	95 50		sta $50,x			sta 	NSStatus,x
.9801	60		rts				rts
.9802					_ETVariable:
.9802	4c 57 98	jmp $9857			jmp 	VariableHandler
.9805					_ETPuncUnary:
.9805	c8		iny				iny 								; consume the unary character
.9806	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9808	f0 2b		beq $9835			beq 	_ETUnaryNegate
.980a	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.980c	f0 36		beq $9844			beq 	_ETDereference
.980e	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9810	f0 3e		beq $9850			beq 	_ETParenthesis
.9812	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9814	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9816	f0 06		beq $981e			beq 	_ETIndirection
.9818	e6 36		inc $36				inc 	zTemp0
.981a	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.981c	d0 a3		bne $97c1			bne 	_ETSyntaxError
.981e					_ETIndirection:
.981e	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9820	1a		inc a				inc 	a
.9821	48		pha				pha
.9822	20 8e 97	jsr $978e			jsr 	EvaluateTerm				; evaluate the term
.9825	20 07 96	jsr $9607			jsr 	Dereference 				; dereference it.
.9828	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.982a	d0 06		bne $9832			bne 	_ETTypeMismatch
.982c	68		pla				pla 								; indirection 1-2
.982d	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.982f	95 50		sta $50,x			sta 	NSStatus,x
.9831	60		rts				rts
.9832					_ETTypeMismatch:
.9832	4c cf 9e	jmp $9ecf			jmp 	TypeError
.9835					_ETUnaryNegate:
.9835	20 8e 97	jsr $978e			jsr 	EvaluateTerm				; evaluate the term
.9838	20 07 96	jsr $9607			jsr 	Dereference 				; dereference it.
.983b	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.983d	29 10		and #$10			and 	#NSTString
.983f	d0 f1		bne $9832			bne 	_ETTypeMismatch
.9841	4c 0f 9d	jmp $9d0f			jmp 	NSMNegate  					; just toggles the sign bit.
.9844					_ETDereference:
.9844	20 8e 97	jsr $978e			jsr 	EvaluateTerm				; evaluate the term
.9847	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9849	29 20		and #$20			and 	#NSBIsReference
.984b	f0 e5		beq $9832			beq 	_ETTypeMismatch
.984d	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.984f	60		rts				rts
.9850					_ETParenthesis:
.9850	20 44 93	jsr $9344			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9853	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; check for )
.9856	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9857					VariableHandler:
.9857	b1 30		lda ($30),y			lda 	(codePtr),y
.9859	18		clc				clc
.985a	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.985c	85 37		sta $37				sta 	zTemp0+1
.985e	c8		iny				iny
.985f	b1 30		lda ($30),y			lda 	(codePtr),y
.9861	85 36		sta $36				sta 	zTemp0
.9863	c8		iny				iny
.9864	18		clc				clc									; copy variable address+3 to mantissa
.9865	69 03		adc #$03			adc 	#3
.9867	95 58		sta $58,x			sta 	NSMantissa0,x
.9869	a5 37		lda $37				lda 	zTemp0+1
.986b	69 00		adc #$00			adc 	#0
.986d	95 60		sta $60,x			sta 	NSMantissa1,x
.986f	74 68		stz $68,x			stz 	NSMantissa2,x
.9871	74 70		stz $70,x			stz 	NSMantissa3,x
.9873	74 78		stz $78,x			stz 	NSExponent,x
.9875	5a		phy				phy
.9876	a0 02		ldy #$02			ldy 	#2 							; read type
.9878	b1 36		lda ($36),y			lda 	(zTemp0),y
.987a	7a		ply				ply
.987b	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.987d	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.987f	95 50		sta $50,x			sta 	NSStatus,x
.9881	29 04		and #$04			and 	#NSBIsArray
.9883	d0 01		bne $9886			bne 	_VHArray
.9885	60		rts				rts
.9886					_VHArray:
.9886	e8		inx				inx
.9887	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; get the 1st index.
.988a	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.988c	95 51		sta $51,x			sta 	NSStatus+1,x
.988e	b1 30		lda ($30),y			lda 	(codePtr),y
.9890	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9892	d0 06		bne $989a			bne 	_VHNoSecondIndex
.9894	c8		iny				iny 								; skip the comma
.9895	e8		inx				inx
.9896	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9899	ca		dex				dex
.989a					_VHNoSecondIndex:
.989a	ca		dex				dex 								; set X back.
.989b	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; and check the right bracket.
.989e	5a		phy				phy 								; save position
.989f	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.98a1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98a3	f0 60		beq $9905			beq 	_VHBadIndex
.98a5	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.98a7	85 3e		sta $3e				sta 	zaTemp
.98a9	b5 60		lda $60,x			lda 	NSMantissa1,x
.98ab	85 3f		sta $3f				sta 	zaTemp+1
.98ad	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.98af	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98b1	f0 02		beq $98b5			beq 	_VHHas2Mask
.98b3	a9 ff		lda #$ff			lda 	#$FF
.98b5					_VHHas2Mask:
.98b5	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.98b7	f0 4c		beq $9905			beq 	_VHBadIndex
.98b9	0a		asl a				asl 	a 							; carry will be set if a second index
.98ba	90 08		bcc $98c4			bcc 	_VHCheckFirstIndex
.98bc	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.98be	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98c0	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.98c2	90 41		bcc $9905			bcc 	_VHBadIndex
.98c4					_VHCheckFirstIndex:
.98c4	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.98c6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98c8	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.98ca	90 39		bcc $9905			bcc 	_VHBadIndex
.98cc	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.98ce	64 37		stz $37				stz 	zTemp0+1
.98d0	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.98d2	30 0e		bmi $98e2			bmi 	_VHNoMultiply
.98d4	da		phx				phx
.98d5	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.98d7	48		pha				pha
.98d8	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.98da	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98dc	1a		inc a				inc 	a 							; add 1 for zero base
.98dd	fa		plx				plx
.98de	20 f8 9c	jsr $9cf8			jsr 	Multiply8x8 				; calculate -> Z0
.98e1	fa		plx				plx
.98e2					_VHNoMultiply:
.98e2	18		clc				clc
.98e3	a5 36		lda $36				lda 	zTemp0
.98e5	75 59		adc $59,x			adc 	NSMantissa0+1,x
.98e7	85 36		sta $36				sta 	zTemp0
.98e9	a5 37		lda $37				lda 	zTemp0+1
.98eb	69 00		adc #$00			adc 	#0
.98ed	85 37		sta $37				sta 	zTemp0+1
.98ef	b5 50		lda $50,x			lda 	NSStatus,x
.98f1	20 03 85	jsr $8503			jsr 	ScaleByBaseType
.98f4	18		clc				clc
.98f5	b2 3e		lda ($3e)			lda 	(zaTemp)
.98f7	65 36		adc $36				adc 	zTemp0
.98f9	95 58		sta $58,x			sta 	NSMantissa0,x
.98fb	a0 01		ldy #$01			ldy 	#1
.98fd	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98ff	65 37		adc $37				adc 	zTemp0+1
.9901	95 60		sta $60,x			sta 	NSMantissa1,x
.9903	7a		ply				ply 								; restore position
.9904	60		rts				rts
.9905					_VHBadIndex:
.9905	a9 17		lda #$17		lda	#23
.9907	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.990a					AbsUnary:
.990a	fa		plx				plx 								; restore stack pos
.990b	20 9b 9c	jsr $9c9b			jsr 	EvaluateNumber 				; get a float or int
.990e	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9911	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.9913	29 7f		and #$7f			and 	#$7F
.9915	95 50		sta $50,x			sta 	NSStatus,x
.9917	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9918					AllocUnary:
.9918	fa		plx				plx 								; restore stack pos
.9919	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger		; get bytes required.
.991c	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.991f	da		phx				phx 								; save X/Y
.9920	5a		phy				phy
.9921	8a		txa				txa 								; copy X into Y
.9922	a8		tay				tay
.9923	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size
.9926	aa		tax				tax
.9927	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.992a	20 37 99	jsr $9937			jsr 	AllocateXABytes 			; allocate memory
.992d	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.9930	8a		txa				txa
.9931	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.9934	7a		ply				ply
.9935	fa		plx				plx
.9936	60		rts				rts
.9937					AllocateXABytes:
.9937	5a		phy				phy
.9938	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.993b	84 36		sty $36				sty 	zTemp0
.993d	5a		phy				phy
.993e	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.9941	84 37		sty $37				sty 	zTemp0+1
.9943	5a		phy				phy
.9944	18		clc				clc 								; add to low memory pointer
.9945	6d 0c 04	adc $040c			adc 	lowMemPtr
.9948	8d 0c 04	sta $040c			sta 	lowMemPtr
.994b	8a		txa				txa
.994c	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.994f	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9952	b0 2f		bcs $9983			bcs 	CISSMemory
.9954	20 75 99	jsr $9975			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9957					_ClearMemory:
.9957	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.995a	c5 36		cmp $36				cmp 	zTemp0
.995c	d0 07		bne $9965			bne 	_CMClearNext
.995e	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9961	c5 37		cmp $37				cmp 	zTemp0+1
.9963	f0 0c		beq $9971			beq 	_CMExit
.9965					_CMClearNext:
.9965	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9967	92 36		sta ($36)			sta 	(zTemp0)
.9969	e6 36		inc $36				inc 	zTemp0
.996b	d0 ea		bne $9957			bne 	_ClearMemory
.996d	e6 37		inc $37				inc		zTemp0+1
.996f	80 e6		bra $9957			bra 	_ClearMemory
.9971					_CMExit:
.9971	fa		plx				plx
.9972	68		pla				pla
.9973	7a		ply				ply
.9974	60		rts				rts
.9975					CheckIdentifierStringSpace:
.9975	48		pha				pha
.9976	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9979	18		clc				clc
.997a	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.997c	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.997f	b0 02		bcs $9983			bcs 	CISSMemory
.9981	68		pla				pla
.9982	60		rts				rts
.9983					CISSMemory:
.9983	a9 06		lda #$06		lda	#6
.9985	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9988					AscUnary:
.9988	fa		plx				plx 								; restore stack pos
.9989	20 a5 9c	jsr $9ca5			jsr 	EvaluateString 				; get a string
.998c	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.998e	20 4f 9d	jsr $9d4f			jsr 	NSMSetByte 					; ASC("") will return zero.
.9991	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9994	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9995					FracUnary:
.9995	fa		plx				plx 								; restore stack pos
.9996	20 9b 9c	jsr $9c9b			jsr 	EvaluateNumber 				; get a float or int
.9999	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.999c	b5 50		lda $50,x			lda 	NSStatus,x
.999e	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.99a0	f0 04		beq $99a6			beq 	_IUZero
.99a2	20 55 94	jsr $9455			jsr 	FloatFractionalPart
.99a5	60		rts				rts
.99a6					_IUZero:
.99a6	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero
.99a9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.99aa					IntUnary:
.99aa	fa		plx				plx 								; restore stack pos
.99ab	20 9b 9c	jsr $9c9b			jsr 	EvaluateNumber 				; get a float or int
.99ae	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.99b1	b5 50		lda $50,x			lda 	NSStatus,x
.99b3	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.99b5	f0 03		beq $99ba			beq 	_IUExit
.99b7	20 ad 94	jsr $94ad			jsr 	FloatIntegerPart
.99ba					_IUExit:
.99ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.99bb					LenUnary:
.99bb	fa		plx				plx 								; restore stack pos
.99bc	20 a5 9c	jsr $9ca5			jsr 	EvaluateString 				; get a string
.99bf	5a		phy				phy
.99c0	a0 00		ldy #$00			ldy 	#0 							; find length
.99c2					_LenFind:
.99c2	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.99c4	f0 06		beq $99cc			beq 	_LenExit
.99c6	c8		iny				iny
.99c7	d0 f9		bne $99c2			bne 	_LenFind
.99c9	4c ca 9e	jmp $9eca			jmp 	RangeError 					; string > 255 - no trailing NULL.
.99cc					_LenExit:
.99cc	98		tya				tya		 							; return length
.99cd	20 4f 9d	jsr $9d4f			jsr 	NSMSetByte
.99d0	7a		ply				ply
.99d1	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.99d4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.99d5					Unary_Min:
.99d5	a9 01		lda #$01			lda 	#1
.99d7	80 02		bra $99db			bra 	UnaryMinMaxMain
.99d9					Unary_Max:
.99d9	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.99db					UnaryMinMaxMain:
.99db	fa		plx				plx 								; get index on number stack
.99dc	48		pha				pha 								; save comparator
.99dd	20 92 9c	jsr $9c92			jsr 	EvaluateValue 				; get the first value.
.99e0					_UMMMLoop:
.99e0	b1 30		lda ($30),y			lda 	(codePtr),y
.99e2	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.99e4	f0 22		beq $9a08			beq 	_UMMMDone
.99e6	20 2f 8e	jsr $8e2f			jsr 	CheckComma 					; must be a comma
.99e9	e8		inx				inx
.99ea	20 92 9c	jsr $9c92			jsr 	EvaluateValue
.99ed	ca		dex				dex
.99ee	20 30 9d	jsr $9d30			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.99f1	e8		inx				inx
.99f2	20 30 9d	jsr $9d30			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.99f5	e8		inx				inx
.99f6	20 f7 8e	jsr $8ef7			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.99f9	ca		dex				dex
.99fa	ca		dex				dex
.99fb	85 36		sta $36				sta 	zTemp0 						; save required result
.99fd	68		pla				pla 								; get and save comparator
.99fe	48		pha				pha
.99ff	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a01	d0 dd		bne $99e0			bne 	_UMMMLoop
.9a03	20 0b 9a	jsr $9a0b			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a06	80 d8		bra $99e0			bra 	_UMMMLoop
.9a08					_UMMMDone:
.9a08	68		pla				pla 								; throw the comparator
.9a09	c8		iny				iny 								; skip )
.9a0a	60		rts				rts
.9a0b					ExpCopyAboveDown:
.9a0b	b5 51		lda $51,x			lda 	NSStatus+1,x
.9a0d	95 50		sta $50,x			sta 	NSStatus,x
.9a0f	b5 79		lda $79,x			lda 	NSExponent+1,x
.9a11	95 78		sta $78,x			sta 	NSExponent,x
.9a13	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9a15	95 58		sta $58,x			sta 	NSMantissa0,x
.9a17	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9a19	95 60		sta $60,x			sta 	NSMantissa1,x
.9a1b	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9a1d	95 68		sta $68,x			sta 	NSMantissa2,x
.9a1f	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9a21	95 70		sta $70,x			sta 	NSMantissa3,x
.9a23	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9a24					Unary_Not:
.9a24	fa		plx				plx
.9a25	20 ba 9c	jsr $9cba			jsr 	EvaluateInteger 			; get integer
.9a28	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9a2b	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; zero mantissa ?
.9a2e	f0 04		beq $9a34			beq 	_NotZero
.9a30	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero
.9a33	60		rts				rts
.9a34					_NotZero:
.9a34	4c ad 8e	jmp $8ead			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9a37					Unary_Random:
.9a37	fa		plx				plx
.9a38	20 a9 9a	jsr $9aa9			jsr 	Random32Bit 				; get a random number
.9a3b	20 92 9a	jsr $9a92			jsr 	URCopyToMantissa  			; put in mantissa
.9a3e	b1 30		lda ($30),y			lda 	(codePtr),y
.9a40	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9a42	f0 08		beq $9a4c			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9a44	e8		inx				inx
.9a45	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9a48	ca		dex				dex
.9a49	20 ff 8f	jsr $8fff			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9a4c					_URNoModulus:
.9a4c	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9a4e	74 78		stz $78,x			stz 	NSExponent,x
.9a50	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9a53	60		rts				rts
.9a54					Unary_Rnd:
.9a54	fa		plx				plx
.9a55	20 9b 9c	jsr $9c9b			jsr 	EvaluateNumber 				; number to use.
.9a58	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; closing bracket
.9a5b	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9a5e	f0 26		beq $9a86			beq 	_URCopySeed
.9a60	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9a62	10 1f		bpl $9a83			bpl 	_URDontSeed
.9a64	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9a66	49 17		eor #$17			eor 	#$17
.9a68	8d 08 04	sta $0408			sta 	RandomSeed+0
.9a6b	b5 60		lda $60,x			lda 	NSMantissa1,x
.9a6d	49 a5		eor #$a5			eor 	#$A5
.9a6f	8d 09 04	sta $0409			sta 	RandomSeed+1
.9a72	b5 68		lda $68,x			lda 	NSMantissa2,x
.9a74	49 c2		eor #$c2			eor 	#$C2
.9a76	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9a79	b5 70		lda $70,x			lda 	NSMantissa3,x
.9a7b	49 9d		eor #$9d			eor 	#$9D
.9a7d	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9a80	20 a9 9a	jsr $9aa9			jsr 	Random32Bit
.9a83					_URDontSeed:
.9a83	20 a9 9a	jsr $9aa9			jsr 	Random32Bit 				; generate a number
.9a86					_URCopySeed:
.9a86	20 92 9a	jsr $9a92			jsr 	URCopyToMantissa 			; copy into mantissa
.9a89	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9a8b	95 78		sta $78,x			sta 	NSExponent,x
.9a8d	a9 08		lda #$08			lda 	#NSTFloat
.9a8f	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9a91	60		rts				rts
.9a92					URCopyToMantissa:
.9a92	ad 08 04	lda $0408			lda 	RandomSeed+0
.9a95	95 58		sta $58,x			sta 	NSMantissa0,x
.9a97	ad 09 04	lda $0409			lda 	RandomSeed+1
.9a9a	95 60		sta $60,x			sta 	NSMantissa1,x
.9a9c	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9a9f	95 68		sta $68,x			sta 	NSMantissa2,x
.9aa1	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9aa4	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9aa6	95 70		sta $70,x			sta 	NSMantissa3,x
.9aa8	60		rts				rts
.9aa9					Random32Bit:
.9aa9	5a		phy				phy
.9aaa	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9aac	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9aaf	d0 03		bne $9ab4			bne 	_Random1
.9ab1	a8		tay				tay 								; if so do it 256 times
.9ab2	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9ab4					_Random1:
.9ab4	0a		asl a				asl 	a 							; LSFR RNG
.9ab5	2e 09 04	rol $0409			rol 	RandomSeed+1
.9ab8	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9abb	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9abe	90 02		bcc $9ac2			bcc 	_Random2
.9ac0	49 c5		eor #$c5			eor 	#$C5
.9ac2					_Random2:
.9ac2	88		dey				dey
.9ac3	d0 ef		bne $9ab4			bne 	_Random1
.9ac5	8d 08 04	sta $0408			sta 	RandomSeed+0
.9ac8	7a		ply				ply
.9ac9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9aca					SgnUnary:
.9aca	fa		plx				plx 								; restore stack pos
.9acb	20 9b 9c	jsr $9c9b			jsr 	EvaluateNumber 				; get a float or int
.9ace	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9ad1	20 6f 9d	jsr $9d6f			jsr 	NSMIsZero 					; if zero
.9ad4	f0 0e		beq $9ae4			beq 	_SGZero  					; return Int Zero
.9ad6	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9ad8	48		pha				pha
.9ad9	a9 01		lda #$01			lda 	#1 							; set to 1
.9adb	20 4f 9d	jsr $9d4f			jsr 	NSMSetByte
.9ade	68		pla				pla
.9adf	29 80		and #$80			and		#$80 						; copy the sign byte out
.9ae1	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9ae3	60		rts				rts
.9ae4	20 4d 9d	jsr $9d4d	_SGZero:jsr 	NSMSetZero
.9ae7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9ae8					ValUnary:
.9ae8	fa		plx				plx 								; restore stack pos
.9ae9	20 fe 9a	jsr $9afe			jsr 	ValMainCode 				; do the main val() code
.9aec	b0 01		bcs $9aef			bcs 	_VUError 					; couldn't convert
.9aee	60		rts				rts
.9aef					_VUError:
.9aef	4c cf 9e	jmp $9ecf			jmp 	TypeError
.9af2					IsValUnary:
.9af2	fa		plx				plx 								; restore stack pos
.9af3	20 fe 9a	jsr $9afe			jsr 	ValMainCode 				; do the main val() code
.9af6	b0 03		bcs $9afb			bcs 	_VUBad
.9af8	4c ad 8e	jmp $8ead			jmp 	ReturnTrue
.9afb					_VUBad:
.9afb	4c b8 8e	jmp $8eb8			jmp 	ReturnFalse
.9afe					ValMainCode:
.9afe	20 a5 9c	jsr $9ca5			jsr 	EvaluateString 				; get a string
.9b01	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; check right bracket present
.9b04					ValEvaluateZTemp0:
.9b04	5a		phy				phy
.9b05	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9b07	f0 17		beq $9b20			beq 	_VMCFail2
.9b09	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9b0b	48		pha				pha 								; save first character
.9b0c	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9b0e	d0 01		bne $9b11			bne 	_VMCStart
.9b10	c8		iny				iny 								; skip over -
.9b11					_VMCStart:
.9b11	38		sec				sec 								; initialise first time round.
.9b12					_VMCNext:
.9b12	c8		iny				iny 								; pre-increment
.9b13	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9b15	f0 0c		beq $9b23			beq 	_VMCSuccess 				; successful.
.9b17	20 8a 96	jsr $968a			jsr 	EncodeNumber 				; send it to the number-builder
.9b1a	90 03		bcc $9b1f			bcc 	_VMCFail 					; if failed, give up.
.9b1c	18		clc				clc 								; next time round, countinue
.9b1d	80 f3		bra $9b12			bra 	_VMCNext
.9b1f					_VMCFail:
.9b1f	68		pla				pla
.9b20					_VMCFail2:
.9b20	7a		ply				ply
.9b21	38		sec				sec
.9b22	60		rts				rts
.9b23					_VMCSuccess:
.9b23	a9 00		lda #$00			lda 	#0 							; construct final
.9b25	20 8a 96	jsr $968a			jsr 	EncodeNumber 				; by sending a duff value.
.9b28	68		pla				pla 								; if it was -ve
.9b29	c9 2d		cmp #$2d			cmp 	#"-"
.9b2b	d0 03		bne $9b30			bne 	_VMCNotNegative
.9b2d	20 0f 9d	jsr $9d0f			jsr		NSMNegate 					; negate it.
.9b30					_VMCNotNegative:
.9b30	7a		ply				ply
.9b31	18		clc				clc
.9b32	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9b33					ChrUnary:
.9b33	fa		plx				plx 								; restore stack pos
.9b34	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger			; get value
.9b37	48		pha				pha
.9b38	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9b3b	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9b3d	20 79 a6	jsr $a679			jsr 	StringTempAllocate
.9b40	68		pla				pla 								; write number to it
.9b41	20 b2 a6	jsr $a6b2			jsr 	StringTempWrite
.9b44	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9b45					SpcUnary:
.9b45	fa		plx				plx 								; restore stack pos
.9b46	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger			; get value
.9b49	5a		phy				phy
.9b4a	48		pha				pha 								; save count
.9b4b	20 79 a6	jsr $a679			jsr 	StringTempAllocate
.9b4e	7a		ply				ply 								; to do count in Y
.9b4f					_SpcLoop:
.9b4f	c0 00		cpy #$00			cpy 	#0
.9b51	f0 08		beq $9b5b			beq 	_SpcExit
.9b53	a9 20		lda #$20			lda 	#32
.9b55	20 b2 a6	jsr $a6b2			jsr 	StringTempWrite
.9b58	88		dey				dey
.9b59	80 f4		bra $9b4f			bra 	_SPCLoop
.9b5b					_SpcExit:
.9b5b	7a		ply				ply
.9b5c	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.9b5f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9b60					Unary_Str:
.9b60	fa		plx				plx
.9b61	20 9b 9c	jsr $9c9b			jsr 	EvaluateNumber  			; get number
.9b64	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; closing bracket
.9b67	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9b69	20 82 9b	jsr $9b82			jsr 	ConvertNumberToString 		; do the conversion.
.9b6c	a9 21		lda #$21			lda		#33 						; create buffer
.9b6e	20 79 a6	jsr $a679			jsr 	StringTempAllocate 			; allocate memory
.9b71	da		phx				phx
.9b72	a2 00		ldx #$00			ldx 	#0
.9b74					_USCopy:
.9b74	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9b77	20 b2 a6	jsr $a6b2			jsr 	StringTempWrite
.9b7a	e8		inx				inx
.9b7b	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9b7e	d0 f4		bne $9b74			bne 	_USCopy
.9b80	fa		plx				plx
.9b81	60		rts				rts
.9b82					ConvertNumberToString:
.9b82	5a		phy				phy 								; save code position
.9b83	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9b86	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9b89	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9b8b	10 09		bpl $9b96			bpl 	_CNTSNotNegative
.9b8d	29 7f		and #$7f			and 	#$7F 						; make +ve
.9b8f	95 50		sta $50,x			sta 	NSStatus,x
.9b91	a9 2d		lda #$2d			lda 	#"-"
.9b93	20 f7 9b	jsr $9bf7			jsr 	WriteDecimalBuffer
.9b96					_CNTSNotNegative:
.9b96	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9b98	f0 12		beq $9bac			beq 	_CNTSNotFloat
.9b9a	e8		inx				inx 								; round up
.9b9b	a9 01		lda #$01			lda 	#1
.9b9d	20 4f 9d	jsr $9d4f			jsr 	NSMSetByte
.9ba0	ca		dex				dex
.9ba1	b5 78		lda $78,x			lda		NSExponent,x
.9ba3	95 79		sta $79,x			sta 	NSExponent+1,x
.9ba5	a9 08		lda #$08			lda 	#NSTFloat
.9ba7	95 51		sta $51,x			sta 	NSStatus+1,x
.9ba9	20 8f 93	jsr $938f			jsr 	FloatAdd
.9bac					_CNTSNotFloat:
.9bac	20 d9 9b	jsr $9bd9			jsr 	MakePlusTwoString
.9baf	20 55 94	jsr $9455			jsr 	FloatFractionalPart 		; get the fractional part
.9bb2	20 06 95	jsr $9506			jsr 	NSNormalise					; normalise , exit if zero
.9bb5	f0 20		beq $9bd7			beq 	_CNTSExit
.9bb7	a9 2e		lda #$2e			lda 	#"."
.9bb9	20 f7 9b	jsr $9bf7			jsr 	WriteDecimalBuffer 			; write decimal place
.9bbc					_CNTSDecimal:
.9bbc	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9bbf	30 16		bmi $9bd7			bmi 	_CNTSExit
.9bc1	e8		inx				inx 								; x 10.0
.9bc2	a9 0a		lda #$0a			lda 	#10
.9bc4	20 4f 9d	jsr $9d4f			jsr 	NSMSetByte
.9bc7	a9 08		lda #$08			lda 	#NSTFloat
.9bc9	95 50		sta $50,x			sta 	NSStatus,x
.9bcb	ca		dex				dex
.9bcc	20 d4 94	jsr $94d4			jsr 	FloatMultiply
.9bcf	20 d9 9b	jsr $9bd9			jsr 	MakePlusTwoString
.9bd2	20 55 94	jsr $9455			jsr 	FloatFractionalPart 		; get the fractional part
.9bd5	80 e5		bra $9bbc			bra 	_CNTSDecimal 				; keep going.
.9bd7					_CNTSExit:
.9bd7	7a		ply				ply
.9bd8	60		rts				rts
.9bd9					MakePlusTwoString:
.9bd9	da		phx				phx
.9bda	20 30 9d	jsr $9d30			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9bdd	e8		inx				inx 								; access it
.9bde	e8		inx				inx
.9bdf	20 ad 94	jsr $94ad			jsr 	FloatIntegerPart 			; make it an integer
.9be2	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9be4	20 bf 92	jsr $92bf			jsr 	ConvertInt32
.9be7	a2 00		ldx #$00			ldx	 	#0
.9be9					_MPTSCopy:
.9be9	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9bec	20 f7 9b	jsr $9bf7			jsr 	WriteDecimalBuffer
.9bef	e8		inx				inx
.9bf0	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9bf3	d0 f4		bne $9be9			bne 	_MPTSCopy
.9bf5	fa		plx				plx
.9bf6	60		rts				rts
.9bf7					WriteDecimalBuffer:
.9bf7	da		phx				phx
.9bf8	ae 15 04	ldx $0415			ldx 	dbOffset
.9bfb	9d 9d 05	sta $059d,x			sta 	DecimalBuffer,x
.9bfe	9e 9e 05	stz $059e,x			stz 	DecimalBuffer+1,x
.9c01	ee 15 04	inc $0415			inc 	dbOffset
.9c04	fa		plx				plx
.9c05	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9c06					Unary_Left:
.9c06	fa		plx				plx
.9c07	18		clc				clc 								; only one parameter
.9c08	20 6b 9c	jsr $9c6b			jsr 	SubstringInitial 			; set up.
.9c0b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9c0d	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c0f	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9c11	80 25		bra $9c38			bra 	SubstringMain
.9c13					Unary_Right:
.9c13	fa		plx				plx
.9c14	18		clc				clc 								; only one parameter
.9c15	20 6b 9c	jsr $9c6b			jsr 	SubstringInitial 			; set up.
.9c18	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9c1a	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c1c	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9c1e	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9c20	b0 02		bcs $9c24			bcs 	_URNotUnderflow
.9c22	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9c24					_URNotUnderFlow:
.9c24	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9c26	80 10		bra $9c38			bra 	SubStringMain
.9c28					Unary_Mid:
.9c28	fa		plx				plx
.9c29	38		sec				sec 								; two parameters
.9c2a	20 6b 9c	jsr $9c6b			jsr 	SubstringInitial 			; set up.
.9c2d	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9c2f	f0 04		beq $9c35			beq 	_UMError
.9c31	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9c33	80 03		bra $9c38			bra 	SubStringMain
.9c35					_UMError:
.9c35	4c d4 9e	jmp $9ed4			jmp 	ArgumentError
.9c38					SubStringMain:
.9c38	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9c3a	d5 78		cmp $78,x			cmp 	NSExponent,x
.9c3c	b0 27		bcs $9c65			bcs 	_SSMNull 					; if so, return an empty string.
.9c3e	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9c40	f0 23		beq $9c65			beq 	_SSMNull 					; return empty string.
.9c42	18		clc				clc 								; add the offset +1 to the address and
.9c43	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp
.9c45	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9c47	85 36		sta $36				sta 	zTemp0
.9c49	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9c4b	69 00		adc #$00			adc 	#0
.9c4d	85 37		sta $37				sta 	zTemp0+1
.9c4f					_SSMNoCarry:
.9c4f	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9c51	20 79 a6	jsr $a679			jsr 	StringTempAllocate 			; allocate that many characters
.9c54	5a		phy				phy 								; save Y
.9c55	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9c57					_SSMCopy:
.9c57	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9c59	f0 08		beq $9c63			beq 	_SSMEString 				; no more to copy
.9c5b	20 b2 a6	jsr $a6b2			jsr 	StringTempWrite 			; and write it out.
.9c5e	c8		iny				iny
.9c5f	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9c61	d0 f4		bne $9c57			bne 	_SSMCopy
.9c63					_SSMEString:
.9c63	7a		ply				ply
.9c64					_SSMExit:
.9c64	60		rts				rts
.9c65					_SSMNull:
.9c65	a9 00		lda #$00			lda 	#0
.9c67	20 79 a6	jsr $a679			jsr 	StringTempAllocate
.9c6a	60		rts				rts
.9c6b					SubstringInitial:
.9c6b	da		phx				phx 								; save initial stack position
.9c6c	08		php				php 								; save carry on stack indicating 2 parameters
.9c6d	20 a5 9c	jsr $9ca5			jsr 	EvaluateString 				; get a string
.9c70	5a		phy				phy 								; calculate length to exponent.
.9c71	a0 ff		ldy #$ff			ldy 	#$FF
.9c73					_SIFindLength:
.9c73	c8		iny				iny
.9c74	b1 36		lda ($36),y			lda 	(zTemp0),y
.9c76	d0 fb		bne $9c73			bne 	_SIFindLength
.9c78	98		tya				tya
.9c79	95 78		sta $78,x			sta 	NSExponent,x
.9c7b	7a		ply				ply
.9c7c	e8		inx				inx
.9c7d	20 2f 8e	jsr $8e2f			jsr 	CheckComma 					; comma next
.9c80	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; get next parameter
.9c83	28		plp				plp 								; is it the last parameter ?
.9c84	90 07		bcc $9c8d			bcc 	_SSIExit 					; if so, exit.
.9c86	e8		inx				inx
.9c87	20 2f 8e	jsr $8e2f			jsr 	CheckComma 					; comma next
.9c8a	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; get last parameter
.9c8d					_SSIExit:
.9c8d	fa		plx				plx
.9c8e	20 27 8e	jsr $8e27			jsr 	CheckRightBracket 			; check closing bracket
.9c91	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9c92					EvaluateValue:
.9c92	48		pha				pha
.9c93	20 44 93	jsr $9344			jsr		EvaluateExpression 			; expression
.9c96	20 07 96	jsr $9607			jsr 	Dereference					; derefernce it
.9c99	68		pla				pla
.9c9a	60		rts				rts
.9c9b					EvaluateNumber:
.9c9b	20 92 9c	jsr $9c92			jsr 	EvaluateValue 				; get a value
.9c9e	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9ca0	29 10		and #$10			and 	#NSBIsString
.9ca2	d0 13		bne $9cb7			bne 	HelperTypeError
.9ca4	60		rts				rts
.9ca5					EvaluateString:
.9ca5	20 92 9c	jsr $9c92			jsr 	EvaluateValue 				; get a value
.9ca8	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9caa	29 10		and #$10			and 	#NSBIsString
.9cac	f0 09		beq $9cb7			beq 	HelperTypeError
.9cae					CopyAddressToTemp0:
.9cae	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9cb0	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9cb2	b5 60		lda $60,x			lda 	NSMantissa1,x
.9cb4	85 37		sta $37				sta 	zTemp0+1
.9cb6	60		rts				rts
.9cb7					HelperTypeError:
.9cb7	4c cf 9e	jmp $9ecf			jmp 	TypeError
.9cba					EvaluateInteger:
.9cba	20 9b 9c	jsr $9c9b			jsr 	EvaluateNumber
.9cbd	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9cbf	d0 09		bne $9cca			bne 	HelperValueError 			; if not, it's a float.
.9cc1	60		rts				rts
.9cc2					EvaluateUnsignedInteger:
.9cc2	20 ba 9c	jsr $9cba			jsr 	EvaluateInteger 			; check integer is +ve
.9cc5	b5 50		lda $50,x			lda 	NSStatus,x
.9cc7	30 01		bmi $9cca			bmi 	HelperValueError
.9cc9	60		rts				rts
.9cca					HelperValueError:
.9cca	4c d4 9e	jmp $9ed4			jmp 	ArgumentError
.9ccd						Evaluate16BitInteger:
.9ccd	20 c2 9c	jsr $9cc2			jsr	 	EvaluateUnsignedInteger		; get integer
.9cd0	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9cd2	15 68		ora $68,x			ora 	NSMantissa2,x
.9cd4	d0 f4		bne $9cca			bne 	HelperValueError
.9cd6	60		rts				rts
.9cd7					Evaluate16BitIntegerSigned:
.9cd7	20 ba 9c	jsr $9cba			jsr	 	EvaluateInteger				; get integer
.9cda	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9cdc	15 68		ora $68,x			ora 	NSMantissa2,x
.9cde	d0 ea		bne $9cca			bne 	HelperValueError
.9ce0	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9ce2	10 03		bpl $9ce7			bpl 	_EISNotSigned
.9ce4	20 16 9d	jsr $9d16			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9ce7					_EISNotSigned:
.9ce7	60		rts				rts
.9ce8					Evaluate8BitInteger:
.9ce8	20 c2 9c	jsr $9cc2			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9ceb	d0 dd		bne $9cca			bne 	HelperValueError
.9ced	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9cef	15 68		ora $68,x			ora 	NSMantissa2,x
.9cf1	15 60		ora $60,x			ora 	NSMantissa1,x
.9cf3	d0 d5		bne $9cca			bne 	HelperValueError
.9cf5	b5 58		lda $58,x			lda 	NSMantissa0,x
.9cf7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9cf8					Multiply8x8:
.9cf8	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9cf9	85 36		sta $36			  	sta 	zTemp0
.9cfb	86 37		stx $37				stx 	zTemp0+1
.9cfd	a9 00		lda #$00			lda 	#0
.9cff	a2 08		ldx #$08			ldx 	#8
.9d01					_M88Loop:
.9d01	90 03		bcc $9d06			bcc 	_M88NoAdd
.9d03	18		clc				clc
.9d04	65 37		adc $37				adc 	zTemp0+1
.9d06					_M88NoAdd:
.9d06	6a		ror a				ror 	a
.9d07	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9d09	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9d0a	d0 f5		bne $9d01			bne 	_M88Loop
.9d0c	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9d0e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9d0f					NSMNegate:
.9d0f	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9d11	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9d13	95 50		sta $50,x			sta 	NSStatus,x
.9d15	60		rts				rts
.9d16					NSMNegateMantissa:
.9d16	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9d17	a9 00		lda #$00			lda 	#0
.9d19	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9d1b	95 58		sta $58,x			sta 	NSMantissa0,x
.9d1d	a9 00		lda #$00			lda 	#0
.9d1f	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9d21	95 60		sta $60,x			sta 	NSMantissa1,x
.9d23	a9 00		lda #$00			lda 	#0
.9d25	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9d27	95 68		sta $68,x			sta 	NSMantissa2,x
.9d29	a9 00		lda #$00			lda 	#0
.9d2b	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9d2d	95 70		sta $70,x			sta 	NSMantissa3,x
.9d2f	60		rts				rts
.9d30					NSMShiftUpTwo:
.9d30	b5 58		lda $58,x			lda 	NSMantissa0,x
.9d32	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d34	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d36	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9d38	b5 68		lda $68,x			lda 	NSMantissa2,x
.9d3a	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9d3c	b5 70		lda $70,x			lda 	NSMantissa3,x
.9d3e	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9d40	b5 78		lda $78,x			lda 	NSExponent,x
.9d42	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9d44	b5 50		lda $50,x			lda 	NSStatus,x
.9d46	95 52		sta $52,x			sta 	NSStatus+2,x
.9d48	60		rts				rts
.9d49					NSMSetZeroMantissaOnly:
.9d49	a9 00		lda #$00			lda 	#0
.9d4b	80 06		bra $9d53			bra 	NSMSetMantissa
.9d4d					NSMSetZero:
.9d4d	a9 00		lda #$00			lda 	#0
.9d4f					NSMSetByte:
.9d4f	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9d51	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9d53					NSMSetMantissa:
.9d53	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9d55	74 60		stz $60,x			stz 	NSMantissa1,x
.9d57	74 68		stz $68,x			stz 	NSMantissa2,x
.9d59	74 70		stz $70,x			stz 	NSMantissa3,x
.9d5b	60		rts				rts
.9d5c					NSMShiftLeft:
.9d5c	18		clc				clc
.9d5d					NSMRotateLeft:
.9d5d	36 58		rol $58,x			rol 	NSMantissa0,x
.9d5f	36 60		rol $60,x			rol		NSMantissa1,x
.9d61	36 68		rol $68,x			rol		NSMantissa2,x
.9d63	36 70		rol $70,x			rol		NSMantissa3,x
.9d65	60		rts				rts
.9d66					NSMShiftRight:
.9d66	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9d68	76 68		ror $68,x			ror		NSMantissa2,x
.9d6a	76 60		ror $60,x			ror		NSMantissa1,x
.9d6c	76 58		ror $58,x			ror		NSMantissa0,x
.9d6e	60		rts				rts
.9d6f					NSMIsZero:
.9d6f	b5 70		lda $70,x			lda 	NSMantissa3,x
.9d71	15 68		ora $68,x			ora		NSMantissa2,x
.9d73	15 60		ora $60,x			ora		NSMantissa1,x
.9d75	15 58		ora $58,x			ora		NSMantissa0,x
.9d77	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.b90d					TickHandler:
.b90d	5a		phy				phy 								; need to preserve Y
.b90e	20 b3 b8	jsr $b8b3			jsr 	SNDUpdate 					; update sound
.b911	7a		ply				ply
.b912	60		rts				rts
.05af					LastTick:
>05af							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9d78					Assemble_ora:
.9d78	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d7b	01					.byte $01
.9d7c					Assemble_and:
.9d7c	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d7f	21					.byte $21
.9d80					Assemble_eor:
.9d80	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d83	41					.byte $41
.9d84					Assemble_adc:
.9d84	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d87	61					.byte $61
.9d88					Assemble_sta:
.9d88	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d8b	81					.byte $81
.9d8c					Assemble_lda:
.9d8c	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d8f	a1					.byte $a1
.9d90					Assemble_cmp:
.9d90	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d93	c1					.byte $c1
.9d94					Assemble_sbc:
.9d94	20 63 80	jsr $8063		jsr	AssembleGroup1
>9d97	e1					.byte $e1
.9d98					Assemble_asl:
.9d98	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9d9b	02					.byte $02
>9d9c	75					.byte $75
.9d9d					Assemble_rol:
.9d9d	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9da0	22					.byte $22
>9da1	75					.byte $75
.9da2					Assemble_lsr:
.9da2	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9da5	42					.byte $42
>9da6	75					.byte $75
.9da7					Assemble_ror:
.9da7	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9daa	62					.byte $62
>9dab	75					.byte $75
.9dac					Assemble_stx:
.9dac	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9daf	82					.byte $82
>9db0	50					.byte $50
.9db1					Assemble_ldx:
.9db1	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9db4	a2					.byte $a2
>9db5	d0					.byte $d0
.9db6					Assemble_dec:
.9db6	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9db9	c2					.byte $c2
>9dba	55					.byte $55
.9dbb					Assemble_inc:
.9dbb	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dbe	e2					.byte $e2
>9dbf	55					.byte $55
.9dc0					Assemble_stz:
.9dc0	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dc3	60					.byte $60
>9dc4	44					.byte $44
.9dc5					Assemble_bit:
.9dc5	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dc8	20					.byte $20
>9dc9	55					.byte $55
.9dca					Assemble_sty:
.9dca	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dcd	80					.byte $80
>9dce	54					.byte $54
.9dcf					Assemble_ldy:
.9dcf	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dd2	a0					.byte $a0
>9dd3	d5					.byte $d5
.9dd4					Assemble_cpy:
.9dd4	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9dd7	c0					.byte $c0
>9dd8	d4					.byte $d4
.9dd9					Assemble_cpx:
.9dd9	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9ddc	e0					.byte $e0
>9ddd	d0					.byte $d0
.9dde					Assemble_tsb:
.9dde	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9de1	00					.byte $00
>9de2	50					.byte $50
.9de3					Assemble_trb:
.9de3	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9de6	10					.byte $10
>9de7	50					.byte $50
.9de8					Assemble_jsr:
.9de8	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9deb	14					.byte $14
>9dec	10					.byte $10
.9ded					Assemble_jmp:
.9ded	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9df0	40					.byte $40
>9df1	10					.byte $10
.9df2					Assemble_bpl:
.9df2	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9df5	10					.byte $10
.9df6					Assemble_bmi:
.9df6	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9df9	30					.byte $30
.9dfa					Assemble_bvc:
.9dfa	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9dfd	50					.byte $50
.9dfe					Assemble_bvs:
.9dfe	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e01	70					.byte $70
.9e02					Assemble_bcc:
.9e02	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e05	90					.byte $90
.9e06					Assemble_bcs:
.9e06	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e09	b0					.byte $b0
.9e0a					Assemble_bne:
.9e0a	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e0d	d0					.byte $d0
.9e0e					Assemble_beq:
.9e0e	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e11	f0					.byte $f0
.9e12					Assemble_bra:
.9e12	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9e15	80					.byte $80
.9e16					Assemble_brk:
.9e16	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e19	00					.byte $00
.9e1a					Assemble_php:
.9e1a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e1d	08					.byte $08
.9e1e					Assemble_clc:
.9e1e	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e21	18					.byte $18
.9e22					Assemble_plp:
.9e22	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e25	28					.byte $28
.9e26					Assemble_sec:
.9e26	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e29	38					.byte $38
.9e2a					Assemble_rti:
.9e2a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e2d	40					.byte $40
.9e2e					Assemble_pha:
.9e2e	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e31	48					.byte $48
.9e32					Assemble_cli:
.9e32	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e35	58					.byte $58
.9e36					Assemble_phy:
.9e36	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e39	5a					.byte $5a
.9e3a					Assemble_rts:
.9e3a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e3d	60					.byte $60
.9e3e					Assemble_pla:
.9e3e	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e41	68					.byte $68
.9e42					Assemble_sei:
.9e42	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e45	78					.byte $78
.9e46					Assemble_ply:
.9e46	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e49	7a					.byte $7a
.9e4a					Assemble_dey:
.9e4a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e4d	88					.byte $88
.9e4e					Assemble_txa:
.9e4e	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e51	8a					.byte $8a
.9e52					Assemble_tya:
.9e52	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e55	98					.byte $98
.9e56					Assemble_txs:
.9e56	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e59	9a					.byte $9a
.9e5a					Assemble_tay:
.9e5a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e5d	a8					.byte $a8
.9e5e					Assemble_tax:
.9e5e	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e61	aa					.byte $aa
.9e62					Assemble_clv:
.9e62	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e65	b8					.byte $b8
.9e66					Assemble_tsx:
.9e66	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e69	ba					.byte $ba
.9e6a					Assemble_iny:
.9e6a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e6d	c8					.byte $c8
.9e6e					Assemble_dex:
.9e6e	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e71	ca					.byte $ca
.9e72					Assemble_cld:
.9e72	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e75	d8					.byte $d8
.9e76					Assemble_phx:
.9e76	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e79	da					.byte $da
.9e7a					Assemble_stp:
.9e7a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e7d	db					.byte $db
.9e7e					Assemble_inx:
.9e7e	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e81	e8					.byte $e8
.9e82					Assemble_nop:
.9e82	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e85	ea					.byte $ea
.9e86					Assemble_sed:
.9e86	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e89	f8					.byte $f8
.9e8a					Assemble_plx:
.9e8a	20 ef 80	jsr $80ef		jsr	AssembleGroup4
>9e8d	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9e8e					DecimalScalarTable:
>9e8e	66 66 66 66				.dword $66666666 ; 0.1
>9e92	de					.byte $de
>9e93	1f 85 eb 51				.dword $51eb851f ; 0.01
>9e97	db					.byte $db
>9e98	4c 37 89 41				.dword $4189374c ; 0.001
>9e9c	d8					.byte $d8
>9e9d	ac 8b db 68				.dword $68db8bac ; 0.0001
>9ea1	d4					.byte $d4
>9ea2	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9ea6	d1					.byte $d1
>9ea7	83 de 1b 43				.dword $431bde83 ; 1e-06
>9eab	ce					.byte $ce
>9eac	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9eb0	ca					.byte $ca
>9eb1	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9eb5	c7					.byte $c7
>9eb6	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9eba	c4					.byte $c4
>9ebb	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9ebf	c0					.byte $c0
>9ec0	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9ec4	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9ec5					SyntaxError:
.9ec5	a9 02		lda #$02		lda	#2
.9ec7	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.9eca					RangeError:
.9eca	a9 04		lda #$04		lda	#4
.9ecc	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.9ecf					TypeError:
.9ecf	a9 05		lda #$05		lda	#5
.9ed1	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.9ed4					ArgumentError:
.9ed4	a9 07		lda #$07		lda	#7
.9ed6	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.9ed9					NotDoneError:
.9ed9	a9 0c		lda #$0c		lda	#12
.9edb	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.9ede					ErrorText:
>9ede	42 72 65 61 6b 00			.text	"Break",0
>9ee4	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9eec	72 72 6f 72 00
>9ef1	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9ef9	20 62 79 20 7a 65 72 6f 00
>9f02	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9f0a	61 6e 67 65 00
>9f0f	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9f17	6d 61 74 63 68 00
>9f1d	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9f25	65 6d 6f 72 79 00
>9f2b	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>9f33	61 72 67 75 6d 65 6e 74 00
>9f3c	53 74 6f 70 00				.text	"Stop",0
>9f41	53 74 72 69 6e 67 20 74			.text	"String too long",0
>9f49	6f 6f 20 6c 6f 6e 67 00
>9f51	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>9f59	6e 20 66 61 69 6c 65 64 00
>9f62	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>9f6a	61 74 61 00
>9f6e	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>9f76	65 6e 74 65 64 00
>9f7c	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>9f84	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>9f90	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>9f98	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>9fa5	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>9fad	74 68 6f 75 74 20 52 65 70 65 61 74 00
>9fba	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>9fc2	68 6f 75 74 20 57 68 69 6c 65 00
>9fcd	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>9fd5	68 6f 75 74 20 46 6f 72 00
>9fde	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>9fe6	61 63 6b 20 66 75 6c 6c 00
>9fef	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>9ff7	75 63 74 75 72 65 00
>9ffe	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a006	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a013	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a01b	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a029	41 72 72 61 79 20 73 69			.text	"Array size",0
>a031	7a 65 00
>a034	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a03c	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a044	52 65 6c 65 61 73 65 20			.text "Release Alpha 6 (26-Nov-22). "
>a04c	41 6c 70 68 61 20 36 20 28 32 36 2d 4e 6f 76 2d
>a05c	32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a061					RectangleCommand:
.a061	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a063	80 02		bra $a067			bra 	ShapeDrawCmd
.a065					CircleCommand:
.a065	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a067					ShapeDrawCmd:
.a067	20 f1 a0	jsr $a0f1			jsr 	RunGraphicsCommand
.a06a					ShapeDraw:
.a06a	0d b1 05	ora $05b1			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a06d	4c e5 a0	jmp $a0e5			jmp 	ExecuteGraphicCommand	 	; and complete
.a070					SpriteCommand:
.a070	a2 00		ldx #$00			ldx 	#0
.a072	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; get image number.
.a075	5a		phy				phy
.a076	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a078	a6 58		ldx $58				ldx 	NSMantissa0
.a07a	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a07c	b0 0d		bcs $a08b			bcs 	_SCRange
.a07e	a0 ff		ldy #$ff			ldy 	#255
.a080	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a083	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a085	7a		ply				ply
.a086	20 f1 a0	jsr $a0f1			jsr 	RunGraphicsCommand
.a089	80 5a		bra $a0e5			bra 	ExecuteGraphicCommand
.a08b					_SCRange:
.a08b	4c ca 9e	jmp $9eca			jmp 	RangeError
.a08e					ImageCommand:
.a08e	a2 00		ldx #$00			ldx 	#0
.a090	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; get image number.
.a093	20 f1 a0	jsr $a0f1			jsr 	RunGraphicsCommand
.a096					ImageRunDraw:
.a096	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a098	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a09b	ad b7 05	lda $05b7			lda 	gxDrawScale
.a09e	0a		asl a				asl 	a
.a09f	0a		asl a				asl 	a
.a0a0	0a		asl a				asl 	a
.a0a1	a8		tay				tay
.a0a2	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a0a4	a6 58		ldx $58				ldx 	NSMantissa0
.a0a6	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a0a9	60		rts				rts
.a0aa					TextCommand:
.a0aa	a2 00		ldx #$00			ldx 	#0
.a0ac	20 a5 9c	jsr $9ca5			jsr 	EvaluateString 				; get text
.a0af	20 f1 a0	jsr $a0f1			jsr 	RunGraphicsCommand
.a0b2					TextRunDraw:
.a0b2	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a0b4	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a0b7	a0 00		ldy #$00			ldy 	#0
.a0b9					_IRDLoop:
.a0b9	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a0bb	85 37		sta $37				sta 	zTemp0+1
.a0bd	a5 58		lda $58				lda 	NSMantissa0
.a0bf	85 36		sta $36				sta 	zTemp0
.a0c1	b1 36		lda ($36),y			lda 	(zTemp0),y
.a0c3	f0 13		beq $a0d8			beq 	_IRDExit
.a0c5	5a		phy				phy									; save string pos
.a0c6	48		pha				pha 								; save char
.a0c7	ad b7 05	lda $05b7			lda 	gxDrawScale 				; get scale
.a0ca	0a		asl a				asl 	a
.a0cb	0a		asl a				asl 	a
.a0cc	0a		asl a				asl 	a
.a0cd	a8		tay				tay
.a0ce	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a0d0	fa		plx				plx 								; char to draw
.a0d1	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a0d4	7a		ply				ply 								; restore string pos
.a0d5	c8		iny				iny
.a0d6	90 e1		bcc $a0b9			bcc 	_IRDLoop 					; go back if no error.
.a0d8					_IRDExit:
.a0d8	60		rts				rts
.a0d9					PlotCommand:
.a0d9	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a0db	20 f1 a0	jsr $a0f1			jsr 	RunGraphicsCommand
.a0de	80 05		bra $a0e5			bra 	ExecuteGraphicCommand
.a0e0					LineCommand:
.a0e0	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a0e2	20 f1 a0	jsr $a0f1			jsr 	RunGraphicsCommand
.a0e5					ExecuteGraphicCommand:
.a0e5	0d b0 05	ora $05b0			ora 	gxCommandID 				; make a full command
.a0e8	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw 				; draw it and exit
.a0eb	b0 01		bcs $a0ee			bcs 	_EGCError
.a0ed	60		rts				rts
.a0ee					_EGCError:
.a0ee	4c c5 9e	jmp $9ec5			jmp 	SyntaxError
.a0f1					RunGraphicsCommand:
.a0f1	8d b0 05	sta $05b0			sta 	gxCommandID					; save TODO graphics command.
.a0f4	68		pla				pla 								; pop handler address
.a0f5	fa		plx				plx
.a0f6	1a		inc a				inc 	a
.a0f7	d0 01		bne $a0fa			bne 	_RGINoCarry
.a0f9	e8		inx				inx
.a0fa					_RGINoCarry:
.a0fa	8d b5 05	sta $05b5			sta 	GXHandler
.a0fd	8e b6 05	stx $05b6			stx 	GXHandler+1
.a100					_RGICommandLoop:
.a100	b1 30		lda ($30),y			lda 	(codePtr),y
.a102	c8		iny				iny
.a103	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a105	f0 53		beq $a15a			beq 	_RGI_To
.a107	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a109	f0 55		beq $a160			beq 	_RGI_Here
.a10b	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a10d	f0 3d		beq $a14c			beq 	_RGI_Exit
.a10f	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a111	f0 39		beq $a14c			beq 	_RGI_Exit
.a113	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a115	f0 3e		beq $a155			beq 	_RGI_Frame
.a117	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a119	f0 33		beq $a14e			beq 	_RGI_Solid
.a11b	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a11d	f0 4b		beq $a16a			beq 	_RGI_By
.a11f	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a121	f0 17		beq $a13a			beq 	_RGI_Move2
.a123	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a125	f0 62		beq $a189			beq 	_RGI_Dim
.a127	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a129	f0 74		beq $a19f			beq 	_RGI_Colour
.a12b	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a12d	f0 70		beq $a19f			beq 	_RGI_Colour
.a12f	ae b0 05	ldx $05b0			ldx 	gxCommandID
.a132	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a134	d0 03		bne $a139			bne 	_RGI_Move 					; move
.a136	4c c7 a1	jmp $a1c7			jmp		_RGI_SpriteInstructions
.a139					_RGI_Move:
.a139	88		dey				dey 								; unpick get.
.a13a					_RGI_Move2:
.a13a	20 ed a1	jsr $a1ed			jsr 	GCGetCoordinatePair 		; move to here
.a13d	20 14 a2	jsr $a214			jsr 	GCCopyPairToStore 			; save
.a140	5a		phy				phy
.a141	20 0a a2	jsr $a20a			jsr 	GCLoadAXY 					; load in
.a144	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a146	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a149	7a		ply				ply
.a14a	80 b4		bra $a100			bra 	_RGICommandLoop 			; and go round
.a14c					_RGI_Exit:
.a14c	88		dey				dey 								; unpick : / EOL
.a14d	60		rts				rts
.a14e					_RGI_Solid:
.a14e	a9 02		lda #$02			lda 	#2
.a150	8d b1 05	sta $05b1			sta 	gxFillSolid
.a153	80 ab		bra $a100			bra 	_RGICommandLoop
.a155					_RGI_Frame:
.a155	9c b1 05	stz $05b1			stz 	gxFillSolid
.a158	80 a6		bra $a100			bra 	_RGICommandLoop
.a15a					_RGI_To:
.a15a	20 ed a1	jsr $a1ed			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a15d	20 14 a2	jsr $a214			jsr 	GCCopyPairToStore
.a160					_RGI_Here:
.a160	5a		phy				phy
.a161	20 0a a2	jsr $a20a			jsr 	GCLoadAXY 					; load it into AXY
.a164	20 c4 a1	jsr $a1c4			jsr 	_RGICallHandler 			; go do whatever it is.
.a167	7a		ply				ply
.a168	80 96		bra $a100			bra 	_RGICommandLoop 			; and go round
.a16a					_RGI_By:
.a16a	20 fa a1	jsr $a1fa			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a16d	18		clc				clc
.a16e	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a170	6d b2 05	adc $05b2			adc 	gxxPos
.a173	8d b2 05	sta $05b2			sta 	gxXPos
.a176	a5 61		lda $61				lda 	NSMantissa1+1
.a178	6d b3 05	adc $05b3			adc 	gxxPos+1
.a17b	8d b3 05	sta $05b3			sta 	gxXPos+1
.a17e	a5 5a		lda $5a				lda 	NSMantissa0+2
.a180	18		clc				clc
.a181	6d b4 05	adc $05b4			adc 	gxYPos
.a184	8d b4 05	sta $05b4			sta 	gxYPos
.a187	80 d7		bra $a160			bra 	_RGI_Here
.a189					_RGI_Dim:
.a189	a2 01		ldx #$01			ldx	 	#1
.a18b	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger
.a18e	a5 59		lda $59				lda 	NSMantissa0+1
.a190	c9 00		cmp #$00			cmp 	#0
.a192	f0 2d		beq $a1c1			beq 	_RGIRange
.a194	c9 09		cmp #$09			cmp 	#8+1
.a196	b0 29		bcs $a1c1			bcs		_RGIRange
.a198	3a		dec a				dec 	a
.a199	8d b7 05	sta $05b7			sta 	gxDrawScale
.a19c	4c 00 a1	jmp $a100			jmp 	_RGICommandLoop
.a19f					_RGI_Colour:
.a19f	a2 01		ldx #$01			ldx 	#1 							; colour
.a1a1	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger
.a1a4	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a1a6	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero
.a1a9	b1 30		lda ($30),y			lda 	(codePtr),y
.a1ab	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a1ad	d0 04		bne $a1b3			bne 	_RGICDefaultMode
.a1af	c8		iny				iny
.a1b0	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger
.a1b3					_RGICDefaultMode:
.a1b3	5a		phy				phy
.a1b4	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a1b6	a6 59		ldx $59				ldx 	NSMantissa0+1
.a1b8	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a1ba	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a1bd	7a		ply				ply
.a1be	4c 00 a1	jmp $a100			jmp 	_RGICommandLoop 			; and go round
.a1c1					_RGIRange:
.a1c1	4c ca 9e	jmp $9eca			jmp 	RangeError
.a1c4					_RGICallHandler:
.a1c4	6c b5 05	jmp ($05b5)			jmp 	(GXHandler)
.a1c7					_RGI_SpriteInstructions:
.a1c7	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a1c9	f0 07		beq $a1d2			beq 	_RGISpriteOff
.a1cb	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a1cd	f0 13		beq $a1e2			beq 	_RGISetImage
.a1cf	4c 39 a1	jmp $a139			jmp 	_RGI_Move
.a1d2					_RGISpriteOff:
.a1d2	5a		phy				phy
.a1d3	a0 01		ldy #$01			ldy 	#1
.a1d5	a2 00		ldx #$00			ldx 	#0
.a1d7					_RGIDoCommandLoop:
.a1d7	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a1d9	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a1dc	7a		ply				ply
.a1dd	b0 e2		bcs $a1c1			bcs 	_RGIRange
.a1df	4c 00 a1	jmp $a100			jmp 	_RGICommandLoop
.a1e2					_RGISetImage:
.a1e2	a2 01		ldx #$01			ldx 	#1
.a1e4	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger
.a1e7	5a		phy				phy
.a1e8	aa		tax				tax
.a1e9	a0 00		ldy #$00			ldy 	#0
.a1eb	80 ea		bra $a1d7			bra 	_RGIDoCommandLoop
.a1ed					GCGetCoordinatePair:
.a1ed	a2 01		ldx #$01			ldx 	#1
.a1ef	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger
.a1f2	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a1f5	e8		inx				inx
.a1f6	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger
.a1f9	60		rts				rts
.a1fa					GCSignedCoordinatePair:
.a1fa	a2 01		ldx #$01			ldx 	#1
.a1fc	20 d7 9c	jsr $9cd7			jsr 	Evaluate16BitIntegerSigned
.a1ff	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a202	e8		inx				inx
.a203	20 d7 9c	jsr $9cd7			jsr 	Evaluate16BitIntegerSigned
.a206	60		rts				rts
.a207					_GCCPRange:
.a207	4c ca 9e	jmp $9eca			jmp 	RangeError
.a20a					GCLoadAXY:
.a20a	ad b3 05	lda $05b3			lda 	gxXPos+1
.a20d	ae b2 05	ldx $05b2			ldx 	gxXPos
.a210	ac b4 05	ldy $05b4			ldy 	gxYPos
.a213	60		rts				rts
.a214					GCCopyPairToStore:
.a214	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a216	8d b2 05	sta $05b2			sta 	gxXPos
.a219	a5 61		lda $61				lda 	NSMantissa1+1
.a21b	8d b3 05	sta $05b3			sta 	gxXPos+1
.a21e	a5 5a		lda $5a				lda 	NSMantissa0+2
.a220	8d b4 05	sta $05b4			sta 	gxYPos
.a223	60		rts				rts
.05b0					gxCommandID:
>05b0							.fill 	1
.05b1					gxFillSolid:
>05b1							.fill 	1
.05b2					gxXPos:
>05b2							.fill 	2
.05b4					gxYPos:
>05b4							.fill 	1
.05b5					gxHandler:
>05b5							.fill 	2
.05b7					gxDrawScale:
>05b7							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a224					BitmapCtrl:
.a224	b1 30		lda ($30),y			lda 	(codePtr),y
.a226	c8		iny				iny
.a227	a2 01		ldx #$01			ldx 	#1
.a229	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a22b	f0 11		beq $a23e			beq 	BitmapSwitch
.a22d	ca		dex				dex
.a22e	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a230	f0 0c		beq $a23e			beq 	BitmapSwitch
.a232	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; get the colour
.a235	5a		phy				phy
.a236	aa		tax				tax
.a237	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a239	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a23c	7a		ply				ply
.a23d	60		rts				rts
.a23e					BitmapSwitch:
.a23e	5a		phy				phy
.a23f	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a241	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a243	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a246	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a248	a0 00		ldy #$00			ldy 	#0
.a24a	a2 ff		ldx #$ff			ldx 	#$FF
.a24c	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a24f	9c b1 05	stz $05b1			stz 	gxFillSolid
.a252	9c b2 05	stz $05b2			stz 	gxXPos
.a255	9c b3 05	stz $05b3			stz 	gxXPos+1
.a258	9c b4 05	stz $05b4			stz 	gxYPos
.a25b	9c b7 05	stz $05b7			stz 	gxDrawScale
.a25e	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a260	a2 00		ldx #$00			ldx 	#0
.a262	a0 00		ldy #$00			ldy 	#0
.a264	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a267	7a		ply				ply
.a268	60		rts				rts
.a269					SpritesCtrl:
.a269	b1 30		lda ($30),y			lda 	(codePtr),y
.a26b	c8		iny				iny
.a26c	a2 01		ldx #$01			ldx 	#1
.a26e	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a270	f0 08		beq $a27a			beq 	SpriteSwitch
.a272	ca		dex				dex
.a273	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a275	f0 03		beq $a27a			beq 	SpriteSwitch
.a277	4c c5 9e	jmp $9ec5			jmp 	SyntaxError
.a27a					SpriteSwitch:
.a27a	5a		phy				phy
.a27b	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a27d	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a27f	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a282	7a		ply				ply
.a283	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a284					GfxCommand:
.a284	a2 00		ldx #$00			ldx 	#0
.a286	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; command
.a289	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a28c	e8		inx				inx
.a28d	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger 		; X
.a290	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a293	e8		inx				inx
.a294	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; Y
.a297	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a299	4a		lsr a				lsr 	a
.a29a	d0 12		bne $a2ae			bne 	_GfxError
.a29c	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a29e	b0 0e		bcs $a2ae			bcs 	_GfxError 					; bit 7 should have been zero
.a2a0	5a		phy				phy 								; save pos
.a2a1	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a2a3	a6 59		ldx $59				ldx 	NSMantissa0+1
.a2a5	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2a7	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw
.a2aa	b0 02		bcs $a2ae			bcs 	_GfxError
.a2ac	7a		ply				ply 								; restore pos and exit.
.a2ad	60		rts				rts
.a2ae					_GfxError:
.a2ae	4c ca 9e	jmp $9eca			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a2b1					UnaryHit:
.a2b1	fa		plx				plx
.a2b2	a9 36		lda #$36			lda 	#zTemp0
.a2b4	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a2b7	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a2ba	e8		inx				inx
.a2bb	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a2be	20 27 8e	jsr $8e27			jsr		CheckRightBracket
.a2c1	ca		dex				dex 								; fix back up again.
.a2c2	da		phx				phx 								; save X/Y
.a2c3	5a		phy				phy
.a2c4	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a2c6	b5 58		lda $58,x			lda 	NSMantissa0,x
.a2c8	aa		tax				tax
.a2c9	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a2cb	20 c1 a9	jsr $a9c1			jsr 	GXGraphicDraw 				; calculate result
.a2ce	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a2cf	7a		ply				ply 								; restore XY
.a2d0	fa		plx				plx
.a2d1	20 4f 9d	jsr $9d4f			jsr 	NSMSetByte 					; return the hit result
.a2d4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a2d5					PaletteCommand:
.a2d5	a2 00		ldx #$00			ldx 	#0
.a2d7	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; colour
.a2da	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a2dd	e8		inx				inx
.a2de	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger 		; r
.a2e1	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a2e4	e8		inx				inx
.a2e5	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; g
.a2e8	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a2eb	e8		inx				inx
.a2ec	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; b
.a2ef	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a2f1	85 36		sta $36				sta 	zTemp0
.a2f3	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a2f5	85 37		sta $37				sta 	zTemp0+1
.a2f7	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a2f9	26 37		rol $37				rol	 	zTemp0+1
.a2fb	06 36		asl $36				asl 	zTemp0
.a2fd	26 37		rol $37				rol	 	zTemp0+1
.a2ff	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a301	85 01		sta $01				sta 	1
.a303	5a		phy				phy
.a304	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a306	92 36		sta ($36)			sta 	(zTemp0)
.a308	a0 01		ldy #$01			ldy 	#1
.a30a	a5 5a		lda $5a				lda 	NSMantissa0+2
.a30c	91 36		sta ($36),y			sta 	(zTemp0),y
.a30e	a5 59		lda $59				lda 	NSMantissa0+1
.a310	c8		iny				iny
.a311	91 36		sta ($36),y			sta 	(zTemp0),y
.a313	7a		ply				ply
.a314	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a315					UnaryEvent:
.a315	fa		plx				plx
.a316	20 c3 a3	jsr $a3c3			jsr 	TimerToStackX 				; timer in +0
.a319	e8		inx				inx  								; put reference into +1
.a31a	20 8e 97	jsr $978e			jsr 	EvaluateTerm
.a31d	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a31f	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a321	d0 4c		bne $a36f			bne 	_UEType
.a323	e8		inx				inx 								; put the step in +2
.a324	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a327	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger
.a32a	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.a32d	ca		dex				dex
.a32e	ca		dex				dex
.a32f	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a331	85 36		sta $36				sta 	zTemp0
.a333	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a335	85 37		sta $37				sta 	zTemp0+1
.a337	5a		phy				phy
.a338	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a33a	b1 36		lda ($36),y			lda 	(zTemp0),y
.a33c	30 2d		bmi $a36b			bmi 	_UEFalse 					; exit if signed.
.a33e	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a340	b5 58		lda $58,x			lda 	NSMantissa0,x
.a342	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a344	c8		iny				iny
.a345	b5 60		lda $60,x			lda 	NSMantissa1,x
.a347	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a349	c8		iny				iny
.a34a	b5 68		lda $68,x			lda 	NSMantissa2,x
.a34c	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a34e	90 1b		bcc $a36b			bcc 	_UEFalse 					; no, return FALSE.
.a350	18		clc				clc
.a351	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a353	b5 58		lda $58,x			lda 	NSMantissa0,x
.a355	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a357	91 36		sta ($36),y			sta 	(zTemp0),y
.a359	c8		iny				iny
.a35a	b5 60		lda $60,x			lda 	NSMantissa1,x
.a35c	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a35e	91 36		sta ($36),y			sta 	(zTemp0),y
.a360	c8		iny				iny
.a361	b5 68		lda $68,x			lda 	NSMantissa2,x
.a363	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a365	91 36		sta ($36),y			sta 	(zTemp0),y
.a367	7a		ply				ply
.a368	4c ad 8e	jmp $8ead			jmp 	ReturnTrue
.a36b					_UEFalse:
.a36b	7a		ply				ply 								; restore Y
.a36c	4c b8 8e	jmp $8eb8			jmp 	ReturnFalse 				; and return False
.a36f					_UEType:
.a36f	4c cf 9e	jmp $9ecf			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a372					UnaryJoyX:
.a372	18		clc				clc
.a373	80 01		bra $a376			bra 	JoyMain
.a375					UnaryJoyY:
.a375	38		sec				sec
.a376					JoyMain:
.a376	fa		plx				plx 								; get pos
.a377	08		php				php 								; save carry (set for Y)
.a378	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a37b	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.a37e	20 7a a9	jsr $a97a			jsr 	EXTReadController 			; read the controller.
.a381	28		plp				plp
.a382	90 02		bcc $a386			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a384	4a		lsr a				lsr 	a
.a385	4a		lsr a				lsr 	a
.a386					_JMNoShift:
.a386	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a387	b0 0a		bcs $a393			bcs 	_JMIsRight
.a389	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a38a	b0 04		bcs $a390			bcs 	_JMIsLeft
.a38c	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero 					; zero result
.a38f	60		rts				rts
.a390					_JMIsLeft:
.a390	4c ad 8e	jmp $8ead			jmp 	ReturnTrue
.a393					_JMIsRight:
.a393	a9 01		lda #$01			lda 	#1
.a395	20 4f 9d	jsr $9d4f			jsr 	NSMSetByte
.a398	60		rts				rts
.a399					UnaryJoyB:
.a399	fa		plx				plx 								; get pos
.a39a	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a39d	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.a3a0	20 7a a9	jsr $a97a			jsr 	EXTReadController 			; read the controller.
.a3a3	4a		lsr a				lsr 	a
.a3a4	4a		lsr a				lsr 	a
.a3a5	4a		lsr a				lsr 	a
.a3a6	4a		lsr a				lsr 	a
.a3a7	29 01		and #$01			and 	#1
.a3a9	20 4f 9d	jsr $9d4f			jsr 	NSMSetByte
.a3ac	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a3ad					LoadCommand:
.a3ad	20 2e 89	jsr $892e			jsr 	NewProgram
.a3b0	20 d2 82	jsr $82d2			jsr 	BackLoadProgram
.a3b3	4c 6a 83	jmp $836a			jmp 	WarmStart
.a3b6					GoCommand:
.a3b6	20 2e 89	jsr $892e			jsr 	NewProgram
.a3b9	20 d2 82	jsr $82d2			jsr 	BackLoadProgram
.a3bc	4c 6a 8a	jmp $8a6a			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a3bf					UnaryTimer:
.a3bf	fa		plx				plx
.a3c0	20 27 8e	jsr $8e27			jsr 	CheckRightBracket
.a3c3					TimerToStackX:
.a3c3	20 4d 9d	jsr $9d4d			jsr 	NSMSetZero 					; zero result
.a3c6	64 01		stz $01				stz 	1 							; access I/O
.a3c8	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a3cb	95 58		sta $58,x			sta 	NSMantissa0,x
.a3cd	ad 5a d6	lda $d65a			lda 	$D65A
.a3d0	95 60		sta $60,x			sta 	NSMantissa1,x
.a3d2	ad 5b d6	lda $d65b			lda 	$D65B
.a3d5	95 68		sta $68,x			sta 	NSMantissa2,x
.a3d7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a3d8					MemoryDeleteLine:
.a3d8	20 f7 a3	jsr $a3f7			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a3db	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a3dd	a8		tay				tay
.a3de					_MDDLLoop:
.a3de	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a3e0	92 30		sta ($30)			sta 	(codePtr)
.a3e2	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a3e4	c5 3a		cmp $3a				cmp 	zTemp2
.a3e6	d0 07		bne $a3ef			bne 	_MDLDLNext
.a3e8	a5 31		lda $31				lda 	codePtr+1
.a3ea	c5 3b		cmp $3b				cmp 	zTemp2+1
.a3ec	d0 01		bne $a3ef			bne 	_MDLDLNext
.a3ee					_MDDLExit:
.a3ee	60		rts				rts
.a3ef					_MDLDLNext:
.a3ef	e6 30		inc $30				inc 	codePtr						; next byte
.a3f1	d0 eb		bne $a3de			bne 	_MDDLLoop
.a3f3	e6 31		inc $31				inc 	codePtr+1
.a3f5	80 e7		bra $a3de			bra 	_MDDLLoop
.a3f7					IMemoryFindEnd:
.a3f7	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a3f9	85 3a		sta $3a				sta 	0+zTemp2
.a3fb	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a3fd	85 3b		sta $3b				sta 	1+zTemp2
.a3ff					_MDLFELoop:
.a3ff	b2 3a		lda ($3a)			lda 	(zTemp2)
.a401	f0 0b		beq $a40e			beq 	_MDLFEExit
.a403	18		clc				clc
.a404	65 3a		adc $3a				adc 	zTemp2
.a406	85 3a		sta $3a				sta 	zTemp2
.a408	90 f5		bcc $a3ff			bcc 	_MDLFELoop
.a40a	e6 3b		inc $3b				inc 	zTemp2+1
.a40c	80 f1		bra $a3ff			bra 	_MDLFELoop
.a40e					_MDLFEExit:
.a40e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a40f					MemoryInsertLine:
.a40f	08		php				php
.a410	20 f7 a3	jsr $a3f7			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a413	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a415	1a		inc a				inc 	a
.a416	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a418	b0 36		bcs $a450			bcs 	_MDLIError
.a41a	28		plp				plp
.a41b	90 08		bcc $a425			bcc 	_MDLIFound
.a41d	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a41f	85 30		sta $30				sta 	codePtr
.a421	a5 3b		lda $3b				lda 	zTemp2+1
.a423	85 31		sta $31				sta 	codePtr+1
.a425					_MDLIFound:
.a425	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a428	a8		tay				tay
.a429					_MDLIInsert:
.a429	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a42b	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a42d	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a42f	c5 3a		cmp $3a				cmp 	zTemp2
.a431	d0 06		bne $a439			bne 	_MDLINext
.a433	a5 31		lda $31				lda 	codePtr+1
.a435	c5 3b		cmp $3b				cmp 	zTemp2+1
.a437	f0 0a		beq $a443			beq 	_MDLIHaveSpace
.a439					_MDLINext:
.a439	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a43b	d0 02		bne $a43f			bne 	_MDLINoBorrow
.a43d	c6 3b		dec $3b				dec 	zTemp2+1
.a43f					_MDLINoBorrow:
.a43f	c6 3a		dec $3a				dec 	zTemp2
.a441	80 e6		bra $a429			bra 	_MDLIInsert
.a443					_MDLIHaveSpace:
.a443	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a446	88		dey				dey 								; from offset-1 to 0
.a447					_MDLICopy:
.a447	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a44a	91 30		sta ($30),y			sta 	(codePtr),y
.a44c	88		dey				dey
.a44d	10 f8		bpl $a447			bpl 	_MDLICopy
.a44f	60		rts				rts
.a450					_MDLIError:
.a450	a9 06		lda #$06		lda	#6
.a452	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.a455					MDLAppendLine:
.a455	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a457	85 36		sta $36				sta 	zTemp0
.a459	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a45b	85 38		sta $38				sta 	0+zTemp1
.a45d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a45f	85 39		sta $39				sta 	1+zTemp1
.a461	b2 38		lda ($38)			lda 	(zTemp1)
.a463	d0 0a		bne $a46f			bne 	_MDLANoInitialise
.a465	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a467	8d b8 05	sta $05b8			sta 	0+AppendPointer
.a46a	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a46c	8d b9 05	sta $05b9			sta 	1+AppendPointer
.a46f					_MDLANoInitialise:
.a46f	18		clc				clc
.a470	ad b8 05	lda $05b8			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a473	85 38		sta $38				sta 	zTemp1
.a475	72 36		adc ($36)			adc 	(zTemp0)
.a477	8d b8 05	sta $05b8			sta 	AppendPointer
.a47a	ad b9 05	lda $05b9			lda 	AppendPointer+1
.a47d	85 39		sta $39				sta 	zTemp1+1
.a47f	69 00		adc #$00			adc 	#0
.a481	8d b9 05	sta $05b9			sta 	AppendPointer+1
.a484	a0 00		ldy #$00			ldy 	#0
.a486					_MDLACopy:
.a486	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a488	91 38		sta ($38),y			sta 	(zTemp1),y
.a48a	c8		iny				iny
.a48b	98		tya				tya
.a48c	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a48e	d0 f6		bne $a486			bne 	_MDLACopy
.a490	a9 00		lda #$00			lda 	#0 							; end of program.
.a492	91 38		sta ($38),y			sta 	(zTemp1),y
.a494	60		rts				rts
.05b8					AppendPointer:
>05b8							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a495					MemoryNew:
.a495	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a497	85 30		sta $30				sta 	codePtr
.a499	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a49b	85 31		sta $31				sta 	codePtr+1
.a49d	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a49f	92 30		sta ($30)			sta 	(codePtr)
.a4a1	60		rts				rts
.a4a2					MemoryInline:
.a4a2	98		tya				tya 								; put address into stack,x
.a4a3	18		clc				clc  								; get the offset, add codePtr
.a4a4	65 30		adc $30				adc 	codePtr
.a4a6	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a4a8	a5 31		lda $31				lda 	codePtr+1
.a4aa	69 00		adc #$00			adc 	#0
.a4ac	95 60		sta $60,x			sta 	NSMantissa1,x
.a4ae	74 68		stz $68,x			stz 	NSMantissa2,x
.a4b0	74 70		stz $70,x			stz 	NSMantissa3,x
.a4b2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a4b3					MemorySearch:
.a4b3	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a4b5	86 37		stx $37				stx 	zTemp0+1
.a4b7	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4b9	85 30		sta $30				sta 	codePtr
.a4bb	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4bd	85 31		sta $31				sta 	codePtr+1
.a4bf					_MTAXLoop:
.a4bf	b2 30		lda ($30)			lda 	(codePtr)
.a4c1	18		clc				clc
.a4c2	f0 21		beq $a4e5			beq 	_MTAXExit 					; reached end, exit with CC.
.a4c4	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a4c6	b1 30		lda ($30),y			lda 	(codePtr),y
.a4c8	38		sec				sec
.a4c9	e5 36		sbc $36				sbc 	zTemp0
.a4cb	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a4cd	c8		iny				iny 								; do the MSB
.a4ce	b1 30		lda ($30),y			lda 	(codePtr),y
.a4d0	e5 37		sbc $37				sbc 	zTemp0+1
.a4d2	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a4d4	f0 0f		beq $a4e5			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a4d6	b0 0d		bcs $a4e5			bcs 	_MTAXExit 					; current < required exit
.a4d8	18		clc				clc
.a4d9	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a4db	65 30		adc $30				adc 	codePtr
.a4dd	85 30		sta $30				sta 	codePtr
.a4df	90 02		bcc $a4e3			bcc 	_CREExit
.a4e1	e6 31		inc $31				inc 	codePtr+1 					; carry
.a4e3					_CREExit:
.a4e3	80 da		bra $a4bf			bra 	_MTAXLoop
.a4e5					_MTAXExit:
.a4e5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a4e6					UnaryPlaying:
.a4e6	fa		plx				plx
.a4e7	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; get channel #
.a4ea	48		pha				pha
.a4eb	20 27 8e	jsr $8e27			jsr		CheckRightBracket
.a4ee	68		pla				pla
.a4ef	c9 04		cmp #$04			cmp 	#4
.a4f1	b0 0c		bcs $a4ff			bcs 	_UPNotPlaying
.a4f3	09 20		ora #$20			ora 	#$20 						; query playing ?
.a4f5	20 80 b8	jsr $b880			jsr 	SNDCommand
.a4f8	c9 00		cmp #$00			cmp 	#0
.a4fa	f0 03		beq $a4ff			beq 	_UPNotPlaying
.a4fc	4c ad 8e	jmp $8ead			jmp 	ReturnTrue
.a4ff					_UPNotPlaying:
.a4ff	4c b8 8e	jmp $8eb8			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a502					SoundCommand:
.a502	b1 30		lda ($30),y			lda 	(codePtr),y
.a504	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a506	d0 09		bne $a511			bne 	_SNDMain
.a508	c8		iny				iny 								; skip OFF
.a509	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a50b	5a		phy				phy
.a50c	20 80 b8	jsr $b880			jsr 	SNDCommand
.a50f	7a		ply				ply
.a510	60		rts				rts
.a511					_SNDMain:
.a511	a2 00		ldx #$00			ldx 	#0
.a513	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; channel
.a516	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a518	b0 4b		bcs $a565			bcs 	_SndError
.a51a	e8		inx				inx 								; do the rest in slot 1.
.a51b	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a51e	20 cd 9c	jsr $9ccd			jsr 	Evaluate16BitInteger 		; Pitch
.a521	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a523	c9 10		cmp #$10			cmp 	#16
.a525	b0 3e		bcs $a565			bcs 	_SndError
.a527	8d bb 05	sta $05bb			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a52a	b5 58		lda $58,x			lda 	NSMantissa0,x
.a52c	8d ba 05	sta $05ba			sta 	SoundCommandBlock
.a52f	20 2f 8e	jsr $8e2f			jsr 	CheckComma
.a532	20 e8 9c	jsr $9ce8			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a535	8d bd 05	sta $05bd			sta 	SoundCommandBlock+3
.a538	a9 0f		lda #$0f			lda 	#15
.a53a	8d bc 05	sta $05bc			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a53d	9c be 05	stz $05be			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a540	9c bf 05	stz $05bf			stz 	SoundCommandBlock+5
.a543	b1 30		lda ($30),y			lda 	(codePtr),y
.a545	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a547	d0 0e		bne $a557			bne 	_SNDPlay
.a549	c8		iny				iny
.a54a	20 d7 9c	jsr $9cd7			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a54d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a54f	8d be 05	sta $05be			sta 	SoundCommandBlock+4
.a552	b5 60		lda $60,x			lda 	NSMantissa1,x
.a554	8d bf 05	sta $05bf			sta 	SoundCommandBlock+5
.a557					_SNDPlay:
.a557	5a		phy				phy
.a558	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a55a	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a55c	a2 ba		ldx #$ba			ldx 	#(SoundCommandBlock & $FF)
.a55e	a0 05		ldy #$05			ldy 	#(SoundCommandBlock >> 8)
.a560	20 80 b8	jsr $b880			jsr 	SNDCommand
.a563	7a		ply				ply
.a564	60		rts				rts
.a565					_SndError:
.a565	4c ca 9e	jmp $9eca			jmp 	RangeError
.05ba					SoundCommandBlock:
>05ba							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a568					StackPushByte:
.a568	48		pha				pha 								; save byte
.a569	a5 34		lda $34				lda 	BasicStack
.a56b	d0 09		bne $a576			bne 	_SPBNoBorrow
.a56d	c6 35		dec $35				dec 	BasicStack+1
.a56f	48		pha				pha
.a570	a5 35		lda $35				lda 	BasicStack+1
.a572	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a574	90 06		bcc $a57c			bcc 	_SPBMemory
.a576					_SPBNoBorrow:
.a576	c6 34		dec $34				dec 	BasicStack
.a578	68		pla				pla 								; get back and write
.a579	92 34		sta ($34)			sta 	(BasicStack)
.a57b	60		rts				rts
.a57c					_SPBMemory:
.a57c	a9 12		lda #$12		lda	#18
.a57e	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.a581					StackPopByte:
.a581	b2 34		lda ($34)			lda 	(BasicStack)
.a583	e6 34		inc $34				inc 	BasicStack
.a585	d0 02		bne $a589			bne 	_SPBNoCarry
.a587	e6 35		inc $35				inc 	BasicStack+1
.a589					_SPBNoCarry:
.a589	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a58a					StackOpen:
.a58a	48		pha				pha 								; save frame byte
.a58b	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a58d	0a		asl a				asl 	a 							; claim twice this for storage
.a58e	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a590	38		sec				sec 								; so basically subtracting from
.a591	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a593	85 34		sta $34				sta 	basicStack
.a595	b0 08		bcs $a59f			bcs 	_SONoBorrow
.a597	c6 35		dec $35				dec 	basicStack+1
.a599	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a59b	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a59d	90 04		bcc $a5a3			bcc 	_SOMemory
.a59f					_SONoBorrow:
.a59f	68		pla				pla 								; get marker back and write at TOS
.a5a0	92 34		sta ($34)			sta 	(basicStack)
.a5a2	60		rts				rts
.a5a3					_SOMemory:
.a5a3	a9 12		lda #$12		lda	#18
.a5a5	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.a5a8					StackClose:
.a5a8	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a5aa	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a5ac	0a		asl a				asl 	a 							; claim twice this.
.a5ad	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a5af	85 34		sta $34				sta 	basicStack
.a5b1	90 02		bcc $a5b5			bcc 	_SCExit
.a5b3	e6 35		inc $35				inc 	basicStack+1
.a5b5					_SCExit:
.a5b5	60		rts				rts
.a5b6					StackCheckFrame:
.a5b6	48		pha				pha
.a5b7					_StackRemoveLocals:
.a5b7	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a5b9	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a5bb	b0 05		bcs $a5c2			bcs 	_SCNoLocal
.a5bd	20 dd 88	jsr $88dd			jsr 	LocalPopValue
.a5c0	80 f5		bra $a5b7			bra 	_StackRemoveLocals
.a5c2					_SCNoLocal:
.a5c2	68		pla				pla
.a5c3	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a5c5	29 f0		and #$f0			and 	#$F0 						; check type bits
.a5c7	d0 01		bne $a5ca			bne 	_SCFError 					; different, we have structures mixed up
.a5c9	60		rts				rts
.a5ca					_SCFError:
.a5ca	8a		txa				txa 								; report error X
.a5cb	4c 40 8e	jmp $8e40			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a5ce					STKSaveCodePosition:
.a5ce	5a		phy				phy
.a5cf	98		tya				tya 								; save Y
.a5d0	a0 05		ldy #$05			ldy 	#5
.a5d2	91 34		sta ($34),y			sta 	(basicStack),y
.a5d4	88		dey				dey 								; save Code Pointer
.a5d5					_STKSaveLoop:
.a5d5	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a5d8	91 34		sta ($34),y			sta 	(basicStack),y
.a5da	88		dey				dey
.a5db	d0 f8		bne $a5d5			bne 	_STKSaveLoop
.a5dd	7a		ply				ply
.a5de	60		rts				rts
.a5df					STKLoadCodePosition:
.a5df	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a5e1					_STKLoadLoop:
.a5e1	b1 34		lda ($34),y			lda 	(basicStack),y
.a5e3	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a5e6	c8		iny				iny
.a5e7	c0 05		cpy #$05			cpy 	#5
.a5e9	d0 f6		bne $a5e1			bne 	_STKLoadLoop
.a5eb	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a5ed	a8		tay				tay
.a5ee	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a5ef					StackReset:
.a5ef	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a5f1	85 34		sta $34				sta 	0+basicStack
.a5f3	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a5f5	85 35		sta $35				sta 	1+basicStack
.a5f7	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a5f9	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a5fb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a5fc					StringConcrete:
.a5fc	5a		phy				phy 								; save position on stack
.a5fd	20 75 99	jsr $9975			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a600	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a602	85 38		sta $38				sta 	zTemp1
.a604	b5 60		lda $60,x			lda 	NSMantissa1,x
.a606	85 39		sta $39				sta 	zTemp1+1
.a608	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a60a					_SALength:
.a60a	c8		iny				iny
.a60b	b1 38		lda ($38),y			lda 	(zTemp1),y
.a60d	d0 fb		bne $a60a			bne 	_SALength
.a60f	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a611	b0 3d		bcs $a650			bcs 	_SALengthError
.a613	98		tya				tya 				 				; length of the new string
.a614	18		clc				clc
.a615	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a617	90 02		bcc $a61b			bcc 	_SAHaveLength
.a619	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a61b					_SAHaveLength:
.a61b	48		pha				pha 								; save length.
.a61c	38		sec				sec
.a61d	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a61f	6d 0e 04	adc $040e			adc 	StringMemory
.a622	8d 0e 04	sta $040e			sta 	StringMemory
.a625	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a627	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a629	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a62b	6d 0f 04	adc $040f			adc 	StringMemory+1
.a62e	8d 0f 04	sta $040f			sta 	StringMemory+1
.a631	85 3b		sta $3b				sta 	zTemp2+1
.a633	95 60		sta $60,x			sta 	NSMantissa1,x
.a635	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a636	38		sec				sec
.a637	e9 03		sbc #$03			sbc 	#3
.a639	92 3a		sta ($3a)			sta 	(zTemp2)
.a63b	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a63d	a0 01		ldy #$01			ldy 	#1
.a63f	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a641					_SACopyNewString:
.a641	a0 00		ldy #$00			ldy 	#0
.a643					_SACopyNSLoop:
.a643	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a645	c8		iny				iny 								; write two on in string storage
.a646	c8		iny				iny
.a647	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a649	88		dey				dey 								; this makes it one one.
.a64a	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a64c	d0 f5		bne $a643			bne 	_SACopyNSLoop
.a64e	7a		ply				ply
.a64f	60		rts				rts
.a650					_SALengthError:
.a650	a9 09		lda #$09		lda	#9
.a652	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a655					StringSystemInitialise:
.a655	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a657	8d 0e 04	sta $040e			sta 	0+StringMemory
.a65a	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a65c	8d 0f 04	sta $040f			sta 	1+StringMemory
.a65f	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a662	60		rts				rts
.a663					StringSpaceInitialise:
.a663	20 75 99	jsr $9975			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a666	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a668	8d 10 04	sta $0410			sta 	StringInitialised
.a66b	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a66e	8d 11 04	sta $0411			sta 	StringTempPointer
.a671	ad 0f 04	lda $040f			lda 	StringMemory+1
.a674	3a		dec a				dec 	a
.a675	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a678	60		rts				rts
.a679					StringTempAllocate:
.a679	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a67b	b0 30		bcs $a6ad			bcs 	_STALength
.a67d	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a680	30 05		bmi $a687			bmi 	_STAAllocate
.a682	48		pha				pha 								; save value to subtract.
.a683	20 63 a6	jsr $a663			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a686	68		pla				pla 								; restore it
.a687					_STAAllocate:
.a687	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a689	18		clc				clc  								; deliberate allows one more
.a68a	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a68d	8d 11 04	sta $0411			sta 	StringTempPointer
.a690	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a692	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a694	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a697	69 ff		adc #$ff			adc 	#$FF
.a699	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a69c	85 3d		sta $3d				sta 	zsTemp+1
.a69e	95 60		sta $60,x			sta 	NSMantissa1,x
.a6a0	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data
.a6a2	74 70		stz $70,x			stz 	NSMantissa3,x
.a6a4	a9 10		lda #$10			lda 	#NSTString
.a6a6	95 50		sta $50,x			sta 	NSStatus,x
.a6a8	a9 00		lda #$00			lda 	#0 							; clear the target string
.a6aa	92 3c		sta ($3c)			sta 	(zsTemp)
.a6ac	60		rts				rts
.a6ad					_STALength:
.a6ad	a9 09		lda #$09		lda	#9
.a6af	4c 40 8e	jmp $8e40		jmp	ErrorHandler
.a6b2					StringTempWrite:
.a6b2	48		pha				pha
.a6b3	92 3c		sta ($3c)			sta 	(zsTemp)
.a6b5	e6 3c		inc $3c				inc 	zsTemp
.a6b7	d0 02		bne $a6bb			bne 	_STWNoCarry
.a6b9	e6 3d		inc $3d				inc 	zsTemp+1
.a6bb					_STWNoCarry:
.a6bb	a9 00		lda #$00			lda 	#0
.a6bd	92 3c		sta ($3c)			sta 	(zsTemp)
.a6bf	68		pla				pla
.a6c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=9					CLINumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a6c1					EXTPrintCharacter:
.a6c1	48		pha				pha
.a6c2	da		phx				phx
.a6c3	5a		phy				phy
.a6c4	a6 01		ldx $01				ldx 	1
.a6c6	da		phx				phx
.a6c7	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a6ca	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a6cc	30 48		bmi $a716			bmi 	_EXPCColour
.a6ce	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a6d0	90 4d		bcc $a71f			bcc 	_EXPCControl
.a6d2	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a6d4	86 01		stx $01				stx 	1
.a6d6	91 40		sta ($40),y			sta 	(EXTAddress),y
.a6d8	e6 01		inc $01				inc 	1 							; select colour memory
.a6da	ad c2 05	lda $05c2			lda 	EXTTextColour
.a6dd	91 40		sta ($40),y			sta 	(EXTAddress),y
.a6df	c8		iny				iny 								; advance horizontal position
.a6e0	8c c1 05	sty $05c1			sty 	EXTColumn
.a6e3	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; reached RHS ?
.a6e6	90 66		bcc $a74e			bcc 	_EXPCExit 					; no, then exit.
.a6e8					_EXPCCRLF:
.a6e8	ee c0 05	inc $05c0			inc 	EXTRow  					; bump row
.a6eb	9c c1 05	stz $05c1			stz 	EXTColumn 					; back to column 0
.a6ee	ad c0 05	lda $05c0			lda 	EXTRow 						; check if reached the bottom ?
.a6f1	cd c4 05	cmp $05c4			cmp 	EXTScreenHeight 			; if so, then scroll.
.a6f4	f0 18		beq $a70e			beq 	_EXPCScroll
.a6f6	18		clc				clc 								; add width to address.
.a6f7	a5 40		lda $40				lda 	EXTAddress
.a6f9	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a6fc	85 40		sta $40				sta 	EXTAddress
.a6fe	90 4e		bcc $a74e			bcc 	_EXPCExit
.a700	e6 41		inc $41				inc 	EXTAddress+1
.a702	80 4a		bra $a74e			bra 	_EXPCExit
.a704					_EXPCLeft:
.a704	ce c1 05	dec $05c1			dec 	EXTColumn
.a707	10 45		bpl $a74e			bpl 	_EXPCExit
.a709					_EXPCBegin:
.a709	9c c1 05	stz $05c1			stz 	EXTColumn
.a70c	80 40		bra $a74e			bra 	_EXPCExit
.a70e					_EXPCScroll:
.a70e	ce c0 05	dec $05c0			dec 	EXTRow 						; the height-1 th line.
.a711	20 db a7	jsr $a7db			jsr 	EXTScreenScroll 			; scroll the screen
.a714	80 38		bra $a74e			bra 	_EXPCExit
.a716					_EXPCColour:
.a716	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a718	b0 34		bcs $a74e			bcs 	_EXPCExit
.a71a	20 bb a7	jsr $a7bb			jsr 	_EXPCHandleColour
.a71d	80 2f		bra $a74e			bra 	_EXPCExit
.a71f					_EXPCControl:
.a71f	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a721	b0 2b		bcs $a74e			bcs 	_EXPCExit
.a723	0a		asl a				asl 	a 							; double into X
.a724	aa		tax				tax
.a725	7c 99 a7	jmp ($a799,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a728					_EXPCUp:
.a728	ad c0 05	lda $05c0			lda 	EXTRow 						; already at top ?
.a72b	f0 21		beq $a74e			beq 	_EXPCExit
.a72d	ce c0 05	dec $05c0			dec 	EXTRow 						; up one in position/address
.a730	38		sec				sec
.a731	a5 40		lda $40				lda 	EXTAddress
.a733	ed c3 05	sbc $05c3			sbc 	EXTScreenWidth
.a736	85 40		sta $40				sta 	EXTAddress
.a738	b0 14		bcs $a74e			bcs 	_EXPCExit
.a73a	c6 41		dec $41				dec 	EXTAddress+1
.a73c	80 10		bra $a74e			bra 	_EXPCExit
.a73e					_EXPCRight:
.a73e	c8		iny				iny
.a73f	8c c1 05	sty $05c1			sty 	EXTColumn
.a742	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a745	d0 07		bne $a74e			bne 	_EXPCExit
.a747					_EXPCEnd:
.a747	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a74a	3a		dec a				dec 	a
.a74b	8d c1 05	sta $05c1			sta 	EXTColumn
.a74e					_EXPCExit:
.a74e	20 30 a8	jsr $a830			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a751	68		pla				pla
.a752	85 01		sta $01				sta 	1
.a754	7a		ply				ply
.a755	fa		plx				plx
.a756	68		pla				pla
.a757	60		rts				rts
.a758					_EXPCClearScreen:
.a758	20 ed a7	jsr $a7ed			jsr		EXTClearScreenCode
.a75b	80 f1		bra $a74e			bra 	_EXPCExit
.a75d					_EXPCDown:
.a75d	ad c4 05	lda $05c4			lda 	EXTScreenHeight 			; at the bottom
.a760	3a		dec a				dec 	a
.a761	cd c0 05	cmp $05c0			cmp 	EXTRow
.a764	f0 e8		beq $a74e			beq 	_EXPCExit
.a766	ee c0 05	inc $05c0			inc 	EXTRow 						; down one in position/address
.a769	18		clc				clc
.a76a	a5 40		lda $40				lda 	EXTAddress
.a76c	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a76f	85 40		sta $40				sta 	EXTAddress
.a771	90 db		bcc $a74e			bcc 	_EXPCExit
.a773	e6 41		inc $41				inc 	EXTAddress+1
.a775	80 d7		bra $a74e			bra 	_EXPCExit
.a777					_EXPCTab:
.a777	ad c1 05	lda $05c1			lda 	EXTColumn 					; next tab stop
.a77a	29 f8		and #$f8			and 	#$F8
.a77c	18		clc				clc
.a77d	69 08		adc #$08			adc 	#8
.a77f	8d c1 05	sta $05c1			sta 	EXTColumn
.a782	cd c3 05	cmp $05c3			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a785	90 c7		bcc $a74e			bcc 	_EXPCExit
.a787	80 be		bra $a747			bra 	_EXPCEnd
.a789					_EXPCBackSpace:
.a789	88		dey				dey
.a78a	30 c2		bmi $a74e			bmi 	_EXPCExit
.a78c	ce c1 05	dec $05c1			dec 	EXTColumn
.a78f	a9 02		lda #$02			lda 	#2
.a791	85 01		sta $01				sta 	1
.a793	a9 20		lda #$20			lda 	#32
.a795	91 40		sta ($40),y			sta 	(EXTAddress),y
.a797	80 b5		bra $a74e			bra 	_EXPCExit
.a799					_EXPCActionTable:
>a799	4e a7						.word 	_EXPCExit 					; 00
>a79b	09 a7						.word 	_EXPCBegin 					; 01 A Start of Line
>a79d	04 a7						.word 	_EXPCLeft 					; 02 B Left
>a79f	4e a7						.word 	_EXPCExit 					; 03 <Break>
>a7a1	4e a7						.word 	_EXPCExit 					; 04
>a7a3	47 a7						.word 	_EXPCEnd 					; 05 E End of Line
>a7a5	3e a7						.word 	_EXPCRight 					; 06 F Right
>a7a7	4e a7						.word 	_EXPCExit 					; 07
>a7a9	89 a7						.word 	_EXPCBackspace 				; 08 H Backspace
>a7ab	77 a7						.word 	_EXPCTab 					; 09 I Tab
>a7ad	4e a7						.word 	_EXPCExit 					; 0A
>a7af	4e a7						.word 	_EXPCExit 					; 0B
>a7b1	58 a7						.word 	_EXPCClearScreen			; 0C L CLS
>a7b3	e8 a6						.word 	_EXPCCRLF 					; 0D M CR/LF
>a7b5	5d a7						.word 	_EXPCDown 					; 0E N Down
>a7b7	4e a7						.word 	_EXPCExit 					; 0F
>a7b9	28 a7						.word 	_EXPCUp 					; 10 P Up
.a7bb					_EXPCHandleColour
.a7bb	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a7bd	b0 16		bcs $a7d5			bcs 	_EXPCBackground
.a7bf	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a7c0	0a		asl a				asl 	a
.a7c1	0a		asl a				asl 	a
.a7c2	0a		asl a				asl 	a
.a7c3	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a7c5					_EXPCUpdate:
.a7c5	48		pha				pha 								; save new colour
.a7c6	8a		txa				txa 								; get mask
.a7c7	2d c2 05	and $05c2			and 	EXTTextColour 				; mask out old.
.a7ca	8d c2 05	sta $05c2			sta 	EXTTextColour
.a7cd	68		pla				pla 								; or in new colour
.a7ce	0d c2 05	ora $05c2			ora 	EXTTextColour
.a7d1	8d c2 05	sta $05c2			sta 	EXTTextColour
.a7d4	60		rts				rts
.a7d5					_EXPCBackground:
.a7d5	29 0f		and #$0f			and 	#$0F 						; get the colour
.a7d7	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a7d9	80 ea		bra $a7c5			bra 	_EXPCUpdate
.a7db					EXTScreenScroll:
.a7db	a9 02		lda #$02			lda 	#2 							; select text page
.a7dd	85 01		sta $01				sta 	1
.a7df	a9 20		lda #$20			lda		#32 						; fill with space
.a7e1	20 f0 a8	jsr $a8f0			jsr 	EXTScrollFill
.a7e4	e6 01		inc $01				inc 	1 							; select colour page
.a7e6	ad c2 05	lda $05c2			lda 	EXTTextColour
.a7e9	20 f0 a8	jsr $a8f0			jsr 	EXTScrollFill
.a7ec	60		rts				rts
.a7ed					EXTClearScreenCode:
.a7ed	a9 02		lda #$02			lda 	#2 							; select text page
.a7ef	85 01		sta $01				sta 	1
.a7f1	a9 20		lda #$20			lda		#32 						; fill with space
.a7f3	20 00 a8	jsr $a800			jsr 	_EXTCSFill
.a7f6	e6 01		inc $01				inc 	1 							; select colour page
.a7f8	ad c2 05	lda $05c2			lda 	EXTTextColour
.a7fb	20 00 a8	jsr $a800			jsr 	_EXTCSFill
.a7fe	80 22		bra $a822			bra 	EXTHomeCursor
.a800					_EXTCSFill:
.a800	aa		tax				tax
.a801	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a803	85 40		sta $40				sta 	EXTAddress
.a805	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a807	85 41		sta $41				sta 	EXTAddress+1
.a809					_EXTCSFill1:
.a809	a0 00		ldy #$00			ldy 	#0
.a80b	8a		txa				txa
.a80c					_EXTCSFill2:
.a80c	91 40		sta ($40),y			sta 	(EXTAddress),y
.a80e	c8		iny				iny
.a80f	d0 fb		bne $a80c			bne 	_EXTCSFill2
.a811	e6 41		inc $41				inc 	EXTAddress+1
.a813	a5 41		lda $41				lda 	EXTAddress+1
.a815	c9 d2		cmp #$d2			cmp 	#$D2
.a817	d0 f0		bne $a809			bne 	_EXTCSFill1
.a819	8a		txa				txa
.a81a					_EXTCSFill3:
.a81a	91 40		sta ($40),y			sta 	(EXTAddress),y
.a81c	c8		iny				iny
.a81d	c0 c0		cpy #$c0			cpy 	#$C0
.a81f	d0 f9		bne $a81a			bne 	_EXTCSFill3
.a821	60		rts				rts
.a822					EXTHomeCursor:
.a822	9c c0 05	stz $05c0			stz 	EXTRow 						; reset row & column
.a825	9c c1 05	stz $05c1			stz 	EXTColumn
.a828	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a82a	85 40		sta $40				sta 	EXTAddress
.a82c	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a82e	85 41		sta $41				sta 	EXTAddress+1
.a830					EXTSetHardwareCursor:
.a830	64 01		stz $01				stz 	1 							; I/O Page zero
.a832	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a834	8d 10 d0	sta $d010			sta 	$D010
.a837	a9 b1		lda #$b1			lda 	#$B1
.a839	8d 12 d0	sta $d012			sta 	$D012
.a83c	ad c1 05	lda $05c1			lda 	EXTColumn
.a83f	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a842	9c 15 d0	stz $d015			stz 	$D015
.a845	ad c0 05	lda $05c0			lda 	EXTRow
.a848	8d 16 d0	sta $d016			sta 	$D016
.a84b	9c 17 d0	stz $d017			stz 	$D017
.a84e	60		rts				rts
.a84f					EXTInputLine:
.a84f	48		pha				pha
.a850	da		phx				phx
.a851	5a		phy				phy
.a852	a5 01		lda $01				lda 	1 							; save I/O page
.a854	48		pha				pha
.a855					_EILLoop:
.a855	20 57 a9	jsr $a957			jsr 	ExtInputSingleCharacter
.a858	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a85a	f0 40		beq $a89c			beq 	_EILExit
.a85c	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a85e	f0 1c		beq $a87c			beq 	_EILBackspace
.a860	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a862	90 12		bcc $a876			bcc 	_EILPrintLoop
.a864	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a866	b0 0e		bcs $a876			bcs 	_EILPrintLoop
.a868	48		pha				pha 								; save character
.a869	a9 02		lda #$02			lda 	#2  						; insert a space
.a86b	85 01		sta $01				sta 	1
.a86d	20 de a8	jsr $a8de			jsr 	EXTILInsert 				; insert in text screen
.a870	e6 01		inc $01				inc 	1
.a872	20 de a8	jsr $a8de			jsr 	EXTILInsert 				; insert in colour screen
.a875	68		pla				pla 								; get character back.
.a876					_EILPrintLoop:
.a876	20 c1 a6	jsr $a6c1			jsr 	ExtPrintCharacter
.a879	80 da		bra $a855			bra 	_EILLoop
.a87b	60		rts				rts
.a87c					_EILBackspace:
.a87c	ad c1 05	lda $05c1			lda 	EXTColumn					; can we backspace ?
.a87f	f0 d4		beq $a855			beq 	_EILLoop
.a881	a9 02		lda #$02			lda 	#2 							; move cursor left
.a883	20 c1 a6	jsr $a6c1			jsr 	EXTPrintCharacter
.a886	a9 02		lda #$02			lda 	#2 							; text block
.a888	85 01		sta $01				sta 	1
.a88a	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a88c	20 c9 a8	jsr $a8c9			jsr 	EXTILDelete
.a88f	e6 01		inc $01				inc 	1 							; colour block
.a891	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; get attribute of last character
.a894	88		dey				dey
.a895	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a897	20 c9 a8	jsr $a8c9			jsr 	EXTILDelete 				; backspace attribute
.a89a	80 b9		bra $a855			bra 	_EILLoop 					; and go round.
.a89c					_EILExit:
.a89c	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a89e	85 01		sta $01				sta 	1
.a8a0	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a8a2					_EILScrapeLine:
.a8a2	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a8a4	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a8a7	c8		iny				iny
.a8a8	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a8ab	d0 f5		bne $a8a2			bne 	_EILScrapeLine
.a8ad					_EILTrimSpaces:
.a8ad	88		dey				dey
.a8ae	f0 08		beq $a8b8			beq 	_EILEndTrim
.a8b0	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.a8b3	c9 20		cmp #$20			cmp 	#' '
.a8b5	f0 f6		beq $a8ad			beq 	_EILTrimSpaces
.a8b7	c8		iny				iny 								; trim after non space character.
.a8b8					_EILEndTrim:
.a8b8	a9 00		lda #$00			lda 	#0 							; trim here.
.a8ba	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a8bd	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a8bf	20 c1 a6	jsr $a6c1			jsr 	ExtPrintCharacter
.a8c2	68		pla				pla 								; reset I/O page
.a8c3	85 01		sta $01				sta 	1
.a8c5	7a		ply				ply
.a8c6	fa		plx				plx
.a8c7	68		pla				pla
.a8c8	60		rts				rts
.a8c9					EXTILDelete:
.a8c9	48		pha				pha 								; save the new character
.a8ca	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; start copying from here.
.a8cd					_EXTDLoop:
.a8cd	c8		iny				iny 								; copy one byte down.
.a8ce	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a8d0	88		dey				dey
.a8d1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8d3	c8		iny				iny 								; do till end of line.
.a8d4	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a8d7	90 f4		bcc $a8cd			bcc 	_EXTDLoop
.a8d9	88		dey				dey 	 							; write in last slot.
.a8da	68		pla				pla
.a8db	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8dd	60		rts				rts
.a8de					EXTILInsert:
.a8de	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; end position
.a8e1					_EXTILoop:
.a8e1	88		dey				dey 								; back one
.a8e2	cc c1 05	cpy $05c1			cpy 	EXTColumn 					; exit if reached insert point.
.a8e5	f0 08		beq $a8ef			beq 	_EXTIExit
.a8e7	88		dey				dey 								; copy one byte up.
.a8e8	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a8ea	c8		iny				iny
.a8eb	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8ed	80 f2		bra $a8e1			bra 	_EXTILoop
.a8ef					_EXTIExit:
.a8ef	60		rts				rts
.a8f0					EXTScrollFill:
.a8f0	aa		tax				tax									; save value to fill with
.a8f1	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a8f3	48		pha				pha
.a8f4	a5 37		lda $37				lda 	zTemp0+1
.a8f6	48		pha				pha
.a8f7	a5 38		lda $38				lda 	zTemp1
.a8f9	48		pha				pha
.a8fa	a5 39		lda $39				lda 	zTemp1+1
.a8fc	48		pha				pha
.a8fd	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.a8ff	85 37		sta $37				sta 	zTemp0+1
.a901	85 39		sta $39				sta 	zTemp1+1
.a903	64 36		stz $36				stz 	zTemp0
.a905	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a908	85 38		sta $38				sta 	zTemp1
.a90a	a0 00		ldy #$00			ldy 	#0
.a90c					_EXSFCopy1:
.a90c	b1 38		lda ($38),y			lda 	(zTemp1),y
.a90e	91 36		sta ($36),y			sta 	(zTemp0),y
.a910	c8		iny				iny
.a911	d0 f9		bne $a90c			bne 	_EXSFCopy1
.a913	e6 37		inc $37				inc 	zTemp0+1 					; next page
.a915	e6 39		inc $39				inc 	zTemp1+1
.a917	a5 39		lda $39				lda 	zTemp1+1
.a919	c9 d3		cmp #$d3			cmp 	#$D3
.a91b	d0 ef		bne $a90c			bne 	_EXSFCopy1
.a91d	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; blank the bottom line.
.a920	8a		txa				txa
.a921					_EXSFFill1:
.a921	88		dey				dey
.a922	91 40		sta ($40),y			sta 	(EXTAddress),y
.a924	c0 00		cpy #$00			cpy 	#0
.a926	10 f9		bpl $a921			bpl 	_EXSFFill1
.a928	68		pla				pla
.a929	85 39		sta $39				sta 	zTemp1+1
.a92b	68		pla				pla
.a92c	85 38		sta $38				sta 	zTemp1
.a92e	68		pla				pla
.a92f	85 37		sta $37				sta 	zTemp0+1
.a931	68		pla				pla
.a932	85 36		sta $36				sta 	zTemp0
.a934	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.05c0					EXTRow:
>05c0							.fill 	1
.05c1					EXTColumn:
>05c1							.fill 	1
.05c2					EXTTextColour:
>05c2							.fill 	1
.05c3					EXTScreenWidth:
>05c3							.fill 	1
.05c4					EXTScreenHeight:
>05c4							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.a935					EXTInitialise:
.a935	64 01		stz $01				stz 	1 							; Access I/O
.a937	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.a93a	9c 08 d0	stz $d008			stz 	$D008
.a93d	9c 09 d0	stz $d009			stz 	$D009
.a940	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.a942	8d 58 d6	sta $d658			sta 	$D658
.a945	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.a947	8d c2 05	sta $05c2			sta 	EXTTextColour
.a94a	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.a94c	8d c3 05	sta $05c3			sta 	EXTScreenWidth
.a94f	a9 3c		lda #$3c			lda 	#60
.a951	8d c4 05	sta $05c4			sta 	EXTScreenHeight
.a954	64 01		stz $01				stz 	1
.a956	60		rts				rts
.a957					EXTInputSingleCharacter:
.a957	da		phx				phx
.a958	5a		phy				phy
.a959					_EISCWait:
.a959	64 01		stz $01				stz 	1 							; access I/O Page 0
.a95b	38		sec				sec 								; calculate timer - LastTick
.a95c	ad 59 d6	lda $d659			lda 	$D659
.a95f	aa		tax				tax 								; saving timer in X
.a960	ed af 05	sbc $05af			sbc 	LastTick
.a963	c9 03		cmp #$03			cmp 	#3
.a965	90 06		bcc $a96d			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.a967	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.a96a	20 0d b9	jsr $b90d			jsr 	TickHandler 				; go do the code.
.a96d					_NoFireTick:
.a96d	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.a970	c9 00		cmp #$00			cmp 	#0
.a972	f0 e5		beq $a959			beq 	_EISCWait
.a974	7a		ply				ply
.a975	fa		plx				plx
.a976	60		rts				rts
.a977					EXTBreakCheck:
.a977	4c e1 ff	jmp $ffe1			jmp		$FFE1
.a97a					EXTReadController:
.a97a	da		phx				phx
.a97b	a2 00		ldx #$00			ldx 	#0
.a97d	a9 05		lda #$05			lda 	#(($2D) >> 3)
.a97f	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a982	29 20		and #$20			and 	#($01 << (($2D) & 7))
.a984	f0 04		beq $a98a			beq 	_NoSet1
.a986	8a		txa				txa
.a987	09 01		ora #$01			ora 	#1
.a989	aa		tax				tax
.a98a					_NoSet1:
.a98a	a9 05		lda #$05			lda 	#(($2C) >> 3)
.a98c	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a98f	29 10		and #$10			and 	#($01 << (($2C) & 7))
.a991	f0 04		beq $a997			beq 	_NoSet1
.a993	8a		txa				txa
.a994	09 02		ora #$02			ora 	#2
.a996	aa		tax				tax
.a997					_NoSet1:
.a997	a9 06		lda #$06			lda 	#(($32) >> 3)
.a999	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a99c	29 04		and #$04			and 	#($01 << (($32) & 7))
.a99e	f0 04		beq $a9a4			beq 	_NoSet1
.a9a0	8a		txa				txa
.a9a1	09 04		ora #$04			ora 	#4
.a9a3	aa		tax				tax
.a9a4					_NoSet1:
.a9a4	a9 04		lda #$04			lda 	#(($25) >> 3)
.a9a6	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a9a9	29 20		and #$20			and 	#($01 << (($25) & 7))
.a9ab	f0 04		beq $a9b1			beq 	_NoSet1
.a9ad	8a		txa				txa
.a9ae	09 08		ora #$08			ora 	#8
.a9b0	aa		tax				tax
.a9b1					_NoSet1:
.a9b1	a9 04		lda #$04			lda 	#(($26) >> 3)
.a9b3	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.a9b6	29 40		and #$40			and 	#($01 << (($26) & 7))
.a9b8	f0 04		beq $a9be			beq 	_NoSet1
.a9ba	8a		txa				txa
.a9bb	09 10		ora #$10			ora 	#16
.a9bd	aa		tax				tax
.a9be					_NoSet1:
.a9be	8a		txa				txa
.a9bf	fa		plx				plx
.a9c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.b913					GRVectorTable:
>b913	bc ab					.word	GXInitialise             ; $00 Initialise
>b915	d6 ab					.word	GXControlBitmap          ; $01 BitmapCtl
>b917	1e ac					.word	GXControlSprite          ; $02 SpriteCtl
>b919	6e ab					.word	GXClearBitmap            ; $03 Clear
>b91b	ad ad					.word	GXSetColourMode          ; $04 Colour
>b91d	75 af					.word	GXFontHandler            ; $05 DrawFont
>b91f	bd af					.word	GXSpriteHandler          ; $06 DrawSprite
>b921	29 b0					.word	GXSelect                 ; $07 SpriteUse
>b923	52 b0					.word	GXSelectImage            ; $08 SpriteImage
>b925	d9 b1					.word	GXCollide                ; $09 SpriteCollide
>b927	20 aa					.word	GRUndefined              ; $0a
>b929	20 aa					.word	GRUndefined              ; $0b
>b92b	20 aa					.word	GRUndefined              ; $0c
>b92d	20 aa					.word	GRUndefined              ; $0d
>b92f	20 aa					.word	GRUndefined              ; $0e
>b931	20 aa					.word	GRUndefined              ; $0f
>b933	20 aa					.word	GRUndefined              ; $10
>b935	20 aa					.word	GRUndefined              ; $11
>b937	20 aa					.word	GRUndefined              ; $12
>b939	20 aa					.word	GRUndefined              ; $13
>b93b	20 aa					.word	GRUndefined              ; $14
>b93d	20 aa					.word	GRUndefined              ; $15
>b93f	20 aa					.word	GRUndefined              ; $16
>b941	20 aa					.word	GRUndefined              ; $17
>b943	20 aa					.word	GRUndefined              ; $18
>b945	20 aa					.word	GRUndefined              ; $19
>b947	20 aa					.word	GRUndefined              ; $1a
>b949	20 aa					.word	GRUndefined              ; $1b
>b94b	20 aa					.word	GRUndefined              ; $1c
>b94d	20 aa					.word	GRUndefined              ; $1d
>b94f	20 aa					.word	GRUndefined              ; $1e
>b951	20 aa					.word	GRUndefined              ; $1f
>b953	1e aa					.word	GXMove                   ; $20 Move
>b955	7b ac					.word	GXLine                   ; $21 Line
>b957	f6 ad					.word	GXFrameRectangle         ; $22 FrameRect
>b959	f3 ad					.word	GXFillRectangle          ; $23 FillRect
>b95b	25 aa					.word	GXFrameCircle            ; $24 FrameCircle
>b95d	21 aa					.word	GXFillCircle             ; $25 FillCircle
>b95f	20 aa					.word	GRUndefined              ; $26
>b961	20 aa					.word	GRUndefined              ; $27
>b963	db ad					.word	GXPlotPoint              ; $28 Plot
>b965	e8 b0					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$57b					gxPixelBuffer = numberBuffer
.05c5					gxCurrentX:
>05c5							.fill 	2
.05c7					gxCurrentY:
>05c7							.fill 	2
.05c9					gxLastX:
>05c9							.fill 	2
.05cb					gxLastY:
>05cb							.fill 	2
.05cd					gxX0:
>05cd							.fill 	2
.05cf					gxY0:
>05cf							.fill 	2
.05d1					gxX1:
>05d1							.fill 	2
.05d3					gxY1:
>05d3							.fill 	2
.05d5					gxSpritesOn:
>05d5							.fill 	1
.05d6					gxBitmapsOn:
>05d6							.fill 	1
.05d7					gxBasePage:
>05d7							.fill 	1
.05d8					gxSpritePage:
>05d8							.fill 	1
.05d9					gxHeight:
>05d9							.fill 	1
.05da					gxMode:
>05da							.fill 	1
.05db					gxColour:
>05db							.fill 	1
.05dc					gxEORValue:
>05dc							.fill 	1
.05dd					gxANDValue:
>05dd							.fill 	1
.05de					gxOriginalLUTValue:
>05de							.fill 	1
.05df					gsOffset:
>05df							.fill 	1
.05e0					GSCurrentSpriteID:
>05e0							.fill 	1
.05e1					GSCurrentSpriteAddr:
>05e1							.fill 	2
.05e3					GXSpriteOffsetBase:
>05e3							.fill 	2
.05e5					GXSpriteLow:
>05e5							.fill 	64
.0625					GXSpriteHigh:
>0625							.fill 	64
.a9c1					GXGraphicDraw:
.a9c1	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.a9c3	b0 06		bcs $a9cb			bcs 	_GDCoordinate
.a9c5	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.a9c7	84 37		sty $37				sty 	gxzTemp0+1
.a9c9	80 4b		bra $aa16			bra 	_GDExecuteA 				; and execute
.a9cb					_GDCoordinate:
.a9cb	48		pha				pha 								; save AXY
.a9cc	da		phx				phx
.a9cd	5a		phy				phy
.a9ce	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.a9d0					_GDCopy1:
.a9d0	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.a9d3	9d c9 05	sta $05c9,x			sta 	gxLastX,x
.a9d6	ca		dex				dex
.a9d7	10 f7		bpl $a9d0			bpl 	_GDCopy1
.a9d9	68		pla				pla 								; update Y
.a9da	8d c7 05	sta $05c7			sta 	gxCurrentY
.a9dd	9c c8 05	stz $05c8			stz 	gxCurrentY+1
.a9e0	68		pla				pla
.a9e1	8d c5 05	sta $05c5			sta 	gxCurrentX
.a9e4	68		pla				pla 								; get A (command+X.1) back
.a9e5	48		pha				pha
.a9e6	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.a9e8	8d c6 05	sta $05c6			sta 	gxCurrentX+1
.a9eb	68		pla				pla 								; get command back
.a9ec	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.a9ee	48		pha				pha 								; push back.
.a9ef	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.a9f1	f0 17		beq $aa0a			beq 	_GDCopyToWorkArea
.a9f3	ad c6 05	lda $05c6			lda 	gxCurrentX+1 				; X < 256 X okay
.a9f6	f0 07		beq $a9ff			beq 	_GDCheckY
.a9f8	ad c5 05	lda $05c5			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.a9fb	c9 40		cmp #$40			cmp 	#64
.a9fd	b0 08		bcs $aa07			bcs 	_GDError1
.a9ff					_GDCheckY:
.a9ff	ad c7 05	lda $05c7			lda 	gxCurrentY 					; check Y < Height.
.aa02	cd d9 05	cmp $05d9			cmp 	gxHeight
.aa05	90 03		bcc $aa0a			bcc 	_GDCopyToWorkArea
.aa07					_GDError1:
.aa07	68		pla				pla
.aa08					_GDError2:
.aa08	38		sec				sec
.aa09	60		rts				rts
.aa0a					_GDCopyToWorkArea:
.aa0a	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.aa0c					_GDCopy2:
.aa0c	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aa0f	9d cd 05	sta $05cd,x			sta 	gxX0,x
.aa12	ca		dex				dex
.aa13	10 f7		bpl $aa0c			bpl 	_GDCopy2
.aa15	68		pla				pla 								; get command
.aa16					_GDExecuteA:
.aa16	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.aa18	b0 ee		bcs $aa08			bcs 	_GDError2
.aa1a	aa		tax				tax
.aa1b	7c 13 b9	jmp ($b913,x)			jmp 	(GRVectorTable,x)
.aa1e					GXMove:
.aa1e	18		clc				clc
.aa1f	60		rts				rts
.aa20					GRUndefined:
>aa20	db						.byte 	$DB 						; causes a break in the emulator
.aa21					GXFillCircle:
.aa21	a9 ff		lda #$ff			lda 	#255
.aa23	80 02		bra $aa27			bra 	GXCircle
.aa25					GXFrameCircle:
.aa25	a9 00		lda #$00			lda 	#0
.aa27					GXCircle:
.aa27	8d 68 06	sta $0668			sta 	gxIsFillMode					; save Fill flag
.aa2a	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.aa2d	f0 26		beq $aa55			beq 	_GXCFail
.aa2f	20 80 b2	jsr $b280			jsr 	GXSortXY 					; topleft/bottomright
.aa32	20 58 b1	jsr $b158			jsr 	GXOpenBitmap 				; start drawing
.aa35	20 27 ab	jsr $ab27			jsr 	GXCircleSetup 				; set up for drawing
.aa38	9c 69 06	stz $0669			stz 	gxYChanged
.aa3b					_GXCircleDraw:
.aa3b	ad 66 06	lda $0666			lda 	gXCentre					; while x <= y
.aa3e	cd 67 06	cmp $0667			cmp 	gYCentre
.aa41	90 0a		bcc $aa4d			bcc 	_GXCircleContinue
.aa43	d0 03		bne $aa48			bne 	_GXNoLast
.aa45	20 5a aa	jsr $aa5a			jsr 	GXPlot1
.aa48					_GXNoLast:
.aa48	20 60 b1	jsr $b160			jsr 	GXCloseBitmap 				; close the bitmap
.aa4b	18		clc				clc
.aa4c	60		rts				rts
.aa4d					_GXCircleContinue:
.aa4d	20 57 aa	jsr $aa57			jsr 	GXPlot2 					; draw it
.aa50	20 d4 aa	jsr $aad4			jsr 	GXCircleMove 				; adjust the coordinates
.aa53	80 e6		bra $aa3b			bra 	_GXCircleDraw
.aa55					_GXCFail:
.aa55	38		sec				sec
.aa56	60		rts				rts
.aa57					GXPlot2:
.aa57	20 5a aa	jsr $aa5a			jsr 	GXPlot1 						; plot and swap, fall through does twice
.aa5a					GXPlot1:
.aa5a	ad 67 06	lda $0667			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.aa5d	f0 03		beq $aa62			beq 	_GXPlot1Only
.aa5f	20 7e aa	jsr $aa7e			jsr 	GXPlot0 						; plot and negate
.aa62					_GXPlot1Only:
.aa62	20 7e aa	jsr $aa7e			jsr 	GXPlot0 						; twice, undoing negation
.aa65	ad 66 06	lda $0666			lda 	gXCentre 						; swap X and Y
.aa68	ae 67 06	ldx $0667			ldx	 	gYCentre
.aa6b	8d 67 06	sta $0667			sta 	gYCentre
.aa6e	8e 66 06	stx $0666			stx 	gXCentre
.aa71	ad 69 06	lda $0669			lda 	gxYChanged 						; toggle Y Changed flag
.aa74	a9 ff		lda #$ff			lda 	#$FF
.aa76	8d 69 06	sta $0669			sta 	gxYChanged
.aa79	60		rts				rts
.aa7a	20 7e aa	jsr $aa7e			jsr 	GXPlot0 						; do once
.aa7d	60		rts				rts
.aa7e	ad 68 06	lda $0668	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.aa81	f0 05		beq $aa88			beq 	_GXPlot0Always
.aa83	ad 69 06	lda $0669			lda 	gxYChanged						; fill mode, only draw if changed.
.aa86	f0 2d		beq $aab5			beq 	GXPlot0Exit
.aa88					_GXPlot0Always:
.aa88	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.aa8a	ad 67 06	lda $0667			lda 	gYCentre
.aa8d	20 b6 aa	jsr $aab6			jsr 	GXSubCopy
.aa90	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.aa92	ad 66 06	lda $0666			lda 	gXCentre
.aa95	20 b6 aa	jsr $aab6			jsr 	GXSubCopy
.aa98	48		pha				pha 									; save last offset X
.aa99	20 68 b1	jsr $b168			jsr 	GXPositionCalc 					; calculate position/offset.
.aa9c	68		pla				pla
.aa9d	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.aa9e	85 36		sta $36				sta 	gxzTemp0
.aaa0	64 37		stz $37				stz 	gxzTemp0+1
.aaa2	26 37		rol $37				rol 	gxzTemp0+1
.aaa4	ad 68 06	lda $0668			lda 	gxIsFillMode
.aaa7	69 80		adc #$80			adc 	#128
.aaa9	20 46 ae	jsr $ae46			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.aaac	38		sec				sec 									; GY = -GY
.aaad	a9 00		lda #$00			lda 	#0
.aaaf	ed 67 06	sbc $0667			sbc 	gYCentre
.aab2	8d 67 06	sta $0667			sta 	gYCentre
.aab5					GXPlot0Exit:
.aab5	60		rts				rts
.aab6					GXSubCopy:
.aab6	85 36		sta $36				sta 	gxzTemp0
.aab8	64 37		stz $37				stz 	gxzTemp0+1
.aaba	29 80		and #$80			and 	#$80
.aabc	f0 02		beq $aac0			beq 	_GXNoSx
.aabe	c6 37		dec $37				dec 	gxzTemp0+1
.aac0					_GXNoSx:
.aac0	38		sec				sec
.aac1	bd d1 05	lda $05d1,x			lda 	gXX1,x
.aac4	e5 36		sbc $36				sbc 	gxzTemp0
.aac6	9d cd 05	sta $05cd,x			sta 	gXX0,x
.aac9	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.aacc	e5 37		sbc $37				sbc 	gxzTemp0+1
.aace	9d ce 05	sta $05ce,x			sta 	gXX0+1,x
.aad1	a5 36		lda $36				lda 	gxzTemp0 						; return A
.aad3	60		rts				rts
.aad4					GXCircleMove:
.aad4	9c 69 06	stz $0669			stz 	gxYChanged 					; clear Y changed flag
.aad7	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.aad9	10 0d		bpl $aae8			bpl 	_GXEMPositive
.aadb	ee 66 06	inc $0666			inc 	gXCentre 					; X++
.aade	ad 66 06	lda $0666			lda 	gXCentre
.aae1	20 07 ab	jsr $ab07			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.aae4	a9 06		lda #$06			lda 	#6  						; and add 6
.aae6	80 15		bra $aafd			bra 	_GXEMAddD
.aae8					_GXEMPositive:
.aae8	ee 66 06	inc $0666			inc 	gXCentre					; X++
.aaeb	ce 67 06	dec $0667			dec 	gyCentre 					; Y--
.aaee	38		sec				sec 								; calculate X-Y
.aaef	ad 66 06	lda $0666			lda 	gXCentre
.aaf2	ed 67 06	sbc $0667			sbc 	gYCentre
.aaf5	20 07 ab	jsr $ab07			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.aaf8	a9 0a		lda #$0a			lda 	#10  						; and add 10
.aafa	ce 69 06	dec $0669			dec 	gxYChanged
.aafd					_GXEMAddD:
.aafd	18		clc				clc
.aafe	65 38		adc $38				adc 	gxzTemp1
.ab00	85 38		sta $38				sta 	gxzTemp1
.ab02	90 02		bcc $ab06			bcc 	_GXEMNoCarry
.ab04	e6 39		inc $39				inc 	gxzTemp1+1
.ab06					_GXEMNoCarry:
.ab06	60		rts				rts
.ab07					_GXAdd4TimesToD:
.ab07	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.ab09	29 80		and #$80			and 	#$80
.ab0b	f0 02		beq $ab0f			beq 	_GXA4Unsigned
.ab0d	a9 ff		lda #$ff			lda 	#$FF
.ab0f					_GXA4Unsigned:
.ab0f	85 37		sta $37				sta 	gxzTemp0+1
.ab11	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ab13	26 37		rol $37				rol 	gxzTemp0+1
.ab15	06 36		asl $36				asl 	gxzTemp0
.ab17	26 37		rol $37				rol 	gxzTemp0+1
.ab19	18		clc				clc 								; add
.ab1a	a5 36		lda $36				lda		gxzTemp0
.ab1c	65 38		adc $38				adc 	gxzTemp1
.ab1e	85 38		sta $38				sta 	gxzTemp1
.ab20	a5 37		lda $37				lda		gxzTemp0+1
.ab22	65 39		adc $39				adc 	gxzTemp1+1
.ab24	85 39		sta $39				sta 	gxzTemp1+1
.ab26	60		rts				rts
.ab27					GXCircleSetup:
.ab27	38		sec				sec
.ab28	ad d3 05	lda $05d3			lda 	gxY1
.ab2b	ed cf 05	sbc $05cf			sbc 	gxY0
.ab2e	4a		lsr a				lsr 	a
.ab2f	8d 65 06	sta $0665			sta 	gxRadius
.ab32	a2 00		ldx #$00			ldx 	#0
.ab34	20 56 ab	jsr $ab56			jsr 	_GXCalculateCentre
.ab37	a2 02		ldx #$02			ldx 	#2
.ab39	20 56 ab	jsr $ab56			jsr 	_GXCalculateCentre
.ab3c	9c 66 06	stz $0666			stz 	gXCentre
.ab3f	ad 65 06	lda $0665			lda 	gxRadius
.ab42	8d 67 06	sta $0667			sta 	gYCentre
.ab45	0a		asl a				asl 	a 							; R x 2
.ab46	85 36		sta $36				sta 	gxzTemp0
.ab48	38		sec				sec
.ab49	a9 03		lda #$03			lda 	#3
.ab4b	e5 36		sbc $36				sbc 	gxzTemp0
.ab4d	85 38		sta $38				sta 	gxzTemp1
.ab4f	a9 00		lda #$00			lda 	#0
.ab51	e9 00		sbc #$00			sbc 	#0
.ab53	85 39		sta $39				sta 	gxzTemp1+1
.ab55	60		rts				rts
.ab56					_GXCalculateCentre:
.ab56	38		sec				sec
.ab57	bd d1 05	lda $05d1,x			lda 	gxX1,x
.ab5a	7d cd 05	adc $05cd,x			adc 	gXX0,x
.ab5d	9d d1 05	sta $05d1,x			sta 	gXX1,x
.ab60	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.ab63	7d ce 05	adc $05ce,x			adc 	gXX0+1,x
.ab66	4a		lsr a				lsr 	a
.ab67	9d d2 05	sta $05d2,x			sta 	gXX1+1,x
.ab6a	7e d1 05	ror $05d1,x			ror 	gXX1,x
.ab6d	60		rts				rts
.0665					gxRadius:
>0665							.fill 	1
.0666					gXCentre:
>0666							.fill 	1
.0667					gYCentre:
>0667							.fill 	1
.0668					gxIsFillMode:
>0668							.fill 	1
.0669					gxYChanged:
>0669							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ab6e					GXClearBitmap:
.ab6e	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP running.
.ab71	f0 24		beq $ab97			beq 	_GXCBFail
.ab73	20 58 b1	jsr $b158			jsr 	GXOpenBitmap 				; start access
.ab76	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ab78	ad d9 05	lda $05d9			lda 	gxHeight
.ab7b	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ab7d	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ab7f					_GXCalcLastPage:
.ab7f	98		tya				tya 								; add to base page
.ab80	18		clc				clc
.ab81	6d d7 05	adc $05d7			adc 	gxBasePage
.ab84	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ab86					_GXClearAll:
.ab86	20 99 ab	jsr $ab99			jsr 	_GXClearBlock 				; clear 8k block
.ab89	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ab8b	a5 0b		lda $0b				lda 	GXEditSlot
.ab8d	cd d7 05	cmp $05d7			cmp 	gxBasePage 					; until before base page
.ab90	b0 f4		bcs $ab86			bcs 	_GXClearAll
.ab92	20 60 b1	jsr $b160			jsr 	GXCloseBitmap	 			; stop access
.ab95	18		clc				clc
.ab96	60		rts				rts
.ab97					_GXCBFail:
.ab97	38		sec				sec
.ab98	60		rts				rts
.ab99					_GXClearBlock:
.ab99	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ab9b	85 38		sta $38				sta 	0+gxzTemp1
.ab9d	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ab9f	85 39		sta $39				sta 	1+gxzTemp1
.aba1					_GXCB0:
.aba1	a5 36		lda $36				lda 	gxzTemp0
.aba3	a0 00		ldy #$00			ldy 	#0
.aba5					_GXCB1:
.aba5	91 38		sta ($38),y			sta 	(gxzTemp1),y
.aba7	c8		iny				iny
.aba8	91 38		sta ($38),y			sta 	(gxzTemp1),y
.abaa	c8		iny				iny
.abab	91 38		sta ($38),y			sta 	(gxzTemp1),y
.abad	c8		iny				iny
.abae	91 38		sta ($38),y			sta 	(gxzTemp1),y
.abb0	c8		iny				iny
.abb1	d0 f2		bne $aba5			bne 	_GXCB1
.abb3	e6 39		inc $39				inc 	gxzTemp1+1
.abb5	a5 39		lda $39				lda 	gxzTemp1+1
.abb7	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.abb9	d0 e6		bne $aba1			bne 	_GXCB0
.abbb	60		rts				rts
.abbc					GXInitialise:
.abbc	64 01		stz $01				stz 	1
.abbe	a9 01		lda #$01			lda 	#1
.abc0	8d 00 d0	sta $d000			sta 	$D000
.abc3	18		clc				clc
.abc4	9c d5 05	stz $05d5			stz 	GXSpritesOn
.abc7	9c d6 05	stz $05d6			stz 	GXBitmapsOn
.abca	a2 0f		ldx #$0f			ldx 	#15
.abcc					_GXIClear:
.abcc	9e c5 05	stz $05c5,x			stz 	gxCurrentX,x
.abcf	ca		dex				dex
.abd0	10 fa		bpl $abcc			bpl 	_GXIClear
.abd2	20 6d ac	jsr $ac6d			jsr 	GXClearSpriteStore
.abd5	60		rts				rts
.abd6					GXControlBitmap:
.abd6	64 01		stz $01				stz 	1
.abd8	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.abda	29 01		and #$01			and 	#1 							; set bitmap flag
.abdc	8d d6 05	sta $05d6			sta 	gxBitmapsOn
.abdf	4a		lsr a				lsr 	a 							; bit 0 into carry.
.abe0	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.abe3	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.abe5	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.abe7	90 02		bcc $abeb			bcc 	_CBNotOn
.abe9	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.abeb					_CBNotOn:
.abeb	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.abee	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.abf0	29 07		and #$07			and 	#7
.abf2	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.abf5	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.abf7	d0 02		bne $abfb			bne 	_CBNotDefault
.abf9	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.abfb					_CBNotDefault:
.abfb	8d d7 05	sta $05d7			sta 	gxBasePage
.abfe	20 5f ac	jsr $ac5f			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ac01	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ac03	8d 03 d1	sta $d103			sta 	$D103
.ac06	a5 36		lda $36				lda 	gxzTemp0
.ac08	8d 02 d1	sta $d102			sta 	$D102
.ac0b	9c 01 d1	stz $d101			stz 	$D101
.ac0e	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ac10	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ac13	29 01		and #$01			and 	#1
.ac15	f0 02		beq $ac19			beq 	_CBHaveHeight
.ac17	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ac19					_CBHaveHeight
.ac19	8e d9 05	stx $05d9			stx 	gxHeight
.ac1c	18		clc				clc
.ac1d	60		rts				rts
.ac1e					GXControlSprite:
.ac1e	64 01		stz $01				stz 	1
.ac20	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ac22	29 01		and #$01			and 	#1 							; set sprites flag
.ac24	8d d5 05	sta $05d5			sta 	gxSpritesOn
.ac27	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ac28	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ac2b	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ac2d	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ac2f	90 02		bcc $ac33			bcc 	_CSNotOn
.ac31	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ac33					_CSNotOn:
.ac33	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ac36	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ac38	d0 02		bne $ac3c			bne 	_CSNotDefault
.ac3a	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ac3c					_CSNotDefault:
.ac3c	8d d8 05	sta $05d8			sta 	gxSpritePage
.ac3f	20 5f ac	jsr $ac5f			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ac42	a5 36		lda $36				lda 	zTemp0
.ac44	8d e3 05	sta $05e3			sta 	GXSpriteOffsetBase
.ac47	a5 37		lda $37				lda 	zTemp0+1
.ac49	8d e4 05	sta $05e4			sta 	GXSpriteOffsetBase+1
.ac4c	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ac4e					_CSClear:
.ac4e	9e 00 d9	stz $d900,x			stz 	$D900,x
.ac51	9e 00 da	stz $da00,x			stz 	$DA00,x
.ac54	ca		dex				dex
.ac55	d0 f7		bne $ac4e			bne 	_CSClear
.ac57	9c e2 05	stz $05e2			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ac5a	20 6d ac	jsr $ac6d			jsr 	GXClearSpriteStore
.ac5d	18		clc				clc
.ac5e	60		rts				rts
.ac5f					GXCalculateBaseAddress:
.ac5f	85 36		sta $36				sta 	gxzTemp0
.ac61	64 37		stz $37				stz 	gxzTemp0+1
.ac63	a9 05		lda #$05			lda 	#5
.ac65					_GXShift:
.ac65	06 36		asl $36				asl 	gxzTemp0
.ac67	26 37		rol $37				rol 	gxzTemp0+1
.ac69	3a		dec a				dec		a
.ac6a	d0 f9		bne $ac65			bne 	_GXShift
.ac6c	60		rts				rts
.ac6d					GXClearSpriteStore:
.ac6d	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ac6f					_GXCSSLoop:
.ac6f	9e 25 06	stz $0625,x			stz 	GXSpriteHigh,x
.ac72	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ac74	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.ac77	ca		dex				dex
.ac78	10 f5		bpl $ac6f			bpl 	_GXCSSLoop
.ac7a	60		rts				rts
.ac7b					GXLine:
.ac7b	ad d6 05	lda $05d6			lda 	GXBitmapsOn
.ac7e	f0 28		beq $aca8			beq 	_GXLFail
.ac80	20 58 b1	jsr $b158			jsr 	GXOpenBitmap
.ac83	20 9e b2	jsr $b29e			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ac86	20 4e ad	jsr $ad4e			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ac89	20 68 b1	jsr $b168			jsr 	GXPositionCalc 				; calculate position/offset.
.ac8c					_GXDrawLoop:
.ac8c	ac df 05	ldy $05df			ldy 	gsOffset 					; draw the pixel
.ac8f	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ac91	2d dd 05	and $05dd			and 	gxANDValue
.ac94	4d dc 05	eor $05dc			eor 	gxEORValue
.ac97	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ac99	20 aa ac	jsr $acaa			jsr 	GXLineIsComplete 			; is the line complete ?
.ac9c	f0 05		beq $aca3			beq 	_GXLExit
.ac9e	20 c5 ac	jsr $acc5			jsr 	GXLineAdvance 				; code as per advance method
.aca1	80 e9		bra $ac8c			bra 	_GXDrawLoop
.aca3					_GXLExit:
.aca3	20 60 b1	jsr $b160			jsr 	GXCloseBitmap
.aca6	18		clc				clc
.aca7	60		rts				rts
.aca8					_GXLFail:
.aca8	38		sec				sec
.aca9	60		rts				rts
.acaa					GXLineIsComplete:
.acaa	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger 			; is dy larger
.acad	d0 0f		bne $acbe			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.acaf	ad cd 05	lda $05cd			lda 	GXX0 						; compare X, LSB and MSB
.acb2	4d d1 05	eor $05d1			eor 	GXX1
.acb5	d0 06		bne $acbd			bne 	_GXLICExit
.acb7	ad ce 05	lda $05ce			lda 	GXX0+1
.acba	4d d2 05	eor $05d2			eor 	GXX1+1
.acbd					_GXLICExit:
.acbd	60		rts				rts
.acbe					_GXLICCompareY:
.acbe	ad d3 05	lda $05d3			lda 	GXY1
.acc1	4d cf 05	eor $05cf			eor 	GXY0
.acc4	60		rts				rts
.acc5					GXLineAdvance:
.acc5	18		clc				clc 								; add adjust to position
.acc6	ad 6e 06	lda $066e			lda 	GXPosition
.acc9	6d 6f 06	adc $066f			adc 	GXAdjust
.accc	8d 6e 06	sta $066e			sta 	GXPosition
.accf	9c 71 06	stz $0671			stz 	GXAddSelect 				; clear add select flag
.acd2	b0 05		bcs $acd9			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.acd4	cd 70 06	cmp $0670			cmp 	GXTotal 					; if exceeded total
.acd7	90 0a		bcc $ace3			bcc 	_GXLANoExtra
.acd9					_GXLAOverflow:
.acd9	ce 71 06	dec $0671			dec 	GXAddSelect 				; set addselect to $FF
.acdc	38		sec				sec 								; subtract total and write back
.acdd	ed 70 06	sbc $0670			sbc 	GXTotal
.ace0	8d 6e 06	sta $066e			sta 	GXPosition
.ace3					_GXLANoExtra:
.ace3	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger
.ace6	f0 0d		beq $acf5			beq 	_GXDXLarger
.ace8	20 47 ad	jsr $ad47			jsr 	GXIncrementY
.aceb	ad 71 06	lda $0671			lda 	GXAddSelect
.acee	f0 10		beq $ad00			beq 	_GXLAExit
.acf0	20 01 ad	jsr $ad01			jsr 	GXAdjustX
.acf3	80 0b		bra $ad00			bra 	_GXLAExit
.acf5					_GXDXLarger:
.acf5	20 01 ad	jsr $ad01			jsr 	GXAdjustX
.acf8	ad 71 06	lda $0671			lda 	GXAddSelect
.acfb	f0 03		beq $ad00			beq 	_GXLAExit
.acfd	20 47 ad	jsr $ad47			jsr 	GXIncrementY
.ad00					_GXLAExit:
.ad00	60		rts				rts
.ad01					GXAdjustX:
.ad01	ad 6d 06	lda $066d			lda 	GXDXNegative
.ad04	10 25		bpl $ad2b			bpl 	_GXAXRight
.ad06	ad cd 05	lda $05cd			lda 	GXX0
.ad09	d0 03		bne $ad0e			bne 	_GXAXNoBorrow
.ad0b	ce ce 05	dec $05ce			dec 	GXX0+1
.ad0e					_GXAXNoBorrow:
.ad0e	ce cd 05	dec $05cd			dec 	GXX0
.ad11	ce df 05	dec $05df			dec 	gsOffset 					; pixel left
.ad14	ad df 05	lda $05df			lda 	gsOffset
.ad17	c9 ff		cmp #$ff			cmp 	#$FF
.ad19	d0 0f		bne $ad2a			bne 	_GXAYExit 					; underflow
.ad1b	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.ad1d	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.ad1f	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.ad21	b0 07		bcs $ad2a			bcs 	_GXAYExit
.ad23	18		clc				clc
.ad24	69 20		adc #$20			adc 	#$20 						; fix up
.ad26	85 3d		sta $3d				sta 	gxzScreen+1
.ad28	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ad2a					_GXAYExit:
.ad2a	60		rts				rts
.ad2b					_GXAXRight:
.ad2b	ee cd 05	inc $05cd			inc 	GXX0
.ad2e	d0 03		bne $ad33			bne 	_GXAXNoCarry
.ad30	ee ce 05	inc $05ce			inc 	GXX0+1
.ad33					_GXAXNoCarry:
.ad33	ee df 05	inc $05df			inc 	gsOffset 					; pixel right
.ad36	d0 0e		bne $ad46			bne 	_GXAXExit 					; if not overflowed, exit.
.ad38	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ad3a	a5 3d		lda $3d				lda 	gxzScreen+1
.ad3c	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ad3e	90 06		bcc $ad46			bcc 	_GXAXExit
.ad40	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ad42	85 3d		sta $3d				sta 	gxzScreen+1
.ad44	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ad46					_GXAXExit:
.ad46	60		rts				rts
.ad47					GXIncrementY:
.ad47	ee cf 05	inc $05cf			inc 	GXY0
.ad4a	20 be b1	jsr $b1be			jsr 	GXMovePositionDown
.ad4d	60		rts				rts
.ad4e					GXLineSetup:
.ad4e	ad d3 05	lda $05d3			lda 	GXY1
.ad51	38		sec				sec
.ad52	ed cf 05	sbc $05cf			sbc 	GXY0
.ad55	4a		lsr a				lsr 	a
.ad56	8d 6b 06	sta $066b			sta 	GXDiffY
.ad59	9c 6d 06	stz $066d			stz 	GXDXNegative 				; clear -ve flag
.ad5c	38		sec				sec
.ad5d	ad d1 05	lda $05d1			lda 	GXX1
.ad60	ed cd 05	sbc $05cd			sbc 	GXX0
.ad63	8d 6a 06	sta $066a			sta 	GXDiffX
.ad66	ad d2 05	lda $05d2			lda 	GXX1+1 						; calculate MSB
.ad69	ed ce 05	sbc $05ce			sbc 	GXX0+1
.ad6c	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ad6d	6e 6a 06	ror $066a			ror 	GXDiffX
.ad70	0a		asl a				asl 	a
.ad71	10 0c		bpl $ad7f			bpl 	_GDXNotNegative
.ad73	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ad75	38		sec				sec
.ad76	ed 6a 06	sbc $066a			sbc 	GXDiffX
.ad79	8d 6a 06	sta $066a			sta 	GXDiffX
.ad7c	ce 6d 06	dec $066d			dec 	GXDXNegative 				; -ve flag = $FF.
.ad7f					_GDXNotNegative:
.ad7f	9c 6c 06	stz $066c			stz 	GXIsDiffYLarger 			; clear larger flag
.ad82	ad 6b 06	lda $066b			lda 	GXDiffY 					; set adjust and total.
.ad85	8d 6f 06	sta $066f			sta 	GXAdjust
.ad88	ad 6a 06	lda $066a			lda 	GXDiffX
.ad8b	8d 70 06	sta $0670			sta 	GXTotal
.ad8e	ad 6b 06	lda $066b			lda 	GXDiffY 					; if dy > dx
.ad91	cd 6a 06	cmp $066a			cmp 	GXDiffX
.ad94	90 0f		bcc $ada5			bcc 	_GDXNotLarger
.ad96	ce 6c 06	dec $066c			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ad99	ad 6a 06	lda $066a			lda 	GXDiffX 					; set adjust and total other way round
.ad9c	8d 6f 06	sta $066f			sta 	GXAdjust
.ad9f	ad 6b 06	lda $066b			lda 	GXDiffY
.ada2	8d 70 06	sta $0670			sta 	GXTotal
.ada5					_GDXNotLarger:
.ada5	ad 70 06	lda $0670			lda 	GXTotal
.ada8	4a		lsr a				lsr 	a
.ada9	8d 6e 06	sta $066e			sta 	GXPosition
.adac	60		rts				rts
.066a					GXDiffX:
>066a							.fill 	1
.066b					GXDiffY:
>066b							.fill 	1
.066c					GXIsDiffYLarger:
>066c							.fill 	1
.066d					GXDXNegative:
>066d							.fill 	1
.066e					GXPosition:
>066e							.fill 	1
.066f					GXAdjust:
>066f							.fill 	1
.0670					GXTotal:
>0670							.fill 	1
.0671					GXAddSelect:
>0671							.fill 	1
.adad					GXSetColourMode:
.adad	a6 36		ldx $36				ldx 	gxzTemp0
.adaf	8e db 05	stx $05db			stx 	gxColour 								; set colour
.adb2	a5 37		lda $37				lda 	gxzTemp0+1 								;
.adb4	8d da 05	sta $05da			sta 	gxMode 									; set mode
.adb7	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.adb9	9c dd 05	stz $05dd			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.adbc	ae db 05	ldx $05db			ldx 	gxColour
.adbf	8e dc 05	stx $05dc			stx 	gxEORValue
.adc2	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.adc4	90 03		bcc $adc9			bcc 	_GXSDCNotAndColour
.adc6	8e dd 05	stx $05dd			stx 	gxANDValue
.adc9					_GXSDCNotAndColour:
.adc9	d0 03		bne $adce			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.adcb	9c dc 05	stz $05dc			stz 	gxEORValue
.adce					_GXSDCNotAnd:
.adce	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.adcf	90 08		bcc $add9			bcc 	_GXSDCNoFlip
.add1	ad dd 05	lda $05dd			lda	 	gxANDValue
.add4	49 ff		eor #$ff			eor 	#$FF
.add6	8d dd 05	sta $05dd			sta 	gxANDValue
.add9					_GXSDCNoFlip:
.add9	18		clc				clc
.adda	60		rts				rts
.addb					GXPlotPoint:
.addb	20 58 b1	jsr $b158			jsr 	GXOpenBitmap 				; start drawing
.adde	20 68 b1	jsr $b168			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.ade1	ac df 05	ldy $05df			ldy 	gsOffset
.ade4	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.ade6	2d dd 05	and $05dd			and 	gxANDValue
.ade9	4d dc 05	eor $05dc			eor 	gxEORValue
.adec	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.adee	20 60 b1	jsr $b160			jsr 	GXCloseBitmap 				; stop drawing and exit
.adf1	18		clc				clc
.adf2	60		rts				rts
.adf3					GXFillRectangle:
.adf3	38		sec				sec
.adf4	80 01		bra $adf7			bra 	GXRectangle
.adf6					GXFrameRectangle:
.adf6	18		clc				clc
.adf7					GXRectangle:
.adf7	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.adfa	f0 35		beq $ae31			beq 	_GXRFail
.adfc	08		php				php 								; save Fill flag (CS)
.adfd	20 58 b1	jsr $b158			jsr 	GXOpenBitmap 				; start drawing
.ae00	20 80 b2	jsr $b280			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.ae03	20 68 b1	jsr $b168			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.ae06	38		sec				sec 								; sec = Draw line
.ae07	20 33 ae	jsr $ae33			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.ae0a	ad cf 05	lda $05cf			lda 	gxY0 						; reached end of rectangle ?
.ae0d	cd d3 05	cmp $05d3			cmp 	gxY1
.ae10	f0 19		beq $ae2b			beq 	_GXRectangleExit
.ae12					_GXRectLoop:
.ae12	20 be b1	jsr $b1be			jsr 	GXMovePositionDown 			; down one.
.ae15	ee cf 05	inc $05cf			inc 	gxY0 						; change Y pos
.ae18	ad cf 05	lda $05cf			lda 	gxY0 						; reached last line
.ae1b	cd d3 05	cmp $05d3			cmp 	gXY1
.ae1e	f0 07		beq $ae27			beq 	_GXLastLine
.ae20	28		plp				plp 								; get flag back
.ae21	08		php				php
.ae22	20 33 ae	jsr $ae33			jsr 	GXDrawLineX1X0 				; draw horizontal line
.ae25	80 eb		bra $ae12			bra 	_GXRectLoop
.ae27					_GXLastLine:
.ae27	38		sec				sec
.ae28	20 33 ae	jsr $ae33			jsr 	GXDrawLineX1X0
.ae2b					_GXRectangleExit:
.ae2b	68		pla				pla 								; throw fill flag.
.ae2c	20 60 b1	jsr $b160			jsr 	GXCloseBitmap 				; stop drawing and exit
.ae2f	18		clc				clc
.ae30	60		rts				rts
.ae31					_GXRFail:
.ae31	38		sec				sec
.ae32	60		rts				rts
.ae33					GXDrawLineX1X0:
.ae33	08		php				php 								; save solid/either-end
.ae34	38		sec				sec
.ae35	ad d1 05	lda $05d1			lda		gXX1
.ae38	ed cd 05	sbc $05cd			sbc 	gXX0
.ae3b	85 36		sta $36				sta 	gxzTemp0
.ae3d	ad d2 05	lda $05d2			lda 	gXX1+1
.ae40	ed ce 05	sbc $05ce			sbc 	gXX0+1
.ae43	85 37		sta $37				sta 	gxzTemp0+1
.ae45	28		plp				plp
.ae46					GXDrawLineTemp0:
.ae46	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.ae48	48		pha				pha
.ae49	a5 3d		lda $3d				lda 	gxzScreen+1
.ae4b	48		pha				pha
.ae4c	ad df 05	lda $05df			lda 	gsOffset
.ae4f	48		pha				pha
.ae50	a5 0b		lda $0b				lda 	GXEditSlot
.ae52	48		pha				pha
.ae53	ac df 05	ldy $05df			ldy 	gsOffset 					; Y offset
.ae56	90 1e		bcc $ae76			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.ae58					_GXDLTLine:
.ae58	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.ae5a	2d dd 05	and $05dd			and 	gxANDValue
.ae5d	4d dc 05	eor $05dc			eor 	gxEORValue
.ae60	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae62	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.ae64	d0 04		bne $ae6a			bne 	_GXDLTNoBorrow
.ae66	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.ae68	30 2e		bmi $ae98			bmi 	_GXDLTExit
.ae6a					_GXDLTNoBorrow:
.ae6a	c6 36		dec $36				dec 	gxzTemp0
.ae6c	c8		iny				iny 								; next slot.
.ae6d	d0 e9		bne $ae58			bne 	_GXDLTLine
.ae6f	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.ae71	20 a6 ae	jsr $aea6			jsr 	GXDLTCheckWrap				; check for new page.
.ae74	80 e2		bra $ae58			bra 	_GXDLTLine
.ae76					_GXDLTEndPoints:
.ae76	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.ae78	2d dd 05	and $05dd			and 	gxANDValue
.ae7b	4d dc 05	eor $05dc			eor 	gxEORValue
.ae7e	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae80	98		tya				tya 								; advance to right side
.ae81	18		clc				clc
.ae82	65 36		adc $36				adc 	gxzTemp0
.ae84	a8		tay				tay
.ae85	a5 3d		lda $3d				lda 	gxzScreen+1
.ae87	65 37		adc $37				adc 	gxzTemp0+1
.ae89	85 3d		sta $3d				sta 	gxzScreen+1
.ae8b	20 a6 ae	jsr $aea6			jsr 	GXDLTCheckWrap 			; fix up.
.ae8e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.ae90	2d dd 05	and $05dd			and 	gxANDValue
.ae93	4d dc 05	eor $05dc			eor 	gxEORValue
.ae96	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae98					_GXDLTExit:
.ae98	68		pla				pla
.ae99	85 0b		sta $0b				sta 	GXEditSlot
.ae9b	68		pla				pla
.ae9c	8d df 05	sta $05df			sta 	gsOffset
.ae9f	68		pla				pla
.aea0	85 3d		sta $3d				sta 	gxzScreen+1
.aea2	68		pla				pla
.aea3	85 3c		sta $3c				sta 	gxzScreen
.aea5	60		rts				rts
.aea6					GXDLTCheckWrap:
.aea6	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.aea8	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.aeaa	90 06		bcc $aeb2			bcc 	_GXDLTCWExit
.aeac	e9 20		sbc #$20			sbc 	#$20 						; fix up
.aeae	85 3d		sta $3d				sta 	gxzScreen+1
.aeb0	e6 0b		inc $0b				inc 	GXEditSlot
.aeb2					_GXDLTCWExit:
.aeb2	60		rts				rts
.aeb3					GXDrawGraphicElement:
.aeb3	8d 72 06	sta $0672			sta 	gxSize 						; save size
.aeb6	3a		dec a				dec 	a
.aeb7	8d 73 06	sta $0673			sta 	gxMask 						; and mask
.aeba	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP on
.aebd	f0 67		beq $af26			beq 	_GXSLFail
.aebf	ad cf 05	lda $05cf			lda 	gxY0 						; push Y on stack
.aec2	48		pha				pha
.aec3	8c 75 06	sty $0675			sty 	gxAcquireVector+1 			; and acquisition vector
.aec6	8e 74 06	stx $0674			stx 	gxAcquireVector
.aec9	20 58 b1	jsr $b158			jsr 	gxOpenBitmap 				; open the bitmap.
.aecc	ad 77 06	lda $0677			lda 	gxUseMode 					; scale bits
.aecf	4a		lsr a				lsr 	a
.aed0	4a		lsr a				lsr 	a
.aed1	4a		lsr a				lsr 	a
.aed2	29 07		and #$07			and		#7
.aed4	1a		inc a				inc 	a
.aed5	8d 76 06	sta $0676			sta 	gxScale
.aed8	64 38		stz $38				stz 	gxzTemp1					; start first line
.aeda					_GXGELoop:
.aeda	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.aedc	2c 77 06	bit $0677			bit 	gxUseMode 					; check for flip.
.aedf	10 06		bpl $aee7			bpl		_GXNoVFlip
.aee1	ad 73 06	lda $0673			lda 	gxMask
.aee4	38		sec				sec
.aee5	e5 38		sbc $38				sbc 	gxzTemp1
.aee7					_GXNoVFlip:
.aee7	aa		tax				tax 								; get the Xth line.
.aee8	20 28 af	jsr $af28			jsr 	_GXCallAcquire 				; get that data.
.aeeb	ad 76 06	lda $0676			lda 	gxScale 					; do scale identical copies of that line.
.aeee	85 39		sta $39				sta 	gxzTemp1+1
.aef0					_GXGELoop2:
.aef0	ad cf 05	lda $05cf			lda 	gxY0 						; off screen
.aef3	cd d9 05	cmp $05d9			cmp 	gxHeight
.aef6	b0 10		bcs $af08			bcs 	_GXDGEExit
.aef8	20 2b af	jsr $af2b			jsr 	GXRenderOneLine 			; render line
.aefb	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.aefd	d0 f1		bne $aef0			bne 	_GXGELoop2
.aeff	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.af01	a5 38		lda $38				lda 	gxzTemp1
.af03	cd 72 06	cmp $0672			cmp 	gxSize
.af06	d0 d2		bne $aeda			bne 	_GXGELoop
.af08					_GXDGEExit:
.af08	68		pla				pla 								; restore Y for next time
.af09	8d cf 05	sta $05cf			sta 	gxY0
.af0c	ae 76 06	ldx $0676			ldx 	gxScale 					; get scale (1-8)
.af0f					_GXShiftLeft:
.af0f	18		clc				clc
.af10	ad 72 06	lda $0672			lda 	gxSize
.af13	6d cd 05	adc $05cd			adc 	gxX0
.af16	8d cd 05	sta $05cd			sta 	gxX0
.af19	90 03		bcc $af1e			bcc 	_GXSLNoCarry
.af1b	ee ce 05	inc $05ce			inc 	gxX0+1
.af1e					_GXSLNoCarry:
.af1e	ca		dex				dex
.af1f	d0 ee		bne $af0f			bne 	_GXShiftLeft
.af21	20 60 b1	jsr $b160			jsr 	GXCloseBitmap
.af24	18		clc				clc
.af25	60		rts				rts
.af26					_GXSLFail:
.af26	38		sec				sec
.af27	60		rts				rts
.af28					_GXCallAcquire:
.af28	6c 74 06	jmp ($0674)			jmp 	(gxAcquireVector)
.af2b					GXRenderOneLine:
.af2b	20 68 b1	jsr $b168			jsr 	GXPositionCalc 				; calculate position/offset.
.af2e	ac df 05	ldy $05df			ldy 	gsOffset 					; Y contains position.
.af31	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.af33					_GXROLLoop1:
.af33	ad 76 06	lda $0676			lda 	gxScale 					; set to do 'scale' times
.af36	85 3b		sta $3b				sta 	gxzTemp2+1
.af38					_GXROLLoop2:
.af38	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.af3a	2c da 05	bit $05da			bit 	gxMode 						; check H Flip
.af3d	50 06		bvc $af45			bvc 	_GXNoHFlip
.af3f	ad 73 06	lda $0673			lda 	gxMask
.af42	38		sec				sec
.af43	e5 3a		sbc $3a				sbc 	gxzTemp2
.af45					_GXNoHFlip:
.af45	aa		tax				tax 								; read from the pixel buffer
.af46	bd 7b 05	lda $057b,x			lda 	gxPixelBuffer,x
.af49	d0 07		bne $af52			bne 	_GXDraw 					; draw if non zero
.af4b	ad 77 06	lda $0677			lda 	gxUseMode 					; check to see if solid background
.af4e	29 04		and #$04			and 	#4
.af50	f0 0a		beq $af5c			beq 	_GXZeroPixel
.af52					_GXDraw:
.af52	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.af54	2d dd 05	and $05dd			and 	gxANDValue
.af57	5d 7b 05	eor $057b,x			eor 	gxPixelBuffer,x
.af5a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af5c					_GXZeroPixel:
.af5c	c8		iny				iny 								; advance pointer
.af5d	d0 05		bne $af64			bne 	_GXNoShift
.af5f	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.af61	20 a6 ae	jsr $aea6			jsr 	GXDLTCheckWrap				; check for new page.
.af64					_GXNoShift:
.af64	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.af66	d0 d0		bne $af38			bne 	_GXROLLoop2
.af68	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.af6a	a5 3a		lda $3a				lda 	gxzTemp2
.af6c	cd 72 06	cmp $0672			cmp 	gxSize
.af6f	d0 c2		bne $af33			bne 	_GXROLLoop1
.af71	ee cf 05	inc $05cf			inc 	gxY0
.af74	60		rts				rts
.0672					gxSize:
>0672							.fill 	1
.0673					gxMask:
>0673							.fill 	1
.0674					gxAcquireVector:
>0674							.fill 	2
.0676					gxScale:
>0676							.fill 	1
.0677					gxUseMode:
>0677							.fill 	1
.af75					GXFontHandler:
.af75	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.af77	4d da 05	eor $05da			eor 	gxMode
.af7a	8d 77 06	sta $0677			sta 	gxUseMode
.af7d	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.af7f	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.af81	26 37		rol $37				rol	 	gxzTemp0+1
.af83	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.af85	26 37		rol $37				rol	 	gxzTemp0+1
.af87	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.af89	26 37		rol $37				rol	 	gxzTemp0+1
.af8b	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.af8d	09 c0		ora #$c0			ora 	#$C0
.af8f	85 37		sta $37				sta 	gxzTemp0+1
.af91	a9 08		lda #$08			lda 	#8 							; size 8x8
.af93	a2 9b		ldx #$9b			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.af95	a0 af		ldy #$af			ldy 	#GXGetGraphicDataFont >> 8
.af97	20 b3 ae	jsr $aeb3			jsr 	GXDrawGraphicElement
.af9a	60		rts				rts
.af9b					GXGetGraphicDataFont:
.af9b	8a		txa				txa 								; X->Y
.af9c	a8		tay				tay
.af9d	a6 01		ldx $01				ldx 	1 							; preserve old value
.af9f	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.afa1	85 01		sta $01				sta 	1
.afa3	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.afa5	86 01		stx $01				stx 	1 							; put old value back.
.afa7	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.afa9					_GXExpand:
.afa9	9e 7b 05	stz $057b,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.afac	0a		asl a				asl 	a 							; shift bit 7 into C
.afad	90 08		bcc $afb7			bcc 	_GXNoPixel
.afaf	48		pha				pha 								; if set, set pixel buffer to current colour.
.afb0	ad db 05	lda $05db			lda 	gxColour
.afb3	9d 7b 05	sta $057b,x			sta 	gxPixelBuffer,x
.afb6	68		pla				pla
.afb7					_GXNoPixel:
.afb7	e8		inx				inx 								; do the whole byte.
.afb8	e0 08		cpx #$08			cpx 	#8
.afba	d0 ed		bne $afa9			bne 	_GXExpand
.afbc	60		rts				rts
.afbd					GXSpriteHandler:
.afbd	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.afbf	4d da 05	eor $05da			eor 	gxMode
.afc2	8d 77 06	sta $0677			sta 	gxUseMode
.afc5	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.afc7	da		phx				phx
.afc8	20 58 b1	jsr $b158			jsr 	GXOpenBitmap 				; can access sprite information
.afcb	68		pla				pla
.afcc	20 39 b2	jsr $b239			jsr 	GXFindSprite 				; get the sprite address
.afcf	08		php				php
.afd0	20 60 b1	jsr $b160			jsr 	GXCloseBitmap
.afd3	28		plp				plp
.afd4	b0 0a		bcs $afe0			bcs		_GXSHExit 					; exit if find failed.
.afd6	ad 78 06	lda $0678			lda 	GXSizePixels 				; return size
.afd9	a2 e1		ldx #$e1			ldx 	#GXSpriteAcquire & $FF
.afdb	a0 af		ldy #$af			ldy 	#GXSpriteAcquire >> 8
.afdd	20 b3 ae	jsr $aeb3			jsr 	GXDrawGraphicElement
.afe0					_GXSHExit:
.afe0	60		rts				rts
.afe1					GXSpriteAcquire:
.afe1	ad d8 05	lda $05d8			lda 	GXSpritePage				; point to base page
.afe4	85 0b		sta $0b				sta 	GXEditSlot
.afe6	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.afe8	a9 00		lda #$00			lda 	#0
.afea	ae 79 06	ldx $0679			ldx 	GXSizeBits
.afed					_GXTimesRowNumber:
.afed	18		clc				clc
.afee	65 36		adc $36				adc 	zTemp0
.aff0	ca		dex				dex
.aff1	10 fa		bpl $afed			bpl 	_GXTimesRowNumber
.aff3	64 37		stz $37				stz 	gxzTemp0+1
.aff5	0a		asl a				asl 	a 							; row x 2,4,6,8
.aff6	26 37		rol $37				rol 	gxzTemp0+1
.aff8	0a		asl a				asl 	a 							; row x 4,8,12,16
.aff9	26 37		rol $37				rol 	gxzTemp0+1
.affb	0a		asl a				asl 	a 							; row x 8,16,24,32
.affc	26 37		rol $37				rol 	gxzTemp0+1
.affe	85 36		sta $36				sta 	gxzTemp0
.b000	18		clc				clc 								; add base address.
.b001	a5 36		lda $36				lda 	gxzTemp0
.b003	6d 7b 06	adc $067b			adc 	GXSpriteOffset
.b006	85 36		sta $36				sta 	gxzTemp0
.b008	a5 37		lda $37				lda 	gxzTemp0+1
.b00a	6d 7c 06	adc $067c			adc 	GXSpriteOffset+1
.b00d					_GXSAFindPage:
.b00d	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b00f	90 06		bcc $b017			bcc 	_GXSAFoundPage
.b011	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b013	e6 0b		inc $0b				inc 	GXEditSlot
.b015	80 f6		bra $b00d			bra 	_GXSAFindPage
.b017					_GXSAFoundPage:
.b017	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b019	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b01b	a0 00		ldy #$00			ldy 	#0
.b01d					_GXSACopyLoop:
.b01d	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b01f	99 7b 05	sta $057b,y			sta 	gxPixelBuffer,y
.b022	c8		iny				iny
.b023	cc 78 06	cpy $0678			cpy 	GXSizePixels
.b026	d0 f5		bne $b01d			bne 	_GXSACopyLoop
.b028	60		rts				rts
.b029					GXSelect:
.b029	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b02c	f0 22		beq $b050			beq 	_GXSFail
.b02e	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b030	c9 40		cmp #$40			cmp 	#64
.b032	b0 1c		bcs $b050			bcs 	_GXSFail
.b034	8d e0 05	sta $05e0			sta 	GSCurrentSpriteID
.b037	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b039	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b03b	06 36		asl $36				asl 	gxzTemp0
.b03d	06 36		asl $36				asl 	gxzTemp0
.b03f	06 36		asl $36				asl 	gxzTemp0
.b041	2a		rol a				rol 	a
.b042	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b044	8d e2 05	sta $05e2			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b047	85 37		sta $37				sta 	gxzTemp0+1
.b049	a5 36		lda $36				lda 	gxzTemp0
.b04b	8d e1 05	sta $05e1			sta 	GSCurrentSpriteAddr
.b04e	18		clc				clc
.b04f	60		rts				rts
.b050					_GXSFail:
.b050	38		sec				sec
.b051	60		rts				rts
.b052					GXSelectImage:
.b052	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b055	f0 74		beq $b0cb			beq 	_GXSIFail
.b057	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b05a	f0 6f		beq $b0cb			beq 	_GXSIFail 					; (checking the MSB)
.b05c	64 01		stz $01				stz 	1
.b05e	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b060	d0 6b		bne $b0cd			bne 	_GXSIHide
.b062	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b064	48		pha				pha
.b065	20 58 b1	jsr $b158			jsr 	GXOpenBitmap
.b068	68		pla				pla
.b069	20 39 b2	jsr $b239			jsr 	GXFindSprite
.b06c	b0 5a		bcs $b0c8			bcs 	_GXSICloseFail 				; no image
.b06e	a0 01		ldy #$01			ldy 	#1
.b070	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b073	85 36		sta $36				sta 	gxzTemp0
.b075	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b078	85 37		sta $37				sta 	gxzTemp0+1
.b07a	ad 7b 06	lda $067b			lda 	GXSpriteOffset
.b07d	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b07f	18		clc				clc
.b080	ad 7c 06	lda $067c			lda 	GXSpriteOffset+1
.b083	6d e3 05	adc $05e3			adc 	GXSpriteOffsetBase
.b086	c8		iny				iny
.b087	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b089	ad e4 05	lda $05e4			lda 	GXSpriteOffsetBase+1
.b08c	69 00		adc #$00			adc 	#0
.b08e	c8		iny				iny
.b08f	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b091	ad 79 06	lda $0679			lda 	GXSizeBits 					; get raw size
.b094	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b096	2a		rol a				rol 	a 							; x 2
.b097	0a		asl a				asl 	a 							; x 4
.b098	0a		asl a				asl 	a 							; x 8
.b099	0a		asl a				asl 	a 							; x 16
.b09a	0d 7a 06	ora $067a			ora 	GXSpriteLUT 				; Or with LUT
.b09d	0a		asl a				asl 	a 							; 1 shift
.b09e	09 01		ora #$01			ora 	#1 							; enable sprite.
.b0a0	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b0a2	20 60 b1	jsr $b160			jsr 	GXCloseBitmap
.b0a5	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b0a8	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b0ab	29 3f		and #$3f			and 	#$3F
.b0ad	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b0b0	ad 79 06	lda $0679			lda 	GXSizeBits 					; get bit size
.b0b3	6a		ror a				ror 	a 							; shift into bits 6/7
.b0b4	6a		ror a				ror 	a
.b0b5	6a		ror a				ror 	a
.b0b6	29 c0		and #$c0			and 	#$C0
.b0b8	1d 25 06	ora $0625,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b0bb	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b0be	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b0c1	29 7f		and #$7f			and 	#$7F
.b0c3	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b0c6	18		clc				clc
.b0c7	60		rts				rts
.b0c8					_GXSICloseFail:
.b0c8	20 60 b1	jsr $b160			jsr 	GXCloseBitmap
.b0cb					_GXSIFail:
.b0cb	38		sec				sec
.b0cc	60		rts				rts
.b0cd					_GXSIHide:
.b0cd	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b0d0	85 36		sta $36				sta 	gxzTemp0
.b0d2	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b0d5	85 37		sta $37				sta 	gxzTemp0+1
.b0d7	a9 00		lda #$00			lda 	#0
.b0d9	92 36		sta ($36)			sta 	(gxzTemp0)
.b0db	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get sprite ID
.b0de	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b0e1	09 80		ora #$80			ora 	#$80
.b0e3	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b0e6	18		clc				clc
.b0e7	60		rts				rts
.b0e8					GXMoveSprite:
.b0e8	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b0eb	f0 65		beq $b152			beq 	_GXSIFail
.b0ed	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b0f0	f0 60		beq $b152			beq 	_GXSIFail
.b0f2	85 37		sta $37				sta 	gxzTemp0+1
.b0f4	a0 04		ldy #$04			ldy 	#4
.b0f6	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b0f9	85 36		sta $36				sta 	gxzTemp0
.b0fb	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b0fe	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b101	2a		rol a				rol 	a	 						; into bits 0,1.
.b102	2a		rol a				rol 	a
.b103	2a		rol a				rol 	a
.b104	29 03		and #$03			and 	#3
.b106	aa		tax				tax
.b107	bd 54 b1	lda $b154,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b10a	48		pha				pha
.b10b	18		clc				clc
.b10c	6d cd 05	adc $05cd			adc 	gxX0						; copy position.
.b10f	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b111	c8		iny				iny
.b112	ad ce 05	lda $05ce			lda 	gxX0+1
.b115	69 00		adc #$00			adc 	#0
.b117	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b119	c8		iny				iny
.b11a	68		pla				pla
.b11b	18		clc				clc
.b11c	6d cf 05	adc $05cf			adc 	gxY0
.b11f	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b121	a9 00		lda #$00			lda 	#0
.b123	69 00		adc #$00			adc 	#0
.b125	c8		iny				iny
.b126	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b128	4e ce 05	lsr $05ce			lsr 	gxX0+1 						; divide X by 4
.b12b	6e cd 05	ror $05cd			ror 	gxX0
.b12e	4e cd 05	lsr $05cd			lsr 	gxX0
.b131	4e cf 05	lsr $05cf			lsr 	gxY0 						; divide Y by 4
.b134	4e cf 05	lsr $05cf			lsr 	gxY0
.b137	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b13a	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x
.b13d	29 80		and #$80			and 	#$80
.b13f	0d cd 05	ora $05cd			ora 	gxX0
.b142	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b145	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b148	29 c0		and #$c0			and 	#$C0
.b14a	0d cf 05	ora $05cf			ora 	gxY0
.b14d	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b150	18		clc				clc
.b151	60		rts				rts
.b152					_GXSIFail:
.b152	38		sec				sec
.b153	60		rts				rts
.b154					_GXMSOffset:
>b154	1c						.byte 	32-8/2
>b155	18						.byte 	32-16/2
>b156	14						.byte 	32-24/2
>b157	10						.byte 	32-32/2
.b158					GXOpenBitmap:
.b158	78		sei				sei 								; no interrupts here
.b159	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b15b	8d de 05	sta $05de			sta 	gxOriginalLUTValue
.b15e	58		cli				cli
.b15f	60		rts				rts
.b160					GXCloseBitmap:
.b160	78		sei				sei
.b161	ad de 05	lda $05de			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b164	85 0b		sta $0b				sta 	GXEditSlot
.b166	58		cli				cli
.b167	60		rts				rts
.b168					GXPositionCalc:
.b168	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b16a	48		pha				pha
.b16b	ad cf 05	lda $05cf			lda 	GXY0 						; gxzScreen = Y0
.b16e	85 3c		sta $3c				sta 	gxzScreen
.b170	64 3d		stz $3d				stz 	gxzScreen+1
.b172	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b174	26 3d		rol $3d				rol 	gxzScreen+1
.b176	06 3c		asl $3c				asl 	gxzScreen
.b178	26 3d		rol $3d				rol 	gxzScreen+1
.b17a	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b17b	65 3c		adc $3c				adc 	gxzScreen
.b17d	85 3c		sta $3c				sta 	gxzScreen
.b17f	90 02		bcc $b183			bcc 	_GXPCNoCarry
.b181	e6 3d		inc $3d				inc 	gxzScreen+1
.b183					_GXPCNoCarry:
.b183	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b185	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b187	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b189	85 36		sta $36				sta 	gxzTemp0
.b18b	64 3d		stz $3d				stz 	gxzScreen+1
.b18d	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b18f					_GXPCMultiply32:
.b18f	06 3c		asl $3c				asl 	gxzScreen
.b191	26 3d		rol $3d				rol 	gxzScreen+1
.b193	3a		dec a				dec 	a
.b194	d0 f9		bne $b18f			bne 	_GXPCMultiply32
.b196	18		clc				clc
.b197	ad cd 05	lda $05cd			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b19a	65 3c		adc $3c				adc 	gxzScreen
.b19c	8d df 05	sta $05df			sta 	gsOffset
.b19f	ad ce 05	lda $05ce			lda 	GXX0+1
.b1a2	65 3d		adc $3d				adc 	gxzScreen+1
.b1a4	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b1a6	90 04		bcc $b1ac			bcc 	_GXPCNoOverflow
.b1a8	29 1f		and #$1f			and 	#$1F 						; fix it up
.b1aa	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b1ac					_GXPCNoOverflow:
.b1ac	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b1ae	85 3d		sta $3d				sta 	gxzScreen+1
.b1b0	64 3c		stz $3c				stz 	gxzScreen
.b1b2	18		clc				clc
.b1b3	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b1b5	6d d7 05	adc $05d7			adc 	gxBasePage 					; by adding the base page
.b1b8	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b1ba	68		pla				pla
.b1bb	85 36		sta $36				sta 	gxzTemp0
.b1bd	60		rts				rts
.b1be					GXMovePositionDown:
.b1be	18		clc				clc 								; add 320 to offset/temp+1
.b1bf	ad df 05	lda $05df			lda 	gsOffset
.b1c2	69 40		adc #$40			adc 	#64
.b1c4	8d df 05	sta $05df			sta 	gsOffset
.b1c7	a5 3d		lda $3d				lda 	gxzScreen+1
.b1c9	69 01		adc #$01			adc 	#1
.b1cb	85 3d		sta $3d				sta 	gxzScreen+1
.b1cd	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b1cf	90 07		bcc $b1d8			bcc 	_GXMPDExit
.b1d1	38		sec				sec  								; next page
.b1d2	e9 20		sbc #$20			sbc 	#$20
.b1d4	85 3d		sta $3d				sta 	gxzScreen+1
.b1d6	e6 0b		inc $0b				inc 	GXEditSlot
.b1d8					_GXMPDExit:
.b1d8	60		rts				rts
.b1d9					GXCollide:
.b1d9	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b1db	aa		tax				tax
.b1dc	05 37		ora $37				ora 	gxzTemp0+1
.b1de	29 c0		and #$c0			and 	#$C0
.b1e0	38		sec				sec
.b1e1	d0 53		bne $b236			bne 	_GXCollideFail 				; if either >= 64, fail.
.b1e3	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b1e5	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b1e8	1d e5 05	ora $05e5,x			ora 	GXSpriteLow,x
.b1eb	30 48		bmi $b235			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b1ed	18		clc				clc 								; need to calculate sum of sizes.
.b1ee	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y
.b1f1	7d 25 06	adc $0625,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b1f4	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b1f6	6a		ror a				ror 	a 							; 5/6/7
.b1f7	4a		lsr a				lsr 	a 							; 4/5/6
.b1f8	4a		lsr a				lsr 	a 							; 3/4/5
.b1f9	4a		lsr a				lsr 	a 							; 2/3/4
.b1fa	18		clc				clc
.b1fb	69 08		adc #$08			adc 	#$08
.b1fd	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b1fe	4a		lsr a				lsr 	a
.b1ff	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b201	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b204	29 3f		and #$3f			and 	#$3F
.b206	85 39		sta $39				sta 	gxzTemp1+1
.b208	38		sec				sec
.b209	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b20c	29 3f		and #$3f			and 	#$3F
.b20e	e5 39		sbc $39				sbc 	gxzTemp1+1
.b210	b0 03		bcs $b215			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b212	49 ff		eor #$ff			eor 	#$FF
.b214	1a		inc a				inc 	a
.b215					_GXCAbs1:
.b215	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b217	b0 1c		bcs $b235			bcs 	_GXOkayFail
.b219	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b21b	38		sec				sec 								; calculate |x1-x0|
.b21c	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y
.b21f	fd e5 05	sbc $05e5,x			sbc 	GXSpriteLow,x
.b222	b0 03		bcs $b227			bcs 	_GXCAbs2
.b224	49 ff		eor #$ff			eor 	#$FF
.b226	1a		inc a				inc 	a
.b227					_GXCAbs2:
.b227	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b229	b0 0a		bcs $b235			bcs 	_GXOkayFail
.b22b	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b22d	90 02		bcc $b231			bcc 	_GXCHaveLowest
.b22f	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b231					_GXCHaveLowest:
.b231	0a		asl a				asl 	a 							; scale to allow for >> 2
.b232	0a		asl a				asl 	a
.b233	18		clc				clc
.b234	60		rts				rts
.b235					_GXOkayFail:
.b235	18		clc				clc
.b236					_GXCollideFail:
.b236	a9 ff		lda #$ff			lda 	#$FF
.b238	60		rts				rts
.b239					GXFindSprite:
.b239	aa		tax				tax
.b23a	ad d8 05	lda $05d8			lda 	GXSpritePage 				; access the base page of the sprite
.b23d	85 0b		sta $0b				sta 	GXEditSlot
.b23f	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b242	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b245	f0 33		beq $b27a			beq 	_GXFSFail
.b247	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b24a	8d 7c 06	sta $067c			sta 	GXSpriteOffset+1
.b24d	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b250	48		pha				pha 								; save twice
.b251	48		pha				pha
.b252	29 03		and #$03			and 	#3 							; get sprite size
.b254	8d 79 06	sta $0679			sta 	GXSizeBits 					; save raw (0-3)
.b257	aa		tax				tax
.b258	bd 7c b2	lda $b27c,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b25b	8d 78 06	sta $0678			sta 	GXSizePixels 					; save (8/16/24/32)
.b25e	68		pla				pla 								; get LUT
.b25f	4a		lsr a				lsr		a
.b260	4a		lsr a				lsr		a
.b261	29 03		and #$03			and 	#3
.b263	8d 7a 06	sta $067a			sta 	GXSpriteLUT
.b266	68		pla				pla 								; address, neeeds to be x 4
.b267	29 f0		and #$f0			and 	#$F0
.b269	8d 7b 06	sta $067b			sta 	GXSpriteOffset
.b26c	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b26f	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b272	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b275	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b278	18		clc				clc
.b279	60		rts				rts
.b27a					_GXFSFail:
.b27a	38		sec				sec
.b27b	60		rts				rts
.b27c					_GXFXSSTTable:
>b27c	08 10 18 20					.byte 	8,16,24,32
.0678					GXSizePixels:
>0678							.fill 	1
.0679					GXSizeBits:
>0679							.fill 	1
.067a					GXSpriteLUT:
>067a							.fill 	1
.067b					GXSpriteOffset:
>067b							.fill 	2
.b280					GXSortXY:
.b280	20 9e b2	jsr $b29e			jsr 	GXSortY 					; will be sorted on Y now
.b283	ad cd 05	lda $05cd			lda 	gxX0 						; compare X0 v X1
.b286	cd d1 05	cmp $05d1			cmp 	gxX1
.b289	ad ce 05	lda $05ce			lda 	gXX0+1
.b28c	ed d2 05	sbc $05d2			sbc 	gXX1+1
.b28f	90 0c		bcc $b29d			bcc 	_GXSXYExit 					; X0 < X1 exit
.b291	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b293	a0 04		ldy #$04			ldy 	#4
.b295	20 b2 b2	jsr $b2b2			jsr 	GXSwapXY
.b298	e8		inx				inx
.b299	c8		iny				iny
.b29a	20 b2 b2	jsr $b2b2			jsr 	GXSwapXY
.b29d					_GXSXYExit:
.b29d	60		rts				rts
.b29e					GXSortY:
.b29e	ad cf 05	lda $05cf			lda 	gxY0 						; if Y0 >= Y1
.b2a1	cd d3 05	cmp $05d3			cmp 	gxY1
.b2a4	90 0b		bcc $b2b1			bcc 	_GXSYSorted
.b2a6	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b2a8	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b2aa					_GXSwap1:
.b2aa	20 b2 b2	jsr $b2b2			jsr 	GXSwapXY
.b2ad	88		dey				dey
.b2ae	ca		dex				dex
.b2af	10 f9		bpl $b2aa			bpl 	_GXSwap1
.b2b1					_GXSYSorted:
.b2b1	60		rts				rts
.b2b2					GXSwapXY:
.b2b2	bd cd 05	lda $05cd,x			lda 	gxX0,x
.b2b5	48		pha				pha
.b2b6	b9 cd 05	lda $05cd,y			lda 	gxX0,y
.b2b9	9d cd 05	sta $05cd,x			sta 	gxX0,x
.b2bc	68		pla				pla
.b2bd	99 cd 05	sta $05cd,y			sta 	gxX0,y
.b2c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b967					KeywordSet0:
>b967	00 65					.text	0,$65,""               ; $80 !0:EOF
>b969	00 58					.text	0,$58,""               ; $81 !1:SH1
>b96b	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b96d	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b973	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b97b	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b981	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b988	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>b990	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>b997	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>b99e	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>b9a4	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>b9aa	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>b9b2	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>b9b9	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>b9c0	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>b9c7	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>b9cf	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>b9d5	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>b9db	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>b9e2	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>b9e8	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>b9ee	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>b9f6	47 28
>b9f8	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>ba00	28
>ba01	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>ba09	28
>ba0a	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>ba10	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>ba16	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>ba1c	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>ba23	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>ba2b	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>ba31	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>ba37	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>ba3c	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>ba40	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>ba46	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>ba4e	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>ba55	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>ba5c	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>ba64	43
>ba65	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>ba6b	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>ba71	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>ba78	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>ba7e	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>ba82	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>ba88	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>ba90	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>ba97	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>ba9c	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>baa3	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>baab	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bab1	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bab6	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>babe	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bac4	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>baca	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bacf	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bad6	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>badc	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bae2	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bae9	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>baf0	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>baf5	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>bafb	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>bb02	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>bb07	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>bb0b	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>bb13	45
>bb14	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>bb1c	45
>bb1d	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>bb23	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>bb2a	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>bb30	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>bb36	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>bb3b	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bb43	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>bb4a	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bb51	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>bb59	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bb5f	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bb63	ff					.text	$FF
.bb64					KeywordSet1:
>bb64	00 65					.text	0,$65,""               ; $80 !0:EOF
>bb66	00 58					.text	0,$58,""               ; $81 !1:SH1
>bb68	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bb6a	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bb72	4c 45
>bb74	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bb7c	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bb84	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bb89	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>bb8d	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>bb93	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>bb99	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>bb9e	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>bba6	45
>bba7	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>bbac	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>bbb4	53
>bbb5	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>bbbb	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $8f WHO
>bbc0	ff					.text	$FF
.bbc1					KeywordSet2:
>bbc1	00 65					.text	0,$65,""               ; $80 !0:EOF
>bbc3	00 58					.text	0,$58,""               ; $81 !1:SH1
>bbc5	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bbc7	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bbcc	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bbd1	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bbd6	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bbdb	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bbe0	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bbe5	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bbea	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bbef	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bbf4	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bbf9	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bbfe	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bc03	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bc08	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bc0d	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bc12	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bc17	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bc1c	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bc21	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bc26	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bc2b	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bc30	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bc35	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bc3a	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bc3f	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bc44	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bc49	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bc4e	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bc53	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bc58	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bc5d	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bc62	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bc67	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bc6c	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bc71	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bc76	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bc7b	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bc80	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bc85	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bc8a	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bc8f	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bc94	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bc99	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bc9e	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bca3	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bca8	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bcad	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bcb2	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bcb7	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bcbc	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bcc1	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bcc6	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bccb	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bcd0	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bcd5	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bcda	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bcdf	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bce4	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bce9	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bcee	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bcf3	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bcf8	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bcfd	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bd02	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bd07	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bd0c	ff					.text	$FF
.b2c1					ListConvertLine:
.b2c1	48		pha				pha 								; save indent on the stack
.b2c2	9c 1d 04	stz $041d			stz 	tbOffset
.b2c5	9c 2d 04	stz $042d			stz 	tokenBuffer
.b2c8	9c 29 04	stz $0429			stz 	currentListColour
.b2cb	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b2cd	b1 30		lda ($30),y			lda 	(codePtr),y
.b2cf	aa		tax				tax
.b2d0	88		dey				dey
.b2d1	b1 30		lda ($30),y			lda 	(codePtr),y
.b2d3	20 af 92	jsr $92af			jsr 	LCLConvertInt16
.b2d6	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b2d8	86 37		stx $37				stx 	zTemp0+1
.b2da	a9 89		lda #$89			lda 	#CLINumber+$80
.b2dc	20 35 b4	jsr $b435			jsr 	LCLWriteColour
.b2df	a0 00		ldy #$00			ldy 	#0
.b2e1					_LCCopyNumber:
.b2e1	b1 36		lda ($36),y			lda 	(zTemp0),y
.b2e3	20 3e b4	jsr $b43e			jsr 	LCLWrite
.b2e6	c8		iny				iny
.b2e7	b1 36		lda ($36),y			lda 	(zTemp0),y
.b2e9	d0 f6		bne $b2e1			bne 	_LCCopyNumber
.b2eb	68		pla				pla 								; adjustment to indent
.b2ec	48		pha				pha 								; save on stack
.b2ed	10 0c		bpl $b2fb			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b2ef	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b2f0	6d 26 04	adc $0426			adc 	listIndent
.b2f3	8d 26 04	sta $0426			sta 	listIndent
.b2f6	10 03		bpl $b2fb			bpl 	_LCNoAdjust
.b2f8	9c 26 04	stz $0426			stz 	listIndent
.b2fb					_LCNoAdjust:
.b2fb	18		clc				clc		 							; work out actual indent.
.b2fc	ad 26 04	lda $0426			lda 	listIndent
.b2ff	0a		asl a				asl 	a
.b300	69 06		adc #$06			adc 	#6
.b302	85 36		sta $36				sta 	zTemp0
.b304					_LCPadOut:
.b304	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b306	20 3e b4	jsr $b43e			jsr 	LCLWrite
.b309	ad 1d 04	lda $041d			lda 	tbOffset
.b30c	c5 36		cmp $36				cmp 	zTemp0
.b30e	d0 f4		bne $b304			bne 	_LCPadOut
.b310	a0 03		ldy #$03			ldy 	#3 							; start position.
.b312					_LCMainLoop:
.b312	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b314	20 35 b4	jsr $b435			jsr 	LCLWriteColour
.b317	b1 30		lda ($30),y			lda 	(codePtr),y
.b319	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b31b	f0 17		beq $b334			beq 	_LCExit
.b31d	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b31f	90 1e		bcc $b33f			bcc 	_LCDoubles
.b321	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b323	90 2a		bcc $b34f			bcc 	_LCShiftPunc
.b325	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b327	90 35		bcc $b35e			bcc 	_LCPunctuation
.b329	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b32b	90 51		bcc $b37e			bcc 	_LCIdentifiers
.b32d	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b32f	90 73		bcc $b3a4			bcc 	_LCTokens
.b331	4c 04 b4	jmp $b404			jmp 	_LCData 					; 254-5 are data objects
.b334					_LCExit:
.b334	68		pla				pla 								; get old indent adjust
.b335	30 07		bmi $b33e			bmi 	_LCExit2
.b337	18		clc				clc 								; add to indent if +ve
.b338	6d 26 04	adc $0426			adc 	listIndent
.b33b	8d 26 04	sta $0426			sta 	listIndent
.b33e					_LCExit2:
.b33e	60		rts				rts
.b33f					_LCDoubles:
.b33f	48		pha				pha
.b340	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b341	29 02		and #$02			and 	#2
.b343	09 3c		ora #$3c			ora 	#60 						; make < >
.b345	20 3e b4	jsr $b43e			jsr 	LCLWrite
.b348	68		pla				pla 								; restore, do lower bit
.b349	29 03		and #$03			and 	#3
.b34b	09 3c		ora #$3c			ora 	#60
.b34d	80 0f		bra $b35e			bra		_LCPunctuation 				; print, increment, loop
.b34f					_LCShiftPunc:
.b34f	aa		tax				tax 								; save in X
.b350	29 07		and #$07			and 	#7 							; lower 3 bits
.b352	f0 02		beq $b356			beq 	_LCNoAdd
.b354	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b356					_LCNoAdd:
.b356	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b358	90 02		bcc $b35c			bcc 	_LCNoAdd2
.b35a	09 20		ora #$20			ora 	#32 						; adds $20
.b35c					_LCNoAdd2:
.b35c	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b35e					_LCPunctuation:
.b35e	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b360	d0 03		bne $b365			bne 	_LCPContinue
.b362	20 54 b4	jsr $b454			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b365					_LCPContinue:
.b365	c9 2e		cmp #$2e			cmp 	#'.'
.b367	f0 08		beq $b371			beq 	_LCPIsConstant
.b369	c9 30		cmp #$30			cmp 	#'0'
.b36b	90 0b		bcc $b378			bcc 	_LCPNotConstant
.b36d	c9 3a		cmp #$3a			cmp 	#'9'+1
.b36f	b0 07		bcs $b378			bcs 	_LCPNotConstant
.b371					_LCPIsConstant:
.b371	48		pha				pha
.b372	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b374	20 35 b4	jsr $b435			jsr 	LCLWriteColour
.b377	68		pla				pla
.b378					_LCPNotConstant:
.b378	c8		iny				iny 								; consume character
.b379	20 3e b4	jsr $b43e			jsr 	LCLWrite 					; write it out.
.b37c	80 94		bra $b312			bra 	_LCMainLoop 				; go round again.
.b37e					_LCIdentifiers:
.b37e	18		clc				clc 								; convert to physical address
.b37f	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b381	85 37		sta $37				sta 	zTemp0+1
.b383	c8		iny				iny
.b384	b1 30		lda ($30),y			lda 	(codePtr),y
.b386	85 36		sta $36				sta 	zTemp0
.b388	c8		iny				iny
.b389	5a		phy				phy 								; save position
.b38a	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b38c	20 35 b4	jsr $b435			jsr 	LCLWriteColour
.b38f	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b391					_LCOutIdentifier:
.b391	c8		iny				iny
.b392	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b394	29 7f		and #$7f			and 	#$7F
.b396	20 90 b4	jsr $b490			jsr 	LCLLowerCase
.b399	20 3e b4	jsr $b43e			jsr 	LCLWrite
.b39c	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b39e	10 f1		bpl $b391			bpl 	_LCOutIdentifier
.b3a0	7a		ply				ply 								; restore position
.b3a1	4c 12 b3	jmp $b312			jmp 	_LCMainLoop
.b3a4					_LCTokens:
.b3a4	aa		tax				tax 								; token in X
.b3a5	a9 c1		lda #$c1			lda 	#((KeywordSet2) & $FF)
.b3a7	85 36		sta $36				sta 	0+zTemp0
.b3a9	a9 bb		lda #$bb			lda 	#((KeywordSet2) >> 8)
.b3ab	85 37		sta $37				sta 	1+zTemp0
.b3ad	e0 82		cpx #$82			cpx 	#$82
.b3af	f0 16		beq $b3c7			beq 	_LCUseShift
.b3b1	a9 64		lda #$64			lda 	#((KeywordSet1) & $FF)
.b3b3	85 36		sta $36				sta 	0+zTemp0
.b3b5	a9 bb		lda #$bb			lda 	#((KeywordSet1) >> 8)
.b3b7	85 37		sta $37				sta 	1+zTemp0
.b3b9	e0 81		cpx #$81			cpx 	#$81
.b3bb	f0 0a		beq $b3c7			beq 	_LCUseShift
.b3bd	a9 67		lda #$67			lda 	#((KeywordSet0) & $FF)
.b3bf	85 36		sta $36				sta 	0+zTemp0
.b3c1	a9 b9		lda #$b9			lda 	#((KeywordSet0) >> 8)
.b3c3	85 37		sta $37				sta 	1+zTemp0
.b3c5	80 01		bra $b3c8			bra 	_LCNoShift
.b3c7					_LCUseShift:
.b3c7	c8		iny				iny
.b3c8					_LCNoShift:
.b3c8	20 68 b4	jsr $b468			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b3cb	b1 30		lda ($30),y			lda 	(codePtr),y
.b3cd	aa		tax				tax 								; into X
.b3ce					_LCFindText:
.b3ce	ca		dex				dex
.b3cf	10 0e		bpl $b3df			bpl 	_LCFoundText 				; found text.
.b3d1	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b3d3	1a		inc a				inc 	a 							; one extra for size
.b3d4	38		sec				sec 								; one extra for checksum
.b3d5	65 36		adc $36				adc 	zTemp0 						; go to next token
.b3d7	85 36		sta $36				sta 	zTemp0
.b3d9	90 f3		bcc $b3ce			bcc 	_LCFindText
.b3db	e6 37		inc $37				inc 	zTemp0+1
.b3dd	80 ef		bra $b3ce			bra 	_LCFindText
.b3df					_LCFoundText:
.b3df	5a		phy				phy 								; save List position
.b3e0	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b3e2	aa		tax				tax
.b3e3	a9 83		lda #$83			lda 	#CLIToken+$80
.b3e5	20 35 b4	jsr $b435			jsr 	LCLWriteColour
.b3e8	a0 02		ldy #$02			ldy 	#2
.b3ea					_LCCopyToken:
.b3ea	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3ec	20 90 b4	jsr $b490			jsr 	LCLLowerCase
.b3ef	20 3e b4	jsr $b43e			jsr 	LCLWrite
.b3f2	c8		iny				iny
.b3f3	ca		dex				dex
.b3f4	d0 f4		bne $b3ea			bne 	_LCCopyToken
.b3f6	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b3f8	f0 05		beq $b3ff			beq 	_LCNoSpace
.b3fa	a9 20		lda #$20			lda 	#' '
.b3fc	20 3e b4	jsr $b43e			jsr 	LCLWrite
.b3ff					_LCNoSpace:
.b3ff	7a		ply				ply 								; restore position.
.b400	c8		iny				iny 								; consume token
.b401	4c 12 b3	jmp $b312			jmp 	_LCMainLoop 				; and go around again.
.b404					_LCData:
.b404	48		pha				pha 								; save type $FE/$FF
.b405	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b407	c9 fe		cmp #$fe			cmp 	#$FE
.b409	f0 07		beq $b412			beq 	_LCHaveOpener
.b40b	a2 22		ldx #$22			ldx 	#'"'
.b40d	a9 81		lda #$81			lda 	#CLIData+$80
.b40f	20 35 b4	jsr $b435			jsr 	LCLWriteColour
.b412					_LCHaveOpener:
.b412	8a		txa				txa 								; output prefix (# or ")
.b413	20 3e b4	jsr $b43e			jsr 	LCLWrite
.b416	c8		iny				iny 								; get count
.b417	b1 30		lda ($30),y			lda 	(codePtr),y
.b419	aa		tax				tax
.b41a	c8		iny				iny 								; point at first character
.b41b					_LCOutData:
.b41b	b1 30		lda ($30),y			lda 	(codePtr),y
.b41d	c9 00		cmp #$00			cmp 	#0
.b41f	f0 03		beq $b424			beq 	_LCNoPrint
.b421	20 3e b4	jsr $b43e			jsr 	LCLWrite
.b424					_LCNoPrint:
.b424	c8		iny				iny
.b425	ca		dex				dex
.b426	d0 f3		bne $b41b			bne 	_LCOutData
.b428	68		pla				pla 								; closing " required ?
.b429	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b42b	d0 05		bne $b432			bne 	_LCNoQuote
.b42d	a9 22		lda #$22			lda 	#'"'
.b42f	20 3e b4	jsr $b43e			jsr 	LCLWrite
.b432					_LCNoQuote:
.b432	4c 12 b3	jmp $b312			jmp 	_LCMainLoop
.b435					LCLWriteColour:
.b435	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b438	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b43b	d0 01		bne $b43e			bne 	LCLWrite 					; if different, output it
.b43d	60		rts				rts
.b43e					LCLWrite:
.b43e	da		phx				phx
.b43f	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b442	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b445	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.b448	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.b44b	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b44d	30 03		bmi $b452			bmi 	_LCLNoColour
.b44f	8d 27 04	sta $0427			sta 	LCLastCharacter
.b452					_LCLNoColour:
.b452	fa		plx				plx
.b453	60		rts				rts
.b454					LCLDeleteLastSpace:
.b454	48		pha				pha
.b455	da		phx				phx
.b456	ae 1d 04	ldx $041d			ldx 	tbOffset
.b459	f0 0a		beq $b465			beq 	_LCDLSExit
.b45b	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.b45e	c9 20		cmp #$20			cmp 	#' '
.b460	d0 03		bne $b465			bne 	_LCDLSExit
.b462	ce 1d 04	dec $041d			dec 	tbOffset
.b465					_LCDLSExit:
.b465	fa		plx				plx
.b466	68		pla				pla
.b467	60		rts				rts
.b468					LCLCheckSpaceRequired:
.b468	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.b46b	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b46d	f0 1b		beq $b48a			beq 	_LCCSRSpace
.b46f	c9 29		cmp #$29			cmp 	#')'
.b471	f0 17		beq $b48a			beq 	_LCCSRSpace
.b473	c9 23		cmp #$23			cmp 	#'#'
.b475	f0 13		beq $b48a			beq 	_LCCSRSpace
.b477	20 90 b4	jsr $b490			jsr 	LCLLowerCase 				; saves a little effort
.b47a	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b47c	90 11		bcc $b48f			bcc 	_LCCSRExit
.b47e	c9 3a		cmp #$3a			cmp 	#"9"+1
.b480	90 08		bcc $b48a			bcc 	_LCCSRSpace
.b482	c9 61		cmp #$61			cmp 	#"a"
.b484	90 09		bcc $b48f			bcc 	_LCCSRExit
.b486	c9 7b		cmp #$7b			cmp 	#"z"+1
.b488	b0 05		bcs $b48f			bcs 	_LCCSRExit
.b48a					_LCCSRSpace:
.b48a	a9 20		lda #$20			lda 	#' '
.b48c	20 3e b4	jsr $b43e			jsr 	LCLWrite
.b48f					_LCCSRExit:
.b48f	60		rts				rts
.b490					LCLLowerCase:
.b490	c9 41		cmp #$41			cmp 	#"A"
.b492	90 06		bcc $b49a			bcc 	_LCLLCOut
.b494	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b496	b0 02		bcs $b49a			bcs 	_LCLLCOut
.b498	69 20		adc #$20			adc 	#$20
.b49a					_LCLLCOut:
.b49a	60		rts				rts
.b49b					LCLUpperCase:
.b49b	c9 61		cmp #$61			cmp 	#"a"
.b49d	90 06		bcc $b4a5			bcc 	_LCLUCOut
.b49f	c9 7b		cmp #$7b			cmp 	#"z"+1
.b4a1	b0 02		bcs $b4a5			bcs 	_LCLUCOut
.b4a3	e9 1f		sbc #$1f			sbc 	#$1F
.b4a5					_LCLUCOut:
.b4a5	60		rts				rts
.b4a6					TOKSearchTable:
.b4a6	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b4a8	85 36		sta $36				sta 	zTemp0
.b4aa	a0 00		ldy #$00			ldy 	#0
.b4ac	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b4ae	85 38		sta $38				sta 	zTemp1
.b4b0					_TSTLoop:
.b4b0	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b4b2	30 49		bmi $b4fd			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b4b4	f0 2e		beq $b4e4			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b4b6	c8		iny				iny 								; get the hash
.b4b7	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4b9	88		dey				dey
.b4ba	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b4bd	d0 25		bne $b4e4			bne 	_TSTNext
.b4bf	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.b4c2	38		sec				sec
.b4c3	ed 00 04	sbc $0400			sbc 	identStart
.b4c6	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b4c8	d0 1a		bne $b4e4			bne 	_TSTNext
.b4ca	5a		phy				phy 								; save Y , we might fail to match.
.b4cb	c8		iny				iny 								; point to text
.b4cc	c8		iny				iny
.b4cd	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.b4d0					_TSTCompareName:
.b4d0	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.b4d3	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b4d5	d0 0c		bne $b4e3			bne 	_TSTNextPullY 				; fail, pullY and do next
.b4d7	e8		inx				inx
.b4d8	c8		iny				iny
.b4d9	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.b4dc	d0 f2		bne $b4d0			bne 	_TSTCompareName
.b4de	7a		ply				ply 								; throw Y
.b4df	a5 38		lda $38				lda 	zTemp1 						; get token #
.b4e1	38		sec				sec 								; return with CS = passed.
.b4e2	60		rts				rts
.b4e3					_TSTNextPullY:
.b4e3	7a		ply				ply 								; restore current, fall through.
.b4e4					_TSTNext:
.b4e4	e6 38		inc $38				inc 	zTemp1 						; token counter
.b4e6	98		tya				tya
.b4e7	18		clc				clc
.b4e8	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b4ea	1a		inc a				inc 	a 							; +1
.b4eb	1a		inc a				inc 	a 							; +2
.b4ec	a8		tay				tay
.b4ed	10 c1		bpl $b4b0			bpl 	_TSTLoop 					; if Y < $80 loop back
.b4ef	98		tya				tya 								; add Y to zTemp0 and reset Y
.b4f0	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b4f2	18		clc				clc  								; but have tables > 255 bytes
.b4f3	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b4f5	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b4f7	90 b7		bcc $b4b0			bcc 	_TSTLoop
.b4f9	e6 37		inc $37				inc 	zTemp0+1
.b4fb	80 b3		bra $b4b0			bra 	_TSTLoop
.b4fd					_TSTFail:
.b4fd	18		clc				clc
.b4fe	60		rts				rts
.b4ff					TokeniseLine:
.b4ff	20 87 b6	jsr $b687			jsr 	LCLFixLineBufferCase 		; fix line case
.b502	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b504	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b507	9c 2b 04	stz $042b			stz 	tokenLineNumber
.b50a	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.b50d	a2 ff		ldx #$ff			ldx 	#$FF
.b50f					_TKFindFirst:
.b50f	e8		inx				inx
.b510	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b513	f0 79		beq $b58e			beq 	_TKExit
.b515	c9 20		cmp #$20			cmp 	#' '
.b517	90 f6		bcc $b50f			bcc 	_TKFindFirst
.b519	c9 30		cmp #$30			cmp 	#'0'
.b51b	90 07		bcc $b524			bcc 	_TKNoLineNumber
.b51d	c9 3a		cmp #$3a			cmp 	#'9'+1
.b51f	b0 03		bcs $b524			bcs 	_TKNoLineNumber
.b521	20 b1 b6	jsr $b6b1			jsr 	TOKExtractLineNumber
.b524					_TKNoLineNumber:
.b524					_TKTokeniseLoop:
.b524	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b527	f0 65		beq $b58e			beq 	_TKExit
.b529	e8		inx				inx
.b52a	c9 20		cmp #$20			cmp 	#' '
.b52c	f0 f6		beq $b524			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b52e	ca		dex				dex 								; undo last get, A contains character, X is position.
.b52f	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b531	f0 61		beq $b594			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.b533	c9 41		cmp #$41			cmp 	#'A'
.b535	90 04		bcc $b53b			bcc 	_TKTokenisePunctuation
.b537	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b539	90 59		bcc $b594			bcc 	_TKTokeniseIdentifier
.b53b					_TKTokenisePunctuation:
.b53b	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b53d	f0 27		beq $b566			beq 	_TKString
.b53f	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.b541	f0 28		beq $b56b			beq 	_TKHexConstant
.b543	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.b545	f0 29		beq $b570			beq 	_TKCheckDouble
.b547	c9 3e		cmp #$3e			cmp 	#'>'
.b549	f0 25		beq $b570			beq 	_TKCheckDouble
.b54b					_TKStandardPunctuation:
.b54b	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.b54e	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b550	90 0e		bcc $b560			bcc 	_TKNoShift
.b552	48		pha				pha 								; save. we are about to convert this punctuation token from
.b553	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b555	85 36		sta $36				sta 	zTemp0
.b557	68		pla				pla
.b558	29 20		and #$20			and 	#32 						; bit 5
.b55a	4a		lsr a				lsr 	a 							; shift into bit 3
.b55b	4a		lsr a				lsr 	a
.b55c	05 36		ora $36				ora 	zTemp0
.b55e	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b560					_TKNoShift:
.b560	20 f6 b6	jsr $b6f6			jsr 	TOKWriteByte 				; write the punctuation character
.b563	e8		inx				inx 								; consume the character
.b564	80 be		bra $b524			bra 	_TKTokeniseLoop 			; and loop round again.
.b566					_TKString:
.b566	20 16 b6	jsr $b616			jsr 	TOKTokenString
.b569	80 b9		bra $b524			bra 	_TKTokeniseLoop
.b56b					_TKHexConstant:
.b56b	20 51 b6	jsr $b651			jsr 	TOKHexConstant
.b56e	80 b4		bra $b524			bra 	_TKTokeniseLoop
.b570					_TKCheckDouble:
.b570	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.b573	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b575	90 d4		bcc $b54b			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.b577	c9 3f		cmp #$3f			cmp 	#'>'+1
.b579	b0 d0		bcs $b54b			bcs 	_TKStandardPunctuation
.b57b	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b57e	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b580	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b581	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b584	38		sec				sec
.b585	e9 3c		sbc #$3c			sbc 	#'<'
.b587	20 f6 b6	jsr $b6f6			jsr 	TOKWriteByte 				; this is in the range 0-7
.b58a	e8		inx				inx 								; consume both
.b58b	e8		inx				inx
.b58c	80 96		bra $b524			bra 	_TKTokeniseLoop
.b58e	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b590	20 f6 b6	jsr $b6f6			jsr 	TOKWriteByte
.b593	60		rts				rts
.b594					_TKTokeniseIdentifier:
.b594	8e 00 04	stx $0400			stx 	identStart 					; save start
.b597	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.b59a					_TKCheckLoop:
.b59a	e8		inx				inx 								; look at next, we know first is identifier already.
.b59b	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.b59e	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b5a0	f0 f8		beq $b59a			beq 	_TKCheckLoop
.b5a2	c9 30		cmp #$30			cmp	 	#"0"
.b5a4	90 0c		bcc $b5b2			bcc 	_TKEndIdentifier
.b5a6	c9 3a		cmp #$3a			cmp 	#"9"+1
.b5a8	90 f0		bcc $b59a			bcc 	_TKCheckLoop
.b5aa	c9 41		cmp #$41			cmp	 	#"A"
.b5ac	90 04		bcc $b5b2			bcc 	_TKEndIdentifier
.b5ae	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b5b0	90 e8		bcc $b59a			bcc 	_TKCheckLoop
.b5b2					_TKEndIdentifier:
.b5b2	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.b5b5	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b5b7	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b5b9	f0 06		beq $b5c1			beq 	_TKHasTypeCharacter
.b5bb	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b5bd	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b5bf	d0 07		bne $b5c8			bne 	_TKNoTypeCharacter
.b5c1					_TKHasTypeCharacter:
.b5c1	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.b5c4	e8		inx				inx 								; consume the type character
.b5c5	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b5c8					_TKNoTypeCharacter:
.b5c8	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b5ca	d0 09		bne $b5d5			bne 	_TKNoArray
.b5cc	e8		inx				inx 								; skip the (
.b5cd	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.b5d0	09 04		ora #$04			ora 	#$04
.b5d2	8d 04 04	sta $0404			sta 	identTypeByte
.b5d5					_TKNoArray:
.b5d5	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b5d8	20 72 b6	jsr $b672			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b5db	a0 b9		ldy #$b9			ldy 	#(KeywordSet0) >> 8
.b5dd	a9 67		lda #$67			lda 	#(KeywordSet0) & $FF
.b5df	20 a6 b4	jsr $b4a6			jsr 	TOKSearchTable
.b5e2	a2 00		ldx #$00			ldx 	#0
.b5e4	b0 1f		bcs $b605			bcs 	_TKFoundToken
.b5e6	a0 bb		ldy #$bb			ldy 	#(KeywordSet1) >> 8
.b5e8	a9 64		lda #$64			lda 	#(KeywordSet1) & $FF
.b5ea	20 a6 b4	jsr $b4a6			jsr 	TOKSearchTable
.b5ed	a2 81		ldx #$81			ldx 	#$81
.b5ef	b0 14		bcs $b605			bcs 	_TKFoundToken
.b5f1	a0 bb		ldy #$bb			ldy 	#(KeywordSet2) >> 8
.b5f3	a9 c1		lda #$c1			lda 	#(KeywordSet2) & $FF
.b5f5	20 a6 b4	jsr $b4a6			jsr 	TOKSearchTable
.b5f8	a2 82		ldx #$82			ldx 	#$82
.b5fa	b0 09		bcs $b605			bcs 	_TKFoundToken
.b5fc	20 02 b7	jsr $b702			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b5ff	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.b602	4c 24 b5	jmp $b524			jmp 	_TKTokeniseLoop 			; and go round again.
.b605					_TKFoundToken:
.b605	48		pha				pha 								; save token
.b606	8a		txa				txa 								; shift in X, is there one ?
.b607	f0 03		beq $b60c			beq 	_TKNoTShift
.b609	20 f6 b6	jsr $b6f6			jsr 	TOKWriteByte 				; if so, write it out
.b60c					_TKNoTShift:
.b60c	68		pla				pla 								; restore and write token
.b60d	20 f6 b6	jsr $b6f6			jsr 	TOKWriteByte
.b610	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.b613	4c 24 b5	jmp $b524			jmp 	_TKTokeniseLoop 			; and go round again.
.b616					TOKTokenString:
.b616	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b618	20 f6 b6	jsr $b6f6			jsr 	TOKWriteByte
.b61b	e8		inx				inx									; start of quoted string.
.b61c	da		phx				phx 								; push start of string on top
.b61d	ca		dex				dex 								; because we pre-increment
.b61e					_TSFindEnd:
.b61e	e8		inx				inx
.b61f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.b622	f0 04		beq $b628			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.b624	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.b626	d0 f6		bne $b61e			bne 	_TSFindEnd
.b628					_TSEndOfString:
.b628	7a		ply				ply  								; so now Y is first character, X is character after end.
.b629	48		pha				pha 								; save terminating character
.b62a	20 32 b6	jsr $b632			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b62d	68		pla				pla 								; terminating character
.b62e	f0 01		beq $b631			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b630	e8		inx				inx
.b631					_TSNotQuote:
.b631	60		rts				rts
.b632					TOKWriteBlockXY:
.b632	86 36		stx $36				stx 	zTemp0 						; save end character
.b634	98		tya				tya 								; use 2's complement to work out the byte size
.b635	49 ff		eor #$ff			eor 	#$FF
.b637	38		sec				sec
.b638	65 36		adc $36				adc 	zTemp0
.b63a	1a		inc a				inc 	a 							; one extra for NULL
.b63b	20 f6 b6	jsr $b6f6			jsr 	TOKWriteByte
.b63e					_TOBlockLoop:
.b63e	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.b640	f0 09		beq $b64b			beq 	_TOBlockExit
.b642	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.b645	20 f6 b6	jsr $b6f6			jsr 	TOKWriteByte
.b648	c8		iny				iny
.b649	80 f3		bra $b63e			bra 	_TOBlockLoop
.b64b					_TOBlockExit:
.b64b	a9 00		lda #$00			lda 	#0 							; add NULL.
.b64d	20 f6 b6	jsr $b6f6			jsr 	TOKWriteByte
.b650	60		rts				rts
.b651					TOKHexConstant:
.b651	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b653	20 f6 b6	jsr $b6f6			jsr 	TOKWriteByte
.b656	e8		inx				inx									; start of quoted string.
.b657	da		phx				phx 								; push start of constant on top
.b658	ca		dex				dex
.b659					_THFindLoop:
.b659	e8		inx				inx 	 							; this is stored in a block, so find out how long
.b65a	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.b65d	c9 30		cmp #$30			cmp 	#"0"
.b65f	90 0c		bcc $b66d			bcc 	_THFoundEnd
.b661	c9 3a		cmp #$3a			cmp 	#"9"+1
.b663	90 f4		bcc $b659			bcc 	_THFindLoop
.b665	c9 41		cmp #$41			cmp 	#"A"
.b667	90 04		bcc $b66d			bcc 	_THFoundEnd
.b669	c9 47		cmp #$47			cmp 	#"F"+1
.b66b	90 ec		bcc $b659			bcc 	_THFindLoop
.b66d					_THFoundEnd:
.b66d	7a		ply				ply 								; restore start
.b66e	20 32 b6	jsr $b632			jsr 	TOKWriteBlockXY 			; output the block
.b671	60		rts				rts
.b672					TOKCalculateHash:
.b672	da		phx				phx
.b673	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.b676	a9 00		lda #$00			lda 	#0
.b678					_TCHLoop:
.b678	18		clc				clc
.b679	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.b67c	e8		inx				inx
.b67d	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b680	d0 f6		bne $b678			bne 	_TCHLoop
.b682	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.b685	fa		plx				plx
.b686	60		rts				rts
.b687					LCLFixLineBufferCase:
.b687	a2 00		ldx #$00			ldx 	#0
.b689					_FLBCLoop:
.b689	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.b68c	f0 22		beq $b6b0			beq 	_FLBCExit 					; end of string.
.b68e	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b690	f0 11		beq $b6a3			beq 	_FLBCInQuotes
.b692	e8		inx				inx
.b693	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b695	90 f2		bcc $b689			bcc 	_FLBCLoop
.b697	c9 7b		cmp #$7b			cmp 	#'z'+1
.b699	b0 ee		bcs $b689			bcs 	_FLBCLoop
.b69b	38		sec				sec 								; make U/C
.b69c	e9 20		sbc #$20			sbc 	#32
.b69e	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.b6a1	80 e6		bra $b689			bra 	_FLBCLoop
.b6a3					_FLBCInQuotes:
.b6a3	e8		inx				inx 								; advance
.b6a4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.b6a7	f0 07		beq $b6b0			beq 	_FLBCExit 					; exit on EOS
.b6a9	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b6ab	d0 f6		bne $b6a3			bne 	_FLBCInQuotes
.b6ad	e8		inx				inx 								; skip over it
.b6ae	80 d9		bra $b689			bra 	_FLBCLoop
.b6b0					_FLBCExit:
.b6b0	60		rts				rts
.b6b1					TOKExtractLineNumber:
.b6b1	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.b6b4	48		pha				pha
.b6b5	ad 2b 04	lda $042b			lda 	tokenLineNumber
.b6b8	48		pha				pha
.b6b9	20 ef b6	jsr $b6ef			jsr 	_LCLNTimes2 				; line # x 2
.b6bc	20 ef b6	jsr $b6ef			jsr 	_LCLNTimes2 				; line # x 4
.b6bf	18		clc				clc 								; add stacked value
.b6c0	68		pla				pla
.b6c1	6d 2b 04	adc $042b			adc 	tokenLineNumber
.b6c4	8d 2b 04	sta $042b			sta 	tokenLineNumber
.b6c7	68		pla				pla
.b6c8	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.b6cb	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.b6ce	20 ef b6	jsr $b6ef			jsr 	_LCLNTimes2 				; line # x 10
.b6d1	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.b6d4	e8		inx				inx
.b6d5	29 0f		and #$0f			and 	#15 						; add to line #
.b6d7	18		clc				clc
.b6d8	6d 2b 04	adc $042b			adc 	tokenLineNumber
.b6db	8d 2b 04	sta $042b			sta 	tokenLineNumber
.b6de	90 03		bcc $b6e3			bcc 	_TLENNoCarry
.b6e0	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.b6e3					_TLENNoCarry:
.b6e3	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.b6e6	c9 30		cmp #$30			cmp 	#'0'
.b6e8	90 04		bcc $b6ee			bcc 	_TLENExit
.b6ea	c9 3a		cmp #$3a			cmp 	#'9'+1
.b6ec	90 c3		bcc $b6b1			bcc 	TOKExtractLineNumber
.b6ee					_TLENExit:
.b6ee	60		rts				rts
.b6ef					_LCLNTimes2:
.b6ef	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.b6f2	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.b6f5	60		rts				rts
.b6f6					TOKWriteByte:
.b6f6	da		phx				phx
.b6f7	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.b6fa	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.b6fd	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.b700	fa		plx				plx
.b701	60		rts				rts
.b702					TOKCheckCreateVariableRecord:
.b702	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b704	85 36		sta $36				sta 	0+zTemp0
.b706	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b708	85 37		sta $37				sta 	1+zTemp0
.b70a					_CCVSearch:
.b70a	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b70c	f0 2c		beq $b73a			beq 	_CCVFail
.b70e	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b710	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b712	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.b715	d0 16		bne $b72d			bne 	_CCVNext
.b717	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b719	ae 00 04	ldx $0400			ldx 	identStart
.b71c					_CCVCompare:
.b71c	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b71f	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b721	e8		inx				inx 								; advance pointers
.b722	c8		iny				iny
.b723	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b724	d0 07		bne $b72d			bne 	_CCVNext  					; didn't match go to next.
.b726	90 f4		bcc $b71c			bcc 	_CCVCompare 				; not finished yet.
.b728	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.b72b	f0 47		beq $b774			beq 	_CCVFound 					; yes, we were successful
.b72d					_CCVNext:
.b72d	18		clc				clc 								; go to next record.
.b72e	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b730	65 36		adc $36				adc 	zTemp0
.b732	85 36		sta $36				sta 	zTemp0
.b734	90 d4		bcc $b70a			bcc 	_CCVSearch
.b736	e6 37		inc $37				inc 	zTemp0+1
.b738	80 d0		bra $b70a			bra 	_CCVSearch
.b73a					_CCVFail:
.b73a	a5 37		lda $37				lda 	zTemp0+1 					; are we out of space
.b73c	c9 1e		cmp #$1e			cmp 	#(EndVariableSpace-512) >> 8
.b73e	b0 44		bcs $b784			bcs 	_CCVMemory
.b740	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b742	ad 03 04	lda $0403			lda 	identHash
.b745	91 36		sta ($36),y			sta 	(zTemp0),y
.b747	c8		iny				iny 								; offset 2 is the type byte
.b748	ad 04 04	lda $0404			lda 	identTypeByte
.b74b	91 36		sta ($36),y			sta 	(zTemp0),y
.b74d	c8		iny				iny
.b74e					_CCVData:
.b74e	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.b750	91 36		sta ($36),y			sta 	(zTemp0),y
.b752	c8		iny				iny
.b753	c0 08		cpy #$08			cpy 	#8
.b755	90 f7		bcc $b74e			bcc 	_CCVData
.b757	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.b75a					_CCVCopyName:
.b75a	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b75d	91 36		sta ($36),y			sta 	(zTemp0),y
.b75f	e8		inx				inx
.b760	c8		iny				iny
.b761	ec 02 04	cpx $0402			cpx 	identTypeEnd
.b764	d0 f4		bne $b75a			bne 	_CCVCopyName
.b766	98		tya				tya 								; patch offset
.b767	92 36		sta ($36)			sta 	(zTemp0)
.b769	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b76b	91 36		sta ($36),y			sta 	(zTemp0),y
.b76d	88		dey				dey
.b76e	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b770	09 80		ora #$80			ora 	#$80
.b772	91 36		sta ($36),y			sta 	(zTemp0),y
.b774					_CCVFound:
.b774	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b776	38		sec				sec
.b777	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.b779	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.b77b	20 f6 b6	jsr $b6f6			jsr 	TOKWriteByte
.b77e	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b780	20 f6 b6	jsr $b6f6			jsr 	TOKWriteByte
.b783	60		rts				rts
.b784					_CCVMemory:
.b784	a9 06		lda #$06		lda	#6
.b786	4c 40 8e	jmp $8e40		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b789					SNDCheckChannel:
.b789	aa		tax				tax
.b78a	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b78d	d0 38		bne $b7c7			bne 	_SNDCCExit
.b78f	da		phx				phx 								; save current channel
.b790	8a		txa				txa 								; put in A
.b791	20 0d b8	jsr $b80d			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b794	68		pla				pla 								; channel # in A
.b795	90 30		bcc $b7c7			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b797	a8		tay				tay 								; Y is the channel #
.b798	bd 80 06	lda $0680,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b79b	99 7f 07	sta $077f,y			sta 	SNDPitchLow,y
.b79e	bd 81 06	lda $0681,x			lda 	SNDQueue+2,x
.b7a1	99 83 07	sta $0783,y			sta 	SNDPitchHigh,y
.b7a4	bd 82 06	lda $0682,x			lda 	SNDQueue+3,x
.b7a7	99 87 07	sta $0787,y			sta 	SNDVolume,y
.b7aa	bd 83 06	lda $0683,x			lda 	SNDQueue+4,x
.b7ad	99 8b 07	sta $078b,y			sta 	SNDTimeLeft,y
.b7b0	bd 84 06	lda $0684,x			lda 	SNDQueue+5,x
.b7b3	99 8f 07	sta $078f,y			sta 	SNDAdjustLow,y
.b7b6	bd 85 06	lda $0685,x			lda 	SNDQueue+6,x
.b7b9	99 93 07	sta $0793,y			sta 	SNDAdjustHigh,y
.b7bc	5a		phy				phy 								; save channel #
.b7bd	20 27 b8	jsr $b827			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b7c0	ce 7e 06	dec $067e			dec 	SNDLength 					; reduce the queue length.
.b7c3	68		pla				pla
.b7c4	20 c8 b7	jsr $b7c8			jsr 	SNDUpdateNote 				; update channel A
.b7c7					_SNDCCExit:
.b7c7	60		rts				rts
.b7c8					SNDUpdateNote:
.b7c8	aa		tax				tax 								; so we can access records
.b7c9	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b7ca	0a		asl a				asl 	a
.b7cb	0a		asl a				asl 	a
.b7cc	0a		asl a				asl 	a
.b7cd	0a		asl a				asl 	a
.b7ce	8d 7d 06	sta $067d			sta 	SNDChannelBits
.b7d1	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; are we silent
.b7d4	f0 2e		beq $b804			beq 	_SNDUNIsSilent
.b7d6	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; push channel bits on stack
.b7d9	48		pha				pha
.b7da	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b7dd	29 0f		and #$0f			and 	#$0F
.b7df	0d 7d 06	ora $067d			ora 	SNDChannelBits 				; set channel bits
.b7e2	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b7e4	20 71 b8	jsr $b871			jsr 	SNDWritePorts
.b7e7	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b7ea	8d 7d 06	sta $067d			sta 	SNDChannelBits
.b7ed	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.b7f0	4e 7d 06	lsr $067d			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b7f3	6a		ror a				ror 	a
.b7f4	4e 7d 06	lsr $067d			lsr 	SNDChannelBits
.b7f7	6a		ror a				ror 	a
.b7f8	4a		lsr a				lsr 	a 							; put in bits 0-5
.b7f9	4a		lsr a				lsr 	a
.b7fa	20 71 b8	jsr $b871			jsr 	SNDWritePorts 				; write as rest of pitch register
.b7fd	68		pla				pla
.b7fe	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b800	20 71 b8	jsr $b871			jsr 	SNDWritePorts
.b803	60		rts				rts
.b804					_SNDUNIsSilent:
.b804	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; channel bits
.b807	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b809	20 71 b8	jsr $b871			jsr 	SNDWritePorts 				; write to the ports
.b80c	60		rts				rts
.b80d					SNDFindNextNoteForA:
.b80d	ac 7e 06	ldy $067e			ldy 	SNDLength 					; queue size into Y
.b810	f0 13		beq $b825			beq 	_SNDFNNFail 				; queue empty.
.b812	a2 00		ldx #$00			ldx 	#0
.b814					_SNDFNNSearch:
.b814	dd 7f 06	cmp $067f,x			cmp 	SNDQueue,x 					; does it match the channel
.b817	38		sec				sec
.b818	f0 0c		beq $b826			beq 	_SNDFNNExit 				; if so exit with CS.
.b81a	e8		inx				inx 								; next queue slot.
.b81b	e8		inx				inx
.b81c	e8		inx				inx
.b81d	e8		inx				inx
.b81e	e8		inx				inx
.b81f	e8		inx				inx
.b820	e8		inx				inx
.b821	e8		inx				inx
.b822	88		dey				dey 								; done the whole queue
.b823	d0 ef		bne $b814			bne 	_SNDFNNSearch 				; no, go back.
.b825					_SNDFNNFail:
.b825	18		clc				clc
.b826					_SNDFNNexit:
.b826	60		rts				rts
.b827					SNDDeleteXFromQueue:
.b827	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b829	f0 09		beq $b834			beq 	_SNDDXExit
.b82b	bd 87 06	lda $0687,x			lda 	SNDQueue+8,x
.b82e	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.b831	e8		inx				inx
.b832	80 f3		bra $b827			bra 	SNDDeleteXFromQueue
.b834					_SNDDXExit:
.b834	60		rts				rts
.067d					SNDChannelBits:
>067d							.fill 	1
.b835					SNDQueueRequest:
.b835	86 36		stx $36				stx 	zTemp0						; save queue address
.b837	84 37		sty $37				sty 	zTemp0+1
.b839	ae 7e 06	ldx $067e			ldx 	SNDLength 					; queue is full, can't take any more.
.b83c	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b83e	f0 21		beq $b861			beq 	_SNDQRExit
.b840	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b842	48		pha				pha
.b843	8a		txa				txa  								; get offset in queue buffer/
.b844	0a		asl a				asl 	a
.b845	0a		asl a				asl 	a
.b846	0a		asl a				asl 	a
.b847	aa		tax				tax
.b848	68		pla				pla 								; get back and push again
.b849	48		pha				pha
.b84a	9d 7f 06	sta $067f,x			sta 	SNDQueue+0,x 				; save the channel #
.b84d	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b84f					_SNDQCopy:
.b84f	b1 36		lda ($36),y			lda 	(zTemp0),y
.b851	e8		inx				inx
.b852	c8		iny				iny
.b853	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.b856	c0 06		cpy #$06			cpy 	#6
.b858	d0 f5		bne $b84f			bne 	_SNDQCopy
.b85a	ee 7e 06	inc $067e			inc 	SNDLength 					; bump queue length.
.b85d	68		pla				pla 								; get channel # back
.b85e	20 89 b7	jsr $b789			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b861					_SNDQRExit:
.b861	60		rts				rts
.b862					SNDSilenceChannel:
.b862	aa		tax				tax 								; zero time left.
.b863	9e 8b 07	stz $078b,x			stz 	SNDTimeLeft,x
.b866	0a		asl a				asl 	a 							; shift into position
.b867	0a		asl a				asl 	a
.b868	0a		asl a				asl 	a
.b869	0a		asl a				asl 	a
.b86a	0a		asl a				asl 	a
.b86b	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b86d	20 71 b8	jsr $b871			jsr 	SNDWritePorts
.b870	60		rts				rts
.b871					SNDWritePorts:
.b871	da		phx				phx 								; save X
.b872	a6 01		ldx $01				ldx 	1 							; save I/O status
.b874	64 01		stz $01				stz 	1 							; access I/O page 0
.b876	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.b879	8d 10 d6	sta $d610			sta 	$D610
.b87c	86 01		stx $01				stx 	1 							; restore I/O
.b87e	fa		plx				plx 								; restore X
.b87f	60		rts				rts
.b880					SNDCommand:
.b880	da		phx				phx 								; save XY
.b881	5a		phy				phy
.b882	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b884	f0 1d		beq $b8a3			beq 	_SNDInitialise
.b886	90 28		bcc $b8b0			bcc 	_SNDExit
.b888	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b88a	f0 17		beq $b8a3			beq 	_SNDSilence
.b88c	b0 22		bcs $b8b0			bcs 	_SNDExit
.b88e	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b890	b0 09		bcs $b89b			bcs 	_SNDQueryPlay
.b892	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b894	b0 1a		bcs $b8b0			bcs 	_SNDExit
.b896	20 35 b8	jsr $b835			jsr 	SNDQueueRequest
.b899	80 15		bra $b8b0			bra 	_SNDExit
.b89b					_SNDQueryPlay:
.b89b	29 03		and #$03			and 	#3 							; get channel #
.b89d	aa		tax				tax
.b89e	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b8a1	80 0d		bra $b8b0			bra 	_SNDExit
.b8a3					_SNDInitialise:
.b8a3					_SNDSilence:
.b8a3	9c 7e 06	stz $067e			stz 	SNDLength 					; empty the queue.
.b8a6	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b8a8					_SNDSilenceLoop:
.b8a8	48		pha				pha
.b8a9	20 62 b8	jsr $b862			jsr 	SNDSilenceChannel
.b8ac	68		pla				pla
.b8ad	3a		dec a				dec 	a
.b8ae	10 f8		bpl $b8a8			bpl 	_SNDSilenceLoop
.b8b0					_SNDExit:
.b8b0	7a		ply				ply
.b8b1	fa		plx				plx
.b8b2	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.067e					SNDLength:
>067e							.fill 	1
.067f					SNDQueue:
>067f							.fill 	SNDQueueSize * 8
.077f					SNDPitchLow:
>077f							.fill 	4
.0783					SNDPitchHigh:
>0783							.fill 	4
.0787					SNDVolume:
>0787							.fill 	4
.078b					SNDTimeLeft:
>078b							.fill 	4
.078f					SNDAdjustLow:
>078f							.fill 	4
.0793					SNDAdjustHigh:
>0793							.fill 	4
.b8b3					SNDUpdate:
.b8b3	ad 8b 07	lda $078b			lda 	SNDTimeLeft+0 				; look at time remaining
.b8b6	f0 05		beq $b8bd			beq 	_SNDUNot0 					; not playing
.b8b8	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.b8ba	20 dc b8	jsr $b8dc			jsr 	SNDUpdateChannel 			; update it.
.b8bd					_SNDUNot0:
.b8bd	ad 8c 07	lda $078c			lda 	SNDTimeLeft+1
.b8c0	f0 05		beq $b8c7			beq 	_SNDUNot1
.b8c2	a2 01		ldx #$01			ldx 	#1
.b8c4	20 dc b8	jsr $b8dc			jsr 	SNDUpdateChannel
.b8c7					_SNDUNot1:
.b8c7	ad 8d 07	lda $078d			lda 	SNDTimeLeft+2
.b8ca	f0 05		beq $b8d1			beq 	_SNDUNot2
.b8cc	a2 02		ldx #$02			ldx 	#2
.b8ce	20 dc b8	jsr $b8dc			jsr 	SNDUpdateChannel
.b8d1					_SNDUNot2:
.b8d1	ad 8e 07	lda $078e			lda 	SNDTimeLeft+3
.b8d4	f0 05		beq $b8db			beq 	_SNDUNot3
.b8d6	a2 03		ldx #$03			ldx 	#3
.b8d8	20 dc b8	jsr $b8dc			jsr 	SNDUpdateChannel
.b8db					_SNDUNot3:
.b8db	60		rts				rts
.b8dc					SNDUpdateChannel:
.b8dc	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.b8de	f0 2c		beq $b90c			beq 	_SNDUCExit
.b8e0	3a		dec a				dec 	a 							; decrement and update timer
.b8e1	9d 8b 07	sta $078b,x			sta 	SNDTimeLeft,x
.b8e4	f0 1d		beq $b903			beq 	_SNDUCUpdate 				; if zero, silence channel
.b8e6	bd 8f 07	lda $078f,x			lda 	SNDAdjustLow,x 				; adjust ?
.b8e9	1d 93 07	ora $0793,x			ora 	SNDAdjustHigh,x
.b8ec	f0 1e		beq $b90c			beq 	_SNDUCExit 					; if zero carry on at current tone.
.b8ee	18		clc				clc 								; add adjust, forcing into a 10 bit range
.b8ef	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.b8f2	7d 8f 07	adc $078f,x			adc 	SNDAdjustLow,x
.b8f5	9d 7f 07	sta $077f,x			sta 	SNDPitchLow,x
.b8f8	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x
.b8fb	7d 93 07	adc $0793,x			adc 	SNDAdjustHigh,x
.b8fe	29 03		and #$03			and 	#3
.b900	9d 83 07	sta $0783,x			sta 	SNDPitchHigh,x
.b903					_SNDUCUpdate:
.b903	8a		txa				txa 								; which channel.
.b904	48		pha				pha
.b905	20 c8 b7	jsr $b7c8			jsr 	SNDUpdateNote 				; update the current note
.b908	68		pla				pla
.b909	20 89 b7	jsr $b789			jsr 	SNDCheckChannel 			; more to do ?
.b90c					_SNDUCExit:
.b90c	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
