
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Mon Nov 21 16:06:59 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					tokenOffset:
>04a8							.fill 	1
.04a9					tokenLineNumber:
>04a9							.fill 	2
.04ab					tokenBuffer:
>04ab							.fill 	253
.05a8					lineBuffer:
>05a8							.fill 	MaxLineSize+1
.05f9					numberBuffer:
>05f9							.fill 	34
.061b					decimalBuffer:
>061b							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_LET                              = $bc; $bc LET
=$bd					KWD_LINE                             = $bd; $bd LINE
=$be					KWD_LOCAL                            = $be; $be LOCAL
=$bf					KWD_OFF                              = $bf; $bf OFF
=$c0					KWD_ON                               = $c0; $c0 ON
=$c1					KWD_OUTLINE                          = $c1; $c1 OUTLINE
=$c2					KWD_PALETTE                          = $c2; $c2 PALETTE
=$c3					KWD_PLOT                             = $c3; $c3 PLOT
=$c4					KWD_PRINT                            = $c4; $c4 PRINT
=$c5					KWD_READ                             = $c5; $c5 READ
=$c6					KWD_RECT                             = $c6; $c6 RECT
=$c7					KWD_REM                              = $c7; $c7 REM
=$c8					KWD_RETURN                           = $c8; $c8 RETURN
=$c9					KWD_SOLID                            = $c9; $c9 SOLID
=$ca					KWD_SOUND                            = $ca; $ca SOUND
=$cb					KWD_SPRITE                           = $cb; $cb SPRITE
=$cc					KWD_TEXT                             = $cc; $cc TEXT
=$cd					KWD_TO                               = $cd; $cd TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 35 aa	jsr $aa35			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 be 8d	jsr $8dbe			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 4f b9	jsr $b94f			jsr 	SNDCommand
.8019	20 4e 88	jsr $884e			jsr 	NewProgram 					; erase current program
.801c	20 e3 82	jsr $82e3			jsr 	BackloadProgram
.801f	4c 53 83	jmp $8353			jmp 	WarmStart
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 4d 6f			.text "Built Monday 21-Nov-2022. Build 3482."
>804b	6e 64 61 79 20 32 31 2d 4e 6f 76 2d 32 30 32 32
>805b	2e 20 42 75 69 6c 64 20 33 34 38 32 2e

;******  Return to file: ./common/aa.system/00start.asm

>8068	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806b					AssembleGroup1:
.806b	a9 ff		lda #$ff			lda 	#$FF
.806d	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8070	80 02		bra $8074			bra 	AsmGroup12
.8072					AssembleGroup2:
.8072	a9 00		lda #$00			lda 	#$00
.8074					AsmGroup12:
.8074	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.8077	68		pla				pla 								; pop the return address to access the information following.
.8078	fa		plx				plx
.8079	20 02 81	jsr $8102			jsr 	AccessParameters 			; get opcode and save as base
.807c	8d a4 04	sta $04a4			sta 	BaseOpcode
.807f	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8082	d0 08		bne $808c			bne 	_AG12HaveMask
.8084	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8086	20 0a 81	jsr $810a			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8089	8d a5 04	sta $04a5			sta 	ModeMask
.808c					_AG12HaveMask:
.808c	20 45 82	jsr $8245			jsr 	TypeAndCalculateOperand 	; get zero page type
.808f	da		phx				phx 								; save found address mode
.8090	20 6e 81	jsr $816e			jsr 	AssembleModeX
.8093	fa		plx				plx  								; restore address mode
.8094	b0 0b		bcs $80a1			bcs 	_AG12Exit
.8096	20 a2 80	jsr $80a2			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8099	20 6e 81	jsr $816e			jsr 	AssembleModeX
.809c	b0 03		bcs $80a1			bcs 	_AG12Exit
.809e	4c b2 9f	jmp $9fb2			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a1					_AG12Exit:
.80a1	60		rts				rts
.80a2					PromoteToAbsolute:
.80a2	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a4	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a6	f0 19		beq $80c1			beq 	_PTADo
.80a8	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80aa	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80ac	f0 13		beq $80c1			beq 	_PTADo
.80ae	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b0	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b2	f0 0d		beq $80c1			beq 	_PTADo
.80b4	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b6	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b8	f0 07		beq $80c1			beq 	_PTADo
.80ba	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bc	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80be	f0 01		beq $80c1			beq 	_PTADo
.80c0	60		rts				rts
.80c1					_PTADo:
.80c1	aa		tax				tax
.80c2	60		rts				rts
.80c3					AssembleGroup3:
.80c3	68		pla				pla 								; get parameters, which is just the opcode.
.80c4	fa		plx				plx
.80c5	20 02 81	jsr $8102			jsr 	AccessParameters 			; get and output opcode
.80c8	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.80cb	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get a 16 bit operand
.80ce	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d1	38		sec				sec
.80d2	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d5	48		pha				pha 								; LSB in A
.80d6	ad 10 04	lda $0410			lda 	NSMantissa1
.80d9	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80dc	aa		tax				tax 								; MSB in X
.80dd	68		pla				pla
.80de	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80df	69 7f		adc #$7f			adc 	#$7F
.80e1	90 01		bcc $80e4			bcc 	_AG3NoCarry
.80e3	e8		inx				inx
.80e4					_AG3NoCarry:
.80e4	38		sec				sec 								; fix back and write out anyways.
.80e5	e9 80		sbc #$80			sbc 	#$80
.80e7	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.80ea	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ec	f0 0a		beq $80f8			beq 	_AG3Exit
.80ee	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f1	29 01		and #$01			and 	#1
.80f3	f0 03		beq $80f8			beq 	_AG3Exit
.80f5	4c b7 9f	jmp $9fb7			jmp 	RangeError 					; no, branch is out of range
.80f8					_AG3Exit:
.80f8	60		rts				rts
.80f9					AssembleGroup4:
.80f9	68		pla				pla 								; pop address
.80fa	fa		plx				plx
.80fb	20 02 81	jsr $8102			jsr 	AccessParameters 			; access and get first
.80fe	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte 			; output it.
.8101	60		rts				rts
.8102					AccessParameters:
.8102	8d a1 04	sta $04a1			sta 	ParamStart
.8105	8e a2 04	stx $04a2			stx 	ParamStart+1
.8108	a9 01		lda #$01			lda 	#1
.810a					GetParameter:
.810a	5a		phy				phy
.810b	a8		tay				tay
.810c	ad a1 04	lda $04a1			lda 	ParamStart
.810f	85 36		sta $36				sta 	zTemp0
.8111	ad a2 04	lda $04a2			lda 	ParamStart+1
.8114	85 37		sta $37				sta 	zTemp0+1
.8116	b1 36		lda ($36),y			lda 	(zTemp0),y
.8118	7a		ply				ply
.8119	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811a					AssemblerWriteByte:
.811a	48		pha			pha
.811b	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.811e	29 02		and #$02		and 	#2
.8120	f0 1b		beq $813d		beq 	_AWBNoPrint
.8122	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8125	20 58 81	jsr $8158		jsr 	PrintHex
.8128	ad 9e 04	lda $049e		lda		AssemblerAddress
.812b	20 58 81	jsr $8158		jsr 	PrintHex
.812e	a9 20		lda #$20		lda 	#' '
.8130	20 c1 a7	jsr $a7c1		jsr 	EXTPrintCharacter
.8133	68		pla			pla 									; print byte
.8134	48		pha			pha
.8135	20 58 81	jsr $8158		jsr 	PrintHex
.8138	a9 0d		lda #$0d		lda 	#13
.813a	20 c1 a7	jsr $a7c1		jsr 	EXTPrintCharacter
.813d					_AWBNoPrint:
.813d	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8140	85 36		sta $36			sta 	zTemp0
.8142	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8145	f0 0e		beq $8155		beq 	_AWBRange
.8147	85 37		sta $37			sta 	zTemp0+1
.8149	68		pla			pla 									; write byte out
.814a	92 36		sta ($36)		sta 	(zTemp0)
.814c	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.814f	d0 03		bne $8154		bne 	_AWBNoCarry
.8151	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8154					_AWBNoCarry:
.8154	60		rts			rts
.8155					_AWBRange:
.8155	4c b7 9f	jmp $9fb7		jmp 	RangeError
.8158					PrintHex:
.8158	48		pha				pha
.8159	4a		lsr a				lsr 	a
.815a	4a		lsr a				lsr 	a
.815b	4a		lsr a				lsr 	a
.815c	4a		lsr a				lsr 	a
.815d	20 61 81	jsr $8161			jsr 	_PrintNibble
.8160	68		pla				pla
.8161					_PrintNibble:
.8161	29 0f		and #$0f			and 	#15
.8163	c9 0a		cmp #$0a			cmp 	#10
.8165	90 02		bcc $8169			bcc 	_NoShift
.8167	69 06		adc #$06			adc 	#6
.8169					_NoShift:
.8169	69 30		adc #$30			adc 	#48
.816b	4c c1 a7	jmp $a7c1			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.816e					AssembleModeX:
.816e	5a		phy				phy
.816f	ad a3 04	lda $04a3			lda 	IsGroup1
.8172	f0 17		beq $818b			beq 	_AMXGroup2
.8174	8a		txa				txa 							; is it in group # 1
.8175	29 40		and #$40			and 	#AM_ISG1
.8177	f0 50		beq $81c9			beq 	_AMXFail 				; no, give up.
.8179	8a		txa				txa 							; get back.
.817a	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817c	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.817e	d0 22		bne $81a2			bne 	_AMXHaveInfo
.8180	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8183	c9 81		cmp #$81			cmp 	#$81
.8185	f0 42		beq $81c9			beq 	_AMXFail
.8187	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.8189	80 17		bra $81a2			bra 	_AMXHaveInfo 			; odd design decision there.
.818b					_AMXGroup2:
.818b	8a		txa				txa 							; is it in group 2 ?
.818c	29 20		and #$20			and 	#AM_ISG2
.818e	f0 39		beq $81c9			beq 	_AMXFail 				; no, give up.
.8190	8a		txa				txa 							; get the offset into Y
.8191	29 1f		and #$1f			and 	#$1F
.8193	4a		lsr a				lsr 	a 						; make it 0-7.
.8194	4a		lsr a				lsr  	a
.8195	a8		tay				tay
.8196	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.8199					_AMXCheckOkay:
.8199	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819a	88		dey				dey
.819b	10 fc		bpl $8199			bpl 	_AMXCheckOkay
.819d	90 2a		bcc $81c9			bcc 	_AMXFail 				; not allowed.
.819f	8a		txa				txa  							; get mask back
.81a0	29 1f		and #$1f			and 	#$1F
.81a2					_AMXHaveInfo:
.81a2	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a4	10 05		bpl $81ab			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a6	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81a9	d0 1e		bne $81c9			bne 	_AMXFail
.81ab					_AMXAnySize:
.81ab	18		clc				clc 							; add offset to the base opcode
.81ac	6d a4 04	adc $04a4			adc 	BaseOpcode
.81af					_AMXOutputCode:
.81af	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b2	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b4	f0 10		beq $81c6			beq 	_AMXExit
.81b6	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81b9	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.81bc	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81be	30 06		bmi $81c6			bmi 	_AMXExit
.81c0	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c3	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.81c6					_AMXExit:
.81c6	7a		ply				ply
.81c7	38		sec				sec
.81c8	60		rts				rts
.81c9					_AMXFail:
.81c9	a0 00		ldy #$00			ldy 	#0
.81cb					_AMXCheckOddities:
.81cb	8a		txa				txa
.81cc	d9 f4 81	cmp $81f4,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81cf	d0 16		bne $81e7			bne 	_AMXCONext
.81d1	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d4	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81d7	d0 0e		bne $81e7			bne 	_AMXCONext
.81d9	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81db	10 05		bpl $81e2			bpl 	_AMXCONotZero
.81dd	ad 10 04	lda $0410			lda 	NSMantissa1
.81e0	d0 05		bne $81e7			bne 	_AMXCONext
.81e2					_AMXCONotZero:
.81e2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e5	80 c8		bra $81af			bra 	_AMXOutputCode 			; and assemble it
.81e7					_AMXCONext:
.81e7	c8		iny				iny
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; end of table
.81ed	d0 dc		bne $81cb			bne 	_AMXCheckOddities
.81ef					_AMXCOFail:
.81ef	7a		ply				ply
.81f0	18		clc				clc
.81f1	60		rts				rts
.81f2					ExtraOpcode:
>81f2	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f5	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f8	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fb	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81fe	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8201	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8204	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8207	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820a	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820d	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8210	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8211					LabelHere:
.8211	c8		iny				iny 								; skip .
.8212	a2 00		ldx #$00			ldx 	#0 							; get a term
.8214	20 ee 97	jsr $97ee			jsr 	EvaluateTerm 				; get a term
.8217	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821a	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821c	d0 24		bne $8242			bne 	_ALType
.821e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8221	85 36		sta $36				sta 	zTemp0
.8223	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8226	85 37		sta $37				sta 	zTemp0+1
.8228	5a		phy				phy 								; copy address in.
.8229	a0 01		ldy #$01			ldy 	#1
.822b	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.822e	92 36		sta ($36)			sta 	(zTemp0)
.8230	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8233	91 36		sta ($36),y			sta 	(zTemp0),y
.8235	c8		iny				iny
.8236	a9 00		lda #$00			lda 	#0
.8238	91 36		sta ($36),y			sta 	(zTemp0),y
.823a	c8		iny				iny
.823b	91 36		sta ($36),y			sta 	(zTemp0),y
.823d	c8		iny				iny
.823e	91 36		sta ($36),y			sta 	(zTemp0),y
.8240	7a		ply				ply
.8241	60		rts				rts
.8242					_ALType:
.8242	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8245					TypeAndCalculateOperand:
.8245	b1 30		lda ($30),y			lda 	(codePtr),y
.8247	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8249	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824b	f0 5b		beq $82a8			beq 	_TACOExit
.824d	c9 80		cmp #$80			cmp 	#KWC_EOL
.824f	f0 57		beq $82a8			beq 	_TACOExit
.8251	c8		iny				iny
.8252	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8254	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8256	f0 51		beq $82a9			beq 	CalculateOperand
.8258	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825a	f0 1f		beq $827b			beq 	_TACOIndirect
.825c	88		dey				dey 								; undo get of first character
.825d	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get operand
.8260	b1 30		lda ($30),y			lda 	(codePtr),y
.8262	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8264	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8266	d0 40		bne $82a8			bne 	_TACOExit
.8268	c8		iny				iny
.8269	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826c	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826e	c9 58		cmp #$58			cmp 	#'X'
.8270	f0 36		beq $82a8			beq 	_TACOExit
.8272	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8274	c9 59		cmp #$59			cmp 	#'Y'
.8276	f0 30		beq $82a8			beq 	_TACOExit
.8278					_TACOSyntax:
.8278	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.827b					_TACOIndirect:
.827b	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get the operand
.827e	b1 30		lda ($30),y			lda 	(codePtr),y
.8280	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8282	f0 17		beq $829b			beq 	_TACOIndX
.8284	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8287	b1 30		lda ($30),y			lda 	(codePtr),y
.8289	a2 d1		ldx #$d1			ldx 	#AM_IND
.828b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828d	d0 19		bne $82a8			bne 	_TACOExit
.828f	c8		iny				iny
.8290	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8293	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8295	d0 e1		bne $8278			bne 	_TACOSyntax
.8297	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8299	80 0d		bra $82a8			bra 	_TACOExit
.829b					_TACOIndX:
.829b	c8		iny				iny
.829c	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.829f	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a1	d0 d5		bne $8278			bne 	_TACOSyntax
.82a3	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket			; check )
.82a6	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a8					_TACOExit:
.82a8	60		rts				rts
.82a9					CalculateOperand:
.82a9	48		pha				pha
.82aa	da		phx				phx
.82ab	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ad	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.82b0	fa		plx				plx
.82b1	68		pla				pla
.82b2	60		rts				rts
.82b3					TACOCheckXY:
.82b3	b1 30		lda ($30),y			lda 	(codePtr),y
.82b5	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b7	c9 40		cmp #$40			cmp 	#$40
.82b9	d0 21		bne $82dc			bne 	_TCXYFail
.82bb	b1 30		lda ($30),y			lda 	(codePtr),y
.82bd	18		clc				clc
.82be	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c0	85 37		sta $37				sta 	zTemp0+1
.82c2	c8		iny				iny
.82c3	b1 30		lda ($30),y			lda 	(codePtr),y
.82c5	c8		iny				iny
.82c6	85 36		sta $36				sta 	zTemp0
.82c8	5a		phy				phy 								; save position
.82c9	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cb	b1 36		lda ($36),y			lda 	(zTemp0),y
.82cd	d0 0c		bne $82db			bne 	_TCXYPopFail
.82cf	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d1	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d3	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d5	f0 08		beq $82df			beq 	_TCXYFound
.82d7	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82d9	f0 04		beq $82df			beq 	_TCXYFound
.82db					_TCXYPopFail:
.82db	7a		ply				ply
.82dc					_TCXYFail:
.82dc	a9 00		lda #$00			lda 	#0
.82de	60		rts				rts
.82df					_TCXYFound:
.82df	7a		ply				ply 								; restore position
.82e0	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e3					BackloadProgram:
.82e3	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e5	8d 2b 06	sta $062b			sta 	0+BackLoadPointer
.82e8	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82ea	8d 2c 06	sta $062c			sta 	1+BackLoadPointer
.82ed					_BPLoop:
.82ed	a2 ff		ldx #$ff			ldx 	#$FF
.82ef	20 17 83	jsr $8317			jsr 	BLReadByte
.82f2	30 1f		bmi $8313			bmi 	_BPExit
.82f4					_BPCopy:
.82f4	e8		inx				inx  								; copy byte in
.82f5	9d a8 05	sta $05a8,x			sta 	lineBuffer,x
.82f8	9e a9 05	stz $05a9,x			stz 	lineBuffer+1,x
.82fb	20 17 83	jsr $8317			jsr 	BLReadByte 					; read next byte
.82fe	30 0a		bmi $830a			bmi 	_BPEndLine 					; -ve = EOL
.8300	c9 09		cmp #$09			cmp 	#9 							; handle TAB
.8302	d0 02		bne $8306			bne 	_BPNotTab
.8304	a9 20		lda #$20			lda 	#' '
.8306					_BPNotTab:
.8306	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8308	b0 ea		bcs $82f4			bcs 	_BPCopy
.830a					_BPEndLine:
.830a	20 df b5	jsr $b5df			jsr 	TokeniseLine 				; tokenise the line.
.830d	38		sec				sec 								; append not insert
.830e	20 19 a5	jsr $a519			jsr 	MemoryInsertLine 			; append to current program
.8311	80 da		bra $82ed			bra 	_BPLoop
.8313					_BPExit:
.8313	20 ec 83	jsr $83ec			jsr 	ClearCommand 				; clear variables etc.
.8316	60		rts				rts
.8317					BLReadByte:
.8317	ad 2b 06	lda $062b			lda 	BackLoadPointer
.831a	85 36		sta $36				sta 	zTemp0
.831c	ad 2c 06	lda $062c			lda 	BackLoadPointer+1
.831f	85 37		sta $37				sta 	zTemp0+1
.8321	b2 36		lda ($36)			lda 	(zTemp0)
.8323	ee 2b 06	inc $062b			inc 	BackLoadPointer
.8326	d0 03		bne $832b			bne 	_BLNoCarry
.8328	ee 2c 06	inc $062c			inc 	BackLoadPointer+1
.832b					_BLNoCarry:
.832b	c9 00		cmp #$00			cmp 	#0
.832d	60		rts				rts
.062b					BackLoadPointer:
>062b							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.832e					EditProgramCode:
.832e	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line.
.8331	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1
.8334	20 c1 a5	jsr $a5c1			jsr 	MemorySearch
.8337	90 05		bcc $833e			bcc 	_EPCNoDelete 				; reached the end don't delete
.8339	d0 03		bne $833e			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.833b	20 e2 a4	jsr $a4e2			jsr 	MemoryDeleteLine 			; delete the line
.833e					_EPCNoDelete:
.833e	ad ab 04	lda $04ab			lda 	TokenBuffer 				; buffer empty
.8341	c9 80		cmp #$80			cmp 	#KWC_EOL
.8343	f0 0d		beq $8352			beq 	_EPCNoInsert
.8345	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line - it cannot exist.
.8348	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.834b	20 c1 a5	jsr $a5c1			jsr 	MemorySearch
.834e	18		clc				clc 								; insert at this point.
.834f	20 19 a5	jsr $a519			jsr 	MemoryInsertLine 			; insert the line
.8352					_EPCNoInsert:
.8352	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8353					WarmStart:
.8353	a2 ff		ldx #$ff			ldx 	#$FF
.8355	9a		txs				txs
.8356	20 4f a9	jsr $a94f			jsr 	EXTInputLine 				; get line to lineBuffer
.8359	20 df b5	jsr $b5df			jsr 	TokeniseLine 				; tokenise the line
.835c	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; line number ?
.835f	0d aa 04	ora $04aa			ora 	TokenLineNumber+1
.8362	d0 17		bne $837b			bne 	_WSEditCode 				; if so,edit code.
.8364	9c a8 04	stz $04a8			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.8367	a9 a8		lda #$a8			lda 	#((TokenOffset) & $FF)
.8369	85 30		sta $30				sta 	codePtr
.836b	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.836d	85 31		sta $31				sta 	codePtr+1
.836f	ad ab 04	lda $04ab			lda 	TokenBuffer 				; nothing to run
.8372	c9 80		cmp #$80			cmp 	#KWC_EOL
.8374	f0 dd		beq $8353			beq 	WarmStart
.8376	20 0c 8a	jsr $8a0c			jsr 	RUNCodePointerLine 			; execute that line.
.8379	80 d8		bra $8353			bra 	WarmStart
.837b					_WSEditCode:
.837b	20 2e 83	jsr $832e			jsr 	EditProgramCode
.837e	20 ec 83	jsr $83ec			jsr 	ClearCommand
.8381	80 d0		bra $8353			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8383					AssembleCommand:
.8383	a2 00		ldx #$00			ldx 	#0
.8385	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; start address
.8388	ad 08 04	lda $0408			lda 	NSMantissa0
.838b	8d 9e 04	sta $049e			sta 	AssemblerAddress
.838e	ad 10 04	lda $0410			lda 	NSMantissa1
.8391	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.8394	20 54 8d	jsr $8d54			jsr 	CheckComma
.8397	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; options
.839a	ad 08 04	lda $0408			lda 	NSMantissa0
.839d	8d a0 04	sta $04a0			sta 	AssemblerControl
.83a0	60		rts				rts
.83a1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83a2					AssertCommand:
.83a2	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83a4	20 74 9d	jsr $9d74			jsr 	EvaluateInteger 			; the assert test
.83a7	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; exit if result is non zero.
.83aa	d0 05		bne $83b1			bne 	_ACExit
.83ac	a9 0a		lda #$0a		lda	#10
.83ae	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.83b1					_ACExit:
.83b1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83b2					CallCommand:
.83b2	a2 00		ldx #$00			ldx 	#0
.83b4	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.83b7					_CCClear
.83b7	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83b8	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.83bb	e0 04		cpx #$04			cpx 	#4
.83bd	d0 f8		bne $83b7			bne 	_CCClear
.83bf	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83c1					_CCCParam:
.83c1	b1 30		lda ($30),y			lda 	(codePtr),y
.83c3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83c5	d0 09		bne $83d0			bne 	_CCCRun6502
.83c7	c8		iny				iny 								; skip comma
.83c8	e8		inx				inx	 								; next level
.83c9	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83cc	e0 03		cpx #$03			cpx 	#3
.83ce	90 f1		bcc $83c1			bcc 	_CCCParam 					; done all 3 ?
.83d0					_CCCRun6502:
.83d0	5a		phy				phy 								; save position
.83d1	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83d4	85 37		sta $37				sta 	zTemp0+1
.83d6	ad 08 04	lda $0408			lda 	NSMantissa0
.83d9	85 36		sta $36				sta 	zTemp0
.83db	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83de	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83e1	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83e4	20 e9 83	jsr $83e9			jsr 	_CCCZTemp0 					; call zTemp0
.83e7	7a		ply				ply 								; restore position and exit
.83e8	60		rts				rts
.83e9					_CCCZTemp0:
.83e9	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83ec					ClearCommand:
.83ec	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83ee	85 36		sta $36				sta 	0+zTemp0
.83f0	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f2	85 37		sta $37				sta 	1+zTemp0
.83f4					_ClearZeroLoop:
.83f4	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables
.83f6	f0 24		beq $841c			beq 	_ClearZeroEnd
.83f8	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83fa	a9 00		lda #$00			lda 	#0
.83fc					_ClearOneVariable:
.83fc	91 36		sta ($36),y			sta 	(zTemp0),y
.83fe	c8		iny				iny
.83ff	c0 08		cpy #$08			cpy 	#8
.8401	d0 f9		bne $83fc			bne 	_ClearOneVariable
.8403	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8405	b1 36		lda ($36),y			lda 	(zTemp0),y
.8407	c9 18		cmp #$18			cmp 	#NSTProcedure
.8409	d0 04		bne $840f			bne 	_ClearNotProcedure
.840b	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; set it back to an integer array
.840d	91 36		sta ($36),y			sta 	(zTemp0),y
.840f					_ClearNotProcedure:
.840f	18		clc				clc 								; go to the next variable
.8410	b2 36		lda ($36)			lda 	(zTemp0)
.8412	65 36		adc $36				adc 	zTemp0
.8414	85 36		sta $36				sta 	zTemp0
.8416	90 dc		bcc $83f4			bcc 	_ClearZeroLoop
.8418	e6 37		inc $37				inc 	zTemp0+1
.841a	80 d8		bra $83f4			bra 	_ClearZeroLoop
.841c					_ClearZeroEnd:
.841c	18		clc				clc
.841d	a5 36		lda $36				lda 	zTemp0
.841f	69 01		adc #$01			adc 	#1
.8421	8d 8c 04	sta $048c			sta 	lowMemPtr
.8424	a5 37		lda $37				lda 	zTemp0+1
.8426	69 00		adc #$00			adc 	#0
.8428	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.842b	20 e6 a6	jsr $a6e6			jsr 	StackReset
.842e	20 50 a7	jsr $a750			jsr 	StringSystemInitialise
.8431	20 55 8c	jsr $8c55			jsr 	ProcedureScan
.8434	20 bb 89	jsr $89bb			jsr 	Command_Restore
.8437	9c 9e 04	stz $049e			stz 	AssemblerAddress
.843a	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.843d	9c a0 04	stz $04a0			stz 	AssemblerControl
.8440	20 f1 99	jsr $99f1			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8443	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8444					ClearScreen:
.8444	5a		phy				phy
.8445	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8447	20 c1 a7	jsr $a7c1			jsr 	EXTPrintCharacter
.844a	7a		ply				ply
.844b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.844c					Command_Data:
.844c	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.844e	a2 80		ldx #$80			ldx 	#KWC_EOL
.8450	20 a7 8c	jsr $8ca7			jsr 	ScanForward
.8453	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8454					DimCommand:
.8454	b1 30		lda ($30),y			lda 	(codePtr),y
.8456	29 c0		and #$c0			and 	#$C0
.8458	c9 40		cmp #$40			cmp 	#$40
.845a	d0 7a		bne $84d6			bne 	_DCSyntax
.845c	b1 30		lda ($30),y			lda 	(codePtr),y
.845e	18		clc				clc
.845f	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8461	85 3f		sta $3f				sta 	zaTemp+1
.8463	c8		iny				iny
.8464	b1 30		lda ($30),y			lda 	(codePtr),y
.8466	c8		iny				iny
.8467	85 3e		sta $3e				sta 	zaTemp
.8469	5a		phy				phy
.846a	a0 02		ldy #$02			ldy 	#2 						; read type byte
.846c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.846e	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8470	c9 18		cmp #$18			cmp 	#NSTProcedure
.8472	f0 62		beq $84d6			beq 	_DCSyntax
.8474	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8476	29 04		and #$04			and 	#NSBIsArray
.8478	f0 64		beq $84de			beq 	_DCType
.847a	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.847c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.847e	d0 59		bne $84d9			bne 	_DCRedefine
.8480	7a		ply				ply
.8481	20 e1 84	jsr $84e1			jsr 	_DCGetSize 				; get array size, check it.
.8484	5a		phy				phy
.8485	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8487	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.8489	7a		ply				ply 							; is there a second (e.g. ,x)
.848a	b1 30		lda ($30),y			lda 	(codePtr),y
.848c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.848e	d0 0a		bne $849a			bne 	_DCOneDimension
.8490	c8		iny				iny 							; skip comma
.8491	20 e1 84	jsr $84e1			jsr 	_DCGetSize 				; get 2nd array size
.8494	5a		phy				phy
.8495	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8497	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8499	7a		ply				ply
.849a					_DCOneDimension:
.849a	5a		phy				phy 							; save position
.849b	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.849d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.849f	aa		tax				tax
.84a0	c8		iny				iny
.84a1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a3	e8		inx				inx 							; bump them.
.84a4	1a		inc a				inc 	a
.84a5	20 bd 9d	jsr $9dbd			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84a8	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84aa	29 e0		and #$e0			and 	#$E0
.84ac	d0 23		bne $84d1			bne 	_DCSize
.84ae	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b0	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b2	20 ef 84	jsr $84ef			jsr 	ScaleByBaseType 		; scale by base type
.84b5	a5 36		lda $36				lda 	zTemp0
.84b7	a6 37		ldx $37				ldx 	zTemp0+1
.84b9	20 b3 99	jsr $99b3			jsr 	AllocateXABytes 		; allocate memory
.84bc	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84be	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c0	c8		iny				iny
.84c1	8a		txa				txa
.84c2	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c4	7a		ply				ply 							; get position back
.84c5	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 		; check )
.84c8	b1 30		lda ($30),y			lda 	(codePtr),y
.84ca	c8		iny				iny 							; consume in case
.84cb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84cd	f0 85		beq $8454			beq 	DimCommand
.84cf	88		dey				dey 							; undo consume
.84d0	60		rts				rts
.84d1					_DCSize:
.84d1	a9 16		lda #$16		lda	#22
.84d3	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.84d6					_DCSyntax:
.84d6	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.84d9					_DCRedefine:
.84d9	a9 15		lda #$15		lda	#21
.84db	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.84de					_DCType:
.84de	4c bc 9f	jmp $9fbc			jmp 	TypeError
.84e1					_DCGetSize:
.84e1	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84e3	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 	; get array dimension
.84e6	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84e8	f0 e7		beq $84d1			beq 	_DCSize
.84ea	c9 fe		cmp #$fe			cmp 	#254
.84ec	f0 e3		beq $84d1			beq 	_DCSize
.84ee	60		rts				rts
.84ef					ScaleByBaseType:
.84ef	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f1	d0 19		bne $850c			bne 	_SBBTString
.84f3	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84f5	48		pha				pha
.84f6	a5 36		lda $36				lda 	zTemp0
.84f8	48		pha				pha
.84f9	06 36		asl $36				asl 	zTemp0 					; x 2
.84fb	26 37		rol $37				rol 	zTemp0+1
.84fd	06 36		asl $36				asl 	zTemp0 					; x 4
.84ff	26 37		rol $37				rol 	zTemp0+1
.8501	68		pla				pla 							; add stacked value = x 5
.8502	65 36		adc $36				adc 	zTemp0
.8504	85 36		sta $36				sta 	zTemp0
.8506	68		pla				pla
.8507	65 37		adc $37				adc 	zTemp0+1
.8509	85 37		sta $37				sta 	zTemp0+1
.850b	60		rts				rts
.850c					_SBBTString:
.850c	06 36		asl $36				asl 	zTemp0
.850e	26 37		rol $37				rol 	zTemp0+1
.8510	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8511					EndCommand:
.8511	4c 53 83	jmp $8353			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8514					ForCommand:
.8514	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.8516	20 81 a6	jsr $a681			jsr 	StackOpen
.8519	a2 00		ldx #$00			ldx 	#0
.851b	20 ee 97	jsr $97ee			jsr 	EvaluateTerm
.851e	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8521	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8523	d0 49		bne $856e			bne		_FCError
.8525	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8527	20 5c 8d	jsr $8d5c			jsr 	CheckNextA
.852a	e8		inx				inx
.852b	20 74 9d	jsr $9d74			jsr 	EvaluateInteger 			; <from> in +1
.852e	b1 30		lda ($30),y			lda 	(codePtr),y
.8530	c8		iny				iny 								; consume it
.8531	48		pha				pha 								; save on stack for later
.8532	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8534	f0 04		beq $853a			beq 	_FCNoSyntax
.8536	c9 cd		cmp #$cd			cmp 	#KWD_TO
.8538	d0 37		bne $8571			bne 	_FCSyntaxError
.853a					_FCNoSyntax:
.853a	e8		inx				inx
.853b	20 74 9d	jsr $9d74			jsr 	EvaluateInteger
.853e	20 c5 a6	jsr $a6c5			jsr 	STKSaveCodePosition 		; save loop back position
.8541	68		pla				pla 								; restore DOWNTO or TO
.8542	5a		phy				phy 								; save Y on the stack
.8543	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8545	f0 02		beq $8549			beq 	_FCNotDownTo
.8547	a9 02		lda #$02			lda 	#2
.8549					_FCNotDownTo:
.8549	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.854a	a0 10		ldy #$10			ldy 	#16
.854c	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.854e	a0 06		ldy #$06			ldy 	#6
.8550	ad 08 04	lda $0408			lda 	NSMantissa0
.8553	91 34		sta ($34),y			sta 	(basicStack),y
.8555	ad 10 04	lda $0410			lda 	NSMantissa1
.8558	c8		iny				iny
.8559	91 34		sta ($34),y			sta 	(basicStack),y
.855b	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.855d	a2 01		ldx #$01			ldx 	#1
.855f	20 74 85	jsr $8574			jsr 	FCIntegerToStack
.8562	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8564	a2 02		ldx #$02			ldx 	#2
.8566	20 74 85	jsr $8574			jsr 	FCIntegerToStack
.8569	20 94 85	jsr $8594			jsr 	CopyIndexToReference
.856c	7a		ply				ply 								; restore position
.856d	60		rts				rts
.856e					_FCError:
.856e	4c bc 9f	jmp $9fbc			jmp 	TypeError
.8571					_FCSyntaxError:
.8571	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.8574					FCIntegerToStack:
.8574	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.8577	10 03		bpl $857c			bpl	 	_FCNotNegative
.8579	20 dd 9d	jsr $9ddd			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.857c					_FCNotNegative:
.857c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.857f	91 34		sta ($34),y			sta 	(basicStack),y
.8581	c8		iny				iny
.8582	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8585	91 34		sta ($34),y			sta 	(basicStack),y
.8587	c8		iny				iny
.8588	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.858b	91 34		sta ($34),y			sta 	(basicStack),y
.858d	c8		iny				iny
.858e	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.8591	91 34		sta ($34),y			sta 	(basicStack),y
.8593	60		rts				rts
.8594					CopyIndexToReference:
.8594	5a		phy				phy
.8595	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8597	38		sec				sec 								; (because we copy from offset 8)
.8598	b1 34		lda ($34),y			lda 	(basicStack),y
.859a	e9 08		sbc #$08			sbc 	#8
.859c	85 36		sta $36				sta 	zTemp0
.859e	c8		iny				iny
.859f	b1 34		lda ($34),y			lda 	(basicStack),y
.85a1	e9 00		sbc #$00			sbc 	#0
.85a3	85 37		sta $37				sta 	zTemp0+1
.85a5	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85a7	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85a9	b1 34		lda ($34),y			lda 	(basicStack),y
.85ab	0a		asl a				asl 	a 							; into carry
.85ac	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85ae	90 14		bcc $85c4			bcc 	_CITRNormal
.85b0	38		sec				sec
.85b1					_CITRNegative:
.85b1	a9 00		lda #$00			lda 	#0
.85b3	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85b5	91 36		sta ($36),y			sta 	(zTemp0),y
.85b7	c8		iny				iny
.85b8	ca		dex				dex
.85b9	d0 f6		bne $85b1			bne 	_CITRNegative
.85bb	88		dey				dey 								; look at MSB of mantissa
.85bc	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85be	09 80		ora #$80			ora 	#$80
.85c0	91 36		sta ($36),y			sta 	(zTemp0),y
.85c2	7a		ply				ply
.85c3	60		rts				rts
.85c4					_CITRNormal:
.85c4	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85c6	91 36		sta ($36),y			sta 	(zTemp0),y
.85c8	c8		iny				iny
.85c9	ca		dex				dex
.85ca	d0 f8		bne $85c4			bne 	_CITRNormal
.85cc	7a		ply				ply 								; and exit.
.85cd	60		rts				rts
.85ce					NextCommand:
.85ce	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85d0	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d2	20 ad a6	jsr $a6ad			jsr 	StackCheckFrame
.85d5	5a		phy				phy
.85d6	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85d8	b1 34		lda ($34),y			lda 	(basicStack),y
.85da	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85dc	30 02		bmi $85e0			bmi 	_NCStepNeg
.85de	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85e0					_NCStepNeg:
.85e0	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e2	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85e4	18		clc				clc
.85e5					_NCBump:
.85e5	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85e7	91 34		sta ($34),y			sta 	(basicStack),y
.85e9	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85eb	c8		iny				iny 								; next byte
.85ec	ca		dex				dex 								; do four times
.85ed	d0 f6		bne $85e5			bne 	_NCBump
.85ef	20 94 85	jsr $8594			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f2	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85f4	b1 34		lda ($34),y			lda 	(basicStack),y
.85f6	0a		asl a				asl 	a 							; sign bit to carry
.85f7	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85f9	85 38		sta $38				sta 	zTemp1
.85fb	90 02		bcc $85ff			bcc 	_NCCompRev 					; use if step is +ve
.85fd	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.85ff					_NCCompRev:
.85ff	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8601	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8603	85 39		sta $39				sta 	zTemp1+1
.8605	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8607	38		sec				sec
.8608					_NCCompare:
.8608	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.860a	b1 34		lda ($34),y			lda 	(basicStack),y
.860c	a4 39		ldy $39				ldy 	zTemp1+1
.860e	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8610	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8612	e6 39		inc $39				inc 	zTemp1+1
.8614	ca		dex				dex 								; do it 4 times.
.8615	d0 f1		bne $8608			bne 	_NCCompare
.8617	50 02		bvc $861b			bvc 	_NCNoOverflow 				; convert to signed comparison
.8619	49 80		eor #$80			eor 	#$80
.861b					_NCNoOverflow:
.861b	7a		ply				ply 								; restore Y position
.861c	0a		asl a				asl 	a 							; is bit 7 set.
.861d	90 04		bcc $8623			bcc 	_NCLoopback 				; if no , >= so loop back
.861f	20 9f a6	jsr $a69f			jsr 	StackClose 					; exit the loop
.8622	60		rts				rts
.8623					_NCLoopBack:
.8623	20 d6 a6	jsr $a6d6			jsr 	STKLoadCodePosition 		; loop back
.8626	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8627					Command_GOSUB:
.8627	a2 00		ldx #$00			ldx 	#0
.8629	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.862c	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.862e	20 81 a6	jsr $a681			jsr 	StackOpen 					; create frame
.8631	20 c5 a6	jsr $a6c5			jsr 	STKSaveCodePosition 		; save current position
.8634	4c 4a 86	jmp $864a			jmp 	GotoStackX
.8637					Command_RETURN:
.8637	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8639	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.863b	20 ad a6	jsr $a6ad			jsr 	StackCheckFrame
.863e	20 d6 a6	jsr $a6d6			jsr 	STKLoadCodePosition 		; restore code position
.8641	20 9f a6	jsr $a69f			jsr 	StackClose
.8644	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8645					GotoCommand:
.8645	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8647	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.864a					GotoStackX:
.864a	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.864d	48		pha				pha 								; it is slightly inefficient, just in cases.
.864e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8651	fa		plx				plx
.8652	20 c1 a5	jsr $a5c1			jsr 	MemorySearch 				; transfer to line number AX.
.8655	90 05		bcc $865c			bcc 	_GotoError 					; not found, off end.
.8657	d0 03		bne $865c			bne 	_GotoError 					; not found exactly
.8659	4c 05 8a	jmp $8a05			jmp 	RunNewLine 					; and go straight to new line code.
.865c					_GotoError:
.865c	a9 0d		lda #$0d		lda	#13
.865e	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8661					IfCommand:
.8661	a2 00		ldx #$00			ldx 	#0 							; If what.
.8663	20 51 9d	jsr $9d51			jsr 	EvaluateNumber
.8666	b1 30		lda ($30),y			lda 	(codePtr),y
.8668	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.866a	d0 0a		bne $8676			bne 	_IFStructured
.866c	c8		iny				iny 								; consume THEN
.866d	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; is it zero
.8670	f0 01		beq $8673			beq 	_IfFail 					; if fail, go to next line
.8672	60		rts				rts 								; if THEN just continue
.8673					_IfFail:
.8673	4c ed 89	jmp $89ed			jmp 	EOLCommand
.8676					_IfStructured:
.8676	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; is it zero
.8679	d0 07		bne $8682			bne 	_IfExit 					; if not, then continue normally.
.867b	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.867d	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.867f	20 a7 8c	jsr $8ca7			jsr 	ScanForward 				; and run from there/
.8682					_IfExit:
.8682	60		rts				rts
.8683					ElseCode:
.8683	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8685	aa		tax				tax 								; so just go to the structure exit
.8686	20 a7 8c	jsr $8ca7			jsr 	ScanForward
.8689	60		rts				rts
.868a					EndIf:
.868a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.868b					LetCommand:
.868b	a2 00		ldx #$00			ldx 	#0
.868d	b1 30		lda ($30),y			lda 	(codePtr),y
.868f	c9 10		cmp #$10			cmp 	#KWD_AT
.8691	d0 16		bne $86a9			bne 	_LCStandard
.8693	c8		iny				iny 								; skip equal
.8694	20 ee 97	jsr $97ee			jsr 	EvaluateTerm 				; get a number
.8697	20 32 96	jsr $9632			jsr 	Dereference 				; dereference it
.869a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.869d	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.869f	9d 00 04	sta $0400,x			sta 	NSStatus,x
.86a2	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.86a4	d0 10		bne $86b6			bne 	_LCMain
.86a6	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; was a reference before.
.86a9					_LCStandard:
.86a9	ad fc 92	lda $92fc			lda 	PrecedenceLevel+"*"			; precedence > this
.86ac	20 16 93	jsr $9316			jsr 	EvaluateExpressionAtPrecedence
.86af	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.86b2	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.86b4	f0 0e		beq $86c4			beq 	_LetGoProc 					; it's a procedure call.
.86b6					_LCMain:
.86b6	a9 3d		lda #$3d			lda 	#"=" 						; check =
.86b8	20 5c 8d	jsr $8d5c			jsr 	CheckNextA
.86bb	e8		inx				inx 								; RHS
.86bc	20 48 9d	jsr $9d48			jsr 	EvaluateValue
.86bf	ca		dex				dex
.86c0	20 c7 86	jsr $86c7			jsr 	AssignVariable
.86c3	60		rts				rts
.86c4					_LetGoProc:
.86c4	4c c5 88	jmp $88c5			jmp 	CallProcedure
.86c7					AssignVariable:
.86c7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.86ca	48		pha				pha 								; save a copy
.86cb	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.86ce	29 10		and #$10			and 	#NSBIsString
.86d0	d0 0b		bne $86dd			bne 	_ASError
.86d2	68		pla				pla 								; get back
.86d3	29 10		and #$10			and 	#NSBIsString 				; check type
.86d5	d0 03		bne $86da			bne 	_ASString
.86d7	4c 5a 95	jmp $955a			jmp 	AssignNumber
.86da					_ASString:
.86da	4c c8 95	jmp $95c8			jmp 	AssignString
.86dd					_ASError:
.86dd	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.86e0					Command_List:
.86e0	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.86e3	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.86e6	9c 14 04	stz $0414			stz 	NSMantissa1+4
.86e9	a9 ff		lda #$ff			lda 	#$FF
.86eb	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.86ee	8d 17 04	sta $0417			sta 	NSMantissa1+7
.86f1	b1 30		lda ($30),y			lda 	(codePtr),y
.86f3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.86f5	f0 1e		beq $8715			beq 	_CLSecond
.86f7	20 76 87	jsr $8776			jsr 	CLIsDigit 					; if not digit, list all
.86fa	b0 24		bcs $8720			bcs 	_CLStart
.86fc	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.86fe	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.8701	b1 30		lda ($30),y			lda 	(codePtr),y
.8703	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8705	f0 0e		beq $8715			beq 	_CLSecond 					; if so go get it
.8707	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.870a	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.870d	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8710	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8713	80 0b		bra $8720			bra 	_CLStart
.8715					_CLSecond:
.8715	c8		iny				iny 								; consume comma
.8716	20 76 87	jsr $8776			jsr 	CLIsDigit 					; digit found
.8719	b0 05		bcs $8720			bcs 	_CLStart 					; if not, continue listing
.871b	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.871d	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.8720					_CLStart
.8720	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8722	85 30		sta $30				sta 	codePtr
.8724	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8726	85 31		sta $31				sta 	codePtr+1
.8728					_CLLoop:
.8728	20 77 aa	jsr $aa77			jsr 	EXTBreakCheck 				; break check
.872b	f0 33		beq $8760			beq 	_CLExit
.872d	b2 30		lda ($30)			lda 	(codePtr)
.872f	f0 2f		beq $8760			beq 	_CLExit
.8731	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8733	20 63 87	jsr $8763			jsr 	CLCompareLineNo
.8736	90 1b		bcc $8753			bcc 	_CLNext
.8738	a2 07		ldx #$07			ldx 	#7
.873a	20 63 87	jsr $8763			jsr 	CLCompareLineNo
.873d	f0 02		beq $8741			beq 	_CLDoThisOne
.873f	b0 12		bcs $8753			bcs 	_CLNext
.8741					_CLDoThisOne:
.8741	20 0a 8d	jsr $8d0a			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8744	20 c1 b3	jsr $b3c1			jsr 	ListConvertLine 			; convert line into token Buffer
.8747	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8749	a9 ab		lda #$ab			lda 	#(tokenBuffer & $FF)
.874b	20 be 8d	jsr $8dbe			jsr 	PrintStringXA
.874e	a9 0d		lda #$0d			lda 	#13 						; new line
.8750	20 c1 a7	jsr $a7c1			jsr 	EXTPrintCharacter
.8753					_CLNext:
.8753	18		clc				clc
.8754	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8756	65 30		adc $30				adc 	codePtr
.8758	85 30		sta $30				sta 	codePtr
.875a	90 02		bcc $875e			bcc 	_CREExit
.875c	e6 31		inc $31				inc 	codePtr+1
.875e					_CREExit:
.875e	80 c8		bra $8728			bra 	_CLLoop
.8760					_CLExit:
.8760	4c 53 83	jmp $8353			jmp 	WarmStart
.8763					CLCompareLineNo:
.8763	38		sec				sec
.8764	a0 01		ldy #$01			ldy 	#1
.8766	b1 30		lda ($30),y			lda 	(codePtr),y
.8768	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.876b	85 36		sta $36				sta 	zTemp0
.876d	c8		iny				iny
.876e	b1 30		lda ($30),y			lda 	(codePtr),y
.8770	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8773	05 36		ora $36				ora 	zTemp0
.8775	60		rts				rts
.8776					CLIsDigit:
.8776	b1 30		lda ($30),y			lda 	(codePtr),y
.8778	c9 30		cmp #$30			cmp 	#"0"
.877a	90 03		bcc $877f			bcc	 	_CLIDExitFalse
.877c	c9 3a		cmp #$3a			cmp 	#"9"+1
.877e	60		rts				rts
.877f					_CLIDExitFalse:
.877f	38		sec				sec
.8780	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8781					Command_LOCAL:
.8781	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8783	20 8f 87	jsr $878f			jsr 	LocaliseNextTerm 			; convert term to a local.
.8786	b1 30		lda ($30),y			lda 	(codePtr),y
.8788	c8		iny				iny
.8789	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.878b	f0 f4		beq $8781			beq 	Command_LOCAL
.878d	88		dey				dey 								; unpick pre-get
.878e	60		rts				rts
.878f					LocaliseNextTerm:
.878f	20 ee 97	jsr $97ee			jsr 	EvaluateTerm 				; evaluate the term
.8792	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8795	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.8797	f0 61		beq $87fa			beq		_LNTError
.8799	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.879c	85 36		sta $36				sta 	zTemp0
.879e	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87a1	85 37		sta $37				sta  	zTemp0+1
.87a3	bd 00 04	lda $0400,x			lda 	NSStatus,x
.87a6	29 10		and #$10			and 	#NSBIsString
.87a8	d0 1e		bne $87c8			bne 	_LNTPushString
.87aa	5a		phy				phy
.87ab	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.87ad					_LNTPushNumLoop:
.87ad	b1 36		lda ($36),y			lda		(zTemp0),y
.87af	20 5f a6	jsr $a65f			jsr 	StackPushByte
.87b2	c8		iny				iny
.87b3	c0 05		cpy #$05			cpy 	#5
.87b5	d0 f6		bne $87ad			bne 	_LNTPushNumLoop
.87b7	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.87b9	20 5f a6	jsr $a65f			jsr 	StackPushByte
.87bc	a5 37		lda $37				lda 	zTemp0+1
.87be	20 5f a6	jsr $a65f			jsr 	StackPushByte
.87c1	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.87c3	20 5f a6	jsr $a65f			jsr 	StackPushByte
.87c6	7a		ply				ply
.87c7	60		rts				rts
.87c8					_LNTPushString:
.87c8	5a		phy				phy
.87c9	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.87cb	85 38		sta $38				sta 	zTemp1
.87cd	a0 01		ldy #$01			ldy 	#1
.87cf	b1 36		lda ($36),y			lda 	(zTemp0),y
.87d1	85 39		sta $39				sta 	zTemp1+1
.87d3	a0 00		ldy #$00			ldy 	#0 							; output string
.87d5	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.87d7	f0 0a		beq $87e3			beq 	_LNTStringOut
.87d9					_LNTPushStrLoop:
.87d9	b1 38		lda ($38),y			lda 	(zTemp1),y
.87db	f0 06		beq $87e3			beq 	_LNTStringOut
.87dd	20 5f a6	jsr $a65f			jsr 	StackPushByte
.87e0	c8		iny				iny
.87e1	80 f6		bra $87d9			bra 	_LNTPushStrLoop
.87e3					_LNTStringOut:
.87e3	98		tya				tya									; output length
.87e4	20 5f a6	jsr $a65f			jsr 	StackPushByte
.87e7	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.87ea	20 5f a6	jsr $a65f			jsr 	StackPushByte
.87ed	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87f0	20 5f a6	jsr $a65f			jsr 	StackPushByte
.87f3	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.87f5	20 5f a6	jsr $a65f			jsr 	StackPushByte
.87f8	7a		ply				ply
.87f9	60		rts				rts
.87fa					_LNTError:
.87fa	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.87fd					LocalPopValue:
.87fd	20 78 a6	jsr $a678			jsr 	StackPopByte
.8800	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8802	d0 17		bne $881b			bne 	_LPVString
.8804	20 78 a6	jsr $a678			jsr 	StackPopByte 				; address
.8807	85 37		sta $37				sta 	zTemp0+1
.8809	20 78 a6	jsr $a678			jsr 	StackPopByte
.880c	85 36		sta $36				sta 	zTemp0
.880e	5a		phy				phy
.880f	a0 04		ldy #$04			ldy 	#4 							; copy back
.8811					_LPVNumberCopy:
.8811	20 78 a6	jsr $a678			jsr 	StackPopByte
.8814	91 36		sta ($36),y			sta 	(zTemp0),y
.8816	88		dey				dey
.8817	10 f8		bpl $8811			bpl 	_LPVNumberCopy
.8819	7a		ply				ply 								; and complete
.881a	60		rts				rts
.881b					_LPVString:
.881b	20 78 a6	jsr $a678			jsr 	StackPopByte 				; address of record => zTemp0
.881e	85 37		sta $37				sta 	zTemp0+1
.8820	20 78 a6	jsr $a678			jsr 	StackPopByte
.8823	85 36		sta $36				sta 	zTemp0
.8825	5a		phy				phy
.8826	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8828	85 38		sta $38				sta 	zTemp1
.882a	a0 01		ldy #$01			ldy 	#1
.882c	b1 36		lda ($36),y			lda 	(zTemp0),y
.882e	85 39		sta $39				sta 	zTemp1+1
.8830	20 78 a6	jsr $a678			jsr 	StackPopByte 				; # to get => y
.8833	a8		tay				tay
.8834	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8836	f0 0e		beq $8846			beq 	_LPVStringCopied
.8838	a9 00		lda #$00			lda 	#0 							; NULL on end
.883a	91 38		sta ($38),y			sta 	(zTemp1),y
.883c					_LPVStringCopy:
.883c	88		dey				dey
.883d	30 07		bmi $8846			bmi 	_LPVStringCopied
.883f	20 78 a6	jsr $a678			jsr 	StackPopByte
.8842	91 38		sta ($38),y			sta 	(zTemp1),y
.8844	80 f6		bra $883c			bra 	_LPVStringCopy
.8846					_LPVStringCopied:
.8846	fa		plx				plx
.8847	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8848					NewCommand:
.8848	20 4e 88	jsr $884e			jsr 	NewProgram
.884b	4c 53 83	jmp $8353			jmp 	WarmStart
.884e					NewProgram:
.884e	20 9f a5	jsr $a59f			jsr 	MemoryNew
.8851	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8854	20 ec 83	jsr $83ec			jsr 	ClearCommand 				; clear everything.
.8857	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/print.asm

.8858					Command_Print:
.8858	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.8859					_CPLoop:
.8859	08		php				php 								; save last action flag
.885a	b1 30		lda ($30),y			lda 	(codePtr),y
.885c	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.885e	f0 46		beq $88a6			beq 	_CPExit
.8860	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8862	f0 42		beq $88a6			beq 	_CPExit
.8864	68		pla				pla 								; throw last action flag
.8865	b1 30		lda ($30),y			lda 	(codePtr),y
.8867	c8		iny				iny
.8868	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.886a	f0 37		beq $88a3			beq 	_CPContinueWithSameLine
.886c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.886e	f0 2e		beq $889e			beq 	_CPTab
.8870	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8872	f0 26		beq $889a			beq 	_CPNewLine
.8874	88		dey				dey 								; undo the get.
.8875	a2 00		ldx #$00			ldx 	#0
.8877	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get a value into slot 0
.887a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.887d	29 10		and #$10			and 	#NSBIsString
.887f	f0 0b		beq $888c			beq 	_CPNumber
.8881	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.8884	ad 08 04	lda $0408			lda 	NSMantissa0
.8887	20 af 88	jsr $88af			jsr 	CPPrintStringXA
.888a	80 cc		bra $8858			bra 	Command_Print 				; loop round clearing carry so NL if end
.888c					_CPNumber:
.888c	a9 05		lda #$05			lda 	#5 							; maximum decimals
.888e	20 1e 9c	jsr $9c1e			jsr 	ConvertNumberToString 		; convert to string
.8891	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8893	a9 1b		lda #$1b			lda 	#DecimalBuffer & $FF
.8895	20 af 88	jsr $88af			jsr 	CPPrintStringXA
.8898	80 be		bra $8858			bra 	Command_Print 				; loop round clearing carry so NL if end
.889a					_CPNewLine:
.889a	a9 0d		lda #$0d			lda 	#13
.889c	80 02		bra $88a0			bra 	_CPPrintChar
.889e					_CPTab:
.889e	a9 09		lda #$09			lda 	#9 							; print TAB
.88a0					_CPPrintChar:
.88a0	20 c2 88	jsr $88c2			jsr 	CPPrintVector
.88a3					_CPContinueWithSameLine:
.88a3	38		sec				sec 								; loop round with carry set, which
.88a4	80 b3		bra $8859			bra 	_CPLoop 					; will inhibit final CR
.88a6					_CPExit:
.88a6	28		plp				plp 								; get last action flag
.88a7	b0 05		bcs $88ae			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.88a9	a9 0d		lda #$0d			lda 	#13 						; print new line
.88ab	20 c2 88	jsr $88c2			jsr 	CPPrintVector
.88ae					_CPExit2:
.88ae	60		rts				rts
.88af					CPPrintStringXA:
.88af	5a		phy				phy
.88b0	86 37		stx $37				stx 	zTemp0+1
.88b2	85 36		sta $36				sta 	zTemp0
.88b4	a0 00		ldy #$00			ldy 	#0
.88b6					_PSXALoop:
.88b6	b1 36		lda ($36),y			lda 	(zTemp0),y
.88b8	f0 06		beq $88c0			beq 	_PSXAExit
.88ba	20 c2 88	jsr $88c2			jsr 	CPPrintVector
.88bd	c8		iny				iny
.88be	80 f6		bra $88b6			bra 	_PSXALoop
.88c0					_PSXAExit:
.88c0	7a		ply				ply
.88c1	60		rts				rts
.88c2					CPPrintVector:
.88c2	4c c1 a7	jmp $a7c1			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.88c5					CallProcedure:
.88c5	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.88c7	b1 30		lda ($30),y			lda 	(codePtr),y
.88c9	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.88cb	f0 0c		beq $88d9			beq 	_CPEndParam
.88cd					_CPParamLoop:
.88cd	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get parameter onto stack
.88d0	e8		inx				inx 								; bump next stack
.88d1	b1 30		lda ($30),y			lda 	(codePtr),y
.88d3	c8		iny				iny
.88d4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.88d6	f0 f5		beq $88cd			beq 	_CPParamLoop
.88d8	88		dey				dey 								; unpick.
.88d9					_CPEndParam:
.88d9	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.88dc	c8		iny				iny									; skip right bracket
.88dd	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.88df	20 81 a6	jsr $a681			jsr 	StackOpen
.88e2	20 c5 a6	jsr $a6c5			jsr 	STKSaveCodePosition 		; save loop position
.88e5	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.88e8	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.88ea	ad 10 04	lda $0410			lda 	NSMantissa1
.88ed	85 37		sta $37				sta 	zTemp0+1
.88ef	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.88f1	b2 36		lda ($36)			lda 	(zTemp0)
.88f3	85 30		sta $30				sta 	safePtr
.88f5	b1 36		lda ($36),y			lda 	(zTemp0),y
.88f7	85 31		sta $31				sta 	safePtr+1
.88f9	c8		iny				iny
.88fa	b1 36		lda ($36),y			lda 	(zTemp0),y
.88fc	85 32		sta $32				sta 	safePtr+2
.88fe	c8		iny				iny
.88ff	b1 36		lda ($36),y			lda 	(zTemp0),y
.8901	85 33		sta $33				sta 	safePtr+3
.8903	c8		iny				iny 								; get Y offset -> Y
.8904	b1 36		lda ($36),y			lda 	(zTemp0),y
.8906	a8		tay				tay
.8907	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8909	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.890c	f0 13		beq $8921			beq 	_ParamExit 					; if so, exit.
.890e					_ParamExtract:
.890e	ca		dex				dex 								; put a local term on the level before
.890f	20 8f 87	jsr $878f			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8912	20 c7 86	jsr $86c7			jsr 	AssignVariable 				; assign stacked value to the variable.
.8915	e8		inx				inx 								; advance to next parameter to do.
.8916	e8		inx				inx
.8917	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.891a	f0 05		beq $8921			beq 	_ParamExit
.891c	20 54 8d	jsr $8d54			jsr 	CheckComma 					; comma seperating parameters
.891f	80 ed		bra $890e			bra 	_ParamExtract
.8921					_ParamExit:
.8921	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; check )
.8924	60		rts				rts 								; and continue from here
.8925					Command_ENDPROC:
.8925	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8927	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8929	20 ad a6	jsr $a6ad			jsr 	StackCheckFrame
.892c	20 d6 a6	jsr $a6d6			jsr 	STKLoadCodePosition 		; restore code position
.892f	20 9f a6	jsr $a69f			jsr 	StackClose
.8932	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8933					Command_Read:
.8933	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8935	20 ee 97	jsr $97ee			jsr 	EvaluateTerm
.8938	bd 00 04	lda $0400,x			lda 	NSStatus,x
.893b	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.893d	f0 4a		beq $8989			beq 	_CRSyntax 					; check reference (bit 0)
.893f	20 d2 89	jsr $89d2			jsr 	SwapDataCodePtrs 			; swap code and data
.8942	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8945	d0 20		bne $8967			bne 	_CRContinueData
.8947					_CRKeepSearching:
.8947	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.8949	aa		tax				tax
.894a	20 a7 8c	jsr $8ca7			jsr 	ScanForward
.894d	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.894f	f0 16		beq $8967			beq 	_CRHaveData 				; found it
.8951	18		clc				clc
.8952	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8954	65 30		adc $30				adc 	codePtr
.8956	85 30		sta $30				sta 	codePtr
.8958	90 02		bcc $895c			bcc 	_CREExit
.895a	e6 31		inc $31				inc 	codePtr+1
.895c					_CREExit:
.895c	a0 03		ldy #$03			ldy 	#3 							; start of line.
.895e	b2 30		lda ($30)			lda 	(codePtr)
.8960	d0 e5		bne $8947			bne 	_CRKeepSearching
.8962	a9 0b		lda #$0b		lda	#11
.8964	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8967					_CRHaveData:
.8967					_CRContinueData:
.8967	a2 01		ldx #$01			ldx 	#1
.8969	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; evaluate value into slot # 1
.896c	ca		dex				dex
.896d	20 c7 86	jsr $86c7			jsr		AssignVariable 				; do the assignment
.8970	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.8973	b1 30		lda ($30),y			lda 	(codePtr),y
.8975	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8977	d0 04		bne $897d			bne 	_CRSwapBack
.8979	c8		iny				iny 								; consume comma
.897a	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.897d					_CRSwapBack:
.897d	20 d2 89	jsr $89d2			jsr 	SwapDataCodePtrs			; swap them back.
.8980	b1 30		lda ($30),y			lda 	(codePtr),y
.8982	c8		iny				iny
.8983	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8985	f0 ac		beq $8933			beq 	Command_Read 				; if so go round again.
.8987	88		dey				dey 								; unpick get.
.8988	60		rts				rts
.8989					_CRSyntax:
.8989	4c b2 9f	jmp $9fb2			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.898c					RemCommand:
.898c	b1 30		lda ($30),y			lda 	(codePtr),y
.898e	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8990	d0 06		bne $8998			bne 	_RMExit
.8992	c8		iny				iny
.8993	98		tya				tya
.8994	38		sec				sec
.8995	71 30		adc ($30),y			adc 	(codePtr),y
.8997	a8		tay				tay
.8998					_RMExit:
.8998	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8999					Command_REPEAT:
.8999	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.899b	20 81 a6	jsr $a681			jsr 	StackOpen
.899e	20 c5 a6	jsr $a6c5			jsr 	STKSaveCodePosition 		; save loop position
.89a1	60		rts				rts
.89a2					Command_UNTIL:
.89a2	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.89a4	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.89a6	20 ad a6	jsr $a6ad			jsr 	StackCheckFrame
.89a9	a2 00		ldx #$00			ldx 	#0
.89ab	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; work out the number
.89ae	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; check if zero
.89b1	f0 04		beq $89b7			beq 	_CULoopBack 				; if so keep looping
.89b3	20 9f a6	jsr $a69f			jsr 	StackClose		 			; return
.89b6	60		rts				rts
.89b7					_CULoopBack:
.89b7	20 d6 a6	jsr $a6d6			jsr 	STKLoadCodePosition 		; loop back
.89ba	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.89bb					Command_Restore:
.89bb	20 d2 89	jsr $89d2			jsr 	SwapDataCodePtrs 			; swap code and data
.89be	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.89c0	85 30		sta $30				sta 	codePtr
.89c2	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.89c4	85 31		sta $31				sta 	codePtr+1
.89c6	20 d2 89	jsr $89d2			jsr 	SwapDataCodePtrs 			; put them back
.89c9	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.89cb	8d 9b 04	sta $049b			sta 	dataPointer+4
.89ce	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.89d1	60		rts				rts
.89d2					SwapDataCodePtrs:
.89d2	da		phx				phx
.89d3	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.89d5					_SDCPLoop:
.89d5	b5 30		lda $30,x			lda 	safePtr,x
.89d7	48		pha				pha
.89d8	bd 97 04	lda $0497,x			lda 	dataPointer,x
.89db	95 30		sta $30,x			sta 	safePtr,x
.89dd	68		pla				pla
.89de	9d 97 04	sta $0497,x			sta 	dataPointer,x
.89e1	ca		dex				dex
.89e2	10 f1		bpl $89d5			bpl 	_SDCPLoop
.89e4	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.89e7	8c 9b 04	sty $049b			sty 	dataPointer+4
.89ea	a8		tay				tay
.89eb	fa		plx				plx
.89ec	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.89ed					EOLCommand:
.89ed	18		clc				clc
.89ee	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.89f0	65 30		adc $30				adc 	codePtr
.89f2	85 30		sta $30				sta 	codePtr
.89f4	90 02		bcc $89f8			bcc 	_CREExit
.89f6	e6 31		inc $31				inc 	codePtr+1
.89f8					_CREExit:
.89f8	80 0b		bra $8a05			bra 	RunNewLine
.89fa					CommandRUN:
.89fa	20 ec 83	jsr $83ec			jsr 	ClearCommand 				; clear variable/stacks/etc.
.89fd	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.89ff	85 30		sta $30				sta 	codePtr
.8a01	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a03	85 31		sta $31				sta 	codePtr+1
.8a05					RUNNewLine:
.8a05	b2 30		lda ($30)			lda 	(codePtr)
.8a07	f0 72		beq $8a7b			beq 	CRNoProgram         		; no then END.
.8a09	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a0b	9a		txs				txs
.8a0c					RUNCodePointerLine:
.8a0c	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a0e					_CRIncMainLoop:
.8a0e	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8a11	d0 19		bne $8a2c			bne 	_CRNoBreakCheck
.8a13	20 77 aa	jsr $aa77			jsr 	EXTBreakCheck 				; break check
.8a16	f0 5e		beq $8a76			beq 	_CRBreak
.8a18	64 01		stz $01				stz 	1 							; access I/O Page 0
.8a1a	38		sec				sec 								; calculate timer - LastTick
.8a1b	ad 59 d6	lda $d659			lda 	$D659
.8a1e	aa		tax				tax 								; saving timer in X
.8a1f	ed 2d 06	sbc $062d			sbc 	LastTick
.8a22	c9 03		cmp #$03			cmp 	#3
.8a24	90 06		bcc $8a2c			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8a26	8e 2d 06	stx $062d			stx 	LastTick 					; update last timer
.8a29	20 d7 b9	jsr $b9d7			jsr 	TickHandler 				; go do the code.
.8a2c					_NoFireTick:
.8a2c					_CRNoBreakCheck:
.8a2c	c8		iny				iny
.8a2d					_CRMainLoop:
.8a2d	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8a30	b1 30		lda ($30),y			lda 	(codePtr),y
.8a32	10 10		bpl $8a44			bpl 	_CRNotKeyword
.8a34	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8a36	b0 04		bcs $8a3c			bcs 	_CRIsKeyword
.8a38	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8a3a	b0 34		bcs $8a70			bcs		_CRSyntaxError
.8a3c					_CRIsKeyword:
.8a3c	c8		iny				iny 								; consume command
.8a3d	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8a3e	aa		tax				tax 								; put in X for vector jump
.8a3f	20 73 8a	jsr $8a73			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8a42	80 e9		bra $8a2d			bra 	_CRMainLoop 				; and loop round
.8a44					_CRNotKeyword:
.8a44	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8a46	f0 c6		beq $8a0e			beq 	_CRIncMainLoop
.8a48	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8a4a	90 05		bcc $8a51			bcc 	_CRNotVariable
.8a4c					_CRGoLet:
.8a4c	20 8b 86	jsr $868b			jsr 	LetCommand
.8a4f	80 dc		bra $8a2d			bra 	_CRMainLoop
.8a51					_CRNotVariable:
.8a51	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8a53	f0 f7		beq $8a4c			beq 	_CRGoLet
.8a55	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8a57	f0 f3		beq $8a4c			beq 	_CRGoLet
.8a59	c9 21		cmp #$21			cmp 	#KWD_PLING
.8a5b	f0 ef		beq $8a4c			beq 	_CRGoLet
.8a5d	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8a5f	f0 09		beq $8a6a			beq 	_CRGoRem
.8a61	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8a63	d0 0b		bne $8a70			bne 	_CRSyntaxError
.8a65	20 11 82	jsr $8211			jsr 	LabelHere
.8a68	80 c3		bra $8a2d			bra 	_CRMainLoop
.8a6a					_CRGoRem:
.8a6a	c8		iny				iny
.8a6b	20 8c 89	jsr $898c			jsr 	RemCommand
.8a6e	80 bd		bra $8a2d			bra 	_CRMainLoop
.8a70					_CRSyntaxError:
.8a70	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.8a73					_CRCallVector0:
.8a73	7c 12 8b	jmp ($8b12,x)			jmp 	(VectorSet0,x)
.8a76					_CRBreak:
.8a76	a9 01		lda #$01		lda	#1
.8a78	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8a7b					CRNoProgram:
.8a7b	4c 11 85	jmp $8511			jmp 	EndCommand
.8a7e					Shift1Command:
.8a7e	b1 30		lda ($30),y			lda 	(codePtr),y
.8a80	c8		iny				iny
.8a81	0a		asl a				asl 	a
.8a82	aa		tax				tax
.8a83	7c ae 8b	jmp ($8bae,x)			jmp 	(VectorSet1,x)
.8a86					Shift2Command:
.8a86	b1 30		lda ($30),y			lda 	(codePtr),y
.8a88	c8		iny				iny
.8a89	0a		asl a				asl 	a
.8a8a	aa		tax				tax
.8a8b	7c c8 8b	jmp ($8bc8,x)			jmp 	(VectorSet2,x)
.8a8e					Unused1:
.8a8e					Unused2:
.8a8e					Unused3:
.8a8e					Unused4:
.8a8e	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
>8a91							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8a92					VectorSetPunc:
>8a92	52 90					.word	ShiftLeft                        ; $00 <<
>8a94	09 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8a96	ff 8d					.word	BinaryCompareNotEqual            ; $02 <>
>8a98	b2 9f					.word	SyntaxError                      ; $03 !!3
>8a9a	b2 9f					.word	SyntaxError                      ; $04 ><
>8a9c	13 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8a9e	55 90					.word	ShiftRight                       ; $06 >>
>8aa0	b2 9f					.word	SyntaxError                      ; $07 !!7
>8aa2	b2 9f					.word	SyntaxError                      ; $08 !!8
>8aa4	b2 9f					.word	SyntaxError                      ; $09 !!9
>8aa6	b2 9f					.word	SyntaxError                      ; $0a !!10
>8aa8	b2 9f					.word	SyntaxError                      ; $0b !!11
>8aaa	b2 9f					.word	SyntaxError                      ; $0c !!12
>8aac	b2 9f					.word	SyntaxError                      ; $0d !!13
>8aae	b2 9f					.word	SyntaxError                      ; $0e !!14
>8ab0	b2 9f					.word	SyntaxError                      ; $0f !!15
>8ab2	b2 9f					.word	SyntaxError                      ; $10 @
>8ab4	b2 9f					.word	SyntaxError                      ; $11 !!17
>8ab6	b2 9f					.word	SyntaxError                      ; $12 !!18
>8ab8	b2 9f					.word	SyntaxError                      ; $13 [
>8aba	d6 8e					.word	IntegerDivide                    ; $14 \
>8abc	b2 9f					.word	SyntaxError                      ; $15 ]
>8abe	e3 91					.word	EorInteger                       ; $16 ^
>8ac0	b2 9f					.word	SyntaxError                      ; $17 _
>8ac2	b2 9f					.word	SyntaxError                      ; $18 `
>8ac4	b2 9f					.word	SyntaxError                      ; $19 !!25
>8ac6	b2 9f					.word	SyntaxError                      ; $1a !!26
>8ac8	b2 9f					.word	SyntaxError                      ; $1b {
>8aca	9d 91					.word	OraInteger                       ; $1c |
>8acc	b2 9f					.word	SyntaxError                      ; $1d }
>8ace	b2 9f					.word	SyntaxError                      ; $1e ~
>8ad0	b2 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8ad2	b2 9f					.word	SyntaxError                      ; $20
>8ad4	29 92					.word	WordIndirect                     ; $21 !
>8ad6	b2 9f					.word	SyntaxError                      ; $22 "
>8ad8	b2 9f					.word	SyntaxError                      ; $23 #
>8ada	b2 9f					.word	SyntaxError                      ; $24 $
>8adc	23 8f					.word	IntegerModulus                   ; $25 %
>8ade	57 91					.word	AndInteger                       ; $26 &
>8ae0	b2 9f					.word	SyntaxError                      ; $27 '
>8ae2	b2 9f					.word	SyntaxError                      ; $28 (
>8ae4	b2 9f					.word	SyntaxError                      ; $29 )
>8ae6	98 8f					.word	MulInteger                       ; $2a *
>8ae8	e9 90					.word	AddInteger                       ; $2b +
>8aea	b2 9f					.word	SyntaxError                      ; $2c ,
>8aec	2c 91					.word	SubInteger                       ; $2d -
>8aee	b2 9f					.word	SyntaxError                      ; $2e .
>8af0	14 94					.word	FDivideCommand                   ; $2f /
>8af2	b2 9f					.word	SyntaxError                      ; $30 0
>8af4	b2 9f					.word	SyntaxError                      ; $31 1
>8af6	b2 9f					.word	SyntaxError                      ; $32 2
>8af8	b2 9f					.word	SyntaxError                      ; $33 3
>8afa	b2 9f					.word	SyntaxError                      ; $34 4
>8afc	b2 9f					.word	SyntaxError                      ; $35 5
>8afe	b2 9f					.word	SyntaxError                      ; $36 6
>8b00	b2 9f					.word	SyntaxError                      ; $37 7
>8b02	b2 9f					.word	SyntaxError                      ; $38 8
>8b04	b2 9f					.word	SyntaxError                      ; $39 9
>8b06	b2 9f					.word	SyntaxError                      ; $3a :
>8b08	b2 9f					.word	SyntaxError                      ; $3b ;
>8b0a	eb 8d					.word	BinaryCompareLess                ; $3c <
>8b0c	e1 8d					.word	BinaryCompareEqual               ; $3d =
>8b0e	f5 8d					.word	BinaryCompareGreater             ; $3e >
>8b10	50 92					.word	ByteIndirect                     ; $3f ?
.8b12					VectorSet0:
>8b12	ed 89					.word	EOLCommand                       ; $80 !0:EOF
>8b14	7e 8a					.word	Shift1Command                    ; $81 !1:SH1
>8b16	86 8a					.word	Shift2Command                    ; $82 !2:SH2
>8b18	84 99					.word	AbsUnary                         ; $83 ABS(
>8b1a	94 99					.word	AllocUnary                       ; $84 ALLOC(
>8b1c	04 9a					.word	AscUnary                         ; $85 ASC(
>8b1e	cf 9b					.word	ChrUnary                         ; $86 CHR$(
>8b20	22 a4					.word	UnaryEvent                       ; $87 EVENT(
>8b22	dd 8d					.word	UnaryFalse                       ; $88 FALSE
>8b24	11 9a					.word	FracUnary                        ; $89 FRAC(
>8b26	b8 a3					.word	UnaryHit                         ; $8a HIT(
>8b28	27 9a					.word	IntUnary                         ; $8b INT(
>8b2a	8e 9b					.word	IsValUnary                       ; $8c ISVAL(
>8b2c	b2 a4					.word	UnaryJoyB                        ; $8d JOYB(
>8b2e	8b a4					.word	UnaryJoyX                        ; $8e JOYX(
>8b30	8e a4					.word	UnaryJoyY                        ; $8f JOYY(
>8b32	a9 9c					.word	Unary_Left                       ; $90 LEFT$(
>8b34	39 9a					.word	LenUnary                         ; $91 LEN(
>8b36	57 9a					.word	Unary_Max                        ; $92 MAX(
>8b38	d3 9c					.word	Unary_Mid                        ; $93 MID$(
>8b3a	53 9a					.word	Unary_Min                        ; $94 MIN(
>8b3c	ae 9a					.word	Unary_Not                        ; $95 NOT(
>8b3e	b2 9f					.word	SyntaxError                      ; $96 PLAYING(
>8b40	c4 9a					.word	Unary_Random                     ; $97 RANDOM(
>8b42	b9 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8b44	e3 9a					.word	Unary_Rnd                        ; $99 RND(
>8b46	64 9b					.word	SgnUnary                         ; $9a SGN(
>8b48	e1 9b					.word	SpcUnary                         ; $9b SPC(
>8b4a	fc 9b					.word	Unary_Str                        ; $9c STR$(
>8b4c	c6 a4					.word	UnaryTimer                       ; $9d TIMER(
>8b4e	d1 8d					.word	UnaryTrue                        ; $9e TRUE
>8b50	84 9b					.word	ValUnary                         ; $9f VAL(
>8b52	14 85					.word	ForCommand                       ; $a0 FOR
>8b54	61 86					.word	IfCommand                        ; $a1 IF
>8b56	8e 8a					.word	Unused1                          ; $a2 PROC
>8b58	99 89					.word	Command_REPEAT                   ; $a3 REPEAT
>8b5a	1d 8d					.word	Command_WHILE                    ; $a4 WHILE
>8b5c	8a 86					.word	EndIf                            ; $a5 ENDIF
>8b5e	25 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8b60	ce 85					.word	NextCommand                      ; $a7 NEXT
>8b62	8e 8a					.word	Unused4                          ; $a8 THEN
>8b64	a2 89					.word	Command_UNTIL                    ; $a9 UNTIL
>8b66	3e 8d					.word	Command_WEND                     ; $aa WEND
>8b68	b2 9f					.word	SyntaxError                      ; $ab BY
>8b6a	b2 83					.word	CallCommand                      ; $ac CALL
>8b6c	5a a1					.word	CircleCommand                    ; $ad CIRCLE
>8b6e	ec 83					.word	ClearCommand                     ; $ae CLEAR
>8b70	44 84					.word	ClearScreen                      ; $af CLS
>8b72	b2 9f					.word	SyntaxError                      ; $b0 COLOR
>8b74	b2 9f					.word	SyntaxError                      ; $b1 COLOUR
>8b76	4c 84					.word	Command_Data                     ; $b2 DATA
>8b78	54 84					.word	DimCommand                       ; $b3 DIM
>8b7a	8e 8a					.word	Unused3                          ; $b4 DOWNTO
>8b7c	83 86					.word	ElseCode                         ; $b5 ELSE
>8b7e	b2 9f					.word	SyntaxError                      ; $b6 FROM
>8b80	86 a3					.word	GfxCommand                       ; $b7 GFX
>8b82	27 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8b84	45 86					.word	GotoCommand                      ; $b9 GOTO
>8b86	b2 9f					.word	SyntaxError                      ; $ba HERE
>8b88	84 a1					.word	ImageCommand                     ; $bb IMAGE
>8b8a	8b 86					.word	LetCommand                       ; $bc LET
>8b8c	d9 a1					.word	LineCommand                      ; $bd LINE
>8b8e	81 87					.word	Command_LOCAL                    ; $be LOCAL
>8b90	b2 9f					.word	SyntaxError                      ; $bf OFF
>8b92	b2 9f					.word	SyntaxError                      ; $c0 ON
>8b94	b2 9f					.word	SyntaxError                      ; $c1 OUTLINE
>8b96	de a3					.word	PaletteCommand                   ; $c2 PALETTE
>8b98	d2 a1					.word	PlotCommand                      ; $c3 PLOT
>8b9a	58 88					.word	Command_Print                    ; $c4 PRINT
>8b9c	33 89					.word	Command_Read                     ; $c5 READ
>8b9e	56 a1					.word	RectangleCommand                 ; $c6 RECT
>8ba0	8c 89					.word	RemCommand                       ; $c7 REM
>8ba2	37 86					.word	Command_RETURN                   ; $c8 RETURN
>8ba4	b2 9f					.word	SyntaxError                      ; $c9 SOLID
>8ba6	f4 a5					.word	SoundCommand                     ; $ca SOUND
>8ba8	65 a1					.word	SpriteCommand                    ; $cb SPRITE
>8baa	a1 a1					.word	TextCommand                      ; $cc TEXT
>8bac	8e 8a					.word	Unused2                          ; $cd TO
.8bae					VectorSet1:
>8bae	b2 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bb0	b2 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bb2	b2 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bb4	83 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8bb6	a2 83					.word	AssertCommand                    ; $84 ASSERT
>8bb8	26 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8bba	11 85					.word	EndCommand                       ; $86 END
>8bbc	e0 86					.word	Command_List                     ; $87 LIST
>8bbe	48 88					.word	NewCommand                       ; $88 NEW
>8bc0	bb 89					.word	Command_Restore                  ; $89 RESTORE
>8bc2	fa 89					.word	CommandRUN                       ; $8a RUN
>8bc4	6b a3					.word	SpritesCtrl                      ; $8b SPRITES
>8bc6	50 8c					.word	StopCommand                      ; $8c STOP
.8bc8					VectorSet2:
>8bc8	b2 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bca	b2 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bcc	b2 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bce	71 9e					.word	Assemble_adc                     ; $83 ADC
>8bd0	69 9e					.word	Assemble_and                     ; $84 AND
>8bd2	85 9e					.word	Assemble_asl                     ; $85 ASL
>8bd4	ef 9e					.word	Assemble_bcc                     ; $86 BCC
>8bd6	f3 9e					.word	Assemble_bcs                     ; $87 BCS
>8bd8	fb 9e					.word	Assemble_beq                     ; $88 BEQ
>8bda	b2 9e					.word	Assemble_bit                     ; $89 BIT
>8bdc	e3 9e					.word	Assemble_bmi                     ; $8a BMI
>8bde	f7 9e					.word	Assemble_bne                     ; $8b BNE
>8be0	df 9e					.word	Assemble_bpl                     ; $8c BPL
>8be2	ff 9e					.word	Assemble_bra                     ; $8d BRA
>8be4	03 9f					.word	Assemble_brk                     ; $8e BRK
>8be6	e7 9e					.word	Assemble_bvc                     ; $8f BVC
>8be8	eb 9e					.word	Assemble_bvs                     ; $90 BVS
>8bea	0b 9f					.word	Assemble_clc                     ; $91 CLC
>8bec	5f 9f					.word	Assemble_cld                     ; $92 CLD
>8bee	1f 9f					.word	Assemble_cli                     ; $93 CLI
>8bf0	4f 9f					.word	Assemble_clv                     ; $94 CLV
>8bf2	7d 9e					.word	Assemble_cmp                     ; $95 CMP
>8bf4	c6 9e					.word	Assemble_cpx                     ; $96 CPX
>8bf6	c1 9e					.word	Assemble_cpy                     ; $97 CPY
>8bf8	a3 9e					.word	Assemble_dec                     ; $98 DEC
>8bfa	5b 9f					.word	Assemble_dex                     ; $99 DEX
>8bfc	37 9f					.word	Assemble_dey                     ; $9a DEY
>8bfe	6d 9e					.word	Assemble_eor                     ; $9b EOR
>8c00	a8 9e					.word	Assemble_inc                     ; $9c INC
>8c02	6b 9f					.word	Assemble_inx                     ; $9d INX
>8c04	57 9f					.word	Assemble_iny                     ; $9e INY
>8c06	da 9e					.word	Assemble_jmp                     ; $9f JMP
>8c08	d5 9e					.word	Assemble_jsr                     ; $a0 JSR
>8c0a	79 9e					.word	Assemble_lda                     ; $a1 LDA
>8c0c	9e 9e					.word	Assemble_ldx                     ; $a2 LDX
>8c0e	bc 9e					.word	Assemble_ldy                     ; $a3 LDY
>8c10	8f 9e					.word	Assemble_lsr                     ; $a4 LSR
>8c12	6f 9f					.word	Assemble_nop                     ; $a5 NOP
>8c14	65 9e					.word	Assemble_ora                     ; $a6 ORA
>8c16	1b 9f					.word	Assemble_pha                     ; $a7 PHA
>8c18	07 9f					.word	Assemble_php                     ; $a8 PHP
>8c1a	63 9f					.word	Assemble_phx                     ; $a9 PHX
>8c1c	23 9f					.word	Assemble_phy                     ; $aa PHY
>8c1e	2b 9f					.word	Assemble_pla                     ; $ab PLA
>8c20	0f 9f					.word	Assemble_plp                     ; $ac PLP
>8c22	77 9f					.word	Assemble_plx                     ; $ad PLX
>8c24	33 9f					.word	Assemble_ply                     ; $ae PLY
>8c26	8a 9e					.word	Assemble_rol                     ; $af ROL
>8c28	94 9e					.word	Assemble_ror                     ; $b0 ROR
>8c2a	17 9f					.word	Assemble_rti                     ; $b1 RTI
>8c2c	27 9f					.word	Assemble_rts                     ; $b2 RTS
>8c2e	81 9e					.word	Assemble_sbc                     ; $b3 SBC
>8c30	13 9f					.word	Assemble_sec                     ; $b4 SEC
>8c32	73 9f					.word	Assemble_sed                     ; $b5 SED
>8c34	2f 9f					.word	Assemble_sei                     ; $b6 SEI
>8c36	75 9e					.word	Assemble_sta                     ; $b7 STA
>8c38	67 9f					.word	Assemble_stp                     ; $b8 STP
>8c3a	99 9e					.word	Assemble_stx                     ; $b9 STX
>8c3c	b7 9e					.word	Assemble_sty                     ; $ba STY
>8c3e	ad 9e					.word	Assemble_stz                     ; $bb STZ
>8c40	4b 9f					.word	Assemble_tax                     ; $bc TAX
>8c42	47 9f					.word	Assemble_tay                     ; $bd TAY
>8c44	d0 9e					.word	Assemble_trb                     ; $be TRB
>8c46	cb 9e					.word	Assemble_tsb                     ; $bf TSB
>8c48	53 9f					.word	Assemble_tsx                     ; $c0 TSX
>8c4a	3b 9f					.word	Assemble_txa                     ; $c1 TXA
>8c4c	43 9f					.word	Assemble_txs                     ; $c2 TXS
>8c4e	3f 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8c50					StopCommand:
.8c50	a9 08		lda #$08		lda	#8
.8c52	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8c55					ProcedureScan:
.8c55	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8c57	85 30		sta $30				sta 	codePtr
.8c59	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8c5b	85 31		sta $31				sta 	codePtr+1
.8c5d					_PSLoop:
.8c5d	b2 30		lda ($30)			lda 	(codePtr)
.8c5f	f0 42		beq $8ca3			beq 	_PSExit
.8c61	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8c63	b1 30		lda ($30),y			lda 	(codePtr),y
.8c65	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8c67	d0 2d		bne $8c96			bne 	_PSNext
.8c69	c8		iny				iny 								; get the address of the record to zTemp0 and
.8c6a	b1 30		lda ($30),y			lda 	(codePtr),y
.8c6c	29 c0		and #$c0			and 	#$C0
.8c6e	c9 40		cmp #$40			cmp 	#$40
.8c70	d0 32		bne $8ca4			bne 	_PSSyntax
.8c72	b1 30		lda ($30),y			lda 	(codePtr),y
.8c74	18		clc				clc
.8c75	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8c77	85 37		sta $37				sta 	zTemp0+1
.8c79	c8		iny				iny 								; LSB
.8c7a	b1 30		lda ($30),y			lda 	(codePtr),y
.8c7c	85 36		sta $36				sta 	zTemp0
.8c7e	c8		iny				iny 								; character after variable call.
.8c7f	98		tya				tya 								; save Y offset at +7
.8c80	a0 07		ldy #$07			ldy 	#7
.8c82	91 36		sta ($36),y			sta 	(zTemp0),y
.8c84	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8c86	a0 02		ldy #$02			ldy 	#2
.8c88	91 36		sta ($36),y			sta 	(zTemp0),y
.8c8a	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8c8c					_PSCopy:
.8c8c	b5 30		lda $30,x			lda 	safePtr,x
.8c8e	c8		iny				iny
.8c8f	91 36		sta ($36),y			sta 	(zTemp0),y
.8c91	e8		inx				inx
.8c92	e0 04		cpx #$04			cpx 	#4
.8c94	d0 f6		bne $8c8c			bne 	_PSCopy
.8c96					_PSNext:
.8c96	18		clc				clc
.8c97	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8c99	65 30		adc $30				adc 	codePtr
.8c9b	85 30		sta $30				sta 	codePtr
.8c9d	90 02		bcc $8ca1			bcc 	_CREExit
.8c9f	e6 31		inc $31				inc 	codePtr+1
.8ca1					_CREExit:
.8ca1	80 ba		bra $8c5d			bra 	_PSLoop
.8ca3					_PSExit:
.8ca3	60		rts				rts
.8ca4					_PSSyntax:
.8ca4	4c b2 9f	jmp $9fb2			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8ca7					ScanForward:
.8ca7	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8ca9	86 37		stx $37				stx 	zTemp0+1
.8cab	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8cad					_ScanLoop:
.8cad	b1 30		lda ($30),y			lda 	(codePtr),y
.8caf	c8		iny				iny
.8cb0	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8cb2	d0 0e		bne $8cc2			bne 	_ScanGoNext
.8cb4	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8cb6	f0 04		beq $8cbc			beq 	_ScanMatch
.8cb8	c5 37		cmp $37				cmp 	zTemp0+1
.8cba	d0 06		bne $8cc2			bne 	_ScanGoNext
.8cbc					_ScanMatch:
.8cbc	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8cbe	d0 01		bne $8cc1			bne 	_ScanNotEndEOL
.8cc0	88		dey				dey
.8cc1					_ScanNotEndEOL:
.8cc1	60		rts				rts
.8cc2					_ScanGoNext:
.8cc2	20 c7 8c	jsr $8cc7			jsr  	ScanForwardOne
.8cc5	80 e6		bra $8cad			bra 	_ScanLoop
.8cc7					ScanForwardOne:
.8cc7	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8cc9	90 3e		bcc $8d09			bcc 	_SFWExit
.8ccb	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8ccd	90 18		bcc $8ce7			bcc 	_ScanSkipOne
.8ccf	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8cd1	b0 2f		bcs $8d02			bcs 	_ScanSkipData
.8cd3	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8cd5	90 32		bcc $8d09			bcc 	_SFWExit 					; if not, ordinary keywords.
.8cd7	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8cd9	b0 2e		bcs $8d09			bcs 	_SFWExit
.8cdb	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8cdd	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8cdf	b0 28		bcs $8d09			bcs 	_SFWExit
.8ce1	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8ce3	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8ce5	80 22		bra $8d09			bra 	_SFWExit
.8ce7					_ScanSkipOne:
.8ce7	c8		iny				iny 								; consume the extra one.
.8ce8	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8cea	d0 1d		bne $8d09			bne 	_SFWExit
.8cec	18		clc				clc
.8ced	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8cef	65 30		adc $30				adc 	codePtr
.8cf1	85 30		sta $30				sta 	codePtr
.8cf3	90 02		bcc $8cf7			bcc 	_CREExit
.8cf5	e6 31		inc $31				inc 	codePtr+1
.8cf7					_CREExit:
.8cf7	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8cf9	b2 30		lda ($30)			lda 	(codePtr)
.8cfb	d0 0c		bne $8d09			bne 	_SFWExit 					; if not zero, more to scan
.8cfd	a9 13		lda #$13		lda	#19
.8cff	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8d02					_ScanSkipData:
.8d02	88		dey				dey 								; point at data token
.8d03	c8		iny				iny
.8d04	98		tya				tya
.8d05	38		sec				sec
.8d06	71 30		adc ($30),y			adc 	(codePtr),y
.8d08	a8		tay				tay
.8d09					_SFWExit:
.8d09	60		rts				rts
.8d0a					ScanGetCurrentLineStep:
.8d0a	64 38		stz $38				stz 	zTemp1
.8d0c	a0 03		ldy #$03			ldy 	#3
.8d0e					_SGCLSLoop:
.8d0e	b1 30		lda ($30),y			lda 	(codePtr),y
.8d10	c8		iny				iny
.8d11	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d13	f0 05		beq $8d1a			beq 	_SGCLSExit
.8d15	20 c7 8c	jsr $8cc7			jsr 	ScanForwardOne
.8d18	80 f4		bra $8d0e			bra 	_SGCLSLoop
.8d1a					_SGCLSExit:
.8d1a	a5 38		lda $38				lda 	zTemp1
.8d1c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8d1d					Command_WHILE:
.8d1d	5a		phy				phy 								; save position of the test
.8d1e	a2 00		ldx #$00			ldx 	#0
.8d20	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; work out the number
.8d23	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; check if zero
.8d26	f0 0e		beq $8d36			beq 	_WHExitLoop 				; if so exit the loop
.8d28	98		tya				tya 								; position *after* test.
.8d29	7a		ply				ply 								; restore position before test, at WHILE
.8d2a	88		dey				dey
.8d2b	48		pha				pha 								; push after test on the stack
.8d2c	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8d2e	20 81 a6	jsr $a681			jsr 	StackOpen
.8d31	20 c5 a6	jsr $a6c5			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8d34	7a		ply				ply 								; restore the position *after* the test
.8d35	60		rts				rts
.8d36					_WHExitLoop:
.8d36	68		pla				pla 								; throw post loop position
.8d37	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8d39	aa		tax				tax
.8d3a	20 a7 8c	jsr $8ca7			jsr 	ScanForward
.8d3d	60		rts				rts
.8d3e					Command_WEND:
.8d3e	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8d40	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8d42	20 ad a6	jsr $a6ad			jsr 	StackCheckFrame
.8d45	20 d6 a6	jsr $a6d6			jsr 	STKLoadCodePosition 		; loop back
.8d48	20 9f a6	jsr $a69f			jsr 	StackClose		 			; erase the frame
.8d4b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8d4c					CheckRightBracket:
.8d4c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d4e	c8		iny				iny
.8d4f	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8d51	d0 0f		bne $8d62			bne 	CNAFail
.8d53	60		rts				rts
.8d54					CheckComma:
.8d54	b1 30		lda ($30),y			lda 	(codePtr),y
.8d56	c8		iny				iny
.8d57	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8d59	d0 07		bne $8d62			bne 	CNAFail
.8d5b	60		rts				rts
.8d5c					CheckNextA:
.8d5c	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8d5e	d0 02		bne $8d62			bne 	CNAFail
.8d60	c8		iny				iny 								; skip character
.8d61	60		rts				rts 								; and exit
.8d62					CNAFail:
.8d62	4c b2 9f	jmp $9fb2			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8d65					ErrorHandler:
.8d65	a8		tay				tay 								; find the error text
.8d66	f0 49		beq $8db1			beq 	_EHEnd
.8d68	a2 00		ldx #$00			ldx 	#0
.8d6a	a9 cb		lda #$cb			lda 	#((ErrorText) & $FF)
.8d6c	85 36		sta $36				sta 	0+zTemp0
.8d6e	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8d70	85 37		sta $37				sta 	1+zTemp0
.8d72					_EHFind:
.8d72	88		dey				dey 								; found the error text ?
.8d73	f0 0e		beq $8d83			beq 	_EHFound
.8d75					_EHFindZero:
.8d75	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8d77	e6 36		inc $36				inc 	zTemp0
.8d79	d0 02		bne $8d7d			bne 	_EHFNoCarry
.8d7b	e6 37		inc $37				inc 	zTemp0+1
.8d7d					_EHFNoCarry:
.8d7d	c9 00		cmp #$00			cmp 	#0
.8d7f	d0 f4		bne $8d75			bne 	_EHFindZero
.8d81	80 ef		bra $8d72			bra 	_EHFind
.8d83					_EHFound:
.8d83	a5 36		lda $36				lda 	zTemp0 						; print message
.8d85	a6 37		ldx $37				ldx 	zTemp0+1
.8d87	20 be 8d	jsr $8dbe			jsr 	PrintStringXA
.8d8a	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8d8c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d8e	d0 05		bne $8d95			bne 	_EHAtMsg
.8d90	c8		iny				iny
.8d91	b1 30		lda ($30),y			lda 	(codePtr),y
.8d93	f0 17		beq $8dac			beq 	_EHCREnd
.8d95					_EHAtMsg:
.8d95	a2 8d		ldx #$8d			ldx 	#_AtMsg >> 8 				; print " at "
.8d97	a9 b4		lda #$b4			lda 	#_AtMsg & $FF
.8d99	20 be 8d	jsr $8dbe			jsr 	PrintStringXA
.8d9c	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8d9e	b1 30		lda ($30),y			lda 	(codePtr),y
.8da0	48		pha				pha
.8da1	c8		iny				iny
.8da2	b1 30		lda ($30),y			lda 	(codePtr),y
.8da4	aa		tax				tax
.8da5	68		pla				pla
.8da6	20 77 92	jsr $9277			jsr 	LCLConvertInt16 				; convert XA to string
.8da9	20 be 8d	jsr $8dbe			jsr 	PrintStringXA 				; and print it.
.8dac					_EHCREnd:
.8dac	a9 0d		lda #$0d			lda 	#13 						; new line
.8dae	20 c1 a7	jsr $a7c1			jsr 	EXTPrintCharacter
.8db1					_EHEnd:
.8db1	4c 53 83	jmp $8353			jmp 	WarmStart
>8db4	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8dbc	20 00
.8dbe					PrintStringXA:
.8dbe	5a		phy				phy
.8dbf	86 37		stx $37				stx 	zTemp0+1
.8dc1	85 36		sta $36				sta 	zTemp0
.8dc3	a0 00		ldy #$00			ldy 	#0
.8dc5					_PSXALoop:
.8dc5	b1 36		lda ($36),y			lda 	(zTemp0),y
.8dc7	f0 06		beq $8dcf			beq 	_PSXAExit
.8dc9	20 c1 a7	jsr $a7c1			jsr 	EXTPrintCharacter
.8dcc	c8		iny				iny
.8dcd	80 f6		bra $8dc5			bra 	_PSXALoop
.8dcf					_PSXAExit:
.8dcf	7a		ply				ply
.8dd0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8dd1					UnaryTrue:
.8dd1	fa		plx				plx
.8dd2					ReturnTrue:
.8dd2	a9 01		lda #$01			lda 	#1  						; set to 1
.8dd4	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.8dd7	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8dd9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8ddc	60		rts				rts
.8ddd					UnaryFalse:
.8ddd	fa		plx				plx
.8dde					ReturnFalse:
.8dde	4c 28 9e	jmp $9e28			jmp 	NSMSetZero 					; set it all to zero
.8de1					BinaryCompareEqual:
.8de1	fa		plx				plx
.8de2	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8de5	c9 00		cmp #$00			cmp 	#0
.8de7	f0 e9		beq $8dd2			beq 	ReturnTrue
.8de9	80 f3		bra $8dde			bra 	ReturnFalse
.8deb					BinaryCompareLess:
.8deb	fa		plx				plx
.8dec	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8def	c9 ff		cmp #$ff			cmp 	#$FF
.8df1	f0 df		beq $8dd2			beq 	ReturnTrue
.8df3	80 e9		bra $8dde			bra 	ReturnFalse
.8df5					BinaryCompareGreater:
.8df5	fa		plx				plx
.8df6	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8df9	c9 01		cmp #$01			cmp 	#1
.8dfb	f0 d5		beq $8dd2			beq 	ReturnTrue
.8dfd	80 df		bra $8dde			bra 	ReturnFalse
.8dff					BinaryCompareNotEqual:
.8dff	fa		plx				plx
.8e00	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8e03	c9 00		cmp #$00			cmp 	#0
.8e05	d0 cb		bne $8dd2			bne 	ReturnTrue
.8e07	80 d5		bra $8dde			bra 	ReturnFalse
.8e09					BinaryCompareLessEqual:
.8e09	fa		plx				plx
.8e0a	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8e0d	c9 01		cmp #$01			cmp 	#1
.8e0f	d0 c1		bne $8dd2			bne 	ReturnTrue
.8e11	80 cb		bra $8dde			bra 	ReturnFalse
.8e13					BinaryCompareGreaterEqual:
.8e13	fa		plx				plx
.8e14	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8e17	c9 ff		cmp #$ff			cmp 	#$FF
.8e19	d0 b7		bne $8dd2			bne 	ReturnTrue
.8e1b	80 c1		bra $8dde			bra 	ReturnFalse
.8e1d					CompareBaseCode:
.8e1d	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; make both values if references.
.8e20	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8e23	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e26	29 10		and #$10			and 	#NSTString
.8e28	d0 40		bne $8e6a			bne 	_CBCString
.8e2a	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8e2d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8e30	d0 3b		bne $8e6d			bne 	_CBCFloat
.8e32	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8e35	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e38	29 08		and #$08			and 	#NSTFloat
.8e3a	d0 31		bne $8e6d			bne 	_CBCFloat
.8e3c	20 70 8e	jsr $8e70			jsr 	CompareFixMinusZero
.8e3f	e8		inx				inx
.8e40	20 70 8e	jsr $8e70			jsr 	CompareFixMinusZero
.8e43	ca		dex				dex
.8e44	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8e47	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8e4a	10 0b		bpl $8e57			bpl 	_CDCSameSign
.8e4c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8e4f	30 16		bmi $8e67			bmi 	_CBCLess 					; return $FF
.8e51					_CBCGreater:
.8e51	a9 01		lda #$01			lda 	#1
.8e53	60		rts				rts
.8e54					_CBCEqual:
.8e54	a9 00		lda #$00			lda 	#0
.8e56	60		rts				rts
.8e57					_CDCSameSign:
.8e57	20 c3 90	jsr $90c3			jsr 	SubTopTwoStack 				; unsigned subtract
.8e5a	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; or the mantissa together
.8e5d	f0 f5		beq $8e54			beq 	_CBCEqual 					; -0 == 0
.8e5f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8e62	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8e65	10 ea		bpl $8e51			bpl 	_CBCGreater
.8e67					_CBCLess:
.8e67	a9 ff		lda #$ff			lda 	#$FF
.8e69	60		rts				rts
.8e6a					_CBCString:
.8e6a	4c 19 90	jmp $9019			jmp 	CompareStrings
.8e6d					_CBCFloat:
.8e6d	4c fa 93	jmp $93fa			jmp 	CompareFloat
.8e70					CompareFixMinusZero:
.8e70	20 58 9e	jsr $9e58			jsr 	NSMIsZero
.8e73	d0 03		bne $8e78			bne 	_CFXMZNotZero
.8e75	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8e78					_CFXMZNotZero:
.8e78	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8e79					StringConcat:
.8e79	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8e7c	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8e7f	29 18		and #$18			and 	#NSBTypeMask
.8e81	c9 10		cmp #$10			cmp 	#NSTString
.8e83	d0 4e		bne $8ed3			bne		_SCType
.8e85	64 38		stz $38				stz 	zTemp1 						; counting total length
.8e87	e8		inx				inx
.8e88	20 a6 8e	jsr $8ea6			jsr 	_SCSetupZ0 					; setup for second
.8e8b	20 b1 8e	jsr $8eb1			jsr 	_SCLengthZ0 				; length for second
.8e8e	ca		dex				dex
.8e8f	20 a6 8e	jsr $8ea6			jsr 	_SCSetupZ0 					; setup for first
.8e92	20 b1 8e	jsr $8eb1			jsr 	_SCLengthZ0 				; length for first
.8e95	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8e97	20 74 a7	jsr $a774			jsr 	StringTempAllocate
.8e9a	20 c4 8e	jsr $8ec4			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8e9d	e8		inx				inx
.8e9e	20 a6 8e	jsr $8ea6			jsr 	_SCSetupZ0 					; copy second out
.8ea1	20 c4 8e	jsr $8ec4			jsr 	_SCCopy
.8ea4	ca		dex				dex
.8ea5	60		rts				rts
.8ea6					_SCSetupZ0:
.8ea6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8ea9	85 36		sta $36				sta 	zTemp0
.8eab	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8eae	85 37		sta $37				sta 	zTemp0+1
.8eb0	60		rts				rts
.8eb1					_SCLengthZ0:
.8eb1	5a		phy				phy
.8eb2	a0 00		ldy #$00			ldy 	#0
.8eb4					_SCLenLoop:
.8eb4	b1 36		lda ($36),y			lda 	(zTemp0),y
.8eb6	f0 0a		beq $8ec2			beq 	_SCLExit
.8eb8	c8		iny				iny
.8eb9	e6 38		inc $38				inc 	zTemp1
.8ebb	10 f7		bpl $8eb4			bpl		_SCLenLoop
.8ebd	a9 09		lda #$09		lda	#9
.8ebf	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8ec2					_SCLExit:
.8ec2	7a		ply				ply
.8ec3	60		rts				rts
.8ec4					_SCCopy:
.8ec4	5a		phy				phy
.8ec5	a0 00		ldy #$00			ldy 	#0
.8ec7					_SCCopyLoop:
.8ec7	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ec9	f0 06		beq $8ed1			beq 	_SCCExit
.8ecb	20 b2 a7	jsr $a7b2			jsr 	StringTempWrite
.8ece	c8		iny				iny
.8ecf	80 f6		bra $8ec7			bra 	_SCCopyLoop
.8ed1					_SCCExit:
.8ed1	7a		ply				ply
.8ed2	60		rts				rts
.8ed3					_SCType:
.8ed3	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8ed6					IntegerDivide:
.8ed6	fa		plx				plx
.8ed7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8eda	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8edd	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8ede	0a		asl a				asl 	a
.8edf	10 05		bpl $8ee6			bpl 	_NotRef
.8ee1	48		pha				pha
.8ee2	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8ee5	68		pla				pla
.8ee6					_NotRef:
.8ee6	0a		asl a				asl 	a
.8ee7	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8ee9	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8eec	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8eef	f0 03		beq $8ef4			beq 	_IntegerCode 				; if clear, then we have two integers
.8ef1	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.8ef4					_IntegerCode:
.8ef4	20 16 8f	jsr $8f16			jsr 	CheckDivideZero 			; do div zero check
.8ef7	20 4e 8f	jsr $8f4e			jsr 	Int32Divide 				; do the division
.8efa	20 0b 90	jsr $900b			jsr 	CalculateSign 				; calculate result sign
.8efd					NSMCopyPlusTwoToZero:
.8efd	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f00	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8f03	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8f06	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8f09	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8f0c	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8f0f	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8f12	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8f15	60		rts				rts
.8f16					CheckDivideZero:
.8f16	e8		inx				inx
.8f17	20 58 9e	jsr $9e58			jsr 	NSMIsZero
.8f1a	f0 02		beq $8f1e			beq 	_CDVError
.8f1c	ca		dex				dex
.8f1d	60		rts				rts
.8f1e					_CDVError:
.8f1e	a9 03		lda #$03		lda	#3
.8f20	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8f23					IntegerModulus:
.8f23	fa		plx				plx
.8f24	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f27	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f2a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f2b	0a		asl a				asl 	a
.8f2c	10 05		bpl $8f33			bpl 	_NotRef
.8f2e	48		pha				pha
.8f2f	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f32	68		pla				pla
.8f33					_NotRef:
.8f33	0a		asl a				asl 	a
.8f34	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f36	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f39	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f3c	f0 03		beq $8f41			beq 	_IntegerCode 				; if clear, then we have two integers
.8f3e	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.8f41					_IntegerCode:
.8f41					IntegerModulusNoCheck:
.8f41	20 16 8f	jsr $8f16			jsr 	CheckDivideZero 			; do div zero check
.8f44	20 4e 8f	jsr $8f4e			jsr 	Int32Divide 				; do the division
.8f47	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8f4a	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8f4d	60		rts				rts
.8f4e					Int32Divide:
.8f4e	48		pha				pha 								; save AXY
.8f4f	5a		phy				phy
.8f50	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8f53	20 24 9e	jsr $9e24			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8f56	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8f58					_I32DivideLoop:
.8f58	e8		inx				inx
.8f59	e8		inx				inx
.8f5a	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8f5d	ca		dex				dex
.8f5e	ca		dex				dex
.8f5f	20 3e 9e	jsr $9e3e			jsr 	NSMRotateLeft
.8f62	20 8e 8f	jsr $8f8e			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f65	90 03		bcc $8f6a			bcc 	_I32DivideNoCarryIn
.8f67	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8f6a					_I32DivideNoCarryIn:
.8f6a	88		dey				dey 								; loop round till division completed.
.8f6b	d0 eb		bne $8f58			bne 	_I32DivideLoop
.8f6d	7a		ply				ply 								; restore AXY and exit
.8f6e	68		pla				pla
.8f6f	60		rts				rts
.8f70					Int32ShiftDivide:
.8f70	48		pha				pha 								; save AY
.8f71	5a		phy				phy
.8f72	e8		inx				inx 								; clear S[X+2]
.8f73	e8		inx				inx
.8f74	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.8f77	ca		dex				dex
.8f78	ca		dex				dex
.8f79	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.8f7b					_I32SDLoop:
.8f7b	20 8e 8f	jsr $8f8e			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f7e	e8		inx				inx
.8f7f	e8		inx				inx
.8f80	20 3e 9e	jsr $9e3e			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.8f83	ca		dex				dex
.8f84	ca		dex				dex
.8f85	20 3e 9e	jsr $9e3e			jsr 	NSMRotateLeft
.8f88	88		dey				dey 	 							; do 31 times
.8f89	d0 f0		bne $8f7b			bne 	_I32SDLoop
.8f8b	7a		ply				ply 								; restore AY and exit
.8f8c	68		pla				pla
.8f8d	60		rts				rts
.8f8e					DivideCheckSubtract:
.8f8e	20 c3 90	jsr $90c3			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.8f91	b0 04		bcs $8f97			bcs 	_DCSExit 					; if carry set, then could do, exit
.8f93	20 9d 90	jsr $909d			jsr 	AddTopTwoStack 				; add it back in
.8f96	18		clc				clc 								; and return False
.8f97					_DCSExit:
.8f97	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.8f98					MulInteger:
.8f98	fa		plx				plx
.8f99	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f9c	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f9f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fa0	0a		asl a				asl 	a
.8fa1	10 05		bpl $8fa8			bpl 	_NotRef
.8fa3	48		pha				pha
.8fa4	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fa7	68		pla				pla
.8fa8					_NotRef:
.8fa8	0a		asl a				asl 	a 							; put MSB of type into A:7
.8fa9	30 0b		bmi $8fb6			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.8fab	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fae	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fb1	f0 06		beq $8fb9			beq 	_IntegerCode 				; if clear, then we have two integers
.8fb3	4c d1 94	jmp $94d1			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.8fb6					_StringData:
.8fb6	4c c6 9f	jmp $9fc6			jmp 	NotDoneError							; at least one string - don't know both are strings.
.8fb9					_IntegerCode:
.8fb9	20 c6 8f	jsr $8fc6			jsr 	MultiplyShort
.8fbc	c9 00		cmp #$00			cmp 	#0
.8fbe	f0 05		beq $8fc5			beq 	_MIExit
.8fc0	a9 04		lda #$04		lda	#4
.8fc2	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8fc5					_MIExit:
.8fc5	60		rts				rts
.8fc6					MultiplyShort:
.8fc6	5a		phy				phy 								; save Y
.8fc7	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fca	20 24 9e	jsr $9e24			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.8fcd	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.8fcf					_I32MLoop:
.8fcf	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.8fd2	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.8fd5	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.8fd8	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.8fdb	f0 28		beq $9005			beq 	_I32MExit 					; exit if zero
.8fdd	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.8fe0	29 01		and #$01			and 	#1
.8fe2	f0 0e		beq $8ff2			beq 	_I32MNoAdd
.8fe4	20 9d 90	jsr $909d			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.8fe7	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.8fea	10 06		bpl $8ff2			bpl 	_I32MNoAdd
.8fec					_I32ShiftRight:
.8fec	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift S[X] right
.8fef	c8		iny				iny 								; increment shift count
.8ff0	80 0a		bra $8ffc			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.8ff2					_I32MNoAdd:
.8ff2	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.8ff5	70 f5		bvs $8fec			bvs 	_I32ShiftRight 				; instead.
.8ff7	e8		inx				inx
.8ff8	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.8ffb	ca		dex				dex
.8ffc					_I32MShiftUpper:
.8ffc	e8		inx				inx 								; shift S[X+2] right
.8ffd	e8		inx				inx
.8ffe	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight
.9001	ca		dex				dex
.9002	ca		dex				dex
.9003	80 ca		bra $8fcf			bra 	_I32MLoop 					; try again.
.9005					_I32MExit:
.9005	20 0b 90	jsr $900b			jsr 	CalculateSign
.9008	98		tya				tya 								; shift in A
.9009	7a		ply				ply 								; restore Y and exit
.900a	60		rts				rts
.900b					CalculateSign:
.900b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.900e	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.9011	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9014	0a		asl a				asl 	a 							; shift bit 7 into carry
.9015	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.9018	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9019					CompareStrings:
.9019	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.901c	3d 01 04	and $0401,x			and 	NSStatus+1,x
.901f	29 10		and #$10			and 	#NSBIsString
.9021	f0 2c		beq $904f			beq 	_CSTypeError
.9023	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9026	85 36		sta $36				sta 	zTemp0
.9028	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.902b	85 37		sta $37				sta 	zTemp0+1
.902d	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9030	85 38		sta $38				sta 	zTemp1
.9032	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9035	85 39		sta $39				sta 	zTemp1+1
.9037	5a		phy				phy 								; save Y so we can access strings
.9038	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.903a					_CSLoop:
.903a	c8		iny				iny
.903b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.903d	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.903f	d0 06		bne $9047			bne 	_CSDifferent
.9041	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9043	d0 f5		bne $903a			bne 	_CSLoop 					; still comparing
.9045					_CSExit:
.9045	7a		ply				ply 								; reached end, return zero in A from EOS
.9046	60		rts				rts
.9047					_CSDifferent:
.9047	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.9049	90 fa		bcc $9045			bcc		_CSExit
.904b	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.904d	80 f6		bra $9045			bra 	_CSExit
.904f					_CSTypeError:
.904f	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9052					ShiftLeft:
.9052	38		sec				sec
.9053	80 01		bra $9056			bra 	ShiftMain
.9055					ShiftRight:
.9055	18		clc				clc
.9056					ShiftMain:
.9056	fa		plx				plx 								; restore X
.9057	08		php				php 								; save direction
.9058	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.905b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.905e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.905f	0a		asl a				asl 	a
.9060	10 05		bpl $9067			bpl 	_NotRef
.9062	48		pha				pha
.9063	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9066	68		pla				pla
.9067					_NotRef:
.9067	0a		asl a				asl 	a
.9068	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.906a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.906d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9070	f0 03		beq $9075			beq 	_IntegerCode 				; if clear, then we have two integers
.9072	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.9075					_IntegerCode:
.9075	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.9078	29 e0		and #$e0			and 	#$E0
.907a	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.907d	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.9080	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9083	d0 13		bne $9098			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9085					_SMLoop:
.9085	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9088	30 11		bmi $909b			bmi 	_SMExit 					; exit if done.
.908a	28		plp				plp 								; restore direcition setting
.908b	08		php				php
.908c	90 05		bcc $9093			bcc 	_SMRight
.908e	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; shift left if CS
.9091	80 f2		bra $9085			bra 	_SMLoop
.9093					_SMRight:
.9093	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift right if CC
.9096	80 ed		bra $9085			bra 	_SMLoop
.9098					_SMExit0:
.9098	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; return zero.
.909b					_SMExit:
.909b	28		plp				plp 								; throw direction
.909c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.909d					AddTopTwoStack:
.909d	18		clc				clc
.909e	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90a1	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.90a4	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90a7	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90aa	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.90ad	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90b0	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90b3	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.90b6	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90b9	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90bc	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.90bf	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90c2	60		rts				rts
.90c3					SubTopTwoStack:
.90c3	38		sec				sec
.90c4	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90c7	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.90ca	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90cd	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90d0	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.90d3	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90d6	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90d9	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.90dc	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90df	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90e2	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.90e5	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90e8	60		rts				rts
.90e9					AddInteger:
.90e9	fa		plx				plx
.90ea	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90ed	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90f0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90f1	0a		asl a				asl 	a
.90f2	10 05		bpl $90f9			bpl 	_NotRef
.90f4	48		pha				pha
.90f5	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90f8	68		pla				pla
.90f9					_NotRef:
.90f9	0a		asl a				asl 	a 							; put MSB of type into A:7
.90fa	30 0b		bmi $9107			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.90fc	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90ff	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9102	f0 06		beq $910a			beq 	_IntegerCode 				; if clear, then we have two integers
.9104	4c 51 93	jmp $9351			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9107					_StringData:
.9107	4c 79 8e	jmp $8e79			jmp 	StringConcat							; at least one string - don't know both are strings.
.910a					_IntegerCode:
.910a					AddCode:
.910a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.910d	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9110	10 8b		bpl $909d			bpl 	AddTopTwoStack
.9112	20 c3 90	jsr $90c3			jsr 	SubTopTwoStack 				; do a physical subtraction
.9115	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9118	10 09		bpl $9123			bpl 	_AddExit
.911a	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.911d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9120	20 dd 9d	jsr $9ddd			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9123					_AddExit:
.9123	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; check for -0
.9126	d0 03		bne $912b			bne 	_AddNonZero
.9128	9e 00 04	stz $0400,x			stz 	NSStatus,x
.912b					_AddNonZero:
.912b	60		rts				rts
.912c					SubInteger:
.912c	fa		plx				plx
.912d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9130	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9133	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9134	0a		asl a				asl 	a
.9135	10 05		bpl $913c			bpl 	_NotRef
.9137	48		pha				pha
.9138	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.913b	68		pla				pla
.913c					_NotRef:
.913c	0a		asl a				asl 	a 							; put MSB of type into A:7
.913d	30 0b		bmi $914a			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.913f	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9142	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9145	f0 06		beq $914d			beq 	_IntegerCode 				; if clear, then we have two integers
.9147	4c 56 93	jmp $9356			jmp 	FloatingPointSub 							; otherwise at least one float.
.914a					_StringData:
.914a	4c c6 9f	jmp $9fc6			jmp 	NotDoneError							; at least one string - don't know both are strings.
.914d					_IntegerCode:
.914d	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.9150	49 80		eor #$80			eor 	#$80
.9152	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9155	80 b3		bra $910a			bra 	AddCode 					; and do the same code as add.
.9157					AndInteger:
.9157	fa		plx				plx
.9158	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.915b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.915e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.915f	0a		asl a				asl 	a
.9160	10 05		bpl $9167			bpl 	_NotRef
.9162	48		pha				pha
.9163	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9166	68		pla				pla
.9167					_NotRef:
.9167	0a		asl a				asl 	a
.9168	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.916a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.916d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9170	f0 03		beq $9175			beq 	_IntegerCode 				; if clear, then we have two integers
.9172	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.9175					_IntegerCode:
.9175	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9178	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.917b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.917e	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9181	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.9184	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9187	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.918a	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.918d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9190	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9193	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.9196	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9199	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.919c	60		rts				rts
.919d					OraInteger:
.919d	fa		plx				plx
.919e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91a1	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91a4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91a5	0a		asl a				asl 	a
.91a6	10 05		bpl $91ad			bpl 	_NotRef
.91a8	48		pha				pha
.91a9	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91ac	68		pla				pla
.91ad					_NotRef:
.91ad	0a		asl a				asl 	a
.91ae	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91b0	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91b3	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91b6	f0 03		beq $91bb			beq 	_IntegerCode 				; if clear, then we have two integers
.91b8	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.91bb					_IntegerCode:
.91bb	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.91be	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.91c1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.91c4	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.91c7	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.91ca	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.91cd	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.91d0	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.91d3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.91d6	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.91d9	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.91dc	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.91df	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.91e2	60		rts				rts
.91e3					EorInteger:
.91e3	fa		plx				plx
.91e4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91e7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91ea	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91eb	0a		asl a				asl 	a
.91ec	10 05		bpl $91f3			bpl 	_NotRef
.91ee	48		pha				pha
.91ef	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f2	68		pla				pla
.91f3					_NotRef:
.91f3	0a		asl a				asl 	a
.91f4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91f6	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91f9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91fc	f0 03		beq $9201			beq 	_IntegerCode 				; if clear, then we have two integers
.91fe	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.9201					_IntegerCode:
.9201	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9204	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.9207	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.920a	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.920d	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.9210	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9213	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9216	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.9219	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.921c	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.921f	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.9222	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9225	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9228	60		rts				rts
.9229					WordIndirect:
.9229	fa		plx				plx
.922a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.922d	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9230	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9231	0a		asl a				asl 	a
.9232	10 05		bpl $9239			bpl 	_NotRef
.9234	48		pha				pha
.9235	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9238	68		pla				pla
.9239					_NotRef:
.9239	0a		asl a				asl 	a
.923a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.923c	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.923f	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9242	f0 03		beq $9247			beq 	_IntegerCode 				; if clear, then we have two integers
.9244	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.9247					_IntegerCode:
.9247	20 0a 91	jsr $910a			jsr 	AddCode 					; add the two values
.924a	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.924c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.924f	60		rts				rts
.9250					ByteIndirect:
.9250	fa		plx				plx
.9251	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9254	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9257	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9258	0a		asl a				asl 	a
.9259	10 05		bpl $9260			bpl 	_NotRef
.925b	48		pha				pha
.925c	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.925f	68		pla				pla
.9260					_NotRef:
.9260	0a		asl a				asl 	a
.9261	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9263	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9266	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9269	f0 03		beq $926e			beq 	_IntegerCode 				; if clear, then we have two integers
.926b	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.926e					_IntegerCode:
.926e	20 0a 91	jsr $910a			jsr 	AddCode 					; add the two values
.9271	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9273	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9276	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9277					LCLConvertInt16:
.9277	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.927a	8e 10 04	stx $0410			stx 	NSMantissa1
.927d	9c 18 04	stz $0418			stz 	NSMantissa2
.9280	9c 20 04	stz $0420			stz 	NSMantissa3
.9283	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.9286	a2 00		ldx #$00			ldx 	#0 							; stack level
.9288	a9 0a		lda #$0a			lda 	#10 						; base
.928a	80 00		bra $928c			bra 	ConvertInt32
.928c					ConvertInt32:
.928c	5a		phy				phy
.928d	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.928f	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.9292	10 08		bpl $929c			bpl 	_CI32NotNeg
.9294	48		pha				pha
.9295	a9 2d		lda #$2d			lda 	#'-'
.9297	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.929a	c8		iny				iny
.929b	68		pla				pla
.929c					_CI32NotNeg:
.929c	20 aa 92	jsr $92aa			jsr 	_CI32DivideConvert 			; recursive conversion
.929f	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.92a1	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.92a4	7a		ply				ply
.92a5	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.92a7	a9 f9		lda #$f9			lda 	#NumberBuffer & $FF
.92a9	60		rts				rts
.92aa					_CI32DivideConvert:
.92aa	e8		inx				inx 								; write to next slot up
.92ab	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.92ae	ca		dex				dex
.92af	20 4e 8f	jsr $8f4e			jsr 	Int32Divide 				; divide
.92b2	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.92b5	48		pha				pha
.92b6	20 fd 8e	jsr $8efd			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.92b9	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; is it zero ?
.92bc	f0 06		beq $92c4			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.92be	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.92c1	20 aa 92	jsr $92aa			jsr 	_CI32DivideConvert 			; and recusrively call.
.92c4					_CI32NoRecurse:
.92c4	68		pla				pla 								; remainder
.92c5	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.92c7	90 02		bcc $92cb			bcc 	_CI32NotHex
.92c9	69 26		adc #$26			adc 	#6+32
.92cb					_CI32NotHex:
.92cb	69 30		adc #$30			adc 	#48
.92cd	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y 				; write out and exit
.92d0	c8		iny				iny
.92d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.92d2					PrecedenceLevel:
>92d2	04					.byte	 4	; $00 <<
>92d3	02					.byte	 2	; $01 <=
>92d4	02					.byte	 2	; $02 <>
>92d5	00					.byte	 0	; $03 !!3
>92d6	00					.byte	 0	; $04 ><
>92d7	02					.byte	 2	; $05 >=
>92d8	04					.byte	 4	; $06 >>
>92d9	00					.byte	 0	; $07 !!7
>92da	00					.byte	 0	; $08 !!8
>92db	00					.byte	 0	; $09 !!9
>92dc	00					.byte	 0	; $0a !!10
>92dd	00					.byte	 0	; $0b !!11
>92de	00					.byte	 0	; $0c !!12
>92df	00					.byte	 0	; $0d !!13
>92e0	00					.byte	 0	; $0e !!14
>92e1	00					.byte	 0	; $0f !!15
>92e2	00					.byte	 0	; $10 @
>92e3	00					.byte	 0	; $11 !!17
>92e4	00					.byte	 0	; $12 !!18
>92e5	00					.byte	 0	; $13 [
>92e6	04					.byte	 4	; $14 \
>92e7	00					.byte	 0	; $15 ]
>92e8	01					.byte	 1	; $16 ^
>92e9	00					.byte	 0	; $17 _
>92ea	00					.byte	 0	; $18 `
>92eb	00					.byte	 0	; $19 !!25
>92ec	00					.byte	 0	; $1a !!26
>92ed	00					.byte	 0	; $1b {
>92ee	01					.byte	 1	; $1c |
>92ef	00					.byte	 0	; $1d }
>92f0	00					.byte	 0	; $1e ~
>92f1	00					.byte	 0	; $1f [7m<7F>[m
>92f2	00					.byte	 0	; $20
>92f3	05					.byte	 5	; $21 !
>92f4	00					.byte	 0	; $22 "
>92f5	00					.byte	 0	; $23 #
>92f6	05					.byte	 5	; $24 $
>92f7	04					.byte	 4	; $25 %
>92f8	01					.byte	 1	; $26 &
>92f9	00					.byte	 0	; $27 '
>92fa	00					.byte	 0	; $28 (
>92fb	00					.byte	 0	; $29 )
>92fc	04					.byte	 4	; $2a *
>92fd	03					.byte	 3	; $2b +
>92fe	00					.byte	 0	; $2c ,
>92ff	03					.byte	 3	; $2d -
>9300	00					.byte	 0	; $2e .
>9301	04					.byte	 4	; $2f /
>9302	00					.byte	 0	; $30 0
>9303	00					.byte	 0	; $31 1
>9304	00					.byte	 0	; $32 2
>9305	00					.byte	 0	; $33 3
>9306	00					.byte	 0	; $34 4
>9307	00					.byte	 0	; $35 5
>9308	00					.byte	 0	; $36 6
>9309	00					.byte	 0	; $37 7
>930a	00					.byte	 0	; $38 8
>930b	00					.byte	 0	; $39 9
>930c	00					.byte	 0	; $3a :
>930d	00					.byte	 0	; $3b ;
>930e	02					.byte	 2	; $3c <
>930f	02					.byte	 2	; $3d =
>9310	02					.byte	 2	; $3e >
>9311	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9312					EvaluateExpressionAt0:
.9312	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9314					EvaluateExpression:
.9314	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9316					EvaluateExpressionAtPrecedence:
.9316	48		pha				pha 								; save precedence level
.9317	20 ee 97	jsr $97ee			jsr 	EvaluateTerm 				; evaluate term into level X.
.931a	68		pla				pla 								; restore precedence level.
.931b					_EXPRLoop:
.931b	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.931d	b1 30		lda ($30),y			lda 	(codePtr),y
.931f	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9321	b0 25		bcs $9348			bcs 	_EXPRExit
.9323	da		phx				phx 								; read the operator precedence
.9324	aa		tax				tax
.9325	bd d2 92	lda $92d2,x			lda 	PrecedenceLevel,x
.9328	fa		plx				plx
.9329	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.932b	f0 1b		beq $9348			beq 	_EXPRExit
.932d	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.932f	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9331	c5 37		cmp $37				cmp 	zTemp0+1
.9333	b0 13		bcs $9348			bcs		_EXPRExit 					; if current >= operator exit
.9335	48		pha				pha 								; save current precedence.
.9336	b1 30		lda ($30),y			lda 	(codePtr),y
.9338	c8		iny				iny
.9339	48		pha				pha
.933a	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.933c	e8		inx				inx 								; work out the right hand side.
.933d	20 16 93	jsr $9316			jsr 	EvaluateExpressionAtPrecedence
.9340	ca		dex				dex
.9341	68		pla				pla 								; get operator, call the code.
.9342	20 4b 93	jsr $934b			jsr 	_EXPRCaller
.9345	68		pla				pla 								; restore precedence level
.9346	80 d3		bra $931b			bra 	_EXPRLoop 					; and go round.
.9348					_EXPRExit:
.9348	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.934a	60		rts				rts
.934b					_EXPRCaller:
.934b	da		phx				phx 								; save on stack, first thing is to restore it
.934c	0a		asl a				asl 	a 							; double so can use vectors into X
.934d	aa		tax				tax
.934e	7c 92 8a	jmp ($8a92,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9351					FloatingPointAdd:
.9351	20 fa 94	jsr $94fa			jsr 	FloatPrepare 				; prepare for floats
.9354	80 0b		bra $9361			bra 	FloatAdd
.9356					FloatingPointSub:
.9356	20 fa 94	jsr $94fa			jsr 	FloatPrepare 				; prepare for floats
.9359					FloatSubtract:
.9359	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.935c	49 80		eor #$80			eor 	#$80
.935e	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.9361					FloatAdd:
.9361	48		pha				pha
.9362	5a		phy				phy
.9363	20 0b 95	jsr $950b			jsr 	NSNormalise 				; normalise S[X]
.9366	f0 5c		beq $93c4			beq 	_FAReturn1
.9368	e8		inx				inx 								; normalise S[X+1]
.9369	20 0b 95	jsr $950b			jsr 	NSNormalise
.936c	ca		dex				dex
.936d	c9 00		cmp #$00			cmp 	#0
.936f	f0 77		beq $93e8			beq 	_FAExit 					; if so, just return A
.9371	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.9374	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.9377	f0 1b		beq $9394			beq 	_FAExponentsEqual
.9379	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.937c	a8		tay				tay
.937d	38		sec				sec 								; do a signed comparison of the exponents.
.937e	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9381	50 02		bvc $9385			bvc 	_FANoSignedChange
.9383	49 80		eor #$80			eor 	#$80
.9385					_FANoSignedChange:
.9385	29 80		and #$80			and 	#$80
.9387	10 03		bpl $938c			bpl 	_FAHaveMax
.9389	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.938c					_FAHaveMax:
.938c	20 eb 93	jsr $93eb			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.938f	e8		inx				inx
.9390	20 eb 93	jsr $93eb			jsr 	_FAShiftToExponent
.9393	ca		dex				dex
.9394					_FAExponentsEqual:
.9394	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.9397	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.939a	30 10		bmi $93ac			bmi 	_FADifferentSigns
.939c	20 9d 90	jsr $909d			jsr 	AddTopTwoStack 				; do the add of the mantissae
.939f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.93a2	10 44		bpl $93e8			bpl 	_FAExit 					; if no, we are done.
.93a4	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.93a7	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.93aa	80 3c		bra $93e8			bra 	_FAExit
.93ac					_FADifferentSigns:
.93ac	20 c3 90	jsr $90c3			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.93af	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.93b2	10 06		bpl $93ba			bpl 	_FACheckZero 				; if no, check for -0
.93b4	20 d4 9d	jsr $9dd4			jsr 	NSMNegate 					; netate result
.93b7	20 dd 9d	jsr $9ddd			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.93ba					_FACheckZero:
.93ba	20 58 9e	jsr $9e58			jsr 	NSMIsZero	 				; check for -0
.93bd	d0 29		bne $93e8			bne 	_FAExit
.93bf	9e 00 04	stz $0400,x			stz 	NSStatus,x
.93c2	80 24		bra $93e8			bra 	_FAExit
.93c4					_FAReturn1:
.93c4	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.93c7	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.93ca	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.93cd	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.93d0	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.93d3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.93d6	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.93d9	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.93dc	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.93df	9d 28 04	sta $0428,x			sta 	NSExponent,x
.93e2	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.93e5	9d 00 04	sta $0400,x			sta 	NSStatus,x
.93e8					_FAExit:
.93e8	7a		ply				ply
.93e9	68		pla				pla
.93ea	60		rts				rts
.93eb					_FAShiftToExponent:
.93eb					_FAShiftToExponent2:
.93eb	98		tya				tya 								; compare Y to exponent
.93ec	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.93ef	f0 08		beq $93f9			beq 	_FASEExit 					; exit if so.
.93f1	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight	 			; shift the mantissa right
.93f4	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.93f7	80 f2		bra $93eb			bra 	_FAShiftToExponent2
.93f9					_FASEExit:
.93f9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.93fa					CompareFloat:
.93fa	20 59 93	jsr $9359			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.93fd	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9400	29 f8		and #$f8			and 	#$F8
.9402	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9405	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.9408	f0 09		beq $9413			beq 	_FCExit 					; zero, so approximately identical
.940a	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.940c	3c 00 04	bit $0400,x			bit 	NSStatus,x
.940f	10 02		bpl $9413			bpl 	_FCExit
.9411					_FCNegative:
.9411	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9413					_FCExit:
.9413	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9414					FDivideCommand:
.9414	fa		plx				plx	 								; restore stack position
.9415	20 fa 94	jsr $94fa			jsr 	FloatPrepare 				; prepare for floats
.9418					FloatDivide:
.9418	48		pha				pha
.9419	e8		inx				inx
.941a	20 0b 95	jsr $950b			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.941d	ca		dex				dex
.941e	c9 00		cmp #$00			cmp 	#0
.9420	f0 20		beq $9442			beq 	_FDZero
.9422	20 0b 95	jsr $950b			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9425	f0 19		beq $9440			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9427	20 70 8f	jsr $8f70			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.942a	20 fd 8e	jsr $8efd			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.942d	20 0b 95	jsr $950b			jsr		NSNormalise 				; renormalise
.9430	20 0b 90	jsr $900b			jsr 	CalculateSign 				; calculate result sign
.9433	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.9436	38		sec				sec
.9437	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.943a	38		sec				sec
.943b	e9 1e		sbc #$1e			sbc 	#30
.943d	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9440					_FDExit:
.9440	68		pla				pla
.9441	60		rts				rts
.9442					_FDZero:
.9442	a9 03		lda #$03		lda	#3
.9444	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9447					FloatFractionalPart:
.9447	5a		phy				phy
.9448	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.944b	29 7f		and #$7f			and 	#$7F
.944d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9450	20 0b 95	jsr $950b			jsr 	NSNormalise
.9453	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9456	38		sec				sec
.9457	e9 e0		sbc #$e0			sbc 	#$E0
.9459	90 31		bcc $948c			bcc 	_FFPExit 					; already fractional
.945b	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.945d	b0 2a		bcs $9489			bcs 	_FFPZero
.945f	a8		tay				tay 								; put count to do in Y
.9460	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.9463	20 8e 94	jsr $948e			jsr 	_FFPPartial
.9466	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9469	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.946c	20 8e 94	jsr $948e			jsr 	_FFPPartial
.946f	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9472	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9475	20 8e 94	jsr $948e			jsr 	_FFPPartial
.9478	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.947b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.947e	20 8e 94	jsr $948e			jsr 	_FFPPartial
.9481	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9484	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; zeroed check.
.9487	d0 03		bne $948c			bne 	_FFPExit
.9489					_FFPZero:
.9489	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.948c					_FFPExit:
.948c	7a		ply				ply
.948d	60		rts				rts
.948e					_FFPPartial:
.948e	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9490	f0 17		beq $94a9			beq 	_FFFPPExit
.9492	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9494	b0 0c		bcs $94a2			bcs 	_FFFPPWholeByte
.9496	5a		phy				phy
.9497					_FFFPPLeft:
.9497	0a		asl a				asl 	a
.9498	88		dey				dey
.9499	d0 fc		bne $9497			bne 	_FFFPPLeft
.949b	7a		ply				ply
.949c					_FFFPPRight:
.949c	4a		lsr a				lsr 	a
.949d	88		dey				dey
.949e	d0 fc		bne $949c			bne 	_FFFPPRight
.94a0	80 07		bra $94a9			bra 	_FFFPPExit
.94a2					_FFFPPWholeByte:
.94a2	98		tya				tya 								; subtract 8 from count
.94a3	38		sec				sec
.94a4	e9 08		sbc #$08			sbc 	#8
.94a6	a8		tay				tay
.94a7	a9 00		lda #$00			lda 	#0 							; and clear all
.94a9					_FFFPPExit:
.94a9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.94aa					FloatIntegerPart:
.94aa	48		pha				pha
.94ab	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.94ae	f0 1f		beq $94cf			beq 	_FIPExit 					; if so do nothing
.94b0	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; is it zero ?
.94b3	f0 17		beq $94cc			beq 	_FIPZero 					; if so return zero.
.94b5	20 0b 95	jsr $950b			jsr 	NSNormalise 				; normalise
.94b8	f0 12		beq $94cc			beq 	_FIPZero 					; normalised to zero, exit zero
.94ba					_FIPShift:
.94ba	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.94bd	10 08		bpl $94c7			bpl 	_FIPCheckZero
.94bf	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift mantissa right
.94c2	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.94c5	80 f3		bra $94ba			bra 	_FIPShift
.94c7					_FIPCheckZero:
.94c7	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; avoid -0 problem
.94ca	d0 03		bne $94cf			bne 	_FIPExit 					; set to zero if mantissa zero.
.94cc					_FIPZero:
.94cc	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.94cf					_FIPExit:
.94cf	68		pla				pla
.94d0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.94d1					FloatingPointMultiply:
.94d1	20 fa 94	jsr $94fa			jsr 	FloatPrepare 				; prepare for floats
.94d4					FloatMultiply:
.94d4	48		pha				pha
.94d5	20 0b 95	jsr $950b			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94d8	f0 1b		beq $94f5			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94da	e8		inx				inx
.94db	20 0b 95	jsr $950b			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94de	ca		dex				dex
.94df	c9 00		cmp #$00			cmp 	#0
.94e1	f0 0f		beq $94f2			beq 	_FDSetZero
.94e3	20 c6 8f	jsr $8fc6			jsr 	MultiplyShort 				; calculate the result.
.94e6	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.94e9	18		clc				clc
.94ea	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.94ed	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94f0	80 03		bra $94f5			bra 	_FDExit
.94f2					_FDSetZero:
.94f2	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; return 0
.94f5					_FDExit:
.94f5	20 0b 95	jsr $950b			jsr 	NSNormalise 				; normalise the result
.94f8	68		pla				pla
.94f9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.94fa					FloatPrepare:
.94fa	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; dereference the top two values
.94fd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.9500	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9503	29 10		and #$10			and 	#NSBIsString
.9505	d0 01		bne $9508			bne 	_FDType
.9507	60		rts				rts
.9508					_FDType:
.9508	4c bc 9f	jmp $9fbc			jmp 	TypeError
.950b					NSNormalise:
.950b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.950e	29 80		and #$80			and 	#$80
.9510	09 08		ora #$08			ora 	#NSTFloat
.9512	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9515	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; if zero exit
.9518	d0 09		bne $9523			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.951a	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.951d	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.9520	a9 00		lda #$00			lda 	#0 							; set Z flag
.9522	60		rts				rts
.9523					_NSNormaliseOptimise:
.9523	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.9526	d0 22		bne $954a			bne 	_NSNormaliseLoop
.9528	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.952b	30 1d		bmi $954a			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.952d	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9530	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9533	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9536	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9539	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.953c	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.953f	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9542	38		sec				sec
.9543	e9 08		sbc #$08			sbc 	#8
.9545	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9548	80 d9		bra $9523			bra 	_NSNormaliseOptimise
.954a					_NSNormaliseLoop:
.954a	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.954d	70 08		bvs $9557			bvs 	_NSNExit 					; exit if so with Z flag clear
.954f	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; shift mantissa left
.9552	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.9555	80 f3		bra $954a			bra 	_NSNormaliseLoop
.9557					_NSNExit:
.9557	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9559	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.955a					AssignNumber:
.955a	5a		phy				phy
.955b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.955e	85 36		sta $36				sta 	zTemp0
.9560	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9563	85 37		sta $37				sta 	zTemp0+1
.9565	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.9568	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.956a	9d 00 04	sta $0400,x			sta 	NSStatus,x
.956d	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.956f	c9 08		cmp #$08			cmp 	#NSTFloat
.9571	f0 2a		beq $959d			beq 	_ANFloat
.9573	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.9576	f0 05		beq $957d			beq		_ANNotFloat
.9578	e8		inx				inx
.9579	20 aa 94	jsr $94aa			jsr 	FloatIntegerPart 			; make it an integer
.957c	ca		dex				dex
.957d					_ANNotFloat:
.957d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.9580	29 03		and #$03			and 	#3
.9582	d0 05		bne $9589			bne 	_ANByteWord
.9584	20 a9 95	jsr $95a9			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9587	80 1e		bra $95a7			bra 	_ANExit
.9589					_ANByteWord:
.9589	48		pha				pha 								; save count
.958a	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.958d	92 36		sta ($36)			sta 	(zTemp0)
.958f	68		pla				pla
.9590	c9 01		cmp #$01			cmp	 	#1
.9592	f0 13		beq $95a7			beq 	_ANExit
.9594	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.9597	a0 01		ldy #$01			ldy 	#1
.9599	91 36		sta ($36),y			sta 	(zTemp0),y
.959b	80 0a		bra $95a7			bra 	_ANExit
.959d					_ANFloat:
.959d	20 a9 95	jsr $95a9			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.95a0	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.95a3	a0 04		ldy #$04			ldy 	#4
.95a5	91 36		sta ($36),y			sta 	(zTemp0),y
.95a7					_ANExit:
.95a7	7a		ply				ply
.95a8	60		rts				rts
.95a9					_ANCopy4PackSign:
.95a9	a0 03		ldy #$03			ldy 	#3
.95ab	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.95ae	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.95b0	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.95b3	91 36		sta ($36),y			sta 	(zTemp0),y
.95b5	88		dey				dey
.95b6	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.95b9	91 36		sta ($36),y			sta 	(zTemp0),y
.95bb	88		dey				dey
.95bc	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95bf	91 36		sta ($36),y			sta 	(zTemp0),y
.95c1	88		dey				dey
.95c2	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95c5	91 36		sta ($36),y			sta 	(zTemp0),y
.95c7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95c8					AssignString:
.95c8	5a		phy				phy
.95c9	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95cc	85 38		sta $38				sta 	zTemp1
.95ce	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95d1	85 39		sta $39				sta 	zTemp1+1
.95d3	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95d6	85 36		sta $36				sta 	zTemp0
.95d8	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95db	85 37		sta $37				sta 	zTemp0+1
.95dd	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.95df	b1 36		lda ($36),y			lda 	(zTemp0),y
.95e1	f0 23		beq $9606			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.95e3	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.95e4	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.95e6	e9 02		sbc #$02			sbc 	#2
.95e8	85 3c		sta $3c				sta 	zsTemp
.95ea	a0 01		ldy #$01			ldy 	#1
.95ec	b1 36		lda ($36),y			lda 	(zTemp0),y
.95ee	e9 00		sbc #$00			sbc 	#0
.95f0	85 3d		sta $3d				sta 	zsTemp+1
.95f2	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.95f4					_ASGetLength:
.95f4	c8		iny				iny
.95f5	b1 38		lda ($38),y			lda 	(zTemp1),y
.95f7	d0 fb		bne $95f4			bne 	_ASGetLength
.95f9	98		tya				tya 								; is this length <= current length
.95fa	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.95fc	90 20		bcc $961e			bcc 	_ASCopyString
.95fe	f0 1e		beq $961e			beq 	_ASCopyString
.9600	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9602	a0 01		ldy #$01			ldy 	#1
.9604	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9606					_ASNewStringRequired:
.9606	e8		inx				inx 								; concrete the new string.
.9607	20 f3 a6	jsr $a6f3			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.960a	ca		dex				dex
.960b	18		clc				clc
.960c	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.960f	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9611	92 36		sta ($36)			sta 	(zTemp0)
.9613	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9616	69 00		adc #$00			adc 	#0
.9618	a0 01		ldy #$01			ldy 	#1
.961a	91 36		sta ($36),y			sta 	(zTemp0),y
.961c	80 0d		bra $962b			bra 	_ASExit
.961e					_ASCopyString:
.961e	a0 00		ldy #$00			ldy 	#0
.9620					_ASCopyLoop:
.9620	b1 38		lda ($38),y			lda 	(zTemp1),y
.9622	c8		iny				iny
.9623	c8		iny				iny
.9624	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9626	88		dey				dey
.9627	c9 00		cmp #$00			cmp 	#0
.9629	d0 f5		bne $9620			bne 	_ASCopyLoop
.962b					_ASExit:
.962b	7a		ply				ply
.962c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.962d					DereferenceTopTwo:
.962d	e8		inx				inx
.962e	20 32 96	jsr $9632			jsr 	Dereference 				; deref x+1
.9631	ca		dex				dex  								; falls through to deref x
.9632					Dereference:
.9632	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.9635	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.9637	f0 57		beq $9690			beq 	_DRFExit 					; not a reference
.9639	5a		phy				phy
.963a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.963d	85 36		sta $36				sta 	zTemp0
.963f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9642	85 37		sta $37				sta 	zTemp0+1
.9644	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.9647	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.9649	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.964c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.964f	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9651	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9653	f0 0f		beq $9664			beq 	_DRFDereferenceTwo
.9655	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9657	f0 39		beq $9692			beq 	_DRFFull
.9659	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.965c	29 03		and #$03			and 	#3
.965e	f0 32		beq $9692			beq 	_DRFFull 					; the whole word
.9660	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9662	f0 07		beq $966b			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9664					_DRFDereferenceTwo:
.9664	a0 01		ldy #$01			ldy 	#1
.9666	b1 36		lda ($36),y			lda 	(zTemp0),y
.9668	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.966b					_DRFClear23:
.966b	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.966e	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9671	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.9674	29 18		and #$18			and 	#NSBTypeMask
.9676	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9679	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.967b	d0 12		bne $968f			bne 	_DRFNotString
.967d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.9680	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9683	d0 0a		bne $968f			bne 	_DRFNotString
.9685	a9 91		lda #$91			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9687	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.968a	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.968c	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.968f					_DRFNotString
.968f	7a		ply				ply 								; restore Y and exit
.9690					_DRFExit:
.9690	60		rts				rts
.9691					_DRFNullString:
>9691	00						.byte 	0
.9692					_DRFFull:
.9692	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9694	b1 36		lda ($36),y			lda 	(zTemp0),y
.9696	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9699	c8		iny				iny
.969a	b1 36		lda ($36),y			lda 	(zTemp0),y
.969c	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.969f	c8		iny				iny
.96a0	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a2	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96a5	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.96a8	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.96ab	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96ad	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.96b0	f0 06		beq $96b8			beq 	_DRFNoExponent
.96b2	c8		iny				iny 								; if not, read the exponent as well.
.96b3	b1 36		lda ($36),y			lda 	(zTemp0),y
.96b5	9d 28 04	sta $0428,x			sta 	NSExponent,x
.96b8					_DRFNoExponent:
.96b8	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96bb	10 0d		bpl $96ca			bpl 	_DRFExit2 					; if not, then exit.
.96bd	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96bf	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96c2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.96c5	09 80		ora #$80			ora 	#NSBIsNegative
.96c7	9d 00 04	sta $0400,x			sta 	NSStatus,x
.96ca					_DRFExit2:
.96ca	7a		ply				ply
.96cb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.96cc					EncodeNumberStart:
.96cc	38		sec				sec
.96cd	80 01		bra $96d0			bra 	EncodeNumberContinue+1
.96cf					EncodeNumberContinue:
.96cf	18		clc				clc
.96d0					EncodeNumber:
.96d0	08		php				php 								; save reset.
.96d1	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.96d3	f0 12		beq $96e7			beq 	_ENIsOkay
.96d5	c9 30		cmp #$30			cmp 	#"0"
.96d7	90 04		bcc $96dd			bcc 	_ENBadNumber
.96d9	c9 3a		cmp #$3a			cmp 	#"9"+1
.96db	90 0a		bcc $96e7			bcc 	_ENIsOkay
.96dd					_ENBadNumber:
.96dd	28		plp				plp 								; throw saved reset
.96de	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.96e1	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96e3	f0 7e		beq $9763			beq 	_ENConstructFinal
.96e5					_ENFail:
.96e5	18		clc				clc 								; not allowed
.96e6	60		rts				rts
.96e7					_ENIsOkay:
.96e7	28		plp				plp 								; are we restarting
.96e8	90 15		bcc $96ff			bcc 	_ENNoRestart
.96ea					_ENStartEncode:
.96ea	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.96ec	f0 0c		beq $96fa			beq 	_ENFirstDP
.96ee	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.96f0	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.96f3	a9 01		lda #$01			lda 	#ESTA_Low
.96f5					_ENExitChange:
.96f5	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.96f8	38		sec				sec
.96f9	60		rts				rts
.96fa					_ENFirstDP:
.96fa	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; clear integer part
.96fd	80 3f		bra $973e			bra 	_ESTASwitchFloat			; go straight to float and exi
.96ff					_ENNoRestart:
.96ff	48		pha				pha 								; save on stack.
.9700	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.9703	c9 01		cmp #$01			cmp 	#ESTA_Low
.9705	f0 09		beq $9710			beq  	_ESTALowState
.9707	c9 02		cmp #$02			cmp 	#ESTA_High
.9709	f0 29		beq $9734			beq 	_ESTAHighState
.970b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.970d	f0 3b		beq $974a			beq 	_ESTADecimalState
>970f	db						.byte 	$DB 						; causes a break in the emulator
.9710					_ESTALowState:
.9710	68		pla				pla 								; get value back
.9711	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9713	f0 29		beq $973e			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9715	29 0f		and #$0f			and 	#15 						; make digit
.9717	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.971a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.971d	0a		asl a				asl 	a
.971e	0a		asl a				asl 	a
.971f	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9722	0a		asl a				asl 	a
.9723	6d 86 04	adc $0486			adc 	DigitTemp
.9726	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9729	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.972b	90 05		bcc $9732			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.972d	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.972f	8d 85 04	sta $0485			sta 	EncodeState
.9732					_ESTANoSwitch:
.9732	38		sec				sec
.9733	60		rts				rts
.9734					_ESTAHighState:
.9734	68		pla				pla 								; get value back
.9735	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.9737	f0 05		beq $973e			beq 	_ESTASwitchFloat
.9739	20 9d 97	jsr $979d			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.973c	38		sec				sec
.973d	60		rts				rts
.973e					_ESTASwitchFloat:
.973e	9c 87 04	stz $0487			stz 	DecimalCount
.9741	e8		inx				inx 								; zero the decimal additive.
.9742	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.9745	ca		dex				dex
.9746	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9748	80 ab		bra $96f5			bra 	_ENExitChange
.974a					_ESTADecimalState:
.974a	68		pla				pla 								; digit.
.974b	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.974d	f0 96		beq $96e5			beq 	_ENFail
.974f	e8		inx				inx 								; put digit into fractional part of X+1
.9750	20 9d 97	jsr $979d			jsr 	ESTAShiftDigitIntoMantissa
.9753	ca		dex				dex
.9754	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.9757	ad 87 04	lda $0487			lda 	DecimalCount
.975a	c9 0b		cmp #$0b			cmp 	#11
.975c	f0 02		beq $9760			beq 	_ESTADSFail
.975e	38		sec				sec
.975f	60		rts				rts
.9760					_ESTADSFail:
.9760	4c b7 9f	jmp $9fb7			jmp 	RangeError
.9763					_ENConstructFinal:
.9763	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.9766	f0 33		beq $979b			beq 	_ENCFExit 					; no decimals
.9768	5a		phy				phy
.9769	0a		asl a				asl 	a 							; x 4 and CLC
.976a	0a		asl a				asl 	a
.976b	6d 87 04	adc $0487			adc 	DecimalCount
.976e	a8		tay				tay
.976f	b9 76 9f	lda $9f76,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9772	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9775	b9 77 9f	lda $9f77,y			lda 	DecimalScalarTable-5+1,y
.9778	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.977b	b9 78 9f	lda $9f78,y			lda 	DecimalScalarTable-5+2,y
.977e	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9781	b9 79 9f	lda $9f79,y			lda 	DecimalScalarTable-5+3,y
.9784	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9787	b9 7a 9f	lda $9f7a,y			lda 	DecimalScalarTable-5+4,y
.978a	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.978d	a9 08		lda #$08			lda 	#NSTFloat
.978f	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9792	7a		ply				ply
.9793	e8		inx				inx 								; multiply decimal const by decimal scalar
.9794	20 d4 94	jsr $94d4			jsr 	FloatMultiply
.9797	ca		dex				dex
.9798	20 61 93	jsr $9361			jsr 	FloatAdd 					; add to integer part.
.979b					_ENCFExit:
.979b	18		clc				clc 								; reject the digit.
.979c	60		rts				rts
.979d					ESTAShiftDigitIntoMantissa:
.979d	29 0f		and #$0f			and 	#15 						; save digit
.979f	48		pha				pha
.97a0	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.97a3	48		pha				pha
.97a4	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.97a7	48		pha				pha
.97a8	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.97ab	48		pha				pha
.97ac	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.97af	48		pha				pha
.97b0	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 2
.97b3	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 4
.97b6	18		clc				clc 								; pop mantissa and add
.97b7	68		pla				pla
.97b8	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97bb	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97be	68		pla				pla
.97bf	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.97c2	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.97c5	68		pla				pla
.97c6	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.97c9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.97cc	68		pla				pla
.97cd	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.97d0	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.97d3	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 10
.97d6	68		pla				pla 								; add digit
.97d7	18		clc				clc
.97d8	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97db	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97de	90 0d		bcc $97ed			bcc 	_ESTASDExit
.97e0	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.97e3	d0 08		bne $97ed			bne 	_ESTASDExit
.97e5	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.97e8	d0 03		bne $97ed			bne 	_ESTASDExit
.97ea	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.97ed					_ESTASDExit:
.97ed	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.97ee					EvaluateTerm:
.97ee	b1 30		lda ($30),y			lda 	(codePtr),y
.97f0	30 18		bmi $980a			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.97f2	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.97f4	b0 6f		bcs $9865			bcs 	_ETVariable
.97f6	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.97f8	90 6e		bcc $9868			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.97fa	c9 3a		cmp #$3a			cmp 	#'9'+1
.97fc	b0 6a		bcs $9868			bcs 	_ETPuncUnary
.97fe	20 cc 96	jsr $96cc			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9801					_ETNumber:
.9801	c8		iny				iny 								; keep encoding until we have the numbers
.9802	b1 30		lda ($30),y			lda 	(codePtr),y
.9804	20 cf 96	jsr $96cf			jsr 	EncodeNumberContinue
.9807	b0 f8		bcs $9801			bcs 	_ETNumber 					; go back if accepted.
.9809	60		rts				rts
.980a					_ETCheckUnary:
.980a	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.980c	f0 41		beq $984f			beq 	_ETString
.980e	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9810	f0 12		beq $9824			beq 	_ETHexConstant
.9812	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9814	90 0b		bcc $9821			bcc 	_ETSyntaxError
.9816	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.9818	b0 07		bcs $9821			bcs 	_ETSyntaxError
.981a	da		phx				phx 								; push X on the stack
.981b	0a		asl a				asl 	a 							; put vector x 2 into X
.981c	aa		tax				tax
.981d	c8		iny				iny 								; consume unary function token
.981e	7c 12 8b	jmp ($8b12,x)			jmp 	(VectorSet0,x) 				; and do it.
.9821					_ETSyntaxError:
.9821	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.9824					_ETHexConstant:
.9824	c8		iny				iny 								; skip #
.9825	c8		iny				iny 								; skip count
.9826	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; clear result
.9829					_ETHLoop:
.9829	b1 30		lda ($30),y			lda 	(codePtr),y
.982b	c8		iny				iny 								; and consume
.982c	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.982e	f0 1e		beq $984e			beq 	_ETHExit
.9830	48		pha				pha 								; save on stack.
.9831	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 2
.9834	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 4
.9837	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 8
.983a	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 16
.983d	68		pla				pla 								; ASCII
.983e	c9 41		cmp #$41			cmp 	#'A'
.9840	90 02		bcc $9844			bcc 	_ETHNotChar
.9842	e9 07		sbc #$07			sbc 	#7
.9844					_ETHNotChar:
.9844	29 0f		and #$0f			and 	#15 						; digit now
.9846	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.9849	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.984c	80 db		bra $9829			bra 	_ETHLoop 					; go round.
.984e					_ETHExit:
.984e	60		rts				rts
.984f					_ETString:
.984f	c8		iny				iny 								; look at length
.9850	b1 30		lda ($30),y			lda 	(codePtr),y
.9852	48		pha				pha
.9853	c8		iny				iny 								; first character
.9854	20 ac a5	jsr $a5ac			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9857	68		pla				pla 								; restore count and save
.9858	85 36		sta $36				sta 	zTemp0
.985a	98		tya				tya 								; add length to Y to skip it.
.985b	18		clc				clc
.985c	65 36		adc $36				adc 	zTemp0
.985e	a8		tay				tay
.985f	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9861	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9864	60		rts				rts
.9865					_ETVariable:
.9865	4c bf 98	jmp $98bf			jmp 	VariableHandler
.9868					_ETPuncUnary:
.9868	c8		iny				iny 								; consume the unary character
.9869	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.986b	f0 2d		beq $989a			beq 	_ETUnaryNegate
.986d	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.986f	f0 39		beq $98aa			beq 	_ETDereference
.9871	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9873	f0 43		beq $98b8			beq 	_ETParenthesis
.9875	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9877	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9879	f0 06		beq $9881			beq 	_ETIndirection
.987b	e6 36		inc $36				inc 	zTemp0
.987d	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.987f	d0 a0		bne $9821			bne 	_ETSyntaxError
.9881					_ETIndirection:
.9881	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9883	1a		inc a				inc 	a
.9884	48		pha				pha
.9885	20 ee 97	jsr $97ee			jsr 	EvaluateTerm				; evaluate the term
.9888	20 32 96	jsr $9632			jsr 	Dereference 				; dereference it.
.988b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.988e	d0 07		bne $9897			bne 	_ETTypeMismatch
.9890	68		pla				pla 								; indirection 1-2
.9891	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9893	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9896	60		rts				rts
.9897					_ETTypeMismatch:
.9897	4c bc 9f	jmp $9fbc			jmp 	TypeError
.989a					_ETUnaryNegate:
.989a	20 ee 97	jsr $97ee			jsr 	EvaluateTerm				; evaluate the term
.989d	20 32 96	jsr $9632			jsr 	Dereference 				; dereference it.
.98a0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.98a3	29 10		and #$10			and 	#NSTString
.98a5	d0 f0		bne $9897			bne 	_ETTypeMismatch
.98a7	4c d4 9d	jmp $9dd4			jmp 	NSMNegate  					; just toggles the sign bit.
.98aa					_ETDereference:
.98aa	20 ee 97	jsr $97ee			jsr 	EvaluateTerm				; evaluate the term
.98ad	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.98b0	29 20		and #$20			and 	#NSBIsReference
.98b2	f0 e3		beq $9897			beq 	_ETTypeMismatch
.98b4	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.98b7	60		rts				rts
.98b8					_ETParenthesis:
.98b8	20 14 93	jsr $9314			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.98bb	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; check for )
.98be	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.98bf					VariableHandler:
.98bf	b1 30		lda ($30),y			lda 	(codePtr),y
.98c1	18		clc				clc
.98c2	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98c4	85 37		sta $37				sta 	zTemp0+1
.98c6	c8		iny				iny
.98c7	b1 30		lda ($30),y			lda 	(codePtr),y
.98c9	85 36		sta $36				sta 	zTemp0
.98cb	c8		iny				iny
.98cc	18		clc				clc									; copy variable address+3 to mantissa
.98cd	69 03		adc #$03			adc 	#3
.98cf	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98d2	a5 37		lda $37				lda 	zTemp0+1
.98d4	69 00		adc #$00			adc 	#0
.98d6	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.98d9	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.98dc	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.98df	9e 28 04	stz $0428,x			stz 	NSExponent,x
.98e2	5a		phy				phy
.98e3	a0 02		ldy #$02			ldy 	#2 							; read type
.98e5	b1 36		lda ($36),y			lda 	(zTemp0),y
.98e7	7a		ply				ply
.98e8	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98ea	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98ec	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98ef	29 04		and #$04			and 	#NSBIsArray
.98f1	d0 01		bne $98f4			bne 	_VHArray
.98f3	60		rts				rts
.98f4					_VHArray:
.98f4	e8		inx				inx
.98f5	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get the 1st index.
.98f8	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.98fa	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.98fd	b1 30		lda ($30),y			lda 	(codePtr),y
.98ff	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9901	d0 06		bne $9909			bne 	_VHNoSecondIndex
.9903	c8		iny				iny 								; skip the comma
.9904	e8		inx				inx
.9905	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9908	ca		dex				dex
.9909					_VHNoSecondIndex:
.9909	ca		dex				dex 								; set X back.
.990a	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; and check the right bracket.
.990d	5a		phy				phy 								; save position
.990e	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9910	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9912	f0 6b		beq $997f			beq 	_VHBadIndex
.9914	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.9917	85 3e		sta $3e				sta 	zaTemp
.9919	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.991c	85 3f		sta $3f				sta 	zaTemp+1
.991e	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9920	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9922	f0 02		beq $9926			beq 	_VHHas2Mask
.9924	a9 ff		lda #$ff			lda 	#$FF
.9926					_VHHas2Mask:
.9926	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9929	f0 54		beq $997f			beq 	_VHBadIndex
.992b	0a		asl a				asl 	a 							; carry will be set if a second index
.992c	90 09		bcc $9937			bcc 	_VHCheckFirstIndex
.992e	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9930	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9932	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.9935	90 48		bcc $997f			bcc 	_VHBadIndex
.9937					_VHCheckFirstIndex:
.9937	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9939	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.993b	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.993e	90 3f		bcc $997f			bcc 	_VHBadIndex
.9940	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9942	64 37		stz $37				stz 	zTemp0+1
.9944	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9947	30 0f		bmi $9958			bmi 	_VHNoMultiply
.9949	da		phx				phx
.994a	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.994d	48		pha				pha
.994e	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9950	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9952	1a		inc a				inc 	a 							; add 1 for zero base
.9953	fa		plx				plx
.9954	20 bd 9d	jsr $9dbd			jsr 	Multiply8x8 				; calculate -> Z0
.9957	fa		plx				plx
.9958					_VHNoMultiply:
.9958	18		clc				clc
.9959	a5 36		lda $36				lda 	zTemp0
.995b	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.995e	85 36		sta $36				sta 	zTemp0
.9960	a5 37		lda $37				lda 	zTemp0+1
.9962	69 00		adc #$00			adc 	#0
.9964	85 37		sta $37				sta 	zTemp0+1
.9966	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9969	20 ef 84	jsr $84ef			jsr 	ScaleByBaseType
.996c	18		clc				clc
.996d	b2 3e		lda ($3e)			lda 	(zaTemp)
.996f	65 36		adc $36				adc 	zTemp0
.9971	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9974	a0 01		ldy #$01			ldy 	#1
.9976	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9978	65 37		adc $37				adc 	zTemp0+1
.997a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.997d	7a		ply				ply 								; restore position
.997e	60		rts				rts
.997f					_VHBadIndex:
.997f	a9 17		lda #$17		lda	#23
.9981	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9984					AbsUnary:
.9984	fa		plx				plx 								; restore stack pos
.9985	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; get a float or int
.9988	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.998b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.998e	29 7f		and #$7f			and 	#$7F
.9990	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9993	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9994					AllocUnary:
.9994	fa		plx				plx 								; restore stack pos
.9995	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger		; get bytes required.
.9998	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.999b	da		phx				phx 								; save X/Y
.999c	5a		phy				phy
.999d	8a		txa				txa 								; copy X into Y
.999e	a8		tay				tay
.999f	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.99a2	aa		tax				tax
.99a3	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.99a6	20 b3 99	jsr $99b3			jsr 	AllocateXABytes 			; allocate memory
.99a9	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.99ac	8a		txa				txa
.99ad	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.99b0	7a		ply				ply
.99b1	fa		plx				plx
.99b2	60		rts				rts
.99b3					AllocateXABytes:
.99b3	5a		phy				phy
.99b4	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99b7	84 36		sty $36				sty 	zTemp0
.99b9	5a		phy				phy
.99ba	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.99bd	84 37		sty $37				sty 	zTemp0+1
.99bf	5a		phy				phy
.99c0	18		clc				clc 								; add to low memory pointer
.99c1	6d 8c 04	adc $048c			adc 	lowMemPtr
.99c4	8d 8c 04	sta $048c			sta 	lowMemPtr
.99c7	8a		txa				txa
.99c8	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.99cb	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.99ce	b0 2f		bcs $99ff			bcs 	CISSMemory
.99d0	20 f1 99	jsr $99f1			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.99d3					_ClearMemory:
.99d3	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.99d6	c5 36		cmp $36				cmp 	zTemp0
.99d8	d0 07		bne $99e1			bne 	_CMClearNext
.99da	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.99dd	c5 37		cmp $37				cmp 	zTemp0+1
.99df	f0 0c		beq $99ed			beq 	_CMExit
.99e1					_CMClearNext:
.99e1	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99e3	92 36		sta ($36)			sta 	(zTemp0)
.99e5	e6 36		inc $36				inc 	zTemp0
.99e7	d0 ea		bne $99d3			bne 	_ClearMemory
.99e9	e6 37		inc $37				inc		zTemp0+1
.99eb	80 e6		bra $99d3			bra 	_ClearMemory
.99ed					_CMExit:
.99ed	fa		plx				plx
.99ee	68		pla				pla
.99ef	7a		ply				ply
.99f0	60		rts				rts
.99f1					CheckIdentifierStringSpace:
.99f1	48		pha				pha
.99f2	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.99f5	18		clc				clc
.99f6	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99f8	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.99fb	b0 02		bcs $99ff			bcs 	CISSMemory
.99fd	68		pla				pla
.99fe	60		rts				rts
.99ff					CISSMemory:
.99ff	a9 06		lda #$06		lda	#6
.9a01	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a04					AscUnary:
.9a04	fa		plx				plx 								; restore stack pos
.9a05	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get a string
.9a08	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9a0a	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9a0d	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9a10	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a11					FracUnary:
.9a11	fa		plx				plx 								; restore stack pos
.9a12	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; get a float or int
.9a15	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9a18	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a1b	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a1d	f0 04		beq $9a23			beq 	_IUZero
.9a1f	20 47 94	jsr $9447			jsr 	FloatFractionalPart
.9a22	60		rts				rts
.9a23					_IUZero:
.9a23	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.9a26	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a27					IntUnary:
.9a27	fa		plx				plx 								; restore stack pos
.9a28	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; get a float or int
.9a2b	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9a2e	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a31	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a33	f0 03		beq $9a38			beq 	_IUExit
.9a35	20 aa 94	jsr $94aa			jsr 	FloatIntegerPart
.9a38					_IUExit:
.9a38	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a39					LenUnary:
.9a39	fa		plx				plx 								; restore stack pos
.9a3a	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get a string
.9a3d	5a		phy				phy
.9a3e	a0 00		ldy #$00			ldy 	#0 							; find length
.9a40					_LenFind:
.9a40	b1 36		lda ($36),y			lda 	(zTemp0),y
.9a42	f0 06		beq $9a4a			beq 	_LenExit
.9a44	c8		iny				iny
.9a45	d0 f9		bne $9a40			bne 	_LenFind
.9a47	4c b7 9f	jmp $9fb7			jmp 	RangeError 					; string > 255
.9a4a					_LenExit:
.9a4a	98		tya				tya
.9a4b	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9a4e	7a		ply				ply
.9a4f	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9a52	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a53					Unary_Min:
.9a53	a9 01		lda #$01			lda 	#1
.9a55	80 02		bra $9a59			bra 	UnaryMinMaxMain
.9a57					Unary_Max:
.9a57	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a59					UnaryMinMaxMain:
.9a59	fa		plx				plx 								; get index on number stack
.9a5a	48		pha				pha 								; save comparator
.9a5b	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get the first value.
.9a5e					_UMMMLoop:
.9a5e	b1 30		lda ($30),y			lda 	(codePtr),y
.9a60	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a62	f0 22		beq $9a86			beq 	_UMMMDone
.9a64	20 54 8d	jsr $8d54			jsr 	CheckComma 					; must be a comma
.9a67	e8		inx				inx
.9a68	20 48 9d	jsr $9d48			jsr 	EvaluateValue
.9a6b	ca		dex				dex
.9a6c	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a6f	e8		inx				inx
.9a70	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a73	e8		inx				inx
.9a74	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a77	ca		dex				dex
.9a78	ca		dex				dex
.9a79	85 36		sta $36				sta 	zTemp0 						; save required result
.9a7b	68		pla				pla 								; get and save comparator
.9a7c	48		pha				pha
.9a7d	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a7f	d0 dd		bne $9a5e			bne 	_UMMMLoop
.9a81	20 89 9a	jsr $9a89			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a84	80 d8		bra $9a5e			bra 	_UMMMLoop
.9a86					_UMMMDone:
.9a86	68		pla				pla 								; throw the comparator
.9a87	c8		iny				iny 								; skip )
.9a88	60		rts				rts
.9a89					ExpCopyAboveDown:
.9a89	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9a8c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a8f	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9a92	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9a95	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9a98	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a9b	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9a9e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9aa1	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9aa4	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9aa7	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9aaa	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9aad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9aae					Unary_Not:
.9aae	fa		plx				plx
.9aaf	20 74 9d	jsr $9d74			jsr 	EvaluateInteger 			; get integer
.9ab2	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9ab5	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; zero mantissa ?
.9ab8	f0 04		beq $9abe			beq 	_NotZero
.9aba	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.9abd	60		rts				rts
.9abe					_NotZero:
.9abe	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.9ac1					_UNBad:
.9ac1	4c c1 9f	jmp $9fc1			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9ac4					Unary_Random:
.9ac4	fa		plx				plx
.9ac5	20 43 9b	jsr $9b43			jsr 	Random32Bit 				; get a random number
.9ac8	20 28 9b	jsr $9b28			jsr 	URCopyToMantissa  			; put in mantissa
.9acb	b1 30		lda ($30),y			lda 	(codePtr),y
.9acd	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9acf	f0 08		beq $9ad9			beq 	_URNoModulus
.9ad1	e8		inx				inx
.9ad2	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9ad5	ca		dex				dex
.9ad6	20 41 8f	jsr $8f41			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9ad9					_URNoModulus:
.9ad9	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9adc	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9adf	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9ae2	60		rts				rts
.9ae3					Unary_Rnd:
.9ae3	fa		plx				plx
.9ae4	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; number to use.
.9ae7	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; closing bracket
.9aea	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9aed	f0 2b		beq $9b1a			beq 	_URCopySeed
.9aef	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9af2	10 23		bpl $9b17			bpl 	_URDontSeed
.9af4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9af7	49 17		eor #$17			eor 	#$17
.9af9	8d 88 04	sta $0488			sta 	RandomSeed+0
.9afc	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9aff	49 a5		eor #$a5			eor 	#$A5
.9b01	8d 89 04	sta $0489			sta 	RandomSeed+1
.9b04	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9b07	49 c2		eor #$c2			eor 	#$C2
.9b09	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9b0c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9b0f	49 9d		eor #$9d			eor 	#$9D
.9b11	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9b14	20 43 9b	jsr $9b43			jsr 	Random32Bit
.9b17					_URDontSeed:
.9b17	20 43 9b	jsr $9b43			jsr 	Random32Bit 				; generate a number.
.9b1a					_URCopySeed:
.9b1a	20 28 9b	jsr $9b28			jsr 	URCopyToMantissa 			; copy into mantissa
.9b1d	a9 e1		lda #$e1			lda 	#-31 						; force into 0-1 range
.9b1f	8d 28 04	sta $0428			sta 	NSExponent
.9b22	a9 08		lda #$08			lda 	#NSTFloat
.9b24	8d 00 04	sta $0400			sta 	NSStatus 					; positive.
.9b27	60		rts				rts
.9b28					URCopyToMantissa:
.9b28	ad 88 04	lda $0488			lda 	RandomSeed+0
.9b2b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b2e	ad 89 04	lda $0489			lda 	RandomSeed+1
.9b31	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b34	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9b37	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b3a	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9b3d	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b3f	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b42	60		rts				rts
.9b43					Random32Bit:
.9b43	5a		phy				phy
.9b44	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b46	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9b49	d0 03		bne $9b4e			bne 	_Random1
.9b4b	a8		tay				tay 								; if so do it 256 times
.9b4c	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b4e					_Random1:
.9b4e	0a		asl a				asl 	a 							; LSFR RNG
.9b4f	2e 89 04	rol $0489			rol 	RandomSeed+1
.9b52	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9b55	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9b58	90 02		bcc $9b5c			bcc 	_Random2
.9b5a	49 c5		eor #$c5			eor 	#$C5
.9b5c					_Random2:
.9b5c	88		dey				dey
.9b5d	d0 ef		bne $9b4e			bne 	_Random1
.9b5f	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b62	7a		ply				ply
.9b63	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b64					SgnUnary:
.9b64	fa		plx				plx 								; restore stack pos
.9b65	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; get a float or int
.9b68	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9b6b	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; if zero
.9b6e	f0 10		beq $9b80			beq 	_SGZero  					; return Int Zero
.9b70	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9b73	48		pha				pha
.9b74	a9 01		lda #$01			lda 	#1 							; set to 1
.9b76	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9b79	68		pla				pla
.9b7a	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b7c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b7f	60		rts				rts
.9b80	20 28 9e	jsr $9e28	_SGZero:jsr 	NSMSetZero
.9b83	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b84					ValUnary:
.9b84	fa		plx				plx 								; restore stack pos
.9b85	20 9a 9b	jsr $9b9a			jsr 	ValMainCode 				; do the main val() code
.9b88	b0 01		bcs $9b8b			bcs 	_VUError 					; couldn't convert
.9b8a	60		rts				rts
.9b8b					_VUError:
.9b8b	4c bc 9f	jmp $9fbc			jmp 	TypeError
.9b8e					IsValUnary:
.9b8e	fa		plx				plx 								; restore stack pos
.9b8f	20 9a 9b	jsr $9b9a			jsr 	ValMainCode 				; do the main val() code
.9b92	b0 03		bcs $9b97			bcs 	_VUBad
.9b94	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.9b97					_VUBad:
.9b97	4c de 8d	jmp $8dde			jmp 	ReturnFalse
.9b9a					ValMainCode:
.9b9a	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get a string
.9b9d	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; check right bracket present
.9ba0	5a		phy				phy
.9ba1	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9ba3	f0 17		beq $9bbc			beq 	_VMCFail2
.9ba5	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9ba7	48		pha				pha 								; save first character
.9ba8	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9baa	d0 01		bne $9bad			bne 	_VMCStart
.9bac	c8		iny				iny 								; skip over -
.9bad					_VMCStart:
.9bad	38		sec				sec 								; initialise first time round.
.9bae					_VMCNext:
.9bae	c8		iny				iny 								; pre-increment
.9baf	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9bb1	f0 0c		beq $9bbf			beq 	_VMCSuccess 				; successful.
.9bb3	20 d0 96	jsr $96d0			jsr 	EncodeNumber 				; send it to the number-builder
.9bb6	90 03		bcc $9bbb			bcc 	_VMCFail 					; if failed, give up.
.9bb8	18		clc				clc 								; next time round, countinue
.9bb9	80 f3		bra $9bae			bra 	_VMCNext
.9bbb					_VMCFail:
.9bbb	68		pla				pla
.9bbc					_VMCFail2:
.9bbc	7a		ply				ply
.9bbd	38		sec				sec
.9bbe	60		rts				rts
.9bbf					_VMCSuccess:
.9bbf	a9 00		lda #$00			lda 	#0 							; construct final
.9bc1	20 d0 96	jsr $96d0			jsr 	EncodeNumber
.9bc4	68		pla				pla
.9bc5	c9 2d		cmp #$2d			cmp 	#"-"
.9bc7	d0 03		bne $9bcc			bne 	_VMCNotNegative
.9bc9	20 d4 9d	jsr $9dd4			jsr		NSMNegate
.9bcc					_VMCNotNegative:
.9bcc	7a		ply				ply
.9bcd	18		clc				clc
.9bce	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9bcf					ChrUnary:
.9bcf	fa		plx				plx 								; restore stack pos
.9bd0	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger			; get value
.9bd3	48		pha				pha
.9bd4	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9bd7	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9bd9	20 74 a7	jsr $a774			jsr 	StringTempAllocate
.9bdc	68		pla				pla 								; write number to it
.9bdd	20 b2 a7	jsr $a7b2			jsr 	StringTempWrite
.9be0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9be1					SpcUnary:
.9be1	fa		plx				plx 								; restore stack pos
.9be2	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger			; get value
.9be5	5a		phy				phy
.9be6	48		pha				pha 								; save count
.9be7	20 74 a7	jsr $a774			jsr 	StringTempAllocate
.9bea	7a		ply				ply 								; to do count in Y
.9beb					_SpcLoop:
.9beb	c0 00		cpy #$00			cpy 	#0
.9bed	f0 08		beq $9bf7			beq 	_SpcExit
.9bef	a9 20		lda #$20			lda 	#32
.9bf1	20 b2 a7	jsr $a7b2			jsr 	StringTempWrite
.9bf4	88		dey				dey
.9bf5	80 f4		bra $9beb			bra 	_SPCLoop
.9bf7					_SpcExit:
.9bf7	7a		ply				ply
.9bf8	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9bfb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9bfc					Unary_Str:
.9bfc	fa		plx				plx
.9bfd	20 51 9d	jsr $9d51			jsr 	EvaluateNumber  			; get number
.9c00	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; closing bracket
.9c03	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c05	20 1e 9c	jsr $9c1e			jsr 	ConvertNumberToString 		; do the conversion.
.9c08	a9 21		lda #$21			lda		#33 						; create buffer
.9c0a	20 74 a7	jsr $a774			jsr 	StringTempAllocate 			; allocate memory
.9c0d	da		phx				phx
.9c0e	a2 00		ldx #$00			ldx 	#0
.9c10					_USCopy:
.9c10	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c13	20 b2 a7	jsr $a7b2			jsr 	StringTempWrite
.9c16	e8		inx				inx
.9c17	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c1a	d0 f4		bne $9c10			bne 	_USCopy
.9c1c	fa		plx				plx
.9c1d	60		rts				rts
.9c1e					ConvertNumberToString:
.9c1e	5a		phy				phy 								; save code position
.9c1f	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9c22	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9c25	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9c28	10 0a		bpl $9c34			bpl 	_CNTSNotNegative
.9c2a	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c2c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c2f	a9 2d		lda #$2d			lda 	#"-"
.9c31	20 9a 9c	jsr $9c9a			jsr 	WriteDecimalBuffer
.9c34					_CNTSNotNegative:
.9c34	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9c37	f0 15		beq $9c4e			beq 	_CNTSNotFloat
.9c39	e8		inx				inx 								; round up
.9c3a	a9 01		lda #$01			lda 	#1
.9c3c	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9c3f	ca		dex				dex
.9c40	bd 28 04	lda $0428,x			lda		NSExponent,x
.9c43	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9c46	a9 08		lda #$08			lda 	#NSTFloat
.9c48	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9c4b	20 61 93	jsr $9361			jsr 	FloatAdd
.9c4e					_CNTSNotFloat:
.9c4e	20 7c 9c	jsr $9c7c			jsr 	MakePlusTwoString
.9c51	20 47 94	jsr $9447			jsr 	FloatFractionalPart 		; get the fractional part
.9c54	20 0b 95	jsr $950b			jsr 	NSNormalise					; normalise , exit if zero
.9c57	f0 21		beq $9c7a			beq 	_CNTSExit
.9c59	a9 2e		lda #$2e			lda 	#"."
.9c5b	20 9a 9c	jsr $9c9a			jsr 	WriteDecimalBuffer 			; write decimal place
.9c5e					_CNTSDecimal:
.9c5e	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9c61	30 17		bmi $9c7a			bmi 	_CNTSExit
.9c63	e8		inx				inx 								; x 10.0
.9c64	a9 0a		lda #$0a			lda 	#10
.9c66	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9c69	a9 08		lda #$08			lda 	#NSTFloat
.9c6b	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c6e	ca		dex				dex
.9c6f	20 d4 94	jsr $94d4			jsr 	FloatMultiply
.9c72	20 7c 9c	jsr $9c7c			jsr 	MakePlusTwoString
.9c75	20 47 94	jsr $9447			jsr 	FloatFractionalPart 		; get the fractional part
.9c78	80 e4		bra $9c5e			bra 	_CNTSDecimal 				; keep going.
.9c7a					_CNTSExit:
.9c7a	7a		ply				ply
.9c7b	60		rts				rts
.9c7c					MakePlusTwoString:
.9c7c	da		phx				phx
.9c7d	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c80	e8		inx				inx 								; access it
.9c81	e8		inx				inx
.9c82	20 aa 94	jsr $94aa			jsr 	FloatIntegerPart 			; make it an integer
.9c85	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c87	20 8c 92	jsr $928c			jsr 	ConvertInt32
.9c8a	a2 00		ldx #$00			ldx	 	#0
.9c8c					_MPTSCopy:
.9c8c	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c8f	20 9a 9c	jsr $9c9a			jsr 	WriteDecimalBuffer
.9c92	e8		inx				inx
.9c93	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c96	d0 f4		bne $9c8c			bne 	_MPTSCopy
.9c98	fa		plx				plx
.9c99	60		rts				rts
.9c9a					WriteDecimalBuffer:
.9c9a	da		phx				phx
.9c9b	ae 95 04	ldx $0495			ldx 	dbOffset
.9c9e	9d 1b 06	sta $061b,x			sta 	DecimalBuffer,x
.9ca1	9e 1c 06	stz $061c,x			stz 	DecimalBuffer+1,x
.9ca4	ee 95 04	inc $0495			inc 	dbOffset
.9ca7	fa		plx				plx
.9ca8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9ca9					Unary_Left:
.9ca9	fa		plx				plx
.9caa	18		clc				clc 								; only one parameter
.9cab	20 20 9d	jsr $9d20			jsr 	SubstringInitial 			; set up.
.9cae	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9cb1	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cb4	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9cb7	80 2c		bra $9ce5			bra 	SubstringMain
.9cb9					Unary_Right:
.9cb9	fa		plx				plx
.9cba	18		clc				clc 								; only one parameter
.9cbb	20 20 9d	jsr $9d20			jsr 	SubstringInitial 			; set up.
.9cbe	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9cc1	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cc4	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9cc7	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cca	b0 02		bcs $9cce			bcs 	_URNotUnderflow
.9ccc	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cce					_URNotUnderFlow:
.9cce	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cd1	80 12		bra $9ce5			bra 	SubStringMain
.9cd3					Unary_Mid:
.9cd3	fa		plx				plx
.9cd4	38		sec				sec 								; two parameters
.9cd5	20 20 9d	jsr $9d20			jsr 	SubstringInitial 			; set up.
.9cd8	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9cdb	f0 05		beq $9ce2			beq 	_UMError
.9cdd	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9ce0	80 03		bra $9ce5			bra 	SubStringMain
.9ce2					_UMError:
.9ce2	4c c1 9f	jmp $9fc1			jmp 	ArgumentError
.9ce5					SubStringMain:
.9ce5	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9ce8	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9ceb	b0 2d		bcs $9d1a			bcs 	_SSMNull 					; if so, return an empty string.
.9ced	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9cf0	f0 28		beq $9d1a			beq 	_SSMNull 					; return empty string.
.9cf2	18		clc				clc 								; add the offset +1 to the address and
.9cf3	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9cf6	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9cf9	85 36		sta $36				sta 	zTemp0
.9cfb	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9cfe	69 00		adc #$00			adc 	#0
.9d00	85 37		sta $37				sta 	zTemp0+1
.9d02					_SSMNoCarry:
.9d02	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d05	20 74 a7	jsr $a774			jsr 	StringTempAllocate 			; allocate that many characters
.9d08	5a		phy				phy 								; save Y
.9d09	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d0b					_SSMCopy:
.9d0b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d0d	f0 09		beq $9d18			beq 	_SSMEString 				; no more to copy
.9d0f	20 b2 a7	jsr $a7b2			jsr 	StringTempWrite 			; and write it out.
.9d12	c8		iny				iny
.9d13	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9d16	d0 f3		bne $9d0b			bne 	_SSMCopy
.9d18					_SSMEString:
.9d18	7a		ply				ply
.9d19					_SSMExit:
.9d19	60		rts				rts
.9d1a					_SSMNull:
.9d1a	a9 00		lda #$00			lda 	#0
.9d1c	20 74 a7	jsr $a774			jsr 	StringTempAllocate
.9d1f	60		rts				rts
.9d20					SubstringInitial:
.9d20	da		phx				phx 								; save initial stack position
.9d21	08		php				php 								; save carry on stack indicating 2 parameters
.9d22	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get a string
.9d25	5a		phy				phy 								; calculate length to exponent.
.9d26	a0 ff		ldy #$ff			ldy 	#$FF
.9d28					_SIFindLength:
.9d28	c8		iny				iny
.9d29	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d2b	d0 fb		bne $9d28			bne 	_SIFindLength
.9d2d	98		tya				tya
.9d2e	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9d31	7a		ply				ply
.9d32	e8		inx				inx
.9d33	20 54 8d	jsr $8d54			jsr 	CheckComma 					; comma next
.9d36	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get next parameter
.9d39	28		plp				plp 								; is it the last parameter ?
.9d3a	90 07		bcc $9d43			bcc 	_SSIExit 					; if so, exit.
.9d3c	e8		inx				inx
.9d3d	20 54 8d	jsr $8d54			jsr 	CheckComma 					; comma next
.9d40	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get last parameter
.9d43					_SSIExit:
.9d43	fa		plx				plx
.9d44	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; check closing bracket
.9d47	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d48					EvaluateValue:
.9d48	48		pha				pha
.9d49	20 14 93	jsr $9314			jsr		EvaluateExpression 			; expression
.9d4c	20 32 96	jsr $9632			jsr 	Dereference					; derefernce it
.9d4f	68		pla				pla
.9d50	60		rts				rts
.9d51					EvaluateNumber:
.9d51	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get a value
.9d54	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d57	29 10		and #$10			and 	#NSBIsString
.9d59	d0 16		bne $9d71			bne 	HelperTypeError
.9d5b	60		rts				rts
.9d5c					EvaluateString:
.9d5c	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get a value
.9d5f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d62	29 10		and #$10			and 	#NSBIsString
.9d64	f0 0b		beq $9d71			beq 	HelperTypeError
.9d66					CopyAddressToTemp0:
.9d66	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d69	85 36		sta $36				sta 	zTemp0
.9d6b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9d6e	85 37		sta $37				sta 	zTemp0+1
.9d70	60		rts				rts
.9d71					HelperTypeError:
.9d71	4c bc 9f	jmp $9fbc			jmp 	TypeError
.9d74					EvaluateInteger:
.9d74	20 51 9d	jsr $9d51			jsr 	EvaluateNumber
.9d77	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9d7a	d0 0a		bne $9d86			bne 	HelperValueError 			; if not, it's a float.
.9d7c	60		rts				rts
.9d7d					EvaluateUnsignedInteger:
.9d7d	20 74 9d	jsr $9d74			jsr 	EvaluateInteger 			; check integer is +ve
.9d80	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9d83	30 01		bmi $9d86			bmi 	HelperValueError
.9d85	60		rts				rts
.9d86					HelperValueError:
.9d86	4c c1 9f	jmp $9fc1			jmp 	ArgumentError
.9d89					Evaluate16BitInteger:
.9d89	20 7d 9d	jsr $9d7d			jsr	 	EvaluateUnsignedInteger		; get integer
.9d8c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d8f	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9d92	d0 f2		bne $9d86			bne 	HelperValueError
.9d94	60		rts				rts
.9d95					Evaluate16BitIntegerSigned:
.9d95	20 74 9d	jsr $9d74			jsr	 	EvaluateInteger				; get integer
.9d98	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d9b	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9d9e	d0 e6		bne $9d86			bne 	HelperValueError
.9da0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9da3	10 03		bpl $9da8			bpl 	_EISNotSigned
.9da5	20 dd 9d	jsr $9ddd			jsr 	NSMNegateMantissa
.9da8					_EISNotSigned:
.9da8	60		rts				rts
.9da9					Evaluate8BitInteger:
.9da9	20 7d 9d	jsr $9d7d			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9dac	d0 d8		bne $9d86			bne 	HelperValueError
.9dae	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9db1	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9db4	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9db7	d0 cd		bne $9d86			bne 	HelperValueError
.9db9	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9dbc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dbd					Multiply8x8:
.9dbd	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dbe	85 36		sta $36			  	sta 	zTemp0
.9dc0	86 37		stx $37				stx 	zTemp0+1
.9dc2	a9 00		lda #$00			lda 	#0
.9dc4	a2 08		ldx #$08			ldx 	#8
.9dc6					_M88Loop:
.9dc6	90 03		bcc $9dcb			bcc 	_M88NoAdd
.9dc8	18		clc				clc
.9dc9	65 37		adc $37				adc 	zTemp0+1
.9dcb					_M88NoAdd:
.9dcb	6a		ror a				ror 	a
.9dcc	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dce	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9dcf	d0 f5		bne $9dc6			bne 	_M88Loop
.9dd1	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9dd3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9dd4					NSMNegate:
.9dd4	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9dd7	49 80		eor #$80			eor 	#NSBIsNegative
.9dd9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9ddc	60		rts				rts
.9ddd					NSMNegateMantissa:
.9ddd	38		sec				sec
.9dde	a9 00		lda #$00			lda 	#0
.9de0	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9de3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9de6	a9 00		lda #$00			lda 	#0
.9de8	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9deb	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9dee	a9 00		lda #$00			lda 	#0
.9df0	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9df3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9df6	a9 00		lda #$00			lda 	#0
.9df8	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9dfb	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9dfe	60		rts				rts
.9dff					NSMShiftUpTwo:
.9dff	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e02	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9e05	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e08	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9e0b	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9e0e	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9e11	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e14	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9e17	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9e1a	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9e1d	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e20	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9e23	60		rts				rts
.9e24					NSMSetZeroMantissaOnly:
.9e24	a9 00		lda #$00			lda 	#0
.9e26	80 08		bra $9e30			bra 	NSMSetMantissa
.9e28					NSMSetZero:
.9e28	a9 00		lda #$00			lda 	#0
.9e2a					NSMSetByte:
.9e2a	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e2d	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9e30					NSMSetMantissa:
.9e30	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9e33	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9e36	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9e39	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9e3c	60		rts				rts
.9e3d					NSMShiftLeft:
.9e3d	18		clc				clc
.9e3e					NSMRotateLeft:
.9e3e	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9e41	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9e44	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9e47	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9e4a	60		rts				rts
.9e4b					NSMShiftRight:
.9e4b	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9e4e	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9e51	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9e54	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9e57	60		rts				rts
.9e58					NSMIsZero:
.9e58	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e5b	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9e5e	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9e61	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9e64	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.b9d7					TickHandler:
.b9d7	5a		phy				phy 								; need to preserve Y
.b9d8	20 7d b9	jsr $b97d			jsr 	SNDUpdate 					; update sound
.b9db	7a		ply				ply
.b9dc	60		rts				rts
.062d					LastTick:
>062d							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e65					Assemble_ora:
.9e65	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e68	01					.byte $01
.9e69					Assemble_and:
.9e69	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e6c	21					.byte $21
.9e6d					Assemble_eor:
.9e6d	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e70	41					.byte $41
.9e71					Assemble_adc:
.9e71	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e74	61					.byte $61
.9e75					Assemble_sta:
.9e75	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e78	81					.byte $81
.9e79					Assemble_lda:
.9e79	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e7c	a1					.byte $a1
.9e7d					Assemble_cmp:
.9e7d	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e80	c1					.byte $c1
.9e81					Assemble_sbc:
.9e81	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e84	e1					.byte $e1
.9e85					Assemble_asl:
.9e85	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e88	02					.byte $02
>9e89	75					.byte $75
.9e8a					Assemble_rol:
.9e8a	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e8d	22					.byte $22
>9e8e	75					.byte $75
.9e8f					Assemble_lsr:
.9e8f	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e92	42					.byte $42
>9e93	75					.byte $75
.9e94					Assemble_ror:
.9e94	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e97	62					.byte $62
>9e98	75					.byte $75
.9e99					Assemble_stx:
.9e99	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e9c	82					.byte $82
>9e9d	50					.byte $50
.9e9e					Assemble_ldx:
.9e9e	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ea1	a2					.byte $a2
>9ea2	d0					.byte $d0
.9ea3					Assemble_dec:
.9ea3	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ea6	c2					.byte $c2
>9ea7	55					.byte $55
.9ea8					Assemble_inc:
.9ea8	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eab	e2					.byte $e2
>9eac	55					.byte $55
.9ead					Assemble_stz:
.9ead	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eb0	60					.byte $60
>9eb1	44					.byte $44
.9eb2					Assemble_bit:
.9eb2	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eb5	20					.byte $20
>9eb6	55					.byte $55
.9eb7					Assemble_sty:
.9eb7	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eba	80					.byte $80
>9ebb	54					.byte $54
.9ebc					Assemble_ldy:
.9ebc	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ebf	a0					.byte $a0
>9ec0	d5					.byte $d5
.9ec1					Assemble_cpy:
.9ec1	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ec4	c0					.byte $c0
>9ec5	d4					.byte $d4
.9ec6					Assemble_cpx:
.9ec6	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ec9	e0					.byte $e0
>9eca	d0					.byte $d0
.9ecb					Assemble_tsb:
.9ecb	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ece	00					.byte $00
>9ecf	50					.byte $50
.9ed0					Assemble_trb:
.9ed0	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ed3	10					.byte $10
>9ed4	50					.byte $50
.9ed5					Assemble_jsr:
.9ed5	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ed8	14					.byte $14
>9ed9	10					.byte $10
.9eda					Assemble_jmp:
.9eda	20 72 80	jsr $8072		jsr	AssembleGroup2
>9edd	40					.byte $40
>9ede	10					.byte $10
.9edf					Assemble_bpl:
.9edf	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ee2	10					.byte $10
.9ee3					Assemble_bmi:
.9ee3	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ee6	30					.byte $30
.9ee7					Assemble_bvc:
.9ee7	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9eea	50					.byte $50
.9eeb					Assemble_bvs:
.9eeb	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9eee	70					.byte $70
.9eef					Assemble_bcc:
.9eef	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ef2	90					.byte $90
.9ef3					Assemble_bcs:
.9ef3	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ef6	b0					.byte $b0
.9ef7					Assemble_bne:
.9ef7	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9efa	d0					.byte $d0
.9efb					Assemble_beq:
.9efb	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9efe	f0					.byte $f0
.9eff					Assemble_bra:
.9eff	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f02	80					.byte $80
.9f03					Assemble_brk:
.9f03	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f06	00					.byte $00
.9f07					Assemble_php:
.9f07	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f0a	08					.byte $08
.9f0b					Assemble_clc:
.9f0b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f0e	18					.byte $18
.9f0f					Assemble_plp:
.9f0f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f12	28					.byte $28
.9f13					Assemble_sec:
.9f13	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f16	38					.byte $38
.9f17					Assemble_rti:
.9f17	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f1a	40					.byte $40
.9f1b					Assemble_pha:
.9f1b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f1e	48					.byte $48
.9f1f					Assemble_cli:
.9f1f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f22	58					.byte $58
.9f23					Assemble_phy:
.9f23	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f26	5a					.byte $5a
.9f27					Assemble_rts:
.9f27	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f2a	60					.byte $60
.9f2b					Assemble_pla:
.9f2b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f2e	68					.byte $68
.9f2f					Assemble_sei:
.9f2f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f32	78					.byte $78
.9f33					Assemble_ply:
.9f33	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f36	7a					.byte $7a
.9f37					Assemble_dey:
.9f37	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f3a	88					.byte $88
.9f3b					Assemble_txa:
.9f3b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f3e	8a					.byte $8a
.9f3f					Assemble_tya:
.9f3f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f42	98					.byte $98
.9f43					Assemble_txs:
.9f43	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f46	9a					.byte $9a
.9f47					Assemble_tay:
.9f47	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f4a	a8					.byte $a8
.9f4b					Assemble_tax:
.9f4b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f4e	aa					.byte $aa
.9f4f					Assemble_clv:
.9f4f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f52	b8					.byte $b8
.9f53					Assemble_tsx:
.9f53	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f56	ba					.byte $ba
.9f57					Assemble_iny:
.9f57	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f5a	c8					.byte $c8
.9f5b					Assemble_dex:
.9f5b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f5e	ca					.byte $ca
.9f5f					Assemble_cld:
.9f5f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f62	d8					.byte $d8
.9f63					Assemble_phx:
.9f63	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f66	da					.byte $da
.9f67					Assemble_stp:
.9f67	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f6a	db					.byte $db
.9f6b					Assemble_inx:
.9f6b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f6e	e8					.byte $e8
.9f6f					Assemble_nop:
.9f6f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f72	ea					.byte $ea
.9f73					Assemble_sed:
.9f73	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f76	f8					.byte $f8
.9f77					Assemble_plx:
.9f77	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f7a	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f7b					DecimalScalarTable:
>9f7b	66 66 66 66				.dword $66666666 ; 0.1
>9f7f	de					.byte $de
>9f80	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f84	db					.byte $db
>9f85	4c 37 89 41				.dword $4189374c ; 0.001
>9f89	d8					.byte $d8
>9f8a	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f8e	d4					.byte $d4
>9f8f	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f93	d1					.byte $d1
>9f94	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f98	ce					.byte $ce
>9f99	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f9d	ca					.byte $ca
>9f9e	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9fa2	c7					.byte $c7
>9fa3	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9fa7	c4					.byte $c4
>9fa8	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9fac	c0					.byte $c0
>9fad	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fb1	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fb2					SyntaxError:
.9fb2	a9 02		lda #$02		lda	#2
.9fb4	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fb7					RangeError:
.9fb7	a9 04		lda #$04		lda	#4
.9fb9	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fbc					TypeError:
.9fbc	a9 05		lda #$05		lda	#5
.9fbe	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fc1					ArgumentError:
.9fc1	a9 07		lda #$07		lda	#7
.9fc3	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fc6					NotDoneError:
.9fc6	a9 0c		lda #$0c		lda	#12
.9fc8	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fcb					ErrorText:
>9fcb	42 72 65 61 6b 00			.text	"Break",0
>9fd1	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fd9	72 72 6f 72 00
>9fde	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fe6	20 62 79 20 7a 65 72 6f 00
>9fef	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9ff7	61 6e 67 65 00
>9ffc	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a004	6d 61 74 63 68 00
>a00a	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a012	65 6d 6f 72 79 00
>a018	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a020	61 72 67 75 6d 65 6e 74 00
>a029	53 74 6f 70 00				.text	"Stop",0
>a02e	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a036	6f 6f 20 6c 6f 6e 67 00
>a03e	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a046	6e 20 66 61 69 6c 65 64 00
>a04f	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a057	61 74 61 00
>a05b	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a063	65 6e 74 65 64 00
>a069	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a071	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a07d	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a085	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a092	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a09a	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a0a7	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0af	68 6f 75 74 20 57 68 69 6c 65 00
>a0ba	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0c2	68 6f 75 74 20 46 6f 72 00
>a0cb	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0d3	61 63 6b 20 66 75 6c 6c 00
>a0dc	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0e4	75 63 74 75 72 65 00
>a0eb	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0f3	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a100	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a108	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a116	41 72 72 61 79 20 73 69			.text	"Array size",0
>a11e	7a 65 00
>a121	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a129	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a131	42 75 69 6c 74 20 4d 6f			.text "Built Monday 21-Nov-2022. Build 3482."
>a139	6e 64 61 79 20 32 31 2d 4e 6f 76 2d 32 30 32 32
>a149	2e 20 42 75 69 6c 64 20 33 34 38 32 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a156					RectangleCommand:
.a156	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a158	80 02		bra $a15c			bra 	ShapeDrawCmd
.a15a					CircleCommand:
.a15a	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a15c					ShapeDrawCmd:
.a15c	20 ea a1	jsr $a1ea			jsr 	RunGraphicsCommand
.a15f					ShapeDraw:
.a15f	0d 2f 06	ora $062f			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a162	4c de a1	jmp $a1de			jmp 	ExecuteGraphicCommand	 	; and complete
.a165					SpriteCommand:
.a165	a2 00		ldx #$00			ldx 	#0
.a167	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get image number.
.a16a	5a		phy				phy
.a16b	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a16d	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a170	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a172	b0 0d		bcs $a181			bcs 	_SCRange
.a174	a0 ff		ldy #$ff			ldy 	#255
.a176	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a179	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a17b	7a		ply				ply
.a17c	20 ea a1	jsr $a1ea			jsr 	RunGraphicsCommand
.a17f	80 5d		bra $a1de			bra 	ExecuteGraphicCommand
.a181					_SCRange:
.a181	4c b7 9f	jmp $9fb7			jmp 	RangeError
.a184					ImageCommand:
.a184	a2 00		ldx #$00			ldx 	#0
.a186	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get image number.
.a189	20 ea a1	jsr $a1ea			jsr 	RunGraphicsCommand
.a18c					ImageRunDraw:
.a18c	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a18e	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a191	ad 35 06	lda $0635			lda 	gxDrawScale
.a194	0a		asl a				asl 	a
.a195	0a		asl a				asl 	a
.a196	0a		asl a				asl 	a
.a197	a8		tay				tay
.a198	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a19a	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a19d	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a1a0	60		rts				rts
.a1a1					TextCommand:
.a1a1	a2 00		ldx #$00			ldx 	#0
.a1a3	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get text
.a1a6	20 ea a1	jsr $a1ea			jsr 	RunGraphicsCommand
.a1a9					TextRunDraw:
.a1a9	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1ab	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a1ae	a0 00		ldy #$00			ldy 	#0
.a1b0					_IRDLoop:
.a1b0	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a1b3	85 37		sta $37				sta 	zTemp0+1
.a1b5	ad 08 04	lda $0408			lda 	NSMantissa0
.a1b8	85 36		sta $36				sta 	zTemp0
.a1ba	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1bc	f0 13		beq $a1d1			beq 	_IRDExit
.a1be	5a		phy				phy									; save string pos
.a1bf	48		pha				pha 								; save char
.a1c0	ad 35 06	lda $0635			lda 	gxDrawScale 				; get scale
.a1c3	0a		asl a				asl 	a
.a1c4	0a		asl a				asl 	a
.a1c5	0a		asl a				asl 	a
.a1c6	a8		tay				tay
.a1c7	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1c9	fa		plx				plx 								; char to draw
.a1ca	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a1cd	7a		ply				ply 								; restore string pos
.a1ce	c8		iny				iny
.a1cf	90 df		bcc $a1b0			bcc 	_IRDLoop 					; go back if no error.
.a1d1					_IRDExit:
.a1d1	60		rts				rts
.a1d2					PlotCommand:
.a1d2	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1d4	20 ea a1	jsr $a1ea			jsr 	RunGraphicsCommand
.a1d7	80 05		bra $a1de			bra 	ExecuteGraphicCommand
.a1d9					LineCommand:
.a1d9	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1db	20 ea a1	jsr $a1ea			jsr 	RunGraphicsCommand
.a1de					ExecuteGraphicCommand:
.a1de	0d 2e 06	ora $062e			ora 	gxCommandID 				; make a full command
.a1e1	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw 				; draw it and exit
.a1e4	b0 01		bcs $a1e7			bcs 	_EGCError
.a1e6	60		rts				rts
.a1e7					_EGCError:
.a1e7	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.a1ea					RunGraphicsCommand:
.a1ea	8d 2e 06	sta $062e			sta 	gxCommandID					; save TODO graphics command.
.a1ed	68		pla				pla 								; pop handler address
.a1ee	fa		plx				plx
.a1ef	1a		inc a				inc 	a
.a1f0	d0 01		bne $a1f3			bne 	_RGINoCarry
.a1f2	e8		inx				inx
.a1f3					_RGINoCarry:
.a1f3	8d 33 06	sta $0633			sta 	GXHandler
.a1f6	8e 34 06	stx $0634			stx 	GXHandler+1
.a1f9					_RGICommandLoop:
.a1f9	b1 30		lda ($30),y			lda 	(codePtr),y
.a1fb	c8		iny				iny
.a1fc	c9 cd		cmp #$cd			cmp 	#KWD_TO						; is it TO x,y
.a1fe	f0 53		beq $a253			beq 	_RGI_To
.a200	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a202	f0 55		beq $a259			beq 	_RGI_Here
.a204	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a206	f0 3d		beq $a245			beq 	_RGI_Exit
.a208	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a20a	f0 39		beq $a245			beq 	_RGI_Exit
.a20c	c9 c1		cmp #$c1			cmp 	#KWD_OUTLINE 				; solid or outline
.a20e	f0 3e		beq $a24e			beq 	_RGI_Frame
.a210	c9 c9		cmp #$c9			cmp 	#KWD_SOLID
.a212	f0 33		beq $a247			beq 	_RGI_Solid
.a214	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a216	f0 4b		beq $a263			beq 	_RGI_By
.a218	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a21a	f0 17		beq $a233			beq 	_RGI_Move2
.a21c	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a21e	f0 65		beq $a285			beq 	_RGI_Dim
.a220	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a222	f0 78		beq $a29c			beq 	_RGI_Colour
.a224	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a226	f0 74		beq $a29c			beq 	_RGI_Colour
.a228	ae 2e 06	ldx $062e			ldx 	gxCommandID
.a22b	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a22d	d0 03		bne $a232			bne 	_RGI_Move 					; move
.a22f	4c c6 a2	jmp $a2c6			jmp		_RGI_SpriteInstructions
.a232					_RGI_Move:
.a232	88		dey				dey 								; unpick get.
.a233					_RGI_Move2:
.a233	20 ec a2	jsr $a2ec			jsr 	GCGetCoordinatePair 		; move to here
.a236	20 13 a3	jsr $a313			jsr 	GCCopyPairToStore 			; save
.a239	5a		phy				phy
.a23a	20 09 a3	jsr $a309			jsr 	GCLoadAXY 					; load in
.a23d	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a23f	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a242	7a		ply				ply
.a243	80 b4		bra $a1f9			bra 	_RGICommandLoop 			; and go round
.a245					_RGI_Exit:
.a245	88		dey				dey 								; unpick : / EOL
.a246	60		rts				rts
.a247					_RGI_Solid:
.a247	a9 02		lda #$02			lda 	#2
.a249	8d 2f 06	sta $062f			sta 	gxFillSolid
.a24c	80 ab		bra $a1f9			bra 	_RGICommandLoop
.a24e					_RGI_Frame:
.a24e	9c 2f 06	stz $062f			stz 	gxFillSolid
.a251	80 a6		bra $a1f9			bra 	_RGICommandLoop
.a253					_RGI_To:
.a253	20 ec a2	jsr $a2ec			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a256	20 13 a3	jsr $a313			jsr 	GCCopyPairToStore
.a259					_RGI_Here:
.a259	5a		phy				phy
.a25a	20 09 a3	jsr $a309			jsr 	GCLoadAXY 					; load it into AXY
.a25d	20 c3 a2	jsr $a2c3			jsr 	_RGICallHandler 			; go do whatever it is.
.a260	7a		ply				ply
.a261	80 96		bra $a1f9			bra 	_RGICommandLoop 			; and go round
.a263					_RGI_By:
.a263	20 f9 a2	jsr $a2f9			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a266	18		clc				clc
.a267	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a26a	6d 30 06	adc $0630			adc 	gxxPos
.a26d	8d 30 06	sta $0630			sta 	gxXPos
.a270	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a273	6d 31 06	adc $0631			adc 	gxxPos+1
.a276	8d 31 06	sta $0631			sta 	gxXPos+1
.a279	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a27c	18		clc				clc
.a27d	6d 32 06	adc $0632			adc 	gxYPos
.a280	8d 32 06	sta $0632			sta 	gxYPos
.a283	80 d4		bra $a259			bra 	_RGI_Here
.a285					_RGI_Dim:
.a285	a2 01		ldx #$01			ldx	 	#1
.a287	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger
.a28a	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a28d	c9 00		cmp #$00			cmp 	#0
.a28f	f0 2f		beq $a2c0			beq 	_RGIRange
.a291	c9 09		cmp #$09			cmp 	#8+1
.a293	b0 2b		bcs $a2c0			bcs		_RGIRange
.a295	3a		dec a				dec 	a
.a296	8d 35 06	sta $0635			sta 	gxDrawScale
.a299	4c f9 a1	jmp $a1f9			jmp 	_RGICommandLoop
.a29c					_RGI_Colour:
.a29c	a2 01		ldx #$01			ldx 	#1 							; colour
.a29e	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger
.a2a1	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a2a3	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.a2a6	b1 30		lda ($30),y			lda 	(codePtr),y
.a2a8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a2aa	d0 04		bne $a2b0			bne 	_RGICDefaultMode
.a2ac	c8		iny				iny
.a2ad	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger
.a2b0					_RGICDefaultMode:
.a2b0	5a		phy				phy
.a2b1	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2b3	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a2b6	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a2b9	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a2bc	7a		ply				ply
.a2bd	4c f9 a1	jmp $a1f9			jmp 	_RGICommandLoop 			; and go round
.a2c0					_RGIRange:
.a2c0	4c b7 9f	jmp $9fb7			jmp 	RangeError
.a2c3					_RGICallHandler:
.a2c3	6c 33 06	jmp ($0633)			jmp 	(GXHandler)
.a2c6					_RGI_SpriteInstructions:
.a2c6	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a2c8	f0 07		beq $a2d1			beq 	_RGISpriteOff
.a2ca	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a2cc	f0 13		beq $a2e1			beq 	_RGISetImage
.a2ce	4c 32 a2	jmp $a232			jmp 	_RGI_Move
.a2d1					_RGISpriteOff:
.a2d1	5a		phy				phy
.a2d2	a0 01		ldy #$01			ldy 	#1
.a2d4	a2 00		ldx #$00			ldx 	#0
.a2d6					_RGIDoCommandLoop:
.a2d6	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2d8	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a2db	7a		ply				ply
.a2dc	b0 e2		bcs $a2c0			bcs 	_RGIRange
.a2de	4c f9 a1	jmp $a1f9			jmp 	_RGICommandLoop
.a2e1					_RGISetImage:
.a2e1	a2 01		ldx #$01			ldx 	#1
.a2e3	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger
.a2e6	5a		phy				phy
.a2e7	aa		tax				tax
.a2e8	a0 00		ldy #$00			ldy 	#0
.a2ea	80 ea		bra $a2d6			bra 	_RGIDoCommandLoop
.a2ec					GCGetCoordinatePair:
.a2ec	a2 01		ldx #$01			ldx 	#1
.a2ee	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.a2f1	20 54 8d	jsr $8d54			jsr 	CheckComma
.a2f4	e8		inx				inx
.a2f5	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.a2f8	60		rts				rts
.a2f9					GCSignedCoordinatePair:
.a2f9	a2 01		ldx #$01			ldx 	#1
.a2fb	20 95 9d	jsr $9d95			jsr 	Evaluate16BitIntegerSigned
.a2fe	20 54 8d	jsr $8d54			jsr 	CheckComma
.a301	e8		inx				inx
.a302	20 95 9d	jsr $9d95			jsr 	Evaluate16BitIntegerSigned
.a305	60		rts				rts
.a306					_GCCPRange:
.a306	4c b7 9f	jmp $9fb7			jmp 	RangeError
.a309					GCLoadAXY:
.a309	ad 31 06	lda $0631			lda 	gxXPos+1
.a30c	ae 30 06	ldx $0630			ldx 	gxXPos
.a30f	ac 32 06	ldy $0632			ldy 	gxYPos
.a312	60		rts				rts
.a313					GCCopyPairToStore:
.a313	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a316	8d 30 06	sta $0630			sta 	gxXPos
.a319	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a31c	8d 31 06	sta $0631			sta 	gxXPos+1
.a31f	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a322	8d 32 06	sta $0632			sta 	gxYPos
.a325	60		rts				rts
.062e					gxCommandID:
>062e							.fill 	1
.062f					gxFillSolid:
>062f							.fill 	1
.0630					gxXPos:
>0630							.fill 	2
.0632					gxYPos:
>0632							.fill 	1
.0633					gxHandler:
>0633							.fill 	2
.0635					gxDrawScale:
>0635							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a326					BitmapCtrl:
.a326	b1 30		lda ($30),y			lda 	(codePtr),y
.a328	c8		iny				iny
.a329	a2 01		ldx #$01			ldx 	#1
.a32b	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a32d	f0 11		beq $a340			beq 	BitmapSwitch
.a32f	ca		dex				dex
.a330	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a332	f0 0c		beq $a340			beq 	BitmapSwitch
.a334	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get the colour
.a337	5a		phy				phy
.a338	aa		tax				tax
.a339	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a33b	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a33e	7a		ply				ply
.a33f	60		rts				rts
.a340					BitmapSwitch:
.a340	5a		phy				phy
.a341	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a343	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a345	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a348	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a34a	a0 00		ldy #$00			ldy 	#0
.a34c	a2 ff		ldx #$ff			ldx 	#$FF
.a34e	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a351	9c 2f 06	stz $062f			stz 	gxFillSolid
.a354	9c 30 06	stz $0630			stz 	gxXPos
.a357	9c 31 06	stz $0631			stz 	gxXPos+1
.a35a	9c 32 06	stz $0632			stz 	gxYPos
.a35d	9c 35 06	stz $0635			stz 	gxDrawScale
.a360	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a362	a2 00		ldx #$00			ldx 	#0
.a364	a0 00		ldy #$00			ldy 	#0
.a366	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a369	7a		ply				ply
.a36a	60		rts				rts
.a36b					SpritesCtrl:
.a36b	b1 30		lda ($30),y			lda 	(codePtr),y
.a36d	c8		iny				iny
.a36e	a2 01		ldx #$01			ldx 	#1
.a370	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a372	f0 08		beq $a37c			beq 	SpriteSwitch
.a374	ca		dex				dex
.a375	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a377	f0 03		beq $a37c			beq 	SpriteSwitch
.a379	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.a37c					SpriteSwitch:
.a37c	5a		phy				phy
.a37d	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a37f	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a381	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a384	7a		ply				ply
.a385	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a386					GfxCommand:
.a386	a2 00		ldx #$00			ldx 	#0
.a388	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; command
.a38b	20 54 8d	jsr $8d54			jsr 	CheckComma
.a38e	e8		inx				inx
.a38f	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; X
.a392	20 54 8d	jsr $8d54			jsr 	CheckComma
.a395	e8		inx				inx
.a396	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; Y
.a399	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a39c	4a		lsr a				lsr 	a
.a39d	d0 16		bne $a3b5			bne 	_GfxError
.a39f	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a3a2	b0 11		bcs $a3b5			bcs 	_GfxError 					; bit 7 should have been zero
.a3a4	5a		phy				phy 								; save pos
.a3a5	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a3a8	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a3ab	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a3ae	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw
.a3b1	b0 02		bcs $a3b5			bcs 	_GfxError
.a3b3	7a		ply				ply 								; restore pos and exit.
.a3b4	60		rts				rts
.a3b5					_GfxError:
.a3b5	4c b7 9f	jmp $9fb7			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a3b8					UnaryHit:
.a3b8	fa		plx				plx
.a3b9	a9 36		lda #$36			lda 	#zTemp0
.a3bb	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3be	20 54 8d	jsr $8d54			jsr 	CheckComma
.a3c1	e8		inx				inx
.a3c2	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3c5	20 4c 8d	jsr $8d4c			jsr		CheckRightBracket
.a3c8	ca		dex				dex 								; fix back up again.
.a3c9	da		phx				phx 								; save X/Y
.a3ca	5a		phy				phy
.a3cb	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3ce	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a3d1	aa		tax				tax
.a3d2	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3d4	20 c1 aa	jsr $aac1			jsr 	GXGraphicDraw 				; calculate result
.a3d7	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3d8	7a		ply				ply 								; restore XY
.a3d9	fa		plx				plx
.a3da	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte 					; return the hit result
.a3dd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3de					PaletteCommand:
.a3de	a2 00		ldx #$00			ldx 	#0
.a3e0	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; colour
.a3e3	20 54 8d	jsr $8d54			jsr 	CheckComma
.a3e6	e8		inx				inx
.a3e7	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; r
.a3ea	20 54 8d	jsr $8d54			jsr 	CheckComma
.a3ed	e8		inx				inx
.a3ee	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; g
.a3f1	20 54 8d	jsr $8d54			jsr 	CheckComma
.a3f4	e8		inx				inx
.a3f5	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; b
.a3f8	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a3fb	85 36		sta $36				sta 	zTemp0
.a3fd	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a3ff	85 37		sta $37				sta 	zTemp0+1
.a401	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a403	26 37		rol $37				rol	 	zTemp0+1
.a405	06 36		asl $36				asl 	zTemp0
.a407	26 37		rol $37				rol	 	zTemp0+1
.a409	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a40b	85 01		sta $01				sta 	1
.a40d	5a		phy				phy
.a40e	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a411	92 36		sta ($36)			sta 	(zTemp0)
.a413	a0 01		ldy #$01			ldy 	#1
.a415	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a418	91 36		sta ($36),y			sta 	(zTemp0),y
.a41a	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a41d	c8		iny				iny
.a41e	91 36		sta ($36),y			sta 	(zTemp0),y
.a420	7a		ply				ply
.a421	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a422					UnaryEvent:
.a422	fa		plx				plx
.a423	20 ca a4	jsr $a4ca			jsr 	TimerToStackX 				; timer in +0
.a426	e8		inx				inx  								; put reference into +1
.a427	20 ee 97	jsr $97ee			jsr 	EvaluateTerm
.a42a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a42d	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a42f	d0 57		bne $a488			bne 	_UEType
.a431	e8		inx				inx 								; put the step in +2
.a432	20 54 8d	jsr $8d54			jsr 	CheckComma
.a435	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.a438	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.a43b	ca		dex				dex
.a43c	ca		dex				dex
.a43d	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a440	85 36		sta $36				sta 	zTemp0
.a442	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a445	85 37		sta $37				sta 	zTemp0+1
.a447	5a		phy				phy
.a448	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a44a	b1 36		lda ($36),y			lda 	(zTemp0),y
.a44c	30 36		bmi $a484			bmi 	_UEFalse 					; exit if signed.
.a44e	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a450	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a453	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a455	c8		iny				iny
.a456	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a459	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a45b	c8		iny				iny
.a45c	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a45f	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a461	90 21		bcc $a484			bcc 	_UEFalse 					; no, return FALSE.
.a463	18		clc				clc
.a464	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a466	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a469	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a46c	91 36		sta ($36),y			sta 	(zTemp0),y
.a46e	c8		iny				iny
.a46f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a472	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a475	91 36		sta ($36),y			sta 	(zTemp0),y
.a477	c8		iny				iny
.a478	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a47b	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a47e	91 36		sta ($36),y			sta 	(zTemp0),y
.a480	7a		ply				ply
.a481	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.a484					_UEFalse:
.a484	7a		ply				ply 								; restore Y
.a485	4c de 8d	jmp $8dde			jmp 	ReturnFalse 				; and return False
.a488					_UEType:
.a488	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a48b					UnaryJoyX:
.a48b	18		clc				clc
.a48c	80 01		bra $a48f			bra 	JoyMain
.a48e					UnaryJoyY:
.a48e	38		sec				sec
.a48f					JoyMain:
.a48f	fa		plx				plx 								; get pos
.a490	08		php				php 								; save carry (set for Y)
.a491	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a494	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.a497	20 7a aa	jsr $aa7a			jsr 	EXTReadController 			; read the controller.
.a49a	28		plp				plp
.a49b	90 02		bcc $a49f			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a49d	4a		lsr a				lsr 	a
.a49e	4a		lsr a				lsr 	a
.a49f					_JMNoShift:
.a49f	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a4a0	b0 0a		bcs $a4ac			bcs 	_JMIsRight
.a4a2	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a4a3	b0 04		bcs $a4a9			bcs 	_JMIsLeft
.a4a5	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; zero result
.a4a8	60		rts				rts
.a4a9					_JMIsLeft:
.a4a9	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.a4ac					_JMIsRight:
.a4ac	a9 01		lda #$01			lda 	#1
.a4ae	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.a4b1	60		rts				rts
.a4b2					UnaryJoyB:
.a4b2	fa		plx				plx 								; get pos
.a4b3	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a4b6	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.a4b9	20 7a aa	jsr $aa7a			jsr 	EXTReadController 			; read the controller.
.a4bc	4a		lsr a				lsr 	a
.a4bd	4a		lsr a				lsr 	a
.a4be	4a		lsr a				lsr 	a
.a4bf	4a		lsr a				lsr 	a
.a4c0	29 01		and #$01			and 	#1
.a4c2	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.a4c5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4c6					UnaryTimer:
.a4c6	fa		plx				plx
.a4c7	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.a4ca					TimerToStackX:
.a4ca	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; zero result
.a4cd	64 01		stz $01				stz 	1 							; access I/O
.a4cf	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4d2	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a4d5	ad 5a d6	lda $d65a			lda 	$D65A
.a4d8	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a4db	ad 5b d6	lda $d65b			lda 	$D65B
.a4de	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a4e1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4e2					MemoryDeleteLine:
.a4e2	20 01 a5	jsr $a501			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4e5	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4e7	a8		tay				tay
.a4e8					_MDDLLoop:
.a4e8	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4ea	92 30		sta ($30)			sta 	(codePtr)
.a4ec	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4ee	c5 3a		cmp $3a				cmp 	zTemp2
.a4f0	d0 07		bne $a4f9			bne 	_MDLDLNext
.a4f2	a5 31		lda $31				lda 	codePtr+1
.a4f4	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4f6	d0 01		bne $a4f9			bne 	_MDLDLNext
.a4f8					_MDDLExit:
.a4f8	60		rts				rts
.a4f9					_MDLDLNext:
.a4f9	e6 30		inc $30				inc 	codePtr						; next byte
.a4fb	d0 eb		bne $a4e8			bne 	_MDDLLoop
.a4fd	e6 31		inc $31				inc 	codePtr+1
.a4ff	80 e7		bra $a4e8			bra 	_MDDLLoop
.a501					IMemoryFindEnd:
.a501	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a503	85 3a		sta $3a				sta 	0+zTemp2
.a505	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a507	85 3b		sta $3b				sta 	1+zTemp2
.a509					_MDLFELoop:
.a509	b2 3a		lda ($3a)			lda 	(zTemp2)
.a50b	f0 0b		beq $a518			beq 	_MDLFEExit
.a50d	18		clc				clc
.a50e	65 3a		adc $3a				adc 	zTemp2
.a510	85 3a		sta $3a				sta 	zTemp2
.a512	90 f5		bcc $a509			bcc 	_MDLFELoop
.a514	e6 3b		inc $3b				inc 	zTemp2+1
.a516	80 f1		bra $a509			bra 	_MDLFELoop
.a518					_MDLFEExit:
.a518	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a519					MemoryInsertLine:
.a519	08		php				php
.a51a	20 01 a5	jsr $a501			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a51d	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a51f	1a		inc a				inc 	a
.a520	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a522	b0 36		bcs $a55a			bcs 	_MDLIError
.a524	28		plp				plp
.a525	90 08		bcc $a52f			bcc 	_MDLIFound
.a527	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a529	85 30		sta $30				sta 	codePtr
.a52b	a5 3b		lda $3b				lda 	zTemp2+1
.a52d	85 31		sta $31				sta 	codePtr+1
.a52f					_MDLIFound:
.a52f	ad a8 04	lda $04a8			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a532	a8		tay				tay
.a533					_MDLIInsert:
.a533	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a535	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a537	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a539	c5 3a		cmp $3a				cmp 	zTemp2
.a53b	d0 06		bne $a543			bne 	_MDLINext
.a53d	a5 31		lda $31				lda 	codePtr+1
.a53f	c5 3b		cmp $3b				cmp 	zTemp2+1
.a541	f0 0a		beq $a54d			beq 	_MDLIHaveSpace
.a543					_MDLINext:
.a543	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a545	d0 02		bne $a549			bne 	_MDLINoBorrow
.a547	c6 3b		dec $3b				dec 	zTemp2+1
.a549					_MDLINoBorrow:
.a549	c6 3a		dec $3a				dec 	zTemp2
.a54b	80 e6		bra $a533			bra 	_MDLIInsert
.a54d					_MDLIHaveSpace:
.a54d	ac a8 04	ldy $04a8			ldy 	tokenOffset 				; bytes to copy
.a550	88		dey				dey 								; from offset-1 to 0
.a551					_MDLICopy:
.a551	b9 a8 04	lda $04a8,y			lda 	tokenOffset,y
.a554	91 30		sta ($30),y			sta 	(codePtr),y
.a556	88		dey				dey
.a557	10 f8		bpl $a551			bpl 	_MDLICopy
.a559	60		rts				rts
.a55a					_MDLIError:
.a55a	a9 06		lda #$06		lda	#6
.a55c	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.a55f					MDLAppendLine:
.a55f	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a561	85 36		sta $36				sta 	zTemp0
.a563	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a565	85 38		sta $38				sta 	0+zTemp1
.a567	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a569	85 39		sta $39				sta 	1+zTemp1
.a56b	b2 38		lda ($38)			lda 	(zTemp1)
.a56d	d0 0a		bne $a579			bne 	_MDLANoInitialise
.a56f	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a571	8d 36 06	sta $0636			sta 	0+AppendPointer
.a574	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a576	8d 37 06	sta $0637			sta 	1+AppendPointer
.a579					_MDLANoInitialise:
.a579	18		clc				clc
.a57a	ad 36 06	lda $0636			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a57d	85 38		sta $38				sta 	zTemp1
.a57f	72 36		adc ($36)			adc 	(zTemp0)
.a581	8d 36 06	sta $0636			sta 	AppendPointer
.a584	ad 37 06	lda $0637			lda 	AppendPointer+1
.a587	85 39		sta $39				sta 	zTemp1+1
.a589	69 00		adc #$00			adc 	#0
.a58b	8d 37 06	sta $0637			sta 	AppendPointer+1
.a58e	a0 00		ldy #$00			ldy 	#0
.a590					_MDLACopy:
.a590	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a592	91 38		sta ($38),y			sta 	(zTemp1),y
.a594	c8		iny				iny
.a595	98		tya				tya
.a596	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a598	d0 f6		bne $a590			bne 	_MDLACopy
.a59a	a9 00		lda #$00			lda 	#0 							; end of program.
.a59c	91 38		sta ($38),y			sta 	(zTemp1),y
.a59e	60		rts				rts
.0636					AppendPointer:
>0636							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a59f					MemoryNew:
.a59f	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a1	85 30		sta $30				sta 	codePtr
.a5a3	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5a5	85 31		sta $31				sta 	codePtr+1
.a5a7	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a5a9	92 30		sta ($30)			sta 	(codePtr)
.a5ab	60		rts				rts
.a5ac					MemoryInline:
.a5ac	98		tya				tya 								; put address into stack,x
.a5ad	18		clc				clc
.a5ae	65 30		adc $30				adc 	codePtr
.a5b0	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a5b3	a5 31		lda $31				lda 	codePtr+1
.a5b5	69 00		adc #$00			adc 	#0
.a5b7	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a5ba	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a5bd	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a5c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a5c1					MemorySearch:
.a5c1	85 36		sta $36				sta 	zTemp0 						; save line number zTemp0
.a5c3	86 37		stx $37				stx 	zTemp0+1
.a5c5	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5c7	85 30		sta $30				sta 	codePtr
.a5c9	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5cb	85 31		sta $31				sta 	codePtr+1
.a5cd					_MTAXLoop:
.a5cd	b2 30		lda ($30)			lda 	(codePtr)
.a5cf	18		clc				clc
.a5d0	f0 21		beq $a5f3			beq 	_MTAXExit 					; reached end, exit with CC.
.a5d2	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5d4	b1 30		lda ($30),y			lda 	(codePtr),y
.a5d6	38		sec				sec
.a5d7	e5 36		sbc $36				sbc 	zTemp0
.a5d9	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5db	c8		iny				iny 								; do the MSB
.a5dc	b1 30		lda ($30),y			lda 	(codePtr),y
.a5de	e5 37		sbc $37				sbc 	zTemp0+1
.a5e0	05 38		ora $38				ora 	zTemp1
.a5e2	f0 0f		beq $a5f3			beq 	_MTAXExit	 				; found
.a5e4	b0 0d		bcs $a5f3			bcs 	_MTAXExit 					; current < required exit
.a5e6	18		clc				clc
.a5e7	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.a5e9	65 30		adc $30				adc 	codePtr
.a5eb	85 30		sta $30				sta 	codePtr
.a5ed	90 02		bcc $a5f1			bcc 	_CREExit
.a5ef	e6 31		inc $31				inc 	codePtr+1
.a5f1					_CREExit:
.a5f1	80 da		bra $a5cd			bra 	_MTAXLoop
.a5f3					_MTAXExit:
.a5f3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a5f4					SoundCommand:
.a5f4	b1 30		lda ($30),y			lda 	(codePtr),y
.a5f6	c9 bf		cmp #$bf			cmp 	#KWD_OFF 					; SOUND OFF ?
.a5f8	d0 09		bne $a603			bne 	_SNDMain
.a5fa	c8		iny				iny 								; skip OFF
.a5fb	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a5fd	5a		phy				phy
.a5fe	20 4f b9	jsr $b94f			jsr 	SNDCommand
.a601	7a		ply				ply
.a602	60		rts				rts
.a603					_SNDMain:
.a603	a2 00		ldx #$00			ldx 	#0
.a605	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; channel
.a608	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a60a	b0 50		bcs $a65c			bcs 	_SndError
.a60c	e8		inx				inx 								; do the rest in slot 1.
.a60d	20 54 8d	jsr $8d54			jsr 	CheckComma
.a610	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; Pitch
.a613	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a616	c9 10		cmp #$10			cmp 	#16
.a618	b0 42		bcs $a65c			bcs 	_SndError
.a61a	8d 39 06	sta $0639			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a61d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a620	8d 38 06	sta $0638			sta 	SoundCommandBlock
.a623	20 54 8d	jsr $8d54			jsr 	CheckComma
.a626	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a629	8d 3b 06	sta $063b			sta 	SoundCommandBlock+3
.a62c	a9 0f		lda #$0f			lda 	#15
.a62e	8d 3a 06	sta $063a			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a631	9c 3c 06	stz $063c			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a634	9c 3d 06	stz $063d			stz 	SoundCommandBlock+5
.a637	b1 30		lda ($30),y			lda 	(codePtr),y
.a639	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a63b	d0 10		bne $a64d			bne 	_SNDPlay
.a63d	c8		iny				iny
.a63e	20 95 9d	jsr $9d95			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a641	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a644	8d 3c 06	sta $063c			sta 	SoundCommandBlock+4
.a647	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a64a	8d 3d 06	sta $063d			sta 	SoundCommandBlock+5
.a64d					_SNDPlay:
.a64d	5a		phy				phy
.a64e	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a651	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a653	a2 38		ldx #$38			ldx 	#(SoundCommandBlock & $FF)
.a655	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a657	20 4f b9	jsr $b94f			jsr 	SNDCommand
.a65a	7a		ply				ply
.a65b	60		rts				rts
.a65c					_SndError:
.a65c	4c b7 9f	jmp $9fb7			jmp 	RangeError
.0638					SoundCommandBlock:
>0638							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a65f					StackPushByte:
.a65f	48		pha				pha 								; save byte
.a660	a5 34		lda $34				lda 	BasicStack
.a662	d0 09		bne $a66d			bne 	_SPBNoBorrow
.a664	c6 35		dec $35				dec 	BasicStack+1
.a666	48		pha				pha
.a667	a5 35		lda $35				lda 	BasicStack+1
.a669	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a66b	90 06		bcc $a673			bcc 	_SPBMemory
.a66d					_SPBNoBorrow:
.a66d	c6 34		dec $34				dec 	BasicStack
.a66f	68		pla				pla 								; get back and write
.a670	92 34		sta ($34)			sta 	(BasicStack)
.a672	60		rts				rts
.a673					_SPBMemory:
.a673	a9 12		lda #$12		lda	#18
.a675	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.a678					StackPopByte:
.a678	b2 34		lda ($34)			lda 	(BasicStack)
.a67a	e6 34		inc $34				inc 	BasicStack
.a67c	d0 02		bne $a680			bne 	_SPBNoCarry
.a67e	e6 35		inc $35				inc 	BasicStack+1
.a680					_SPBNoCarry:
.a680	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a681					StackOpen:
.a681	48		pha				pha 								; save frame byte
.a682	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a684	0a		asl a				asl 	a 							; claim twice this for storage
.a685	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a687	38		sec				sec 								; so basically subtracting from
.a688	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a68a	85 34		sta $34				sta 	basicStack
.a68c	b0 08		bcs $a696			bcs 	_SONoBorrow
.a68e	c6 35		dec $35				dec 	basicStack+1
.a690	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a692	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a694	90 04		bcc $a69a			bcc 	_SOMemory
.a696					_SONoBorrow:
.a696	68		pla				pla 								; get marker back and write at TOS
.a697	92 34		sta ($34)			sta 	(basicStack)
.a699	60		rts				rts
.a69a					_SOMemory:
.a69a	a9 12		lda #$12		lda	#18
.a69c	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.a69f					StackClose:
.a69f	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6a1	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6a3	0a		asl a				asl 	a 							; claim twice this.
.a6a4	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6a6	85 34		sta $34				sta 	basicStack
.a6a8	90 02		bcc $a6ac			bcc 	_SCExit
.a6aa	e6 35		inc $35				inc 	basicStack+1
.a6ac					_SCExit:
.a6ac	60		rts				rts
.a6ad					StackCheckFrame:
.a6ad	48		pha				pha
.a6ae					_StackRemoveLocals:
.a6ae	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6b0	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a6b2	b0 05		bcs $a6b9			bcs 	_SCNoLocal
.a6b4	20 fd 87	jsr $87fd			jsr 	LocalPopValue
.a6b7	80 f5		bra $a6ae			bra 	_StackRemoveLocals
.a6b9					_SCNoLocal:
.a6b9	68		pla				pla
.a6ba	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6bc	29 f0		and #$f0			and 	#$F0 						; check type bits
.a6be	d0 01		bne $a6c1			bne 	_SCFError 					; different, we have structures mixed up
.a6c0	60		rts				rts
.a6c1					_SCFError:
.a6c1	8a		txa				txa 								; report error X
.a6c2	4c 65 8d	jmp $8d65			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a6c5					STKSaveCodePosition:
.a6c5	5a		phy				phy
.a6c6	98		tya				tya 								; save Y
.a6c7	a0 05		ldy #$05			ldy 	#5
.a6c9	91 34		sta ($34),y			sta 	(basicStack),y
.a6cb	88		dey				dey 								; save Code Pointer
.a6cc					_STKSaveLoop:
.a6cc	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a6cf	91 34		sta ($34),y			sta 	(basicStack),y
.a6d1	88		dey				dey
.a6d2	d0 f8		bne $a6cc			bne 	_STKSaveLoop
.a6d4	7a		ply				ply
.a6d5	60		rts				rts
.a6d6					STKLoadCodePosition:
.a6d6	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a6d8					_STKLoadLoop:
.a6d8	b1 34		lda ($34),y			lda 	(basicStack),y
.a6da	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a6dd	c8		iny				iny
.a6de	c0 05		cpy #$05			cpy 	#5
.a6e0	d0 f6		bne $a6d8			bne 	_STKLoadLoop
.a6e2	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a6e4	a8		tay				tay
.a6e5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a6e6					StackReset:
.a6e6	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a6e8	85 34		sta $34				sta 	0+basicStack
.a6ea	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a6ec	85 35		sta $35				sta 	1+basicStack
.a6ee	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a6f0	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a6f2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a6f3					StringConcrete:
.a6f3	5a		phy				phy 								; save position on stack
.a6f4	20 f1 99	jsr $99f1			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a6f7	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a6fa	85 38		sta $38				sta 	zTemp1
.a6fc	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a6ff	85 39		sta $39				sta 	zTemp1+1
.a701	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a703					_SALength:
.a703	c8		iny				iny
.a704	b1 38		lda ($38),y			lda 	(zTemp1),y
.a706	d0 fb		bne $a703			bne 	_SALength
.a708	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a70a	b0 3f		bcs $a74b			bcs 	_SALengthError
.a70c	98		tya				tya 				 				; length of the new string
.a70d	18		clc				clc
.a70e	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a710	90 02		bcc $a714			bcc 	_SAHaveLength
.a712	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a714					_SAHaveLength:
.a714	48		pha				pha 								; save length.
.a715	38		sec				sec
.a716	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a718	6d 8e 04	adc $048e			adc 	StringMemory
.a71b	8d 8e 04	sta $048e			sta 	StringMemory
.a71e	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a720	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a723	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a725	6d 8f 04	adc $048f			adc 	StringMemory+1
.a728	8d 8f 04	sta $048f			sta 	StringMemory+1
.a72b	85 3b		sta $3b				sta 	zTemp2+1
.a72d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a730	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a731	38		sec				sec
.a732	e9 03		sbc #$03			sbc 	#3
.a734	92 3a		sta ($3a)			sta 	(zTemp2)
.a736	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a738	a0 01		ldy #$01			ldy 	#1
.a73a	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a73c					_SACopyNewString:
.a73c	a0 00		ldy #$00			ldy 	#0
.a73e					_SACopyNSLoop:
.a73e	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a740	c8		iny				iny 								; write two on in string storage
.a741	c8		iny				iny
.a742	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a744	88		dey				dey 								; this makes it one one.
.a745	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a747	d0 f5		bne $a73e			bne 	_SACopyNSLoop
.a749	7a		ply				ply
.a74a	60		rts				rts
.a74b					_SALengthError:
.a74b	a9 09		lda #$09		lda	#9
.a74d	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a750					StringSystemInitialise:
.a750	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a752	8d 8e 04	sta $048e			sta 	0+StringMemory
.a755	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a757	8d 8f 04	sta $048f			sta 	1+StringMemory
.a75a	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a75d	60		rts				rts
.a75e					StringSpaceInitialise:
.a75e	20 f1 99	jsr $99f1			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a761	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a763	8d 90 04	sta $0490			sta 	StringInitialised
.a766	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a769	8d 91 04	sta $0491			sta 	StringTempPointer
.a76c	ad 8f 04	lda $048f			lda 	StringMemory+1
.a76f	3a		dec a				dec 	a
.a770	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a773	60		rts				rts
.a774					StringTempAllocate:
.a774	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a776	b0 35		bcs $a7ad			bcs 	_STALength
.a778	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a77b	30 05		bmi $a782			bmi 	_STAAllocate
.a77d	48		pha				pha 								; save value to subtract.
.a77e	20 5e a7	jsr $a75e			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a781	68		pla				pla 								; restore it
.a782					_STAAllocate:
.a782	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a784	18		clc				clc  								; deliberate allows one more
.a785	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a788	8d 91 04	sta $0491			sta 	StringTempPointer
.a78b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a78e	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a790	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a793	69 ff		adc #$ff			adc 	#$FF
.a795	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a798	85 3d		sta $3d				sta 	zsTemp+1
.a79a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a79d	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a7a0	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a7a3	a9 10		lda #$10			lda 	#NSTString
.a7a5	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a7a8	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7aa	92 3c		sta ($3c)			sta 	(zsTemp)
.a7ac	60		rts				rts
.a7ad					_STALength:
.a7ad	a9 09		lda #$09		lda	#9
.a7af	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.a7b2					StringTempWrite:
.a7b2	48		pha				pha
.a7b3	92 3c		sta ($3c)			sta 	(zsTemp)
.a7b5	e6 3c		inc $3c				inc 	zsTemp
.a7b7	d0 02		bne $a7bb			bne 	_STWNoCarry
.a7b9	e6 3d		inc $3d				inc 	zsTemp+1
.a7bb					_STWNoCarry:
.a7bb	a9 00		lda #$00			lda 	#0
.a7bd	92 3c		sta ($3c)			sta 	(zsTemp)
.a7bf	68		pla				pla
.a7c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7c1					EXTPrintCharacter:
.a7c1	48		pha				pha
.a7c2	da		phx				phx
.a7c3	5a		phy				phy
.a7c4	a6 01		ldx $01				ldx 	1
.a7c6	da		phx				phx
.a7c7	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a7ca	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a7cc	30 48		bmi $a816			bmi 	_EXPCColour
.a7ce	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a7d0	90 4d		bcc $a81f			bcc 	_EXPCControl
.a7d2	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a7d4	86 01		stx $01				stx 	1
.a7d6	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7d8	e6 01		inc $01				inc 	1 							; select colour memory
.a7da	ad 40 06	lda $0640			lda 	EXTTextColour
.a7dd	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7df	c8		iny				iny 								; advance horizontal position
.a7e0	8c 3f 06	sty $063f			sty 	EXTColumn
.a7e3	cc 41 06	cpy $0641			cpy 	EXTScreenWidth 				; reached RHS ?
.a7e6	90 66		bcc $a84e			bcc 	_EXPCExit 					; no, then exit.
.a7e8					_EXPCCRLF:
.a7e8	ee 3e 06	inc $063e			inc 	EXTRow  					; bump row
.a7eb	9c 3f 06	stz $063f			stz 	EXTColumn 					; back to column 0
.a7ee	ad 3e 06	lda $063e			lda 	EXTRow 						; check if reached the bottom ?
.a7f1	cd 42 06	cmp $0642			cmp 	EXTScreenHeight 			; if so, then scroll.
.a7f4	f0 18		beq $a80e			beq 	_EXPCScroll
.a7f6	18		clc				clc 								; add width to address.
.a7f7	a5 40		lda $40				lda 	EXTAddress
.a7f9	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a7fc	85 40		sta $40				sta 	EXTAddress
.a7fe	90 4e		bcc $a84e			bcc 	_EXPCExit
.a800	e6 41		inc $41				inc 	EXTAddress+1
.a802	80 4a		bra $a84e			bra 	_EXPCExit
.a804					_EXPCLeft:
.a804	ce 3f 06	dec $063f			dec 	EXTColumn
.a807	10 45		bpl $a84e			bpl 	_EXPCExit
.a809					_EXPCBegin:
.a809	9c 3f 06	stz $063f			stz 	EXTColumn
.a80c	80 40		bra $a84e			bra 	_EXPCExit
.a80e					_EXPCScroll:
.a80e	ce 3e 06	dec $063e			dec 	EXTRow 						; the height-1 th line.
.a811	20 db a8	jsr $a8db			jsr 	EXTScreenScroll 			; scroll the screen
.a814	80 38		bra $a84e			bra 	_EXPCExit
.a816					_EXPCColour:
.a816	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a818	b0 34		bcs $a84e			bcs 	_EXPCExit
.a81a	20 bb a8	jsr $a8bb			jsr 	_EXPCHandleColour
.a81d	80 2f		bra $a84e			bra 	_EXPCExit
.a81f					_EXPCControl:
.a81f	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a821	b0 2b		bcs $a84e			bcs 	_EXPCExit
.a823	0a		asl a				asl 	a 							; double into X
.a824	aa		tax				tax
.a825	7c 99 a8	jmp ($a899,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a828					_EXPCUp:
.a828	ad 3e 06	lda $063e			lda 	EXTRow 						; already at top ?
.a82b	f0 21		beq $a84e			beq 	_EXPCExit
.a82d	ce 3e 06	dec $063e			dec 	EXTRow 						; up one in position/address
.a830	38		sec				sec
.a831	a5 40		lda $40				lda 	EXTAddress
.a833	ed 41 06	sbc $0641			sbc 	EXTScreenWidth
.a836	85 40		sta $40				sta 	EXTAddress
.a838	b0 14		bcs $a84e			bcs 	_EXPCExit
.a83a	c6 41		dec $41				dec 	EXTAddress+1
.a83c	80 10		bra $a84e			bra 	_EXPCExit
.a83e					_EXPCRight:
.a83e	c8		iny				iny
.a83f	8c 3f 06	sty $063f			sty 	EXTColumn
.a842	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a845	d0 07		bne $a84e			bne 	_EXPCExit
.a847					_EXPCEnd:
.a847	ad 41 06	lda $0641			lda 	EXTScreenWidth
.a84a	3a		dec a				dec 	a
.a84b	8d 3f 06	sta $063f			sta 	EXTColumn
.a84e					_EXPCExit:
.a84e	20 30 a9	jsr $a930			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a851	68		pla				pla
.a852	85 01		sta $01				sta 	1
.a854	7a		ply				ply
.a855	fa		plx				plx
.a856	68		pla				pla
.a857	60		rts				rts
.a858					_EXPCClearScreen:
.a858	20 ed a8	jsr $a8ed			jsr		EXTClearScreenCode
.a85b	80 f1		bra $a84e			bra 	_EXPCExit
.a85d					_EXPCDown:
.a85d	ad 42 06	lda $0642			lda 	EXTScreenHeight 			; at the bottom
.a860	3a		dec a				dec 	a
.a861	cd 3e 06	cmp $063e			cmp 	EXTRow
.a864	f0 e8		beq $a84e			beq 	_EXPCExit
.a866	ee 3e 06	inc $063e			inc 	EXTRow 						; down one in position/address
.a869	18		clc				clc
.a86a	a5 40		lda $40				lda 	EXTAddress
.a86c	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a86f	85 40		sta $40				sta 	EXTAddress
.a871	90 db		bcc $a84e			bcc 	_EXPCExit
.a873	e6 41		inc $41				inc 	EXTAddress+1
.a875	80 d7		bra $a84e			bra 	_EXPCExit
.a877					_EXPCTab:
.a877	ad 3f 06	lda $063f			lda 	EXTColumn 					; next tab stop
.a87a	29 f8		and #$f8			and 	#$F8
.a87c	18		clc				clc
.a87d	69 08		adc #$08			adc 	#8
.a87f	8d 3f 06	sta $063f			sta 	EXTColumn
.a882	cd 41 06	cmp $0641			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a885	90 c7		bcc $a84e			bcc 	_EXPCExit
.a887	80 be		bra $a847			bra 	_EXPCEnd
.a889					_EXPCBackSpace:
.a889	88		dey				dey
.a88a	30 c2		bmi $a84e			bmi 	_EXPCExit
.a88c	ce 3f 06	dec $063f			dec 	EXTColumn
.a88f	a9 02		lda #$02			lda 	#2
.a891	85 01		sta $01				sta 	1
.a893	a9 20		lda #$20			lda 	#32
.a895	91 40		sta ($40),y			sta 	(EXTAddress),y
.a897	80 b5		bra $a84e			bra 	_EXPCExit
.a899					_EXPCActionTable:
>a899	4e a8						.word 	_EXPCExit 					; 00
>a89b	09 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a89d	04 a8						.word 	_EXPCLeft 					; 02 B Left
>a89f	4e a8						.word 	_EXPCExit 					; 03 <Break>
>a8a1	4e a8						.word 	_EXPCExit 					; 04
>a8a3	47 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a8a5	3e a8						.word 	_EXPCRight 					; 06 F Right
>a8a7	4e a8						.word 	_EXPCExit 					; 07
>a8a9	89 a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a8ab	77 a8						.word 	_EXPCTab 					; 09 I Tab
>a8ad	4e a8						.word 	_EXPCExit 					; 0A
>a8af	4e a8						.word 	_EXPCExit 					; 0B
>a8b1	58 a8						.word 	_EXPCClearScreen			; 0C L CLS
>a8b3	e8 a7						.word 	_EXPCCRLF 					; 0D M CR/LF
>a8b5	5d a8						.word 	_EXPCDown 					; 0E N Down
>a8b7	4e a8						.word 	_EXPCExit 					; 0F
>a8b9	28 a8						.word 	_EXPCUp 					; 10 P Up
.a8bb					_EXPCHandleColour
.a8bb	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a8bd	b0 16		bcs $a8d5			bcs 	_EXPCBackground
.a8bf	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a8c0	0a		asl a				asl 	a
.a8c1	0a		asl a				asl 	a
.a8c2	0a		asl a				asl 	a
.a8c3	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a8c5					_EXPCUpdate:
.a8c5	48		pha				pha 								; save new colour
.a8c6	8a		txa				txa 								; get mask
.a8c7	2d 40 06	and $0640			and 	EXTTextColour 				; mask out old.
.a8ca	8d 40 06	sta $0640			sta 	EXTTextColour
.a8cd	68		pla				pla 								; or in new colour
.a8ce	0d 40 06	ora $0640			ora 	EXTTextColour
.a8d1	8d 40 06	sta $0640			sta 	EXTTextColour
.a8d4	60		rts				rts
.a8d5					_EXPCBackground:
.a8d5	29 0f		and #$0f			and 	#$0F 						; get the colour
.a8d7	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a8d9	80 ea		bra $a8c5			bra 	_EXPCUpdate
.a8db					EXTScreenScroll:
.a8db	a9 02		lda #$02			lda 	#2 							; select text page
.a8dd	85 01		sta $01				sta 	1
.a8df	a9 20		lda #$20			lda		#32 						; fill with space
.a8e1	20 f0 a9	jsr $a9f0			jsr 	EXTScrollFill
.a8e4	e6 01		inc $01				inc 	1 							; select colour page
.a8e6	ad 40 06	lda $0640			lda 	EXTTextColour
.a8e9	20 f0 a9	jsr $a9f0			jsr 	EXTScrollFill
.a8ec	60		rts				rts
.a8ed					EXTClearScreenCode:
.a8ed	a9 02		lda #$02			lda 	#2 							; select text page
.a8ef	85 01		sta $01				sta 	1
.a8f1	a9 20		lda #$20			lda		#32 						; fill with space
.a8f3	20 00 a9	jsr $a900			jsr 	_EXTCSFill
.a8f6	e6 01		inc $01				inc 	1 							; select colour page
.a8f8	ad 40 06	lda $0640			lda 	EXTTextColour
.a8fb	20 00 a9	jsr $a900			jsr 	_EXTCSFill
.a8fe	80 22		bra $a922			bra 	EXTHomeCursor
.a900					_EXTCSFill:
.a900	aa		tax				tax
.a901	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a903	85 40		sta $40				sta 	EXTAddress
.a905	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a907	85 41		sta $41				sta 	EXTAddress+1
.a909					_EXTCSFill1:
.a909	a0 00		ldy #$00			ldy 	#0
.a90b	8a		txa				txa
.a90c					_EXTCSFill2:
.a90c	91 40		sta ($40),y			sta 	(EXTAddress),y
.a90e	c8		iny				iny
.a90f	d0 fb		bne $a90c			bne 	_EXTCSFill2
.a911	e6 41		inc $41				inc 	EXTAddress+1
.a913	a5 41		lda $41				lda 	EXTAddress+1
.a915	c9 d2		cmp #$d2			cmp 	#$D2
.a917	d0 f0		bne $a909			bne 	_EXTCSFill1
.a919	8a		txa				txa
.a91a					_EXTCSFill3:
.a91a	91 40		sta ($40),y			sta 	(EXTAddress),y
.a91c	c8		iny				iny
.a91d	c0 c0		cpy #$c0			cpy 	#$C0
.a91f	d0 f9		bne $a91a			bne 	_EXTCSFill3
.a921	60		rts				rts
.a922					EXTHomeCursor:
.a922	9c 3e 06	stz $063e			stz 	EXTRow 						; reset row & column
.a925	9c 3f 06	stz $063f			stz 	EXTColumn
.a928	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a92a	85 40		sta $40				sta 	EXTAddress
.a92c	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a92e	85 41		sta $41				sta 	EXTAddress+1
.a930					EXTSetHardwareCursor:
.a930	64 01		stz $01				stz 	1 							; I/O Page zero
.a932	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a934	8d 10 d0	sta $d010			sta 	$D010
.a937	a9 b1		lda #$b1			lda 	#$B1
.a939	8d 12 d0	sta $d012			sta 	$D012
.a93c	ad 3f 06	lda $063f			lda 	EXTColumn
.a93f	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a942	9c 15 d0	stz $d015			stz 	$D015
.a945	ad 3e 06	lda $063e			lda 	EXTRow
.a948	8d 16 d0	sta $d016			sta 	$D016
.a94b	9c 17 d0	stz $d017			stz 	$D017
.a94e	60		rts				rts
.a94f					EXTInputLine:
.a94f	48		pha				pha
.a950	da		phx				phx
.a951	5a		phy				phy
.a952	a5 01		lda $01				lda 	1 							; save I/O page
.a954	48		pha				pha
.a955					_EILLoop:
.a955	20 57 aa	jsr $aa57			jsr 	ExtInputSingleCharacter
.a958	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a95a	f0 40		beq $a99c			beq 	_EILExit
.a95c	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a95e	f0 1c		beq $a97c			beq 	_EILBackspace
.a960	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a962	90 12		bcc $a976			bcc 	_EILPrintLoop
.a964	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a966	b0 0e		bcs $a976			bcs 	_EILPrintLoop
.a968	48		pha				pha 								; save character
.a969	a9 02		lda #$02			lda 	#2  						; insert a space
.a96b	85 01		sta $01				sta 	1
.a96d	20 de a9	jsr $a9de			jsr 	EXTILInsert 				; insert in text screen
.a970	e6 01		inc $01				inc 	1
.a972	20 de a9	jsr $a9de			jsr 	EXTILInsert 				; insert in colour screen
.a975	68		pla				pla 								; get character back.
.a976					_EILPrintLoop:
.a976	20 c1 a7	jsr $a7c1			jsr 	ExtPrintCharacter
.a979	80 da		bra $a955			bra 	_EILLoop
.a97b	60		rts				rts
.a97c					_EILBackspace:
.a97c	ad 3f 06	lda $063f			lda 	EXTColumn					; can we backspace ?
.a97f	f0 d4		beq $a955			beq 	_EILLoop
.a981	a9 02		lda #$02			lda 	#2 							; move cursor left
.a983	20 c1 a7	jsr $a7c1			jsr 	EXTPrintCharacter
.a986	a9 02		lda #$02			lda 	#2 							; text block
.a988	85 01		sta $01				sta 	1
.a98a	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a98c	20 c9 a9	jsr $a9c9			jsr 	EXTILDelete
.a98f	e6 01		inc $01				inc 	1 							; colour block
.a991	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; get attribute of last character
.a994	88		dey				dey
.a995	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a997	20 c9 a9	jsr $a9c9			jsr 	EXTILDelete 				; backspace attribute
.a99a	80 b9		bra $a955			bra 	_EILLoop 					; and go round.
.a99c					_EILExit:
.a99c	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a99e	85 01		sta $01				sta 	1
.a9a0	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a9a2					_EILScrapeLine:
.a9a2	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9a4	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9a7	c8		iny				iny
.a9a8	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9ab	d0 f5		bne $a9a2			bne 	_EILScrapeLine
.a9ad					_EILTrimSpaces:
.a9ad	88		dey				dey
.a9ae	f0 08		beq $a9b8			beq 	_EILEndTrim
.a9b0	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.a9b3	c9 20		cmp #$20			cmp 	#' '
.a9b5	f0 f6		beq $a9ad			beq 	_EILTrimSpaces
.a9b7	c8		iny				iny 								; trim after non space character.
.a9b8					_EILEndTrim:
.a9b8	a9 00		lda #$00			lda 	#0 							; trim here.
.a9ba	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9bd	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a9bf	20 c1 a7	jsr $a7c1			jsr 	ExtPrintCharacter
.a9c2	68		pla				pla 								; reset I/O page
.a9c3	85 01		sta $01				sta 	1
.a9c5	7a		ply				ply
.a9c6	fa		plx				plx
.a9c7	68		pla				pla
.a9c8	60		rts				rts
.a9c9					EXTILDelete:
.a9c9	48		pha				pha 								; save the new character
.a9ca	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; start copying from here.
.a9cd					_EXTDLoop:
.a9cd	c8		iny				iny 								; copy one byte down.
.a9ce	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9d0	88		dey				dey
.a9d1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9d3	c8		iny				iny 								; do till end of line.
.a9d4	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9d7	90 f4		bcc $a9cd			bcc 	_EXTDLoop
.a9d9	88		dey				dey 	 							; write in last slot.
.a9da	68		pla				pla
.a9db	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9dd	60		rts				rts
.a9de					EXTILInsert:
.a9de	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; end position
.a9e1					_EXTILoop:
.a9e1	88		dey				dey 								; back one
.a9e2	cc 3f 06	cpy $063f			cpy 	EXTColumn 					; exit if reached insert point.
.a9e5	f0 08		beq $a9ef			beq 	_EXTIExit
.a9e7	88		dey				dey 								; copy one byte up.
.a9e8	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9ea	c8		iny				iny
.a9eb	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9ed	80 f2		bra $a9e1			bra 	_EXTILoop
.a9ef					_EXTIExit:
.a9ef	60		rts				rts
.a9f0					EXTScrollFill:
.a9f0	aa		tax				tax									; save value to fill with
.a9f1	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a9f3	48		pha				pha
.a9f4	a5 37		lda $37				lda 	zTemp0+1
.a9f6	48		pha				pha
.a9f7	a5 38		lda $38				lda 	zTemp1
.a9f9	48		pha				pha
.a9fa	a5 39		lda $39				lda 	zTemp1+1
.a9fc	48		pha				pha
.a9fd	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.a9ff	85 37		sta $37				sta 	zTemp0+1
.aa01	85 39		sta $39				sta 	zTemp1+1
.aa03	64 36		stz $36				stz 	zTemp0
.aa05	ad 41 06	lda $0641			lda 	EXTScreenWidth
.aa08	85 38		sta $38				sta 	zTemp1
.aa0a	a0 00		ldy #$00			ldy 	#0
.aa0c					_EXSFCopy1:
.aa0c	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa0e	91 36		sta ($36),y			sta 	(zTemp0),y
.aa10	c8		iny				iny
.aa11	d0 f9		bne $aa0c			bne 	_EXSFCopy1
.aa13	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa15	e6 39		inc $39				inc 	zTemp1+1
.aa17	a5 39		lda $39				lda 	zTemp1+1
.aa19	c9 d3		cmp #$d3			cmp 	#$D3
.aa1b	d0 ef		bne $aa0c			bne 	_EXSFCopy1
.aa1d	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa20	8a		txa				txa
.aa21					_EXSFFill1:
.aa21	88		dey				dey
.aa22	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa24	c0 00		cpy #$00			cpy 	#0
.aa26	10 f9		bpl $aa21			bpl 	_EXSFFill1
.aa28	68		pla				pla
.aa29	85 39		sta $39				sta 	zTemp1+1
.aa2b	68		pla				pla
.aa2c	85 38		sta $38				sta 	zTemp1
.aa2e	68		pla				pla
.aa2f	85 37		sta $37				sta 	zTemp0+1
.aa31	68		pla				pla
.aa32	85 36		sta $36				sta 	zTemp0
.aa34	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063e					EXTRow:
>063e							.fill 	1
.063f					EXTColumn:
>063f							.fill 	1
.0640					EXTTextColour:
>0640							.fill 	1
.0641					EXTScreenWidth:
>0641							.fill 	1
.0642					EXTScreenHeight:
>0642							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa35					EXTInitialise:
.aa35	64 01		stz $01				stz 	1 							; Access I/O
.aa37	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa3a	9c 08 d0	stz $d008			stz 	$D008
.aa3d	9c 09 d0	stz $d009			stz 	$D009
.aa40	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aa42	8d 58 d6	sta $d658			sta 	$D658
.aa45	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.aa47	8d 40 06	sta $0640			sta 	EXTTextColour
.aa4a	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aa4c	8d 41 06	sta $0641			sta 	EXTScreenWidth
.aa4f	a9 3c		lda #$3c			lda 	#60
.aa51	8d 42 06	sta $0642			sta 	EXTScreenHeight
.aa54	64 01		stz $01				stz 	1
.aa56	60		rts				rts
.aa57					EXTInputSingleCharacter:
.aa57	da		phx				phx
.aa58	5a		phy				phy
.aa59					_EISCWait:
.aa59	64 01		stz $01				stz 	1 							; access I/O Page 0
.aa5b	38		sec				sec 								; calculate timer - LastTick
.aa5c	ad 59 d6	lda $d659			lda 	$D659
.aa5f	aa		tax				tax 								; saving timer in X
.aa60	ed 2d 06	sbc $062d			sbc 	LastTick
.aa63	c9 03		cmp #$03			cmp 	#3
.aa65	90 06		bcc $aa6d			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aa67	8e 2d 06	stx $062d			stx 	LastTick 					; update last timer
.aa6a	20 d7 b9	jsr $b9d7			jsr 	TickHandler 				; go do the code.
.aa6d					_NoFireTick:
.aa6d	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.aa70	c9 00		cmp #$00			cmp 	#0
.aa72	f0 e5		beq $aa59			beq 	_EISCWait
.aa74	7a		ply				ply
.aa75	fa		plx				plx
.aa76	60		rts				rts
.aa77					EXTBreakCheck:
.aa77	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aa7a					EXTReadController:
.aa7a	da		phx				phx
.aa7b	a2 00		ldx #$00			ldx 	#0
.aa7d	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aa7f	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa82	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aa84	f0 04		beq $aa8a			beq 	_NoSet1
.aa86	8a		txa				txa
.aa87	09 01		ora #$01			ora 	#1
.aa89	aa		tax				tax
.aa8a					_NoSet1:
.aa8a	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aa8c	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa8f	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aa91	f0 04		beq $aa97			beq 	_NoSet1
.aa93	8a		txa				txa
.aa94	09 02		ora #$02			ora 	#2
.aa96	aa		tax				tax
.aa97					_NoSet1:
.aa97	a9 06		lda #$06			lda 	#(($32) >> 3)
.aa99	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa9c	29 04		and #$04			and 	#($01 << (($32) & 7))
.aa9e	f0 04		beq $aaa4			beq 	_NoSet1
.aaa0	8a		txa				txa
.aaa1	09 04		ora #$04			ora 	#4
.aaa3	aa		tax				tax
.aaa4					_NoSet1:
.aaa4	a9 04		lda #$04			lda 	#(($25) >> 3)
.aaa6	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaa9	29 20		and #$20			and 	#($01 << (($25) & 7))
.aaab	f0 04		beq $aab1			beq 	_NoSet1
.aaad	8a		txa				txa
.aaae	09 08		ora #$08			ora 	#8
.aab0	aa		tax				tax
.aab1					_NoSet1:
.aab1	a9 04		lda #$04			lda 	#(($26) >> 3)
.aab3	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aab6	29 40		and #$40			and 	#($01 << (($26) & 7))
.aab8	f0 04		beq $aabe			beq 	_NoSet1
.aaba	8a		txa				txa
.aabb	09 10		ora #$10			ora 	#16
.aabd	aa		tax				tax
.aabe					_NoSet1:
.aabe	8a		txa				txa
.aabf	fa		plx				plx
.aac0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.b9dd					GRVectorTable:
>b9dd	bc ac					.word	GXInitialise             ; $00 Initialise
>b9df	d6 ac					.word	GXControlBitmap          ; $01 BitmapCtl
>b9e1	1e ad					.word	GXControlSprite          ; $02 SpriteCtl
>b9e3	6e ac					.word	GXClearBitmap            ; $03 Clear
>b9e5	ad ae					.word	GXSetColourMode          ; $04 Colour
>b9e7	75 b0					.word	GXFontHandler            ; $05 DrawFont
>b9e9	bd b0					.word	GXSpriteHandler          ; $06 DrawSprite
>b9eb	29 b1					.word	GXSelect                 ; $07 SpriteUse
>b9ed	52 b1					.word	GXSelectImage            ; $08 SpriteImage
>b9ef	d9 b2					.word	GXCollide                ; $09 SpriteCollide
>b9f1	20 ab					.word	GRUndefined              ; $0a
>b9f3	20 ab					.word	GRUndefined              ; $0b
>b9f5	20 ab					.word	GRUndefined              ; $0c
>b9f7	20 ab					.word	GRUndefined              ; $0d
>b9f9	20 ab					.word	GRUndefined              ; $0e
>b9fb	20 ab					.word	GRUndefined              ; $0f
>b9fd	20 ab					.word	GRUndefined              ; $10
>b9ff	20 ab					.word	GRUndefined              ; $11
>ba01	20 ab					.word	GRUndefined              ; $12
>ba03	20 ab					.word	GRUndefined              ; $13
>ba05	20 ab					.word	GRUndefined              ; $14
>ba07	20 ab					.word	GRUndefined              ; $15
>ba09	20 ab					.word	GRUndefined              ; $16
>ba0b	20 ab					.word	GRUndefined              ; $17
>ba0d	20 ab					.word	GRUndefined              ; $18
>ba0f	20 ab					.word	GRUndefined              ; $19
>ba11	20 ab					.word	GRUndefined              ; $1a
>ba13	20 ab					.word	GRUndefined              ; $1b
>ba15	20 ab					.word	GRUndefined              ; $1c
>ba17	20 ab					.word	GRUndefined              ; $1d
>ba19	20 ab					.word	GRUndefined              ; $1e
>ba1b	20 ab					.word	GRUndefined              ; $1f
>ba1d	1e ab					.word	GXMove                   ; $20 Move
>ba1f	7b ad					.word	GXLine                   ; $21 Line
>ba21	f6 ae					.word	GXFrameRectangle         ; $22 FrameRect
>ba23	f3 ae					.word	GXFillRectangle          ; $23 FillRect
>ba25	25 ab					.word	GXFrameCircle            ; $24 FrameCircle
>ba27	21 ab					.word	GXFillCircle             ; $25 FillCircle
>ba29	20 ab					.word	GRUndefined              ; $26
>ba2b	20 ab					.word	GRUndefined              ; $27
>ba2d	db ae					.word	GXPlotPoint              ; $28 Plot
>ba2f	e8 b1					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5f9					gxPixelBuffer = numberBuffer
.0643					gxCurrentX:
>0643							.fill 	2
.0645					gxCurrentY:
>0645							.fill 	2
.0647					gxLastX:
>0647							.fill 	2
.0649					gxLastY:
>0649							.fill 	2
.064b					gxX0:
>064b							.fill 	2
.064d					gxY0:
>064d							.fill 	2
.064f					gxX1:
>064f							.fill 	2
.0651					gxY1:
>0651							.fill 	2
.0653					gxSpritesOn:
>0653							.fill 	1
.0654					gxBitmapsOn:
>0654							.fill 	1
.0655					gxBasePage:
>0655							.fill 	1
.0656					gxSpritePage:
>0656							.fill 	1
.0657					gxHeight:
>0657							.fill 	1
.0658					gxMode:
>0658							.fill 	1
.0659					gxColour:
>0659							.fill 	1
.065a					gxEORValue:
>065a							.fill 	1
.065b					gxANDValue:
>065b							.fill 	1
.065c					gxOriginalLUTValue:
>065c							.fill 	1
.065d					gsOffset:
>065d							.fill 	1
.065e					GSCurrentSpriteID:
>065e							.fill 	1
.065f					GSCurrentSpriteAddr:
>065f							.fill 	2
.0661					GXSpriteOffsetBase:
>0661							.fill 	2
.0663					GXSpriteLow:
>0663							.fill 	64
.06a3					GXSpriteHigh:
>06a3							.fill 	64
.aac1					GXGraphicDraw:
.aac1	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aac3	b0 06		bcs $aacb			bcs 	_GDCoordinate
.aac5	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aac7	84 37		sty $37				sty 	gxzTemp0+1
.aac9	80 4b		bra $ab16			bra 	_GDExecuteA 				; and execute
.aacb					_GDCoordinate:
.aacb	48		pha				pha 								; save AXY
.aacc	da		phx				phx
.aacd	5a		phy				phy
.aace	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aad0					_GDCopy1:
.aad0	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.aad3	9d 47 06	sta $0647,x			sta 	gxLastX,x
.aad6	ca		dex				dex
.aad7	10 f7		bpl $aad0			bpl 	_GDCopy1
.aad9	68		pla				pla 								; update Y
.aada	8d 45 06	sta $0645			sta 	gxCurrentY
.aadd	9c 46 06	stz $0646			stz 	gxCurrentY+1
.aae0	68		pla				pla
.aae1	8d 43 06	sta $0643			sta 	gxCurrentX
.aae4	68		pla				pla 								; get A (command+X.1) back
.aae5	48		pha				pha
.aae6	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aae8	8d 44 06	sta $0644			sta 	gxCurrentX+1
.aaeb	68		pla				pla 								; get command back
.aaec	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aaee	48		pha				pha 								; push back.
.aaef	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aaf1	f0 17		beq $ab0a			beq 	_GDCopyToWorkArea
.aaf3	ad 44 06	lda $0644			lda 	gxCurrentX+1 				; X < 256 X okay
.aaf6	f0 07		beq $aaff			beq 	_GDCheckY
.aaf8	ad 43 06	lda $0643			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aafb	c9 40		cmp #$40			cmp 	#64
.aafd	b0 08		bcs $ab07			bcs 	_GDError1
.aaff					_GDCheckY:
.aaff	ad 45 06	lda $0645			lda 	gxCurrentY 					; check Y < Height.
.ab02	cd 57 06	cmp $0657			cmp 	gxHeight
.ab05	90 03		bcc $ab0a			bcc 	_GDCopyToWorkArea
.ab07					_GDError1:
.ab07	68		pla				pla
.ab08					_GDError2:
.ab08	38		sec				sec
.ab09	60		rts				rts
.ab0a					_GDCopyToWorkArea:
.ab0a	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.ab0c					_GDCopy2:
.ab0c	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.ab0f	9d 4b 06	sta $064b,x			sta 	gxX0,x
.ab12	ca		dex				dex
.ab13	10 f7		bpl $ab0c			bpl 	_GDCopy2
.ab15	68		pla				pla 								; get command
.ab16					_GDExecuteA:
.ab16	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.ab18	b0 ee		bcs $ab08			bcs 	_GDError2
.ab1a	aa		tax				tax
.ab1b	7c dd b9	jmp ($b9dd,x)			jmp 	(GRVectorTable,x)
.ab1e					GXMove:
.ab1e	18		clc				clc
.ab1f	60		rts				rts
.ab20					GRUndefined:
>ab20	db						.byte 	$DB 						; causes a break in the emulator
.ab21					GXFillCircle:
.ab21	a9 ff		lda #$ff			lda 	#255
.ab23	80 02		bra $ab27			bra 	GXCircle
.ab25					GXFrameCircle:
.ab25	a9 00		lda #$00			lda 	#0
.ab27					GXCircle:
.ab27	8d e6 06	sta $06e6			sta 	gxIsFillMode					; save Fill flag
.ab2a	ad 54 06	lda $0654			lda 	gxBitmapsOn
.ab2d	f0 26		beq $ab55			beq 	_GXCFail
.ab2f	20 80 b3	jsr $b380			jsr 	GXSortXY 					; topleft/bottomright
.ab32	20 58 b2	jsr $b258			jsr 	GXOpenBitmap 				; start drawing
.ab35	20 27 ac	jsr $ac27			jsr 	GXCircleSetup 				; set up for drawing
.ab38	9c e7 06	stz $06e7			stz 	gxYChanged
.ab3b					_GXCircleDraw:
.ab3b	ad e4 06	lda $06e4			lda 	gXCentre					; while x <= y
.ab3e	cd e5 06	cmp $06e5			cmp 	gYCentre
.ab41	90 0a		bcc $ab4d			bcc 	_GXCircleContinue
.ab43	d0 03		bne $ab48			bne 	_GXNoLast
.ab45	20 5a ab	jsr $ab5a			jsr 	GXPlot1
.ab48					_GXNoLast:
.ab48	20 60 b2	jsr $b260			jsr 	GXCloseBitmap 				; close the bitmap
.ab4b	18		clc				clc
.ab4c	60		rts				rts
.ab4d					_GXCircleContinue:
.ab4d	20 57 ab	jsr $ab57			jsr 	GXPlot2 					; draw it
.ab50	20 d4 ab	jsr $abd4			jsr 	GXCircleMove 				; adjust the coordinates
.ab53	80 e6		bra $ab3b			bra 	_GXCircleDraw
.ab55					_GXCFail:
.ab55	38		sec				sec
.ab56	60		rts				rts
.ab57					GXPlot2:
.ab57	20 5a ab	jsr $ab5a			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ab5a					GXPlot1:
.ab5a	ad e5 06	lda $06e5			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ab5d	f0 03		beq $ab62			beq 	_GXPlot1Only
.ab5f	20 7e ab	jsr $ab7e			jsr 	GXPlot0 						; plot and negate
.ab62					_GXPlot1Only:
.ab62	20 7e ab	jsr $ab7e			jsr 	GXPlot0 						; twice, undoing negation
.ab65	ad e4 06	lda $06e4			lda 	gXCentre 						; swap X and Y
.ab68	ae e5 06	ldx $06e5			ldx	 	gYCentre
.ab6b	8d e5 06	sta $06e5			sta 	gYCentre
.ab6e	8e e4 06	stx $06e4			stx 	gXCentre
.ab71	ad e7 06	lda $06e7			lda 	gxYChanged 						; toggle Y Changed flag
.ab74	a9 ff		lda #$ff			lda 	#$FF
.ab76	8d e7 06	sta $06e7			sta 	gxYChanged
.ab79	60		rts				rts
.ab7a	20 7e ab	jsr $ab7e			jsr 	GXPlot0 						; do once
.ab7d	60		rts				rts
.ab7e	ad e6 06	lda $06e6	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ab81	f0 05		beq $ab88			beq 	_GXPlot0Always
.ab83	ad e7 06	lda $06e7			lda 	gxYChanged						; fill mode, only draw if changed.
.ab86	f0 2d		beq $abb5			beq 	GXPlot0Exit
.ab88					_GXPlot0Always:
.ab88	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ab8a	ad e5 06	lda $06e5			lda 	gYCentre
.ab8d	20 b6 ab	jsr $abb6			jsr 	GXSubCopy
.ab90	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ab92	ad e4 06	lda $06e4			lda 	gXCentre
.ab95	20 b6 ab	jsr $abb6			jsr 	GXSubCopy
.ab98	48		pha				pha 									; save last offset X
.ab99	20 68 b2	jsr $b268			jsr 	GXPositionCalc 					; calculate position/offset.
.ab9c	68		pla				pla
.ab9d	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ab9e	85 36		sta $36				sta 	gxzTemp0
.aba0	64 37		stz $37				stz 	gxzTemp0+1
.aba2	26 37		rol $37				rol 	gxzTemp0+1
.aba4	ad e6 06	lda $06e6			lda 	gxIsFillMode
.aba7	69 80		adc #$80			adc 	#128
.aba9	20 46 af	jsr $af46			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.abac	38		sec				sec 									; GY = -GY
.abad	a9 00		lda #$00			lda 	#0
.abaf	ed e5 06	sbc $06e5			sbc 	gYCentre
.abb2	8d e5 06	sta $06e5			sta 	gYCentre
.abb5					GXPlot0Exit:
.abb5	60		rts				rts
.abb6					GXSubCopy:
.abb6	85 36		sta $36				sta 	gxzTemp0
.abb8	64 37		stz $37				stz 	gxzTemp0+1
.abba	29 80		and #$80			and 	#$80
.abbc	f0 02		beq $abc0			beq 	_GXNoSx
.abbe	c6 37		dec $37				dec 	gxzTemp0+1
.abc0					_GXNoSx:
.abc0	38		sec				sec
.abc1	bd 4f 06	lda $064f,x			lda 	gXX1,x
.abc4	e5 36		sbc $36				sbc 	gxzTemp0
.abc6	9d 4b 06	sta $064b,x			sta 	gXX0,x
.abc9	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.abcc	e5 37		sbc $37				sbc 	gxzTemp0+1
.abce	9d 4c 06	sta $064c,x			sta 	gXX0+1,x
.abd1	a5 36		lda $36				lda 	gxzTemp0 						; return A
.abd3	60		rts				rts
.abd4					GXCircleMove:
.abd4	9c e7 06	stz $06e7			stz 	gxYChanged 					; clear Y changed flag
.abd7	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.abd9	10 0d		bpl $abe8			bpl 	_GXEMPositive
.abdb	ee e4 06	inc $06e4			inc 	gXCentre 					; X++
.abde	ad e4 06	lda $06e4			lda 	gXCentre
.abe1	20 07 ac	jsr $ac07			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abe4	a9 06		lda #$06			lda 	#6  						; and add 6
.abe6	80 15		bra $abfd			bra 	_GXEMAddD
.abe8					_GXEMPositive:
.abe8	ee e4 06	inc $06e4			inc 	gXCentre					; X++
.abeb	ce e5 06	dec $06e5			dec 	gyCentre 					; Y--
.abee	38		sec				sec 								; calculate X-Y
.abef	ad e4 06	lda $06e4			lda 	gXCentre
.abf2	ed e5 06	sbc $06e5			sbc 	gYCentre
.abf5	20 07 ac	jsr $ac07			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abf8	a9 0a		lda #$0a			lda 	#10  						; and add 10
.abfa	ce e7 06	dec $06e7			dec 	gxYChanged
.abfd					_GXEMAddD:
.abfd	18		clc				clc
.abfe	65 38		adc $38				adc 	gxzTemp1
.ac00	85 38		sta $38				sta 	gxzTemp1
.ac02	90 02		bcc $ac06			bcc 	_GXEMNoCarry
.ac04	e6 39		inc $39				inc 	gxzTemp1+1
.ac06					_GXEMNoCarry:
.ac06	60		rts				rts
.ac07					_GXAdd4TimesToD:
.ac07	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.ac09	29 80		and #$80			and 	#$80
.ac0b	f0 02		beq $ac0f			beq 	_GXA4Unsigned
.ac0d	a9 ff		lda #$ff			lda 	#$FF
.ac0f					_GXA4Unsigned:
.ac0f	85 37		sta $37				sta 	gxzTemp0+1
.ac11	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ac13	26 37		rol $37				rol 	gxzTemp0+1
.ac15	06 36		asl $36				asl 	gxzTemp0
.ac17	26 37		rol $37				rol 	gxzTemp0+1
.ac19	18		clc				clc 								; add
.ac1a	a5 36		lda $36				lda		gxzTemp0
.ac1c	65 38		adc $38				adc 	gxzTemp1
.ac1e	85 38		sta $38				sta 	gxzTemp1
.ac20	a5 37		lda $37				lda		gxzTemp0+1
.ac22	65 39		adc $39				adc 	gxzTemp1+1
.ac24	85 39		sta $39				sta 	gxzTemp1+1
.ac26	60		rts				rts
.ac27					GXCircleSetup:
.ac27	38		sec				sec
.ac28	ad 51 06	lda $0651			lda 	gxY1
.ac2b	ed 4d 06	sbc $064d			sbc 	gxY0
.ac2e	4a		lsr a				lsr 	a
.ac2f	8d e3 06	sta $06e3			sta 	gxRadius
.ac32	a2 00		ldx #$00			ldx 	#0
.ac34	20 56 ac	jsr $ac56			jsr 	_GXCalculateCentre
.ac37	a2 02		ldx #$02			ldx 	#2
.ac39	20 56 ac	jsr $ac56			jsr 	_GXCalculateCentre
.ac3c	9c e4 06	stz $06e4			stz 	gXCentre
.ac3f	ad e3 06	lda $06e3			lda 	gxRadius
.ac42	8d e5 06	sta $06e5			sta 	gYCentre
.ac45	0a		asl a				asl 	a 							; R x 2
.ac46	85 36		sta $36				sta 	gxzTemp0
.ac48	38		sec				sec
.ac49	a9 03		lda #$03			lda 	#3
.ac4b	e5 36		sbc $36				sbc 	gxzTemp0
.ac4d	85 38		sta $38				sta 	gxzTemp1
.ac4f	a9 00		lda #$00			lda 	#0
.ac51	e9 00		sbc #$00			sbc 	#0
.ac53	85 39		sta $39				sta 	gxzTemp1+1
.ac55	60		rts				rts
.ac56					_GXCalculateCentre:
.ac56	38		sec				sec
.ac57	bd 4f 06	lda $064f,x			lda 	gxX1,x
.ac5a	7d 4b 06	adc $064b,x			adc 	gXX0,x
.ac5d	9d 4f 06	sta $064f,x			sta 	gXX1,x
.ac60	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.ac63	7d 4c 06	adc $064c,x			adc 	gXX0+1,x
.ac66	4a		lsr a				lsr 	a
.ac67	9d 50 06	sta $0650,x			sta 	gXX1+1,x
.ac6a	7e 4f 06	ror $064f,x			ror 	gXX1,x
.ac6d	60		rts				rts
.06e3					gxRadius:
>06e3							.fill 	1
.06e4					gXCentre:
>06e4							.fill 	1
.06e5					gYCentre:
>06e5							.fill 	1
.06e6					gxIsFillMode:
>06e6							.fill 	1
.06e7					gxYChanged:
>06e7							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ac6e					GXClearBitmap:
.ac6e	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP running.
.ac71	f0 24		beq $ac97			beq 	_GXCBFail
.ac73	20 58 b2	jsr $b258			jsr 	GXOpenBitmap 				; start access
.ac76	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac78	ad 57 06	lda $0657			lda 	gxHeight
.ac7b	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ac7d	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ac7f					_GXCalcLastPage:
.ac7f	98		tya				tya 								; add to base page
.ac80	18		clc				clc
.ac81	6d 55 06	adc $0655			adc 	gxBasePage
.ac84	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ac86					_GXClearAll:
.ac86	20 99 ac	jsr $ac99			jsr 	_GXClearBlock 				; clear 8k block
.ac89	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ac8b	a5 0b		lda $0b				lda 	GXEditSlot
.ac8d	cd 55 06	cmp $0655			cmp 	gxBasePage 					; until before base page
.ac90	b0 f4		bcs $ac86			bcs 	_GXClearAll
.ac92	20 60 b2	jsr $b260			jsr 	GXCloseBitmap	 			; stop access
.ac95	18		clc				clc
.ac96	60		rts				rts
.ac97					_GXCBFail:
.ac97	38		sec				sec
.ac98	60		rts				rts
.ac99					_GXClearBlock:
.ac99	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ac9b	85 38		sta $38				sta 	0+gxzTemp1
.ac9d	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ac9f	85 39		sta $39				sta 	1+gxzTemp1
.aca1					_GXCB0:
.aca1	a5 36		lda $36				lda 	gxzTemp0
.aca3	a0 00		ldy #$00			ldy 	#0
.aca5					_GXCB1:
.aca5	91 38		sta ($38),y			sta 	(gxzTemp1),y
.aca7	c8		iny				iny
.aca8	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acaa	c8		iny				iny
.acab	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acad	c8		iny				iny
.acae	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acb0	c8		iny				iny
.acb1	d0 f2		bne $aca5			bne 	_GXCB1
.acb3	e6 39		inc $39				inc 	gxzTemp1+1
.acb5	a5 39		lda $39				lda 	gxzTemp1+1
.acb7	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.acb9	d0 e6		bne $aca1			bne 	_GXCB0
.acbb	60		rts				rts
.acbc					GXInitialise:
.acbc	64 01		stz $01				stz 	1
.acbe	a9 01		lda #$01			lda 	#1
.acc0	8d 00 d0	sta $d000			sta 	$D000
.acc3	18		clc				clc
.acc4	9c 53 06	stz $0653			stz 	GXSpritesOn
.acc7	9c 54 06	stz $0654			stz 	GXBitmapsOn
.acca	a2 0f		ldx #$0f			ldx 	#15
.accc					_GXIClear:
.accc	9e 43 06	stz $0643,x			stz 	gxCurrentX,x
.accf	ca		dex				dex
.acd0	10 fa		bpl $accc			bpl 	_GXIClear
.acd2	20 6d ad	jsr $ad6d			jsr 	GXClearSpriteStore
.acd5	60		rts				rts
.acd6					GXControlBitmap:
.acd6	64 01		stz $01				stz 	1
.acd8	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acda	29 01		and #$01			and 	#1 							; set bitmap flag
.acdc	8d 54 06	sta $0654			sta 	gxBitmapsOn
.acdf	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ace0	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ace3	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ace5	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ace7	90 02		bcc $aceb			bcc 	_CBNotOn
.ace9	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.aceb					_CBNotOn:
.aceb	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.acee	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.acf0	29 07		and #$07			and 	#7
.acf2	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.acf5	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.acf7	d0 02		bne $acfb			bne 	_CBNotDefault
.acf9	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.acfb					_CBNotDefault:
.acfb	8d 55 06	sta $0655			sta 	gxBasePage
.acfe	20 5f ad	jsr $ad5f			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad01	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ad03	8d 03 d1	sta $d103			sta 	$D103
.ad06	a5 36		lda $36				lda 	gxzTemp0
.ad08	8d 02 d1	sta $d102			sta 	$D102
.ad0b	9c 01 d1	stz $d101			stz 	$D101
.ad0e	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ad10	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ad13	29 01		and #$01			and 	#1
.ad15	f0 02		beq $ad19			beq 	_CBHaveHeight
.ad17	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ad19					_CBHaveHeight
.ad19	8e 57 06	stx $0657			stx 	gxHeight
.ad1c	18		clc				clc
.ad1d	60		rts				rts
.ad1e					GXControlSprite:
.ad1e	64 01		stz $01				stz 	1
.ad20	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad22	29 01		and #$01			and 	#1 							; set sprites flag
.ad24	8d 53 06	sta $0653			sta 	gxSpritesOn
.ad27	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad28	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad2b	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad2d	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ad2f	90 02		bcc $ad33			bcc 	_CSNotOn
.ad31	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ad33					_CSNotOn:
.ad33	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad36	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad38	d0 02		bne $ad3c			bne 	_CSNotDefault
.ad3a	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ad3c					_CSNotDefault:
.ad3c	8d 56 06	sta $0656			sta 	gxSpritePage
.ad3f	20 5f ad	jsr $ad5f			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad42	a5 36		lda $36				lda 	zTemp0
.ad44	8d 61 06	sta $0661			sta 	GXSpriteOffsetBase
.ad47	a5 37		lda $37				lda 	zTemp0+1
.ad49	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase+1
.ad4c	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ad4e					_CSClear:
.ad4e	9e 00 d9	stz $d900,x			stz 	$D900,x
.ad51	9e 00 da	stz $da00,x			stz 	$DA00,x
.ad54	ca		dex				dex
.ad55	d0 f7		bne $ad4e			bne 	_CSClear
.ad57	9c 60 06	stz $0660			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ad5a	20 6d ad	jsr $ad6d			jsr 	GXClearSpriteStore
.ad5d	18		clc				clc
.ad5e	60		rts				rts
.ad5f					GXCalculateBaseAddress:
.ad5f	85 36		sta $36				sta 	gxzTemp0
.ad61	64 37		stz $37				stz 	gxzTemp0+1
.ad63	a9 05		lda #$05			lda 	#5
.ad65					_GXShift:
.ad65	06 36		asl $36				asl 	gxzTemp0
.ad67	26 37		rol $37				rol 	gxzTemp0+1
.ad69	3a		dec a				dec		a
.ad6a	d0 f9		bne $ad65			bne 	_GXShift
.ad6c	60		rts				rts
.ad6d					GXClearSpriteStore:
.ad6d	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ad6f					_GXCSSLoop:
.ad6f	9e a3 06	stz $06a3,x			stz 	GXSpriteHigh,x
.ad72	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad74	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.ad77	ca		dex				dex
.ad78	10 f5		bpl $ad6f			bpl 	_GXCSSLoop
.ad7a	60		rts				rts
.ad7b					GXLine:
.ad7b	ad 54 06	lda $0654			lda 	GXBitmapsOn
.ad7e	f0 28		beq $ada8			beq 	_GXLFail
.ad80	20 58 b2	jsr $b258			jsr 	GXOpenBitmap
.ad83	20 9e b3	jsr $b39e			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ad86	20 4e ae	jsr $ae4e			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ad89	20 68 b2	jsr $b268			jsr 	GXPositionCalc 				; calculate position/offset.
.ad8c					_GXDrawLoop:
.ad8c	ac 5d 06	ldy $065d			ldy 	gsOffset 					; draw the pixel
.ad8f	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ad91	2d 5b 06	and $065b			and 	gxANDValue
.ad94	4d 5a 06	eor $065a			eor 	gxEORValue
.ad97	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ad99	20 aa ad	jsr $adaa			jsr 	GXLineIsComplete 			; is the line complete ?
.ad9c	f0 05		beq $ada3			beq 	_GXLExit
.ad9e	20 c5 ad	jsr $adc5			jsr 	GXLineAdvance 				; code as per advance method
.ada1	80 e9		bra $ad8c			bra 	_GXDrawLoop
.ada3					_GXLExit:
.ada3	20 60 b2	jsr $b260			jsr 	GXCloseBitmap
.ada6	18		clc				clc
.ada7	60		rts				rts
.ada8					_GXLFail:
.ada8	38		sec				sec
.ada9	60		rts				rts
.adaa					GXLineIsComplete:
.adaa	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger 			; is dy larger
.adad	d0 0f		bne $adbe			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.adaf	ad 4b 06	lda $064b			lda 	GXX0 						; compare X, LSB and MSB
.adb2	4d 4f 06	eor $064f			eor 	GXX1
.adb5	d0 06		bne $adbd			bne 	_GXLICExit
.adb7	ad 4c 06	lda $064c			lda 	GXX0+1
.adba	4d 50 06	eor $0650			eor 	GXX1+1
.adbd					_GXLICExit:
.adbd	60		rts				rts
.adbe					_GXLICCompareY:
.adbe	ad 51 06	lda $0651			lda 	GXY1
.adc1	4d 4d 06	eor $064d			eor 	GXY0
.adc4	60		rts				rts
.adc5					GXLineAdvance:
.adc5	18		clc				clc 								; add adjust to position
.adc6	ad ec 06	lda $06ec			lda 	GXPosition
.adc9	6d ed 06	adc $06ed			adc 	GXAdjust
.adcc	8d ec 06	sta $06ec			sta 	GXPosition
.adcf	9c ef 06	stz $06ef			stz 	GXAddSelect 				; clear add select flag
.add2	b0 05		bcs $add9			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.add4	cd ee 06	cmp $06ee			cmp 	GXTotal 					; if exceeded total
.add7	90 0a		bcc $ade3			bcc 	_GXLANoExtra
.add9					_GXLAOverflow:
.add9	ce ef 06	dec $06ef			dec 	GXAddSelect 				; set addselect to $FF
.addc	38		sec				sec 								; subtract total and write back
.addd	ed ee 06	sbc $06ee			sbc 	GXTotal
.ade0	8d ec 06	sta $06ec			sta 	GXPosition
.ade3					_GXLANoExtra:
.ade3	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger
.ade6	f0 0d		beq $adf5			beq 	_GXDXLarger
.ade8	20 47 ae	jsr $ae47			jsr 	GXIncrementY
.adeb	ad ef 06	lda $06ef			lda 	GXAddSelect
.adee	f0 10		beq $ae00			beq 	_GXLAExit
.adf0	20 01 ae	jsr $ae01			jsr 	GXAdjustX
.adf3	80 0b		bra $ae00			bra 	_GXLAExit
.adf5					_GXDXLarger:
.adf5	20 01 ae	jsr $ae01			jsr 	GXAdjustX
.adf8	ad ef 06	lda $06ef			lda 	GXAddSelect
.adfb	f0 03		beq $ae00			beq 	_GXLAExit
.adfd	20 47 ae	jsr $ae47			jsr 	GXIncrementY
.ae00					_GXLAExit:
.ae00	60		rts				rts
.ae01					GXAdjustX:
.ae01	ad eb 06	lda $06eb			lda 	GXDXNegative
.ae04	10 25		bpl $ae2b			bpl 	_GXAXRight
.ae06	ad 4b 06	lda $064b			lda 	GXX0
.ae09	d0 03		bne $ae0e			bne 	_GXAXNoBorrow
.ae0b	ce 4c 06	dec $064c			dec 	GXX0+1
.ae0e					_GXAXNoBorrow:
.ae0e	ce 4b 06	dec $064b			dec 	GXX0
.ae11	ce 5d 06	dec $065d			dec 	gsOffset 					; pixel left
.ae14	ad 5d 06	lda $065d			lda 	gsOffset
.ae17	c9 ff		cmp #$ff			cmp 	#$FF
.ae19	d0 0f		bne $ae2a			bne 	_GXAYExit 					; underflow
.ae1b	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.ae1d	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.ae1f	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.ae21	b0 07		bcs $ae2a			bcs 	_GXAYExit
.ae23	18		clc				clc
.ae24	69 20		adc #$20			adc 	#$20 						; fix up
.ae26	85 3d		sta $3d				sta 	gxzScreen+1
.ae28	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ae2a					_GXAYExit:
.ae2a	60		rts				rts
.ae2b					_GXAXRight:
.ae2b	ee 4b 06	inc $064b			inc 	GXX0
.ae2e	d0 03		bne $ae33			bne 	_GXAXNoCarry
.ae30	ee 4c 06	inc $064c			inc 	GXX0+1
.ae33					_GXAXNoCarry:
.ae33	ee 5d 06	inc $065d			inc 	gsOffset 					; pixel right
.ae36	d0 0e		bne $ae46			bne 	_GXAXExit 					; if not overflowed, exit.
.ae38	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ae3a	a5 3d		lda $3d				lda 	gxzScreen+1
.ae3c	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ae3e	90 06		bcc $ae46			bcc 	_GXAXExit
.ae40	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae42	85 3d		sta $3d				sta 	gxzScreen+1
.ae44	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ae46					_GXAXExit:
.ae46	60		rts				rts
.ae47					GXIncrementY:
.ae47	ee 4d 06	inc $064d			inc 	GXY0
.ae4a	20 be b2	jsr $b2be			jsr 	GXMovePositionDown
.ae4d	60		rts				rts
.ae4e					GXLineSetup:
.ae4e	ad 51 06	lda $0651			lda 	GXY1
.ae51	38		sec				sec
.ae52	ed 4d 06	sbc $064d			sbc 	GXY0
.ae55	4a		lsr a				lsr 	a
.ae56	8d e9 06	sta $06e9			sta 	GXDiffY
.ae59	9c eb 06	stz $06eb			stz 	GXDXNegative 				; clear -ve flag
.ae5c	38		sec				sec
.ae5d	ad 4f 06	lda $064f			lda 	GXX1
.ae60	ed 4b 06	sbc $064b			sbc 	GXX0
.ae63	8d e8 06	sta $06e8			sta 	GXDiffX
.ae66	ad 50 06	lda $0650			lda 	GXX1+1 						; calculate MSB
.ae69	ed 4c 06	sbc $064c			sbc 	GXX0+1
.ae6c	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ae6d	6e e8 06	ror $06e8			ror 	GXDiffX
.ae70	0a		asl a				asl 	a
.ae71	10 0c		bpl $ae7f			bpl 	_GDXNotNegative
.ae73	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae75	38		sec				sec
.ae76	ed e8 06	sbc $06e8			sbc 	GXDiffX
.ae79	8d e8 06	sta $06e8			sta 	GXDiffX
.ae7c	ce eb 06	dec $06eb			dec 	GXDXNegative 				; -ve flag = $FF.
.ae7f					_GDXNotNegative:
.ae7f	9c ea 06	stz $06ea			stz 	GXIsDiffYLarger 			; clear larger flag
.ae82	ad e9 06	lda $06e9			lda 	GXDiffY 					; set adjust and total.
.ae85	8d ed 06	sta $06ed			sta 	GXAdjust
.ae88	ad e8 06	lda $06e8			lda 	GXDiffX
.ae8b	8d ee 06	sta $06ee			sta 	GXTotal
.ae8e	ad e9 06	lda $06e9			lda 	GXDiffY 					; if dy > dx
.ae91	cd e8 06	cmp $06e8			cmp 	GXDiffX
.ae94	90 0f		bcc $aea5			bcc 	_GDXNotLarger
.ae96	ce ea 06	dec $06ea			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ae99	ad e8 06	lda $06e8			lda 	GXDiffX 					; set adjust and total other way round
.ae9c	8d ed 06	sta $06ed			sta 	GXAdjust
.ae9f	ad e9 06	lda $06e9			lda 	GXDiffY
.aea2	8d ee 06	sta $06ee			sta 	GXTotal
.aea5					_GDXNotLarger:
.aea5	ad ee 06	lda $06ee			lda 	GXTotal
.aea8	4a		lsr a				lsr 	a
.aea9	8d ec 06	sta $06ec			sta 	GXPosition
.aeac	60		rts				rts
.06e8					GXDiffX:
>06e8							.fill 	1
.06e9					GXDiffY:
>06e9							.fill 	1
.06ea					GXIsDiffYLarger:
>06ea							.fill 	1
.06eb					GXDXNegative:
>06eb							.fill 	1
.06ec					GXPosition:
>06ec							.fill 	1
.06ed					GXAdjust:
>06ed							.fill 	1
.06ee					GXTotal:
>06ee							.fill 	1
.06ef					GXAddSelect:
>06ef							.fill 	1
.aead					GXSetColourMode:
.aead	a6 36		ldx $36				ldx 	gxzTemp0
.aeaf	8e 59 06	stx $0659			stx 	gxColour 								; set colour
.aeb2	a5 37		lda $37				lda 	gxzTemp0+1 								;
.aeb4	8d 58 06	sta $0658			sta 	gxMode 									; set mode
.aeb7	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.aeb9	9c 5b 06	stz $065b			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.aebc	ae 59 06	ldx $0659			ldx 	gxColour
.aebf	8e 5a 06	stx $065a			stx 	gxEORValue
.aec2	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.aec4	90 03		bcc $aec9			bcc 	_GXSDCNotAndColour
.aec6	8e 5b 06	stx $065b			stx 	gxANDValue
.aec9					_GXSDCNotAndColour:
.aec9	d0 03		bne $aece			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.aecb	9c 5a 06	stz $065a			stz 	gxEORValue
.aece					_GXSDCNotAnd:
.aece	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.aecf	90 08		bcc $aed9			bcc 	_GXSDCNoFlip
.aed1	ad 5b 06	lda $065b			lda	 	gxANDValue
.aed4	49 ff		eor #$ff			eor 	#$FF
.aed6	8d 5b 06	sta $065b			sta 	gxANDValue
.aed9					_GXSDCNoFlip:
.aed9	18		clc				clc
.aeda	60		rts				rts
.aedb					GXPlotPoint:
.aedb	20 58 b2	jsr $b258			jsr 	GXOpenBitmap 				; start drawing
.aede	20 68 b2	jsr $b268			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aee1	ac 5d 06	ldy $065d			ldy 	gsOffset
.aee4	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.aee6	2d 5b 06	and $065b			and 	gxANDValue
.aee9	4d 5a 06	eor $065a			eor 	gxEORValue
.aeec	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aeee	20 60 b2	jsr $b260			jsr 	GXCloseBitmap 				; stop drawing and exit
.aef1	18		clc				clc
.aef2	60		rts				rts
.aef3					GXFillRectangle:
.aef3	38		sec				sec
.aef4	80 01		bra $aef7			bra 	GXRectangle
.aef6					GXFrameRectangle:
.aef6	18		clc				clc
.aef7					GXRectangle:
.aef7	ad 54 06	lda $0654			lda 	gxBitmapsOn
.aefa	f0 35		beq $af31			beq 	_GXRFail
.aefc	08		php				php 								; save Fill flag (CS)
.aefd	20 58 b2	jsr $b258			jsr 	GXOpenBitmap 				; start drawing
.af00	20 80 b3	jsr $b380			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.af03	20 68 b2	jsr $b268			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.af06	38		sec				sec 								; sec = Draw line
.af07	20 33 af	jsr $af33			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.af0a	ad 4d 06	lda $064d			lda 	gxY0 						; reached end of rectangle ?
.af0d	cd 51 06	cmp $0651			cmp 	gxY1
.af10	f0 19		beq $af2b			beq 	_GXRectangleExit
.af12					_GXRectLoop:
.af12	20 be b2	jsr $b2be			jsr 	GXMovePositionDown 			; down one.
.af15	ee 4d 06	inc $064d			inc 	gxY0 						; change Y pos
.af18	ad 4d 06	lda $064d			lda 	gxY0 						; reached last line
.af1b	cd 51 06	cmp $0651			cmp 	gXY1
.af1e	f0 07		beq $af27			beq 	_GXLastLine
.af20	28		plp				plp 								; get flag back
.af21	08		php				php
.af22	20 33 af	jsr $af33			jsr 	GXDrawLineX1X0 				; draw horizontal line
.af25	80 eb		bra $af12			bra 	_GXRectLoop
.af27					_GXLastLine:
.af27	38		sec				sec
.af28	20 33 af	jsr $af33			jsr 	GXDrawLineX1X0
.af2b					_GXRectangleExit:
.af2b	68		pla				pla 								; throw fill flag.
.af2c	20 60 b2	jsr $b260			jsr 	GXCloseBitmap 				; stop drawing and exit
.af2f	18		clc				clc
.af30	60		rts				rts
.af31					_GXRFail:
.af31	38		sec				sec
.af32	60		rts				rts
.af33					GXDrawLineX1X0:
.af33	08		php				php 								; save solid/either-end
.af34	38		sec				sec
.af35	ad 4f 06	lda $064f			lda		gXX1
.af38	ed 4b 06	sbc $064b			sbc 	gXX0
.af3b	85 36		sta $36				sta 	gxzTemp0
.af3d	ad 50 06	lda $0650			lda 	gXX1+1
.af40	ed 4c 06	sbc $064c			sbc 	gXX0+1
.af43	85 37		sta $37				sta 	gxzTemp0+1
.af45	28		plp				plp
.af46					GXDrawLineTemp0:
.af46	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.af48	48		pha				pha
.af49	a5 3d		lda $3d				lda 	gxzScreen+1
.af4b	48		pha				pha
.af4c	ad 5d 06	lda $065d			lda 	gsOffset
.af4f	48		pha				pha
.af50	a5 0b		lda $0b				lda 	GXEditSlot
.af52	48		pha				pha
.af53	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y offset
.af56	90 1e		bcc $af76			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.af58					_GXDLTLine:
.af58	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af5a	2d 5b 06	and $065b			and 	gxANDValue
.af5d	4d 5a 06	eor $065a			eor 	gxEORValue
.af60	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af62	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.af64	d0 04		bne $af6a			bne 	_GXDLTNoBorrow
.af66	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.af68	30 2e		bmi $af98			bmi 	_GXDLTExit
.af6a					_GXDLTNoBorrow:
.af6a	c6 36		dec $36				dec 	gxzTemp0
.af6c	c8		iny				iny 								; next slot.
.af6d	d0 e9		bne $af58			bne 	_GXDLTLine
.af6f	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.af71	20 a6 af	jsr $afa6			jsr 	GXDLTCheckWrap				; check for new page.
.af74	80 e2		bra $af58			bra 	_GXDLTLine
.af76					_GXDLTEndPoints:
.af76	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af78	2d 5b 06	and $065b			and 	gxANDValue
.af7b	4d 5a 06	eor $065a			eor 	gxEORValue
.af7e	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af80	98		tya				tya 								; advance to right side
.af81	18		clc				clc
.af82	65 36		adc $36				adc 	gxzTemp0
.af84	a8		tay				tay
.af85	a5 3d		lda $3d				lda 	gxzScreen+1
.af87	65 37		adc $37				adc 	gxzTemp0+1
.af89	85 3d		sta $3d				sta 	gxzScreen+1
.af8b	20 a6 af	jsr $afa6			jsr 	GXDLTCheckWrap 			; fix up.
.af8e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af90	2d 5b 06	and $065b			and 	gxANDValue
.af93	4d 5a 06	eor $065a			eor 	gxEORValue
.af96	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af98					_GXDLTExit:
.af98	68		pla				pla
.af99	85 0b		sta $0b				sta 	GXEditSlot
.af9b	68		pla				pla
.af9c	8d 5d 06	sta $065d			sta 	gsOffset
.af9f	68		pla				pla
.afa0	85 3d		sta $3d				sta 	gxzScreen+1
.afa2	68		pla				pla
.afa3	85 3c		sta $3c				sta 	gxzScreen
.afa5	60		rts				rts
.afa6					GXDLTCheckWrap:
.afa6	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.afa8	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.afaa	90 06		bcc $afb2			bcc 	_GXDLTCWExit
.afac	e9 20		sbc #$20			sbc 	#$20 						; fix up
.afae	85 3d		sta $3d				sta 	gxzScreen+1
.afb0	e6 0b		inc $0b				inc 	GXEditSlot
.afb2					_GXDLTCWExit:
.afb2	60		rts				rts
.afb3					GXDrawGraphicElement:
.afb3	8d f0 06	sta $06f0			sta 	gxSize 						; save size
.afb6	3a		dec a				dec 	a
.afb7	8d f1 06	sta $06f1			sta 	gxMask 						; and mask
.afba	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP on
.afbd	f0 67		beq $b026			beq 	_GXSLFail
.afbf	ad 4d 06	lda $064d			lda 	gxY0 						; push Y on stack
.afc2	48		pha				pha
.afc3	8c f3 06	sty $06f3			sty 	gxAcquireVector+1 			; and acquisition vector
.afc6	8e f2 06	stx $06f2			stx 	gxAcquireVector
.afc9	20 58 b2	jsr $b258			jsr 	gxOpenBitmap 				; open the bitmap.
.afcc	ad f5 06	lda $06f5			lda 	gxUseMode 					; scale bits
.afcf	4a		lsr a				lsr 	a
.afd0	4a		lsr a				lsr 	a
.afd1	4a		lsr a				lsr 	a
.afd2	29 07		and #$07			and		#7
.afd4	1a		inc a				inc 	a
.afd5	8d f4 06	sta $06f4			sta 	gxScale
.afd8	64 38		stz $38				stz 	gxzTemp1					; start first line
.afda					_GXGELoop:
.afda	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.afdc	2c f5 06	bit $06f5			bit 	gxUseMode 					; check for flip.
.afdf	10 06		bpl $afe7			bpl		_GXNoVFlip
.afe1	ad f1 06	lda $06f1			lda 	gxMask
.afe4	38		sec				sec
.afe5	e5 38		sbc $38				sbc 	gxzTemp1
.afe7					_GXNoVFlip:
.afe7	aa		tax				tax 								; get the Xth line.
.afe8	20 28 b0	jsr $b028			jsr 	_GXCallAcquire 				; get that data.
.afeb	ad f4 06	lda $06f4			lda 	gxScale 					; do scale identical copies of that line.
.afee	85 39		sta $39				sta 	gxzTemp1+1
.aff0					_GXGELoop2:
.aff0	ad 4d 06	lda $064d			lda 	gxY0 						; off screen
.aff3	cd 57 06	cmp $0657			cmp 	gxHeight
.aff6	b0 10		bcs $b008			bcs 	_GXDGEExit
.aff8	20 2b b0	jsr $b02b			jsr 	GXRenderOneLine 			; render line
.affb	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.affd	d0 f1		bne $aff0			bne 	_GXGELoop2
.afff	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b001	a5 38		lda $38				lda 	gxzTemp1
.b003	cd f0 06	cmp $06f0			cmp 	gxSize
.b006	d0 d2		bne $afda			bne 	_GXGELoop
.b008					_GXDGEExit:
.b008	68		pla				pla 								; restore Y for next time
.b009	8d 4d 06	sta $064d			sta 	gxY0
.b00c	ae f4 06	ldx $06f4			ldx 	gxScale 					; get scale (1-8)
.b00f					_GXShiftLeft:
.b00f	18		clc				clc
.b010	ad f0 06	lda $06f0			lda 	gxSize
.b013	6d 4b 06	adc $064b			adc 	gxX0
.b016	8d 4b 06	sta $064b			sta 	gxX0
.b019	90 03		bcc $b01e			bcc 	_GXSLNoCarry
.b01b	ee 4c 06	inc $064c			inc 	gxX0+1
.b01e					_GXSLNoCarry:
.b01e	ca		dex				dex
.b01f	d0 ee		bne $b00f			bne 	_GXShiftLeft
.b021	20 60 b2	jsr $b260			jsr 	GXCloseBitmap
.b024	18		clc				clc
.b025	60		rts				rts
.b026					_GXSLFail:
.b026	38		sec				sec
.b027	60		rts				rts
.b028					_GXCallAcquire:
.b028	6c f2 06	jmp ($06f2)			jmp 	(gxAcquireVector)
.b02b					GXRenderOneLine:
.b02b	20 68 b2	jsr $b268			jsr 	GXPositionCalc 				; calculate position/offset.
.b02e	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y contains position.
.b031	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b033					_GXROLLoop1:
.b033	ad f4 06	lda $06f4			lda 	gxScale 					; set to do 'scale' times
.b036	85 3b		sta $3b				sta 	gxzTemp2+1
.b038					_GXROLLoop2:
.b038	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b03a	2c 58 06	bit $0658			bit 	gxMode 						; check H Flip
.b03d	50 06		bvc $b045			bvc 	_GXNoHFlip
.b03f	ad f1 06	lda $06f1			lda 	gxMask
.b042	38		sec				sec
.b043	e5 3a		sbc $3a				sbc 	gxzTemp2
.b045					_GXNoHFlip:
.b045	aa		tax				tax 								; read from the pixel buffer
.b046	bd f9 05	lda $05f9,x			lda 	gxPixelBuffer,x
.b049	d0 07		bne $b052			bne 	_GXDraw 					; draw if non zero
.b04b	ad f5 06	lda $06f5			lda 	gxUseMode 					; check to see if solid background
.b04e	29 04		and #$04			and 	#4
.b050	f0 0a		beq $b05c			beq 	_GXZeroPixel
.b052					_GXDraw:
.b052	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b054	2d 5b 06	and $065b			and 	gxANDValue
.b057	5d f9 05	eor $05f9,x			eor 	gxPixelBuffer,x
.b05a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b05c					_GXZeroPixel:
.b05c	c8		iny				iny 								; advance pointer
.b05d	d0 05		bne $b064			bne 	_GXNoShift
.b05f	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b061	20 a6 af	jsr $afa6			jsr 	GXDLTCheckWrap				; check for new page.
.b064					_GXNoShift:
.b064	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b066	d0 d0		bne $b038			bne 	_GXROLLoop2
.b068	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b06a	a5 3a		lda $3a				lda 	gxzTemp2
.b06c	cd f0 06	cmp $06f0			cmp 	gxSize
.b06f	d0 c2		bne $b033			bne 	_GXROLLoop1
.b071	ee 4d 06	inc $064d			inc 	gxY0
.b074	60		rts				rts
.06f0					gxSize:
>06f0							.fill 	1
.06f1					gxMask:
>06f1							.fill 	1
.06f2					gxAcquireVector:
>06f2							.fill 	2
.06f4					gxScale:
>06f4							.fill 	1
.06f5					gxUseMode:
>06f5							.fill 	1
.b075					GXFontHandler:
.b075	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b077	4d 58 06	eor $0658			eor 	gxMode
.b07a	8d f5 06	sta $06f5			sta 	gxUseMode
.b07d	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b07f	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b081	26 37		rol $37				rol	 	gxzTemp0+1
.b083	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b085	26 37		rol $37				rol	 	gxzTemp0+1
.b087	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b089	26 37		rol $37				rol	 	gxzTemp0+1
.b08b	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b08d	09 c0		ora #$c0			ora 	#$C0
.b08f	85 37		sta $37				sta 	gxzTemp0+1
.b091	a9 08		lda #$08			lda 	#8 							; size 8x8
.b093	a2 9b		ldx #$9b			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b095	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b097	20 b3 af	jsr $afb3			jsr 	GXDrawGraphicElement
.b09a	60		rts				rts
.b09b					GXGetGraphicDataFont:
.b09b	8a		txa				txa 								; X->Y
.b09c	a8		tay				tay
.b09d	a6 01		ldx $01				ldx 	1 							; preserve old value
.b09f	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b0a1	85 01		sta $01				sta 	1
.b0a3	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b0a5	86 01		stx $01				stx 	1 							; put old value back.
.b0a7	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b0a9					_GXExpand:
.b0a9	9e f9 05	stz $05f9,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b0ac	0a		asl a				asl 	a 							; shift bit 7 into C
.b0ad	90 08		bcc $b0b7			bcc 	_GXNoPixel
.b0af	48		pha				pha 								; if set, set pixel buffer to current colour.
.b0b0	ad 59 06	lda $0659			lda 	gxColour
.b0b3	9d f9 05	sta $05f9,x			sta 	gxPixelBuffer,x
.b0b6	68		pla				pla
.b0b7					_GXNoPixel:
.b0b7	e8		inx				inx 								; do the whole byte.
.b0b8	e0 08		cpx #$08			cpx 	#8
.b0ba	d0 ed		bne $b0a9			bne 	_GXExpand
.b0bc	60		rts				rts
.b0bd					GXSpriteHandler:
.b0bd	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b0bf	4d 58 06	eor $0658			eor 	gxMode
.b0c2	8d f5 06	sta $06f5			sta 	gxUseMode
.b0c5	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b0c7	da		phx				phx
.b0c8	20 58 b2	jsr $b258			jsr 	GXOpenBitmap 				; can access sprite information
.b0cb	68		pla				pla
.b0cc	20 39 b3	jsr $b339			jsr 	GXFindSprite 				; get the sprite address
.b0cf	08		php				php
.b0d0	20 60 b2	jsr $b260			jsr 	GXCloseBitmap
.b0d3	28		plp				plp
.b0d4	b0 0a		bcs $b0e0			bcs		_GXSHExit 					; exit if find failed.
.b0d6	ad f6 06	lda $06f6			lda 	GXSizePixels 				; return size
.b0d9	a2 e1		ldx #$e1			ldx 	#GXSpriteAcquire & $FF
.b0db	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b0dd	20 b3 af	jsr $afb3			jsr 	GXDrawGraphicElement
.b0e0					_GXSHExit:
.b0e0	60		rts				rts
.b0e1					GXSpriteAcquire:
.b0e1	ad 56 06	lda $0656			lda 	GXSpritePage				; point to base page
.b0e4	85 0b		sta $0b				sta 	GXEditSlot
.b0e6	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b0e8	a9 00		lda #$00			lda 	#0
.b0ea	ae f7 06	ldx $06f7			ldx 	GXSizeBits
.b0ed					_GXTimesRowNumber:
.b0ed	18		clc				clc
.b0ee	65 36		adc $36				adc 	zTemp0
.b0f0	ca		dex				dex
.b0f1	10 fa		bpl $b0ed			bpl 	_GXTimesRowNumber
.b0f3	64 37		stz $37				stz 	gxzTemp0+1
.b0f5	0a		asl a				asl 	a 							; row x 2,4,6,8
.b0f6	26 37		rol $37				rol 	gxzTemp0+1
.b0f8	0a		asl a				asl 	a 							; row x 4,8,12,16
.b0f9	26 37		rol $37				rol 	gxzTemp0+1
.b0fb	0a		asl a				asl 	a 							; row x 8,16,24,32
.b0fc	26 37		rol $37				rol 	gxzTemp0+1
.b0fe	85 36		sta $36				sta 	gxzTemp0
.b100	18		clc				clc 								; add base address.
.b101	a5 36		lda $36				lda 	gxzTemp0
.b103	6d f9 06	adc $06f9			adc 	GXSpriteOffset
.b106	85 36		sta $36				sta 	gxzTemp0
.b108	a5 37		lda $37				lda 	gxzTemp0+1
.b10a	6d fa 06	adc $06fa			adc 	GXSpriteOffset+1
.b10d					_GXSAFindPage:
.b10d	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b10f	90 06		bcc $b117			bcc 	_GXSAFoundPage
.b111	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b113	e6 0b		inc $0b				inc 	GXEditSlot
.b115	80 f6		bra $b10d			bra 	_GXSAFindPage
.b117					_GXSAFoundPage:
.b117	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b119	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b11b	a0 00		ldy #$00			ldy 	#0
.b11d					_GXSACopyLoop:
.b11d	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b11f	99 f9 05	sta $05f9,y			sta 	gxPixelBuffer,y
.b122	c8		iny				iny
.b123	cc f6 06	cpy $06f6			cpy 	GXSizePixels
.b126	d0 f5		bne $b11d			bne 	_GXSACopyLoop
.b128	60		rts				rts
.b129					GXSelect:
.b129	ad 53 06	lda $0653			lda 	gxSpritesOn
.b12c	f0 22		beq $b150			beq 	_GXSFail
.b12e	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b130	c9 40		cmp #$40			cmp 	#64
.b132	b0 1c		bcs $b150			bcs 	_GXSFail
.b134	8d 5e 06	sta $065e			sta 	GSCurrentSpriteID
.b137	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b139	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b13b	06 36		asl $36				asl 	gxzTemp0
.b13d	06 36		asl $36				asl 	gxzTemp0
.b13f	06 36		asl $36				asl 	gxzTemp0
.b141	2a		rol a				rol 	a
.b142	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b144	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b147	85 37		sta $37				sta 	gxzTemp0+1
.b149	a5 36		lda $36				lda 	gxzTemp0
.b14b	8d 5f 06	sta $065f			sta 	GSCurrentSpriteAddr
.b14e	18		clc				clc
.b14f	60		rts				rts
.b150					_GXSFail:
.b150	38		sec				sec
.b151	60		rts				rts
.b152					GXSelectImage:
.b152	ad 53 06	lda $0653			lda 	gxSpritesOn
.b155	f0 74		beq $b1cb			beq 	_GXSIFail
.b157	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b15a	f0 6f		beq $b1cb			beq 	_GXSIFail 					; (checking the MSB)
.b15c	64 01		stz $01				stz 	1
.b15e	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b160	d0 6b		bne $b1cd			bne 	_GXSIHide
.b162	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b164	48		pha				pha
.b165	20 58 b2	jsr $b258			jsr 	GXOpenBitmap
.b168	68		pla				pla
.b169	20 39 b3	jsr $b339			jsr 	GXFindSprite
.b16c	b0 5a		bcs $b1c8			bcs 	_GXSICloseFail 				; no image
.b16e	a0 01		ldy #$01			ldy 	#1
.b170	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b173	85 36		sta $36				sta 	gxzTemp0
.b175	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b178	85 37		sta $37				sta 	gxzTemp0+1
.b17a	ad f9 06	lda $06f9			lda 	GXSpriteOffset
.b17d	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b17f	18		clc				clc
.b180	ad fa 06	lda $06fa			lda 	GXSpriteOffset+1
.b183	6d 61 06	adc $0661			adc 	GXSpriteOffsetBase
.b186	c8		iny				iny
.b187	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b189	ad 62 06	lda $0662			lda 	GXSpriteOffsetBase+1
.b18c	69 00		adc #$00			adc 	#0
.b18e	c8		iny				iny
.b18f	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b191	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get raw size
.b194	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b196	2a		rol a				rol 	a 							; x 2
.b197	0a		asl a				asl 	a 							; x 4
.b198	0a		asl a				asl 	a 							; x 8
.b199	0a		asl a				asl 	a 							; x 16
.b19a	0d f8 06	ora $06f8			ora 	GXSpriteLUT 				; Or with LUT
.b19d	0a		asl a				asl 	a 							; 1 shift
.b19e	09 01		ora #$01			ora 	#1 							; enable sprite.
.b1a0	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b1a2	20 60 b2	jsr $b260			jsr 	GXCloseBitmap
.b1a5	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b1a8	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b1ab	29 3f		and #$3f			and 	#$3F
.b1ad	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1b0	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get bit size
.b1b3	6a		ror a				ror 	a 							; shift into bits 6/7
.b1b4	6a		ror a				ror 	a
.b1b5	6a		ror a				ror 	a
.b1b6	29 c0		and #$c0			and 	#$C0
.b1b8	1d a3 06	ora $06a3,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b1bb	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1be	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b1c1	29 7f		and #$7f			and 	#$7F
.b1c3	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b1c6	18		clc				clc
.b1c7	60		rts				rts
.b1c8					_GXSICloseFail:
.b1c8	20 60 b2	jsr $b260			jsr 	GXCloseBitmap
.b1cb					_GXSIFail:
.b1cb	38		sec				sec
.b1cc	60		rts				rts
.b1cd					_GXSIHide:
.b1cd	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b1d0	85 36		sta $36				sta 	gxzTemp0
.b1d2	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b1d5	85 37		sta $37				sta 	gxzTemp0+1
.b1d7	a9 00		lda #$00			lda 	#0
.b1d9	92 36		sta ($36)			sta 	(gxzTemp0)
.b1db	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get sprite ID
.b1de	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b1e1	09 80		ora #$80			ora 	#$80
.b1e3	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b1e6	18		clc				clc
.b1e7	60		rts				rts
.b1e8					GXMoveSprite:
.b1e8	ad 53 06	lda $0653			lda 	gxSpritesOn
.b1eb	f0 65		beq $b252			beq 	_GXSIFail
.b1ed	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b1f0	f0 60		beq $b252			beq 	_GXSIFail
.b1f2	85 37		sta $37				sta 	gxzTemp0+1
.b1f4	a0 04		ldy #$04			ldy 	#4
.b1f6	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b1f9	85 36		sta $36				sta 	gxzTemp0
.b1fb	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b1fe	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b201	2a		rol a				rol 	a	 						; into bits 0,1.
.b202	2a		rol a				rol 	a
.b203	2a		rol a				rol 	a
.b204	29 03		and #$03			and 	#3
.b206	aa		tax				tax
.b207	bd 54 b2	lda $b254,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b20a	48		pha				pha
.b20b	18		clc				clc
.b20c	6d 4b 06	adc $064b			adc 	gxX0						; copy position.
.b20f	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b211	c8		iny				iny
.b212	ad 4c 06	lda $064c			lda 	gxX0+1
.b215	69 00		adc #$00			adc 	#0
.b217	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b219	c8		iny				iny
.b21a	68		pla				pla
.b21b	18		clc				clc
.b21c	6d 4d 06	adc $064d			adc 	gxY0
.b21f	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b221	a9 00		lda #$00			lda 	#0
.b223	69 00		adc #$00			adc 	#0
.b225	c8		iny				iny
.b226	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b228	4e 4c 06	lsr $064c			lsr 	gxX0+1 						; divide X by 4
.b22b	6e 4b 06	ror $064b			ror 	gxX0
.b22e	4e 4b 06	lsr $064b			lsr 	gxX0
.b231	4e 4d 06	lsr $064d			lsr 	gxY0 						; divide Y by 4
.b234	4e 4d 06	lsr $064d			lsr 	gxY0
.b237	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b23a	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x
.b23d	29 80		and #$80			and 	#$80
.b23f	0d 4b 06	ora $064b			ora 	gxX0
.b242	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b245	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b248	29 c0		and #$c0			and 	#$C0
.b24a	0d 4d 06	ora $064d			ora 	gxY0
.b24d	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b250	18		clc				clc
.b251	60		rts				rts
.b252					_GXSIFail:
.b252	38		sec				sec
.b253	60		rts				rts
.b254					_GXMSOffset:
>b254	1c						.byte 	32-8/2
>b255	18						.byte 	32-16/2
>b256	14						.byte 	32-24/2
>b257	10						.byte 	32-32/2
.b258					GXOpenBitmap:
.b258	78		sei				sei 								; no interrupts here
.b259	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b25b	8d 5c 06	sta $065c			sta 	gxOriginalLUTValue
.b25e	58		cli				cli
.b25f	60		rts				rts
.b260					GXCloseBitmap:
.b260	78		sei				sei
.b261	ad 5c 06	lda $065c			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b264	85 0b		sta $0b				sta 	GXEditSlot
.b266	58		cli				cli
.b267	60		rts				rts
.b268					GXPositionCalc:
.b268	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b26a	48		pha				pha
.b26b	ad 4d 06	lda $064d			lda 	GXY0 						; gxzScreen = Y0
.b26e	85 3c		sta $3c				sta 	gxzScreen
.b270	64 3d		stz $3d				stz 	gxzScreen+1
.b272	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b274	26 3d		rol $3d				rol 	gxzScreen+1
.b276	06 3c		asl $3c				asl 	gxzScreen
.b278	26 3d		rol $3d				rol 	gxzScreen+1
.b27a	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b27b	65 3c		adc $3c				adc 	gxzScreen
.b27d	85 3c		sta $3c				sta 	gxzScreen
.b27f	90 02		bcc $b283			bcc 	_GXPCNoCarry
.b281	e6 3d		inc $3d				inc 	gxzScreen+1
.b283					_GXPCNoCarry:
.b283	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b285	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b287	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b289	85 36		sta $36				sta 	gxzTemp0
.b28b	64 3d		stz $3d				stz 	gxzScreen+1
.b28d	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b28f					_GXPCMultiply32:
.b28f	06 3c		asl $3c				asl 	gxzScreen
.b291	26 3d		rol $3d				rol 	gxzScreen+1
.b293	3a		dec a				dec 	a
.b294	d0 f9		bne $b28f			bne 	_GXPCMultiply32
.b296	18		clc				clc
.b297	ad 4b 06	lda $064b			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b29a	65 3c		adc $3c				adc 	gxzScreen
.b29c	8d 5d 06	sta $065d			sta 	gsOffset
.b29f	ad 4c 06	lda $064c			lda 	GXX0+1
.b2a2	65 3d		adc $3d				adc 	gxzScreen+1
.b2a4	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b2a6	90 04		bcc $b2ac			bcc 	_GXPCNoOverflow
.b2a8	29 1f		and #$1f			and 	#$1F 						; fix it up
.b2aa	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b2ac					_GXPCNoOverflow:
.b2ac	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b2ae	85 3d		sta $3d				sta 	gxzScreen+1
.b2b0	64 3c		stz $3c				stz 	gxzScreen
.b2b2	18		clc				clc
.b2b3	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b2b5	6d 55 06	adc $0655			adc 	gxBasePage 					; by adding the base page
.b2b8	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b2ba	68		pla				pla
.b2bb	85 36		sta $36				sta 	gxzTemp0
.b2bd	60		rts				rts
.b2be					GXMovePositionDown:
.b2be	18		clc				clc 								; add 320 to offset/temp+1
.b2bf	ad 5d 06	lda $065d			lda 	gsOffset
.b2c2	69 40		adc #$40			adc 	#64
.b2c4	8d 5d 06	sta $065d			sta 	gsOffset
.b2c7	a5 3d		lda $3d				lda 	gxzScreen+1
.b2c9	69 01		adc #$01			adc 	#1
.b2cb	85 3d		sta $3d				sta 	gxzScreen+1
.b2cd	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b2cf	90 07		bcc $b2d8			bcc 	_GXMPDExit
.b2d1	38		sec				sec  								; next page
.b2d2	e9 20		sbc #$20			sbc 	#$20
.b2d4	85 3d		sta $3d				sta 	gxzScreen+1
.b2d6	e6 0b		inc $0b				inc 	GXEditSlot
.b2d8					_GXMPDExit:
.b2d8	60		rts				rts
.b2d9					GXCollide:
.b2d9	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b2db	aa		tax				tax
.b2dc	05 37		ora $37				ora 	gxzTemp0+1
.b2de	29 c0		and #$c0			and 	#$C0
.b2e0	38		sec				sec
.b2e1	d0 53		bne $b336			bne 	_GXCollideFail 				; if either >= 64, fail.
.b2e3	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b2e5	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b2e8	1d 63 06	ora $0663,x			ora 	GXSpriteLow,x
.b2eb	30 48		bmi $b335			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b2ed	18		clc				clc 								; need to calculate sum of sizes.
.b2ee	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y
.b2f1	7d a3 06	adc $06a3,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b2f4	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b2f6	6a		ror a				ror 	a 							; 5/6/7
.b2f7	4a		lsr a				lsr 	a 							; 4/5/6
.b2f8	4a		lsr a				lsr 	a 							; 3/4/5
.b2f9	4a		lsr a				lsr 	a 							; 2/3/4
.b2fa	18		clc				clc
.b2fb	69 08		adc #$08			adc 	#$08
.b2fd	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b2fe	4a		lsr a				lsr 	a
.b2ff	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b301	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b304	29 3f		and #$3f			and 	#$3F
.b306	85 39		sta $39				sta 	gxzTemp1+1
.b308	38		sec				sec
.b309	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b30c	29 3f		and #$3f			and 	#$3F
.b30e	e5 39		sbc $39				sbc 	gxzTemp1+1
.b310	b0 03		bcs $b315			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b312	49 ff		eor #$ff			eor 	#$FF
.b314	1a		inc a				inc 	a
.b315					_GXCAbs1:
.b315	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b317	b0 1c		bcs $b335			bcs 	_GXOkayFail
.b319	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b31b	38		sec				sec 								; calculate |x1-x0|
.b31c	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y
.b31f	fd 63 06	sbc $0663,x			sbc 	GXSpriteLow,x
.b322	b0 03		bcs $b327			bcs 	_GXCAbs2
.b324	49 ff		eor #$ff			eor 	#$FF
.b326	1a		inc a				inc 	a
.b327					_GXCAbs2:
.b327	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b329	b0 0a		bcs $b335			bcs 	_GXOkayFail
.b32b	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b32d	90 02		bcc $b331			bcc 	_GXCHaveLowest
.b32f	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b331					_GXCHaveLowest:
.b331	0a		asl a				asl 	a 							; scale to allow for >> 2
.b332	0a		asl a				asl 	a
.b333	18		clc				clc
.b334	60		rts				rts
.b335					_GXOkayFail:
.b335	18		clc				clc
.b336					_GXCollideFail:
.b336	a9 ff		lda #$ff			lda 	#$FF
.b338	60		rts				rts
.b339					GXFindSprite:
.b339	aa		tax				tax
.b33a	ad 56 06	lda $0656			lda 	GXSpritePage 				; access the base page of the sprite
.b33d	85 0b		sta $0b				sta 	GXEditSlot
.b33f	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b342	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b345	f0 33		beq $b37a			beq 	_GXFSFail
.b347	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b34a	8d fa 06	sta $06fa			sta 	GXSpriteOffset+1
.b34d	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b350	48		pha				pha 								; save twice
.b351	48		pha				pha
.b352	29 03		and #$03			and 	#3 							; get sprite size
.b354	8d f7 06	sta $06f7			sta 	GXSizeBits 					; save raw (0-3)
.b357	aa		tax				tax
.b358	bd 7c b3	lda $b37c,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b35b	8d f6 06	sta $06f6			sta 	GXSizePixels 					; save (8/16/24/32)
.b35e	68		pla				pla 								; get LUT
.b35f	4a		lsr a				lsr		a
.b360	4a		lsr a				lsr		a
.b361	29 03		and #$03			and 	#3
.b363	8d f8 06	sta $06f8			sta 	GXSpriteLUT
.b366	68		pla				pla 								; address, neeeds to be x 4
.b367	29 f0		and #$f0			and 	#$F0
.b369	8d f9 06	sta $06f9			sta 	GXSpriteOffset
.b36c	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b36f	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b372	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b375	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b378	18		clc				clc
.b379	60		rts				rts
.b37a					_GXFSFail:
.b37a	38		sec				sec
.b37b	60		rts				rts
.b37c					_GXFXSSTTable:
>b37c	08 10 18 20					.byte 	8,16,24,32
.06f6					GXSizePixels:
>06f6							.fill 	1
.06f7					GXSizeBits:
>06f7							.fill 	1
.06f8					GXSpriteLUT:
>06f8							.fill 	1
.06f9					GXSpriteOffset:
>06f9							.fill 	2
.b380					GXSortXY:
.b380	20 9e b3	jsr $b39e			jsr 	GXSortY 					; will be sorted on Y now
.b383	ad 4b 06	lda $064b			lda 	gxX0 						; compare X0 v X1
.b386	cd 4f 06	cmp $064f			cmp 	gxX1
.b389	ad 4c 06	lda $064c			lda 	gXX0+1
.b38c	ed 50 06	sbc $0650			sbc 	gXX1+1
.b38f	90 0c		bcc $b39d			bcc 	_GXSXYExit 					; X0 < X1 exit
.b391	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b393	a0 04		ldy #$04			ldy 	#4
.b395	20 b2 b3	jsr $b3b2			jsr 	GXSwapXY
.b398	e8		inx				inx
.b399	c8		iny				iny
.b39a	20 b2 b3	jsr $b3b2			jsr 	GXSwapXY
.b39d					_GXSXYExit:
.b39d	60		rts				rts
.b39e					GXSortY:
.b39e	ad 4d 06	lda $064d			lda 	gxY0 						; if Y0 >= Y1
.b3a1	cd 51 06	cmp $0651			cmp 	gxY1
.b3a4	90 0b		bcc $b3b1			bcc 	_GXSYSorted
.b3a6	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b3a8	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b3aa					_GXSwap1:
.b3aa	20 b2 b3	jsr $b3b2			jsr 	GXSwapXY
.b3ad	88		dey				dey
.b3ae	ca		dex				dex
.b3af	10 f9		bpl $b3aa			bpl 	_GXSwap1
.b3b1					_GXSYSorted:
.b3b1	60		rts				rts
.b3b2					GXSwapXY:
.b3b2	bd 4b 06	lda $064b,x			lda 	gxX0,x
.b3b5	48		pha				pha
.b3b6	b9 4b 06	lda $064b,y			lda 	gxX0,y
.b3b9	9d 4b 06	sta $064b,x			sta 	gxX0,x
.b3bc	68		pla				pla
.b3bd	99 4b 06	sta $064b,y			sta 	gxX0,y
.b3c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.ba31					KeywordSet0:
>ba31	00 65					.text	0,$65,""               ; $80 !0:EOF
>ba33	00 58					.text	0,$58,""               ; $81 !1:SH1
>ba35	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ba37	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>ba3d	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>ba45	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>ba4b	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>ba52	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>ba5a	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>ba61	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>ba68	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>ba6e	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>ba74	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>ba7c	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>ba83	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>ba8a	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>ba91	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>ba99	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>ba9f	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>baa5	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>baac	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bab2	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bab8	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bac0	47 28
>bac2	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>baca	28
>bacb	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>bad3	28
>bad4	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bada	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bae0	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>bae6	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>baed	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>baf5	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bafb	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bb01	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bb06	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bb0a	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bb10	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bb18	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bb1f	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bb26	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bb2e	43
>bb2f	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bb35	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bb3b	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bb42	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bb48	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bb4c	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bb52	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bb5a	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bb61	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bb66	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bb6d	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bb75	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bb7b	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bb80	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bb88	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bb8e	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bb94	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bb99	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bba0	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bba6	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bbac	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bbb3	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bc LET
>bbb8	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $bd LINE
>bbbe	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $be LOCAL
>bbc5	03 db 4f 46 46				.text	3,$db,"OFF"            ; $bf OFF
>bbca	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c0 ON
>bbce	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c1 OUTLINE
>bbd6	45
>bbd7	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c2 PALETTE
>bbdf	45
>bbe0	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c3 PLOT
>bbe6	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c4 PRINT
>bbed	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c5 READ
>bbf3	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c6 RECT
>bbf9	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c7 REM
>bbfe	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c8 RETURN
>bc06	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $c9 SOLID
>bc0d	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $ca SOUND
>bc14	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cb SPRITE
>bc1c	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cc TEXT
>bc22	02 a3 54 4f				.text	2,$a3,"TO"             ; $cd TO
>bc26	ff					.text	$FF
.bc27					KeywordSet1:
>bc27	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc29	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc2b	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc2d	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bc35	4c 45
>bc37	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bc3f	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bc47	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bc4c	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $87 LIST
>bc52	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $88 NEW
>bc57	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $89 RESTORE
>bc5f	45
>bc60	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8a RUN
>bc65	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8b SPRITES
>bc6d	53
>bc6e	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8c STOP
>bc74	ff					.text	$FF
.bc75					KeywordSet2:
>bc75	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc77	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc79	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc7b	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bc80	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bc85	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bc8a	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bc8f	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bc94	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bc99	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bc9e	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bca3	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bca8	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bcad	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bcb2	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bcb7	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bcbc	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bcc1	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bcc6	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bccb	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bcd0	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bcd5	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bcda	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bcdf	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bce4	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bce9	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bcee	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bcf3	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bcf8	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bcfd	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bd02	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bd07	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bd0c	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bd11	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bd16	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bd1b	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bd20	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bd25	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bd2a	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bd2f	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bd34	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bd39	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bd3e	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bd43	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bd48	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bd4d	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bd52	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bd57	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bd5c	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bd61	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bd66	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bd6b	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bd70	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bd75	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bd7a	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bd7f	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bd84	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bd89	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bd8e	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bd93	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bd98	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bd9d	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bda2	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bda7	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bdac	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bdb1	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bdb6	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bdbb	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bdc0	ff					.text	$FF
.b3c1					ListConvertLine:
.b3c1	48		pha				pha 								; save indent on the stack
.b3c2	9c 9d 04	stz $049d			stz 	tbOffset
.b3c5	9c ab 04	stz $04ab			stz 	tokenBuffer
.b3c8	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b3ca	b1 30		lda ($30),y			lda 	(codePtr),y
.b3cc	aa		tax				tax
.b3cd	88		dey				dey
.b3ce	b1 30		lda ($30),y			lda 	(codePtr),y
.b3d0	20 77 92	jsr $9277			jsr 	LCLConvertInt16
.b3d3	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b3d5	86 37		stx $37				stx 	zTemp0+1
.b3d7	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b3d9	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b3dc	a0 00		ldy #$00			ldy 	#0
.b3de					_LCCopyNumber:
.b3de	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3e0	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b3e3	c8		iny				iny
.b3e4	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3e6	d0 f6		bne $b3de			bne 	_LCCopyNumber
.b3e8	68		pla				pla 								; adjustment to indent
.b3e9	48		pha				pha 								; save on stack
.b3ea	10 0c		bpl $b3f8			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b3ec	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b3ed	6d a6 04	adc $04a6			adc 	listIndent
.b3f0	8d a6 04	sta $04a6			sta 	listIndent
.b3f3	10 03		bpl $b3f8			bpl 	_LCNoAdjust
.b3f5	9c a6 04	stz $04a6			stz 	listIndent
.b3f8					_LCNoAdjust:
.b3f8	18		clc				clc		 							; work out actual indent.
.b3f9	ad a6 04	lda $04a6			lda 	listIndent
.b3fc	0a		asl a				asl 	a
.b3fd	69 06		adc #$06			adc 	#6
.b3ff	85 36		sta $36				sta 	zTemp0
.b401					_LCPadOut:
.b401	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b403	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b406	ad 9d 04	lda $049d			lda 	tbOffset
.b409	c5 36		cmp $36				cmp 	zTemp0
.b40b	d0 f4		bne $b401			bne 	_LCPadOut
.b40d	a0 03		ldy #$03			ldy 	#3 							; start position.
.b40f					_LCMainLoop:
.b40f	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b411	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b414	b1 30		lda ($30),y			lda 	(codePtr),y
.b416	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b418	f0 17		beq $b431			beq 	_LCExit
.b41a	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b41c	90 1e		bcc $b43c			bcc 	_LCDoubles
.b41e	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b420	90 2a		bcc $b44c			bcc 	_LCShiftPunc
.b422	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b424	90 35		bcc $b45b			bcc 	_LCPunctuation
.b426	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b428	90 3e		bcc $b468			bcc 	_LCIdentifiers
.b42a	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b42c	90 5f		bcc $b48d			bcc 	_LCTokens
.b42e	4c ed b4	jmp $b4ed			jmp 	_LCData 					; 254-5 are data objects
.b431					_LCExit:
.b431	68		pla				pla 								; get old indent adjust
.b432	30 07		bmi $b43b			bmi 	_LCExit2
.b434	18		clc				clc 								; add to indent if +ve
.b435	6d a6 04	adc $04a6			adc 	listIndent
.b438	8d a6 04	sta $04a6			sta 	listIndent
.b43b					_LCExit2:
.b43b	60		rts				rts
.b43c					_LCDoubles:
.b43c	48		pha				pha
.b43d	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b43e	29 02		and #$02			and 	#2
.b440	09 3c		ora #$3c			ora 	#60 						; make < >
.b442	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b445	68		pla				pla 								; restore, do lower bit
.b446	29 03		and #$03			and 	#3
.b448	09 3c		ora #$3c			ora 	#60
.b44a	80 0f		bra $b45b			bra		_LCPunctuation 				; print, increment, loop
.b44c					_LCShiftPunc:
.b44c	aa		tax				tax 								; save in X
.b44d	29 07		and #$07			and 	#7 							; lower 3 bits
.b44f	f0 02		beq $b453			beq 	_LCNoAdd
.b451	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b453					_LCNoAdd:
.b453	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b455	90 02		bcc $b459			bcc 	_LCNoAdd2
.b457	09 20		ora #$20			ora 	#32 						; adds $20
.b459					_LCNoAdd2:
.b459	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b45b					_LCPunctuation:
.b45b	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b45d	d0 03		bne $b462			bne 	_LCPContinue
.b45f	20 34 b5	jsr $b534			jsr 	LCLDeleteLastSpace
.b462					_LCPContinue:
.b462	c8		iny				iny 								; consume character
.b463	20 1e b5	jsr $b51e			jsr 	LCLWrite 					; write it out.
.b466	80 a7		bra $b40f			bra 	_LCMainLoop 				; go round again.
.b468					_LCIdentifiers:
.b468	18		clc				clc 								; convert to physical address
.b469	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b46b	85 37		sta $37				sta 	zTemp0+1
.b46d	c8		iny				iny
.b46e	b1 30		lda ($30),y			lda 	(codePtr),y
.b470	85 36		sta $36				sta 	zTemp0
.b472	c8		iny				iny
.b473	5a		phy				phy 								; save position
.b474	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b476	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b479	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b47b					_LCOutIdentifier:
.b47b	c8		iny				iny
.b47c	b1 36		lda ($36),y			lda 	(zTemp0),y
.b47e	29 7f		and #$7f			and 	#$7F
.b480	20 70 b5	jsr $b570			jsr 	LCLLowerCase
.b483	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b486	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b488	10 f1		bpl $b47b			bpl 	_LCOutIdentifier
.b48a	7a		ply				ply 								; restore position
.b48b	80 82		bra $b40f			bra 	_LCMainLoop
.b48d					_LCTokens:
.b48d	aa		tax				tax 								; token in X
.b48e	a9 75		lda #$75			lda 	#((KeywordSet2) & $FF)
.b490	85 36		sta $36				sta 	0+zTemp0
.b492	a9 bc		lda #$bc			lda 	#((KeywordSet2) >> 8)
.b494	85 37		sta $37				sta 	1+zTemp0
.b496	e0 82		cpx #$82			cpx 	#$82
.b498	f0 16		beq $b4b0			beq 	_LCUseShift
.b49a	a9 27		lda #$27			lda 	#((KeywordSet1) & $FF)
.b49c	85 36		sta $36				sta 	0+zTemp0
.b49e	a9 bc		lda #$bc			lda 	#((KeywordSet1) >> 8)
.b4a0	85 37		sta $37				sta 	1+zTemp0
.b4a2	e0 81		cpx #$81			cpx 	#$81
.b4a4	f0 0a		beq $b4b0			beq 	_LCUseShift
.b4a6	a9 31		lda #$31			lda 	#((KeywordSet0) & $FF)
.b4a8	85 36		sta $36				sta 	0+zTemp0
.b4aa	a9 ba		lda #$ba			lda 	#((KeywordSet0) >> 8)
.b4ac	85 37		sta $37				sta 	1+zTemp0
.b4ae	80 01		bra $b4b1			bra 	_LCNoShift
.b4b0					_LCUseShift:
.b4b0	c8		iny				iny
.b4b1					_LCNoShift:
.b4b1	20 48 b5	jsr $b548			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b4b4	b1 30		lda ($30),y			lda 	(codePtr),y
.b4b6	aa		tax				tax 								; into X
.b4b7					_LCFindText:
.b4b7	ca		dex				dex
.b4b8	10 0e		bpl $b4c8			bpl 	_LCFoundText 				; found text.
.b4ba	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b4bc	1a		inc a				inc 	a 							; one extra for size
.b4bd	38		sec				sec 								; one extra for checksum
.b4be	65 36		adc $36				adc 	zTemp0 						; go to next token
.b4c0	85 36		sta $36				sta 	zTemp0
.b4c2	90 f3		bcc $b4b7			bcc 	_LCFindText
.b4c4	e6 37		inc $37				inc 	zTemp0+1
.b4c6	80 ef		bra $b4b7			bra 	_LCFindText
.b4c8					_LCFoundText:
.b4c8	5a		phy				phy 								; save List position
.b4c9	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b4cb	aa		tax				tax
.b4cc	a9 83		lda #$83			lda 	#CLIToken+$80
.b4ce	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b4d1	a0 02		ldy #$02			ldy 	#2
.b4d3					_LCCopyToken:
.b4d3	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4d5	20 70 b5	jsr $b570			jsr 	LCLLowerCase
.b4d8	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b4db	c8		iny				iny
.b4dc	ca		dex				dex
.b4dd	d0 f4		bne $b4d3			bne 	_LCCopyToken
.b4df	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b4e1	f0 05		beq $b4e8			beq 	_LCNoSpace
.b4e3	a9 20		lda #$20			lda 	#' '
.b4e5	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b4e8					_LCNoSpace:
.b4e8	7a		ply				ply 								; restore position.
.b4e9	c8		iny				iny 								; consume token
.b4ea	4c 0f b4	jmp $b40f			jmp 	_LCMainLoop 				; and go around again.
.b4ed					_LCData:
.b4ed	48		pha				pha 								; save type $FE/$FF
.b4ee	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b4f0	c9 fe		cmp #$fe			cmp 	#$FE
.b4f2	f0 07		beq $b4fb			beq 	_LCHaveOpener
.b4f4	a2 22		ldx #$22			ldx 	#'"'
.b4f6	a9 81		lda #$81			lda 	#CLIData+$80
.b4f8	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b4fb					_LCHaveOpener:
.b4fb	8a		txa				txa 								; output prefix (# or ")
.b4fc	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b4ff	c8		iny				iny 								; get count
.b500	b1 30		lda ($30),y			lda 	(codePtr),y
.b502	aa		tax				tax
.b503	c8		iny				iny 								; point at first character
.b504					_LCOutData:
.b504	b1 30		lda ($30),y			lda 	(codePtr),y
.b506	c9 00		cmp #$00			cmp 	#0
.b508	f0 03		beq $b50d			beq 	_LCNoPrint
.b50a	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b50d					_LCNoPrint:
.b50d	c8		iny				iny
.b50e	ca		dex				dex
.b50f	d0 f3		bne $b504			bne 	_LCOutData
.b511	68		pla				pla 								; closing " required ?
.b512	c9 ff		cmp #$ff			cmp 	#$FF
.b514	d0 05		bne $b51b			bne 	_LCNoQuote
.b516	a9 22		lda #$22			lda 	#'"'
.b518	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b51b					_LCNoQuote:
.b51b	4c 0f b4	jmp $b40f			jmp 	_LCMainLoop
.b51e					LCLWrite:
.b51e	da		phx				phx
.b51f	ae 9d 04	ldx $049d			ldx 	tbOffset
.b522	9d ab 04	sta $04ab,x			sta 	tokenBuffer,x
.b525	9e ac 04	stz $04ac,x			stz 	tokenBuffer+1,x
.b528	ee 9d 04	inc $049d			inc 	tbOffset
.b52b	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b52d	30 03		bmi $b532			bmi 	_LCLNoColour
.b52f	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b532					_LCLNoColour:
.b532	fa		plx				plx
.b533	60		rts				rts
.b534					LCLDeleteLastSpace:
.b534	48		pha				pha
.b535	da		phx				phx
.b536	ae 9d 04	ldx $049d			ldx 	tbOffset
.b539	f0 0a		beq $b545			beq 	_LCDLSExit
.b53b	bd aa 04	lda $04aa,x			lda 	tokenBuffer-1,x
.b53e	c9 20		cmp #$20			cmp 	#' '
.b540	d0 03		bne $b545			bne 	_LCDLSExit
.b542	ce 9d 04	dec $049d			dec 	tbOffset
.b545					_LCDLSExit:
.b545	fa		plx				plx
.b546	68		pla				pla
.b547	60		rts				rts
.b548					LCLCheckSpaceRequired:
.b548	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b54b	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b54d	f0 1b		beq $b56a			beq 	_LCCSRSpace
.b54f	c9 29		cmp #$29			cmp 	#')'
.b551	f0 17		beq $b56a			beq 	_LCCSRSpace
.b553	c9 23		cmp #$23			cmp 	#'#'
.b555	f0 13		beq $b56a			beq 	_LCCSRSpace
.b557	20 70 b5	jsr $b570			jsr 	LCLLowerCase 				; saves a little effort
.b55a	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b55c	90 11		bcc $b56f			bcc 	_LCCSRExit
.b55e	c9 3a		cmp #$3a			cmp 	#"9"+1
.b560	90 08		bcc $b56a			bcc 	_LCCSRSpace
.b562	c9 61		cmp #$61			cmp 	#"a"
.b564	90 09		bcc $b56f			bcc 	_LCCSRExit
.b566	c9 7b		cmp #$7b			cmp 	#"z"+1
.b568	b0 05		bcs $b56f			bcs 	_LCCSRExit
.b56a					_LCCSRSpace:
.b56a	a9 20		lda #$20			lda 	#' '
.b56c	20 1e b5	jsr $b51e			jsr 	LCLWrite
.b56f					_LCCSRExit:
.b56f	60		rts				rts
.b570					LCLLowerCase:
.b570	c9 41		cmp #$41			cmp 	#"A"
.b572	90 06		bcc $b57a			bcc 	_LCLLCOut
.b574	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b576	b0 02		bcs $b57a			bcs 	_LCLLCOut
.b578	69 20		adc #$20			adc 	#$20
.b57a					_LCLLCOut:
.b57a	60		rts				rts
.b57b					LCLUpperCase:
.b57b	c9 61		cmp #$61			cmp 	#"a"
.b57d	90 06		bcc $b585			bcc 	_LCLUCOut
.b57f	c9 7b		cmp #$7b			cmp 	#"z"+1
.b581	b0 02		bcs $b585			bcs 	_LCLUCOut
.b583	e9 1f		sbc #$1f			sbc 	#$1F
.b585					_LCLUCOut:
.b585	60		rts				rts
.b586					TOKSearchTable:
.b586	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token.
.b588	85 36		sta $36				sta 	zTemp0
.b58a	a0 00		ldy #$00			ldy 	#0
.b58c	a9 80		lda #$80			lda 	#$80 						; token #
.b58e	85 38		sta $38				sta 	zTemp1
.b590					_TSTLoop:
.b590	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b592	30 49		bmi $b5dd			bmi 	_TSTFail 					; -ve = end of table
.b594	f0 2e		beq $b5c4			beq 	_TSTNext 					; zero, check next it's a dummy
.b596	c8		iny				iny 								; get the hash
.b597	b1 36		lda ($36),y			lda 	(zTemp0),y
.b599	88		dey				dey
.b59a	cd 83 04	cmp $0483			cmp 	identHash 					; check they match, if not go to next
.b59d	d0 25		bne $b5c4			bne 	_TSTNext
.b59f	ad 82 04	lda $0482			lda 	identTypeEnd 				; length of identifier
.b5a2	38		sec				sec
.b5a3	ed 80 04	sbc $0480			sbc 	identStart
.b5a6	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; no match, then return.
.b5a8	d0 1a		bne $b5c4			bne 	_TSTNext
.b5aa	5a		phy				phy 								; save Y , we might fail
.b5ab	c8		iny				iny 								; point to text
.b5ac	c8		iny				iny
.b5ad	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b5b0					_TSTCompareName:
.b5b0	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; compare text.
.b5b3	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b5b5	d0 0c		bne $b5c3			bne 	_TSTNextPullY 				; fail, pullY and do next
.b5b7	e8		inx				inx
.b5b8	c8		iny				iny
.b5b9	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b5bc	d0 f2		bne $b5b0			bne 	_TSTCompareName
.b5be	7a		ply				ply 								; throw Y
.b5bf	a5 38		lda $38				lda 	zTemp1 						; get token #
.b5c1	38		sec				sec 								; return with CS = passed.
.b5c2	60		rts				rts
.b5c3					_TSTNextPullY:
.b5c3	7a		ply				ply 								; restore current, fall through.
.b5c4					_TSTNext:
.b5c4	e6 38		inc $38				inc 	zTemp1 						; token counter
.b5c6	98		tya				tya
.b5c7	18		clc				clc
.b5c8	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b5ca	1a		inc a				inc 	a 							; +1
.b5cb	1a		inc a				inc 	a 							; +2
.b5cc	a8		tay				tay
.b5cd	10 c1		bpl $b590			bpl 	_TSTLoop 					; if Y < $80 loop back
.b5cf	98		tya				tya 								; add Y to zTemp0 and reset Y
.b5d0	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b5d2	18		clc				clc  								; but have tables > 255 bytes
.b5d3	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b5d5	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b5d7	90 b7		bcc $b590			bcc 	_TSTLoop
.b5d9	e6 37		inc $37				inc 	zTemp0+1
.b5db	80 b3		bra $b590			bra 	_TSTLoop
.b5dd					_TSTFail:
.b5dd	18		clc				clc
.b5de	60		rts				rts
.b5df					TokeniseLine:
.b5df	20 67 b7	jsr $b767			jsr 	LCLFixLineBufferCase 		; fix line case
.b5e2	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b5e4	8d a8 04	sta $04a8			sta 	tokenOffset
.b5e7	9c a9 04	stz $04a9			stz 	tokenLineNumber
.b5ea	9c aa 04	stz $04aa			stz 	tokenLineNumber+1
.b5ed	a2 ff		ldx #$ff			ldx 	#$FF
.b5ef					_TKFindFirst:
.b5ef	e8		inx				inx
.b5f0	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b5f3	f0 79		beq $b66e			beq 	_TKExit
.b5f5	c9 20		cmp #$20			cmp 	#' '
.b5f7	90 f6		bcc $b5ef			bcc 	_TKFindFirst
.b5f9	c9 30		cmp #$30			cmp 	#'0'
.b5fb	90 07		bcc $b604			bcc 	_TKNoLineNumber
.b5fd	c9 3a		cmp #$3a			cmp 	#'9'+1
.b5ff	b0 03		bcs $b604			bcs 	_TKNoLineNumber
.b601	20 91 b7	jsr $b791			jsr 	TOKExtractLineNumber
.b604					_TKNoLineNumber:
.b604					_TKTokeniseLoop:
.b604	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b607	f0 65		beq $b66e			beq 	_TKExit
.b609	e8		inx				inx
.b60a	c9 20		cmp #$20			cmp 	#' '
.b60c	f0 f6		beq $b604			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b60e	ca		dex				dex 								; undo last get, A contains character, X is position.
.b60f	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b611	f0 61		beq $b674			beq 	_TKTokeniseIdentifier
.b613	c9 41		cmp #$41			cmp 	#'A'
.b615	90 04		bcc $b61b			bcc 	_TKTokenisePunctuation
.b617	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b619	90 59		bcc $b674			bcc 	_TKTokeniseIdentifier
.b61b					_TKTokenisePunctuation:
.b61b	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b61d	f0 27		beq $b646			beq 	_TKString
.b61f	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant (# only appears at end of identifiers)
.b621	f0 28		beq $b64b			beq 	_TKHexConstant
.b623	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers.
.b625	f0 29		beq $b650			beq 	_TKCheckDouble
.b627	c9 3e		cmp #$3e			cmp 	#'>'
.b629	f0 25		beq $b650			beq 	_TKCheckDouble
.b62b					_TKStandardPunctuation:
.b62b	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get it back.
.b62e	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b630	90 0e		bcc $b640			bcc 	_TKNoShift
.b632	48		pha				pha 								; save
.b633	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b635	85 36		sta $36				sta 	zTemp0
.b637	68		pla				pla
.b638	29 20		and #$20			and 	#32 						; bit 5
.b63a	4a		lsr a				lsr 	a 							; shift into bit 3
.b63b	4a		lsr a				lsr 	a
.b63c	05 36		ora $36				ora 	zTemp0
.b63e	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b640					_TKNoShift:
.b640	20 d6 b7	jsr $b7d6			jsr 	TOKWriteByte 				; write the punctuation character
.b643	e8		inx				inx 								; consume the character
.b644	80 be		bra $b604			bra 	_TKTokeniseLoop 			; and loop round again.
.b646					_TKString:
.b646	20 f6 b6	jsr $b6f6			jsr 	TOKTokenString
.b649	80 b9		bra $b604			bra 	_TKTokeniseLoop
.b64b					_TKHexConstant:
.b64b	20 31 b7	jsr $b731			jsr 	TOKHexConstant
.b64e	80 b4		bra $b604			bra 	_TKTokeniseLoop
.b650					_TKCheckDouble:
.b650	bd a9 05	lda $05a9,x			lda 	lineBuffer+1,x 				; get next character
.b653	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b655	90 d4		bcc $b62b			bcc 	_TKStandardPunctuation
.b657	c9 3f		cmp #$3f			cmp 	#'>'+1
.b659	b0 d0		bcs $b62b			bcs 	_TKStandardPunctuation
.b65b	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b65e	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b660	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b661	7d a9 05	adc $05a9,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b664	38		sec				sec
.b665	e9 3c		sbc #$3c			sbc 	#'<'
.b667	20 d6 b7	jsr $b7d6			jsr 	TOKWriteByte 				; this is in the range 0-7
.b66a	e8		inx				inx 								; consume both
.b66b	e8		inx				inx
.b66c	80 96		bra $b604			bra 	_TKTokeniseLoop
.b66e	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b670	20 d6 b7	jsr $b7d6			jsr 	TOKWriteByte
.b673	60		rts				rts
.b674					_TKTokeniseIdentifier:
.b674	8e 80 04	stx $0480			stx 	identStart 					; save start
.b677	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b67a					_TKCheckLoop:
.b67a	e8		inx				inx 								; look at next, we know first is identifier.
.b67b	bd a8 05	lda $05a8,x			lda  	lineBuffer,x
.b67e	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b680	f0 f8		beq $b67a			beq 	_TKCheckLoop
.b682	c9 30		cmp #$30			cmp	 	#"0"
.b684	90 0c		bcc $b692			bcc 	_TKEndIdentifier
.b686	c9 3a		cmp #$3a			cmp 	#"9"+1
.b688	90 f0		bcc $b67a			bcc 	_TKCheckLoop
.b68a	c9 41		cmp #$41			cmp	 	#"A"
.b68c	90 04		bcc $b692			bcc 	_TKEndIdentifier
.b68e	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b690	90 e8		bcc $b67a			bcc 	_TKCheckLoop
.b692					_TKEndIdentifier:
.b692	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b695	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b697	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b699	f0 06		beq $b6a1			beq 	_TKHasTypeCharacter
.b69b	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b69d	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b69f	d0 07		bne $b6a8			bne 	_TKNoTypeCharacter
.b6a1					_TKHasTypeCharacter:
.b6a1	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b6a4	e8		inx				inx 								; read next
.b6a5	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b6a8					_TKNoTypeCharacter:
.b6a8	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b6aa	d0 09		bne $b6b5			bne 	_TKNoArray
.b6ac	e8		inx				inx 								; skip the (
.b6ad	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array)
.b6b0	09 04		ora #$04			ora 	#$04
.b6b2	8d 84 04	sta $0484			sta 	identTypeByte
.b6b5					_TKNoArray:
.b6b5	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b6b8	20 52 b7	jsr $b752			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b6bb	a0 ba		ldy #$ba			ldy 	#(KeywordSet0) >> 8
.b6bd	a9 31		lda #$31			lda 	#(KeywordSet0) & $FF
.b6bf	20 86 b5	jsr $b586			jsr 	TOKSearchTable
.b6c2	a2 00		ldx #$00			ldx 	#0
.b6c4	b0 1f		bcs $b6e5			bcs 	_TKFoundToken
.b6c6	a0 bc		ldy #$bc			ldy 	#(KeywordSet1) >> 8
.b6c8	a9 27		lda #$27			lda 	#(KeywordSet1) & $FF
.b6ca	20 86 b5	jsr $b586			jsr 	TOKSearchTable
.b6cd	a2 81		ldx #$81			ldx 	#$81
.b6cf	b0 14		bcs $b6e5			bcs 	_TKFoundToken
.b6d1	a0 bc		ldy #$bc			ldy 	#(KeywordSet2) >> 8
.b6d3	a9 75		lda #$75			lda 	#(KeywordSet2) & $FF
.b6d5	20 86 b5	jsr $b586			jsr 	TOKSearchTable
.b6d8	a2 82		ldx #$82			ldx 	#$82
.b6da	b0 09		bcs $b6e5			bcs 	_TKFoundToken
.b6dc	20 e2 b7	jsr $b7e2			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b6df	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6e2	4c 04 b6	jmp $b604			jmp 	_TKTokeniseLoop 			; and go round again.
.b6e5					_TKFoundToken:
.b6e5	48		pha				pha 								; save token
.b6e6	8a		txa				txa 								; shift in X, is there one ?
.b6e7	f0 03		beq $b6ec			beq 	_TKNoTShift
.b6e9	20 d6 b7	jsr $b7d6			jsr 	TOKWriteByte 				; if so, write it out
.b6ec					_TKNoTShift:
.b6ec	68		pla				pla 								; restore and write token
.b6ed	20 d6 b7	jsr $b7d6			jsr 	TOKWriteByte
.b6f0	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6f3	4c 04 b6	jmp $b604			jmp 	_TKTokeniseLoop 			; and go round again.
.b6f6					TOKTokenString:
.b6f6	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b6f8	20 d6 b7	jsr $b7d6			jsr 	TOKWriteByte
.b6fb	e8		inx				inx									; start of quoted string.
.b6fc	da		phx				phx 								; push start of string on top
.b6fd	ca		dex				dex
.b6fe					_TSFindEnd:
.b6fe	e8		inx				inx
.b6ff	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character
.b702	f0 04		beq $b708			beq 	_TSEndOfString
.b704	c9 22		cmp #$22			cmp 	#'"'
.b706	d0 f6		bne $b6fe			bne 	_TSFindEnd
.b708					_TSEndOfString:
.b708	7a		ply				ply  								; so now Y is first character, X is character after end.
.b709	48		pha				pha 								; save terminating character
.b70a	20 12 b7	jsr $b712			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b70d	68		pla				pla 								; terminating character
.b70e	f0 01		beq $b711			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b710	e8		inx				inx
.b711					_TSNotQuote:
.b711	60		rts				rts
.b712					TOKWriteBlockXY:
.b712	86 36		stx $36				stx 	zTemp0 						; write end character
.b714	98		tya				tya
.b715	49 ff		eor #$ff			eor 	#$FF
.b717	38		sec				sec
.b718	65 36		adc $36				adc 	zTemp0
.b71a	1a		inc a				inc 	a 							; one extra for NULL
.b71b	20 d6 b7	jsr $b7d6			jsr 	TOKWriteByte
.b71e					_TOBlockLoop:
.b71e	c4 36		cpy $36				cpy 	zTemp0
.b720	f0 09		beq $b72b			beq 	_TOBlockExit
.b722	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.b725	20 d6 b7	jsr $b7d6			jsr 	TOKWriteByte
.b728	c8		iny				iny
.b729	80 f3		bra $b71e			bra 	_TOBlockLoop
.b72b					_TOBlockExit:
.b72b	a9 00		lda #$00			lda 	#0
.b72d	20 d6 b7	jsr $b7d6			jsr 	TOKWriteByte
.b730	60		rts				rts
.b731					TOKHexConstant:
.b731	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b733	20 d6 b7	jsr $b7d6			jsr 	TOKWriteByte
.b736	e8		inx				inx									; start of quoted string.
.b737	da		phx				phx 								; push start of constant on top
.b738	ca		dex				dex
.b739					_THFindLoop:
.b739	e8		inx				inx
.b73a	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b73d	c9 30		cmp #$30			cmp 	#"0"
.b73f	90 0c		bcc $b74d			bcc 	_THFoundEnd
.b741	c9 3a		cmp #$3a			cmp 	#"9"+1
.b743	90 f4		bcc $b739			bcc 	_THFindLoop
.b745	c9 41		cmp #$41			cmp 	#"A"
.b747	90 04		bcc $b74d			bcc 	_THFoundEnd
.b749	c9 47		cmp #$47			cmp 	#"F"+1
.b74b	90 ec		bcc $b739			bcc 	_THFindLoop
.b74d					_THFoundEnd:
.b74d	7a		ply				ply 								; restore start
.b74e	20 12 b7	jsr $b712			jsr 	TOKWriteBlockXY 			; output the block
.b751	60		rts				rts
.b752					TOKCalculateHash:
.b752	da		phx				phx
.b753	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum
.b756	a9 00		lda #$00			lda 	#0
.b758					_TCHLoop:
.b758	18		clc				clc
.b759	7d a8 05	adc $05a8,x			adc 	lineBuffer,x
.b75c	e8		inx				inx
.b75d	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b760	d0 f6		bne $b758			bne 	_TCHLoop
.b762	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b765	fa		plx				plx
.b766	60		rts				rts
.b767					LCLFixLineBufferCase:
.b767	a2 00		ldx #$00			ldx 	#0
.b769					_FLBCLoop:
.b769	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next character
.b76c	f0 22		beq $b790			beq 	_FLBCExit 					; end of string.
.b76e	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b770	f0 11		beq $b783			beq 	_FLBCInQuotes
.b772	e8		inx				inx
.b773	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b775	90 f2		bcc $b769			bcc 	_FLBCLoop
.b777	c9 7b		cmp #$7b			cmp 	#'z'+1
.b779	b0 ee		bcs $b769			bcs 	_FLBCLoop
.b77b	38		sec				sec 								; make U/C
.b77c	e9 20		sbc #$20			sbc 	#32
.b77e	9d a7 05	sta $05a7,x			sta	 	lineBuffer-1,x 				; write back
.b781	80 e6		bra $b769			bra 	_FLBCLoop
.b783					_FLBCInQuotes:
.b783	e8		inx				inx 								; advance
.b784	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next
.b787	f0 07		beq $b790			beq 	_FLBCExit 					; exit on EOS
.b789	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b78b	d0 f6		bne $b783			bne 	_FLBCInQuotes
.b78d	e8		inx				inx 								; skip over it
.b78e	80 d9		bra $b769			bra 	_FLBCLoop
.b790					_FLBCExit:
.b790	60		rts				rts
.b791					TOKExtractLineNumber:
.b791	ad aa 04	lda $04aa			lda 	tokenLineNumber+1 			; push current value on stack
.b794	48		pha				pha
.b795	ad a9 04	lda $04a9			lda 	tokenLineNumber
.b798	48		pha				pha
.b799	20 cf b7	jsr $b7cf			jsr 	_LCLNTimes2 				; line # x 4
.b79c	20 cf b7	jsr $b7cf			jsr 	_LCLNTimes2 				; line # x 2
.b79f	18		clc				clc 								; add stacked value
.b7a0	68		pla				pla
.b7a1	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b7a4	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b7a7	68		pla				pla
.b7a8	6d aa 04	adc $04aa			adc 	tokenLineNumber+1
.b7ab	8d aa 04	sta $04aa			sta 	tokenLineNumber+1 			; line # x 5
.b7ae	20 cf b7	jsr $b7cf			jsr 	_LCLNTimes2 				; line # x 10
.b7b1	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get and consume character
.b7b4	e8		inx				inx
.b7b5	29 0f		and #$0f			and 	#15 						; add to line #
.b7b7	18		clc				clc
.b7b8	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b7bb	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b7be	90 03		bcc $b7c3			bcc 	_TLENNoCarry
.b7c0	ee aa 04	inc $04aa			inc 	tokenLineNumber+1
.b7c3					_TLENNoCarry:
.b7c3	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; more digits ?
.b7c6	c9 30		cmp #$30			cmp 	#'0'
.b7c8	90 04		bcc $b7ce			bcc 	_TLENExit
.b7ca	c9 3a		cmp #$3a			cmp 	#'9'+1
.b7cc	90 c3		bcc $b791			bcc 	TOKExtractLineNumber
.b7ce					_TLENExit:
.b7ce	60		rts				rts
.b7cf					_LCLNTimes2:
.b7cf	0e a9 04	asl $04a9			asl 	tokenLineNumber
.b7d2	2e aa 04	rol $04aa			rol 	tokenLineNumber+1
.b7d5	60		rts				rts
.b7d6					TOKWriteByte:
.b7d6	da		phx				phx
.b7d7	ae a8 04	ldx $04a8			ldx 	tokenOffset 				; next slot to write to
.b7da	9d a8 04	sta $04a8,x			sta 	tokenOffset,x 				; write byte out
.b7dd	ee a8 04	inc $04a8			inc 	tokenOffset 				; advance slot.
.b7e0	fa		plx				plx
.b7e1	60		rts				rts
.b7e2					TOKCheckCreateVariableRecord:
.b7e2	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b7e4	85 36		sta $36				sta 	0+zTemp0
.b7e6	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b7e8	85 37		sta $37				sta 	1+zTemp0
.b7ea					_CCVSearch:
.b7ea	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b7ec	f0 2c		beq $b81a			beq 	_CCVFail
.b7ee	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b7f0	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b7f2	cd 83 04	cmp $0483			cmp 	identHash
.b7f5	d0 16		bne $b80d			bne 	_CCVNext
.b7f7	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b7f9	ae 80 04	ldx $0480			ldx 	identStart
.b7fc					_CCVCompare:
.b7fc	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b7ff	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b801	e8		inx				inx 								; advance pointers
.b802	c8		iny				iny
.b803	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b804	d0 07		bne $b80d			bne 	_CCVNext  					; didn't match go to next.
.b806	90 f4		bcc $b7fc			bcc 	_CCVCompare 				; not finished yet.
.b808	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b80b	f0 41		beq $b84e			beq 	_CCVFound 					; yes, we were successful
.b80d					_CCVNext:
.b80d	18		clc				clc
.b80e	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b810	65 36		adc $36				adc 	zTemp0
.b812	85 36		sta $36				sta 	zTemp0
.b814	90 d4		bcc $b7ea			bcc 	_CCVSearch
.b816	e6 37		inc $37				inc 	zTemp0+1
.b818	80 d0		bra $b7ea			bra 	_CCVSearch
.b81a					_CCVFail:
.b81a	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b81c	ad 83 04	lda $0483			lda 	identHash
.b81f	91 36		sta ($36),y			sta 	(zTemp0),y
.b821	c8		iny				iny 								; offset 2 is the type byte
.b822	ad 84 04	lda $0484			lda 	identTypeByte
.b825	91 36		sta ($36),y			sta 	(zTemp0),y
.b827	c8		iny				iny
.b828					_CCVData:
.b828	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b82a	91 36		sta ($36),y			sta 	(zTemp0),y
.b82c	c8		iny				iny
.b82d	c0 08		cpy #$08			cpy 	#8
.b82f	90 f7		bcc $b828			bcc 	_CCVData
.b831	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b834					_CCVCopyName:
.b834	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b837	91 36		sta ($36),y			sta 	(zTemp0),y
.b839	e8		inx				inx
.b83a	c8		iny				iny
.b83b	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b83e	d0 f4		bne $b834			bne 	_CCVCopyName
.b840	98		tya				tya 								; patch offset
.b841	92 36		sta ($36)			sta 	(zTemp0)
.b843	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b845	91 36		sta ($36),y			sta 	(zTemp0),y
.b847	88		dey				dey
.b848	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b84a	09 80		ora #$80			ora 	#$80
.b84c	91 36		sta ($36),y			sta 	(zTemp0),y
.b84e					_CCVFound:
.b84e	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b850	38		sec				sec
.b851	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b853	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b855	20 d6 b7	jsr $b7d6			jsr 	TOKWriteByte
.b858	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b85a	20 d6 b7	jsr $b7d6			jsr 	TOKWriteByte
.b85d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b85e					SNDCheckChannel:
.b85e	aa		tax				tax
.b85f	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b862	d0 38		bne $b89c			bne 	_SNDCCExit
.b864	da		phx				phx 								; save current channel
.b865	8a		txa				txa 								; put in A
.b866	20 e2 b8	jsr $b8e2			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b869	68		pla				pla 								; channel # in A
.b86a	90 30		bcc $b89c			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b86c	a8		tay				tay 								; Y is the channel #
.b86d	bd fe 06	lda $06fe,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b870	99 fd 07	sta $07fd,y			sta 	SNDPitchLow,y
.b873	bd ff 06	lda $06ff,x			lda 	SNDQueue+2,x
.b876	99 01 08	sta $0801,y			sta 	SNDPitchHigh,y
.b879	bd 00 07	lda $0700,x			lda 	SNDQueue+3,x
.b87c	99 05 08	sta $0805,y			sta 	SNDVolume,y
.b87f	bd 01 07	lda $0701,x			lda 	SNDQueue+4,x
.b882	99 09 08	sta $0809,y			sta 	SNDTimeLeft,y
.b885	bd 02 07	lda $0702,x			lda 	SNDQueue+5,x
.b888	99 0d 08	sta $080d,y			sta 	SNDAdjustLow,y
.b88b	bd 03 07	lda $0703,x			lda 	SNDQueue+6,x
.b88e	99 11 08	sta $0811,y			sta 	SNDAdjustHigh,y
.b891	5a		phy				phy 								; save channel #
.b892	20 fc b8	jsr $b8fc			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b895	ce fc 06	dec $06fc			dec 	SNDLength 					; reduce the queue length.
.b898	68		pla				pla
.b899	20 9d b8	jsr $b89d			jsr 	SNDUpdateNote 				; update channel A
.b89c					_SNDCCExit:
.b89c	60		rts				rts
.b89d					SNDUpdateNote:
.b89d	aa		tax				tax 								; so we can access records
.b89e	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b89f	0a		asl a				asl 	a
.b8a0	0a		asl a				asl 	a
.b8a1	0a		asl a				asl 	a
.b8a2	0a		asl a				asl 	a
.b8a3	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b8a6	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; are we silent
.b8a9	f0 2e		beq $b8d9			beq 	_SNDUNIsSilent
.b8ab	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; push channel bits on stack
.b8ae	48		pha				pha
.b8af	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b8b2	29 0f		and #$0f			and 	#$0F
.b8b4	0d fb 06	ora $06fb			ora 	SNDChannelBits 				; set channel bits
.b8b7	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b8b9	20 46 b9	jsr $b946			jsr 	SNDWritePorts
.b8bc	bd 01 08	lda $0801,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b8bf	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b8c2	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x
.b8c5	4e fb 06	lsr $06fb			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b8c8	6a		ror a				ror 	a
.b8c9	4e fb 06	lsr $06fb			lsr 	SNDChannelBits
.b8cc	6a		ror a				ror 	a
.b8cd	4a		lsr a				lsr 	a 							; put in bits 0-5
.b8ce	4a		lsr a				lsr 	a
.b8cf	20 46 b9	jsr $b946			jsr 	SNDWritePorts 				; write as rest of pitch register
.b8d2	68		pla				pla
.b8d3	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b8d5	20 46 b9	jsr $b946			jsr 	SNDWritePorts
.b8d8	60		rts				rts
.b8d9					_SNDUNIsSilent:
.b8d9	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; channel bits
.b8dc	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b8de	20 46 b9	jsr $b946			jsr 	SNDWritePorts 				; write to the ports
.b8e1	60		rts				rts
.b8e2					SNDFindNextNoteForA:
.b8e2	ac fc 06	ldy $06fc			ldy 	SNDLength 					; queue size into Y
.b8e5	f0 13		beq $b8fa			beq 	_SNDFNNFail 				; queue empty.
.b8e7	a2 00		ldx #$00			ldx 	#0
.b8e9					_SNDFNNSearch:
.b8e9	dd fd 06	cmp $06fd,x			cmp 	SNDQueue,x 					; does it match the channel
.b8ec	38		sec				sec
.b8ed	f0 0c		beq $b8fb			beq 	_SNDFNNExit 				; if so exit with CS.
.b8ef	e8		inx				inx 								; next queue slot.
.b8f0	e8		inx				inx
.b8f1	e8		inx				inx
.b8f2	e8		inx				inx
.b8f3	e8		inx				inx
.b8f4	e8		inx				inx
.b8f5	e8		inx				inx
.b8f6	e8		inx				inx
.b8f7	88		dey				dey 								; done the whole queue
.b8f8	d0 ef		bne $b8e9			bne 	_SNDFNNSearch 				; no, go back.
.b8fa					_SNDFNNFail:
.b8fa	18		clc				clc
.b8fb					_SNDFNNexit:
.b8fb	60		rts				rts
.b8fc					SNDDeleteXFromQueue:
.b8fc	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b8fe	f0 09		beq $b909			beq 	_SNDDXExit
.b900	bd 05 07	lda $0705,x			lda 	SNDQueue+8,x
.b903	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b906	e8		inx				inx
.b907	80 f3		bra $b8fc			bra 	SNDDeleteXFromQueue
.b909					_SNDDXExit:
.b909	60		rts				rts
.06fb					SNDChannelBits:
>06fb							.fill 	1
.b90a					SNDQueueRequest:
.b90a	86 36		stx $36				stx 	zTemp0						; save queue address
.b90c	84 37		sty $37				sty 	zTemp0+1
.b90e	ae fc 06	ldx $06fc			ldx 	SNDLength 					; queue is full, can't take any more.
.b911	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b913	f0 21		beq $b936			beq 	_SNDQRExit
.b915	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b917	48		pha				pha
.b918	8a		txa				txa  								; get offset in queue buffer/
.b919	0a		asl a				asl 	a
.b91a	0a		asl a				asl 	a
.b91b	0a		asl a				asl 	a
.b91c	aa		tax				tax
.b91d	68		pla				pla 								; get back and push again
.b91e	48		pha				pha
.b91f	9d fd 06	sta $06fd,x			sta 	SNDQueue+0,x 				; save the channel #
.b922	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b924					_SNDQCopy:
.b924	b1 36		lda ($36),y			lda 	(zTemp0),y
.b926	e8		inx				inx
.b927	c8		iny				iny
.b928	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b92b	c0 06		cpy #$06			cpy 	#6
.b92d	d0 f5		bne $b924			bne 	_SNDQCopy
.b92f	ee fc 06	inc $06fc			inc 	SNDLength 					; bump queue length.
.b932	68		pla				pla 								; get channel # back
.b933	20 5e b8	jsr $b85e			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b936					_SNDQRExit:
.b936	60		rts				rts
.b937					SNDSilenceChannel:
.b937	aa		tax				tax 								; zero time left.
.b938	9e 09 08	stz $0809,x			stz 	SNDTimeLeft,x
.b93b	0a		asl a				asl 	a 							; shift into position
.b93c	0a		asl a				asl 	a
.b93d	0a		asl a				asl 	a
.b93e	0a		asl a				asl 	a
.b93f	0a		asl a				asl 	a
.b940	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b942	20 46 b9	jsr $b946			jsr 	SNDWritePorts
.b945	60		rts				rts
.b946					SNDWritePorts:
.b946	64 01		stz $01				stz 	1
.b948	8d 00 d6	sta $d600			sta 	$D600
.b94b	8d 10 d6	sta $d610			sta 	$D610
.b94e	60		rts				rts
.b94f					SNDCommand:
.b94f	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b951	f0 1c		beq $b96f			beq 	_SNDInitialise
.b953	90 27		bcc $b97c			bcc 	_SNDExit
.b955	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b957	f0 16		beq $b96f			beq 	_SNDSilence
.b959	b0 21		bcs $b97c			bcs 	_SNDExit
.b95b	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b95d	b0 09		bcs $b968			bcs 	_SNDQueryPlay
.b95f	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b961	b0 19		bcs $b97c			bcs 	_SNDExit
.b963	20 0a b9	jsr $b90a			jsr 	SNDQueueRequest
.b966	80 14		bra $b97c			bra 	_SNDExit
.b968					_SNDQueryPlay:
.b968	29 03		and #$03			and 	#3 							; get channel #
.b96a	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b96d	80 0d		bra $b97c			bra 	_SNDExit
.b96f					_SNDInitialise:
.b96f					_SNDSilence:
.b96f	9c fc 06	stz $06fc			stz 	SNDLength 					; empty the queue.
.b972	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b974					_SNDSilenceLoop:
.b974	48		pha				pha
.b975	20 37 b9	jsr $b937			jsr 	SNDSilenceChannel
.b978	68		pla				pla
.b979	3a		dec a				dec 	a
.b97a	10 f8		bpl $b974			bpl 	_SNDSilenceLoop
.b97c					_SNDExit:
.b97c	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fc					SNDLength:
>06fc							.fill 	1
.06fd					SNDQueue:
>06fd							.fill 	SNDQueueSize * 8
.07fd					SNDPitchLow:
>07fd							.fill 	4
.0801					SNDPitchHigh:
>0801							.fill 	4
.0805					SNDVolume:
>0805							.fill 	4
.0809					SNDTimeLeft:
>0809							.fill 	4
.080d					SNDAdjustLow:
>080d							.fill 	4
.0811					SNDAdjustHigh:
>0811							.fill 	4
.b97d					SNDUpdate:
.b97d	ad 09 08	lda $0809			lda 	SNDTimeLeft+0 				; look at time remaining
.b980	f0 05		beq $b987			beq 	_SNDUNot0 					; not playing
.b982	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.b984	20 a6 b9	jsr $b9a6			jsr 	SNDUpdateChannel 			; update it.
.b987					_SNDUNot0:
.b987	ad 0a 08	lda $080a			lda 	SNDTimeLeft+1
.b98a	f0 05		beq $b991			beq 	_SNDUNot1
.b98c	a2 01		ldx #$01			ldx 	#1
.b98e	20 a6 b9	jsr $b9a6			jsr 	SNDUpdateChannel
.b991					_SNDUNot1:
.b991	ad 0b 08	lda $080b			lda 	SNDTimeLeft+2
.b994	f0 05		beq $b99b			beq 	_SNDUNot2
.b996	a2 02		ldx #$02			ldx 	#2
.b998	20 a6 b9	jsr $b9a6			jsr 	SNDUpdateChannel
.b99b					_SNDUNot2:
.b99b	ad 0c 08	lda $080c			lda 	SNDTimeLeft+3
.b99e	f0 05		beq $b9a5			beq 	_SNDUNot3
.b9a0	a2 03		ldx #$03			ldx 	#3
.b9a2	20 a6 b9	jsr $b9a6			jsr 	SNDUpdateChannel
.b9a5					_SNDUNot3:
.b9a5	60		rts				rts
.b9a6					SNDUpdateChannel:
.b9a6	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.b9a8	f0 2c		beq $b9d6			beq 	_SNDUCExit
.b9aa	3a		dec a				dec 	a 							; decrement and update timer
.b9ab	9d 09 08	sta $0809,x			sta 	SNDTimeLeft,x
.b9ae	f0 1d		beq $b9cd			beq 	_SNDUCUpdate 				; if zero, silence channel
.b9b0	bd 0d 08	lda $080d,x			lda 	SNDAdjustLow,x 				; adjust ?
.b9b3	1d 11 08	ora $0811,x			ora 	SNDAdjustHigh,x
.b9b6	f0 1e		beq $b9d6			beq 	_SNDUCExit 					; if zero carry on at current tone.
.b9b8	18		clc				clc 								; add adjust, forcing into a 10 bit range
.b9b9	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x
.b9bc	7d 0d 08	adc $080d,x			adc 	SNDAdjustLow,x
.b9bf	9d fd 07	sta $07fd,x			sta 	SNDPitchLow,x
.b9c2	bd 01 08	lda $0801,x			lda 	SNDPitchHigh,x
.b9c5	7d 11 08	adc $0811,x			adc 	SNDAdjustHigh,x
.b9c8	29 03		and #$03			and 	#3
.b9ca	9d 01 08	sta $0801,x			sta 	SNDPitchHigh,x
.b9cd					_SNDUCUpdate:
.b9cd	8a		txa				txa 								; which channel.
.b9ce	48		pha				pha
.b9cf	20 9d b8	jsr $b89d			jsr 	SNDUpdateNote 				; update the current note
.b9d2	68		pla				pla
.b9d3	20 5e b8	jsr $b85e			jsr 	SNDCheckChannel 			; more to do ?
.b9d6					_SNDUCExit:
.b9d6	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
