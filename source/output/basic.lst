
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Thu Dec  1 10:29:17 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	MaxLineSize+1
.057b					numberBuffer:
>057b							.fill 	34
.059d					decimalBuffer:
>059d							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c 11 a7	jmp $a711		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c aa a9	jmp $a9aa		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c e0 a9	jmp $a9e0		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c 06 aa	jmp $aa06		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c 09 aa	jmp $aa09		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c c0 a8	jmp $a8c0		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c a4 aa	jmp $aaa4		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 59 bd	jmp $bd59		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c 8c bd	jmp $bd8c		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 4f b7	jmp $b74f		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c e3 b9	jmp $b9e3		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.802a	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.802c	aa		tax				tax
.802d	a8		tay				tay
.802e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.8031	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8033	20 18 80	jsr $8018			jsr 	SNDCommand
.8036	20 6f 89	jsr $896f			jsr 	NewProgram 					; erase current program
.8039	20 ae 82	jsr $82ae			jsr 	BackloadProgram
.803c	4c ab 8a	jmp $8aab			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.803f					AssembleGroup1:
.803f	a9 ff		lda #$ff			lda 	#$FF
.8041	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8044	80 02		bra $8048			bra 	AsmGroup12
.8046					AssembleGroup2:
.8046	a9 00		lda #$00			lda 	#$00
.8048					AsmGroup12:
.8048	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.804b	68		pla				pla 								; pop the return address to access the information following.
.804c	fa		plx				plx
.804d	20 d4 80	jsr $80d4			jsr 	AccessParameters 			; get opcode and save as base
.8050	8d 24 04	sta $0424			sta 	BaseOpcode
.8053	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8056	d0 08		bne $8060			bne 	_AG12HaveMask
.8058	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.805a	20 dc 80	jsr $80dc			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.805d	8d 25 04	sta $0425			sta 	ModeMask
.8060					_AG12HaveMask:
.8060	20 10 82	jsr $8210			jsr 	TypeAndCalculateOperand 	; get zero page type
.8063	da		phx				phx 								; save found address mode
.8064	20 40 81	jsr $8140			jsr 	AssembleModeX
.8067	fa		plx				plx  								; restore address mode
.8068	b0 0b		bcs $8075			bcs 	_AG12Exit
.806a	20 76 80	jsr $8076			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.806d	20 40 81	jsr $8140			jsr 	AssembleModeX
.8070	b0 03		bcs $8075			bcs 	_AG12Exit
.8072	4c 15 9f	jmp $9f15			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8075					_AG12Exit:
.8075	60		rts				rts
.8076					PromoteToAbsolute:
.8076	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.8078	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.807a	f0 19		beq $8095			beq 	_PTADo
.807c	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.807e	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.8080	f0 13		beq $8095			beq 	_PTADo
.8082	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.8084	e0 80		cpx #$80			cpx 	#AM_ZEROY
.8086	f0 0d		beq $8095			beq 	_PTADo
.8088	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.808a	e0 d1		cpx #$d1			cpx 	#AM_IND
.808c	f0 07		beq $8095			beq 	_PTADo
.808e	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8090	e0 c0		cpx #$c0			cpx 	#AM_INDX
.8092	f0 01		beq $8095			beq 	_PTADo
.8094	60		rts				rts
.8095					_PTADo:
.8095	aa		tax				tax
.8096	60		rts				rts
.8097					AssembleGroup3:
.8097	68		pla				pla 								; get parameters, which is just the opcode.
.8098	fa		plx				plx
.8099	20 d4 80	jsr $80d4			jsr 	AccessParameters 			; get and output opcode
.809c	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte
.809f	20 74 82	jsr $8274			jsr 	CalculateOperand 			; get a 16 bit operand
.80a2	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80a4	38		sec				sec
.80a5	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80a8	48		pha				pha 								; LSB in A
.80a9	a5 60		lda $60				lda 	NSMantissa1
.80ab	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80ae	aa		tax				tax 								; MSB in X
.80af	68		pla				pla
.80b0	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80b1	69 7f		adc #$7f			adc 	#$7F
.80b3	90 01		bcc $80b6			bcc 	_AG3NoCarry
.80b5	e8		inx				inx
.80b6					_AG3NoCarry:
.80b6	38		sec				sec 								; fix back and write out anyways.
.80b7	e9 80		sbc #$80			sbc 	#$80
.80b9	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte
.80bc	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80be	f0 0a		beq $80ca			beq 	_AG3Exit
.80c0	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.80c3	29 01		and #$01			and 	#1
.80c5	f0 03		beq $80ca			beq 	_AG3Exit
.80c7	4c 1a 9f	jmp $9f1a			jmp 	RangeError 					; no, branch is out of range
.80ca					_AG3Exit:
.80ca	60		rts				rts
.80cb					AssembleGroup4:
.80cb	68		pla				pla 								; pop address
.80cc	fa		plx				plx
.80cd	20 d4 80	jsr $80d4			jsr 	AccessParameters 			; access and get first
.80d0	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte 			; output it.
.80d3	60		rts				rts
.80d4					AccessParameters:
.80d4	8d 21 04	sta $0421			sta 	ParamStart
.80d7	8e 22 04	stx $0422			stx 	ParamStart+1
.80da	a9 01		lda #$01			lda 	#1
.80dc					GetParameter:
.80dc	5a		phy				phy
.80dd	a8		tay				tay
.80de	ad 21 04	lda $0421			lda 	ParamStart
.80e1	85 36		sta $36				sta 	zTemp0
.80e3	ad 22 04	lda $0422			lda 	ParamStart+1
.80e6	85 37		sta $37				sta 	zTemp0+1
.80e8	b1 36		lda ($36),y			lda 	(zTemp0),y
.80ea	7a		ply				ply
.80eb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.80ec					AssemblerWriteByte:
.80ec	48		pha			pha
.80ed	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.80f0	29 02		and #$02		and 	#2
.80f2	f0 1b		beq $810f		beq 	_AWBNoPrint
.80f4	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.80f7	20 2a 81	jsr $812a		jsr 	PrintHex
.80fa	ad 1e 04	lda $041e		lda		AssemblerAddress
.80fd	20 2a 81	jsr $812a		jsr 	PrintHex
.8100	a9 20		lda #$20		lda 	#' '
.8102	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8105	68		pla			pla 									; print byte
.8106	48		pha			pha
.8107	20 2a 81	jsr $812a		jsr 	PrintHex
.810a	a9 0d		lda #$0d		lda 	#13
.810c	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.810f					_AWBNoPrint:
.810f	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8112	85 36		sta $36			sta 	zTemp0
.8114	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.8117	f0 0e		beq $8127		beq 	_AWBRange
.8119	85 37		sta $37			sta 	zTemp0+1
.811b	68		pla			pla 									; write byte out
.811c	92 36		sta ($36)		sta 	(zTemp0)
.811e	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8121	d0 03		bne $8126		bne 	_AWBNoCarry
.8123	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.8126					_AWBNoCarry:
.8126	60		rts			rts
.8127					_AWBRange:
.8127	4c 1a 9f	jmp $9f1a		jmp 	RangeError
.812a					PrintHex:
.812a	48		pha				pha
.812b	4a		lsr a				lsr 	a
.812c	4a		lsr a				lsr 	a
.812d	4a		lsr a				lsr 	a
.812e	4a		lsr a				lsr 	a
.812f	20 33 81	jsr $8133			jsr 	_PrintNibble
.8132	68		pla				pla
.8133					_PrintNibble:
.8133	29 0f		and #$0f			and 	#15
.8135	c9 0a		cmp #$0a			cmp 	#10
.8137	90 02		bcc $813b			bcc 	_NoShift
.8139	69 06		adc #$06			adc 	#6
.813b					_NoShift:
.813b	69 30		adc #$30			adc 	#48
.813d	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8140					AssembleModeX:
.8140	5a		phy				phy
.8141	ad 23 04	lda $0423			lda 	IsGroup1
.8144	f0 17		beq $815d			beq 	_AMXGroup2
.8146	8a		txa				txa 							; is it in group # 1
.8147	29 40		and #$40			and 	#AM_ISG1
.8149	f0 4d		beq $8198			beq 	_AMXFail 				; no, give up.
.814b	8a		txa				txa 							; get back.
.814c	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.814e	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8150	d0 22		bne $8174			bne 	_AMXHaveInfo
.8152	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8155	c9 81		cmp #$81			cmp 	#$81
.8157	f0 3f		beq $8198			beq 	_AMXFail
.8159	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.815b	80 17		bra $8174			bra 	_AMXHaveInfo 			; odd design decision there.
.815d					_AMXGroup2:
.815d	8a		txa				txa 							; is it in group 2 ?
.815e	29 20		and #$20			and 	#AM_ISG2
.8160	f0 36		beq $8198			beq 	_AMXFail 				; no, give up.
.8162	8a		txa				txa 							; get the offset into Y
.8163	29 1f		and #$1f			and 	#$1F
.8165	4a		lsr a				lsr 	a 						; make it 0-7.
.8166	4a		lsr a				lsr  	a
.8167	a8		tay				tay
.8168	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.816b					_AMXCheckOkay:
.816b	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.816c	88		dey				dey
.816d	10 fc		bpl $816b			bpl 	_AMXCheckOkay
.816f	90 27		bcc $8198			bcc 	_AMXFail 				; not allowed.
.8171	8a		txa				txa  							; get mask back
.8172	29 1f		and #$1f			and 	#$1F
.8174					_AMXHaveInfo:
.8174	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.8176	10 04		bpl $817c			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.8178	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.817a	d0 1c		bne $8198			bne 	_AMXFail
.817c					_AMXAnySize:
.817c	18		clc				clc 							; add offset to the base opcode
.817d	6d 24 04	adc $0424			adc 	BaseOpcode
.8180					_AMXOutputCode:
.8180	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte 		; write the opcode out.
.8183	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.8185	f0 0e		beq $8195			beq 	_AMXExit
.8187	a5 58		lda $58				lda 	NSMantissa0 				; write LSB operand
.8189	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte
.818c	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.818e	30 05		bmi $8195			bmi 	_AMXExit
.8190	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.8192	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte
.8195					_AMXExit:
.8195	7a		ply				ply
.8196	38		sec				sec
.8197	60		rts				rts
.8198					_AMXFail:
.8198	a0 00		ldy #$00			ldy 	#0
.819a					_AMXCheckOddities:
.819a	8a		txa				txa
.819b	d9 c2 81	cmp $81c2,y			cmp 	ExtraOpcode+2,y 		; match address mode
.819e	d0 15		bne $81b5			bne 	_AMXCONext
.81a0	b9 c0 81	lda $81c0,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81a3	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81a6	d0 0d		bne $81b5			bne 	_AMXCONext
.81a8	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81aa	10 04		bpl $81b0			bpl 	_AMXCONotZero
.81ac	a5 60		lda $60				lda 	NSMantissa1
.81ae	d0 05		bne $81b5			bne 	_AMXCONext
.81b0					_AMXCONotZero:
.81b0	b9 c1 81	lda $81c1,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81b3	80 cb		bra $8180			bra 	_AMXOutputCode 			; and assemble it
.81b5					_AMXCONext:
.81b5	c8		iny				iny
.81b6	c8		iny				iny
.81b7	c8		iny				iny
.81b8	b9 c0 81	lda $81c0,y			lda 	ExtraOpcode+0,y 		; end of table
.81bb	d0 dd		bne $819a			bne 	_AMXCheckOddities
.81bd					_AMXCOFail:
.81bd	7a		ply				ply
.81be	18		clc				clc
.81bf	60		rts				rts
.81c0					ExtraOpcode:
>81c0	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>81c3	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>81c6	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81c9	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81cc	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>81cf	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>81d2	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>81d5	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>81d8	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>81db	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>81de	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.81df					LabelHere:
.81df	c8		iny				iny 								; skip .
.81e0	a2 00		ldx #$00			ldx 	#0 							; get a term
.81e2	20 d8 97	jsr $97d8			jsr 	EvaluateTerm 				; get a term
.81e5	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.81e7	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.81e9	d0 22		bne $820d			bne 	_ALType
.81eb	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.81ed	85 36		sta $36				sta 	zTemp0
.81ef	b5 60		lda $60,x			lda 	NSMantissa1,x
.81f1	85 37		sta $37				sta 	zTemp0+1
.81f3	5a		phy				phy 								; copy address in.
.81f4	a0 01		ldy #$01			ldy 	#1
.81f6	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.81f9	92 36		sta ($36)			sta 	(zTemp0)
.81fb	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.81fe	91 36		sta ($36),y			sta 	(zTemp0),y
.8200	c8		iny				iny
.8201	a9 00		lda #$00			lda 	#0
.8203	91 36		sta ($36),y			sta 	(zTemp0),y
.8205	c8		iny				iny
.8206	91 36		sta ($36),y			sta 	(zTemp0),y
.8208	c8		iny				iny
.8209	91 36		sta ($36),y			sta 	(zTemp0),y
.820b	7a		ply				ply
.820c	60		rts				rts
.820d					_ALType:
.820d	4c 1f 9f	jmp $9f1f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8210					TypeAndCalculateOperand:
.8210	b1 30		lda ($30),y			lda 	(codePtr),y
.8212	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8214	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8216	f0 5b		beq $8273			beq 	_TACOExit
.8218	c9 80		cmp #$80			cmp 	#KWC_EOL
.821a	f0 57		beq $8273			beq 	_TACOExit
.821c	c8		iny				iny
.821d	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.821f	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8221	f0 51		beq $8274			beq 	CalculateOperand
.8223	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8225	f0 1f		beq $8246			beq 	_TACOIndirect
.8227	88		dey				dey 								; undo get of first character
.8228	20 74 82	jsr $8274			jsr 	CalculateOperand 			; get operand
.822b	b1 30		lda ($30),y			lda 	(codePtr),y
.822d	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.822f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8231	d0 40		bne $8273			bne 	_TACOExit
.8233	c8		iny				iny
.8234	20 7e 82	jsr $827e			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8237	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.8239	c9 58		cmp #$58			cmp 	#'X'
.823b	f0 36		beq $8273			beq 	_TACOExit
.823d	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.823f	c9 59		cmp #$59			cmp 	#'Y'
.8241	f0 30		beq $8273			beq 	_TACOExit
.8243					_TACOSyntax:
.8243	4c 15 9f	jmp $9f15			jmp 	SyntaxError
.8246					_TACOIndirect:
.8246	20 74 82	jsr $8274			jsr 	CalculateOperand 			; get the operand
.8249	b1 30		lda ($30),y			lda 	(codePtr),y
.824b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.824d	f0 17		beq $8266			beq 	_TACOIndX
.824f	20 71 8e	jsr $8e71			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8252	b1 30		lda ($30),y			lda 	(codePtr),y
.8254	a2 d1		ldx #$d1			ldx 	#AM_IND
.8256	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.8258	d0 19		bne $8273			bne 	_TACOExit
.825a	c8		iny				iny
.825b	20 7e 82	jsr $827e			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.825e	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8260	d0 e1		bne $8243			bne 	_TACOSyntax
.8262	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8264	80 0d		bra $8273			bra 	_TACOExit
.8266					_TACOIndX:
.8266	c8		iny				iny
.8267	20 7e 82	jsr $827e			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.826a	c9 58		cmp #$58			cmp 	#'X' 						; check X
.826c	d0 d5		bne $8243			bne 	_TACOSyntax
.826e	20 71 8e	jsr $8e71			jsr 	CheckRightBracket			; check )
.8271	a2 c0		ldx #$c0			ldx 	#AM_INDX
.8273					_TACOExit:
.8273	60		rts				rts
.8274					CalculateOperand:
.8274	48		pha				pha
.8275	da		phx				phx
.8276	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.8278	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger
.827b	fa		plx				plx
.827c	68		pla				pla
.827d	60		rts				rts
.827e					TACOCheckXY:
.827e	b1 30		lda ($30),y			lda 	(codePtr),y
.8280	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.8282	c9 40		cmp #$40			cmp 	#$40
.8284	d0 21		bne $82a7			bne 	_TCXYFail
.8286	b1 30		lda ($30),y			lda 	(codePtr),y
.8288	18		clc				clc
.8289	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.828b	85 37		sta $37				sta 	zTemp0+1
.828d	c8		iny				iny
.828e	b1 30		lda ($30),y			lda 	(codePtr),y
.8290	c8		iny				iny
.8291	85 36		sta $36				sta 	zTemp0
.8293	5a		phy				phy 								; save position
.8294	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.8296	b1 36		lda ($36),y			lda 	(zTemp0),y
.8298	d0 0c		bne $82a6			bne 	_TCXYPopFail
.829a	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.829c	b1 36		lda ($36),y			lda 	(zTemp0),y
.829e	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82a0	f0 08		beq $82aa			beq 	_TCXYFound
.82a2	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82a4	f0 04		beq $82aa			beq 	_TCXYFound
.82a6					_TCXYPopFail:
.82a6	7a		ply				ply
.82a7					_TCXYFail:
.82a7	a9 00		lda #$00			lda 	#0
.82a9	60		rts				rts
.82aa					_TCXYFound:
.82aa	7a		ply				ply 								; restore position
.82ab	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82ad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82ae					BackloadProgram:
.82ae	a2 82		ldx #$82			ldx 	#_BLLoad >> 8
.82b0	a9 f5		lda #$f5			lda 	#_BLLoad & $FF
.82b2	20 e3 8e	jsr $8ee3			jsr 	PrintStringXA
.82b5	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82b7	8d ad 05	sta $05ad			sta 	0+BackLoadPointer
.82ba	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82bc	8d ae 05	sta $05ae			sta 	1+BackLoadPointer
.82bf	a9 ff		lda #$ff			lda 	#$FF
.82c1	8d fa ff	sta $fffa			sta 	$FFFA
.82c4					_BPLoop:
.82c4	a2 ff		ldx #$ff			ldx 	#$FF
.82c6	20 0a 83	jsr $830a			jsr 	BLReadByte 					; read a byte
.82c9	c9 00		cmp #$00			cmp 	#0
.82cb	f0 21		beq $82ee			beq 	_BPExit 					; if 0 exit
.82cd	30 1f		bmi $82ee			bmi 	_BPExit 					; if -ve exit
.82cf					_BPCopy:
.82cf	e8		inx				inx  								; copy byte into the lineBuffer
.82d0	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.82d3	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.82d6	20 0a 83	jsr $830a			jsr 	BLReadByte 					; read next byte
.82d9	30 0a		bmi $82e5			bmi 	_BPEndLine 					; -ve = EOL
.82db	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.82dd	d0 02		bne $82e1			bne 	_BPNotTab
.82df	a9 20		lda #$20			lda 	#' '
.82e1					_BPNotTab:
.82e1	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.82e3	b0 ea		bcs $82cf			bcs 	_BPCopy 					; until a control character, should be 13 received.
.82e5					_BPEndLine:
.82e5	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.82e8	ea		nop				nop
.82e9	20 21 83	jsr $8321			jsr 	EditProgramCode
.82ec	80 d6		bra $82c4			bra 	_BPLoop
.82ee					_BPExit:
.82ee	9c fa ff	stz $fffa			stz 	$FFFA
.82f1	20 dc 83	jsr $83dc			jsr 	ClearCommand 				; clear variables etc.
.82f4	60		rts				rts
.82f5					_BLLoad:
>82f5	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>82fd	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.830a					BLReadByte:
.830a	ad ad 05	lda $05ad			lda 	BackLoadPointer 			; copy pointer to zTemp0
.830d	85 36		sta $36				sta 	zTemp0
.830f	ad ae 05	lda $05ae			lda 	BackLoadPointer+1
.8312	85 37		sta $37				sta 	zTemp0+1
.8314	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8316	ee ad 05	inc $05ad			inc 	BackLoadPointer 			; bump pointer
.8319	d0 03		bne $831e			bne 	_BLNoCarry
.831b	ee ae 05	inc $05ae			inc 	BackLoadPointer+1
.831e					_BLNoCarry:
.831e	c9 00		cmp #$00			cmp 	#0
.8320	60		rts				rts
.05ad					BackLoadPointer:
>05ad							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8321					EditProgramCode:
.8321	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line.
.8324	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.8327	20 03 a5	jsr $a503			jsr 	MemorySearch
.832a	90 05		bcc $8331			bcc 	_EPCNoDelete 				; reached the end don't delete
.832c	d0 03		bne $8331			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.832e	20 28 a4	jsr $a428			jsr 	MemoryDeleteLine 			; delete the line
.8331					_EPCNoDelete:
.8331	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty
.8334	c9 80		cmp #$80			cmp 	#KWC_EOL
.8336	f0 0d		beq $8345			beq 	_EPCNoInsert
.8338	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist.
.833b	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.833e	20 03 a5	jsr $a503			jsr 	MemorySearch
.8341	18		clc				clc 								; insert at this point.
.8342	20 5f a4	jsr $a45f			jsr 	MemoryInsertLine 			; insert the line
.8345					_EPCNoInsert:
.8345	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8346					WarmStart:
.8346	a2 ff		ldx #$ff			ldx 	#$FF
.8348	9a		txs				txs
.8349	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour
.834b	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.834e	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.8351	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.8354	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number ?
.8357	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.835a	d0 17		bne $8373			bne 	_WSEditCode 				; if so,edit code.
.835c	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.835f	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.8361	85 30		sta $30				sta 	codePtr
.8363	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8365	85 31		sta $31				sta 	codePtr+1
.8367	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.836a	c9 80		cmp #$80			cmp 	#KWC_EOL
.836c	f0 d8		beq $8346			beq 	WarmStart
.836e	20 bd 8a	jsr $8abd			jsr 	RUNCodePointerLine 			; execute that line.
.8371	80 d3		bra $8346			bra 	WarmStart
.8373					_WSEditCode:
.8373	20 21 83	jsr $8321			jsr 	EditProgramCode
.8376	20 dc 83	jsr $83dc			jsr 	ClearCommand
.8379	80 cb		bra $8346			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.837b					AssembleCommand:
.837b	a2 00		ldx #$00			ldx 	#0
.837d	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger 		; start address
.8380	a5 58		lda $58				lda 	NSMantissa0
.8382	8d 1e 04	sta $041e			sta 	AssemblerAddress
.8385	a5 60		lda $60				lda 	NSMantissa1
.8387	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.838a	20 79 8e	jsr $8e79			jsr 	CheckComma
.838d	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; options
.8390	a5 58		lda $58				lda 	NSMantissa0
.8392	8d 20 04	sta $0420			sta 	AssemblerControl
.8395	60		rts				rts
.8396	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.8397					AssertCommand:
.8397	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8399	20 04 9d	jsr $9d04			jsr 	EvaluateInteger 			; the assert test
.839c	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; exit if result is non zero.
.839f	d0 05		bne $83a6			bne 	_ACExit
.83a1	a9 0a		lda #$0a		lda	#10
.83a3	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.83a6					_ACExit:
.83a6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83a7					CallCommand:
.83a7	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83a9	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger
.83ac					_CCClear
.83ac	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83ad	20 97 9d	jsr $9d97			jsr 	NSMSetZero 					; these are optional sequentially.
.83b0	e0 04		cpx #$04			cpx 	#4
.83b2	d0 f8		bne $83ac			bne 	_CCClear
.83b4	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83b6					_CCCParam:
.83b6	b1 30		lda ($30),y			lda 	(codePtr),y
.83b8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83ba	d0 09		bne $83c5			bne 	_CCCRun6502
.83bc	c8		iny				iny 								; skip comma
.83bd	e8		inx				inx	 								; next level
.83be	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83c1	e0 03		cpx #$03			cpx 	#3
.83c3	90 f1		bcc $83b6			bcc 	_CCCParam 					; done all 3 ?
.83c5					_CCCRun6502:
.83c5	5a		phy				phy 								; save position
.83c6	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.83c8	85 37		sta $37				sta 	zTemp0+1
.83ca	a5 58		lda $58				lda 	NSMantissa0
.83cc	85 36		sta $36				sta 	zTemp0
.83ce	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.83d0	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.83d2	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.83d4	20 d9 83	jsr $83d9			jsr 	_CCCZTemp0 					; call zTemp0
.83d7	7a		ply				ply 								; restore position and exit
.83d8	60		rts				rts
.83d9					_CCCZTemp0:
.83d9	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83dc					ClearCommand:
.83dc	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83de	85 36		sta $36				sta 	0+zTemp0
.83e0	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83e2	85 37		sta $37				sta 	1+zTemp0
.83e4					_ClearZeroLoop:
.83e4	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.83e6	f0 24		beq $840c			beq 	_ClearZeroEnd
.83e8	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83ea	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.83ec					_ClearOneVariable:
.83ec	91 36		sta ($36),y			sta 	(zTemp0),y
.83ee	c8		iny				iny
.83ef	c0 08		cpy #$08			cpy 	#8
.83f1	d0 f9		bne $83ec			bne 	_ClearOneVariable
.83f3	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.83f5	b1 36		lda ($36),y			lda 	(zTemp0),y
.83f7	c9 18		cmp #$18			cmp 	#NSTProcedure
.83f9	d0 04		bne $83ff			bne 	_ClearNotProcedure
.83fb	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.83fd	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.83ff					_ClearNotProcedure:
.83ff	18		clc				clc 								; go to the next variable
.8400	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8402	65 36		adc $36				adc 	zTemp0
.8404	85 36		sta $36				sta 	zTemp0
.8406	90 dc		bcc $83e4			bcc 	_ClearZeroLoop
.8408	e6 37		inc $37				inc 	zTemp0+1
.840a	80 d8		bra $83e4			bra 	_ClearZeroLoop
.840c					_ClearZeroEnd:
.840c	18		clc				clc
.840d	a5 36		lda $36				lda 	zTemp0
.840f	69 01		adc #$01			adc 	#1
.8411	8d 0c 04	sta $040c			sta 	lowMemPtr
.8414	a5 37		lda $37				lda 	zTemp0+1
.8416	69 00		adc #$00			adc 	#0
.8418	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.841b	20 3f a6	jsr $a63f			jsr 	StackReset
.841e	20 a5 a6	jsr $a6a5			jsr 	StringSystemInitialise
.8421	20 17 8d	jsr $8d17			jsr 	ProcedureScan
.8424	20 6c 8a	jsr $8a6c			jsr 	Command_Restore
.8427	9c 1e 04	stz $041e			stz 	AssemblerAddress
.842a	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.842d	9c 20 04	stz $0420			stz 	AssemblerControl
.8430	20 bf 99	jsr $99bf			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8433	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8434					ClearScreen:
.8434	5a		phy				phy
.8435	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8437	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.843a	7a		ply				ply
.843b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.843c					Command_Data:
.843c	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.843e	a2 80		ldx #$80			ldx 	#KWC_EOL
.8440	20 69 8d	jsr $8d69			jsr 	ScanForward
.8443	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8444					DimCommand:
.8444	b1 30		lda ($30),y			lda 	(codePtr),y
.8446	29 c0		and #$c0			and 	#$C0
.8448	c9 40		cmp #$40			cmp 	#$40
.844a	d0 7a		bne $84c6			bne 	_DCSyntax
.844c	b1 30		lda ($30),y			lda 	(codePtr),y
.844e	18		clc				clc
.844f	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8451	85 3f		sta $3f				sta 	zaTemp+1
.8453	c8		iny				iny
.8454	b1 30		lda ($30),y			lda 	(codePtr),y
.8456	c8		iny				iny
.8457	85 3e		sta $3e				sta 	zaTemp
.8459	5a		phy				phy
.845a	a0 02		ldy #$02			ldy 	#2 						; read type byte
.845c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.845e	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8460	c9 18		cmp #$18			cmp 	#NSTProcedure
.8462	f0 62		beq $84c6			beq 	_DCSyntax
.8464	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8466	29 04		and #$04			and 	#NSBIsArray
.8468	f0 64		beq $84ce			beq 	_DCType
.846a	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.846c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.846e	d0 59		bne $84c9			bne 	_DCRedefine
.8470	7a		ply				ply
.8471	20 d1 84	jsr $84d1			jsr 	_DCGetSize 				; get array size, check it.
.8474	5a		phy				phy
.8475	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8477	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.8479	7a		ply				ply 							; is there a second (e.g. ,x)
.847a	b1 30		lda ($30),y			lda 	(codePtr),y
.847c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.847e	d0 0a		bne $848a			bne 	_DCOneDimension
.8480	c8		iny				iny 							; skip comma
.8481	20 d1 84	jsr $84d1			jsr 	_DCGetSize 				; get 2nd array size
.8484	5a		phy				phy
.8485	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8487	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8489	7a		ply				ply
.848a					_DCOneDimension:
.848a	5a		phy				phy 							; save position
.848b	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.848d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.848f	aa		tax				tax
.8490	c8		iny				iny
.8491	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8493	e8		inx				inx 							; bump them.
.8494	1a		inc a				inc 	a
.8495	20 42 9d	jsr $9d42			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.8498	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.849a	29 e0		and #$e0			and 	#$E0
.849c	d0 23		bne $84c1			bne 	_DCSize
.849e	a0 02		ldy #$02			ldy 	#2 						; get base type
.84a0	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a2	20 df 84	jsr $84df			jsr 	ScaleByBaseType 		; scale by base type
.84a5	a5 36		lda $36				lda 	zTemp0
.84a7	a6 37		ldx $37				ldx 	zTemp0+1
.84a9	20 81 99	jsr $9981			jsr 	AllocateXABytes 		; allocate memory
.84ac	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84ae	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84b0	c8		iny				iny
.84b1	8a		txa				txa
.84b2	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84b4	7a		ply				ply 							; get position back
.84b5	20 71 8e	jsr $8e71			jsr 	CheckRightBracket 		; check )
.84b8	b1 30		lda ($30),y			lda 	(codePtr),y
.84ba	c8		iny				iny 							; consume in case
.84bb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84bd	f0 85		beq $8444			beq 	DimCommand
.84bf	88		dey				dey 							; undo consume
.84c0	60		rts				rts
.84c1					_DCSize:
.84c1	a9 16		lda #$16		lda	#22
.84c3	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.84c6					_DCSyntax:
.84c6	4c 15 9f	jmp $9f15			jmp 	SyntaxError
.84c9					_DCRedefine:
.84c9	a9 15		lda #$15		lda	#21
.84cb	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.84ce					_DCType:
.84ce	4c 1f 9f	jmp $9f1f			jmp 	TypeError
.84d1					_DCGetSize:
.84d1	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84d3	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 	; get array dimension
.84d6	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84d8	f0 e7		beq $84c1			beq 	_DCSize
.84da	c9 fe		cmp #$fe			cmp 	#254
.84dc	f0 e3		beq $84c1			beq 	_DCSize
.84de	60		rts				rts
.84df					ScaleByBaseType:
.84df	29 10		and #$10			and 	#NSBIsString 			; is it string
.84e1	d0 19		bne $84fc			bne 	_SBBTString
.84e3	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84e5	48		pha				pha
.84e6	a5 36		lda $36				lda 	zTemp0
.84e8	48		pha				pha
.84e9	06 36		asl $36				asl 	zTemp0 					; x 2
.84eb	26 37		rol $37				rol 	zTemp0+1
.84ed	06 36		asl $36				asl 	zTemp0 					; x 4
.84ef	26 37		rol $37				rol 	zTemp0+1
.84f1	68		pla				pla 							; add stacked value = x 5
.84f2	65 36		adc $36				adc 	zTemp0
.84f4	85 36		sta $36				sta 	zTemp0
.84f6	68		pla				pla
.84f7	65 37		adc $37				adc 	zTemp0+1
.84f9	85 37		sta $37				sta 	zTemp0+1
.84fb	60		rts				rts
.84fc					_SBBTString:
.84fc	06 36		asl $36				asl 	zTemp0
.84fe	26 37		rol $37				rol 	zTemp0+1
.8500	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8501					EndCommand:
.8501	4c 46 83	jmp $8346			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8504					ForCommand:
.8504	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.8506	20 d9 a5	jsr $a5d9			jsr 	StackOpen
.8509	a2 00		ldx #$00			ldx 	#0
.850b	20 d8 97	jsr $97d8			jsr 	EvaluateTerm
.850e	b5 50		lda $50,x			lda 	NSStatus,x
.8510	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8512	d0 47		bne $855b			bne		_FCError
.8514	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8516	20 81 8e	jsr $8e81			jsr 	CheckNextA
.8519	e8		inx				inx
.851a	20 04 9d	jsr $9d04			jsr 	EvaluateInteger 			; <from> in +1
.851d	b1 30		lda ($30),y			lda 	(codePtr),y
.851f	c8		iny				iny 								; consume it
.8520	48		pha				pha 								; save on stack for later
.8521	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8523	f0 04		beq $8529			beq 	_FCNoSyntax
.8525	c9 ce		cmp #$ce			cmp 	#KWD_TO
.8527	d0 35		bne $855e			bne 	_FCSyntaxError
.8529					_FCNoSyntax:
.8529	e8		inx				inx
.852a	20 04 9d	jsr $9d04			jsr 	EvaluateInteger
.852d	20 1e a6	jsr $a61e			jsr 	STKSaveCodePosition 		; save loop back position
.8530	68		pla				pla 								; restore DOWNTO or TO
.8531	5a		phy				phy 								; save Y on the stack
.8532	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8534	f0 02		beq $8538			beq 	_FCNotDownTo
.8536	a9 02		lda #$02			lda 	#2
.8538					_FCNotDownTo:
.8538	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8539	a0 10		ldy #$10			ldy 	#16
.853b	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.853d	a0 06		ldy #$06			ldy 	#6
.853f	a5 58		lda $58				lda 	NSMantissa0
.8541	91 34		sta ($34),y			sta 	(basicStack),y
.8543	a5 60		lda $60				lda 	NSMantissa1
.8545	c8		iny				iny
.8546	91 34		sta ($34),y			sta 	(basicStack),y
.8548	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.854a	a2 01		ldx #$01			ldx 	#1
.854c	20 61 85	jsr $8561			jsr 	FCIntegerToStack
.854f	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8551	a2 02		ldx #$02			ldx 	#2
.8553	20 61 85	jsr $8561			jsr 	FCIntegerToStack
.8556	20 7c 85	jsr $857c			jsr 	CopyIndexToReference
.8559	7a		ply				ply 								; restore position
.855a	60		rts				rts
.855b					_FCError:
.855b	4c 1f 9f	jmp $9f1f			jmp 	TypeError
.855e					_FCSyntaxError:
.855e	4c 15 9f	jmp $9f15			jmp 	SyntaxError
.8561					FCIntegerToStack:
.8561	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8563	10 03		bpl $8568			bpl	 	_FCNotNegative
.8565	20 60 9d	jsr $9d60			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8568					_FCNotNegative:
.8568	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.856a	91 34		sta ($34),y			sta 	(basicStack),y
.856c	c8		iny				iny
.856d	b5 60		lda $60,x			lda 	NSMantissa1,x
.856f	91 34		sta ($34),y			sta 	(basicStack),y
.8571	c8		iny				iny
.8572	b5 68		lda $68,x			lda 	NSMantissa2,x
.8574	91 34		sta ($34),y			sta 	(basicStack),y
.8576	c8		iny				iny
.8577	b5 70		lda $70,x			lda 	NSMantissa3,x
.8579	91 34		sta ($34),y			sta 	(basicStack),y
.857b	60		rts				rts
.857c					CopyIndexToReference:
.857c	5a		phy				phy
.857d	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.857f	38		sec				sec 								; (because we copy from offset 8)
.8580	b1 34		lda ($34),y			lda 	(basicStack),y
.8582	e9 08		sbc #$08			sbc 	#8
.8584	85 36		sta $36				sta 	zTemp0
.8586	c8		iny				iny
.8587	b1 34		lda ($34),y			lda 	(basicStack),y
.8589	e9 00		sbc #$00			sbc 	#0
.858b	85 37		sta $37				sta 	zTemp0+1
.858d	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.858f	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.8591	b1 34		lda ($34),y			lda 	(basicStack),y
.8593	0a		asl a				asl 	a 							; into carry
.8594	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8596	90 14		bcc $85ac			bcc 	_CITRNormal
.8598	38		sec				sec
.8599					_CITRNegative:
.8599	a9 00		lda #$00			lda 	#0
.859b	f1 34		sbc ($34),y			sbc 	(basicStack),y
.859d	91 36		sta ($36),y			sta 	(zTemp0),y
.859f	c8		iny				iny
.85a0	ca		dex				dex
.85a1	d0 f6		bne $8599			bne 	_CITRNegative
.85a3	88		dey				dey 								; look at MSB of mantissa
.85a4	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85a6	09 80		ora #$80			ora 	#$80
.85a8	91 36		sta ($36),y			sta 	(zTemp0),y
.85aa	7a		ply				ply
.85ab	60		rts				rts
.85ac					_CITRNormal:
.85ac	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85ae	91 36		sta ($36),y			sta 	(zTemp0),y
.85b0	c8		iny				iny
.85b1	ca		dex				dex
.85b2	d0 f8		bne $85ac			bne 	_CITRNormal
.85b4	7a		ply				ply 								; and exit.
.85b5	60		rts				rts
.85b6					NextCommand:
.85b6	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85b8	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85ba	20 06 a6	jsr $a606			jsr 	StackCheckFrame
.85bd	5a		phy				phy
.85be	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85c0	b1 34		lda ($34),y			lda 	(basicStack),y
.85c2	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85c4	30 02		bmi $85c8			bmi 	_NCStepNeg
.85c6	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85c8					_NCStepNeg:
.85c8	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85ca	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85cc	18		clc				clc
.85cd					_NCBump:
.85cd	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85cf	91 34		sta ($34),y			sta 	(basicStack),y
.85d1	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85d3	c8		iny				iny 								; next byte
.85d4	ca		dex				dex 								; do four times
.85d5	d0 f6		bne $85cd			bne 	_NCBump
.85d7	20 7c 85	jsr $857c			jsr		CopyIndexToReference		; copy it to the reference variable.
.85da	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85dc	b1 34		lda ($34),y			lda 	(basicStack),y
.85de	0a		asl a				asl 	a 							; sign bit to carry
.85df	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85e1	85 38		sta $38				sta 	zTemp1
.85e3	90 02		bcc $85e7			bcc 	_NCCompRev 					; use if step is +ve
.85e5	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.85e7					_NCCompRev:
.85e7	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.85e9	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.85eb	85 39		sta $39				sta 	zTemp1+1
.85ed	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.85ef	38		sec				sec
.85f0					_NCCompare:
.85f0	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.85f2	b1 34		lda ($34),y			lda 	(basicStack),y
.85f4	a4 39		ldy $39				ldy 	zTemp1+1
.85f6	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85f8	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.85fa	e6 39		inc $39				inc 	zTemp1+1
.85fc	ca		dex				dex 								; do it 4 times.
.85fd	d0 f1		bne $85f0			bne 	_NCCompare
.85ff	50 02		bvc $8603			bvc 	_NCNoOverflow 				; convert to signed comparison
.8601	49 80		eor #$80			eor 	#$80
.8603					_NCNoOverflow:
.8603	7a		ply				ply 								; restore Y position
.8604	0a		asl a				asl 	a 							; is bit 7 set.
.8605	90 04		bcc $860b			bcc 	_NCLoopback 				; if no , >= so loop back
.8607	20 f8 a5	jsr $a5f8			jsr 	StackClose 					; exit the loop
.860a	60		rts				rts
.860b					_NCLoopBack:
.860b	20 2f a6	jsr $a62f			jsr 	STKLoadCodePosition 		; loop back
.860e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.860f					Command_GOSUB:
.860f	a2 00		ldx #$00			ldx 	#0
.8611	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8614	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8616	20 d9 a5	jsr $a5d9			jsr 	StackOpen 					; create frame
.8619	20 1e a6	jsr $a61e			jsr 	STKSaveCodePosition 		; save current position
.861c	4c 32 86	jmp $8632			jmp 	GotoStackX
.861f					Command_RETURN:
.861f	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8621	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8623	20 06 a6	jsr $a606			jsr 	StackCheckFrame
.8626	20 2f a6	jsr $a62f			jsr 	STKLoadCodePosition 		; restore code position
.8629	20 f8 a5	jsr $a5f8			jsr 	StackClose
.862c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.862d					GotoCommand:
.862d	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.862f	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger
.8632					GotoStackX:
.8632	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8634	48		pha				pha 								; it is slightly inefficient, just in cases.
.8635	b5 58		lda $58,x			lda 	NSMantissa0,x
.8637	fa		plx				plx
.8638	20 03 a5	jsr $a503			jsr 	MemorySearch 				; transfer to line number AX.
.863b	90 05		bcc $8642			bcc 	_GotoError 					; not found, off end.
.863d	d0 03		bne $8642			bne 	_GotoError 					; not found exactly
.863f	4c b6 8a	jmp $8ab6			jmp 	RunNewLine 					; and go straight to new line code.
.8642					_GotoError:
.8642	a9 0d		lda #$0d		lda	#13
.8644	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8647					IfCommand:
.8647	a2 00		ldx #$00			ldx 	#0 							; If what.
.8649	20 e5 9c	jsr $9ce5			jsr 	EvaluateNumber
.864c	b1 30		lda ($30),y			lda 	(codePtr),y
.864e	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8650	d0 0a		bne $865c			bne 	_IFStructured
.8652	c8		iny				iny 								; consume THEN
.8653	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; is it zero
.8656	f0 01		beq $8659			beq 	_IfFail 					; if fail, go to next line
.8658	60		rts				rts 								; if THEN just continue
.8659					_IfFail:
.8659	4c 9e 8a	jmp $8a9e			jmp 	EOLCommand
.865c					_IfStructured:
.865c	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; is it zero
.865f	d0 07		bne $8668			bne 	_IfExit 					; if not, then continue normally.
.8661	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8663	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8665	20 69 8d	jsr $8d69			jsr 	ScanForward 				; and run from there/
.8668					_IfExit:
.8668	60		rts				rts
.8669					ElseCode:
.8669	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.866b	aa		tax				tax 								; so just go to the structure exit
.866c	20 69 8d	jsr $8d69			jsr 	ScanForward
.866f	60		rts				rts
.8670					EndIf:
.8670	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8671					Command_Input:
.8671	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.8673	8d 28 04	sta $0428			sta 	IsInputFlag
.8676	80 03		bra $867b			bra 	Command_IP_Main
.8678					Command_Print:
.8678	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.867b					Command_IP_Main:
.867b	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.867c					_CPLoop:
.867c	08		php				php 								; save last action flag
.867d	b1 30		lda ($30),y			lda 	(codePtr),y
.867f	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8681	f0 54		beq $86d7			beq 	_CPExit
.8683	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8685	f0 50		beq $86d7			beq 	_CPExit
.8687	68		pla				pla 								; throw last action flag
.8688	b1 30		lda ($30),y			lda 	(codePtr),y
.868a	c8		iny				iny
.868b	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.868d	f0 45		beq $86d4			beq 	_CPContinueWithSameLine
.868f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8691	f0 3c		beq $86cf			beq 	_CPTab
.8693	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8695	f0 34		beq $86cb			beq 	_CPNewLine
.8697	88		dey				dey 								; undo the get.
.8698	20 8c 93	jsr $938c			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.869b	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.869d	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.869f	f0 0d		beq $86ae			beq 	_CPIsValue 					; no, display it.
.86a1	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.86a4	f0 05		beq $86ab			beq 	_CPIsPrint 					; otherwise display.
.86a6	20 e0 86	jsr $86e0			jsr 	CIInputValue 				; input a value to the reference
.86a9	80 20		bra $86cb			bra 	_CPNewLine
.86ab					_CPIsPrint:
.86ab	20 51 96	jsr $9651			jsr 	Dereference 				; dereference if required.
.86ae					_CPIsValue:
.86ae	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.86b0	29 10		and #$10			and 	#NSBIsString
.86b2	f0 09		beq $86bd			beq 	_CPNumber
.86b4	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.86b6	a5 58		lda $58				lda 	NSMantissa0
.86b8	20 43 87	jsr $8743			jsr 	CPPrintStringXA
.86bb	80 be		bra $867b			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86bd					_CPNumber:
.86bd	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86bf	20 cc 9b	jsr $9bcc			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.86c2	a2 05		ldx #$05			ldx 	#DecimalBuffer >> 8
.86c4	a9 9d		lda #$9d			lda 	#DecimalBuffer & $FF
.86c6	20 43 87	jsr $8743			jsr 	CPPrintStringXA 			; print it.
.86c9	80 b0		bra $867b			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86cb					_CPNewLine:
.86cb	a9 0d		lda #$0d			lda 	#13
.86cd	80 02		bra $86d1			bra 	_CPPrintChar
.86cf					_CPTab:
.86cf	a9 09		lda #$09			lda 	#9 							; print TAB
.86d1					_CPPrintChar:
.86d1	20 56 87	jsr $8756			jsr 	CPPrintVector
.86d4					_CPContinueWithSameLine:
.86d4	38		sec				sec 								; loop round with carry set, which
.86d5	80 a5		bra $867c			bra 	_CPLoop 					; will inhibit final CR
.86d7					_CPExit:
.86d7	28		plp				plp 								; get last action flag
.86d8	b0 05		bcs $86df			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.86da	a9 0d		lda #$0d			lda 	#13 						; print new line
.86dc	20 56 87	jsr $8756			jsr 	CPPrintVector
.86df					_CPExit2:
.86df	60		rts				rts
.86e0					CIInputValue:
.86e0	a2 00		ldx #$00			ldx 	#0 							; input a line.
.86e2					_CIInputLine:
.86e2	20 59 87	jsr $8759			jsr 	CPInputVector 				; get key
.86e5	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.86e7	f0 1f		beq $8708			beq 	_CIHaveValue
.86e9	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.86eb	f0 11		beq $86fe			beq 	_CIBackspace
.86ed	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.86ef	90 f1		bcc $86e2			bcc 	_CIInputLine
.86f1	e0 50		cpx #$50			cpx 	#80 						; max length
.86f3	b0 ed		bcs $86e2			bcs 	_CIInputLine
.86f5	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.86f8	e8		inx				inx
.86f9	20 56 87	jsr $8756			jsr 	CPPrintVector 				; echo it.
.86fc	80 e4		bra $86e2			bra 	_CIInputLine
.86fe					_CIBackSpace:
.86fe	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8700	f0 e0		beq $86e2			beq 	_CIInputLine
.8702	20 56 87	jsr $8756			jsr 	CPPrintVector 				; echo it.
.8705	ca		dex				dex
.8706	80 da		bra $86e2			bra 	_CIInputLine
.8708					_CIHaveValue:
.8708	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.870b	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.870d	29 10		and #$10			and 	#NSBIsString
.870f	f0 17		beq $8728			beq 	_CIAssignNumber 			; assign a number
.8711	a2 01		ldx #$01			ldx 	#1
.8713	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8715	95 58		sta $58,x			sta 	NSMantissa0,x
.8717	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8719	95 60		sta $60,x			sta 	NSMantissa1,x
.871b	74 68		stz $68,x			stz 	NSMantissa2,x
.871d	74 70		stz $70,x			stz 	NSMantissa3,x
.871f	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8721	95 50		sta $50,x			sta  	NSStatus,x
.8723	ca		dex				dex 								; X = 0
.8724	20 95 87	jsr $8795			jsr 	AssignVariable
.8727	60		rts				rts
.8728					_CIAssignNumber:
.8728	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.872a	85 36		sta $36				sta 	zTemp0
.872c	a9 05		lda #$05			lda 	#lineBuffer >> 8
.872e	85 37		sta $37				sta 	zTemp0+1
.8730	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8732	20 4e 9b	jsr $9b4e			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8735	90 07		bcc $873e			bcc 	_CIIsOkay
.8737	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8739	20 56 87	jsr $8756			jsr 	CPPrintVector
.873c	80 a2		bra $86e0			bra 	CIInputValue
.873e					_CIIsOkay:
.873e	ca		dex				dex 								; X = 0
.873f	20 95 87	jsr $8795			jsr 	AssignVariable
.8742	60		rts				rts
.8743					CPPrintStringXA:
.8743	5a		phy				phy
.8744	86 37		stx $37				stx 	zTemp0+1
.8746	85 36		sta $36				sta 	zTemp0
.8748	a0 00		ldy #$00			ldy 	#0
.874a					_PSXALoop:
.874a	b1 36		lda ($36),y			lda 	(zTemp0),y
.874c	f0 06		beq $8754			beq 	_PSXAExit
.874e	20 56 87	jsr $8756			jsr 	CPPrintVector
.8751	c8		iny				iny
.8752	80 f6		bra $874a			bra 	_PSXALoop
.8754					_PSXAExit:
.8754	7a		ply				ply
.8755	60		rts				rts
.8756					CPPrintVector:
.8756	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.8759					CPInputVector:
.8759	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.875c					LetCommand:
.875c	a2 00		ldx #$00			ldx 	#0
.875e	b1 30		lda ($30),y			lda 	(codePtr),y
.8760	c9 10		cmp #$10			cmp 	#KWD_AT
.8762	d0 14		bne $8778			bne 	_LCStandard
.8764	c8		iny				iny 								; skip equal
.8765	20 d8 97	jsr $97d8			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.8768	20 51 96	jsr $9651			jsr 	Dereference 				; dereference it to a value
.876b	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.876d	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.876f	95 50		sta $50,x			sta 	NSStatus,x
.8771	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8773	d0 0f		bne $8784			bne 	_LCMain
.8775	4c 1f 9f	jmp $9f1f			jmp 	TypeError 					; was a reference before.
.8778					_LCStandard:
.8778	ad 76 93	lda $9376			lda 	PrecedenceLevel+"*"			; precedence > this
.877b	20 90 93	jsr $9390			jsr 	EvaluateExpressionAtPrecedence
.877e	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.8780	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.8782	f0 0e		beq $8792			beq 	_LetGoProc 					; it's a procedure call.
.8784					_LCMain:
.8784	a9 3d		lda #$3d			lda 	#"=" 						; check =
.8786	20 81 8e	jsr $8e81			jsr 	CheckNextA
.8789	e8		inx				inx 								; RHS
.878a	20 dc 9c	jsr $9cdc			jsr 	EvaluateValue
.878d	ca		dex				dex
.878e	20 95 87	jsr $8795			jsr 	AssignVariable
.8791	60		rts				rts
.8792					_LetGoProc:
.8792	4c 79 89	jmp $8979			jmp 	CallProcedure
.8795					AssignVariable:
.8795	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8797	48		pha				pha 								; save a copy
.8798	55 51		eor $51,x			eor 	NSStatus+1,x
.879a	29 10		and #$10			and 	#NSBIsString
.879c	d0 0b		bne $87a9			bne 	_ASError
.879e	68		pla				pla 								; get back
.879f	29 10		and #$10			and 	#NSBIsString 				; check type
.87a1	d0 03		bne $87a6			bne 	_ASString
.87a3	4c 8f 95	jmp $958f			jmp 	AssignNumber
.87a6					_ASString:
.87a6	4c ed 95	jmp $95ed			jmp 	AssignString
.87a9					_ASError:
.87a9	4c 1f 9f	jmp $9f1f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87ac					Command_List:
.87ac	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.87af	b1 30		lda ($30),y			lda 	(codePtr),y
.87b1	29 c0		and #$c0			and 	#$C0
.87b3	c9 40		cmp #$40			cmp 	#$40
.87b5	f0 69		beq $8820			beq 	_CLListProcedure
.87b7	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87b9	64 64		stz $64				stz 	NSMantissa1+4
.87bb	a9 ff		lda #$ff			lda 	#$FF
.87bd	85 5f		sta $5f				sta 	NSMantissa0+7
.87bf	85 67		sta $67				sta 	NSMantissa1+7
.87c1	b1 30		lda ($30),y			lda 	(codePtr),y
.87c3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87c5	f0 1a		beq $87e1			beq 	_CLSecond
.87c7	20 9d 88	jsr $889d			jsr 	CLIsDigit 					; if not digit, list all
.87ca	b0 20		bcs $87ec			bcs 	_CLStart
.87cc	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.87ce	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger
.87d1	b1 30		lda ($30),y			lda 	(codePtr),y
.87d3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87d5	f0 0a		beq $87e1			beq 	_CLSecond 					; if so go get it
.87d7	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.87d9	85 5f		sta $5f				sta 	NSMantissa0+7
.87db	a5 64		lda $64				lda 	NSMantissa1+4
.87dd	85 67		sta $67				sta 	NSMantissa1+7
.87df	80 0b		bra $87ec			bra 	_CLStart
.87e1					_CLSecond:
.87e1	c8		iny				iny 								; consume comma
.87e2	20 9d 88	jsr $889d			jsr 	CLIsDigit 					; digit found
.87e5	b0 05		bcs $87ec			bcs 	_CLStart 					; if not, continue listing
.87e7	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.87e9	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger
.87ec					_CLStart
.87ec	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.87ee	85 30		sta $30				sta 	codePtr
.87f0	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.87f2	85 31		sta $31				sta 	codePtr+1
.87f4					_CLLoop:
.87f4	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.87f7	f0 24		beq $881d			beq 	_CLExit
.87f9	b2 30		lda ($30)			lda 	(codePtr)
.87fb	f0 20		beq $881d			beq 	_CLExit
.87fd	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.87ff	20 8c 88	jsr $888c			jsr 	CLCompareLineNo
.8802	90 0c		bcc $8810			bcc 	_CLNext
.8804	a2 07		ldx #$07			ldx 	#7
.8806	20 8c 88	jsr $888c			jsr 	CLCompareLineNo
.8809	f0 02		beq $880d			beq 	_CLDoThisOne
.880b	b0 03		bcs $8810			bcs 	_CLNext
.880d					_CLDoThisOne:
.880d	20 79 88	jsr $8879			jsr 	CLListOneLine
.8810					_CLNext:
.8810	18		clc				clc
.8811	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8813	65 30		adc $30				adc 	codePtr
.8815	85 30		sta $30				sta 	codePtr
.8817	90 02		bcc $881b			bcc 	_CREExit
.8819	e6 31		inc $31				inc 	codePtr+1 					; carry
.881b					_CREExit:
.881b	80 d7		bra $87f4			bra 	_CLLoop
.881d					_CLExit:
.881d	4c 46 83	jmp $8346			jmp 	WarmStart
.8820					_CLListProcedure:
.8820	b1 30		lda ($30),y			lda 	(codePtr),y
.8822	85 38		sta $38				sta 	zTemp1
.8824	c8		iny				iny
.8825	b1 30		lda ($30),y			lda 	(codePtr),y
.8827	85 39		sta $39				sta 	zTemp1+1
.8829	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.882b	85 30		sta $30				sta 	codePtr
.882d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.882f	85 31		sta $31				sta 	codePtr+1
.8831					_CLLPSearch:
.8831	b2 30		lda ($30)			lda 	(codePtr)
.8833	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.8835	f0 e6		beq $881d			beq 	_CLExit
.8837	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.8839	b1 30		lda ($30),y			lda 	(codePtr),y
.883b	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.883d	d0 0e		bne $884d			bne 	_CLLPNext
.883f	c8		iny				iny 								; check if PROC this.
.8840	b1 30		lda ($30),y			lda 	(codePtr),y
.8842	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8844	d0 07		bne $884d			bne 	_CLLPNext
.8846	c8		iny				iny
.8847	b1 30		lda ($30),y			lda 	(codePtr),y
.8849	c5 39		cmp $39				cmp 	zTemp1+1
.884b	f0 0d		beq $885a			beq 	_CLLPFound
.884d					_CLLPNext:
.884d	18		clc				clc
.884e	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8850	65 30		adc $30				adc 	codePtr
.8852	85 30		sta $30				sta 	codePtr
.8854	90 02		bcc $8858			bcc 	_CREExit
.8856	e6 31		inc $31				inc 	codePtr+1 					; carry
.8858					_CREExit:
.8858	80 d7		bra $8831			bra 	_CLLPSearch
.885a					_CLLPFound:
.885a	b2 30		lda ($30)			lda 	(codePtr)
.885c	f0 bf		beq $881d			beq 	_CLExit
.885e	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.8860	b1 30		lda ($30),y			lda 	(codePtr),y
.8862	48		pha				pha
.8863	20 79 88	jsr $8879			jsr 	CLListOneLine 				; list line and go forward
.8866	18		clc				clc
.8867	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8869	65 30		adc $30				adc 	codePtr
.886b	85 30		sta $30				sta 	codePtr
.886d	90 02		bcc $8871			bcc 	_CREExit
.886f	e6 31		inc $31				inc 	codePtr+1 					; carry
.8871					_CREExit:
.8871	68		pla				pla 								; reached ENDPROC ?
.8872	c9 a6		cmp #$a6			cmp 	#KWD_ENDPROC
.8874	d0 e4		bne $885a			bne 	_CLLPFound
.8876	4c 46 83	jmp $8346			jmp 	WarmStart
.8879					CLListOneLine:
.8879	20 cc 8d	jsr $8dcc			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.887c	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.887f	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8881	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8883	20 e3 8e	jsr $8ee3			jsr 	PrintStringXA
.8886	a9 0d		lda #$0d			lda 	#13 						; new line
.8888	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.888b	60		rts				rts
.888c					CLCompareLineNo:
.888c	38		sec				sec
.888d	a0 01		ldy #$01			ldy 	#1
.888f	b1 30		lda ($30),y			lda 	(codePtr),y
.8891	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8893	85 36		sta $36				sta 	zTemp0
.8895	c8		iny				iny
.8896	b1 30		lda ($30),y			lda 	(codePtr),y
.8898	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.889a	05 36		ora $36				ora 	zTemp0
.889c	60		rts				rts
.889d					CLIsDigit:
.889d	b1 30		lda ($30),y			lda 	(codePtr),y
.889f	c9 30		cmp #$30			cmp 	#"0"
.88a1	90 03		bcc $88a6			bcc	 	_CLIDExitFalse
.88a3	c9 3a		cmp #$3a			cmp 	#"9"+1
.88a5	60		rts				rts
.88a6					_CLIDExitFalse:
.88a6	38		sec				sec
.88a7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.88a8					Command_LOCAL:
.88a8	a2 00		ldx #$00			ldx 	#0 							; at level 0
.88aa	20 b6 88	jsr $88b6			jsr 	LocaliseNextTerm 			; convert term to a local.
.88ad	b1 30		lda ($30),y			lda 	(codePtr),y
.88af	c8		iny				iny
.88b0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.88b2	f0 f4		beq $88a8			beq 	Command_LOCAL
.88b4	88		dey				dey 								; unpick pre-get
.88b5	60		rts				rts
.88b6					LocaliseNextTerm:
.88b6	20 d8 97	jsr $97d8			jsr 	EvaluateTerm 				; evaluate the term
.88b9	b5 50		lda $50,x			lda 	NSStatus,x
.88bb	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.88bd	f0 5c		beq $891b			beq		_LNTError
.88bf	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.88c1	85 36		sta $36				sta 	zTemp0
.88c3	b5 60		lda $60,x			lda 	NSMantissa1,x
.88c5	85 37		sta $37				sta  	zTemp0+1
.88c7	b5 50		lda $50,x			lda 	NSStatus,x
.88c9	29 10		and #$10			and 	#NSBIsString
.88cb	d0 1e		bne $88eb			bne 	_LNTPushString
.88cd	5a		phy				phy
.88ce	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.88d0					_LNTPushNumLoop:
.88d0	b1 36		lda ($36),y			lda		(zTemp0),y
.88d2	20 b8 a5	jsr $a5b8			jsr 	StackPushByte
.88d5	c8		iny				iny
.88d6	c0 05		cpy #$05			cpy 	#5
.88d8	d0 f6		bne $88d0			bne 	_LNTPushNumLoop
.88da	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.88dc	20 b8 a5	jsr $a5b8			jsr 	StackPushByte
.88df	a5 37		lda $37				lda 	zTemp0+1
.88e1	20 b8 a5	jsr $a5b8			jsr 	StackPushByte
.88e4	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88e6	20 b8 a5	jsr $a5b8			jsr 	StackPushByte
.88e9	7a		ply				ply
.88ea	60		rts				rts
.88eb					_LNTPushString:
.88eb	5a		phy				phy
.88ec	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88ee	85 38		sta $38				sta 	zTemp1
.88f0	a0 01		ldy #$01			ldy 	#1
.88f2	b1 36		lda ($36),y			lda 	(zTemp0),y
.88f4	85 39		sta $39				sta 	zTemp1+1
.88f6	a0 00		ldy #$00			ldy 	#0 							; output string
.88f8	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88fa	f0 0a		beq $8906			beq 	_LNTStringOut
.88fc					_LNTPushStrLoop:
.88fc	b1 38		lda ($38),y			lda 	(zTemp1),y
.88fe	f0 06		beq $8906			beq 	_LNTStringOut
.8900	20 b8 a5	jsr $a5b8			jsr 	StackPushByte
.8903	c8		iny				iny
.8904	80 f6		bra $88fc			bra 	_LNTPushStrLoop
.8906					_LNTStringOut:
.8906	98		tya				tya									; output length
.8907	20 b8 a5	jsr $a5b8			jsr 	StackPushByte
.890a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.890c	20 b8 a5	jsr $a5b8			jsr 	StackPushByte
.890f	b5 60		lda $60,x			lda 	NSMantissa1,x
.8911	20 b8 a5	jsr $a5b8			jsr 	StackPushByte
.8914	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8916	20 b8 a5	jsr $a5b8			jsr 	StackPushByte
.8919	7a		ply				ply
.891a	60		rts				rts
.891b					_LNTError:
.891b	4c 15 9f	jmp $9f15			jmp 	SyntaxError
.891e					LocalPopValue:
.891e	20 d0 a5	jsr $a5d0			jsr 	StackPopByte
.8921	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8923	d0 17		bne $893c			bne 	_LPVString
.8925	20 d0 a5	jsr $a5d0			jsr 	StackPopByte 				; address
.8928	85 37		sta $37				sta 	zTemp0+1
.892a	20 d0 a5	jsr $a5d0			jsr 	StackPopByte
.892d	85 36		sta $36				sta 	zTemp0
.892f	5a		phy				phy
.8930	a0 04		ldy #$04			ldy 	#4 							; copy back
.8932					_LPVNumberCopy:
.8932	20 d0 a5	jsr $a5d0			jsr 	StackPopByte
.8935	91 36		sta ($36),y			sta 	(zTemp0),y
.8937	88		dey				dey
.8938	10 f8		bpl $8932			bpl 	_LPVNumberCopy
.893a	7a		ply				ply 								; and complete
.893b	60		rts				rts
.893c					_LPVString:
.893c	20 d0 a5	jsr $a5d0			jsr 	StackPopByte 				; address of record => zTemp0
.893f	85 37		sta $37				sta 	zTemp0+1
.8941	20 d0 a5	jsr $a5d0			jsr 	StackPopByte
.8944	85 36		sta $36				sta 	zTemp0
.8946	5a		phy				phy
.8947	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8949	85 38		sta $38				sta 	zTemp1
.894b	a0 01		ldy #$01			ldy 	#1
.894d	b1 36		lda ($36),y			lda 	(zTemp0),y
.894f	85 39		sta $39				sta 	zTemp1+1
.8951	20 d0 a5	jsr $a5d0			jsr 	StackPopByte 				; # to get => y
.8954	a8		tay				tay
.8955	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8957	f0 0e		beq $8967			beq 	_LPVStringCopied
.8959	a9 00		lda #$00			lda 	#0 							; NULL on end
.895b	91 38		sta ($38),y			sta 	(zTemp1),y
.895d					_LPVStringCopy:
.895d	88		dey				dey
.895e	30 07		bmi $8967			bmi 	_LPVStringCopied
.8960	20 d0 a5	jsr $a5d0			jsr 	StackPopByte
.8963	91 38		sta ($38),y			sta 	(zTemp1),y
.8965	80 f6		bra $895d			bra 	_LPVStringCopy
.8967					_LPVStringCopied:
.8967	fa		plx				plx
.8968	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8969					NewCommand:
.8969	20 6f 89	jsr $896f			jsr 	NewProgram 					; does the actual NEW.
.896c	4c 46 83	jmp $8346			jmp 	WarmStart 					; and warm starts straight away.
.896f					NewProgram:
.896f	20 e5 a4	jsr $a4e5			jsr 	MemoryNew
.8972	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8975	20 dc 83	jsr $83dc			jsr 	ClearCommand 				; clear everything.
.8978	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8979					CallProcedure:
.8979	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.897b	b1 30		lda ($30),y			lda 	(codePtr),y
.897d	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.897f	f0 0c		beq $898d			beq 	_CPEndParam
.8981					_CPParamLoop:
.8981	20 dc 9c	jsr $9cdc			jsr 	EvaluateValue 				; get parameter onto stack
.8984	e8		inx				inx 								; bump next stack
.8985	b1 30		lda ($30),y			lda 	(codePtr),y
.8987	c8		iny				iny
.8988	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.898a	f0 f5		beq $8981			beq 	_CPParamLoop
.898c	88		dey				dey 								; unpick.
.898d					_CPEndParam:
.898d	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8990	c8		iny				iny									; skip right bracket
.8991	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8993	20 d9 a5	jsr $a5d9			jsr 	StackOpen
.8996	20 1e a6	jsr $a61e			jsr 	STKSaveCodePosition 		; save loop position
.8999	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.899b	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.899d	a5 60		lda $60				lda 	NSMantissa1
.899f	85 37		sta $37				sta 	zTemp0+1
.89a1	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.89a3	b2 36		lda ($36)			lda 	(zTemp0)
.89a5	85 30		sta $30				sta 	safePtr
.89a7	b1 36		lda ($36),y			lda 	(zTemp0),y
.89a9	85 31		sta $31				sta 	safePtr+1
.89ab	c8		iny				iny
.89ac	b1 36		lda ($36),y			lda 	(zTemp0),y
.89ae	85 32		sta $32				sta 	safePtr+2
.89b0	c8		iny				iny
.89b1	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b3	85 33		sta $33				sta 	safePtr+3
.89b5	c8		iny				iny 								; get Y offset -> Y
.89b6	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b8	a8		tay				tay
.89b9	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.89bb	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check no parameters at the start
.89be	f0 13		beq $89d3			beq 	_ParamExit 					; if so, exit.
.89c0					_ParamExtract:
.89c0	ca		dex				dex 								; put a local term on the level before
.89c1	20 b6 88	jsr $88b6			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.89c4	20 95 87	jsr $8795			jsr 	AssignVariable 				; assign stacked value to the variable.
.89c7	e8		inx				inx 								; advance to next parameter to do.
.89c8	e8		inx				inx
.89c9	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.89cc	f0 05		beq $89d3			beq 	_ParamExit
.89ce	20 79 8e	jsr $8e79			jsr 	CheckComma 					; comma seperating parameters
.89d1	80 ed		bra $89c0			bra 	_ParamExtract
.89d3					_ParamExit:
.89d3	20 71 8e	jsr $8e71			jsr 	CheckRightBracket 			; check )
.89d6	60		rts				rts 								; and continue from here
.89d7					Command_ENDPROC:
.89d7	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.89d9	a2 14		ldx #$14			ldx 	#ERRID_PROC
.89db	20 06 a6	jsr $a606			jsr 	StackCheckFrame
.89de	20 2f a6	jsr $a62f			jsr 	STKLoadCodePosition 		; restore code position
.89e1	20 f8 a5	jsr $a5f8			jsr 	StackClose
.89e4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89e5					Command_Read:
.89e5	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89e7	20 d8 97	jsr $97d8			jsr 	EvaluateTerm
.89ea	b5 50		lda $50,x			lda 	NSStatus,x
.89ec	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89ee	f0 4a		beq $8a3a			beq 	_CRSyntax 					; check reference (bit 0)
.89f0	20 83 8a	jsr $8a83			jsr 	SwapDataCodePtrs 			; swap code and data
.89f3	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89f6	d0 20		bne $8a18			bne 	_CRContinueData
.89f8					_CRKeepSearching:
.89f8	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89fa	aa		tax				tax
.89fb	20 69 8d	jsr $8d69			jsr 	ScanForward
.89fe	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8a00	f0 16		beq $8a18			beq 	_CRHaveData 				; found it
.8a02	18		clc				clc
.8a03	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a05	65 30		adc $30				adc 	codePtr
.8a07	85 30		sta $30				sta 	codePtr
.8a09	90 02		bcc $8a0d			bcc 	_CREExit
.8a0b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a0d					_CREExit:
.8a0d	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8a0f	b2 30		lda ($30)			lda 	(codePtr)
.8a11	d0 e5		bne $89f8			bne 	_CRKeepSearching
.8a13	a9 0b		lda #$0b		lda	#11
.8a15	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.8a18					_CRHaveData:
.8a18					_CRContinueData:
.8a18	a2 01		ldx #$01			ldx 	#1
.8a1a	20 dc 9c	jsr $9cdc			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a1d	ca		dex				dex
.8a1e	20 95 87	jsr $8795			jsr		AssignVariable 				; do the assignment
.8a21	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data
.8a24	b1 30		lda ($30),y			lda 	(codePtr),y
.8a26	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a28	d0 04		bne $8a2e			bne 	_CRSwapBack
.8a2a	c8		iny				iny 								; consume comma
.8a2b	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8a2e					_CRSwapBack:
.8a2e	20 83 8a	jsr $8a83			jsr 	SwapDataCodePtrs			; swap them back.
.8a31	b1 30		lda ($30),y			lda 	(codePtr),y
.8a33	c8		iny				iny
.8a34	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a36	f0 ad		beq $89e5			beq 	Command_Read 				; if so go round again.
.8a38	88		dey				dey 								; unpick get.
.8a39	60		rts				rts
.8a3a					_CRSyntax:
.8a3a	4c 15 9f	jmp $9f15			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a3d					RemCommand:
.8a3d	b1 30		lda ($30),y			lda 	(codePtr),y
.8a3f	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a41	d0 06		bne $8a49			bne 	_RMExit
.8a43	c8		iny				iny 								; point to offset
.8a44	98		tya				tya 								; A = offset position
.8a45	38		sec				sec 								; add size +1 hence SEC
.8a46	71 30		adc ($30),y			adc 	(codePtr),y
.8a48	a8		tay				tay 								; make current position.
.8a49					_RMExit:
.8a49	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a4a					Command_REPEAT:
.8a4a	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a4c	20 d9 a5	jsr $a5d9			jsr 	StackOpen
.8a4f	20 1e a6	jsr $a61e			jsr 	STKSaveCodePosition 		; save loop position
.8a52	60		rts				rts
.8a53					Command_UNTIL:
.8a53	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a55	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a57	20 06 a6	jsr $a606			jsr 	StackCheckFrame
.8a5a	a2 00		ldx #$00			ldx 	#0
.8a5c	20 e5 9c	jsr $9ce5			jsr 	EvaluateNumber 				; work out the number
.8a5f	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; check if zero
.8a62	f0 04		beq $8a68			beq 	_CULoopBack 				; if so keep looping
.8a64	20 f8 a5	jsr $a5f8			jsr 	StackClose		 			; return
.8a67	60		rts				rts
.8a68					_CULoopBack:
.8a68	20 2f a6	jsr $a62f			jsr 	STKLoadCodePosition 		; loop back
.8a6b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a6c					Command_Restore:
.8a6c	20 83 8a	jsr $8a83			jsr 	SwapDataCodePtrs 			; swap code and data
.8a6f	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a71	85 30		sta $30				sta 	codePtr
.8a73	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a75	85 31		sta $31				sta 	codePtr+1
.8a77	20 83 8a	jsr $8a83			jsr 	SwapDataCodePtrs 			; put them back
.8a7a	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a7c	8d 1b 04	sta $041b			sta 	dataPointer+4
.8a7f	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8a82	60		rts				rts
.8a83					SwapDataCodePtrs:
.8a83	da		phx				phx
.8a84	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a86					_SDCPLoop:
.8a86	b5 30		lda $30,x			lda 	safePtr,x
.8a88	48		pha				pha
.8a89	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8a8c	95 30		sta $30,x			sta 	safePtr,x
.8a8e	68		pla				pla
.8a8f	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8a92	ca		dex				dex
.8a93	10 f1		bpl $8a86			bpl 	_SDCPLoop
.8a95	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8a98	8c 1b 04	sty $041b			sty 	dataPointer+4
.8a9b	a8		tay				tay
.8a9c	fa		plx				plx
.8a9d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a9e					EOLCommand:
.8a9e	18		clc				clc
.8a9f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8aa1	65 30		adc $30				adc 	codePtr
.8aa3	85 30		sta $30				sta 	codePtr
.8aa5	90 02		bcc $8aa9			bcc 	_CREExit
.8aa7	e6 31		inc $31				inc 	codePtr+1 					; carry
.8aa9					_CREExit:
.8aa9	80 0b		bra $8ab6			bra 	RunNewLine
.8aab					CommandRUN:
.8aab	20 dc 83	jsr $83dc			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8aae	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ab0	85 30		sta $30				sta 	codePtr
.8ab2	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8ab4	85 31		sta $31				sta 	codePtr+1
.8ab6					RUNNewLine:
.8ab6	b2 30		lda ($30)			lda 	(codePtr)
.8ab8	f0 7b		beq $8b35			beq 	CRNoProgram         		; no then END.
.8aba	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8abc	9a		txs				txs
.8abd					RUNCodePointerLine:
.8abd	a0 02		ldy #$02			ldy 	#2 							; start of program
.8abf					_CRIncMainLoop:
.8abf	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8ac2	d0 22		bne $8ae6			bne 	_CRNoBreakCheck
.8ac4	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8ac7	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8aca	f0 64		beq $8b30			beq 	_CRBreak
.8acc	a5 01		lda $01				lda 	1 							; save I/O 0
.8ace	48		pha				pha
.8acf	64 01		stz $01				stz 	1 							; access I/O Page 0
.8ad1	38		sec				sec 								; calculate timer - LastTick
.8ad2	ad 59 d6	lda $d659			lda 	$D659
.8ad5	aa		tax				tax 								; saving timer in X
.8ad6	ed af 05	sbc $05af			sbc 	LastTick
.8ad9	c9 03		cmp #$03			cmp 	#3
.8adb	90 06		bcc $8ae3			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8add	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.8ae0	20 c2 9d	jsr $9dc2			jsr 	TickHandler 							; go do the code.
.8ae3					_NoFireTick:
.8ae3	68		pla				pla 								; restore I/O 0
.8ae4	85 01		sta $01				sta 	1
.8ae6					_CRNoBreakCheck:
.8ae6	c8		iny				iny									; next token
.8ae7					_CRMainLoop:
.8ae7	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8aea	b1 30		lda ($30),y			lda 	(codePtr),y
.8aec	10 10		bpl $8afe			bpl 	_CRNotKeyword				; not a token.
.8aee	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8af0	b0 04		bcs $8af6			bcs 	_CRIsKeyword
.8af2	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8af4	b0 34		bcs $8b2a			bcs		_CRSyntaxError
.8af6					_CRIsKeyword:
.8af6	c8		iny				iny 								; consume command
.8af7	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8af8	aa		tax				tax 								; put in X for vector jump
.8af9	20 2d 8b	jsr $8b2d			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8afc	80 e9		bra $8ae7			bra 	_CRMainLoop 				; and loop round
.8afe					_CRNotKeyword:
.8afe	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8b00	f0 bd		beq $8abf			beq 	_CRIncMainLoop
.8b02	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8b04	90 05		bcc $8b0b			bcc 	_CRNotVariable
.8b06					_CRGoLet:
.8b06	20 5c 87	jsr $875c			jsr 	LetCommand
.8b09	80 dc		bra $8ae7			bra 	_CRMainLoop
.8b0b					_CRNotVariable:
.8b0b	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8b0d	f0 f7		beq $8b06			beq 	_CRGoLet
.8b0f	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8b11	f0 f3		beq $8b06			beq 	_CRGoLet
.8b13	c9 21		cmp #$21			cmp 	#KWD_PLING
.8b15	f0 ef		beq $8b06			beq 	_CRGoLet
.8b17	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8b19	f0 09		beq $8b24			beq 	_CRGoRem
.8b1b	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8b1d	d0 0b		bne $8b2a			bne 	_CRSyntaxError
.8b1f	20 df 81	jsr $81df			jsr 	LabelHere
.8b22	80 c3		bra $8ae7			bra 	_CRMainLoop
.8b24					_CRGoRem:
.8b24	c8		iny				iny
.8b25	20 3d 8a	jsr $8a3d			jsr 	RemCommand
.8b28	80 bd		bra $8ae7			bra 	_CRMainLoop
.8b2a					_CRSyntaxError:
.8b2a	4c 15 9f	jmp $9f15			jmp 	SyntaxError
.8b2d					_CRCallVector0:
.8b2d	7c cc 8b	jmp ($8bcc,x)			jmp 	(VectorSet0,x)
.8b30					_CRBreak:
.8b30	a9 01		lda #$01		lda	#1
.8b32	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.8b35					CRNoProgram:
.8b35	4c 01 85	jmp $8501			jmp 	EndCommand
.8b38					Shift1Command:
.8b38	b1 30		lda ($30),y			lda 	(codePtr),y
.8b3a	c8		iny				iny
.8b3b	0a		asl a				asl 	a
.8b3c	aa		tax				tax
.8b3d	7c 6a 8c	jmp ($8c6a,x)			jmp 	(VectorSet1,x)
.8b40					Shift2Command:
.8b40	b1 30		lda ($30),y			lda 	(codePtr),y
.8b42	c8		iny				iny
.8b43	0a		asl a				asl 	a
.8b44	aa		tax				tax
.8b45	7c 8a 8c	jmp ($8c8a,x)			jmp 	(VectorSet2,x)
.8b48					Unused1:
.8b48					Unused2:
.8b48					Unused3:
.8b48					Unused4:
.8b48	4c 15 9f	jmp $9f15			jmp 	SyntaxError
>8b4b							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b4c					VectorSetPunc:
>8b4c	42 91					.word	ShiftLeft                        ; $00 <<
>8b4e	2d 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8b50	23 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8b52	15 9f					.word	SyntaxError                      ; $03 !!3
>8b54	15 9f					.word	SyntaxError                      ; $04 ><
>8b56	37 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b58	45 91					.word	ShiftRight                       ; $06 >>
>8b5a	15 9f					.word	SyntaxError                      ; $07 !!7
>8b5c	15 9f					.word	SyntaxError                      ; $08 !!8
>8b5e	15 9f					.word	SyntaxError                      ; $09 !!9
>8b60	15 9f					.word	SyntaxError                      ; $0a !!10
>8b62	15 9f					.word	SyntaxError                      ; $0b !!11
>8b64	15 9f					.word	SyntaxError                      ; $0c !!12
>8b66	15 9f					.word	SyntaxError                      ; $0d !!13
>8b68	15 9f					.word	SyntaxError                      ; $0e !!14
>8b6a	15 9f					.word	SyntaxError                      ; $0f !!15
>8b6c	15 9f					.word	SyntaxError                      ; $10 @
>8b6e	15 9f					.word	SyntaxError                      ; $11 !!17
>8b70	15 9f					.word	SyntaxError                      ; $12 !!18
>8b72	15 9f					.word	SyntaxError                      ; $13 [
>8b74	ee 8f					.word	IntegerDivide                    ; $14 \
>8b76	15 9f					.word	SyntaxError                      ; $15 ]
>8b78	80 92					.word	EorInteger                       ; $16 ^
>8b7a	15 9f					.word	SyntaxError                      ; $17 _
>8b7c	15 9f					.word	SyntaxError                      ; $18 `
>8b7e	15 9f					.word	SyntaxError                      ; $19 !!25
>8b80	15 9f					.word	SyntaxError                      ; $1a !!26
>8b82	15 9f					.word	SyntaxError                      ; $1b {
>8b84	4b 92					.word	OraInteger                       ; $1c |
>8b86	15 9f					.word	SyntaxError                      ; $1d }
>8b88	15 9f					.word	SyntaxError                      ; $1e ~
>8b8a	15 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b8c	15 9f					.word	SyntaxError                      ; $20
>8b8e	b5 92					.word	WordIndirect                     ; $21 !
>8b90	15 9f					.word	SyntaxError                      ; $22 "
>8b92	15 9f					.word	SyntaxError                      ; $23 #
>8b94	15 9f					.word	SyntaxError                      ; $24 $
>8b96	2f 90					.word	IntegerModulus                   ; $25 %
>8b98	16 92					.word	AndInteger                       ; $26 &
>8b9a	15 9f					.word	SyntaxError                      ; $27 '
>8b9c	15 9f					.word	SyntaxError                      ; $28 (
>8b9e	15 9f					.word	SyntaxError                      ; $29 )
>8ba0	9d 90					.word	MulInteger                       ; $2a *
>8ba2	b8 91					.word	AddInteger                       ; $2b +
>8ba4	15 9f					.word	SyntaxError                      ; $2c ,
>8ba6	f1 91					.word	SubInteger                       ; $2d -
>8ba8	15 9f					.word	SyntaxError                      ; $2e .
>8baa	6f 94					.word	FDivideCommand                   ; $2f /
>8bac	15 9f					.word	SyntaxError                      ; $30 0
>8bae	15 9f					.word	SyntaxError                      ; $31 1
>8bb0	15 9f					.word	SyntaxError                      ; $32 2
>8bb2	15 9f					.word	SyntaxError                      ; $33 3
>8bb4	15 9f					.word	SyntaxError                      ; $34 4
>8bb6	15 9f					.word	SyntaxError                      ; $35 5
>8bb8	15 9f					.word	SyntaxError                      ; $36 6
>8bba	15 9f					.word	SyntaxError                      ; $37 7
>8bbc	15 9f					.word	SyntaxError                      ; $38 8
>8bbe	15 9f					.word	SyntaxError                      ; $39 9
>8bc0	15 9f					.word	SyntaxError                      ; $3a :
>8bc2	15 9f					.word	SyntaxError                      ; $3b ;
>8bc4	0f 8f					.word	BinaryCompareLess                ; $3c <
>8bc6	05 8f					.word	BinaryCompareEqual               ; $3d =
>8bc8	19 8f					.word	BinaryCompareGreater             ; $3e >
>8bca	d7 92					.word	ByteIndirect                     ; $3f ?
.8bcc					VectorSet0:
>8bcc	9e 8a					.word	EOLCommand                       ; $80 !0:EOF
>8bce	38 8b					.word	Shift1Command                    ; $81 !1:SH1
>8bd0	40 8b					.word	Shift2Command                    ; $82 !2:SH2
>8bd2	54 99					.word	AbsUnary                         ; $83 ABS(
>8bd4	62 99					.word	AllocUnary                       ; $84 ALLOC(
>8bd6	d2 99					.word	AscUnary                         ; $85 ASC(
>8bd8	7d 9b					.word	ChrUnary                         ; $86 CHR$(
>8bda	65 a3					.word	UnaryEvent                       ; $87 EVENT(
>8bdc	01 8f					.word	UnaryFalse                       ; $88 FALSE
>8bde	df 99					.word	FracUnary                        ; $89 FRAC(
>8be0	01 a3					.word	UnaryHit                         ; $8a HIT(
>8be2	f4 99					.word	IntUnary                         ; $8b INT(
>8be4	3c 9b					.word	IsValUnary                       ; $8c ISVAL(
>8be6	e9 a3					.word	UnaryJoyB                        ; $8d JOYB(
>8be8	c2 a3					.word	UnaryJoyX                        ; $8e JOYX(
>8bea	c5 a3					.word	UnaryJoyY                        ; $8f JOYY(
>8bec	50 9c					.word	Unary_Left                       ; $90 LEFT$(
>8bee	05 9a					.word	LenUnary                         ; $91 LEN(
>8bf0	23 9a					.word	Unary_Max                        ; $92 MAX(
>8bf2	72 9c					.word	Unary_Mid                        ; $93 MID$(
>8bf4	1f 9a					.word	Unary_Min                        ; $94 MIN(
>8bf6	6e 9a					.word	Unary_Not                        ; $95 NOT(
>8bf8	36 a5					.word	UnaryPlaying                     ; $96 PLAYING(
>8bfa	81 9a					.word	Unary_Random                     ; $97 RANDOM(
>8bfc	5d 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8bfe	9e 9a					.word	Unary_Rnd                        ; $99 RND(
>8c00	14 9b					.word	SgnUnary                         ; $9a SGN(
>8c02	8f 9b					.word	SpcUnary                         ; $9b SPC(
>8c04	aa 9b					.word	Unary_Str                        ; $9c STR$(
>8c06	0f a4					.word	UnaryTimer                       ; $9d TIMER(
>8c08	f6 8e					.word	UnaryTrue                        ; $9e TRUE
>8c0a	32 9b					.word	ValUnary                         ; $9f VAL(
>8c0c	04 85					.word	ForCommand                       ; $a0 FOR
>8c0e	47 86					.word	IfCommand                        ; $a1 IF
>8c10	48 8b					.word	Unused1                          ; $a2 PROC
>8c12	4a 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8c14	df 8d					.word	Command_WHILE                    ; $a4 WHILE
>8c16	70 86					.word	EndIf                            ; $a5 ENDIF
>8c18	d7 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8c1a	b6 85					.word	NextCommand                      ; $a7 NEXT
>8c1c	48 8b					.word	Unused4                          ; $a8 THEN
>8c1e	53 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8c20	00 8e					.word	Command_WEND                     ; $aa WEND
>8c22	15 9f					.word	SyntaxError                      ; $ab BY
>8c24	a7 83					.word	CallCommand                      ; $ac CALL
>8c26	b5 a0					.word	CircleCommand                    ; $ad CIRCLE
>8c28	dc 83					.word	ClearCommand                     ; $ae CLEAR
>8c2a	34 84					.word	ClearScreen                      ; $af CLS
>8c2c	15 9f					.word	SyntaxError                      ; $b0 COLOR
>8c2e	15 9f					.word	SyntaxError                      ; $b1 COLOUR
>8c30	3c 84					.word	Command_Data                     ; $b2 DATA
>8c32	44 84					.word	DimCommand                       ; $b3 DIM
>8c34	48 8b					.word	Unused3                          ; $b4 DOWNTO
>8c36	69 86					.word	ElseCode                         ; $b5 ELSE
>8c38	15 9f					.word	SyntaxError                      ; $b6 FROM
>8c3a	d4 a2					.word	GfxCommand                       ; $b7 GFX
>8c3c	0f 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c3e	2d 86					.word	GotoCommand                      ; $b9 GOTO
>8c40	15 9f					.word	SyntaxError                      ; $ba HERE
>8c42	de a0					.word	ImageCommand                     ; $bb IMAGE
>8c44	71 86					.word	Command_Input                    ; $bc INPUT
>8c46	5c 87					.word	LetCommand                       ; $bd LET
>8c48	30 a1					.word	LineCommand                      ; $be LINE
>8c4a	a8 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c4c	15 9f					.word	SyntaxError                      ; $c0 OFF
>8c4e	15 9f					.word	SyntaxError                      ; $c1 ON
>8c50	15 9f					.word	SyntaxError                      ; $c2 OUTLINE
>8c52	25 a3					.word	PaletteCommand                   ; $c3 PALETTE
>8c54	29 a1					.word	PlotCommand                      ; $c4 PLOT
>8c56	78 86					.word	Command_Print                    ; $c5 PRINT
>8c58	e5 89					.word	Command_Read                     ; $c6 READ
>8c5a	b1 a0					.word	RectangleCommand                 ; $c7 RECT
>8c5c	3d 8a					.word	RemCommand                       ; $c8 REM
>8c5e	1f 86					.word	Command_RETURN                   ; $c9 RETURN
>8c60	15 9f					.word	SyntaxError                      ; $ca SOLID
>8c62	52 a5					.word	SoundCommand                     ; $cb SOUND
>8c64	c0 a0					.word	SpriteCommand                    ; $cc SPRITE
>8c66	fa a0					.word	TextCommand                      ; $cd TEXT
>8c68	48 8b					.word	Unused2                          ; $ce TO
.8c6a					VectorSet1:
>8c6a	15 9f					.word	SyntaxError                      ; $80 !0:EOF
>8c6c	15 9f					.word	SyntaxError                      ; $81 !1:SH1
>8c6e	15 9f					.word	SyntaxError                      ; $82 !2:SH2
>8c70	7b 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c72	97 83					.word	AssertCommand                    ; $84 ASSERT
>8c74	74 a2					.word	BitmapCtrl                       ; $85 BITMAP
>8c76	01 85					.word	EndCommand                       ; $86 END
>8c78	06 a4					.word	GoCommand                        ; $87 GO
>8c7a	ac 87					.word	Command_List                     ; $88 LIST
>8c7c	fd a3					.word	LoadCommand                      ; $89 LOAD
>8c7e	69 89					.word	NewCommand                       ; $8a NEW
>8c80	6c 8a					.word	Command_Restore                  ; $8b RESTORE
>8c82	ab 8a					.word	CommandRUN                       ; $8c RUN
>8c84	b9 a2					.word	SpritesCtrl                      ; $8d SPRITES
>8c86	12 8d					.word	StopCommand                      ; $8e STOP
>8c88	0e 8e					.word	WhoCommand                       ; $8f WHO
.8c8a					VectorSet2:
>8c8a	15 9f					.word	SyntaxError                      ; $80 !0:EOF
>8c8c	15 9f					.word	SyntaxError                      ; $81 !1:SH1
>8c8e	15 9f					.word	SyntaxError                      ; $82 !2:SH2
>8c90	d4 9d					.word	Assemble_adc                     ; $83 ADC
>8c92	cc 9d					.word	Assemble_and                     ; $84 AND
>8c94	e8 9d					.word	Assemble_asl                     ; $85 ASL
>8c96	52 9e					.word	Assemble_bcc                     ; $86 BCC
>8c98	56 9e					.word	Assemble_bcs                     ; $87 BCS
>8c9a	5e 9e					.word	Assemble_beq                     ; $88 BEQ
>8c9c	15 9e					.word	Assemble_bit                     ; $89 BIT
>8c9e	46 9e					.word	Assemble_bmi                     ; $8a BMI
>8ca0	5a 9e					.word	Assemble_bne                     ; $8b BNE
>8ca2	42 9e					.word	Assemble_bpl                     ; $8c BPL
>8ca4	62 9e					.word	Assemble_bra                     ; $8d BRA
>8ca6	66 9e					.word	Assemble_brk                     ; $8e BRK
>8ca8	4a 9e					.word	Assemble_bvc                     ; $8f BVC
>8caa	4e 9e					.word	Assemble_bvs                     ; $90 BVS
>8cac	6e 9e					.word	Assemble_clc                     ; $91 CLC
>8cae	c2 9e					.word	Assemble_cld                     ; $92 CLD
>8cb0	82 9e					.word	Assemble_cli                     ; $93 CLI
>8cb2	b2 9e					.word	Assemble_clv                     ; $94 CLV
>8cb4	e0 9d					.word	Assemble_cmp                     ; $95 CMP
>8cb6	29 9e					.word	Assemble_cpx                     ; $96 CPX
>8cb8	24 9e					.word	Assemble_cpy                     ; $97 CPY
>8cba	06 9e					.word	Assemble_dec                     ; $98 DEC
>8cbc	be 9e					.word	Assemble_dex                     ; $99 DEX
>8cbe	9a 9e					.word	Assemble_dey                     ; $9a DEY
>8cc0	d0 9d					.word	Assemble_eor                     ; $9b EOR
>8cc2	0b 9e					.word	Assemble_inc                     ; $9c INC
>8cc4	ce 9e					.word	Assemble_inx                     ; $9d INX
>8cc6	ba 9e					.word	Assemble_iny                     ; $9e INY
>8cc8	3d 9e					.word	Assemble_jmp                     ; $9f JMP
>8cca	38 9e					.word	Assemble_jsr                     ; $a0 JSR
>8ccc	dc 9d					.word	Assemble_lda                     ; $a1 LDA
>8cce	01 9e					.word	Assemble_ldx                     ; $a2 LDX
>8cd0	1f 9e					.word	Assemble_ldy                     ; $a3 LDY
>8cd2	f2 9d					.word	Assemble_lsr                     ; $a4 LSR
>8cd4	d2 9e					.word	Assemble_nop                     ; $a5 NOP
>8cd6	c8 9d					.word	Assemble_ora                     ; $a6 ORA
>8cd8	7e 9e					.word	Assemble_pha                     ; $a7 PHA
>8cda	6a 9e					.word	Assemble_php                     ; $a8 PHP
>8cdc	c6 9e					.word	Assemble_phx                     ; $a9 PHX
>8cde	86 9e					.word	Assemble_phy                     ; $aa PHY
>8ce0	8e 9e					.word	Assemble_pla                     ; $ab PLA
>8ce2	72 9e					.word	Assemble_plp                     ; $ac PLP
>8ce4	da 9e					.word	Assemble_plx                     ; $ad PLX
>8ce6	96 9e					.word	Assemble_ply                     ; $ae PLY
>8ce8	ed 9d					.word	Assemble_rol                     ; $af ROL
>8cea	f7 9d					.word	Assemble_ror                     ; $b0 ROR
>8cec	7a 9e					.word	Assemble_rti                     ; $b1 RTI
>8cee	8a 9e					.word	Assemble_rts                     ; $b2 RTS
>8cf0	e4 9d					.word	Assemble_sbc                     ; $b3 SBC
>8cf2	76 9e					.word	Assemble_sec                     ; $b4 SEC
>8cf4	d6 9e					.word	Assemble_sed                     ; $b5 SED
>8cf6	92 9e					.word	Assemble_sei                     ; $b6 SEI
>8cf8	d8 9d					.word	Assemble_sta                     ; $b7 STA
>8cfa	ca 9e					.word	Assemble_stp                     ; $b8 STP
>8cfc	fc 9d					.word	Assemble_stx                     ; $b9 STX
>8cfe	1a 9e					.word	Assemble_sty                     ; $ba STY
>8d00	10 9e					.word	Assemble_stz                     ; $bb STZ
>8d02	ae 9e					.word	Assemble_tax                     ; $bc TAX
>8d04	aa 9e					.word	Assemble_tay                     ; $bd TAY
>8d06	33 9e					.word	Assemble_trb                     ; $be TRB
>8d08	2e 9e					.word	Assemble_tsb                     ; $bf TSB
>8d0a	b6 9e					.word	Assemble_tsx                     ; $c0 TSX
>8d0c	9e 9e					.word	Assemble_txa                     ; $c1 TXA
>8d0e	a6 9e					.word	Assemble_txs                     ; $c2 TXS
>8d10	a2 9e					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8d12					StopCommand:
.8d12	a9 08		lda #$08		lda	#8
.8d14	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8d17					ProcedureScan:
.8d17	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8d19	85 30		sta $30				sta 	codePtr
.8d1b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8d1d	85 31		sta $31				sta 	codePtr+1
.8d1f					_PSLoop:
.8d1f	b2 30		lda ($30)			lda 	(codePtr)
.8d21	f0 42		beq $8d65			beq 	_PSExit
.8d23	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8d25	b1 30		lda ($30),y			lda 	(codePtr),y
.8d27	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8d29	d0 2d		bne $8d58			bne 	_PSNext
.8d2b	c8		iny				iny 								; get the address of the record to zTemp0 and
.8d2c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d2e	29 c0		and #$c0			and 	#$C0
.8d30	c9 40		cmp #$40			cmp 	#$40
.8d32	d0 32		bne $8d66			bne 	_PSSyntax
.8d34	b1 30		lda ($30),y			lda 	(codePtr),y
.8d36	18		clc				clc
.8d37	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d39	85 37		sta $37				sta 	zTemp0+1
.8d3b	c8		iny				iny 								; LSB
.8d3c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d3e	85 36		sta $36				sta 	zTemp0
.8d40	c8		iny				iny 								; character after variable call.
.8d41	98		tya				tya 								; save Y offset at +7
.8d42	a0 07		ldy #$07			ldy 	#7
.8d44	91 36		sta ($36),y			sta 	(zTemp0),y
.8d46	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d48	a0 02		ldy #$02			ldy 	#2
.8d4a	91 36		sta ($36),y			sta 	(zTemp0),y
.8d4c	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d4e					_PSCopy:
.8d4e	b5 30		lda $30,x			lda 	safePtr,x
.8d50	c8		iny				iny
.8d51	91 36		sta ($36),y			sta 	(zTemp0),y
.8d53	e8		inx				inx
.8d54	e0 04		cpx #$04			cpx 	#4
.8d56	d0 f6		bne $8d4e			bne 	_PSCopy
.8d58					_PSNext:
.8d58	18		clc				clc
.8d59	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d5b	65 30		adc $30				adc 	codePtr
.8d5d	85 30		sta $30				sta 	codePtr
.8d5f	90 02		bcc $8d63			bcc 	_CREExit
.8d61	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d63					_CREExit:
.8d63	80 ba		bra $8d1f			bra 	_PSLoop
.8d65					_PSExit:
.8d65	60		rts				rts
.8d66					_PSSyntax:
.8d66	4c 15 9f	jmp $9f15			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d69					ScanForward:
.8d69	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d6b	86 37		stx $37				stx 	zTemp0+1
.8d6d	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d6f					_ScanLoop:
.8d6f	b1 30		lda ($30),y			lda 	(codePtr),y
.8d71	c8		iny				iny
.8d72	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d74	d0 0e		bne $8d84			bne 	_ScanGoNext
.8d76	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d78	f0 04		beq $8d7e			beq 	_ScanMatch
.8d7a	c5 37		cmp $37				cmp 	zTemp0+1
.8d7c	d0 06		bne $8d84			bne 	_ScanGoNext
.8d7e					_ScanMatch:
.8d7e	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d80	d0 01		bne $8d83			bne 	_ScanNotEndEOL
.8d82	88		dey				dey
.8d83					_ScanNotEndEOL:
.8d83	60		rts				rts
.8d84					_ScanGoNext:
.8d84	20 89 8d	jsr $8d89			jsr  	ScanForwardOne
.8d87	80 e6		bra $8d6f			bra 	_ScanLoop
.8d89					ScanForwardOne:
.8d89	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d8b	90 3e		bcc $8dcb			bcc 	_SFWExit
.8d8d	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d8f	90 18		bcc $8da9			bcc 	_ScanSkipOne
.8d91	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d93	b0 2f		bcs $8dc4			bcs 	_ScanSkipData
.8d95	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d97	90 32		bcc $8dcb			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d99	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d9b	b0 2e		bcs $8dcb			bcs 	_SFWExit
.8d9d	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d9f	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8da1	b0 28		bcs $8dcb			bcs 	_SFWExit
.8da3	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8da5	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8da7	80 22		bra $8dcb			bra 	_SFWExit
.8da9					_ScanSkipOne:
.8da9	c8		iny				iny 								; consume the extra one.
.8daa	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8dac	d0 1d		bne $8dcb			bne 	_SFWExit
.8dae	18		clc				clc
.8daf	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8db1	65 30		adc $30				adc 	codePtr
.8db3	85 30		sta $30				sta 	codePtr
.8db5	90 02		bcc $8db9			bcc 	_CREExit
.8db7	e6 31		inc $31				inc 	codePtr+1 					; carry
.8db9					_CREExit:
.8db9	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8dbb	b2 30		lda ($30)			lda 	(codePtr)
.8dbd	d0 0c		bne $8dcb			bne 	_SFWExit 					; if not zero, more to scan
.8dbf	a9 13		lda #$13		lda	#19
.8dc1	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.8dc4					_ScanSkipData:
.8dc4	88		dey				dey 								; point at data token
.8dc5	c8		iny				iny 								; point to offset
.8dc6	98		tya				tya 								; A = offset position
.8dc7	38		sec				sec 								; add size +1 hence SEC
.8dc8	71 30		adc ($30),y			adc 	(codePtr),y
.8dca	a8		tay				tay 								; make current position.
.8dcb					_SFWExit:
.8dcb	60		rts				rts
.8dcc					ScanGetCurrentLineStep:
.8dcc	64 38		stz $38				stz 	zTemp1
.8dce	a0 03		ldy #$03			ldy 	#3
.8dd0					_SGCLSLoop:
.8dd0	b1 30		lda ($30),y			lda 	(codePtr),y
.8dd2	c8		iny				iny
.8dd3	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8dd5	f0 05		beq $8ddc			beq 	_SGCLSExit
.8dd7	20 89 8d	jsr $8d89			jsr 	ScanForwardOne
.8dda	80 f4		bra $8dd0			bra 	_SGCLSLoop
.8ddc					_SGCLSExit:
.8ddc	a5 38		lda $38				lda 	zTemp1
.8dde	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8ddf					Command_WHILE:
.8ddf	5a		phy				phy 								; save position of the test
.8de0	a2 00		ldx #$00			ldx 	#0
.8de2	20 e5 9c	jsr $9ce5			jsr 	EvaluateNumber 				; work out the number
.8de5	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; check if zero
.8de8	f0 0e		beq $8df8			beq 	_WHExitLoop 				; if so exit the loop
.8dea	98		tya				tya 								; position *after* test.
.8deb	7a		ply				ply 								; restore position before test, at WHILE
.8dec	88		dey				dey
.8ded	48		pha				pha 								; push after test on the stack
.8dee	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8df0	20 d9 a5	jsr $a5d9			jsr 	StackOpen
.8df3	20 1e a6	jsr $a61e			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8df6	7a		ply				ply 								; restore the position *after* the test
.8df7	60		rts				rts
.8df8					_WHExitLoop:
.8df8	68		pla				pla 								; throw post loop position
.8df9	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8dfb	aa		tax				tax
.8dfc	20 69 8d	jsr $8d69			jsr 	ScanForward
.8dff	60		rts				rts
.8e00					Command_WEND:
.8e00	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8e02	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8e04	20 06 a6	jsr $a606			jsr 	StackCheckFrame
.8e07	20 2f a6	jsr $a62f			jsr 	STKLoadCodePosition 		; loop back
.8e0a	20 f8 a5	jsr $a5f8			jsr 	StackClose		 			; erase the frame
.8e0d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8e0e					WhoCommand:
.8e0e	a2 8e		ldx #$8e			ldx 	#(_WHOMessage >> 8)
.8e10	a9 16		lda #$16			lda 	#(_WHOMessage & $FF)
.8e12	20 e3 8e	jsr $8ee3			jsr 	PrintStringXA
.8e15	60		rts				rts
.8e16					_WHOMessage:
>8e16	81						.byte 	$81
>8e17	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8e1f	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8e2c	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8e34	20 41 6c 6c 61 69 72 65 0d
>8e3d	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8e45	4f 62 65 72 72 65 75 74 65 72 0d
>8e50	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8e58	62 73 6f 6e 0d
>8e5d	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8e65	65 69 6e 67 61 72 74 6e 65 72 0d
>8e70	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8e71					CheckRightBracket:
.8e71	b1 30		lda ($30),y			lda 	(codePtr),y
.8e73	c8		iny				iny
.8e74	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8e76	d0 0f		bne $8e87			bne 	CNAFail
.8e78	60		rts				rts
.8e79					CheckComma:
.8e79	b1 30		lda ($30),y			lda 	(codePtr),y
.8e7b	c8		iny				iny
.8e7c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8e7e	d0 07		bne $8e87			bne 	CNAFail
.8e80	60		rts				rts
.8e81					CheckNextA:
.8e81	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8e83	d0 02		bne $8e87			bne 	CNAFail
.8e85	c8		iny				iny 								; skip character
.8e86	60		rts				rts 								; and exit
.8e87					CNAFail:
.8e87	4c 15 9f	jmp $9f15			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8e8a					ErrorHandler:
.8e8a	a8		tay				tay 								; find the error text
.8e8b	f0 49		beq $8ed6			beq 	_EHEnd
.8e8d	a2 00		ldx #$00			ldx 	#0
.8e8f	a9 2e		lda #$2e			lda 	#((ErrorText) & $FF)
.8e91	85 36		sta $36				sta 	0+zTemp0
.8e93	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8e95	85 37		sta $37				sta 	1+zTemp0
.8e97					_EHFind:
.8e97	88		dey				dey 								; keep looking through text
.8e98	f0 0e		beq $8ea8			beq 	_EHFound
.8e9a					_EHFindZero:
.8e9a	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e9c	e6 36		inc $36				inc 	zTemp0
.8e9e	d0 02		bne $8ea2			bne 	_EHFNoCarry
.8ea0	e6 37		inc $37				inc 	zTemp0+1
.8ea2					_EHFNoCarry:
.8ea2	c9 00		cmp #$00			cmp 	#0
.8ea4	d0 f4		bne $8e9a			bne 	_EHFindZero
.8ea6	80 ef		bra $8e97			bra 	_EHFind
.8ea8					_EHFound:
.8ea8	a5 36		lda $36				lda 	zTemp0 						; print message
.8eaa	a6 37		ldx $37				ldx 	zTemp0+1
.8eac	20 e3 8e	jsr $8ee3			jsr 	PrintStringXA
.8eaf	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8eb1	b1 30		lda ($30),y			lda 	(codePtr),y
.8eb3	d0 05		bne $8eba			bne 	_EHAtMsg
.8eb5	c8		iny				iny
.8eb6	b1 30		lda ($30),y			lda 	(codePtr),y
.8eb8	f0 17		beq $8ed1			beq 	_EHCREnd
.8eba					_EHAtMsg:
.8eba	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8ebc	a9 d9		lda #$d9			lda 	#_AtMsg & $FF
.8ebe	20 e3 8e	jsr $8ee3			jsr 	PrintStringXA
.8ec1	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8ec3	b1 30		lda ($30),y			lda 	(codePtr),y
.8ec5	48		pha				pha
.8ec6	c8		iny				iny
.8ec7	b1 30		lda ($30),y			lda 	(codePtr),y
.8ec9	aa		tax				tax
.8eca	68		pla				pla
.8ecb	20 f9 92	jsr $92f9			jsr 	ConvertInt16 				; convert XA to string
.8ece	20 e3 8e	jsr $8ee3			jsr 	PrintStringXA 				; and print it.
.8ed1					_EHCREnd:
.8ed1	a9 0d		lda #$0d			lda 	#13 						; new line
.8ed3	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8ed6					_EHEnd:
.8ed6	4c 46 83	jmp $8346			jmp 	WarmStart
>8ed9	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8ee1	20 00
.8ee3					PrintStringXA:
.8ee3	5a		phy				phy
.8ee4	86 37		stx $37				stx 	zTemp0+1
.8ee6	85 36		sta $36				sta 	zTemp0
.8ee8	a0 00		ldy #$00			ldy 	#0
.8eea					_PSXALoop:
.8eea	b1 36		lda ($36),y			lda 	(zTemp0),y
.8eec	f0 06		beq $8ef4			beq 	_PSXAExit
.8eee	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8ef1	c8		iny				iny
.8ef2	80 f6		bra $8eea			bra 	_PSXALoop
.8ef4					_PSXAExit:
.8ef4	7a		ply				ply
.8ef5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8ef6					UnaryTrue:
.8ef6	fa		plx				plx
.8ef7					ReturnTrue:
.8ef7	a9 01		lda #$01			lda 	#1  						; set to 1
.8ef9	20 99 9d	jsr $9d99			jsr 	NSMSetByte
.8efc	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8efe	95 50		sta $50,x			sta 	NSStatus,x
.8f00	60		rts				rts
.8f01					UnaryFalse:
.8f01	fa		plx				plx
.8f02					ReturnFalse:
.8f02	4c 97 9d	jmp $9d97			jmp 	NSMSetZero 					; set it all to zero
.8f05					BinaryCompareEqual:
.8f05	fa		plx				plx
.8f06	20 41 8f	jsr $8f41			jsr 	CompareBaseCode
.8f09	c9 00		cmp #$00			cmp 	#0
.8f0b	f0 ea		beq $8ef7			beq 	ReturnTrue
.8f0d	80 f3		bra $8f02			bra 	ReturnFalse
.8f0f					BinaryCompareLess:
.8f0f	fa		plx				plx
.8f10	20 41 8f	jsr $8f41			jsr 	CompareBaseCode
.8f13	c9 ff		cmp #$ff			cmp 	#$FF
.8f15	f0 e0		beq $8ef7			beq 	ReturnTrue
.8f17	80 e9		bra $8f02			bra 	ReturnFalse
.8f19					BinaryCompareGreater:
.8f19	fa		plx				plx
.8f1a	20 41 8f	jsr $8f41			jsr 	CompareBaseCode
.8f1d	c9 01		cmp #$01			cmp 	#1
.8f1f	f0 d6		beq $8ef7			beq 	ReturnTrue
.8f21	80 df		bra $8f02			bra 	ReturnFalse
.8f23					BinaryCompareNotEqual:
.8f23	fa		plx				plx
.8f24	20 41 8f	jsr $8f41			jsr 	CompareBaseCode
.8f27	c9 00		cmp #$00			cmp 	#0
.8f29	d0 cc		bne $8ef7			bne 	ReturnTrue
.8f2b	80 d5		bra $8f02			bra 	ReturnFalse
.8f2d					BinaryCompareLessEqual:
.8f2d	fa		plx				plx
.8f2e	20 41 8f	jsr $8f41			jsr 	CompareBaseCode
.8f31	c9 01		cmp #$01			cmp 	#1
.8f33	d0 c2		bne $8ef7			bne 	ReturnTrue
.8f35	80 cb		bra $8f02			bra 	ReturnFalse
.8f37					BinaryCompareGreaterEqual:
.8f37	fa		plx				plx
.8f38	20 41 8f	jsr $8f41			jsr 	CompareBaseCode
.8f3b	c9 ff		cmp #$ff			cmp 	#$FF
.8f3d	d0 b8		bne $8ef7			bne 	ReturnTrue
.8f3f	80 c1		bra $8f02			bra 	ReturnFalse
.8f41					CompareBaseCode:
.8f41	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; make both values if references.
.8f44	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8f46	15 51		ora $51,x			ora 	NSStatus+1,x
.8f48	29 10		and #$10			and 	#NSTString
.8f4a	d0 37		bne $8f83			bne 	_CBCString 					; if so do string code, which will check if both.
.8f4c	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8f4e	15 79		ora $79,x			ora 	NSExponent+1,x
.8f50	d0 34		bne $8f86			bne 	_CBCFloat
.8f52	b5 50		lda $50,x			lda 	NSStatus,x
.8f54	15 51		ora $51,x			ora 	NSStatus+1,x
.8f56	29 08		and #$08			and 	#NSTFloat
.8f58	d0 2c		bne $8f86			bne 	_CBCFloat
.8f5a	20 89 8f	jsr $8f89			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8f5d	e8		inx				inx
.8f5e	20 89 8f	jsr $8f89			jsr 	CompareFixMinusZero
.8f61	ca		dex				dex
.8f62	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8f64	55 51		eor $51,x			eor 	NSStatus+1,x
.8f66	10 0a		bpl $8f72			bpl 	_CDCSameSign
.8f68	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8f6a	30 14		bmi $8f80			bmi 	_CBCLess 					; return $FF
.8f6c					_CBCGreater:
.8f6c	a9 01		lda #$01			lda 	#1
.8f6e	60		rts				rts
.8f6f					_CBCEqual:
.8f6f	a9 00		lda #$00			lda 	#0
.8f71	60		rts				rts
.8f72					_CDCSameSign:
.8f72	20 9e 91	jsr $919e			jsr 	SubTopTwoStack 				; unsigned subtract
.8f75	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; or the mantissa together
.8f78	f0 f5		beq $8f6f			beq 	_CBCEqual 					; -0 == 0
.8f7a	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8f7c	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8f7e	10 ec		bpl $8f6c			bpl 	_CBCGreater
.8f80					_CBCLess:
.8f80	a9 ff		lda #$ff			lda 	#$FF
.8f82	60		rts				rts
.8f83					_CBCString:
.8f83	4c 0f 91	jmp $910f			jmp 	CompareStrings
.8f86					_CBCFloat:
.8f86	4c 59 94	jmp $9459			jmp 	CompareFloat
.8f89					CompareFixMinusZero:
.8f89	20 b9 9d	jsr $9db9			jsr 	NSMIsZero
.8f8c	d0 02		bne $8f90			bne 	_CFXMZNotZero
.8f8e	74 50		stz $50,x			stz 	NSStatus,x
.8f90					_CFXMZNotZero:
.8f90	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f91					StringConcat:
.8f91	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.8f93	35 51		and $51,x			and 	NSStatus+1,x
.8f95	29 18		and #$18			and 	#NSBTypeMask
.8f97	c9 10		cmp #$10			cmp 	#NSTString
.8f99	d0 50		bne $8feb			bne		_SCType
.8f9b	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f9d	e8		inx				inx
.8f9e	20 bc 8f	jsr $8fbc			jsr 	_SCSetupZ0 					; setup for second
.8fa1	20 c5 8f	jsr $8fc5			jsr 	_SCLengthZ0 				; length for second
.8fa4	ca		dex				dex
.8fa5	20 bc 8f	jsr $8fbc			jsr 	_SCSetupZ0 					; setup for first
.8fa8	20 c5 8f	jsr $8fc5			jsr 	_SCLengthZ0 				; length for first
.8fab	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.8fad	20 c9 a6	jsr $a6c9			jsr 	StringTempAllocate
.8fb0	20 dc 8f	jsr $8fdc			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8fb3	e8		inx				inx
.8fb4	20 bc 8f	jsr $8fbc			jsr 	_SCSetupZ0 					; copy second out
.8fb7	20 dc 8f	jsr $8fdc			jsr 	_SCCopy
.8fba	ca		dex				dex
.8fbb	60		rts				rts
.8fbc					_SCSetupZ0:
.8fbc	b5 58		lda $58,x			lda 	NSMantissa0,x
.8fbe	85 36		sta $36				sta 	zTemp0
.8fc0	b5 60		lda $60,x			lda 	NSMantissa1,x
.8fc2	85 37		sta $37				sta 	zTemp0+1
.8fc4	60		rts				rts
.8fc5					_SCLengthZ0:
.8fc5	5a		phy				phy
.8fc6	a0 00		ldy #$00			ldy 	#0
.8fc8					_SCLenLoop:
.8fc8	b1 36		lda ($36),y			lda 	(zTemp0),y
.8fca	f0 0e		beq $8fda			beq 	_SCLExit
.8fcc	c8		iny				iny
.8fcd	e6 38		inc $38				inc 	zTemp1
.8fcf	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.8fd1	c9 fd		cmp #$fd			cmp 	#253
.8fd3	d0 f3		bne $8fc8			bne		_SCLenLoop
.8fd5	a9 09		lda #$09		lda	#9
.8fd7	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.8fda					_SCLExit:
.8fda	7a		ply				ply
.8fdb	60		rts				rts
.8fdc					_SCCopy:
.8fdc	5a		phy				phy
.8fdd	a0 00		ldy #$00			ldy 	#0
.8fdf					_SCCopyLoop:
.8fdf	b1 36		lda ($36),y			lda 	(zTemp0),y
.8fe1	f0 06		beq $8fe9			beq 	_SCCExit
.8fe3	20 02 a7	jsr $a702			jsr 	StringTempWrite
.8fe6	c8		iny				iny
.8fe7	80 f6		bra $8fdf			bra 	_SCCopyLoop
.8fe9					_SCCExit:
.8fe9	7a		ply				ply
.8fea	60		rts				rts
.8feb					_SCType:
.8feb	4c 1f 9f	jmp $9f1f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8fee					IntegerDivide:
.8fee	fa		plx				plx
.8fef	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.8ff1	15 51		ora $51,x			ora 	NSStatus+1,x
.8ff3	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8ff4	0a		asl a				asl 	a
.8ff5	10 05		bpl $8ffc			bpl 	_NotRef
.8ff7	48		pha				pha
.8ff8	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8ffb	68		pla				pla
.8ffc					_NotRef:
.8ffc	0a		asl a				asl 	a
.8ffd	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8fff	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9001	15 79		ora $79,x			ora 	NSExponent+1,x
.9003	f0 03		beq $9008			beq 	_IntegerCode 				; if clear, then we have two integers
.9005	4c 1f 9f	jmp $9f1f			jmp 	TypeError 					; anything else, type mismatch.
.9008					_IntegerCode:
.9008	20 22 90	jsr $9022			jsr 	CheckDivideZero 			; do div zero check
.900b	20 54 90	jsr $9054			jsr 	Int32Divide 				; do the division
.900e	20 05 91	jsr $9105			jsr 	CalculateSign 				; calculate result sign
.9011					NSMCopyPlusTwoToZero:
.9011	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9013	95 58		sta $58,x			sta 	NSMantissa0,x
.9015	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.9017	95 60		sta $60,x			sta 	NSMantissa1,x
.9019	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.901b	95 68		sta $68,x			sta 	NSMantissa2,x
.901d	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.901f	95 70		sta $70,x			sta 	NSMantissa3,x
.9021	60		rts				rts
.9022					CheckDivideZero:
.9022	e8		inx				inx
.9023	20 b9 9d	jsr $9db9			jsr 	NSMIsZero
.9026	f0 02		beq $902a			beq 	_CDVError
.9028	ca		dex				dex
.9029	60		rts				rts
.902a					_CDVError:
.902a	a9 03		lda #$03		lda	#3
.902c	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.902f					IntegerModulus:
.902f	fa		plx				plx
.9030	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9032	15 51		ora $51,x			ora 	NSStatus+1,x
.9034	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9035	0a		asl a				asl 	a
.9036	10 05		bpl $903d			bpl 	_NotRef
.9038	48		pha				pha
.9039	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.903c	68		pla				pla
.903d					_NotRef:
.903d	0a		asl a				asl 	a
.903e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9040	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9042	15 79		ora $79,x			ora 	NSExponent+1,x
.9044	f0 03		beq $9049			beq 	_IntegerCode 				; if clear, then we have two integers
.9046	4c 1f 9f	jmp $9f1f			jmp 	TypeError 					; anything else, type mismatch.
.9049					_IntegerCode:
.9049					IntegerModulusNoCheck:
.9049	20 22 90	jsr $9022			jsr 	CheckDivideZero 			; do div zero check
.904c	20 54 90	jsr $9054			jsr 	Int32Divide 				; do the division
.904f	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9051	56 50		lsr $50,x			lsr 	NSStatus,x
.9053	60		rts				rts
.9054					Int32Divide:
.9054	48		pha				pha 								; save AXY
.9055	5a		phy				phy
.9056	20 7a 9d	jsr $9d7a			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9059	20 93 9d	jsr $9d93			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.905c	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.905e					_I32DivideLoop:
.905e	e8		inx				inx
.905f	e8		inx				inx
.9060	20 a6 9d	jsr $9da6			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.9063	ca		dex				dex
.9064	ca		dex				dex
.9065	20 a7 9d	jsr $9da7			jsr 	NSMRotateLeft
.9068	20 93 90	jsr $9093			jsr 	DivideCheckSubtract 		; check if subtract possible
.906b	90 02		bcc $906f			bcc 	_I32DivideNoCarryIn
.906d	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.906f					_I32DivideNoCarryIn:
.906f	88		dey				dey 								; loop round till division completed.
.9070	d0 ec		bne $905e			bne 	_I32DivideLoop
.9072	7a		ply				ply 								; restore AXY and exit
.9073	68		pla				pla
.9074	60		rts				rts
.9075					Int32ShiftDivide:
.9075	48		pha				pha 								; save AY
.9076	5a		phy				phy
.9077	e8		inx				inx 								; clear S[X+2]
.9078	e8		inx				inx
.9079	20 97 9d	jsr $9d97			jsr 	NSMSetZero
.907c	ca		dex				dex
.907d	ca		dex				dex
.907e	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9080					_I32SDLoop:
.9080	20 93 90	jsr $9093			jsr 	DivideCheckSubtract 		; check if subtract possible
.9083	e8		inx				inx
.9084	e8		inx				inx
.9085	20 a7 9d	jsr $9da7			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.9088	ca		dex				dex
.9089	ca		dex				dex
.908a	20 a7 9d	jsr $9da7			jsr 	NSMRotateLeft
.908d	88		dey				dey 	 							; do 31 times
.908e	d0 f0		bne $9080			bne 	_I32SDLoop
.9090	7a		ply				ply 								; restore AY and exit
.9091	68		pla				pla
.9092	60		rts				rts
.9093					DivideCheckSubtract:
.9093	20 9e 91	jsr $919e			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9096	b0 04		bcs $909c			bcs 	_DCSExit 					; if carry set, then could do, exit
.9098	20 84 91	jsr $9184			jsr 	AddTopTwoStack 				; add it back in
.909b	18		clc				clc 								; and return False
.909c					_DCSExit:
.909c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.909d					MulInteger:
.909d	fa		plx				plx
.909e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90a0	15 51		ora $51,x			ora 	NSStatus+1,x
.90a2	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90a3	0a		asl a				asl 	a
.90a4	10 05		bpl $90ab			bpl 	_NotRef
.90a6	48		pha				pha
.90a7	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90aa	68		pla				pla
.90ab					_NotRef:
.90ab	0a		asl a				asl 	a 							; put MSB of type into A:7
.90ac	30 09		bmi $90b7			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.90ae	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90b0	15 79		ora $79,x			ora 	NSExponent+1,x
.90b2	f0 06		beq $90ba			beq 	_IntegerCode 				; if clear, then we have two integers
.90b4	4c 1b 95	jmp $951b			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.90b7					_StringData:
.90b7	4c 29 9f	jmp $9f29			jmp 	NotDoneError							; at least one string - don't know both are strings.
.90ba					_IntegerCode:
.90ba	20 c7 90	jsr $90c7			jsr 	MultiplyShort
.90bd	c9 00		cmp #$00			cmp 	#0
.90bf	f0 05		beq $90c6			beq 	_MIExit
.90c1	a9 04		lda #$04		lda	#4
.90c3	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.90c6					_MIExit:
.90c6	60		rts				rts
.90c7					MultiplyShort:
.90c7	5a		phy				phy 								; save Y
.90c8	20 7a 9d	jsr $9d7a			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90cb	20 93 9d	jsr $9d93			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.90ce	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.90d0					_I32MLoop:
.90d0	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.90d2	15 62		ora $62,x			ora 	NSMantissa1+2,x
.90d4	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.90d6	15 72		ora $72,x			ora 	NSMantissa3+2,x
.90d8	f0 25		beq $90ff			beq 	_I32MExit 					; exit if zero
.90da	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.90dc	29 01		and #$01			and 	#1
.90de	f0 0d		beq $90ed			beq 	_I32MNoAdd
.90e0	20 84 91	jsr $9184			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.90e3	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.90e5	10 06		bpl $90ed			bpl 	_I32MNoAdd
.90e7					_I32ShiftRight:
.90e7	20 b0 9d	jsr $9db0			jsr 	NSMShiftRight 				; shift S[X] right
.90ea	c8		iny				iny 								; increment shift count
.90eb	80 09		bra $90f6			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.90ed					_I32MNoAdd:
.90ed	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.90ef	70 f6		bvs $90e7			bvs 	_I32ShiftRight 				; instead.
.90f1	e8		inx				inx
.90f2	20 a6 9d	jsr $9da6			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.90f5	ca		dex				dex
.90f6					_I32MShiftUpper:
.90f6	e8		inx				inx 								; shift S[X+2] right
.90f7	e8		inx				inx
.90f8	20 b0 9d	jsr $9db0			jsr 	NSMShiftRight
.90fb	ca		dex				dex
.90fc	ca		dex				dex
.90fd	80 d1		bra $90d0			bra 	_I32MLoop 					; try again.
.90ff					_I32MExit:
.90ff	20 05 91	jsr $9105			jsr 	CalculateSign
.9102	98		tya				tya 								; shift in A
.9103	7a		ply				ply 								; restore Y and exit
.9104	60		rts				rts
.9105					CalculateSign:
.9105	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9107	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.9109	55 51		eor $51,x			eor 	NSStatus+1,x
.910b	0a		asl a				asl 	a 							; shift bit 7 into carry
.910c	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.910e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.910f					CompareStrings:
.910f	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.9111	35 51		and $51,x			and 	NSStatus+1,x
.9113	29 10		and #$10			and 	#NSBIsString
.9115	f0 28		beq $913f			beq 	_CSTypeError
.9117	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9119	85 36		sta $36				sta 	zTemp0
.911b	b5 60		lda $60,x			lda 	NSMantissa1,x
.911d	85 37		sta $37				sta 	zTemp0+1
.911f	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9121	85 38		sta $38				sta 	zTemp1
.9123	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9125	85 39		sta $39				sta 	zTemp1+1
.9127	5a		phy				phy 								; save Y so we can access strings
.9128	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.912a					_CSLoop:
.912a	c8		iny				iny
.912b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.912d	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.912f	d0 06		bne $9137			bne 	_CSDifferent
.9131	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9133	d0 f5		bne $912a			bne 	_CSLoop 					; still comparing
.9135					_CSExit:
.9135	7a		ply				ply 								; reached end, return zero in A from EOS
.9136	60		rts				rts
.9137					_CSDifferent:
.9137	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.9139	90 fa		bcc $9135			bcc		_CSExit
.913b	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.913d	80 f6		bra $9135			bra 	_CSExit
.913f					_CSTypeError:
.913f	4c 1f 9f	jmp $9f1f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9142					ShiftLeft:
.9142	38		sec				sec 								; common code, carry determines which way.
.9143	80 01		bra $9146			bra 	ShiftMain
.9145					ShiftRight:
.9145	18		clc				clc
.9146					ShiftMain:
.9146	fa		plx				plx 								; restore X
.9147	08		php				php 								; save direction
.9148	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.914a	15 51		ora $51,x			ora 	NSStatus+1,x
.914c	0a		asl a				asl 	a 							; shift reference bit into sign bit
.914d	0a		asl a				asl 	a
.914e	10 05		bpl $9155			bpl 	_NotRef
.9150	48		pha				pha
.9151	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9154	68		pla				pla
.9155					_NotRef:
.9155	0a		asl a				asl 	a
.9156	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9158	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.915a	15 79		ora $79,x			ora 	NSExponent+1,x
.915c	f0 03		beq $9161			beq 	_IntegerCode 				; if clear, then we have two integers
.915e	4c 1f 9f	jmp $9f1f			jmp 	TypeError 					; anything else, type mismatch.
.9161					_IntegerCode:
.9161	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.9163	29 e0		and #$e0			and 	#$E0
.9165	15 61		ora $61,x			ora 	NSMantissa1+1,x
.9167	15 69		ora $69,x			ora 	NSMantissa2+1,x
.9169	15 71		ora $71,x			ora 	NSMantissa3+1,x
.916b	d0 12		bne $917f			bne 	_SMExit0 					; if >= 32 it will always return zero.
.916d					_SMLoop:
.916d	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.916f	30 11		bmi $9182			bmi 	_SMExit 					; exit if done.
.9171	28		plp				plp 								; restore direction setting
.9172	08		php				php
.9173	90 05		bcc $917a			bcc 	_SMRight
.9175	20 a6 9d	jsr $9da6			jsr 	NSMShiftLeft 				; shift left if CS
.9178	80 f3		bra $916d			bra 	_SMLoop
.917a					_SMRight:
.917a	20 b0 9d	jsr $9db0			jsr 	NSMShiftRight 				; shift right if CC
.917d	80 ee		bra $916d			bra 	_SMLoop
.917f					_SMExit0:
.917f	20 97 9d	jsr $9d97			jsr 	NSMSetZero 					; return zero.
.9182					_SMExit:
.9182	28		plp				plp 								; throw direction
.9183	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9184					AddTopTwoStack:
.9184	18		clc				clc
.9185	b5 58		lda $58,x			lda		NSMantissa0,x
.9187	75 59		adc $59,x			adc 		NSMantissa0+1,x
.9189	95 58		sta $58,x			sta 	NSMantissa0,x
.918b	b5 60		lda $60,x			lda		NSMantissa1,x
.918d	75 61		adc $61,x			adc 		NSMantissa1+1,x
.918f	95 60		sta $60,x			sta 	NSMantissa1,x
.9191	b5 68		lda $68,x			lda		NSMantissa2,x
.9193	75 69		adc $69,x			adc 		NSMantissa2+1,x
.9195	95 68		sta $68,x			sta 	NSMantissa2,x
.9197	b5 70		lda $70,x			lda		NSMantissa3,x
.9199	75 71		adc $71,x			adc 		NSMantissa3+1,x
.919b	95 70		sta $70,x			sta 	NSMantissa3,x
.919d	60		rts				rts
.919e					SubTopTwoStack:
.919e	38		sec				sec
.919f	b5 58		lda $58,x			lda		NSMantissa0,x
.91a1	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.91a3	95 58		sta $58,x			sta 	NSMantissa0,x
.91a5	b5 60		lda $60,x			lda		NSMantissa1,x
.91a7	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.91a9	95 60		sta $60,x			sta 	NSMantissa1,x
.91ab	b5 68		lda $68,x			lda		NSMantissa2,x
.91ad	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.91af	95 68		sta $68,x			sta 	NSMantissa2,x
.91b1	b5 70		lda $70,x			lda		NSMantissa3,x
.91b3	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.91b5	95 70		sta $70,x			sta 	NSMantissa3,x
.91b7	60		rts				rts
.91b8					AddInteger:
.91b8	fa		plx				plx
.91b9	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91bb	15 51		ora $51,x			ora 	NSStatus+1,x
.91bd	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91be	0a		asl a				asl 	a
.91bf	10 05		bpl $91c6			bpl 	_NotRef
.91c1	48		pha				pha
.91c2	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91c5	68		pla				pla
.91c6					_NotRef:
.91c6	0a		asl a				asl 	a 							; put MSB of type into A:7
.91c7	30 09		bmi $91d2			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91c9	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91cb	15 79		ora $79,x			ora 	NSExponent+1,x
.91cd	f0 06		beq $91d5			beq 	_IntegerCode 				; if clear, then we have two integers
.91cf	4c cb 93	jmp $93cb			jmp 	FloatingPointAdd 							; otherwise at least one float.
.91d2					_StringData:
.91d2	4c 91 8f	jmp $8f91			jmp 	StringConcat							; at least one string - don't know both are strings.
.91d5					_IntegerCode:
.91d5					AddCode:
.91d5	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.91d7	55 51		eor $51,x			eor 	NSStatus+1,x
.91d9	10 a9		bpl $9184			bpl 	AddTopTwoStack
.91db	20 9e 91	jsr $919e			jsr 	SubTopTwoStack 				; do a physical subtraction
.91de	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.91e0	10 07		bpl $91e9			bpl 	_AddExit
.91e2	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.91e4	95 50		sta $50,x			sta 	NSStatus,x
.91e6	20 60 9d	jsr $9d60			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.91e9					_AddExit:
.91e9	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; check for -0
.91ec	d0 02		bne $91f0			bne 	_AddNonZero
.91ee	74 50		stz $50,x			stz 	NSStatus,x
.91f0					_AddNonZero:
.91f0	60		rts				rts
.91f1					SubInteger:
.91f1	fa		plx				plx
.91f2	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91f4	15 51		ora $51,x			ora 	NSStatus+1,x
.91f6	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91f7	0a		asl a				asl 	a
.91f8	10 05		bpl $91ff			bpl 	_NotRef
.91fa	48		pha				pha
.91fb	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91fe	68		pla				pla
.91ff					_NotRef:
.91ff	0a		asl a				asl 	a 							; put MSB of type into A:7
.9200	30 09		bmi $920b			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9202	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9204	15 79		ora $79,x			ora 	NSExponent+1,x
.9206	f0 06		beq $920e			beq 	_IntegerCode 				; if clear, then we have two integers
.9208	4c d0 93	jmp $93d0			jmp 	FloatingPointSub 							; otherwise at least one float.
.920b					_StringData:
.920b	4c 29 9f	jmp $9f29			jmp 	NotDoneError							; at least one string - don't know both are strings.
.920e					_IntegerCode:
.920e	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.9210	49 80		eor #$80			eor 	#$80
.9212	95 51		sta $51,x			sta 	NSStatus+1,x
.9214	80 bf		bra $91d5			bra 	AddCode 					; and do the same code as add.
.9216					AndInteger:
.9216	fa		plx				plx
.9217	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9219	15 51		ora $51,x			ora 	NSStatus+1,x
.921b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.921c	0a		asl a				asl 	a
.921d	10 05		bpl $9224			bpl 	_NotRef
.921f	48		pha				pha
.9220	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9223	68		pla				pla
.9224					_NotRef:
.9224	0a		asl a				asl 	a
.9225	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9227	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9229	15 79		ora $79,x			ora 	NSExponent+1,x
.922b	f0 03		beq $9230			beq 	_IntegerCode 				; if clear, then we have two integers
.922d	4c 1f 9f	jmp $9f1f			jmp 	TypeError 					; anything else, type mismatch.
.9230					_IntegerCode:
.9230	b5 58		lda $58,x			lda		NSMantissa0,x
.9232	35 59		and $59,x			and 		NSMantissa0+1,x
.9234	95 58		sta $58,x			sta 	NSMantissa0,x
.9236	b5 60		lda $60,x			lda		NSMantissa1,x
.9238	35 61		and $61,x			and 		NSMantissa1+1,x
.923a	95 60		sta $60,x			sta 	NSMantissa1,x
.923c	b5 68		lda $68,x			lda		NSMantissa2,x
.923e	35 69		and $69,x			and 		NSMantissa2+1,x
.9240	95 68		sta $68,x			sta 	NSMantissa2,x
.9242	b5 70		lda $70,x			lda		NSMantissa3,x
.9244	35 71		and $71,x			and 		NSMantissa3+1,x
.9246	95 70		sta $70,x			sta 	NSMantissa3,x
.9248	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.924a	60		rts				rts
.924b					OraInteger:
.924b	fa		plx				plx
.924c	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.924e	15 51		ora $51,x			ora 	NSStatus+1,x
.9250	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9251	0a		asl a				asl 	a
.9252	10 05		bpl $9259			bpl 	_NotRef
.9254	48		pha				pha
.9255	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9258	68		pla				pla
.9259					_NotRef:
.9259	0a		asl a				asl 	a
.925a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.925c	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.925e	15 79		ora $79,x			ora 	NSExponent+1,x
.9260	f0 03		beq $9265			beq 	_IntegerCode 				; if clear, then we have two integers
.9262	4c 1f 9f	jmp $9f1f			jmp 	TypeError 					; anything else, type mismatch.
.9265					_IntegerCode:
.9265	b5 58		lda $58,x			lda		NSMantissa0,x
.9267	15 59		ora $59,x			ora 		NSMantissa0+1,x
.9269	95 58		sta $58,x			sta 	NSMantissa0,x
.926b	b5 60		lda $60,x			lda		NSMantissa1,x
.926d	15 61		ora $61,x			ora 		NSMantissa1+1,x
.926f	95 60		sta $60,x			sta 	NSMantissa1,x
.9271	b5 68		lda $68,x			lda		NSMantissa2,x
.9273	15 69		ora $69,x			ora 		NSMantissa2+1,x
.9275	95 68		sta $68,x			sta 	NSMantissa2,x
.9277	b5 70		lda $70,x			lda		NSMantissa3,x
.9279	15 71		ora $71,x			ora 		NSMantissa3+1,x
.927b	95 70		sta $70,x			sta 	NSMantissa3,x
.927d	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.927f	60		rts				rts
.9280					EorInteger:
.9280	fa		plx				plx
.9281	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9283	15 51		ora $51,x			ora 	NSStatus+1,x
.9285	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9286	0a		asl a				asl 	a
.9287	10 05		bpl $928e			bpl 	_NotRef
.9289	48		pha				pha
.928a	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.928d	68		pla				pla
.928e					_NotRef:
.928e	0a		asl a				asl 	a
.928f	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9291	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9293	15 79		ora $79,x			ora 	NSExponent+1,x
.9295	f0 03		beq $929a			beq 	_IntegerCode 				; if clear, then we have two integers
.9297	4c 1f 9f	jmp $9f1f			jmp 	TypeError 					; anything else, type mismatch.
.929a					_IntegerCode:
.929a	b5 58		lda $58,x			lda		NSMantissa0,x
.929c	55 59		eor $59,x			eor 		NSMantissa0+1,x
.929e	95 58		sta $58,x			sta 	NSMantissa0,x
.92a0	b5 60		lda $60,x			lda		NSMantissa1,x
.92a2	55 61		eor $61,x			eor 		NSMantissa1+1,x
.92a4	95 60		sta $60,x			sta 	NSMantissa1,x
.92a6	b5 68		lda $68,x			lda		NSMantissa2,x
.92a8	55 69		eor $69,x			eor 		NSMantissa2+1,x
.92aa	95 68		sta $68,x			sta 	NSMantissa2,x
.92ac	b5 70		lda $70,x			lda		NSMantissa3,x
.92ae	55 71		eor $71,x			eor 		NSMantissa3+1,x
.92b0	95 70		sta $70,x			sta 	NSMantissa3,x
.92b2	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92b4	60		rts				rts
.92b5					WordIndirect:
.92b5	fa		plx				plx
.92b6	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92b8	15 51		ora $51,x			ora 	NSStatus+1,x
.92ba	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92bb	0a		asl a				asl 	a
.92bc	10 05		bpl $92c3			bpl 	_NotRef
.92be	48		pha				pha
.92bf	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92c2	68		pla				pla
.92c3					_NotRef:
.92c3	0a		asl a				asl 	a
.92c4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92c6	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92c8	15 79		ora $79,x			ora 	NSExponent+1,x
.92ca	f0 03		beq $92cf			beq 	_IntegerCode 				; if clear, then we have two integers
.92cc	4c 1f 9f	jmp $9f1f			jmp 	TypeError 					; anything else, type mismatch.
.92cf					_IntegerCode:
.92cf	20 d5 91	jsr $91d5			jsr 	AddCode 					; add the two values
.92d2	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.92d4	95 50		sta $50,x			sta 	NSStatus,x
.92d6	60		rts				rts
.92d7					ByteIndirect:
.92d7	fa		plx				plx
.92d8	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92da	15 51		ora $51,x			ora 	NSStatus+1,x
.92dc	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92dd	0a		asl a				asl 	a
.92de	10 05		bpl $92e5			bpl 	_NotRef
.92e0	48		pha				pha
.92e1	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92e4	68		pla				pla
.92e5					_NotRef:
.92e5	0a		asl a				asl 	a
.92e6	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92e8	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92ea	15 79		ora $79,x			ora 	NSExponent+1,x
.92ec	f0 03		beq $92f1			beq 	_IntegerCode 				; if clear, then we have two integers
.92ee	4c 1f 9f	jmp $9f1f			jmp 	TypeError 					; anything else, type mismatch.
.92f1					_IntegerCode:
.92f1	20 d5 91	jsr $91d5			jsr 	AddCode 					; add the two values
.92f4	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.92f6	95 50		sta $50,x			sta 	NSStatus,x
.92f8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.92f9					ConvertInt16:
.92f9	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.92fb	86 60		stx $60				stx 	NSMantissa1
.92fd	64 68		stz $68				stz 	NSMantissa2
.92ff	64 70		stz $70				stz 	NSMantissa3
.9301	64 50		stz $50				stz 	NSStatus 					; positive integer
.9303	a2 00		ldx #$00			ldx 	#0 							; stack level
.9305	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.9307	80 00		bra $9309			bra 	ConvertInt32
.9309					ConvertInt32:
.9309	5a		phy				phy
.930a	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.930c	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.930e	10 08		bpl $9318			bpl 	_CI32NotNeg
.9310	48		pha				pha
.9311	a9 2d		lda #$2d			lda 	#'-'
.9313	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.9316	c8		iny				iny
.9317	68		pla				pla
.9318					_CI32NotNeg:
.9318	20 26 93	jsr $9326			jsr 	_CI32DivideConvert 			; recursive conversion
.931b	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.931d	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.9320	7a		ply				ply
.9321	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8 			; return address in XA
.9323	a9 7b		lda #$7b			lda 	#NumberBuffer & $FF
.9325	60		rts				rts
.9326					_CI32DivideConvert:
.9326	e8		inx				inx 								; write to next slot up
.9327	20 99 9d	jsr $9d99			jsr 	NSMSetByte 		 			; write the base out.
.932a	ca		dex				dex
.932b	20 54 90	jsr $9054			jsr 	Int32Divide 				; divide
.932e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.9330	48		pha				pha
.9331	20 11 90	jsr $9011			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.9334	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; is it zero ?
.9337	f0 05		beq $933e			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9339	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.933b	20 26 93	jsr $9326			jsr 	_CI32DivideConvert 			; and recusrively call.
.933e					_CI32NoRecurse:
.933e	68		pla				pla 								; remainder
.933f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.9341	90 02		bcc $9345			bcc 	_CI32NotHex
.9343	69 26		adc #$26			adc 	#6+32
.9345					_CI32NotHex:
.9345	69 30		adc #$30			adc 	#48
.9347	99 7b 05	sta $057b,y			sta 	NumberBuffer,y 				; write out and exit
.934a	c8		iny				iny
.934b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.934c					PrecedenceLevel:
>934c	04					.byte	 4	; $00 <<
>934d	02					.byte	 2	; $01 <=
>934e	02					.byte	 2	; $02 <>
>934f	00					.byte	 0	; $03 !!3
>9350	00					.byte	 0	; $04 ><
>9351	02					.byte	 2	; $05 >=
>9352	04					.byte	 4	; $06 >>
>9353	00					.byte	 0	; $07 !!7
>9354	00					.byte	 0	; $08 !!8
>9355	00					.byte	 0	; $09 !!9
>9356	00					.byte	 0	; $0a !!10
>9357	00					.byte	 0	; $0b !!11
>9358	00					.byte	 0	; $0c !!12
>9359	00					.byte	 0	; $0d !!13
>935a	00					.byte	 0	; $0e !!14
>935b	00					.byte	 0	; $0f !!15
>935c	00					.byte	 0	; $10 @
>935d	00					.byte	 0	; $11 !!17
>935e	00					.byte	 0	; $12 !!18
>935f	00					.byte	 0	; $13 [
>9360	04					.byte	 4	; $14 \
>9361	00					.byte	 0	; $15 ]
>9362	01					.byte	 1	; $16 ^
>9363	00					.byte	 0	; $17 _
>9364	00					.byte	 0	; $18 `
>9365	00					.byte	 0	; $19 !!25
>9366	00					.byte	 0	; $1a !!26
>9367	00					.byte	 0	; $1b {
>9368	01					.byte	 1	; $1c |
>9369	00					.byte	 0	; $1d }
>936a	00					.byte	 0	; $1e ~
>936b	00					.byte	 0	; $1f [7m<7F>[m
>936c	00					.byte	 0	; $20
>936d	05					.byte	 5	; $21 !
>936e	00					.byte	 0	; $22 "
>936f	00					.byte	 0	; $23 #
>9370	05					.byte	 5	; $24 $
>9371	04					.byte	 4	; $25 %
>9372	01					.byte	 1	; $26 &
>9373	00					.byte	 0	; $27 '
>9374	00					.byte	 0	; $28 (
>9375	00					.byte	 0	; $29 )
>9376	04					.byte	 4	; $2a *
>9377	03					.byte	 3	; $2b +
>9378	00					.byte	 0	; $2c ,
>9379	03					.byte	 3	; $2d -
>937a	00					.byte	 0	; $2e .
>937b	04					.byte	 4	; $2f /
>937c	00					.byte	 0	; $30 0
>937d	00					.byte	 0	; $31 1
>937e	00					.byte	 0	; $32 2
>937f	00					.byte	 0	; $33 3
>9380	00					.byte	 0	; $34 4
>9381	00					.byte	 0	; $35 5
>9382	00					.byte	 0	; $36 6
>9383	00					.byte	 0	; $37 7
>9384	00					.byte	 0	; $38 8
>9385	00					.byte	 0	; $39 9
>9386	00					.byte	 0	; $3a :
>9387	00					.byte	 0	; $3b ;
>9388	02					.byte	 2	; $3c <
>9389	02					.byte	 2	; $3d =
>938a	02					.byte	 2	; $3e >
>938b	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.938c					EvaluateExpressionAt0:
.938c	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.938e					EvaluateExpression:
.938e	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9390					EvaluateExpressionAtPrecedence:
.9390	48		pha				pha 								; save precedence level
.9391	20 d8 97	jsr $97d8			jsr 	EvaluateTerm 				; evaluate term into level X.
.9394	68		pla				pla 								; restore precedence level.
.9395					_EXPRLoop:
.9395	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9397	b1 30		lda ($30),y			lda 	(codePtr),y
.9399	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.939b	b0 25		bcs $93c2			bcs 	_EXPRExit
.939d	da		phx				phx 								; read the operator precedence
.939e	aa		tax				tax
.939f	bd 4c 93	lda $934c,x			lda 	PrecedenceLevel,x
.93a2	fa		plx				plx
.93a3	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.93a5	f0 1b		beq $93c2			beq 	_EXPRExit
.93a7	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93a9	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93ab	c5 37		cmp $37				cmp 	zTemp0+1
.93ad	b0 13		bcs $93c2			bcs		_EXPRExit 					; if current >= operator exit
.93af	48		pha				pha 								; save current precedence.
.93b0	b1 30		lda ($30),y			lda 	(codePtr),y
.93b2	c8		iny				iny
.93b3	48		pha				pha
.93b4	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93b6	e8		inx				inx 								; work out the right hand side.
.93b7	20 90 93	jsr $9390			jsr 	EvaluateExpressionAtPrecedence
.93ba	ca		dex				dex
.93bb	68		pla				pla 								; get operator, call the code.
.93bc	20 c5 93	jsr $93c5			jsr 	_EXPRCaller
.93bf	68		pla				pla 								; restore precedence level
.93c0	80 d3		bra $9395			bra 	_EXPRLoop 					; and go round.
.93c2					_EXPRExit:
.93c2	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93c4	60		rts				rts
.93c5					_EXPRCaller:
.93c5	da		phx				phx 								; save on stack, first thing is to restore it
.93c6	0a		asl a				asl 	a 							; double so can use vectors into X
.93c7	aa		tax				tax
.93c8	7c 4c 8b	jmp ($8b4c,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.93cb					FloatingPointAdd:
.93cb	20 41 95	jsr $9541			jsr 	FloatPrepare 				; prepare for floats
.93ce	80 09		bra $93d9			bra 	FloatAdd
.93d0					FloatingPointSub:
.93d0	20 41 95	jsr $9541			jsr 	FloatPrepare 				; prepare for floats
.93d3					FloatSubtract:
.93d3	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.93d5	49 80		eor #$80			eor 	#$80
.93d7	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.93d9					FloatAdd:
.93d9	48		pha				pha
.93da	5a		phy				phy
.93db	20 50 95	jsr $9550			jsr 	NSNormalise 				; normalise S[X]
.93de	f0 51		beq $9431			beq 	_FAReturn1
.93e0	e8		inx				inx 								; normalise S[X+1]
.93e1	20 50 95	jsr $9550			jsr 	NSNormalise
.93e4	ca		dex				dex
.93e5	c9 00		cmp #$00			cmp 	#0
.93e7	f0 60		beq $9449			beq 	_FAExit 					; if so, just return A
.93e9	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.93eb	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.93ed	f0 18		beq $9407			beq 	_FAExponentsEqual
.93ef	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.93f1	a8		tay				tay
.93f2	38		sec				sec 								; do a signed comparison of the exponents.
.93f3	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.93f5	50 02		bvc $93f9			bvc 	_FANoSignedChange
.93f7	49 80		eor #$80			eor 	#$80
.93f9					_FANoSignedChange:
.93f9	29 80		and #$80			and 	#$80
.93fb	10 02		bpl $93ff			bpl 	_FAHaveMax
.93fd	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.93ff					_FAHaveMax:
.93ff	20 4c 94	jsr $944c			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9402	e8		inx				inx
.9403	20 4c 94	jsr $944c			jsr 	_FAShiftToExponent
.9406	ca		dex				dex
.9407					_FAExponentsEqual:
.9407	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9409	55 51		eor $51,x			eor 	NSStatus+1,x
.940b	30 0e		bmi $941b			bmi 	_FADifferentSigns
.940d	20 84 91	jsr $9184			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9410	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9412	10 35		bpl $9449			bpl 	_FAExit 					; if no, we are done.
.9414	20 b0 9d	jsr $9db0			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9417	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.9419	80 2e		bra $9449			bra 	_FAExit
.941b					_FADifferentSigns:
.941b	20 9e 91	jsr $919e			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.941e	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.9420	10 06		bpl $9428			bpl 	_FACheckZero 				; if no, check for -0
.9422	20 59 9d	jsr $9d59			jsr 	NSMNegate 					; netate result
.9425	20 60 9d	jsr $9d60			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9428					_FACheckZero:
.9428	20 b9 9d	jsr $9db9			jsr 	NSMIsZero	 				; check for -0
.942b	d0 1c		bne $9449			bne 	_FAExit
.942d	74 50		stz $50,x			stz 	NSStatus,x
.942f	80 18		bra $9449			bra 	_FAExit
.9431					_FAReturn1:
.9431	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.9433	95 58		sta $58,x			sta 	NSMantissa0,x
.9435	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9437	95 60		sta $60,x			sta 	NSMantissa1,x
.9439	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.943b	95 68		sta $68,x			sta 	NSMantissa2,x
.943d	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.943f	95 70		sta $70,x			sta 	NSMantissa3,x
.9441	b5 79		lda $79,x			lda 	NSExponent+1,x
.9443	95 78		sta $78,x			sta 	NSExponent,x
.9445	b5 51		lda $51,x			lda 	NSStatus+1,x
.9447	95 50		sta $50,x			sta 	NSStatus,x
.9449					_FAExit:
.9449	7a		ply				ply
.944a	68		pla				pla
.944b	60		rts				rts
.944c					_FAShiftToExponent:
.944c					_FAShiftToExponent2:
.944c	98		tya				tya 								; compare Y to exponent
.944d	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.944f	f0 07		beq $9458			beq 	_FASEExit 					; exit if so.
.9451	20 b0 9d	jsr $9db0			jsr 	NSMShiftRight	 			; shift the mantissa right
.9454	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.9456	80 f4		bra $944c			bra 	_FAShiftToExponent2
.9458					_FASEExit:
.9458	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9459					CompareFloat:
.9459	20 d3 93	jsr $93d3			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.945c	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.945e	29 f8		and #$f8			and 	#$F8
.9460	15 68		ora $68,x			ora 	NSMantissa2,x
.9462	15 70		ora $70,x			ora 	NSMantissa3,x
.9464	f0 08		beq $946e			beq 	_FCExit 					; zero, so approximately identical
.9466	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9468	34 50		bit $50,x			bit 	NSStatus,x
.946a	10 02		bpl $946e			bpl 	_FCExit
.946c					_FCNegative:
.946c	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.946e					_FCExit:
.946e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.946f					FDivideCommand:
.946f	fa		plx				plx	 								; restore stack position
.9470	20 41 95	jsr $9541			jsr 	FloatPrepare 				; prepare for floats
.9473					FloatDivide:
.9473	48		pha				pha
.9474	e8		inx				inx
.9475	20 50 95	jsr $9550			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9478	ca		dex				dex
.9479	c9 00		cmp #$00			cmp 	#0
.947b	f0 1d		beq $949a			beq 	_FDZero
.947d	20 50 95	jsr $9550			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9480	f0 16		beq $9498			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9482	20 75 90	jsr $9075			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.9485	20 11 90	jsr $9011			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9488	20 50 95	jsr $9550			jsr		NSNormalise 				; renormalise
.948b	20 05 91	jsr $9105			jsr 	CalculateSign 				; calculate result sign
.948e	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.9490	38		sec				sec
.9491	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9493	38		sec				sec
.9494	e9 1e		sbc #$1e			sbc 	#30
.9496	95 78		sta $78,x			sta 	NSExponent,x
.9498					_FDExit:
.9498	68		pla				pla
.9499	60		rts				rts
.949a					_FDZero:
.949a	a9 03		lda #$03		lda	#3
.949c	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.949f					FloatFractionalPart:
.949f	5a		phy				phy
.94a0	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.94a2	29 7f		and #$7f			and 	#$7F
.94a4	95 50		sta $50,x			sta 	NSStatus,x
.94a6	20 50 95	jsr $9550			jsr 	NSNormalise
.94a9	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.94ab	38		sec				sec
.94ac	e9 e0		sbc #$e0			sbc 	#$E0
.94ae	90 29		bcc $94d9			bcc 	_FFPExit 					; already fractional
.94b0	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.94b2	b0 22		bcs $94d6			bcs 	_FFPZero
.94b4	a8		tay				tay 								; put count to do in Y
.94b5	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.94b7	20 db 94	jsr $94db			jsr 	_FFPPartial
.94ba	95 70		sta $70,x			sta 	NSMantissa3,x
.94bc	b5 68		lda $68,x			lda 	NSMantissa2,x
.94be	20 db 94	jsr $94db			jsr 	_FFPPartial
.94c1	95 68		sta $68,x			sta 	NSMantissa2,x
.94c3	b5 60		lda $60,x			lda 	NSMantissa1,x
.94c5	20 db 94	jsr $94db			jsr 	_FFPPartial
.94c8	95 60		sta $60,x			sta 	NSMantissa1,x
.94ca	b5 58		lda $58,x			lda 	NSMantissa0,x
.94cc	20 db 94	jsr $94db			jsr 	_FFPPartial
.94cf	95 58		sta $58,x			sta 	NSMantissa0,x
.94d1	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; zeroed check.
.94d4	d0 03		bne $94d9			bne 	_FFPExit
.94d6					_FFPZero:
.94d6	20 97 9d	jsr $9d97			jsr 	NSMSetZero
.94d9					_FFPExit:
.94d9	7a		ply				ply
.94da	60		rts				rts
.94db					_FFPPartial:
.94db	c0 00		cpy #$00			cpy 	#0 							; no more to do
.94dd	f0 17		beq $94f6			beq 	_FFFPPExit
.94df	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.94e1	b0 0c		bcs $94ef			bcs 	_FFFPPWholeByte
.94e3	5a		phy				phy
.94e4					_FFFPPLeft:
.94e4	0a		asl a				asl 	a
.94e5	88		dey				dey
.94e6	d0 fc		bne $94e4			bne 	_FFFPPLeft
.94e8	7a		ply				ply
.94e9					_FFFPPRight:
.94e9	4a		lsr a				lsr 	a
.94ea	88		dey				dey
.94eb	d0 fc		bne $94e9			bne 	_FFFPPRight
.94ed	80 07		bra $94f6			bra 	_FFFPPExit
.94ef					_FFFPPWholeByte:
.94ef	98		tya				tya 								; subtract 8 from count
.94f0	38		sec				sec
.94f1	e9 08		sbc #$08			sbc 	#8
.94f3	a8		tay				tay
.94f4	a9 00		lda #$00			lda 	#0 							; and clear all
.94f6					_FFFPPExit:
.94f6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.94f7					FloatIntegerPart:
.94f7	48		pha				pha
.94f8	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.94fa	f0 1d		beq $9519			beq 	_FIPExit 					; if so do nothing
.94fc	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; is it zero ?
.94ff	f0 15		beq $9516			beq 	_FIPZero 					; if so return zero.
.9501	20 50 95	jsr $9550			jsr 	NSNormalise 				; normalise
.9504	f0 10		beq $9516			beq 	_FIPZero 					; normalised to zero, exit zero
.9506					_FIPShift:
.9506	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9508	10 07		bpl $9511			bpl 	_FIPCheckZero
.950a	20 b0 9d	jsr $9db0			jsr 	NSMShiftRight 				; shift mantissa right
.950d	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.950f	80 f5		bra $9506			bra 	_FIPShift
.9511					_FIPCheckZero:
.9511	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; avoid -0 problem
.9514	d0 03		bne $9519			bne 	_FIPExit 					; set to zero if mantissa zero.
.9516					_FIPZero:
.9516	20 97 9d	jsr $9d97			jsr 	NSMSetZero
.9519					_FIPExit:
.9519	68		pla				pla
.951a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.951b					FloatingPointMultiply:
.951b	20 41 95	jsr $9541			jsr 	FloatPrepare 				; prepare for floats
.951e					FloatMultiply:
.951e	48		pha				pha
.951f	20 50 95	jsr $9550			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9522	f0 18		beq $953c			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.9524	e8		inx				inx
.9525	20 50 95	jsr $9550			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9528	ca		dex				dex
.9529	c9 00		cmp #$00			cmp 	#0
.952b	f0 0c		beq $9539			beq 	_FDSetZero
.952d	20 c7 90	jsr $90c7			jsr 	MultiplyShort 				; calculate the result.
.9530	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9532	18		clc				clc
.9533	75 79		adc $79,x			adc 	NSExponent+1,x
.9535	95 78		sta $78,x			sta 	NSExponent,x
.9537	80 03		bra $953c			bra 	_FDExit
.9539					_FDSetZero:
.9539	20 97 9d	jsr $9d97			jsr 	NSMSetZero 					; return 0
.953c					_FDExit:
.953c	20 50 95	jsr $9550			jsr 	NSNormalise 				; normalise the result
.953f	68		pla				pla
.9540	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9541					FloatPrepare:
.9541	20 4c 96	jsr $964c			jsr 	DereferenceTopTwo 			; dereference the top two values
.9544	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.9546	15 51		ora $51,x			ora 	NSStatus+1,x
.9548	29 10		and #$10			and 	#NSBIsString
.954a	d0 01		bne $954d			bne 	_FDType
.954c	60		rts				rts
.954d					_FDType:
.954d	4c 1f 9f	jmp $9f1f			jmp 	TypeError
.9550					NSNormalise:
.9550	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.9552	29 80		and #$80			and 	#$80
.9554	09 08		ora #$08			ora 	#NSTFloat
.9556	95 50		sta $50,x			sta 	NSStatus,x
.9558	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; if zero exit
.955b	d0 07		bne $9564			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.955d	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.955f	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.9561	a9 00		lda #$00			lda 	#0 							; set Z flag
.9563	60		rts				rts
.9564					_NSNormaliseOptimise:
.9564	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.9566	d0 19		bne $9581			bne 	_NSNormaliseLoop
.9568	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.956a	30 15		bmi $9581			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.956c	95 70		sta $70,x			sta 	NSMantissa3,x
.956e	b5 60		lda $60,x			lda 	NSMantissa1,x
.9570	95 68		sta $68,x			sta 	NSMantissa2,x
.9572	b5 58		lda $58,x			lda 	NSMantissa0,x
.9574	95 60		sta $60,x			sta 	NSMantissa1,x
.9576	74 58		stz $58,x			stz 	NSMantissa0,x
.9578	b5 78		lda $78,x			lda 	NSExponent,x
.957a	38		sec				sec
.957b	e9 08		sbc #$08			sbc 	#8
.957d	95 78		sta $78,x			sta 	NSExponent,x
.957f	80 e3		bra $9564			bra 	_NSNormaliseOptimise
.9581					_NSNormaliseLoop:
.9581	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9583	70 07		bvs $958c			bvs 	_NSNExit 					; exit if so with Z flag clear
.9585	20 a6 9d	jsr $9da6			jsr 	NSMShiftLeft 				; shift mantissa left
.9588	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.958a	80 f5		bra $9581			bra 	_NSNormaliseLoop
.958c					_NSNExit:
.958c	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.958e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.958f					AssignNumber:
.958f	5a		phy				phy
.9590	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9592	85 36		sta $36				sta 	zTemp0
.9594	b5 60		lda $60,x			lda 	NSMantissa1,x
.9596	85 37		sta $37				sta 	zTemp0+1
.9598	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.959a	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.959c	95 50		sta $50,x			sta 	NSStatus,x
.959e	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.95a0	c9 08		cmp #$08			cmp 	#NSTFloat
.95a2	f0 24		beq $95c8			beq 	_ANFloat
.95a4	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.95a6	f0 03		beq $95ab			beq		_ANNotFloat
.95a8	4c 1a 9f	jmp $9f1a			jmp 	RangeError					; if it is, report an error.
.95ab					_ANNotFloat:
.95ab	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.95ad	29 03		and #$03			and 	#3
.95af	d0 05		bne $95b6			bne 	_ANByteWord
.95b1	20 d3 95	jsr $95d3			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.95b4	80 1b		bra $95d1			bra 	_ANExit
.95b6					_ANByteWord:
.95b6	48		pha				pha 								; save count
.95b7	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.95b9	92 36		sta ($36)			sta 	(zTemp0)
.95bb	68		pla				pla
.95bc	c9 01		cmp #$01			cmp	 	#1
.95be	f0 11		beq $95d1			beq 	_ANExit
.95c0	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.95c2	a0 01		ldy #$01			ldy 	#1
.95c4	91 36		sta ($36),y			sta 	(zTemp0),y
.95c6	80 09		bra $95d1			bra 	_ANExit
.95c8					_ANFloat:
.95c8	20 d3 95	jsr $95d3			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.95cb	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.95cd	a0 04		ldy #$04			ldy 	#4
.95cf	91 36		sta ($36),y			sta 	(zTemp0),y
.95d1					_ANExit:
.95d1	7a		ply				ply
.95d2	60		rts				rts
.95d3					_ANCopy4PackSign:
.95d3	a0 03		ldy #$03			ldy 	#3
.95d5	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.95d7	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.95d9	15 71		ora $71,x			ora 	NSMantissa3+1,x
.95db	91 36		sta ($36),y			sta 	(zTemp0),y
.95dd	88		dey				dey
.95de	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.95e0	91 36		sta ($36),y			sta 	(zTemp0),y
.95e2	88		dey				dey
.95e3	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.95e5	91 36		sta ($36),y			sta 	(zTemp0),y
.95e7	88		dey				dey
.95e8	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.95ea	91 36		sta ($36),y			sta 	(zTemp0),y
.95ec	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95ed					AssignString:
.95ed	5a		phy				phy
.95ee	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.95f0	85 38		sta $38				sta 	zTemp1
.95f2	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.95f4	85 39		sta $39				sta 	zTemp1+1
.95f6	b5 58		lda $58,x			lda 	NSMantissa0,x
.95f8	85 36		sta $36				sta 	zTemp0
.95fa	b5 60		lda $60,x			lda 	NSMantissa1,x
.95fc	85 37		sta $37				sta 	zTemp0+1
.95fe	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9600	b1 36		lda ($36),y			lda 	(zTemp0),y
.9602	f0 23		beq $9627			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9604	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9605	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9607	e9 02		sbc #$02			sbc 	#2
.9609	85 3c		sta $3c				sta 	zsTemp
.960b	a0 01		ldy #$01			ldy 	#1
.960d	b1 36		lda ($36),y			lda 	(zTemp0),y
.960f	e9 00		sbc #$00			sbc 	#0
.9611	85 3d		sta $3d				sta 	zsTemp+1
.9613	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9615					_ASGetLength:
.9615	c8		iny				iny
.9616	b1 38		lda ($38),y			lda 	(zTemp1),y
.9618	d0 fb		bne $9615			bne 	_ASGetLength
.961a	98		tya				tya 								; is this length <= current length
.961b	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.961d	90 1e		bcc $963d			bcc 	_ASCopyString
.961f	f0 1c		beq $963d			beq 	_ASCopyString
.9621	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9623	a0 01		ldy #$01			ldy 	#1
.9625	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9627					_ASNewStringRequired:
.9627	e8		inx				inx 								; concrete the new string.
.9628	20 4c a6	jsr $a64c			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.962b	ca		dex				dex
.962c	18		clc				clc
.962d	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.962f	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9631	92 36		sta ($36)			sta 	(zTemp0)
.9633	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9635	69 00		adc #$00			adc 	#0
.9637	a0 01		ldy #$01			ldy 	#1
.9639	91 36		sta ($36),y			sta 	(zTemp0),y
.963b	80 0d		bra $964a			bra 	_ASExit
.963d					_ASCopyString:
.963d	a0 00		ldy #$00			ldy 	#0
.963f					_ASCopyLoop:
.963f	b1 38		lda ($38),y			lda 	(zTemp1),y
.9641	c8		iny				iny
.9642	c8		iny				iny
.9643	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9645	88		dey				dey
.9646	c9 00		cmp #$00			cmp 	#0
.9648	d0 f5		bne $963f			bne 	_ASCopyLoop
.964a					_ASExit:
.964a	7a		ply				ply
.964b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.964c					DereferenceTopTwo:
.964c	e8		inx				inx
.964d	20 51 96	jsr $9651			jsr 	Dereference 				; deref x+1
.9650	ca		dex				dex  								; falls through to deref x
.9651					Dereference:
.9651	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.9653	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.9655	f0 48		beq $969f			beq 	_DRFExit 					; not a reference, so exit.
.9657	5a		phy				phy
.9658	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.965a	85 36		sta $36				sta 	zTemp0
.965c	b5 60		lda $60,x			lda 	NSMantissa1,x
.965e	85 37		sta $37				sta 	zTemp0+1
.9660	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.9662	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.9664	95 58		sta $58,x			sta 	NSMantissa0,x
.9666	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.9668	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.966a	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.966c	f0 0e		beq $967c			beq 	_DRFDereferenceTwo
.966e	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9670	f0 2f		beq $96a1			beq 	_DRFFull
.9672	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9674	29 03		and #$03			and 	#3
.9676	f0 29		beq $96a1			beq 	_DRFFull 					; the whole word
.9678	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.967a	f0 06		beq $9682			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.967c					_DRFDereferenceTwo:
.967c	a0 01		ldy #$01			ldy 	#1
.967e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9680	95 60		sta $60,x			sta 	NSMantissa1,x
.9682					_DRFClear23:
.9682	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9684	74 70		stz $70,x			stz 	NSMantissa3,x
.9686	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.9688	29 18		and #$18			and 	#NSBTypeMask
.968a	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.968c	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.968e	d0 0e		bne $969e			bne 	_DRFNotString
.9690	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9692	15 60		ora $60,x			ora 	NSMantissa1,x
.9694	d0 08		bne $969e			bne 	_DRFNotString
.9696	a9 a0		lda #$a0			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9698	95 58		sta $58,x			sta 	NSMantissa0,X
.969a	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.969c	95 60		sta $60,x			sta 	NSMantissa1,X
.969e					_DRFNotString
.969e	7a		ply				ply 								; restore Y and exit
.969f					_DRFExit:
.969f	60		rts				rts
.96a0					_DRFNullString:
>96a0	00						.byte 	0
.96a1					_DRFFull:
.96a1	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.96a3	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a5	95 60		sta $60,x			sta 	NSMantissa1,x
.96a7	c8		iny				iny
.96a8	b1 36		lda ($36),y			lda 	(zTemp0),y
.96aa	95 68		sta $68,x			sta 	NSMantissa2,x
.96ac	c8		iny				iny
.96ad	b1 36		lda ($36),y			lda 	(zTemp0),y
.96af	95 70		sta $70,x			sta 	NSMantissa3,x
.96b1	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.96b3	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.96b5	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96b7	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.96b9	f0 05		beq $96c0			beq 	_DRFNoExponent
.96bb	c8		iny				iny 								; if not, read the exponent as well.
.96bc	b1 36		lda ($36),y			lda 	(zTemp0),y
.96be	95 78		sta $78,x			sta 	NSExponent,x
.96c0					_DRFNoExponent:
.96c0	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96c2	10 0a		bpl $96ce			bpl 	_DRFExit2 					; if not, then exit.
.96c4	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96c6	95 70		sta $70,x			sta 	NSMantissa3,x
.96c8	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.96ca	09 80		ora #$80			ora 	#NSBIsNegative
.96cc	95 50		sta $50,x			sta 	NSStatus,x
.96ce					_DRFExit2:
.96ce	7a		ply				ply
.96cf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.96d0					EncodeNumberStart:
.96d0	38		sec				sec
.96d1	80 01		bra $96d4			bra 	EncodeNumberContinue+1
.96d3					EncodeNumberContinue:
.96d3	18		clc				clc
.96d4					EncodeNumber:
.96d4	08		php				php 								; save reset flag.
.96d5	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.96d7	f0 12		beq $96eb			beq 	_ENIsOkay
.96d9	c9 30		cmp #$30			cmp 	#"0"
.96db	90 04		bcc $96e1			bcc 	_ENBadNumber
.96dd	c9 3a		cmp #$3a			cmp 	#"9"+1
.96df	90 0a		bcc $96eb			bcc 	_ENIsOkay
.96e1					_ENBadNumber:
.96e1	28		plp				plp 								; throw saved reset
.96e2	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.96e5	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96e7	f0 7b		beq $9764			beq 	_ENConstructFinal
.96e9					_ENFail:
.96e9	18		clc				clc 								; not allowed
.96ea	60		rts				rts
.96eb					_ENIsOkay:
.96eb	28		plp				plp 								; are we restarting
.96ec	90 15		bcc $9703			bcc 	_ENNoRestart
.96ee					_ENStartEncode:
.96ee	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.96f0	f0 0c		beq $96fe			beq 	_ENFirstDP
.96f2	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.96f4	20 99 9d	jsr $9d99			jsr 	NSMSetByte 					; in single byte mode.
.96f7	a9 01		lda #$01			lda 	#ESTA_Low
.96f9					_ENExitChange:
.96f9	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.96fc	38		sec				sec
.96fd	60		rts				rts
.96fe					_ENFirstDP:
.96fe	20 97 9d	jsr $9d97			jsr 	NSMSetZero 					; clear integer part
.9701	80 3c		bra $973f			bra 	_ESTASwitchFloat			; go straight to float and exi
.9703					_ENNoRestart:
.9703	48		pha				pha 								; save digit or DP on stack.
.9704	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.9707	c9 01		cmp #$01			cmp 	#ESTA_Low
.9709	f0 09		beq $9714			beq  	_ESTALowState
.970b	c9 02		cmp #$02			cmp 	#ESTA_High
.970d	f0 26		beq $9735			beq 	_ESTAHighState
.970f	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9711	f0 38		beq $974b			beq 	_ESTADecimalState
>9713	db						.byte 	$DB 						; causes a break in the emulator
.9714					_ESTALowState:
.9714	68		pla				pla 								; get value back
.9715	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9717	f0 26		beq $973f			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9719	29 0f		and #$0f			and 	#15 						; make digit
.971b	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.971e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9720	0a		asl a				asl 	a
.9721	0a		asl a				asl 	a
.9722	75 58		adc $58,x			adc 	NSMantissa0,x
.9724	0a		asl a				asl 	a
.9725	6d 06 04	adc $0406			adc 	DigitTemp
.9728	95 58		sta $58,x			sta 	NSMantissa0,x
.972a	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.972c	90 05		bcc $9733			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.972e	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.9730	8d 05 04	sta $0405			sta 	EncodeState
.9733					_ESTANoSwitch:
.9733	38		sec				sec
.9734	60		rts				rts
.9735					_ESTAHighState:
.9735	68		pla				pla 								; get value back
.9736	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.9738	f0 05		beq $973f			beq 	_ESTASwitchFloat
.973a	20 98 97	jsr $9798			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.973d	38		sec				sec
.973e	60		rts				rts
.973f					_ESTASwitchFloat:
.973f	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.9742	e8		inx				inx 								; zero the decimal additive.
.9743	20 97 9d	jsr $9d97			jsr 	NSMSetZero
.9746	ca		dex				dex
.9747	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9749	80 ae		bra $96f9			bra 	_ENExitChange
.974b					_ESTADecimalState:
.974b	68		pla				pla 								; digit.
.974c	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.974e	f0 99		beq $96e9			beq 	_ENFail
.9750	e8		inx				inx 								; put digit into fractional part of X+1
.9751	20 98 97	jsr $9798			jsr 	ESTAShiftDigitIntoMantissa
.9754	ca		dex				dex
.9755	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.9758	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.975b	c9 0b		cmp #$0b			cmp 	#11
.975d	f0 02		beq $9761			beq 	_ESTADSFail
.975f	38		sec				sec
.9760	60		rts				rts
.9761					_ESTADSFail:
.9761	4c 1a 9f	jmp $9f1a			jmp 	RangeError
.9764					_ENConstructFinal:
.9764	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.9767	f0 2d		beq $9796			beq 	_ENCFExit 					; no decimals
.9769	5a		phy				phy
.976a	0a		asl a				asl 	a 							; x 4 and CLC
.976b	0a		asl a				asl 	a
.976c	6d 07 04	adc $0407			adc 	DecimalCount
.976f	a8		tay				tay
.9770	b9 d9 9e	lda $9ed9,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9773	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.9775	b9 da 9e	lda $9eda,y			lda 	DecimalScalarTable-5+1,y
.9778	95 62		sta $62,x			sta 	NSMantissa1+2,x
.977a	b9 db 9e	lda $9edb,y			lda 	DecimalScalarTable-5+2,y
.977d	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.977f	b9 dc 9e	lda $9edc,y			lda 	DecimalScalarTable-5+3,y
.9782	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9784	b9 dd 9e	lda $9edd,y			lda 	DecimalScalarTable-5+4,y
.9787	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9789	a9 08		lda #$08			lda 	#NSTFloat
.978b	95 52		sta $52,x			sta 	NSStatus+2,x
.978d	7a		ply				ply
.978e	e8		inx				inx 								; multiply decimal const by decimal scalar
.978f	20 1e 95	jsr $951e			jsr 	FloatMultiply
.9792	ca		dex				dex
.9793	20 d9 93	jsr $93d9			jsr 	FloatAdd 					; add to integer part.
.9796					_ENCFExit:
.9796	18		clc				clc 								; reject the digit.
.9797	60		rts				rts
.9798					ESTAShiftDigitIntoMantissa:
.9798	29 0f		and #$0f			and 	#15 						; save digit
.979a	48		pha				pha
.979b	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.979d	48		pha				pha
.979e	b5 68		lda $68,x			lda 	NSMantissa2,x
.97a0	48		pha				pha
.97a1	b5 60		lda $60,x			lda 	NSMantissa1,x
.97a3	48		pha				pha
.97a4	b5 58		lda $58,x			lda 	NSMantissa0,x
.97a6	48		pha				pha
.97a7	20 a6 9d	jsr $9da6			jsr 	NSMShiftLeft 				; x 2
.97aa	20 a6 9d	jsr $9da6			jsr 	NSMShiftLeft 				; x 4
.97ad	18		clc				clc 								; pop mantissa and add
.97ae	68		pla				pla
.97af	75 58		adc $58,x			adc 	NSMantissa0,x
.97b1	95 58		sta $58,x			sta 	NSMantissa0,x
.97b3	68		pla				pla
.97b4	75 60		adc $60,x			adc 	NSMantissa1,x
.97b6	95 60		sta $60,x			sta 	NSMantissa1,x
.97b8	68		pla				pla
.97b9	75 68		adc $68,x			adc 	NSMantissa2,x
.97bb	95 68		sta $68,x			sta 	NSMantissa2,x
.97bd	68		pla				pla
.97be	75 70		adc $70,x			adc 	NSMantissa3,x
.97c0	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.97c2	20 a6 9d	jsr $9da6			jsr 	NSMShiftLeft 				; x 10
.97c5	68		pla				pla 								; add digit
.97c6	18		clc				clc
.97c7	75 58		adc $58,x			adc 	NSMantissa0,x
.97c9	95 58		sta $58,x			sta 	NSMantissa0,x
.97cb	90 0a		bcc $97d7			bcc 	_ESTASDExit
.97cd	f6 60		inc $60,x			inc 	NSMantissa1,x
.97cf	d0 06		bne $97d7			bne 	_ESTASDExit
.97d1	f6 68		inc $68,x			inc 	NSMantissa2,x
.97d3	d0 02		bne $97d7			bne 	_ESTASDExit
.97d5	f6 70		inc $70,x			inc 	NSMantissa3,x
.97d7					_ESTASDExit:
.97d7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.97d8					EvaluateTerm:
.97d8	b1 30		lda ($30),y			lda 	(codePtr),y
.97da	30 18		bmi $97f4			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.97dc	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.97de	b0 6c		bcs $984c			bcs 	_ETVariable
.97e0	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.97e2	90 6b		bcc $984f			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.97e4	c9 3a		cmp #$3a			cmp 	#'9'+1
.97e6	b0 67		bcs $984f			bcs 	_ETPuncUnary
.97e8	20 d0 96	jsr $96d0			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.97eb					_ETNumber:
.97eb	c8		iny				iny 								; keep encoding until we have the numbers
.97ec	b1 30		lda ($30),y			lda 	(codePtr),y
.97ee	20 d3 96	jsr $96d3			jsr 	EncodeNumberContinue
.97f1	b0 f8		bcs $97eb			bcs 	_ETNumber 					; go back if accepted.
.97f3	60		rts				rts
.97f4					_ETCheckUnary:
.97f4	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.97f6	f0 3f		beq $9837			beq 	_ETString
.97f8	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.97fa	f0 12		beq $980e			beq 	_ETHexConstant
.97fc	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.97fe	90 0b		bcc $980b			bcc 	_ETSyntaxError
.9800	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.9802	b0 07		bcs $980b			bcs 	_ETSyntaxError
.9804	da		phx				phx 								; push X on the stack
.9805	0a		asl a				asl 	a 							; put vector x 2 into X
.9806	aa		tax				tax
.9807	c8		iny				iny 								; consume unary function token
.9808	7c cc 8b	jmp ($8bcc,x)			jmp 	(VectorSet0,x) 				; and do it.
.980b					_ETSyntaxError:
.980b	4c 15 9f	jmp $9f15			jmp 	SyntaxError
.980e					_ETHexConstant:
.980e	c8		iny				iny 								; skip #
.980f	c8		iny				iny 								; skip count
.9810	20 97 9d	jsr $9d97			jsr 	NSMSetZero 					; clear result
.9813					_ETHLoop:
.9813	b1 30		lda ($30),y			lda 	(codePtr),y
.9815	c8		iny				iny 								; and consume
.9816	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9818	f0 1c		beq $9836			beq 	_ETHExit
.981a	48		pha				pha 								; save on stack.
.981b	20 a6 9d	jsr $9da6			jsr 	NSMShiftLeft 				; x 2
.981e	20 a6 9d	jsr $9da6			jsr 	NSMShiftLeft 				; x 4
.9821	20 a6 9d	jsr $9da6			jsr 	NSMShiftLeft 				; x 8
.9824	20 a6 9d	jsr $9da6			jsr 	NSMShiftLeft 				; x 16
.9827	68		pla				pla 								; ASCII
.9828	c9 41		cmp #$41			cmp 	#'A'
.982a	90 02		bcc $982e			bcc 	_ETHNotChar
.982c	e9 07		sbc #$07			sbc 	#7
.982e					_ETHNotChar:
.982e	29 0f		and #$0f			and 	#15 						; digit now
.9830	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.9832	95 58		sta $58,x			sta 	NSMantissa0,x
.9834	80 dd		bra $9813			bra 	_ETHLoop 					; go round.
.9836					_ETHExit:
.9836	60		rts				rts
.9837					_ETString:
.9837	c8		iny				iny 								; look at length
.9838	b1 30		lda ($30),y			lda 	(codePtr),y
.983a	48		pha				pha
.983b	c8		iny				iny 								; first character
.983c	20 f2 a4	jsr $a4f2			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.983f	68		pla				pla 								; restore count and save
.9840	85 36		sta $36				sta 	zTemp0
.9842	98		tya				tya 								; add length to Y to skip it.
.9843	18		clc				clc
.9844	65 36		adc $36				adc 	zTemp0
.9846	a8		tay				tay
.9847	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9849	95 50		sta $50,x			sta 	NSStatus,x
.984b	60		rts				rts
.984c					_ETVariable:
.984c	4c a1 98	jmp $98a1			jmp 	VariableHandler
.984f					_ETPuncUnary:
.984f	c8		iny				iny 								; consume the unary character
.9850	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9852	f0 2b		beq $987f			beq 	_ETUnaryNegate
.9854	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9856	f0 36		beq $988e			beq 	_ETDereference
.9858	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.985a	f0 3e		beq $989a			beq 	_ETParenthesis
.985c	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.985e	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9860	f0 06		beq $9868			beq 	_ETIndirection
.9862	e6 36		inc $36				inc 	zTemp0
.9864	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9866	d0 a3		bne $980b			bne 	_ETSyntaxError
.9868					_ETIndirection:
.9868	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.986a	1a		inc a				inc 	a
.986b	48		pha				pha
.986c	20 d8 97	jsr $97d8			jsr 	EvaluateTerm				; evaluate the term
.986f	20 51 96	jsr $9651			jsr 	Dereference 				; dereference it.
.9872	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.9874	d0 06		bne $987c			bne 	_ETTypeMismatch
.9876	68		pla				pla 								; indirection 1-2
.9877	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9879	95 50		sta $50,x			sta 	NSStatus,x
.987b	60		rts				rts
.987c					_ETTypeMismatch:
.987c	4c 1f 9f	jmp $9f1f			jmp 	TypeError
.987f					_ETUnaryNegate:
.987f	20 d8 97	jsr $97d8			jsr 	EvaluateTerm				; evaluate the term
.9882	20 51 96	jsr $9651			jsr 	Dereference 				; dereference it.
.9885	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.9887	29 10		and #$10			and 	#NSTString
.9889	d0 f1		bne $987c			bne 	_ETTypeMismatch
.988b	4c 59 9d	jmp $9d59			jmp 	NSMNegate  					; just toggles the sign bit.
.988e					_ETDereference:
.988e	20 d8 97	jsr $97d8			jsr 	EvaluateTerm				; evaluate the term
.9891	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9893	29 20		and #$20			and 	#NSBIsReference
.9895	f0 e5		beq $987c			beq 	_ETTypeMismatch
.9897	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9899	60		rts				rts
.989a					_ETParenthesis:
.989a	20 8e 93	jsr $938e			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.989d	20 71 8e	jsr $8e71			jsr 	CheckRightBracket 			; check for )
.98a0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.98a1					VariableHandler:
.98a1	b1 30		lda ($30),y			lda 	(codePtr),y
.98a3	18		clc				clc
.98a4	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98a6	85 37		sta $37				sta 	zTemp0+1
.98a8	c8		iny				iny
.98a9	b1 30		lda ($30),y			lda 	(codePtr),y
.98ab	85 36		sta $36				sta 	zTemp0
.98ad	c8		iny				iny
.98ae	18		clc				clc									; copy variable address+3 to mantissa
.98af	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.98b1	95 58		sta $58,x			sta 	NSMantissa0,x
.98b3	a5 37		lda $37				lda 	zTemp0+1
.98b5	69 00		adc #$00			adc 	#0
.98b7	95 60		sta $60,x			sta 	NSMantissa1,x
.98b9	74 68		stz $68,x			stz 	NSMantissa2,x
.98bb	74 70		stz $70,x			stz 	NSMantissa3,x
.98bd	74 78		stz $78,x			stz 	NSExponent,x
.98bf	5a		phy				phy
.98c0	a0 02		ldy #$02			ldy 	#2 							; read type
.98c2	b1 36		lda ($36),y			lda 	(zTemp0),y
.98c4	7a		ply				ply
.98c5	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98c7	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98c9	95 50		sta $50,x			sta 	NSStatus,x
.98cb	29 04		and #$04			and 	#NSBIsArray
.98cd	d0 01		bne $98d0			bne 	_VHArray
.98cf	60		rts				rts
.98d0					_VHArray:
.98d0	e8		inx				inx
.98d1	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; get the 1st index.
.98d4	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.98d6	95 51		sta $51,x			sta 	NSStatus+1,x
.98d8	b1 30		lda ($30),y			lda 	(codePtr),y
.98da	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.98dc	d0 06		bne $98e4			bne 	_VHNoSecondIndex
.98de	c8		iny				iny 								; skip the comma
.98df	e8		inx				inx
.98e0	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.98e3	ca		dex				dex
.98e4					_VHNoSecondIndex:
.98e4	ca		dex				dex 								; set X back.
.98e5	20 71 8e	jsr $8e71			jsr 	CheckRightBracket 			; and check the right bracket.
.98e8	5a		phy				phy 								; save position
.98e9	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.98eb	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98ed	f0 60		beq $994f			beq 	_VHBadIndex
.98ef	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.98f1	85 3e		sta $3e				sta 	zaTemp
.98f3	b5 60		lda $60,x			lda 	NSMantissa1,x
.98f5	85 3f		sta $3f				sta 	zaTemp+1
.98f7	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.98f9	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98fb	f0 02		beq $98ff			beq 	_VHHas2Mask
.98fd	a9 ff		lda #$ff			lda 	#$FF
.98ff					_VHHas2Mask:
.98ff	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9901	f0 4c		beq $994f			beq 	_VHBadIndex
.9903	0a		asl a				asl 	a 							; carry will be set if a second index
.9904	90 08		bcc $990e			bcc 	_VHCheckFirstIndex
.9906	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9908	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.990a	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.990c	90 41		bcc $994f			bcc 	_VHBadIndex
.990e					_VHCheckFirstIndex:
.990e	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9910	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9912	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.9914	90 39		bcc $994f			bcc 	_VHBadIndex
.9916	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9918	64 37		stz $37				stz 	zTemp0+1
.991a	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.991c	30 0e		bmi $992c			bmi 	_VHNoMultiply
.991e	da		phx				phx
.991f	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9921	48		pha				pha
.9922	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9924	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9926	1a		inc a				inc 	a 							; add 1 for zero base
.9927	fa		plx				plx
.9928	20 42 9d	jsr $9d42			jsr 	Multiply8x8 				; calculate -> Z0
.992b	fa		plx				plx
.992c					_VHNoMultiply:
.992c	18		clc				clc
.992d	a5 36		lda $36				lda 	zTemp0
.992f	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9931	85 36		sta $36				sta 	zTemp0
.9933	a5 37		lda $37				lda 	zTemp0+1
.9935	69 00		adc #$00			adc 	#0
.9937	85 37		sta $37				sta 	zTemp0+1
.9939	b5 50		lda $50,x			lda 	NSStatus,x
.993b	20 df 84	jsr $84df			jsr 	ScaleByBaseType
.993e	18		clc				clc
.993f	b2 3e		lda ($3e)			lda 	(zaTemp)
.9941	65 36		adc $36				adc 	zTemp0
.9943	95 58		sta $58,x			sta 	NSMantissa0,x
.9945	a0 01		ldy #$01			ldy 	#1
.9947	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9949	65 37		adc $37				adc 	zTemp0+1
.994b	95 60		sta $60,x			sta 	NSMantissa1,x
.994d	7a		ply				ply 								; restore position
.994e	60		rts				rts
.994f					_VHBadIndex:
.994f	a9 17		lda #$17		lda	#23
.9951	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9954					AbsUnary:
.9954	fa		plx				plx 								; restore stack pos
.9955	20 e5 9c	jsr $9ce5			jsr 	EvaluateNumber 				; get a float or int
.9958	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.995b	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.995d	29 7f		and #$7f			and 	#$7F
.995f	95 50		sta $50,x			sta 	NSStatus,x
.9961	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9962					AllocUnary:
.9962	fa		plx				plx 								; restore stack pos
.9963	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger		; get bytes required.
.9966	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.9969	da		phx				phx 								; save X/Y
.996a	5a		phy				phy
.996b	8a		txa				txa 								; copy X into Y
.996c	a8		tay				tay
.996d	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.9970	aa		tax				tax
.9971	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.9974	20 81 99	jsr $9981			jsr 	AllocateXABytes 			; allocate memory
.9977	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.997a	8a		txa				txa 	 							; typing is 16 bit integer.
.997b	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.997e	7a		ply				ply
.997f	fa		plx				plx
.9980	60		rts				rts
.9981					AllocateXABytes:
.9981	5a		phy				phy
.9982	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9985	84 36		sty $36				sty 	zTemp0
.9987	5a		phy				phy
.9988	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.998b	84 37		sty $37				sty 	zTemp0+1
.998d	5a		phy				phy
.998e	18		clc				clc 								; add to low memory pointer
.998f	6d 0c 04	adc $040c			adc 	lowMemPtr
.9992	8d 0c 04	sta $040c			sta 	lowMemPtr
.9995	8a		txa				txa
.9996	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9999	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.999c	b0 2f		bcs $99cd			bcs 	CISSMemory
.999e	20 bf 99	jsr $99bf			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.99a1					_ClearMemory:
.99a1	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.99a4	c5 36		cmp $36				cmp 	zTemp0
.99a6	d0 07		bne $99af			bne 	_CMClearNext
.99a8	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.99ab	c5 37		cmp $37				cmp 	zTemp0+1
.99ad	f0 0c		beq $99bb			beq 	_CMExit
.99af					_CMClearNext:
.99af	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99b1	92 36		sta ($36)			sta 	(zTemp0)
.99b3	e6 36		inc $36				inc 	zTemp0
.99b5	d0 ea		bne $99a1			bne 	_ClearMemory
.99b7	e6 37		inc $37				inc		zTemp0+1
.99b9	80 e6		bra $99a1			bra 	_ClearMemory
.99bb					_CMExit:
.99bb	fa		plx				plx
.99bc	68		pla				pla
.99bd	7a		ply				ply
.99be	60		rts				rts
.99bf					CheckIdentifierStringSpace:
.99bf	48		pha				pha
.99c0	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.99c3	18		clc				clc
.99c4	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99c6	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.99c9	b0 02		bcs $99cd			bcs 	CISSMemory
.99cb	68		pla				pla
.99cc	60		rts				rts
.99cd					CISSMemory:
.99cd	a9 06		lda #$06		lda	#6
.99cf	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.99d2					AscUnary:
.99d2	fa		plx				plx 								; restore stack pos
.99d3	20 ef 9c	jsr $9cef			jsr 	EvaluateString 				; get a string
.99d6	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.99d8	20 99 9d	jsr $9d99			jsr 	NSMSetByte 					; ASC("") will return zero.
.99db	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.99de	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.99df					FracUnary:
.99df	fa		plx				plx 								; restore stack pos
.99e0	20 e5 9c	jsr $9ce5			jsr 	EvaluateNumber 				; get a float or int
.99e3	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.99e6	b5 50		lda $50,x			lda 	NSStatus,x
.99e8	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.99ea	f0 04		beq $99f0			beq 	_IUZero
.99ec	20 9f 94	jsr $949f			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.99ef	60		rts				rts
.99f0					_IUZero:
.99f0	20 97 9d	jsr $9d97			jsr 	NSMSetZero
.99f3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.99f4					IntUnary:
.99f4	fa		plx				plx 								; restore stack pos
.99f5	20 e5 9c	jsr $9ce5			jsr 	EvaluateNumber 				; get a float or int
.99f8	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.99fb	b5 50		lda $50,x			lda 	NSStatus,x
.99fd	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.99ff	f0 03		beq $9a04			beq 	_IUExit
.9a01	20 f7 94	jsr $94f7			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9a04					_IUExit:
.9a04	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a05					LenUnary:
.9a05	fa		plx				plx 								; restore stack pos
.9a06	20 ef 9c	jsr $9cef			jsr 	EvaluateString 				; get a string
.9a09	5a		phy				phy
.9a0a	a0 00		ldy #$00			ldy 	#0 							; find length
.9a0c					_LenFind:
.9a0c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a0e	f0 06		beq $9a16			beq 	_LenExit
.9a10	c8		iny				iny
.9a11	d0 f9		bne $9a0c			bne 	_LenFind
.9a13	4c 1a 9f	jmp $9f1a			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9a16					_LenExit:
.9a16	98		tya				tya		 							; return length
.9a17	20 99 9d	jsr $9d99			jsr 	NSMSetByte
.9a1a	7a		ply				ply
.9a1b	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.9a1e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a1f					Unary_Min:
.9a1f	a9 01		lda #$01			lda 	#1
.9a21	80 02		bra $9a25			bra 	UnaryMinMaxMain
.9a23					Unary_Max:
.9a23	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a25					UnaryMinMaxMain:
.9a25	fa		plx				plx 								; get index on number stack
.9a26	48		pha				pha 								; save comparator
.9a27	20 dc 9c	jsr $9cdc			jsr 	EvaluateValue 				; get the first value.
.9a2a					_UMMMLoop:
.9a2a	b1 30		lda ($30),y			lda 	(codePtr),y
.9a2c	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a2e	f0 22		beq $9a52			beq 	_UMMMDone
.9a30	20 79 8e	jsr $8e79			jsr 	CheckComma 					; must be a comma
.9a33	e8		inx				inx
.9a34	20 dc 9c	jsr $9cdc			jsr 	EvaluateValue
.9a37	ca		dex				dex
.9a38	20 7a 9d	jsr $9d7a			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a3b	e8		inx				inx
.9a3c	20 7a 9d	jsr $9d7a			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a3f	e8		inx				inx
.9a40	20 41 8f	jsr $8f41			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a43	ca		dex				dex
.9a44	ca		dex				dex
.9a45	85 36		sta $36				sta 	zTemp0 						; save required result
.9a47	68		pla				pla 								; get and save comparator
.9a48	48		pha				pha
.9a49	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a4b	d0 dd		bne $9a2a			bne 	_UMMMLoop
.9a4d	20 55 9a	jsr $9a55			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a50	80 d8		bra $9a2a			bra 	_UMMMLoop
.9a52					_UMMMDone:
.9a52	68		pla				pla 								; throw the comparator
.9a53	c8		iny				iny 								; skip )
.9a54	60		rts				rts
.9a55					ExpCopyAboveDown:
.9a55	b5 51		lda $51,x			lda 	NSStatus+1,x
.9a57	95 50		sta $50,x			sta 	NSStatus,x
.9a59	b5 79		lda $79,x			lda 	NSExponent+1,x
.9a5b	95 78		sta $78,x			sta 	NSExponent,x
.9a5d	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9a5f	95 58		sta $58,x			sta 	NSMantissa0,x
.9a61	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9a63	95 60		sta $60,x			sta 	NSMantissa1,x
.9a65	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9a67	95 68		sta $68,x			sta 	NSMantissa2,x
.9a69	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9a6b	95 70		sta $70,x			sta 	NSMantissa3,x
.9a6d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9a6e					Unary_Not:
.9a6e	fa		plx				plx
.9a6f	20 04 9d	jsr $9d04			jsr 	EvaluateInteger 			; get integer
.9a72	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.9a75	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; zero mantissa ?
.9a78	f0 04		beq $9a7e			beq 	_NotZero
.9a7a	20 97 9d	jsr $9d97			jsr 	NSMSetZero
.9a7d	60		rts				rts
.9a7e					_NotZero:
.9a7e	4c f7 8e	jmp $8ef7			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9a81					Unary_Random:
.9a81	fa		plx				plx
.9a82	20 f3 9a	jsr $9af3			jsr 	Random32Bit 				; get a random number
.9a85	20 dc 9a	jsr $9adc			jsr 	URCopyToMantissa  			; put in mantissa
.9a88	b1 30		lda ($30),y			lda 	(codePtr),y
.9a8a	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9a8c	f0 08		beq $9a96			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9a8e	e8		inx				inx
.9a8f	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9a92	ca		dex				dex
.9a93	20 49 90	jsr $9049			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9a96					_URNoModulus:
.9a96	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9a98	74 78		stz $78,x			stz 	NSExponent,x
.9a9a	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.9a9d	60		rts				rts
.9a9e					Unary_Rnd:
.9a9e	fa		plx				plx
.9a9f	20 e5 9c	jsr $9ce5			jsr 	EvaluateNumber 				; number to use.
.9aa2	20 71 8e	jsr $8e71			jsr 	CheckRightBracket 			; closing bracket
.9aa5	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9aa8	f0 26		beq $9ad0			beq 	_URCopySeed
.9aaa	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9aac	10 1f		bpl $9acd			bpl 	_URDontSeed
.9aae	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9ab0	49 17		eor #$17			eor 	#$17
.9ab2	8d 08 04	sta $0408			sta 	RandomSeed+0
.9ab5	b5 60		lda $60,x			lda 	NSMantissa1,x
.9ab7	49 a5		eor #$a5			eor 	#$A5
.9ab9	8d 09 04	sta $0409			sta 	RandomSeed+1
.9abc	b5 68		lda $68,x			lda 	NSMantissa2,x
.9abe	49 c2		eor #$c2			eor 	#$C2
.9ac0	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9ac3	b5 70		lda $70,x			lda 	NSMantissa3,x
.9ac5	49 9d		eor #$9d			eor 	#$9D
.9ac7	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9aca	20 f3 9a	jsr $9af3			jsr 	Random32Bit
.9acd					_URDontSeed:
.9acd	20 f3 9a	jsr $9af3			jsr 	Random32Bit 				; generate a number
.9ad0					_URCopySeed:
.9ad0	20 dc 9a	jsr $9adc			jsr 	URCopyToMantissa 			; copy into mantissa
.9ad3	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9ad5	95 78		sta $78,x			sta 	NSExponent,x
.9ad7	a9 08		lda #$08			lda 	#NSTFloat
.9ad9	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9adb	60		rts				rts
.9adc					URCopyToMantissa:
.9adc	ad 08 04	lda $0408			lda 	RandomSeed+0
.9adf	95 58		sta $58,x			sta 	NSMantissa0,x
.9ae1	ad 09 04	lda $0409			lda 	RandomSeed+1
.9ae4	95 60		sta $60,x			sta 	NSMantissa1,x
.9ae6	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9ae9	95 68		sta $68,x			sta 	NSMantissa2,x
.9aeb	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9aee	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9af0	95 70		sta $70,x			sta 	NSMantissa3,x
.9af2	60		rts				rts
.9af3					Random32Bit:
.9af3	5a		phy				phy
.9af4	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9af6	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9af9	d0 03		bne $9afe			bne 	_Random1
.9afb	a8		tay				tay 								; if so do it 256 times
.9afc	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9afe					_Random1:
.9afe	0a		asl a				asl 	a 							; LSFR RNG
.9aff	2e 09 04	rol $0409			rol 	RandomSeed+1
.9b02	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9b05	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9b08	90 02		bcc $9b0c			bcc 	_Random2
.9b0a	49 c5		eor #$c5			eor 	#$C5
.9b0c					_Random2:
.9b0c	88		dey				dey
.9b0d	d0 ef		bne $9afe			bne 	_Random1
.9b0f	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b12	7a		ply				ply
.9b13	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b14					SgnUnary:
.9b14	fa		plx				plx 								; restore stack pos
.9b15	20 e5 9c	jsr $9ce5			jsr 	EvaluateNumber 				; get a float or int
.9b18	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.9b1b	20 b9 9d	jsr $9db9			jsr 	NSMIsZero 					; if zero
.9b1e	f0 0e		beq $9b2e			beq 	_SGZero  					; return Int Zero
.9b20	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9b22	48		pha				pha
.9b23	a9 01		lda #$01			lda 	#1 							; set to 1
.9b25	20 99 9d	jsr $9d99			jsr 	NSMSetByte
.9b28	68		pla				pla
.9b29	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b2b	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9b2d	60		rts				rts
.9b2e	20 97 9d	jsr $9d97	_SGZero:jsr 	NSMSetZero
.9b31	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b32					ValUnary:
.9b32	fa		plx				plx 								; restore stack pos
.9b33	20 48 9b	jsr $9b48			jsr 	ValMainCode 				; do the main val() code
.9b36	b0 01		bcs $9b39			bcs 	_VUError 					; couldn't convert
.9b38	60		rts				rts
.9b39					_VUError:
.9b39	4c 1f 9f	jmp $9f1f			jmp 	TypeError
.9b3c					IsValUnary:
.9b3c	fa		plx				plx 								; restore stack pos
.9b3d	20 48 9b	jsr $9b48			jsr 	ValMainCode 				; do the main val() code
.9b40	b0 03		bcs $9b45			bcs 	_VUBad
.9b42	4c f7 8e	jmp $8ef7			jmp 	ReturnTrue
.9b45					_VUBad:
.9b45	4c 02 8f	jmp $8f02			jmp 	ReturnFalse
.9b48					ValMainCode:
.9b48	20 ef 9c	jsr $9cef			jsr 	EvaluateString 				; get a string
.9b4b	20 71 8e	jsr $8e71			jsr 	CheckRightBracket 			; check right bracket present
.9b4e					ValEvaluateZTemp0:
.9b4e	5a		phy				phy
.9b4f	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9b51	f0 17		beq $9b6a			beq 	_VMCFail2
.9b53	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9b55	48		pha				pha 								; save first character
.9b56	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9b58	d0 01		bne $9b5b			bne 	_VMCStart
.9b5a	c8		iny				iny 								; skip over -
.9b5b					_VMCStart:
.9b5b	38		sec				sec 								; initialise first time round.
.9b5c					_VMCNext:
.9b5c	c8		iny				iny 								; pre-increment
.9b5d	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9b5f	f0 0c		beq $9b6d			beq 	_VMCSuccess 				; successful.
.9b61	20 d4 96	jsr $96d4			jsr 	EncodeNumber 				; send it to the number-builder
.9b64	90 03		bcc $9b69			bcc 	_VMCFail 					; if failed, give up.
.9b66	18		clc				clc 								; next time round, countinue
.9b67	80 f3		bra $9b5c			bra 	_VMCNext
.9b69					_VMCFail:
.9b69	68		pla				pla
.9b6a					_VMCFail2:
.9b6a	7a		ply				ply
.9b6b	38		sec				sec
.9b6c	60		rts				rts
.9b6d					_VMCSuccess:
.9b6d	a9 00		lda #$00			lda 	#0 							; construct final
.9b6f	20 d4 96	jsr $96d4			jsr 	EncodeNumber 				; by sending a duff value.
.9b72	68		pla				pla 								; if it was -ve
.9b73	c9 2d		cmp #$2d			cmp 	#"-"
.9b75	d0 03		bne $9b7a			bne 	_VMCNotNegative
.9b77	20 59 9d	jsr $9d59			jsr		NSMNegate 					; negate it.
.9b7a					_VMCNotNegative:
.9b7a	7a		ply				ply
.9b7b	18		clc				clc
.9b7c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9b7d					ChrUnary:
.9b7d	fa		plx				plx 								; restore stack pos
.9b7e	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9b81	48		pha				pha
.9b82	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.9b85	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9b87	20 c9 a6	jsr $a6c9			jsr 	StringTempAllocate
.9b8a	68		pla				pla 								; write number to it
.9b8b	20 02 a7	jsr $a702			jsr 	StringTempWrite
.9b8e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9b8f					SpcUnary:
.9b8f	fa		plx				plx 								; restore stack pos
.9b90	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger			; get value
.9b93	5a		phy				phy
.9b94	48		pha				pha 								; save count
.9b95	20 c9 a6	jsr $a6c9			jsr 	StringTempAllocate
.9b98	7a		ply				ply 								; to do count in Y
.9b99					_SpcLoop:
.9b99	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9b9b	f0 08		beq $9ba5			beq 	_SpcExit
.9b9d	a9 20		lda #$20			lda 	#32
.9b9f	20 02 a7	jsr $a702			jsr 	StringTempWrite
.9ba2	88		dey				dey
.9ba3	80 f4		bra $9b99			bra 	_SPCLoop
.9ba5					_SpcExit:
.9ba5	7a		ply				ply
.9ba6	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.9ba9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9baa					Unary_Str:
.9baa	fa		plx				plx
.9bab	20 e5 9c	jsr $9ce5			jsr 	EvaluateNumber  			; get number
.9bae	20 71 8e	jsr $8e71			jsr 	CheckRightBracket 			; closing bracket
.9bb1	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9bb3	20 cc 9b	jsr $9bcc			jsr 	ConvertNumberToString 		; do the conversion.
.9bb6	a9 21		lda #$21			lda		#33 						; create buffer
.9bb8	20 c9 a6	jsr $a6c9			jsr 	StringTempAllocate 			; allocate memory
.9bbb	da		phx				phx  								; copy the converted string into the buffer.
.9bbc	a2 00		ldx #$00			ldx 	#0
.9bbe					_USCopy:
.9bbe	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9bc1	20 02 a7	jsr $a702			jsr 	StringTempWrite
.9bc4	e8		inx				inx
.9bc5	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9bc8	d0 f4		bne $9bbe			bne 	_USCopy
.9bca	fa		plx				plx
.9bcb	60		rts				rts
.9bcc					ConvertNumberToString:
.9bcc	5a		phy				phy 								; save code position
.9bcd	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9bd0	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9bd3	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9bd5	10 09		bpl $9be0			bpl 	_CNTSNotNegative
.9bd7	29 7f		and #$7f			and 	#$7F 						; make +ve
.9bd9	95 50		sta $50,x			sta 	NSStatus,x
.9bdb	a9 2d		lda #$2d			lda 	#"-"
.9bdd	20 41 9c	jsr $9c41			jsr 	WriteDecimalBuffer
.9be0					_CNTSNotNegative:
.9be0	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9be2	f0 12		beq $9bf6			beq 	_CNTSNotFloat
.9be4	e8		inx				inx 								; round up so we don't get too many 6.999999
.9be5	a9 01		lda #$01			lda 	#1
.9be7	20 99 9d	jsr $9d99			jsr 	NSMSetByte
.9bea	ca		dex				dex
.9beb	b5 78		lda $78,x			lda		NSExponent,x
.9bed	95 79		sta $79,x			sta 	NSExponent+1,x
.9bef	a9 08		lda #$08			lda 	#NSTFloat
.9bf1	95 51		sta $51,x			sta 	NSStatus+1,x
.9bf3	20 d9 93	jsr $93d9			jsr 	FloatAdd
.9bf6					_CNTSNotFloat:
.9bf6	20 23 9c	jsr $9c23			jsr 	MakePlusTwoString 			; do the integer part.
.9bf9	20 9f 94	jsr $949f			jsr 	FloatFractionalPart 		; get the fractional part
.9bfc	20 50 95	jsr $9550			jsr 	NSNormalise					; normalise , exit if zero
.9bff	f0 20		beq $9c21			beq 	_CNTSExit
.9c01	a9 2e		lda #$2e			lda 	#"."
.9c03	20 41 9c	jsr $9c41			jsr 	WriteDecimalBuffer 			; write decimal place
.9c06					_CNTSDecimal:
.9c06	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9c09	30 16		bmi $9c21			bmi 	_CNTSExit
.9c0b	e8		inx				inx 								; x 10.0
.9c0c	a9 0a		lda #$0a			lda 	#10
.9c0e	20 99 9d	jsr $9d99			jsr 	NSMSetByte
.9c11	a9 08		lda #$08			lda 	#NSTFloat
.9c13	95 50		sta $50,x			sta 	NSStatus,x
.9c15	ca		dex				dex
.9c16	20 1e 95	jsr $951e			jsr 	FloatMultiply
.9c19	20 23 9c	jsr $9c23			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9c1c	20 9f 94	jsr $949f			jsr 	FloatFractionalPart 		; get the fractional part
.9c1f	80 e5		bra $9c06			bra 	_CNTSDecimal 				; keep going.
.9c21					_CNTSExit:
.9c21	7a		ply				ply
.9c22	60		rts				rts
.9c23					MakePlusTwoString:
.9c23	da		phx				phx
.9c24	20 7a 9d	jsr $9d7a			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c27	e8		inx				inx 								; access it
.9c28	e8		inx				inx
.9c29	20 f7 94	jsr $94f7			jsr 	FloatIntegerPart 			; make it an integer
.9c2c	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c2e	20 09 93	jsr $9309			jsr 	ConvertInt32
.9c31	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9c33					_MPTSCopy:
.9c33	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9c36	20 41 9c	jsr $9c41			jsr 	WriteDecimalBuffer
.9c39	e8		inx				inx
.9c3a	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9c3d	d0 f4		bne $9c33			bne 	_MPTSCopy
.9c3f	fa		plx				plx
.9c40	60		rts				rts
.9c41					WriteDecimalBuffer:
.9c41	da		phx				phx
.9c42	ae 15 04	ldx $0415			ldx 	dbOffset
.9c45	9d 9d 05	sta $059d,x			sta 	DecimalBuffer,x
.9c48	9e 9e 05	stz $059e,x			stz 	DecimalBuffer+1,x
.9c4b	ee 15 04	inc $0415			inc 	dbOffset
.9c4e	fa		plx				plx
.9c4f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9c50					Unary_Left:
.9c50	fa		plx				plx
.9c51	18		clc				clc 								; only one parameter
.9c52	20 b5 9c	jsr $9cb5			jsr 	SubstringInitial 			; set up.
.9c55	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9c57	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c59	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9c5b	80 25		bra $9c82			bra 	SubstringMain
.9c5d					Unary_Right:
.9c5d	fa		plx				plx
.9c5e	18		clc				clc 								; only one parameter
.9c5f	20 b5 9c	jsr $9cb5			jsr 	SubstringInitial 			; set up.
.9c62	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9c64	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c66	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9c68	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9c6a	b0 02		bcs $9c6e			bcs 	_URNotUnderflow
.9c6c	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9c6e					_URNotUnderFlow:
.9c6e	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9c70	80 10		bra $9c82			bra 	SubStringMain
.9c72					Unary_Mid:
.9c72	fa		plx				plx
.9c73	38		sec				sec 								; two parameters
.9c74	20 b5 9c	jsr $9cb5			jsr 	SubstringInitial 			; set up.
.9c77	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9c79	f0 04		beq $9c7f			beq 	_UMError
.9c7b	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9c7d	80 03		bra $9c82			bra 	SubStringMain
.9c7f					_UMError:
.9c7f	4c 24 9f	jmp $9f24			jmp 	ArgumentError
.9c82					SubStringMain:
.9c82	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9c84	d5 78		cmp $78,x			cmp 	NSExponent,x
.9c86	b0 27		bcs $9caf			bcs 	_SSMNull 					; if so, return an empty string.
.9c88	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9c8a	f0 23		beq $9caf			beq 	_SSMNull 					; return empty string.
.9c8c	18		clc				clc 								; add the offset +1 to the address and
.9c8d	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9c8f	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9c91	85 36		sta $36				sta 	zTemp0
.9c93	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9c95	69 00		adc #$00			adc 	#0
.9c97	85 37		sta $37				sta 	zTemp0+1
.9c99					_SSMNoCarry:
.9c99	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9c9b	20 c9 a6	jsr $a6c9			jsr 	StringTempAllocate 			; allocate that many characters
.9c9e	5a		phy				phy 								; save Y
.9c9f	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9ca1					_SSMCopy:
.9ca1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9ca3	f0 08		beq $9cad			beq 	_SSMEString 				; no more to copy
.9ca5	20 02 a7	jsr $a702			jsr 	StringTempWrite 			; and write it out.
.9ca8	c8		iny				iny
.9ca9	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9cab	d0 f4		bne $9ca1			bne 	_SSMCopy
.9cad					_SSMEString:
.9cad	7a		ply				ply
.9cae					_SSMExit:
.9cae	60		rts				rts
.9caf					_SSMNull:
.9caf	a9 00		lda #$00			lda 	#0
.9cb1	20 c9 a6	jsr $a6c9			jsr 	StringTempAllocate
.9cb4	60		rts				rts
.9cb5					SubstringInitial:
.9cb5	da		phx				phx 								; save initial stack position
.9cb6	08		php				php 								; save carry on stack indicating 2 parameters
.9cb7	20 ef 9c	jsr $9cef			jsr 	EvaluateString 				; get a string
.9cba	5a		phy				phy 								; calculate length to exponent.
.9cbb	a0 ff		ldy #$ff			ldy 	#$FF
.9cbd					_SIFindLength:
.9cbd	c8		iny				iny
.9cbe	b1 36		lda ($36),y			lda 	(zTemp0),y
.9cc0	d0 fb		bne $9cbd			bne 	_SIFindLength
.9cc2	98		tya				tya
.9cc3	95 78		sta $78,x			sta 	NSExponent,x
.9cc5	7a		ply				ply
.9cc6	e8		inx				inx
.9cc7	20 79 8e	jsr $8e79			jsr 	CheckComma 					; comma next
.9cca	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; get next parameter
.9ccd	28		plp				plp 								; is it the last parameter ?
.9cce	90 07		bcc $9cd7			bcc 	_SSIExit 					; if so, exit.
.9cd0	e8		inx				inx
.9cd1	20 79 8e	jsr $8e79			jsr 	CheckComma 					; comma next
.9cd4	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; get last parameter
.9cd7					_SSIExit:
.9cd7	fa		plx				plx
.9cd8	20 71 8e	jsr $8e71			jsr 	CheckRightBracket 			; check closing bracket
.9cdb	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9cdc					EvaluateValue:
.9cdc	48		pha				pha
.9cdd	20 8e 93	jsr $938e			jsr		EvaluateExpression 			; expression
.9ce0	20 51 96	jsr $9651			jsr 	Dereference					; derefernce it
.9ce3	68		pla				pla
.9ce4	60		rts				rts
.9ce5					EvaluateNumber:
.9ce5	20 dc 9c	jsr $9cdc			jsr 	EvaluateValue 				; get a value
.9ce8	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9cea	29 10		and #$10			and 	#NSBIsString
.9cec	d0 13		bne $9d01			bne 	HelperTypeError
.9cee	60		rts				rts
.9cef					EvaluateString:
.9cef	20 dc 9c	jsr $9cdc			jsr 	EvaluateValue 				; get a value
.9cf2	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9cf4	29 10		and #$10			and 	#NSBIsString
.9cf6	f0 09		beq $9d01			beq 	HelperTypeError
.9cf8					CopyAddressToTemp0:
.9cf8	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9cfa	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9cfc	b5 60		lda $60,x			lda 	NSMantissa1,x
.9cfe	85 37		sta $37				sta 	zTemp0+1
.9d00	60		rts				rts
.9d01					HelperTypeError:
.9d01	4c 1f 9f	jmp $9f1f			jmp 	TypeError
.9d04					EvaluateInteger:
.9d04	20 e5 9c	jsr $9ce5			jsr 	EvaluateNumber
.9d07	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9d09	d0 09		bne $9d14			bne 	HelperValueError 			; if not, it's a float.
.9d0b	60		rts				rts
.9d0c					EvaluateUnsignedInteger:
.9d0c	20 04 9d	jsr $9d04			jsr 	EvaluateInteger 			; check integer is +ve
.9d0f	b5 50		lda $50,x			lda 	NSStatus,x
.9d11	30 01		bmi $9d14			bmi 	HelperValueError
.9d13	60		rts				rts
.9d14					HelperValueError:
.9d14	4c 24 9f	jmp $9f24			jmp 	ArgumentError
.9d17						Evaluate16BitInteger:
.9d17	20 0c 9d	jsr $9d0c			jsr	 	EvaluateUnsignedInteger		; get integer
.9d1a	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d1c	15 68		ora $68,x			ora 	NSMantissa2,x
.9d1e	d0 f4		bne $9d14			bne 	HelperValueError
.9d20	60		rts				rts
.9d21					Evaluate16BitIntegerSigned:
.9d21	20 04 9d	jsr $9d04			jsr	 	EvaluateInteger				; get integer
.9d24	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d26	15 68		ora $68,x			ora 	NSMantissa2,x
.9d28	d0 ea		bne $9d14			bne 	HelperValueError
.9d2a	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9d2c	10 03		bpl $9d31			bpl 	_EISNotSigned
.9d2e	20 60 9d	jsr $9d60			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9d31					_EISNotSigned:
.9d31	60		rts				rts
.9d32					Evaluate8BitInteger:
.9d32	20 0c 9d	jsr $9d0c			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9d35	d0 dd		bne $9d14			bne 	HelperValueError
.9d37	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9d39	15 68		ora $68,x			ora 	NSMantissa2,x
.9d3b	15 60		ora $60,x			ora 	NSMantissa1,x
.9d3d	d0 d5		bne $9d14			bne 	HelperValueError
.9d3f	b5 58		lda $58,x			lda 	NSMantissa0,x
.9d41	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9d42					Multiply8x8:
.9d42	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9d43	85 36		sta $36			  	sta 	zTemp0
.9d45	86 37		stx $37				stx 	zTemp0+1
.9d47	a9 00		lda #$00			lda 	#0
.9d49	a2 08		ldx #$08			ldx 	#8
.9d4b					_M88Loop:
.9d4b	90 03		bcc $9d50			bcc 	_M88NoAdd
.9d4d	18		clc				clc
.9d4e	65 37		adc $37				adc 	zTemp0+1
.9d50					_M88NoAdd:
.9d50	6a		ror a				ror 	a
.9d51	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9d53	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9d54	d0 f5		bne $9d4b			bne 	_M88Loop
.9d56	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9d58	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9d59					NSMNegate:
.9d59	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9d5b	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9d5d	95 50		sta $50,x			sta 	NSStatus,x
.9d5f	60		rts				rts
.9d60					NSMNegateMantissa:
.9d60	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9d61	a9 00		lda #$00			lda 	#0
.9d63	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9d65	95 58		sta $58,x			sta 	NSMantissa0,x
.9d67	a9 00		lda #$00			lda 	#0
.9d69	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9d6b	95 60		sta $60,x			sta 	NSMantissa1,x
.9d6d	a9 00		lda #$00			lda 	#0
.9d6f	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9d71	95 68		sta $68,x			sta 	NSMantissa2,x
.9d73	a9 00		lda #$00			lda 	#0
.9d75	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9d77	95 70		sta $70,x			sta 	NSMantissa3,x
.9d79	60		rts				rts
.9d7a					NSMShiftUpTwo:
.9d7a	b5 58		lda $58,x			lda 	NSMantissa0,x
.9d7c	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d7e	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d80	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9d82	b5 68		lda $68,x			lda 	NSMantissa2,x
.9d84	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9d86	b5 70		lda $70,x			lda 	NSMantissa3,x
.9d88	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9d8a	b5 78		lda $78,x			lda 	NSExponent,x
.9d8c	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9d8e	b5 50		lda $50,x			lda 	NSStatus,x
.9d90	95 52		sta $52,x			sta 	NSStatus+2,x
.9d92	60		rts				rts
.9d93					NSMSetZeroMantissaOnly:
.9d93	a9 00		lda #$00			lda 	#0
.9d95	80 06		bra $9d9d			bra 	NSMSetMantissa
.9d97					NSMSetZero:
.9d97	a9 00		lda #$00			lda 	#0
.9d99					NSMSetByte:
.9d99	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9d9b	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9d9d					NSMSetMantissa:
.9d9d	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9d9f	74 60		stz $60,x			stz 	NSMantissa1,x
.9da1	74 68		stz $68,x			stz 	NSMantissa2,x
.9da3	74 70		stz $70,x			stz 	NSMantissa3,x
.9da5	60		rts				rts
.9da6					NSMShiftLeft:
.9da6	18		clc				clc
.9da7					NSMRotateLeft:
.9da7	36 58		rol $58,x			rol 	NSMantissa0,x
.9da9	36 60		rol $60,x			rol		NSMantissa1,x
.9dab	36 68		rol $68,x			rol		NSMantissa2,x
.9dad	36 70		rol $70,x			rol		NSMantissa3,x
.9daf	60		rts				rts
.9db0					NSMShiftRight:
.9db0	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9db2	76 68		ror $68,x			ror		NSMantissa2,x
.9db4	76 60		ror $60,x			ror		NSMantissa1,x
.9db6	76 58		ror $58,x			ror		NSMantissa0,x
.9db8	60		rts				rts
.9db9					NSMIsZero:
.9db9	b5 70		lda $70,x			lda 	NSMantissa3,x
.9dbb	15 68		ora $68,x			ora		NSMantissa2,x
.9dbd	15 60		ora $60,x			ora		NSMantissa1,x
.9dbf	15 58		ora $58,x			ora		NSMantissa0,x
.9dc1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9dc2					TickHandler:
.9dc2	5a		phy				phy 								; need to preserve Y
.9dc3	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9dc6	7a		ply				ply
.9dc7	60		rts				rts
.05af					LastTick:
>05af							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9dc8					Assemble_ora:
.9dc8	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dcb	01					.byte $01
.9dcc					Assemble_and:
.9dcc	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dcf	21					.byte $21
.9dd0					Assemble_eor:
.9dd0	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dd3	41					.byte $41
.9dd4					Assemble_adc:
.9dd4	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dd7	61					.byte $61
.9dd8					Assemble_sta:
.9dd8	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9ddb	81					.byte $81
.9ddc					Assemble_lda:
.9ddc	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9ddf	a1					.byte $a1
.9de0					Assemble_cmp:
.9de0	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9de3	c1					.byte $c1
.9de4					Assemble_sbc:
.9de4	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9de7	e1					.byte $e1
.9de8					Assemble_asl:
.9de8	20 46 80	jsr $8046		jsr	AssembleGroup2
>9deb	02					.byte $02
>9dec	75					.byte $75
.9ded					Assemble_rol:
.9ded	20 46 80	jsr $8046		jsr	AssembleGroup2
>9df0	22					.byte $22
>9df1	75					.byte $75
.9df2					Assemble_lsr:
.9df2	20 46 80	jsr $8046		jsr	AssembleGroup2
>9df5	42					.byte $42
>9df6	75					.byte $75
.9df7					Assemble_ror:
.9df7	20 46 80	jsr $8046		jsr	AssembleGroup2
>9dfa	62					.byte $62
>9dfb	75					.byte $75
.9dfc					Assemble_stx:
.9dfc	20 46 80	jsr $8046		jsr	AssembleGroup2
>9dff	82					.byte $82
>9e00	50					.byte $50
.9e01					Assemble_ldx:
.9e01	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e04	a2					.byte $a2
>9e05	d0					.byte $d0
.9e06					Assemble_dec:
.9e06	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e09	c2					.byte $c2
>9e0a	55					.byte $55
.9e0b					Assemble_inc:
.9e0b	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e0e	e2					.byte $e2
>9e0f	55					.byte $55
.9e10					Assemble_stz:
.9e10	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e13	60					.byte $60
>9e14	44					.byte $44
.9e15					Assemble_bit:
.9e15	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e18	20					.byte $20
>9e19	55					.byte $55
.9e1a					Assemble_sty:
.9e1a	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e1d	80					.byte $80
>9e1e	54					.byte $54
.9e1f					Assemble_ldy:
.9e1f	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e22	a0					.byte $a0
>9e23	d5					.byte $d5
.9e24					Assemble_cpy:
.9e24	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e27	c0					.byte $c0
>9e28	d4					.byte $d4
.9e29					Assemble_cpx:
.9e29	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e2c	e0					.byte $e0
>9e2d	d0					.byte $d0
.9e2e					Assemble_tsb:
.9e2e	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e31	00					.byte $00
>9e32	50					.byte $50
.9e33					Assemble_trb:
.9e33	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e36	10					.byte $10
>9e37	50					.byte $50
.9e38					Assemble_jsr:
.9e38	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e3b	14					.byte $14
>9e3c	10					.byte $10
.9e3d					Assemble_jmp:
.9e3d	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e40	40					.byte $40
>9e41	10					.byte $10
.9e42					Assemble_bpl:
.9e42	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e45	10					.byte $10
.9e46					Assemble_bmi:
.9e46	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e49	30					.byte $30
.9e4a					Assemble_bvc:
.9e4a	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e4d	50					.byte $50
.9e4e					Assemble_bvs:
.9e4e	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e51	70					.byte $70
.9e52					Assemble_bcc:
.9e52	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e55	90					.byte $90
.9e56					Assemble_bcs:
.9e56	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e59	b0					.byte $b0
.9e5a					Assemble_bne:
.9e5a	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e5d	d0					.byte $d0
.9e5e					Assemble_beq:
.9e5e	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e61	f0					.byte $f0
.9e62					Assemble_bra:
.9e62	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e65	80					.byte $80
.9e66					Assemble_brk:
.9e66	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e69	00					.byte $00
.9e6a					Assemble_php:
.9e6a	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e6d	08					.byte $08
.9e6e					Assemble_clc:
.9e6e	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e71	18					.byte $18
.9e72					Assemble_plp:
.9e72	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e75	28					.byte $28
.9e76					Assemble_sec:
.9e76	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e79	38					.byte $38
.9e7a					Assemble_rti:
.9e7a	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e7d	40					.byte $40
.9e7e					Assemble_pha:
.9e7e	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e81	48					.byte $48
.9e82					Assemble_cli:
.9e82	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e85	58					.byte $58
.9e86					Assemble_phy:
.9e86	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e89	5a					.byte $5a
.9e8a					Assemble_rts:
.9e8a	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e8d	60					.byte $60
.9e8e					Assemble_pla:
.9e8e	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e91	68					.byte $68
.9e92					Assemble_sei:
.9e92	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e95	78					.byte $78
.9e96					Assemble_ply:
.9e96	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e99	7a					.byte $7a
.9e9a					Assemble_dey:
.9e9a	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e9d	88					.byte $88
.9e9e					Assemble_txa:
.9e9e	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ea1	8a					.byte $8a
.9ea2					Assemble_tya:
.9ea2	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ea5	98					.byte $98
.9ea6					Assemble_txs:
.9ea6	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ea9	9a					.byte $9a
.9eaa					Assemble_tay:
.9eaa	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ead	a8					.byte $a8
.9eae					Assemble_tax:
.9eae	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9eb1	aa					.byte $aa
.9eb2					Assemble_clv:
.9eb2	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9eb5	b8					.byte $b8
.9eb6					Assemble_tsx:
.9eb6	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9eb9	ba					.byte $ba
.9eba					Assemble_iny:
.9eba	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ebd	c8					.byte $c8
.9ebe					Assemble_dex:
.9ebe	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ec1	ca					.byte $ca
.9ec2					Assemble_cld:
.9ec2	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ec5	d8					.byte $d8
.9ec6					Assemble_phx:
.9ec6	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ec9	da					.byte $da
.9eca					Assemble_stp:
.9eca	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ecd	db					.byte $db
.9ece					Assemble_inx:
.9ece	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ed1	e8					.byte $e8
.9ed2					Assemble_nop:
.9ed2	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ed5	ea					.byte $ea
.9ed6					Assemble_sed:
.9ed6	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ed9	f8					.byte $f8
.9eda					Assemble_plx:
.9eda	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9edd	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9ede					DecimalScalarTable:
>9ede	66 66 66 66				.dword $66666666 ; 0.1
>9ee2	de					.byte $de
>9ee3	1f 85 eb 51				.dword $51eb851f ; 0.01
>9ee7	db					.byte $db
>9ee8	4c 37 89 41				.dword $4189374c ; 0.001
>9eec	d8					.byte $d8
>9eed	ac 8b db 68				.dword $68db8bac ; 0.0001
>9ef1	d4					.byte $d4
>9ef2	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9ef6	d1					.byte $d1
>9ef7	83 de 1b 43				.dword $431bde83 ; 1e-06
>9efb	ce					.byte $ce
>9efc	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f00	ca					.byte $ca
>9f01	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9f05	c7					.byte $c7
>9f06	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f0a	c4					.byte $c4
>9f0b	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f0f	c0					.byte $c0
>9f10	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9f14	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9f15					SyntaxError:
.9f15	a9 02		lda #$02		lda	#2
.9f17	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.9f1a					RangeError:
.9f1a	a9 04		lda #$04		lda	#4
.9f1c	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.9f1f					TypeError:
.9f1f	a9 05		lda #$05		lda	#5
.9f21	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.9f24					ArgumentError:
.9f24	a9 07		lda #$07		lda	#7
.9f26	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.9f29					NotDoneError:
.9f29	a9 0c		lda #$0c		lda	#12
.9f2b	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.9f2e					ErrorText:
>9f2e	42 72 65 61 6b 00			.text	"Break",0
>9f34	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9f3c	72 72 6f 72 00
>9f41	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9f49	20 62 79 20 7a 65 72 6f 00
>9f52	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9f5a	61 6e 67 65 00
>9f5f	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9f67	6d 61 74 63 68 00
>9f6d	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9f75	65 6d 6f 72 79 00
>9f7b	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>9f83	61 72 67 75 6d 65 6e 74 00
>9f8c	53 74 6f 70 00				.text	"Stop",0
>9f91	53 74 72 69 6e 67 20 74			.text	"String too long",0
>9f99	6f 6f 20 6c 6f 6e 67 00
>9fa1	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>9fa9	6e 20 66 61 69 6c 65 64 00
>9fb2	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>9fba	61 74 61 00
>9fbe	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>9fc6	65 6e 74 65 64 00
>9fcc	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>9fd4	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>9fe0	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>9fe8	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>9ff5	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>9ffd	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a00a	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a012	68 6f 75 74 20 57 68 69 6c 65 00
>a01d	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a025	68 6f 75 74 20 46 6f 72 00
>a02e	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a036	61 63 6b 20 66 75 6c 6c 00
>a03f	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a047	75 63 74 75 72 65 00
>a04e	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a056	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a063	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a06b	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a079	41 72 72 61 79 20 73 69			.text	"Array size",0
>a081	7a 65 00
>a084	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a08c	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a094	52 65 6c 65 61 73 65 20			.text "Release Alpha 8 (01-Dec-22). "
>a09c	41 6c 70 68 61 20 38 20 28 30 31 2d 44 65 63 2d
>a0ac	32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a0b1					RectangleCommand:
.a0b1	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a0b3	80 02		bra $a0b7			bra 	ShapeDrawCmd
.a0b5					CircleCommand:
.a0b5	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a0b7					ShapeDrawCmd:
.a0b7	20 41 a1	jsr $a141			jsr 	RunGraphicsCommand
.a0ba					ShapeDraw:
.a0ba	0d b1 05	ora $05b1			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a0bd	4c 35 a1	jmp $a135			jmp 	ExecuteGraphicCommand	 	; and complete
.a0c0					SpriteCommand:
.a0c0	a2 00		ldx #$00			ldx 	#0
.a0c2	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; get image number.
.a0c5	5a		phy				phy
.a0c6	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a0c8	a6 58		ldx $58				ldx 	NSMantissa0
.a0ca	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a0cc	b0 0d		bcs $a0db			bcs 	_SCRange
.a0ce	a0 ff		ldy #$ff			ldy 	#255
.a0d0	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a0d3	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a0d5	7a		ply				ply
.a0d6	20 41 a1	jsr $a141			jsr 	RunGraphicsCommand
.a0d9	80 5a		bra $a135			bra 	ExecuteGraphicCommand
.a0db					_SCRange:
.a0db	4c 1a 9f	jmp $9f1a			jmp 	RangeError
.a0de					ImageCommand:
.a0de	a2 00		ldx #$00			ldx 	#0
.a0e0	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; get image number.
.a0e3	20 41 a1	jsr $a141			jsr 	RunGraphicsCommand
.a0e6					ImageRunDraw:
.a0e6	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a0e8	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a0eb	ad b7 05	lda $05b7			lda 	gxDrawScale
.a0ee	0a		asl a				asl 	a
.a0ef	0a		asl a				asl 	a
.a0f0	0a		asl a				asl 	a
.a0f1	a8		tay				tay
.a0f2	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a0f4	a6 58		ldx $58				ldx 	NSMantissa0
.a0f6	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a0f9	60		rts				rts
.a0fa					TextCommand:
.a0fa	a2 00		ldx #$00			ldx 	#0
.a0fc	20 ef 9c	jsr $9cef			jsr 	EvaluateString 				; get text
.a0ff	20 41 a1	jsr $a141			jsr 	RunGraphicsCommand
.a102					TextRunDraw:
.a102	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a104	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a107	a0 00		ldy #$00			ldy 	#0
.a109					_IRDLoop:
.a109	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a10b	85 37		sta $37				sta 	zTemp0+1
.a10d	a5 58		lda $58				lda 	NSMantissa0
.a10f	85 36		sta $36				sta 	zTemp0
.a111	b1 36		lda ($36),y			lda 	(zTemp0),y
.a113	f0 13		beq $a128			beq 	_IRDExit
.a115	5a		phy				phy									; save string pos
.a116	48		pha				pha 								; save char
.a117	ad b7 05	lda $05b7			lda 	gxDrawScale 				; get scale
.a11a	0a		asl a				asl 	a
.a11b	0a		asl a				asl 	a
.a11c	0a		asl a				asl 	a
.a11d	a8		tay				tay
.a11e	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a120	fa		plx				plx 								; char to draw
.a121	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a124	7a		ply				ply 								; restore string pos
.a125	c8		iny				iny
.a126	90 e1		bcc $a109			bcc 	_IRDLoop 					; go back if no error.
.a128					_IRDExit:
.a128	60		rts				rts
.a129					PlotCommand:
.a129	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a12b	20 41 a1	jsr $a141			jsr 	RunGraphicsCommand
.a12e	80 05		bra $a135			bra 	ExecuteGraphicCommand
.a130					LineCommand:
.a130	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a132	20 41 a1	jsr $a141			jsr 	RunGraphicsCommand
.a135					ExecuteGraphicCommand:
.a135	0d b0 05	ora $05b0			ora 	gxCommandID 				; make a full command
.a138	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a13b	b0 01		bcs $a13e			bcs 	_EGCError
.a13d	60		rts				rts
.a13e					_EGCError:
.a13e	4c 15 9f	jmp $9f15			jmp 	SyntaxError
.a141					RunGraphicsCommand:
.a141	8d b0 05	sta $05b0			sta 	gxCommandID					; save TODO graphics command.
.a144	68		pla				pla 								; pop handler address
.a145	fa		plx				plx
.a146	1a		inc a				inc 	a
.a147	d0 01		bne $a14a			bne 	_RGINoCarry
.a149	e8		inx				inx
.a14a					_RGINoCarry:
.a14a	8d b5 05	sta $05b5			sta 	GXHandler
.a14d	8e b6 05	stx $05b6			stx 	GXHandler+1
.a150					_RGICommandLoop:
.a150	b1 30		lda ($30),y			lda 	(codePtr),y
.a152	c8		iny				iny
.a153	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a155	f0 53		beq $a1aa			beq 	_RGI_To
.a157	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a159	f0 55		beq $a1b0			beq 	_RGI_Here
.a15b	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a15d	f0 3d		beq $a19c			beq 	_RGI_Exit
.a15f	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a161	f0 39		beq $a19c			beq 	_RGI_Exit
.a163	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a165	f0 3e		beq $a1a5			beq 	_RGI_Frame
.a167	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a169	f0 33		beq $a19e			beq 	_RGI_Solid
.a16b	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a16d	f0 4b		beq $a1ba			beq 	_RGI_By
.a16f	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a171	f0 17		beq $a18a			beq 	_RGI_Move2
.a173	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a175	f0 62		beq $a1d9			beq 	_RGI_Dim
.a177	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a179	f0 74		beq $a1ef			beq 	_RGI_Colour
.a17b	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a17d	f0 70		beq $a1ef			beq 	_RGI_Colour
.a17f	ae b0 05	ldx $05b0			ldx 	gxCommandID
.a182	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a184	d0 03		bne $a189			bne 	_RGI_Move 					; move
.a186	4c 17 a2	jmp $a217			jmp		_RGI_SpriteInstructions
.a189					_RGI_Move:
.a189	88		dey				dey 								; unpick get.
.a18a					_RGI_Move2:
.a18a	20 3d a2	jsr $a23d			jsr 	GCGetCoordinatePair 		; move to here
.a18d	20 64 a2	jsr $a264			jsr 	GCCopyPairToStore 			; save
.a190	5a		phy				phy
.a191	20 5a a2	jsr $a25a			jsr 	GCLoadAXY 					; load in
.a194	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a196	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a199	7a		ply				ply
.a19a	80 b4		bra $a150			bra 	_RGICommandLoop 			; and go round
.a19c					_RGI_Exit:
.a19c	88		dey				dey 								; unpick : / EOL
.a19d	60		rts				rts
.a19e					_RGI_Solid:
.a19e	a9 02		lda #$02			lda 	#2
.a1a0	8d b1 05	sta $05b1			sta 	gxFillSolid
.a1a3	80 ab		bra $a150			bra 	_RGICommandLoop
.a1a5					_RGI_Frame:
.a1a5	9c b1 05	stz $05b1			stz 	gxFillSolid
.a1a8	80 a6		bra $a150			bra 	_RGICommandLoop
.a1aa					_RGI_To:
.a1aa	20 3d a2	jsr $a23d			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a1ad	20 64 a2	jsr $a264			jsr 	GCCopyPairToStore
.a1b0					_RGI_Here:
.a1b0	5a		phy				phy
.a1b1	20 5a a2	jsr $a25a			jsr 	GCLoadAXY 					; load it into AXY
.a1b4	20 14 a2	jsr $a214			jsr 	_RGICallHandler 			; go do whatever it is.
.a1b7	7a		ply				ply
.a1b8	80 96		bra $a150			bra 	_RGICommandLoop 			; and go round
.a1ba					_RGI_By:
.a1ba	20 4a a2	jsr $a24a			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a1bd	18		clc				clc
.a1be	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a1c0	6d b2 05	adc $05b2			adc 	gxxPos
.a1c3	8d b2 05	sta $05b2			sta 	gxXPos
.a1c6	a5 61		lda $61				lda 	NSMantissa1+1
.a1c8	6d b3 05	adc $05b3			adc 	gxxPos+1
.a1cb	8d b3 05	sta $05b3			sta 	gxXPos+1
.a1ce	a5 5a		lda $5a				lda 	NSMantissa0+2
.a1d0	18		clc				clc
.a1d1	6d b4 05	adc $05b4			adc 	gxYPos
.a1d4	8d b4 05	sta $05b4			sta 	gxYPos
.a1d7	80 d7		bra $a1b0			bra 	_RGI_Here
.a1d9					_RGI_Dim:
.a1d9	a2 01		ldx #$01			ldx	 	#1
.a1db	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger
.a1de	a5 59		lda $59				lda 	NSMantissa0+1
.a1e0	c9 00		cmp #$00			cmp 	#0
.a1e2	f0 2d		beq $a211			beq 	_RGIRange
.a1e4	c9 09		cmp #$09			cmp 	#8+1
.a1e6	b0 29		bcs $a211			bcs		_RGIRange
.a1e8	3a		dec a				dec 	a
.a1e9	8d b7 05	sta $05b7			sta 	gxDrawScale
.a1ec	4c 50 a1	jmp $a150			jmp 	_RGICommandLoop
.a1ef					_RGI_Colour:
.a1ef	a2 01		ldx #$01			ldx 	#1 							; colour
.a1f1	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger
.a1f4	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a1f6	20 97 9d	jsr $9d97			jsr 	NSMSetZero
.a1f9	b1 30		lda ($30),y			lda 	(codePtr),y
.a1fb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a1fd	d0 04		bne $a203			bne 	_RGICDefaultMode
.a1ff	c8		iny				iny
.a200	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger
.a203					_RGICDefaultMode:
.a203	5a		phy				phy
.a204	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a206	a6 59		ldx $59				ldx 	NSMantissa0+1
.a208	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a20a	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a20d	7a		ply				ply
.a20e	4c 50 a1	jmp $a150			jmp 	_RGICommandLoop 			; and go round
.a211					_RGIRange:
.a211	4c 1a 9f	jmp $9f1a			jmp 	RangeError
.a214					_RGICallHandler:
.a214	6c b5 05	jmp ($05b5)			jmp 	(GXHandler)
.a217					_RGI_SpriteInstructions:
.a217	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a219	f0 07		beq $a222			beq 	_RGISpriteOff
.a21b	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a21d	f0 13		beq $a232			beq 	_RGISetImage
.a21f	4c 89 a1	jmp $a189			jmp 	_RGI_Move
.a222					_RGISpriteOff:
.a222	5a		phy				phy
.a223	a0 01		ldy #$01			ldy 	#1
.a225	a2 00		ldx #$00			ldx 	#0
.a227					_RGIDoCommandLoop:
.a227	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a229	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a22c	7a		ply				ply
.a22d	b0 e2		bcs $a211			bcs 	_RGIRange
.a22f	4c 50 a1	jmp $a150			jmp 	_RGICommandLoop
.a232					_RGISetImage:
.a232	a2 01		ldx #$01			ldx 	#1
.a234	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger
.a237	5a		phy				phy
.a238	aa		tax				tax
.a239	a0 00		ldy #$00			ldy 	#0
.a23b	80 ea		bra $a227			bra 	_RGIDoCommandLoop
.a23d					GCGetCoordinatePair:
.a23d	a2 01		ldx #$01			ldx 	#1
.a23f	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger
.a242	20 79 8e	jsr $8e79			jsr 	CheckComma
.a245	e8		inx				inx
.a246	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger
.a249	60		rts				rts
.a24a					GCSignedCoordinatePair:
.a24a	a2 01		ldx #$01			ldx 	#1
.a24c	20 21 9d	jsr $9d21			jsr 	Evaluate16BitIntegerSigned
.a24f	20 79 8e	jsr $8e79			jsr 	CheckComma
.a252	e8		inx				inx
.a253	20 21 9d	jsr $9d21			jsr 	Evaluate16BitIntegerSigned
.a256	60		rts				rts
.a257					_GCCPRange:
.a257	4c 1a 9f	jmp $9f1a			jmp 	RangeError
.a25a					GCLoadAXY:
.a25a	ad b3 05	lda $05b3			lda 	gxXPos+1
.a25d	ae b2 05	ldx $05b2			ldx 	gxXPos
.a260	ac b4 05	ldy $05b4			ldy 	gxYPos
.a263	60		rts				rts
.a264					GCCopyPairToStore:
.a264	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a266	8d b2 05	sta $05b2			sta 	gxXPos
.a269	a5 61		lda $61				lda 	NSMantissa1+1
.a26b	8d b3 05	sta $05b3			sta 	gxXPos+1
.a26e	a5 5a		lda $5a				lda 	NSMantissa0+2
.a270	8d b4 05	sta $05b4			sta 	gxYPos
.a273	60		rts				rts
.05b0					gxCommandID:
>05b0							.fill 	1
.05b1					gxFillSolid:
>05b1							.fill 	1
.05b2					gxXPos:
>05b2							.fill 	2
.05b4					gxYPos:
>05b4							.fill 	1
.05b5					gxHandler:
>05b5							.fill 	2
.05b7					gxDrawScale:
>05b7							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a274					BitmapCtrl:
.a274	b1 30		lda ($30),y			lda 	(codePtr),y
.a276	c8		iny				iny
.a277	a2 01		ldx #$01			ldx 	#1
.a279	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a27b	f0 11		beq $a28e			beq 	BitmapSwitch
.a27d	ca		dex				dex
.a27e	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a280	f0 0c		beq $a28e			beq 	BitmapSwitch
.a282	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; get the colour
.a285	5a		phy				phy
.a286	aa		tax				tax
.a287	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a289	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a28c	7a		ply				ply
.a28d	60		rts				rts
.a28e					BitmapSwitch:
.a28e	5a		phy				phy
.a28f	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a291	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a293	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a296	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a298	a0 00		ldy #$00			ldy 	#0
.a29a	a2 ff		ldx #$ff			ldx 	#$FF
.a29c	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a29f	9c b1 05	stz $05b1			stz 	gxFillSolid
.a2a2	9c b2 05	stz $05b2			stz 	gxXPos
.a2a5	9c b3 05	stz $05b3			stz 	gxXPos+1
.a2a8	9c b4 05	stz $05b4			stz 	gxYPos
.a2ab	9c b7 05	stz $05b7			stz 	gxDrawScale
.a2ae	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a2b0	a2 00		ldx #$00			ldx 	#0
.a2b2	a0 00		ldy #$00			ldy 	#0
.a2b4	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2b7	7a		ply				ply
.a2b8	60		rts				rts
.a2b9					SpritesCtrl:
.a2b9	b1 30		lda ($30),y			lda 	(codePtr),y
.a2bb	c8		iny				iny
.a2bc	a2 01		ldx #$01			ldx 	#1
.a2be	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a2c0	f0 08		beq $a2ca			beq 	SpriteSwitch
.a2c2	ca		dex				dex
.a2c3	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a2c5	f0 03		beq $a2ca			beq 	SpriteSwitch
.a2c7	4c 15 9f	jmp $9f15			jmp 	SyntaxError
.a2ca					SpriteSwitch:
.a2ca	5a		phy				phy
.a2cb	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a2cd	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a2cf	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2d2	7a		ply				ply
.a2d3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a2d4					GfxCommand:
.a2d4	a2 00		ldx #$00			ldx 	#0
.a2d6	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; command
.a2d9	20 79 8e	jsr $8e79			jsr 	CheckComma
.a2dc	e8		inx				inx
.a2dd	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger 		; X
.a2e0	20 79 8e	jsr $8e79			jsr 	CheckComma
.a2e3	e8		inx				inx
.a2e4	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; Y
.a2e7	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a2e9	4a		lsr a				lsr 	a
.a2ea	d0 12		bne $a2fe			bne 	_GfxError
.a2ec	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a2ee	b0 0e		bcs $a2fe			bcs 	_GfxError 					; bit 7 should have been zero
.a2f0	5a		phy				phy 								; save pos
.a2f1	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a2f3	a6 59		ldx $59				ldx 	NSMantissa0+1
.a2f5	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2f7	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2fa	b0 02		bcs $a2fe			bcs 	_GfxError
.a2fc	7a		ply				ply 								; restore pos and exit.
.a2fd	60		rts				rts
.a2fe					_GfxError:
.a2fe	4c 1a 9f	jmp $9f1a			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a301					UnaryHit:
.a301	fa		plx				plx
.a302	a9 36		lda #$36			lda 	#zTemp0
.a304	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a307	20 79 8e	jsr $8e79			jsr 	CheckComma
.a30a	e8		inx				inx
.a30b	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a30e	20 71 8e	jsr $8e71			jsr		CheckRightBracket
.a311	ca		dex				dex 								; fix back up again.
.a312	da		phx				phx 								; save X/Y
.a313	5a		phy				phy
.a314	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a316	b5 58		lda $58,x			lda 	NSMantissa0,x
.a318	aa		tax				tax
.a319	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a31b	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a31e	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a31f	7a		ply				ply 								; restore XY
.a320	fa		plx				plx
.a321	20 99 9d	jsr $9d99			jsr 	NSMSetByte 					; return the hit result
.a324	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a325					PaletteCommand:
.a325	a2 00		ldx #$00			ldx 	#0
.a327	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; colour
.a32a	20 79 8e	jsr $8e79			jsr 	CheckComma
.a32d	e8		inx				inx
.a32e	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger 		; r
.a331	20 79 8e	jsr $8e79			jsr 	CheckComma
.a334	e8		inx				inx
.a335	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; g
.a338	20 79 8e	jsr $8e79			jsr 	CheckComma
.a33b	e8		inx				inx
.a33c	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; b
.a33f	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a341	85 36		sta $36				sta 	zTemp0
.a343	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a345	85 37		sta $37				sta 	zTemp0+1
.a347	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a349	26 37		rol $37				rol	 	zTemp0+1
.a34b	06 36		asl $36				asl 	zTemp0
.a34d	26 37		rol $37				rol	 	zTemp0+1
.a34f	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a351	85 01		sta $01				sta 	1
.a353	5a		phy				phy
.a354	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a356	92 36		sta ($36)			sta 	(zTemp0)
.a358	a0 01		ldy #$01			ldy 	#1
.a35a	a5 5a		lda $5a				lda 	NSMantissa0+2
.a35c	91 36		sta ($36),y			sta 	(zTemp0),y
.a35e	a5 59		lda $59				lda 	NSMantissa0+1
.a360	c8		iny				iny
.a361	91 36		sta ($36),y			sta 	(zTemp0),y
.a363	7a		ply				ply
.a364	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a365					UnaryEvent:
.a365	fa		plx				plx
.a366	20 13 a4	jsr $a413			jsr 	TimerToStackX 				; timer in +0
.a369	e8		inx				inx  								; put reference into +1
.a36a	20 d8 97	jsr $97d8			jsr 	EvaluateTerm
.a36d	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a36f	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a371	d0 4c		bne $a3bf			bne 	_UEType
.a373	e8		inx				inx 								; put the step in +2
.a374	20 79 8e	jsr $8e79			jsr 	CheckComma
.a377	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger
.a37a	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.a37d	ca		dex				dex
.a37e	ca		dex				dex
.a37f	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a381	85 36		sta $36				sta 	zTemp0
.a383	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a385	85 37		sta $37				sta 	zTemp0+1
.a387	5a		phy				phy
.a388	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a38a	b1 36		lda ($36),y			lda 	(zTemp0),y
.a38c	30 2d		bmi $a3bb			bmi 	_UEFalse 					; exit if signed.
.a38e	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a390	b5 58		lda $58,x			lda 	NSMantissa0,x
.a392	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a394	c8		iny				iny
.a395	b5 60		lda $60,x			lda 	NSMantissa1,x
.a397	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a399	c8		iny				iny
.a39a	b5 68		lda $68,x			lda 	NSMantissa2,x
.a39c	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a39e	90 1b		bcc $a3bb			bcc 	_UEFalse 					; no, return FALSE.
.a3a0	18		clc				clc
.a3a1	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a3a3	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3a5	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a3a7	91 36		sta ($36),y			sta 	(zTemp0),y
.a3a9	c8		iny				iny
.a3aa	b5 60		lda $60,x			lda 	NSMantissa1,x
.a3ac	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a3ae	91 36		sta ($36),y			sta 	(zTemp0),y
.a3b0	c8		iny				iny
.a3b1	b5 68		lda $68,x			lda 	NSMantissa2,x
.a3b3	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a3b5	91 36		sta ($36),y			sta 	(zTemp0),y
.a3b7	7a		ply				ply
.a3b8	4c f7 8e	jmp $8ef7			jmp 	ReturnTrue
.a3bb					_UEFalse:
.a3bb	7a		ply				ply 								; restore Y
.a3bc	4c 02 8f	jmp $8f02			jmp 	ReturnFalse 				; and return False
.a3bf					_UEType:
.a3bf	4c 1f 9f	jmp $9f1f			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a3c2					UnaryJoyX:
.a3c2	18		clc				clc
.a3c3	80 01		bra $a3c6			bra 	JoyMain
.a3c5					UnaryJoyY:
.a3c5	38		sec				sec
.a3c6					JoyMain:
.a3c6	fa		plx				plx 								; get pos
.a3c7	08		php				php 								; save carry (set for Y)
.a3c8	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a3cb	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.a3ce	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a3d1	28		plp				plp
.a3d2	90 02		bcc $a3d6			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a3d4	4a		lsr a				lsr 	a
.a3d5	4a		lsr a				lsr 	a
.a3d6					_JMNoShift:
.a3d6	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a3d7	b0 0a		bcs $a3e3			bcs 	_JMIsRight
.a3d9	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a3da	b0 04		bcs $a3e0			bcs 	_JMIsLeft
.a3dc	20 97 9d	jsr $9d97			jsr 	NSMSetZero 					; zero result
.a3df	60		rts				rts
.a3e0					_JMIsLeft:
.a3e0	4c f7 8e	jmp $8ef7			jmp 	ReturnTrue
.a3e3					_JMIsRight:
.a3e3	a9 01		lda #$01			lda 	#1
.a3e5	20 99 9d	jsr $9d99			jsr 	NSMSetByte
.a3e8	60		rts				rts
.a3e9					UnaryJoyB:
.a3e9	fa		plx				plx 								; get pos
.a3ea	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a3ed	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.a3f0	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a3f3	4a		lsr a				lsr 	a
.a3f4	4a		lsr a				lsr 	a
.a3f5	4a		lsr a				lsr 	a
.a3f6	4a		lsr a				lsr 	a
.a3f7	29 01		and #$01			and 	#1
.a3f9	20 99 9d	jsr $9d99			jsr 	NSMSetByte
.a3fc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a3fd					LoadCommand:
.a3fd	20 6f 89	jsr $896f			jsr 	NewProgram
.a400	20 ae 82	jsr $82ae			jsr 	BackLoadProgram
.a403	4c 46 83	jmp $8346			jmp 	WarmStart
.a406					GoCommand:
.a406	20 6f 89	jsr $896f			jsr 	NewProgram
.a409	20 ae 82	jsr $82ae			jsr 	BackLoadProgram
.a40c	4c ab 8a	jmp $8aab			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a40f					UnaryTimer:
.a40f	fa		plx				plx
.a410	20 71 8e	jsr $8e71			jsr 	CheckRightBracket
.a413					TimerToStackX:
.a413	20 97 9d	jsr $9d97			jsr 	NSMSetZero 					; zero result
.a416	64 01		stz $01				stz 	1 							; access I/O
.a418	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a41b	95 58		sta $58,x			sta 	NSMantissa0,x
.a41d	ad 5a d6	lda $d65a			lda 	$D65A
.a420	95 60		sta $60,x			sta 	NSMantissa1,x
.a422	ad 5b d6	lda $d65b			lda 	$D65B
.a425	95 68		sta $68,x			sta 	NSMantissa2,x
.a427	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a428					MemoryDeleteLine:
.a428	20 47 a4	jsr $a447			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a42b	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a42d	a8		tay				tay
.a42e					_MDDLLoop:
.a42e	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a430	92 30		sta ($30)			sta 	(codePtr)
.a432	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a434	c5 3a		cmp $3a				cmp 	zTemp2
.a436	d0 07		bne $a43f			bne 	_MDLDLNext
.a438	a5 31		lda $31				lda 	codePtr+1
.a43a	c5 3b		cmp $3b				cmp 	zTemp2+1
.a43c	d0 01		bne $a43f			bne 	_MDLDLNext
.a43e					_MDDLExit:
.a43e	60		rts				rts
.a43f					_MDLDLNext:
.a43f	e6 30		inc $30				inc 	codePtr						; next byte
.a441	d0 eb		bne $a42e			bne 	_MDDLLoop
.a443	e6 31		inc $31				inc 	codePtr+1
.a445	80 e7		bra $a42e			bra 	_MDDLLoop
.a447					IMemoryFindEnd:
.a447	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a449	85 3a		sta $3a				sta 	0+zTemp2
.a44b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a44d	85 3b		sta $3b				sta 	1+zTemp2
.a44f					_MDLFELoop:
.a44f	b2 3a		lda ($3a)			lda 	(zTemp2)
.a451	f0 0b		beq $a45e			beq 	_MDLFEExit
.a453	18		clc				clc
.a454	65 3a		adc $3a				adc 	zTemp2
.a456	85 3a		sta $3a				sta 	zTemp2
.a458	90 f5		bcc $a44f			bcc 	_MDLFELoop
.a45a	e6 3b		inc $3b				inc 	zTemp2+1
.a45c	80 f1		bra $a44f			bra 	_MDLFELoop
.a45e					_MDLFEExit:
.a45e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a45f					MemoryInsertLine:
.a45f	08		php				php
.a460	20 47 a4	jsr $a447			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a463	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a465	1a		inc a				inc 	a
.a466	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a468	b0 36		bcs $a4a0			bcs 	_MDLIError
.a46a	28		plp				plp
.a46b	90 08		bcc $a475			bcc 	_MDLIFound
.a46d	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a46f	85 30		sta $30				sta 	codePtr
.a471	a5 3b		lda $3b				lda 	zTemp2+1
.a473	85 31		sta $31				sta 	codePtr+1
.a475					_MDLIFound:
.a475	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a478	a8		tay				tay
.a479					_MDLIInsert:
.a479	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a47b	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a47d	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a47f	c5 3a		cmp $3a				cmp 	zTemp2
.a481	d0 06		bne $a489			bne 	_MDLINext
.a483	a5 31		lda $31				lda 	codePtr+1
.a485	c5 3b		cmp $3b				cmp 	zTemp2+1
.a487	f0 0a		beq $a493			beq 	_MDLIHaveSpace
.a489					_MDLINext:
.a489	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a48b	d0 02		bne $a48f			bne 	_MDLINoBorrow
.a48d	c6 3b		dec $3b				dec 	zTemp2+1
.a48f					_MDLINoBorrow:
.a48f	c6 3a		dec $3a				dec 	zTemp2
.a491	80 e6		bra $a479			bra 	_MDLIInsert
.a493					_MDLIHaveSpace:
.a493	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a496	88		dey				dey 								; from offset-1 to 0
.a497					_MDLICopy:
.a497	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a49a	91 30		sta ($30),y			sta 	(codePtr),y
.a49c	88		dey				dey
.a49d	10 f8		bpl $a497			bpl 	_MDLICopy
.a49f	60		rts				rts
.a4a0					_MDLIError:
.a4a0	a9 06		lda #$06		lda	#6
.a4a2	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.a4a5					MDLAppendLine:
.a4a5	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a4a7	85 36		sta $36				sta 	zTemp0
.a4a9	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4ab	85 38		sta $38				sta 	0+zTemp1
.a4ad	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4af	85 39		sta $39				sta 	1+zTemp1
.a4b1	b2 38		lda ($38)			lda 	(zTemp1)
.a4b3	d0 0a		bne $a4bf			bne 	_MDLANoInitialise
.a4b5	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4b7	8d b8 05	sta $05b8			sta 	0+AppendPointer
.a4ba	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4bc	8d b9 05	sta $05b9			sta 	1+AppendPointer
.a4bf					_MDLANoInitialise:
.a4bf	18		clc				clc
.a4c0	ad b8 05	lda $05b8			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a4c3	85 38		sta $38				sta 	zTemp1
.a4c5	72 36		adc ($36)			adc 	(zTemp0)
.a4c7	8d b8 05	sta $05b8			sta 	AppendPointer
.a4ca	ad b9 05	lda $05b9			lda 	AppendPointer+1
.a4cd	85 39		sta $39				sta 	zTemp1+1
.a4cf	69 00		adc #$00			adc 	#0
.a4d1	8d b9 05	sta $05b9			sta 	AppendPointer+1
.a4d4	a0 00		ldy #$00			ldy 	#0
.a4d6					_MDLACopy:
.a4d6	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a4d8	91 38		sta ($38),y			sta 	(zTemp1),y
.a4da	c8		iny				iny
.a4db	98		tya				tya
.a4dc	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a4de	d0 f6		bne $a4d6			bne 	_MDLACopy
.a4e0	a9 00		lda #$00			lda 	#0 							; end of program.
.a4e2	91 38		sta ($38),y			sta 	(zTemp1),y
.a4e4	60		rts				rts
.05b8					AppendPointer:
>05b8							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a4e5					MemoryNew:
.a4e5	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4e7	85 30		sta $30				sta 	codePtr
.a4e9	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4eb	85 31		sta $31				sta 	codePtr+1
.a4ed	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a4ef	92 30		sta ($30)			sta 	(codePtr)
.a4f1	60		rts				rts
.a4f2					MemoryInline:
.a4f2	98		tya				tya 								; put address into stack,x
.a4f3	18		clc				clc  								; get the offset, add codePtr
.a4f4	65 30		adc $30				adc 	codePtr
.a4f6	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a4f8	a5 31		lda $31				lda 	codePtr+1
.a4fa	69 00		adc #$00			adc 	#0
.a4fc	95 60		sta $60,x			sta 	NSMantissa1,x
.a4fe	74 68		stz $68,x			stz 	NSMantissa2,x
.a500	74 70		stz $70,x			stz 	NSMantissa3,x
.a502	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a503					MemorySearch:
.a503	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a505	86 37		stx $37				stx 	zTemp0+1
.a507	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a509	85 30		sta $30				sta 	codePtr
.a50b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a50d	85 31		sta $31				sta 	codePtr+1
.a50f					_MTAXLoop:
.a50f	b2 30		lda ($30)			lda 	(codePtr)
.a511	18		clc				clc
.a512	f0 21		beq $a535			beq 	_MTAXExit 					; reached end, exit with CC.
.a514	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a516	b1 30		lda ($30),y			lda 	(codePtr),y
.a518	38		sec				sec
.a519	e5 36		sbc $36				sbc 	zTemp0
.a51b	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a51d	c8		iny				iny 								; do the MSB
.a51e	b1 30		lda ($30),y			lda 	(codePtr),y
.a520	e5 37		sbc $37				sbc 	zTemp0+1
.a522	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a524	f0 0f		beq $a535			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a526	b0 0d		bcs $a535			bcs 	_MTAXExit 					; current < required exit
.a528	18		clc				clc
.a529	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a52b	65 30		adc $30				adc 	codePtr
.a52d	85 30		sta $30				sta 	codePtr
.a52f	90 02		bcc $a533			bcc 	_CREExit
.a531	e6 31		inc $31				inc 	codePtr+1 					; carry
.a533					_CREExit:
.a533	80 da		bra $a50f			bra 	_MTAXLoop
.a535					_MTAXExit:
.a535	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a536					UnaryPlaying:
.a536	fa		plx				plx
.a537	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; get channel #
.a53a	48		pha				pha
.a53b	20 71 8e	jsr $8e71			jsr		CheckRightBracket
.a53e	68		pla				pla
.a53f	c9 04		cmp #$04			cmp 	#4
.a541	b0 0c		bcs $a54f			bcs 	_UPNotPlaying
.a543	09 20		ora #$20			ora 	#$20 						; query playing ?
.a545	20 18 80	jsr $8018			jsr 	SNDCommand
.a548	c9 00		cmp #$00			cmp 	#0
.a54a	f0 03		beq $a54f			beq 	_UPNotPlaying
.a54c	4c f7 8e	jmp $8ef7			jmp 	ReturnTrue
.a54f					_UPNotPlaying:
.a54f	4c 02 8f	jmp $8f02			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a552					SoundCommand:
.a552	b1 30		lda ($30),y			lda 	(codePtr),y
.a554	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a556	d0 09		bne $a561			bne 	_SNDMain
.a558	c8		iny				iny 								; skip OFF
.a559	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a55b	5a		phy				phy
.a55c	20 18 80	jsr $8018			jsr 	SNDCommand
.a55f	7a		ply				ply
.a560	60		rts				rts
.a561					_SNDMain:
.a561	a2 00		ldx #$00			ldx 	#0
.a563	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; channel
.a566	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a568	b0 4b		bcs $a5b5			bcs 	_SndError
.a56a	e8		inx				inx 								; do the rest in slot 1.
.a56b	20 79 8e	jsr $8e79			jsr 	CheckComma
.a56e	20 17 9d	jsr $9d17			jsr 	Evaluate16BitInteger 		; Pitch
.a571	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a573	c9 10		cmp #$10			cmp 	#16
.a575	b0 3e		bcs $a5b5			bcs 	_SndError
.a577	8d bb 05	sta $05bb			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a57a	b5 58		lda $58,x			lda 	NSMantissa0,x
.a57c	8d ba 05	sta $05ba			sta 	SoundCommandBlock
.a57f	20 79 8e	jsr $8e79			jsr 	CheckComma
.a582	20 32 9d	jsr $9d32			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a585	8d bd 05	sta $05bd			sta 	SoundCommandBlock+3
.a588	a9 0f		lda #$0f			lda 	#15
.a58a	8d bc 05	sta $05bc			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a58d	9c be 05	stz $05be			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a590	9c bf 05	stz $05bf			stz 	SoundCommandBlock+5
.a593	b1 30		lda ($30),y			lda 	(codePtr),y
.a595	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a597	d0 0e		bne $a5a7			bne 	_SNDPlay
.a599	c8		iny				iny
.a59a	20 21 9d	jsr $9d21			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a59d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a59f	8d be 05	sta $05be			sta 	SoundCommandBlock+4
.a5a2	b5 60		lda $60,x			lda 	NSMantissa1,x
.a5a4	8d bf 05	sta $05bf			sta 	SoundCommandBlock+5
.a5a7					_SNDPlay:
.a5a7	5a		phy				phy
.a5a8	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a5aa	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a5ac	a2 ba		ldx #$ba			ldx 	#(SoundCommandBlock & $FF)
.a5ae	a0 05		ldy #$05			ldy 	#(SoundCommandBlock >> 8)
.a5b0	20 18 80	jsr $8018			jsr 	SNDCommand
.a5b3	7a		ply				ply
.a5b4	60		rts				rts
.a5b5					_SndError:
.a5b5	4c 1a 9f	jmp $9f1a			jmp 	RangeError
.05ba					SoundCommandBlock:
>05ba							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a5b8					StackPushByte:
.a5b8	48		pha				pha 								; save byte on stack
.a5b9	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a5bb	d0 08		bne $a5c5			bne 	_SPBNoBorrow
.a5bd	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a5bf	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a5c1	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a5c3	90 06		bcc $a5cb			bcc 	_SPBMemory
.a5c5					_SPBNoBorrow:
.a5c5	c6 34		dec $34				dec 	BasicStack
.a5c7	68		pla				pla 								; get back and write
.a5c8	92 34		sta ($34)			sta 	(BasicStack)
.a5ca	60		rts				rts
.a5cb					_SPBMemory:
.a5cb	a9 12		lda #$12		lda	#18
.a5cd	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.a5d0					StackPopByte:
.a5d0	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a5d2	e6 34		inc $34				inc 	BasicStack
.a5d4	d0 02		bne $a5d8			bne 	_SPBNoCarry
.a5d6	e6 35		inc $35				inc 	BasicStack+1
.a5d8					_SPBNoCarry:
.a5d8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a5d9					StackOpen:
.a5d9	48		pha				pha 								; save frame byte
.a5da	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a5dc	0a		asl a				asl 	a 							; claim twice this for storage
.a5dd	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a5df	38		sec				sec 								; so basically subtracting from
.a5e0	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a5e2	85 34		sta $34				sta 	basicStack
.a5e4	b0 09		bcs $a5ef			bcs 	_SONoBorrow
>a5e6	db						.byte 	$DB 						; causes a break in the emulator
.a5e7	c6 35		dec $35				dec 	basicStack+1
.a5e9	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a5eb	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a5ed	90 04		bcc $a5f3			bcc 	_SOMemory
.a5ef					_SONoBorrow:
.a5ef	68		pla				pla 								; get marker back and write at TOS
.a5f0	92 34		sta ($34)			sta 	(basicStack)
.a5f2	60		rts				rts
.a5f3					_SOMemory:
.a5f3	a9 12		lda #$12		lda	#18
.a5f5	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.a5f8					StackClose:
.a5f8	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a5fa	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a5fc	0a		asl a				asl 	a 							; claim twice this.
.a5fd	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a5ff	85 34		sta $34				sta 	basicStack
.a601	90 02		bcc $a605			bcc 	_SCExit
.a603	e6 35		inc $35				inc 	basicStack+1
.a605					_SCExit:
.a605	60		rts				rts
.a606					StackCheckFrame:
.a606	48		pha				pha
.a607					_StackRemoveLocals:
.a607	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a609	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a60b	b0 05		bcs $a612			bcs 	_SCNoLocal
.a60d	20 1e 89	jsr $891e			jsr 	LocalPopValue 				; restore the local value
.a610	80 f5		bra $a607			bra 	_StackRemoveLocals 			; gr round again
.a612					_SCNoLocal:
.a612	68		pla				pla 								; get the frame check.
.a613	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a615	29 f0		and #$f0			and 	#$F0 						; check type bits
.a617	d0 01		bne $a61a			bne 	_SCFError 					; different, we have structures mixed up
.a619	60		rts				rts
.a61a					_SCFError:
.a61a	8a		txa				txa 								; report error X
.a61b	4c 8a 8e	jmp $8e8a			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a61e					STKSaveCodePosition:
.a61e	5a		phy				phy
.a61f	98		tya				tya 								; save Y
.a620	a0 05		ldy #$05			ldy 	#5
.a622	91 34		sta ($34),y			sta 	(basicStack),y
.a624	88		dey				dey 								; save Code Pointer
.a625					_STKSaveLoop:
.a625	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a628	91 34		sta ($34),y			sta 	(basicStack),y
.a62a	88		dey				dey
.a62b	d0 f8		bne $a625			bne 	_STKSaveLoop
.a62d	7a		ply				ply
.a62e	60		rts				rts
.a62f					STKLoadCodePosition:
.a62f	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a631					_STKLoadLoop:
.a631	b1 34		lda ($34),y			lda 	(basicStack),y
.a633	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a636	c8		iny				iny
.a637	c0 05		cpy #$05			cpy 	#5
.a639	d0 f6		bne $a631			bne 	_STKLoadLoop
.a63b	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a63d	a8		tay				tay
.a63e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a63f					StackReset:
.a63f	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a641	85 34		sta $34				sta 	0+basicStack
.a643	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a645	85 35		sta $35				sta 	1+basicStack
.a647	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a649	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a64b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a64c					StringConcrete:
.a64c	5a		phy				phy 								; save position on stack
.a64d	20 bf 99	jsr $99bf			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a650	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a652	85 38		sta $38				sta 	zTemp1
.a654	b5 60		lda $60,x			lda 	NSMantissa1,x
.a656	85 39		sta $39				sta 	zTemp1+1
.a658	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a65a					_SALength:
.a65a	c8		iny				iny
.a65b	b1 38		lda ($38),y			lda 	(zTemp1),y
.a65d	d0 fb		bne $a65a			bne 	_SALength
.a65f	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a661	b0 3d		bcs $a6a0			bcs 	_SALengthError
.a663	98		tya				tya 				 				; length of the new string
.a664	18		clc				clc
.a665	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a667	90 02		bcc $a66b			bcc 	_SAHaveLength
.a669	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a66b					_SAHaveLength:
.a66b	48		pha				pha 								; save length.
.a66c	38		sec				sec
.a66d	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a66f	6d 0e 04	adc $040e			adc 	StringMemory
.a672	8d 0e 04	sta $040e			sta 	StringMemory
.a675	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a677	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a679	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a67b	6d 0f 04	adc $040f			adc 	StringMemory+1
.a67e	8d 0f 04	sta $040f			sta 	StringMemory+1
.a681	85 3b		sta $3b				sta 	zTemp2+1
.a683	95 60		sta $60,x			sta 	NSMantissa1,x
.a685	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a686	38		sec				sec
.a687	e9 03		sbc #$03			sbc 	#3
.a689	92 3a		sta ($3a)			sta 	(zTemp2)
.a68b	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a68d	a0 01		ldy #$01			ldy 	#1
.a68f	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a691					_SACopyNewString:
.a691	a0 00		ldy #$00			ldy 	#0
.a693					_SACopyNSLoop:
.a693	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a695	c8		iny				iny 								; write two on in string storage
.a696	c8		iny				iny
.a697	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a699	88		dey				dey 								; this makes it one one.
.a69a	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a69c	d0 f5		bne $a693			bne 	_SACopyNSLoop
.a69e	7a		ply				ply
.a69f	60		rts				rts
.a6a0					_SALengthError:
.a6a0	a9 09		lda #$09		lda	#9
.a6a2	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a6a5					StringSystemInitialise:
.a6a5	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a6a7	8d 0e 04	sta $040e			sta 	0+StringMemory
.a6aa	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a6ac	8d 0f 04	sta $040f			sta 	1+StringMemory
.a6af	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a6b2	60		rts				rts
.a6b3					StringSpaceInitialise:
.a6b3	20 bf 99	jsr $99bf			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a6b6	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a6b8	8d 10 04	sta $0410			sta 	StringInitialised
.a6bb	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a6be	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a6c1	ad 0f 04	lda $040f			lda 	StringMemory+1
.a6c4	3a		dec a				dec 	a
.a6c5	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a6c8	60		rts				rts
.a6c9					StringTempAllocate:
.a6c9	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a6cb	b0 30		bcs $a6fd			bcs 	_STALength
.a6cd	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a6d0	30 05		bmi $a6d7			bmi 	_STAAllocate
.a6d2	48		pha				pha 								; save value to subtract.
.a6d3	20 b3 a6	jsr $a6b3			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a6d6	68		pla				pla 								; restore it
.a6d7					_STAAllocate:
.a6d7	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a6d9	18		clc				clc  								; deliberate allows one more
.a6da	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a6dd	8d 11 04	sta $0411			sta 	StringTempPointer
.a6e0	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a6e2	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a6e4	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a6e7	69 ff		adc #$ff			adc 	#$FF
.a6e9	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a6ec	85 3d		sta $3d				sta 	zsTemp+1
.a6ee	95 60		sta $60,x			sta 	NSMantissa1,x
.a6f0	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a6f2	74 70		stz $70,x			stz 	NSMantissa3,x
.a6f4	a9 10		lda #$10			lda 	#NSTString
.a6f6	95 50		sta $50,x			sta 	NSStatus,x
.a6f8	a9 00		lda #$00			lda 	#0 							; clear the target string
.a6fa	92 3c		sta ($3c)			sta 	(zsTemp)
.a6fc	60		rts				rts
.a6fd					_STALength:
.a6fd	a9 09		lda #$09		lda	#9
.a6ff	4c 8a 8e	jmp $8e8a		jmp	ErrorHandler
.a702					StringTempWrite:
.a702	48		pha				pha
.a703	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a705	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a707	d0 02		bne $a70b			bne 	_STWNoCarry
.a709	e6 3d		inc $3d				inc 	zsTemp+1
.a70b					_STWNoCarry:
.a70b	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a70d	92 3c		sta ($3c)			sta 	(zsTemp)
.a70f	68		pla				pla
.a710	60		rts				rts

;******  Return to file: _basic.asm

.a711					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a711					Export_EXTPrintCharacter:
.a711					PAGEDPrintCharacter:
.a711	48		pha				pha
.a712	da		phx				phx
.a713	5a		phy				phy
.a714	a6 01		ldx $01				ldx 	1
.a716	da		phx				phx
.a717	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a71a	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a71c	30 48		bmi $a766			bmi 	_EXPCColour
.a71e	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a720	90 4d		bcc $a76f			bcc 	_EXPCControl
.a722	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a724	86 01		stx $01				stx 	1
.a726	91 40		sta ($40),y			sta 	(EXTAddress),y
.a728	e6 01		inc $01				inc 	1 							; select colour memory
.a72a	ad c2 05	lda $05c2			lda 	EXTTextColour
.a72d	91 40		sta ($40),y			sta 	(EXTAddress),y
.a72f	c8		iny				iny 								; advance horizontal position
.a730	8c c1 05	sty $05c1			sty 	EXTColumn
.a733	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; reached RHS ?
.a736	90 63		bcc $a79b			bcc 	_EXPCExit 					; no, then exit.
.a738					_EXPCCRLF:
.a738	ee c0 05	inc $05c0			inc 	EXTRow  					; bump row
.a73b	9c c1 05	stz $05c1			stz 	EXTColumn 					; back to column 0
.a73e	ad c0 05	lda $05c0			lda 	EXTRow 						; check if reached the bottom ?
.a741	cd c4 05	cmp $05c4			cmp 	EXTScreenHeight 			; if so, then scroll.
.a744	f0 18		beq $a75e			beq 	_EXPCScroll
.a746	18		clc				clc 								; add width to address.
.a747	a5 40		lda $40				lda 	EXTAddress
.a749	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a74c	85 40		sta $40				sta 	EXTAddress
.a74e	90 4b		bcc $a79b			bcc 	_EXPCExit
.a750	e6 41		inc $41				inc 	EXTAddress+1
.a752	80 47		bra $a79b			bra 	_EXPCExit
.a754					_EXPCLeft:
.a754	ce c1 05	dec $05c1			dec 	EXTColumn
.a757	10 42		bpl $a79b			bpl 	_EXPCExit
.a759					_EXPCBegin:
.a759	9c c1 05	stz $05c1			stz 	EXTColumn
.a75c	80 3d		bra $a79b			bra 	_EXPCExit
.a75e					_EXPCScroll:
.a75e	ce c0 05	dec $05c0			dec 	EXTRow 						; the height-1 th line.
.a761	20 4c a8	jsr $a84c			jsr 	EXTScreenScroll 			; scroll the screen
.a764	80 35		bra $a79b			bra 	_EXPCExit
.a766					_EXPCColour:
.a766	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a768	b0 31		bcs $a79b			bcs 	_EXPCExit
.a76a	20 2c a8	jsr $a82c			jsr 	_EXPCHandleColour
.a76d	80 2c		bra $a79b			bra 	_EXPCExit
.a76f					_EXPCControl:
.a76f	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a771	b0 28		bcs $a79b			bcs 	_EXPCExit
.a773	0a		asl a				asl 	a 							; double into X
.a774	aa		tax				tax
.a775	7c 0a a8	jmp ($a80a,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a778					_EXPCUp:
.a778	ad c0 05	lda $05c0			lda 	EXTRow 						; already at top ?
.a77b	f0 1e		beq $a79b			beq 	_EXPCExit
.a77d	ce c0 05	dec $05c0			dec 	EXTRow 						; up one in position/address
.a780	38		sec				sec
.a781	a5 40		lda $40				lda 	EXTAddress
.a783	ed c3 05	sbc $05c3			sbc 	EXTScreenWidth
.a786	85 40		sta $40				sta 	EXTAddress
.a788	b0 11		bcs $a79b			bcs 	_EXPCExit
.a78a	c6 41		dec $41				dec 	EXTAddress+1
.a78c	80 0d		bra $a79b			bra 	_EXPCExit
.a78e					_EXPCRight:
.a78e	c8		iny				iny
.a78f	8c c1 05	sty $05c1			sty 	EXTColumn
.a792	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a795	d0 04		bne $a79b			bne 	_EXPCExit
.a797	88		dey				dey
.a798					_EXPCSetColumnY:
.a798	8c c1 05	sty $05c1			sty 	EXTColumn
.a79b					_EXPCExit:
.a79b	20 a1 a8	jsr $a8a1			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a79e	68		pla				pla
.a79f	85 01		sta $01				sta 	1
.a7a1	7a		ply				ply
.a7a2	fa		plx				plx
.a7a3	68		pla				pla
.a7a4	60		rts				rts
.a7a5					_EXPCClearScreen:
.a7a5	20 5e a8	jsr $a85e			jsr		EXTClearScreenCode
.a7a8	80 f1		bra $a79b			bra 	_EXPCExit
.a7aa					_EXPCDown:
.a7aa	ad c4 05	lda $05c4			lda 	EXTScreenHeight 			; at the bottom
.a7ad	3a		dec a				dec 	a
.a7ae	cd c0 05	cmp $05c0			cmp 	EXTRow
.a7b1	f0 e8		beq $a79b			beq 	_EXPCExit
.a7b3	ee c0 05	inc $05c0			inc 	EXTRow 						; down one in position/address
.a7b6	18		clc				clc
.a7b7	a5 40		lda $40				lda 	EXTAddress
.a7b9	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a7bc	85 40		sta $40				sta 	EXTAddress
.a7be	90 db		bcc $a79b			bcc 	_EXPCExit
.a7c0	e6 41		inc $41				inc 	EXTAddress+1
.a7c2	80 d7		bra $a79b			bra 	_EXPCExit
.a7c4					_EXPCTab:
.a7c4	ad c1 05	lda $05c1			lda 	EXTColumn 					; next tab stop
.a7c7	29 f8		and #$f8			and 	#$F8
.a7c9	18		clc				clc
.a7ca	69 08		adc #$08			adc 	#8
.a7cc	8d c1 05	sta $05c1			sta 	EXTColumn
.a7cf	cd c3 05	cmp $05c3			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a7d2	90 c7		bcc $a79b			bcc 	_EXPCExit
.a7d4	80 10		bra $a7e6			bra 	_EXPCEnd
.a7d6					_EXPCBackSpace:
.a7d6	88		dey				dey
.a7d7	30 c2		bmi $a79b			bmi 	_EXPCExit
.a7d9	ce c1 05	dec $05c1			dec 	EXTColumn
.a7dc	a9 02		lda #$02			lda 	#2
.a7de	85 01		sta $01				sta 	1
.a7e0	a9 20		lda #$20			lda 	#32
.a7e2	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7e4	80 b5		bra $a79b			bra 	_EXPCExit
.a7e6					_EXPCEnd:
.a7e6	a9 02		lda #$02			lda 	#2 							; access text screen
.a7e8	85 01		sta $01				sta 	1
.a7ea	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; point to last character
.a7ed	88		dey				dey
.a7ee					_EXPCEndSearch:
.a7ee	88		dey				dey 								; if past start, move to col 0.
.a7ef	30 06		bmi $a7f7			bmi 	_EXPCFound
.a7f1	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a7f3	c9 20		cmp #$20			cmp 	#' '
.a7f5	f0 f7		beq $a7ee			beq 	_EXPCEndSearch
.a7f7					_EXPCFound:
.a7f7	c8		iny				iny 								; move to following cell.
.a7f8	80 9e		bra $a798			bra 	_EXPCSetColumnY
.a7fa					_EXPCClearEOL:
.a7fa	a9 02		lda #$02			lda 	#2 							; access character RAM
.a7fc	85 01		sta $01				sta 	1
.a7fe	a9 20		lda #$20			lda 	#' ' 						; write space
.a800	91 40		sta ($40),y			sta 	(EXTAddress),y
.a802	c8		iny				iny
.a803	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; until RHS of screen.
.a806	90 f2		bcc $a7fa			bcc 	_EXPCClearEOL
.a808	80 91		bra $a79b			bra 	_EXPCExit
.a80a					_EXPCActionTable:
>a80a	9b a7						.word 	_EXPCExit 					; 00
>a80c	59 a7						.word 	_EXPCBegin 					; 01 A Start of Line
>a80e	54 a7						.word 	_EXPCLeft 					; 02 B Left
>a810	9b a7						.word 	_EXPCExit 					; 03 <Break>
>a812	9b a7						.word 	_EXPCExit 					; 04
>a814	e6 a7						.word 	_EXPCEnd 					; 05 E End of Line
>a816	8e a7						.word 	_EXPCRight 					; 06 F Right
>a818	9b a7						.word 	_EXPCExit 					; 07
>a81a	d6 a7						.word 	_EXPCBackspace 				; 08 H Backspace
>a81c	c4 a7						.word 	_EXPCTab 					; 09 I Tab
>a81e	9b a7						.word 	_EXPCExit 					; 0A
>a820	fa a7						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a822	a5 a7						.word 	_EXPCClearScreen			; 0C L CLS
>a824	38 a7						.word 	_EXPCCRLF 					; 0D M CR/LF
>a826	aa a7						.word 	_EXPCDown 					; 0E N Down
>a828	9b a7						.word 	_EXPCExit 					; 0F
>a82a	78 a7						.word 	_EXPCUp 					; 10 P Up
.a82c					_EXPCHandleColour
.a82c	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a82e	b0 16		bcs $a846			bcs 	_EXPCBackground
.a830	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a831	0a		asl a				asl 	a
.a832	0a		asl a				asl 	a
.a833	0a		asl a				asl 	a
.a834	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a836					_EXPCUpdate:
.a836	48		pha				pha 								; save new colour
.a837	8a		txa				txa 								; get mask
.a838	2d c2 05	and $05c2			and 	EXTTextColour 				; mask out old.
.a83b	8d c2 05	sta $05c2			sta 	EXTTextColour
.a83e	68		pla				pla 								; or in new colour
.a83f	0d c2 05	ora $05c2			ora 	EXTTextColour
.a842	8d c2 05	sta $05c2			sta 	EXTTextColour
.a845	60		rts				rts
.a846					_EXPCBackground:
.a846	29 0f		and #$0f			and 	#$0F 						; get the colour
.a848	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a84a	80 ea		bra $a836			bra 	_EXPCUpdate
.a84c					EXTScreenScroll:
.a84c	a9 02		lda #$02			lda 	#2 							; select text page
.a84e	85 01		sta $01				sta 	1
.a850	a9 20		lda #$20			lda		#32 						; fill with space
.a852	20 65 a9	jsr $a965			jsr 	EXTScrollFill
.a855	e6 01		inc $01				inc 	1 							; select colour page
.a857	ad c2 05	lda $05c2			lda 	EXTTextColour
.a85a	20 65 a9	jsr $a965			jsr 	EXTScrollFill
.a85d	60		rts				rts
.a85e					EXTClearScreenCode:
.a85e	a9 02		lda #$02			lda 	#2 							; select text page
.a860	85 01		sta $01				sta 	1
.a862	a9 20		lda #$20			lda		#32 						; fill with space
.a864	20 71 a8	jsr $a871			jsr 	_EXTCSFill
.a867	e6 01		inc $01				inc 	1 							; select colour page
.a869	ad c2 05	lda $05c2			lda 	EXTTextColour
.a86c	20 71 a8	jsr $a871			jsr 	_EXTCSFill
.a86f	80 22		bra $a893			bra 	EXTHomeCursor
.a871					_EXTCSFill:
.a871	aa		tax				tax
.a872	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a874	85 40		sta $40				sta 	EXTAddress
.a876	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a878	85 41		sta $41				sta 	EXTAddress+1
.a87a					_EXTCSFill1:
.a87a	a0 00		ldy #$00			ldy 	#0
.a87c	8a		txa				txa
.a87d					_EXTCSFill2:
.a87d	91 40		sta ($40),y			sta 	(EXTAddress),y
.a87f	c8		iny				iny
.a880	d0 fb		bne $a87d			bne 	_EXTCSFill2
.a882	e6 41		inc $41				inc 	EXTAddress+1
.a884	a5 41		lda $41				lda 	EXTAddress+1
.a886	c9 d2		cmp #$d2			cmp 	#$D2
.a888	d0 f0		bne $a87a			bne 	_EXTCSFill1
.a88a	8a		txa				txa
.a88b					_EXTCSFill3:
.a88b	91 40		sta ($40),y			sta 	(EXTAddress),y
.a88d	c8		iny				iny
.a88e	c0 c0		cpy #$c0			cpy 	#$C0
.a890	d0 f9		bne $a88b			bne 	_EXTCSFill3
.a892	60		rts				rts
.a893					EXTHomeCursor:
.a893	9c c0 05	stz $05c0			stz 	EXTRow 						; reset row & column
.a896	9c c1 05	stz $05c1			stz 	EXTColumn
.a899	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a89b	85 40		sta $40				sta 	EXTAddress
.a89d	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a89f	85 41		sta $41				sta 	EXTAddress+1
.a8a1					EXTSetHardwareCursor:
.a8a1	64 01		stz $01				stz 	1 							; I/O Page zero
.a8a3	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a8a5	8d 10 d0	sta $d010			sta 	$D010
.a8a8	a9 b1		lda #$b1			lda 	#$B1
.a8aa	8d 12 d0	sta $d012			sta 	$D012
.a8ad	ad c1 05	lda $05c1			lda 	EXTColumn
.a8b0	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a8b3	9c 15 d0	stz $d015			stz 	$D015
.a8b6	ad c0 05	lda $05c0			lda 	EXTRow
.a8b9	8d 16 d0	sta $d016			sta 	$D016
.a8bc	9c 17 d0	stz $d017			stz 	$D017
.a8bf	60		rts				rts
.a8c0					Export_EXTInputLine:
.a8c0	48		pha				pha
.a8c1	da		phx				phx
.a8c2	5a		phy				phy
.a8c3	a5 01		lda $01				lda 	1 							; save I/O page
.a8c5	48		pha				pha
.a8c6					_EILLoop:
.a8c6	20 e0 a9	jsr $a9e0			jsr 	PagedInputSingleCharacter
.a8c9	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a8cb	f0 44		beq $a911			beq 	_EILExit
.a8cd	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a8cf	f0 2a		beq $a8fb			beq 	_EILDelete
.a8d1	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a8d3	f0 1c		beq $a8f1			beq 	_EILBackspace
.a8d5	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a8d7	90 12		bcc $a8eb			bcc 	_EILPrintLoop
.a8d9	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a8db	b0 0e		bcs $a8eb			bcs 	_EILPrintLoop
.a8dd	48		pha				pha 								; save character
.a8de	a9 02		lda #$02			lda 	#2  						; insert a space
.a8e0	85 01		sta $01				sta 	1
.a8e2	20 53 a9	jsr $a953			jsr 	EXTILInsert 				; insert in text screen
.a8e5	e6 01		inc $01				inc 	1
.a8e7	20 53 a9	jsr $a953			jsr 	EXTILInsert 				; insert in colour screen
.a8ea	68		pla				pla 								; get character back.
.a8eb					_EILPrintLoop:
.a8eb	20 11 a7	jsr $a711			jsr 	PagedPrintCharacter
.a8ee	80 d6		bra $a8c6			bra 	_EILLoop
.a8f0	60		rts				rts
.a8f1					_EILBackspace:
.a8f1	ad c1 05	lda $05c1			lda 	EXTColumn					; can we backspace ?
.a8f4	f0 d0		beq $a8c6			beq 	_EILLoop
.a8f6	a9 02		lda #$02			lda 	#2 							; move cursor left
.a8f8	20 11 a7	jsr $a711			jsr 	PagedPrintCharacter
.a8fb					_EILDelete
.a8fb	a9 02		lda #$02			lda 	#2 							; text block
.a8fd	85 01		sta $01				sta 	1
.a8ff	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a901	20 3e a9	jsr $a93e			jsr 	EXTILDelete
.a904	e6 01		inc $01				inc 	1 							; colour block
.a906	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; get attribute of last character
.a909	88		dey				dey
.a90a	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a90c	20 3e a9	jsr $a93e			jsr 	EXTILDelete 				; backspace attribute
.a90f	80 b5		bra $a8c6			bra 	_EILLoop 					; and go round.
.a911					_EILExit:
.a911	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a913	85 01		sta $01				sta 	1
.a915	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a917					_EILScrapeLine:
.a917	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a919	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a91c	c8		iny				iny
.a91d	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a920	d0 f5		bne $a917			bne 	_EILScrapeLine
.a922					_EILTrimSpaces:
.a922	88		dey				dey
.a923	f0 08		beq $a92d			beq 	_EILEndTrim
.a925	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.a928	c9 20		cmp #$20			cmp 	#' '
.a92a	f0 f6		beq $a922			beq 	_EILTrimSpaces
.a92c	c8		iny				iny 								; trim after non space character.
.a92d					_EILEndTrim:
.a92d	a9 00		lda #$00			lda 	#0 							; trim here.
.a92f	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a932	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a934	20 11 a7	jsr $a711			jsr 	PagedPrintCharacter
.a937	68		pla				pla 								; reset I/O page
.a938	85 01		sta $01				sta 	1
.a93a	7a		ply				ply
.a93b	fa		plx				plx
.a93c	68		pla				pla
.a93d	60		rts				rts
.a93e					EXTILDelete:
.a93e	48		pha				pha 								; save the new character
.a93f	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; start copying from here.
.a942					_EXTDLoop:
.a942	c8		iny				iny 								; copy one byte down.
.a943	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a945	88		dey				dey
.a946	91 40		sta ($40),y			sta 	(EXTAddress),y
.a948	c8		iny				iny 								; do till end of line.
.a949	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a94c	90 f4		bcc $a942			bcc 	_EXTDLoop
.a94e	88		dey				dey 	 							; write in last slot.
.a94f	68		pla				pla
.a950	91 40		sta ($40),y			sta 	(EXTAddress),y
.a952	60		rts				rts
.a953					EXTILInsert:
.a953	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; end position
.a956					_EXTILoop:
.a956	88		dey				dey 								; back one
.a957	cc c1 05	cpy $05c1			cpy 	EXTColumn 					; exit if reached insert point.
.a95a	f0 08		beq $a964			beq 	_EXTIExit
.a95c	88		dey				dey 								; copy one byte up.
.a95d	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a95f	c8		iny				iny
.a960	91 40		sta ($40),y			sta 	(EXTAddress),y
.a962	80 f2		bra $a956			bra 	_EXTILoop
.a964					_EXTIExit:
.a964	60		rts				rts
.a965					EXTScrollFill:
.a965	aa		tax				tax									; save value to fill with
.a966	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a968	48		pha				pha
.a969	a5 37		lda $37				lda 	zTemp0+1
.a96b	48		pha				pha
.a96c	a5 38		lda $38				lda 	zTemp1
.a96e	48		pha				pha
.a96f	a5 39		lda $39				lda 	zTemp1+1
.a971	48		pha				pha
.a972	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.a974	85 37		sta $37				sta 	zTemp0+1
.a976	85 39		sta $39				sta 	zTemp1+1
.a978	64 36		stz $36				stz 	zTemp0
.a97a	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a97d	85 38		sta $38				sta 	zTemp1
.a97f	a0 00		ldy #$00			ldy 	#0
.a981					_EXSFCopy1:
.a981	b1 38		lda ($38),y			lda 	(zTemp1),y
.a983	91 36		sta ($36),y			sta 	(zTemp0),y
.a985	c8		iny				iny
.a986	d0 f9		bne $a981			bne 	_EXSFCopy1
.a988	e6 37		inc $37				inc 	zTemp0+1 					; next page
.a98a	e6 39		inc $39				inc 	zTemp1+1
.a98c	a5 39		lda $39				lda 	zTemp1+1
.a98e	c9 d3		cmp #$d3			cmp 	#$D3
.a990	d0 ef		bne $a981			bne 	_EXSFCopy1
.a992	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; blank the bottom line.
.a995	8a		txa				txa
.a996					_EXSFFill1:
.a996	88		dey				dey
.a997	91 40		sta ($40),y			sta 	(EXTAddress),y
.a999	c0 00		cpy #$00			cpy 	#0
.a99b	10 f9		bpl $a996			bpl 	_EXSFFill1
.a99d	68		pla				pla
.a99e	85 39		sta $39				sta 	zTemp1+1
.a9a0	68		pla				pla
.a9a1	85 38		sta $38				sta 	zTemp1
.a9a3	68		pla				pla
.a9a4	85 37		sta $37				sta 	zTemp0+1
.a9a6	68		pla				pla
.a9a7	85 36		sta $36				sta 	zTemp0
.a9a9	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.05c0					EXTRow:
>05c0							.fill 	1
.05c1					EXTColumn:
>05c1							.fill 	1
.05c2					EXTTextColour:
>05c2							.fill 	1
.05c3					EXTScreenWidth:
>05c3							.fill 	1
.05c4					EXTScreenHeight:
>05c4							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.a9aa					Export_EXTInitialise:
.a9aa	64 01		stz $01				stz 	1 							; Access I/O page 0
.a9ac	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.a9af	9c 08 d0	stz $d008			stz 	$D008
.a9b2	9c 09 d0	stz $d009			stz 	$D009
.a9b5	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.a9b7	8d 58 d6	sta $d658			sta 	$D658
.a9ba	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.a9bc	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.a9be	ad 00 c0	lda $c000			lda 	$C000
.a9c1	8d c2 05	sta $05c2			sta 	EXTTextColour
.a9c4	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.a9c6	8d c3 05	sta $05c3			sta 	EXTScreenWidth
.a9c9	a9 3c		lda #$3c			lda 	#60
.a9cb	8d c4 05	sta $05c4			sta 	EXTScreenHeight
.a9ce	20 93 a8	jsr $a893			jsr 	EXTHomeCursor 				; home cursor
.a9d1					_EXMoveDown:
.a9d1	a9 0d		lda #$0d			lda 	#13
.a9d3	20 11 a7	jsr $a711			jsr 	PAGEDPrintCharacter
.a9d6	ad c0 05	lda $05c0			lda 	EXTRow
.a9d9	c9 06		cmp #$06			cmp 	#6
.a9db	d0 f4		bne $a9d1			bne 	_EXMoveDown
.a9dd	64 01		stz $01				stz 	1
.a9df	60		rts				rts
.a9e0					Export_EXTInputSingleCharacter:
.a9e0					PagedInputSingleCharacter:
.a9e0	da		phx				phx
.a9e1	5a		phy				phy
.a9e2					_EISCWait:
.a9e2	a5 01		lda $01				lda 	1 							; save I/O 0
.a9e4	48		pha				pha
.a9e5	64 01		stz $01				stz 	1 							; access I/O Page 0
.a9e7	38		sec				sec 								; calculate timer - LastTick
.a9e8	ad 59 d6	lda $d659			lda 	$D659
.a9eb	aa		tax				tax 								; saving timer in X
.a9ec	ed af 05	sbc $05af			sbc 	LastTick
.a9ef	c9 03		cmp #$03			cmp 	#3
.a9f1	90 06		bcc $a9f9			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.a9f3	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.a9f6	20 8c bd	jsr $bd8c			jsr 	PagedSNDUpdate 							; go do the code.
.a9f9					_NoFireTick:
.a9f9	68		pla				pla 								; restore I/O 0
.a9fa	85 01		sta $01				sta 	1
.a9fc	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.a9ff	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.aa01	f0 df		beq $a9e2			beq 	_EISCWait
.aa03	7a		ply				ply
.aa04	fa		plx				plx
.aa05	60		rts				rts
.aa06					Export_EXTBreakCheck:
.aa06	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aa09					Export_EXTReadController:
.aa09	da		phx				phx
.aa0a	a2 00		ldx #$00			ldx 	#0
.aa0c	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aa0e	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa11	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aa13	f0 04		beq $aa19			beq 	_NoSet1
.aa15	8a		txa				txa
.aa16	09 01		ora #$01			ora 	#1
.aa18	aa		tax				tax
.aa19					_NoSet1:
.aa19	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aa1b	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa1e	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aa20	f0 04		beq $aa26			beq 	_NoSet1
.aa22	8a		txa				txa
.aa23	09 02		ora #$02			ora 	#2
.aa25	aa		tax				tax
.aa26					_NoSet1:
.aa26	a9 06		lda #$06			lda 	#(($32) >> 3)
.aa28	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa2b	29 04		and #$04			and 	#($01 << (($32) & 7))
.aa2d	f0 04		beq $aa33			beq 	_NoSet1
.aa2f	8a		txa				txa
.aa30	09 04		ora #$04			ora 	#4
.aa32	aa		tax				tax
.aa33					_NoSet1:
.aa33	a9 04		lda #$04			lda 	#(($25) >> 3)
.aa35	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa38	29 20		and #$20			and 	#($01 << (($25) & 7))
.aa3a	f0 04		beq $aa40			beq 	_NoSet1
.aa3c	8a		txa				txa
.aa3d	09 08		ora #$08			ora 	#8
.aa3f	aa		tax				tax
.aa40					_NoSet1:
.aa40	a9 04		lda #$04			lda 	#(($26) >> 3)
.aa42	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa45	29 40		and #$40			and 	#($01 << (($26) & 7))
.aa47	f0 04		beq $aa4d			beq 	_NoSet1
.aa49	8a		txa				txa
.aa4a	09 10		ora #$10			ora 	#16
.aa4c	aa		tax				tax
.aa4d					_NoSet1:
.aa4d	8a		txa				txa
.aa4e	fa		plx				plx
.aa4f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.aa50					GRVectorTable:
>aa50	9f ac					.word	GXInitialise             ; $00 Initialise
>aa52	b9 ac					.word	GXControlBitmap          ; $01 BitmapCtl
>aa54	01 ad					.word	GXControlSprite          ; $02 SpriteCtl
>aa56	51 ac					.word	GXClearBitmap            ; $03 Clear
>aa58	90 ae					.word	GXSetColourMode          ; $04 Colour
>aa5a	58 b0					.word	GXFontHandler            ; $05 DrawFont
>aa5c	a0 b0					.word	GXSpriteHandler          ; $06 DrawSprite
>aa5e	11 b1					.word	GXSelect                 ; $07 SpriteUse
>aa60	3a b1					.word	GXSelectImage            ; $08 SpriteImage
>aa62	c1 b2					.word	GXCollide                ; $09 SpriteCollide
>aa64	03 ab					.word	GRUndefined              ; $0a
>aa66	03 ab					.word	GRUndefined              ; $0b
>aa68	03 ab					.word	GRUndefined              ; $0c
>aa6a	03 ab					.word	GRUndefined              ; $0d
>aa6c	03 ab					.word	GRUndefined              ; $0e
>aa6e	03 ab					.word	GRUndefined              ; $0f
>aa70	03 ab					.word	GRUndefined              ; $10
>aa72	03 ab					.word	GRUndefined              ; $11
>aa74	03 ab					.word	GRUndefined              ; $12
>aa76	03 ab					.word	GRUndefined              ; $13
>aa78	03 ab					.word	GRUndefined              ; $14
>aa7a	03 ab					.word	GRUndefined              ; $15
>aa7c	03 ab					.word	GRUndefined              ; $16
>aa7e	03 ab					.word	GRUndefined              ; $17
>aa80	03 ab					.word	GRUndefined              ; $18
>aa82	03 ab					.word	GRUndefined              ; $19
>aa84	03 ab					.word	GRUndefined              ; $1a
>aa86	03 ab					.word	GRUndefined              ; $1b
>aa88	03 ab					.word	GRUndefined              ; $1c
>aa8a	03 ab					.word	GRUndefined              ; $1d
>aa8c	03 ab					.word	GRUndefined              ; $1e
>aa8e	03 ab					.word	GRUndefined              ; $1f
>aa90	01 ab					.word	GXMove                   ; $20 Move
>aa92	5e ad					.word	GXLine                   ; $21 Line
>aa94	d9 ae					.word	GXFrameRectangle         ; $22 FrameRect
>aa96	d6 ae					.word	GXFillRectangle          ; $23 FillRect
>aa98	08 ab					.word	GXFrameCircle            ; $24 FrameCircle
>aa9a	04 ab					.word	GXFillCircle             ; $25 FillCircle
>aa9c	03 ab					.word	GRUndefined              ; $26
>aa9e	03 ab					.word	GRUndefined              ; $27
>aaa0	be ae					.word	GXPlotPoint              ; $28 Plot
>aaa2	d0 b1					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$57b					gxPixelBuffer = numberBuffer
.05c5					gxCurrentX:
>05c5							.fill 	2
.05c7					gxCurrentY:
>05c7							.fill 	2
.05c9					gxLastX:
>05c9							.fill 	2
.05cb					gxLastY:
>05cb							.fill 	2
.05cd					gxX0:
>05cd							.fill 	2
.05cf					gxY0:
>05cf							.fill 	2
.05d1					gxX1:
>05d1							.fill 	2
.05d3					gxY1:
>05d3							.fill 	2
.05d5					gxSpritesOn:
>05d5							.fill 	1
.05d6					gxBitmapsOn:
>05d6							.fill 	1
.05d7					gxBasePage:
>05d7							.fill 	1
.05d8					gxSpritePage:
>05d8							.fill 	1
.05d9					gxHeight:
>05d9							.fill 	1
.05da					gxMode:
>05da							.fill 	1
.05db					gxColour:
>05db							.fill 	1
.05dc					gxEORValue:
>05dc							.fill 	1
.05dd					gxANDValue:
>05dd							.fill 	1
.05de					gxOriginalLUTValue:
>05de							.fill 	1
.05df					gsOffset:
>05df							.fill 	1
.05e0					GSCurrentSpriteID:
>05e0							.fill 	1
.05e1					GSCurrentSpriteAddr:
>05e1							.fill 	2
.05e3					GXSpriteOffsetBase:
>05e3							.fill 	2
.05e5					GXSpriteLow:
>05e5							.fill 	64
.0625					GXSpriteHigh:
>0625							.fill 	64
.aaa4					Export_GXGraphicDraw:
.aaa4	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aaa6	b0 06		bcs $aaae			bcs 	_GDCoordinate
.aaa8	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aaaa	84 37		sty $37				sty 	gxzTemp0+1
.aaac	80 4b		bra $aaf9			bra 	_GDExecuteA 				; and execute
.aaae					_GDCoordinate:
.aaae	48		pha				pha 								; save AXY
.aaaf	da		phx				phx
.aab0	5a		phy				phy
.aab1	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aab3					_GDCopy1:
.aab3	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aab6	9d c9 05	sta $05c9,x			sta 	gxLastX,x
.aab9	ca		dex				dex
.aaba	10 f7		bpl $aab3			bpl 	_GDCopy1
.aabc	68		pla				pla 								; update Y
.aabd	8d c7 05	sta $05c7			sta 	gxCurrentY
.aac0	9c c8 05	stz $05c8			stz 	gxCurrentY+1
.aac3	68		pla				pla
.aac4	8d c5 05	sta $05c5			sta 	gxCurrentX
.aac7	68		pla				pla 								; get A (command+X.1) back
.aac8	48		pha				pha
.aac9	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aacb	8d c6 05	sta $05c6			sta 	gxCurrentX+1
.aace	68		pla				pla 								; get command back
.aacf	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aad1	48		pha				pha 								; push back.
.aad2	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aad4	f0 17		beq $aaed			beq 	_GDCopyToWorkArea
.aad6	ad c6 05	lda $05c6			lda 	gxCurrentX+1 				; X < 256 X okay
.aad9	f0 07		beq $aae2			beq 	_GDCheckY
.aadb	ad c5 05	lda $05c5			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aade	c9 40		cmp #$40			cmp 	#64
.aae0	b0 08		bcs $aaea			bcs 	_GDError1
.aae2					_GDCheckY:
.aae2	ad c7 05	lda $05c7			lda 	gxCurrentY 					; check Y < Height.
.aae5	cd d9 05	cmp $05d9			cmp 	gxHeight
.aae8	90 03		bcc $aaed			bcc 	_GDCopyToWorkArea
.aaea					_GDError1:
.aaea	68		pla				pla
.aaeb					_GDError2:
.aaeb	38		sec				sec
.aaec	60		rts				rts
.aaed					_GDCopyToWorkArea:
.aaed	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.aaef					_GDCopy2:
.aaef	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aaf2	9d cd 05	sta $05cd,x			sta 	gxX0,x
.aaf5	ca		dex				dex
.aaf6	10 f7		bpl $aaef			bpl 	_GDCopy2
.aaf8	68		pla				pla 								; get command
.aaf9					_GDExecuteA:
.aaf9	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.aafb	b0 ee		bcs $aaeb			bcs 	_GDError2
.aafd	aa		tax				tax
.aafe	7c 50 aa	jmp ($aa50,x)			jmp 	(GRVectorTable,x)
.ab01					GXMove:
.ab01	18		clc				clc
.ab02	60		rts				rts
.ab03					GRUndefined:
>ab03	db						.byte 	$DB 						; causes a break in the emulator
.ab04					GXFillCircle:
.ab04	a9 ff		lda #$ff			lda 	#255
.ab06	80 02		bra $ab0a			bra 	GXCircle
.ab08					GXFrameCircle:
.ab08	a9 00		lda #$00			lda 	#0
.ab0a					GXCircle:
.ab0a	8d 68 06	sta $0668			sta 	gxIsFillMode					; save Fill flag
.ab0d	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.ab10	f0 26		beq $ab38			beq 	_GXCFail
.ab12	20 68 b3	jsr $b368			jsr 	GXSortXY 					; topleft/bottomright
.ab15	20 40 b2	jsr $b240			jsr 	GXOpenBitmap 				; start drawing
.ab18	20 0a ac	jsr $ac0a			jsr 	GXCircleSetup 				; set up for drawing
.ab1b	9c 69 06	stz $0669			stz 	gxYChanged
.ab1e					_GXCircleDraw:
.ab1e	ad 66 06	lda $0666			lda 	gXCentre					; while x <= y
.ab21	cd 67 06	cmp $0667			cmp 	gYCentre
.ab24	90 0a		bcc $ab30			bcc 	_GXCircleContinue
.ab26	d0 03		bne $ab2b			bne 	_GXNoLast
.ab28	20 3d ab	jsr $ab3d			jsr 	GXPlot1
.ab2b					_GXNoLast:
.ab2b	20 48 b2	jsr $b248			jsr 	GXCloseBitmap 				; close the bitmap
.ab2e	18		clc				clc
.ab2f	60		rts				rts
.ab30					_GXCircleContinue:
.ab30	20 3a ab	jsr $ab3a			jsr 	GXPlot2 					; draw it
.ab33	20 b7 ab	jsr $abb7			jsr 	GXCircleMove 				; adjust the coordinates
.ab36	80 e6		bra $ab1e			bra 	_GXCircleDraw
.ab38					_GXCFail:
.ab38	38		sec				sec
.ab39	60		rts				rts
.ab3a					GXPlot2:
.ab3a	20 3d ab	jsr $ab3d			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ab3d					GXPlot1:
.ab3d	ad 67 06	lda $0667			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ab40	f0 03		beq $ab45			beq 	_GXPlot1Only
.ab42	20 61 ab	jsr $ab61			jsr 	GXPlot0 						; plot and negate
.ab45					_GXPlot1Only:
.ab45	20 61 ab	jsr $ab61			jsr 	GXPlot0 						; twice, undoing negation
.ab48	ad 66 06	lda $0666			lda 	gXCentre 						; swap X and Y
.ab4b	ae 67 06	ldx $0667			ldx	 	gYCentre
.ab4e	8d 67 06	sta $0667			sta 	gYCentre
.ab51	8e 66 06	stx $0666			stx 	gXCentre
.ab54	ad 69 06	lda $0669			lda 	gxYChanged 						; toggle Y Changed flag
.ab57	a9 ff		lda #$ff			lda 	#$FF
.ab59	8d 69 06	sta $0669			sta 	gxYChanged
.ab5c	60		rts				rts
.ab5d	20 61 ab	jsr $ab61			jsr 	GXPlot0 						; do once
.ab60	60		rts				rts
.ab61	ad 68 06	lda $0668	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ab64	f0 05		beq $ab6b			beq 	_GXPlot0Always
.ab66	ad 69 06	lda $0669			lda 	gxYChanged						; fill mode, only draw if changed.
.ab69	f0 2d		beq $ab98			beq 	GXPlot0Exit
.ab6b					_GXPlot0Always:
.ab6b	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ab6d	ad 67 06	lda $0667			lda 	gYCentre
.ab70	20 99 ab	jsr $ab99			jsr 	GXSubCopy
.ab73	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ab75	ad 66 06	lda $0666			lda 	gXCentre
.ab78	20 99 ab	jsr $ab99			jsr 	GXSubCopy
.ab7b	48		pha				pha 									; save last offset X
.ab7c	20 50 b2	jsr $b250			jsr 	GXPositionCalc 					; calculate position/offset.
.ab7f	68		pla				pla
.ab80	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ab81	85 36		sta $36				sta 	gxzTemp0
.ab83	64 37		stz $37				stz 	gxzTemp0+1
.ab85	26 37		rol $37				rol 	gxzTemp0+1
.ab87	ad 68 06	lda $0668			lda 	gxIsFillMode
.ab8a	69 80		adc #$80			adc 	#128
.ab8c	20 29 af	jsr $af29			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ab8f	38		sec				sec 									; GY = -GY
.ab90	a9 00		lda #$00			lda 	#0
.ab92	ed 67 06	sbc $0667			sbc 	gYCentre
.ab95	8d 67 06	sta $0667			sta 	gYCentre
.ab98					GXPlot0Exit:
.ab98	60		rts				rts
.ab99					GXSubCopy:
.ab99	85 36		sta $36				sta 	gxzTemp0
.ab9b	64 37		stz $37				stz 	gxzTemp0+1
.ab9d	29 80		and #$80			and 	#$80
.ab9f	f0 02		beq $aba3			beq 	_GXNoSx
.aba1	c6 37		dec $37				dec 	gxzTemp0+1
.aba3					_GXNoSx:
.aba3	38		sec				sec
.aba4	bd d1 05	lda $05d1,x			lda 	gXX1,x
.aba7	e5 36		sbc $36				sbc 	gxzTemp0
.aba9	9d cd 05	sta $05cd,x			sta 	gXX0,x
.abac	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.abaf	e5 37		sbc $37				sbc 	gxzTemp0+1
.abb1	9d ce 05	sta $05ce,x			sta 	gXX0+1,x
.abb4	a5 36		lda $36				lda 	gxzTemp0 						; return A
.abb6	60		rts				rts
.abb7					GXCircleMove:
.abb7	9c 69 06	stz $0669			stz 	gxYChanged 					; clear Y changed flag
.abba	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.abbc	10 0d		bpl $abcb			bpl 	_GXEMPositive
.abbe	ee 66 06	inc $0666			inc 	gXCentre 					; X++
.abc1	ad 66 06	lda $0666			lda 	gXCentre
.abc4	20 ea ab	jsr $abea			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abc7	a9 06		lda #$06			lda 	#6  						; and add 6
.abc9	80 15		bra $abe0			bra 	_GXEMAddD
.abcb					_GXEMPositive:
.abcb	ee 66 06	inc $0666			inc 	gXCentre					; X++
.abce	ce 67 06	dec $0667			dec 	gyCentre 					; Y--
.abd1	38		sec				sec 								; calculate X-Y
.abd2	ad 66 06	lda $0666			lda 	gXCentre
.abd5	ed 67 06	sbc $0667			sbc 	gYCentre
.abd8	20 ea ab	jsr $abea			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abdb	a9 0a		lda #$0a			lda 	#10  						; and add 10
.abdd	ce 69 06	dec $0669			dec 	gxYChanged
.abe0					_GXEMAddD:
.abe0	18		clc				clc
.abe1	65 38		adc $38				adc 	gxzTemp1
.abe3	85 38		sta $38				sta 	gxzTemp1
.abe5	90 02		bcc $abe9			bcc 	_GXEMNoCarry
.abe7	e6 39		inc $39				inc 	gxzTemp1+1
.abe9					_GXEMNoCarry:
.abe9	60		rts				rts
.abea					_GXAdd4TimesToD:
.abea	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.abec	29 80		and #$80			and 	#$80
.abee	f0 02		beq $abf2			beq 	_GXA4Unsigned
.abf0	a9 ff		lda #$ff			lda 	#$FF
.abf2					_GXA4Unsigned:
.abf2	85 37		sta $37				sta 	gxzTemp0+1
.abf4	06 36		asl $36				asl 	gxzTemp0  					; x 4
.abf6	26 37		rol $37				rol 	gxzTemp0+1
.abf8	06 36		asl $36				asl 	gxzTemp0
.abfa	26 37		rol $37				rol 	gxzTemp0+1
.abfc	18		clc				clc 								; add
.abfd	a5 36		lda $36				lda		gxzTemp0
.abff	65 38		adc $38				adc 	gxzTemp1
.ac01	85 38		sta $38				sta 	gxzTemp1
.ac03	a5 37		lda $37				lda		gxzTemp0+1
.ac05	65 39		adc $39				adc 	gxzTemp1+1
.ac07	85 39		sta $39				sta 	gxzTemp1+1
.ac09	60		rts				rts
.ac0a					GXCircleSetup:
.ac0a	38		sec				sec
.ac0b	ad d3 05	lda $05d3			lda 	gxY1
.ac0e	ed cf 05	sbc $05cf			sbc 	gxY0
.ac11	4a		lsr a				lsr 	a
.ac12	8d 65 06	sta $0665			sta 	gxRadius
.ac15	a2 00		ldx #$00			ldx 	#0
.ac17	20 39 ac	jsr $ac39			jsr 	_GXCalculateCentre
.ac1a	a2 02		ldx #$02			ldx 	#2
.ac1c	20 39 ac	jsr $ac39			jsr 	_GXCalculateCentre
.ac1f	9c 66 06	stz $0666			stz 	gXCentre
.ac22	ad 65 06	lda $0665			lda 	gxRadius
.ac25	8d 67 06	sta $0667			sta 	gYCentre
.ac28	0a		asl a				asl 	a 							; R x 2
.ac29	85 36		sta $36				sta 	gxzTemp0
.ac2b	38		sec				sec
.ac2c	a9 03		lda #$03			lda 	#3
.ac2e	e5 36		sbc $36				sbc 	gxzTemp0
.ac30	85 38		sta $38				sta 	gxzTemp1
.ac32	a9 00		lda #$00			lda 	#0
.ac34	e9 00		sbc #$00			sbc 	#0
.ac36	85 39		sta $39				sta 	gxzTemp1+1
.ac38	60		rts				rts
.ac39					_GXCalculateCentre:
.ac39	38		sec				sec
.ac3a	bd d1 05	lda $05d1,x			lda 	gxX1,x
.ac3d	7d cd 05	adc $05cd,x			adc 	gXX0,x
.ac40	9d d1 05	sta $05d1,x			sta 	gXX1,x
.ac43	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.ac46	7d ce 05	adc $05ce,x			adc 	gXX0+1,x
.ac49	4a		lsr a				lsr 	a
.ac4a	9d d2 05	sta $05d2,x			sta 	gXX1+1,x
.ac4d	7e d1 05	ror $05d1,x			ror 	gXX1,x
.ac50	60		rts				rts
.0665					gxRadius:
>0665							.fill 	1
.0666					gXCentre:
>0666							.fill 	1
.0667					gYCentre:
>0667							.fill 	1
.0668					gxIsFillMode:
>0668							.fill 	1
.0669					gxYChanged:
>0669							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ac51					GXClearBitmap:
.ac51	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP running.
.ac54	f0 24		beq $ac7a			beq 	_GXCBFail
.ac56	20 40 b2	jsr $b240			jsr 	GXOpenBitmap 				; start access
.ac59	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac5b	ad d9 05	lda $05d9			lda 	gxHeight
.ac5e	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ac60	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ac62					_GXCalcLastPage:
.ac62	98		tya				tya 								; add to base page
.ac63	18		clc				clc
.ac64	6d d7 05	adc $05d7			adc 	gxBasePage
.ac67	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ac69					_GXClearAll:
.ac69	20 7c ac	jsr $ac7c			jsr 	_GXClearBlock 				; clear 8k block
.ac6c	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ac6e	a5 0b		lda $0b				lda 	GXEditSlot
.ac70	cd d7 05	cmp $05d7			cmp 	gxBasePage 					; until before base page
.ac73	b0 f4		bcs $ac69			bcs 	_GXClearAll
.ac75	20 48 b2	jsr $b248			jsr 	GXCloseBitmap	 			; stop access
.ac78	18		clc				clc
.ac79	60		rts				rts
.ac7a					_GXCBFail:
.ac7a	38		sec				sec
.ac7b	60		rts				rts
.ac7c					_GXClearBlock:
.ac7c	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ac7e	85 38		sta $38				sta 	0+gxzTemp1
.ac80	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ac82	85 39		sta $39				sta 	1+gxzTemp1
.ac84					_GXCB0:
.ac84	a5 36		lda $36				lda 	gxzTemp0
.ac86	a0 00		ldy #$00			ldy 	#0
.ac88					_GXCB1:
.ac88	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac8a	c8		iny				iny
.ac8b	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac8d	c8		iny				iny
.ac8e	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac90	c8		iny				iny
.ac91	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac93	c8		iny				iny
.ac94	d0 f2		bne $ac88			bne 	_GXCB1
.ac96	e6 39		inc $39				inc 	gxzTemp1+1
.ac98	a5 39		lda $39				lda 	gxzTemp1+1
.ac9a	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ac9c	d0 e6		bne $ac84			bne 	_GXCB0
.ac9e	60		rts				rts
.ac9f					GXInitialise:
.ac9f	64 01		stz $01				stz 	1
.aca1	a9 01		lda #$01			lda 	#1
.aca3	8d 00 d0	sta $d000			sta 	$D000
.aca6	18		clc				clc
.aca7	9c d5 05	stz $05d5			stz 	GXSpritesOn
.acaa	9c d6 05	stz $05d6			stz 	GXBitmapsOn
.acad	a2 0f		ldx #$0f			ldx 	#15
.acaf					_GXIClear:
.acaf	9e c5 05	stz $05c5,x			stz 	gxCurrentX,x
.acb2	ca		dex				dex
.acb3	10 fa		bpl $acaf			bpl 	_GXIClear
.acb5	20 50 ad	jsr $ad50			jsr 	GXClearSpriteStore
.acb8	60		rts				rts
.acb9					GXControlBitmap:
.acb9	64 01		stz $01				stz 	1
.acbb	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acbd	29 01		and #$01			and 	#1 							; set bitmap flag
.acbf	8d d6 05	sta $05d6			sta 	gxBitmapsOn
.acc2	4a		lsr a				lsr 	a 							; bit 0 into carry.
.acc3	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.acc6	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.acc8	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.acca	90 02		bcc $acce			bcc 	_CBNotOn
.accc	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.acce					_CBNotOn:
.acce	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.acd1	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.acd3	29 07		and #$07			and 	#7
.acd5	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.acd8	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.acda	d0 02		bne $acde			bne 	_CBNotDefault
.acdc	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.acde					_CBNotDefault:
.acde	8d d7 05	sta $05d7			sta 	gxBasePage
.ace1	20 42 ad	jsr $ad42			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ace4	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ace6	8d 03 d1	sta $d103			sta 	$D103
.ace9	a5 36		lda $36				lda 	gxzTemp0
.aceb	8d 02 d1	sta $d102			sta 	$D102
.acee	9c 01 d1	stz $d101			stz 	$D101
.acf1	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.acf3	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.acf6	29 01		and #$01			and 	#1
.acf8	f0 02		beq $acfc			beq 	_CBHaveHeight
.acfa	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.acfc					_CBHaveHeight
.acfc	8e d9 05	stx $05d9			stx 	gxHeight
.acff	18		clc				clc
.ad00	60		rts				rts
.ad01					GXControlSprite:
.ad01	64 01		stz $01				stz 	1
.ad03	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad05	29 01		and #$01			and 	#1 							; set sprites flag
.ad07	8d d5 05	sta $05d5			sta 	gxSpritesOn
.ad0a	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad0b	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad0e	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad10	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ad12	90 02		bcc $ad16			bcc 	_CSNotOn
.ad14	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ad16					_CSNotOn:
.ad16	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad19	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad1b	d0 02		bne $ad1f			bne 	_CSNotDefault
.ad1d	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ad1f					_CSNotDefault:
.ad1f	8d d8 05	sta $05d8			sta 	gxSpritePage
.ad22	20 42 ad	jsr $ad42			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad25	a5 36		lda $36				lda 	zTemp0
.ad27	8d e3 05	sta $05e3			sta 	GXSpriteOffsetBase
.ad2a	a5 37		lda $37				lda 	zTemp0+1
.ad2c	8d e4 05	sta $05e4			sta 	GXSpriteOffsetBase+1
.ad2f	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ad31					_CSClear:
.ad31	9e 00 d9	stz $d900,x			stz 	$D900,x
.ad34	9e 00 da	stz $da00,x			stz 	$DA00,x
.ad37	ca		dex				dex
.ad38	d0 f7		bne $ad31			bne 	_CSClear
.ad3a	9c e2 05	stz $05e2			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ad3d	20 50 ad	jsr $ad50			jsr 	GXClearSpriteStore
.ad40	18		clc				clc
.ad41	60		rts				rts
.ad42					GXCalculateBaseAddress:
.ad42	85 36		sta $36				sta 	gxzTemp0
.ad44	64 37		stz $37				stz 	gxzTemp0+1
.ad46	a9 05		lda #$05			lda 	#5
.ad48					_GXShift:
.ad48	06 36		asl $36				asl 	gxzTemp0
.ad4a	26 37		rol $37				rol 	gxzTemp0+1
.ad4c	3a		dec a				dec		a
.ad4d	d0 f9		bne $ad48			bne 	_GXShift
.ad4f	60		rts				rts
.ad50					GXClearSpriteStore:
.ad50	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ad52					_GXCSSLoop:
.ad52	9e 25 06	stz $0625,x			stz 	GXSpriteHigh,x
.ad55	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad57	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.ad5a	ca		dex				dex
.ad5b	10 f5		bpl $ad52			bpl 	_GXCSSLoop
.ad5d	60		rts				rts
.ad5e					GXLine:
.ad5e	ad d6 05	lda $05d6			lda 	GXBitmapsOn
.ad61	f0 28		beq $ad8b			beq 	_GXLFail
.ad63	20 40 b2	jsr $b240			jsr 	GXOpenBitmap
.ad66	20 86 b3	jsr $b386			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ad69	20 31 ae	jsr $ae31			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ad6c	20 50 b2	jsr $b250			jsr 	GXPositionCalc 				; calculate position/offset.
.ad6f					_GXDrawLoop:
.ad6f	ac df 05	ldy $05df			ldy 	gsOffset 					; draw the pixel
.ad72	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ad74	2d dd 05	and $05dd			and 	gxANDValue
.ad77	4d dc 05	eor $05dc			eor 	gxEORValue
.ad7a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ad7c	20 8d ad	jsr $ad8d			jsr 	GXLineIsComplete 			; is the line complete ?
.ad7f	f0 05		beq $ad86			beq 	_GXLExit
.ad81	20 a8 ad	jsr $ada8			jsr 	GXLineAdvance 				; code as per advance method
.ad84	80 e9		bra $ad6f			bra 	_GXDrawLoop
.ad86					_GXLExit:
.ad86	20 48 b2	jsr $b248			jsr 	GXCloseBitmap
.ad89	18		clc				clc
.ad8a	60		rts				rts
.ad8b					_GXLFail:
.ad8b	38		sec				sec
.ad8c	60		rts				rts
.ad8d					GXLineIsComplete:
.ad8d	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger 			; is dy larger
.ad90	d0 0f		bne $ada1			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ad92	ad cd 05	lda $05cd			lda 	GXX0 						; compare X, LSB and MSB
.ad95	4d d1 05	eor $05d1			eor 	GXX1
.ad98	d0 06		bne $ada0			bne 	_GXLICExit
.ad9a	ad ce 05	lda $05ce			lda 	GXX0+1
.ad9d	4d d2 05	eor $05d2			eor 	GXX1+1
.ada0					_GXLICExit:
.ada0	60		rts				rts
.ada1					_GXLICCompareY:
.ada1	ad d3 05	lda $05d3			lda 	GXY1
.ada4	4d cf 05	eor $05cf			eor 	GXY0
.ada7	60		rts				rts
.ada8					GXLineAdvance:
.ada8	18		clc				clc 								; add adjust to position
.ada9	ad 6e 06	lda $066e			lda 	GXPosition
.adac	6d 6f 06	adc $066f			adc 	GXAdjust
.adaf	8d 6e 06	sta $066e			sta 	GXPosition
.adb2	9c 71 06	stz $0671			stz 	GXAddSelect 				; clear add select flag
.adb5	b0 05		bcs $adbc			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.adb7	cd 70 06	cmp $0670			cmp 	GXTotal 					; if exceeded total
.adba	90 0a		bcc $adc6			bcc 	_GXLANoExtra
.adbc					_GXLAOverflow:
.adbc	ce 71 06	dec $0671			dec 	GXAddSelect 				; set addselect to $FF
.adbf	38		sec				sec 								; subtract total and write back
.adc0	ed 70 06	sbc $0670			sbc 	GXTotal
.adc3	8d 6e 06	sta $066e			sta 	GXPosition
.adc6					_GXLANoExtra:
.adc6	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger
.adc9	f0 0d		beq $add8			beq 	_GXDXLarger
.adcb	20 2a ae	jsr $ae2a			jsr 	GXIncrementY
.adce	ad 71 06	lda $0671			lda 	GXAddSelect
.add1	f0 10		beq $ade3			beq 	_GXLAExit
.add3	20 e4 ad	jsr $ade4			jsr 	GXAdjustX
.add6	80 0b		bra $ade3			bra 	_GXLAExit
.add8					_GXDXLarger:
.add8	20 e4 ad	jsr $ade4			jsr 	GXAdjustX
.addb	ad 71 06	lda $0671			lda 	GXAddSelect
.adde	f0 03		beq $ade3			beq 	_GXLAExit
.ade0	20 2a ae	jsr $ae2a			jsr 	GXIncrementY
.ade3					_GXLAExit:
.ade3	60		rts				rts
.ade4					GXAdjustX:
.ade4	ad 6d 06	lda $066d			lda 	GXDXNegative
.ade7	10 25		bpl $ae0e			bpl 	_GXAXRight
.ade9	ad cd 05	lda $05cd			lda 	GXX0
.adec	d0 03		bne $adf1			bne 	_GXAXNoBorrow
.adee	ce ce 05	dec $05ce			dec 	GXX0+1
.adf1					_GXAXNoBorrow:
.adf1	ce cd 05	dec $05cd			dec 	GXX0
.adf4	ce df 05	dec $05df			dec 	gsOffset 					; pixel left
.adf7	ad df 05	lda $05df			lda 	gsOffset
.adfa	c9 ff		cmp #$ff			cmp 	#$FF
.adfc	d0 0f		bne $ae0d			bne 	_GXAYExit 					; underflow
.adfe	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.ae00	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.ae02	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.ae04	b0 07		bcs $ae0d			bcs 	_GXAYExit
.ae06	18		clc				clc
.ae07	69 20		adc #$20			adc 	#$20 						; fix up
.ae09	85 3d		sta $3d				sta 	gxzScreen+1
.ae0b	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ae0d					_GXAYExit:
.ae0d	60		rts				rts
.ae0e					_GXAXRight:
.ae0e	ee cd 05	inc $05cd			inc 	GXX0
.ae11	d0 03		bne $ae16			bne 	_GXAXNoCarry
.ae13	ee ce 05	inc $05ce			inc 	GXX0+1
.ae16					_GXAXNoCarry:
.ae16	ee df 05	inc $05df			inc 	gsOffset 					; pixel right
.ae19	d0 0e		bne $ae29			bne 	_GXAXExit 					; if not overflowed, exit.
.ae1b	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ae1d	a5 3d		lda $3d				lda 	gxzScreen+1
.ae1f	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ae21	90 06		bcc $ae29			bcc 	_GXAXExit
.ae23	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae25	85 3d		sta $3d				sta 	gxzScreen+1
.ae27	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ae29					_GXAXExit:
.ae29	60		rts				rts
.ae2a					GXIncrementY:
.ae2a	ee cf 05	inc $05cf			inc 	GXY0
.ae2d	20 a6 b2	jsr $b2a6			jsr 	GXMovePositionDown
.ae30	60		rts				rts
.ae31					GXLineSetup:
.ae31	ad d3 05	lda $05d3			lda 	GXY1
.ae34	38		sec				sec
.ae35	ed cf 05	sbc $05cf			sbc 	GXY0
.ae38	4a		lsr a				lsr 	a
.ae39	8d 6b 06	sta $066b			sta 	GXDiffY
.ae3c	9c 6d 06	stz $066d			stz 	GXDXNegative 				; clear -ve flag
.ae3f	38		sec				sec
.ae40	ad d1 05	lda $05d1			lda 	GXX1
.ae43	ed cd 05	sbc $05cd			sbc 	GXX0
.ae46	8d 6a 06	sta $066a			sta 	GXDiffX
.ae49	ad d2 05	lda $05d2			lda 	GXX1+1 						; calculate MSB
.ae4c	ed ce 05	sbc $05ce			sbc 	GXX0+1
.ae4f	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ae50	6e 6a 06	ror $066a			ror 	GXDiffX
.ae53	0a		asl a				asl 	a
.ae54	10 0c		bpl $ae62			bpl 	_GDXNotNegative
.ae56	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae58	38		sec				sec
.ae59	ed 6a 06	sbc $066a			sbc 	GXDiffX
.ae5c	8d 6a 06	sta $066a			sta 	GXDiffX
.ae5f	ce 6d 06	dec $066d			dec 	GXDXNegative 				; -ve flag = $FF.
.ae62					_GDXNotNegative:
.ae62	9c 6c 06	stz $066c			stz 	GXIsDiffYLarger 			; clear larger flag
.ae65	ad 6b 06	lda $066b			lda 	GXDiffY 					; set adjust and total.
.ae68	8d 6f 06	sta $066f			sta 	GXAdjust
.ae6b	ad 6a 06	lda $066a			lda 	GXDiffX
.ae6e	8d 70 06	sta $0670			sta 	GXTotal
.ae71	ad 6b 06	lda $066b			lda 	GXDiffY 					; if dy > dx
.ae74	cd 6a 06	cmp $066a			cmp 	GXDiffX
.ae77	90 0f		bcc $ae88			bcc 	_GDXNotLarger
.ae79	ce 6c 06	dec $066c			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ae7c	ad 6a 06	lda $066a			lda 	GXDiffX 					; set adjust and total other way round
.ae7f	8d 6f 06	sta $066f			sta 	GXAdjust
.ae82	ad 6b 06	lda $066b			lda 	GXDiffY
.ae85	8d 70 06	sta $0670			sta 	GXTotal
.ae88					_GDXNotLarger:
.ae88	ad 70 06	lda $0670			lda 	GXTotal
.ae8b	4a		lsr a				lsr 	a
.ae8c	8d 6e 06	sta $066e			sta 	GXPosition
.ae8f	60		rts				rts
.066a					GXDiffX:
>066a							.fill 	1
.066b					GXDiffY:
>066b							.fill 	1
.066c					GXIsDiffYLarger:
>066c							.fill 	1
.066d					GXDXNegative:
>066d							.fill 	1
.066e					GXPosition:
>066e							.fill 	1
.066f					GXAdjust:
>066f							.fill 	1
.0670					GXTotal:
>0670							.fill 	1
.0671					GXAddSelect:
>0671							.fill 	1
.ae90					GXSetColourMode:
.ae90	a6 36		ldx $36				ldx 	gxzTemp0
.ae92	8e db 05	stx $05db			stx 	gxColour 								; set colour
.ae95	a5 37		lda $37				lda 	gxzTemp0+1 								;
.ae97	8d da 05	sta $05da			sta 	gxMode 									; set mode
.ae9a	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.ae9c	9c dd 05	stz $05dd			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.ae9f	ae db 05	ldx $05db			ldx 	gxColour
.aea2	8e dc 05	stx $05dc			stx 	gxEORValue
.aea5	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.aea7	90 03		bcc $aeac			bcc 	_GXSDCNotAndColour
.aea9	8e dd 05	stx $05dd			stx 	gxANDValue
.aeac					_GXSDCNotAndColour:
.aeac	d0 03		bne $aeb1			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.aeae	9c dc 05	stz $05dc			stz 	gxEORValue
.aeb1					_GXSDCNotAnd:
.aeb1	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.aeb2	90 08		bcc $aebc			bcc 	_GXSDCNoFlip
.aeb4	ad dd 05	lda $05dd			lda	 	gxANDValue
.aeb7	49 ff		eor #$ff			eor 	#$FF
.aeb9	8d dd 05	sta $05dd			sta 	gxANDValue
.aebc					_GXSDCNoFlip:
.aebc	18		clc				clc
.aebd	60		rts				rts
.aebe					GXPlotPoint:
.aebe	20 40 b2	jsr $b240			jsr 	GXOpenBitmap 				; start drawing
.aec1	20 50 b2	jsr $b250			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aec4	ac df 05	ldy $05df			ldy 	gsOffset
.aec7	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.aec9	2d dd 05	and $05dd			and 	gxANDValue
.aecc	4d dc 05	eor $05dc			eor 	gxEORValue
.aecf	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aed1	20 48 b2	jsr $b248			jsr 	GXCloseBitmap 				; stop drawing and exit
.aed4	18		clc				clc
.aed5	60		rts				rts
.aed6					GXFillRectangle:
.aed6	38		sec				sec
.aed7	80 01		bra $aeda			bra 	GXRectangle
.aed9					GXFrameRectangle:
.aed9	18		clc				clc
.aeda					GXRectangle:
.aeda	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.aedd	f0 35		beq $af14			beq 	_GXRFail
.aedf	08		php				php 								; save Fill flag (CS)
.aee0	20 40 b2	jsr $b240			jsr 	GXOpenBitmap 				; start drawing
.aee3	20 68 b3	jsr $b368			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.aee6	20 50 b2	jsr $b250			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aee9	38		sec				sec 								; sec = Draw line
.aeea	20 16 af	jsr $af16			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.aeed	ad cf 05	lda $05cf			lda 	gxY0 						; reached end of rectangle ?
.aef0	cd d3 05	cmp $05d3			cmp 	gxY1
.aef3	f0 19		beq $af0e			beq 	_GXRectangleExit
.aef5					_GXRectLoop:
.aef5	20 a6 b2	jsr $b2a6			jsr 	GXMovePositionDown 			; down one.
.aef8	ee cf 05	inc $05cf			inc 	gxY0 						; change Y pos
.aefb	ad cf 05	lda $05cf			lda 	gxY0 						; reached last line
.aefe	cd d3 05	cmp $05d3			cmp 	gXY1
.af01	f0 07		beq $af0a			beq 	_GXLastLine
.af03	28		plp				plp 								; get flag back
.af04	08		php				php
.af05	20 16 af	jsr $af16			jsr 	GXDrawLineX1X0 				; draw horizontal line
.af08	80 eb		bra $aef5			bra 	_GXRectLoop
.af0a					_GXLastLine:
.af0a	38		sec				sec
.af0b	20 16 af	jsr $af16			jsr 	GXDrawLineX1X0
.af0e					_GXRectangleExit:
.af0e	68		pla				pla 								; throw fill flag.
.af0f	20 48 b2	jsr $b248			jsr 	GXCloseBitmap 				; stop drawing and exit
.af12	18		clc				clc
.af13	60		rts				rts
.af14					_GXRFail:
.af14	38		sec				sec
.af15	60		rts				rts
.af16					GXDrawLineX1X0:
.af16	08		php				php 								; save solid/either-end
.af17	38		sec				sec
.af18	ad d1 05	lda $05d1			lda		gXX1
.af1b	ed cd 05	sbc $05cd			sbc 	gXX0
.af1e	85 36		sta $36				sta 	gxzTemp0
.af20	ad d2 05	lda $05d2			lda 	gXX1+1
.af23	ed ce 05	sbc $05ce			sbc 	gXX0+1
.af26	85 37		sta $37				sta 	gxzTemp0+1
.af28	28		plp				plp
.af29					GXDrawLineTemp0:
.af29	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.af2b	48		pha				pha
.af2c	a5 3d		lda $3d				lda 	gxzScreen+1
.af2e	48		pha				pha
.af2f	ad df 05	lda $05df			lda 	gsOffset
.af32	48		pha				pha
.af33	a5 0b		lda $0b				lda 	GXEditSlot
.af35	48		pha				pha
.af36	ac df 05	ldy $05df			ldy 	gsOffset 					; Y offset
.af39	90 1e		bcc $af59			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.af3b					_GXDLTLine:
.af3b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af3d	2d dd 05	and $05dd			and 	gxANDValue
.af40	4d dc 05	eor $05dc			eor 	gxEORValue
.af43	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af45	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.af47	d0 04		bne $af4d			bne 	_GXDLTNoBorrow
.af49	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.af4b	30 2e		bmi $af7b			bmi 	_GXDLTExit
.af4d					_GXDLTNoBorrow:
.af4d	c6 36		dec $36				dec 	gxzTemp0
.af4f	c8		iny				iny 								; next slot.
.af50	d0 e9		bne $af3b			bne 	_GXDLTLine
.af52	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.af54	20 89 af	jsr $af89			jsr 	GXDLTCheckWrap				; check for new page.
.af57	80 e2		bra $af3b			bra 	_GXDLTLine
.af59					_GXDLTEndPoints:
.af59	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af5b	2d dd 05	and $05dd			and 	gxANDValue
.af5e	4d dc 05	eor $05dc			eor 	gxEORValue
.af61	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af63	98		tya				tya 								; advance to right side
.af64	18		clc				clc
.af65	65 36		adc $36				adc 	gxzTemp0
.af67	a8		tay				tay
.af68	a5 3d		lda $3d				lda 	gxzScreen+1
.af6a	65 37		adc $37				adc 	gxzTemp0+1
.af6c	85 3d		sta $3d				sta 	gxzScreen+1
.af6e	20 89 af	jsr $af89			jsr 	GXDLTCheckWrap 			; fix up.
.af71	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af73	2d dd 05	and $05dd			and 	gxANDValue
.af76	4d dc 05	eor $05dc			eor 	gxEORValue
.af79	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af7b					_GXDLTExit:
.af7b	68		pla				pla
.af7c	85 0b		sta $0b				sta 	GXEditSlot
.af7e	68		pla				pla
.af7f	8d df 05	sta $05df			sta 	gsOffset
.af82	68		pla				pla
.af83	85 3d		sta $3d				sta 	gxzScreen+1
.af85	68		pla				pla
.af86	85 3c		sta $3c				sta 	gxzScreen
.af88	60		rts				rts
.af89					GXDLTCheckWrap:
.af89	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.af8b	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.af8d	90 06		bcc $af95			bcc 	_GXDLTCWExit
.af8f	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af91	85 3d		sta $3d				sta 	gxzScreen+1
.af93	e6 0b		inc $0b				inc 	GXEditSlot
.af95					_GXDLTCWExit:
.af95	60		rts				rts
.af96					GXDrawGraphicElement:
.af96	8d 72 06	sta $0672			sta 	gxSize 						; save size
.af99	3a		dec a				dec 	a
.af9a	8d 73 06	sta $0673			sta 	gxMask 						; and mask
.af9d	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP on
.afa0	f0 67		beq $b009			beq 	_GXSLFail
.afa2	ad cf 05	lda $05cf			lda 	gxY0 						; push Y on stack
.afa5	48		pha				pha
.afa6	8c 75 06	sty $0675			sty 	gxAcquireVector+1 			; and acquisition vector
.afa9	8e 74 06	stx $0674			stx 	gxAcquireVector
.afac	20 40 b2	jsr $b240			jsr 	gxOpenBitmap 				; open the bitmap.
.afaf	ad 77 06	lda $0677			lda 	gxUseMode 					; scale bits
.afb2	4a		lsr a				lsr 	a
.afb3	4a		lsr a				lsr 	a
.afb4	4a		lsr a				lsr 	a
.afb5	29 07		and #$07			and		#7
.afb7	1a		inc a				inc 	a
.afb8	8d 76 06	sta $0676			sta 	gxScale
.afbb	64 38		stz $38				stz 	gxzTemp1					; start first line
.afbd					_GXGELoop:
.afbd	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.afbf	2c 77 06	bit $0677			bit 	gxUseMode 					; check for flip.
.afc2	10 06		bpl $afca			bpl		_GXNoVFlip
.afc4	ad 73 06	lda $0673			lda 	gxMask
.afc7	38		sec				sec
.afc8	e5 38		sbc $38				sbc 	gxzTemp1
.afca					_GXNoVFlip:
.afca	aa		tax				tax 								; get the Xth line.
.afcb	20 0b b0	jsr $b00b			jsr 	_GXCallAcquire 				; get that data.
.afce	ad 76 06	lda $0676			lda 	gxScale 					; do scale identical copies of that line.
.afd1	85 39		sta $39				sta 	gxzTemp1+1
.afd3					_GXGELoop2:
.afd3	ad cf 05	lda $05cf			lda 	gxY0 						; off screen
.afd6	cd d9 05	cmp $05d9			cmp 	gxHeight
.afd9	b0 10		bcs $afeb			bcs 	_GXDGEExit
.afdb	20 0e b0	jsr $b00e			jsr 	GXRenderOneLine 			; render line
.afde	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.afe0	d0 f1		bne $afd3			bne 	_GXGELoop2
.afe2	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.afe4	a5 38		lda $38				lda 	gxzTemp1
.afe6	cd 72 06	cmp $0672			cmp 	gxSize
.afe9	d0 d2		bne $afbd			bne 	_GXGELoop
.afeb					_GXDGEExit:
.afeb	68		pla				pla 								; restore Y for next time
.afec	8d cf 05	sta $05cf			sta 	gxY0
.afef	ae 76 06	ldx $0676			ldx 	gxScale 					; get scale (1-8)
.aff2					_GXShiftLeft:
.aff2	18		clc				clc
.aff3	ad 72 06	lda $0672			lda 	gxSize
.aff6	6d cd 05	adc $05cd			adc 	gxX0
.aff9	8d cd 05	sta $05cd			sta 	gxX0
.affc	90 03		bcc $b001			bcc 	_GXSLNoCarry
.affe	ee ce 05	inc $05ce			inc 	gxX0+1
.b001					_GXSLNoCarry:
.b001	ca		dex				dex
.b002	d0 ee		bne $aff2			bne 	_GXShiftLeft
.b004	20 48 b2	jsr $b248			jsr 	GXCloseBitmap
.b007	18		clc				clc
.b008	60		rts				rts
.b009					_GXSLFail:
.b009	38		sec				sec
.b00a	60		rts				rts
.b00b					_GXCallAcquire:
.b00b	6c 74 06	jmp ($0674)			jmp 	(gxAcquireVector)
.b00e					GXRenderOneLine:
.b00e	20 50 b2	jsr $b250			jsr 	GXPositionCalc 				; calculate position/offset.
.b011	ac df 05	ldy $05df			ldy 	gsOffset 					; Y contains position.
.b014	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b016					_GXROLLoop1:
.b016	ad 76 06	lda $0676			lda 	gxScale 					; set to do 'scale' times
.b019	85 3b		sta $3b				sta 	gxzTemp2+1
.b01b					_GXROLLoop2:
.b01b	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b01d	2c da 05	bit $05da			bit 	gxMode 						; check H Flip
.b020	50 06		bvc $b028			bvc 	_GXNoHFlip
.b022	ad 73 06	lda $0673			lda 	gxMask
.b025	38		sec				sec
.b026	e5 3a		sbc $3a				sbc 	gxzTemp2
.b028					_GXNoHFlip:
.b028	aa		tax				tax 								; read from the pixel buffer
.b029	bd 7b 05	lda $057b,x			lda 	gxPixelBuffer,x
.b02c	d0 07		bne $b035			bne 	_GXDraw 					; draw if non zero
.b02e	ad 77 06	lda $0677			lda 	gxUseMode 					; check to see if solid background
.b031	29 04		and #$04			and 	#4
.b033	f0 0a		beq $b03f			beq 	_GXZeroPixel
.b035					_GXDraw:
.b035	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b037	2d dd 05	and $05dd			and 	gxANDValue
.b03a	5d 7b 05	eor $057b,x			eor 	gxPixelBuffer,x
.b03d	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b03f					_GXZeroPixel:
.b03f	c8		iny				iny 								; advance pointer
.b040	d0 05		bne $b047			bne 	_GXNoShift
.b042	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b044	20 89 af	jsr $af89			jsr 	GXDLTCheckWrap				; check for new page.
.b047					_GXNoShift:
.b047	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b049	d0 d0		bne $b01b			bne 	_GXROLLoop2
.b04b	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b04d	a5 3a		lda $3a				lda 	gxzTemp2
.b04f	cd 72 06	cmp $0672			cmp 	gxSize
.b052	d0 c2		bne $b016			bne 	_GXROLLoop1
.b054	ee cf 05	inc $05cf			inc 	gxY0
.b057	60		rts				rts
.0672					gxSize:
>0672							.fill 	1
.0673					gxMask:
>0673							.fill 	1
.0674					gxAcquireVector:
>0674							.fill 	2
.0676					gxScale:
>0676							.fill 	1
.0677					gxUseMode:
>0677							.fill 	1
.b058					GXFontHandler:
.b058	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b05a	4d da 05	eor $05da			eor 	gxMode
.b05d	8d 77 06	sta $0677			sta 	gxUseMode
.b060	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b062	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b064	26 37		rol $37				rol	 	gxzTemp0+1
.b066	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b068	26 37		rol $37				rol	 	gxzTemp0+1
.b06a	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b06c	26 37		rol $37				rol	 	gxzTemp0+1
.b06e	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b070	09 c0		ora #$c0			ora 	#$C0
.b072	85 37		sta $37				sta 	gxzTemp0+1
.b074	a9 08		lda #$08			lda 	#8 							; size 8x8
.b076	a2 7e		ldx #$7e			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b078	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b07a	20 96 af	jsr $af96			jsr 	GXDrawGraphicElement
.b07d	60		rts				rts
.b07e					GXGetGraphicDataFont:
.b07e	8a		txa				txa 								; X->Y
.b07f	a8		tay				tay
.b080	a6 01		ldx $01				ldx 	1 							; preserve old value
.b082	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b084	85 01		sta $01				sta 	1
.b086	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b088	86 01		stx $01				stx 	1 							; put old value back.
.b08a	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b08c					_GXExpand:
.b08c	9e 7b 05	stz $057b,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b08f	0a		asl a				asl 	a 							; shift bit 7 into C
.b090	90 08		bcc $b09a			bcc 	_GXNoPixel
.b092	48		pha				pha 								; if set, set pixel buffer to current colour.
.b093	ad db 05	lda $05db			lda 	gxColour
.b096	9d 7b 05	sta $057b,x			sta 	gxPixelBuffer,x
.b099	68		pla				pla
.b09a					_GXNoPixel:
.b09a	e8		inx				inx 								; do the whole byte.
.b09b	e0 08		cpx #$08			cpx 	#8
.b09d	d0 ed		bne $b08c			bne 	_GXExpand
.b09f	60		rts				rts
.b0a0					GXSpriteHandler:
.b0a0	ad d5 05	lda $05d5			lda 	gxSpritesOn 				; sprites on ?
.b0a3	f0 23		beq $b0c8			beq 	_GXSHExit
.b0a5	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b0a7	4d da 05	eor $05da			eor 	gxMode
.b0aa	8d 77 06	sta $0677			sta 	gxUseMode
.b0ad	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b0af	da		phx				phx
.b0b0	20 40 b2	jsr $b240			jsr 	GXOpenBitmap 				; can access sprite information
.b0b3	68		pla				pla
.b0b4	20 21 b3	jsr $b321			jsr 	GXFindSprite 				; get the sprite address
.b0b7	08		php				php
.b0b8	20 48 b2	jsr $b248			jsr 	GXCloseBitmap
.b0bb	28		plp				plp
.b0bc	b0 0a		bcs $b0c8			bcs		_GXSHExit 					; exit if find failed.
.b0be	ad 78 06	lda $0678			lda 	GXSizePixels 				; return size
.b0c1	a2 c9		ldx #$c9			ldx 	#GXSpriteAcquire & $FF
.b0c3	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b0c5	20 96 af	jsr $af96			jsr 	GXDrawGraphicElement
.b0c8					_GXSHExit:
.b0c8	60		rts				rts
.b0c9					GXSpriteAcquire:
.b0c9	ad d8 05	lda $05d8			lda 	GXSpritePage				; point to base page
.b0cc	85 0b		sta $0b				sta 	GXEditSlot
.b0ce	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b0d0	a9 00		lda #$00			lda 	#0
.b0d2	ae 79 06	ldx $0679			ldx 	GXSizeBits
.b0d5					_GXTimesRowNumber:
.b0d5	18		clc				clc
.b0d6	65 36		adc $36				adc 	zTemp0
.b0d8	ca		dex				dex
.b0d9	10 fa		bpl $b0d5			bpl 	_GXTimesRowNumber
.b0db	64 37		stz $37				stz 	gxzTemp0+1
.b0dd	0a		asl a				asl 	a 							; row x 2,4,6,8
.b0de	26 37		rol $37				rol 	gxzTemp0+1
.b0e0	0a		asl a				asl 	a 							; row x 4,8,12,16
.b0e1	26 37		rol $37				rol 	gxzTemp0+1
.b0e3	0a		asl a				asl 	a 							; row x 8,16,24,32
.b0e4	26 37		rol $37				rol 	gxzTemp0+1
.b0e6	85 36		sta $36				sta 	gxzTemp0
.b0e8	18		clc				clc 								; add base address.
.b0e9	a5 36		lda $36				lda 	gxzTemp0
.b0eb	6d 7b 06	adc $067b			adc 	GXSpriteOffset
.b0ee	85 36		sta $36				sta 	gxzTemp0
.b0f0	a5 37		lda $37				lda 	gxzTemp0+1
.b0f2	6d 7c 06	adc $067c			adc 	GXSpriteOffset+1
.b0f5					_GXSAFindPage:
.b0f5	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b0f7	90 06		bcc $b0ff			bcc 	_GXSAFoundPage
.b0f9	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b0fb	e6 0b		inc $0b				inc 	GXEditSlot
.b0fd	80 f6		bra $b0f5			bra 	_GXSAFindPage
.b0ff					_GXSAFoundPage:
.b0ff	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b101	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b103	a0 00		ldy #$00			ldy 	#0
.b105					_GXSACopyLoop:
.b105	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b107	99 7b 05	sta $057b,y			sta 	gxPixelBuffer,y
.b10a	c8		iny				iny
.b10b	cc 78 06	cpy $0678			cpy 	GXSizePixels
.b10e	d0 f5		bne $b105			bne 	_GXSACopyLoop
.b110	60		rts				rts
.b111					GXSelect:
.b111	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b114	f0 22		beq $b138			beq 	_GXSFail
.b116	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b118	c9 40		cmp #$40			cmp 	#64
.b11a	b0 1c		bcs $b138			bcs 	_GXSFail
.b11c	8d e0 05	sta $05e0			sta 	GSCurrentSpriteID
.b11f	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b121	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b123	06 36		asl $36				asl 	gxzTemp0
.b125	06 36		asl $36				asl 	gxzTemp0
.b127	06 36		asl $36				asl 	gxzTemp0
.b129	2a		rol a				rol 	a
.b12a	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b12c	8d e2 05	sta $05e2			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b12f	85 37		sta $37				sta 	gxzTemp0+1
.b131	a5 36		lda $36				lda 	gxzTemp0
.b133	8d e1 05	sta $05e1			sta 	GSCurrentSpriteAddr
.b136	18		clc				clc
.b137	60		rts				rts
.b138					_GXSFail:
.b138	38		sec				sec
.b139	60		rts				rts
.b13a					GXSelectImage:
.b13a	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b13d	f0 74		beq $b1b3			beq 	_GXSIFail
.b13f	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b142	f0 6f		beq $b1b3			beq 	_GXSIFail 					; (checking the MSB)
.b144	64 01		stz $01				stz 	1
.b146	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b148	d0 6b		bne $b1b5			bne 	_GXSIHide
.b14a	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b14c	48		pha				pha
.b14d	20 40 b2	jsr $b240			jsr 	GXOpenBitmap
.b150	68		pla				pla
.b151	20 21 b3	jsr $b321			jsr 	GXFindSprite
.b154	b0 5a		bcs $b1b0			bcs 	_GXSICloseFail 				; no image
.b156	a0 01		ldy #$01			ldy 	#1
.b158	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b15b	85 36		sta $36				sta 	gxzTemp0
.b15d	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b160	85 37		sta $37				sta 	gxzTemp0+1
.b162	ad 7b 06	lda $067b			lda 	GXSpriteOffset
.b165	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b167	18		clc				clc
.b168	ad 7c 06	lda $067c			lda 	GXSpriteOffset+1
.b16b	6d e3 05	adc $05e3			adc 	GXSpriteOffsetBase
.b16e	c8		iny				iny
.b16f	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b171	ad e4 05	lda $05e4			lda 	GXSpriteOffsetBase+1
.b174	69 00		adc #$00			adc 	#0
.b176	c8		iny				iny
.b177	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b179	ad 79 06	lda $0679			lda 	GXSizeBits 					; get raw size
.b17c	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b17e	2a		rol a				rol 	a 							; x 2
.b17f	0a		asl a				asl 	a 							; x 4
.b180	0a		asl a				asl 	a 							; x 8
.b181	0a		asl a				asl 	a 							; x 16
.b182	0d 7a 06	ora $067a			ora 	GXSpriteLUT 				; Or with LUT
.b185	0a		asl a				asl 	a 							; 1 shift
.b186	09 01		ora #$01			ora 	#1 							; enable sprite.
.b188	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b18a	20 48 b2	jsr $b248			jsr 	GXCloseBitmap
.b18d	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b190	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b193	29 3f		and #$3f			and 	#$3F
.b195	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b198	ad 79 06	lda $0679			lda 	GXSizeBits 					; get bit size
.b19b	6a		ror a				ror 	a 							; shift into bits 6/7
.b19c	6a		ror a				ror 	a
.b19d	6a		ror a				ror 	a
.b19e	29 c0		and #$c0			and 	#$C0
.b1a0	1d 25 06	ora $0625,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b1a3	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b1a6	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b1a9	29 7f		and #$7f			and 	#$7F
.b1ab	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b1ae	18		clc				clc
.b1af	60		rts				rts
.b1b0					_GXSICloseFail:
.b1b0	20 48 b2	jsr $b248			jsr 	GXCloseBitmap
.b1b3					_GXSIFail:
.b1b3	38		sec				sec
.b1b4	60		rts				rts
.b1b5					_GXSIHide:
.b1b5	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b1b8	85 36		sta $36				sta 	gxzTemp0
.b1ba	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b1bd	85 37		sta $37				sta 	gxzTemp0+1
.b1bf	a9 00		lda #$00			lda 	#0
.b1c1	92 36		sta ($36)			sta 	(gxzTemp0)
.b1c3	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get sprite ID
.b1c6	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b1c9	09 80		ora #$80			ora 	#$80
.b1cb	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b1ce	18		clc				clc
.b1cf	60		rts				rts
.b1d0					GXMoveSprite:
.b1d0	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b1d3	f0 65		beq $b23a			beq 	_GXSIFail
.b1d5	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b1d8	f0 60		beq $b23a			beq 	_GXSIFail
.b1da	85 37		sta $37				sta 	gxzTemp0+1
.b1dc	a0 04		ldy #$04			ldy 	#4
.b1de	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b1e1	85 36		sta $36				sta 	gxzTemp0
.b1e3	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b1e6	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b1e9	2a		rol a				rol 	a	 						; into bits 0,1.
.b1ea	2a		rol a				rol 	a
.b1eb	2a		rol a				rol 	a
.b1ec	29 03		and #$03			and 	#3
.b1ee	aa		tax				tax
.b1ef	bd 3c b2	lda $b23c,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b1f2	48		pha				pha
.b1f3	18		clc				clc
.b1f4	6d cd 05	adc $05cd			adc 	gxX0						; copy position.
.b1f7	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1f9	c8		iny				iny
.b1fa	ad ce 05	lda $05ce			lda 	gxX0+1
.b1fd	69 00		adc #$00			adc 	#0
.b1ff	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b201	c8		iny				iny
.b202	68		pla				pla
.b203	18		clc				clc
.b204	6d cf 05	adc $05cf			adc 	gxY0
.b207	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b209	a9 00		lda #$00			lda 	#0
.b20b	69 00		adc #$00			adc 	#0
.b20d	c8		iny				iny
.b20e	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b210	4e ce 05	lsr $05ce			lsr 	gxX0+1 						; divide X by 4
.b213	6e cd 05	ror $05cd			ror 	gxX0
.b216	4e cd 05	lsr $05cd			lsr 	gxX0
.b219	4e cf 05	lsr $05cf			lsr 	gxY0 						; divide Y by 4
.b21c	4e cf 05	lsr $05cf			lsr 	gxY0
.b21f	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b222	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x
.b225	29 80		and #$80			and 	#$80
.b227	0d cd 05	ora $05cd			ora 	gxX0
.b22a	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b22d	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b230	29 c0		and #$c0			and 	#$C0
.b232	0d cf 05	ora $05cf			ora 	gxY0
.b235	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b238	18		clc				clc
.b239	60		rts				rts
.b23a					_GXSIFail:
.b23a	38		sec				sec
.b23b	60		rts				rts
.b23c					_GXMSOffset:
>b23c	1c						.byte 	32-8/2
>b23d	18						.byte 	32-16/2
>b23e	14						.byte 	32-24/2
>b23f	10						.byte 	32-32/2
.b240					GXOpenBitmap:
.b240	78		sei				sei 								; no interrupts here
.b241	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b243	8d de 05	sta $05de			sta 	gxOriginalLUTValue
.b246	58		cli				cli
.b247	60		rts				rts
.b248					GXCloseBitmap:
.b248	78		sei				sei
.b249	ad de 05	lda $05de			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b24c	85 0b		sta $0b				sta 	GXEditSlot
.b24e	58		cli				cli
.b24f	60		rts				rts
.b250					GXPositionCalc:
.b250	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b252	48		pha				pha
.b253	ad cf 05	lda $05cf			lda 	GXY0 						; gxzScreen = Y0
.b256	85 3c		sta $3c				sta 	gxzScreen
.b258	64 3d		stz $3d				stz 	gxzScreen+1
.b25a	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b25c	26 3d		rol $3d				rol 	gxzScreen+1
.b25e	06 3c		asl $3c				asl 	gxzScreen
.b260	26 3d		rol $3d				rol 	gxzScreen+1
.b262	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b263	65 3c		adc $3c				adc 	gxzScreen
.b265	85 3c		sta $3c				sta 	gxzScreen
.b267	90 02		bcc $b26b			bcc 	_GXPCNoCarry
.b269	e6 3d		inc $3d				inc 	gxzScreen+1
.b26b					_GXPCNoCarry:
.b26b	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b26d	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b26f	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b271	85 36		sta $36				sta 	gxzTemp0
.b273	64 3d		stz $3d				stz 	gxzScreen+1
.b275	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b277					_GXPCMultiply32:
.b277	06 3c		asl $3c				asl 	gxzScreen
.b279	26 3d		rol $3d				rol 	gxzScreen+1
.b27b	3a		dec a				dec 	a
.b27c	d0 f9		bne $b277			bne 	_GXPCMultiply32
.b27e	18		clc				clc
.b27f	ad cd 05	lda $05cd			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b282	65 3c		adc $3c				adc 	gxzScreen
.b284	8d df 05	sta $05df			sta 	gsOffset
.b287	ad ce 05	lda $05ce			lda 	GXX0+1
.b28a	65 3d		adc $3d				adc 	gxzScreen+1
.b28c	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b28e	90 04		bcc $b294			bcc 	_GXPCNoOverflow
.b290	29 1f		and #$1f			and 	#$1F 						; fix it up
.b292	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b294					_GXPCNoOverflow:
.b294	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b296	85 3d		sta $3d				sta 	gxzScreen+1
.b298	64 3c		stz $3c				stz 	gxzScreen
.b29a	18		clc				clc
.b29b	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b29d	6d d7 05	adc $05d7			adc 	gxBasePage 					; by adding the base page
.b2a0	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b2a2	68		pla				pla
.b2a3	85 36		sta $36				sta 	gxzTemp0
.b2a5	60		rts				rts
.b2a6					GXMovePositionDown:
.b2a6	18		clc				clc 								; add 320 to offset/temp+1
.b2a7	ad df 05	lda $05df			lda 	gsOffset
.b2aa	69 40		adc #$40			adc 	#64
.b2ac	8d df 05	sta $05df			sta 	gsOffset
.b2af	a5 3d		lda $3d				lda 	gxzScreen+1
.b2b1	69 01		adc #$01			adc 	#1
.b2b3	85 3d		sta $3d				sta 	gxzScreen+1
.b2b5	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b2b7	90 07		bcc $b2c0			bcc 	_GXMPDExit
.b2b9	38		sec				sec  								; next page
.b2ba	e9 20		sbc #$20			sbc 	#$20
.b2bc	85 3d		sta $3d				sta 	gxzScreen+1
.b2be	e6 0b		inc $0b				inc 	GXEditSlot
.b2c0					_GXMPDExit:
.b2c0	60		rts				rts
.b2c1					GXCollide:
.b2c1	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b2c3	aa		tax				tax
.b2c4	05 37		ora $37				ora 	gxzTemp0+1
.b2c6	29 c0		and #$c0			and 	#$C0
.b2c8	38		sec				sec
.b2c9	d0 53		bne $b31e			bne 	_GXCollideFail 				; if either >= 64, fail.
.b2cb	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b2cd	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b2d0	1d e5 05	ora $05e5,x			ora 	GXSpriteLow,x
.b2d3	30 48		bmi $b31d			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b2d5	18		clc				clc 								; need to calculate sum of sizes.
.b2d6	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y
.b2d9	7d 25 06	adc $0625,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b2dc	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b2de	6a		ror a				ror 	a 							; 5/6/7
.b2df	4a		lsr a				lsr 	a 							; 4/5/6
.b2e0	4a		lsr a				lsr 	a 							; 3/4/5
.b2e1	4a		lsr a				lsr 	a 							; 2/3/4
.b2e2	18		clc				clc
.b2e3	69 08		adc #$08			adc 	#$08
.b2e5	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b2e6	4a		lsr a				lsr 	a
.b2e7	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b2e9	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b2ec	29 3f		and #$3f			and 	#$3F
.b2ee	85 39		sta $39				sta 	gxzTemp1+1
.b2f0	38		sec				sec
.b2f1	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b2f4	29 3f		and #$3f			and 	#$3F
.b2f6	e5 39		sbc $39				sbc 	gxzTemp1+1
.b2f8	b0 03		bcs $b2fd			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b2fa	49 ff		eor #$ff			eor 	#$FF
.b2fc	1a		inc a				inc 	a
.b2fd					_GXCAbs1:
.b2fd	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b2ff	b0 1c		bcs $b31d			bcs 	_GXOkayFail
.b301	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b303	38		sec				sec 								; calculate |x1-x0|
.b304	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y
.b307	fd e5 05	sbc $05e5,x			sbc 	GXSpriteLow,x
.b30a	b0 03		bcs $b30f			bcs 	_GXCAbs2
.b30c	49 ff		eor #$ff			eor 	#$FF
.b30e	1a		inc a				inc 	a
.b30f					_GXCAbs2:
.b30f	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b311	b0 0a		bcs $b31d			bcs 	_GXOkayFail
.b313	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b315	90 02		bcc $b319			bcc 	_GXCHaveLowest
.b317	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b319					_GXCHaveLowest:
.b319	0a		asl a				asl 	a 							; scale to allow for >> 2
.b31a	0a		asl a				asl 	a
.b31b	18		clc				clc
.b31c	60		rts				rts
.b31d					_GXOkayFail:
.b31d	18		clc				clc
.b31e					_GXCollideFail:
.b31e	a9 ff		lda #$ff			lda 	#$FF
.b320	60		rts				rts
.b321					GXFindSprite:
.b321	aa		tax				tax
.b322	ad d8 05	lda $05d8			lda 	GXSpritePage 				; access the base page of the sprite
.b325	85 0b		sta $0b				sta 	GXEditSlot
.b327	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b32a	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b32d	f0 33		beq $b362			beq 	_GXFSFail
.b32f	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b332	8d 7c 06	sta $067c			sta 	GXSpriteOffset+1
.b335	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b338	48		pha				pha 								; save twice
.b339	48		pha				pha
.b33a	29 03		and #$03			and 	#3 							; get sprite size
.b33c	8d 79 06	sta $0679			sta 	GXSizeBits 					; save raw (0-3)
.b33f	aa		tax				tax
.b340	bd 64 b3	lda $b364,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b343	8d 78 06	sta $0678			sta 	GXSizePixels 					; save (8/16/24/32)
.b346	68		pla				pla 								; get LUT
.b347	4a		lsr a				lsr		a
.b348	4a		lsr a				lsr		a
.b349	29 03		and #$03			and 	#3
.b34b	8d 7a 06	sta $067a			sta 	GXSpriteLUT
.b34e	68		pla				pla 								; address, neeeds to be x 4
.b34f	29 f0		and #$f0			and 	#$F0
.b351	8d 7b 06	sta $067b			sta 	GXSpriteOffset
.b354	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b357	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b35a	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b35d	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b360	18		clc				clc
.b361	60		rts				rts
.b362					_GXFSFail:
.b362	38		sec				sec
.b363	60		rts				rts
.b364					_GXFXSSTTable:
>b364	08 10 18 20					.byte 	8,16,24,32
.0678					GXSizePixels:
>0678							.fill 	1
.0679					GXSizeBits:
>0679							.fill 	1
.067a					GXSpriteLUT:
>067a							.fill 	1
.067b					GXSpriteOffset:
>067b							.fill 	2
.b368					GXSortXY:
.b368	20 86 b3	jsr $b386			jsr 	GXSortY 					; will be sorted on Y now
.b36b	ad cd 05	lda $05cd			lda 	gxX0 						; compare X0 v X1
.b36e	cd d1 05	cmp $05d1			cmp 	gxX1
.b371	ad ce 05	lda $05ce			lda 	gXX0+1
.b374	ed d2 05	sbc $05d2			sbc 	gXX1+1
.b377	90 0c		bcc $b385			bcc 	_GXSXYExit 					; X0 < X1 exit
.b379	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b37b	a0 04		ldy #$04			ldy 	#4
.b37d	20 9a b3	jsr $b39a			jsr 	GXSwapXY
.b380	e8		inx				inx
.b381	c8		iny				iny
.b382	20 9a b3	jsr $b39a			jsr 	GXSwapXY
.b385					_GXSXYExit:
.b385	60		rts				rts
.b386					GXSortY:
.b386	ad cf 05	lda $05cf			lda 	gxY0 						; if Y0 >= Y1
.b389	cd d3 05	cmp $05d3			cmp 	gxY1
.b38c	90 0b		bcc $b399			bcc 	_GXSYSorted
.b38e	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b390	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b392					_GXSwap1:
.b392	20 9a b3	jsr $b39a			jsr 	GXSwapXY
.b395	88		dey				dey
.b396	ca		dex				dex
.b397	10 f9		bpl $b392			bpl 	_GXSwap1
.b399					_GXSYSorted:
.b399	60		rts				rts
.b39a					GXSwapXY:
.b39a	bd cd 05	lda $05cd,x			lda 	gxX0,x
.b39d	48		pha				pha
.b39e	b9 cd 05	lda $05cd,y			lda 	gxX0,y
.b3a1	9d cd 05	sta $05cd,x			sta 	gxX0,x
.b3a4	68		pla				pla
.b3a5	99 cd 05	sta $05cd,y			sta 	gxX0,y
.b3a8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b3a9					KeywordSet0:
>b3a9	00 65					.text	0,$65,""               ; $80 !0:EOF
>b3ab	00 58					.text	0,$58,""               ; $81 !1:SH1
>b3ad	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b3af	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b3b5	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b3bd	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b3c3	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b3ca	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>b3d2	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>b3d9	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>b3e0	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>b3e6	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>b3ec	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>b3f4	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>b3fb	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>b402	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>b409	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>b411	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>b417	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>b41d	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>b424	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>b42a	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>b430	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>b438	47 28
>b43a	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>b442	28
>b443	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>b44b	28
>b44c	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>b452	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>b458	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>b45e	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>b465	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>b46d	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>b473	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>b479	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>b47e	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>b482	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>b488	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>b490	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>b497	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>b49e	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>b4a6	43
>b4a7	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>b4ad	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>b4b3	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>b4ba	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>b4c0	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>b4c4	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>b4ca	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>b4d2	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>b4d9	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>b4de	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>b4e5	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>b4ed	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>b4f3	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>b4f8	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>b500	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>b506	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>b50c	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>b511	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>b518	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>b51e	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>b524	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>b52b	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>b532	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>b537	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>b53d	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>b544	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>b549	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>b54d	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>b555	45
>b556	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>b55e	45
>b55f	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>b565	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>b56c	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>b572	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>b578	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>b57d	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>b585	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>b58c	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>b593	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>b59b	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>b5a1	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>b5a5	ff					.text	$FF
.b5a6					KeywordSet1:
>b5a6	00 65					.text	0,$65,""               ; $80 !0:EOF
>b5a8	00 58					.text	0,$58,""               ; $81 !1:SH1
>b5aa	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b5ac	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b5b4	4c 45
>b5b6	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b5be	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b5c6	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b5cb	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>b5cf	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>b5d5	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>b5db	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>b5e0	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>b5e8	45
>b5e9	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>b5ee	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>b5f6	53
>b5f7	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>b5fd	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $8f WHO
>b602	ff					.text	$FF
.b603					KeywordSet2:
>b603	00 65					.text	0,$65,""               ; $80 !0:EOF
>b605	00 58					.text	0,$58,""               ; $81 !1:SH1
>b607	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b609	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b60e	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b613	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b618	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b61d	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b622	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b627	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b62c	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b631	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b636	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b63b	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b640	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b645	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b64a	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b64f	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b654	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b659	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b65e	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b663	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b668	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b66d	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b672	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b677	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b67c	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b681	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b686	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b68b	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b690	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b695	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b69a	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b69f	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b6a4	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b6a9	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b6ae	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b6b3	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b6b8	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b6bd	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b6c2	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b6c7	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b6cc	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b6d1	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b6d6	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b6db	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b6e0	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b6e5	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b6ea	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b6ef	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b6f4	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b6f9	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b6fe	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b703	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b708	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b70d	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b712	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b717	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b71c	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b721	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b726	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b72b	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b730	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b735	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b73a	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b73f	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b744	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b749	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b74e	ff					.text	$FF
.b74f					Export_TKListConvertLine:
.b74f	48		pha				pha 								; save indent on the stack
.b750	9c 1d 04	stz $041d			stz 	tbOffset
.b753	9c 2d 04	stz $042d			stz 	tokenBuffer
.b756	9c 29 04	stz $0429			stz 	currentListColour
.b759	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b75b	20 d8 b8	jsr $b8d8			jsr 	LCLWriteColour
.b75e	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b760	b1 30		lda ($30),y			lda 	(codePtr),y
.b762	aa		tax				tax
.b763	88		dey				dey
.b764	b1 30		lda ($30),y			lda 	(codePtr),y
.b766	20 49 b9	jsr $b949			jsr 	LCLWriteNumberXA
.b769	68		pla				pla 								; adjustment to indent
.b76a	48		pha				pha 								; save on stack
.b76b	10 0c		bpl $b779			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b76d	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b76e	6d 26 04	adc $0426			adc 	listIndent
.b771	8d 26 04	sta $0426			sta 	listIndent
.b774	10 03		bpl $b779			bpl 	_LCNoAdjust
.b776	9c 26 04	stz $0426			stz 	listIndent
.b779					_LCNoAdjust:
.b779	18		clc				clc		 							; work out actual indent.
.b77a	ad 26 04	lda $0426			lda 	listIndent
.b77d	0a		asl a				asl 	a
.b77e	69 07		adc #$07			adc 	#7
.b780	85 36		sta $36				sta 	zTemp0
.b782					_LCPadOut:
.b782	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b784	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b787	ad 1d 04	lda $041d			lda 	tbOffset
.b78a	c5 36		cmp $36				cmp 	zTemp0
.b78c	d0 f4		bne $b782			bne 	_LCPadOut
.b78e	a0 03		ldy #$03			ldy 	#3 							; start position.
.b790					_LCMainLoop:
.b790	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b792	20 d8 b8	jsr $b8d8			jsr 	LCLWriteColour
.b795	b1 30		lda ($30),y			lda 	(codePtr),y
.b797	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b799	f0 17		beq $b7b2			beq 	_LCExit
.b79b	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b79d	90 1e		bcc $b7bd			bcc 	_LCDoubles
.b79f	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b7a1	90 2a		bcc $b7cd			bcc 	_LCShiftPunc
.b7a3	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b7a5	90 35		bcc $b7dc			bcc 	_LCPunctuation
.b7a7	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b7a9	90 51		bcc $b7fc			bcc 	_LCIdentifiers
.b7ab	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b7ad	90 73		bcc $b822			bcc 	_LCTokens
.b7af	4c 82 b8	jmp $b882			jmp 	_LCData 					; 254-5 are data objects
.b7b2					_LCExit:
.b7b2	68		pla				pla 								; get old indent adjust
.b7b3	30 07		bmi $b7bc			bmi 	_LCExit2
.b7b5	18		clc				clc 								; add to indent if +ve
.b7b6	6d 26 04	adc $0426			adc 	listIndent
.b7b9	8d 26 04	sta $0426			sta 	listIndent
.b7bc					_LCExit2:
.b7bc	60		rts				rts
.b7bd					_LCDoubles:
.b7bd	48		pha				pha
.b7be	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b7bf	29 02		and #$02			and 	#2
.b7c1	09 3c		ora #$3c			ora 	#60 						; make < >
.b7c3	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b7c6	68		pla				pla 								; restore, do lower bit
.b7c7	29 03		and #$03			and 	#3
.b7c9	09 3c		ora #$3c			ora 	#60
.b7cb	80 0f		bra $b7dc			bra		_LCPunctuation 				; print, increment, loop
.b7cd					_LCShiftPunc:
.b7cd	aa		tax				tax 								; save in X
.b7ce	29 07		and #$07			and 	#7 							; lower 3 bits
.b7d0	f0 02		beq $b7d4			beq 	_LCNoAdd
.b7d2	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b7d4					_LCNoAdd:
.b7d4	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b7d6	90 02		bcc $b7da			bcc 	_LCNoAdd2
.b7d8	09 20		ora #$20			ora 	#32 						; adds $20
.b7da					_LCNoAdd2:
.b7da	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b7dc					_LCPunctuation:
.b7dc	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b7de	d0 03		bne $b7e3			bne 	_LCPContinue
.b7e0	20 f7 b8	jsr $b8f7			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b7e3					_LCPContinue:
.b7e3	c9 2e		cmp #$2e			cmp 	#'.'
.b7e5	f0 08		beq $b7ef			beq 	_LCPIsConstant
.b7e7	c9 30		cmp #$30			cmp 	#'0'
.b7e9	90 0b		bcc $b7f6			bcc 	_LCPNotConstant
.b7eb	c9 3a		cmp #$3a			cmp 	#'9'+1
.b7ed	b0 07		bcs $b7f6			bcs 	_LCPNotConstant
.b7ef					_LCPIsConstant:
.b7ef	48		pha				pha
.b7f0	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b7f2	20 d8 b8	jsr $b8d8			jsr 	LCLWriteColour
.b7f5	68		pla				pla
.b7f6					_LCPNotConstant:
.b7f6	c8		iny				iny 								; consume character
.b7f7	20 e1 b8	jsr $b8e1			jsr 	LCLWrite 					; write it out.
.b7fa	80 94		bra $b790			bra 	_LCMainLoop 				; go round again.
.b7fc					_LCIdentifiers:
.b7fc	18		clc				clc 								; convert to physical address
.b7fd	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b7ff	85 37		sta $37				sta 	zTemp0+1
.b801	c8		iny				iny
.b802	b1 30		lda ($30),y			lda 	(codePtr),y
.b804	85 36		sta $36				sta 	zTemp0
.b806	c8		iny				iny
.b807	5a		phy				phy 								; save position
.b808	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b80a	20 d8 b8	jsr $b8d8			jsr 	LCLWriteColour
.b80d	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b80f					_LCOutIdentifier:
.b80f	c8		iny				iny
.b810	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b812	29 7f		and #$7f			and 	#$7F
.b814	20 33 b9	jsr $b933			jsr 	LCLLowerCase
.b817	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b81a	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b81c	10 f1		bpl $b80f			bpl 	_LCOutIdentifier
.b81e	7a		ply				ply 								; restore position
.b81f	4c 90 b7	jmp $b790			jmp 	_LCMainLoop
.b822					_LCTokens:
.b822	aa		tax				tax 								; token in X
.b823	a9 03		lda #$03			lda 	#((KeywordSet2) & $FF)
.b825	85 36		sta $36				sta 	0+zTemp0
.b827	a9 b6		lda #$b6			lda 	#((KeywordSet2) >> 8)
.b829	85 37		sta $37				sta 	1+zTemp0
.b82b	e0 82		cpx #$82			cpx 	#$82
.b82d	f0 16		beq $b845			beq 	_LCUseShift
.b82f	a9 a6		lda #$a6			lda 	#((KeywordSet1) & $FF)
.b831	85 36		sta $36				sta 	0+zTemp0
.b833	a9 b5		lda #$b5			lda 	#((KeywordSet1) >> 8)
.b835	85 37		sta $37				sta 	1+zTemp0
.b837	e0 81		cpx #$81			cpx 	#$81
.b839	f0 0a		beq $b845			beq 	_LCUseShift
.b83b	a9 a9		lda #$a9			lda 	#((KeywordSet0) & $FF)
.b83d	85 36		sta $36				sta 	0+zTemp0
.b83f	a9 b3		lda #$b3			lda 	#((KeywordSet0) >> 8)
.b841	85 37		sta $37				sta 	1+zTemp0
.b843	80 01		bra $b846			bra 	_LCNoShift
.b845					_LCUseShift:
.b845	c8		iny				iny
.b846					_LCNoShift:
.b846	20 0b b9	jsr $b90b			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b849	b1 30		lda ($30),y			lda 	(codePtr),y
.b84b	aa		tax				tax 								; into X
.b84c					_LCFindText:
.b84c	ca		dex				dex
.b84d	10 0e		bpl $b85d			bpl 	_LCFoundText 				; found text.
.b84f	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b851	1a		inc a				inc 	a 							; one extra for size
.b852	38		sec				sec 								; one extra for checksum
.b853	65 36		adc $36				adc 	zTemp0 						; go to next token
.b855	85 36		sta $36				sta 	zTemp0
.b857	90 f3		bcc $b84c			bcc 	_LCFindText
.b859	e6 37		inc $37				inc 	zTemp0+1
.b85b	80 ef		bra $b84c			bra 	_LCFindText
.b85d					_LCFoundText:
.b85d	5a		phy				phy 								; save List position
.b85e	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b860	aa		tax				tax
.b861	a9 83		lda #$83			lda 	#CLIToken+$80
.b863	20 d8 b8	jsr $b8d8			jsr 	LCLWriteColour
.b866	a0 02		ldy #$02			ldy 	#2
.b868					_LCCopyToken:
.b868	b1 36		lda ($36),y			lda 	(zTemp0),y
.b86a	20 33 b9	jsr $b933			jsr 	LCLLowerCase
.b86d	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b870	c8		iny				iny
.b871	ca		dex				dex
.b872	d0 f4		bne $b868			bne 	_LCCopyToken
.b874	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b876	f0 05		beq $b87d			beq 	_LCNoSpace
.b878	a9 20		lda #$20			lda 	#' '
.b87a	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b87d					_LCNoSpace:
.b87d	7a		ply				ply 								; restore position.
.b87e	c8		iny				iny 								; consume token
.b87f	4c 90 b7	jmp $b790			jmp 	_LCMainLoop 				; and go around again.
.b882					_LCData:
.b882	48		pha				pha 								; save type $FE/$FF
.b883	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b885	c9 fe		cmp #$fe			cmp 	#$FE
.b887	f0 22		beq $b8ab			beq 	_LCHaveOpener
.b889	a2 22		ldx #$22			ldx 	#'"'
.b88b	a9 81		lda #$81			lda 	#CLIData+$80
.b88d	20 d8 b8	jsr $b8d8			jsr 	LCLWriteColour
.b890	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b892	d0 17		bne $b8ab			bne 	_LCHaveOpener
.b894	88		dey				dey 								; what precedes it ?
.b895	b1 30		lda ($30),y			lda 	(codePtr),y
.b897	c8		iny				iny
.b898	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b89a	d0 0f		bne $b8ab			bne 	_LCHaveOpener
.b89c	a9 09		lda #$09			lda 	#9 							; tab
.b89e	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b8a1	a9 97		lda #$97			lda 	#$90+CLIBComment
.b8a3	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b8a6	a9 80		lda #$80			lda 	#CLIFComment+$80
.b8a8	20 d8 b8	jsr $b8d8			jsr 	LCLWriteColour
.b8ab					_LCHaveOpener:
.b8ab	8a		txa				txa 								; output prefix (# or ")
.b8ac	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b8af	c8		iny				iny 								; get count
.b8b0	b1 30		lda ($30),y			lda 	(codePtr),y
.b8b2	aa		tax				tax
.b8b3	c8		iny				iny 								; point at first character
.b8b4					_LCOutData:
.b8b4	b1 30		lda ($30),y			lda 	(codePtr),y
.b8b6	c9 00		cmp #$00			cmp 	#0
.b8b8	f0 03		beq $b8bd			beq 	_LCNoPrint
.b8ba	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b8bd					_LCNoPrint:
.b8bd	c8		iny				iny
.b8be	ca		dex				dex
.b8bf	d0 f3		bne $b8b4			bne 	_LCOutData
.b8c1	68		pla				pla 								; closing " required ?
.b8c2	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b8c4	d0 0f		bne $b8d5			bne 	_LCNoQuote
.b8c6	a9 22		lda #$22			lda 	#'"'
.b8c8	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b8cb	ad c2 05	lda $05c2			lda 	EXTTextColour
.b8ce	29 0f		and #$0f			and 	#$0F
.b8d0	09 90		ora #$90			ora 	#$90
.b8d2	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b8d5					_LCNoQuote:
.b8d5	4c 90 b7	jmp $b790			jmp 	_LCMainLoop
.b8d8					LCLWriteColour:
.b8d8	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b8db	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b8de	d0 01		bne $b8e1			bne 	LCLWrite 					; if different, output it
.b8e0	60		rts				rts
.b8e1					LCLWrite:
.b8e1	da		phx				phx
.b8e2	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b8e5	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b8e8	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.b8eb	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.b8ee	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b8f0	30 03		bmi $b8f5			bmi 	_LCLNoColour
.b8f2	8d 27 04	sta $0427			sta 	LCLastCharacter
.b8f5					_LCLNoColour:
.b8f5	fa		plx				plx
.b8f6	60		rts				rts
.b8f7					LCLDeleteLastSpace:
.b8f7	48		pha				pha
.b8f8	da		phx				phx
.b8f9	ae 1d 04	ldx $041d			ldx 	tbOffset
.b8fc	f0 0a		beq $b908			beq 	_LCDLSExit
.b8fe	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.b901	c9 20		cmp #$20			cmp 	#' '
.b903	d0 03		bne $b908			bne 	_LCDLSExit
.b905	ce 1d 04	dec $041d			dec 	tbOffset
.b908					_LCDLSExit:
.b908	fa		plx				plx
.b909	68		pla				pla
.b90a	60		rts				rts
.b90b					LCLCheckSpaceRequired:
.b90b	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.b90e	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b910	f0 1b		beq $b92d			beq 	_LCCSRSpace
.b912	c9 29		cmp #$29			cmp 	#')'
.b914	f0 17		beq $b92d			beq 	_LCCSRSpace
.b916	c9 23		cmp #$23			cmp 	#'#'
.b918	f0 13		beq $b92d			beq 	_LCCSRSpace
.b91a	20 33 b9	jsr $b933			jsr 	LCLLowerCase 				; saves a little effort
.b91d	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b91f	90 11		bcc $b932			bcc 	_LCCSRExit
.b921	c9 3a		cmp #$3a			cmp 	#"9"+1
.b923	90 08		bcc $b92d			bcc 	_LCCSRSpace
.b925	c9 61		cmp #$61			cmp 	#"a"
.b927	90 09		bcc $b932			bcc 	_LCCSRExit
.b929	c9 7b		cmp #$7b			cmp 	#"z"+1
.b92b	b0 05		bcs $b932			bcs 	_LCCSRExit
.b92d					_LCCSRSpace:
.b92d	a9 20		lda #$20			lda 	#' '
.b92f	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b932					_LCCSRExit:
.b932	60		rts				rts
.b933					LCLLowerCase:
.b933	c9 41		cmp #$41			cmp 	#"A"
.b935	90 06		bcc $b93d			bcc 	_LCLLCOut
.b937	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b939	b0 02		bcs $b93d			bcs 	_LCLLCOut
.b93b	69 20		adc #$20			adc 	#$20
.b93d					_LCLLCOut:
.b93d	60		rts				rts
.b93e					LCLUpperCase:
.b93e	c9 61		cmp #$61			cmp 	#"a"
.b940	90 06		bcc $b948			bcc 	_LCLUCOut
.b942	c9 7b		cmp #$7b			cmp 	#"z"+1
.b944	b0 02		bcs $b948			bcs 	_LCLUCOut
.b946	e9 1f		sbc #$1f			sbc 	#$1F
.b948					_LCLUCOut:
.b948	60		rts				rts
.b949					LCLWriteNumberXA:
.b949	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.b94b					_LCLWNLoop1:
.b94b	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.b94d					_LCLWNLoop2:
.b94d	48		pha				pha 								; save initial LSB
.b94e	38		sec				sec
.b94f	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.b951	f9 82 b9	sbc $b982,y			sbc 	_LCLWNTable,y
.b954	48		pha				pha
.b955	8a		txa				txa
.b956	f9 83 b9	sbc $b983,y			sbc 	_LCLWNTable+1,y
.b959	90 07		bcc $b962			bcc 	_LCLWNUnderflow
.b95b	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.b95d	aa		tax				tax 								; update X
.b95e	68		pla				pla 								; restore A
.b95f	7a		ply				ply 								; throw original
.b960	80 eb		bra $b94d			bra 	_LCLWNLoop2 				; try again.
.b962					_LCLWNUnderflow:
.b962	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.b964	d0 06		bne $b96c			bne 	_LCLWNOut
.b966	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.b969	3a		dec a				dec 	a
.b96a	f0 04		beq $b970			beq 	_LCLWNNext
.b96c					_LCLWNOut:
.b96c	98		tya				tya
.b96d	20 7c b9	jsr $b97c			jsr 	_LCLWNOutDigit
.b970					_LCLWNNext:
.b970	7a		ply				ply 							 	; restore original value.
.b971	68		pla				pla
.b972	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.b974	c8		iny				iny
.b975	c8		iny				iny
.b976	84 37		sty $37				sty 	zTemp0+1
.b978	c0 08		cpy #$08			cpy 	#8 							; done all 4
.b97a	d0 cf		bne $b94b			bne 	_LCLWNLoop1
.b97c					_LCLWNOutDigit:
.b97c	09 30		ora #$30			ora 	#'0'
.b97e	20 e1 b8	jsr $b8e1			jsr 	LCLWrite
.b981	60		rts				rts
.b982					_LCLWNTable:
>b982	10 27						.word 	10000
>b984	e8 03						.word 	1000
>b986	64 00						.word 	100
>b988	0a 00						.word 	10
.b98a					TOKSearchTable:
.b98a	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b98c	85 36		sta $36				sta 	zTemp0
.b98e	a0 00		ldy #$00			ldy 	#0
.b990	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b992	85 38		sta $38				sta 	zTemp1
.b994					_TSTLoop:
.b994	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b996	30 49		bmi $b9e1			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b998	f0 2e		beq $b9c8			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b99a	c8		iny				iny 								; get the hash
.b99b	b1 36		lda ($36),y			lda 	(zTemp0),y
.b99d	88		dey				dey
.b99e	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b9a1	d0 25		bne $b9c8			bne 	_TSTNext
.b9a3	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.b9a6	38		sec				sec
.b9a7	ed 00 04	sbc $0400			sbc 	identStart
.b9aa	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b9ac	d0 1a		bne $b9c8			bne 	_TSTNext
.b9ae	5a		phy				phy 								; save Y , we might fail to match.
.b9af	c8		iny				iny 								; point to text
.b9b0	c8		iny				iny
.b9b1	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.b9b4					_TSTCompareName:
.b9b4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.b9b7	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b9b9	d0 0c		bne $b9c7			bne 	_TSTNextPullY 				; fail, pullY and do next
.b9bb	e8		inx				inx
.b9bc	c8		iny				iny
.b9bd	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.b9c0	d0 f2		bne $b9b4			bne 	_TSTCompareName
.b9c2	7a		ply				ply 								; throw Y
.b9c3	a5 38		lda $38				lda 	zTemp1 						; get token #
.b9c5	38		sec				sec 								; return with CS = passed.
.b9c6	60		rts				rts
.b9c7					_TSTNextPullY:
.b9c7	7a		ply				ply 								; restore current, fall through.
.b9c8					_TSTNext:
.b9c8	e6 38		inc $38				inc 	zTemp1 						; token counter
.b9ca	98		tya				tya
.b9cb	18		clc				clc
.b9cc	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b9ce	1a		inc a				inc 	a 							; +1
.b9cf	1a		inc a				inc 	a 							; +2
.b9d0	a8		tay				tay
.b9d1	10 c1		bpl $b994			bpl 	_TSTLoop 					; if Y < $80 loop back
.b9d3	98		tya				tya 								; add Y to zTemp0 and reset Y
.b9d4	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b9d6	18		clc				clc  								; but have tables > 255 bytes
.b9d7	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b9d9	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b9db	90 b7		bcc $b994			bcc 	_TSTLoop
.b9dd	e6 37		inc $37				inc 	zTemp0+1
.b9df	80 b3		bra $b994			bra 	_TSTLoop
.b9e1					_TSTFail:
.b9e1	18		clc				clc
.b9e2	60		rts				rts
.b9e3					Export_TKTokeniseLine:
.b9e3	20 6b bb	jsr $bb6b			jsr 	LCLFixLineBufferCase 		; fix line case
.b9e6	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b9e8	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b9eb	9c 2b 04	stz $042b			stz 	tokenLineNumber
.b9ee	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.b9f1	a2 ff		ldx #$ff			ldx 	#$FF
.b9f3					_TKFindFirst:
.b9f3	e8		inx				inx
.b9f4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b9f7	f0 79		beq $ba72			beq 	_TKExit
.b9f9	c9 20		cmp #$20			cmp 	#' '
.b9fb	90 f6		bcc $b9f3			bcc 	_TKFindFirst
.b9fd	c9 30		cmp #$30			cmp 	#'0'
.b9ff	90 07		bcc $ba08			bcc 	_TKNoLineNumber
.ba01	c9 3a		cmp #$3a			cmp 	#'9'+1
.ba03	b0 03		bcs $ba08			bcs 	_TKNoLineNumber
.ba05	20 95 bb	jsr $bb95			jsr 	TOKExtractLineNumber
.ba08					_TKNoLineNumber:
.ba08					_TKTokeniseLoop:
.ba08	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.ba0b	f0 65		beq $ba72			beq 	_TKExit
.ba0d	e8		inx				inx
.ba0e	c9 20		cmp #$20			cmp 	#' '
.ba10	f0 f6		beq $ba08			beq 	_TKTokeniseLoop 			; keep looping if space found.
.ba12	ca		dex				dex 								; undo last get, A contains character, X is position.
.ba13	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.ba15	f0 61		beq $ba78			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.ba17	c9 41		cmp #$41			cmp 	#'A'
.ba19	90 04		bcc $ba1f			bcc 	_TKTokenisePunctuation
.ba1b	c9 5b		cmp #$5b			cmp 	#'Z'+1
.ba1d	90 59		bcc $ba78			bcc 	_TKTokeniseIdentifier
.ba1f					_TKTokenisePunctuation:
.ba1f	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.ba21	f0 27		beq $ba4a			beq 	_TKString
.ba23	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.ba25	f0 28		beq $ba4f			beq 	_TKHexConstant
.ba27	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.ba29	f0 29		beq $ba54			beq 	_TKCheckDouble
.ba2b	c9 3e		cmp #$3e			cmp 	#'>'
.ba2d	f0 25		beq $ba54			beq 	_TKCheckDouble
.ba2f					_TKStandardPunctuation:
.ba2f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.ba32	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.ba34	90 0e		bcc $ba44			bcc 	_TKNoShift
.ba36	48		pha				pha 								; save. we are about to convert this punctuation token from
.ba37	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.ba39	85 36		sta $36				sta 	zTemp0
.ba3b	68		pla				pla
.ba3c	29 20		and #$20			and 	#32 						; bit 5
.ba3e	4a		lsr a				lsr 	a 							; shift into bit 3
.ba3f	4a		lsr a				lsr 	a
.ba40	05 36		ora $36				ora 	zTemp0
.ba42	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.ba44					_TKNoShift:
.ba44	20 da bb	jsr $bbda			jsr 	TOKWriteByte 				; write the punctuation character
.ba47	e8		inx				inx 								; consume the character
.ba48	80 be		bra $ba08			bra 	_TKTokeniseLoop 			; and loop round again.
.ba4a					_TKString:
.ba4a	20 fa ba	jsr $bafa			jsr 	TOKTokenString
.ba4d	80 b9		bra $ba08			bra 	_TKTokeniseLoop
.ba4f					_TKHexConstant:
.ba4f	20 35 bb	jsr $bb35			jsr 	TOKHexConstant
.ba52	80 b4		bra $ba08			bra 	_TKTokeniseLoop
.ba54					_TKCheckDouble:
.ba54	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.ba57	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.ba59	90 d4		bcc $ba2f			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.ba5b	c9 3f		cmp #$3f			cmp 	#'>'+1
.ba5d	b0 d0		bcs $ba2f			bcs 	_TKStandardPunctuation
.ba5f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.ba62	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.ba64	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.ba65	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.ba68	38		sec				sec
.ba69	e9 3c		sbc #$3c			sbc 	#'<'
.ba6b	20 da bb	jsr $bbda			jsr 	TOKWriteByte 				; this is in the range 0-7
.ba6e	e8		inx				inx 								; consume both
.ba6f	e8		inx				inx
.ba70	80 96		bra $ba08			bra 	_TKTokeniseLoop
.ba72	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.ba74	20 da bb	jsr $bbda			jsr 	TOKWriteByte
.ba77	60		rts				rts
.ba78					_TKTokeniseIdentifier:
.ba78	8e 00 04	stx $0400			stx 	identStart 					; save start
.ba7b	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.ba7e					_TKCheckLoop:
.ba7e	e8		inx				inx 								; look at next, we know first is identifier already.
.ba7f	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.ba82	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.ba84	f0 f8		beq $ba7e			beq 	_TKCheckLoop
.ba86	c9 30		cmp #$30			cmp	 	#"0"
.ba88	90 0c		bcc $ba96			bcc 	_TKEndIdentifier
.ba8a	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba8c	90 f0		bcc $ba7e			bcc 	_TKCheckLoop
.ba8e	c9 41		cmp #$41			cmp	 	#"A"
.ba90	90 04		bcc $ba96			bcc 	_TKEndIdentifier
.ba92	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba94	90 e8		bcc $ba7e			bcc 	_TKCheckLoop
.ba96					_TKEndIdentifier:
.ba96	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.ba99	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.ba9b	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.ba9d	f0 06		beq $baa5			beq 	_TKHasTypeCharacter
.ba9f	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.baa1	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.baa3	d0 07		bne $baac			bne 	_TKNoTypeCharacter
.baa5					_TKHasTypeCharacter:
.baa5	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.baa8	e8		inx				inx 								; consume the type character
.baa9	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.baac					_TKNoTypeCharacter:
.baac	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.baae	d0 09		bne $bab9			bne 	_TKNoArray
.bab0	e8		inx				inx 								; skip the (
.bab1	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.bab4	09 04		ora #$04			ora 	#$04
.bab6	8d 04 04	sta $0404			sta 	identTypeByte
.bab9					_TKNoArray:
.bab9	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.babc	20 56 bb	jsr $bb56			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.babf	a0 b3		ldy #$b3			ldy 	#(KeywordSet0) >> 8
.bac1	a9 a9		lda #$a9			lda 	#(KeywordSet0) & $FF
.bac3	20 8a b9	jsr $b98a			jsr 	TOKSearchTable
.bac6	a2 00		ldx #$00			ldx 	#0
.bac8	b0 1f		bcs $bae9			bcs 	_TKFoundToken
.baca	a0 b5		ldy #$b5			ldy 	#(KeywordSet1) >> 8
.bacc	a9 a6		lda #$a6			lda 	#(KeywordSet1) & $FF
.bace	20 8a b9	jsr $b98a			jsr 	TOKSearchTable
.bad1	a2 81		ldx #$81			ldx 	#$81
.bad3	b0 14		bcs $bae9			bcs 	_TKFoundToken
.bad5	a0 b6		ldy #$b6			ldy 	#(KeywordSet2) >> 8
.bad7	a9 03		lda #$03			lda 	#(KeywordSet2) & $FF
.bad9	20 8a b9	jsr $b98a			jsr 	TOKSearchTable
.badc	a2 82		ldx #$82			ldx 	#$82
.bade	b0 09		bcs $bae9			bcs 	_TKFoundToken
.bae0	20 e6 bb	jsr $bbe6			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bae3	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bae6	4c 08 ba	jmp $ba08			jmp 	_TKTokeniseLoop 			; and go round again.
.bae9					_TKFoundToken:
.bae9	48		pha				pha 								; save token
.baea	8a		txa				txa 								; shift in X, is there one ?
.baeb	f0 03		beq $baf0			beq 	_TKNoTShift
.baed	20 da bb	jsr $bbda			jsr 	TOKWriteByte 				; if so, write it out
.baf0					_TKNoTShift:
.baf0	68		pla				pla 								; restore and write token
.baf1	20 da bb	jsr $bbda			jsr 	TOKWriteByte
.baf4	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.baf7	4c 08 ba	jmp $ba08			jmp 	_TKTokeniseLoop 			; and go round again.
.bafa					TOKTokenString:
.bafa	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bafc	20 da bb	jsr $bbda			jsr 	TOKWriteByte
.baff	e8		inx				inx									; start of quoted string.
.bb00	da		phx				phx 								; push start of string on top
.bb01	ca		dex				dex 								; because we pre-increment
.bb02					_TSFindEnd:
.bb02	e8		inx				inx
.bb03	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bb06	f0 04		beq $bb0c			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bb08	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bb0a	d0 f6		bne $bb02			bne 	_TSFindEnd
.bb0c					_TSEndOfString:
.bb0c	7a		ply				ply  								; so now Y is first character, X is character after end.
.bb0d	48		pha				pha 								; save terminating character
.bb0e	20 16 bb	jsr $bb16			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bb11	68		pla				pla 								; terminating character
.bb12	f0 01		beq $bb15			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bb14	e8		inx				inx
.bb15					_TSNotQuote:
.bb15	60		rts				rts
.bb16					TOKWriteBlockXY:
.bb16	86 36		stx $36				stx 	zTemp0 						; save end character
.bb18	98		tya				tya 								; use 2's complement to work out the byte size
.bb19	49 ff		eor #$ff			eor 	#$FF
.bb1b	38		sec				sec
.bb1c	65 36		adc $36				adc 	zTemp0
.bb1e	1a		inc a				inc 	a 							; one extra for NULL
.bb1f	20 da bb	jsr $bbda			jsr 	TOKWriteByte
.bb22					_TOBlockLoop:
.bb22	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bb24	f0 09		beq $bb2f			beq 	_TOBlockExit
.bb26	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bb29	20 da bb	jsr $bbda			jsr 	TOKWriteByte
.bb2c	c8		iny				iny
.bb2d	80 f3		bra $bb22			bra 	_TOBlockLoop
.bb2f					_TOBlockExit:
.bb2f	a9 00		lda #$00			lda 	#0 							; add NULL.
.bb31	20 da bb	jsr $bbda			jsr 	TOKWriteByte
.bb34	60		rts				rts
.bb35					TOKHexConstant:
.bb35	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bb37	20 da bb	jsr $bbda			jsr 	TOKWriteByte
.bb3a	e8		inx				inx									; start of quoted string.
.bb3b	da		phx				phx 								; push start of constant on top
.bb3c	ca		dex				dex
.bb3d					_THFindLoop:
.bb3d	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bb3e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bb41	c9 30		cmp #$30			cmp 	#"0"
.bb43	90 0c		bcc $bb51			bcc 	_THFoundEnd
.bb45	c9 3a		cmp #$3a			cmp 	#"9"+1
.bb47	90 f4		bcc $bb3d			bcc 	_THFindLoop
.bb49	c9 41		cmp #$41			cmp 	#"A"
.bb4b	90 04		bcc $bb51			bcc 	_THFoundEnd
.bb4d	c9 47		cmp #$47			cmp 	#"F"+1
.bb4f	90 ec		bcc $bb3d			bcc 	_THFindLoop
.bb51					_THFoundEnd:
.bb51	7a		ply				ply 								; restore start
.bb52	20 16 bb	jsr $bb16			jsr 	TOKWriteBlockXY 			; output the block
.bb55	60		rts				rts
.bb56					TOKCalculateHash:
.bb56	da		phx				phx
.bb57	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bb5a	a9 00		lda #$00			lda 	#0
.bb5c					_TCHLoop:
.bb5c	18		clc				clc
.bb5d	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bb60	e8		inx				inx
.bb61	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bb64	d0 f6		bne $bb5c			bne 	_TCHLoop
.bb66	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bb69	fa		plx				plx
.bb6a	60		rts				rts
.bb6b					LCLFixLineBufferCase:
.bb6b	a2 00		ldx #$00			ldx 	#0
.bb6d					_FLBCLoop:
.bb6d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bb70	f0 22		beq $bb94			beq 	_FLBCExit 					; end of string.
.bb72	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bb74	f0 11		beq $bb87			beq 	_FLBCInQuotes
.bb76	e8		inx				inx
.bb77	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bb79	90 f2		bcc $bb6d			bcc 	_FLBCLoop
.bb7b	c9 7b		cmp #$7b			cmp 	#'z'+1
.bb7d	b0 ee		bcs $bb6d			bcs 	_FLBCLoop
.bb7f	38		sec				sec 								; make U/C
.bb80	e9 20		sbc #$20			sbc 	#32
.bb82	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bb85	80 e6		bra $bb6d			bra 	_FLBCLoop
.bb87					_FLBCInQuotes:
.bb87	e8		inx				inx 								; advance
.bb88	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bb8b	f0 07		beq $bb94			beq 	_FLBCExit 					; exit on EOS
.bb8d	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bb8f	d0 f6		bne $bb87			bne 	_FLBCInQuotes
.bb91	e8		inx				inx 								; skip over it
.bb92	80 d9		bra $bb6d			bra 	_FLBCLoop
.bb94					_FLBCExit:
.bb94	60		rts				rts
.bb95					TOKExtractLineNumber:
.bb95	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bb98	48		pha				pha
.bb99	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bb9c	48		pha				pha
.bb9d	20 d3 bb	jsr $bbd3			jsr 	_LCLNTimes2 				; line # x 2
.bba0	20 d3 bb	jsr $bbd3			jsr 	_LCLNTimes2 				; line # x 4
.bba3	18		clc				clc 								; add stacked value
.bba4	68		pla				pla
.bba5	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bba8	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bbab	68		pla				pla
.bbac	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bbaf	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bbb2	20 d3 bb	jsr $bbd3			jsr 	_LCLNTimes2 				; line # x 10
.bbb5	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bbb8	e8		inx				inx
.bbb9	29 0f		and #$0f			and 	#15 						; add to line #
.bbbb	18		clc				clc
.bbbc	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bbbf	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bbc2	90 03		bcc $bbc7			bcc 	_TLENNoCarry
.bbc4	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bbc7					_TLENNoCarry:
.bbc7	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bbca	c9 30		cmp #$30			cmp 	#'0'
.bbcc	90 04		bcc $bbd2			bcc 	_TLENExit
.bbce	c9 3a		cmp #$3a			cmp 	#'9'+1
.bbd0	90 c3		bcc $bb95			bcc 	TOKExtractLineNumber
.bbd2					_TLENExit:
.bbd2	60		rts				rts
.bbd3					_LCLNTimes2:
.bbd3	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bbd6	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bbd9	60		rts				rts
.bbda					TOKWriteByte:
.bbda	da		phx				phx
.bbdb	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bbde	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bbe1	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bbe4	fa		plx				plx
.bbe5	60		rts				rts
.bbe6					TOKCheckCreateVariableRecord:
.bbe6	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bbe8	85 36		sta $36				sta 	0+zTemp0
.bbea	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bbec	85 37		sta $37				sta 	1+zTemp0
.bbee					_CCVSearch:
.bbee	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bbf0	f0 2c		beq $bc1e			beq 	_CCVFail
.bbf2	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bbf4	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bbf6	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bbf9	d0 16		bne $bc11			bne 	_CCVNext
.bbfb	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bbfd	ae 00 04	ldx $0400			ldx 	identStart
.bc00					_CCVCompare:
.bc00	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bc03	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bc05	e8		inx				inx 								; advance pointers
.bc06	c8		iny				iny
.bc07	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bc08	d0 07		bne $bc11			bne 	_CCVNext  					; didn't match go to next.
.bc0a	90 f4		bcc $bc00			bcc 	_CCVCompare 				; not finished yet.
.bc0c	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bc0f	f0 41		beq $bc52			beq 	_CCVFound 					; yes, we were successful
.bc11					_CCVNext:
.bc11	18		clc				clc 								; go to next record.
.bc12	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bc14	65 36		adc $36				adc 	zTemp0
.bc16	85 36		sta $36				sta 	zTemp0
.bc18	90 d4		bcc $bbee			bcc 	_CCVSearch
.bc1a	e6 37		inc $37				inc 	zTemp0+1
.bc1c	80 d0		bra $bbee			bra 	_CCVSearch
.bc1e					_CCVFail:
.bc1e	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bc20	ad 03 04	lda $0403			lda 	identHash
.bc23	91 36		sta ($36),y			sta 	(zTemp0),y
.bc25	c8		iny				iny 								; offset 2 is the type byte
.bc26	ad 04 04	lda $0404			lda 	identTypeByte
.bc29	91 36		sta ($36),y			sta 	(zTemp0),y
.bc2b	c8		iny				iny
.bc2c					_CCVData:
.bc2c	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bc2e	91 36		sta ($36),y			sta 	(zTemp0),y
.bc30	c8		iny				iny
.bc31	c0 08		cpy #$08			cpy 	#8
.bc33	90 f7		bcc $bc2c			bcc 	_CCVData
.bc35	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bc38					_CCVCopyName:
.bc38	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bc3b	91 36		sta ($36),y			sta 	(zTemp0),y
.bc3d	e8		inx				inx
.bc3e	c8		iny				iny
.bc3f	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bc42	d0 f4		bne $bc38			bne 	_CCVCopyName
.bc44	98		tya				tya 								; patch offset
.bc45	92 36		sta ($36)			sta 	(zTemp0)
.bc47	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bc49	91 36		sta ($36),y			sta 	(zTemp0),y
.bc4b	88		dey				dey
.bc4c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bc4e	09 80		ora #$80			ora 	#$80
.bc50	91 36		sta ($36),y			sta 	(zTemp0),y
.bc52					_CCVFound:
.bc52	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bc54	38		sec				sec
.bc55	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bc57	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bc59	20 da bb	jsr $bbda			jsr 	TOKWriteByte
.bc5c	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bc5e	20 da bb	jsr $bbda			jsr 	TOKWriteByte
.bc61	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bc62					SNDCheckChannel:
.bc62	aa		tax				tax
.bc63	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bc66	d0 38		bne $bca0			bne 	_SNDCCExit
.bc68	da		phx				phx 								; save current channel
.bc69	8a		txa				txa 								; put in A
.bc6a	20 e6 bc	jsr $bce6			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bc6d	68		pla				pla 								; channel # in A
.bc6e	90 30		bcc $bca0			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bc70	a8		tay				tay 								; Y is the channel #
.bc71	bd 80 06	lda $0680,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bc74	99 7f 07	sta $077f,y			sta 	SNDPitchLow,y
.bc77	bd 81 06	lda $0681,x			lda 	SNDQueue+2,x
.bc7a	99 83 07	sta $0783,y			sta 	SNDPitchHigh,y
.bc7d	bd 82 06	lda $0682,x			lda 	SNDQueue+3,x
.bc80	99 87 07	sta $0787,y			sta 	SNDVolume,y
.bc83	bd 83 06	lda $0683,x			lda 	SNDQueue+4,x
.bc86	99 8b 07	sta $078b,y			sta 	SNDTimeLeft,y
.bc89	bd 84 06	lda $0684,x			lda 	SNDQueue+5,x
.bc8c	99 8f 07	sta $078f,y			sta 	SNDAdjustLow,y
.bc8f	bd 85 06	lda $0685,x			lda 	SNDQueue+6,x
.bc92	99 93 07	sta $0793,y			sta 	SNDAdjustHigh,y
.bc95	5a		phy				phy 								; save channel #
.bc96	20 00 bd	jsr $bd00			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bc99	ce 7e 06	dec $067e			dec 	SNDLength 					; reduce the queue length.
.bc9c	68		pla				pla
.bc9d	20 a1 bc	jsr $bca1			jsr 	SNDUpdateNote 				; update channel A
.bca0					_SNDCCExit:
.bca0	60		rts				rts
.bca1					SNDUpdateNote:
.bca1	aa		tax				tax 								; so we can access records
.bca2	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bca3	0a		asl a				asl 	a
.bca4	0a		asl a				asl 	a
.bca5	0a		asl a				asl 	a
.bca6	0a		asl a				asl 	a
.bca7	8d 7d 06	sta $067d			sta 	SNDChannelBits
.bcaa	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; are we silent
.bcad	f0 2e		beq $bcdd			beq 	_SNDUNIsSilent
.bcaf	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; push channel bits on stack
.bcb2	48		pha				pha
.bcb3	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bcb6	29 0f		and #$0f			and 	#$0F
.bcb8	0d 7d 06	ora $067d			ora 	SNDChannelBits 				; set channel bits
.bcbb	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bcbd	20 4a bd	jsr $bd4a			jsr 	SNDWritePorts
.bcc0	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bcc3	8d 7d 06	sta $067d			sta 	SNDChannelBits
.bcc6	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.bcc9	4e 7d 06	lsr $067d			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bccc	6a		ror a				ror 	a
.bccd	4e 7d 06	lsr $067d			lsr 	SNDChannelBits
.bcd0	6a		ror a				ror 	a
.bcd1	4a		lsr a				lsr 	a 							; put in bits 0-5
.bcd2	4a		lsr a				lsr 	a
.bcd3	20 4a bd	jsr $bd4a			jsr 	SNDWritePorts 				; write as rest of pitch register
.bcd6	68		pla				pla
.bcd7	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.bcd9	20 4a bd	jsr $bd4a			jsr 	SNDWritePorts
.bcdc	60		rts				rts
.bcdd					_SNDUNIsSilent:
.bcdd	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; channel bits
.bce0	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.bce2	20 4a bd	jsr $bd4a			jsr 	SNDWritePorts 				; write to the ports
.bce5	60		rts				rts
.bce6					SNDFindNextNoteForA:
.bce6	ac 7e 06	ldy $067e			ldy 	SNDLength 					; queue size into Y
.bce9	f0 13		beq $bcfe			beq 	_SNDFNNFail 				; queue empty.
.bceb	a2 00		ldx #$00			ldx 	#0
.bced					_SNDFNNSearch:
.bced	dd 7f 06	cmp $067f,x			cmp 	SNDQueue,x 					; does it match the channel
.bcf0	38		sec				sec
.bcf1	f0 0c		beq $bcff			beq 	_SNDFNNExit 				; if so exit with CS.
.bcf3	e8		inx				inx 								; next queue slot.
.bcf4	e8		inx				inx
.bcf5	e8		inx				inx
.bcf6	e8		inx				inx
.bcf7	e8		inx				inx
.bcf8	e8		inx				inx
.bcf9	e8		inx				inx
.bcfa	e8		inx				inx
.bcfb	88		dey				dey 								; done the whole queue
.bcfc	d0 ef		bne $bced			bne 	_SNDFNNSearch 				; no, go back.
.bcfe					_SNDFNNFail:
.bcfe	18		clc				clc
.bcff					_SNDFNNexit:
.bcff	60		rts				rts
.bd00					SNDDeleteXFromQueue:
.bd00	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.bd02	f0 09		beq $bd0d			beq 	_SNDDXExit
.bd04	bd 87 06	lda $0687,x			lda 	SNDQueue+8,x
.bd07	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.bd0a	e8		inx				inx
.bd0b	80 f3		bra $bd00			bra 	SNDDeleteXFromQueue
.bd0d					_SNDDXExit:
.bd0d	60		rts				rts
.067d					SNDChannelBits:
>067d							.fill 	1
.bd0e					SNDQueueRequest:
.bd0e	86 36		stx $36				stx 	zTemp0						; save queue address
.bd10	84 37		sty $37				sty 	zTemp0+1
.bd12	ae 7e 06	ldx $067e			ldx 	SNDLength 					; queue is full, can't take any more.
.bd15	e0 20		cpx #$20			cpx 	#SNDQueueSize
.bd17	f0 21		beq $bd3a			beq 	_SNDQRExit
.bd19	29 03		and #$03			and 	#3	 						; channel # and push on stack
.bd1b	48		pha				pha
.bd1c	8a		txa				txa  								; get offset in queue buffer/
.bd1d	0a		asl a				asl 	a
.bd1e	0a		asl a				asl 	a
.bd1f	0a		asl a				asl 	a
.bd20	aa		tax				tax
.bd21	68		pla				pla 								; get back and push again
.bd22	48		pha				pha
.bd23	9d 7f 06	sta $067f,x			sta 	SNDQueue+0,x 				; save the channel #
.bd26	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.bd28					_SNDQCopy:
.bd28	b1 36		lda ($36),y			lda 	(zTemp0),y
.bd2a	e8		inx				inx
.bd2b	c8		iny				iny
.bd2c	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.bd2f	c0 06		cpy #$06			cpy 	#6
.bd31	d0 f5		bne $bd28			bne 	_SNDQCopy
.bd33	ee 7e 06	inc $067e			inc 	SNDLength 					; bump queue length.
.bd36	68		pla				pla 								; get channel # back
.bd37	20 62 bc	jsr $bc62			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.bd3a					_SNDQRExit:
.bd3a	60		rts				rts
.bd3b					SNDSilenceChannel:
.bd3b	aa		tax				tax 								; zero time left.
.bd3c	9e 8b 07	stz $078b,x			stz 	SNDTimeLeft,x
.bd3f	0a		asl a				asl 	a 							; shift into position
.bd40	0a		asl a				asl 	a
.bd41	0a		asl a				asl 	a
.bd42	0a		asl a				asl 	a
.bd43	0a		asl a				asl 	a
.bd44	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.bd46	20 4a bd	jsr $bd4a			jsr 	SNDWritePorts
.bd49	60		rts				rts
.bd4a					SNDWritePorts:
.bd4a	da		phx				phx 								; save X
.bd4b	a6 01		ldx $01				ldx 	1 							; save I/O status
.bd4d	64 01		stz $01				stz 	1 							; access I/O page 0
.bd4f	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.bd52	8d 10 d6	sta $d610			sta 	$D610
.bd55	86 01		stx $01				stx 	1 							; restore I/O
.bd57	fa		plx				plx 								; restore X
.bd58	60		rts				rts
.bd59					Export_SNDCommand:
.bd59	da		phx				phx 								; save XY
.bd5a	5a		phy				phy
.bd5b	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.bd5d	f0 1d		beq $bd7c			beq 	_SNDInitialise
.bd5f	90 28		bcc $bd89			bcc 	_SNDExit
.bd61	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.bd63	f0 17		beq $bd7c			beq 	_SNDSilence
.bd65	b0 22		bcs $bd89			bcs 	_SNDExit
.bd67	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.bd69	b0 09		bcs $bd74			bcs 	_SNDQueryPlay
.bd6b	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.bd6d	b0 1a		bcs $bd89			bcs 	_SNDExit
.bd6f	20 0e bd	jsr $bd0e			jsr 	SNDQueueRequest
.bd72	80 15		bra $bd89			bra 	_SNDExit
.bd74					_SNDQueryPlay:
.bd74	29 03		and #$03			and 	#3 							; get channel #
.bd76	aa		tax				tax
.bd77	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.bd7a	80 0d		bra $bd89			bra 	_SNDExit
.bd7c					_SNDInitialise:
.bd7c					_SNDSilence:
.bd7c	9c 7e 06	stz $067e			stz 	SNDLength 					; empty the queue.
.bd7f	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.bd81					_SNDSilenceLoop:
.bd81	48		pha				pha
.bd82	20 3b bd	jsr $bd3b			jsr 	SNDSilenceChannel
.bd85	68		pla				pla
.bd86	3a		dec a				dec 	a
.bd87	10 f8		bpl $bd81			bpl 	_SNDSilenceLoop
.bd89					_SNDExit:
.bd89	7a		ply				ply
.bd8a	fa		plx				plx
.bd8b	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.067e					SNDLength:
>067e							.fill 	1
.067f					SNDQueue:
>067f							.fill 	SNDQueueSize * 8
.077f					SNDPitchLow:
>077f							.fill 	4
.0783					SNDPitchHigh:
>0783							.fill 	4
.0787					SNDVolume:
>0787							.fill 	4
.078b					SNDTimeLeft:
>078b							.fill 	4
.078f					SNDAdjustLow:
>078f							.fill 	4
.0793					SNDAdjustHigh:
>0793							.fill 	4
.bd8c					Export_SNDUpdate:
.bd8c					PagedSNDUpdate:
.bd8c	ad 8b 07	lda $078b			lda 	SNDTimeLeft+0 				; look at time remaining
.bd8f	f0 05		beq $bd96			beq 	_SNDUNot0 					; not playing
.bd91	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.bd93	20 b5 bd	jsr $bdb5			jsr 	SNDUpdateChannel 			; update it.
.bd96					_SNDUNot0:
.bd96	ad 8c 07	lda $078c			lda 	SNDTimeLeft+1
.bd99	f0 05		beq $bda0			beq 	_SNDUNot1
.bd9b	a2 01		ldx #$01			ldx 	#1
.bd9d	20 b5 bd	jsr $bdb5			jsr 	SNDUpdateChannel
.bda0					_SNDUNot1:
.bda0	ad 8d 07	lda $078d			lda 	SNDTimeLeft+2
.bda3	f0 05		beq $bdaa			beq 	_SNDUNot2
.bda5	a2 02		ldx #$02			ldx 	#2
.bda7	20 b5 bd	jsr $bdb5			jsr 	SNDUpdateChannel
.bdaa					_SNDUNot2:
.bdaa	ad 8e 07	lda $078e			lda 	SNDTimeLeft+3
.bdad	f0 05		beq $bdb4			beq 	_SNDUNot3
.bdaf	a2 03		ldx #$03			ldx 	#3
.bdb1	20 b5 bd	jsr $bdb5			jsr 	SNDUpdateChannel
.bdb4					_SNDUNot3:
.bdb4	60		rts				rts
.bdb5					SNDUpdateChannel:
.bdb5	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.bdb7	f0 2c		beq $bde5			beq 	_SNDUCExit
.bdb9	3a		dec a				dec 	a 							; decrement and update timer
.bdba	9d 8b 07	sta $078b,x			sta 	SNDTimeLeft,x
.bdbd	f0 1d		beq $bddc			beq 	_SNDUCUpdate 				; if zero, silence channel
.bdbf	bd 8f 07	lda $078f,x			lda 	SNDAdjustLow,x 				; adjust ?
.bdc2	1d 93 07	ora $0793,x			ora 	SNDAdjustHigh,x
.bdc5	f0 1e		beq $bde5			beq 	_SNDUCExit 					; if zero carry on at current tone.
.bdc7	18		clc				clc 								; add adjust, forcing into a 10 bit range
.bdc8	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.bdcb	7d 8f 07	adc $078f,x			adc 	SNDAdjustLow,x
.bdce	9d 7f 07	sta $077f,x			sta 	SNDPitchLow,x
.bdd1	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x
.bdd4	7d 93 07	adc $0793,x			adc 	SNDAdjustHigh,x
.bdd7	29 03		and #$03			and 	#3
.bdd9	9d 83 07	sta $0783,x			sta 	SNDPitchHigh,x
.bddc					_SNDUCUpdate:
.bddc	8a		txa				txa 								; which channel.
.bddd	48		pha				pha
.bdde	20 a1 bc	jsr $bca1			jsr 	SNDUpdateNote 				; update the current note
.bde1	68		pla				pla
.bde2	20 62 bc	jsr $bc62			jsr 	SNDCheckChannel 			; more to do ?
.bde5					_SNDUCExit:
.bde5	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
