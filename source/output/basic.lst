
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Sat Nov 26 10:06:36 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					isInputFlag:
>04a8							.fill 	1
.04a9					tokenOffset:
>04a9							.fill 	1
.04aa					tokenLineNumber:
>04aa							.fill 	2
.04ac					tokenBuffer:
>04ac							.fill 	253
.05a9					lineBuffer:
>05a9							.fill 	MaxLineSize+1
.05fa					numberBuffer:
>05fa							.fill 	34
.061c					decimalBuffer:
>061c							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 01 ab	jsr $ab01			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt display
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 64 8e	jsr $8e64			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 1b ba	jsr $ba1b			jsr 	SNDCommand
.8019	20 5b 89	jsr $895b			jsr 	NewProgram 					; erase current program
.801c	20 db 82	jsr $82db			jsr 	BackloadProgram
.801f	4c 9a 8a	jmp $8a9a			jmp 	CommandRun
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	52 65 6c 65 61 73 65 20			.text "Release Alpha 5 (26-Nov-22). "
>804b	41 6c 70 68 61 20 35 20 28 32 36 2d 4e 6f 76 2d
>805b	32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>8060	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8063					AssembleGroup1:
.8063	a9 ff		lda #$ff			lda 	#$FF
.8065	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8068	80 02		bra $806c			bra 	AsmGroup12
.806a					AssembleGroup2:
.806a	a9 00		lda #$00			lda 	#$00
.806c					AsmGroup12:
.806c	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.806f	68		pla				pla 								; pop the return address to access the information following.
.8070	fa		plx				plx
.8071	20 fa 80	jsr $80fa			jsr 	AccessParameters 			; get opcode and save as base
.8074	8d a4 04	sta $04a4			sta 	BaseOpcode
.8077	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.807a	d0 08		bne $8084			bne 	_AG12HaveMask
.807c	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.807e	20 02 81	jsr $8102			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8081	8d a5 04	sta $04a5			sta 	ModeMask
.8084					_AG12HaveMask:
.8084	20 3d 82	jsr $823d			jsr 	TypeAndCalculateOperand 	; get zero page type
.8087	da		phx				phx 								; save found address mode
.8088	20 66 81	jsr $8166			jsr 	AssembleModeX
.808b	fa		plx				plx  								; restore address mode
.808c	b0 0b		bcs $8099			bcs 	_AG12Exit
.808e	20 9a 80	jsr $809a			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8091	20 66 81	jsr $8166			jsr 	AssembleModeX
.8094	b0 03		bcs $8099			bcs 	_AG12Exit
.8096	4c 58 a0	jmp $a058			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8099					_AG12Exit:
.8099	60		rts				rts
.809a					PromoteToAbsolute:
.809a	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.809c	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.809e	f0 19		beq $80b9			beq 	_PTADo
.80a0	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80a2	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80a4	f0 13		beq $80b9			beq 	_PTADo
.80a6	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80a8	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80aa	f0 0d		beq $80b9			beq 	_PTADo
.80ac	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80ae	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b0	f0 07		beq $80b9			beq 	_PTADo
.80b2	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80b4	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80b6	f0 01		beq $80b9			beq 	_PTADo
.80b8	60		rts				rts
.80b9					_PTADo:
.80b9	aa		tax				tax
.80ba	60		rts				rts
.80bb					AssembleGroup3:
.80bb	68		pla				pla 								; get parameters, which is just the opcode.
.80bc	fa		plx				plx
.80bd	20 fa 80	jsr $80fa			jsr 	AccessParameters 			; get and output opcode
.80c0	20 12 81	jsr $8112			jsr 	AssemblerWriteByte
.80c3	20 a1 82	jsr $82a1			jsr 	CalculateOperand 			; get a 16 bit operand
.80c6	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80c9	38		sec				sec
.80ca	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80cd	48		pha				pha 								; LSB in A
.80ce	ad 10 04	lda $0410			lda 	NSMantissa1
.80d1	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80d4	aa		tax				tax 								; MSB in X
.80d5	68		pla				pla
.80d6	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80d7	69 7f		adc #$7f			adc 	#$7F
.80d9	90 01		bcc $80dc			bcc 	_AG3NoCarry
.80db	e8		inx				inx
.80dc					_AG3NoCarry:
.80dc	38		sec				sec 								; fix back and write out anyways.
.80dd	e9 80		sbc #$80			sbc 	#$80
.80df	20 12 81	jsr $8112			jsr 	AssemblerWriteByte
.80e2	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80e4	f0 0a		beq $80f0			beq 	_AG3Exit
.80e6	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80e9	29 01		and #$01			and 	#1
.80eb	f0 03		beq $80f0			beq 	_AG3Exit
.80ed	4c 5d a0	jmp $a05d			jmp 	RangeError 					; no, branch is out of range
.80f0					_AG3Exit:
.80f0	60		rts				rts
.80f1					AssembleGroup4:
.80f1	68		pla				pla 								; pop address
.80f2	fa		plx				plx
.80f3	20 fa 80	jsr $80fa			jsr 	AccessParameters 			; access and get first
.80f6	20 12 81	jsr $8112			jsr 	AssemblerWriteByte 			; output it.
.80f9	60		rts				rts
.80fa					AccessParameters:
.80fa	8d a1 04	sta $04a1			sta 	ParamStart
.80fd	8e a2 04	stx $04a2			stx 	ParamStart+1
.8100	a9 01		lda #$01			lda 	#1
.8102					GetParameter:
.8102	5a		phy				phy
.8103	a8		tay				tay
.8104	ad a1 04	lda $04a1			lda 	ParamStart
.8107	85 36		sta $36				sta 	zTemp0
.8109	ad a2 04	lda $04a2			lda 	ParamStart+1
.810c	85 37		sta $37				sta 	zTemp0+1
.810e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8110	7a		ply				ply
.8111	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.8112					AssemblerWriteByte:
.8112	48		pha			pha
.8113	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.8116	29 02		and #$02		and 	#2
.8118	f0 1b		beq $8135		beq 	_AWBNoPrint
.811a	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.811d	20 50 81	jsr $8150		jsr 	PrintHex
.8120	ad 9e 04	lda $049e		lda		AssemblerAddress
.8123	20 50 81	jsr $8150		jsr 	PrintHex
.8126	a9 20		lda #$20		lda 	#' '
.8128	20 8d a8	jsr $a88d		jsr 	EXTPrintCharacter
.812b	68		pla			pla 									; print byte
.812c	48		pha			pha
.812d	20 50 81	jsr $8150		jsr 	PrintHex
.8130	a9 0d		lda #$0d		lda 	#13
.8132	20 8d a8	jsr $a88d		jsr 	EXTPrintCharacter
.8135					_AWBNoPrint:
.8135	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8138	85 36		sta $36			sta 	zTemp0
.813a	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.813d	f0 0e		beq $814d		beq 	_AWBRange
.813f	85 37		sta $37			sta 	zTemp0+1
.8141	68		pla			pla 									; write byte out
.8142	92 36		sta ($36)		sta 	(zTemp0)
.8144	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.8147	d0 03		bne $814c		bne 	_AWBNoCarry
.8149	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.814c					_AWBNoCarry:
.814c	60		rts			rts
.814d					_AWBRange:
.814d	4c 5d a0	jmp $a05d		jmp 	RangeError
.8150					PrintHex:
.8150	48		pha				pha
.8151	4a		lsr a				lsr 	a
.8152	4a		lsr a				lsr 	a
.8153	4a		lsr a				lsr 	a
.8154	4a		lsr a				lsr 	a
.8155	20 59 81	jsr $8159			jsr 	_PrintNibble
.8158	68		pla				pla
.8159					_PrintNibble:
.8159	29 0f		and #$0f			and 	#15
.815b	c9 0a		cmp #$0a			cmp 	#10
.815d	90 02		bcc $8161			bcc 	_NoShift
.815f	69 06		adc #$06			adc 	#6
.8161					_NoShift:
.8161	69 30		adc #$30			adc 	#48
.8163	4c 8d a8	jmp $a88d			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8166					AssembleModeX:
.8166	5a		phy				phy
.8167	ad a3 04	lda $04a3			lda 	IsGroup1
.816a	f0 17		beq $8183			beq 	_AMXGroup2
.816c	8a		txa				txa 							; is it in group # 1
.816d	29 40		and #$40			and 	#AM_ISG1
.816f	f0 50		beq $81c1			beq 	_AMXFail 				; no, give up.
.8171	8a		txa				txa 							; get back.
.8172	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8174	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8176	d0 22		bne $819a			bne 	_AMXHaveInfo
.8178	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.817b	c9 81		cmp #$81			cmp 	#$81
.817d	f0 42		beq $81c1			beq 	_AMXFail
.817f	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.8181	80 17		bra $819a			bra 	_AMXHaveInfo 			; odd design decision there.
.8183					_AMXGroup2:
.8183	8a		txa				txa 							; is it in group 2 ?
.8184	29 20		and #$20			and 	#AM_ISG2
.8186	f0 39		beq $81c1			beq 	_AMXFail 				; no, give up.
.8188	8a		txa				txa 							; get the offset into Y
.8189	29 1f		and #$1f			and 	#$1F
.818b	4a		lsr a				lsr 	a 						; make it 0-7.
.818c	4a		lsr a				lsr  	a
.818d	a8		tay				tay
.818e	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.8191					_AMXCheckOkay:
.8191	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.8192	88		dey				dey
.8193	10 fc		bpl $8191			bpl 	_AMXCheckOkay
.8195	90 2a		bcc $81c1			bcc 	_AMXFail 				; not allowed.
.8197	8a		txa				txa  							; get mask back
.8198	29 1f		and #$1f			and 	#$1F
.819a					_AMXHaveInfo:
.819a	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.819c	10 05		bpl $81a3			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.819e	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81a1	d0 1e		bne $81c1			bne 	_AMXFail
.81a3					_AMXAnySize:
.81a3	18		clc				clc 							; add offset to the base opcode
.81a4	6d a4 04	adc $04a4			adc 	BaseOpcode
.81a7					_AMXOutputCode:
.81a7	20 12 81	jsr $8112			jsr 	AssemblerWriteByte 		; write the opcode out.
.81aa	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81ac	f0 10		beq $81be			beq 	_AMXExit
.81ae	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81b1	20 12 81	jsr $8112			jsr 	AssemblerWriteByte
.81b4	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81b6	30 06		bmi $81be			bmi 	_AMXExit
.81b8	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81bb	20 12 81	jsr $8112			jsr 	AssemblerWriteByte
.81be					_AMXExit:
.81be	7a		ply				ply
.81bf	38		sec				sec
.81c0	60		rts				rts
.81c1					_AMXFail:
.81c1	a0 00		ldy #$00			ldy 	#0
.81c3					_AMXCheckOddities:
.81c3	8a		txa				txa
.81c4	d9 ec 81	cmp $81ec,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81c7	d0 16		bne $81df			bne 	_AMXCONext
.81c9	b9 ea 81	lda $81ea,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81cc	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81cf	d0 0e		bne $81df			bne 	_AMXCONext
.81d1	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81d3	10 05		bpl $81da			bpl 	_AMXCONotZero
.81d5	ad 10 04	lda $0410			lda 	NSMantissa1
.81d8	d0 05		bne $81df			bne 	_AMXCONext
.81da					_AMXCONotZero:
.81da	b9 eb 81	lda $81eb,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81dd	80 c8		bra $81a7			bra 	_AMXOutputCode 			; and assemble it
.81df					_AMXCONext:
.81df	c8		iny				iny
.81e0	c8		iny				iny
.81e1	c8		iny				iny
.81e2	b9 ea 81	lda $81ea,y			lda 	ExtraOpcode+0,y 		; end of table
.81e5	d0 dc		bne $81c3			bne 	_AMXCheckOddities
.81e7					_AMXCOFail:
.81e7	7a		ply				ply
.81e8	18		clc				clc
.81e9	60		rts				rts
.81ea					ExtraOpcode:
>81ea	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81ed	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f0	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81f3	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81f6	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>81f9	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>81fc	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>81ff	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>8202	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>8205	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8208	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8209					LabelHere:
.8209	c8		iny				iny 								; skip .
.820a	a2 00		ldx #$00			ldx 	#0 							; get a term
.820c	20 94 98	jsr $9894			jsr 	EvaluateTerm 				; get a term
.820f	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.8212	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.8214	d0 24		bne $823a			bne 	_ALType
.8216	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8219	85 36		sta $36				sta 	zTemp0
.821b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.821e	85 37		sta $37				sta 	zTemp0+1
.8220	5a		phy				phy 								; copy address in.
.8221	a0 01		ldy #$01			ldy 	#1
.8223	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.8226	92 36		sta ($36)			sta 	(zTemp0)
.8228	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.822b	91 36		sta ($36),y			sta 	(zTemp0),y
.822d	c8		iny				iny
.822e	a9 00		lda #$00			lda 	#0
.8230	91 36		sta ($36),y			sta 	(zTemp0),y
.8232	c8		iny				iny
.8233	91 36		sta ($36),y			sta 	(zTemp0),y
.8235	c8		iny				iny
.8236	91 36		sta ($36),y			sta 	(zTemp0),y
.8238	7a		ply				ply
.8239	60		rts				rts
.823a					_ALType:
.823a	4c 62 a0	jmp $a062			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.823d					TypeAndCalculateOperand:
.823d	b1 30		lda ($30),y			lda 	(codePtr),y
.823f	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8241	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8243	f0 5b		beq $82a0			beq 	_TACOExit
.8245	c9 80		cmp #$80			cmp 	#KWC_EOL
.8247	f0 57		beq $82a0			beq 	_TACOExit
.8249	c8		iny				iny
.824a	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.824c	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.824e	f0 51		beq $82a1			beq 	CalculateOperand
.8250	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8252	f0 1f		beq $8273			beq 	_TACOIndirect
.8254	88		dey				dey 								; undo get of first character
.8255	20 a1 82	jsr $82a1			jsr 	CalculateOperand 			; get operand
.8258	b1 30		lda ($30),y			lda 	(codePtr),y
.825a	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.825c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.825e	d0 40		bne $82a0			bne 	_TACOExit
.8260	c8		iny				iny
.8261	20 ab 82	jsr $82ab			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8264	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.8266	c9 58		cmp #$58			cmp 	#'X'
.8268	f0 36		beq $82a0			beq 	_TACOExit
.826a	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.826c	c9 59		cmp #$59			cmp 	#'Y'
.826e	f0 30		beq $82a0			beq 	_TACOExit
.8270					_TACOSyntax:
.8270	4c 58 a0	jmp $a058			jmp 	SyntaxError
.8273					_TACOIndirect:
.8273	20 a1 82	jsr $82a1			jsr 	CalculateOperand 			; get the operand
.8276	b1 30		lda ($30),y			lda 	(codePtr),y
.8278	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.827a	f0 17		beq $8293			beq 	_TACOIndX
.827c	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.827f	b1 30		lda ($30),y			lda 	(codePtr),y
.8281	a2 d1		ldx #$d1			ldx 	#AM_IND
.8283	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.8285	d0 19		bne $82a0			bne 	_TACOExit
.8287	c8		iny				iny
.8288	20 ab 82	jsr $82ab			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.828b	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.828d	d0 e1		bne $8270			bne 	_TACOSyntax
.828f	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8291	80 0d		bra $82a0			bra 	_TACOExit
.8293					_TACOIndX:
.8293	c8		iny				iny
.8294	20 ab 82	jsr $82ab			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8297	c9 58		cmp #$58			cmp 	#'X' 						; check X
.8299	d0 d5		bne $8270			bne 	_TACOSyntax
.829b	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket			; check )
.829e	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a0					_TACOExit:
.82a0	60		rts				rts
.82a1					CalculateOperand:
.82a1	48		pha				pha
.82a2	da		phx				phx
.82a3	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82a5	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger
.82a8	fa		plx				plx
.82a9	68		pla				pla
.82aa	60		rts				rts
.82ab					TACOCheckXY:
.82ab	b1 30		lda ($30),y			lda 	(codePtr),y
.82ad	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82af	c9 40		cmp #$40			cmp 	#$40
.82b1	d0 21		bne $82d4			bne 	_TCXYFail
.82b3	b1 30		lda ($30),y			lda 	(codePtr),y
.82b5	18		clc				clc
.82b6	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82b8	85 37		sta $37				sta 	zTemp0+1
.82ba	c8		iny				iny
.82bb	b1 30		lda ($30),y			lda 	(codePtr),y
.82bd	c8		iny				iny
.82be	85 36		sta $36				sta 	zTemp0
.82c0	5a		phy				phy 								; save position
.82c1	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82c3	b1 36		lda ($36),y			lda 	(zTemp0),y
.82c5	d0 0c		bne $82d3			bne 	_TCXYPopFail
.82c7	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82c9	b1 36		lda ($36),y			lda 	(zTemp0),y
.82cb	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82cd	f0 08		beq $82d7			beq 	_TCXYFound
.82cf	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82d1	f0 04		beq $82d7			beq 	_TCXYFound
.82d3					_TCXYPopFail:
.82d3	7a		ply				ply
.82d4					_TCXYFail:
.82d4	a9 00		lda #$00			lda 	#0
.82d6	60		rts				rts
.82d7					_TCXYFound:
.82d7	7a		ply				ply 								; restore position
.82d8	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82da	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82db					BackloadProgram:
.82db	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82dd	a9 1a		lda #$1a			lda 	#_BLLoad & $FF
.82df	20 64 8e	jsr $8e64			jsr 	PrintStringXA
.82e2	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e4	8d 2c 06	sta $062c			sta 	0+BackLoadPointer
.82e7	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82e9	8d 2d 06	sta $062d			sta 	1+BackLoadPointer
.82ec					_BPLoop:
.82ec	a2 ff		ldx #$ff			ldx 	#$FF
.82ee	20 2f 83	jsr $832f			jsr 	BLReadByte 					; read a byte
.82f1	c9 00		cmp #$00			cmp 	#0
.82f3	f0 21		beq $8316			beq 	_BPExit 					; if 0 exit
.82f5	30 1f		bmi $8316			bmi 	_BPExit 					; if -ve exit
.82f7					_BPCopy:
.82f7	e8		inx				inx  								; copy byte into the lineBuffer
.82f8	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.82fb	9e aa 05	stz $05aa,x			stz 	lineBuffer+1,x
.82fe	20 2f 83	jsr $832f			jsr 	BLReadByte 					; read next byte
.8301	30 0a		bmi $830d			bmi 	_BPEndLine 					; -ve = EOL
.8303	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8305	d0 02		bne $8309			bne 	_BPNotTab
.8307	a9 20		lda #$20			lda 	#' '
.8309					_BPNotTab:
.8309	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.830b	b0 ea		bcs $82f7			bcs 	_BPCopy 					; until a control character, should be 13 received.
.830d					_BPEndLine:
.830d	20 ab b6	jsr $b6ab			jsr 	TokeniseLine 				; tokenise the line.
.8310	ea		nop				nop
.8311	20 46 83	jsr $8346			jsr 	EditProgramCode
.8314	80 d6		bra $82ec			bra 	_BPLoop
.8316					_BPExit:
.8316	20 04 84	jsr $8404			jsr 	ClearCommand 				; clear variables etc.
.8319	60		rts				rts
.831a					_BLLoad:
>831a	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8322	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.832f					BLReadByte:
.832f	ad 2c 06	lda $062c			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8332	85 36		sta $36				sta 	zTemp0
.8334	ad 2d 06	lda $062d			lda 	BackLoadPointer+1
.8337	85 37		sta $37				sta 	zTemp0+1
.8339	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.833b	ee 2c 06	inc $062c			inc 	BackLoadPointer 			; bump pointer
.833e	d0 03		bne $8343			bne 	_BLNoCarry
.8340	ee 2d 06	inc $062d			inc 	BackLoadPointer+1
.8343					_BLNoCarry:
.8343	c9 00		cmp #$00			cmp 	#0
.8345	60		rts				rts
.062c					BackLoadPointer:
>062c							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8346					EditProgramCode:
.8346	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line.
.8349	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1
.834c	20 71 a6	jsr $a671			jsr 	MemorySearch
.834f	90 05		bcc $8356			bcc 	_EPCNoDelete 				; reached the end don't delete
.8351	d0 03		bne $8356			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8353	20 92 a5	jsr $a592			jsr 	MemoryDeleteLine 			; delete the line
.8356					_EPCNoDelete:
.8356	ad ac 04	lda $04ac			lda 	TokenBuffer 				; buffer empty
.8359	c9 80		cmp #$80			cmp 	#KWC_EOL
.835b	f0 0d		beq $836a			beq 	_EPCNoInsert
.835d	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line - it cannot exist.
.8360	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8363	20 71 a6	jsr $a671			jsr 	MemorySearch
.8366	18		clc				clc 								; insert at this point.
.8367	20 c9 a5	jsr $a5c9			jsr 	MemoryInsertLine 			; insert the line
.836a					_EPCNoInsert:
.836a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.836b					WarmStart:
.836b	a2 ff		ldx #$ff			ldx 	#$FF
.836d	9a		txs				txs
.836e	20 1b aa	jsr $aa1b			jsr 	EXTInputLine 				; get line to lineBuffer
.8371	20 ab b6	jsr $b6ab			jsr 	TokeniseLine 				; tokenise the line
.8374	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; line number ?
.8377	0d ab 04	ora $04ab			ora 	TokenLineNumber+1
.837a	d0 17		bne $8393			bne 	_WSEditCode 				; if so,edit code.
.837c	9c a9 04	stz $04a9			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.837f	a9 a9		lda #$a9			lda 	#((TokenOffset) & $FF)
.8381	85 30		sta $30				sta 	codePtr
.8383	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8385	85 31		sta $31				sta 	codePtr+1
.8387	ad ac 04	lda $04ac			lda 	TokenBuffer 				; nothing to run
.838a	c9 80		cmp #$80			cmp 	#KWC_EOL
.838c	f0 dd		beq $836b			beq 	WarmStart
.838e	20 ac 8a	jsr $8aac			jsr 	RUNCodePointerLine 			; execute that line.
.8391	80 d8		bra $836b			bra 	WarmStart
.8393					_WSEditCode:
.8393	20 46 83	jsr $8346			jsr 	EditProgramCode
.8396	20 04 84	jsr $8404			jsr 	ClearCommand
.8399	80 d0		bra $836b			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.839b					AssembleCommand:
.839b	a2 00		ldx #$00			ldx 	#0
.839d	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger 		; start address
.83a0	ad 08 04	lda $0408			lda 	NSMantissa0
.83a3	8d 9e 04	sta $049e			sta 	AssemblerAddress
.83a6	ad 10 04	lda $0410			lda 	NSMantissa1
.83a9	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.83ac	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.83af	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; options
.83b2	ad 08 04	lda $0408			lda 	NSMantissa0
.83b5	8d a0 04	sta $04a0			sta 	AssemblerControl
.83b8	60		rts				rts
.83b9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83ba					AssertCommand:
.83ba	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83bc	20 1a 9e	jsr $9e1a			jsr 	EvaluateInteger 			; the assert test
.83bf	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; exit if result is non zero.
.83c2	d0 05		bne $83c9			bne 	_ACExit
.83c4	a9 0a		lda #$0a		lda	#10
.83c6	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.83c9					_ACExit:
.83c9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83ca					CallCommand:
.83ca	a2 00		ldx #$00			ldx 	#0
.83cc	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger
.83cf					_CCClear
.83cf	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83d0	20 ce 9e	jsr $9ece			jsr 	NSMSetZero
.83d3	e0 04		cpx #$04			cpx 	#4
.83d5	d0 f8		bne $83cf			bne 	_CCClear
.83d7	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83d9					_CCCParam:
.83d9	b1 30		lda ($30),y			lda 	(codePtr),y
.83db	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83dd	d0 09		bne $83e8			bne 	_CCCRun6502
.83df	c8		iny				iny 								; skip comma
.83e0	e8		inx				inx	 								; next level
.83e1	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83e4	e0 03		cpx #$03			cpx 	#3
.83e6	90 f1		bcc $83d9			bcc 	_CCCParam 					; done all 3 ?
.83e8					_CCCRun6502:
.83e8	5a		phy				phy 								; save position
.83e9	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83ec	85 37		sta $37				sta 	zTemp0+1
.83ee	ad 08 04	lda $0408			lda 	NSMantissa0
.83f1	85 36		sta $36				sta 	zTemp0
.83f3	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83f6	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83f9	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83fc	20 01 84	jsr $8401			jsr 	_CCCZTemp0 					; call zTemp0
.83ff	7a		ply				ply 								; restore position and exit
.8400	60		rts				rts
.8401					_CCCZTemp0:
.8401	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.8404					ClearCommand:
.8404	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8406	85 36		sta $36				sta 	0+zTemp0
.8408	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.840a	85 37		sta $37				sta 	1+zTemp0
.840c					_ClearZeroLoop:
.840c	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.840e	f0 24		beq $8434			beq 	_ClearZeroEnd
.8410	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.8412	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8414					_ClearOneVariable:
.8414	91 36		sta ($36),y			sta 	(zTemp0),y
.8416	c8		iny				iny
.8417	c0 08		cpy #$08			cpy 	#8
.8419	d0 f9		bne $8414			bne 	_ClearOneVariable
.841b	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.841d	b1 36		lda ($36),y			lda 	(zTemp0),y
.841f	c9 18		cmp #$18			cmp 	#NSTProcedure
.8421	d0 04		bne $8427			bne 	_ClearNotProcedure
.8423	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8425	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8427					_ClearNotProcedure:
.8427	18		clc				clc 								; go to the next variable
.8428	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.842a	65 36		adc $36				adc 	zTemp0
.842c	85 36		sta $36				sta 	zTemp0
.842e	90 dc		bcc $840c			bcc 	_ClearZeroLoop
.8430	e6 37		inc $37				inc 	zTemp0+1
.8432	80 d8		bra $840c			bra 	_ClearZeroLoop
.8434					_ClearZeroEnd:
.8434	18		clc				clc
.8435	a5 36		lda $36				lda 	zTemp0
.8437	69 01		adc #$01			adc 	#1
.8439	8d 8c 04	sta $048c			sta 	lowMemPtr
.843c	a5 37		lda $37				lda 	zTemp0+1
.843e	69 00		adc #$00			adc 	#0
.8440	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.8443	20 b2 a7	jsr $a7b2			jsr 	StackReset
.8446	20 1c a8	jsr $a81c			jsr 	StringSystemInitialise
.8449	20 fb 8c	jsr $8cfb			jsr 	ProcedureScan
.844c	20 5b 8a	jsr $8a5b			jsr 	Command_Restore
.844f	9c 9e 04	stz $049e			stz 	AssemblerAddress
.8452	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.8455	9c a0 04	stz $04a0			stz 	AssemblerControl
.8458	20 97 9a	jsr $9a97			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.845b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.845c					ClearScreen:
.845c	5a		phy				phy
.845d	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.845f	20 8d a8	jsr $a88d			jsr 	EXTPrintCharacter
.8462	7a		ply				ply
.8463	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8464					Command_Data:
.8464	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8466	a2 80		ldx #$80			ldx 	#KWC_EOL
.8468	20 4d 8d	jsr $8d4d			jsr 	ScanForward
.846b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.846c					DimCommand:
.846c	b1 30		lda ($30),y			lda 	(codePtr),y
.846e	29 c0		and #$c0			and 	#$C0
.8470	c9 40		cmp #$40			cmp 	#$40
.8472	d0 7a		bne $84ee			bne 	_DCSyntax
.8474	b1 30		lda ($30),y			lda 	(codePtr),y
.8476	18		clc				clc
.8477	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8479	85 3f		sta $3f				sta 	zaTemp+1
.847b	c8		iny				iny
.847c	b1 30		lda ($30),y			lda 	(codePtr),y
.847e	c8		iny				iny
.847f	85 3e		sta $3e				sta 	zaTemp
.8481	5a		phy				phy
.8482	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8484	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8486	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8488	c9 18		cmp #$18			cmp 	#NSTProcedure
.848a	f0 62		beq $84ee			beq 	_DCSyntax
.848c	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.848e	29 04		and #$04			and 	#NSBIsArray
.8490	f0 64		beq $84f6			beq 	_DCType
.8492	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8494	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8496	d0 59		bne $84f1			bne 	_DCRedefine
.8498	7a		ply				ply
.8499	20 f9 84	jsr $84f9			jsr 	_DCGetSize 				; get array size, check it.
.849c	5a		phy				phy
.849d	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.849f	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.84a1	7a		ply				ply 							; is there a second (e.g. ,x)
.84a2	b1 30		lda ($30),y			lda 	(codePtr),y
.84a4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84a6	d0 0a		bne $84b2			bne 	_DCOneDimension
.84a8	c8		iny				iny 							; skip comma
.84a9	20 f9 84	jsr $84f9			jsr 	_DCGetSize 				; get 2nd array size
.84ac	5a		phy				phy
.84ad	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84af	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84b1	7a		ply				ply
.84b2					_DCOneDimension:
.84b2	5a		phy				phy 							; save position
.84b3	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84b5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b7	aa		tax				tax
.84b8	c8		iny				iny
.84b9	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84bb	e8		inx				inx 							; bump them.
.84bc	1a		inc a				inc 	a
.84bd	20 63 9e	jsr $9e63			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84c0	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84c2	29 e0		and #$e0			and 	#$E0
.84c4	d0 23		bne $84e9			bne 	_DCSize
.84c6	a0 02		ldy #$02			ldy 	#2 						; get base type
.84c8	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ca	20 07 85	jsr $8507			jsr 	ScaleByBaseType 		; scale by base type
.84cd	a5 36		lda $36				lda 	zTemp0
.84cf	a6 37		ldx $37				ldx 	zTemp0+1
.84d1	20 59 9a	jsr $9a59			jsr 	AllocateXABytes 		; allocate memory
.84d4	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84d6	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84d8	c8		iny				iny
.84d9	8a		txa				txa
.84da	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84dc	7a		ply				ply 							; get position back
.84dd	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 		; check )
.84e0	b1 30		lda ($30),y			lda 	(codePtr),y
.84e2	c8		iny				iny 							; consume in case
.84e3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84e5	f0 85		beq $846c			beq 	DimCommand
.84e7	88		dey				dey 							; undo consume
.84e8	60		rts				rts
.84e9					_DCSize:
.84e9	a9 16		lda #$16		lda	#22
.84eb	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.84ee					_DCSyntax:
.84ee	4c 58 a0	jmp $a058			jmp 	SyntaxError
.84f1					_DCRedefine:
.84f1	a9 15		lda #$15		lda	#21
.84f3	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.84f6					_DCType:
.84f6	4c 62 a0	jmp $a062			jmp 	TypeError
.84f9					_DCGetSize:
.84f9	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84fb	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 	; get array dimension
.84fe	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8500	f0 e7		beq $84e9			beq 	_DCSize
.8502	c9 fe		cmp #$fe			cmp 	#254
.8504	f0 e3		beq $84e9			beq 	_DCSize
.8506	60		rts				rts
.8507					ScaleByBaseType:
.8507	29 10		and #$10			and 	#NSBIsString 			; is it string
.8509	d0 19		bne $8524			bne 	_SBBTString
.850b	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.850d	48		pha				pha
.850e	a5 36		lda $36				lda 	zTemp0
.8510	48		pha				pha
.8511	06 36		asl $36				asl 	zTemp0 					; x 2
.8513	26 37		rol $37				rol 	zTemp0+1
.8515	06 36		asl $36				asl 	zTemp0 					; x 4
.8517	26 37		rol $37				rol 	zTemp0+1
.8519	68		pla				pla 							; add stacked value = x 5
.851a	65 36		adc $36				adc 	zTemp0
.851c	85 36		sta $36				sta 	zTemp0
.851e	68		pla				pla
.851f	65 37		adc $37				adc 	zTemp0+1
.8521	85 37		sta $37				sta 	zTemp0+1
.8523	60		rts				rts
.8524					_SBBTString:
.8524	06 36		asl $36				asl 	zTemp0
.8526	26 37		rol $37				rol 	zTemp0+1
.8528	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8529					EndCommand:
.8529	4c 6b 83	jmp $836b			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.852c					ForCommand:
.852c	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.852e	20 4d a7	jsr $a74d			jsr 	StackOpen
.8531	a2 00		ldx #$00			ldx 	#0
.8533	20 94 98	jsr $9894			jsr 	EvaluateTerm
.8536	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8539	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.853b	d0 49		bne $8586			bne		_FCError
.853d	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.853f	20 02 8e	jsr $8e02			jsr 	CheckNextA
.8542	e8		inx				inx
.8543	20 1a 9e	jsr $9e1a			jsr 	EvaluateInteger 			; <from> in +1
.8546	b1 30		lda ($30),y			lda 	(codePtr),y
.8548	c8		iny				iny 								; consume it
.8549	48		pha				pha 								; save on stack for later
.854a	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.854c	f0 04		beq $8552			beq 	_FCNoSyntax
.854e	c9 ce		cmp #$ce			cmp 	#KWD_TO
.8550	d0 37		bne $8589			bne 	_FCSyntaxError
.8552					_FCNoSyntax:
.8552	e8		inx				inx
.8553	20 1a 9e	jsr $9e1a			jsr 	EvaluateInteger
.8556	20 91 a7	jsr $a791			jsr 	STKSaveCodePosition 		; save loop back position
.8559	68		pla				pla 								; restore DOWNTO or TO
.855a	5a		phy				phy 								; save Y on the stack
.855b	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.855d	f0 02		beq $8561			beq 	_FCNotDownTo
.855f	a9 02		lda #$02			lda 	#2
.8561					_FCNotDownTo:
.8561	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8562	a0 10		ldy #$10			ldy 	#16
.8564	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8566	a0 06		ldy #$06			ldy 	#6
.8568	ad 08 04	lda $0408			lda 	NSMantissa0
.856b	91 34		sta ($34),y			sta 	(basicStack),y
.856d	ad 10 04	lda $0410			lda 	NSMantissa1
.8570	c8		iny				iny
.8571	91 34		sta ($34),y			sta 	(basicStack),y
.8573	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8575	a2 01		ldx #$01			ldx 	#1
.8577	20 8c 85	jsr $858c			jsr 	FCIntegerToStack
.857a	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.857c	a2 02		ldx #$02			ldx 	#2
.857e	20 8c 85	jsr $858c			jsr 	FCIntegerToStack
.8581	20 ac 85	jsr $85ac			jsr 	CopyIndexToReference
.8584	7a		ply				ply 								; restore position
.8585	60		rts				rts
.8586					_FCError:
.8586	4c 62 a0	jmp $a062			jmp 	TypeError
.8589					_FCSyntaxError:
.8589	4c 58 a0	jmp $a058			jmp 	SyntaxError
.858c					FCIntegerToStack:
.858c	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.858f	10 03		bpl $8594			bpl	 	_FCNotNegative
.8591	20 83 9e	jsr $9e83			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8594					_FCNotNegative:
.8594	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8597	91 34		sta ($34),y			sta 	(basicStack),y
.8599	c8		iny				iny
.859a	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.859d	91 34		sta ($34),y			sta 	(basicStack),y
.859f	c8		iny				iny
.85a0	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.85a3	91 34		sta ($34),y			sta 	(basicStack),y
.85a5	c8		iny				iny
.85a6	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.85a9	91 34		sta ($34),y			sta 	(basicStack),y
.85ab	60		rts				rts
.85ac					CopyIndexToReference:
.85ac	5a		phy				phy
.85ad	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85af	38		sec				sec 								; (because we copy from offset 8)
.85b0	b1 34		lda ($34),y			lda 	(basicStack),y
.85b2	e9 08		sbc #$08			sbc 	#8
.85b4	85 36		sta $36				sta 	zTemp0
.85b6	c8		iny				iny
.85b7	b1 34		lda ($34),y			lda 	(basicStack),y
.85b9	e9 00		sbc #$00			sbc 	#0
.85bb	85 37		sta $37				sta 	zTemp0+1
.85bd	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85bf	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85c1	b1 34		lda ($34),y			lda 	(basicStack),y
.85c3	0a		asl a				asl 	a 							; into carry
.85c4	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85c6	90 14		bcc $85dc			bcc 	_CITRNormal
.85c8	38		sec				sec
.85c9					_CITRNegative:
.85c9	a9 00		lda #$00			lda 	#0
.85cb	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85cd	91 36		sta ($36),y			sta 	(zTemp0),y
.85cf	c8		iny				iny
.85d0	ca		dex				dex
.85d1	d0 f6		bne $85c9			bne 	_CITRNegative
.85d3	88		dey				dey 								; look at MSB of mantissa
.85d4	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85d6	09 80		ora #$80			ora 	#$80
.85d8	91 36		sta ($36),y			sta 	(zTemp0),y
.85da	7a		ply				ply
.85db	60		rts				rts
.85dc					_CITRNormal:
.85dc	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85de	91 36		sta ($36),y			sta 	(zTemp0),y
.85e0	c8		iny				iny
.85e1	ca		dex				dex
.85e2	d0 f8		bne $85dc			bne 	_CITRNormal
.85e4	7a		ply				ply 								; and exit.
.85e5	60		rts				rts
.85e6					NextCommand:
.85e6	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85e8	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85ea	20 79 a7	jsr $a779			jsr 	StackCheckFrame
.85ed	5a		phy				phy
.85ee	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85f0	b1 34		lda ($34),y			lda 	(basicStack),y
.85f2	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85f4	30 02		bmi $85f8			bmi 	_NCStepNeg
.85f6	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85f8					_NCStepNeg:
.85f8	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85fa	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85fc	18		clc				clc
.85fd					_NCBump:
.85fd	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85ff	91 34		sta ($34),y			sta 	(basicStack),y
.8601	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8603	c8		iny				iny 								; next byte
.8604	ca		dex				dex 								; do four times
.8605	d0 f6		bne $85fd			bne 	_NCBump
.8607	20 ac 85	jsr $85ac			jsr		CopyIndexToReference		; copy it to the reference variable.
.860a	a0 10		ldy #$10			ldy 	#16 						; get step count again
.860c	b1 34		lda ($34),y			lda 	(basicStack),y
.860e	0a		asl a				asl 	a 							; sign bit to carry
.860f	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8611	85 38		sta $38				sta 	zTemp1
.8613	90 02		bcc $8617			bcc 	_NCCompRev 					; use if step is +ve
.8615	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8617					_NCCompRev:
.8617	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8619	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.861b	85 39		sta $39				sta 	zTemp1+1
.861d	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.861f	38		sec				sec
.8620					_NCCompare:
.8620	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8622	b1 34		lda ($34),y			lda 	(basicStack),y
.8624	a4 39		ldy $39				ldy 	zTemp1+1
.8626	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8628	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.862a	e6 39		inc $39				inc 	zTemp1+1
.862c	ca		dex				dex 								; do it 4 times.
.862d	d0 f1		bne $8620			bne 	_NCCompare
.862f	50 02		bvc $8633			bvc 	_NCNoOverflow 				; convert to signed comparison
.8631	49 80		eor #$80			eor 	#$80
.8633					_NCNoOverflow:
.8633	7a		ply				ply 								; restore Y position
.8634	0a		asl a				asl 	a 							; is bit 7 set.
.8635	90 04		bcc $863b			bcc 	_NCLoopback 				; if no , >= so loop back
.8637	20 6b a7	jsr $a76b			jsr 	StackClose 					; exit the loop
.863a	60		rts				rts
.863b					_NCLoopBack:
.863b	20 a2 a7	jsr $a7a2			jsr 	STKLoadCodePosition 		; loop back
.863e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.863f					Command_GOSUB:
.863f	a2 00		ldx #$00			ldx 	#0
.8641	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8644	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8646	20 4d a7	jsr $a74d			jsr 	StackOpen 					; create frame
.8649	20 91 a7	jsr $a791			jsr 	STKSaveCodePosition 		; save current position
.864c	4c 62 86	jmp $8662			jmp 	GotoStackX
.864f					Command_RETURN:
.864f	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8651	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8653	20 79 a7	jsr $a779			jsr 	StackCheckFrame
.8656	20 a2 a7	jsr $a7a2			jsr 	STKLoadCodePosition 		; restore code position
.8659	20 6b a7	jsr $a76b			jsr 	StackClose
.865c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.865d					GotoCommand:
.865d	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.865f	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger
.8662					GotoStackX:
.8662	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8665	48		pha				pha 								; it is slightly inefficient, just in cases.
.8666	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8669	fa		plx				plx
.866a	20 71 a6	jsr $a671			jsr 	MemorySearch 				; transfer to line number AX.
.866d	90 05		bcc $8674			bcc 	_GotoError 					; not found, off end.
.866f	d0 03		bne $8674			bne 	_GotoError 					; not found exactly
.8671	4c a5 8a	jmp $8aa5			jmp 	RunNewLine 					; and go straight to new line code.
.8674					_GotoError:
.8674	a9 0d		lda #$0d		lda	#13
.8676	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8679					IfCommand:
.8679	a2 00		ldx #$00			ldx 	#0 							; If what.
.867b	20 f7 9d	jsr $9df7			jsr 	EvaluateNumber
.867e	b1 30		lda ($30),y			lda 	(codePtr),y
.8680	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8682	d0 0a		bne $868e			bne 	_IFStructured
.8684	c8		iny				iny 								; consume THEN
.8685	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; is it zero
.8688	f0 01		beq $868b			beq 	_IfFail 					; if fail, go to next line
.868a	60		rts				rts 								; if THEN just continue
.868b					_IfFail:
.868b	4c 8d 8a	jmp $8a8d			jmp 	EOLCommand
.868e					_IfStructured:
.868e	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; is it zero
.8691	d0 07		bne $869a			bne 	_IfExit 					; if not, then continue normally.
.8693	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8695	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8697	20 4d 8d	jsr $8d4d			jsr 	ScanForward 				; and run from there/
.869a					_IfExit:
.869a	60		rts				rts
.869b					ElseCode:
.869b	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.869d	aa		tax				tax 								; so just go to the structure exit
.869e	20 4d 8d	jsr $8d4d			jsr 	ScanForward
.86a1	60		rts				rts
.86a2					EndIf:
.86a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.86a3					Command_Input:
.86a3	a9 ff		lda #$ff			lda 	#$FF
.86a5	8d a8 04	sta $04a8			sta 	IsInputFlag
.86a8	80 03		bra $86ad			bra 	Command_IP_Main
.86aa					Command_Print:
.86aa	9c a8 04	stz $04a8			stz 	IsInputFlag
.86ad					Command_IP_Main:
.86ad	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86ae					_CPLoop:
.86ae	08		php				php 								; save last action flag
.86af	b1 30		lda ($30),y			lda 	(codePtr),y
.86b1	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86b3	f0 58		beq $870d			beq 	_CPExit
.86b5	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86b7	f0 54		beq $870d			beq 	_CPExit
.86b9	68		pla				pla 								; throw last action flag
.86ba	b1 30		lda ($30),y			lda 	(codePtr),y
.86bc	c8		iny				iny
.86bd	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86bf	f0 49		beq $870a			beq 	_CPContinueWithSameLine
.86c1	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86c3	f0 40		beq $8705			beq 	_CPTab
.86c5	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86c7	f0 38		beq $8701			beq 	_CPNewLine
.86c9	88		dey				dey 								; undo the get.
.86ca	20 b8 93	jsr $93b8			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86cd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; read the status
.86d0	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86d2	f0 0d		beq $86e1			beq 	_CPIsValue
.86d4	ad a8 04	lda $04a8			lda 	IsInputFlag 				; if print, dereference and print.
.86d7	f0 05		beq $86de			beq 	_CPIsPrint
.86d9	20 16 87	jsr $8716			jsr 	CIInputValue 				; input a value to the reference
.86dc	80 23		bra $8701			bra 	_CPNewLine
.86de					_CPIsPrint:
.86de	20 d8 96	jsr $96d8			jsr 	Dereference
.86e1					_CPIsValue:
.86e1	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.86e4	29 10		and #$10			and 	#NSBIsString
.86e6	f0 0b		beq $86f3			beq 	_CPNumber
.86e8	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.86eb	ad 08 04	lda $0408			lda 	NSMantissa0
.86ee	20 7f 87	jsr $877f			jsr 	CPPrintStringXA
.86f1	80 ba		bra $86ad			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86f3					_CPNumber:
.86f3	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86f5	20 c4 9c	jsr $9cc4			jsr 	ConvertNumberToString 		; convert to string
.86f8	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.86fa	a9 1c		lda #$1c			lda 	#DecimalBuffer & $FF
.86fc	20 7f 87	jsr $877f			jsr 	CPPrintStringXA
.86ff	80 ac		bra $86ad			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8701					_CPNewLine:
.8701	a9 0d		lda #$0d			lda 	#13
.8703	80 02		bra $8707			bra 	_CPPrintChar
.8705					_CPTab:
.8705	a9 09		lda #$09			lda 	#9 							; print TAB
.8707					_CPPrintChar:
.8707	20 92 87	jsr $8792			jsr 	CPPrintVector
.870a					_CPContinueWithSameLine:
.870a	38		sec				sec 								; loop round with carry set, which
.870b	80 a1		bra $86ae			bra 	_CPLoop 					; will inhibit final CR
.870d					_CPExit:
.870d	28		plp				plp 								; get last action flag
.870e	b0 05		bcs $8715			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8710	a9 0d		lda #$0d			lda 	#13 						; print new line
.8712	20 92 87	jsr $8792			jsr 	CPPrintVector
.8715					_CPExit2:
.8715	60		rts				rts
.8716					CIInputValue:
.8716	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8718					_CIInputLine:
.8718	20 95 87	jsr $8795			jsr 	CPInputVector 				; get key
.871b	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.871d	f0 1f		beq $873e			beq 	_CIHaveValue
.871f	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8721	f0 11		beq $8734			beq 	_CIBackspace
.8723	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8725	90 f1		bcc $8718			bcc 	_CIInputLine
.8727	e0 50		cpx #$50			cpx 	#80 						; max length
.8729	b0 ed		bcs $8718			bcs 	_CIInputLine
.872b	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.872e	e8		inx				inx
.872f	20 92 87	jsr $8792			jsr 	CPPrintVector 				; echo it.
.8732	80 e4		bra $8718			bra 	_CIInputLine
.8734					_CIBackSpace:
.8734	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8736	f0 e0		beq $8718			beq 	_CIInputLine
.8738	20 92 87	jsr $8792			jsr 	CPPrintVector 				; echo it.
.873b	ca		dex				dex
.873c	80 da		bra $8718			bra 	_CIInputLine
.873e					_CIHaveValue:
.873e	9e a9 05	stz $05a9,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.8741	ad 00 04	lda $0400			lda 	NSStatus 					; was it a string assignment
.8744	29 10		and #$10			and 	#NSBIsString
.8746	f0 1c		beq $8764			beq 	_CIAssignNumber 			; assign a number
.8748	a2 01		ldx #$01			ldx 	#1
.874a	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.874c	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.874f	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8751	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8754	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.8757	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.875a	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.875c	9d 00 04	sta $0400,x			sta  	NSStatus,x
.875f	ca		dex				dex 								; X = 0
.8760	20 d4 87	jsr $87d4			jsr 	AssignVariable
.8763	60		rts				rts
.8764					_CIAssignNumber:
.8764	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.8766	85 36		sta $36				sta 	zTemp0
.8768	a9 05		lda #$05			lda 	#lineBuffer >> 8
.876a	85 37		sta $37				sta 	zTemp0+1
.876c	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.876e	20 46 9c	jsr $9c46			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8771	90 07		bcc $877a			bcc 	_CIIsOkay
.8773	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8775	20 92 87	jsr $8792			jsr 	CPPrintVector
.8778	80 9c		bra $8716			bra 	CIInputValue
.877a					_CIIsOkay:
.877a	ca		dex				dex 								; X = 0
.877b	20 d4 87	jsr $87d4			jsr 	AssignVariable
.877e	60		rts				rts
.877f					CPPrintStringXA:
.877f	5a		phy				phy
.8780	86 37		stx $37				stx 	zTemp0+1
.8782	85 36		sta $36				sta 	zTemp0
.8784	a0 00		ldy #$00			ldy 	#0
.8786					_PSXALoop:
.8786	b1 36		lda ($36),y			lda 	(zTemp0),y
.8788	f0 06		beq $8790			beq 	_PSXAExit
.878a	20 92 87	jsr $8792			jsr 	CPPrintVector
.878d	c8		iny				iny
.878e	80 f6		bra $8786			bra 	_PSXALoop
.8790					_PSXAExit:
.8790	7a		ply				ply
.8791	60		rts				rts
.8792					CPPrintVector:
.8792	4c 8d a8	jmp $a88d			jmp 	EXTPrintCharacter
.8795					CPInputVector:
.8795	4c 23 ab	jmp $ab23			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8798					LetCommand:
.8798	a2 00		ldx #$00			ldx 	#0
.879a	b1 30		lda ($30),y			lda 	(codePtr),y
.879c	c9 10		cmp #$10			cmp 	#KWD_AT
.879e	d0 16		bne $87b6			bne 	_LCStandard
.87a0	c8		iny				iny 								; skip equal
.87a1	20 94 98	jsr $9894			jsr 	EvaluateTerm 				; get a number
.87a4	20 d8 96	jsr $96d8			jsr 	Dereference 				; dereference it
.87a7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.87aa	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.87ac	9d 00 04	sta $0400,x			sta 	NSStatus,x
.87af	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.87b1	d0 10		bne $87c3			bne 	_LCMain
.87b3	4c 62 a0	jmp $a062			jmp 	TypeError 					; was a reference before.
.87b6					_LCStandard:
.87b6	ad a2 93	lda $93a2			lda 	PrecedenceLevel+"*"			; precedence > this
.87b9	20 bc 93	jsr $93bc			jsr 	EvaluateExpressionAtPrecedence
.87bc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.87bf	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87c1	f0 0e		beq $87d1			beq 	_LetGoProc 					; it's a procedure call.
.87c3					_LCMain:
.87c3	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87c5	20 02 8e	jsr $8e02			jsr 	CheckNextA
.87c8	e8		inx				inx 								; RHS
.87c9	20 ee 9d	jsr $9dee			jsr 	EvaluateValue
.87cc	ca		dex				dex
.87cd	20 d4 87	jsr $87d4			jsr 	AssignVariable
.87d0	60		rts				rts
.87d1					_LetGoProc:
.87d1	4c 65 89	jmp $8965			jmp 	CallProcedure
.87d4					AssignVariable:
.87d4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.87d7	48		pha				pha 								; save a copy
.87d8	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.87db	29 10		and #$10			and 	#NSBIsString
.87dd	d0 0b		bne $87ea			bne 	_ASError
.87df	68		pla				pla 								; get back
.87e0	29 10		and #$10			and 	#NSBIsString 				; check type
.87e2	d0 03		bne $87e7			bne 	_ASString
.87e4	4c 00 96	jmp $9600			jmp 	AssignNumber
.87e7					_ASString:
.87e7	4c 6e 96	jmp $966e			jmp 	AssignString
.87ea					_ASError:
.87ea	4c 62 a0	jmp $a062			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87ed					Command_List:
.87ed	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.87f0	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87f3	9c 14 04	stz $0414			stz 	NSMantissa1+4
.87f6	a9 ff		lda #$ff			lda 	#$FF
.87f8	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.87fb	8d 17 04	sta $0417			sta 	NSMantissa1+7
.87fe	b1 30		lda ($30),y			lda 	(codePtr),y
.8800	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8802	f0 1e		beq $8822			beq 	_CLSecond
.8804	20 83 88	jsr $8883			jsr 	CLIsDigit 					; if not digit, list all
.8807	b0 24		bcs $882d			bcs 	_CLStart
.8809	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.880b	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger
.880e	b1 30		lda ($30),y			lda 	(codePtr),y
.8810	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8812	f0 0e		beq $8822			beq 	_CLSecond 					; if so go get it
.8814	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.8817	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.881a	ad 14 04	lda $0414			lda 	NSMantissa1+4
.881d	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8820	80 0b		bra $882d			bra 	_CLStart
.8822					_CLSecond:
.8822	c8		iny				iny 								; consume comma
.8823	20 83 88	jsr $8883			jsr 	CLIsDigit 					; digit found
.8826	b0 05		bcs $882d			bcs 	_CLStart 					; if not, continue listing
.8828	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.882a	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger
.882d					_CLStart
.882d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.882f	85 30		sta $30				sta 	codePtr
.8831	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8833	85 31		sta $31				sta 	codePtr+1
.8835					_CLLoop:
.8835	20 43 ab	jsr $ab43			jsr 	EXTBreakCheck 				; break check
.8838	f0 33		beq $886d			beq 	_CLExit
.883a	b2 30		lda ($30)			lda 	(codePtr)
.883c	f0 2f		beq $886d			beq 	_CLExit
.883e	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8840	20 70 88	jsr $8870			jsr 	CLCompareLineNo
.8843	90 1b		bcc $8860			bcc 	_CLNext
.8845	a2 07		ldx #$07			ldx 	#7
.8847	20 70 88	jsr $8870			jsr 	CLCompareLineNo
.884a	f0 02		beq $884e			beq 	_CLDoThisOne
.884c	b0 12		bcs $8860			bcs 	_CLNext
.884e					_CLDoThisOne:
.884e	20 b0 8d	jsr $8db0			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8851	20 8d b4	jsr $b48d			jsr 	ListConvertLine 			; convert line into token Buffer
.8854	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8856	a9 ac		lda #$ac			lda 	#(tokenBuffer & $FF)
.8858	20 64 8e	jsr $8e64			jsr 	PrintStringXA
.885b	a9 0d		lda #$0d			lda 	#13 						; new line
.885d	20 8d a8	jsr $a88d			jsr 	EXTPrintCharacter
.8860					_CLNext:
.8860	18		clc				clc
.8861	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8863	65 30		adc $30				adc 	codePtr
.8865	85 30		sta $30				sta 	codePtr
.8867	90 02		bcc $886b			bcc 	_CREExit
.8869	e6 31		inc $31				inc 	codePtr+1 					; carry
.886b					_CREExit:
.886b	80 c8		bra $8835			bra 	_CLLoop
.886d					_CLExit:
.886d	4c 6b 83	jmp $836b			jmp 	WarmStart
.8870					CLCompareLineNo:
.8870	38		sec				sec
.8871	a0 01		ldy #$01			ldy 	#1
.8873	b1 30		lda ($30),y			lda 	(codePtr),y
.8875	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.8878	85 36		sta $36				sta 	zTemp0
.887a	c8		iny				iny
.887b	b1 30		lda ($30),y			lda 	(codePtr),y
.887d	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8880	05 36		ora $36				ora 	zTemp0
.8882	60		rts				rts
.8883					CLIsDigit:
.8883	b1 30		lda ($30),y			lda 	(codePtr),y
.8885	c9 30		cmp #$30			cmp 	#"0"
.8887	90 03		bcc $888c			bcc	 	_CLIDExitFalse
.8889	c9 3a		cmp #$3a			cmp 	#"9"+1
.888b	60		rts				rts
.888c					_CLIDExitFalse:
.888c	38		sec				sec
.888d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.888e					Command_LOCAL:
.888e	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8890	20 9c 88	jsr $889c			jsr 	LocaliseNextTerm 			; convert term to a local.
.8893	b1 30		lda ($30),y			lda 	(codePtr),y
.8895	c8		iny				iny
.8896	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8898	f0 f4		beq $888e			beq 	Command_LOCAL
.889a	88		dey				dey 								; unpick pre-get
.889b	60		rts				rts
.889c					LocaliseNextTerm:
.889c	20 94 98	jsr $9894			jsr 	EvaluateTerm 				; evaluate the term
.889f	bd 00 04	lda $0400,x			lda 	NSStatus,x
.88a2	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.88a4	f0 61		beq $8907			beq		_LNTError
.88a6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.88a9	85 36		sta $36				sta 	zTemp0
.88ab	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.88ae	85 37		sta $37				sta  	zTemp0+1
.88b0	bd 00 04	lda $0400,x			lda 	NSStatus,x
.88b3	29 10		and #$10			and 	#NSBIsString
.88b5	d0 1e		bne $88d5			bne 	_LNTPushString
.88b7	5a		phy				phy
.88b8	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.88ba					_LNTPushNumLoop:
.88ba	b1 36		lda ($36),y			lda		(zTemp0),y
.88bc	20 2b a7	jsr $a72b			jsr 	StackPushByte
.88bf	c8		iny				iny
.88c0	c0 05		cpy #$05			cpy 	#5
.88c2	d0 f6		bne $88ba			bne 	_LNTPushNumLoop
.88c4	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.88c6	20 2b a7	jsr $a72b			jsr 	StackPushByte
.88c9	a5 37		lda $37				lda 	zTemp0+1
.88cb	20 2b a7	jsr $a72b			jsr 	StackPushByte
.88ce	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88d0	20 2b a7	jsr $a72b			jsr 	StackPushByte
.88d3	7a		ply				ply
.88d4	60		rts				rts
.88d5					_LNTPushString:
.88d5	5a		phy				phy
.88d6	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88d8	85 38		sta $38				sta 	zTemp1
.88da	a0 01		ldy #$01			ldy 	#1
.88dc	b1 36		lda ($36),y			lda 	(zTemp0),y
.88de	85 39		sta $39				sta 	zTemp1+1
.88e0	a0 00		ldy #$00			ldy 	#0 							; output string
.88e2	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88e4	f0 0a		beq $88f0			beq 	_LNTStringOut
.88e6					_LNTPushStrLoop:
.88e6	b1 38		lda ($38),y			lda 	(zTemp1),y
.88e8	f0 06		beq $88f0			beq 	_LNTStringOut
.88ea	20 2b a7	jsr $a72b			jsr 	StackPushByte
.88ed	c8		iny				iny
.88ee	80 f6		bra $88e6			bra 	_LNTPushStrLoop
.88f0					_LNTStringOut:
.88f0	98		tya				tya									; output length
.88f1	20 2b a7	jsr $a72b			jsr 	StackPushByte
.88f4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.88f7	20 2b a7	jsr $a72b			jsr 	StackPushByte
.88fa	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.88fd	20 2b a7	jsr $a72b			jsr 	StackPushByte
.8900	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8902	20 2b a7	jsr $a72b			jsr 	StackPushByte
.8905	7a		ply				ply
.8906	60		rts				rts
.8907					_LNTError:
.8907	4c 58 a0	jmp $a058			jmp 	SyntaxError
.890a					LocalPopValue:
.890a	20 44 a7	jsr $a744			jsr 	StackPopByte
.890d	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.890f	d0 17		bne $8928			bne 	_LPVString
.8911	20 44 a7	jsr $a744			jsr 	StackPopByte 				; address
.8914	85 37		sta $37				sta 	zTemp0+1
.8916	20 44 a7	jsr $a744			jsr 	StackPopByte
.8919	85 36		sta $36				sta 	zTemp0
.891b	5a		phy				phy
.891c	a0 04		ldy #$04			ldy 	#4 							; copy back
.891e					_LPVNumberCopy:
.891e	20 44 a7	jsr $a744			jsr 	StackPopByte
.8921	91 36		sta ($36),y			sta 	(zTemp0),y
.8923	88		dey				dey
.8924	10 f8		bpl $891e			bpl 	_LPVNumberCopy
.8926	7a		ply				ply 								; and complete
.8927	60		rts				rts
.8928					_LPVString:
.8928	20 44 a7	jsr $a744			jsr 	StackPopByte 				; address of record => zTemp0
.892b	85 37		sta $37				sta 	zTemp0+1
.892d	20 44 a7	jsr $a744			jsr 	StackPopByte
.8930	85 36		sta $36				sta 	zTemp0
.8932	5a		phy				phy
.8933	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8935	85 38		sta $38				sta 	zTemp1
.8937	a0 01		ldy #$01			ldy 	#1
.8939	b1 36		lda ($36),y			lda 	(zTemp0),y
.893b	85 39		sta $39				sta 	zTemp1+1
.893d	20 44 a7	jsr $a744			jsr 	StackPopByte 				; # to get => y
.8940	a8		tay				tay
.8941	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8943	f0 0e		beq $8953			beq 	_LPVStringCopied
.8945	a9 00		lda #$00			lda 	#0 							; NULL on end
.8947	91 38		sta ($38),y			sta 	(zTemp1),y
.8949					_LPVStringCopy:
.8949	88		dey				dey
.894a	30 07		bmi $8953			bmi 	_LPVStringCopied
.894c	20 44 a7	jsr $a744			jsr 	StackPopByte
.894f	91 38		sta ($38),y			sta 	(zTemp1),y
.8951	80 f6		bra $8949			bra 	_LPVStringCopy
.8953					_LPVStringCopied:
.8953	fa		plx				plx
.8954	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8955					NewCommand:
.8955	20 5b 89	jsr $895b			jsr 	NewProgram 					; does the actual NEW.
.8958	4c 6b 83	jmp $836b			jmp 	WarmStart 					; and warm starts straight away.
.895b					NewProgram:
.895b	20 4f a6	jsr $a64f			jsr 	MemoryNew
.895e	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8961	20 04 84	jsr $8404			jsr 	ClearCommand 				; clear everything.
.8964	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8965					CallProcedure:
.8965	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8967	b1 30		lda ($30),y			lda 	(codePtr),y
.8969	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.896b	f0 0c		beq $8979			beq 	_CPEndParam
.896d					_CPParamLoop:
.896d	20 ee 9d	jsr $9dee			jsr 	EvaluateValue 				; get parameter onto stack
.8970	e8		inx				inx 								; bump next stack
.8971	b1 30		lda ($30),y			lda 	(codePtr),y
.8973	c8		iny				iny
.8974	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8976	f0 f5		beq $896d			beq 	_CPParamLoop
.8978	88		dey				dey 								; unpick.
.8979					_CPEndParam:
.8979	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.897c	c8		iny				iny									; skip right bracket
.897d	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.897f	20 4d a7	jsr $a74d			jsr 	StackOpen
.8982	20 91 a7	jsr $a791			jsr 	STKSaveCodePosition 		; save loop position
.8985	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8988	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.898a	ad 10 04	lda $0410			lda 	NSMantissa1
.898d	85 37		sta $37				sta 	zTemp0+1
.898f	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8991	b2 36		lda ($36)			lda 	(zTemp0)
.8993	85 30		sta $30				sta 	safePtr
.8995	b1 36		lda ($36),y			lda 	(zTemp0),y
.8997	85 31		sta $31				sta 	safePtr+1
.8999	c8		iny				iny
.899a	b1 36		lda ($36),y			lda 	(zTemp0),y
.899c	85 32		sta $32				sta 	safePtr+2
.899e	c8		iny				iny
.899f	b1 36		lda ($36),y			lda 	(zTemp0),y
.89a1	85 33		sta $33				sta 	safePtr+3
.89a3	c8		iny				iny 								; get Y offset -> Y
.89a4	b1 36		lda ($36),y			lda 	(zTemp0),y
.89a6	a8		tay				tay
.89a7	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.89a9	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.89ac	f0 13		beq $89c1			beq 	_ParamExit 					; if so, exit.
.89ae					_ParamExtract:
.89ae	ca		dex				dex 								; put a local term on the level before
.89af	20 9c 88	jsr $889c			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.89b2	20 d4 87	jsr $87d4			jsr 	AssignVariable 				; assign stacked value to the variable.
.89b5	e8		inx				inx 								; advance to next parameter to do.
.89b6	e8		inx				inx
.89b7	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.89ba	f0 05		beq $89c1			beq 	_ParamExit
.89bc	20 fa 8d	jsr $8dfa			jsr 	CheckComma 					; comma seperating parameters
.89bf	80 ed		bra $89ae			bra 	_ParamExtract
.89c1					_ParamExit:
.89c1	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; check )
.89c4	60		rts				rts 								; and continue from here
.89c5					Command_ENDPROC:
.89c5	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.89c7	a2 14		ldx #$14			ldx 	#ERRID_PROC
.89c9	20 79 a7	jsr $a779			jsr 	StackCheckFrame
.89cc	20 a2 a7	jsr $a7a2			jsr 	STKLoadCodePosition 		; restore code position
.89cf	20 6b a7	jsr $a76b			jsr 	StackClose
.89d2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89d3					Command_Read:
.89d3	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89d5	20 94 98	jsr $9894			jsr 	EvaluateTerm
.89d8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.89db	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89dd	f0 4a		beq $8a29			beq 	_CRSyntax 					; check reference (bit 0)
.89df	20 72 8a	jsr $8a72			jsr 	SwapDataCodePtrs 			; swap code and data
.89e2	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89e5	d0 20		bne $8a07			bne 	_CRContinueData
.89e7					_CRKeepSearching:
.89e7	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89e9	aa		tax				tax
.89ea	20 4d 8d	jsr $8d4d			jsr 	ScanForward
.89ed	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.89ef	f0 16		beq $8a07			beq 	_CRHaveData 				; found it
.89f1	18		clc				clc
.89f2	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.89f4	65 30		adc $30				adc 	codePtr
.89f6	85 30		sta $30				sta 	codePtr
.89f8	90 02		bcc $89fc			bcc 	_CREExit
.89fa	e6 31		inc $31				inc 	codePtr+1 					; carry
.89fc					_CREExit:
.89fc	a0 03		ldy #$03			ldy 	#3 							; start of line.
.89fe	b2 30		lda ($30)			lda 	(codePtr)
.8a00	d0 e5		bne $89e7			bne 	_CRKeepSearching
.8a02	a9 0b		lda #$0b		lda	#11
.8a04	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.8a07					_CRHaveData:
.8a07					_CRContinueData:
.8a07	a2 01		ldx #$01			ldx 	#1
.8a09	20 ee 9d	jsr $9dee			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a0c	ca		dex				dex
.8a0d	20 d4 87	jsr $87d4			jsr		AssignVariable 				; do the assignment
.8a10	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.8a13	b1 30		lda ($30),y			lda 	(codePtr),y
.8a15	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a17	d0 04		bne $8a1d			bne 	_CRSwapBack
.8a19	c8		iny				iny 								; consume comma
.8a1a	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8a1d					_CRSwapBack:
.8a1d	20 72 8a	jsr $8a72			jsr 	SwapDataCodePtrs			; swap them back.
.8a20	b1 30		lda ($30),y			lda 	(codePtr),y
.8a22	c8		iny				iny
.8a23	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a25	f0 ac		beq $89d3			beq 	Command_Read 				; if so go round again.
.8a27	88		dey				dey 								; unpick get.
.8a28	60		rts				rts
.8a29					_CRSyntax:
.8a29	4c 58 a0	jmp $a058			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a2c					RemCommand:
.8a2c	b1 30		lda ($30),y			lda 	(codePtr),y
.8a2e	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a30	d0 06		bne $8a38			bne 	_RMExit
.8a32	c8		iny				iny 								; point to offset
.8a33	98		tya				tya 								; A = offset position
.8a34	38		sec				sec 								; add size +1 hence SEC
.8a35	71 30		adc ($30),y			adc 	(codePtr),y
.8a37	a8		tay				tay 								; make current position.
.8a38					_RMExit:
.8a38	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a39					Command_REPEAT:
.8a39	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a3b	20 4d a7	jsr $a74d			jsr 	StackOpen
.8a3e	20 91 a7	jsr $a791			jsr 	STKSaveCodePosition 		; save loop position
.8a41	60		rts				rts
.8a42					Command_UNTIL:
.8a42	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a44	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a46	20 79 a7	jsr $a779			jsr 	StackCheckFrame
.8a49	a2 00		ldx #$00			ldx 	#0
.8a4b	20 f7 9d	jsr $9df7			jsr 	EvaluateNumber 				; work out the number
.8a4e	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; check if zero
.8a51	f0 04		beq $8a57			beq 	_CULoopBack 				; if so keep looping
.8a53	20 6b a7	jsr $a76b			jsr 	StackClose		 			; return
.8a56	60		rts				rts
.8a57					_CULoopBack:
.8a57	20 a2 a7	jsr $a7a2			jsr 	STKLoadCodePosition 		; loop back
.8a5a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a5b					Command_Restore:
.8a5b	20 72 8a	jsr $8a72			jsr 	SwapDataCodePtrs 			; swap code and data
.8a5e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a60	85 30		sta $30				sta 	codePtr
.8a62	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a64	85 31		sta $31				sta 	codePtr+1
.8a66	20 72 8a	jsr $8a72			jsr 	SwapDataCodePtrs 			; put them back
.8a69	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a6b	8d 9b 04	sta $049b			sta 	dataPointer+4
.8a6e	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.8a71	60		rts				rts
.8a72					SwapDataCodePtrs:
.8a72	da		phx				phx
.8a73	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a75					_SDCPLoop:
.8a75	b5 30		lda $30,x			lda 	safePtr,x
.8a77	48		pha				pha
.8a78	bd 97 04	lda $0497,x			lda 	dataPointer,x
.8a7b	95 30		sta $30,x			sta 	safePtr,x
.8a7d	68		pla				pla
.8a7e	9d 97 04	sta $0497,x			sta 	dataPointer,x
.8a81	ca		dex				dex
.8a82	10 f1		bpl $8a75			bpl 	_SDCPLoop
.8a84	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.8a87	8c 9b 04	sty $049b			sty 	dataPointer+4
.8a8a	a8		tay				tay
.8a8b	fa		plx				plx
.8a8c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a8d					EOLCommand:
.8a8d	18		clc				clc
.8a8e	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a90	65 30		adc $30				adc 	codePtr
.8a92	85 30		sta $30				sta 	codePtr
.8a94	90 02		bcc $8a98			bcc 	_CREExit
.8a96	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a98					_CREExit:
.8a98	80 0b		bra $8aa5			bra 	RunNewLine
.8a9a					CommandRUN:
.8a9a	20 04 84	jsr $8404			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a9d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a9f	85 30		sta $30				sta 	codePtr
.8aa1	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8aa3	85 31		sta $31				sta 	codePtr+1
.8aa5					RUNNewLine:
.8aa5	b2 30		lda ($30)			lda 	(codePtr)
.8aa7	f0 72		beq $8b1b			beq 	CRNoProgram         		; no then END.
.8aa9	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8aab	9a		txs				txs
.8aac					RUNCodePointerLine:
.8aac	a0 02		ldy #$02			ldy 	#2 							; start of program
.8aae					_CRIncMainLoop:
.8aae	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8ab1	d0 19		bne $8acc			bne 	_CRNoBreakCheck
.8ab3	20 43 ab	jsr $ab43			jsr 	EXTBreakCheck 				; break check
.8ab6	f0 5e		beq $8b16			beq 	_CRBreak
.8ab8	64 01		stz $01				stz 	1 							; access I/O Page 0
.8aba	38		sec				sec 								; calculate timer - LastTick
.8abb	ad 59 d6	lda $d659			lda 	$D659
.8abe	aa		tax				tax 								; saving timer in X
.8abf	ed 2e 06	sbc $062e			sbc 	LastTick
.8ac2	c9 03		cmp #$03			cmp 	#3
.8ac4	90 06		bcc $8acc			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8ac6	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.8ac9	20 a8 ba	jsr $baa8			jsr 	TickHandler 				; go do the code.
.8acc					_NoFireTick:
.8acc					_CRNoBreakCheck:
.8acc	c8		iny				iny
.8acd					_CRMainLoop:
.8acd	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8ad0	b1 30		lda ($30),y			lda 	(codePtr),y
.8ad2	10 10		bpl $8ae4			bpl 	_CRNotKeyword
.8ad4	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8ad6	b0 04		bcs $8adc			bcs 	_CRIsKeyword
.8ad8	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8ada	b0 34		bcs $8b10			bcs		_CRSyntaxError
.8adc					_CRIsKeyword:
.8adc	c8		iny				iny 								; consume command
.8add	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8ade	aa		tax				tax 								; put in X for vector jump
.8adf	20 13 8b	jsr $8b13			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8ae2	80 e9		bra $8acd			bra 	_CRMainLoop 				; and loop round
.8ae4					_CRNotKeyword:
.8ae4	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8ae6	f0 c6		beq $8aae			beq 	_CRIncMainLoop
.8ae8	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8aea	90 05		bcc $8af1			bcc 	_CRNotVariable
.8aec					_CRGoLet:
.8aec	20 98 87	jsr $8798			jsr 	LetCommand
.8aef	80 dc		bra $8acd			bra 	_CRMainLoop
.8af1					_CRNotVariable:
.8af1	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8af3	f0 f7		beq $8aec			beq 	_CRGoLet
.8af5	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8af7	f0 f3		beq $8aec			beq 	_CRGoLet
.8af9	c9 21		cmp #$21			cmp 	#KWD_PLING
.8afb	f0 ef		beq $8aec			beq 	_CRGoLet
.8afd	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8aff	f0 09		beq $8b0a			beq 	_CRGoRem
.8b01	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8b03	d0 0b		bne $8b10			bne 	_CRSyntaxError
.8b05	20 09 82	jsr $8209			jsr 	LabelHere
.8b08	80 c3		bra $8acd			bra 	_CRMainLoop
.8b0a					_CRGoRem:
.8b0a	c8		iny				iny
.8b0b	20 2c 8a	jsr $8a2c			jsr 	RemCommand
.8b0e	80 bd		bra $8acd			bra 	_CRMainLoop
.8b10					_CRSyntaxError:
.8b10	4c 58 a0	jmp $a058			jmp 	SyntaxError
.8b13					_CRCallVector0:
.8b13	7c b2 8b	jmp ($8bb2,x)			jmp 	(VectorSet0,x)
.8b16					_CRBreak:
.8b16	a9 01		lda #$01		lda	#1
.8b18	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.8b1b					CRNoProgram:
.8b1b	4c 29 85	jmp $8529			jmp 	EndCommand
.8b1e					Shift1Command:
.8b1e	b1 30		lda ($30),y			lda 	(codePtr),y
.8b20	c8		iny				iny
.8b21	0a		asl a				asl 	a
.8b22	aa		tax				tax
.8b23	7c 50 8c	jmp ($8c50,x)			jmp 	(VectorSet1,x)
.8b26					Shift2Command:
.8b26	b1 30		lda ($30),y			lda 	(codePtr),y
.8b28	c8		iny				iny
.8b29	0a		asl a				asl 	a
.8b2a	aa		tax				tax
.8b2b	7c 6e 8c	jmp ($8c6e,x)			jmp 	(VectorSet2,x)
.8b2e					Unused1:
.8b2e					Unused2:
.8b2e					Unused3:
.8b2e					Unused4:
.8b2e	4c 58 a0	jmp $a058			jmp 	SyntaxError
>8b31							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b32					VectorSetPunc:
>8b32	f8 90					.word	ShiftLeft                        ; $00 <<
>8b34	af 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8b36	a5 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8b38	58 a0					.word	SyntaxError                      ; $03 !!3
>8b3a	58 a0					.word	SyntaxError                      ; $04 ><
>8b3c	b9 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b3e	fb 90					.word	ShiftRight                       ; $06 >>
>8b40	58 a0					.word	SyntaxError                      ; $07 !!7
>8b42	58 a0					.word	SyntaxError                      ; $08 !!8
>8b44	58 a0					.word	SyntaxError                      ; $09 !!9
>8b46	58 a0					.word	SyntaxError                      ; $0a !!10
>8b48	58 a0					.word	SyntaxError                      ; $0b !!11
>8b4a	58 a0					.word	SyntaxError                      ; $0c !!12
>8b4c	58 a0					.word	SyntaxError                      ; $0d !!13
>8b4e	58 a0					.word	SyntaxError                      ; $0e !!14
>8b50	58 a0					.word	SyntaxError                      ; $0f !!15
>8b52	58 a0					.word	SyntaxError                      ; $10 @
>8b54	58 a0					.word	SyntaxError                      ; $11 !!17
>8b56	58 a0					.word	SyntaxError                      ; $12 !!18
>8b58	58 a0					.word	SyntaxError                      ; $13 [
>8b5a	7c 8f					.word	IntegerDivide                    ; $14 \
>8b5c	58 a0					.word	SyntaxError                      ; $15 ]
>8b5e	89 92					.word	EorInteger                       ; $16 ^
>8b60	58 a0					.word	SyntaxError                      ; $17 _
>8b62	58 a0					.word	SyntaxError                      ; $18 `
>8b64	58 a0					.word	SyntaxError                      ; $19 !!25
>8b66	58 a0					.word	SyntaxError                      ; $1a !!26
>8b68	58 a0					.word	SyntaxError                      ; $1b {
>8b6a	43 92					.word	OraInteger                       ; $1c |
>8b6c	58 a0					.word	SyntaxError                      ; $1d }
>8b6e	58 a0					.word	SyntaxError                      ; $1e ~
>8b70	58 a0					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b72	58 a0					.word	SyntaxError                      ; $20
>8b74	cf 92					.word	WordIndirect                     ; $21 !
>8b76	58 a0					.word	SyntaxError                      ; $22 "
>8b78	58 a0					.word	SyntaxError                      ; $23 #
>8b7a	58 a0					.word	SyntaxError                      ; $24 $
>8b7c	c9 8f					.word	IntegerModulus                   ; $25 %
>8b7e	fd 91					.word	AndInteger                       ; $26 &
>8b80	58 a0					.word	SyntaxError                      ; $27 '
>8b82	58 a0					.word	SyntaxError                      ; $28 (
>8b84	58 a0					.word	SyntaxError                      ; $29 )
>8b86	3e 90					.word	MulInteger                       ; $2a *
>8b88	8f 91					.word	AddInteger                       ; $2b +
>8b8a	58 a0					.word	SyntaxError                      ; $2c ,
>8b8c	d2 91					.word	SubInteger                       ; $2d -
>8b8e	58 a0					.word	SyntaxError                      ; $2e .
>8b90	ba 94					.word	FDivideCommand                   ; $2f /
>8b92	58 a0					.word	SyntaxError                      ; $30 0
>8b94	58 a0					.word	SyntaxError                      ; $31 1
>8b96	58 a0					.word	SyntaxError                      ; $32 2
>8b98	58 a0					.word	SyntaxError                      ; $33 3
>8b9a	58 a0					.word	SyntaxError                      ; $34 4
>8b9c	58 a0					.word	SyntaxError                      ; $35 5
>8b9e	58 a0					.word	SyntaxError                      ; $36 6
>8ba0	58 a0					.word	SyntaxError                      ; $37 7
>8ba2	58 a0					.word	SyntaxError                      ; $38 8
>8ba4	58 a0					.word	SyntaxError                      ; $39 9
>8ba6	58 a0					.word	SyntaxError                      ; $3a :
>8ba8	58 a0					.word	SyntaxError                      ; $3b ;
>8baa	91 8e					.word	BinaryCompareLess                ; $3c <
>8bac	87 8e					.word	BinaryCompareEqual               ; $3d =
>8bae	9b 8e					.word	BinaryCompareGreater             ; $3e >
>8bb0	f6 92					.word	ByteIndirect                     ; $3f ?
.8bb2					VectorSet0:
>8bb2	8d 8a					.word	EOLCommand                       ; $80 !0:EOF
>8bb4	1e 8b					.word	Shift1Command                    ; $81 !1:SH1
>8bb6	26 8b					.word	Shift2Command                    ; $82 !2:SH2
>8bb8	2a 9a					.word	AbsUnary                         ; $83 ABS(
>8bba	3a 9a					.word	AllocUnary                       ; $84 ALLOC(
>8bbc	aa 9a					.word	AscUnary                         ; $85 ASC(
>8bbe	75 9c					.word	ChrUnary                         ; $86 CHR$(
>8bc0	c0 a4					.word	UnaryEvent                       ; $87 EVENT(
>8bc2	83 8e					.word	UnaryFalse                       ; $88 FALSE
>8bc4	b7 9a					.word	FracUnary                        ; $89 FRAC(
>8bc6	56 a4					.word	UnaryHit                         ; $8a HIT(
>8bc8	cd 9a					.word	IntUnary                         ; $8b INT(
>8bca	34 9c					.word	IsValUnary                       ; $8c ISVAL(
>8bcc	50 a5					.word	UnaryJoyB                        ; $8d JOYB(
>8bce	29 a5					.word	UnaryJoyX                        ; $8e JOYX(
>8bd0	2c a5					.word	UnaryJoyY                        ; $8f JOYY(
>8bd2	4f 9d					.word	Unary_Left                       ; $90 LEFT$(
>8bd4	df 9a					.word	LenUnary                         ; $91 LEN(
>8bd6	fd 9a					.word	Unary_Max                        ; $92 MAX(
>8bd8	79 9d					.word	Unary_Mid                        ; $93 MID$(
>8bda	f9 9a					.word	Unary_Min                        ; $94 MIN(
>8bdc	54 9b					.word	Unary_Not                        ; $95 NOT(
>8bde	a4 a6					.word	UnaryPlaying                     ; $96 PLAYING(
>8be0	6a 9b					.word	Unary_Random                     ; $97 RANDOM(
>8be2	5f 9d					.word	Unary_Right                      ; $98 RIGHT$(
>8be4	89 9b					.word	Unary_Rnd                        ; $99 RND(
>8be6	0a 9c					.word	SgnUnary                         ; $9a SGN(
>8be8	87 9c					.word	SpcUnary                         ; $9b SPC(
>8bea	a2 9c					.word	Unary_Str                        ; $9c STR$(
>8bec	76 a5					.word	UnaryTimer                       ; $9d TIMER(
>8bee	77 8e					.word	UnaryTrue                        ; $9e TRUE
>8bf0	2a 9c					.word	ValUnary                         ; $9f VAL(
>8bf2	2c 85					.word	ForCommand                       ; $a0 FOR
>8bf4	79 86					.word	IfCommand                        ; $a1 IF
>8bf6	2e 8b					.word	Unused1                          ; $a2 PROC
>8bf8	39 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8bfa	c3 8d					.word	Command_WHILE                    ; $a4 WHILE
>8bfc	a2 86					.word	EndIf                            ; $a5 ENDIF
>8bfe	c5 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8c00	e6 85					.word	NextCommand                      ; $a7 NEXT
>8c02	2e 8b					.word	Unused4                          ; $a8 THEN
>8c04	42 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8c06	e4 8d					.word	Command_WEND                     ; $aa WEND
>8c08	58 a0					.word	SyntaxError                      ; $ab BY
>8c0a	ca 83					.word	CallCommand                      ; $ac CALL
>8c0c	f8 a1					.word	CircleCommand                    ; $ad CIRCLE
>8c0e	04 84					.word	ClearCommand                     ; $ae CLEAR
>8c10	5c 84					.word	ClearScreen                      ; $af CLS
>8c12	58 a0					.word	SyntaxError                      ; $b0 COLOR
>8c14	58 a0					.word	SyntaxError                      ; $b1 COLOUR
>8c16	64 84					.word	Command_Data                     ; $b2 DATA
>8c18	6c 84					.word	DimCommand                       ; $b3 DIM
>8c1a	2e 8b					.word	Unused3                          ; $b4 DOWNTO
>8c1c	9b 86					.word	ElseCode                         ; $b5 ELSE
>8c1e	58 a0					.word	SyntaxError                      ; $b6 FROM
>8c20	24 a4					.word	GfxCommand                       ; $b7 GFX
>8c22	3f 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c24	5d 86					.word	GotoCommand                      ; $b9 GOTO
>8c26	58 a0					.word	SyntaxError                      ; $ba HERE
>8c28	22 a2					.word	ImageCommand                     ; $bb IMAGE
>8c2a	a3 86					.word	Command_Input                    ; $bc INPUT
>8c2c	98 87					.word	LetCommand                       ; $bd LET
>8c2e	77 a2					.word	LineCommand                      ; $be LINE
>8c30	8e 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c32	58 a0					.word	SyntaxError                      ; $c0 OFF
>8c34	58 a0					.word	SyntaxError                      ; $c1 ON
>8c36	58 a0					.word	SyntaxError                      ; $c2 OUTLINE
>8c38	7c a4					.word	PaletteCommand                   ; $c3 PALETTE
>8c3a	70 a2					.word	PlotCommand                      ; $c4 PLOT
>8c3c	aa 86					.word	Command_Print                    ; $c5 PRINT
>8c3e	d3 89					.word	Command_Read                     ; $c6 READ
>8c40	f4 a1					.word	RectangleCommand                 ; $c7 RECT
>8c42	2c 8a					.word	RemCommand                       ; $c8 REM
>8c44	4f 86					.word	Command_RETURN                   ; $c9 RETURN
>8c46	58 a0					.word	SyntaxError                      ; $ca SOLID
>8c48	c0 a6					.word	SoundCommand                     ; $cb SOUND
>8c4a	03 a2					.word	SpriteCommand                    ; $cc SPRITE
>8c4c	3f a2					.word	TextCommand                      ; $cd TEXT
>8c4e	2e 8b					.word	Unused2                          ; $ce TO
.8c50					VectorSet1:
>8c50	58 a0					.word	SyntaxError                      ; $80 !0:EOF
>8c52	58 a0					.word	SyntaxError                      ; $81 !1:SH1
>8c54	58 a0					.word	SyntaxError                      ; $82 !2:SH2
>8c56	9b 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c58	ba 83					.word	AssertCommand                    ; $84 ASSERT
>8c5a	c4 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8c5c	29 85					.word	EndCommand                       ; $86 END
>8c5e	6d a5					.word	GoCommand                        ; $87 GO
>8c60	ed 87					.word	Command_List                     ; $88 LIST
>8c62	64 a5					.word	LoadCommand                      ; $89 LOAD
>8c64	55 89					.word	NewCommand                       ; $8a NEW
>8c66	5b 8a					.word	Command_Restore                  ; $8b RESTORE
>8c68	9a 8a					.word	CommandRUN                       ; $8c RUN
>8c6a	09 a4					.word	SpritesCtrl                      ; $8d SPRITES
>8c6c	f6 8c					.word	StopCommand                      ; $8e STOP
.8c6e					VectorSet2:
>8c6e	58 a0					.word	SyntaxError                      ; $80 !0:EOF
>8c70	58 a0					.word	SyntaxError                      ; $81 !1:SH1
>8c72	58 a0					.word	SyntaxError                      ; $82 !2:SH2
>8c74	17 9f					.word	Assemble_adc                     ; $83 ADC
>8c76	0f 9f					.word	Assemble_and                     ; $84 AND
>8c78	2b 9f					.word	Assemble_asl                     ; $85 ASL
>8c7a	95 9f					.word	Assemble_bcc                     ; $86 BCC
>8c7c	99 9f					.word	Assemble_bcs                     ; $87 BCS
>8c7e	a1 9f					.word	Assemble_beq                     ; $88 BEQ
>8c80	58 9f					.word	Assemble_bit                     ; $89 BIT
>8c82	89 9f					.word	Assemble_bmi                     ; $8a BMI
>8c84	9d 9f					.word	Assemble_bne                     ; $8b BNE
>8c86	85 9f					.word	Assemble_bpl                     ; $8c BPL
>8c88	a5 9f					.word	Assemble_bra                     ; $8d BRA
>8c8a	a9 9f					.word	Assemble_brk                     ; $8e BRK
>8c8c	8d 9f					.word	Assemble_bvc                     ; $8f BVC
>8c8e	91 9f					.word	Assemble_bvs                     ; $90 BVS
>8c90	b1 9f					.word	Assemble_clc                     ; $91 CLC
>8c92	05 a0					.word	Assemble_cld                     ; $92 CLD
>8c94	c5 9f					.word	Assemble_cli                     ; $93 CLI
>8c96	f5 9f					.word	Assemble_clv                     ; $94 CLV
>8c98	23 9f					.word	Assemble_cmp                     ; $95 CMP
>8c9a	6c 9f					.word	Assemble_cpx                     ; $96 CPX
>8c9c	67 9f					.word	Assemble_cpy                     ; $97 CPY
>8c9e	49 9f					.word	Assemble_dec                     ; $98 DEC
>8ca0	01 a0					.word	Assemble_dex                     ; $99 DEX
>8ca2	dd 9f					.word	Assemble_dey                     ; $9a DEY
>8ca4	13 9f					.word	Assemble_eor                     ; $9b EOR
>8ca6	4e 9f					.word	Assemble_inc                     ; $9c INC
>8ca8	11 a0					.word	Assemble_inx                     ; $9d INX
>8caa	fd 9f					.word	Assemble_iny                     ; $9e INY
>8cac	80 9f					.word	Assemble_jmp                     ; $9f JMP
>8cae	7b 9f					.word	Assemble_jsr                     ; $a0 JSR
>8cb0	1f 9f					.word	Assemble_lda                     ; $a1 LDA
>8cb2	44 9f					.word	Assemble_ldx                     ; $a2 LDX
>8cb4	62 9f					.word	Assemble_ldy                     ; $a3 LDY
>8cb6	35 9f					.word	Assemble_lsr                     ; $a4 LSR
>8cb8	15 a0					.word	Assemble_nop                     ; $a5 NOP
>8cba	0b 9f					.word	Assemble_ora                     ; $a6 ORA
>8cbc	c1 9f					.word	Assemble_pha                     ; $a7 PHA
>8cbe	ad 9f					.word	Assemble_php                     ; $a8 PHP
>8cc0	09 a0					.word	Assemble_phx                     ; $a9 PHX
>8cc2	c9 9f					.word	Assemble_phy                     ; $aa PHY
>8cc4	d1 9f					.word	Assemble_pla                     ; $ab PLA
>8cc6	b5 9f					.word	Assemble_plp                     ; $ac PLP
>8cc8	1d a0					.word	Assemble_plx                     ; $ad PLX
>8cca	d9 9f					.word	Assemble_ply                     ; $ae PLY
>8ccc	30 9f					.word	Assemble_rol                     ; $af ROL
>8cce	3a 9f					.word	Assemble_ror                     ; $b0 ROR
>8cd0	bd 9f					.word	Assemble_rti                     ; $b1 RTI
>8cd2	cd 9f					.word	Assemble_rts                     ; $b2 RTS
>8cd4	27 9f					.word	Assemble_sbc                     ; $b3 SBC
>8cd6	b9 9f					.word	Assemble_sec                     ; $b4 SEC
>8cd8	19 a0					.word	Assemble_sed                     ; $b5 SED
>8cda	d5 9f					.word	Assemble_sei                     ; $b6 SEI
>8cdc	1b 9f					.word	Assemble_sta                     ; $b7 STA
>8cde	0d a0					.word	Assemble_stp                     ; $b8 STP
>8ce0	3f 9f					.word	Assemble_stx                     ; $b9 STX
>8ce2	5d 9f					.word	Assemble_sty                     ; $ba STY
>8ce4	53 9f					.word	Assemble_stz                     ; $bb STZ
>8ce6	f1 9f					.word	Assemble_tax                     ; $bc TAX
>8ce8	ed 9f					.word	Assemble_tay                     ; $bd TAY
>8cea	76 9f					.word	Assemble_trb                     ; $be TRB
>8cec	71 9f					.word	Assemble_tsb                     ; $bf TSB
>8cee	f9 9f					.word	Assemble_tsx                     ; $c0 TSX
>8cf0	e1 9f					.word	Assemble_txa                     ; $c1 TXA
>8cf2	e9 9f					.word	Assemble_txs                     ; $c2 TXS
>8cf4	e5 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8cf6					StopCommand:
.8cf6	a9 08		lda #$08		lda	#8
.8cf8	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8cfb					ProcedureScan:
.8cfb	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8cfd	85 30		sta $30				sta 	codePtr
.8cff	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8d01	85 31		sta $31				sta 	codePtr+1
.8d03					_PSLoop:
.8d03	b2 30		lda ($30)			lda 	(codePtr)
.8d05	f0 42		beq $8d49			beq 	_PSExit
.8d07	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8d09	b1 30		lda ($30),y			lda 	(codePtr),y
.8d0b	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8d0d	d0 2d		bne $8d3c			bne 	_PSNext
.8d0f	c8		iny				iny 								; get the address of the record to zTemp0 and
.8d10	b1 30		lda ($30),y			lda 	(codePtr),y
.8d12	29 c0		and #$c0			and 	#$C0
.8d14	c9 40		cmp #$40			cmp 	#$40
.8d16	d0 32		bne $8d4a			bne 	_PSSyntax
.8d18	b1 30		lda ($30),y			lda 	(codePtr),y
.8d1a	18		clc				clc
.8d1b	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d1d	85 37		sta $37				sta 	zTemp0+1
.8d1f	c8		iny				iny 								; LSB
.8d20	b1 30		lda ($30),y			lda 	(codePtr),y
.8d22	85 36		sta $36				sta 	zTemp0
.8d24	c8		iny				iny 								; character after variable call.
.8d25	98		tya				tya 								; save Y offset at +7
.8d26	a0 07		ldy #$07			ldy 	#7
.8d28	91 36		sta ($36),y			sta 	(zTemp0),y
.8d2a	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d2c	a0 02		ldy #$02			ldy 	#2
.8d2e	91 36		sta ($36),y			sta 	(zTemp0),y
.8d30	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d32					_PSCopy:
.8d32	b5 30		lda $30,x			lda 	safePtr,x
.8d34	c8		iny				iny
.8d35	91 36		sta ($36),y			sta 	(zTemp0),y
.8d37	e8		inx				inx
.8d38	e0 04		cpx #$04			cpx 	#4
.8d3a	d0 f6		bne $8d32			bne 	_PSCopy
.8d3c					_PSNext:
.8d3c	18		clc				clc
.8d3d	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d3f	65 30		adc $30				adc 	codePtr
.8d41	85 30		sta $30				sta 	codePtr
.8d43	90 02		bcc $8d47			bcc 	_CREExit
.8d45	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d47					_CREExit:
.8d47	80 ba		bra $8d03			bra 	_PSLoop
.8d49					_PSExit:
.8d49	60		rts				rts
.8d4a					_PSSyntax:
.8d4a	4c 58 a0	jmp $a058			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d4d					ScanForward:
.8d4d	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d4f	86 37		stx $37				stx 	zTemp0+1
.8d51	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d53					_ScanLoop:
.8d53	b1 30		lda ($30),y			lda 	(codePtr),y
.8d55	c8		iny				iny
.8d56	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d58	d0 0e		bne $8d68			bne 	_ScanGoNext
.8d5a	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d5c	f0 04		beq $8d62			beq 	_ScanMatch
.8d5e	c5 37		cmp $37				cmp 	zTemp0+1
.8d60	d0 06		bne $8d68			bne 	_ScanGoNext
.8d62					_ScanMatch:
.8d62	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d64	d0 01		bne $8d67			bne 	_ScanNotEndEOL
.8d66	88		dey				dey
.8d67					_ScanNotEndEOL:
.8d67	60		rts				rts
.8d68					_ScanGoNext:
.8d68	20 6d 8d	jsr $8d6d			jsr  	ScanForwardOne
.8d6b	80 e6		bra $8d53			bra 	_ScanLoop
.8d6d					ScanForwardOne:
.8d6d	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d6f	90 3e		bcc $8daf			bcc 	_SFWExit
.8d71	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d73	90 18		bcc $8d8d			bcc 	_ScanSkipOne
.8d75	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d77	b0 2f		bcs $8da8			bcs 	_ScanSkipData
.8d79	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d7b	90 32		bcc $8daf			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d7d	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d7f	b0 2e		bcs $8daf			bcs 	_SFWExit
.8d81	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d83	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d85	b0 28		bcs $8daf			bcs 	_SFWExit
.8d87	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d89	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8d8b	80 22		bra $8daf			bra 	_SFWExit
.8d8d					_ScanSkipOne:
.8d8d	c8		iny				iny 								; consume the extra one.
.8d8e	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8d90	d0 1d		bne $8daf			bne 	_SFWExit
.8d92	18		clc				clc
.8d93	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d95	65 30		adc $30				adc 	codePtr
.8d97	85 30		sta $30				sta 	codePtr
.8d99	90 02		bcc $8d9d			bcc 	_CREExit
.8d9b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d9d					_CREExit:
.8d9d	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8d9f	b2 30		lda ($30)			lda 	(codePtr)
.8da1	d0 0c		bne $8daf			bne 	_SFWExit 					; if not zero, more to scan
.8da3	a9 13		lda #$13		lda	#19
.8da5	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.8da8					_ScanSkipData:
.8da8	88		dey				dey 								; point at data token
.8da9	c8		iny				iny 								; point to offset
.8daa	98		tya				tya 								; A = offset position
.8dab	38		sec				sec 								; add size +1 hence SEC
.8dac	71 30		adc ($30),y			adc 	(codePtr),y
.8dae	a8		tay				tay 								; make current position.
.8daf					_SFWExit:
.8daf	60		rts				rts
.8db0					ScanGetCurrentLineStep:
.8db0	64 38		stz $38				stz 	zTemp1
.8db2	a0 03		ldy #$03			ldy 	#3
.8db4					_SGCLSLoop:
.8db4	b1 30		lda ($30),y			lda 	(codePtr),y
.8db6	c8		iny				iny
.8db7	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8db9	f0 05		beq $8dc0			beq 	_SGCLSExit
.8dbb	20 6d 8d	jsr $8d6d			jsr 	ScanForwardOne
.8dbe	80 f4		bra $8db4			bra 	_SGCLSLoop
.8dc0					_SGCLSExit:
.8dc0	a5 38		lda $38				lda 	zTemp1
.8dc2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8dc3					Command_WHILE:
.8dc3	5a		phy				phy 								; save position of the test
.8dc4	a2 00		ldx #$00			ldx 	#0
.8dc6	20 f7 9d	jsr $9df7			jsr 	EvaluateNumber 				; work out the number
.8dc9	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; check if zero
.8dcc	f0 0e		beq $8ddc			beq 	_WHExitLoop 				; if so exit the loop
.8dce	98		tya				tya 								; position *after* test.
.8dcf	7a		ply				ply 								; restore position before test, at WHILE
.8dd0	88		dey				dey
.8dd1	48		pha				pha 								; push after test on the stack
.8dd2	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8dd4	20 4d a7	jsr $a74d			jsr 	StackOpen
.8dd7	20 91 a7	jsr $a791			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8dda	7a		ply				ply 								; restore the position *after* the test
.8ddb	60		rts				rts
.8ddc					_WHExitLoop:
.8ddc	68		pla				pla 								; throw post loop position
.8ddd	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8ddf	aa		tax				tax
.8de0	20 4d 8d	jsr $8d4d			jsr 	ScanForward
.8de3	60		rts				rts
.8de4					Command_WEND:
.8de4	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8de6	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8de8	20 79 a7	jsr $a779			jsr 	StackCheckFrame
.8deb	20 a2 a7	jsr $a7a2			jsr 	STKLoadCodePosition 		; loop back
.8dee	20 6b a7	jsr $a76b			jsr 	StackClose		 			; erase the frame
.8df1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8df2					CheckRightBracket:
.8df2	b1 30		lda ($30),y			lda 	(codePtr),y
.8df4	c8		iny				iny
.8df5	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8df7	d0 0f		bne $8e08			bne 	CNAFail
.8df9	60		rts				rts
.8dfa					CheckComma:
.8dfa	b1 30		lda ($30),y			lda 	(codePtr),y
.8dfc	c8		iny				iny
.8dfd	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8dff	d0 07		bne $8e08			bne 	CNAFail
.8e01	60		rts				rts
.8e02					CheckNextA:
.8e02	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8e04	d0 02		bne $8e08			bne 	CNAFail
.8e06	c8		iny				iny 								; skip character
.8e07	60		rts				rts 								; and exit
.8e08					CNAFail:
.8e08	4c 58 a0	jmp $a058			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8e0b					ErrorHandler:
.8e0b	a8		tay				tay 								; find the error text
.8e0c	f0 49		beq $8e57			beq 	_EHEnd
.8e0e	a2 00		ldx #$00			ldx 	#0
.8e10	a9 71		lda #$71			lda 	#((ErrorText) & $FF)
.8e12	85 36		sta $36				sta 	0+zTemp0
.8e14	a9 a0		lda #$a0			lda 	#((ErrorText) >> 8)
.8e16	85 37		sta $37				sta 	1+zTemp0
.8e18					_EHFind:
.8e18	88		dey				dey 								; found the error text ?
.8e19	f0 0e		beq $8e29			beq 	_EHFound
.8e1b					_EHFindZero:
.8e1b	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e1d	e6 36		inc $36				inc 	zTemp0
.8e1f	d0 02		bne $8e23			bne 	_EHFNoCarry
.8e21	e6 37		inc $37				inc 	zTemp0+1
.8e23					_EHFNoCarry:
.8e23	c9 00		cmp #$00			cmp 	#0
.8e25	d0 f4		bne $8e1b			bne 	_EHFindZero
.8e27	80 ef		bra $8e18			bra 	_EHFind
.8e29					_EHFound:
.8e29	a5 36		lda $36				lda 	zTemp0 						; print message
.8e2b	a6 37		ldx $37				ldx 	zTemp0+1
.8e2d	20 64 8e	jsr $8e64			jsr 	PrintStringXA
.8e30	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8e32	b1 30		lda ($30),y			lda 	(codePtr),y
.8e34	d0 05		bne $8e3b			bne 	_EHAtMsg
.8e36	c8		iny				iny
.8e37	b1 30		lda ($30),y			lda 	(codePtr),y
.8e39	f0 17		beq $8e52			beq 	_EHCREnd
.8e3b					_EHAtMsg:
.8e3b	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8e3d	a9 5a		lda #$5a			lda 	#_AtMsg & $FF
.8e3f	20 64 8e	jsr $8e64			jsr 	PrintStringXA
.8e42	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8e44	b1 30		lda ($30),y			lda 	(codePtr),y
.8e46	48		pha				pha
.8e47	c8		iny				iny
.8e48	b1 30		lda ($30),y			lda 	(codePtr),y
.8e4a	aa		tax				tax
.8e4b	68		pla				pla
.8e4c	20 1d 93	jsr $931d			jsr 	LCLConvertInt16 				; convert XA to string
.8e4f	20 64 8e	jsr $8e64			jsr 	PrintStringXA 				; and print it.
.8e52					_EHCREnd:
.8e52	a9 0d		lda #$0d			lda 	#13 						; new line
.8e54	20 8d a8	jsr $a88d			jsr 	EXTPrintCharacter
.8e57					_EHEnd:
.8e57	4c 6b 83	jmp $836b			jmp 	WarmStart
>8e5a	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8e62	20 00
.8e64					PrintStringXA:
.8e64	5a		phy				phy
.8e65	86 37		stx $37				stx 	zTemp0+1
.8e67	85 36		sta $36				sta 	zTemp0
.8e69	a0 00		ldy #$00			ldy 	#0
.8e6b					_PSXALoop:
.8e6b	b1 36		lda ($36),y			lda 	(zTemp0),y
.8e6d	f0 06		beq $8e75			beq 	_PSXAExit
.8e6f	20 8d a8	jsr $a88d			jsr 	EXTPrintCharacter
.8e72	c8		iny				iny
.8e73	80 f6		bra $8e6b			bra 	_PSXALoop
.8e75					_PSXAExit:
.8e75	7a		ply				ply
.8e76	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8e77					UnaryTrue:
.8e77	fa		plx				plx
.8e78					ReturnTrue:
.8e78	a9 01		lda #$01			lda 	#1  						; set to 1
.8e7a	20 d0 9e	jsr $9ed0			jsr 	NSMSetByte
.8e7d	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8e7f	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8e82	60		rts				rts
.8e83					UnaryFalse:
.8e83	fa		plx				plx
.8e84					ReturnFalse:
.8e84	4c ce 9e	jmp $9ece			jmp 	NSMSetZero 					; set it all to zero
.8e87					BinaryCompareEqual:
.8e87	fa		plx				plx
.8e88	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode
.8e8b	c9 00		cmp #$00			cmp 	#0
.8e8d	f0 e9		beq $8e78			beq 	ReturnTrue
.8e8f	80 f3		bra $8e84			bra 	ReturnFalse
.8e91					BinaryCompareLess:
.8e91	fa		plx				plx
.8e92	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode
.8e95	c9 ff		cmp #$ff			cmp 	#$FF
.8e97	f0 df		beq $8e78			beq 	ReturnTrue
.8e99	80 e9		bra $8e84			bra 	ReturnFalse
.8e9b					BinaryCompareGreater:
.8e9b	fa		plx				plx
.8e9c	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode
.8e9f	c9 01		cmp #$01			cmp 	#1
.8ea1	f0 d5		beq $8e78			beq 	ReturnTrue
.8ea3	80 df		bra $8e84			bra 	ReturnFalse
.8ea5					BinaryCompareNotEqual:
.8ea5	fa		plx				plx
.8ea6	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode
.8ea9	c9 00		cmp #$00			cmp 	#0
.8eab	d0 cb		bne $8e78			bne 	ReturnTrue
.8ead	80 d5		bra $8e84			bra 	ReturnFalse
.8eaf					BinaryCompareLessEqual:
.8eaf	fa		plx				plx
.8eb0	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode
.8eb3	c9 01		cmp #$01			cmp 	#1
.8eb5	d0 c1		bne $8e78			bne 	ReturnTrue
.8eb7	80 cb		bra $8e84			bra 	ReturnFalse
.8eb9					BinaryCompareGreaterEqual:
.8eb9	fa		plx				plx
.8eba	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode
.8ebd	c9 ff		cmp #$ff			cmp 	#$FF
.8ebf	d0 b7		bne $8e78			bne 	ReturnTrue
.8ec1	80 c1		bra $8e84			bra 	ReturnFalse
.8ec3					CompareBaseCode:
.8ec3	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; make both values if references.
.8ec6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8ec9	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ecc	29 10		and #$10			and 	#NSTString
.8ece	d0 40		bne $8f10			bne 	_CBCString
.8ed0	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8ed3	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8ed6	d0 3b		bne $8f13			bne 	_CBCFloat
.8ed8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8edb	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ede	29 08		and #$08			and 	#NSTFloat
.8ee0	d0 31		bne $8f13			bne 	_CBCFloat
.8ee2	20 16 8f	jsr $8f16			jsr 	CompareFixMinusZero
.8ee5	e8		inx				inx
.8ee6	20 16 8f	jsr $8f16			jsr 	CompareFixMinusZero
.8ee9	ca		dex				dex
.8eea	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8eed	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8ef0	10 0b		bpl $8efd			bpl 	_CDCSameSign
.8ef2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8ef5	30 16		bmi $8f0d			bmi 	_CBCLess 					; return $FF
.8ef7					_CBCGreater:
.8ef7	a9 01		lda #$01			lda 	#1
.8ef9	60		rts				rts
.8efa					_CBCEqual:
.8efa	a9 00		lda #$00			lda 	#0
.8efc	60		rts				rts
.8efd					_CDCSameSign:
.8efd	20 69 91	jsr $9169			jsr 	SubTopTwoStack 				; unsigned subtract
.8f00	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; or the mantissa together
.8f03	f0 f5		beq $8efa			beq 	_CBCEqual 					; -0 == 0
.8f05	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8f08	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8f0b	10 ea		bpl $8ef7			bpl 	_CBCGreater
.8f0d					_CBCLess:
.8f0d	a9 ff		lda #$ff			lda 	#$FF
.8f0f	60		rts				rts
.8f10					_CBCString:
.8f10	4c bf 90	jmp $90bf			jmp 	CompareStrings
.8f13					_CBCFloat:
.8f13	4c a0 94	jmp $94a0			jmp 	CompareFloat
.8f16					CompareFixMinusZero:
.8f16	20 fe 9e	jsr $9efe			jsr 	NSMIsZero
.8f19	d0 03		bne $8f1e			bne 	_CFXMZNotZero
.8f1b	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8f1e					_CFXMZNotZero:
.8f1e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f1f					StringConcat:
.8f1f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8f22	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8f25	29 18		and #$18			and 	#NSBTypeMask
.8f27	c9 10		cmp #$10			cmp 	#NSTString
.8f29	d0 4e		bne $8f79			bne		_SCType
.8f2b	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f2d	e8		inx				inx
.8f2e	20 4c 8f	jsr $8f4c			jsr 	_SCSetupZ0 					; setup for second
.8f31	20 57 8f	jsr $8f57			jsr 	_SCLengthZ0 				; length for second
.8f34	ca		dex				dex
.8f35	20 4c 8f	jsr $8f4c			jsr 	_SCSetupZ0 					; setup for first
.8f38	20 57 8f	jsr $8f57			jsr 	_SCLengthZ0 				; length for first
.8f3b	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8f3d	20 40 a8	jsr $a840			jsr 	StringTempAllocate
.8f40	20 6a 8f	jsr $8f6a			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8f43	e8		inx				inx
.8f44	20 4c 8f	jsr $8f4c			jsr 	_SCSetupZ0 					; copy second out
.8f47	20 6a 8f	jsr $8f6a			jsr 	_SCCopy
.8f4a	ca		dex				dex
.8f4b	60		rts				rts
.8f4c					_SCSetupZ0:
.8f4c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8f4f	85 36		sta $36				sta 	zTemp0
.8f51	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8f54	85 37		sta $37				sta 	zTemp0+1
.8f56	60		rts				rts
.8f57					_SCLengthZ0:
.8f57	5a		phy				phy
.8f58	a0 00		ldy #$00			ldy 	#0
.8f5a					_SCLenLoop:
.8f5a	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f5c	f0 0a		beq $8f68			beq 	_SCLExit
.8f5e	c8		iny				iny
.8f5f	e6 38		inc $38				inc 	zTemp1
.8f61	10 f7		bpl $8f5a			bpl		_SCLenLoop
.8f63	a9 09		lda #$09		lda	#9
.8f65	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.8f68					_SCLExit:
.8f68	7a		ply				ply
.8f69	60		rts				rts
.8f6a					_SCCopy:
.8f6a	5a		phy				phy
.8f6b	a0 00		ldy #$00			ldy 	#0
.8f6d					_SCCopyLoop:
.8f6d	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f6f	f0 06		beq $8f77			beq 	_SCCExit
.8f71	20 7e a8	jsr $a87e			jsr 	StringTempWrite
.8f74	c8		iny				iny
.8f75	80 f6		bra $8f6d			bra 	_SCCopyLoop
.8f77					_SCCExit:
.8f77	7a		ply				ply
.8f78	60		rts				rts
.8f79					_SCType:
.8f79	4c 62 a0	jmp $a062			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8f7c					IntegerDivide:
.8f7c	fa		plx				plx
.8f7d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f80	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f83	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f84	0a		asl a				asl 	a
.8f85	10 05		bpl $8f8c			bpl 	_NotRef
.8f87	48		pha				pha
.8f88	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f8b	68		pla				pla
.8f8c					_NotRef:
.8f8c	0a		asl a				asl 	a
.8f8d	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f8f	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f92	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f95	f0 03		beq $8f9a			beq 	_IntegerCode 				; if clear, then we have two integers
.8f97	4c 62 a0	jmp $a062			jmp 	TypeError 					; anything else, type mismatch.
.8f9a					_IntegerCode:
.8f9a	20 bc 8f	jsr $8fbc			jsr 	CheckDivideZero 			; do div zero check
.8f9d	20 f4 8f	jsr $8ff4			jsr 	Int32Divide 				; do the division
.8fa0	20 b1 90	jsr $90b1			jsr 	CalculateSign 				; calculate result sign
.8fa3					NSMCopyPlusTwoToZero:
.8fa3	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8fa6	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8fa9	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8fac	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8faf	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8fb2	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8fb5	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8fb8	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8fbb	60		rts				rts
.8fbc					CheckDivideZero:
.8fbc	e8		inx				inx
.8fbd	20 fe 9e	jsr $9efe			jsr 	NSMIsZero
.8fc0	f0 02		beq $8fc4			beq 	_CDVError
.8fc2	ca		dex				dex
.8fc3	60		rts				rts
.8fc4					_CDVError:
.8fc4	a9 03		lda #$03		lda	#3
.8fc6	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.8fc9					IntegerModulus:
.8fc9	fa		plx				plx
.8fca	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8fcd	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8fd0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fd1	0a		asl a				asl 	a
.8fd2	10 05		bpl $8fd9			bpl 	_NotRef
.8fd4	48		pha				pha
.8fd5	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fd8	68		pla				pla
.8fd9					_NotRef:
.8fd9	0a		asl a				asl 	a
.8fda	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8fdc	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fdf	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fe2	f0 03		beq $8fe7			beq 	_IntegerCode 				; if clear, then we have two integers
.8fe4	4c 62 a0	jmp $a062			jmp 	TypeError 					; anything else, type mismatch.
.8fe7					_IntegerCode:
.8fe7					IntegerModulusNoCheck:
.8fe7	20 bc 8f	jsr $8fbc			jsr 	CheckDivideZero 			; do div zero check
.8fea	20 f4 8f	jsr $8ff4			jsr 	Int32Divide 				; do the division
.8fed	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8ff0	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8ff3	60		rts				rts
.8ff4					Int32Divide:
.8ff4	48		pha				pha 								; save AXY
.8ff5	5a		phy				phy
.8ff6	20 a5 9e	jsr $9ea5			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8ff9	20 ca 9e	jsr $9eca			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8ffc	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8ffe					_I32DivideLoop:
.8ffe	e8		inx				inx
.8fff	e8		inx				inx
.9000	20 e3 9e	jsr $9ee3			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.9003	ca		dex				dex
.9004	ca		dex				dex
.9005	20 e4 9e	jsr $9ee4			jsr 	NSMRotateLeft
.9008	20 34 90	jsr $9034			jsr 	DivideCheckSubtract 		; check if subtract possible
.900b	90 03		bcc $9010			bcc 	_I32DivideNoCarryIn
.900d	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9010					_I32DivideNoCarryIn:
.9010	88		dey				dey 								; loop round till division completed.
.9011	d0 eb		bne $8ffe			bne 	_I32DivideLoop
.9013	7a		ply				ply 								; restore AXY and exit
.9014	68		pla				pla
.9015	60		rts				rts
.9016					Int32ShiftDivide:
.9016	48		pha				pha 								; save AY
.9017	5a		phy				phy
.9018	e8		inx				inx 								; clear S[X+2]
.9019	e8		inx				inx
.901a	20 ce 9e	jsr $9ece			jsr 	NSMSetZero
.901d	ca		dex				dex
.901e	ca		dex				dex
.901f	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9021					_I32SDLoop:
.9021	20 34 90	jsr $9034			jsr 	DivideCheckSubtract 		; check if subtract possible
.9024	e8		inx				inx
.9025	e8		inx				inx
.9026	20 e4 9e	jsr $9ee4			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.9029	ca		dex				dex
.902a	ca		dex				dex
.902b	20 e4 9e	jsr $9ee4			jsr 	NSMRotateLeft
.902e	88		dey				dey 	 							; do 31 times
.902f	d0 f0		bne $9021			bne 	_I32SDLoop
.9031	7a		ply				ply 								; restore AY and exit
.9032	68		pla				pla
.9033	60		rts				rts
.9034					DivideCheckSubtract:
.9034	20 69 91	jsr $9169			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9037	b0 04		bcs $903d			bcs 	_DCSExit 					; if carry set, then could do, exit
.9039	20 43 91	jsr $9143			jsr 	AddTopTwoStack 				; add it back in
.903c	18		clc				clc 								; and return False
.903d					_DCSExit:
.903d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.903e					MulInteger:
.903e	fa		plx				plx
.903f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9042	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9045	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9046	0a		asl a				asl 	a
.9047	10 05		bpl $904e			bpl 	_NotRef
.9049	48		pha				pha
.904a	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.904d	68		pla				pla
.904e					_NotRef:
.904e	0a		asl a				asl 	a 							; put MSB of type into A:7
.904f	30 0b		bmi $905c			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9051	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9054	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9057	f0 06		beq $905f			beq 	_IntegerCode 				; if clear, then we have two integers
.9059	4c 77 95	jmp $9577			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.905c					_StringData:
.905c	4c 6c a0	jmp $a06c			jmp 	NotDoneError							; at least one string - don't know both are strings.
.905f					_IntegerCode:
.905f	20 6c 90	jsr $906c			jsr 	MultiplyShort
.9062	c9 00		cmp #$00			cmp 	#0
.9064	f0 05		beq $906b			beq 	_MIExit
.9066	a9 04		lda #$04		lda	#4
.9068	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.906b					_MIExit:
.906b	60		rts				rts
.906c					MultiplyShort:
.906c	5a		phy				phy 								; save Y
.906d	20 a5 9e	jsr $9ea5			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9070	20 ca 9e	jsr $9eca			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9073	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9075					_I32MLoop:
.9075	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9078	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.907b	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.907e	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.9081	f0 28		beq $90ab			beq 	_I32MExit 					; exit if zero
.9083	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9086	29 01		and #$01			and 	#1
.9088	f0 0e		beq $9098			beq 	_I32MNoAdd
.908a	20 43 91	jsr $9143			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.908d	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9090	10 06		bpl $9098			bpl 	_I32MNoAdd
.9092					_I32ShiftRight:
.9092	20 f1 9e	jsr $9ef1			jsr 	NSMShiftRight 				; shift S[X] right
.9095	c8		iny				iny 								; increment shift count
.9096	80 0a		bra $90a2			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9098					_I32MNoAdd:
.9098	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.909b	70 f5		bvs $9092			bvs 	_I32ShiftRight 				; instead.
.909d	e8		inx				inx
.909e	20 e3 9e	jsr $9ee3			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.90a1	ca		dex				dex
.90a2					_I32MShiftUpper:
.90a2	e8		inx				inx 								; shift S[X+2] right
.90a3	e8		inx				inx
.90a4	20 f1 9e	jsr $9ef1			jsr 	NSMShiftRight
.90a7	ca		dex				dex
.90a8	ca		dex				dex
.90a9	80 ca		bra $9075			bra 	_I32MLoop 					; try again.
.90ab					_I32MExit:
.90ab	20 b1 90	jsr $90b1			jsr 	CalculateSign
.90ae	98		tya				tya 								; shift in A
.90af	7a		ply				ply 								; restore Y and exit
.90b0	60		rts				rts
.90b1					CalculateSign:
.90b1	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.90b4	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.90b7	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.90ba	0a		asl a				asl 	a 							; shift bit 7 into carry
.90bb	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.90be	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.90bf					CompareStrings:
.90bf	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.90c2	3d 01 04	and $0401,x			and 	NSStatus+1,x
.90c5	29 10		and #$10			and 	#NSBIsString
.90c7	f0 2c		beq $90f5			beq 	_CSTypeError
.90c9	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.90cc	85 36		sta $36				sta 	zTemp0
.90ce	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.90d1	85 37		sta $37				sta 	zTemp0+1
.90d3	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.90d6	85 38		sta $38				sta 	zTemp1
.90d8	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.90db	85 39		sta $39				sta 	zTemp1+1
.90dd	5a		phy				phy 								; save Y so we can access strings
.90de	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.90e0					_CSLoop:
.90e0	c8		iny				iny
.90e1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.90e3	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.90e5	d0 06		bne $90ed			bne 	_CSDifferent
.90e7	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.90e9	d0 f5		bne $90e0			bne 	_CSLoop 					; still comparing
.90eb					_CSExit:
.90eb	7a		ply				ply 								; reached end, return zero in A from EOS
.90ec	60		rts				rts
.90ed					_CSDifferent:
.90ed	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.90ef	90 fa		bcc $90eb			bcc		_CSExit
.90f1	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.90f3	80 f6		bra $90eb			bra 	_CSExit
.90f5					_CSTypeError:
.90f5	4c 62 a0	jmp $a062			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.90f8					ShiftLeft:
.90f8	38		sec				sec
.90f9	80 01		bra $90fc			bra 	ShiftMain
.90fb					ShiftRight:
.90fb	18		clc				clc
.90fc					ShiftMain:
.90fc	fa		plx				plx 								; restore X
.90fd	08		php				php 								; save direction
.90fe	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9101	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9104	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9105	0a		asl a				asl 	a
.9106	10 05		bpl $910d			bpl 	_NotRef
.9108	48		pha				pha
.9109	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.910c	68		pla				pla
.910d					_NotRef:
.910d	0a		asl a				asl 	a
.910e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9110	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9113	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9116	f0 03		beq $911b			beq 	_IntegerCode 				; if clear, then we have two integers
.9118	4c 62 a0	jmp $a062			jmp 	TypeError 					; anything else, type mismatch.
.911b					_IntegerCode:
.911b	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.911e	29 e0		and #$e0			and 	#$E0
.9120	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.9123	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.9126	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9129	d0 13		bne $913e			bne 	_SMExit0 					; if >= 32 it will always return zero.
.912b					_SMLoop:
.912b	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.912e	30 11		bmi $9141			bmi 	_SMExit 					; exit if done.
.9130	28		plp				plp 								; restore direcition setting
.9131	08		php				php
.9132	90 05		bcc $9139			bcc 	_SMRight
.9134	20 e3 9e	jsr $9ee3			jsr 	NSMShiftLeft 				; shift left if CS
.9137	80 f2		bra $912b			bra 	_SMLoop
.9139					_SMRight:
.9139	20 f1 9e	jsr $9ef1			jsr 	NSMShiftRight 				; shift right if CC
.913c	80 ed		bra $912b			bra 	_SMLoop
.913e					_SMExit0:
.913e	20 ce 9e	jsr $9ece			jsr 	NSMSetZero 					; return zero.
.9141					_SMExit:
.9141	28		plp				plp 								; throw direction
.9142	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9143					AddTopTwoStack:
.9143	18		clc				clc
.9144	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9147	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.914a	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.914d	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9150	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.9153	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9156	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9159	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.915c	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.915f	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9162	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.9165	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9168	60		rts				rts
.9169					SubTopTwoStack:
.9169	38		sec				sec
.916a	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.916d	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.9170	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9173	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9176	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.9179	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.917c	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.917f	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.9182	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9185	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9188	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.918b	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.918e	60		rts				rts
.918f					AddInteger:
.918f	fa		plx				plx
.9190	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9193	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9196	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9197	0a		asl a				asl 	a
.9198	10 05		bpl $919f			bpl 	_NotRef
.919a	48		pha				pha
.919b	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.919e	68		pla				pla
.919f					_NotRef:
.919f	0a		asl a				asl 	a 							; put MSB of type into A:7
.91a0	30 0b		bmi $91ad			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91a2	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91a5	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91a8	f0 06		beq $91b0			beq 	_IntegerCode 				; if clear, then we have two integers
.91aa	4c f7 93	jmp $93f7			jmp 	FloatingPointAdd 							; otherwise at least one float.
.91ad					_StringData:
.91ad	4c 1f 8f	jmp $8f1f			jmp 	StringConcat							; at least one string - don't know both are strings.
.91b0					_IntegerCode:
.91b0					AddCode:
.91b0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.91b3	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.91b6	10 8b		bpl $9143			bpl 	AddTopTwoStack
.91b8	20 69 91	jsr $9169			jsr 	SubTopTwoStack 				; do a physical subtraction
.91bb	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.91be	10 09		bpl $91c9			bpl 	_AddExit
.91c0	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.91c3	9d 00 04	sta $0400,x			sta 	NSStatus,x
.91c6	20 83 9e	jsr $9e83			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.91c9					_AddExit:
.91c9	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; check for -0
.91cc	d0 03		bne $91d1			bne 	_AddNonZero
.91ce	9e 00 04	stz $0400,x			stz 	NSStatus,x
.91d1					_AddNonZero:
.91d1	60		rts				rts
.91d2					SubInteger:
.91d2	fa		plx				plx
.91d3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91d6	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91d9	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91da	0a		asl a				asl 	a
.91db	10 05		bpl $91e2			bpl 	_NotRef
.91dd	48		pha				pha
.91de	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91e1	68		pla				pla
.91e2					_NotRef:
.91e2	0a		asl a				asl 	a 							; put MSB of type into A:7
.91e3	30 0b		bmi $91f0			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91e5	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91e8	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91eb	f0 06		beq $91f3			beq 	_IntegerCode 				; if clear, then we have two integers
.91ed	4c fc 93	jmp $93fc			jmp 	FloatingPointSub 							; otherwise at least one float.
.91f0					_StringData:
.91f0	4c 6c a0	jmp $a06c			jmp 	NotDoneError							; at least one string - don't know both are strings.
.91f3					_IntegerCode:
.91f3	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.91f6	49 80		eor #$80			eor 	#$80
.91f8	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.91fb	80 b3		bra $91b0			bra 	AddCode 					; and do the same code as add.
.91fd					AndInteger:
.91fd	fa		plx				plx
.91fe	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9201	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9204	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9205	0a		asl a				asl 	a
.9206	10 05		bpl $920d			bpl 	_NotRef
.9208	48		pha				pha
.9209	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.920c	68		pla				pla
.920d					_NotRef:
.920d	0a		asl a				asl 	a
.920e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9210	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9213	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9216	f0 03		beq $921b			beq 	_IntegerCode 				; if clear, then we have two integers
.9218	4c 62 a0	jmp $a062			jmp 	TypeError 					; anything else, type mismatch.
.921b					_IntegerCode:
.921b	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.921e	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.9221	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9224	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9227	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.922a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.922d	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9230	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.9233	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9236	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9239	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.923c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.923f	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9242	60		rts				rts
.9243					OraInteger:
.9243	fa		plx				plx
.9244	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9247	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.924a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.924b	0a		asl a				asl 	a
.924c	10 05		bpl $9253			bpl 	_NotRef
.924e	48		pha				pha
.924f	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9252	68		pla				pla
.9253					_NotRef:
.9253	0a		asl a				asl 	a
.9254	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9256	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9259	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.925c	f0 03		beq $9261			beq 	_IntegerCode 				; if clear, then we have two integers
.925e	4c 62 a0	jmp $a062			jmp 	TypeError 					; anything else, type mismatch.
.9261					_IntegerCode:
.9261	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9264	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.9267	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.926a	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.926d	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.9270	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9273	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9276	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.9279	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.927c	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.927f	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.9282	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9285	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9288	60		rts				rts
.9289					EorInteger:
.9289	fa		plx				plx
.928a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.928d	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9290	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9291	0a		asl a				asl 	a
.9292	10 05		bpl $9299			bpl 	_NotRef
.9294	48		pha				pha
.9295	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9298	68		pla				pla
.9299					_NotRef:
.9299	0a		asl a				asl 	a
.929a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.929c	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.929f	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92a2	f0 03		beq $92a7			beq 	_IntegerCode 				; if clear, then we have two integers
.92a4	4c 62 a0	jmp $a062			jmp 	TypeError 					; anything else, type mismatch.
.92a7					_IntegerCode:
.92a7	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.92aa	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.92ad	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.92b0	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.92b3	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.92b6	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.92b9	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.92bc	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.92bf	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.92c2	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.92c5	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.92c8	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.92cb	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.92ce	60		rts				rts
.92cf					WordIndirect:
.92cf	fa		plx				plx
.92d0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92d3	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92d6	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92d7	0a		asl a				asl 	a
.92d8	10 05		bpl $92df			bpl 	_NotRef
.92da	48		pha				pha
.92db	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92de	68		pla				pla
.92df					_NotRef:
.92df	0a		asl a				asl 	a
.92e0	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92e2	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92e5	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92e8	f0 03		beq $92ed			beq 	_IntegerCode 				; if clear, then we have two integers
.92ea	4c 62 a0	jmp $a062			jmp 	TypeError 					; anything else, type mismatch.
.92ed					_IntegerCode:
.92ed	20 b0 91	jsr $91b0			jsr 	AddCode 					; add the two values
.92f0	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.92f2	9d 00 04	sta $0400,x			sta 	NSStatus,x
.92f5	60		rts				rts
.92f6					ByteIndirect:
.92f6	fa		plx				plx
.92f7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92fa	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92fd	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92fe	0a		asl a				asl 	a
.92ff	10 05		bpl $9306			bpl 	_NotRef
.9301	48		pha				pha
.9302	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9305	68		pla				pla
.9306					_NotRef:
.9306	0a		asl a				asl 	a
.9307	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9309	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.930c	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.930f	f0 03		beq $9314			beq 	_IntegerCode 				; if clear, then we have two integers
.9311	4c 62 a0	jmp $a062			jmp 	TypeError 					; anything else, type mismatch.
.9314					_IntegerCode:
.9314	20 b0 91	jsr $91b0			jsr 	AddCode 					; add the two values
.9317	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9319	9d 00 04	sta $0400,x			sta 	NSStatus,x
.931c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.931d					LCLConvertInt16:
.931d	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.9320	8e 10 04	stx $0410			stx 	NSMantissa1
.9323	9c 18 04	stz $0418			stz 	NSMantissa2
.9326	9c 20 04	stz $0420			stz 	NSMantissa3
.9329	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.932c	a2 00		ldx #$00			ldx 	#0 							; stack level
.932e	a9 0a		lda #$0a			lda 	#10 						; base
.9330	80 00		bra $9332			bra 	ConvertInt32
.9332					ConvertInt32:
.9332	5a		phy				phy
.9333	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9335	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.9338	10 08		bpl $9342			bpl 	_CI32NotNeg
.933a	48		pha				pha
.933b	a9 2d		lda #$2d			lda 	#'-'
.933d	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.9340	c8		iny				iny
.9341	68		pla				pla
.9342					_CI32NotNeg:
.9342	20 50 93	jsr $9350			jsr 	_CI32DivideConvert 			; recursive conversion
.9345	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9347	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.934a	7a		ply				ply
.934b	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.934d	a9 fa		lda #$fa			lda 	#NumberBuffer & $FF
.934f	60		rts				rts
.9350					_CI32DivideConvert:
.9350	e8		inx				inx 								; write to next slot up
.9351	20 d0 9e	jsr $9ed0			jsr 	NSMSetByte
.9354	ca		dex				dex
.9355	20 f4 8f	jsr $8ff4			jsr 	Int32Divide 				; divide
.9358	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.935b	48		pha				pha
.935c	20 a3 8f	jsr $8fa3			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.935f	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; is it zero ?
.9362	f0 06		beq $936a			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9364	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9367	20 50 93	jsr $9350			jsr 	_CI32DivideConvert 			; and recusrively call.
.936a					_CI32NoRecurse:
.936a	68		pla				pla 								; remainder
.936b	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.936d	90 02		bcc $9371			bcc 	_CI32NotHex
.936f	69 26		adc #$26			adc 	#6+32
.9371					_CI32NotHex:
.9371	69 30		adc #$30			adc 	#48
.9373	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y 				; write out and exit
.9376	c8		iny				iny
.9377	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9378					PrecedenceLevel:
>9378	04					.byte	 4	; $00 <<
>9379	02					.byte	 2	; $01 <=
>937a	02					.byte	 2	; $02 <>
>937b	00					.byte	 0	; $03 !!3
>937c	00					.byte	 0	; $04 ><
>937d	02					.byte	 2	; $05 >=
>937e	04					.byte	 4	; $06 >>
>937f	00					.byte	 0	; $07 !!7
>9380	00					.byte	 0	; $08 !!8
>9381	00					.byte	 0	; $09 !!9
>9382	00					.byte	 0	; $0a !!10
>9383	00					.byte	 0	; $0b !!11
>9384	00					.byte	 0	; $0c !!12
>9385	00					.byte	 0	; $0d !!13
>9386	00					.byte	 0	; $0e !!14
>9387	00					.byte	 0	; $0f !!15
>9388	00					.byte	 0	; $10 @
>9389	00					.byte	 0	; $11 !!17
>938a	00					.byte	 0	; $12 !!18
>938b	00					.byte	 0	; $13 [
>938c	04					.byte	 4	; $14 \
>938d	00					.byte	 0	; $15 ]
>938e	01					.byte	 1	; $16 ^
>938f	00					.byte	 0	; $17 _
>9390	00					.byte	 0	; $18 `
>9391	00					.byte	 0	; $19 !!25
>9392	00					.byte	 0	; $1a !!26
>9393	00					.byte	 0	; $1b {
>9394	01					.byte	 1	; $1c |
>9395	00					.byte	 0	; $1d }
>9396	00					.byte	 0	; $1e ~
>9397	00					.byte	 0	; $1f [7m<7F>[m
>9398	00					.byte	 0	; $20
>9399	05					.byte	 5	; $21 !
>939a	00					.byte	 0	; $22 "
>939b	00					.byte	 0	; $23 #
>939c	05					.byte	 5	; $24 $
>939d	04					.byte	 4	; $25 %
>939e	01					.byte	 1	; $26 &
>939f	00					.byte	 0	; $27 '
>93a0	00					.byte	 0	; $28 (
>93a1	00					.byte	 0	; $29 )
>93a2	04					.byte	 4	; $2a *
>93a3	03					.byte	 3	; $2b +
>93a4	00					.byte	 0	; $2c ,
>93a5	03					.byte	 3	; $2d -
>93a6	00					.byte	 0	; $2e .
>93a7	04					.byte	 4	; $2f /
>93a8	00					.byte	 0	; $30 0
>93a9	00					.byte	 0	; $31 1
>93aa	00					.byte	 0	; $32 2
>93ab	00					.byte	 0	; $33 3
>93ac	00					.byte	 0	; $34 4
>93ad	00					.byte	 0	; $35 5
>93ae	00					.byte	 0	; $36 6
>93af	00					.byte	 0	; $37 7
>93b0	00					.byte	 0	; $38 8
>93b1	00					.byte	 0	; $39 9
>93b2	00					.byte	 0	; $3a :
>93b3	00					.byte	 0	; $3b ;
>93b4	02					.byte	 2	; $3c <
>93b5	02					.byte	 2	; $3d =
>93b6	02					.byte	 2	; $3e >
>93b7	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93b8					EvaluateExpressionAt0:
.93b8	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93ba					EvaluateExpression:
.93ba	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93bc					EvaluateExpressionAtPrecedence:
.93bc	48		pha				pha 								; save precedence level
.93bd	20 94 98	jsr $9894			jsr 	EvaluateTerm 				; evaluate term into level X.
.93c0	68		pla				pla 								; restore precedence level.
.93c1					_EXPRLoop:
.93c1	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.93c3	b1 30		lda ($30),y			lda 	(codePtr),y
.93c5	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.93c7	b0 25		bcs $93ee			bcs 	_EXPRExit
.93c9	da		phx				phx 								; read the operator precedence
.93ca	aa		tax				tax
.93cb	bd 78 93	lda $9378,x			lda 	PrecedenceLevel,x
.93ce	fa		plx				plx
.93cf	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.93d1	f0 1b		beq $93ee			beq 	_EXPRExit
.93d3	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93d5	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93d7	c5 37		cmp $37				cmp 	zTemp0+1
.93d9	b0 13		bcs $93ee			bcs		_EXPRExit 					; if current >= operator exit
.93db	48		pha				pha 								; save current precedence.
.93dc	b1 30		lda ($30),y			lda 	(codePtr),y
.93de	c8		iny				iny
.93df	48		pha				pha
.93e0	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93e2	e8		inx				inx 								; work out the right hand side.
.93e3	20 bc 93	jsr $93bc			jsr 	EvaluateExpressionAtPrecedence
.93e6	ca		dex				dex
.93e7	68		pla				pla 								; get operator, call the code.
.93e8	20 f1 93	jsr $93f1			jsr 	_EXPRCaller
.93eb	68		pla				pla 								; restore precedence level
.93ec	80 d3		bra $93c1			bra 	_EXPRLoop 					; and go round.
.93ee					_EXPRExit:
.93ee	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93f0	60		rts				rts
.93f1					_EXPRCaller:
.93f1	da		phx				phx 								; save on stack, first thing is to restore it
.93f2	0a		asl a				asl 	a 							; double so can use vectors into X
.93f3	aa		tax				tax
.93f4	7c 32 8b	jmp ($8b32,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.93f7					FloatingPointAdd:
.93f7	20 a0 95	jsr $95a0			jsr 	FloatPrepare 				; prepare for floats
.93fa	80 0b		bra $9407			bra 	FloatAdd
.93fc					FloatingPointSub:
.93fc	20 a0 95	jsr $95a0			jsr 	FloatPrepare 				; prepare for floats
.93ff					FloatSubtract:
.93ff	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.9402	49 80		eor #$80			eor 	#$80
.9404	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.9407					FloatAdd:
.9407	48		pha				pha
.9408	5a		phy				phy
.9409	20 b1 95	jsr $95b1			jsr 	NSNormalise 				; normalise S[X]
.940c	f0 5c		beq $946a			beq 	_FAReturn1
.940e	e8		inx				inx 								; normalise S[X+1]
.940f	20 b1 95	jsr $95b1			jsr 	NSNormalise
.9412	ca		dex				dex
.9413	c9 00		cmp #$00			cmp 	#0
.9415	f0 77		beq $948e			beq 	_FAExit 					; if so, just return A
.9417	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.941a	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.941d	f0 1b		beq $943a			beq 	_FAExponentsEqual
.941f	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.9422	a8		tay				tay
.9423	38		sec				sec 								; do a signed comparison of the exponents.
.9424	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9427	50 02		bvc $942b			bvc 	_FANoSignedChange
.9429	49 80		eor #$80			eor 	#$80
.942b					_FANoSignedChange:
.942b	29 80		and #$80			and 	#$80
.942d	10 03		bpl $9432			bpl 	_FAHaveMax
.942f	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.9432					_FAHaveMax:
.9432	20 91 94	jsr $9491			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9435	e8		inx				inx
.9436	20 91 94	jsr $9491			jsr 	_FAShiftToExponent
.9439	ca		dex				dex
.943a					_FAExponentsEqual:
.943a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.943d	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9440	30 10		bmi $9452			bmi 	_FADifferentSigns
.9442	20 43 91	jsr $9143			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9445	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9448	10 44		bpl $948e			bpl 	_FAExit 					; if no, we are done.
.944a	20 f1 9e	jsr $9ef1			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.944d	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.9450	80 3c		bra $948e			bra 	_FAExit
.9452					_FADifferentSigns:
.9452	20 69 91	jsr $9169			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9455	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.9458	10 06		bpl $9460			bpl 	_FACheckZero 				; if no, check for -0
.945a	20 7a 9e	jsr $9e7a			jsr 	NSMNegate 					; netate result
.945d	20 83 9e	jsr $9e83			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9460					_FACheckZero:
.9460	20 fe 9e	jsr $9efe			jsr 	NSMIsZero	 				; check for -0
.9463	d0 29		bne $948e			bne 	_FAExit
.9465	9e 00 04	stz $0400,x			stz 	NSStatus,x
.9468	80 24		bra $948e			bra 	_FAExit
.946a					_FAReturn1:
.946a	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.946d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9470	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9473	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9476	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9479	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.947c	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.947f	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9482	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9485	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9488	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.948b	9d 00 04	sta $0400,x			sta 	NSStatus,x
.948e					_FAExit:
.948e	7a		ply				ply
.948f	68		pla				pla
.9490	60		rts				rts
.9491					_FAShiftToExponent:
.9491					_FAShiftToExponent2:
.9491	98		tya				tya 								; compare Y to exponent
.9492	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9495	f0 08		beq $949f			beq 	_FASEExit 					; exit if so.
.9497	20 f1 9e	jsr $9ef1			jsr 	NSMShiftRight	 			; shift the mantissa right
.949a	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.949d	80 f2		bra $9491			bra 	_FAShiftToExponent2
.949f					_FASEExit:
.949f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94a0					CompareFloat:
.94a0	20 ff 93	jsr $93ff			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94a3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94a6	29 f8		and #$f8			and 	#$F8
.94a8	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.94ab	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.94ae	f0 09		beq $94b9			beq 	_FCExit 					; zero, so approximately identical
.94b0	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94b2	3c 00 04	bit $0400,x			bit 	NSStatus,x
.94b5	10 02		bpl $94b9			bpl 	_FCExit
.94b7					_FCNegative:
.94b7	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94b9					_FCExit:
.94b9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94ba					FDivideCommand:
.94ba	fa		plx				plx	 								; restore stack position
.94bb	20 a0 95	jsr $95a0			jsr 	FloatPrepare 				; prepare for floats
.94be					FloatDivide:
.94be	48		pha				pha
.94bf	e8		inx				inx
.94c0	20 b1 95	jsr $95b1			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94c3	ca		dex				dex
.94c4	c9 00		cmp #$00			cmp 	#0
.94c6	f0 20		beq $94e8			beq 	_FDZero
.94c8	20 b1 95	jsr $95b1			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94cb	f0 19		beq $94e6			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94cd	20 16 90	jsr $9016			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94d0	20 a3 8f	jsr $8fa3			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94d3	20 b1 95	jsr $95b1			jsr		NSNormalise 				; renormalise
.94d6	20 b1 90	jsr $90b1			jsr 	CalculateSign 				; calculate result sign
.94d9	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.94dc	38		sec				sec
.94dd	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.94e0	38		sec				sec
.94e1	e9 1e		sbc #$1e			sbc 	#30
.94e3	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94e6					_FDExit:
.94e6	68		pla				pla
.94e7	60		rts				rts
.94e8					_FDZero:
.94e8	a9 03		lda #$03		lda	#3
.94ea	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.94ed					FloatFractionalPart:
.94ed	5a		phy				phy
.94ee	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.94f1	29 7f		and #$7f			and 	#$7F
.94f3	9d 00 04	sta $0400,x			sta 	NSStatus,x
.94f6	20 b1 95	jsr $95b1			jsr 	NSNormalise
.94f9	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.94fc	38		sec				sec
.94fd	e9 e0		sbc #$e0			sbc 	#$E0
.94ff	90 31		bcc $9532			bcc 	_FFPExit 					; already fractional
.9501	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9503	b0 2a		bcs $952f			bcs 	_FFPZero
.9505	a8		tay				tay 								; put count to do in Y
.9506	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.9509	20 34 95	jsr $9534			jsr 	_FFPPartial
.950c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.950f	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9512	20 34 95	jsr $9534			jsr 	_FFPPartial
.9515	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9518	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.951b	20 34 95	jsr $9534			jsr 	_FFPPartial
.951e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9521	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9524	20 34 95	jsr $9534			jsr 	_FFPPartial
.9527	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.952a	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; zeroed check.
.952d	d0 03		bne $9532			bne 	_FFPExit
.952f					_FFPZero:
.952f	20 ce 9e	jsr $9ece			jsr 	NSMSetZero
.9532					_FFPExit:
.9532	7a		ply				ply
.9533	60		rts				rts
.9534					_FFPPartial:
.9534	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9536	f0 17		beq $954f			beq 	_FFFPPExit
.9538	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.953a	b0 0c		bcs $9548			bcs 	_FFFPPWholeByte
.953c	5a		phy				phy
.953d					_FFFPPLeft:
.953d	0a		asl a				asl 	a
.953e	88		dey				dey
.953f	d0 fc		bne $953d			bne 	_FFFPPLeft
.9541	7a		ply				ply
.9542					_FFFPPRight:
.9542	4a		lsr a				lsr 	a
.9543	88		dey				dey
.9544	d0 fc		bne $9542			bne 	_FFFPPRight
.9546	80 07		bra $954f			bra 	_FFFPPExit
.9548					_FFFPPWholeByte:
.9548	98		tya				tya 								; subtract 8 from count
.9549	38		sec				sec
.954a	e9 08		sbc #$08			sbc 	#8
.954c	a8		tay				tay
.954d	a9 00		lda #$00			lda 	#0 							; and clear all
.954f					_FFFPPExit:
.954f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9550					FloatIntegerPart:
.9550	48		pha				pha
.9551	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.9554	f0 1f		beq $9575			beq 	_FIPExit 					; if so do nothing
.9556	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; is it zero ?
.9559	f0 17		beq $9572			beq 	_FIPZero 					; if so return zero.
.955b	20 b1 95	jsr $95b1			jsr 	NSNormalise 				; normalise
.955e	f0 12		beq $9572			beq 	_FIPZero 					; normalised to zero, exit zero
.9560					_FIPShift:
.9560	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9563	10 08		bpl $956d			bpl 	_FIPCheckZero
.9565	20 f1 9e	jsr $9ef1			jsr 	NSMShiftRight 				; shift mantissa right
.9568	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.956b	80 f3		bra $9560			bra 	_FIPShift
.956d					_FIPCheckZero:
.956d	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; avoid -0 problem
.9570	d0 03		bne $9575			bne 	_FIPExit 					; set to zero if mantissa zero.
.9572					_FIPZero:
.9572	20 ce 9e	jsr $9ece			jsr 	NSMSetZero
.9575					_FIPExit:
.9575	68		pla				pla
.9576	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9577					FloatingPointMultiply:
.9577	20 a0 95	jsr $95a0			jsr 	FloatPrepare 				; prepare for floats
.957a					FloatMultiply:
.957a	48		pha				pha
.957b	20 b1 95	jsr $95b1			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.957e	f0 1b		beq $959b			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9580	e8		inx				inx
.9581	20 b1 95	jsr $95b1			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9584	ca		dex				dex
.9585	c9 00		cmp #$00			cmp 	#0
.9587	f0 0f		beq $9598			beq 	_FDSetZero
.9589	20 6c 90	jsr $906c			jsr 	MultiplyShort 				; calculate the result.
.958c	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.958f	18		clc				clc
.9590	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.9593	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9596	80 03		bra $959b			bra 	_FDExit
.9598					_FDSetZero:
.9598	20 ce 9e	jsr $9ece			jsr 	NSMSetZero 					; return 0
.959b					_FDExit:
.959b	20 b1 95	jsr $95b1			jsr 	NSNormalise 				; normalise the result
.959e	68		pla				pla
.959f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95a0					FloatPrepare:
.95a0	20 d3 96	jsr $96d3			jsr 	DereferenceTopTwo 			; dereference the top two values
.95a3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.95a6	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.95a9	29 10		and #$10			and 	#NSBIsString
.95ab	d0 01		bne $95ae			bne 	_FDType
.95ad	60		rts				rts
.95ae					_FDType:
.95ae	4c 62 a0	jmp $a062			jmp 	TypeError
.95b1					NSNormalise:
.95b1	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.95b4	29 80		and #$80			and 	#$80
.95b6	09 08		ora #$08			ora 	#NSTFloat
.95b8	9d 00 04	sta $0400,x			sta 	NSStatus,x
.95bb	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; if zero exit
.95be	d0 09		bne $95c9			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95c0	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.95c3	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.95c6	a9 00		lda #$00			lda 	#0 							; set Z flag
.95c8	60		rts				rts
.95c9					_NSNormaliseOptimise:
.95c9	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95cc	d0 22		bne $95f0			bne 	_NSNormaliseLoop
.95ce	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.95d1	30 1d		bmi $95f0			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95d3	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.95d6	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95d9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.95dc	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95df	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.95e2	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.95e5	bd 28 04	lda $0428,x			lda 	NSExponent,x
.95e8	38		sec				sec
.95e9	e9 08		sbc #$08			sbc 	#8
.95eb	9d 28 04	sta $0428,x			sta 	NSExponent,x
.95ee	80 d9		bra $95c9			bra 	_NSNormaliseOptimise
.95f0					_NSNormaliseLoop:
.95f0	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95f3	70 08		bvs $95fd			bvs 	_NSNExit 					; exit if so with Z flag clear
.95f5	20 e3 9e	jsr $9ee3			jsr 	NSMShiftLeft 				; shift mantissa left
.95f8	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.95fb	80 f3		bra $95f0			bra 	_NSNormaliseLoop
.95fd					_NSNExit:
.95fd	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95ff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9600					AssignNumber:
.9600	5a		phy				phy
.9601	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9604	85 36		sta $36				sta 	zTemp0
.9606	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9609	85 37		sta $37				sta 	zTemp0+1
.960b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.960e	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9610	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9613	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9615	c9 08		cmp #$08			cmp 	#NSTFloat
.9617	f0 2a		beq $9643			beq 	_ANFloat
.9619	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.961c	f0 05		beq $9623			beq		_ANNotFloat
.961e	e8		inx				inx
.961f	20 50 95	jsr $9550			jsr 	FloatIntegerPart 			; make it an integer
.9622	ca		dex				dex
.9623					_ANNotFloat:
.9623	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.9626	29 03		and #$03			and 	#3
.9628	d0 05		bne $962f			bne 	_ANByteWord
.962a	20 4f 96	jsr $964f			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.962d	80 1e		bra $964d			bra 	_ANExit
.962f					_ANByteWord:
.962f	48		pha				pha 								; save count
.9630	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.9633	92 36		sta ($36)			sta 	(zTemp0)
.9635	68		pla				pla
.9636	c9 01		cmp #$01			cmp	 	#1
.9638	f0 13		beq $964d			beq 	_ANExit
.963a	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.963d	a0 01		ldy #$01			ldy 	#1
.963f	91 36		sta ($36),y			sta 	(zTemp0),y
.9641	80 0a		bra $964d			bra 	_ANExit
.9643					_ANFloat:
.9643	20 4f 96	jsr $964f			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9646	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9649	a0 04		ldy #$04			ldy 	#4
.964b	91 36		sta ($36),y			sta 	(zTemp0),y
.964d					_ANExit:
.964d	7a		ply				ply
.964e	60		rts				rts
.964f					_ANCopy4PackSign:
.964f	a0 03		ldy #$03			ldy 	#3
.9651	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.9654	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9656	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9659	91 36		sta ($36),y			sta 	(zTemp0),y
.965b	88		dey				dey
.965c	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.965f	91 36		sta ($36),y			sta 	(zTemp0),y
.9661	88		dey				dey
.9662	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9665	91 36		sta ($36),y			sta 	(zTemp0),y
.9667	88		dey				dey
.9668	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.966b	91 36		sta ($36),y			sta 	(zTemp0),y
.966d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.966e					AssignString:
.966e	5a		phy				phy
.966f	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9672	85 38		sta $38				sta 	zTemp1
.9674	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9677	85 39		sta $39				sta 	zTemp1+1
.9679	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.967c	85 36		sta $36				sta 	zTemp0
.967e	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9681	85 37		sta $37				sta 	zTemp0+1
.9683	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9685	b1 36		lda ($36),y			lda 	(zTemp0),y
.9687	f0 23		beq $96ac			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9689	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.968a	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.968c	e9 02		sbc #$02			sbc 	#2
.968e	85 3c		sta $3c				sta 	zsTemp
.9690	a0 01		ldy #$01			ldy 	#1
.9692	b1 36		lda ($36),y			lda 	(zTemp0),y
.9694	e9 00		sbc #$00			sbc 	#0
.9696	85 3d		sta $3d				sta 	zsTemp+1
.9698	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.969a					_ASGetLength:
.969a	c8		iny				iny
.969b	b1 38		lda ($38),y			lda 	(zTemp1),y
.969d	d0 fb		bne $969a			bne 	_ASGetLength
.969f	98		tya				tya 								; is this length <= current length
.96a0	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.96a2	90 20		bcc $96c4			bcc 	_ASCopyString
.96a4	f0 1e		beq $96c4			beq 	_ASCopyString
.96a6	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.96a8	a0 01		ldy #$01			ldy 	#1
.96aa	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96ac					_ASNewStringRequired:
.96ac	e8		inx				inx 								; concrete the new string.
.96ad	20 bf a7	jsr $a7bf			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.96b0	ca		dex				dex
.96b1	18		clc				clc
.96b2	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96b5	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96b7	92 36		sta ($36)			sta 	(zTemp0)
.96b9	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.96bc	69 00		adc #$00			adc 	#0
.96be	a0 01		ldy #$01			ldy 	#1
.96c0	91 36		sta ($36),y			sta 	(zTemp0),y
.96c2	80 0d		bra $96d1			bra 	_ASExit
.96c4					_ASCopyString:
.96c4	a0 00		ldy #$00			ldy 	#0
.96c6					_ASCopyLoop:
.96c6	b1 38		lda ($38),y			lda 	(zTemp1),y
.96c8	c8		iny				iny
.96c9	c8		iny				iny
.96ca	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96cc	88		dey				dey
.96cd	c9 00		cmp #$00			cmp 	#0
.96cf	d0 f5		bne $96c6			bne 	_ASCopyLoop
.96d1					_ASExit:
.96d1	7a		ply				ply
.96d2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96d3					DereferenceTopTwo:
.96d3	e8		inx				inx
.96d4	20 d8 96	jsr $96d8			jsr 	Dereference 				; deref x+1
.96d7	ca		dex				dex  								; falls through to deref x
.96d8					Dereference:
.96d8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.96db	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.96dd	f0 57		beq $9736			beq 	_DRFExit 					; not a reference
.96df	5a		phy				phy
.96e0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96e3	85 36		sta $36				sta 	zTemp0
.96e5	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.96e8	85 37		sta $37				sta 	zTemp0+1
.96ea	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.96ed	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96ef	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.96f2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.96f5	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96f7	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96f9	f0 0f		beq $970a			beq 	_DRFDereferenceTwo
.96fb	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96fd	f0 39		beq $9738			beq 	_DRFFull
.96ff	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9702	29 03		and #$03			and 	#3
.9704	f0 32		beq $9738			beq 	_DRFFull 					; the whole word
.9706	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9708	f0 07		beq $9711			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.970a					_DRFDereferenceTwo:
.970a	a0 01		ldy #$01			ldy 	#1
.970c	b1 36		lda ($36),y			lda 	(zTemp0),y
.970e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9711					_DRFClear23:
.9711	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9714	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9717	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.971a	29 18		and #$18			and 	#NSBTypeMask
.971c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.971f	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9721	d0 12		bne $9735			bne 	_DRFNotString
.9723	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.9726	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9729	d0 0a		bne $9735			bne 	_DRFNotString
.972b	a9 37		lda #$37			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.972d	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.9730	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9732	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.9735					_DRFNotString
.9735	7a		ply				ply 								; restore Y and exit
.9736					_DRFExit:
.9736	60		rts				rts
.9737					_DRFNullString:
>9737	00						.byte 	0
.9738					_DRFFull:
.9738	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.973a	b1 36		lda ($36),y			lda 	(zTemp0),y
.973c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.973f	c8		iny				iny
.9740	b1 36		lda ($36),y			lda 	(zTemp0),y
.9742	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9745	c8		iny				iny
.9746	b1 36		lda ($36),y			lda 	(zTemp0),y
.9748	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.974b	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.974e	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.9751	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9753	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.9756	f0 06		beq $975e			beq 	_DRFNoExponent
.9758	c8		iny				iny 								; if not, read the exponent as well.
.9759	b1 36		lda ($36),y			lda 	(zTemp0),y
.975b	9d 28 04	sta $0428,x			sta 	NSExponent,x
.975e					_DRFNoExponent:
.975e	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9761	10 0d		bpl $9770			bpl 	_DRFExit2 					; if not, then exit.
.9763	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9765	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9768	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.976b	09 80		ora #$80			ora 	#NSBIsNegative
.976d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9770					_DRFExit2:
.9770	7a		ply				ply
.9771	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9772					EncodeNumberStart:
.9772	38		sec				sec
.9773	80 01		bra $9776			bra 	EncodeNumberContinue+1
.9775					EncodeNumberContinue:
.9775	18		clc				clc
.9776					EncodeNumber:
.9776	08		php				php 								; save reset.
.9777	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9779	f0 12		beq $978d			beq 	_ENIsOkay
.977b	c9 30		cmp #$30			cmp 	#"0"
.977d	90 04		bcc $9783			bcc 	_ENBadNumber
.977f	c9 3a		cmp #$3a			cmp 	#"9"+1
.9781	90 0a		bcc $978d			bcc 	_ENIsOkay
.9783					_ENBadNumber:
.9783	28		plp				plp 								; throw saved reset
.9784	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.9787	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9789	f0 7e		beq $9809			beq 	_ENConstructFinal
.978b					_ENFail:
.978b	18		clc				clc 								; not allowed
.978c	60		rts				rts
.978d					_ENIsOkay:
.978d	28		plp				plp 								; are we restarting
.978e	90 15		bcc $97a5			bcc 	_ENNoRestart
.9790					_ENStartEncode:
.9790	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.9792	f0 0c		beq $97a0			beq 	_ENFirstDP
.9794	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.9796	20 d0 9e	jsr $9ed0			jsr 	NSMSetByte
.9799	a9 01		lda #$01			lda 	#ESTA_Low
.979b					_ENExitChange:
.979b	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.979e	38		sec				sec
.979f	60		rts				rts
.97a0					_ENFirstDP:
.97a0	20 ce 9e	jsr $9ece			jsr 	NSMSetZero 					; clear integer part
.97a3	80 3f		bra $97e4			bra 	_ESTASwitchFloat			; go straight to float and exi
.97a5					_ENNoRestart:
.97a5	48		pha				pha 								; save on stack.
.97a6	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.97a9	c9 01		cmp #$01			cmp 	#ESTA_Low
.97ab	f0 09		beq $97b6			beq  	_ESTALowState
.97ad	c9 02		cmp #$02			cmp 	#ESTA_High
.97af	f0 29		beq $97da			beq 	_ESTAHighState
.97b1	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.97b3	f0 3b		beq $97f0			beq 	_ESTADecimalState
>97b5	db						.byte 	$DB 						; causes a break in the emulator
.97b6					_ESTALowState:
.97b6	68		pla				pla 								; get value back
.97b7	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.97b9	f0 29		beq $97e4			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.97bb	29 0f		and #$0f			and 	#15 						; make digit
.97bd	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.97c0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97c3	0a		asl a				asl 	a
.97c4	0a		asl a				asl 	a
.97c5	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97c8	0a		asl a				asl 	a
.97c9	6d 86 04	adc $0486			adc 	DigitTemp
.97cc	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97cf	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97d1	90 05		bcc $97d8			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97d3	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97d5	8d 85 04	sta $0485			sta 	EncodeState
.97d8					_ESTANoSwitch:
.97d8	38		sec				sec
.97d9	60		rts				rts
.97da					_ESTAHighState:
.97da	68		pla				pla 								; get value back
.97db	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97dd	f0 05		beq $97e4			beq 	_ESTASwitchFloat
.97df	20 43 98	jsr $9843			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97e2	38		sec				sec
.97e3	60		rts				rts
.97e4					_ESTASwitchFloat:
.97e4	9c 87 04	stz $0487			stz 	DecimalCount
.97e7	e8		inx				inx 								; zero the decimal additive.
.97e8	20 ce 9e	jsr $9ece			jsr 	NSMSetZero
.97eb	ca		dex				dex
.97ec	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97ee	80 ab		bra $979b			bra 	_ENExitChange
.97f0					_ESTADecimalState:
.97f0	68		pla				pla 								; digit.
.97f1	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97f3	f0 96		beq $978b			beq 	_ENFail
.97f5	e8		inx				inx 								; put digit into fractional part of X+1
.97f6	20 43 98	jsr $9843			jsr 	ESTAShiftDigitIntoMantissa
.97f9	ca		dex				dex
.97fa	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.97fd	ad 87 04	lda $0487			lda 	DecimalCount
.9800	c9 0b		cmp #$0b			cmp 	#11
.9802	f0 02		beq $9806			beq 	_ESTADSFail
.9804	38		sec				sec
.9805	60		rts				rts
.9806					_ESTADSFail:
.9806	4c 5d a0	jmp $a05d			jmp 	RangeError
.9809					_ENConstructFinal:
.9809	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.980c	f0 33		beq $9841			beq 	_ENCFExit 					; no decimals
.980e	5a		phy				phy
.980f	0a		asl a				asl 	a 							; x 4 and CLC
.9810	0a		asl a				asl 	a
.9811	6d 87 04	adc $0487			adc 	DecimalCount
.9814	a8		tay				tay
.9815	b9 1c a0	lda $a01c,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9818	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.981b	b9 1d a0	lda $a01d,y			lda 	DecimalScalarTable-5+1,y
.981e	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9821	b9 1e a0	lda $a01e,y			lda 	DecimalScalarTable-5+2,y
.9824	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9827	b9 1f a0	lda $a01f,y			lda 	DecimalScalarTable-5+3,y
.982a	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.982d	b9 20 a0	lda $a020,y			lda 	DecimalScalarTable-5+4,y
.9830	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9833	a9 08		lda #$08			lda 	#NSTFloat
.9835	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9838	7a		ply				ply
.9839	e8		inx				inx 								; multiply decimal const by decimal scalar
.983a	20 7a 95	jsr $957a			jsr 	FloatMultiply
.983d	ca		dex				dex
.983e	20 07 94	jsr $9407			jsr 	FloatAdd 					; add to integer part.
.9841					_ENCFExit:
.9841	18		clc				clc 								; reject the digit.
.9842	60		rts				rts
.9843					ESTAShiftDigitIntoMantissa:
.9843	29 0f		and #$0f			and 	#15 						; save digit
.9845	48		pha				pha
.9846	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9849	48		pha				pha
.984a	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.984d	48		pha				pha
.984e	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9851	48		pha				pha
.9852	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9855	48		pha				pha
.9856	20 e3 9e	jsr $9ee3			jsr 	NSMShiftLeft 				; x 2
.9859	20 e3 9e	jsr $9ee3			jsr 	NSMShiftLeft 				; x 4
.985c	18		clc				clc 								; pop mantissa and add
.985d	68		pla				pla
.985e	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9861	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9864	68		pla				pla
.9865	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.9868	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.986b	68		pla				pla
.986c	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.986f	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9872	68		pla				pla
.9873	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.9876	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.9879	20 e3 9e	jsr $9ee3			jsr 	NSMShiftLeft 				; x 10
.987c	68		pla				pla 								; add digit
.987d	18		clc				clc
.987e	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9881	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9884	90 0d		bcc $9893			bcc 	_ESTASDExit
.9886	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.9889	d0 08		bne $9893			bne 	_ESTASDExit
.988b	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.988e	d0 03		bne $9893			bne 	_ESTASDExit
.9890	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.9893					_ESTASDExit:
.9893	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9894					EvaluateTerm:
.9894	b1 30		lda ($30),y			lda 	(codePtr),y
.9896	30 18		bmi $98b0			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9898	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.989a	b0 6f		bcs $990b			bcs 	_ETVariable
.989c	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.989e	90 6e		bcc $990e			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.98a0	c9 3a		cmp #$3a			cmp 	#'9'+1
.98a2	b0 6a		bcs $990e			bcs 	_ETPuncUnary
.98a4	20 72 97	jsr $9772			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.98a7					_ETNumber:
.98a7	c8		iny				iny 								; keep encoding until we have the numbers
.98a8	b1 30		lda ($30),y			lda 	(codePtr),y
.98aa	20 75 97	jsr $9775			jsr 	EncodeNumberContinue
.98ad	b0 f8		bcs $98a7			bcs 	_ETNumber 					; go back if accepted.
.98af	60		rts				rts
.98b0					_ETCheckUnary:
.98b0	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.98b2	f0 41		beq $98f5			beq 	_ETString
.98b4	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.98b6	f0 12		beq $98ca			beq 	_ETHexConstant
.98b8	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.98ba	90 0b		bcc $98c7			bcc 	_ETSyntaxError
.98bc	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.98be	b0 07		bcs $98c7			bcs 	_ETSyntaxError
.98c0	da		phx				phx 								; push X on the stack
.98c1	0a		asl a				asl 	a 							; put vector x 2 into X
.98c2	aa		tax				tax
.98c3	c8		iny				iny 								; consume unary function token
.98c4	7c b2 8b	jmp ($8bb2,x)			jmp 	(VectorSet0,x) 				; and do it.
.98c7					_ETSyntaxError:
.98c7	4c 58 a0	jmp $a058			jmp 	SyntaxError
.98ca					_ETHexConstant:
.98ca	c8		iny				iny 								; skip #
.98cb	c8		iny				iny 								; skip count
.98cc	20 ce 9e	jsr $9ece			jsr 	NSMSetZero 					; clear result
.98cf					_ETHLoop:
.98cf	b1 30		lda ($30),y			lda 	(codePtr),y
.98d1	c8		iny				iny 								; and consume
.98d2	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.98d4	f0 1e		beq $98f4			beq 	_ETHExit
.98d6	48		pha				pha 								; save on stack.
.98d7	20 e3 9e	jsr $9ee3			jsr 	NSMShiftLeft 				; x 2
.98da	20 e3 9e	jsr $9ee3			jsr 	NSMShiftLeft 				; x 4
.98dd	20 e3 9e	jsr $9ee3			jsr 	NSMShiftLeft 				; x 8
.98e0	20 e3 9e	jsr $9ee3			jsr 	NSMShiftLeft 				; x 16
.98e3	68		pla				pla 								; ASCII
.98e4	c9 41		cmp #$41			cmp 	#'A'
.98e6	90 02		bcc $98ea			bcc 	_ETHNotChar
.98e8	e9 07		sbc #$07			sbc 	#7
.98ea					_ETHNotChar:
.98ea	29 0f		and #$0f			and 	#15 						; digit now
.98ec	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98ef	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98f2	80 db		bra $98cf			bra 	_ETHLoop 					; go round.
.98f4					_ETHExit:
.98f4	60		rts				rts
.98f5					_ETString:
.98f5	c8		iny				iny 								; look at length
.98f6	b1 30		lda ($30),y			lda 	(codePtr),y
.98f8	48		pha				pha
.98f9	c8		iny				iny 								; first character
.98fa	20 5c a6	jsr $a65c			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98fd	68		pla				pla 								; restore count and save
.98fe	85 36		sta $36				sta 	zTemp0
.9900	98		tya				tya 								; add length to Y to skip it.
.9901	18		clc				clc
.9902	65 36		adc $36				adc 	zTemp0
.9904	a8		tay				tay
.9905	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9907	9d 00 04	sta $0400,x			sta 	NSStatus,x
.990a	60		rts				rts
.990b					_ETVariable:
.990b	4c 65 99	jmp $9965			jmp 	VariableHandler
.990e					_ETPuncUnary:
.990e	c8		iny				iny 								; consume the unary character
.990f	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9911	f0 2d		beq $9940			beq 	_ETUnaryNegate
.9913	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9915	f0 39		beq $9950			beq 	_ETDereference
.9917	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9919	f0 43		beq $995e			beq 	_ETParenthesis
.991b	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.991d	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.991f	f0 06		beq $9927			beq 	_ETIndirection
.9921	e6 36		inc $36				inc 	zTemp0
.9923	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9925	d0 a0		bne $98c7			bne 	_ETSyntaxError
.9927					_ETIndirection:
.9927	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9929	1a		inc a				inc 	a
.992a	48		pha				pha
.992b	20 94 98	jsr $9894			jsr 	EvaluateTerm				; evaluate the term
.992e	20 d8 96	jsr $96d8			jsr 	Dereference 				; dereference it.
.9931	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.9934	d0 07		bne $993d			bne 	_ETTypeMismatch
.9936	68		pla				pla 								; indirection 1-2
.9937	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9939	9d 00 04	sta $0400,x			sta 	NSStatus,x
.993c	60		rts				rts
.993d					_ETTypeMismatch:
.993d	4c 62 a0	jmp $a062			jmp 	TypeError
.9940					_ETUnaryNegate:
.9940	20 94 98	jsr $9894			jsr 	EvaluateTerm				; evaluate the term
.9943	20 d8 96	jsr $96d8			jsr 	Dereference 				; dereference it.
.9946	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.9949	29 10		and #$10			and 	#NSTString
.994b	d0 f0		bne $993d			bne 	_ETTypeMismatch
.994d	4c 7a 9e	jmp $9e7a			jmp 	NSMNegate  					; just toggles the sign bit.
.9950					_ETDereference:
.9950	20 94 98	jsr $9894			jsr 	EvaluateTerm				; evaluate the term
.9953	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.9956	29 20		and #$20			and 	#NSBIsReference
.9958	f0 e3		beq $993d			beq 	_ETTypeMismatch
.995a	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.995d	60		rts				rts
.995e					_ETParenthesis:
.995e	20 ba 93	jsr $93ba			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9961	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; check for )
.9964	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9965					VariableHandler:
.9965	b1 30		lda ($30),y			lda 	(codePtr),y
.9967	18		clc				clc
.9968	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.996a	85 37		sta $37				sta 	zTemp0+1
.996c	c8		iny				iny
.996d	b1 30		lda ($30),y			lda 	(codePtr),y
.996f	85 36		sta $36				sta 	zTemp0
.9971	c8		iny				iny
.9972	18		clc				clc									; copy variable address+3 to mantissa
.9973	69 03		adc #$03			adc 	#3
.9975	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9978	a5 37		lda $37				lda 	zTemp0+1
.997a	69 00		adc #$00			adc 	#0
.997c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.997f	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9982	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9985	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9988	5a		phy				phy
.9989	a0 02		ldy #$02			ldy 	#2 							; read type
.998b	b1 36		lda ($36),y			lda 	(zTemp0),y
.998d	7a		ply				ply
.998e	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9990	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9992	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9995	29 04		and #$04			and 	#NSBIsArray
.9997	d0 01		bne $999a			bne 	_VHArray
.9999	60		rts				rts
.999a					_VHArray:
.999a	e8		inx				inx
.999b	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; get the 1st index.
.999e	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.99a0	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.99a3	b1 30		lda ($30),y			lda 	(codePtr),y
.99a5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.99a7	d0 06		bne $99af			bne 	_VHNoSecondIndex
.99a9	c8		iny				iny 								; skip the comma
.99aa	e8		inx				inx
.99ab	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.99ae	ca		dex				dex
.99af					_VHNoSecondIndex:
.99af	ca		dex				dex 								; set X back.
.99b0	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; and check the right bracket.
.99b3	5a		phy				phy 								; save position
.99b4	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.99b6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99b8	f0 6b		beq $9a25			beq 	_VHBadIndex
.99ba	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.99bd	85 3e		sta $3e				sta 	zaTemp
.99bf	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.99c2	85 3f		sta $3f				sta 	zaTemp+1
.99c4	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.99c6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99c8	f0 02		beq $99cc			beq 	_VHHas2Mask
.99ca	a9 ff		lda #$ff			lda 	#$FF
.99cc					_VHHas2Mask:
.99cc	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.99cf	f0 54		beq $9a25			beq 	_VHBadIndex
.99d1	0a		asl a				asl 	a 							; carry will be set if a second index
.99d2	90 09		bcc $99dd			bcc 	_VHCheckFirstIndex
.99d4	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.99d6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99d8	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.99db	90 48		bcc $9a25			bcc 	_VHBadIndex
.99dd					_VHCheckFirstIndex:
.99dd	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.99df	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99e1	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.99e4	90 3f		bcc $9a25			bcc 	_VHBadIndex
.99e6	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.99e8	64 37		stz $37				stz 	zTemp0+1
.99ea	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99ed	30 0f		bmi $99fe			bmi 	_VHNoMultiply
.99ef	da		phx				phx
.99f0	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.99f3	48		pha				pha
.99f4	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.99f6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99f8	1a		inc a				inc 	a 							; add 1 for zero base
.99f9	fa		plx				plx
.99fa	20 63 9e	jsr $9e63			jsr 	Multiply8x8 				; calculate -> Z0
.99fd	fa		plx				plx
.99fe					_VHNoMultiply:
.99fe	18		clc				clc
.99ff	a5 36		lda $36				lda 	zTemp0
.9a01	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9a04	85 36		sta $36				sta 	zTemp0
.9a06	a5 37		lda $37				lda 	zTemp0+1
.9a08	69 00		adc #$00			adc 	#0
.9a0a	85 37		sta $37				sta 	zTemp0+1
.9a0c	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a0f	20 07 85	jsr $8507			jsr 	ScaleByBaseType
.9a12	18		clc				clc
.9a13	b2 3e		lda ($3e)			lda 	(zaTemp)
.9a15	65 36		adc $36				adc 	zTemp0
.9a17	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a1a	a0 01		ldy #$01			ldy 	#1
.9a1c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9a1e	65 37		adc $37				adc 	zTemp0+1
.9a20	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9a23	7a		ply				ply 								; restore position
.9a24	60		rts				rts
.9a25					_VHBadIndex:
.9a25	a9 17		lda #$17		lda	#23
.9a27	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9a2a					AbsUnary:
.9a2a	fa		plx				plx 								; restore stack pos
.9a2b	20 f7 9d	jsr $9df7			jsr 	EvaluateNumber 				; get a float or int
.9a2e	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9a31	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.9a34	29 7f		and #$7f			and 	#$7F
.9a36	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a39	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9a3a					AllocUnary:
.9a3a	fa		plx				plx 								; restore stack pos
.9a3b	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger		; get bytes required.
.9a3e	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9a41	da		phx				phx 								; save X/Y
.9a42	5a		phy				phy
.9a43	8a		txa				txa 								; copy X into Y
.9a44	a8		tay				tay
.9a45	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.9a48	aa		tax				tax
.9a49	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.9a4c	20 59 9a	jsr $9a59			jsr 	AllocateXABytes 			; allocate memory
.9a4f	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.9a52	8a		txa				txa
.9a53	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.9a56	7a		ply				ply
.9a57	fa		plx				plx
.9a58	60		rts				rts
.9a59					AllocateXABytes:
.9a59	5a		phy				phy
.9a5a	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a5d	84 36		sty $36				sty 	zTemp0
.9a5f	5a		phy				phy
.9a60	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.9a63	84 37		sty $37				sty 	zTemp0+1
.9a65	5a		phy				phy
.9a66	18		clc				clc 								; add to low memory pointer
.9a67	6d 8c 04	adc $048c			adc 	lowMemPtr
.9a6a	8d 8c 04	sta $048c			sta 	lowMemPtr
.9a6d	8a		txa				txa
.9a6e	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.9a71	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.9a74	b0 2f		bcs $9aa5			bcs 	CISSMemory
.9a76	20 97 9a	jsr $9a97			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a79					_ClearMemory:
.9a79	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.9a7c	c5 36		cmp $36				cmp 	zTemp0
.9a7e	d0 07		bne $9a87			bne 	_CMClearNext
.9a80	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.9a83	c5 37		cmp $37				cmp 	zTemp0+1
.9a85	f0 0c		beq $9a93			beq 	_CMExit
.9a87					_CMClearNext:
.9a87	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a89	92 36		sta ($36)			sta 	(zTemp0)
.9a8b	e6 36		inc $36				inc 	zTemp0
.9a8d	d0 ea		bne $9a79			bne 	_ClearMemory
.9a8f	e6 37		inc $37				inc		zTemp0+1
.9a91	80 e6		bra $9a79			bra 	_ClearMemory
.9a93					_CMExit:
.9a93	fa		plx				plx
.9a94	68		pla				pla
.9a95	7a		ply				ply
.9a96	60		rts				rts
.9a97					CheckIdentifierStringSpace:
.9a97	48		pha				pha
.9a98	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.9a9b	18		clc				clc
.9a9c	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a9e	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.9aa1	b0 02		bcs $9aa5			bcs 	CISSMemory
.9aa3	68		pla				pla
.9aa4	60		rts				rts
.9aa5					CISSMemory:
.9aa5	a9 06		lda #$06		lda	#6
.9aa7	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9aaa					AscUnary:
.9aaa	fa		plx				plx 								; restore stack pos
.9aab	20 02 9e	jsr $9e02			jsr 	EvaluateString 				; get a string
.9aae	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9ab0	20 d0 9e	jsr $9ed0			jsr 	NSMSetByte
.9ab3	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9ab6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9ab7					FracUnary:
.9ab7	fa		plx				plx 								; restore stack pos
.9ab8	20 f7 9d	jsr $9df7			jsr 	EvaluateNumber 				; get a float or int
.9abb	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9abe	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ac1	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9ac3	f0 04		beq $9ac9			beq 	_IUZero
.9ac5	20 ed 94	jsr $94ed			jsr 	FloatFractionalPart
.9ac8	60		rts				rts
.9ac9					_IUZero:
.9ac9	20 ce 9e	jsr $9ece			jsr 	NSMSetZero
.9acc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9acd					IntUnary:
.9acd	fa		plx				plx 								; restore stack pos
.9ace	20 f7 9d	jsr $9df7			jsr 	EvaluateNumber 				; get a float or int
.9ad1	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9ad4	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ad7	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9ad9	f0 03		beq $9ade			beq 	_IUExit
.9adb	20 50 95	jsr $9550			jsr 	FloatIntegerPart
.9ade					_IUExit:
.9ade	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9adf					LenUnary:
.9adf	fa		plx				plx 								; restore stack pos
.9ae0	20 02 9e	jsr $9e02			jsr 	EvaluateString 				; get a string
.9ae3	5a		phy				phy
.9ae4	a0 00		ldy #$00			ldy 	#0 							; find length
.9ae6					_LenFind:
.9ae6	b1 36		lda ($36),y			lda 	(zTemp0),y
.9ae8	f0 06		beq $9af0			beq 	_LenExit
.9aea	c8		iny				iny
.9aeb	d0 f9		bne $9ae6			bne 	_LenFind
.9aed	4c 5d a0	jmp $a05d			jmp 	RangeError 					; string > 255
.9af0					_LenExit:
.9af0	98		tya				tya
.9af1	20 d0 9e	jsr $9ed0			jsr 	NSMSetByte
.9af4	7a		ply				ply
.9af5	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9af8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9af9					Unary_Min:
.9af9	a9 01		lda #$01			lda 	#1
.9afb	80 02		bra $9aff			bra 	UnaryMinMaxMain
.9afd					Unary_Max:
.9afd	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9aff					UnaryMinMaxMain:
.9aff	fa		plx				plx 								; get index on number stack
.9b00	48		pha				pha 								; save comparator
.9b01	20 ee 9d	jsr $9dee			jsr 	EvaluateValue 				; get the first value.
.9b04					_UMMMLoop:
.9b04	b1 30		lda ($30),y			lda 	(codePtr),y
.9b06	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9b08	f0 22		beq $9b2c			beq 	_UMMMDone
.9b0a	20 fa 8d	jsr $8dfa			jsr 	CheckComma 					; must be a comma
.9b0d	e8		inx				inx
.9b0e	20 ee 9d	jsr $9dee			jsr 	EvaluateValue
.9b11	ca		dex				dex
.9b12	20 a5 9e	jsr $9ea5			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9b15	e8		inx				inx
.9b16	20 a5 9e	jsr $9ea5			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9b19	e8		inx				inx
.9b1a	20 c3 8e	jsr $8ec3			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9b1d	ca		dex				dex
.9b1e	ca		dex				dex
.9b1f	85 36		sta $36				sta 	zTemp0 						; save required result
.9b21	68		pla				pla 								; get and save comparator
.9b22	48		pha				pha
.9b23	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9b25	d0 dd		bne $9b04			bne 	_UMMMLoop
.9b27	20 2f 9b	jsr $9b2f			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9b2a	80 d8		bra $9b04			bra 	_UMMMLoop
.9b2c					_UMMMDone:
.9b2c	68		pla				pla 								; throw the comparator
.9b2d	c8		iny				iny 								; skip )
.9b2e	60		rts				rts
.9b2f					ExpCopyAboveDown:
.9b2f	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9b32	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b35	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9b38	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9b3b	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9b3e	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b41	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9b44	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b47	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9b4a	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b4d	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9b50	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b53	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b54					Unary_Not:
.9b54	fa		plx				plx
.9b55	20 1a 9e	jsr $9e1a			jsr 	EvaluateInteger 			; get integer
.9b58	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9b5b	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; zero mantissa ?
.9b5e	f0 04		beq $9b64			beq 	_NotZero
.9b60	20 ce 9e	jsr $9ece			jsr 	NSMSetZero
.9b63	60		rts				rts
.9b64					_NotZero:
.9b64	4c 78 8e	jmp $8e78			jmp 	ReturnTrue
.9b67					_UNBad:
.9b67	4c 67 a0	jmp $a067			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b6a					Unary_Random:
.9b6a	fa		plx				plx
.9b6b	20 e9 9b	jsr $9be9			jsr 	Random32Bit 				; get a random number
.9b6e	20 ce 9b	jsr $9bce			jsr 	URCopyToMantissa  			; put in mantissa
.9b71	b1 30		lda ($30),y			lda 	(codePtr),y
.9b73	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b75	f0 08		beq $9b7f			beq 	_URNoModulus
.9b77	e8		inx				inx
.9b78	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b7b	ca		dex				dex
.9b7c	20 e7 8f	jsr $8fe7			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9b7f					_URNoModulus:
.9b7f	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9b82	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9b85	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9b88	60		rts				rts
.9b89					Unary_Rnd:
.9b89	fa		plx				plx
.9b8a	20 f7 9d	jsr $9df7			jsr 	EvaluateNumber 				; number to use.
.9b8d	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; closing bracket
.9b90	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b93	f0 2b		beq $9bc0			beq 	_URCopySeed
.9b95	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b98	10 23		bpl $9bbd			bpl 	_URDontSeed
.9b9a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b9d	49 17		eor #$17			eor 	#$17
.9b9f	8d 88 04	sta $0488			sta 	RandomSeed+0
.9ba2	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9ba5	49 a5		eor #$a5			eor 	#$A5
.9ba7	8d 89 04	sta $0489			sta 	RandomSeed+1
.9baa	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9bad	49 c2		eor #$c2			eor 	#$C2
.9baf	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9bb2	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9bb5	49 9d		eor #$9d			eor 	#$9D
.9bb7	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9bba	20 e9 9b	jsr $9be9			jsr 	Random32Bit
.9bbd					_URDontSeed:
.9bbd	20 e9 9b	jsr $9be9			jsr 	Random32Bit 				; generate a number.
.9bc0					_URCopySeed:
.9bc0	20 ce 9b	jsr $9bce			jsr 	URCopyToMantissa 			; copy into mantissa
.9bc3	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9bc5	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9bc8	a9 08		lda #$08			lda 	#NSTFloat
.9bca	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; positive.
.9bcd	60		rts				rts
.9bce					URCopyToMantissa:
.9bce	ad 88 04	lda $0488			lda 	RandomSeed+0
.9bd1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9bd4	ad 89 04	lda $0489			lda 	RandomSeed+1
.9bd7	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9bda	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9bdd	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9be0	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9be3	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9be5	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9be8	60		rts				rts
.9be9					Random32Bit:
.9be9	5a		phy				phy
.9bea	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9bec	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9bef	d0 03		bne $9bf4			bne 	_Random1
.9bf1	a8		tay				tay 								; if so do it 256 times
.9bf2	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9bf4					_Random1:
.9bf4	0a		asl a				asl 	a 							; LSFR RNG
.9bf5	2e 89 04	rol $0489			rol 	RandomSeed+1
.9bf8	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9bfb	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9bfe	90 02		bcc $9c02			bcc 	_Random2
.9c00	49 c5		eor #$c5			eor 	#$C5
.9c02					_Random2:
.9c02	88		dey				dey
.9c03	d0 ef		bne $9bf4			bne 	_Random1
.9c05	8d 88 04	sta $0488			sta 	RandomSeed+0
.9c08	7a		ply				ply
.9c09	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9c0a					SgnUnary:
.9c0a	fa		plx				plx 								; restore stack pos
.9c0b	20 f7 9d	jsr $9df7			jsr 	EvaluateNumber 				; get a float or int
.9c0e	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9c11	20 fe 9e	jsr $9efe			jsr 	NSMIsZero 					; if zero
.9c14	f0 10		beq $9c26			beq 	_SGZero  					; return Int Zero
.9c16	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9c19	48		pha				pha
.9c1a	a9 01		lda #$01			lda 	#1 							; set to 1
.9c1c	20 d0 9e	jsr $9ed0			jsr 	NSMSetByte
.9c1f	68		pla				pla
.9c20	29 80		and #$80			and		#$80 						; copy the sign byte out
.9c22	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c25	60		rts				rts
.9c26	20 ce 9e	jsr $9ece	_SGZero:jsr 	NSMSetZero
.9c29	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9c2a					ValUnary:
.9c2a	fa		plx				plx 								; restore stack pos
.9c2b	20 40 9c	jsr $9c40			jsr 	ValMainCode 				; do the main val() code
.9c2e	b0 01		bcs $9c31			bcs 	_VUError 					; couldn't convert
.9c30	60		rts				rts
.9c31					_VUError:
.9c31	4c 62 a0	jmp $a062			jmp 	TypeError
.9c34					IsValUnary:
.9c34	fa		plx				plx 								; restore stack pos
.9c35	20 40 9c	jsr $9c40			jsr 	ValMainCode 				; do the main val() code
.9c38	b0 03		bcs $9c3d			bcs 	_VUBad
.9c3a	4c 78 8e	jmp $8e78			jmp 	ReturnTrue
.9c3d					_VUBad:
.9c3d	4c 84 8e	jmp $8e84			jmp 	ReturnFalse
.9c40					ValMainCode:
.9c40	20 02 9e	jsr $9e02			jsr 	EvaluateString 				; get a string
.9c43	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; check right bracket present
.9c46					ValEvaluateZTemp0:
.9c46	5a		phy				phy
.9c47	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9c49	f0 17		beq $9c62			beq 	_VMCFail2
.9c4b	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9c4d	48		pha				pha 								; save first character
.9c4e	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9c50	d0 01		bne $9c53			bne 	_VMCStart
.9c52	c8		iny				iny 								; skip over -
.9c53					_VMCStart:
.9c53	38		sec				sec 								; initialise first time round.
.9c54					_VMCNext:
.9c54	c8		iny				iny 								; pre-increment
.9c55	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9c57	f0 0c		beq $9c65			beq 	_VMCSuccess 				; successful.
.9c59	20 76 97	jsr $9776			jsr 	EncodeNumber 				; send it to the number-builder
.9c5c	90 03		bcc $9c61			bcc 	_VMCFail 					; if failed, give up.
.9c5e	18		clc				clc 								; next time round, countinue
.9c5f	80 f3		bra $9c54			bra 	_VMCNext
.9c61					_VMCFail:
.9c61	68		pla				pla
.9c62					_VMCFail2:
.9c62	7a		ply				ply
.9c63	38		sec				sec
.9c64	60		rts				rts
.9c65					_VMCSuccess:
.9c65	a9 00		lda #$00			lda 	#0 							; construct final
.9c67	20 76 97	jsr $9776			jsr 	EncodeNumber
.9c6a	68		pla				pla
.9c6b	c9 2d		cmp #$2d			cmp 	#"-"
.9c6d	d0 03		bne $9c72			bne 	_VMCNotNegative
.9c6f	20 7a 9e	jsr $9e7a			jsr		NSMNegate
.9c72					_VMCNotNegative:
.9c72	7a		ply				ply
.9c73	18		clc				clc
.9c74	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c75					ChrUnary:
.9c75	fa		plx				plx 								; restore stack pos
.9c76	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger			; get value
.9c79	48		pha				pha
.9c7a	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9c7d	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c7f	20 40 a8	jsr $a840			jsr 	StringTempAllocate
.9c82	68		pla				pla 								; write number to it
.9c83	20 7e a8	jsr $a87e			jsr 	StringTempWrite
.9c86	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c87					SpcUnary:
.9c87	fa		plx				plx 								; restore stack pos
.9c88	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger			; get value
.9c8b	5a		phy				phy
.9c8c	48		pha				pha 								; save count
.9c8d	20 40 a8	jsr $a840			jsr 	StringTempAllocate
.9c90	7a		ply				ply 								; to do count in Y
.9c91					_SpcLoop:
.9c91	c0 00		cpy #$00			cpy 	#0
.9c93	f0 08		beq $9c9d			beq 	_SpcExit
.9c95	a9 20		lda #$20			lda 	#32
.9c97	20 7e a8	jsr $a87e			jsr 	StringTempWrite
.9c9a	88		dey				dey
.9c9b	80 f4		bra $9c91			bra 	_SPCLoop
.9c9d					_SpcExit:
.9c9d	7a		ply				ply
.9c9e	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.9ca1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9ca2					Unary_Str:
.9ca2	fa		plx				plx
.9ca3	20 f7 9d	jsr $9df7			jsr 	EvaluateNumber  			; get number
.9ca6	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; closing bracket
.9ca9	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9cab	20 c4 9c	jsr $9cc4			jsr 	ConvertNumberToString 		; do the conversion.
.9cae	a9 21		lda #$21			lda		#33 						; create buffer
.9cb0	20 40 a8	jsr $a840			jsr 	StringTempAllocate 			; allocate memory
.9cb3	da		phx				phx
.9cb4	a2 00		ldx #$00			ldx 	#0
.9cb6					_USCopy:
.9cb6	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9cb9	20 7e a8	jsr $a87e			jsr 	StringTempWrite
.9cbc	e8		inx				inx
.9cbd	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9cc0	d0 f4		bne $9cb6			bne 	_USCopy
.9cc2	fa		plx				plx
.9cc3	60		rts				rts
.9cc4					ConvertNumberToString:
.9cc4	5a		phy				phy 								; save code position
.9cc5	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9cc8	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9ccb	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9cce	10 0a		bpl $9cda			bpl 	_CNTSNotNegative
.9cd0	29 7f		and #$7f			and 	#$7F 						; make +ve
.9cd2	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9cd5	a9 2d		lda #$2d			lda 	#"-"
.9cd7	20 40 9d	jsr $9d40			jsr 	WriteDecimalBuffer
.9cda					_CNTSNotNegative:
.9cda	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9cdd	f0 15		beq $9cf4			beq 	_CNTSNotFloat
.9cdf	e8		inx				inx 								; round up
.9ce0	a9 01		lda #$01			lda 	#1
.9ce2	20 d0 9e	jsr $9ed0			jsr 	NSMSetByte
.9ce5	ca		dex				dex
.9ce6	bd 28 04	lda $0428,x			lda		NSExponent,x
.9ce9	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9cec	a9 08		lda #$08			lda 	#NSTFloat
.9cee	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9cf1	20 07 94	jsr $9407			jsr 	FloatAdd
.9cf4					_CNTSNotFloat:
.9cf4	20 22 9d	jsr $9d22			jsr 	MakePlusTwoString
.9cf7	20 ed 94	jsr $94ed			jsr 	FloatFractionalPart 		; get the fractional part
.9cfa	20 b1 95	jsr $95b1			jsr 	NSNormalise					; normalise , exit if zero
.9cfd	f0 21		beq $9d20			beq 	_CNTSExit
.9cff	a9 2e		lda #$2e			lda 	#"."
.9d01	20 40 9d	jsr $9d40			jsr 	WriteDecimalBuffer 			; write decimal place
.9d04					_CNTSDecimal:
.9d04	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9d07	30 17		bmi $9d20			bmi 	_CNTSExit
.9d09	e8		inx				inx 								; x 10.0
.9d0a	a9 0a		lda #$0a			lda 	#10
.9d0c	20 d0 9e	jsr $9ed0			jsr 	NSMSetByte
.9d0f	a9 08		lda #$08			lda 	#NSTFloat
.9d11	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9d14	ca		dex				dex
.9d15	20 7a 95	jsr $957a			jsr 	FloatMultiply
.9d18	20 22 9d	jsr $9d22			jsr 	MakePlusTwoString
.9d1b	20 ed 94	jsr $94ed			jsr 	FloatFractionalPart 		; get the fractional part
.9d1e	80 e4		bra $9d04			bra 	_CNTSDecimal 				; keep going.
.9d20					_CNTSExit:
.9d20	7a		ply				ply
.9d21	60		rts				rts
.9d22					MakePlusTwoString:
.9d22	da		phx				phx
.9d23	20 a5 9e	jsr $9ea5			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9d26	e8		inx				inx 								; access it
.9d27	e8		inx				inx
.9d28	20 50 95	jsr $9550			jsr 	FloatIntegerPart 			; make it an integer
.9d2b	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9d2d	20 32 93	jsr $9332			jsr 	ConvertInt32
.9d30	a2 00		ldx #$00			ldx	 	#0
.9d32					_MPTSCopy:
.9d32	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d35	20 40 9d	jsr $9d40			jsr 	WriteDecimalBuffer
.9d38	e8		inx				inx
.9d39	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d3c	d0 f4		bne $9d32			bne 	_MPTSCopy
.9d3e	fa		plx				plx
.9d3f	60		rts				rts
.9d40					WriteDecimalBuffer:
.9d40	da		phx				phx
.9d41	ae 95 04	ldx $0495			ldx 	dbOffset
.9d44	9d 1c 06	sta $061c,x			sta 	DecimalBuffer,x
.9d47	9e 1d 06	stz $061d,x			stz 	DecimalBuffer+1,x
.9d4a	ee 95 04	inc $0495			inc 	dbOffset
.9d4d	fa		plx				plx
.9d4e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9d4f					Unary_Left:
.9d4f	fa		plx				plx
.9d50	18		clc				clc 								; only one parameter
.9d51	20 c6 9d	jsr $9dc6			jsr 	SubstringInitial 			; set up.
.9d54	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9d57	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d5a	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9d5d	80 2c		bra $9d8b			bra 	SubstringMain
.9d5f					Unary_Right:
.9d5f	fa		plx				plx
.9d60	18		clc				clc 								; only one parameter
.9d61	20 c6 9d	jsr $9dc6			jsr 	SubstringInitial 			; set up.
.9d64	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9d67	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d6a	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9d6d	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d70	b0 02		bcs $9d74			bcs 	_URNotUnderflow
.9d72	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d74					_URNotUnderFlow:
.9d74	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d77	80 12		bra $9d8b			bra 	SubStringMain
.9d79					Unary_Mid:
.9d79	fa		plx				plx
.9d7a	38		sec				sec 								; two parameters
.9d7b	20 c6 9d	jsr $9dc6			jsr 	SubstringInitial 			; set up.
.9d7e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d81	f0 05		beq $9d88			beq 	_UMError
.9d83	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d86	80 03		bra $9d8b			bra 	SubStringMain
.9d88					_UMError:
.9d88	4c 67 a0	jmp $a067			jmp 	ArgumentError
.9d8b					SubStringMain:
.9d8b	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d8e	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9d91	b0 2d		bcs $9dc0			bcs 	_SSMNull 					; if so, return an empty string.
.9d93	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d96	f0 28		beq $9dc0			beq 	_SSMNull 					; return empty string.
.9d98	18		clc				clc 								; add the offset +1 to the address and
.9d99	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9d9c	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9d9f	85 36		sta $36				sta 	zTemp0
.9da1	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9da4	69 00		adc #$00			adc 	#0
.9da6	85 37		sta $37				sta 	zTemp0+1
.9da8					_SSMNoCarry:
.9da8	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9dab	20 40 a8	jsr $a840			jsr 	StringTempAllocate 			; allocate that many characters
.9dae	5a		phy				phy 								; save Y
.9daf	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9db1					_SSMCopy:
.9db1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9db3	f0 09		beq $9dbe			beq 	_SSMEString 				; no more to copy
.9db5	20 7e a8	jsr $a87e			jsr 	StringTempWrite 			; and write it out.
.9db8	c8		iny				iny
.9db9	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9dbc	d0 f3		bne $9db1			bne 	_SSMCopy
.9dbe					_SSMEString:
.9dbe	7a		ply				ply
.9dbf					_SSMExit:
.9dbf	60		rts				rts
.9dc0					_SSMNull:
.9dc0	a9 00		lda #$00			lda 	#0
.9dc2	20 40 a8	jsr $a840			jsr 	StringTempAllocate
.9dc5	60		rts				rts
.9dc6					SubstringInitial:
.9dc6	da		phx				phx 								; save initial stack position
.9dc7	08		php				php 								; save carry on stack indicating 2 parameters
.9dc8	20 02 9e	jsr $9e02			jsr 	EvaluateString 				; get a string
.9dcb	5a		phy				phy 								; calculate length to exponent.
.9dcc	a0 ff		ldy #$ff			ldy 	#$FF
.9dce					_SIFindLength:
.9dce	c8		iny				iny
.9dcf	b1 36		lda ($36),y			lda 	(zTemp0),y
.9dd1	d0 fb		bne $9dce			bne 	_SIFindLength
.9dd3	98		tya				tya
.9dd4	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9dd7	7a		ply				ply
.9dd8	e8		inx				inx
.9dd9	20 fa 8d	jsr $8dfa			jsr 	CheckComma 					; comma next
.9ddc	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; get next parameter
.9ddf	28		plp				plp 								; is it the last parameter ?
.9de0	90 07		bcc $9de9			bcc 	_SSIExit 					; if so, exit.
.9de2	e8		inx				inx
.9de3	20 fa 8d	jsr $8dfa			jsr 	CheckComma 					; comma next
.9de6	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; get last parameter
.9de9					_SSIExit:
.9de9	fa		plx				plx
.9dea	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket 			; check closing bracket
.9ded	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9dee					EvaluateValue:
.9dee	48		pha				pha
.9def	20 ba 93	jsr $93ba			jsr		EvaluateExpression 			; expression
.9df2	20 d8 96	jsr $96d8			jsr 	Dereference					; derefernce it
.9df5	68		pla				pla
.9df6	60		rts				rts
.9df7					EvaluateNumber:
.9df7	20 ee 9d	jsr $9dee			jsr 	EvaluateValue 				; get a value
.9dfa	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9dfd	29 10		and #$10			and 	#NSBIsString
.9dff	d0 16		bne $9e17			bne 	HelperTypeError
.9e01	60		rts				rts
.9e02					EvaluateString:
.9e02	20 ee 9d	jsr $9dee			jsr 	EvaluateValue 				; get a value
.9e05	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9e08	29 10		and #$10			and 	#NSBIsString
.9e0a	f0 0b		beq $9e17			beq 	HelperTypeError
.9e0c					CopyAddressToTemp0:
.9e0c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9e0f	85 36		sta $36				sta 	zTemp0
.9e11	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e14	85 37		sta $37				sta 	zTemp0+1
.9e16	60		rts				rts
.9e17					HelperTypeError:
.9e17	4c 62 a0	jmp $a062			jmp 	TypeError
.9e1a					EvaluateInteger:
.9e1a	20 f7 9d	jsr $9df7			jsr 	EvaluateNumber
.9e1d	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9e20	d0 0a		bne $9e2c			bne 	HelperValueError 			; if not, it's a float.
.9e22	60		rts				rts
.9e23					EvaluateUnsignedInteger:
.9e23	20 1a 9e	jsr $9e1a			jsr 	EvaluateInteger 			; check integer is +ve
.9e26	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e29	30 01		bmi $9e2c			bmi 	HelperValueError
.9e2b	60		rts				rts
.9e2c					HelperValueError:
.9e2c	4c 67 a0	jmp $a067			jmp 	ArgumentError
.9e2f					Evaluate16BitInteger:
.9e2f	20 23 9e	jsr $9e23			jsr	 	EvaluateUnsignedInteger		; get integer
.9e32	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e35	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e38	d0 f2		bne $9e2c			bne 	HelperValueError
.9e3a	60		rts				rts
.9e3b					Evaluate16BitIntegerSigned:
.9e3b	20 1a 9e	jsr $9e1a			jsr	 	EvaluateInteger				; get integer
.9e3e	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e41	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e44	d0 e6		bne $9e2c			bne 	HelperValueError
.9e46	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9e49	10 03		bpl $9e4e			bpl 	_EISNotSigned
.9e4b	20 83 9e	jsr $9e83			jsr 	NSMNegateMantissa
.9e4e					_EISNotSigned:
.9e4e	60		rts				rts
.9e4f					Evaluate8BitInteger:
.9e4f	20 23 9e	jsr $9e23			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9e52	d0 d8		bne $9e2c			bne 	HelperValueError
.9e54	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9e57	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e5a	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9e5d	d0 cd		bne $9e2c			bne 	HelperValueError
.9e5f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e62	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9e63					Multiply8x8:
.9e63	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9e64	85 36		sta $36			  	sta 	zTemp0
.9e66	86 37		stx $37				stx 	zTemp0+1
.9e68	a9 00		lda #$00			lda 	#0
.9e6a	a2 08		ldx #$08			ldx 	#8
.9e6c					_M88Loop:
.9e6c	90 03		bcc $9e71			bcc 	_M88NoAdd
.9e6e	18		clc				clc
.9e6f	65 37		adc $37				adc 	zTemp0+1
.9e71					_M88NoAdd:
.9e71	6a		ror a				ror 	a
.9e72	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9e74	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9e75	d0 f5		bne $9e6c			bne 	_M88Loop
.9e77	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9e79	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9e7a					NSMNegate:
.9e7a	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e7d	49 80		eor #$80			eor 	#NSBIsNegative
.9e7f	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9e82	60		rts				rts
.9e83					NSMNegateMantissa:
.9e83	38		sec				sec
.9e84	a9 00		lda #$00			lda 	#0
.9e86	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9e89	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9e8c	a9 00		lda #$00			lda 	#0
.9e8e	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9e91	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9e94	a9 00		lda #$00			lda 	#0
.9e96	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9e99	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9e9c	a9 00		lda #$00			lda 	#0
.9e9e	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9ea1	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9ea4	60		rts				rts
.9ea5					NSMShiftUpTwo:
.9ea5	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9ea8	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9eab	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9eae	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9eb1	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9eb4	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9eb7	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9eba	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9ebd	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9ec0	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9ec3	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ec6	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9ec9	60		rts				rts
.9eca					NSMSetZeroMantissaOnly:
.9eca	a9 00		lda #$00			lda 	#0
.9ecc	80 08		bra $9ed6			bra 	NSMSetMantissa
.9ece					NSMSetZero:
.9ece	a9 00		lda #$00			lda 	#0
.9ed0					NSMSetByte:
.9ed0	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9ed3	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9ed6					NSMSetMantissa:
.9ed6	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9ed9	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9edc	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9edf	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9ee2	60		rts				rts
.9ee3					NSMShiftLeft:
.9ee3	18		clc				clc
.9ee4					NSMRotateLeft:
.9ee4	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9ee7	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9eea	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9eed	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9ef0	60		rts				rts
.9ef1					NSMShiftRight:
.9ef1	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9ef4	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9ef7	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9efa	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9efd	60		rts				rts
.9efe					NSMIsZero:
.9efe	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9f01	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9f04	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9f07	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9f0a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.baa8					TickHandler:
.baa8	5a		phy				phy 								; need to preserve Y
.baa9	20 4e ba	jsr $ba4e			jsr 	SNDUpdate 					; update sound
.baac	7a		ply				ply
.baad	60		rts				rts
.062e					LastTick:
>062e							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9f0b					Assemble_ora:
.9f0b	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f0e	01					.byte $01
.9f0f					Assemble_and:
.9f0f	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f12	21					.byte $21
.9f13					Assemble_eor:
.9f13	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f16	41					.byte $41
.9f17					Assemble_adc:
.9f17	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f1a	61					.byte $61
.9f1b					Assemble_sta:
.9f1b	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f1e	81					.byte $81
.9f1f					Assemble_lda:
.9f1f	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f22	a1					.byte $a1
.9f23					Assemble_cmp:
.9f23	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f26	c1					.byte $c1
.9f27					Assemble_sbc:
.9f27	20 63 80	jsr $8063		jsr	AssembleGroup1
>9f2a	e1					.byte $e1
.9f2b					Assemble_asl:
.9f2b	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f2e	02					.byte $02
>9f2f	75					.byte $75
.9f30					Assemble_rol:
.9f30	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f33	22					.byte $22
>9f34	75					.byte $75
.9f35					Assemble_lsr:
.9f35	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f38	42					.byte $42
>9f39	75					.byte $75
.9f3a					Assemble_ror:
.9f3a	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f3d	62					.byte $62
>9f3e	75					.byte $75
.9f3f					Assemble_stx:
.9f3f	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f42	82					.byte $82
>9f43	50					.byte $50
.9f44					Assemble_ldx:
.9f44	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f47	a2					.byte $a2
>9f48	d0					.byte $d0
.9f49					Assemble_dec:
.9f49	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f4c	c2					.byte $c2
>9f4d	55					.byte $55
.9f4e					Assemble_inc:
.9f4e	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f51	e2					.byte $e2
>9f52	55					.byte $55
.9f53					Assemble_stz:
.9f53	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f56	60					.byte $60
>9f57	44					.byte $44
.9f58					Assemble_bit:
.9f58	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f5b	20					.byte $20
>9f5c	55					.byte $55
.9f5d					Assemble_sty:
.9f5d	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f60	80					.byte $80
>9f61	54					.byte $54
.9f62					Assemble_ldy:
.9f62	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f65	a0					.byte $a0
>9f66	d5					.byte $d5
.9f67					Assemble_cpy:
.9f67	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f6a	c0					.byte $c0
>9f6b	d4					.byte $d4
.9f6c					Assemble_cpx:
.9f6c	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f6f	e0					.byte $e0
>9f70	d0					.byte $d0
.9f71					Assemble_tsb:
.9f71	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f74	00					.byte $00
>9f75	50					.byte $50
.9f76					Assemble_trb:
.9f76	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f79	10					.byte $10
>9f7a	50					.byte $50
.9f7b					Assemble_jsr:
.9f7b	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f7e	14					.byte $14
>9f7f	10					.byte $10
.9f80					Assemble_jmp:
.9f80	20 6a 80	jsr $806a		jsr	AssembleGroup2
>9f83	40					.byte $40
>9f84	10					.byte $10
.9f85					Assemble_bpl:
.9f85	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9f88	10					.byte $10
.9f89					Assemble_bmi:
.9f89	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9f8c	30					.byte $30
.9f8d					Assemble_bvc:
.9f8d	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9f90	50					.byte $50
.9f91					Assemble_bvs:
.9f91	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9f94	70					.byte $70
.9f95					Assemble_bcc:
.9f95	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9f98	90					.byte $90
.9f99					Assemble_bcs:
.9f99	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9f9c	b0					.byte $b0
.9f9d					Assemble_bne:
.9f9d	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9fa0	d0					.byte $d0
.9fa1					Assemble_beq:
.9fa1	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9fa4	f0					.byte $f0
.9fa5					Assemble_bra:
.9fa5	20 bb 80	jsr $80bb		jsr	AssembleGroup3
>9fa8	80					.byte $80
.9fa9					Assemble_brk:
.9fa9	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fac	00					.byte $00
.9fad					Assemble_php:
.9fad	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fb0	08					.byte $08
.9fb1					Assemble_clc:
.9fb1	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fb4	18					.byte $18
.9fb5					Assemble_plp:
.9fb5	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fb8	28					.byte $28
.9fb9					Assemble_sec:
.9fb9	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fbc	38					.byte $38
.9fbd					Assemble_rti:
.9fbd	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fc0	40					.byte $40
.9fc1					Assemble_pha:
.9fc1	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fc4	48					.byte $48
.9fc5					Assemble_cli:
.9fc5	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fc8	58					.byte $58
.9fc9					Assemble_phy:
.9fc9	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fcc	5a					.byte $5a
.9fcd					Assemble_rts:
.9fcd	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fd0	60					.byte $60
.9fd1					Assemble_pla:
.9fd1	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fd4	68					.byte $68
.9fd5					Assemble_sei:
.9fd5	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fd8	78					.byte $78
.9fd9					Assemble_ply:
.9fd9	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fdc	7a					.byte $7a
.9fdd					Assemble_dey:
.9fdd	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fe0	88					.byte $88
.9fe1					Assemble_txa:
.9fe1	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fe4	8a					.byte $8a
.9fe5					Assemble_tya:
.9fe5	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fe8	98					.byte $98
.9fe9					Assemble_txs:
.9fe9	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9fec	9a					.byte $9a
.9fed					Assemble_tay:
.9fed	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9ff0	a8					.byte $a8
.9ff1					Assemble_tax:
.9ff1	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9ff4	aa					.byte $aa
.9ff5					Assemble_clv:
.9ff5	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9ff8	b8					.byte $b8
.9ff9					Assemble_tsx:
.9ff9	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>9ffc	ba					.byte $ba
.9ffd					Assemble_iny:
.9ffd	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a000	c8					.byte $c8
.a001					Assemble_dex:
.a001	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a004	ca					.byte $ca
.a005					Assemble_cld:
.a005	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a008	d8					.byte $d8
.a009					Assemble_phx:
.a009	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a00c	da					.byte $da
.a00d					Assemble_stp:
.a00d	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a010	db					.byte $db
.a011					Assemble_inx:
.a011	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a014	e8					.byte $e8
.a015					Assemble_nop:
.a015	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a018	ea					.byte $ea
.a019					Assemble_sed:
.a019	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a01c	f8					.byte $f8
.a01d					Assemble_plx:
.a01d	20 f1 80	jsr $80f1		jsr	AssembleGroup4
>a020	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.a021					DecimalScalarTable:
>a021	66 66 66 66				.dword $66666666 ; 0.1
>a025	de					.byte $de
>a026	1f 85 eb 51				.dword $51eb851f ; 0.01
>a02a	db					.byte $db
>a02b	4c 37 89 41				.dword $4189374c ; 0.001
>a02f	d8					.byte $d8
>a030	ac 8b db 68				.dword $68db8bac ; 0.0001
>a034	d4					.byte $d4
>a035	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>a039	d1					.byte $d1
>a03a	83 de 1b 43				.dword $431bde83 ; 1e-06
>a03e	ce					.byte $ce
>a03f	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>a043	ca					.byte $ca
>a044	89 3b e6 55				.dword $55e63b89 ; 1e-08
>a048	c7					.byte $c7
>a049	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>a04d	c4					.byte $c4
>a04e	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>a052	c0					.byte $c0
>a053	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>a057	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.a058					SyntaxError:
.a058	a9 02		lda #$02		lda	#2
.a05a	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a05d					RangeError:
.a05d	a9 04		lda #$04		lda	#4
.a05f	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a062					TypeError:
.a062	a9 05		lda #$05		lda	#5
.a064	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a067					ArgumentError:
.a067	a9 07		lda #$07		lda	#7
.a069	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a06c					NotDoneError:
.a06c	a9 0c		lda #$0c		lda	#12
.a06e	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a071					ErrorText:
>a071	42 72 65 61 6b 00			.text	"Break",0
>a077	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a07f	72 72 6f 72 00
>a084	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a08c	20 62 79 20 7a 65 72 6f 00
>a095	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a09d	61 6e 67 65 00
>a0a2	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a0aa	6d 61 74 63 68 00
>a0b0	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a0b8	65 6d 6f 72 79 00
>a0be	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a0c6	61 72 67 75 6d 65 6e 74 00
>a0cf	53 74 6f 70 00				.text	"Stop",0
>a0d4	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a0dc	6f 6f 20 6c 6f 6e 67 00
>a0e4	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a0ec	6e 20 66 61 69 6c 65 64 00
>a0f5	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a0fd	61 74 61 00
>a101	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a109	65 6e 74 65 64 00
>a10f	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a117	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a123	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a12b	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a138	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a140	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a14d	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a155	68 6f 75 74 20 57 68 69 6c 65 00
>a160	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a168	68 6f 75 74 20 46 6f 72 00
>a171	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a179	61 63 6b 20 66 75 6c 6c 00
>a182	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a18a	75 63 74 75 72 65 00
>a191	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a199	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a1a6	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a1ae	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a1bc	41 72 72 61 79 20 73 69			.text	"Array size",0
>a1c4	7a 65 00
>a1c7	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a1cf	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a1d7	52 65 6c 65 61 73 65 20			.text "Release Alpha 5 (26-Nov-22). "
>a1df	41 6c 70 68 61 20 35 20 28 32 36 2d 4e 6f 76 2d
>a1ef	32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a1f4					RectangleCommand:
.a1f4	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a1f6	80 02		bra $a1fa			bra 	ShapeDrawCmd
.a1f8					CircleCommand:
.a1f8	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a1fa					ShapeDrawCmd:
.a1fa	20 88 a2	jsr $a288			jsr 	RunGraphicsCommand
.a1fd					ShapeDraw:
.a1fd	0d 30 06	ora $0630			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a200	4c 7c a2	jmp $a27c			jmp 	ExecuteGraphicCommand	 	; and complete
.a203					SpriteCommand:
.a203	a2 00		ldx #$00			ldx 	#0
.a205	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; get image number.
.a208	5a		phy				phy
.a209	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a20b	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a20e	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a210	b0 0d		bcs $a21f			bcs 	_SCRange
.a212	a0 ff		ldy #$ff			ldy 	#255
.a214	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a217	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a219	7a		ply				ply
.a21a	20 88 a2	jsr $a288			jsr 	RunGraphicsCommand
.a21d	80 5d		bra $a27c			bra 	ExecuteGraphicCommand
.a21f					_SCRange:
.a21f	4c 5d a0	jmp $a05d			jmp 	RangeError
.a222					ImageCommand:
.a222	a2 00		ldx #$00			ldx 	#0
.a224	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; get image number.
.a227	20 88 a2	jsr $a288			jsr 	RunGraphicsCommand
.a22a					ImageRunDraw:
.a22a	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a22c	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a22f	ad 36 06	lda $0636			lda 	gxDrawScale
.a232	0a		asl a				asl 	a
.a233	0a		asl a				asl 	a
.a234	0a		asl a				asl 	a
.a235	a8		tay				tay
.a236	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a238	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a23b	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a23e	60		rts				rts
.a23f					TextCommand:
.a23f	a2 00		ldx #$00			ldx 	#0
.a241	20 02 9e	jsr $9e02			jsr 	EvaluateString 				; get text
.a244	20 88 a2	jsr $a288			jsr 	RunGraphicsCommand
.a247					TextRunDraw:
.a247	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a249	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a24c	a0 00		ldy #$00			ldy 	#0
.a24e					_IRDLoop:
.a24e	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a251	85 37		sta $37				sta 	zTemp0+1
.a253	ad 08 04	lda $0408			lda 	NSMantissa0
.a256	85 36		sta $36				sta 	zTemp0
.a258	b1 36		lda ($36),y			lda 	(zTemp0),y
.a25a	f0 13		beq $a26f			beq 	_IRDExit
.a25c	5a		phy				phy									; save string pos
.a25d	48		pha				pha 								; save char
.a25e	ad 36 06	lda $0636			lda 	gxDrawScale 				; get scale
.a261	0a		asl a				asl 	a
.a262	0a		asl a				asl 	a
.a263	0a		asl a				asl 	a
.a264	a8		tay				tay
.a265	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a267	fa		plx				plx 								; char to draw
.a268	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a26b	7a		ply				ply 								; restore string pos
.a26c	c8		iny				iny
.a26d	90 df		bcc $a24e			bcc 	_IRDLoop 					; go back if no error.
.a26f					_IRDExit:
.a26f	60		rts				rts
.a270					PlotCommand:
.a270	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a272	20 88 a2	jsr $a288			jsr 	RunGraphicsCommand
.a275	80 05		bra $a27c			bra 	ExecuteGraphicCommand
.a277					LineCommand:
.a277	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a279	20 88 a2	jsr $a288			jsr 	RunGraphicsCommand
.a27c					ExecuteGraphicCommand:
.a27c	0d 2f 06	ora $062f			ora 	gxCommandID 				; make a full command
.a27f	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw 				; draw it and exit
.a282	b0 01		bcs $a285			bcs 	_EGCError
.a284	60		rts				rts
.a285					_EGCError:
.a285	4c 58 a0	jmp $a058			jmp 	SyntaxError
.a288					RunGraphicsCommand:
.a288	8d 2f 06	sta $062f			sta 	gxCommandID					; save TODO graphics command.
.a28b	68		pla				pla 								; pop handler address
.a28c	fa		plx				plx
.a28d	1a		inc a				inc 	a
.a28e	d0 01		bne $a291			bne 	_RGINoCarry
.a290	e8		inx				inx
.a291					_RGINoCarry:
.a291	8d 34 06	sta $0634			sta 	GXHandler
.a294	8e 35 06	stx $0635			stx 	GXHandler+1
.a297					_RGICommandLoop:
.a297	b1 30		lda ($30),y			lda 	(codePtr),y
.a299	c8		iny				iny
.a29a	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a29c	f0 53		beq $a2f1			beq 	_RGI_To
.a29e	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a2a0	f0 55		beq $a2f7			beq 	_RGI_Here
.a2a2	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a2a4	f0 3d		beq $a2e3			beq 	_RGI_Exit
.a2a6	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a2a8	f0 39		beq $a2e3			beq 	_RGI_Exit
.a2aa	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a2ac	f0 3e		beq $a2ec			beq 	_RGI_Frame
.a2ae	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a2b0	f0 33		beq $a2e5			beq 	_RGI_Solid
.a2b2	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a2b4	f0 4b		beq $a301			beq 	_RGI_By
.a2b6	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a2b8	f0 17		beq $a2d1			beq 	_RGI_Move2
.a2ba	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a2bc	f0 65		beq $a323			beq 	_RGI_Dim
.a2be	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a2c0	f0 78		beq $a33a			beq 	_RGI_Colour
.a2c2	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a2c4	f0 74		beq $a33a			beq 	_RGI_Colour
.a2c6	ae 2f 06	ldx $062f			ldx 	gxCommandID
.a2c9	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a2cb	d0 03		bne $a2d0			bne 	_RGI_Move 					; move
.a2cd	4c 64 a3	jmp $a364			jmp		_RGI_SpriteInstructions
.a2d0					_RGI_Move:
.a2d0	88		dey				dey 								; unpick get.
.a2d1					_RGI_Move2:
.a2d1	20 8a a3	jsr $a38a			jsr 	GCGetCoordinatePair 		; move to here
.a2d4	20 b1 a3	jsr $a3b1			jsr 	GCCopyPairToStore 			; save
.a2d7	5a		phy				phy
.a2d8	20 a7 a3	jsr $a3a7			jsr 	GCLoadAXY 					; load in
.a2db	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a2dd	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a2e0	7a		ply				ply
.a2e1	80 b4		bra $a297			bra 	_RGICommandLoop 			; and go round
.a2e3					_RGI_Exit:
.a2e3	88		dey				dey 								; unpick : / EOL
.a2e4	60		rts				rts
.a2e5					_RGI_Solid:
.a2e5	a9 02		lda #$02			lda 	#2
.a2e7	8d 30 06	sta $0630			sta 	gxFillSolid
.a2ea	80 ab		bra $a297			bra 	_RGICommandLoop
.a2ec					_RGI_Frame:
.a2ec	9c 30 06	stz $0630			stz 	gxFillSolid
.a2ef	80 a6		bra $a297			bra 	_RGICommandLoop
.a2f1					_RGI_To:
.a2f1	20 8a a3	jsr $a38a			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a2f4	20 b1 a3	jsr $a3b1			jsr 	GCCopyPairToStore
.a2f7					_RGI_Here:
.a2f7	5a		phy				phy
.a2f8	20 a7 a3	jsr $a3a7			jsr 	GCLoadAXY 					; load it into AXY
.a2fb	20 61 a3	jsr $a361			jsr 	_RGICallHandler 			; go do whatever it is.
.a2fe	7a		ply				ply
.a2ff	80 96		bra $a297			bra 	_RGICommandLoop 			; and go round
.a301					_RGI_By:
.a301	20 97 a3	jsr $a397			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a304	18		clc				clc
.a305	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a308	6d 31 06	adc $0631			adc 	gxxPos
.a30b	8d 31 06	sta $0631			sta 	gxXPos
.a30e	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a311	6d 32 06	adc $0632			adc 	gxxPos+1
.a314	8d 32 06	sta $0632			sta 	gxXPos+1
.a317	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a31a	18		clc				clc
.a31b	6d 33 06	adc $0633			adc 	gxYPos
.a31e	8d 33 06	sta $0633			sta 	gxYPos
.a321	80 d4		bra $a2f7			bra 	_RGI_Here
.a323					_RGI_Dim:
.a323	a2 01		ldx #$01			ldx	 	#1
.a325	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger
.a328	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a32b	c9 00		cmp #$00			cmp 	#0
.a32d	f0 2f		beq $a35e			beq 	_RGIRange
.a32f	c9 09		cmp #$09			cmp 	#8+1
.a331	b0 2b		bcs $a35e			bcs		_RGIRange
.a333	3a		dec a				dec 	a
.a334	8d 36 06	sta $0636			sta 	gxDrawScale
.a337	4c 97 a2	jmp $a297			jmp 	_RGICommandLoop
.a33a					_RGI_Colour:
.a33a	a2 01		ldx #$01			ldx 	#1 							; colour
.a33c	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger
.a33f	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a341	20 ce 9e	jsr $9ece			jsr 	NSMSetZero
.a344	b1 30		lda ($30),y			lda 	(codePtr),y
.a346	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a348	d0 04		bne $a34e			bne 	_RGICDefaultMode
.a34a	c8		iny				iny
.a34b	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger
.a34e					_RGICDefaultMode:
.a34e	5a		phy				phy
.a34f	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a351	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a354	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a357	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a35a	7a		ply				ply
.a35b	4c 97 a2	jmp $a297			jmp 	_RGICommandLoop 			; and go round
.a35e					_RGIRange:
.a35e	4c 5d a0	jmp $a05d			jmp 	RangeError
.a361					_RGICallHandler:
.a361	6c 34 06	jmp ($0634)			jmp 	(GXHandler)
.a364					_RGI_SpriteInstructions:
.a364	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a366	f0 07		beq $a36f			beq 	_RGISpriteOff
.a368	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a36a	f0 13		beq $a37f			beq 	_RGISetImage
.a36c	4c d0 a2	jmp $a2d0			jmp 	_RGI_Move
.a36f					_RGISpriteOff:
.a36f	5a		phy				phy
.a370	a0 01		ldy #$01			ldy 	#1
.a372	a2 00		ldx #$00			ldx 	#0
.a374					_RGIDoCommandLoop:
.a374	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a376	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a379	7a		ply				ply
.a37a	b0 e2		bcs $a35e			bcs 	_RGIRange
.a37c	4c 97 a2	jmp $a297			jmp 	_RGICommandLoop
.a37f					_RGISetImage:
.a37f	a2 01		ldx #$01			ldx 	#1
.a381	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger
.a384	5a		phy				phy
.a385	aa		tax				tax
.a386	a0 00		ldy #$00			ldy 	#0
.a388	80 ea		bra $a374			bra 	_RGIDoCommandLoop
.a38a					GCGetCoordinatePair:
.a38a	a2 01		ldx #$01			ldx 	#1
.a38c	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger
.a38f	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a392	e8		inx				inx
.a393	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger
.a396	60		rts				rts
.a397					GCSignedCoordinatePair:
.a397	a2 01		ldx #$01			ldx 	#1
.a399	20 3b 9e	jsr $9e3b			jsr 	Evaluate16BitIntegerSigned
.a39c	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a39f	e8		inx				inx
.a3a0	20 3b 9e	jsr $9e3b			jsr 	Evaluate16BitIntegerSigned
.a3a3	60		rts				rts
.a3a4					_GCCPRange:
.a3a4	4c 5d a0	jmp $a05d			jmp 	RangeError
.a3a7					GCLoadAXY:
.a3a7	ad 32 06	lda $0632			lda 	gxXPos+1
.a3aa	ae 31 06	ldx $0631			ldx 	gxXPos
.a3ad	ac 33 06	ldy $0633			ldy 	gxYPos
.a3b0	60		rts				rts
.a3b1					GCCopyPairToStore:
.a3b1	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a3b4	8d 31 06	sta $0631			sta 	gxXPos
.a3b7	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a3ba	8d 32 06	sta $0632			sta 	gxXPos+1
.a3bd	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a3c0	8d 33 06	sta $0633			sta 	gxYPos
.a3c3	60		rts				rts
.062f					gxCommandID:
>062f							.fill 	1
.0630					gxFillSolid:
>0630							.fill 	1
.0631					gxXPos:
>0631							.fill 	2
.0633					gxYPos:
>0633							.fill 	1
.0634					gxHandler:
>0634							.fill 	2
.0636					gxDrawScale:
>0636							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a3c4					BitmapCtrl:
.a3c4	b1 30		lda ($30),y			lda 	(codePtr),y
.a3c6	c8		iny				iny
.a3c7	a2 01		ldx #$01			ldx 	#1
.a3c9	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a3cb	f0 11		beq $a3de			beq 	BitmapSwitch
.a3cd	ca		dex				dex
.a3ce	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a3d0	f0 0c		beq $a3de			beq 	BitmapSwitch
.a3d2	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; get the colour
.a3d5	5a		phy				phy
.a3d6	aa		tax				tax
.a3d7	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a3d9	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a3dc	7a		ply				ply
.a3dd	60		rts				rts
.a3de					BitmapSwitch:
.a3de	5a		phy				phy
.a3df	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a3e1	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a3e3	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a3e6	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a3e8	a0 00		ldy #$00			ldy 	#0
.a3ea	a2 ff		ldx #$ff			ldx 	#$FF
.a3ec	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a3ef	9c 30 06	stz $0630			stz 	gxFillSolid
.a3f2	9c 31 06	stz $0631			stz 	gxXPos
.a3f5	9c 32 06	stz $0632			stz 	gxXPos+1
.a3f8	9c 33 06	stz $0633			stz 	gxYPos
.a3fb	9c 36 06	stz $0636			stz 	gxDrawScale
.a3fe	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a400	a2 00		ldx #$00			ldx 	#0
.a402	a0 00		ldy #$00			ldy 	#0
.a404	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a407	7a		ply				ply
.a408	60		rts				rts
.a409					SpritesCtrl:
.a409	b1 30		lda ($30),y			lda 	(codePtr),y
.a40b	c8		iny				iny
.a40c	a2 01		ldx #$01			ldx 	#1
.a40e	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a410	f0 08		beq $a41a			beq 	SpriteSwitch
.a412	ca		dex				dex
.a413	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a415	f0 03		beq $a41a			beq 	SpriteSwitch
.a417	4c 58 a0	jmp $a058			jmp 	SyntaxError
.a41a					SpriteSwitch:
.a41a	5a		phy				phy
.a41b	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a41d	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a41f	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a422	7a		ply				ply
.a423	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a424					GfxCommand:
.a424	a2 00		ldx #$00			ldx 	#0
.a426	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; command
.a429	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a42c	e8		inx				inx
.a42d	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger 		; X
.a430	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a433	e8		inx				inx
.a434	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; Y
.a437	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a43a	4a		lsr a				lsr 	a
.a43b	d0 16		bne $a453			bne 	_GfxError
.a43d	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a440	b0 11		bcs $a453			bcs 	_GfxError 					; bit 7 should have been zero
.a442	5a		phy				phy 								; save pos
.a443	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a446	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a449	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a44c	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw
.a44f	b0 02		bcs $a453			bcs 	_GfxError
.a451	7a		ply				ply 								; restore pos and exit.
.a452	60		rts				rts
.a453					_GfxError:
.a453	4c 5d a0	jmp $a05d			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a456					UnaryHit:
.a456	fa		plx				plx
.a457	a9 36		lda #$36			lda 	#zTemp0
.a459	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a45c	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a45f	e8		inx				inx
.a460	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a463	20 f2 8d	jsr $8df2			jsr		CheckRightBracket
.a466	ca		dex				dex 								; fix back up again.
.a467	da		phx				phx 								; save X/Y
.a468	5a		phy				phy
.a469	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a46c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a46f	aa		tax				tax
.a470	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a472	20 8d ab	jsr $ab8d			jsr 	GXGraphicDraw 				; calculate result
.a475	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a476	7a		ply				ply 								; restore XY
.a477	fa		plx				plx
.a478	20 d0 9e	jsr $9ed0			jsr 	NSMSetByte 					; return the hit result
.a47b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a47c					PaletteCommand:
.a47c	a2 00		ldx #$00			ldx 	#0
.a47e	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; colour
.a481	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a484	e8		inx				inx
.a485	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger 		; r
.a488	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a48b	e8		inx				inx
.a48c	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; g
.a48f	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a492	e8		inx				inx
.a493	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; b
.a496	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a499	85 36		sta $36				sta 	zTemp0
.a49b	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a49d	85 37		sta $37				sta 	zTemp0+1
.a49f	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a4a1	26 37		rol $37				rol	 	zTemp0+1
.a4a3	06 36		asl $36				asl 	zTemp0
.a4a5	26 37		rol $37				rol	 	zTemp0+1
.a4a7	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a4a9	85 01		sta $01				sta 	1
.a4ab	5a		phy				phy
.a4ac	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a4af	92 36		sta ($36)			sta 	(zTemp0)
.a4b1	a0 01		ldy #$01			ldy 	#1
.a4b3	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a4b6	91 36		sta ($36),y			sta 	(zTemp0),y
.a4b8	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a4bb	c8		iny				iny
.a4bc	91 36		sta ($36),y			sta 	(zTemp0),y
.a4be	7a		ply				ply
.a4bf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a4c0					UnaryEvent:
.a4c0	fa		plx				plx
.a4c1	20 7a a5	jsr $a57a			jsr 	TimerToStackX 				; timer in +0
.a4c4	e8		inx				inx  								; put reference into +1
.a4c5	20 94 98	jsr $9894			jsr 	EvaluateTerm
.a4c8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a4cb	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a4cd	d0 57		bne $a526			bne 	_UEType
.a4cf	e8		inx				inx 								; put the step in +2
.a4d0	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a4d3	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger
.a4d6	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.a4d9	ca		dex				dex
.a4da	ca		dex				dex
.a4db	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a4de	85 36		sta $36				sta 	zTemp0
.a4e0	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a4e3	85 37		sta $37				sta 	zTemp0+1
.a4e5	5a		phy				phy
.a4e6	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a4e8	b1 36		lda ($36),y			lda 	(zTemp0),y
.a4ea	30 36		bmi $a522			bmi 	_UEFalse 					; exit if signed.
.a4ec	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a4ee	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a4f1	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a4f3	c8		iny				iny
.a4f4	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a4f7	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4f9	c8		iny				iny
.a4fa	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a4fd	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4ff	90 21		bcc $a522			bcc 	_UEFalse 					; no, return FALSE.
.a501	18		clc				clc
.a502	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a504	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a507	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a50a	91 36		sta ($36),y			sta 	(zTemp0),y
.a50c	c8		iny				iny
.a50d	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a510	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a513	91 36		sta ($36),y			sta 	(zTemp0),y
.a515	c8		iny				iny
.a516	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a519	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a51c	91 36		sta ($36),y			sta 	(zTemp0),y
.a51e	7a		ply				ply
.a51f	4c 78 8e	jmp $8e78			jmp 	ReturnTrue
.a522					_UEFalse:
.a522	7a		ply				ply 								; restore Y
.a523	4c 84 8e	jmp $8e84			jmp 	ReturnFalse 				; and return False
.a526					_UEType:
.a526	4c 62 a0	jmp $a062			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a529					UnaryJoyX:
.a529	18		clc				clc
.a52a	80 01		bra $a52d			bra 	JoyMain
.a52c					UnaryJoyY:
.a52c	38		sec				sec
.a52d					JoyMain:
.a52d	fa		plx				plx 								; get pos
.a52e	08		php				php 								; save carry (set for Y)
.a52f	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a532	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.a535	20 46 ab	jsr $ab46			jsr 	EXTReadController 			; read the controller.
.a538	28		plp				plp
.a539	90 02		bcc $a53d			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a53b	4a		lsr a				lsr 	a
.a53c	4a		lsr a				lsr 	a
.a53d					_JMNoShift:
.a53d	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a53e	b0 0a		bcs $a54a			bcs 	_JMIsRight
.a540	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a541	b0 04		bcs $a547			bcs 	_JMIsLeft
.a543	20 ce 9e	jsr $9ece			jsr 	NSMSetZero 					; zero result
.a546	60		rts				rts
.a547					_JMIsLeft:
.a547	4c 78 8e	jmp $8e78			jmp 	ReturnTrue
.a54a					_JMIsRight:
.a54a	a9 01		lda #$01			lda 	#1
.a54c	20 d0 9e	jsr $9ed0			jsr 	NSMSetByte
.a54f	60		rts				rts
.a550					UnaryJoyB:
.a550	fa		plx				plx 								; get pos
.a551	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a554	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.a557	20 46 ab	jsr $ab46			jsr 	EXTReadController 			; read the controller.
.a55a	4a		lsr a				lsr 	a
.a55b	4a		lsr a				lsr 	a
.a55c	4a		lsr a				lsr 	a
.a55d	4a		lsr a				lsr 	a
.a55e	29 01		and #$01			and 	#1
.a560	20 d0 9e	jsr $9ed0			jsr 	NSMSetByte
.a563	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a564					LoadCommand:
.a564	20 5b 89	jsr $895b			jsr 	NewProgram
.a567	20 db 82	jsr $82db			jsr 	BackLoadProgram
.a56a	4c 6b 83	jmp $836b			jmp 	WarmStart
.a56d					GoCommand:
.a56d	20 5b 89	jsr $895b			jsr 	NewProgram
.a570	20 db 82	jsr $82db			jsr 	BackLoadProgram
.a573	4c 9a 8a	jmp $8a9a			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a576					UnaryTimer:
.a576	fa		plx				plx
.a577	20 f2 8d	jsr $8df2			jsr 	CheckRightBracket
.a57a					TimerToStackX:
.a57a	20 ce 9e	jsr $9ece			jsr 	NSMSetZero 					; zero result
.a57d	64 01		stz $01				stz 	1 							; access I/O
.a57f	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a582	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a585	ad 5a d6	lda $d65a			lda 	$D65A
.a588	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a58b	ad 5b d6	lda $d65b			lda 	$D65B
.a58e	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a591	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a592					MemoryDeleteLine:
.a592	20 b1 a5	jsr $a5b1			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a595	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a597	a8		tay				tay
.a598					_MDDLLoop:
.a598	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a59a	92 30		sta ($30)			sta 	(codePtr)
.a59c	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a59e	c5 3a		cmp $3a				cmp 	zTemp2
.a5a0	d0 07		bne $a5a9			bne 	_MDLDLNext
.a5a2	a5 31		lda $31				lda 	codePtr+1
.a5a4	c5 3b		cmp $3b				cmp 	zTemp2+1
.a5a6	d0 01		bne $a5a9			bne 	_MDLDLNext
.a5a8					_MDDLExit:
.a5a8	60		rts				rts
.a5a9					_MDLDLNext:
.a5a9	e6 30		inc $30				inc 	codePtr						; next byte
.a5ab	d0 eb		bne $a598			bne 	_MDDLLoop
.a5ad	e6 31		inc $31				inc 	codePtr+1
.a5af	80 e7		bra $a598			bra 	_MDDLLoop
.a5b1					IMemoryFindEnd:
.a5b1	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5b3	85 3a		sta $3a				sta 	0+zTemp2
.a5b5	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5b7	85 3b		sta $3b				sta 	1+zTemp2
.a5b9					_MDLFELoop:
.a5b9	b2 3a		lda ($3a)			lda 	(zTemp2)
.a5bb	f0 0b		beq $a5c8			beq 	_MDLFEExit
.a5bd	18		clc				clc
.a5be	65 3a		adc $3a				adc 	zTemp2
.a5c0	85 3a		sta $3a				sta 	zTemp2
.a5c2	90 f5		bcc $a5b9			bcc 	_MDLFELoop
.a5c4	e6 3b		inc $3b				inc 	zTemp2+1
.a5c6	80 f1		bra $a5b9			bra 	_MDLFELoop
.a5c8					_MDLFEExit:
.a5c8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a5c9					MemoryInsertLine:
.a5c9	08		php				php
.a5ca	20 b1 a5	jsr $a5b1			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a5cd	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a5cf	1a		inc a				inc 	a
.a5d0	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a5d2	b0 36		bcs $a60a			bcs 	_MDLIError
.a5d4	28		plp				plp
.a5d5	90 08		bcc $a5df			bcc 	_MDLIFound
.a5d7	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a5d9	85 30		sta $30				sta 	codePtr
.a5db	a5 3b		lda $3b				lda 	zTemp2+1
.a5dd	85 31		sta $31				sta 	codePtr+1
.a5df					_MDLIFound:
.a5df	ad a9 04	lda $04a9			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a5e2	a8		tay				tay
.a5e3					_MDLIInsert:
.a5e3	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a5e5	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a5e7	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a5e9	c5 3a		cmp $3a				cmp 	zTemp2
.a5eb	d0 06		bne $a5f3			bne 	_MDLINext
.a5ed	a5 31		lda $31				lda 	codePtr+1
.a5ef	c5 3b		cmp $3b				cmp 	zTemp2+1
.a5f1	f0 0a		beq $a5fd			beq 	_MDLIHaveSpace
.a5f3					_MDLINext:
.a5f3	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a5f5	d0 02		bne $a5f9			bne 	_MDLINoBorrow
.a5f7	c6 3b		dec $3b				dec 	zTemp2+1
.a5f9					_MDLINoBorrow:
.a5f9	c6 3a		dec $3a				dec 	zTemp2
.a5fb	80 e6		bra $a5e3			bra 	_MDLIInsert
.a5fd					_MDLIHaveSpace:
.a5fd	ac a9 04	ldy $04a9			ldy 	tokenOffset 				; bytes to copy
.a600	88		dey				dey 								; from offset-1 to 0
.a601					_MDLICopy:
.a601	b9 a9 04	lda $04a9,y			lda 	tokenOffset,y
.a604	91 30		sta ($30),y			sta 	(codePtr),y
.a606	88		dey				dey
.a607	10 f8		bpl $a601			bpl 	_MDLICopy
.a609	60		rts				rts
.a60a					_MDLIError:
.a60a	a9 06		lda #$06		lda	#6
.a60c	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a60f					MDLAppendLine:
.a60f	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a611	85 36		sta $36				sta 	zTemp0
.a613	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a615	85 38		sta $38				sta 	0+zTemp1
.a617	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a619	85 39		sta $39				sta 	1+zTemp1
.a61b	b2 38		lda ($38)			lda 	(zTemp1)
.a61d	d0 0a		bne $a629			bne 	_MDLANoInitialise
.a61f	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a621	8d 37 06	sta $0637			sta 	0+AppendPointer
.a624	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a626	8d 38 06	sta $0638			sta 	1+AppendPointer
.a629					_MDLANoInitialise:
.a629	18		clc				clc
.a62a	ad 37 06	lda $0637			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a62d	85 38		sta $38				sta 	zTemp1
.a62f	72 36		adc ($36)			adc 	(zTemp0)
.a631	8d 37 06	sta $0637			sta 	AppendPointer
.a634	ad 38 06	lda $0638			lda 	AppendPointer+1
.a637	85 39		sta $39				sta 	zTemp1+1
.a639	69 00		adc #$00			adc 	#0
.a63b	8d 38 06	sta $0638			sta 	AppendPointer+1
.a63e	a0 00		ldy #$00			ldy 	#0
.a640					_MDLACopy:
.a640	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a642	91 38		sta ($38),y			sta 	(zTemp1),y
.a644	c8		iny				iny
.a645	98		tya				tya
.a646	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a648	d0 f6		bne $a640			bne 	_MDLACopy
.a64a	a9 00		lda #$00			lda 	#0 							; end of program.
.a64c	91 38		sta ($38),y			sta 	(zTemp1),y
.a64e	60		rts				rts
.0637					AppendPointer:
>0637							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a64f					MemoryNew:
.a64f	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a651	85 30		sta $30				sta 	codePtr
.a653	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a655	85 31		sta $31				sta 	codePtr+1
.a657	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a659	92 30		sta ($30)			sta 	(codePtr)
.a65b	60		rts				rts
.a65c					MemoryInline:
.a65c	98		tya				tya 								; put address into stack,x
.a65d	18		clc				clc  								; get the offset, add codePtr
.a65e	65 30		adc $30				adc 	codePtr
.a660	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a663	a5 31		lda $31				lda 	codePtr+1
.a665	69 00		adc #$00			adc 	#0
.a667	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a66a	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a66d	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a670	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a671					MemorySearch:
.a671	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a673	86 37		stx $37				stx 	zTemp0+1
.a675	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a677	85 30		sta $30				sta 	codePtr
.a679	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a67b	85 31		sta $31				sta 	codePtr+1
.a67d					_MTAXLoop:
.a67d	b2 30		lda ($30)			lda 	(codePtr)
.a67f	18		clc				clc
.a680	f0 21		beq $a6a3			beq 	_MTAXExit 					; reached end, exit with CC.
.a682	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a684	b1 30		lda ($30),y			lda 	(codePtr),y
.a686	38		sec				sec
.a687	e5 36		sbc $36				sbc 	zTemp0
.a689	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a68b	c8		iny				iny 								; do the MSB
.a68c	b1 30		lda ($30),y			lda 	(codePtr),y
.a68e	e5 37		sbc $37				sbc 	zTemp0+1
.a690	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a692	f0 0f		beq $a6a3			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a694	b0 0d		bcs $a6a3			bcs 	_MTAXExit 					; current < required exit
.a696	18		clc				clc
.a697	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a699	65 30		adc $30				adc 	codePtr
.a69b	85 30		sta $30				sta 	codePtr
.a69d	90 02		bcc $a6a1			bcc 	_CREExit
.a69f	e6 31		inc $31				inc 	codePtr+1 					; carry
.a6a1					_CREExit:
.a6a1	80 da		bra $a67d			bra 	_MTAXLoop
.a6a3					_MTAXExit:
.a6a3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a6a4					UnaryPlaying:
.a6a4	fa		plx				plx
.a6a5	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; get channel #
.a6a8	48		pha				pha
.a6a9	20 f2 8d	jsr $8df2			jsr		CheckRightBracket
.a6ac	68		pla				pla
.a6ad	c9 04		cmp #$04			cmp 	#4
.a6af	b0 0c		bcs $a6bd			bcs 	_UPNotPlaying
.a6b1	09 20		ora #$20			ora 	#$20 						; query playing ?
.a6b3	20 1b ba	jsr $ba1b			jsr 	SNDCommand
.a6b6	c9 00		cmp #$00			cmp 	#0
.a6b8	f0 03		beq $a6bd			beq 	_UPNotPlaying
.a6ba	4c 78 8e	jmp $8e78			jmp 	ReturnTrue
.a6bd					_UPNotPlaying:
.a6bd	4c 84 8e	jmp $8e84			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a6c0					SoundCommand:
.a6c0	b1 30		lda ($30),y			lda 	(codePtr),y
.a6c2	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a6c4	d0 09		bne $a6cf			bne 	_SNDMain
.a6c6	c8		iny				iny 								; skip OFF
.a6c7	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a6c9	5a		phy				phy
.a6ca	20 1b ba	jsr $ba1b			jsr 	SNDCommand
.a6cd	7a		ply				ply
.a6ce	60		rts				rts
.a6cf					_SNDMain:
.a6cf	a2 00		ldx #$00			ldx 	#0
.a6d1	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; channel
.a6d4	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a6d6	b0 50		bcs $a728			bcs 	_SndError
.a6d8	e8		inx				inx 								; do the rest in slot 1.
.a6d9	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a6dc	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitInteger 		; Pitch
.a6df	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a6e2	c9 10		cmp #$10			cmp 	#16
.a6e4	b0 42		bcs $a728			bcs 	_SndError
.a6e6	8d 3a 06	sta $063a			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a6e9	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a6ec	8d 39 06	sta $0639			sta 	SoundCommandBlock
.a6ef	20 fa 8d	jsr $8dfa			jsr 	CheckComma
.a6f2	20 4f 9e	jsr $9e4f			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a6f5	8d 3c 06	sta $063c			sta 	SoundCommandBlock+3
.a6f8	a9 0f		lda #$0f			lda 	#15
.a6fa	8d 3b 06	sta $063b			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a6fd	9c 3d 06	stz $063d			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a700	9c 3e 06	stz $063e			stz 	SoundCommandBlock+5
.a703	b1 30		lda ($30),y			lda 	(codePtr),y
.a705	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a707	d0 10		bne $a719			bne 	_SNDPlay
.a709	c8		iny				iny
.a70a	20 3b 9e	jsr $9e3b			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a70d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a710	8d 3d 06	sta $063d			sta 	SoundCommandBlock+4
.a713	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a716	8d 3e 06	sta $063e			sta 	SoundCommandBlock+5
.a719					_SNDPlay:
.a719	5a		phy				phy
.a71a	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a71d	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a71f	a2 39		ldx #$39			ldx 	#(SoundCommandBlock & $FF)
.a721	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a723	20 1b ba	jsr $ba1b			jsr 	SNDCommand
.a726	7a		ply				ply
.a727	60		rts				rts
.a728					_SndError:
.a728	4c 5d a0	jmp $a05d			jmp 	RangeError
.0639					SoundCommandBlock:
>0639							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a72b					StackPushByte:
.a72b	48		pha				pha 								; save byte
.a72c	a5 34		lda $34				lda 	BasicStack
.a72e	d0 09		bne $a739			bne 	_SPBNoBorrow
.a730	c6 35		dec $35				dec 	BasicStack+1
.a732	48		pha				pha
.a733	a5 35		lda $35				lda 	BasicStack+1
.a735	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a737	90 06		bcc $a73f			bcc 	_SPBMemory
.a739					_SPBNoBorrow:
.a739	c6 34		dec $34				dec 	BasicStack
.a73b	68		pla				pla 								; get back and write
.a73c	92 34		sta ($34)			sta 	(BasicStack)
.a73e	60		rts				rts
.a73f					_SPBMemory:
.a73f	a9 12		lda #$12		lda	#18
.a741	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a744					StackPopByte:
.a744	b2 34		lda ($34)			lda 	(BasicStack)
.a746	e6 34		inc $34				inc 	BasicStack
.a748	d0 02		bne $a74c			bne 	_SPBNoCarry
.a74a	e6 35		inc $35				inc 	BasicStack+1
.a74c					_SPBNoCarry:
.a74c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a74d					StackOpen:
.a74d	48		pha				pha 								; save frame byte
.a74e	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a750	0a		asl a				asl 	a 							; claim twice this for storage
.a751	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a753	38		sec				sec 								; so basically subtracting from
.a754	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a756	85 34		sta $34				sta 	basicStack
.a758	b0 08		bcs $a762			bcs 	_SONoBorrow
.a75a	c6 35		dec $35				dec 	basicStack+1
.a75c	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a75e	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a760	90 04		bcc $a766			bcc 	_SOMemory
.a762					_SONoBorrow:
.a762	68		pla				pla 								; get marker back and write at TOS
.a763	92 34		sta ($34)			sta 	(basicStack)
.a765	60		rts				rts
.a766					_SOMemory:
.a766	a9 12		lda #$12		lda	#18
.a768	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a76b					StackClose:
.a76b	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a76d	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a76f	0a		asl a				asl 	a 							; claim twice this.
.a770	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a772	85 34		sta $34				sta 	basicStack
.a774	90 02		bcc $a778			bcc 	_SCExit
.a776	e6 35		inc $35				inc 	basicStack+1
.a778					_SCExit:
.a778	60		rts				rts
.a779					StackCheckFrame:
.a779	48		pha				pha
.a77a					_StackRemoveLocals:
.a77a	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a77c	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a77e	b0 05		bcs $a785			bcs 	_SCNoLocal
.a780	20 0a 89	jsr $890a			jsr 	LocalPopValue
.a783	80 f5		bra $a77a			bra 	_StackRemoveLocals
.a785					_SCNoLocal:
.a785	68		pla				pla
.a786	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a788	29 f0		and #$f0			and 	#$F0 						; check type bits
.a78a	d0 01		bne $a78d			bne 	_SCFError 					; different, we have structures mixed up
.a78c	60		rts				rts
.a78d					_SCFError:
.a78d	8a		txa				txa 								; report error X
.a78e	4c 0b 8e	jmp $8e0b			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a791					STKSaveCodePosition:
.a791	5a		phy				phy
.a792	98		tya				tya 								; save Y
.a793	a0 05		ldy #$05			ldy 	#5
.a795	91 34		sta ($34),y			sta 	(basicStack),y
.a797	88		dey				dey 								; save Code Pointer
.a798					_STKSaveLoop:
.a798	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a79b	91 34		sta ($34),y			sta 	(basicStack),y
.a79d	88		dey				dey
.a79e	d0 f8		bne $a798			bne 	_STKSaveLoop
.a7a0	7a		ply				ply
.a7a1	60		rts				rts
.a7a2					STKLoadCodePosition:
.a7a2	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a7a4					_STKLoadLoop:
.a7a4	b1 34		lda ($34),y			lda 	(basicStack),y
.a7a6	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a7a9	c8		iny				iny
.a7aa	c0 05		cpy #$05			cpy 	#5
.a7ac	d0 f6		bne $a7a4			bne 	_STKLoadLoop
.a7ae	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a7b0	a8		tay				tay
.a7b1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a7b2					StackReset:
.a7b2	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a7b4	85 34		sta $34				sta 	0+basicStack
.a7b6	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a7b8	85 35		sta $35				sta 	1+basicStack
.a7ba	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a7bc	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a7be	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a7bf					StringConcrete:
.a7bf	5a		phy				phy 								; save position on stack
.a7c0	20 97 9a	jsr $9a97			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7c3	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a7c6	85 38		sta $38				sta 	zTemp1
.a7c8	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a7cb	85 39		sta $39				sta 	zTemp1+1
.a7cd	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a7cf					_SALength:
.a7cf	c8		iny				iny
.a7d0	b1 38		lda ($38),y			lda 	(zTemp1),y
.a7d2	d0 fb		bne $a7cf			bne 	_SALength
.a7d4	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a7d6	b0 3f		bcs $a817			bcs 	_SALengthError
.a7d8	98		tya				tya 				 				; length of the new string
.a7d9	18		clc				clc
.a7da	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a7dc	90 02		bcc $a7e0			bcc 	_SAHaveLength
.a7de	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a7e0					_SAHaveLength:
.a7e0	48		pha				pha 								; save length.
.a7e1	38		sec				sec
.a7e2	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a7e4	6d 8e 04	adc $048e			adc 	StringMemory
.a7e7	8d 8e 04	sta $048e			sta 	StringMemory
.a7ea	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a7ec	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a7ef	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a7f1	6d 8f 04	adc $048f			adc 	StringMemory+1
.a7f4	8d 8f 04	sta $048f			sta 	StringMemory+1
.a7f7	85 3b		sta $3b				sta 	zTemp2+1
.a7f9	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a7fc	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a7fd	38		sec				sec
.a7fe	e9 03		sbc #$03			sbc 	#3
.a800	92 3a		sta ($3a)			sta 	(zTemp2)
.a802	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a804	a0 01		ldy #$01			ldy 	#1
.a806	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a808					_SACopyNewString:
.a808	a0 00		ldy #$00			ldy 	#0
.a80a					_SACopyNSLoop:
.a80a	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a80c	c8		iny				iny 								; write two on in string storage
.a80d	c8		iny				iny
.a80e	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a810	88		dey				dey 								; this makes it one one.
.a811	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a813	d0 f5		bne $a80a			bne 	_SACopyNSLoop
.a815	7a		ply				ply
.a816	60		rts				rts
.a817					_SALengthError:
.a817	a9 09		lda #$09		lda	#9
.a819	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a81c					StringSystemInitialise:
.a81c	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a81e	8d 8e 04	sta $048e			sta 	0+StringMemory
.a821	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a823	8d 8f 04	sta $048f			sta 	1+StringMemory
.a826	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a829	60		rts				rts
.a82a					StringSpaceInitialise:
.a82a	20 97 9a	jsr $9a97			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a82d	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a82f	8d 90 04	sta $0490			sta 	StringInitialised
.a832	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a835	8d 91 04	sta $0491			sta 	StringTempPointer
.a838	ad 8f 04	lda $048f			lda 	StringMemory+1
.a83b	3a		dec a				dec 	a
.a83c	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a83f	60		rts				rts
.a840					StringTempAllocate:
.a840	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a842	b0 35		bcs $a879			bcs 	_STALength
.a844	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a847	30 05		bmi $a84e			bmi 	_STAAllocate
.a849	48		pha				pha 								; save value to subtract.
.a84a	20 2a a8	jsr $a82a			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a84d	68		pla				pla 								; restore it
.a84e					_STAAllocate:
.a84e	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a850	18		clc				clc  								; deliberate allows one more
.a851	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a854	8d 91 04	sta $0491			sta 	StringTempPointer
.a857	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a85a	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a85c	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a85f	69 ff		adc #$ff			adc 	#$FF
.a861	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a864	85 3d		sta $3d				sta 	zsTemp+1
.a866	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a869	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a86c	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a86f	a9 10		lda #$10			lda 	#NSTString
.a871	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a874	a9 00		lda #$00			lda 	#0 							; clear the target string
.a876	92 3c		sta ($3c)			sta 	(zsTemp)
.a878	60		rts				rts
.a879					_STALength:
.a879	a9 09		lda #$09		lda	#9
.a87b	4c 0b 8e	jmp $8e0b		jmp	ErrorHandler
.a87e					StringTempWrite:
.a87e	48		pha				pha
.a87f	92 3c		sta ($3c)			sta 	(zsTemp)
.a881	e6 3c		inc $3c				inc 	zsTemp
.a883	d0 02		bne $a887			bne 	_STWNoCarry
.a885	e6 3d		inc $3d				inc 	zsTemp+1
.a887					_STWNoCarry:
.a887	a9 00		lda #$00			lda 	#0
.a889	92 3c		sta ($3c)			sta 	(zsTemp)
.a88b	68		pla				pla
.a88c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a88d					EXTPrintCharacter:
.a88d	48		pha				pha
.a88e	da		phx				phx
.a88f	5a		phy				phy
.a890	a6 01		ldx $01				ldx 	1
.a892	da		phx				phx
.a893	ac 40 06	ldy $0640			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a896	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a898	30 48		bmi $a8e2			bmi 	_EXPCColour
.a89a	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a89c	90 4d		bcc $a8eb			bcc 	_EXPCControl
.a89e	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a8a0	86 01		stx $01				stx 	1
.a8a2	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8a4	e6 01		inc $01				inc 	1 							; select colour memory
.a8a6	ad 41 06	lda $0641			lda 	EXTTextColour
.a8a9	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8ab	c8		iny				iny 								; advance horizontal position
.a8ac	8c 40 06	sty $0640			sty 	EXTColumn
.a8af	cc 42 06	cpy $0642			cpy 	EXTScreenWidth 				; reached RHS ?
.a8b2	90 66		bcc $a91a			bcc 	_EXPCExit 					; no, then exit.
.a8b4					_EXPCCRLF:
.a8b4	ee 3f 06	inc $063f			inc 	EXTRow  					; bump row
.a8b7	9c 40 06	stz $0640			stz 	EXTColumn 					; back to column 0
.a8ba	ad 3f 06	lda $063f			lda 	EXTRow 						; check if reached the bottom ?
.a8bd	cd 43 06	cmp $0643			cmp 	EXTScreenHeight 			; if so, then scroll.
.a8c0	f0 18		beq $a8da			beq 	_EXPCScroll
.a8c2	18		clc				clc 								; add width to address.
.a8c3	a5 40		lda $40				lda 	EXTAddress
.a8c5	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a8c8	85 40		sta $40				sta 	EXTAddress
.a8ca	90 4e		bcc $a91a			bcc 	_EXPCExit
.a8cc	e6 41		inc $41				inc 	EXTAddress+1
.a8ce	80 4a		bra $a91a			bra 	_EXPCExit
.a8d0					_EXPCLeft:
.a8d0	ce 40 06	dec $0640			dec 	EXTColumn
.a8d3	10 45		bpl $a91a			bpl 	_EXPCExit
.a8d5					_EXPCBegin:
.a8d5	9c 40 06	stz $0640			stz 	EXTColumn
.a8d8	80 40		bra $a91a			bra 	_EXPCExit
.a8da					_EXPCScroll:
.a8da	ce 3f 06	dec $063f			dec 	EXTRow 						; the height-1 th line.
.a8dd	20 a7 a9	jsr $a9a7			jsr 	EXTScreenScroll 			; scroll the screen
.a8e0	80 38		bra $a91a			bra 	_EXPCExit
.a8e2					_EXPCColour:
.a8e2	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a8e4	b0 34		bcs $a91a			bcs 	_EXPCExit
.a8e6	20 87 a9	jsr $a987			jsr 	_EXPCHandleColour
.a8e9	80 2f		bra $a91a			bra 	_EXPCExit
.a8eb					_EXPCControl:
.a8eb	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a8ed	b0 2b		bcs $a91a			bcs 	_EXPCExit
.a8ef	0a		asl a				asl 	a 							; double into X
.a8f0	aa		tax				tax
.a8f1	7c 65 a9	jmp ($a965,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a8f4					_EXPCUp:
.a8f4	ad 3f 06	lda $063f			lda 	EXTRow 						; already at top ?
.a8f7	f0 21		beq $a91a			beq 	_EXPCExit
.a8f9	ce 3f 06	dec $063f			dec 	EXTRow 						; up one in position/address
.a8fc	38		sec				sec
.a8fd	a5 40		lda $40				lda 	EXTAddress
.a8ff	ed 42 06	sbc $0642			sbc 	EXTScreenWidth
.a902	85 40		sta $40				sta 	EXTAddress
.a904	b0 14		bcs $a91a			bcs 	_EXPCExit
.a906	c6 41		dec $41				dec 	EXTAddress+1
.a908	80 10		bra $a91a			bra 	_EXPCExit
.a90a					_EXPCRight:
.a90a	c8		iny				iny
.a90b	8c 40 06	sty $0640			sty 	EXTColumn
.a90e	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.a911	d0 07		bne $a91a			bne 	_EXPCExit
.a913					_EXPCEnd:
.a913	ad 42 06	lda $0642			lda 	EXTScreenWidth
.a916	3a		dec a				dec 	a
.a917	8d 40 06	sta $0640			sta 	EXTColumn
.a91a					_EXPCExit:
.a91a	20 fc a9	jsr $a9fc			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a91d	68		pla				pla
.a91e	85 01		sta $01				sta 	1
.a920	7a		ply				ply
.a921	fa		plx				plx
.a922	68		pla				pla
.a923	60		rts				rts
.a924					_EXPCClearScreen:
.a924	20 b9 a9	jsr $a9b9			jsr		EXTClearScreenCode
.a927	80 f1		bra $a91a			bra 	_EXPCExit
.a929					_EXPCDown:
.a929	ad 43 06	lda $0643			lda 	EXTScreenHeight 			; at the bottom
.a92c	3a		dec a				dec 	a
.a92d	cd 3f 06	cmp $063f			cmp 	EXTRow
.a930	f0 e8		beq $a91a			beq 	_EXPCExit
.a932	ee 3f 06	inc $063f			inc 	EXTRow 						; down one in position/address
.a935	18		clc				clc
.a936	a5 40		lda $40				lda 	EXTAddress
.a938	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a93b	85 40		sta $40				sta 	EXTAddress
.a93d	90 db		bcc $a91a			bcc 	_EXPCExit
.a93f	e6 41		inc $41				inc 	EXTAddress+1
.a941	80 d7		bra $a91a			bra 	_EXPCExit
.a943					_EXPCTab:
.a943	ad 40 06	lda $0640			lda 	EXTColumn 					; next tab stop
.a946	29 f8		and #$f8			and 	#$F8
.a948	18		clc				clc
.a949	69 08		adc #$08			adc 	#8
.a94b	8d 40 06	sta $0640			sta 	EXTColumn
.a94e	cd 42 06	cmp $0642			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a951	90 c7		bcc $a91a			bcc 	_EXPCExit
.a953	80 be		bra $a913			bra 	_EXPCEnd
.a955					_EXPCBackSpace:
.a955	88		dey				dey
.a956	30 c2		bmi $a91a			bmi 	_EXPCExit
.a958	ce 40 06	dec $0640			dec 	EXTColumn
.a95b	a9 02		lda #$02			lda 	#2
.a95d	85 01		sta $01				sta 	1
.a95f	a9 20		lda #$20			lda 	#32
.a961	91 40		sta ($40),y			sta 	(EXTAddress),y
.a963	80 b5		bra $a91a			bra 	_EXPCExit
.a965					_EXPCActionTable:
>a965	1a a9						.word 	_EXPCExit 					; 00
>a967	d5 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a969	d0 a8						.word 	_EXPCLeft 					; 02 B Left
>a96b	1a a9						.word 	_EXPCExit 					; 03 <Break>
>a96d	1a a9						.word 	_EXPCExit 					; 04
>a96f	13 a9						.word 	_EXPCEnd 					; 05 E End of Line
>a971	0a a9						.word 	_EXPCRight 					; 06 F Right
>a973	1a a9						.word 	_EXPCExit 					; 07
>a975	55 a9						.word 	_EXPCBackspace 				; 08 H Backspace
>a977	43 a9						.word 	_EXPCTab 					; 09 I Tab
>a979	1a a9						.word 	_EXPCExit 					; 0A
>a97b	1a a9						.word 	_EXPCExit 					; 0B
>a97d	24 a9						.word 	_EXPCClearScreen			; 0C L CLS
>a97f	b4 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a981	29 a9						.word 	_EXPCDown 					; 0E N Down
>a983	1a a9						.word 	_EXPCExit 					; 0F
>a985	f4 a8						.word 	_EXPCUp 					; 10 P Up
.a987					_EXPCHandleColour
.a987	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a989	b0 16		bcs $a9a1			bcs 	_EXPCBackground
.a98b	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a98c	0a		asl a				asl 	a
.a98d	0a		asl a				asl 	a
.a98e	0a		asl a				asl 	a
.a98f	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a991					_EXPCUpdate:
.a991	48		pha				pha 								; save new colour
.a992	8a		txa				txa 								; get mask
.a993	2d 41 06	and $0641			and 	EXTTextColour 				; mask out old.
.a996	8d 41 06	sta $0641			sta 	EXTTextColour
.a999	68		pla				pla 								; or in new colour
.a99a	0d 41 06	ora $0641			ora 	EXTTextColour
.a99d	8d 41 06	sta $0641			sta 	EXTTextColour
.a9a0	60		rts				rts
.a9a1					_EXPCBackground:
.a9a1	29 0f		and #$0f			and 	#$0F 						; get the colour
.a9a3	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a9a5	80 ea		bra $a991			bra 	_EXPCUpdate
.a9a7					EXTScreenScroll:
.a9a7	a9 02		lda #$02			lda 	#2 							; select text page
.a9a9	85 01		sta $01				sta 	1
.a9ab	a9 20		lda #$20			lda		#32 						; fill with space
.a9ad	20 bc aa	jsr $aabc			jsr 	EXTScrollFill
.a9b0	e6 01		inc $01				inc 	1 							; select colour page
.a9b2	ad 41 06	lda $0641			lda 	EXTTextColour
.a9b5	20 bc aa	jsr $aabc			jsr 	EXTScrollFill
.a9b8	60		rts				rts
.a9b9					EXTClearScreenCode:
.a9b9	a9 02		lda #$02			lda 	#2 							; select text page
.a9bb	85 01		sta $01				sta 	1
.a9bd	a9 20		lda #$20			lda		#32 						; fill with space
.a9bf	20 cc a9	jsr $a9cc			jsr 	_EXTCSFill
.a9c2	e6 01		inc $01				inc 	1 							; select colour page
.a9c4	ad 41 06	lda $0641			lda 	EXTTextColour
.a9c7	20 cc a9	jsr $a9cc			jsr 	_EXTCSFill
.a9ca	80 22		bra $a9ee			bra 	EXTHomeCursor
.a9cc					_EXTCSFill:
.a9cc	aa		tax				tax
.a9cd	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a9cf	85 40		sta $40				sta 	EXTAddress
.a9d1	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9d3	85 41		sta $41				sta 	EXTAddress+1
.a9d5					_EXTCSFill1:
.a9d5	a0 00		ldy #$00			ldy 	#0
.a9d7	8a		txa				txa
.a9d8					_EXTCSFill2:
.a9d8	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9da	c8		iny				iny
.a9db	d0 fb		bne $a9d8			bne 	_EXTCSFill2
.a9dd	e6 41		inc $41				inc 	EXTAddress+1
.a9df	a5 41		lda $41				lda 	EXTAddress+1
.a9e1	c9 d2		cmp #$d2			cmp 	#$D2
.a9e3	d0 f0		bne $a9d5			bne 	_EXTCSFill1
.a9e5	8a		txa				txa
.a9e6					_EXTCSFill3:
.a9e6	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9e8	c8		iny				iny
.a9e9	c0 c0		cpy #$c0			cpy 	#$C0
.a9eb	d0 f9		bne $a9e6			bne 	_EXTCSFill3
.a9ed	60		rts				rts
.a9ee					EXTHomeCursor:
.a9ee	9c 3f 06	stz $063f			stz 	EXTRow 						; reset row & column
.a9f1	9c 40 06	stz $0640			stz 	EXTColumn
.a9f4	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a9f6	85 40		sta $40				sta 	EXTAddress
.a9f8	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9fa	85 41		sta $41				sta 	EXTAddress+1
.a9fc					EXTSetHardwareCursor:
.a9fc	64 01		stz $01				stz 	1 							; I/O Page zero
.a9fe	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.aa00	8d 10 d0	sta $d010			sta 	$D010
.aa03	a9 b1		lda #$b1			lda 	#$B1
.aa05	8d 12 d0	sta $d012			sta 	$D012
.aa08	ad 40 06	lda $0640			lda 	EXTColumn
.aa0b	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.aa0e	9c 15 d0	stz $d015			stz 	$D015
.aa11	ad 3f 06	lda $063f			lda 	EXTRow
.aa14	8d 16 d0	sta $d016			sta 	$D016
.aa17	9c 17 d0	stz $d017			stz 	$D017
.aa1a	60		rts				rts
.aa1b					EXTInputLine:
.aa1b	48		pha				pha
.aa1c	da		phx				phx
.aa1d	5a		phy				phy
.aa1e	a5 01		lda $01				lda 	1 							; save I/O page
.aa20	48		pha				pha
.aa21					_EILLoop:
.aa21	20 23 ab	jsr $ab23			jsr 	ExtInputSingleCharacter
.aa24	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.aa26	f0 40		beq $aa68			beq 	_EILExit
.aa28	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.aa2a	f0 1c		beq $aa48			beq 	_EILBackspace
.aa2c	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.aa2e	90 12		bcc $aa42			bcc 	_EILPrintLoop
.aa30	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.aa32	b0 0e		bcs $aa42			bcs 	_EILPrintLoop
.aa34	48		pha				pha 								; save character
.aa35	a9 02		lda #$02			lda 	#2  						; insert a space
.aa37	85 01		sta $01				sta 	1
.aa39	20 aa aa	jsr $aaaa			jsr 	EXTILInsert 				; insert in text screen
.aa3c	e6 01		inc $01				inc 	1
.aa3e	20 aa aa	jsr $aaaa			jsr 	EXTILInsert 				; insert in colour screen
.aa41	68		pla				pla 								; get character back.
.aa42					_EILPrintLoop:
.aa42	20 8d a8	jsr $a88d			jsr 	ExtPrintCharacter
.aa45	80 da		bra $aa21			bra 	_EILLoop
.aa47	60		rts				rts
.aa48					_EILBackspace:
.aa48	ad 40 06	lda $0640			lda 	EXTColumn					; can we backspace ?
.aa4b	f0 d4		beq $aa21			beq 	_EILLoop
.aa4d	a9 02		lda #$02			lda 	#2 							; move cursor left
.aa4f	20 8d a8	jsr $a88d			jsr 	EXTPrintCharacter
.aa52	a9 02		lda #$02			lda 	#2 							; text block
.aa54	85 01		sta $01				sta 	1
.aa56	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.aa58	20 95 aa	jsr $aa95			jsr 	EXTILDelete
.aa5b	e6 01		inc $01				inc 	1 							; colour block
.aa5d	ac 40 06	ldy $0640			ldy 	EXTColumn 					; get attribute of last character
.aa60	88		dey				dey
.aa61	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa63	20 95 aa	jsr $aa95			jsr 	EXTILDelete 				; backspace attribute
.aa66	80 b9		bra $aa21			bra 	_EILLoop 					; and go round.
.aa68					_EILExit:
.aa68	a9 02		lda #$02			lda 	#2 							; switch to page 2
.aa6a	85 01		sta $01				sta 	1
.aa6c	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa6e					_EILScrapeLine:
.aa6e	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa70	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa73	c8		iny				iny
.aa74	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aa77	d0 f5		bne $aa6e			bne 	_EILScrapeLine
.aa79					_EILTrimSpaces:
.aa79	88		dey				dey
.aa7a	f0 08		beq $aa84			beq 	_EILEndTrim
.aa7c	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y
.aa7f	c9 20		cmp #$20			cmp 	#' '
.aa81	f0 f6		beq $aa79			beq 	_EILTrimSpaces
.aa83	c8		iny				iny 								; trim after non space character.
.aa84					_EILEndTrim:
.aa84	a9 00		lda #$00			lda 	#0 							; trim here.
.aa86	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa89	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa8b	20 8d a8	jsr $a88d			jsr 	ExtPrintCharacter
.aa8e	68		pla				pla 								; reset I/O page
.aa8f	85 01		sta $01				sta 	1
.aa91	7a		ply				ply
.aa92	fa		plx				plx
.aa93	68		pla				pla
.aa94	60		rts				rts
.aa95					EXTILDelete:
.aa95	48		pha				pha 								; save the new character
.aa96	ac 40 06	ldy $0640			ldy 	EXTColumn 					; start copying from here.
.aa99					_EXTDLoop:
.aa99	c8		iny				iny 								; copy one byte down.
.aa9a	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa9c	88		dey				dey
.aa9d	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa9f	c8		iny				iny 								; do till end of line.
.aaa0	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aaa3	90 f4		bcc $aa99			bcc 	_EXTDLoop
.aaa5	88		dey				dey 	 							; write in last slot.
.aaa6	68		pla				pla
.aaa7	91 40		sta ($40),y			sta 	(EXTAddress),y
.aaa9	60		rts				rts
.aaaa					EXTILInsert:
.aaaa	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; end position
.aaad					_EXTILoop:
.aaad	88		dey				dey 								; back one
.aaae	cc 40 06	cpy $0640			cpy 	EXTColumn 					; exit if reached insert point.
.aab1	f0 08		beq $aabb			beq 	_EXTIExit
.aab3	88		dey				dey 								; copy one byte up.
.aab4	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aab6	c8		iny				iny
.aab7	91 40		sta ($40),y			sta 	(EXTAddress),y
.aab9	80 f2		bra $aaad			bra 	_EXTILoop
.aabb					_EXTIExit:
.aabb	60		rts				rts
.aabc					EXTScrollFill:
.aabc	aa		tax				tax									; save value to fill with
.aabd	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aabf	48		pha				pha
.aac0	a5 37		lda $37				lda 	zTemp0+1
.aac2	48		pha				pha
.aac3	a5 38		lda $38				lda 	zTemp1
.aac5	48		pha				pha
.aac6	a5 39		lda $39				lda 	zTemp1+1
.aac8	48		pha				pha
.aac9	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aacb	85 37		sta $37				sta 	zTemp0+1
.aacd	85 39		sta $39				sta 	zTemp1+1
.aacf	64 36		stz $36				stz 	zTemp0
.aad1	ad 42 06	lda $0642			lda 	EXTScreenWidth
.aad4	85 38		sta $38				sta 	zTemp1
.aad6	a0 00		ldy #$00			ldy 	#0
.aad8					_EXSFCopy1:
.aad8	b1 38		lda ($38),y			lda 	(zTemp1),y
.aada	91 36		sta ($36),y			sta 	(zTemp0),y
.aadc	c8		iny				iny
.aadd	d0 f9		bne $aad8			bne 	_EXSFCopy1
.aadf	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aae1	e6 39		inc $39				inc 	zTemp1+1
.aae3	a5 39		lda $39				lda 	zTemp1+1
.aae5	c9 d3		cmp #$d3			cmp 	#$D3
.aae7	d0 ef		bne $aad8			bne 	_EXSFCopy1
.aae9	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; blank the bottom line.
.aaec	8a		txa				txa
.aaed					_EXSFFill1:
.aaed	88		dey				dey
.aaee	91 40		sta ($40),y			sta 	(EXTAddress),y
.aaf0	c0 00		cpy #$00			cpy 	#0
.aaf2	10 f9		bpl $aaed			bpl 	_EXSFFill1
.aaf4	68		pla				pla
.aaf5	85 39		sta $39				sta 	zTemp1+1
.aaf7	68		pla				pla
.aaf8	85 38		sta $38				sta 	zTemp1
.aafa	68		pla				pla
.aafb	85 37		sta $37				sta 	zTemp0+1
.aafd	68		pla				pla
.aafe	85 36		sta $36				sta 	zTemp0
.ab00	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063f					EXTRow:
>063f							.fill 	1
.0640					EXTColumn:
>0640							.fill 	1
.0641					EXTTextColour:
>0641							.fill 	1
.0642					EXTScreenWidth:
>0642							.fill 	1
.0643					EXTScreenHeight:
>0643							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.ab01					EXTInitialise:
.ab01	64 01		stz $01				stz 	1 							; Access I/O
.ab03	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.ab06	9c 08 d0	stz $d008			stz 	$D008
.ab09	9c 09 d0	stz $d009			stz 	$D009
.ab0c	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.ab0e	8d 58 d6	sta $d658			sta 	$D658
.ab11	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.ab13	8d 41 06	sta $0641			sta 	EXTTextColour
.ab16	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.ab18	8d 42 06	sta $0642			sta 	EXTScreenWidth
.ab1b	a9 3c		lda #$3c			lda 	#60
.ab1d	8d 43 06	sta $0643			sta 	EXTScreenHeight
.ab20	64 01		stz $01				stz 	1
.ab22	60		rts				rts
.ab23					EXTInputSingleCharacter:
.ab23	da		phx				phx
.ab24	5a		phy				phy
.ab25					_EISCWait:
.ab25	64 01		stz $01				stz 	1 							; access I/O Page 0
.ab27	38		sec				sec 								; calculate timer - LastTick
.ab28	ad 59 d6	lda $d659			lda 	$D659
.ab2b	aa		tax				tax 								; saving timer in X
.ab2c	ed 2e 06	sbc $062e			sbc 	LastTick
.ab2f	c9 03		cmp #$03			cmp 	#3
.ab31	90 06		bcc $ab39			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.ab33	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.ab36	20 a8 ba	jsr $baa8			jsr 	TickHandler 				; go do the code.
.ab39					_NoFireTick:
.ab39	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.ab3c	c9 00		cmp #$00			cmp 	#0
.ab3e	f0 e5		beq $ab25			beq 	_EISCWait
.ab40	7a		ply				ply
.ab41	fa		plx				plx
.ab42	60		rts				rts
.ab43					EXTBreakCheck:
.ab43	4c e1 ff	jmp $ffe1			jmp		$FFE1
.ab46					EXTReadController:
.ab46	da		phx				phx
.ab47	a2 00		ldx #$00			ldx 	#0
.ab49	a9 05		lda #$05			lda 	#(($2D) >> 3)
.ab4b	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab4e	29 20		and #$20			and 	#($01 << (($2D) & 7))
.ab50	f0 04		beq $ab56			beq 	_NoSet1
.ab52	8a		txa				txa
.ab53	09 01		ora #$01			ora 	#1
.ab55	aa		tax				tax
.ab56					_NoSet1:
.ab56	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab58	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab5b	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab5d	f0 04		beq $ab63			beq 	_NoSet1
.ab5f	8a		txa				txa
.ab60	09 02		ora #$02			ora 	#2
.ab62	aa		tax				tax
.ab63					_NoSet1:
.ab63	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab65	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab68	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab6a	f0 04		beq $ab70			beq 	_NoSet1
.ab6c	8a		txa				txa
.ab6d	09 04		ora #$04			ora 	#4
.ab6f	aa		tax				tax
.ab70					_NoSet1:
.ab70	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab72	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab75	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab77	f0 04		beq $ab7d			beq 	_NoSet1
.ab79	8a		txa				txa
.ab7a	09 08		ora #$08			ora 	#8
.ab7c	aa		tax				tax
.ab7d					_NoSet1:
.ab7d	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab7f	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab82	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab84	f0 04		beq $ab8a			beq 	_NoSet1
.ab86	8a		txa				txa
.ab87	09 10		ora #$10			ora 	#16
.ab89	aa		tax				tax
.ab8a					_NoSet1:
.ab8a	8a		txa				txa
.ab8b	fa		plx				plx
.ab8c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.baae					GRVectorTable:
>baae	88 ad					.word	GXInitialise             ; $00 Initialise
>bab0	a2 ad					.word	GXControlBitmap          ; $01 BitmapCtl
>bab2	ea ad					.word	GXControlSprite          ; $02 SpriteCtl
>bab4	3a ad					.word	GXClearBitmap            ; $03 Clear
>bab6	79 af					.word	GXSetColourMode          ; $04 Colour
>bab8	41 b1					.word	GXFontHandler            ; $05 DrawFont
>baba	89 b1					.word	GXSpriteHandler          ; $06 DrawSprite
>babc	f5 b1					.word	GXSelect                 ; $07 SpriteUse
>babe	1e b2					.word	GXSelectImage            ; $08 SpriteImage
>bac0	a5 b3					.word	GXCollide                ; $09 SpriteCollide
>bac2	ec ab					.word	GRUndefined              ; $0a
>bac4	ec ab					.word	GRUndefined              ; $0b
>bac6	ec ab					.word	GRUndefined              ; $0c
>bac8	ec ab					.word	GRUndefined              ; $0d
>baca	ec ab					.word	GRUndefined              ; $0e
>bacc	ec ab					.word	GRUndefined              ; $0f
>bace	ec ab					.word	GRUndefined              ; $10
>bad0	ec ab					.word	GRUndefined              ; $11
>bad2	ec ab					.word	GRUndefined              ; $12
>bad4	ec ab					.word	GRUndefined              ; $13
>bad6	ec ab					.word	GRUndefined              ; $14
>bad8	ec ab					.word	GRUndefined              ; $15
>bada	ec ab					.word	GRUndefined              ; $16
>badc	ec ab					.word	GRUndefined              ; $17
>bade	ec ab					.word	GRUndefined              ; $18
>bae0	ec ab					.word	GRUndefined              ; $19
>bae2	ec ab					.word	GRUndefined              ; $1a
>bae4	ec ab					.word	GRUndefined              ; $1b
>bae6	ec ab					.word	GRUndefined              ; $1c
>bae8	ec ab					.word	GRUndefined              ; $1d
>baea	ec ab					.word	GRUndefined              ; $1e
>baec	ec ab					.word	GRUndefined              ; $1f
>baee	ea ab					.word	GXMove                   ; $20 Move
>baf0	47 ae					.word	GXLine                   ; $21 Line
>baf2	c2 af					.word	GXFrameRectangle         ; $22 FrameRect
>baf4	bf af					.word	GXFillRectangle          ; $23 FillRect
>baf6	f1 ab					.word	GXFrameCircle            ; $24 FrameCircle
>baf8	ed ab					.word	GXFillCircle             ; $25 FillCircle
>bafa	ec ab					.word	GRUndefined              ; $26
>bafc	ec ab					.word	GRUndefined              ; $27
>bafe	a7 af					.word	GXPlotPoint              ; $28 Plot
>bb00	b4 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5fa					gxPixelBuffer = numberBuffer
.0644					gxCurrentX:
>0644							.fill 	2
.0646					gxCurrentY:
>0646							.fill 	2
.0648					gxLastX:
>0648							.fill 	2
.064a					gxLastY:
>064a							.fill 	2
.064c					gxX0:
>064c							.fill 	2
.064e					gxY0:
>064e							.fill 	2
.0650					gxX1:
>0650							.fill 	2
.0652					gxY1:
>0652							.fill 	2
.0654					gxSpritesOn:
>0654							.fill 	1
.0655					gxBitmapsOn:
>0655							.fill 	1
.0656					gxBasePage:
>0656							.fill 	1
.0657					gxSpritePage:
>0657							.fill 	1
.0658					gxHeight:
>0658							.fill 	1
.0659					gxMode:
>0659							.fill 	1
.065a					gxColour:
>065a							.fill 	1
.065b					gxEORValue:
>065b							.fill 	1
.065c					gxANDValue:
>065c							.fill 	1
.065d					gxOriginalLUTValue:
>065d							.fill 	1
.065e					gsOffset:
>065e							.fill 	1
.065f					GSCurrentSpriteID:
>065f							.fill 	1
.0660					GSCurrentSpriteAddr:
>0660							.fill 	2
.0662					GXSpriteOffsetBase:
>0662							.fill 	2
.0664					GXSpriteLow:
>0664							.fill 	64
.06a4					GXSpriteHigh:
>06a4							.fill 	64
.ab8d					GXGraphicDraw:
.ab8d	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab8f	b0 06		bcs $ab97			bcs 	_GDCoordinate
.ab91	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab93	84 37		sty $37				sty 	gxzTemp0+1
.ab95	80 4b		bra $abe2			bra 	_GDExecuteA 				; and execute
.ab97					_GDCoordinate:
.ab97	48		pha				pha 								; save AXY
.ab98	da		phx				phx
.ab99	5a		phy				phy
.ab9a	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab9c					_GDCopy1:
.ab9c	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.ab9f	9d 48 06	sta $0648,x			sta 	gxLastX,x
.aba2	ca		dex				dex
.aba3	10 f7		bpl $ab9c			bpl 	_GDCopy1
.aba5	68		pla				pla 								; update Y
.aba6	8d 46 06	sta $0646			sta 	gxCurrentY
.aba9	9c 47 06	stz $0647			stz 	gxCurrentY+1
.abac	68		pla				pla
.abad	8d 44 06	sta $0644			sta 	gxCurrentX
.abb0	68		pla				pla 								; get A (command+X.1) back
.abb1	48		pha				pha
.abb2	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.abb4	8d 45 06	sta $0645			sta 	gxCurrentX+1
.abb7	68		pla				pla 								; get command back
.abb8	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abba	48		pha				pha 								; push back.
.abbb	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abbd	f0 17		beq $abd6			beq 	_GDCopyToWorkArea
.abbf	ad 45 06	lda $0645			lda 	gxCurrentX+1 				; X < 256 X okay
.abc2	f0 07		beq $abcb			beq 	_GDCheckY
.abc4	ad 44 06	lda $0644			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abc7	c9 40		cmp #$40			cmp 	#64
.abc9	b0 08		bcs $abd3			bcs 	_GDError1
.abcb					_GDCheckY:
.abcb	ad 46 06	lda $0646			lda 	gxCurrentY 					; check Y < Height.
.abce	cd 58 06	cmp $0658			cmp 	gxHeight
.abd1	90 03		bcc $abd6			bcc 	_GDCopyToWorkArea
.abd3					_GDError1:
.abd3	68		pla				pla
.abd4					_GDError2:
.abd4	38		sec				sec
.abd5	60		rts				rts
.abd6					_GDCopyToWorkArea:
.abd6	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abd8					_GDCopy2:
.abd8	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.abdb	9d 4c 06	sta $064c,x			sta 	gxX0,x
.abde	ca		dex				dex
.abdf	10 f7		bpl $abd8			bpl 	_GDCopy2
.abe1	68		pla				pla 								; get command
.abe2					_GDExecuteA:
.abe2	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abe4	b0 ee		bcs $abd4			bcs 	_GDError2
.abe6	aa		tax				tax
.abe7	7c ae ba	jmp ($baae,x)			jmp 	(GRVectorTable,x)
.abea					GXMove:
.abea	18		clc				clc
.abeb	60		rts				rts
.abec					GRUndefined:
>abec	db						.byte 	$DB 						; causes a break in the emulator
.abed					GXFillCircle:
.abed	a9 ff		lda #$ff			lda 	#255
.abef	80 02		bra $abf3			bra 	GXCircle
.abf1					GXFrameCircle:
.abf1	a9 00		lda #$00			lda 	#0
.abf3					GXCircle:
.abf3	8d e7 06	sta $06e7			sta 	gxIsFillMode					; save Fill flag
.abf6	ad 55 06	lda $0655			lda 	gxBitmapsOn
.abf9	f0 26		beq $ac21			beq 	_GXCFail
.abfb	20 4c b4	jsr $b44c			jsr 	GXSortXY 					; topleft/bottomright
.abfe	20 24 b3	jsr $b324			jsr 	GXOpenBitmap 				; start drawing
.ac01	20 f3 ac	jsr $acf3			jsr 	GXCircleSetup 				; set up for drawing
.ac04	9c e8 06	stz $06e8			stz 	gxYChanged
.ac07					_GXCircleDraw:
.ac07	ad e5 06	lda $06e5			lda 	gXCentre					; while x <= y
.ac0a	cd e6 06	cmp $06e6			cmp 	gYCentre
.ac0d	90 0a		bcc $ac19			bcc 	_GXCircleContinue
.ac0f	d0 03		bne $ac14			bne 	_GXNoLast
.ac11	20 26 ac	jsr $ac26			jsr 	GXPlot1
.ac14					_GXNoLast:
.ac14	20 2c b3	jsr $b32c			jsr 	GXCloseBitmap 				; close the bitmap
.ac17	18		clc				clc
.ac18	60		rts				rts
.ac19					_GXCircleContinue:
.ac19	20 23 ac	jsr $ac23			jsr 	GXPlot2 					; draw it
.ac1c	20 a0 ac	jsr $aca0			jsr 	GXCircleMove 				; adjust the coordinates
.ac1f	80 e6		bra $ac07			bra 	_GXCircleDraw
.ac21					_GXCFail:
.ac21	38		sec				sec
.ac22	60		rts				rts
.ac23					GXPlot2:
.ac23	20 26 ac	jsr $ac26			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac26					GXPlot1:
.ac26	ad e6 06	lda $06e6			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac29	f0 03		beq $ac2e			beq 	_GXPlot1Only
.ac2b	20 4a ac	jsr $ac4a			jsr 	GXPlot0 						; plot and negate
.ac2e					_GXPlot1Only:
.ac2e	20 4a ac	jsr $ac4a			jsr 	GXPlot0 						; twice, undoing negation
.ac31	ad e5 06	lda $06e5			lda 	gXCentre 						; swap X and Y
.ac34	ae e6 06	ldx $06e6			ldx	 	gYCentre
.ac37	8d e6 06	sta $06e6			sta 	gYCentre
.ac3a	8e e5 06	stx $06e5			stx 	gXCentre
.ac3d	ad e8 06	lda $06e8			lda 	gxYChanged 						; toggle Y Changed flag
.ac40	a9 ff		lda #$ff			lda 	#$FF
.ac42	8d e8 06	sta $06e8			sta 	gxYChanged
.ac45	60		rts				rts
.ac46	20 4a ac	jsr $ac4a			jsr 	GXPlot0 						; do once
.ac49	60		rts				rts
.ac4a	ad e7 06	lda $06e7	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac4d	f0 05		beq $ac54			beq 	_GXPlot0Always
.ac4f	ad e8 06	lda $06e8			lda 	gxYChanged						; fill mode, only draw if changed.
.ac52	f0 2d		beq $ac81			beq 	GXPlot0Exit
.ac54					_GXPlot0Always:
.ac54	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac56	ad e6 06	lda $06e6			lda 	gYCentre
.ac59	20 82 ac	jsr $ac82			jsr 	GXSubCopy
.ac5c	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac5e	ad e5 06	lda $06e5			lda 	gXCentre
.ac61	20 82 ac	jsr $ac82			jsr 	GXSubCopy
.ac64	48		pha				pha 									; save last offset X
.ac65	20 34 b3	jsr $b334			jsr 	GXPositionCalc 					; calculate position/offset.
.ac68	68		pla				pla
.ac69	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac6a	85 36		sta $36				sta 	gxzTemp0
.ac6c	64 37		stz $37				stz 	gxzTemp0+1
.ac6e	26 37		rol $37				rol 	gxzTemp0+1
.ac70	ad e7 06	lda $06e7			lda 	gxIsFillMode
.ac73	69 80		adc #$80			adc 	#128
.ac75	20 12 b0	jsr $b012			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac78	38		sec				sec 									; GY = -GY
.ac79	a9 00		lda #$00			lda 	#0
.ac7b	ed e6 06	sbc $06e6			sbc 	gYCentre
.ac7e	8d e6 06	sta $06e6			sta 	gYCentre
.ac81					GXPlot0Exit:
.ac81	60		rts				rts
.ac82					GXSubCopy:
.ac82	85 36		sta $36				sta 	gxzTemp0
.ac84	64 37		stz $37				stz 	gxzTemp0+1
.ac86	29 80		and #$80			and 	#$80
.ac88	f0 02		beq $ac8c			beq 	_GXNoSx
.ac8a	c6 37		dec $37				dec 	gxzTemp0+1
.ac8c					_GXNoSx:
.ac8c	38		sec				sec
.ac8d	bd 50 06	lda $0650,x			lda 	gXX1,x
.ac90	e5 36		sbc $36				sbc 	gxzTemp0
.ac92	9d 4c 06	sta $064c,x			sta 	gXX0,x
.ac95	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ac98	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac9a	9d 4d 06	sta $064d,x			sta 	gXX0+1,x
.ac9d	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ac9f	60		rts				rts
.aca0					GXCircleMove:
.aca0	9c e8 06	stz $06e8			stz 	gxYChanged 					; clear Y changed flag
.aca3	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.aca5	10 0d		bpl $acb4			bpl 	_GXEMPositive
.aca7	ee e5 06	inc $06e5			inc 	gXCentre 					; X++
.acaa	ad e5 06	lda $06e5			lda 	gXCentre
.acad	20 d3 ac	jsr $acd3			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acb0	a9 06		lda #$06			lda 	#6  						; and add 6
.acb2	80 15		bra $acc9			bra 	_GXEMAddD
.acb4					_GXEMPositive:
.acb4	ee e5 06	inc $06e5			inc 	gXCentre					; X++
.acb7	ce e6 06	dec $06e6			dec 	gyCentre 					; Y--
.acba	38		sec				sec 								; calculate X-Y
.acbb	ad e5 06	lda $06e5			lda 	gXCentre
.acbe	ed e6 06	sbc $06e6			sbc 	gYCentre
.acc1	20 d3 ac	jsr $acd3			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acc4	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acc6	ce e8 06	dec $06e8			dec 	gxYChanged
.acc9					_GXEMAddD:
.acc9	18		clc				clc
.acca	65 38		adc $38				adc 	gxzTemp1
.accc	85 38		sta $38				sta 	gxzTemp1
.acce	90 02		bcc $acd2			bcc 	_GXEMNoCarry
.acd0	e6 39		inc $39				inc 	gxzTemp1+1
.acd2					_GXEMNoCarry:
.acd2	60		rts				rts
.acd3					_GXAdd4TimesToD:
.acd3	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acd5	29 80		and #$80			and 	#$80
.acd7	f0 02		beq $acdb			beq 	_GXA4Unsigned
.acd9	a9 ff		lda #$ff			lda 	#$FF
.acdb					_GXA4Unsigned:
.acdb	85 37		sta $37				sta 	gxzTemp0+1
.acdd	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acdf	26 37		rol $37				rol 	gxzTemp0+1
.ace1	06 36		asl $36				asl 	gxzTemp0
.ace3	26 37		rol $37				rol 	gxzTemp0+1
.ace5	18		clc				clc 								; add
.ace6	a5 36		lda $36				lda		gxzTemp0
.ace8	65 38		adc $38				adc 	gxzTemp1
.acea	85 38		sta $38				sta 	gxzTemp1
.acec	a5 37		lda $37				lda		gxzTemp0+1
.acee	65 39		adc $39				adc 	gxzTemp1+1
.acf0	85 39		sta $39				sta 	gxzTemp1+1
.acf2	60		rts				rts
.acf3					GXCircleSetup:
.acf3	38		sec				sec
.acf4	ad 52 06	lda $0652			lda 	gxY1
.acf7	ed 4e 06	sbc $064e			sbc 	gxY0
.acfa	4a		lsr a				lsr 	a
.acfb	8d e4 06	sta $06e4			sta 	gxRadius
.acfe	a2 00		ldx #$00			ldx 	#0
.ad00	20 22 ad	jsr $ad22			jsr 	_GXCalculateCentre
.ad03	a2 02		ldx #$02			ldx 	#2
.ad05	20 22 ad	jsr $ad22			jsr 	_GXCalculateCentre
.ad08	9c e5 06	stz $06e5			stz 	gXCentre
.ad0b	ad e4 06	lda $06e4			lda 	gxRadius
.ad0e	8d e6 06	sta $06e6			sta 	gYCentre
.ad11	0a		asl a				asl 	a 							; R x 2
.ad12	85 36		sta $36				sta 	gxzTemp0
.ad14	38		sec				sec
.ad15	a9 03		lda #$03			lda 	#3
.ad17	e5 36		sbc $36				sbc 	gxzTemp0
.ad19	85 38		sta $38				sta 	gxzTemp1
.ad1b	a9 00		lda #$00			lda 	#0
.ad1d	e9 00		sbc #$00			sbc 	#0
.ad1f	85 39		sta $39				sta 	gxzTemp1+1
.ad21	60		rts				rts
.ad22					_GXCalculateCentre:
.ad22	38		sec				sec
.ad23	bd 50 06	lda $0650,x			lda 	gxX1,x
.ad26	7d 4c 06	adc $064c,x			adc 	gXX0,x
.ad29	9d 50 06	sta $0650,x			sta 	gXX1,x
.ad2c	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ad2f	7d 4d 06	adc $064d,x			adc 	gXX0+1,x
.ad32	4a		lsr a				lsr 	a
.ad33	9d 51 06	sta $0651,x			sta 	gXX1+1,x
.ad36	7e 50 06	ror $0650,x			ror 	gXX1,x
.ad39	60		rts				rts
.06e4					gxRadius:
>06e4							.fill 	1
.06e5					gXCentre:
>06e5							.fill 	1
.06e6					gYCentre:
>06e6							.fill 	1
.06e7					gxIsFillMode:
>06e7							.fill 	1
.06e8					gxYChanged:
>06e8							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad3a					GXClearBitmap:
.ad3a	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP running.
.ad3d	f0 24		beq $ad63			beq 	_GXCBFail
.ad3f	20 24 b3	jsr $b324			jsr 	GXOpenBitmap 				; start access
.ad42	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad44	ad 58 06	lda $0658			lda 	gxHeight
.ad47	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad49	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad4b					_GXCalcLastPage:
.ad4b	98		tya				tya 								; add to base page
.ad4c	18		clc				clc
.ad4d	6d 56 06	adc $0656			adc 	gxBasePage
.ad50	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad52					_GXClearAll:
.ad52	20 65 ad	jsr $ad65			jsr 	_GXClearBlock 				; clear 8k block
.ad55	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad57	a5 0b		lda $0b				lda 	GXEditSlot
.ad59	cd 56 06	cmp $0656			cmp 	gxBasePage 					; until before base page
.ad5c	b0 f4		bcs $ad52			bcs 	_GXClearAll
.ad5e	20 2c b3	jsr $b32c			jsr 	GXCloseBitmap	 			; stop access
.ad61	18		clc				clc
.ad62	60		rts				rts
.ad63					_GXCBFail:
.ad63	38		sec				sec
.ad64	60		rts				rts
.ad65					_GXClearBlock:
.ad65	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad67	85 38		sta $38				sta 	0+gxzTemp1
.ad69	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad6b	85 39		sta $39				sta 	1+gxzTemp1
.ad6d					_GXCB0:
.ad6d	a5 36		lda $36				lda 	gxzTemp0
.ad6f	a0 00		ldy #$00			ldy 	#0
.ad71					_GXCB1:
.ad71	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad73	c8		iny				iny
.ad74	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad76	c8		iny				iny
.ad77	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad79	c8		iny				iny
.ad7a	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad7c	c8		iny				iny
.ad7d	d0 f2		bne $ad71			bne 	_GXCB1
.ad7f	e6 39		inc $39				inc 	gxzTemp1+1
.ad81	a5 39		lda $39				lda 	gxzTemp1+1
.ad83	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad85	d0 e6		bne $ad6d			bne 	_GXCB0
.ad87	60		rts				rts
.ad88					GXInitialise:
.ad88	64 01		stz $01				stz 	1
.ad8a	a9 01		lda #$01			lda 	#1
.ad8c	8d 00 d0	sta $d000			sta 	$D000
.ad8f	18		clc				clc
.ad90	9c 54 06	stz $0654			stz 	GXSpritesOn
.ad93	9c 55 06	stz $0655			stz 	GXBitmapsOn
.ad96	a2 0f		ldx #$0f			ldx 	#15
.ad98					_GXIClear:
.ad98	9e 44 06	stz $0644,x			stz 	gxCurrentX,x
.ad9b	ca		dex				dex
.ad9c	10 fa		bpl $ad98			bpl 	_GXIClear
.ad9e	20 39 ae	jsr $ae39			jsr 	GXClearSpriteStore
.ada1	60		rts				rts
.ada2					GXControlBitmap:
.ada2	64 01		stz $01				stz 	1
.ada4	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ada6	29 01		and #$01			and 	#1 							; set bitmap flag
.ada8	8d 55 06	sta $0655			sta 	gxBitmapsOn
.adab	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adac	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adaf	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adb1	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.adb3	90 02		bcc $adb7			bcc 	_CBNotOn
.adb5	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.adb7					_CBNotOn:
.adb7	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adba	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.adbc	29 07		and #$07			and 	#7
.adbe	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adc1	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adc3	d0 02		bne $adc7			bne 	_CBNotDefault
.adc5	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adc7					_CBNotDefault:
.adc7	8d 56 06	sta $0656			sta 	gxBasePage
.adca	20 2b ae	jsr $ae2b			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adcd	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.adcf	8d 03 d1	sta $d103			sta 	$D103
.add2	a5 36		lda $36				lda 	gxzTemp0
.add4	8d 02 d1	sta $d102			sta 	$D102
.add7	9c 01 d1	stz $d101			stz 	$D101
.adda	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.addc	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.addf	29 01		and #$01			and 	#1
.ade1	f0 02		beq $ade5			beq 	_CBHaveHeight
.ade3	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ade5					_CBHaveHeight
.ade5	8e 58 06	stx $0658			stx 	gxHeight
.ade8	18		clc				clc
.ade9	60		rts				rts
.adea					GXControlSprite:
.adea	64 01		stz $01				stz 	1
.adec	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adee	29 01		and #$01			and 	#1 							; set sprites flag
.adf0	8d 54 06	sta $0654			sta 	gxSpritesOn
.adf3	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adf4	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adf7	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adf9	29 df		and #$df			and 	#$DF 						; clear sprite bit
.adfb	90 02		bcc $adff			bcc 	_CSNotOn
.adfd	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.adff					_CSNotOn:
.adff	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ae02	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ae04	d0 02		bne $ae08			bne 	_CSNotDefault
.ae06	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ae08					_CSNotDefault:
.ae08	8d 57 06	sta $0657			sta 	gxSpritePage
.ae0b	20 2b ae	jsr $ae2b			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae0e	a5 36		lda $36				lda 	zTemp0
.ae10	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase
.ae13	a5 37		lda $37				lda 	zTemp0+1
.ae15	8d 63 06	sta $0663			sta 	GXSpriteOffsetBase+1
.ae18	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae1a					_CSClear:
.ae1a	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae1d	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae20	ca		dex				dex
.ae21	d0 f7		bne $ae1a			bne 	_CSClear
.ae23	9c 61 06	stz $0661			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae26	20 39 ae	jsr $ae39			jsr 	GXClearSpriteStore
.ae29	18		clc				clc
.ae2a	60		rts				rts
.ae2b					GXCalculateBaseAddress:
.ae2b	85 36		sta $36				sta 	gxzTemp0
.ae2d	64 37		stz $37				stz 	gxzTemp0+1
.ae2f	a9 05		lda #$05			lda 	#5
.ae31					_GXShift:
.ae31	06 36		asl $36				asl 	gxzTemp0
.ae33	26 37		rol $37				rol 	gxzTemp0+1
.ae35	3a		dec a				dec		a
.ae36	d0 f9		bne $ae31			bne 	_GXShift
.ae38	60		rts				rts
.ae39					GXClearSpriteStore:
.ae39	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae3b					_GXCSSLoop:
.ae3b	9e a4 06	stz $06a4,x			stz 	GXSpriteHigh,x
.ae3e	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae40	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.ae43	ca		dex				dex
.ae44	10 f5		bpl $ae3b			bpl 	_GXCSSLoop
.ae46	60		rts				rts
.ae47					GXLine:
.ae47	ad 55 06	lda $0655			lda 	GXBitmapsOn
.ae4a	f0 28		beq $ae74			beq 	_GXLFail
.ae4c	20 24 b3	jsr $b324			jsr 	GXOpenBitmap
.ae4f	20 6a b4	jsr $b46a			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae52	20 1a af	jsr $af1a			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae55	20 34 b3	jsr $b334			jsr 	GXPositionCalc 				; calculate position/offset.
.ae58					_GXDrawLoop:
.ae58	ac 5e 06	ldy $065e			ldy 	gsOffset 					; draw the pixel
.ae5b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae5d	2d 5c 06	and $065c			and 	gxANDValue
.ae60	4d 5b 06	eor $065b			eor 	gxEORValue
.ae63	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae65	20 76 ae	jsr $ae76			jsr 	GXLineIsComplete 			; is the line complete ?
.ae68	f0 05		beq $ae6f			beq 	_GXLExit
.ae6a	20 91 ae	jsr $ae91			jsr 	GXLineAdvance 				; code as per advance method
.ae6d	80 e9		bra $ae58			bra 	_GXDrawLoop
.ae6f					_GXLExit:
.ae6f	20 2c b3	jsr $b32c			jsr 	GXCloseBitmap
.ae72	18		clc				clc
.ae73	60		rts				rts
.ae74					_GXLFail:
.ae74	38		sec				sec
.ae75	60		rts				rts
.ae76					GXLineIsComplete:
.ae76	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger 			; is dy larger
.ae79	d0 0f		bne $ae8a			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae7b	ad 4c 06	lda $064c			lda 	GXX0 						; compare X, LSB and MSB
.ae7e	4d 50 06	eor $0650			eor 	GXX1
.ae81	d0 06		bne $ae89			bne 	_GXLICExit
.ae83	ad 4d 06	lda $064d			lda 	GXX0+1
.ae86	4d 51 06	eor $0651			eor 	GXX1+1
.ae89					_GXLICExit:
.ae89	60		rts				rts
.ae8a					_GXLICCompareY:
.ae8a	ad 52 06	lda $0652			lda 	GXY1
.ae8d	4d 4e 06	eor $064e			eor 	GXY0
.ae90	60		rts				rts
.ae91					GXLineAdvance:
.ae91	18		clc				clc 								; add adjust to position
.ae92	ad ed 06	lda $06ed			lda 	GXPosition
.ae95	6d ee 06	adc $06ee			adc 	GXAdjust
.ae98	8d ed 06	sta $06ed			sta 	GXPosition
.ae9b	9c f0 06	stz $06f0			stz 	GXAddSelect 				; clear add select flag
.ae9e	b0 05		bcs $aea5			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.aea0	cd ef 06	cmp $06ef			cmp 	GXTotal 					; if exceeded total
.aea3	90 0a		bcc $aeaf			bcc 	_GXLANoExtra
.aea5					_GXLAOverflow:
.aea5	ce f0 06	dec $06f0			dec 	GXAddSelect 				; set addselect to $FF
.aea8	38		sec				sec 								; subtract total and write back
.aea9	ed ef 06	sbc $06ef			sbc 	GXTotal
.aeac	8d ed 06	sta $06ed			sta 	GXPosition
.aeaf					_GXLANoExtra:
.aeaf	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger
.aeb2	f0 0d		beq $aec1			beq 	_GXDXLarger
.aeb4	20 13 af	jsr $af13			jsr 	GXIncrementY
.aeb7	ad f0 06	lda $06f0			lda 	GXAddSelect
.aeba	f0 10		beq $aecc			beq 	_GXLAExit
.aebc	20 cd ae	jsr $aecd			jsr 	GXAdjustX
.aebf	80 0b		bra $aecc			bra 	_GXLAExit
.aec1					_GXDXLarger:
.aec1	20 cd ae	jsr $aecd			jsr 	GXAdjustX
.aec4	ad f0 06	lda $06f0			lda 	GXAddSelect
.aec7	f0 03		beq $aecc			beq 	_GXLAExit
.aec9	20 13 af	jsr $af13			jsr 	GXIncrementY
.aecc					_GXLAExit:
.aecc	60		rts				rts
.aecd					GXAdjustX:
.aecd	ad ec 06	lda $06ec			lda 	GXDXNegative
.aed0	10 25		bpl $aef7			bpl 	_GXAXRight
.aed2	ad 4c 06	lda $064c			lda 	GXX0
.aed5	d0 03		bne $aeda			bne 	_GXAXNoBorrow
.aed7	ce 4d 06	dec $064d			dec 	GXX0+1
.aeda					_GXAXNoBorrow:
.aeda	ce 4c 06	dec $064c			dec 	GXX0
.aedd	ce 5e 06	dec $065e			dec 	gsOffset 					; pixel left
.aee0	ad 5e 06	lda $065e			lda 	gsOffset
.aee3	c9 ff		cmp #$ff			cmp 	#$FF
.aee5	d0 0f		bne $aef6			bne 	_GXAYExit 					; underflow
.aee7	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aee9	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aeeb	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aeed	b0 07		bcs $aef6			bcs 	_GXAYExit
.aeef	18		clc				clc
.aef0	69 20		adc #$20			adc 	#$20 						; fix up
.aef2	85 3d		sta $3d				sta 	gxzScreen+1
.aef4	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aef6					_GXAYExit:
.aef6	60		rts				rts
.aef7					_GXAXRight:
.aef7	ee 4c 06	inc $064c			inc 	GXX0
.aefa	d0 03		bne $aeff			bne 	_GXAXNoCarry
.aefc	ee 4d 06	inc $064d			inc 	GXX0+1
.aeff					_GXAXNoCarry:
.aeff	ee 5e 06	inc $065e			inc 	gsOffset 					; pixel right
.af02	d0 0e		bne $af12			bne 	_GXAXExit 					; if not overflowed, exit.
.af04	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.af06	a5 3d		lda $3d				lda 	gxzScreen+1
.af08	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.af0a	90 06		bcc $af12			bcc 	_GXAXExit
.af0c	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af0e	85 3d		sta $3d				sta 	gxzScreen+1
.af10	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af12					_GXAXExit:
.af12	60		rts				rts
.af13					GXIncrementY:
.af13	ee 4e 06	inc $064e			inc 	GXY0
.af16	20 8a b3	jsr $b38a			jsr 	GXMovePositionDown
.af19	60		rts				rts
.af1a					GXLineSetup:
.af1a	ad 52 06	lda $0652			lda 	GXY1
.af1d	38		sec				sec
.af1e	ed 4e 06	sbc $064e			sbc 	GXY0
.af21	4a		lsr a				lsr 	a
.af22	8d ea 06	sta $06ea			sta 	GXDiffY
.af25	9c ec 06	stz $06ec			stz 	GXDXNegative 				; clear -ve flag
.af28	38		sec				sec
.af29	ad 50 06	lda $0650			lda 	GXX1
.af2c	ed 4c 06	sbc $064c			sbc 	GXX0
.af2f	8d e9 06	sta $06e9			sta 	GXDiffX
.af32	ad 51 06	lda $0651			lda 	GXX1+1 						; calculate MSB
.af35	ed 4d 06	sbc $064d			sbc 	GXX0+1
.af38	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af39	6e e9 06	ror $06e9			ror 	GXDiffX
.af3c	0a		asl a				asl 	a
.af3d	10 0c		bpl $af4b			bpl 	_GDXNotNegative
.af3f	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af41	38		sec				sec
.af42	ed e9 06	sbc $06e9			sbc 	GXDiffX
.af45	8d e9 06	sta $06e9			sta 	GXDiffX
.af48	ce ec 06	dec $06ec			dec 	GXDXNegative 				; -ve flag = $FF.
.af4b					_GDXNotNegative:
.af4b	9c eb 06	stz $06eb			stz 	GXIsDiffYLarger 			; clear larger flag
.af4e	ad ea 06	lda $06ea			lda 	GXDiffY 					; set adjust and total.
.af51	8d ee 06	sta $06ee			sta 	GXAdjust
.af54	ad e9 06	lda $06e9			lda 	GXDiffX
.af57	8d ef 06	sta $06ef			sta 	GXTotal
.af5a	ad ea 06	lda $06ea			lda 	GXDiffY 					; if dy > dx
.af5d	cd e9 06	cmp $06e9			cmp 	GXDiffX
.af60	90 0f		bcc $af71			bcc 	_GDXNotLarger
.af62	ce eb 06	dec $06eb			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af65	ad e9 06	lda $06e9			lda 	GXDiffX 					; set adjust and total other way round
.af68	8d ee 06	sta $06ee			sta 	GXAdjust
.af6b	ad ea 06	lda $06ea			lda 	GXDiffY
.af6e	8d ef 06	sta $06ef			sta 	GXTotal
.af71					_GDXNotLarger:
.af71	ad ef 06	lda $06ef			lda 	GXTotal
.af74	4a		lsr a				lsr 	a
.af75	8d ed 06	sta $06ed			sta 	GXPosition
.af78	60		rts				rts
.06e9					GXDiffX:
>06e9							.fill 	1
.06ea					GXDiffY:
>06ea							.fill 	1
.06eb					GXIsDiffYLarger:
>06eb							.fill 	1
.06ec					GXDXNegative:
>06ec							.fill 	1
.06ed					GXPosition:
>06ed							.fill 	1
.06ee					GXAdjust:
>06ee							.fill 	1
.06ef					GXTotal:
>06ef							.fill 	1
.06f0					GXAddSelect:
>06f0							.fill 	1
.af79					GXSetColourMode:
.af79	a6 36		ldx $36				ldx 	gxzTemp0
.af7b	8e 5a 06	stx $065a			stx 	gxColour 								; set colour
.af7e	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af80	8d 59 06	sta $0659			sta 	gxMode 									; set mode
.af83	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af85	9c 5c 06	stz $065c			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af88	ae 5a 06	ldx $065a			ldx 	gxColour
.af8b	8e 5b 06	stx $065b			stx 	gxEORValue
.af8e	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af90	90 03		bcc $af95			bcc 	_GXSDCNotAndColour
.af92	8e 5c 06	stx $065c			stx 	gxANDValue
.af95					_GXSDCNotAndColour:
.af95	d0 03		bne $af9a			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af97	9c 5b 06	stz $065b			stz 	gxEORValue
.af9a					_GXSDCNotAnd:
.af9a	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af9b	90 08		bcc $afa5			bcc 	_GXSDCNoFlip
.af9d	ad 5c 06	lda $065c			lda	 	gxANDValue
.afa0	49 ff		eor #$ff			eor 	#$FF
.afa2	8d 5c 06	sta $065c			sta 	gxANDValue
.afa5					_GXSDCNoFlip:
.afa5	18		clc				clc
.afa6	60		rts				rts
.afa7					GXPlotPoint:
.afa7	20 24 b3	jsr $b324			jsr 	GXOpenBitmap 				; start drawing
.afaa	20 34 b3	jsr $b334			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afad	ac 5e 06	ldy $065e			ldy 	gsOffset
.afb0	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afb2	2d 5c 06	and $065c			and 	gxANDValue
.afb5	4d 5b 06	eor $065b			eor 	gxEORValue
.afb8	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afba	20 2c b3	jsr $b32c			jsr 	GXCloseBitmap 				; stop drawing and exit
.afbd	18		clc				clc
.afbe	60		rts				rts
.afbf					GXFillRectangle:
.afbf	38		sec				sec
.afc0	80 01		bra $afc3			bra 	GXRectangle
.afc2					GXFrameRectangle:
.afc2	18		clc				clc
.afc3					GXRectangle:
.afc3	ad 55 06	lda $0655			lda 	gxBitmapsOn
.afc6	f0 35		beq $affd			beq 	_GXRFail
.afc8	08		php				php 								; save Fill flag (CS)
.afc9	20 24 b3	jsr $b324			jsr 	GXOpenBitmap 				; start drawing
.afcc	20 4c b4	jsr $b44c			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afcf	20 34 b3	jsr $b334			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afd2	38		sec				sec 								; sec = Draw line
.afd3	20 ff af	jsr $afff			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afd6	ad 4e 06	lda $064e			lda 	gxY0 						; reached end of rectangle ?
.afd9	cd 52 06	cmp $0652			cmp 	gxY1
.afdc	f0 19		beq $aff7			beq 	_GXRectangleExit
.afde					_GXRectLoop:
.afde	20 8a b3	jsr $b38a			jsr 	GXMovePositionDown 			; down one.
.afe1	ee 4e 06	inc $064e			inc 	gxY0 						; change Y pos
.afe4	ad 4e 06	lda $064e			lda 	gxY0 						; reached last line
.afe7	cd 52 06	cmp $0652			cmp 	gXY1
.afea	f0 07		beq $aff3			beq 	_GXLastLine
.afec	28		plp				plp 								; get flag back
.afed	08		php				php
.afee	20 ff af	jsr $afff			jsr 	GXDrawLineX1X0 				; draw horizontal line
.aff1	80 eb		bra $afde			bra 	_GXRectLoop
.aff3					_GXLastLine:
.aff3	38		sec				sec
.aff4	20 ff af	jsr $afff			jsr 	GXDrawLineX1X0
.aff7					_GXRectangleExit:
.aff7	68		pla				pla 								; throw fill flag.
.aff8	20 2c b3	jsr $b32c			jsr 	GXCloseBitmap 				; stop drawing and exit
.affb	18		clc				clc
.affc	60		rts				rts
.affd					_GXRFail:
.affd	38		sec				sec
.affe	60		rts				rts
.afff					GXDrawLineX1X0:
.afff	08		php				php 								; save solid/either-end
.b000	38		sec				sec
.b001	ad 50 06	lda $0650			lda		gXX1
.b004	ed 4c 06	sbc $064c			sbc 	gXX0
.b007	85 36		sta $36				sta 	gxzTemp0
.b009	ad 51 06	lda $0651			lda 	gXX1+1
.b00c	ed 4d 06	sbc $064d			sbc 	gXX0+1
.b00f	85 37		sta $37				sta 	gxzTemp0+1
.b011	28		plp				plp
.b012					GXDrawLineTemp0:
.b012	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b014	48		pha				pha
.b015	a5 3d		lda $3d				lda 	gxzScreen+1
.b017	48		pha				pha
.b018	ad 5e 06	lda $065e			lda 	gsOffset
.b01b	48		pha				pha
.b01c	a5 0b		lda $0b				lda 	GXEditSlot
.b01e	48		pha				pha
.b01f	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y offset
.b022	90 1e		bcc $b042			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b024					_GXDLTLine:
.b024	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b026	2d 5c 06	and $065c			and 	gxANDValue
.b029	4d 5b 06	eor $065b			eor 	gxEORValue
.b02c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b02e	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b030	d0 04		bne $b036			bne 	_GXDLTNoBorrow
.b032	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b034	30 2e		bmi $b064			bmi 	_GXDLTExit
.b036					_GXDLTNoBorrow:
.b036	c6 36		dec $36				dec 	gxzTemp0
.b038	c8		iny				iny 								; next slot.
.b039	d0 e9		bne $b024			bne 	_GXDLTLine
.b03b	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b03d	20 72 b0	jsr $b072			jsr 	GXDLTCheckWrap				; check for new page.
.b040	80 e2		bra $b024			bra 	_GXDLTLine
.b042					_GXDLTEndPoints:
.b042	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b044	2d 5c 06	and $065c			and 	gxANDValue
.b047	4d 5b 06	eor $065b			eor 	gxEORValue
.b04a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b04c	98		tya				tya 								; advance to right side
.b04d	18		clc				clc
.b04e	65 36		adc $36				adc 	gxzTemp0
.b050	a8		tay				tay
.b051	a5 3d		lda $3d				lda 	gxzScreen+1
.b053	65 37		adc $37				adc 	gxzTemp0+1
.b055	85 3d		sta $3d				sta 	gxzScreen+1
.b057	20 72 b0	jsr $b072			jsr 	GXDLTCheckWrap 			; fix up.
.b05a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b05c	2d 5c 06	and $065c			and 	gxANDValue
.b05f	4d 5b 06	eor $065b			eor 	gxEORValue
.b062	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b064					_GXDLTExit:
.b064	68		pla				pla
.b065	85 0b		sta $0b				sta 	GXEditSlot
.b067	68		pla				pla
.b068	8d 5e 06	sta $065e			sta 	gsOffset
.b06b	68		pla				pla
.b06c	85 3d		sta $3d				sta 	gxzScreen+1
.b06e	68		pla				pla
.b06f	85 3c		sta $3c				sta 	gxzScreen
.b071	60		rts				rts
.b072					GXDLTCheckWrap:
.b072	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b074	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b076	90 06		bcc $b07e			bcc 	_GXDLTCWExit
.b078	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b07a	85 3d		sta $3d				sta 	gxzScreen+1
.b07c	e6 0b		inc $0b				inc 	GXEditSlot
.b07e					_GXDLTCWExit:
.b07e	60		rts				rts
.b07f					GXDrawGraphicElement:
.b07f	8d f1 06	sta $06f1			sta 	gxSize 						; save size
.b082	3a		dec a				dec 	a
.b083	8d f2 06	sta $06f2			sta 	gxMask 						; and mask
.b086	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP on
.b089	f0 67		beq $b0f2			beq 	_GXSLFail
.b08b	ad 4e 06	lda $064e			lda 	gxY0 						; push Y on stack
.b08e	48		pha				pha
.b08f	8c f4 06	sty $06f4			sty 	gxAcquireVector+1 			; and acquisition vector
.b092	8e f3 06	stx $06f3			stx 	gxAcquireVector
.b095	20 24 b3	jsr $b324			jsr 	gxOpenBitmap 				; open the bitmap.
.b098	ad f6 06	lda $06f6			lda 	gxUseMode 					; scale bits
.b09b	4a		lsr a				lsr 	a
.b09c	4a		lsr a				lsr 	a
.b09d	4a		lsr a				lsr 	a
.b09e	29 07		and #$07			and		#7
.b0a0	1a		inc a				inc 	a
.b0a1	8d f5 06	sta $06f5			sta 	gxScale
.b0a4	64 38		stz $38				stz 	gxzTemp1					; start first line
.b0a6					_GXGELoop:
.b0a6	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b0a8	2c f6 06	bit $06f6			bit 	gxUseMode 					; check for flip.
.b0ab	10 06		bpl $b0b3			bpl		_GXNoVFlip
.b0ad	ad f2 06	lda $06f2			lda 	gxMask
.b0b0	38		sec				sec
.b0b1	e5 38		sbc $38				sbc 	gxzTemp1
.b0b3					_GXNoVFlip:
.b0b3	aa		tax				tax 								; get the Xth line.
.b0b4	20 f4 b0	jsr $b0f4			jsr 	_GXCallAcquire 				; get that data.
.b0b7	ad f5 06	lda $06f5			lda 	gxScale 					; do scale identical copies of that line.
.b0ba	85 39		sta $39				sta 	gxzTemp1+1
.b0bc					_GXGELoop2:
.b0bc	ad 4e 06	lda $064e			lda 	gxY0 						; off screen
.b0bf	cd 58 06	cmp $0658			cmp 	gxHeight
.b0c2	b0 10		bcs $b0d4			bcs 	_GXDGEExit
.b0c4	20 f7 b0	jsr $b0f7			jsr 	GXRenderOneLine 			; render line
.b0c7	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0c9	d0 f1		bne $b0bc			bne 	_GXGELoop2
.b0cb	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0cd	a5 38		lda $38				lda 	gxzTemp1
.b0cf	cd f1 06	cmp $06f1			cmp 	gxSize
.b0d2	d0 d2		bne $b0a6			bne 	_GXGELoop
.b0d4					_GXDGEExit:
.b0d4	68		pla				pla 								; restore Y for next time
.b0d5	8d 4e 06	sta $064e			sta 	gxY0
.b0d8	ae f5 06	ldx $06f5			ldx 	gxScale 					; get scale (1-8)
.b0db					_GXShiftLeft:
.b0db	18		clc				clc
.b0dc	ad f1 06	lda $06f1			lda 	gxSize
.b0df	6d 4c 06	adc $064c			adc 	gxX0
.b0e2	8d 4c 06	sta $064c			sta 	gxX0
.b0e5	90 03		bcc $b0ea			bcc 	_GXSLNoCarry
.b0e7	ee 4d 06	inc $064d			inc 	gxX0+1
.b0ea					_GXSLNoCarry:
.b0ea	ca		dex				dex
.b0eb	d0 ee		bne $b0db			bne 	_GXShiftLeft
.b0ed	20 2c b3	jsr $b32c			jsr 	GXCloseBitmap
.b0f0	18		clc				clc
.b0f1	60		rts				rts
.b0f2					_GXSLFail:
.b0f2	38		sec				sec
.b0f3	60		rts				rts
.b0f4					_GXCallAcquire:
.b0f4	6c f3 06	jmp ($06f3)			jmp 	(gxAcquireVector)
.b0f7					GXRenderOneLine:
.b0f7	20 34 b3	jsr $b334			jsr 	GXPositionCalc 				; calculate position/offset.
.b0fa	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y contains position.
.b0fd	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b0ff					_GXROLLoop1:
.b0ff	ad f5 06	lda $06f5			lda 	gxScale 					; set to do 'scale' times
.b102	85 3b		sta $3b				sta 	gxzTemp2+1
.b104					_GXROLLoop2:
.b104	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b106	2c 59 06	bit $0659			bit 	gxMode 						; check H Flip
.b109	50 06		bvc $b111			bvc 	_GXNoHFlip
.b10b	ad f2 06	lda $06f2			lda 	gxMask
.b10e	38		sec				sec
.b10f	e5 3a		sbc $3a				sbc 	gxzTemp2
.b111					_GXNoHFlip:
.b111	aa		tax				tax 								; read from the pixel buffer
.b112	bd fa 05	lda $05fa,x			lda 	gxPixelBuffer,x
.b115	d0 07		bne $b11e			bne 	_GXDraw 					; draw if non zero
.b117	ad f6 06	lda $06f6			lda 	gxUseMode 					; check to see if solid background
.b11a	29 04		and #$04			and 	#4
.b11c	f0 0a		beq $b128			beq 	_GXZeroPixel
.b11e					_GXDraw:
.b11e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b120	2d 5c 06	and $065c			and 	gxANDValue
.b123	5d fa 05	eor $05fa,x			eor 	gxPixelBuffer,x
.b126	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b128					_GXZeroPixel:
.b128	c8		iny				iny 								; advance pointer
.b129	d0 05		bne $b130			bne 	_GXNoShift
.b12b	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b12d	20 72 b0	jsr $b072			jsr 	GXDLTCheckWrap				; check for new page.
.b130					_GXNoShift:
.b130	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b132	d0 d0		bne $b104			bne 	_GXROLLoop2
.b134	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b136	a5 3a		lda $3a				lda 	gxzTemp2
.b138	cd f1 06	cmp $06f1			cmp 	gxSize
.b13b	d0 c2		bne $b0ff			bne 	_GXROLLoop1
.b13d	ee 4e 06	inc $064e			inc 	gxY0
.b140	60		rts				rts
.06f1					gxSize:
>06f1							.fill 	1
.06f2					gxMask:
>06f2							.fill 	1
.06f3					gxAcquireVector:
>06f3							.fill 	2
.06f5					gxScale:
>06f5							.fill 	1
.06f6					gxUseMode:
>06f6							.fill 	1
.b141					GXFontHandler:
.b141	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b143	4d 59 06	eor $0659			eor 	gxMode
.b146	8d f6 06	sta $06f6			sta 	gxUseMode
.b149	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b14b	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b14d	26 37		rol $37				rol	 	gxzTemp0+1
.b14f	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b151	26 37		rol $37				rol	 	gxzTemp0+1
.b153	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b155	26 37		rol $37				rol	 	gxzTemp0+1
.b157	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b159	09 c0		ora #$c0			ora 	#$C0
.b15b	85 37		sta $37				sta 	gxzTemp0+1
.b15d	a9 08		lda #$08			lda 	#8 							; size 8x8
.b15f	a2 67		ldx #$67			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b161	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b163	20 7f b0	jsr $b07f			jsr 	GXDrawGraphicElement
.b166	60		rts				rts
.b167					GXGetGraphicDataFont:
.b167	8a		txa				txa 								; X->Y
.b168	a8		tay				tay
.b169	a6 01		ldx $01				ldx 	1 							; preserve old value
.b16b	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b16d	85 01		sta $01				sta 	1
.b16f	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b171	86 01		stx $01				stx 	1 							; put old value back.
.b173	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b175					_GXExpand:
.b175	9e fa 05	stz $05fa,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b178	0a		asl a				asl 	a 							; shift bit 7 into C
.b179	90 08		bcc $b183			bcc 	_GXNoPixel
.b17b	48		pha				pha 								; if set, set pixel buffer to current colour.
.b17c	ad 5a 06	lda $065a			lda 	gxColour
.b17f	9d fa 05	sta $05fa,x			sta 	gxPixelBuffer,x
.b182	68		pla				pla
.b183					_GXNoPixel:
.b183	e8		inx				inx 								; do the whole byte.
.b184	e0 08		cpx #$08			cpx 	#8
.b186	d0 ed		bne $b175			bne 	_GXExpand
.b188	60		rts				rts
.b189					GXSpriteHandler:
.b189	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b18b	4d 59 06	eor $0659			eor 	gxMode
.b18e	8d f6 06	sta $06f6			sta 	gxUseMode
.b191	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b193	da		phx				phx
.b194	20 24 b3	jsr $b324			jsr 	GXOpenBitmap 				; can access sprite information
.b197	68		pla				pla
.b198	20 05 b4	jsr $b405			jsr 	GXFindSprite 				; get the sprite address
.b19b	08		php				php
.b19c	20 2c b3	jsr $b32c			jsr 	GXCloseBitmap
.b19f	28		plp				plp
.b1a0	b0 0a		bcs $b1ac			bcs		_GXSHExit 					; exit if find failed.
.b1a2	ad f7 06	lda $06f7			lda 	GXSizePixels 				; return size
.b1a5	a2 ad		ldx #$ad			ldx 	#GXSpriteAcquire & $FF
.b1a7	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b1a9	20 7f b0	jsr $b07f			jsr 	GXDrawGraphicElement
.b1ac					_GXSHExit:
.b1ac	60		rts				rts
.b1ad					GXSpriteAcquire:
.b1ad	ad 57 06	lda $0657			lda 	GXSpritePage				; point to base page
.b1b0	85 0b		sta $0b				sta 	GXEditSlot
.b1b2	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1b4	a9 00		lda #$00			lda 	#0
.b1b6	ae f8 06	ldx $06f8			ldx 	GXSizeBits
.b1b9					_GXTimesRowNumber:
.b1b9	18		clc				clc
.b1ba	65 36		adc $36				adc 	zTemp0
.b1bc	ca		dex				dex
.b1bd	10 fa		bpl $b1b9			bpl 	_GXTimesRowNumber
.b1bf	64 37		stz $37				stz 	gxzTemp0+1
.b1c1	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1c2	26 37		rol $37				rol 	gxzTemp0+1
.b1c4	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1c5	26 37		rol $37				rol 	gxzTemp0+1
.b1c7	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1c8	26 37		rol $37				rol 	gxzTemp0+1
.b1ca	85 36		sta $36				sta 	gxzTemp0
.b1cc	18		clc				clc 								; add base address.
.b1cd	a5 36		lda $36				lda 	gxzTemp0
.b1cf	6d fa 06	adc $06fa			adc 	GXSpriteOffset
.b1d2	85 36		sta $36				sta 	gxzTemp0
.b1d4	a5 37		lda $37				lda 	gxzTemp0+1
.b1d6	6d fb 06	adc $06fb			adc 	GXSpriteOffset+1
.b1d9					_GXSAFindPage:
.b1d9	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1db	90 06		bcc $b1e3			bcc 	_GXSAFoundPage
.b1dd	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1df	e6 0b		inc $0b				inc 	GXEditSlot
.b1e1	80 f6		bra $b1d9			bra 	_GXSAFindPage
.b1e3					_GXSAFoundPage:
.b1e3	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1e5	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1e7	a0 00		ldy #$00			ldy 	#0
.b1e9					_GXSACopyLoop:
.b1e9	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1eb	99 fa 05	sta $05fa,y			sta 	gxPixelBuffer,y
.b1ee	c8		iny				iny
.b1ef	cc f7 06	cpy $06f7			cpy 	GXSizePixels
.b1f2	d0 f5		bne $b1e9			bne 	_GXSACopyLoop
.b1f4	60		rts				rts
.b1f5					GXSelect:
.b1f5	ad 54 06	lda $0654			lda 	gxSpritesOn
.b1f8	f0 22		beq $b21c			beq 	_GXSFail
.b1fa	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b1fc	c9 40		cmp #$40			cmp 	#64
.b1fe	b0 1c		bcs $b21c			bcs 	_GXSFail
.b200	8d 5f 06	sta $065f			sta 	GSCurrentSpriteID
.b203	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b205	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b207	06 36		asl $36				asl 	gxzTemp0
.b209	06 36		asl $36				asl 	gxzTemp0
.b20b	06 36		asl $36				asl 	gxzTemp0
.b20d	2a		rol a				rol 	a
.b20e	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b210	8d 61 06	sta $0661			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b213	85 37		sta $37				sta 	gxzTemp0+1
.b215	a5 36		lda $36				lda 	gxzTemp0
.b217	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr
.b21a	18		clc				clc
.b21b	60		rts				rts
.b21c					_GXSFail:
.b21c	38		sec				sec
.b21d	60		rts				rts
.b21e					GXSelectImage:
.b21e	ad 54 06	lda $0654			lda 	gxSpritesOn
.b221	f0 74		beq $b297			beq 	_GXSIFail
.b223	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b226	f0 6f		beq $b297			beq 	_GXSIFail 					; (checking the MSB)
.b228	64 01		stz $01				stz 	1
.b22a	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b22c	d0 6b		bne $b299			bne 	_GXSIHide
.b22e	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b230	48		pha				pha
.b231	20 24 b3	jsr $b324			jsr 	GXOpenBitmap
.b234	68		pla				pla
.b235	20 05 b4	jsr $b405			jsr 	GXFindSprite
.b238	b0 5a		bcs $b294			bcs 	_GXSICloseFail 				; no image
.b23a	a0 01		ldy #$01			ldy 	#1
.b23c	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b23f	85 36		sta $36				sta 	gxzTemp0
.b241	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b244	85 37		sta $37				sta 	gxzTemp0+1
.b246	ad fa 06	lda $06fa			lda 	GXSpriteOffset
.b249	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b24b	18		clc				clc
.b24c	ad fb 06	lda $06fb			lda 	GXSpriteOffset+1
.b24f	6d 62 06	adc $0662			adc 	GXSpriteOffsetBase
.b252	c8		iny				iny
.b253	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b255	ad 63 06	lda $0663			lda 	GXSpriteOffsetBase+1
.b258	69 00		adc #$00			adc 	#0
.b25a	c8		iny				iny
.b25b	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b25d	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get raw size
.b260	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b262	2a		rol a				rol 	a 							; x 2
.b263	0a		asl a				asl 	a 							; x 4
.b264	0a		asl a				asl 	a 							; x 8
.b265	0a		asl a				asl 	a 							; x 16
.b266	0d f9 06	ora $06f9			ora 	GXSpriteLUT 				; Or with LUT
.b269	0a		asl a				asl 	a 							; 1 shift
.b26a	09 01		ora #$01			ora 	#1 							; enable sprite.
.b26c	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b26e	20 2c b3	jsr $b32c			jsr 	GXCloseBitmap
.b271	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b274	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b277	29 3f		and #$3f			and 	#$3F
.b279	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b27c	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get bit size
.b27f	6a		ror a				ror 	a 							; shift into bits 6/7
.b280	6a		ror a				ror 	a
.b281	6a		ror a				ror 	a
.b282	29 c0		and #$c0			and 	#$C0
.b284	1d a4 06	ora $06a4,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b287	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b28a	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b28d	29 7f		and #$7f			and 	#$7F
.b28f	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b292	18		clc				clc
.b293	60		rts				rts
.b294					_GXSICloseFail:
.b294	20 2c b3	jsr $b32c			jsr 	GXCloseBitmap
.b297					_GXSIFail:
.b297	38		sec				sec
.b298	60		rts				rts
.b299					_GXSIHide:
.b299	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b29c	85 36		sta $36				sta 	gxzTemp0
.b29e	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b2a1	85 37		sta $37				sta 	gxzTemp0+1
.b2a3	a9 00		lda #$00			lda 	#0
.b2a5	92 36		sta ($36)			sta 	(gxzTemp0)
.b2a7	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get sprite ID
.b2aa	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2ad	09 80		ora #$80			ora 	#$80
.b2af	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b2b2	18		clc				clc
.b2b3	60		rts				rts
.b2b4					GXMoveSprite:
.b2b4	ad 54 06	lda $0654			lda 	gxSpritesOn
.b2b7	f0 65		beq $b31e			beq 	_GXSIFail
.b2b9	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2bc	f0 60		beq $b31e			beq 	_GXSIFail
.b2be	85 37		sta $37				sta 	gxzTemp0+1
.b2c0	a0 04		ldy #$04			ldy 	#4
.b2c2	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b2c5	85 36		sta $36				sta 	gxzTemp0
.b2c7	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2ca	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b2cd	2a		rol a				rol 	a	 						; into bits 0,1.
.b2ce	2a		rol a				rol 	a
.b2cf	2a		rol a				rol 	a
.b2d0	29 03		and #$03			and 	#3
.b2d2	aa		tax				tax
.b2d3	bd 20 b3	lda $b320,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2d6	48		pha				pha
.b2d7	18		clc				clc
.b2d8	6d 4c 06	adc $064c			adc 	gxX0						; copy position.
.b2db	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2dd	c8		iny				iny
.b2de	ad 4d 06	lda $064d			lda 	gxX0+1
.b2e1	69 00		adc #$00			adc 	#0
.b2e3	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e5	c8		iny				iny
.b2e6	68		pla				pla
.b2e7	18		clc				clc
.b2e8	6d 4e 06	adc $064e			adc 	gxY0
.b2eb	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2ed	a9 00		lda #$00			lda 	#0
.b2ef	69 00		adc #$00			adc 	#0
.b2f1	c8		iny				iny
.b2f2	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f4	4e 4d 06	lsr $064d			lsr 	gxX0+1 						; divide X by 4
.b2f7	6e 4c 06	ror $064c			ror 	gxX0
.b2fa	4e 4c 06	lsr $064c			lsr 	gxX0
.b2fd	4e 4e 06	lsr $064e			lsr 	gxY0 						; divide Y by 4
.b300	4e 4e 06	lsr $064e			lsr 	gxY0
.b303	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b306	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x
.b309	29 80		and #$80			and 	#$80
.b30b	0d 4c 06	ora $064c			ora 	gxX0
.b30e	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b311	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b314	29 c0		and #$c0			and 	#$C0
.b316	0d 4e 06	ora $064e			ora 	gxY0
.b319	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b31c	18		clc				clc
.b31d	60		rts				rts
.b31e					_GXSIFail:
.b31e	38		sec				sec
.b31f	60		rts				rts
.b320					_GXMSOffset:
>b320	1c						.byte 	32-8/2
>b321	18						.byte 	32-16/2
>b322	14						.byte 	32-24/2
>b323	10						.byte 	32-32/2
.b324					GXOpenBitmap:
.b324	78		sei				sei 								; no interrupts here
.b325	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b327	8d 5d 06	sta $065d			sta 	gxOriginalLUTValue
.b32a	58		cli				cli
.b32b	60		rts				rts
.b32c					GXCloseBitmap:
.b32c	78		sei				sei
.b32d	ad 5d 06	lda $065d			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b330	85 0b		sta $0b				sta 	GXEditSlot
.b332	58		cli				cli
.b333	60		rts				rts
.b334					GXPositionCalc:
.b334	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b336	48		pha				pha
.b337	ad 4e 06	lda $064e			lda 	GXY0 						; gxzScreen = Y0
.b33a	85 3c		sta $3c				sta 	gxzScreen
.b33c	64 3d		stz $3d				stz 	gxzScreen+1
.b33e	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b340	26 3d		rol $3d				rol 	gxzScreen+1
.b342	06 3c		asl $3c				asl 	gxzScreen
.b344	26 3d		rol $3d				rol 	gxzScreen+1
.b346	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b347	65 3c		adc $3c				adc 	gxzScreen
.b349	85 3c		sta $3c				sta 	gxzScreen
.b34b	90 02		bcc $b34f			bcc 	_GXPCNoCarry
.b34d	e6 3d		inc $3d				inc 	gxzScreen+1
.b34f					_GXPCNoCarry:
.b34f	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b351	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b353	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b355	85 36		sta $36				sta 	gxzTemp0
.b357	64 3d		stz $3d				stz 	gxzScreen+1
.b359	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b35b					_GXPCMultiply32:
.b35b	06 3c		asl $3c				asl 	gxzScreen
.b35d	26 3d		rol $3d				rol 	gxzScreen+1
.b35f	3a		dec a				dec 	a
.b360	d0 f9		bne $b35b			bne 	_GXPCMultiply32
.b362	18		clc				clc
.b363	ad 4c 06	lda $064c			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b366	65 3c		adc $3c				adc 	gxzScreen
.b368	8d 5e 06	sta $065e			sta 	gsOffset
.b36b	ad 4d 06	lda $064d			lda 	GXX0+1
.b36e	65 3d		adc $3d				adc 	gxzScreen+1
.b370	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b372	90 04		bcc $b378			bcc 	_GXPCNoOverflow
.b374	29 1f		and #$1f			and 	#$1F 						; fix it up
.b376	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b378					_GXPCNoOverflow:
.b378	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b37a	85 3d		sta $3d				sta 	gxzScreen+1
.b37c	64 3c		stz $3c				stz 	gxzScreen
.b37e	18		clc				clc
.b37f	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b381	6d 56 06	adc $0656			adc 	gxBasePage 					; by adding the base page
.b384	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b386	68		pla				pla
.b387	85 36		sta $36				sta 	gxzTemp0
.b389	60		rts				rts
.b38a					GXMovePositionDown:
.b38a	18		clc				clc 								; add 320 to offset/temp+1
.b38b	ad 5e 06	lda $065e			lda 	gsOffset
.b38e	69 40		adc #$40			adc 	#64
.b390	8d 5e 06	sta $065e			sta 	gsOffset
.b393	a5 3d		lda $3d				lda 	gxzScreen+1
.b395	69 01		adc #$01			adc 	#1
.b397	85 3d		sta $3d				sta 	gxzScreen+1
.b399	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b39b	90 07		bcc $b3a4			bcc 	_GXMPDExit
.b39d	38		sec				sec  								; next page
.b39e	e9 20		sbc #$20			sbc 	#$20
.b3a0	85 3d		sta $3d				sta 	gxzScreen+1
.b3a2	e6 0b		inc $0b				inc 	GXEditSlot
.b3a4					_GXMPDExit:
.b3a4	60		rts				rts
.b3a5					GXCollide:
.b3a5	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b3a7	aa		tax				tax
.b3a8	05 37		ora $37				ora 	gxzTemp0+1
.b3aa	29 c0		and #$c0			and 	#$C0
.b3ac	38		sec				sec
.b3ad	d0 53		bne $b402			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3af	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3b1	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3b4	1d 64 06	ora $0664,x			ora 	GXSpriteLow,x
.b3b7	30 48		bmi $b401			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3b9	18		clc				clc 								; need to calculate sum of sizes.
.b3ba	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y
.b3bd	7d a4 06	adc $06a4,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3c0	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3c2	6a		ror a				ror 	a 							; 5/6/7
.b3c3	4a		lsr a				lsr 	a 							; 4/5/6
.b3c4	4a		lsr a				lsr 	a 							; 3/4/5
.b3c5	4a		lsr a				lsr 	a 							; 2/3/4
.b3c6	18		clc				clc
.b3c7	69 08		adc #$08			adc 	#$08
.b3c9	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3ca	4a		lsr a				lsr 	a
.b3cb	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3cd	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3d0	29 3f		and #$3f			and 	#$3F
.b3d2	85 39		sta $39				sta 	gxzTemp1+1
.b3d4	38		sec				sec
.b3d5	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b3d8	29 3f		and #$3f			and 	#$3F
.b3da	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3dc	b0 03		bcs $b3e1			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3de	49 ff		eor #$ff			eor 	#$FF
.b3e0	1a		inc a				inc 	a
.b3e1					_GXCAbs1:
.b3e1	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3e3	b0 1c		bcs $b401			bcs 	_GXOkayFail
.b3e5	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3e7	38		sec				sec 								; calculate |x1-x0|
.b3e8	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y
.b3eb	fd 64 06	sbc $0664,x			sbc 	GXSpriteLow,x
.b3ee	b0 03		bcs $b3f3			bcs 	_GXCAbs2
.b3f0	49 ff		eor #$ff			eor 	#$FF
.b3f2	1a		inc a				inc 	a
.b3f3					_GXCAbs2:
.b3f3	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3f5	b0 0a		bcs $b401			bcs 	_GXOkayFail
.b3f7	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b3f9	90 02		bcc $b3fd			bcc 	_GXCHaveLowest
.b3fb	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b3fd					_GXCHaveLowest:
.b3fd	0a		asl a				asl 	a 							; scale to allow for >> 2
.b3fe	0a		asl a				asl 	a
.b3ff	18		clc				clc
.b400	60		rts				rts
.b401					_GXOkayFail:
.b401	18		clc				clc
.b402					_GXCollideFail:
.b402	a9 ff		lda #$ff			lda 	#$FF
.b404	60		rts				rts
.b405					GXFindSprite:
.b405	aa		tax				tax
.b406	ad 57 06	lda $0657			lda 	GXSpritePage 				; access the base page of the sprite
.b409	85 0b		sta $0b				sta 	GXEditSlot
.b40b	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b40e	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b411	f0 33		beq $b446			beq 	_GXFSFail
.b413	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b416	8d fb 06	sta $06fb			sta 	GXSpriteOffset+1
.b419	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b41c	48		pha				pha 								; save twice
.b41d	48		pha				pha
.b41e	29 03		and #$03			and 	#3 							; get sprite size
.b420	8d f8 06	sta $06f8			sta 	GXSizeBits 					; save raw (0-3)
.b423	aa		tax				tax
.b424	bd 48 b4	lda $b448,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b427	8d f7 06	sta $06f7			sta 	GXSizePixels 					; save (8/16/24/32)
.b42a	68		pla				pla 								; get LUT
.b42b	4a		lsr a				lsr		a
.b42c	4a		lsr a				lsr		a
.b42d	29 03		and #$03			and 	#3
.b42f	8d f9 06	sta $06f9			sta 	GXSpriteLUT
.b432	68		pla				pla 								; address, neeeds to be x 4
.b433	29 f0		and #$f0			and 	#$F0
.b435	8d fa 06	sta $06fa			sta 	GXSpriteOffset
.b438	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b43b	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b43e	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b441	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b444	18		clc				clc
.b445	60		rts				rts
.b446					_GXFSFail:
.b446	38		sec				sec
.b447	60		rts				rts
.b448					_GXFXSSTTable:
>b448	08 10 18 20					.byte 	8,16,24,32
.06f7					GXSizePixels:
>06f7							.fill 	1
.06f8					GXSizeBits:
>06f8							.fill 	1
.06f9					GXSpriteLUT:
>06f9							.fill 	1
.06fa					GXSpriteOffset:
>06fa							.fill 	2
.b44c					GXSortXY:
.b44c	20 6a b4	jsr $b46a			jsr 	GXSortY 					; will be sorted on Y now
.b44f	ad 4c 06	lda $064c			lda 	gxX0 						; compare X0 v X1
.b452	cd 50 06	cmp $0650			cmp 	gxX1
.b455	ad 4d 06	lda $064d			lda 	gXX0+1
.b458	ed 51 06	sbc $0651			sbc 	gXX1+1
.b45b	90 0c		bcc $b469			bcc 	_GXSXYExit 					; X0 < X1 exit
.b45d	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b45f	a0 04		ldy #$04			ldy 	#4
.b461	20 7e b4	jsr $b47e			jsr 	GXSwapXY
.b464	e8		inx				inx
.b465	c8		iny				iny
.b466	20 7e b4	jsr $b47e			jsr 	GXSwapXY
.b469					_GXSXYExit:
.b469	60		rts				rts
.b46a					GXSortY:
.b46a	ad 4e 06	lda $064e			lda 	gxY0 						; if Y0 >= Y1
.b46d	cd 52 06	cmp $0652			cmp 	gxY1
.b470	90 0b		bcc $b47d			bcc 	_GXSYSorted
.b472	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b474	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b476					_GXSwap1:
.b476	20 7e b4	jsr $b47e			jsr 	GXSwapXY
.b479	88		dey				dey
.b47a	ca		dex				dex
.b47b	10 f9		bpl $b476			bpl 	_GXSwap1
.b47d					_GXSYSorted:
.b47d	60		rts				rts
.b47e					GXSwapXY:
.b47e	bd 4c 06	lda $064c,x			lda 	gxX0,x
.b481	48		pha				pha
.b482	b9 4c 06	lda $064c,y			lda 	gxX0,y
.b485	9d 4c 06	sta $064c,x			sta 	gxX0,x
.b488	68		pla				pla
.b489	99 4c 06	sta $064c,y			sta 	gxX0,y
.b48c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.bb02					KeywordSet0:
>bb02	00 65					.text	0,$65,""               ; $80 !0:EOF
>bb04	00 58					.text	0,$58,""               ; $81 !1:SH1
>bb06	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bb08	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>bb0e	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>bb16	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>bb1c	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>bb23	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>bb2b	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>bb32	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>bb39	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>bb3f	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>bb45	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>bb4d	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>bb54	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>bb5b	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>bb62	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>bb6a	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>bb70	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>bb76	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>bb7d	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bb83	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bb89	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bb91	47 28
>bb93	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>bb9b	28
>bb9c	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>bba4	28
>bba5	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bbab	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bbb1	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>bbb7	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>bbbe	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>bbc6	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bbcc	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bbd2	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bbd7	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bbdb	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bbe1	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bbe9	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bbf0	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bbf7	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bbff	43
>bc00	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bc06	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bc0c	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bc13	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bc19	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bc1d	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bc23	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bc2b	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bc32	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bc37	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bc3e	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bc46	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bc4c	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bc51	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bc59	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bc5f	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bc65	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bc6a	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bc71	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bc77	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bc7d	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bc84	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>bc8b	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>bc90	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>bc96	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>bc9d	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>bca2	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>bca6	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>bcae	45
>bcaf	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>bcb7	45
>bcb8	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>bcbe	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>bcc5	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>bccb	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>bcd1	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>bcd6	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bcde	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>bce5	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bcec	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>bcf4	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bcfa	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bcfe	ff					.text	$FF
.bcff					KeywordSet1:
>bcff	00 65					.text	0,$65,""               ; $80 !0:EOF
>bd01	00 58					.text	0,$58,""               ; $81 !1:SH1
>bd03	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bd05	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bd0d	4c 45
>bd0f	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bd17	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bd1f	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bd24	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>bd28	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>bd2e	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>bd34	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>bd39	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>bd41	45
>bd42	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>bd47	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>bd4f	53
>bd50	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>bd56	ff					.text	$FF
.bd57					KeywordSet2:
>bd57	00 65					.text	0,$65,""               ; $80 !0:EOF
>bd59	00 58					.text	0,$58,""               ; $81 !1:SH1
>bd5b	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bd5d	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bd62	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bd67	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bd6c	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bd71	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bd76	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bd7b	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bd80	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bd85	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bd8a	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bd8f	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bd94	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bd99	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bd9e	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bda3	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bda8	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bdad	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bdb2	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bdb7	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bdbc	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bdc1	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bdc6	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bdcb	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bdd0	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bdd5	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bdda	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bddf	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bde4	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bde9	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bdee	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bdf3	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bdf8	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bdfd	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>be02	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>be07	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>be0c	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>be11	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>be16	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>be1b	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>be20	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>be25	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>be2a	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>be2f	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>be34	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>be39	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>be3e	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>be43	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>be48	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>be4d	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>be52	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>be57	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>be5c	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>be61	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>be66	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>be6b	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>be70	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>be75	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>be7a	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>be7f	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>be84	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>be89	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>be8e	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>be93	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>be98	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>be9d	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bea2	ff					.text	$FF
.b48d					ListConvertLine:
.b48d	48		pha				pha 								; save indent on the stack
.b48e	9c 9d 04	stz $049d			stz 	tbOffset
.b491	9c ac 04	stz $04ac			stz 	tokenBuffer
.b494	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b496	b1 30		lda ($30),y			lda 	(codePtr),y
.b498	aa		tax				tax
.b499	88		dey				dey
.b49a	b1 30		lda ($30),y			lda 	(codePtr),y
.b49c	20 1d 93	jsr $931d			jsr 	LCLConvertInt16
.b49f	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b4a1	86 37		stx $37				stx 	zTemp0+1
.b4a3	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b4a5	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b4a8	a0 00		ldy #$00			ldy 	#0
.b4aa					_LCCopyNumber:
.b4aa	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4ac	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b4af	c8		iny				iny
.b4b0	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4b2	d0 f6		bne $b4aa			bne 	_LCCopyNumber
.b4b4	68		pla				pla 								; adjustment to indent
.b4b5	48		pha				pha 								; save on stack
.b4b6	10 0c		bpl $b4c4			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b4b8	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b4b9	6d a6 04	adc $04a6			adc 	listIndent
.b4bc	8d a6 04	sta $04a6			sta 	listIndent
.b4bf	10 03		bpl $b4c4			bpl 	_LCNoAdjust
.b4c1	9c a6 04	stz $04a6			stz 	listIndent
.b4c4					_LCNoAdjust:
.b4c4	18		clc				clc		 							; work out actual indent.
.b4c5	ad a6 04	lda $04a6			lda 	listIndent
.b4c8	0a		asl a				asl 	a
.b4c9	69 06		adc #$06			adc 	#6
.b4cb	85 36		sta $36				sta 	zTemp0
.b4cd					_LCPadOut:
.b4cd	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b4cf	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b4d2	ad 9d 04	lda $049d			lda 	tbOffset
.b4d5	c5 36		cmp $36				cmp 	zTemp0
.b4d7	d0 f4		bne $b4cd			bne 	_LCPadOut
.b4d9	a0 03		ldy #$03			ldy 	#3 							; start position.
.b4db					_LCMainLoop:
.b4db	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b4dd	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b4e0	b1 30		lda ($30),y			lda 	(codePtr),y
.b4e2	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b4e4	f0 17		beq $b4fd			beq 	_LCExit
.b4e6	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b4e8	90 1e		bcc $b508			bcc 	_LCDoubles
.b4ea	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b4ec	90 2a		bcc $b518			bcc 	_LCShiftPunc
.b4ee	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b4f0	90 35		bcc $b527			bcc 	_LCPunctuation
.b4f2	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b4f4	90 3e		bcc $b534			bcc 	_LCIdentifiers
.b4f6	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b4f8	90 5f		bcc $b559			bcc 	_LCTokens
.b4fa	4c b9 b5	jmp $b5b9			jmp 	_LCData 					; 254-5 are data objects
.b4fd					_LCExit:
.b4fd	68		pla				pla 								; get old indent adjust
.b4fe	30 07		bmi $b507			bmi 	_LCExit2
.b500	18		clc				clc 								; add to indent if +ve
.b501	6d a6 04	adc $04a6			adc 	listIndent
.b504	8d a6 04	sta $04a6			sta 	listIndent
.b507					_LCExit2:
.b507	60		rts				rts
.b508					_LCDoubles:
.b508	48		pha				pha
.b509	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b50a	29 02		and #$02			and 	#2
.b50c	09 3c		ora #$3c			ora 	#60 						; make < >
.b50e	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b511	68		pla				pla 								; restore, do lower bit
.b512	29 03		and #$03			and 	#3
.b514	09 3c		ora #$3c			ora 	#60
.b516	80 0f		bra $b527			bra		_LCPunctuation 				; print, increment, loop
.b518					_LCShiftPunc:
.b518	aa		tax				tax 								; save in X
.b519	29 07		and #$07			and 	#7 							; lower 3 bits
.b51b	f0 02		beq $b51f			beq 	_LCNoAdd
.b51d	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b51f					_LCNoAdd:
.b51f	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b521	90 02		bcc $b525			bcc 	_LCNoAdd2
.b523	09 20		ora #$20			ora 	#32 						; adds $20
.b525					_LCNoAdd2:
.b525	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b527					_LCPunctuation:
.b527	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b529	d0 03		bne $b52e			bne 	_LCPContinue
.b52b	20 00 b6	jsr $b600			jsr 	LCLDeleteLastSpace
.b52e					_LCPContinue:
.b52e	c8		iny				iny 								; consume character
.b52f	20 ea b5	jsr $b5ea			jsr 	LCLWrite 					; write it out.
.b532	80 a7		bra $b4db			bra 	_LCMainLoop 				; go round again.
.b534					_LCIdentifiers:
.b534	18		clc				clc 								; convert to physical address
.b535	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b537	85 37		sta $37				sta 	zTemp0+1
.b539	c8		iny				iny
.b53a	b1 30		lda ($30),y			lda 	(codePtr),y
.b53c	85 36		sta $36				sta 	zTemp0
.b53e	c8		iny				iny
.b53f	5a		phy				phy 								; save position
.b540	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b542	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b545	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b547					_LCOutIdentifier:
.b547	c8		iny				iny
.b548	b1 36		lda ($36),y			lda 	(zTemp0),y
.b54a	29 7f		and #$7f			and 	#$7F
.b54c	20 3c b6	jsr $b63c			jsr 	LCLLowerCase
.b54f	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b552	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b554	10 f1		bpl $b547			bpl 	_LCOutIdentifier
.b556	7a		ply				ply 								; restore position
.b557	80 82		bra $b4db			bra 	_LCMainLoop
.b559					_LCTokens:
.b559	aa		tax				tax 								; token in X
.b55a	a9 57		lda #$57			lda 	#((KeywordSet2) & $FF)
.b55c	85 36		sta $36				sta 	0+zTemp0
.b55e	a9 bd		lda #$bd			lda 	#((KeywordSet2) >> 8)
.b560	85 37		sta $37				sta 	1+zTemp0
.b562	e0 82		cpx #$82			cpx 	#$82
.b564	f0 16		beq $b57c			beq 	_LCUseShift
.b566	a9 ff		lda #$ff			lda 	#((KeywordSet1) & $FF)
.b568	85 36		sta $36				sta 	0+zTemp0
.b56a	a9 bc		lda #$bc			lda 	#((KeywordSet1) >> 8)
.b56c	85 37		sta $37				sta 	1+zTemp0
.b56e	e0 81		cpx #$81			cpx 	#$81
.b570	f0 0a		beq $b57c			beq 	_LCUseShift
.b572	a9 02		lda #$02			lda 	#((KeywordSet0) & $FF)
.b574	85 36		sta $36				sta 	0+zTemp0
.b576	a9 bb		lda #$bb			lda 	#((KeywordSet0) >> 8)
.b578	85 37		sta $37				sta 	1+zTemp0
.b57a	80 01		bra $b57d			bra 	_LCNoShift
.b57c					_LCUseShift:
.b57c	c8		iny				iny
.b57d					_LCNoShift:
.b57d	20 14 b6	jsr $b614			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b580	b1 30		lda ($30),y			lda 	(codePtr),y
.b582	aa		tax				tax 								; into X
.b583					_LCFindText:
.b583	ca		dex				dex
.b584	10 0e		bpl $b594			bpl 	_LCFoundText 				; found text.
.b586	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b588	1a		inc a				inc 	a 							; one extra for size
.b589	38		sec				sec 								; one extra for checksum
.b58a	65 36		adc $36				adc 	zTemp0 						; go to next token
.b58c	85 36		sta $36				sta 	zTemp0
.b58e	90 f3		bcc $b583			bcc 	_LCFindText
.b590	e6 37		inc $37				inc 	zTemp0+1
.b592	80 ef		bra $b583			bra 	_LCFindText
.b594					_LCFoundText:
.b594	5a		phy				phy 								; save List position
.b595	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b597	aa		tax				tax
.b598	a9 83		lda #$83			lda 	#CLIToken+$80
.b59a	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b59d	a0 02		ldy #$02			ldy 	#2
.b59f					_LCCopyToken:
.b59f	b1 36		lda ($36),y			lda 	(zTemp0),y
.b5a1	20 3c b6	jsr $b63c			jsr 	LCLLowerCase
.b5a4	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b5a7	c8		iny				iny
.b5a8	ca		dex				dex
.b5a9	d0 f4		bne $b59f			bne 	_LCCopyToken
.b5ab	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b5ad	f0 05		beq $b5b4			beq 	_LCNoSpace
.b5af	a9 20		lda #$20			lda 	#' '
.b5b1	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b5b4					_LCNoSpace:
.b5b4	7a		ply				ply 								; restore position.
.b5b5	c8		iny				iny 								; consume token
.b5b6	4c db b4	jmp $b4db			jmp 	_LCMainLoop 				; and go around again.
.b5b9					_LCData:
.b5b9	48		pha				pha 								; save type $FE/$FF
.b5ba	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b5bc	c9 fe		cmp #$fe			cmp 	#$FE
.b5be	f0 07		beq $b5c7			beq 	_LCHaveOpener
.b5c0	a2 22		ldx #$22			ldx 	#'"'
.b5c2	a9 81		lda #$81			lda 	#CLIData+$80
.b5c4	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b5c7					_LCHaveOpener:
.b5c7	8a		txa				txa 								; output prefix (# or ")
.b5c8	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b5cb	c8		iny				iny 								; get count
.b5cc	b1 30		lda ($30),y			lda 	(codePtr),y
.b5ce	aa		tax				tax
.b5cf	c8		iny				iny 								; point at first character
.b5d0					_LCOutData:
.b5d0	b1 30		lda ($30),y			lda 	(codePtr),y
.b5d2	c9 00		cmp #$00			cmp 	#0
.b5d4	f0 03		beq $b5d9			beq 	_LCNoPrint
.b5d6	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b5d9					_LCNoPrint:
.b5d9	c8		iny				iny
.b5da	ca		dex				dex
.b5db	d0 f3		bne $b5d0			bne 	_LCOutData
.b5dd	68		pla				pla 								; closing " required ?
.b5de	c9 ff		cmp #$ff			cmp 	#$FF
.b5e0	d0 05		bne $b5e7			bne 	_LCNoQuote
.b5e2	a9 22		lda #$22			lda 	#'"'
.b5e4	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b5e7					_LCNoQuote:
.b5e7	4c db b4	jmp $b4db			jmp 	_LCMainLoop
.b5ea					LCLWrite:
.b5ea	da		phx				phx
.b5eb	ae 9d 04	ldx $049d			ldx 	tbOffset
.b5ee	9d ac 04	sta $04ac,x			sta 	tokenBuffer,x
.b5f1	9e ad 04	stz $04ad,x			stz 	tokenBuffer+1,x
.b5f4	ee 9d 04	inc $049d			inc 	tbOffset
.b5f7	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b5f9	30 03		bmi $b5fe			bmi 	_LCLNoColour
.b5fb	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b5fe					_LCLNoColour:
.b5fe	fa		plx				plx
.b5ff	60		rts				rts
.b600					LCLDeleteLastSpace:
.b600	48		pha				pha
.b601	da		phx				phx
.b602	ae 9d 04	ldx $049d			ldx 	tbOffset
.b605	f0 0a		beq $b611			beq 	_LCDLSExit
.b607	bd ab 04	lda $04ab,x			lda 	tokenBuffer-1,x
.b60a	c9 20		cmp #$20			cmp 	#' '
.b60c	d0 03		bne $b611			bne 	_LCDLSExit
.b60e	ce 9d 04	dec $049d			dec 	tbOffset
.b611					_LCDLSExit:
.b611	fa		plx				plx
.b612	68		pla				pla
.b613	60		rts				rts
.b614					LCLCheckSpaceRequired:
.b614	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b617	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b619	f0 1b		beq $b636			beq 	_LCCSRSpace
.b61b	c9 29		cmp #$29			cmp 	#')'
.b61d	f0 17		beq $b636			beq 	_LCCSRSpace
.b61f	c9 23		cmp #$23			cmp 	#'#'
.b621	f0 13		beq $b636			beq 	_LCCSRSpace
.b623	20 3c b6	jsr $b63c			jsr 	LCLLowerCase 				; saves a little effort
.b626	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b628	90 11		bcc $b63b			bcc 	_LCCSRExit
.b62a	c9 3a		cmp #$3a			cmp 	#"9"+1
.b62c	90 08		bcc $b636			bcc 	_LCCSRSpace
.b62e	c9 61		cmp #$61			cmp 	#"a"
.b630	90 09		bcc $b63b			bcc 	_LCCSRExit
.b632	c9 7b		cmp #$7b			cmp 	#"z"+1
.b634	b0 05		bcs $b63b			bcs 	_LCCSRExit
.b636					_LCCSRSpace:
.b636	a9 20		lda #$20			lda 	#' '
.b638	20 ea b5	jsr $b5ea			jsr 	LCLWrite
.b63b					_LCCSRExit:
.b63b	60		rts				rts
.b63c					LCLLowerCase:
.b63c	c9 41		cmp #$41			cmp 	#"A"
.b63e	90 06		bcc $b646			bcc 	_LCLLCOut
.b640	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b642	b0 02		bcs $b646			bcs 	_LCLLCOut
.b644	69 20		adc #$20			adc 	#$20
.b646					_LCLLCOut:
.b646	60		rts				rts
.b647					LCLUpperCase:
.b647	c9 61		cmp #$61			cmp 	#"a"
.b649	90 06		bcc $b651			bcc 	_LCLUCOut
.b64b	c9 7b		cmp #$7b			cmp 	#"z"+1
.b64d	b0 02		bcs $b651			bcs 	_LCLUCOut
.b64f	e9 1f		sbc #$1f			sbc 	#$1F
.b651					_LCLUCOut:
.b651	60		rts				rts
.b652					TOKSearchTable:
.b652	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b654	85 36		sta $36				sta 	zTemp0
.b656	a0 00		ldy #$00			ldy 	#0
.b658	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b65a	85 38		sta $38				sta 	zTemp1
.b65c					_TSTLoop:
.b65c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b65e	30 49		bmi $b6a9			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b660	f0 2e		beq $b690			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b662	c8		iny				iny 								; get the hash
.b663	b1 36		lda ($36),y			lda 	(zTemp0),y
.b665	88		dey				dey
.b666	cd 83 04	cmp $0483			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b669	d0 25		bne $b690			bne 	_TSTNext
.b66b	ad 82 04	lda $0482			lda 	identTypeEnd 				; get length of identifier from end-start
.b66e	38		sec				sec
.b66f	ed 80 04	sbc $0480			sbc 	identStart
.b672	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b674	d0 1a		bne $b690			bne 	_TSTNext
.b676	5a		phy				phy 								; save Y , we might fail to match.
.b677	c8		iny				iny 								; point to text
.b678	c8		iny				iny
.b679	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b67c					_TSTCompareName:
.b67c	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; compare text.
.b67f	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b681	d0 0c		bne $b68f			bne 	_TSTNextPullY 				; fail, pullY and do next
.b683	e8		inx				inx
.b684	c8		iny				iny
.b685	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b688	d0 f2		bne $b67c			bne 	_TSTCompareName
.b68a	7a		ply				ply 								; throw Y
.b68b	a5 38		lda $38				lda 	zTemp1 						; get token #
.b68d	38		sec				sec 								; return with CS = passed.
.b68e	60		rts				rts
.b68f					_TSTNextPullY:
.b68f	7a		ply				ply 								; restore current, fall through.
.b690					_TSTNext:
.b690	e6 38		inc $38				inc 	zTemp1 						; token counter
.b692	98		tya				tya
.b693	18		clc				clc
.b694	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b696	1a		inc a				inc 	a 							; +1
.b697	1a		inc a				inc 	a 							; +2
.b698	a8		tay				tay
.b699	10 c1		bpl $b65c			bpl 	_TSTLoop 					; if Y < $80 loop back
.b69b	98		tya				tya 								; add Y to zTemp0 and reset Y
.b69c	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b69e	18		clc				clc  								; but have tables > 255 bytes
.b69f	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b6a1	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b6a3	90 b7		bcc $b65c			bcc 	_TSTLoop
.b6a5	e6 37		inc $37				inc 	zTemp0+1
.b6a7	80 b3		bra $b65c			bra 	_TSTLoop
.b6a9					_TSTFail:
.b6a9	18		clc				clc
.b6aa	60		rts				rts
.b6ab					TokeniseLine:
.b6ab	20 33 b8	jsr $b833			jsr 	LCLFixLineBufferCase 		; fix line case
.b6ae	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b6b0	8d a9 04	sta $04a9			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b6b3	9c aa 04	stz $04aa			stz 	tokenLineNumber
.b6b6	9c ab 04	stz $04ab			stz 	tokenLineNumber+1
.b6b9	a2 ff		ldx #$ff			ldx 	#$FF
.b6bb					_TKFindFirst:
.b6bb	e8		inx				inx
.b6bc	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b6bf	f0 79		beq $b73a			beq 	_TKExit
.b6c1	c9 20		cmp #$20			cmp 	#' '
.b6c3	90 f6		bcc $b6bb			bcc 	_TKFindFirst
.b6c5	c9 30		cmp #$30			cmp 	#'0'
.b6c7	90 07		bcc $b6d0			bcc 	_TKNoLineNumber
.b6c9	c9 3a		cmp #$3a			cmp 	#'9'+1
.b6cb	b0 03		bcs $b6d0			bcs 	_TKNoLineNumber
.b6cd	20 5d b8	jsr $b85d			jsr 	TOKExtractLineNumber
.b6d0					_TKNoLineNumber:
.b6d0					_TKTokeniseLoop:
.b6d0	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b6d3	f0 65		beq $b73a			beq 	_TKExit
.b6d5	e8		inx				inx
.b6d6	c9 20		cmp #$20			cmp 	#' '
.b6d8	f0 f6		beq $b6d0			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b6da	ca		dex				dex 								; undo last get, A contains character, X is position.
.b6db	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b6dd	f0 61		beq $b740			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.b6df	c9 41		cmp #$41			cmp 	#'A'
.b6e1	90 04		bcc $b6e7			bcc 	_TKTokenisePunctuation
.b6e3	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b6e5	90 59		bcc $b740			bcc 	_TKTokeniseIdentifier
.b6e7					_TKTokenisePunctuation:
.b6e7	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b6e9	f0 27		beq $b712			beq 	_TKString
.b6eb	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.b6ed	f0 28		beq $b717			beq 	_TKHexConstant
.b6ef	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.b6f1	f0 29		beq $b71c			beq 	_TKCheckDouble
.b6f3	c9 3e		cmp #$3e			cmp 	#'>'
.b6f5	f0 25		beq $b71c			beq 	_TKCheckDouble
.b6f7					_TKStandardPunctuation:
.b6f7	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get the punctuation token back.
.b6fa	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b6fc	90 0e		bcc $b70c			bcc 	_TKNoShift
.b6fe	48		pha				pha 								; save. we are about to convert this punctuation token from
.b6ff	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b701	85 36		sta $36				sta 	zTemp0
.b703	68		pla				pla
.b704	29 20		and #$20			and 	#32 						; bit 5
.b706	4a		lsr a				lsr 	a 							; shift into bit 3
.b707	4a		lsr a				lsr 	a
.b708	05 36		ora $36				ora 	zTemp0
.b70a	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b70c					_TKNoShift:
.b70c	20 a2 b8	jsr $b8a2			jsr 	TOKWriteByte 				; write the punctuation character
.b70f	e8		inx				inx 								; consume the character
.b710	80 be		bra $b6d0			bra 	_TKTokeniseLoop 			; and loop round again.
.b712					_TKString:
.b712	20 c2 b7	jsr $b7c2			jsr 	TOKTokenString
.b715	80 b9		bra $b6d0			bra 	_TKTokeniseLoop
.b717					_TKHexConstant:
.b717	20 fd b7	jsr $b7fd			jsr 	TOKHexConstant
.b71a	80 b4		bra $b6d0			bra 	_TKTokeniseLoop
.b71c					_TKCheckDouble:
.b71c	bd aa 05	lda $05aa,x			lda 	lineBuffer+1,x 				; get next character
.b71f	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b721	90 d4		bcc $b6f7			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.b723	c9 3f		cmp #$3f			cmp 	#'>'+1
.b725	b0 d0		bcs $b6f7			bcs 	_TKStandardPunctuation
.b727	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b72a	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b72c	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b72d	7d aa 05	adc $05aa,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b730	38		sec				sec
.b731	e9 3c		sbc #$3c			sbc 	#'<'
.b733	20 a2 b8	jsr $b8a2			jsr 	TOKWriteByte 				; this is in the range 0-7
.b736	e8		inx				inx 								; consume both
.b737	e8		inx				inx
.b738	80 96		bra $b6d0			bra 	_TKTokeniseLoop
.b73a	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b73c	20 a2 b8	jsr $b8a2			jsr 	TOKWriteByte
.b73f	60		rts				rts
.b740					_TKTokeniseIdentifier:
.b740	8e 80 04	stx $0480			stx 	identStart 					; save start
.b743	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b746					_TKCheckLoop:
.b746	e8		inx				inx 								; look at next, we know first is identifier already.
.b747	bd a9 05	lda $05a9,x			lda  	lineBuffer,x
.b74a	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b74c	f0 f8		beq $b746			beq 	_TKCheckLoop
.b74e	c9 30		cmp #$30			cmp	 	#"0"
.b750	90 0c		bcc $b75e			bcc 	_TKEndIdentifier
.b752	c9 3a		cmp #$3a			cmp 	#"9"+1
.b754	90 f0		bcc $b746			bcc 	_TKCheckLoop
.b756	c9 41		cmp #$41			cmp	 	#"A"
.b758	90 04		bcc $b75e			bcc 	_TKEndIdentifier
.b75a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b75c	90 e8		bcc $b746			bcc 	_TKCheckLoop
.b75e					_TKEndIdentifier:
.b75e	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b761	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b763	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b765	f0 06		beq $b76d			beq 	_TKHasTypeCharacter
.b767	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b769	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b76b	d0 07		bne $b774			bne 	_TKNoTypeCharacter
.b76d					_TKHasTypeCharacter:
.b76d	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b770	e8		inx				inx 								; consume the type character
.b771	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b774					_TKNoTypeCharacter:
.b774	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b776	d0 09		bne $b781			bne 	_TKNoArray
.b778	e8		inx				inx 								; skip the (
.b779	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.b77c	09 04		ora #$04			ora 	#$04
.b77e	8d 84 04	sta $0484			sta 	identTypeByte
.b781					_TKNoArray:
.b781	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b784	20 1e b8	jsr $b81e			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b787	a0 bb		ldy #$bb			ldy 	#(KeywordSet0) >> 8
.b789	a9 02		lda #$02			lda 	#(KeywordSet0) & $FF
.b78b	20 52 b6	jsr $b652			jsr 	TOKSearchTable
.b78e	a2 00		ldx #$00			ldx 	#0
.b790	b0 1f		bcs $b7b1			bcs 	_TKFoundToken
.b792	a0 bc		ldy #$bc			ldy 	#(KeywordSet1) >> 8
.b794	a9 ff		lda #$ff			lda 	#(KeywordSet1) & $FF
.b796	20 52 b6	jsr $b652			jsr 	TOKSearchTable
.b799	a2 81		ldx #$81			ldx 	#$81
.b79b	b0 14		bcs $b7b1			bcs 	_TKFoundToken
.b79d	a0 bd		ldy #$bd			ldy 	#(KeywordSet2) >> 8
.b79f	a9 57		lda #$57			lda 	#(KeywordSet2) & $FF
.b7a1	20 52 b6	jsr $b652			jsr 	TOKSearchTable
.b7a4	a2 82		ldx #$82			ldx 	#$82
.b7a6	b0 09		bcs $b7b1			bcs 	_TKFoundToken
.b7a8	20 ae b8	jsr $b8ae			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b7ab	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b7ae	4c d0 b6	jmp $b6d0			jmp 	_TKTokeniseLoop 			; and go round again.
.b7b1					_TKFoundToken:
.b7b1	48		pha				pha 								; save token
.b7b2	8a		txa				txa 								; shift in X, is there one ?
.b7b3	f0 03		beq $b7b8			beq 	_TKNoTShift
.b7b5	20 a2 b8	jsr $b8a2			jsr 	TOKWriteByte 				; if so, write it out
.b7b8					_TKNoTShift:
.b7b8	68		pla				pla 								; restore and write token
.b7b9	20 a2 b8	jsr $b8a2			jsr 	TOKWriteByte
.b7bc	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b7bf	4c d0 b6	jmp $b6d0			jmp 	_TKTokeniseLoop 			; and go round again.
.b7c2					TOKTokenString:
.b7c2	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b7c4	20 a2 b8	jsr $b8a2			jsr 	TOKWriteByte
.b7c7	e8		inx				inx									; start of quoted string.
.b7c8	da		phx				phx 								; push start of string on top
.b7c9	ca		dex				dex 								; because we pre-increment
.b7ca					_TSFindEnd:
.b7ca	e8		inx				inx
.b7cb	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character
.b7ce	f0 04		beq $b7d4			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.b7d0	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.b7d2	d0 f6		bne $b7ca			bne 	_TSFindEnd
.b7d4					_TSEndOfString:
.b7d4	7a		ply				ply  								; so now Y is first character, X is character after end.
.b7d5	48		pha				pha 								; save terminating character
.b7d6	20 de b7	jsr $b7de			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b7d9	68		pla				pla 								; terminating character
.b7da	f0 01		beq $b7dd			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b7dc	e8		inx				inx
.b7dd					_TSNotQuote:
.b7dd	60		rts				rts
.b7de					TOKWriteBlockXY:
.b7de	86 36		stx $36				stx 	zTemp0 						; save end character
.b7e0	98		tya				tya 								; use 2's complement to work out the byte size
.b7e1	49 ff		eor #$ff			eor 	#$FF
.b7e3	38		sec				sec
.b7e4	65 36		adc $36				adc 	zTemp0
.b7e6	1a		inc a				inc 	a 							; one extra for NULL
.b7e7	20 a2 b8	jsr $b8a2			jsr 	TOKWriteByte
.b7ea					_TOBlockLoop:
.b7ea	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.b7ec	f0 09		beq $b7f7			beq 	_TOBlockExit
.b7ee	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y 				; write byte out.
.b7f1	20 a2 b8	jsr $b8a2			jsr 	TOKWriteByte
.b7f4	c8		iny				iny
.b7f5	80 f3		bra $b7ea			bra 	_TOBlockLoop
.b7f7					_TOBlockExit:
.b7f7	a9 00		lda #$00			lda 	#0 							; add NULL.
.b7f9	20 a2 b8	jsr $b8a2			jsr 	TOKWriteByte
.b7fc	60		rts				rts
.b7fd					TOKHexConstant:
.b7fd	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b7ff	20 a2 b8	jsr $b8a2			jsr 	TOKWriteByte
.b802	e8		inx				inx									; start of quoted string.
.b803	da		phx				phx 								; push start of constant on top
.b804	ca		dex				dex
.b805					_THFindLoop:
.b805	e8		inx				inx 	 							; this is stored in a block, so find out how long
.b806	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; the hex constant is.
.b809	c9 30		cmp #$30			cmp 	#"0"
.b80b	90 0c		bcc $b819			bcc 	_THFoundEnd
.b80d	c9 3a		cmp #$3a			cmp 	#"9"+1
.b80f	90 f4		bcc $b805			bcc 	_THFindLoop
.b811	c9 41		cmp #$41			cmp 	#"A"
.b813	90 04		bcc $b819			bcc 	_THFoundEnd
.b815	c9 47		cmp #$47			cmp 	#"F"+1
.b817	90 ec		bcc $b805			bcc 	_THFindLoop
.b819					_THFoundEnd:
.b819	7a		ply				ply 								; restore start
.b81a	20 de b7	jsr $b7de			jsr 	TOKWriteBlockXY 			; output the block
.b81d	60		rts				rts
.b81e					TOKCalculateHash:
.b81e	da		phx				phx
.b81f	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.b822	a9 00		lda #$00			lda 	#0
.b824					_TCHLoop:
.b824	18		clc				clc
.b825	7d a9 05	adc $05a9,x			adc 	lineBuffer,x
.b828	e8		inx				inx
.b829	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b82c	d0 f6		bne $b824			bne 	_TCHLoop
.b82e	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b831	fa		plx				plx
.b832	60		rts				rts
.b833					LCLFixLineBufferCase:
.b833	a2 00		ldx #$00			ldx 	#0
.b835					_FLBCLoop:
.b835	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next character
.b838	f0 22		beq $b85c			beq 	_FLBCExit 					; end of string.
.b83a	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b83c	f0 11		beq $b84f			beq 	_FLBCInQuotes
.b83e	e8		inx				inx
.b83f	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b841	90 f2		bcc $b835			bcc 	_FLBCLoop
.b843	c9 7b		cmp #$7b			cmp 	#'z'+1
.b845	b0 ee		bcs $b835			bcs 	_FLBCLoop
.b847	38		sec				sec 								; make U/C
.b848	e9 20		sbc #$20			sbc 	#32
.b84a	9d a8 05	sta $05a8,x			sta	 	lineBuffer-1,x 				; write back
.b84d	80 e6		bra $b835			bra 	_FLBCLoop
.b84f					_FLBCInQuotes:
.b84f	e8		inx				inx 								; advance
.b850	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next
.b853	f0 07		beq $b85c			beq 	_FLBCExit 					; exit on EOS
.b855	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b857	d0 f6		bne $b84f			bne 	_FLBCInQuotes
.b859	e8		inx				inx 								; skip over it
.b85a	80 d9		bra $b835			bra 	_FLBCLoop
.b85c					_FLBCExit:
.b85c	60		rts				rts
.b85d					TOKExtractLineNumber:
.b85d	ad ab 04	lda $04ab			lda 	tokenLineNumber+1 			; push current value on stack
.b860	48		pha				pha
.b861	ad aa 04	lda $04aa			lda 	tokenLineNumber
.b864	48		pha				pha
.b865	20 9b b8	jsr $b89b			jsr 	_LCLNTimes2 				; line # x 2
.b868	20 9b b8	jsr $b89b			jsr 	_LCLNTimes2 				; line # x 4
.b86b	18		clc				clc 								; add stacked value
.b86c	68		pla				pla
.b86d	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b870	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b873	68		pla				pla
.b874	6d ab 04	adc $04ab			adc 	tokenLineNumber+1
.b877	8d ab 04	sta $04ab			sta 	tokenLineNumber+1 			; line # x 5
.b87a	20 9b b8	jsr $b89b			jsr 	_LCLNTimes2 				; line # x 10
.b87d	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get and consume character
.b880	e8		inx				inx
.b881	29 0f		and #$0f			and 	#15 						; add to line #
.b883	18		clc				clc
.b884	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b887	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b88a	90 03		bcc $b88f			bcc 	_TLENNoCarry
.b88c	ee ab 04	inc $04ab			inc 	tokenLineNumber+1
.b88f					_TLENNoCarry:
.b88f	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; more digits ?
.b892	c9 30		cmp #$30			cmp 	#'0'
.b894	90 04		bcc $b89a			bcc 	_TLENExit
.b896	c9 3a		cmp #$3a			cmp 	#'9'+1
.b898	90 c3		bcc $b85d			bcc 	TOKExtractLineNumber
.b89a					_TLENExit:
.b89a	60		rts				rts
.b89b					_LCLNTimes2:
.b89b	0e aa 04	asl $04aa			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.b89e	2e ab 04	rol $04ab			rol 	tokenLineNumber+1
.b8a1	60		rts				rts
.b8a2					TOKWriteByte:
.b8a2	da		phx				phx
.b8a3	ae a9 04	ldx $04a9			ldx 	tokenOffset 				; next slot to write to
.b8a6	9d a9 04	sta $04a9,x			sta 	tokenOffset,x 				; write byte out
.b8a9	ee a9 04	inc $04a9			inc 	tokenOffset 				; advance slot.
.b8ac	fa		plx				plx
.b8ad	60		rts				rts
.b8ae					TOKCheckCreateVariableRecord:
.b8ae	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b8b0	85 36		sta $36				sta 	0+zTemp0
.b8b2	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b8b4	85 37		sta $37				sta 	1+zTemp0
.b8b6					_CCVSearch:
.b8b6	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b8b8	f0 2c		beq $b8e6			beq 	_CCVFail
.b8ba	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b8bc	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b8be	cd 83 04	cmp $0483			cmp 	identHash
.b8c1	d0 16		bne $b8d9			bne 	_CCVNext
.b8c3	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b8c5	ae 80 04	ldx $0480			ldx 	identStart
.b8c8					_CCVCompare:
.b8c8	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b8cb	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b8cd	e8		inx				inx 								; advance pointers
.b8ce	c8		iny				iny
.b8cf	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b8d0	d0 07		bne $b8d9			bne 	_CCVNext  					; didn't match go to next.
.b8d2	90 f4		bcc $b8c8			bcc 	_CCVCompare 				; not finished yet.
.b8d4	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b8d7	f0 41		beq $b91a			beq 	_CCVFound 					; yes, we were successful
.b8d9					_CCVNext:
.b8d9	18		clc				clc
.b8da	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b8dc	65 36		adc $36				adc 	zTemp0
.b8de	85 36		sta $36				sta 	zTemp0
.b8e0	90 d4		bcc $b8b6			bcc 	_CCVSearch
.b8e2	e6 37		inc $37				inc 	zTemp0+1
.b8e4	80 d0		bra $b8b6			bra 	_CCVSearch
.b8e6					_CCVFail:
.b8e6	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b8e8	ad 83 04	lda $0483			lda 	identHash
.b8eb	91 36		sta ($36),y			sta 	(zTemp0),y
.b8ed	c8		iny				iny 								; offset 2 is the type byte
.b8ee	ad 84 04	lda $0484			lda 	identTypeByte
.b8f1	91 36		sta ($36),y			sta 	(zTemp0),y
.b8f3	c8		iny				iny
.b8f4					_CCVData:
.b8f4	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b8f6	91 36		sta ($36),y			sta 	(zTemp0),y
.b8f8	c8		iny				iny
.b8f9	c0 08		cpy #$08			cpy 	#8
.b8fb	90 f7		bcc $b8f4			bcc 	_CCVData
.b8fd	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b900					_CCVCopyName:
.b900	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b903	91 36		sta ($36),y			sta 	(zTemp0),y
.b905	e8		inx				inx
.b906	c8		iny				iny
.b907	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b90a	d0 f4		bne $b900			bne 	_CCVCopyName
.b90c	98		tya				tya 								; patch offset
.b90d	92 36		sta ($36)			sta 	(zTemp0)
.b90f	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b911	91 36		sta ($36),y			sta 	(zTemp0),y
.b913	88		dey				dey
.b914	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b916	09 80		ora #$80			ora 	#$80
.b918	91 36		sta ($36),y			sta 	(zTemp0),y
.b91a					_CCVFound:
.b91a	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b91c	38		sec				sec
.b91d	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b91f	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b921	20 a2 b8	jsr $b8a2			jsr 	TOKWriteByte
.b924	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b926	20 a2 b8	jsr $b8a2			jsr 	TOKWriteByte
.b929	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b92a					SNDCheckChannel:
.b92a	aa		tax				tax
.b92b	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b92e	d0 38		bne $b968			bne 	_SNDCCExit
.b930	da		phx				phx 								; save current channel
.b931	8a		txa				txa 								; put in A
.b932	20 ae b9	jsr $b9ae			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b935	68		pla				pla 								; channel # in A
.b936	90 30		bcc $b968			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b938	a8		tay				tay 								; Y is the channel #
.b939	bd ff 06	lda $06ff,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b93c	99 fe 07	sta $07fe,y			sta 	SNDPitchLow,y
.b93f	bd 00 07	lda $0700,x			lda 	SNDQueue+2,x
.b942	99 02 08	sta $0802,y			sta 	SNDPitchHigh,y
.b945	bd 01 07	lda $0701,x			lda 	SNDQueue+3,x
.b948	99 06 08	sta $0806,y			sta 	SNDVolume,y
.b94b	bd 02 07	lda $0702,x			lda 	SNDQueue+4,x
.b94e	99 0a 08	sta $080a,y			sta 	SNDTimeLeft,y
.b951	bd 03 07	lda $0703,x			lda 	SNDQueue+5,x
.b954	99 0e 08	sta $080e,y			sta 	SNDAdjustLow,y
.b957	bd 04 07	lda $0704,x			lda 	SNDQueue+6,x
.b95a	99 12 08	sta $0812,y			sta 	SNDAdjustHigh,y
.b95d	5a		phy				phy 								; save channel #
.b95e	20 c8 b9	jsr $b9c8			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b961	ce fd 06	dec $06fd			dec 	SNDLength 					; reduce the queue length.
.b964	68		pla				pla
.b965	20 69 b9	jsr $b969			jsr 	SNDUpdateNote 				; update channel A
.b968					_SNDCCExit:
.b968	60		rts				rts
.b969					SNDUpdateNote:
.b969	aa		tax				tax 								; so we can access records
.b96a	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b96b	0a		asl a				asl 	a
.b96c	0a		asl a				asl 	a
.b96d	0a		asl a				asl 	a
.b96e	0a		asl a				asl 	a
.b96f	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b972	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; are we silent
.b975	f0 2e		beq $b9a5			beq 	_SNDUNIsSilent
.b977	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; push channel bits on stack
.b97a	48		pha				pha
.b97b	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b97e	29 0f		and #$0f			and 	#$0F
.b980	0d fc 06	ora $06fc			ora 	SNDChannelBits 				; set channel bits
.b983	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b985	20 12 ba	jsr $ba12			jsr 	SNDWritePorts
.b988	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b98b	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b98e	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.b991	4e fc 06	lsr $06fc			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b994	6a		ror a				ror 	a
.b995	4e fc 06	lsr $06fc			lsr 	SNDChannelBits
.b998	6a		ror a				ror 	a
.b999	4a		lsr a				lsr 	a 							; put in bits 0-5
.b99a	4a		lsr a				lsr 	a
.b99b	20 12 ba	jsr $ba12			jsr 	SNDWritePorts 				; write as rest of pitch register
.b99e	68		pla				pla
.b99f	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b9a1	20 12 ba	jsr $ba12			jsr 	SNDWritePorts
.b9a4	60		rts				rts
.b9a5					_SNDUNIsSilent:
.b9a5	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; channel bits
.b9a8	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b9aa	20 12 ba	jsr $ba12			jsr 	SNDWritePorts 				; write to the ports
.b9ad	60		rts				rts
.b9ae					SNDFindNextNoteForA:
.b9ae	ac fd 06	ldy $06fd			ldy 	SNDLength 					; queue size into Y
.b9b1	f0 13		beq $b9c6			beq 	_SNDFNNFail 				; queue empty.
.b9b3	a2 00		ldx #$00			ldx 	#0
.b9b5					_SNDFNNSearch:
.b9b5	dd fe 06	cmp $06fe,x			cmp 	SNDQueue,x 					; does it match the channel
.b9b8	38		sec				sec
.b9b9	f0 0c		beq $b9c7			beq 	_SNDFNNExit 				; if so exit with CS.
.b9bb	e8		inx				inx 								; next queue slot.
.b9bc	e8		inx				inx
.b9bd	e8		inx				inx
.b9be	e8		inx				inx
.b9bf	e8		inx				inx
.b9c0	e8		inx				inx
.b9c1	e8		inx				inx
.b9c2	e8		inx				inx
.b9c3	88		dey				dey 								; done the whole queue
.b9c4	d0 ef		bne $b9b5			bne 	_SNDFNNSearch 				; no, go back.
.b9c6					_SNDFNNFail:
.b9c6	18		clc				clc
.b9c7					_SNDFNNexit:
.b9c7	60		rts				rts
.b9c8					SNDDeleteXFromQueue:
.b9c8	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b9ca	f0 09		beq $b9d5			beq 	_SNDDXExit
.b9cc	bd 06 07	lda $0706,x			lda 	SNDQueue+8,x
.b9cf	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9d2	e8		inx				inx
.b9d3	80 f3		bra $b9c8			bra 	SNDDeleteXFromQueue
.b9d5					_SNDDXExit:
.b9d5	60		rts				rts
.06fc					SNDChannelBits:
>06fc							.fill 	1
.b9d6					SNDQueueRequest:
.b9d6	86 36		stx $36				stx 	zTemp0						; save queue address
.b9d8	84 37		sty $37				sty 	zTemp0+1
.b9da	ae fd 06	ldx $06fd			ldx 	SNDLength 					; queue is full, can't take any more.
.b9dd	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b9df	f0 21		beq $ba02			beq 	_SNDQRExit
.b9e1	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b9e3	48		pha				pha
.b9e4	8a		txa				txa  								; get offset in queue buffer/
.b9e5	0a		asl a				asl 	a
.b9e6	0a		asl a				asl 	a
.b9e7	0a		asl a				asl 	a
.b9e8	aa		tax				tax
.b9e9	68		pla				pla 								; get back and push again
.b9ea	48		pha				pha
.b9eb	9d fe 06	sta $06fe,x			sta 	SNDQueue+0,x 				; save the channel #
.b9ee	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b9f0					_SNDQCopy:
.b9f0	b1 36		lda ($36),y			lda 	(zTemp0),y
.b9f2	e8		inx				inx
.b9f3	c8		iny				iny
.b9f4	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9f7	c0 06		cpy #$06			cpy 	#6
.b9f9	d0 f5		bne $b9f0			bne 	_SNDQCopy
.b9fb	ee fd 06	inc $06fd			inc 	SNDLength 					; bump queue length.
.b9fe	68		pla				pla 								; get channel # back
.b9ff	20 2a b9	jsr $b92a			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.ba02					_SNDQRExit:
.ba02	60		rts				rts
.ba03					SNDSilenceChannel:
.ba03	aa		tax				tax 								; zero time left.
.ba04	9e 0a 08	stz $080a,x			stz 	SNDTimeLeft,x
.ba07	0a		asl a				asl 	a 							; shift into position
.ba08	0a		asl a				asl 	a
.ba09	0a		asl a				asl 	a
.ba0a	0a		asl a				asl 	a
.ba0b	0a		asl a				asl 	a
.ba0c	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.ba0e	20 12 ba	jsr $ba12			jsr 	SNDWritePorts
.ba11	60		rts				rts
.ba12					SNDWritePorts:
.ba12	64 01		stz $01				stz 	1
.ba14	8d 00 d6	sta $d600			sta 	$D600
.ba17	8d 10 d6	sta $d610			sta 	$D610
.ba1a	60		rts				rts
.ba1b					SNDCommand:
.ba1b	da		phx				phx
.ba1c	5a		phy				phy
.ba1d	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.ba1f	f0 1d		beq $ba3e			beq 	_SNDInitialise
.ba21	90 28		bcc $ba4b			bcc 	_SNDExit
.ba23	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.ba25	f0 17		beq $ba3e			beq 	_SNDSilence
.ba27	b0 22		bcs $ba4b			bcs 	_SNDExit
.ba29	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.ba2b	b0 09		bcs $ba36			bcs 	_SNDQueryPlay
.ba2d	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.ba2f	b0 1a		bcs $ba4b			bcs 	_SNDExit
.ba31	20 d6 b9	jsr $b9d6			jsr 	SNDQueueRequest
.ba34	80 15		bra $ba4b			bra 	_SNDExit
.ba36					_SNDQueryPlay:
.ba36	29 03		and #$03			and 	#3 							; get channel #
.ba38	aa		tax				tax
.ba39	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.ba3c	80 0d		bra $ba4b			bra 	_SNDExit
.ba3e					_SNDInitialise:
.ba3e					_SNDSilence:
.ba3e	9c fd 06	stz $06fd			stz 	SNDLength 					; empty the queue.
.ba41	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.ba43					_SNDSilenceLoop:
.ba43	48		pha				pha
.ba44	20 03 ba	jsr $ba03			jsr 	SNDSilenceChannel
.ba47	68		pla				pla
.ba48	3a		dec a				dec 	a
.ba49	10 f8		bpl $ba43			bpl 	_SNDSilenceLoop
.ba4b					_SNDExit:
.ba4b	7a		ply				ply
.ba4c	fa		plx				plx
.ba4d	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fd					SNDLength:
>06fd							.fill 	1
.06fe					SNDQueue:
>06fe							.fill 	SNDQueueSize * 8
.07fe					SNDPitchLow:
>07fe							.fill 	4
.0802					SNDPitchHigh:
>0802							.fill 	4
.0806					SNDVolume:
>0806							.fill 	4
.080a					SNDTimeLeft:
>080a							.fill 	4
.080e					SNDAdjustLow:
>080e							.fill 	4
.0812					SNDAdjustHigh:
>0812							.fill 	4
.ba4e					SNDUpdate:
.ba4e	ad 0a 08	lda $080a			lda 	SNDTimeLeft+0 				; look at time remaining
.ba51	f0 05		beq $ba58			beq 	_SNDUNot0 					; not playing
.ba53	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.ba55	20 77 ba	jsr $ba77			jsr 	SNDUpdateChannel 			; update it.
.ba58					_SNDUNot0:
.ba58	ad 0b 08	lda $080b			lda 	SNDTimeLeft+1
.ba5b	f0 05		beq $ba62			beq 	_SNDUNot1
.ba5d	a2 01		ldx #$01			ldx 	#1
.ba5f	20 77 ba	jsr $ba77			jsr 	SNDUpdateChannel
.ba62					_SNDUNot1:
.ba62	ad 0c 08	lda $080c			lda 	SNDTimeLeft+2
.ba65	f0 05		beq $ba6c			beq 	_SNDUNot2
.ba67	a2 02		ldx #$02			ldx 	#2
.ba69	20 77 ba	jsr $ba77			jsr 	SNDUpdateChannel
.ba6c					_SNDUNot2:
.ba6c	ad 0d 08	lda $080d			lda 	SNDTimeLeft+3
.ba6f	f0 05		beq $ba76			beq 	_SNDUNot3
.ba71	a2 03		ldx #$03			ldx 	#3
.ba73	20 77 ba	jsr $ba77			jsr 	SNDUpdateChannel
.ba76					_SNDUNot3:
.ba76	60		rts				rts
.ba77					SNDUpdateChannel:
.ba77	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.ba79	f0 2c		beq $baa7			beq 	_SNDUCExit
.ba7b	3a		dec a				dec 	a 							; decrement and update timer
.ba7c	9d 0a 08	sta $080a,x			sta 	SNDTimeLeft,x
.ba7f	f0 1d		beq $ba9e			beq 	_SNDUCUpdate 				; if zero, silence channel
.ba81	bd 0e 08	lda $080e,x			lda 	SNDAdjustLow,x 				; adjust ?
.ba84	1d 12 08	ora $0812,x			ora 	SNDAdjustHigh,x
.ba87	f0 1e		beq $baa7			beq 	_SNDUCExit 					; if zero carry on at current tone.
.ba89	18		clc				clc 								; add adjust, forcing into a 10 bit range
.ba8a	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.ba8d	7d 0e 08	adc $080e,x			adc 	SNDAdjustLow,x
.ba90	9d fe 07	sta $07fe,x			sta 	SNDPitchLow,x
.ba93	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x
.ba96	7d 12 08	adc $0812,x			adc 	SNDAdjustHigh,x
.ba99	29 03		and #$03			and 	#3
.ba9b	9d 02 08	sta $0802,x			sta 	SNDPitchHigh,x
.ba9e					_SNDUCUpdate:
.ba9e	8a		txa				txa 								; which channel.
.ba9f	48		pha				pha
.baa0	20 69 b9	jsr $b969			jsr 	SNDUpdateNote 				; update the current note
.baa3	68		pla				pla
.baa4	20 2a b9	jsr $b92a			jsr 	SNDCheckChannel 			; more to do ?
.baa7					_SNDUCExit:
.baa7	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
