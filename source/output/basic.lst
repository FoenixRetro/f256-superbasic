
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Tue Nov 22 18:39:16 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					isInputFlag:
>04a8							.fill 	1
.04a9					tokenOffset:
>04a9							.fill 	1
.04aa					tokenLineNumber:
>04aa							.fill 	2
.04ac					tokenBuffer:
>04ac							.fill 	253
.05a9					lineBuffer:
>05a9							.fill 	MaxLineSize+1
.05fa					numberBuffer:
>05fa							.fill 	34
.061c					decimalBuffer:
>061c							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 dc aa	jsr $aadc			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 48 8e	jsr $8e48			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 f6 b9	jsr $b9f6			jsr 	SNDCommand
.8019	20 44 89	jsr $8944			jsr 	NewProgram 					; erase current program
.801c	20 e4 82	jsr $82e4			jsr 	BackloadProgram
.801f	4c 54 83	jmp $8354			jmp 	WarmStart
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 54 75			.text "Built Tuesday 22-Nov-2022. Build 3571."
>804b	65 73 64 61 79 20 32 32 2d 4e 6f 76 2d 32 30 32
>805b	32 2e 20 42 75 69 6c 64 20 33 35 37 31 2e

;******  Return to file: ./common/aa.system/00start.asm

>8069	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806c					AssembleGroup1:
.806c	a9 ff		lda #$ff			lda 	#$FF
.806e	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8071	80 02		bra $8075			bra 	AsmGroup12
.8073					AssembleGroup2:
.8073	a9 00		lda #$00			lda 	#$00
.8075					AsmGroup12:
.8075	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.8078	68		pla				pla 								; pop the return address to access the information following.
.8079	fa		plx				plx
.807a	20 03 81	jsr $8103			jsr 	AccessParameters 			; get opcode and save as base
.807d	8d a4 04	sta $04a4			sta 	BaseOpcode
.8080	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8083	d0 08		bne $808d			bne 	_AG12HaveMask
.8085	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8087	20 0b 81	jsr $810b			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.808a	8d a5 04	sta $04a5			sta 	ModeMask
.808d					_AG12HaveMask:
.808d	20 46 82	jsr $8246			jsr 	TypeAndCalculateOperand 	; get zero page type
.8090	da		phx				phx 								; save found address mode
.8091	20 6f 81	jsr $816f			jsr 	AssembleModeX
.8094	fa		plx				plx  								; restore address mode
.8095	b0 0b		bcs $80a2			bcs 	_AG12Exit
.8097	20 a3 80	jsr $80a3			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.809a	20 6f 81	jsr $816f			jsr 	AssembleModeX
.809d	b0 03		bcs $80a2			bcs 	_AG12Exit
.809f	4c 3c a0	jmp $a03c			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a2					_AG12Exit:
.80a2	60		rts				rts
.80a3					PromoteToAbsolute:
.80a3	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a5	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a7	f0 19		beq $80c2			beq 	_PTADo
.80a9	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80ab	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80ad	f0 13		beq $80c2			beq 	_PTADo
.80af	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b1	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b3	f0 0d		beq $80c2			beq 	_PTADo
.80b5	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b7	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b9	f0 07		beq $80c2			beq 	_PTADo
.80bb	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bd	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80bf	f0 01		beq $80c2			beq 	_PTADo
.80c1	60		rts				rts
.80c2					_PTADo:
.80c2	aa		tax				tax
.80c3	60		rts				rts
.80c4					AssembleGroup3:
.80c4	68		pla				pla 								; get parameters, which is just the opcode.
.80c5	fa		plx				plx
.80c6	20 03 81	jsr $8103			jsr 	AccessParameters 			; get and output opcode
.80c9	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.80cc	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get a 16 bit operand
.80cf	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d2	38		sec				sec
.80d3	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d6	48		pha				pha 								; LSB in A
.80d7	ad 10 04	lda $0410			lda 	NSMantissa1
.80da	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80dd	aa		tax				tax 								; MSB in X
.80de	68		pla				pla
.80df	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80e0	69 7f		adc #$7f			adc 	#$7F
.80e2	90 01		bcc $80e5			bcc 	_AG3NoCarry
.80e4	e8		inx				inx
.80e5					_AG3NoCarry:
.80e5	38		sec				sec 								; fix back and write out anyways.
.80e6	e9 80		sbc #$80			sbc 	#$80
.80e8	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.80eb	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ed	f0 0a		beq $80f9			beq 	_AG3Exit
.80ef	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f2	29 01		and #$01			and 	#1
.80f4	f0 03		beq $80f9			beq 	_AG3Exit
.80f6	4c 41 a0	jmp $a041			jmp 	RangeError 					; no, branch is out of range
.80f9					_AG3Exit:
.80f9	60		rts				rts
.80fa					AssembleGroup4:
.80fa	68		pla				pla 								; pop address
.80fb	fa		plx				plx
.80fc	20 03 81	jsr $8103			jsr 	AccessParameters 			; access and get first
.80ff	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte 			; output it.
.8102	60		rts				rts
.8103					AccessParameters:
.8103	8d a1 04	sta $04a1			sta 	ParamStart
.8106	8e a2 04	stx $04a2			stx 	ParamStart+1
.8109	a9 01		lda #$01			lda 	#1
.810b					GetParameter:
.810b	5a		phy				phy
.810c	a8		tay				tay
.810d	ad a1 04	lda $04a1			lda 	ParamStart
.8110	85 36		sta $36				sta 	zTemp0
.8112	ad a2 04	lda $04a2			lda 	ParamStart+1
.8115	85 37		sta $37				sta 	zTemp0+1
.8117	b1 36		lda ($36),y			lda 	(zTemp0),y
.8119	7a		ply				ply
.811a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811b					AssemblerWriteByte:
.811b	48		pha			pha
.811c	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.811f	29 02		and #$02		and 	#2
.8121	f0 1b		beq $813e		beq 	_AWBNoPrint
.8123	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8126	20 59 81	jsr $8159		jsr 	PrintHex
.8129	ad 9e 04	lda $049e		lda		AssemblerAddress
.812c	20 59 81	jsr $8159		jsr 	PrintHex
.812f	a9 20		lda #$20		lda 	#' '
.8131	20 68 a8	jsr $a868		jsr 	EXTPrintCharacter
.8134	68		pla			pla 									; print byte
.8135	48		pha			pha
.8136	20 59 81	jsr $8159		jsr 	PrintHex
.8139	a9 0d		lda #$0d		lda 	#13
.813b	20 68 a8	jsr $a868		jsr 	EXTPrintCharacter
.813e					_AWBNoPrint:
.813e	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8141	85 36		sta $36			sta 	zTemp0
.8143	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8146	f0 0e		beq $8156		beq 	_AWBRange
.8148	85 37		sta $37			sta 	zTemp0+1
.814a	68		pla			pla 									; write byte out
.814b	92 36		sta ($36)		sta 	(zTemp0)
.814d	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.8150	d0 03		bne $8155		bne 	_AWBNoCarry
.8152	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8155					_AWBNoCarry:
.8155	60		rts			rts
.8156					_AWBRange:
.8156	4c 41 a0	jmp $a041		jmp 	RangeError
.8159					PrintHex:
.8159	48		pha				pha
.815a	4a		lsr a				lsr 	a
.815b	4a		lsr a				lsr 	a
.815c	4a		lsr a				lsr 	a
.815d	4a		lsr a				lsr 	a
.815e	20 62 81	jsr $8162			jsr 	_PrintNibble
.8161	68		pla				pla
.8162					_PrintNibble:
.8162	29 0f		and #$0f			and 	#15
.8164	c9 0a		cmp #$0a			cmp 	#10
.8166	90 02		bcc $816a			bcc 	_NoShift
.8168	69 06		adc #$06			adc 	#6
.816a					_NoShift:
.816a	69 30		adc #$30			adc 	#48
.816c	4c 68 a8	jmp $a868			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.816f					AssembleModeX:
.816f	5a		phy				phy
.8170	ad a3 04	lda $04a3			lda 	IsGroup1
.8173	f0 17		beq $818c			beq 	_AMXGroup2
.8175	8a		txa				txa 							; is it in group # 1
.8176	29 40		and #$40			and 	#AM_ISG1
.8178	f0 50		beq $81ca			beq 	_AMXFail 				; no, give up.
.817a	8a		txa				txa 							; get back.
.817b	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817d	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.817f	d0 22		bne $81a3			bne 	_AMXHaveInfo
.8181	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8184	c9 81		cmp #$81			cmp 	#$81
.8186	f0 42		beq $81ca			beq 	_AMXFail
.8188	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.818a	80 17		bra $81a3			bra 	_AMXHaveInfo 			; odd design decision there.
.818c					_AMXGroup2:
.818c	8a		txa				txa 							; is it in group 2 ?
.818d	29 20		and #$20			and 	#AM_ISG2
.818f	f0 39		beq $81ca			beq 	_AMXFail 				; no, give up.
.8191	8a		txa				txa 							; get the offset into Y
.8192	29 1f		and #$1f			and 	#$1F
.8194	4a		lsr a				lsr 	a 						; make it 0-7.
.8195	4a		lsr a				lsr  	a
.8196	a8		tay				tay
.8197	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.819a					_AMXCheckOkay:
.819a	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819b	88		dey				dey
.819c	10 fc		bpl $819a			bpl 	_AMXCheckOkay
.819e	90 2a		bcc $81ca			bcc 	_AMXFail 				; not allowed.
.81a0	8a		txa				txa  							; get mask back
.81a1	29 1f		and #$1f			and 	#$1F
.81a3					_AMXHaveInfo:
.81a3	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a5	10 05		bpl $81ac			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a7	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81aa	d0 1e		bne $81ca			bne 	_AMXFail
.81ac					_AMXAnySize:
.81ac	18		clc				clc 							; add offset to the base opcode
.81ad	6d a4 04	adc $04a4			adc 	BaseOpcode
.81b0					_AMXOutputCode:
.81b0	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b3	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b5	f0 10		beq $81c7			beq 	_AMXExit
.81b7	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81ba	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.81bd	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81bf	30 06		bmi $81c7			bmi 	_AMXExit
.81c1	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c4	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.81c7					_AMXExit:
.81c7	7a		ply				ply
.81c8	38		sec				sec
.81c9	60		rts				rts
.81ca					_AMXFail:
.81ca	a0 00		ldy #$00			ldy 	#0
.81cc					_AMXCheckOddities:
.81cc	8a		txa				txa
.81cd	d9 f5 81	cmp $81f5,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d0	d0 16		bne $81e8			bne 	_AMXCONext
.81d2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d5	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81d8	d0 0e		bne $81e8			bne 	_AMXCONext
.81da	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81dc	10 05		bpl $81e3			bpl 	_AMXCONotZero
.81de	ad 10 04	lda $0410			lda 	NSMantissa1
.81e1	d0 05		bne $81e8			bne 	_AMXCONext
.81e3					_AMXCONotZero:
.81e3	b9 f4 81	lda $81f4,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e6	80 c8		bra $81b0			bra 	_AMXOutputCode 			; and assemble it
.81e8					_AMXCONext:
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	c8		iny				iny
.81eb	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; end of table
.81ee	d0 dc		bne $81cc			bne 	_AMXCheckOddities
.81f0					_AMXCOFail:
.81f0	7a		ply				ply
.81f1	18		clc				clc
.81f2	60		rts				rts
.81f3					ExtraOpcode:
>81f3	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f6	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f9	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fc	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81ff	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8202	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8205	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8208	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820b	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820e	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8211	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8212					LabelHere:
.8212	c8		iny				iny 								; skip .
.8213	a2 00		ldx #$00			ldx 	#0 							; get a term
.8215	20 78 98	jsr $9878			jsr 	EvaluateTerm 				; get a term
.8218	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821b	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821d	d0 24		bne $8243			bne 	_ALType
.821f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8222	85 36		sta $36				sta 	zTemp0
.8224	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8227	85 37		sta $37				sta 	zTemp0+1
.8229	5a		phy				phy 								; copy address in.
.822a	a0 01		ldy #$01			ldy 	#1
.822c	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.822f	92 36		sta ($36)			sta 	(zTemp0)
.8231	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8234	91 36		sta ($36),y			sta 	(zTemp0),y
.8236	c8		iny				iny
.8237	a9 00		lda #$00			lda 	#0
.8239	91 36		sta ($36),y			sta 	(zTemp0),y
.823b	c8		iny				iny
.823c	91 36		sta ($36),y			sta 	(zTemp0),y
.823e	c8		iny				iny
.823f	91 36		sta ($36),y			sta 	(zTemp0),y
.8241	7a		ply				ply
.8242	60		rts				rts
.8243					_ALType:
.8243	4c 46 a0	jmp $a046			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8246					TypeAndCalculateOperand:
.8246	b1 30		lda ($30),y			lda 	(codePtr),y
.8248	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.824a	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824c	f0 5b		beq $82a9			beq 	_TACOExit
.824e	c9 80		cmp #$80			cmp 	#KWC_EOL
.8250	f0 57		beq $82a9			beq 	_TACOExit
.8252	c8		iny				iny
.8253	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8255	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8257	f0 51		beq $82aa			beq 	CalculateOperand
.8259	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825b	f0 1f		beq $827c			beq 	_TACOIndirect
.825d	88		dey				dey 								; undo get of first character
.825e	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get operand
.8261	b1 30		lda ($30),y			lda 	(codePtr),y
.8263	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8265	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8267	d0 40		bne $82a9			bne 	_TACOExit
.8269	c8		iny				iny
.826a	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826d	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826f	c9 58		cmp #$58			cmp 	#'X'
.8271	f0 36		beq $82a9			beq 	_TACOExit
.8273	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8275	c9 59		cmp #$59			cmp 	#'Y'
.8277	f0 30		beq $82a9			beq 	_TACOExit
.8279					_TACOSyntax:
.8279	4c 3c a0	jmp $a03c			jmp 	SyntaxError
.827c					_TACOIndirect:
.827c	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get the operand
.827f	b1 30		lda ($30),y			lda 	(codePtr),y
.8281	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8283	f0 17		beq $829c			beq 	_TACOIndX
.8285	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8288	b1 30		lda ($30),y			lda 	(codePtr),y
.828a	a2 d1		ldx #$d1			ldx 	#AM_IND
.828c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828e	d0 19		bne $82a9			bne 	_TACOExit
.8290	c8		iny				iny
.8291	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8294	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8296	d0 e1		bne $8279			bne 	_TACOSyntax
.8298	a2 d0		ldx #$d0			ldx 	#AM_INDY
.829a	80 0d		bra $82a9			bra 	_TACOExit
.829c					_TACOIndX:
.829c	c8		iny				iny
.829d	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82a0	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a2	d0 d5		bne $8279			bne 	_TACOSyntax
.82a4	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket			; check )
.82a7	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a9					_TACOExit:
.82a9	60		rts				rts
.82aa					CalculateOperand:
.82aa	48		pha				pha
.82ab	da		phx				phx
.82ac	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ae	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger
.82b1	fa		plx				plx
.82b2	68		pla				pla
.82b3	60		rts				rts
.82b4					TACOCheckXY:
.82b4	b1 30		lda ($30),y			lda 	(codePtr),y
.82b6	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b8	c9 40		cmp #$40			cmp 	#$40
.82ba	d0 21		bne $82dd			bne 	_TCXYFail
.82bc	b1 30		lda ($30),y			lda 	(codePtr),y
.82be	18		clc				clc
.82bf	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c1	85 37		sta $37				sta 	zTemp0+1
.82c3	c8		iny				iny
.82c4	b1 30		lda ($30),y			lda 	(codePtr),y
.82c6	c8		iny				iny
.82c7	85 36		sta $36				sta 	zTemp0
.82c9	5a		phy				phy 								; save position
.82ca	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cc	b1 36		lda ($36),y			lda 	(zTemp0),y
.82ce	d0 0c		bne $82dc			bne 	_TCXYPopFail
.82d0	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d2	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d4	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d6	f0 08		beq $82e0			beq 	_TCXYFound
.82d8	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82da	f0 04		beq $82e0			beq 	_TCXYFound
.82dc					_TCXYPopFail:
.82dc	7a		ply				ply
.82dd					_TCXYFail:
.82dd	a9 00		lda #$00			lda 	#0
.82df	60		rts				rts
.82e0					_TCXYFound:
.82e0	7a		ply				ply 								; restore position
.82e1	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e4					BackloadProgram:
.82e4	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e6	8d 2c 06	sta $062c			sta 	0+BackLoadPointer
.82e9	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82eb	8d 2d 06	sta $062d			sta 	1+BackLoadPointer
.82ee					_BPLoop:
.82ee	a2 ff		ldx #$ff			ldx 	#$FF
.82f0	20 18 83	jsr $8318			jsr 	BLReadByte
.82f3	30 1f		bmi $8314			bmi 	_BPExit
.82f5					_BPCopy:
.82f5	e8		inx				inx  								; copy byte in
.82f6	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.82f9	9e aa 05	stz $05aa,x			stz 	lineBuffer+1,x
.82fc	20 18 83	jsr $8318			jsr 	BLReadByte 					; read next byte
.82ff	30 0a		bmi $830b			bmi 	_BPEndLine 					; -ve = EOL
.8301	c9 09		cmp #$09			cmp 	#9 							; handle TAB
.8303	d0 02		bne $8307			bne 	_BPNotTab
.8305	a9 20		lda #$20			lda 	#' '
.8307					_BPNotTab:
.8307	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8309	b0 ea		bcs $82f5			bcs 	_BPCopy
.830b					_BPEndLine:
.830b	20 86 b6	jsr $b686			jsr 	TokeniseLine 				; tokenise the line.
.830e	38		sec				sec 								; append not insert
.830f	20 a4 a5	jsr $a5a4			jsr 	MemoryInsertLine 			; append to current program
.8312	80 da		bra $82ee			bra 	_BPLoop
.8314					_BPExit:
.8314	20 ed 83	jsr $83ed			jsr 	ClearCommand 				; clear variables etc.
.8317	60		rts				rts
.8318					BLReadByte:
.8318	ad 2c 06	lda $062c			lda 	BackLoadPointer
.831b	85 36		sta $36				sta 	zTemp0
.831d	ad 2d 06	lda $062d			lda 	BackLoadPointer+1
.8320	85 37		sta $37				sta 	zTemp0+1
.8322	b2 36		lda ($36)			lda 	(zTemp0)
.8324	ee 2c 06	inc $062c			inc 	BackLoadPointer
.8327	d0 03		bne $832c			bne 	_BLNoCarry
.8329	ee 2d 06	inc $062d			inc 	BackLoadPointer+1
.832c					_BLNoCarry:
.832c	c9 00		cmp #$00			cmp 	#0
.832e	60		rts				rts
.062c					BackLoadPointer:
>062c							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.832f					EditProgramCode:
.832f	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line.
.8332	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1
.8335	20 4c a6	jsr $a64c			jsr 	MemorySearch
.8338	90 05		bcc $833f			bcc 	_EPCNoDelete 				; reached the end don't delete
.833a	d0 03		bne $833f			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.833c	20 6d a5	jsr $a56d			jsr 	MemoryDeleteLine 			; delete the line
.833f					_EPCNoDelete:
.833f	ad ac 04	lda $04ac			lda 	TokenBuffer 				; buffer empty
.8342	c9 80		cmp #$80			cmp 	#KWC_EOL
.8344	f0 0d		beq $8353			beq 	_EPCNoInsert
.8346	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line - it cannot exist.
.8349	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.834c	20 4c a6	jsr $a64c			jsr 	MemorySearch
.834f	18		clc				clc 								; insert at this point.
.8350	20 a4 a5	jsr $a5a4			jsr 	MemoryInsertLine 			; insert the line
.8353					_EPCNoInsert:
.8353	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8354					WarmStart:
.8354	a2 ff		ldx #$ff			ldx 	#$FF
.8356	9a		txs				txs
.8357	20 f6 a9	jsr $a9f6			jsr 	EXTInputLine 				; get line to lineBuffer
.835a	20 86 b6	jsr $b686			jsr 	TokeniseLine 				; tokenise the line
.835d	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; line number ?
.8360	0d ab 04	ora $04ab			ora 	TokenLineNumber+1
.8363	d0 17		bne $837c			bne 	_WSEditCode 				; if so,edit code.
.8365	9c a9 04	stz $04a9			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.8368	a9 a9		lda #$a9			lda 	#((TokenOffset) & $FF)
.836a	85 30		sta $30				sta 	codePtr
.836c	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.836e	85 31		sta $31				sta 	codePtr+1
.8370	ad ac 04	lda $04ac			lda 	TokenBuffer 				; nothing to run
.8373	c9 80		cmp #$80			cmp 	#KWC_EOL
.8375	f0 dd		beq $8354			beq 	WarmStart
.8377	20 95 8a	jsr $8a95			jsr 	RUNCodePointerLine 			; execute that line.
.837a	80 d8		bra $8354			bra 	WarmStart
.837c					_WSEditCode:
.837c	20 2f 83	jsr $832f			jsr 	EditProgramCode
.837f	20 ed 83	jsr $83ed			jsr 	ClearCommand
.8382	80 d0		bra $8354			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8384					AssembleCommand:
.8384	a2 00		ldx #$00			ldx 	#0
.8386	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger 		; start address
.8389	ad 08 04	lda $0408			lda 	NSMantissa0
.838c	8d 9e 04	sta $049e			sta 	AssemblerAddress
.838f	ad 10 04	lda $0410			lda 	NSMantissa1
.8392	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.8395	20 de 8d	jsr $8dde			jsr 	CheckComma
.8398	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; options
.839b	ad 08 04	lda $0408			lda 	NSMantissa0
.839e	8d a0 04	sta $04a0			sta 	AssemblerControl
.83a1	60		rts				rts
.83a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83a3					AssertCommand:
.83a3	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83a5	20 fe 9d	jsr $9dfe			jsr 	EvaluateInteger 			; the assert test
.83a8	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; exit if result is non zero.
.83ab	d0 05		bne $83b2			bne 	_ACExit
.83ad	a9 0a		lda #$0a		lda	#10
.83af	4c ef 8d	jmp $8def		jmp	ErrorHandler
.83b2					_ACExit:
.83b2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83b3					CallCommand:
.83b3	a2 00		ldx #$00			ldx 	#0
.83b5	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger
.83b8					_CCClear
.83b8	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83b9	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero
.83bc	e0 04		cpx #$04			cpx 	#4
.83be	d0 f8		bne $83b8			bne 	_CCClear
.83c0	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83c2					_CCCParam:
.83c2	b1 30		lda ($30),y			lda 	(codePtr),y
.83c4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83c6	d0 09		bne $83d1			bne 	_CCCRun6502
.83c8	c8		iny				iny 								; skip comma
.83c9	e8		inx				inx	 								; next level
.83ca	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83cd	e0 03		cpx #$03			cpx 	#3
.83cf	90 f1		bcc $83c2			bcc 	_CCCParam 					; done all 3 ?
.83d1					_CCCRun6502:
.83d1	5a		phy				phy 								; save position
.83d2	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83d5	85 37		sta $37				sta 	zTemp0+1
.83d7	ad 08 04	lda $0408			lda 	NSMantissa0
.83da	85 36		sta $36				sta 	zTemp0
.83dc	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83df	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83e2	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83e5	20 ea 83	jsr $83ea			jsr 	_CCCZTemp0 					; call zTemp0
.83e8	7a		ply				ply 								; restore position and exit
.83e9	60		rts				rts
.83ea					_CCCZTemp0:
.83ea	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83ed					ClearCommand:
.83ed	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83ef	85 36		sta $36				sta 	0+zTemp0
.83f1	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f3	85 37		sta $37				sta 	1+zTemp0
.83f5					_ClearZeroLoop:
.83f5	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables
.83f7	f0 24		beq $841d			beq 	_ClearZeroEnd
.83f9	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83fb	a9 00		lda #$00			lda 	#0
.83fd					_ClearOneVariable:
.83fd	91 36		sta ($36),y			sta 	(zTemp0),y
.83ff	c8		iny				iny
.8400	c0 08		cpy #$08			cpy 	#8
.8402	d0 f9		bne $83fd			bne 	_ClearOneVariable
.8404	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8406	b1 36		lda ($36),y			lda 	(zTemp0),y
.8408	c9 18		cmp #$18			cmp 	#NSTProcedure
.840a	d0 04		bne $8410			bne 	_ClearNotProcedure
.840c	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; set it back to an integer array
.840e	91 36		sta ($36),y			sta 	(zTemp0),y
.8410					_ClearNotProcedure:
.8410	18		clc				clc 								; go to the next variable
.8411	b2 36		lda ($36)			lda 	(zTemp0)
.8413	65 36		adc $36				adc 	zTemp0
.8415	85 36		sta $36				sta 	zTemp0
.8417	90 dc		bcc $83f5			bcc 	_ClearZeroLoop
.8419	e6 37		inc $37				inc 	zTemp0+1
.841b	80 d8		bra $83f5			bra 	_ClearZeroLoop
.841d					_ClearZeroEnd:
.841d	18		clc				clc
.841e	a5 36		lda $36				lda 	zTemp0
.8420	69 01		adc #$01			adc 	#1
.8422	8d 8c 04	sta $048c			sta 	lowMemPtr
.8425	a5 37		lda $37				lda 	zTemp0+1
.8427	69 00		adc #$00			adc 	#0
.8429	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.842c	20 8d a7	jsr $a78d			jsr 	StackReset
.842f	20 f7 a7	jsr $a7f7			jsr 	StringSystemInitialise
.8432	20 df 8c	jsr $8cdf			jsr 	ProcedureScan
.8435	20 44 8a	jsr $8a44			jsr 	Command_Restore
.8438	9c 9e 04	stz $049e			stz 	AssemblerAddress
.843b	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.843e	9c a0 04	stz $04a0			stz 	AssemblerControl
.8441	20 7b 9a	jsr $9a7b			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8444	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8445					ClearScreen:
.8445	5a		phy				phy
.8446	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8448	20 68 a8	jsr $a868			jsr 	EXTPrintCharacter
.844b	7a		ply				ply
.844c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.844d					Command_Data:
.844d	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.844f	a2 80		ldx #$80			ldx 	#KWC_EOL
.8451	20 31 8d	jsr $8d31			jsr 	ScanForward
.8454	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8455					DimCommand:
.8455	b1 30		lda ($30),y			lda 	(codePtr),y
.8457	29 c0		and #$c0			and 	#$C0
.8459	c9 40		cmp #$40			cmp 	#$40
.845b	d0 7a		bne $84d7			bne 	_DCSyntax
.845d	b1 30		lda ($30),y			lda 	(codePtr),y
.845f	18		clc				clc
.8460	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8462	85 3f		sta $3f				sta 	zaTemp+1
.8464	c8		iny				iny
.8465	b1 30		lda ($30),y			lda 	(codePtr),y
.8467	c8		iny				iny
.8468	85 3e		sta $3e				sta 	zaTemp
.846a	5a		phy				phy
.846b	a0 02		ldy #$02			ldy 	#2 						; read type byte
.846d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.846f	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8471	c9 18		cmp #$18			cmp 	#NSTProcedure
.8473	f0 62		beq $84d7			beq 	_DCSyntax
.8475	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8477	29 04		and #$04			and 	#NSBIsArray
.8479	f0 64		beq $84df			beq 	_DCType
.847b	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.847d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.847f	d0 59		bne $84da			bne 	_DCRedefine
.8481	7a		ply				ply
.8482	20 e2 84	jsr $84e2			jsr 	_DCGetSize 				; get array size, check it.
.8485	5a		phy				phy
.8486	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8488	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.848a	7a		ply				ply 							; is there a second (e.g. ,x)
.848b	b1 30		lda ($30),y			lda 	(codePtr),y
.848d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.848f	d0 0a		bne $849b			bne 	_DCOneDimension
.8491	c8		iny				iny 							; skip comma
.8492	20 e2 84	jsr $84e2			jsr 	_DCGetSize 				; get 2nd array size
.8495	5a		phy				phy
.8496	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8498	91 3e		sta ($3e),y			sta 	(zaTemp),y
.849a	7a		ply				ply
.849b					_DCOneDimension:
.849b	5a		phy				phy 							; save position
.849c	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.849e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a0	aa		tax				tax
.84a1	c8		iny				iny
.84a2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a4	e8		inx				inx 							; bump them.
.84a5	1a		inc a				inc 	a
.84a6	20 47 9e	jsr $9e47			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84a9	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84ab	29 e0		and #$e0			and 	#$E0
.84ad	d0 23		bne $84d2			bne 	_DCSize
.84af	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b3	20 f0 84	jsr $84f0			jsr 	ScaleByBaseType 		; scale by base type
.84b6	a5 36		lda $36				lda 	zTemp0
.84b8	a6 37		ldx $37				ldx 	zTemp0+1
.84ba	20 3d 9a	jsr $9a3d			jsr 	AllocateXABytes 		; allocate memory
.84bd	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84bf	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c1	c8		iny				iny
.84c2	8a		txa				txa
.84c3	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c5	7a		ply				ply 							; get position back
.84c6	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket 		; check )
.84c9	b1 30		lda ($30),y			lda 	(codePtr),y
.84cb	c8		iny				iny 							; consume in case
.84cc	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84ce	f0 85		beq $8455			beq 	DimCommand
.84d0	88		dey				dey 							; undo consume
.84d1	60		rts				rts
.84d2					_DCSize:
.84d2	a9 16		lda #$16		lda	#22
.84d4	4c ef 8d	jmp $8def		jmp	ErrorHandler
.84d7					_DCSyntax:
.84d7	4c 3c a0	jmp $a03c			jmp 	SyntaxError
.84da					_DCRedefine:
.84da	a9 15		lda #$15		lda	#21
.84dc	4c ef 8d	jmp $8def		jmp	ErrorHandler
.84df					_DCType:
.84df	4c 46 a0	jmp $a046			jmp 	TypeError
.84e2					_DCGetSize:
.84e2	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84e4	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 	; get array dimension
.84e7	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84e9	f0 e7		beq $84d2			beq 	_DCSize
.84eb	c9 fe		cmp #$fe			cmp 	#254
.84ed	f0 e3		beq $84d2			beq 	_DCSize
.84ef	60		rts				rts
.84f0					ScaleByBaseType:
.84f0	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f2	d0 19		bne $850d			bne 	_SBBTString
.84f4	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84f6	48		pha				pha
.84f7	a5 36		lda $36				lda 	zTemp0
.84f9	48		pha				pha
.84fa	06 36		asl $36				asl 	zTemp0 					; x 2
.84fc	26 37		rol $37				rol 	zTemp0+1
.84fe	06 36		asl $36				asl 	zTemp0 					; x 4
.8500	26 37		rol $37				rol 	zTemp0+1
.8502	68		pla				pla 							; add stacked value = x 5
.8503	65 36		adc $36				adc 	zTemp0
.8505	85 36		sta $36				sta 	zTemp0
.8507	68		pla				pla
.8508	65 37		adc $37				adc 	zTemp0+1
.850a	85 37		sta $37				sta 	zTemp0+1
.850c	60		rts				rts
.850d					_SBBTString:
.850d	06 36		asl $36				asl 	zTemp0
.850f	26 37		rol $37				rol 	zTemp0+1
.8511	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8512					EndCommand:
.8512	4c 54 83	jmp $8354			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8515					ForCommand:
.8515	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.8517	20 28 a7	jsr $a728			jsr 	StackOpen
.851a	a2 00		ldx #$00			ldx 	#0
.851c	20 78 98	jsr $9878			jsr 	EvaluateTerm
.851f	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8522	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8524	d0 49		bne $856f			bne		_FCError
.8526	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8528	20 e6 8d	jsr $8de6			jsr 	CheckNextA
.852b	e8		inx				inx
.852c	20 fe 9d	jsr $9dfe			jsr 	EvaluateInteger 			; <from> in +1
.852f	b1 30		lda ($30),y			lda 	(codePtr),y
.8531	c8		iny				iny 								; consume it
.8532	48		pha				pha 								; save on stack for later
.8533	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8535	f0 04		beq $853b			beq 	_FCNoSyntax
.8537	c9 ce		cmp #$ce			cmp 	#KWD_TO
.8539	d0 37		bne $8572			bne 	_FCSyntaxError
.853b					_FCNoSyntax:
.853b	e8		inx				inx
.853c	20 fe 9d	jsr $9dfe			jsr 	EvaluateInteger
.853f	20 6c a7	jsr $a76c			jsr 	STKSaveCodePosition 		; save loop back position
.8542	68		pla				pla 								; restore DOWNTO or TO
.8543	5a		phy				phy 								; save Y on the stack
.8544	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8546	f0 02		beq $854a			beq 	_FCNotDownTo
.8548	a9 02		lda #$02			lda 	#2
.854a					_FCNotDownTo:
.854a	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.854b	a0 10		ldy #$10			ldy 	#16
.854d	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.854f	a0 06		ldy #$06			ldy 	#6
.8551	ad 08 04	lda $0408			lda 	NSMantissa0
.8554	91 34		sta ($34),y			sta 	(basicStack),y
.8556	ad 10 04	lda $0410			lda 	NSMantissa1
.8559	c8		iny				iny
.855a	91 34		sta ($34),y			sta 	(basicStack),y
.855c	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.855e	a2 01		ldx #$01			ldx 	#1
.8560	20 75 85	jsr $8575			jsr 	FCIntegerToStack
.8563	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8565	a2 02		ldx #$02			ldx 	#2
.8567	20 75 85	jsr $8575			jsr 	FCIntegerToStack
.856a	20 95 85	jsr $8595			jsr 	CopyIndexToReference
.856d	7a		ply				ply 								; restore position
.856e	60		rts				rts
.856f					_FCError:
.856f	4c 46 a0	jmp $a046			jmp 	TypeError
.8572					_FCSyntaxError:
.8572	4c 3c a0	jmp $a03c			jmp 	SyntaxError
.8575					FCIntegerToStack:
.8575	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.8578	10 03		bpl $857d			bpl	 	_FCNotNegative
.857a	20 67 9e	jsr $9e67			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.857d					_FCNotNegative:
.857d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8580	91 34		sta ($34),y			sta 	(basicStack),y
.8582	c8		iny				iny
.8583	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8586	91 34		sta ($34),y			sta 	(basicStack),y
.8588	c8		iny				iny
.8589	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.858c	91 34		sta ($34),y			sta 	(basicStack),y
.858e	c8		iny				iny
.858f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.8592	91 34		sta ($34),y			sta 	(basicStack),y
.8594	60		rts				rts
.8595					CopyIndexToReference:
.8595	5a		phy				phy
.8596	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8598	38		sec				sec 								; (because we copy from offset 8)
.8599	b1 34		lda ($34),y			lda 	(basicStack),y
.859b	e9 08		sbc #$08			sbc 	#8
.859d	85 36		sta $36				sta 	zTemp0
.859f	c8		iny				iny
.85a0	b1 34		lda ($34),y			lda 	(basicStack),y
.85a2	e9 00		sbc #$00			sbc 	#0
.85a4	85 37		sta $37				sta 	zTemp0+1
.85a6	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85a8	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85aa	b1 34		lda ($34),y			lda 	(basicStack),y
.85ac	0a		asl a				asl 	a 							; into carry
.85ad	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85af	90 14		bcc $85c5			bcc 	_CITRNormal
.85b1	38		sec				sec
.85b2					_CITRNegative:
.85b2	a9 00		lda #$00			lda 	#0
.85b4	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85b6	91 36		sta ($36),y			sta 	(zTemp0),y
.85b8	c8		iny				iny
.85b9	ca		dex				dex
.85ba	d0 f6		bne $85b2			bne 	_CITRNegative
.85bc	88		dey				dey 								; look at MSB of mantissa
.85bd	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85bf	09 80		ora #$80			ora 	#$80
.85c1	91 36		sta ($36),y			sta 	(zTemp0),y
.85c3	7a		ply				ply
.85c4	60		rts				rts
.85c5					_CITRNormal:
.85c5	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85c7	91 36		sta ($36),y			sta 	(zTemp0),y
.85c9	c8		iny				iny
.85ca	ca		dex				dex
.85cb	d0 f8		bne $85c5			bne 	_CITRNormal
.85cd	7a		ply				ply 								; and exit.
.85ce	60		rts				rts
.85cf					NextCommand:
.85cf	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85d1	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d3	20 54 a7	jsr $a754			jsr 	StackCheckFrame
.85d6	5a		phy				phy
.85d7	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85d9	b1 34		lda ($34),y			lda 	(basicStack),y
.85db	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85dd	30 02		bmi $85e1			bmi 	_NCStepNeg
.85df	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85e1					_NCStepNeg:
.85e1	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e3	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85e5	18		clc				clc
.85e6					_NCBump:
.85e6	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85e8	91 34		sta ($34),y			sta 	(basicStack),y
.85ea	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85ec	c8		iny				iny 								; next byte
.85ed	ca		dex				dex 								; do four times
.85ee	d0 f6		bne $85e6			bne 	_NCBump
.85f0	20 95 85	jsr $8595			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f3	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85f5	b1 34		lda ($34),y			lda 	(basicStack),y
.85f7	0a		asl a				asl 	a 							; sign bit to carry
.85f8	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85fa	85 38		sta $38				sta 	zTemp1
.85fc	90 02		bcc $8600			bcc 	_NCCompRev 					; use if step is +ve
.85fe	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8600					_NCCompRev:
.8600	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8602	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8604	85 39		sta $39				sta 	zTemp1+1
.8606	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8608	38		sec				sec
.8609					_NCCompare:
.8609	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.860b	b1 34		lda ($34),y			lda 	(basicStack),y
.860d	a4 39		ldy $39				ldy 	zTemp1+1
.860f	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8611	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8613	e6 39		inc $39				inc 	zTemp1+1
.8615	ca		dex				dex 								; do it 4 times.
.8616	d0 f1		bne $8609			bne 	_NCCompare
.8618	50 02		bvc $861c			bvc 	_NCNoOverflow 				; convert to signed comparison
.861a	49 80		eor #$80			eor 	#$80
.861c					_NCNoOverflow:
.861c	7a		ply				ply 								; restore Y position
.861d	0a		asl a				asl 	a 							; is bit 7 set.
.861e	90 04		bcc $8624			bcc 	_NCLoopback 				; if no , >= so loop back
.8620	20 46 a7	jsr $a746			jsr 	StackClose 					; exit the loop
.8623	60		rts				rts
.8624					_NCLoopBack:
.8624	20 7d a7	jsr $a77d			jsr 	STKLoadCodePosition 		; loop back
.8627	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8628					Command_GOSUB:
.8628	a2 00		ldx #$00			ldx 	#0
.862a	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.862d	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.862f	20 28 a7	jsr $a728			jsr 	StackOpen 					; create frame
.8632	20 6c a7	jsr $a76c			jsr 	STKSaveCodePosition 		; save current position
.8635	4c 4b 86	jmp $864b			jmp 	GotoStackX
.8638					Command_RETURN:
.8638	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.863a	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.863c	20 54 a7	jsr $a754			jsr 	StackCheckFrame
.863f	20 7d a7	jsr $a77d			jsr 	STKLoadCodePosition 		; restore code position
.8642	20 46 a7	jsr $a746			jsr 	StackClose
.8645	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8646					GotoCommand:
.8646	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8648	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger
.864b					GotoStackX:
.864b	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.864e	48		pha				pha 								; it is slightly inefficient, just in cases.
.864f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8652	fa		plx				plx
.8653	20 4c a6	jsr $a64c			jsr 	MemorySearch 				; transfer to line number AX.
.8656	90 05		bcc $865d			bcc 	_GotoError 					; not found, off end.
.8658	d0 03		bne $865d			bne 	_GotoError 					; not found exactly
.865a	4c 8e 8a	jmp $8a8e			jmp 	RunNewLine 					; and go straight to new line code.
.865d					_GotoError:
.865d	a9 0d		lda #$0d		lda	#13
.865f	4c ef 8d	jmp $8def		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8662					IfCommand:
.8662	a2 00		ldx #$00			ldx 	#0 							; If what.
.8664	20 db 9d	jsr $9ddb			jsr 	EvaluateNumber
.8667	b1 30		lda ($30),y			lda 	(codePtr),y
.8669	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.866b	d0 0a		bne $8677			bne 	_IFStructured
.866d	c8		iny				iny 								; consume THEN
.866e	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; is it zero
.8671	f0 01		beq $8674			beq 	_IfFail 					; if fail, go to next line
.8673	60		rts				rts 								; if THEN just continue
.8674					_IfFail:
.8674	4c 76 8a	jmp $8a76			jmp 	EOLCommand
.8677					_IfStructured:
.8677	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; is it zero
.867a	d0 07		bne $8683			bne 	_IfExit 					; if not, then continue normally.
.867c	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.867e	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8680	20 31 8d	jsr $8d31			jsr 	ScanForward 				; and run from there/
.8683					_IfExit:
.8683	60		rts				rts
.8684					ElseCode:
.8684	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8686	aa		tax				tax 								; so just go to the structure exit
.8687	20 31 8d	jsr $8d31			jsr 	ScanForward
.868a	60		rts				rts
.868b					EndIf:
.868b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.868c					Command_Input:
.868c	a9 ff		lda #$ff			lda 	#$FF
.868e	8d a8 04	sta $04a8			sta 	IsInputFlag
.8691	80 03		bra $8696			bra 	Command_IP_Main
.8693					Command_Print:
.8693	9c a8 04	stz $04a8			stz 	IsInputFlag
.8696					Command_IP_Main:
.8696	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.8697					_CPLoop:
.8697	08		php				php 								; save last action flag
.8698	b1 30		lda ($30),y			lda 	(codePtr),y
.869a	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.869c	f0 58		beq $86f6			beq 	_CPExit
.869e	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86a0	f0 54		beq $86f6			beq 	_CPExit
.86a2	68		pla				pla 								; throw last action flag
.86a3	b1 30		lda ($30),y			lda 	(codePtr),y
.86a5	c8		iny				iny
.86a6	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86a8	f0 49		beq $86f3			beq 	_CPContinueWithSameLine
.86aa	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86ac	f0 40		beq $86ee			beq 	_CPTab
.86ae	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86b0	f0 38		beq $86ea			beq 	_CPNewLine
.86b2	88		dey				dey 								; undo the get.
.86b3	20 9c 93	jsr $939c			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86b6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; read the status
.86b9	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86bb	f0 0d		beq $86ca			beq 	_CPIsValue
.86bd	ad a8 04	lda $04a8			lda 	IsInputFlag 				; if print, dereference and print.
.86c0	f0 05		beq $86c7			beq 	_CPIsPrint
.86c2	20 ff 86	jsr $86ff			jsr 	CIInputValue 				; input a value to the reference
.86c5	80 23		bra $86ea			bra 	_CPNewLine
.86c7					_CPIsPrint:
.86c7	20 bc 96	jsr $96bc			jsr 	Dereference
.86ca					_CPIsValue:
.86ca	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.86cd	29 10		and #$10			and 	#NSBIsString
.86cf	f0 0b		beq $86dc			beq 	_CPNumber
.86d1	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.86d4	ad 08 04	lda $0408			lda 	NSMantissa0
.86d7	20 68 87	jsr $8768			jsr 	CPPrintStringXA
.86da	80 ba		bra $8696			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86dc					_CPNumber:
.86dc	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86de	20 a8 9c	jsr $9ca8			jsr 	ConvertNumberToString 		; convert to string
.86e1	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.86e3	a9 1c		lda #$1c			lda 	#DecimalBuffer & $FF
.86e5	20 68 87	jsr $8768			jsr 	CPPrintStringXA
.86e8	80 ac		bra $8696			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86ea					_CPNewLine:
.86ea	a9 0d		lda #$0d			lda 	#13
.86ec	80 02		bra $86f0			bra 	_CPPrintChar
.86ee					_CPTab:
.86ee	a9 09		lda #$09			lda 	#9 							; print TAB
.86f0					_CPPrintChar:
.86f0	20 7b 87	jsr $877b			jsr 	CPPrintVector
.86f3					_CPContinueWithSameLine:
.86f3	38		sec				sec 								; loop round with carry set, which
.86f4	80 a1		bra $8697			bra 	_CPLoop 					; will inhibit final CR
.86f6					_CPExit:
.86f6	28		plp				plp 								; get last action flag
.86f7	b0 05		bcs $86fe			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.86f9	a9 0d		lda #$0d			lda 	#13 						; print new line
.86fb	20 7b 87	jsr $877b			jsr 	CPPrintVector
.86fe					_CPExit2:
.86fe	60		rts				rts
.86ff					CIInputValue:
.86ff	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8701					_CIInputLine:
.8701	20 7e 87	jsr $877e			jsr 	CPInputVector 				; get key
.8704	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8706	f0 1f		beq $8727			beq 	_CIHaveValue
.8708	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.870a	f0 11		beq $871d			beq 	_CIBackspace
.870c	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.870e	90 f1		bcc $8701			bcc 	_CIInputLine
.8710	e0 50		cpx #$50			cpx 	#80 						; max length
.8712	b0 ed		bcs $8701			bcs 	_CIInputLine
.8714	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.8717	e8		inx				inx
.8718	20 7b 87	jsr $877b			jsr 	CPPrintVector 				; echo it.
.871b	80 e4		bra $8701			bra 	_CIInputLine
.871d					_CIBackSpace:
.871d	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.871f	f0 e0		beq $8701			beq 	_CIInputLine
.8721	20 7b 87	jsr $877b			jsr 	CPPrintVector 				; echo it.
.8724	ca		dex				dex
.8725	80 da		bra $8701			bra 	_CIInputLine
.8727					_CIHaveValue:
.8727	9e a9 05	stz $05a9,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.872a	ad 00 04	lda $0400			lda 	NSStatus 					; was it a string assignment
.872d	29 10		and #$10			and 	#NSBIsString
.872f	f0 1c		beq $874d			beq 	_CIAssignNumber 			; assign a number
.8731	a2 01		ldx #$01			ldx 	#1
.8733	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.8735	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8738	a9 05		lda #$05			lda 	#lineBuffer >> 8
.873a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.873d	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.8740	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.8743	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8745	9d 00 04	sta $0400,x			sta  	NSStatus,x
.8748	ca		dex				dex 								; X = 0
.8749	20 bd 87	jsr $87bd			jsr 	AssignVariable
.874c	60		rts				rts
.874d					_CIAssignNumber:
.874d	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.874f	85 36		sta $36				sta 	zTemp0
.8751	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8753	85 37		sta $37				sta 	zTemp0+1
.8755	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8757	20 2a 9c	jsr $9c2a			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.875a	90 07		bcc $8763			bcc 	_CIIsOkay
.875c	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.875e	20 7b 87	jsr $877b			jsr 	CPPrintVector
.8761	80 9c		bra $86ff			bra 	CIInputValue
.8763					_CIIsOkay:
.8763	ca		dex				dex 								; X = 0
.8764	20 bd 87	jsr $87bd			jsr 	AssignVariable
.8767	60		rts				rts
.8768					CPPrintStringXA:
.8768	5a		phy				phy
.8769	86 37		stx $37				stx 	zTemp0+1
.876b	85 36		sta $36				sta 	zTemp0
.876d	a0 00		ldy #$00			ldy 	#0
.876f					_PSXALoop:
.876f	b1 36		lda ($36),y			lda 	(zTemp0),y
.8771	f0 06		beq $8779			beq 	_PSXAExit
.8773	20 7b 87	jsr $877b			jsr 	CPPrintVector
.8776	c8		iny				iny
.8777	80 f6		bra $876f			bra 	_PSXALoop
.8779					_PSXAExit:
.8779	7a		ply				ply
.877a	60		rts				rts
.877b					CPPrintVector:
.877b	4c 68 a8	jmp $a868			jmp 	EXTPrintCharacter
.877e					CPInputVector:
.877e	4c fe aa	jmp $aafe			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8781					LetCommand:
.8781	a2 00		ldx #$00			ldx 	#0
.8783	b1 30		lda ($30),y			lda 	(codePtr),y
.8785	c9 10		cmp #$10			cmp 	#KWD_AT
.8787	d0 16		bne $879f			bne 	_LCStandard
.8789	c8		iny				iny 								; skip equal
.878a	20 78 98	jsr $9878			jsr 	EvaluateTerm 				; get a number
.878d	20 bc 96	jsr $96bc			jsr 	Dereference 				; dereference it
.8790	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.8793	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8795	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8798	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.879a	d0 10		bne $87ac			bne 	_LCMain
.879c	4c 46 a0	jmp $a046			jmp 	TypeError 					; was a reference before.
.879f					_LCStandard:
.879f	ad 86 93	lda $9386			lda 	PrecedenceLevel+"*"			; precedence > this
.87a2	20 a0 93	jsr $93a0			jsr 	EvaluateExpressionAtPrecedence
.87a5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.87a8	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87aa	f0 0e		beq $87ba			beq 	_LetGoProc 					; it's a procedure call.
.87ac					_LCMain:
.87ac	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87ae	20 e6 8d	jsr $8de6			jsr 	CheckNextA
.87b1	e8		inx				inx 								; RHS
.87b2	20 d2 9d	jsr $9dd2			jsr 	EvaluateValue
.87b5	ca		dex				dex
.87b6	20 bd 87	jsr $87bd			jsr 	AssignVariable
.87b9	60		rts				rts
.87ba					_LetGoProc:
.87ba	4c 4e 89	jmp $894e			jmp 	CallProcedure
.87bd					AssignVariable:
.87bd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.87c0	48		pha				pha 								; save a copy
.87c1	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.87c4	29 10		and #$10			and 	#NSBIsString
.87c6	d0 0b		bne $87d3			bne 	_ASError
.87c8	68		pla				pla 								; get back
.87c9	29 10		and #$10			and 	#NSBIsString 				; check type
.87cb	d0 03		bne $87d0			bne 	_ASString
.87cd	4c e4 95	jmp $95e4			jmp 	AssignNumber
.87d0					_ASString:
.87d0	4c 52 96	jmp $9652			jmp 	AssignString
.87d3					_ASError:
.87d3	4c 46 a0	jmp $a046			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87d6					Command_List:
.87d6	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.87d9	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87dc	9c 14 04	stz $0414			stz 	NSMantissa1+4
.87df	a9 ff		lda #$ff			lda 	#$FF
.87e1	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.87e4	8d 17 04	sta $0417			sta 	NSMantissa1+7
.87e7	b1 30		lda ($30),y			lda 	(codePtr),y
.87e9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87eb	f0 1e		beq $880b			beq 	_CLSecond
.87ed	20 6c 88	jsr $886c			jsr 	CLIsDigit 					; if not digit, list all
.87f0	b0 24		bcs $8816			bcs 	_CLStart
.87f2	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.87f4	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger
.87f7	b1 30		lda ($30),y			lda 	(codePtr),y
.87f9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87fb	f0 0e		beq $880b			beq 	_CLSecond 					; if so go get it
.87fd	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.8800	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.8803	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8806	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8809	80 0b		bra $8816			bra 	_CLStart
.880b					_CLSecond:
.880b	c8		iny				iny 								; consume comma
.880c	20 6c 88	jsr $886c			jsr 	CLIsDigit 					; digit found
.880f	b0 05		bcs $8816			bcs 	_CLStart 					; if not, continue listing
.8811	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8813	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger
.8816					_CLStart
.8816	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8818	85 30		sta $30				sta 	codePtr
.881a	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.881c	85 31		sta $31				sta 	codePtr+1
.881e					_CLLoop:
.881e	20 1e ab	jsr $ab1e			jsr 	EXTBreakCheck 				; break check
.8821	f0 33		beq $8856			beq 	_CLExit
.8823	b2 30		lda ($30)			lda 	(codePtr)
.8825	f0 2f		beq $8856			beq 	_CLExit
.8827	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8829	20 59 88	jsr $8859			jsr 	CLCompareLineNo
.882c	90 1b		bcc $8849			bcc 	_CLNext
.882e	a2 07		ldx #$07			ldx 	#7
.8830	20 59 88	jsr $8859			jsr 	CLCompareLineNo
.8833	f0 02		beq $8837			beq 	_CLDoThisOne
.8835	b0 12		bcs $8849			bcs 	_CLNext
.8837					_CLDoThisOne:
.8837	20 94 8d	jsr $8d94			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.883a	20 68 b4	jsr $b468			jsr 	ListConvertLine 			; convert line into token Buffer
.883d	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.883f	a9 ac		lda #$ac			lda 	#(tokenBuffer & $FF)
.8841	20 48 8e	jsr $8e48			jsr 	PrintStringXA
.8844	a9 0d		lda #$0d			lda 	#13 						; new line
.8846	20 68 a8	jsr $a868			jsr 	EXTPrintCharacter
.8849					_CLNext:
.8849	18		clc				clc
.884a	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.884c	65 30		adc $30				adc 	codePtr
.884e	85 30		sta $30				sta 	codePtr
.8850	90 02		bcc $8854			bcc 	_CREExit
.8852	e6 31		inc $31				inc 	codePtr+1
.8854					_CREExit:
.8854	80 c8		bra $881e			bra 	_CLLoop
.8856					_CLExit:
.8856	4c 54 83	jmp $8354			jmp 	WarmStart
.8859					CLCompareLineNo:
.8859	38		sec				sec
.885a	a0 01		ldy #$01			ldy 	#1
.885c	b1 30		lda ($30),y			lda 	(codePtr),y
.885e	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.8861	85 36		sta $36				sta 	zTemp0
.8863	c8		iny				iny
.8864	b1 30		lda ($30),y			lda 	(codePtr),y
.8866	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8869	05 36		ora $36				ora 	zTemp0
.886b	60		rts				rts
.886c					CLIsDigit:
.886c	b1 30		lda ($30),y			lda 	(codePtr),y
.886e	c9 30		cmp #$30			cmp 	#"0"
.8870	90 03		bcc $8875			bcc	 	_CLIDExitFalse
.8872	c9 3a		cmp #$3a			cmp 	#"9"+1
.8874	60		rts				rts
.8875					_CLIDExitFalse:
.8875	38		sec				sec
.8876	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8877					Command_LOCAL:
.8877	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8879	20 85 88	jsr $8885			jsr 	LocaliseNextTerm 			; convert term to a local.
.887c	b1 30		lda ($30),y			lda 	(codePtr),y
.887e	c8		iny				iny
.887f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8881	f0 f4		beq $8877			beq 	Command_LOCAL
.8883	88		dey				dey 								; unpick pre-get
.8884	60		rts				rts
.8885					LocaliseNextTerm:
.8885	20 78 98	jsr $9878			jsr 	EvaluateTerm 				; evaluate the term
.8888	bd 00 04	lda $0400,x			lda 	NSStatus,x
.888b	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.888d	f0 61		beq $88f0			beq		_LNTError
.888f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8892	85 36		sta $36				sta 	zTemp0
.8894	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8897	85 37		sta $37				sta  	zTemp0+1
.8899	bd 00 04	lda $0400,x			lda 	NSStatus,x
.889c	29 10		and #$10			and 	#NSBIsString
.889e	d0 1e		bne $88be			bne 	_LNTPushString
.88a0	5a		phy				phy
.88a1	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.88a3					_LNTPushNumLoop:
.88a3	b1 36		lda ($36),y			lda		(zTemp0),y
.88a5	20 06 a7	jsr $a706			jsr 	StackPushByte
.88a8	c8		iny				iny
.88a9	c0 05		cpy #$05			cpy 	#5
.88ab	d0 f6		bne $88a3			bne 	_LNTPushNumLoop
.88ad	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.88af	20 06 a7	jsr $a706			jsr 	StackPushByte
.88b2	a5 37		lda $37				lda 	zTemp0+1
.88b4	20 06 a7	jsr $a706			jsr 	StackPushByte
.88b7	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88b9	20 06 a7	jsr $a706			jsr 	StackPushByte
.88bc	7a		ply				ply
.88bd	60		rts				rts
.88be					_LNTPushString:
.88be	5a		phy				phy
.88bf	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88c1	85 38		sta $38				sta 	zTemp1
.88c3	a0 01		ldy #$01			ldy 	#1
.88c5	b1 36		lda ($36),y			lda 	(zTemp0),y
.88c7	85 39		sta $39				sta 	zTemp1+1
.88c9	a0 00		ldy #$00			ldy 	#0 							; output string
.88cb	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88cd	f0 0a		beq $88d9			beq 	_LNTStringOut
.88cf					_LNTPushStrLoop:
.88cf	b1 38		lda ($38),y			lda 	(zTemp1),y
.88d1	f0 06		beq $88d9			beq 	_LNTStringOut
.88d3	20 06 a7	jsr $a706			jsr 	StackPushByte
.88d6	c8		iny				iny
.88d7	80 f6		bra $88cf			bra 	_LNTPushStrLoop
.88d9					_LNTStringOut:
.88d9	98		tya				tya									; output length
.88da	20 06 a7	jsr $a706			jsr 	StackPushByte
.88dd	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.88e0	20 06 a7	jsr $a706			jsr 	StackPushByte
.88e3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.88e6	20 06 a7	jsr $a706			jsr 	StackPushByte
.88e9	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.88eb	20 06 a7	jsr $a706			jsr 	StackPushByte
.88ee	7a		ply				ply
.88ef	60		rts				rts
.88f0					_LNTError:
.88f0	4c 3c a0	jmp $a03c			jmp 	SyntaxError
.88f3					LocalPopValue:
.88f3	20 1f a7	jsr $a71f			jsr 	StackPopByte
.88f6	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.88f8	d0 17		bne $8911			bne 	_LPVString
.88fa	20 1f a7	jsr $a71f			jsr 	StackPopByte 				; address
.88fd	85 37		sta $37				sta 	zTemp0+1
.88ff	20 1f a7	jsr $a71f			jsr 	StackPopByte
.8902	85 36		sta $36				sta 	zTemp0
.8904	5a		phy				phy
.8905	a0 04		ldy #$04			ldy 	#4 							; copy back
.8907					_LPVNumberCopy:
.8907	20 1f a7	jsr $a71f			jsr 	StackPopByte
.890a	91 36		sta ($36),y			sta 	(zTemp0),y
.890c	88		dey				dey
.890d	10 f8		bpl $8907			bpl 	_LPVNumberCopy
.890f	7a		ply				ply 								; and complete
.8910	60		rts				rts
.8911					_LPVString:
.8911	20 1f a7	jsr $a71f			jsr 	StackPopByte 				; address of record => zTemp0
.8914	85 37		sta $37				sta 	zTemp0+1
.8916	20 1f a7	jsr $a71f			jsr 	StackPopByte
.8919	85 36		sta $36				sta 	zTemp0
.891b	5a		phy				phy
.891c	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.891e	85 38		sta $38				sta 	zTemp1
.8920	a0 01		ldy #$01			ldy 	#1
.8922	b1 36		lda ($36),y			lda 	(zTemp0),y
.8924	85 39		sta $39				sta 	zTemp1+1
.8926	20 1f a7	jsr $a71f			jsr 	StackPopByte 				; # to get => y
.8929	a8		tay				tay
.892a	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.892c	f0 0e		beq $893c			beq 	_LPVStringCopied
.892e	a9 00		lda #$00			lda 	#0 							; NULL on end
.8930	91 38		sta ($38),y			sta 	(zTemp1),y
.8932					_LPVStringCopy:
.8932	88		dey				dey
.8933	30 07		bmi $893c			bmi 	_LPVStringCopied
.8935	20 1f a7	jsr $a71f			jsr 	StackPopByte
.8938	91 38		sta ($38),y			sta 	(zTemp1),y
.893a	80 f6		bra $8932			bra 	_LPVStringCopy
.893c					_LPVStringCopied:
.893c	fa		plx				plx
.893d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.893e					NewCommand:
.893e	20 44 89	jsr $8944			jsr 	NewProgram
.8941	4c 54 83	jmp $8354			jmp 	WarmStart
.8944					NewProgram:
.8944	20 2a a6	jsr $a62a			jsr 	MemoryNew
.8947	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.894a	20 ed 83	jsr $83ed			jsr 	ClearCommand 				; clear everything.
.894d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.894e					CallProcedure:
.894e	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8950	b1 30		lda ($30),y			lda 	(codePtr),y
.8952	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8954	f0 0c		beq $8962			beq 	_CPEndParam
.8956					_CPParamLoop:
.8956	20 d2 9d	jsr $9dd2			jsr 	EvaluateValue 				; get parameter onto stack
.8959	e8		inx				inx 								; bump next stack
.895a	b1 30		lda ($30),y			lda 	(codePtr),y
.895c	c8		iny				iny
.895d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.895f	f0 f5		beq $8956			beq 	_CPParamLoop
.8961	88		dey				dey 								; unpick.
.8962					_CPEndParam:
.8962	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.8965	c8		iny				iny									; skip right bracket
.8966	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8968	20 28 a7	jsr $a728			jsr 	StackOpen
.896b	20 6c a7	jsr $a76c			jsr 	STKSaveCodePosition 		; save loop position
.896e	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8971	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8973	ad 10 04	lda $0410			lda 	NSMantissa1
.8976	85 37		sta $37				sta 	zTemp0+1
.8978	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.897a	b2 36		lda ($36)			lda 	(zTemp0)
.897c	85 30		sta $30				sta 	safePtr
.897e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8980	85 31		sta $31				sta 	safePtr+1
.8982	c8		iny				iny
.8983	b1 36		lda ($36),y			lda 	(zTemp0),y
.8985	85 32		sta $32				sta 	safePtr+2
.8987	c8		iny				iny
.8988	b1 36		lda ($36),y			lda 	(zTemp0),y
.898a	85 33		sta $33				sta 	safePtr+3
.898c	c8		iny				iny 								; get Y offset -> Y
.898d	b1 36		lda ($36),y			lda 	(zTemp0),y
.898f	a8		tay				tay
.8990	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8992	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.8995	f0 13		beq $89aa			beq 	_ParamExit 					; if so, exit.
.8997					_ParamExtract:
.8997	ca		dex				dex 								; put a local term on the level before
.8998	20 85 88	jsr $8885			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.899b	20 bd 87	jsr $87bd			jsr 	AssignVariable 				; assign stacked value to the variable.
.899e	e8		inx				inx 								; advance to next parameter to do.
.899f	e8		inx				inx
.89a0	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.89a3	f0 05		beq $89aa			beq 	_ParamExit
.89a5	20 de 8d	jsr $8dde			jsr 	CheckComma 					; comma seperating parameters
.89a8	80 ed		bra $8997			bra 	_ParamExtract
.89aa					_ParamExit:
.89aa	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket 			; check )
.89ad	60		rts				rts 								; and continue from here
.89ae					Command_ENDPROC:
.89ae	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.89b0	a2 14		ldx #$14			ldx 	#ERRID_PROC
.89b2	20 54 a7	jsr $a754			jsr 	StackCheckFrame
.89b5	20 7d a7	jsr $a77d			jsr 	STKLoadCodePosition 		; restore code position
.89b8	20 46 a7	jsr $a746			jsr 	StackClose
.89bb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89bc					Command_Read:
.89bc	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89be	20 78 98	jsr $9878			jsr 	EvaluateTerm
.89c1	bd 00 04	lda $0400,x			lda 	NSStatus,x
.89c4	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89c6	f0 4a		beq $8a12			beq 	_CRSyntax 					; check reference (bit 0)
.89c8	20 5b 8a	jsr $8a5b			jsr 	SwapDataCodePtrs 			; swap code and data
.89cb	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89ce	d0 20		bne $89f0			bne 	_CRContinueData
.89d0					_CRKeepSearching:
.89d0	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89d2	aa		tax				tax
.89d3	20 31 8d	jsr $8d31			jsr 	ScanForward
.89d6	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.89d8	f0 16		beq $89f0			beq 	_CRHaveData 				; found it
.89da	18		clc				clc
.89db	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.89dd	65 30		adc $30				adc 	codePtr
.89df	85 30		sta $30				sta 	codePtr
.89e1	90 02		bcc $89e5			bcc 	_CREExit
.89e3	e6 31		inc $31				inc 	codePtr+1
.89e5					_CREExit:
.89e5	a0 03		ldy #$03			ldy 	#3 							; start of line.
.89e7	b2 30		lda ($30)			lda 	(codePtr)
.89e9	d0 e5		bne $89d0			bne 	_CRKeepSearching
.89eb	a9 0b		lda #$0b		lda	#11
.89ed	4c ef 8d	jmp $8def		jmp	ErrorHandler
.89f0					_CRHaveData:
.89f0					_CRContinueData:
.89f0	a2 01		ldx #$01			ldx 	#1
.89f2	20 d2 9d	jsr $9dd2			jsr 	EvaluateValue 				; evaluate value into slot # 1
.89f5	ca		dex				dex
.89f6	20 bd 87	jsr $87bd			jsr		AssignVariable 				; do the assignment
.89f9	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.89fc	b1 30		lda ($30),y			lda 	(codePtr),y
.89fe	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a00	d0 04		bne $8a06			bne 	_CRSwapBack
.8a02	c8		iny				iny 								; consume comma
.8a03	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8a06					_CRSwapBack:
.8a06	20 5b 8a	jsr $8a5b			jsr 	SwapDataCodePtrs			; swap them back.
.8a09	b1 30		lda ($30),y			lda 	(codePtr),y
.8a0b	c8		iny				iny
.8a0c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a0e	f0 ac		beq $89bc			beq 	Command_Read 				; if so go round again.
.8a10	88		dey				dey 								; unpick get.
.8a11	60		rts				rts
.8a12					_CRSyntax:
.8a12	4c 3c a0	jmp $a03c			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a15					RemCommand:
.8a15	b1 30		lda ($30),y			lda 	(codePtr),y
.8a17	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a19	d0 06		bne $8a21			bne 	_RMExit
.8a1b	c8		iny				iny
.8a1c	98		tya				tya
.8a1d	38		sec				sec
.8a1e	71 30		adc ($30),y			adc 	(codePtr),y
.8a20	a8		tay				tay
.8a21					_RMExit:
.8a21	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a22					Command_REPEAT:
.8a22	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a24	20 28 a7	jsr $a728			jsr 	StackOpen
.8a27	20 6c a7	jsr $a76c			jsr 	STKSaveCodePosition 		; save loop position
.8a2a	60		rts				rts
.8a2b					Command_UNTIL:
.8a2b	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a2d	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a2f	20 54 a7	jsr $a754			jsr 	StackCheckFrame
.8a32	a2 00		ldx #$00			ldx 	#0
.8a34	20 db 9d	jsr $9ddb			jsr 	EvaluateNumber 				; work out the number
.8a37	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; check if zero
.8a3a	f0 04		beq $8a40			beq 	_CULoopBack 				; if so keep looping
.8a3c	20 46 a7	jsr $a746			jsr 	StackClose		 			; return
.8a3f	60		rts				rts
.8a40					_CULoopBack:
.8a40	20 7d a7	jsr $a77d			jsr 	STKLoadCodePosition 		; loop back
.8a43	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a44					Command_Restore:
.8a44	20 5b 8a	jsr $8a5b			jsr 	SwapDataCodePtrs 			; swap code and data
.8a47	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a49	85 30		sta $30				sta 	codePtr
.8a4b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a4d	85 31		sta $31				sta 	codePtr+1
.8a4f	20 5b 8a	jsr $8a5b			jsr 	SwapDataCodePtrs 			; put them back
.8a52	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a54	8d 9b 04	sta $049b			sta 	dataPointer+4
.8a57	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.8a5a	60		rts				rts
.8a5b					SwapDataCodePtrs:
.8a5b	da		phx				phx
.8a5c	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a5e					_SDCPLoop:
.8a5e	b5 30		lda $30,x			lda 	safePtr,x
.8a60	48		pha				pha
.8a61	bd 97 04	lda $0497,x			lda 	dataPointer,x
.8a64	95 30		sta $30,x			sta 	safePtr,x
.8a66	68		pla				pla
.8a67	9d 97 04	sta $0497,x			sta 	dataPointer,x
.8a6a	ca		dex				dex
.8a6b	10 f1		bpl $8a5e			bpl 	_SDCPLoop
.8a6d	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.8a70	8c 9b 04	sty $049b			sty 	dataPointer+4
.8a73	a8		tay				tay
.8a74	fa		plx				plx
.8a75	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a76					EOLCommand:
.8a76	18		clc				clc
.8a77	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8a79	65 30		adc $30				adc 	codePtr
.8a7b	85 30		sta $30				sta 	codePtr
.8a7d	90 02		bcc $8a81			bcc 	_CREExit
.8a7f	e6 31		inc $31				inc 	codePtr+1
.8a81					_CREExit:
.8a81	80 0b		bra $8a8e			bra 	RunNewLine
.8a83					CommandRUN:
.8a83	20 ed 83	jsr $83ed			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a86	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a88	85 30		sta $30				sta 	codePtr
.8a8a	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a8c	85 31		sta $31				sta 	codePtr+1
.8a8e					RUNNewLine:
.8a8e	b2 30		lda ($30)			lda 	(codePtr)
.8a90	f0 72		beq $8b04			beq 	CRNoProgram         		; no then END.
.8a92	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a94	9a		txs				txs
.8a95					RUNCodePointerLine:
.8a95	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a97					_CRIncMainLoop:
.8a97	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8a9a	d0 19		bne $8ab5			bne 	_CRNoBreakCheck
.8a9c	20 1e ab	jsr $ab1e			jsr 	EXTBreakCheck 				; break check
.8a9f	f0 5e		beq $8aff			beq 	_CRBreak
.8aa1	64 01		stz $01				stz 	1 							; access I/O Page 0
.8aa3	38		sec				sec 								; calculate timer - LastTick
.8aa4	ad 59 d6	lda $d659			lda 	$D659
.8aa7	aa		tax				tax 								; saving timer in X
.8aa8	ed 2e 06	sbc $062e			sbc 	LastTick
.8aab	c9 03		cmp #$03			cmp 	#3
.8aad	90 06		bcc $8ab5			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8aaf	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.8ab2	20 83 ba	jsr $ba83			jsr 	TickHandler 				; go do the code.
.8ab5					_NoFireTick:
.8ab5					_CRNoBreakCheck:
.8ab5	c8		iny				iny
.8ab6					_CRMainLoop:
.8ab6	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8ab9	b1 30		lda ($30),y			lda 	(codePtr),y
.8abb	10 10		bpl $8acd			bpl 	_CRNotKeyword
.8abd	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8abf	b0 04		bcs $8ac5			bcs 	_CRIsKeyword
.8ac1	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8ac3	b0 34		bcs $8af9			bcs		_CRSyntaxError
.8ac5					_CRIsKeyword:
.8ac5	c8		iny				iny 								; consume command
.8ac6	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8ac7	aa		tax				tax 								; put in X for vector jump
.8ac8	20 fc 8a	jsr $8afc			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8acb	80 e9		bra $8ab6			bra 	_CRMainLoop 				; and loop round
.8acd					_CRNotKeyword:
.8acd	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8acf	f0 c6		beq $8a97			beq 	_CRIncMainLoop
.8ad1	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8ad3	90 05		bcc $8ada			bcc 	_CRNotVariable
.8ad5					_CRGoLet:
.8ad5	20 81 87	jsr $8781			jsr 	LetCommand
.8ad8	80 dc		bra $8ab6			bra 	_CRMainLoop
.8ada					_CRNotVariable:
.8ada	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8adc	f0 f7		beq $8ad5			beq 	_CRGoLet
.8ade	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8ae0	f0 f3		beq $8ad5			beq 	_CRGoLet
.8ae2	c9 21		cmp #$21			cmp 	#KWD_PLING
.8ae4	f0 ef		beq $8ad5			beq 	_CRGoLet
.8ae6	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8ae8	f0 09		beq $8af3			beq 	_CRGoRem
.8aea	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8aec	d0 0b		bne $8af9			bne 	_CRSyntaxError
.8aee	20 12 82	jsr $8212			jsr 	LabelHere
.8af1	80 c3		bra $8ab6			bra 	_CRMainLoop
.8af3					_CRGoRem:
.8af3	c8		iny				iny
.8af4	20 15 8a	jsr $8a15			jsr 	RemCommand
.8af7	80 bd		bra $8ab6			bra 	_CRMainLoop
.8af9					_CRSyntaxError:
.8af9	4c 3c a0	jmp $a03c			jmp 	SyntaxError
.8afc					_CRCallVector0:
.8afc	7c 9a 8b	jmp ($8b9a,x)			jmp 	(VectorSet0,x)
.8aff					_CRBreak:
.8aff	a9 01		lda #$01		lda	#1
.8b01	4c ef 8d	jmp $8def		jmp	ErrorHandler
.8b04					CRNoProgram:
.8b04	4c 12 85	jmp $8512			jmp 	EndCommand
.8b07					Shift1Command:
.8b07	b1 30		lda ($30),y			lda 	(codePtr),y
.8b09	c8		iny				iny
.8b0a	0a		asl a				asl 	a
.8b0b	aa		tax				tax
.8b0c	7c 38 8c	jmp ($8c38,x)			jmp 	(VectorSet1,x)
.8b0f					Shift2Command:
.8b0f	b1 30		lda ($30),y			lda 	(codePtr),y
.8b11	c8		iny				iny
.8b12	0a		asl a				asl 	a
.8b13	aa		tax				tax
.8b14	7c 52 8c	jmp ($8c52,x)			jmp 	(VectorSet2,x)
.8b17					Unused1:
.8b17					Unused2:
.8b17					Unused3:
.8b17					Unused4:
.8b17	4c 3c a0	jmp $a03c			jmp 	SyntaxError
>8b1a							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b1a					VectorSetPunc:
>8b1a	dc 90					.word	ShiftLeft                        ; $00 <<
>8b1c	93 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8b1e	89 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8b20	3c a0					.word	SyntaxError                      ; $03 !!3
>8b22	3c a0					.word	SyntaxError                      ; $04 ><
>8b24	9d 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b26	df 90					.word	ShiftRight                       ; $06 >>
>8b28	3c a0					.word	SyntaxError                      ; $07 !!7
>8b2a	3c a0					.word	SyntaxError                      ; $08 !!8
>8b2c	3c a0					.word	SyntaxError                      ; $09 !!9
>8b2e	3c a0					.word	SyntaxError                      ; $0a !!10
>8b30	3c a0					.word	SyntaxError                      ; $0b !!11
>8b32	3c a0					.word	SyntaxError                      ; $0c !!12
>8b34	3c a0					.word	SyntaxError                      ; $0d !!13
>8b36	3c a0					.word	SyntaxError                      ; $0e !!14
>8b38	3c a0					.word	SyntaxError                      ; $0f !!15
>8b3a	3c a0					.word	SyntaxError                      ; $10 @
>8b3c	3c a0					.word	SyntaxError                      ; $11 !!17
>8b3e	3c a0					.word	SyntaxError                      ; $12 !!18
>8b40	3c a0					.word	SyntaxError                      ; $13 [
>8b42	60 8f					.word	IntegerDivide                    ; $14 \
>8b44	3c a0					.word	SyntaxError                      ; $15 ]
>8b46	6d 92					.word	EorInteger                       ; $16 ^
>8b48	3c a0					.word	SyntaxError                      ; $17 _
>8b4a	3c a0					.word	SyntaxError                      ; $18 `
>8b4c	3c a0					.word	SyntaxError                      ; $19 !!25
>8b4e	3c a0					.word	SyntaxError                      ; $1a !!26
>8b50	3c a0					.word	SyntaxError                      ; $1b {
>8b52	27 92					.word	OraInteger                       ; $1c |
>8b54	3c a0					.word	SyntaxError                      ; $1d }
>8b56	3c a0					.word	SyntaxError                      ; $1e ~
>8b58	3c a0					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b5a	3c a0					.word	SyntaxError                      ; $20
>8b5c	b3 92					.word	WordIndirect                     ; $21 !
>8b5e	3c a0					.word	SyntaxError                      ; $22 "
>8b60	3c a0					.word	SyntaxError                      ; $23 #
>8b62	3c a0					.word	SyntaxError                      ; $24 $
>8b64	ad 8f					.word	IntegerModulus                   ; $25 %
>8b66	e1 91					.word	AndInteger                       ; $26 &
>8b68	3c a0					.word	SyntaxError                      ; $27 '
>8b6a	3c a0					.word	SyntaxError                      ; $28 (
>8b6c	3c a0					.word	SyntaxError                      ; $29 )
>8b6e	22 90					.word	MulInteger                       ; $2a *
>8b70	73 91					.word	AddInteger                       ; $2b +
>8b72	3c a0					.word	SyntaxError                      ; $2c ,
>8b74	b6 91					.word	SubInteger                       ; $2d -
>8b76	3c a0					.word	SyntaxError                      ; $2e .
>8b78	9e 94					.word	FDivideCommand                   ; $2f /
>8b7a	3c a0					.word	SyntaxError                      ; $30 0
>8b7c	3c a0					.word	SyntaxError                      ; $31 1
>8b7e	3c a0					.word	SyntaxError                      ; $32 2
>8b80	3c a0					.word	SyntaxError                      ; $33 3
>8b82	3c a0					.word	SyntaxError                      ; $34 4
>8b84	3c a0					.word	SyntaxError                      ; $35 5
>8b86	3c a0					.word	SyntaxError                      ; $36 6
>8b88	3c a0					.word	SyntaxError                      ; $37 7
>8b8a	3c a0					.word	SyntaxError                      ; $38 8
>8b8c	3c a0					.word	SyntaxError                      ; $39 9
>8b8e	3c a0					.word	SyntaxError                      ; $3a :
>8b90	3c a0					.word	SyntaxError                      ; $3b ;
>8b92	75 8e					.word	BinaryCompareLess                ; $3c <
>8b94	6b 8e					.word	BinaryCompareEqual               ; $3d =
>8b96	7f 8e					.word	BinaryCompareGreater             ; $3e >
>8b98	da 92					.word	ByteIndirect                     ; $3f ?
.8b9a					VectorSet0:
>8b9a	76 8a					.word	EOLCommand                       ; $80 !0:EOF
>8b9c	07 8b					.word	Shift1Command                    ; $81 !1:SH1
>8b9e	0f 8b					.word	Shift2Command                    ; $82 !2:SH2
>8ba0	0e 9a					.word	AbsUnary                         ; $83 ABS(
>8ba2	1e 9a					.word	AllocUnary                       ; $84 ALLOC(
>8ba4	8e 9a					.word	AscUnary                         ; $85 ASC(
>8ba6	59 9c					.word	ChrUnary                         ; $86 CHR$(
>8ba8	ad a4					.word	UnaryEvent                       ; $87 EVENT(
>8baa	67 8e					.word	UnaryFalse                       ; $88 FALSE
>8bac	9b 9a					.word	FracUnary                        ; $89 FRAC(
>8bae	43 a4					.word	UnaryHit                         ; $8a HIT(
>8bb0	b1 9a					.word	IntUnary                         ; $8b INT(
>8bb2	18 9c					.word	IsValUnary                       ; $8c ISVAL(
>8bb4	3d a5					.word	UnaryJoyB                        ; $8d JOYB(
>8bb6	16 a5					.word	UnaryJoyX                        ; $8e JOYX(
>8bb8	19 a5					.word	UnaryJoyY                        ; $8f JOYY(
>8bba	33 9d					.word	Unary_Left                       ; $90 LEFT$(
>8bbc	c3 9a					.word	LenUnary                         ; $91 LEN(
>8bbe	e1 9a					.word	Unary_Max                        ; $92 MAX(
>8bc0	5d 9d					.word	Unary_Mid                        ; $93 MID$(
>8bc2	dd 9a					.word	Unary_Min                        ; $94 MIN(
>8bc4	38 9b					.word	Unary_Not                        ; $95 NOT(
>8bc6	7f a6					.word	UnaryPlaying                     ; $96 PLAYING(
>8bc8	4e 9b					.word	Unary_Random                     ; $97 RANDOM(
>8bca	43 9d					.word	Unary_Right                      ; $98 RIGHT$(
>8bcc	6d 9b					.word	Unary_Rnd                        ; $99 RND(
>8bce	ee 9b					.word	SgnUnary                         ; $9a SGN(
>8bd0	6b 9c					.word	SpcUnary                         ; $9b SPC(
>8bd2	86 9c					.word	Unary_Str                        ; $9c STR$(
>8bd4	51 a5					.word	UnaryTimer                       ; $9d TIMER(
>8bd6	5b 8e					.word	UnaryTrue                        ; $9e TRUE
>8bd8	0e 9c					.word	ValUnary                         ; $9f VAL(
>8bda	15 85					.word	ForCommand                       ; $a0 FOR
>8bdc	62 86					.word	IfCommand                        ; $a1 IF
>8bde	17 8b					.word	Unused1                          ; $a2 PROC
>8be0	22 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8be2	a7 8d					.word	Command_WHILE                    ; $a4 WHILE
>8be4	8b 86					.word	EndIf                            ; $a5 ENDIF
>8be6	ae 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8be8	cf 85					.word	NextCommand                      ; $a7 NEXT
>8bea	17 8b					.word	Unused4                          ; $a8 THEN
>8bec	2b 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8bee	c8 8d					.word	Command_WEND                     ; $aa WEND
>8bf0	3c a0					.word	SyntaxError                      ; $ab BY
>8bf2	b3 83					.word	CallCommand                      ; $ac CALL
>8bf4	e5 a1					.word	CircleCommand                    ; $ad CIRCLE
>8bf6	ed 83					.word	ClearCommand                     ; $ae CLEAR
>8bf8	45 84					.word	ClearScreen                      ; $af CLS
>8bfa	3c a0					.word	SyntaxError                      ; $b0 COLOR
>8bfc	3c a0					.word	SyntaxError                      ; $b1 COLOUR
>8bfe	4d 84					.word	Command_Data                     ; $b2 DATA
>8c00	55 84					.word	DimCommand                       ; $b3 DIM
>8c02	17 8b					.word	Unused3                          ; $b4 DOWNTO
>8c04	84 86					.word	ElseCode                         ; $b5 ELSE
>8c06	3c a0					.word	SyntaxError                      ; $b6 FROM
>8c08	11 a4					.word	GfxCommand                       ; $b7 GFX
>8c0a	28 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c0c	46 86					.word	GotoCommand                      ; $b9 GOTO
>8c0e	3c a0					.word	SyntaxError                      ; $ba HERE
>8c10	0f a2					.word	ImageCommand                     ; $bb IMAGE
>8c12	8c 86					.word	Command_Input                    ; $bc INPUT
>8c14	81 87					.word	LetCommand                       ; $bd LET
>8c16	64 a2					.word	LineCommand                      ; $be LINE
>8c18	77 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c1a	3c a0					.word	SyntaxError                      ; $c0 OFF
>8c1c	3c a0					.word	SyntaxError                      ; $c1 ON
>8c1e	3c a0					.word	SyntaxError                      ; $c2 OUTLINE
>8c20	69 a4					.word	PaletteCommand                   ; $c3 PALETTE
>8c22	5d a2					.word	PlotCommand                      ; $c4 PLOT
>8c24	93 86					.word	Command_Print                    ; $c5 PRINT
>8c26	bc 89					.word	Command_Read                     ; $c6 READ
>8c28	e1 a1					.word	RectangleCommand                 ; $c7 RECT
>8c2a	15 8a					.word	RemCommand                       ; $c8 REM
>8c2c	38 86					.word	Command_RETURN                   ; $c9 RETURN
>8c2e	3c a0					.word	SyntaxError                      ; $ca SOLID
>8c30	9b a6					.word	SoundCommand                     ; $cb SOUND
>8c32	f0 a1					.word	SpriteCommand                    ; $cc SPRITE
>8c34	2c a2					.word	TextCommand                      ; $cd TEXT
>8c36	17 8b					.word	Unused2                          ; $ce TO
.8c38					VectorSet1:
>8c38	3c a0					.word	SyntaxError                      ; $80 !0:EOF
>8c3a	3c a0					.word	SyntaxError                      ; $81 !1:SH1
>8c3c	3c a0					.word	SyntaxError                      ; $82 !2:SH2
>8c3e	84 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c40	a3 83					.word	AssertCommand                    ; $84 ASSERT
>8c42	b1 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8c44	12 85					.word	EndCommand                       ; $86 END
>8c46	d6 87					.word	Command_List                     ; $87 LIST
>8c48	3e 89					.word	NewCommand                       ; $88 NEW
>8c4a	44 8a					.word	Command_Restore                  ; $89 RESTORE
>8c4c	83 8a					.word	CommandRUN                       ; $8a RUN
>8c4e	f6 a3					.word	SpritesCtrl                      ; $8b SPRITES
>8c50	da 8c					.word	StopCommand                      ; $8c STOP
.8c52					VectorSet2:
>8c52	3c a0					.word	SyntaxError                      ; $80 !0:EOF
>8c54	3c a0					.word	SyntaxError                      ; $81 !1:SH1
>8c56	3c a0					.word	SyntaxError                      ; $82 !2:SH2
>8c58	fb 9e					.word	Assemble_adc                     ; $83 ADC
>8c5a	f3 9e					.word	Assemble_and                     ; $84 AND
>8c5c	0f 9f					.word	Assemble_asl                     ; $85 ASL
>8c5e	79 9f					.word	Assemble_bcc                     ; $86 BCC
>8c60	7d 9f					.word	Assemble_bcs                     ; $87 BCS
>8c62	85 9f					.word	Assemble_beq                     ; $88 BEQ
>8c64	3c 9f					.word	Assemble_bit                     ; $89 BIT
>8c66	6d 9f					.word	Assemble_bmi                     ; $8a BMI
>8c68	81 9f					.word	Assemble_bne                     ; $8b BNE
>8c6a	69 9f					.word	Assemble_bpl                     ; $8c BPL
>8c6c	89 9f					.word	Assemble_bra                     ; $8d BRA
>8c6e	8d 9f					.word	Assemble_brk                     ; $8e BRK
>8c70	71 9f					.word	Assemble_bvc                     ; $8f BVC
>8c72	75 9f					.word	Assemble_bvs                     ; $90 BVS
>8c74	95 9f					.word	Assemble_clc                     ; $91 CLC
>8c76	e9 9f					.word	Assemble_cld                     ; $92 CLD
>8c78	a9 9f					.word	Assemble_cli                     ; $93 CLI
>8c7a	d9 9f					.word	Assemble_clv                     ; $94 CLV
>8c7c	07 9f					.word	Assemble_cmp                     ; $95 CMP
>8c7e	50 9f					.word	Assemble_cpx                     ; $96 CPX
>8c80	4b 9f					.word	Assemble_cpy                     ; $97 CPY
>8c82	2d 9f					.word	Assemble_dec                     ; $98 DEC
>8c84	e5 9f					.word	Assemble_dex                     ; $99 DEX
>8c86	c1 9f					.word	Assemble_dey                     ; $9a DEY
>8c88	f7 9e					.word	Assemble_eor                     ; $9b EOR
>8c8a	32 9f					.word	Assemble_inc                     ; $9c INC
>8c8c	f5 9f					.word	Assemble_inx                     ; $9d INX
>8c8e	e1 9f					.word	Assemble_iny                     ; $9e INY
>8c90	64 9f					.word	Assemble_jmp                     ; $9f JMP
>8c92	5f 9f					.word	Assemble_jsr                     ; $a0 JSR
>8c94	03 9f					.word	Assemble_lda                     ; $a1 LDA
>8c96	28 9f					.word	Assemble_ldx                     ; $a2 LDX
>8c98	46 9f					.word	Assemble_ldy                     ; $a3 LDY
>8c9a	19 9f					.word	Assemble_lsr                     ; $a4 LSR
>8c9c	f9 9f					.word	Assemble_nop                     ; $a5 NOP
>8c9e	ef 9e					.word	Assemble_ora                     ; $a6 ORA
>8ca0	a5 9f					.word	Assemble_pha                     ; $a7 PHA
>8ca2	91 9f					.word	Assemble_php                     ; $a8 PHP
>8ca4	ed 9f					.word	Assemble_phx                     ; $a9 PHX
>8ca6	ad 9f					.word	Assemble_phy                     ; $aa PHY
>8ca8	b5 9f					.word	Assemble_pla                     ; $ab PLA
>8caa	99 9f					.word	Assemble_plp                     ; $ac PLP
>8cac	01 a0					.word	Assemble_plx                     ; $ad PLX
>8cae	bd 9f					.word	Assemble_ply                     ; $ae PLY
>8cb0	14 9f					.word	Assemble_rol                     ; $af ROL
>8cb2	1e 9f					.word	Assemble_ror                     ; $b0 ROR
>8cb4	a1 9f					.word	Assemble_rti                     ; $b1 RTI
>8cb6	b1 9f					.word	Assemble_rts                     ; $b2 RTS
>8cb8	0b 9f					.word	Assemble_sbc                     ; $b3 SBC
>8cba	9d 9f					.word	Assemble_sec                     ; $b4 SEC
>8cbc	fd 9f					.word	Assemble_sed                     ; $b5 SED
>8cbe	b9 9f					.word	Assemble_sei                     ; $b6 SEI
>8cc0	ff 9e					.word	Assemble_sta                     ; $b7 STA
>8cc2	f1 9f					.word	Assemble_stp                     ; $b8 STP
>8cc4	23 9f					.word	Assemble_stx                     ; $b9 STX
>8cc6	41 9f					.word	Assemble_sty                     ; $ba STY
>8cc8	37 9f					.word	Assemble_stz                     ; $bb STZ
>8cca	d5 9f					.word	Assemble_tax                     ; $bc TAX
>8ccc	d1 9f					.word	Assemble_tay                     ; $bd TAY
>8cce	5a 9f					.word	Assemble_trb                     ; $be TRB
>8cd0	55 9f					.word	Assemble_tsb                     ; $bf TSB
>8cd2	dd 9f					.word	Assemble_tsx                     ; $c0 TSX
>8cd4	c5 9f					.word	Assemble_txa                     ; $c1 TXA
>8cd6	cd 9f					.word	Assemble_txs                     ; $c2 TXS
>8cd8	c9 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8cda					StopCommand:
.8cda	a9 08		lda #$08		lda	#8
.8cdc	4c ef 8d	jmp $8def		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8cdf					ProcedureScan:
.8cdf	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ce1	85 30		sta $30				sta 	codePtr
.8ce3	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8ce5	85 31		sta $31				sta 	codePtr+1
.8ce7					_PSLoop:
.8ce7	b2 30		lda ($30)			lda 	(codePtr)
.8ce9	f0 42		beq $8d2d			beq 	_PSExit
.8ceb	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8ced	b1 30		lda ($30),y			lda 	(codePtr),y
.8cef	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8cf1	d0 2d		bne $8d20			bne 	_PSNext
.8cf3	c8		iny				iny 								; get the address of the record to zTemp0 and
.8cf4	b1 30		lda ($30),y			lda 	(codePtr),y
.8cf6	29 c0		and #$c0			and 	#$C0
.8cf8	c9 40		cmp #$40			cmp 	#$40
.8cfa	d0 32		bne $8d2e			bne 	_PSSyntax
.8cfc	b1 30		lda ($30),y			lda 	(codePtr),y
.8cfe	18		clc				clc
.8cff	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d01	85 37		sta $37				sta 	zTemp0+1
.8d03	c8		iny				iny 								; LSB
.8d04	b1 30		lda ($30),y			lda 	(codePtr),y
.8d06	85 36		sta $36				sta 	zTemp0
.8d08	c8		iny				iny 								; character after variable call.
.8d09	98		tya				tya 								; save Y offset at +7
.8d0a	a0 07		ldy #$07			ldy 	#7
.8d0c	91 36		sta ($36),y			sta 	(zTemp0),y
.8d0e	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d10	a0 02		ldy #$02			ldy 	#2
.8d12	91 36		sta ($36),y			sta 	(zTemp0),y
.8d14	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d16					_PSCopy:
.8d16	b5 30		lda $30,x			lda 	safePtr,x
.8d18	c8		iny				iny
.8d19	91 36		sta ($36),y			sta 	(zTemp0),y
.8d1b	e8		inx				inx
.8d1c	e0 04		cpx #$04			cpx 	#4
.8d1e	d0 f6		bne $8d16			bne 	_PSCopy
.8d20					_PSNext:
.8d20	18		clc				clc
.8d21	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8d23	65 30		adc $30				adc 	codePtr
.8d25	85 30		sta $30				sta 	codePtr
.8d27	90 02		bcc $8d2b			bcc 	_CREExit
.8d29	e6 31		inc $31				inc 	codePtr+1
.8d2b					_CREExit:
.8d2b	80 ba		bra $8ce7			bra 	_PSLoop
.8d2d					_PSExit:
.8d2d	60		rts				rts
.8d2e					_PSSyntax:
.8d2e	4c 3c a0	jmp $a03c			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d31					ScanForward:
.8d31	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d33	86 37		stx $37				stx 	zTemp0+1
.8d35	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d37					_ScanLoop:
.8d37	b1 30		lda ($30),y			lda 	(codePtr),y
.8d39	c8		iny				iny
.8d3a	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d3c	d0 0e		bne $8d4c			bne 	_ScanGoNext
.8d3e	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d40	f0 04		beq $8d46			beq 	_ScanMatch
.8d42	c5 37		cmp $37				cmp 	zTemp0+1
.8d44	d0 06		bne $8d4c			bne 	_ScanGoNext
.8d46					_ScanMatch:
.8d46	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d48	d0 01		bne $8d4b			bne 	_ScanNotEndEOL
.8d4a	88		dey				dey
.8d4b					_ScanNotEndEOL:
.8d4b	60		rts				rts
.8d4c					_ScanGoNext:
.8d4c	20 51 8d	jsr $8d51			jsr  	ScanForwardOne
.8d4f	80 e6		bra $8d37			bra 	_ScanLoop
.8d51					ScanForwardOne:
.8d51	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d53	90 3e		bcc $8d93			bcc 	_SFWExit
.8d55	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d57	90 18		bcc $8d71			bcc 	_ScanSkipOne
.8d59	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d5b	b0 2f		bcs $8d8c			bcs 	_ScanSkipData
.8d5d	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d5f	90 32		bcc $8d93			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d61	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d63	b0 2e		bcs $8d93			bcs 	_SFWExit
.8d65	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d67	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d69	b0 28		bcs $8d93			bcs 	_SFWExit
.8d6b	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d6d	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8d6f	80 22		bra $8d93			bra 	_SFWExit
.8d71					_ScanSkipOne:
.8d71	c8		iny				iny 								; consume the extra one.
.8d72	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8d74	d0 1d		bne $8d93			bne 	_SFWExit
.8d76	18		clc				clc
.8d77	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8d79	65 30		adc $30				adc 	codePtr
.8d7b	85 30		sta $30				sta 	codePtr
.8d7d	90 02		bcc $8d81			bcc 	_CREExit
.8d7f	e6 31		inc $31				inc 	codePtr+1
.8d81					_CREExit:
.8d81	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8d83	b2 30		lda ($30)			lda 	(codePtr)
.8d85	d0 0c		bne $8d93			bne 	_SFWExit 					; if not zero, more to scan
.8d87	a9 13		lda #$13		lda	#19
.8d89	4c ef 8d	jmp $8def		jmp	ErrorHandler
.8d8c					_ScanSkipData:
.8d8c	88		dey				dey 								; point at data token
.8d8d	c8		iny				iny
.8d8e	98		tya				tya
.8d8f	38		sec				sec
.8d90	71 30		adc ($30),y			adc 	(codePtr),y
.8d92	a8		tay				tay
.8d93					_SFWExit:
.8d93	60		rts				rts
.8d94					ScanGetCurrentLineStep:
.8d94	64 38		stz $38				stz 	zTemp1
.8d96	a0 03		ldy #$03			ldy 	#3
.8d98					_SGCLSLoop:
.8d98	b1 30		lda ($30),y			lda 	(codePtr),y
.8d9a	c8		iny				iny
.8d9b	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d9d	f0 05		beq $8da4			beq 	_SGCLSExit
.8d9f	20 51 8d	jsr $8d51			jsr 	ScanForwardOne
.8da2	80 f4		bra $8d98			bra 	_SGCLSLoop
.8da4					_SGCLSExit:
.8da4	a5 38		lda $38				lda 	zTemp1
.8da6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8da7					Command_WHILE:
.8da7	5a		phy				phy 								; save position of the test
.8da8	a2 00		ldx #$00			ldx 	#0
.8daa	20 db 9d	jsr $9ddb			jsr 	EvaluateNumber 				; work out the number
.8dad	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; check if zero
.8db0	f0 0e		beq $8dc0			beq 	_WHExitLoop 				; if so exit the loop
.8db2	98		tya				tya 								; position *after* test.
.8db3	7a		ply				ply 								; restore position before test, at WHILE
.8db4	88		dey				dey
.8db5	48		pha				pha 								; push after test on the stack
.8db6	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8db8	20 28 a7	jsr $a728			jsr 	StackOpen
.8dbb	20 6c a7	jsr $a76c			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8dbe	7a		ply				ply 								; restore the position *after* the test
.8dbf	60		rts				rts
.8dc0					_WHExitLoop:
.8dc0	68		pla				pla 								; throw post loop position
.8dc1	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8dc3	aa		tax				tax
.8dc4	20 31 8d	jsr $8d31			jsr 	ScanForward
.8dc7	60		rts				rts
.8dc8					Command_WEND:
.8dc8	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8dca	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8dcc	20 54 a7	jsr $a754			jsr 	StackCheckFrame
.8dcf	20 7d a7	jsr $a77d			jsr 	STKLoadCodePosition 		; loop back
.8dd2	20 46 a7	jsr $a746			jsr 	StackClose		 			; erase the frame
.8dd5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8dd6					CheckRightBracket:
.8dd6	b1 30		lda ($30),y			lda 	(codePtr),y
.8dd8	c8		iny				iny
.8dd9	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8ddb	d0 0f		bne $8dec			bne 	CNAFail
.8ddd	60		rts				rts
.8dde					CheckComma:
.8dde	b1 30		lda ($30),y			lda 	(codePtr),y
.8de0	c8		iny				iny
.8de1	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8de3	d0 07		bne $8dec			bne 	CNAFail
.8de5	60		rts				rts
.8de6					CheckNextA:
.8de6	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8de8	d0 02		bne $8dec			bne 	CNAFail
.8dea	c8		iny				iny 								; skip character
.8deb	60		rts				rts 								; and exit
.8dec					CNAFail:
.8dec	4c 3c a0	jmp $a03c			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8def					ErrorHandler:
.8def	a8		tay				tay 								; find the error text
.8df0	f0 49		beq $8e3b			beq 	_EHEnd
.8df2	a2 00		ldx #$00			ldx 	#0
.8df4	a9 55		lda #$55			lda 	#((ErrorText) & $FF)
.8df6	85 36		sta $36				sta 	0+zTemp0
.8df8	a9 a0		lda #$a0			lda 	#((ErrorText) >> 8)
.8dfa	85 37		sta $37				sta 	1+zTemp0
.8dfc					_EHFind:
.8dfc	88		dey				dey 								; found the error text ?
.8dfd	f0 0e		beq $8e0d			beq 	_EHFound
.8dff					_EHFindZero:
.8dff	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e01	e6 36		inc $36				inc 	zTemp0
.8e03	d0 02		bne $8e07			bne 	_EHFNoCarry
.8e05	e6 37		inc $37				inc 	zTemp0+1
.8e07					_EHFNoCarry:
.8e07	c9 00		cmp #$00			cmp 	#0
.8e09	d0 f4		bne $8dff			bne 	_EHFindZero
.8e0b	80 ef		bra $8dfc			bra 	_EHFind
.8e0d					_EHFound:
.8e0d	a5 36		lda $36				lda 	zTemp0 						; print message
.8e0f	a6 37		ldx $37				ldx 	zTemp0+1
.8e11	20 48 8e	jsr $8e48			jsr 	PrintStringXA
.8e14	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8e16	b1 30		lda ($30),y			lda 	(codePtr),y
.8e18	d0 05		bne $8e1f			bne 	_EHAtMsg
.8e1a	c8		iny				iny
.8e1b	b1 30		lda ($30),y			lda 	(codePtr),y
.8e1d	f0 17		beq $8e36			beq 	_EHCREnd
.8e1f					_EHAtMsg:
.8e1f	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8e21	a9 3e		lda #$3e			lda 	#_AtMsg & $FF
.8e23	20 48 8e	jsr $8e48			jsr 	PrintStringXA
.8e26	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8e28	b1 30		lda ($30),y			lda 	(codePtr),y
.8e2a	48		pha				pha
.8e2b	c8		iny				iny
.8e2c	b1 30		lda ($30),y			lda 	(codePtr),y
.8e2e	aa		tax				tax
.8e2f	68		pla				pla
.8e30	20 01 93	jsr $9301			jsr 	LCLConvertInt16 				; convert XA to string
.8e33	20 48 8e	jsr $8e48			jsr 	PrintStringXA 				; and print it.
.8e36					_EHCREnd:
.8e36	a9 0d		lda #$0d			lda 	#13 						; new line
.8e38	20 68 a8	jsr $a868			jsr 	EXTPrintCharacter
.8e3b					_EHEnd:
.8e3b	4c 54 83	jmp $8354			jmp 	WarmStart
>8e3e	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8e46	20 00
.8e48					PrintStringXA:
.8e48	5a		phy				phy
.8e49	86 37		stx $37				stx 	zTemp0+1
.8e4b	85 36		sta $36				sta 	zTemp0
.8e4d	a0 00		ldy #$00			ldy 	#0
.8e4f					_PSXALoop:
.8e4f	b1 36		lda ($36),y			lda 	(zTemp0),y
.8e51	f0 06		beq $8e59			beq 	_PSXAExit
.8e53	20 68 a8	jsr $a868			jsr 	EXTPrintCharacter
.8e56	c8		iny				iny
.8e57	80 f6		bra $8e4f			bra 	_PSXALoop
.8e59					_PSXAExit:
.8e59	7a		ply				ply
.8e5a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8e5b					UnaryTrue:
.8e5b	fa		plx				plx
.8e5c					ReturnTrue:
.8e5c	a9 01		lda #$01			lda 	#1  						; set to 1
.8e5e	20 b4 9e	jsr $9eb4			jsr 	NSMSetByte
.8e61	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8e63	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8e66	60		rts				rts
.8e67					UnaryFalse:
.8e67	fa		plx				plx
.8e68					ReturnFalse:
.8e68	4c b2 9e	jmp $9eb2			jmp 	NSMSetZero 					; set it all to zero
.8e6b					BinaryCompareEqual:
.8e6b	fa		plx				plx
.8e6c	20 a7 8e	jsr $8ea7			jsr 	CompareBaseCode
.8e6f	c9 00		cmp #$00			cmp 	#0
.8e71	f0 e9		beq $8e5c			beq 	ReturnTrue
.8e73	80 f3		bra $8e68			bra 	ReturnFalse
.8e75					BinaryCompareLess:
.8e75	fa		plx				plx
.8e76	20 a7 8e	jsr $8ea7			jsr 	CompareBaseCode
.8e79	c9 ff		cmp #$ff			cmp 	#$FF
.8e7b	f0 df		beq $8e5c			beq 	ReturnTrue
.8e7d	80 e9		bra $8e68			bra 	ReturnFalse
.8e7f					BinaryCompareGreater:
.8e7f	fa		plx				plx
.8e80	20 a7 8e	jsr $8ea7			jsr 	CompareBaseCode
.8e83	c9 01		cmp #$01			cmp 	#1
.8e85	f0 d5		beq $8e5c			beq 	ReturnTrue
.8e87	80 df		bra $8e68			bra 	ReturnFalse
.8e89					BinaryCompareNotEqual:
.8e89	fa		plx				plx
.8e8a	20 a7 8e	jsr $8ea7			jsr 	CompareBaseCode
.8e8d	c9 00		cmp #$00			cmp 	#0
.8e8f	d0 cb		bne $8e5c			bne 	ReturnTrue
.8e91	80 d5		bra $8e68			bra 	ReturnFalse
.8e93					BinaryCompareLessEqual:
.8e93	fa		plx				plx
.8e94	20 a7 8e	jsr $8ea7			jsr 	CompareBaseCode
.8e97	c9 01		cmp #$01			cmp 	#1
.8e99	d0 c1		bne $8e5c			bne 	ReturnTrue
.8e9b	80 cb		bra $8e68			bra 	ReturnFalse
.8e9d					BinaryCompareGreaterEqual:
.8e9d	fa		plx				plx
.8e9e	20 a7 8e	jsr $8ea7			jsr 	CompareBaseCode
.8ea1	c9 ff		cmp #$ff			cmp 	#$FF
.8ea3	d0 b7		bne $8e5c			bne 	ReturnTrue
.8ea5	80 c1		bra $8e68			bra 	ReturnFalse
.8ea7					CompareBaseCode:
.8ea7	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; make both values if references.
.8eaa	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8ead	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8eb0	29 10		and #$10			and 	#NSTString
.8eb2	d0 40		bne $8ef4			bne 	_CBCString
.8eb4	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8eb7	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8eba	d0 3b		bne $8ef7			bne 	_CBCFloat
.8ebc	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8ebf	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ec2	29 08		and #$08			and 	#NSTFloat
.8ec4	d0 31		bne $8ef7			bne 	_CBCFloat
.8ec6	20 fa 8e	jsr $8efa			jsr 	CompareFixMinusZero
.8ec9	e8		inx				inx
.8eca	20 fa 8e	jsr $8efa			jsr 	CompareFixMinusZero
.8ecd	ca		dex				dex
.8ece	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8ed1	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8ed4	10 0b		bpl $8ee1			bpl 	_CDCSameSign
.8ed6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8ed9	30 16		bmi $8ef1			bmi 	_CBCLess 					; return $FF
.8edb					_CBCGreater:
.8edb	a9 01		lda #$01			lda 	#1
.8edd	60		rts				rts
.8ede					_CBCEqual:
.8ede	a9 00		lda #$00			lda 	#0
.8ee0	60		rts				rts
.8ee1					_CDCSameSign:
.8ee1	20 4d 91	jsr $914d			jsr 	SubTopTwoStack 				; unsigned subtract
.8ee4	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; or the mantissa together
.8ee7	f0 f5		beq $8ede			beq 	_CBCEqual 					; -0 == 0
.8ee9	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8eec	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8eef	10 ea		bpl $8edb			bpl 	_CBCGreater
.8ef1					_CBCLess:
.8ef1	a9 ff		lda #$ff			lda 	#$FF
.8ef3	60		rts				rts
.8ef4					_CBCString:
.8ef4	4c a3 90	jmp $90a3			jmp 	CompareStrings
.8ef7					_CBCFloat:
.8ef7	4c 84 94	jmp $9484			jmp 	CompareFloat
.8efa					CompareFixMinusZero:
.8efa	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero
.8efd	d0 03		bne $8f02			bne 	_CFXMZNotZero
.8eff	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8f02					_CFXMZNotZero:
.8f02	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f03					StringConcat:
.8f03	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8f06	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8f09	29 18		and #$18			and 	#NSBTypeMask
.8f0b	c9 10		cmp #$10			cmp 	#NSTString
.8f0d	d0 4e		bne $8f5d			bne		_SCType
.8f0f	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f11	e8		inx				inx
.8f12	20 30 8f	jsr $8f30			jsr 	_SCSetupZ0 					; setup for second
.8f15	20 3b 8f	jsr $8f3b			jsr 	_SCLengthZ0 				; length for second
.8f18	ca		dex				dex
.8f19	20 30 8f	jsr $8f30			jsr 	_SCSetupZ0 					; setup for first
.8f1c	20 3b 8f	jsr $8f3b			jsr 	_SCLengthZ0 				; length for first
.8f1f	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8f21	20 1b a8	jsr $a81b			jsr 	StringTempAllocate
.8f24	20 4e 8f	jsr $8f4e			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8f27	e8		inx				inx
.8f28	20 30 8f	jsr $8f30			jsr 	_SCSetupZ0 					; copy second out
.8f2b	20 4e 8f	jsr $8f4e			jsr 	_SCCopy
.8f2e	ca		dex				dex
.8f2f	60		rts				rts
.8f30					_SCSetupZ0:
.8f30	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8f33	85 36		sta $36				sta 	zTemp0
.8f35	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8f38	85 37		sta $37				sta 	zTemp0+1
.8f3a	60		rts				rts
.8f3b					_SCLengthZ0:
.8f3b	5a		phy				phy
.8f3c	a0 00		ldy #$00			ldy 	#0
.8f3e					_SCLenLoop:
.8f3e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f40	f0 0a		beq $8f4c			beq 	_SCLExit
.8f42	c8		iny				iny
.8f43	e6 38		inc $38				inc 	zTemp1
.8f45	10 f7		bpl $8f3e			bpl		_SCLenLoop
.8f47	a9 09		lda #$09		lda	#9
.8f49	4c ef 8d	jmp $8def		jmp	ErrorHandler
.8f4c					_SCLExit:
.8f4c	7a		ply				ply
.8f4d	60		rts				rts
.8f4e					_SCCopy:
.8f4e	5a		phy				phy
.8f4f	a0 00		ldy #$00			ldy 	#0
.8f51					_SCCopyLoop:
.8f51	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f53	f0 06		beq $8f5b			beq 	_SCCExit
.8f55	20 59 a8	jsr $a859			jsr 	StringTempWrite
.8f58	c8		iny				iny
.8f59	80 f6		bra $8f51			bra 	_SCCopyLoop
.8f5b					_SCCExit:
.8f5b	7a		ply				ply
.8f5c	60		rts				rts
.8f5d					_SCType:
.8f5d	4c 46 a0	jmp $a046			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8f60					IntegerDivide:
.8f60	fa		plx				plx
.8f61	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f64	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f67	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f68	0a		asl a				asl 	a
.8f69	10 05		bpl $8f70			bpl 	_NotRef
.8f6b	48		pha				pha
.8f6c	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f6f	68		pla				pla
.8f70					_NotRef:
.8f70	0a		asl a				asl 	a
.8f71	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f73	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f76	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f79	f0 03		beq $8f7e			beq 	_IntegerCode 				; if clear, then we have two integers
.8f7b	4c 46 a0	jmp $a046			jmp 	TypeError 					; anything else, type mismatch.
.8f7e					_IntegerCode:
.8f7e	20 a0 8f	jsr $8fa0			jsr 	CheckDivideZero 			; do div zero check
.8f81	20 d8 8f	jsr $8fd8			jsr 	Int32Divide 				; do the division
.8f84	20 95 90	jsr $9095			jsr 	CalculateSign 				; calculate result sign
.8f87					NSMCopyPlusTwoToZero:
.8f87	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f8a	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8f8d	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8f90	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8f93	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8f96	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8f99	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8f9c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8f9f	60		rts				rts
.8fa0					CheckDivideZero:
.8fa0	e8		inx				inx
.8fa1	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero
.8fa4	f0 02		beq $8fa8			beq 	_CDVError
.8fa6	ca		dex				dex
.8fa7	60		rts				rts
.8fa8					_CDVError:
.8fa8	a9 03		lda #$03		lda	#3
.8faa	4c ef 8d	jmp $8def		jmp	ErrorHandler
.8fad					IntegerModulus:
.8fad	fa		plx				plx
.8fae	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8fb1	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8fb4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fb5	0a		asl a				asl 	a
.8fb6	10 05		bpl $8fbd			bpl 	_NotRef
.8fb8	48		pha				pha
.8fb9	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fbc	68		pla				pla
.8fbd					_NotRef:
.8fbd	0a		asl a				asl 	a
.8fbe	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8fc0	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fc3	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fc6	f0 03		beq $8fcb			beq 	_IntegerCode 				; if clear, then we have two integers
.8fc8	4c 46 a0	jmp $a046			jmp 	TypeError 					; anything else, type mismatch.
.8fcb					_IntegerCode:
.8fcb					IntegerModulusNoCheck:
.8fcb	20 a0 8f	jsr $8fa0			jsr 	CheckDivideZero 			; do div zero check
.8fce	20 d8 8f	jsr $8fd8			jsr 	Int32Divide 				; do the division
.8fd1	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8fd4	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8fd7	60		rts				rts
.8fd8					Int32Divide:
.8fd8	48		pha				pha 								; save AXY
.8fd9	5a		phy				phy
.8fda	20 89 9e	jsr $9e89			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fdd	20 ae 9e	jsr $9eae			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8fe0	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8fe2					_I32DivideLoop:
.8fe2	e8		inx				inx
.8fe3	e8		inx				inx
.8fe4	20 c7 9e	jsr $9ec7			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8fe7	ca		dex				dex
.8fe8	ca		dex				dex
.8fe9	20 c8 9e	jsr $9ec8			jsr 	NSMRotateLeft
.8fec	20 18 90	jsr $9018			jsr 	DivideCheckSubtract 		; check if subtract possible
.8fef	90 03		bcc $8ff4			bcc 	_I32DivideNoCarryIn
.8ff1	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8ff4					_I32DivideNoCarryIn:
.8ff4	88		dey				dey 								; loop round till division completed.
.8ff5	d0 eb		bne $8fe2			bne 	_I32DivideLoop
.8ff7	7a		ply				ply 								; restore AXY and exit
.8ff8	68		pla				pla
.8ff9	60		rts				rts
.8ffa					Int32ShiftDivide:
.8ffa	48		pha				pha 								; save AY
.8ffb	5a		phy				phy
.8ffc	e8		inx				inx 								; clear S[X+2]
.8ffd	e8		inx				inx
.8ffe	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero
.9001	ca		dex				dex
.9002	ca		dex				dex
.9003	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9005					_I32SDLoop:
.9005	20 18 90	jsr $9018			jsr 	DivideCheckSubtract 		; check if subtract possible
.9008	e8		inx				inx
.9009	e8		inx				inx
.900a	20 c8 9e	jsr $9ec8			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.900d	ca		dex				dex
.900e	ca		dex				dex
.900f	20 c8 9e	jsr $9ec8			jsr 	NSMRotateLeft
.9012	88		dey				dey 	 							; do 31 times
.9013	d0 f0		bne $9005			bne 	_I32SDLoop
.9015	7a		ply				ply 								; restore AY and exit
.9016	68		pla				pla
.9017	60		rts				rts
.9018					DivideCheckSubtract:
.9018	20 4d 91	jsr $914d			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.901b	b0 04		bcs $9021			bcs 	_DCSExit 					; if carry set, then could do, exit
.901d	20 27 91	jsr $9127			jsr 	AddTopTwoStack 				; add it back in
.9020	18		clc				clc 								; and return False
.9021					_DCSExit:
.9021	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9022					MulInteger:
.9022	fa		plx				plx
.9023	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9026	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9029	0a		asl a				asl 	a 							; shift reference bit into sign bit
.902a	0a		asl a				asl 	a
.902b	10 05		bpl $9032			bpl 	_NotRef
.902d	48		pha				pha
.902e	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9031	68		pla				pla
.9032					_NotRef:
.9032	0a		asl a				asl 	a 							; put MSB of type into A:7
.9033	30 0b		bmi $9040			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9035	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9038	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.903b	f0 06		beq $9043			beq 	_IntegerCode 				; if clear, then we have two integers
.903d	4c 5b 95	jmp $955b			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9040					_StringData:
.9040	4c 50 a0	jmp $a050			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9043					_IntegerCode:
.9043	20 50 90	jsr $9050			jsr 	MultiplyShort
.9046	c9 00		cmp #$00			cmp 	#0
.9048	f0 05		beq $904f			beq 	_MIExit
.904a	a9 04		lda #$04		lda	#4
.904c	4c ef 8d	jmp $8def		jmp	ErrorHandler
.904f					_MIExit:
.904f	60		rts				rts
.9050					MultiplyShort:
.9050	5a		phy				phy 								; save Y
.9051	20 89 9e	jsr $9e89			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9054	20 ae 9e	jsr $9eae			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9057	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9059					_I32MLoop:
.9059	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.905c	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.905f	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.9062	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.9065	f0 28		beq $908f			beq 	_I32MExit 					; exit if zero
.9067	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.906a	29 01		and #$01			and 	#1
.906c	f0 0e		beq $907c			beq 	_I32MNoAdd
.906e	20 27 91	jsr $9127			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9071	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9074	10 06		bpl $907c			bpl 	_I32MNoAdd
.9076					_I32ShiftRight:
.9076	20 d5 9e	jsr $9ed5			jsr 	NSMShiftRight 				; shift S[X] right
.9079	c8		iny				iny 								; increment shift count
.907a	80 0a		bra $9086			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.907c					_I32MNoAdd:
.907c	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.907f	70 f5		bvs $9076			bvs 	_I32ShiftRight 				; instead.
.9081	e8		inx				inx
.9082	20 c7 9e	jsr $9ec7			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9085	ca		dex				dex
.9086					_I32MShiftUpper:
.9086	e8		inx				inx 								; shift S[X+2] right
.9087	e8		inx				inx
.9088	20 d5 9e	jsr $9ed5			jsr 	NSMShiftRight
.908b	ca		dex				dex
.908c	ca		dex				dex
.908d	80 ca		bra $9059			bra 	_I32MLoop 					; try again.
.908f					_I32MExit:
.908f	20 95 90	jsr $9095			jsr 	CalculateSign
.9092	98		tya				tya 								; shift in A
.9093	7a		ply				ply 								; restore Y and exit
.9094	60		rts				rts
.9095					CalculateSign:
.9095	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9098	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.909b	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.909e	0a		asl a				asl 	a 							; shift bit 7 into carry
.909f	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.90a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.90a3					CompareStrings:
.90a3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.90a6	3d 01 04	and $0401,x			and 	NSStatus+1,x
.90a9	29 10		and #$10			and 	#NSBIsString
.90ab	f0 2c		beq $90d9			beq 	_CSTypeError
.90ad	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.90b0	85 36		sta $36				sta 	zTemp0
.90b2	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.90b5	85 37		sta $37				sta 	zTemp0+1
.90b7	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.90ba	85 38		sta $38				sta 	zTemp1
.90bc	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.90bf	85 39		sta $39				sta 	zTemp1+1
.90c1	5a		phy				phy 								; save Y so we can access strings
.90c2	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.90c4					_CSLoop:
.90c4	c8		iny				iny
.90c5	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.90c7	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.90c9	d0 06		bne $90d1			bne 	_CSDifferent
.90cb	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.90cd	d0 f5		bne $90c4			bne 	_CSLoop 					; still comparing
.90cf					_CSExit:
.90cf	7a		ply				ply 								; reached end, return zero in A from EOS
.90d0	60		rts				rts
.90d1					_CSDifferent:
.90d1	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.90d3	90 fa		bcc $90cf			bcc		_CSExit
.90d5	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.90d7	80 f6		bra $90cf			bra 	_CSExit
.90d9					_CSTypeError:
.90d9	4c 46 a0	jmp $a046			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.90dc					ShiftLeft:
.90dc	38		sec				sec
.90dd	80 01		bra $90e0			bra 	ShiftMain
.90df					ShiftRight:
.90df	18		clc				clc
.90e0					ShiftMain:
.90e0	fa		plx				plx 								; restore X
.90e1	08		php				php 								; save direction
.90e2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90e5	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90e8	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90e9	0a		asl a				asl 	a
.90ea	10 05		bpl $90f1			bpl 	_NotRef
.90ec	48		pha				pha
.90ed	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90f0	68		pla				pla
.90f1					_NotRef:
.90f1	0a		asl a				asl 	a
.90f2	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90f4	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90f7	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.90fa	f0 03		beq $90ff			beq 	_IntegerCode 				; if clear, then we have two integers
.90fc	4c 46 a0	jmp $a046			jmp 	TypeError 					; anything else, type mismatch.
.90ff					_IntegerCode:
.90ff	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.9102	29 e0		and #$e0			and 	#$E0
.9104	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.9107	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.910a	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.910d	d0 13		bne $9122			bne 	_SMExit0 					; if >= 32 it will always return zero.
.910f					_SMLoop:
.910f	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9112	30 11		bmi $9125			bmi 	_SMExit 					; exit if done.
.9114	28		plp				plp 								; restore direcition setting
.9115	08		php				php
.9116	90 05		bcc $911d			bcc 	_SMRight
.9118	20 c7 9e	jsr $9ec7			jsr 	NSMShiftLeft 				; shift left if CS
.911b	80 f2		bra $910f			bra 	_SMLoop
.911d					_SMRight:
.911d	20 d5 9e	jsr $9ed5			jsr 	NSMShiftRight 				; shift right if CC
.9120	80 ed		bra $910f			bra 	_SMLoop
.9122					_SMExit0:
.9122	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero 					; return zero.
.9125					_SMExit:
.9125	28		plp				plp 								; throw direction
.9126	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9127					AddTopTwoStack:
.9127	18		clc				clc
.9128	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.912b	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.912e	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9131	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9134	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.9137	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.913a	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.913d	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.9140	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9143	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9146	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.9149	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.914c	60		rts				rts
.914d					SubTopTwoStack:
.914d	38		sec				sec
.914e	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9151	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.9154	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9157	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.915a	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.915d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9160	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9163	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.9166	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9169	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.916c	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.916f	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9172	60		rts				rts
.9173					AddInteger:
.9173	fa		plx				plx
.9174	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9177	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.917a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.917b	0a		asl a				asl 	a
.917c	10 05		bpl $9183			bpl 	_NotRef
.917e	48		pha				pha
.917f	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9182	68		pla				pla
.9183					_NotRef:
.9183	0a		asl a				asl 	a 							; put MSB of type into A:7
.9184	30 0b		bmi $9191			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9186	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9189	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.918c	f0 06		beq $9194			beq 	_IntegerCode 				; if clear, then we have two integers
.918e	4c db 93	jmp $93db			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9191					_StringData:
.9191	4c 03 8f	jmp $8f03			jmp 	StringConcat							; at least one string - don't know both are strings.
.9194					_IntegerCode:
.9194					AddCode:
.9194	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9197	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.919a	10 8b		bpl $9127			bpl 	AddTopTwoStack
.919c	20 4d 91	jsr $914d			jsr 	SubTopTwoStack 				; do a physical subtraction
.919f	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.91a2	10 09		bpl $91ad			bpl 	_AddExit
.91a4	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.91a7	9d 00 04	sta $0400,x			sta 	NSStatus,x
.91aa	20 67 9e	jsr $9e67			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.91ad					_AddExit:
.91ad	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; check for -0
.91b0	d0 03		bne $91b5			bne 	_AddNonZero
.91b2	9e 00 04	stz $0400,x			stz 	NSStatus,x
.91b5					_AddNonZero:
.91b5	60		rts				rts
.91b6					SubInteger:
.91b6	fa		plx				plx
.91b7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91ba	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91bd	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91be	0a		asl a				asl 	a
.91bf	10 05		bpl $91c6			bpl 	_NotRef
.91c1	48		pha				pha
.91c2	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91c5	68		pla				pla
.91c6					_NotRef:
.91c6	0a		asl a				asl 	a 							; put MSB of type into A:7
.91c7	30 0b		bmi $91d4			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91c9	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91cc	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91cf	f0 06		beq $91d7			beq 	_IntegerCode 				; if clear, then we have two integers
.91d1	4c e0 93	jmp $93e0			jmp 	FloatingPointSub 							; otherwise at least one float.
.91d4					_StringData:
.91d4	4c 50 a0	jmp $a050			jmp 	NotDoneError							; at least one string - don't know both are strings.
.91d7					_IntegerCode:
.91d7	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.91da	49 80		eor #$80			eor 	#$80
.91dc	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.91df	80 b3		bra $9194			bra 	AddCode 					; and do the same code as add.
.91e1					AndInteger:
.91e1	fa		plx				plx
.91e2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91e5	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91e8	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91e9	0a		asl a				asl 	a
.91ea	10 05		bpl $91f1			bpl 	_NotRef
.91ec	48		pha				pha
.91ed	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f0	68		pla				pla
.91f1					_NotRef:
.91f1	0a		asl a				asl 	a
.91f2	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91f4	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91f7	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91fa	f0 03		beq $91ff			beq 	_IntegerCode 				; if clear, then we have two integers
.91fc	4c 46 a0	jmp $a046			jmp 	TypeError 					; anything else, type mismatch.
.91ff					_IntegerCode:
.91ff	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9202	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.9205	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9208	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.920b	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.920e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9211	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9214	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.9217	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.921a	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.921d	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.9220	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9223	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9226	60		rts				rts
.9227					OraInteger:
.9227	fa		plx				plx
.9228	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.922b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.922e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.922f	0a		asl a				asl 	a
.9230	10 05		bpl $9237			bpl 	_NotRef
.9232	48		pha				pha
.9233	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9236	68		pla				pla
.9237					_NotRef:
.9237	0a		asl a				asl 	a
.9238	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.923a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.923d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9240	f0 03		beq $9245			beq 	_IntegerCode 				; if clear, then we have two integers
.9242	4c 46 a0	jmp $a046			jmp 	TypeError 					; anything else, type mismatch.
.9245					_IntegerCode:
.9245	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9248	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.924b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.924e	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9251	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.9254	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9257	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.925a	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.925d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9260	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9263	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.9266	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9269	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.926c	60		rts				rts
.926d					EorInteger:
.926d	fa		plx				plx
.926e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9271	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9274	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9275	0a		asl a				asl 	a
.9276	10 05		bpl $927d			bpl 	_NotRef
.9278	48		pha				pha
.9279	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.927c	68		pla				pla
.927d					_NotRef:
.927d	0a		asl a				asl 	a
.927e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9280	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9283	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9286	f0 03		beq $928b			beq 	_IntegerCode 				; if clear, then we have two integers
.9288	4c 46 a0	jmp $a046			jmp 	TypeError 					; anything else, type mismatch.
.928b					_IntegerCode:
.928b	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.928e	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.9291	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9294	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9297	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.929a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.929d	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.92a0	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.92a3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.92a6	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.92a9	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.92ac	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.92af	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.92b2	60		rts				rts
.92b3					WordIndirect:
.92b3	fa		plx				plx
.92b4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92b7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92ba	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92bb	0a		asl a				asl 	a
.92bc	10 05		bpl $92c3			bpl 	_NotRef
.92be	48		pha				pha
.92bf	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92c2	68		pla				pla
.92c3					_NotRef:
.92c3	0a		asl a				asl 	a
.92c4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92c6	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92c9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92cc	f0 03		beq $92d1			beq 	_IntegerCode 				; if clear, then we have two integers
.92ce	4c 46 a0	jmp $a046			jmp 	TypeError 					; anything else, type mismatch.
.92d1					_IntegerCode:
.92d1	20 94 91	jsr $9194			jsr 	AddCode 					; add the two values
.92d4	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.92d6	9d 00 04	sta $0400,x			sta 	NSStatus,x
.92d9	60		rts				rts
.92da					ByteIndirect:
.92da	fa		plx				plx
.92db	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92de	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92e1	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92e2	0a		asl a				asl 	a
.92e3	10 05		bpl $92ea			bpl 	_NotRef
.92e5	48		pha				pha
.92e6	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92e9	68		pla				pla
.92ea					_NotRef:
.92ea	0a		asl a				asl 	a
.92eb	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92ed	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92f0	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92f3	f0 03		beq $92f8			beq 	_IntegerCode 				; if clear, then we have two integers
.92f5	4c 46 a0	jmp $a046			jmp 	TypeError 					; anything else, type mismatch.
.92f8					_IntegerCode:
.92f8	20 94 91	jsr $9194			jsr 	AddCode 					; add the two values
.92fb	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.92fd	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9300	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9301					LCLConvertInt16:
.9301	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.9304	8e 10 04	stx $0410			stx 	NSMantissa1
.9307	9c 18 04	stz $0418			stz 	NSMantissa2
.930a	9c 20 04	stz $0420			stz 	NSMantissa3
.930d	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.9310	a2 00		ldx #$00			ldx 	#0 							; stack level
.9312	a9 0a		lda #$0a			lda 	#10 						; base
.9314	80 00		bra $9316			bra 	ConvertInt32
.9316					ConvertInt32:
.9316	5a		phy				phy
.9317	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9319	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.931c	10 08		bpl $9326			bpl 	_CI32NotNeg
.931e	48		pha				pha
.931f	a9 2d		lda #$2d			lda 	#'-'
.9321	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.9324	c8		iny				iny
.9325	68		pla				pla
.9326					_CI32NotNeg:
.9326	20 34 93	jsr $9334			jsr 	_CI32DivideConvert 			; recursive conversion
.9329	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.932b	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.932e	7a		ply				ply
.932f	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.9331	a9 fa		lda #$fa			lda 	#NumberBuffer & $FF
.9333	60		rts				rts
.9334					_CI32DivideConvert:
.9334	e8		inx				inx 								; write to next slot up
.9335	20 b4 9e	jsr $9eb4			jsr 	NSMSetByte
.9338	ca		dex				dex
.9339	20 d8 8f	jsr $8fd8			jsr 	Int32Divide 				; divide
.933c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.933f	48		pha				pha
.9340	20 87 8f	jsr $8f87			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.9343	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; is it zero ?
.9346	f0 06		beq $934e			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9348	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.934b	20 34 93	jsr $9334			jsr 	_CI32DivideConvert 			; and recusrively call.
.934e					_CI32NoRecurse:
.934e	68		pla				pla 								; remainder
.934f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.9351	90 02		bcc $9355			bcc 	_CI32NotHex
.9353	69 26		adc #$26			adc 	#6+32
.9355					_CI32NotHex:
.9355	69 30		adc #$30			adc 	#48
.9357	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y 				; write out and exit
.935a	c8		iny				iny
.935b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.935c					PrecedenceLevel:
>935c	04					.byte	 4	; $00 <<
>935d	02					.byte	 2	; $01 <=
>935e	02					.byte	 2	; $02 <>
>935f	00					.byte	 0	; $03 !!3
>9360	00					.byte	 0	; $04 ><
>9361	02					.byte	 2	; $05 >=
>9362	04					.byte	 4	; $06 >>
>9363	00					.byte	 0	; $07 !!7
>9364	00					.byte	 0	; $08 !!8
>9365	00					.byte	 0	; $09 !!9
>9366	00					.byte	 0	; $0a !!10
>9367	00					.byte	 0	; $0b !!11
>9368	00					.byte	 0	; $0c !!12
>9369	00					.byte	 0	; $0d !!13
>936a	00					.byte	 0	; $0e !!14
>936b	00					.byte	 0	; $0f !!15
>936c	00					.byte	 0	; $10 @
>936d	00					.byte	 0	; $11 !!17
>936e	00					.byte	 0	; $12 !!18
>936f	00					.byte	 0	; $13 [
>9370	04					.byte	 4	; $14 \
>9371	00					.byte	 0	; $15 ]
>9372	01					.byte	 1	; $16 ^
>9373	00					.byte	 0	; $17 _
>9374	00					.byte	 0	; $18 `
>9375	00					.byte	 0	; $19 !!25
>9376	00					.byte	 0	; $1a !!26
>9377	00					.byte	 0	; $1b {
>9378	01					.byte	 1	; $1c |
>9379	00					.byte	 0	; $1d }
>937a	00					.byte	 0	; $1e ~
>937b	00					.byte	 0	; $1f [7m<7F>[m
>937c	00					.byte	 0	; $20
>937d	05					.byte	 5	; $21 !
>937e	00					.byte	 0	; $22 "
>937f	00					.byte	 0	; $23 #
>9380	05					.byte	 5	; $24 $
>9381	04					.byte	 4	; $25 %
>9382	01					.byte	 1	; $26 &
>9383	00					.byte	 0	; $27 '
>9384	00					.byte	 0	; $28 (
>9385	00					.byte	 0	; $29 )
>9386	04					.byte	 4	; $2a *
>9387	03					.byte	 3	; $2b +
>9388	00					.byte	 0	; $2c ,
>9389	03					.byte	 3	; $2d -
>938a	00					.byte	 0	; $2e .
>938b	04					.byte	 4	; $2f /
>938c	00					.byte	 0	; $30 0
>938d	00					.byte	 0	; $31 1
>938e	00					.byte	 0	; $32 2
>938f	00					.byte	 0	; $33 3
>9390	00					.byte	 0	; $34 4
>9391	00					.byte	 0	; $35 5
>9392	00					.byte	 0	; $36 6
>9393	00					.byte	 0	; $37 7
>9394	00					.byte	 0	; $38 8
>9395	00					.byte	 0	; $39 9
>9396	00					.byte	 0	; $3a :
>9397	00					.byte	 0	; $3b ;
>9398	02					.byte	 2	; $3c <
>9399	02					.byte	 2	; $3d =
>939a	02					.byte	 2	; $3e >
>939b	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.939c					EvaluateExpressionAt0:
.939c	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.939e					EvaluateExpression:
.939e	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93a0					EvaluateExpressionAtPrecedence:
.93a0	48		pha				pha 								; save precedence level
.93a1	20 78 98	jsr $9878			jsr 	EvaluateTerm 				; evaluate term into level X.
.93a4	68		pla				pla 								; restore precedence level.
.93a5					_EXPRLoop:
.93a5	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.93a7	b1 30		lda ($30),y			lda 	(codePtr),y
.93a9	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.93ab	b0 25		bcs $93d2			bcs 	_EXPRExit
.93ad	da		phx				phx 								; read the operator precedence
.93ae	aa		tax				tax
.93af	bd 5c 93	lda $935c,x			lda 	PrecedenceLevel,x
.93b2	fa		plx				plx
.93b3	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.93b5	f0 1b		beq $93d2			beq 	_EXPRExit
.93b7	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93b9	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93bb	c5 37		cmp $37				cmp 	zTemp0+1
.93bd	b0 13		bcs $93d2			bcs		_EXPRExit 					; if current >= operator exit
.93bf	48		pha				pha 								; save current precedence.
.93c0	b1 30		lda ($30),y			lda 	(codePtr),y
.93c2	c8		iny				iny
.93c3	48		pha				pha
.93c4	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93c6	e8		inx				inx 								; work out the right hand side.
.93c7	20 a0 93	jsr $93a0			jsr 	EvaluateExpressionAtPrecedence
.93ca	ca		dex				dex
.93cb	68		pla				pla 								; get operator, call the code.
.93cc	20 d5 93	jsr $93d5			jsr 	_EXPRCaller
.93cf	68		pla				pla 								; restore precedence level
.93d0	80 d3		bra $93a5			bra 	_EXPRLoop 					; and go round.
.93d2					_EXPRExit:
.93d2	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93d4	60		rts				rts
.93d5					_EXPRCaller:
.93d5	da		phx				phx 								; save on stack, first thing is to restore it
.93d6	0a		asl a				asl 	a 							; double so can use vectors into X
.93d7	aa		tax				tax
.93d8	7c 1a 8b	jmp ($8b1a,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.93db					FloatingPointAdd:
.93db	20 84 95	jsr $9584			jsr 	FloatPrepare 				; prepare for floats
.93de	80 0b		bra $93eb			bra 	FloatAdd
.93e0					FloatingPointSub:
.93e0	20 84 95	jsr $9584			jsr 	FloatPrepare 				; prepare for floats
.93e3					FloatSubtract:
.93e3	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.93e6	49 80		eor #$80			eor 	#$80
.93e8	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.93eb					FloatAdd:
.93eb	48		pha				pha
.93ec	5a		phy				phy
.93ed	20 95 95	jsr $9595			jsr 	NSNormalise 				; normalise S[X]
.93f0	f0 5c		beq $944e			beq 	_FAReturn1
.93f2	e8		inx				inx 								; normalise S[X+1]
.93f3	20 95 95	jsr $9595			jsr 	NSNormalise
.93f6	ca		dex				dex
.93f7	c9 00		cmp #$00			cmp 	#0
.93f9	f0 77		beq $9472			beq 	_FAExit 					; if so, just return A
.93fb	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.93fe	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.9401	f0 1b		beq $941e			beq 	_FAExponentsEqual
.9403	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.9406	a8		tay				tay
.9407	38		sec				sec 								; do a signed comparison of the exponents.
.9408	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.940b	50 02		bvc $940f			bvc 	_FANoSignedChange
.940d	49 80		eor #$80			eor 	#$80
.940f					_FANoSignedChange:
.940f	29 80		and #$80			and 	#$80
.9411	10 03		bpl $9416			bpl 	_FAHaveMax
.9413	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.9416					_FAHaveMax:
.9416	20 75 94	jsr $9475			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9419	e8		inx				inx
.941a	20 75 94	jsr $9475			jsr 	_FAShiftToExponent
.941d	ca		dex				dex
.941e					_FAExponentsEqual:
.941e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.9421	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9424	30 10		bmi $9436			bmi 	_FADifferentSigns
.9426	20 27 91	jsr $9127			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9429	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.942c	10 44		bpl $9472			bpl 	_FAExit 					; if no, we are done.
.942e	20 d5 9e	jsr $9ed5			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9431	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.9434	80 3c		bra $9472			bra 	_FAExit
.9436					_FADifferentSigns:
.9436	20 4d 91	jsr $914d			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9439	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.943c	10 06		bpl $9444			bpl 	_FACheckZero 				; if no, check for -0
.943e	20 5e 9e	jsr $9e5e			jsr 	NSMNegate 					; netate result
.9441	20 67 9e	jsr $9e67			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9444					_FACheckZero:
.9444	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero	 				; check for -0
.9447	d0 29		bne $9472			bne 	_FAExit
.9449	9e 00 04	stz $0400,x			stz 	NSStatus,x
.944c	80 24		bra $9472			bra 	_FAExit
.944e					_FAReturn1:
.944e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9451	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9454	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9457	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.945a	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.945d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9460	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9463	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9466	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9469	9d 28 04	sta $0428,x			sta 	NSExponent,x
.946c	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.946f	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9472					_FAExit:
.9472	7a		ply				ply
.9473	68		pla				pla
.9474	60		rts				rts
.9475					_FAShiftToExponent:
.9475					_FAShiftToExponent2:
.9475	98		tya				tya 								; compare Y to exponent
.9476	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9479	f0 08		beq $9483			beq 	_FASEExit 					; exit if so.
.947b	20 d5 9e	jsr $9ed5			jsr 	NSMShiftRight	 			; shift the mantissa right
.947e	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.9481	80 f2		bra $9475			bra 	_FAShiftToExponent2
.9483					_FASEExit:
.9483	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9484					CompareFloat:
.9484	20 e3 93	jsr $93e3			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9487	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.948a	29 f8		and #$f8			and 	#$F8
.948c	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.948f	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.9492	f0 09		beq $949d			beq 	_FCExit 					; zero, so approximately identical
.9494	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9496	3c 00 04	bit $0400,x			bit 	NSStatus,x
.9499	10 02		bpl $949d			bpl 	_FCExit
.949b					_FCNegative:
.949b	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.949d					_FCExit:
.949d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.949e					FDivideCommand:
.949e	fa		plx				plx	 								; restore stack position
.949f	20 84 95	jsr $9584			jsr 	FloatPrepare 				; prepare for floats
.94a2					FloatDivide:
.94a2	48		pha				pha
.94a3	e8		inx				inx
.94a4	20 95 95	jsr $9595			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94a7	ca		dex				dex
.94a8	c9 00		cmp #$00			cmp 	#0
.94aa	f0 20		beq $94cc			beq 	_FDZero
.94ac	20 95 95	jsr $9595			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94af	f0 19		beq $94ca			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94b1	20 fa 8f	jsr $8ffa			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94b4	20 87 8f	jsr $8f87			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94b7	20 95 95	jsr $9595			jsr		NSNormalise 				; renormalise
.94ba	20 95 90	jsr $9095			jsr 	CalculateSign 				; calculate result sign
.94bd	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.94c0	38		sec				sec
.94c1	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.94c4	38		sec				sec
.94c5	e9 1e		sbc #$1e			sbc 	#30
.94c7	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94ca					_FDExit:
.94ca	68		pla				pla
.94cb	60		rts				rts
.94cc					_FDZero:
.94cc	a9 03		lda #$03		lda	#3
.94ce	4c ef 8d	jmp $8def		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.94d1					FloatFractionalPart:
.94d1	5a		phy				phy
.94d2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.94d5	29 7f		and #$7f			and 	#$7F
.94d7	9d 00 04	sta $0400,x			sta 	NSStatus,x
.94da	20 95 95	jsr $9595			jsr 	NSNormalise
.94dd	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.94e0	38		sec				sec
.94e1	e9 e0		sbc #$e0			sbc 	#$E0
.94e3	90 31		bcc $9516			bcc 	_FFPExit 					; already fractional
.94e5	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.94e7	b0 2a		bcs $9513			bcs 	_FFPZero
.94e9	a8		tay				tay 								; put count to do in Y
.94ea	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.94ed	20 18 95	jsr $9518			jsr 	_FFPPartial
.94f0	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.94f3	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.94f6	20 18 95	jsr $9518			jsr 	_FFPPartial
.94f9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.94fc	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.94ff	20 18 95	jsr $9518			jsr 	_FFPPartial
.9502	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9505	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9508	20 18 95	jsr $9518			jsr 	_FFPPartial
.950b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.950e	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; zeroed check.
.9511	d0 03		bne $9516			bne 	_FFPExit
.9513					_FFPZero:
.9513	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero
.9516					_FFPExit:
.9516	7a		ply				ply
.9517	60		rts				rts
.9518					_FFPPartial:
.9518	c0 00		cpy #$00			cpy 	#0 							; no more to do
.951a	f0 17		beq $9533			beq 	_FFFPPExit
.951c	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.951e	b0 0c		bcs $952c			bcs 	_FFFPPWholeByte
.9520	5a		phy				phy
.9521					_FFFPPLeft:
.9521	0a		asl a				asl 	a
.9522	88		dey				dey
.9523	d0 fc		bne $9521			bne 	_FFFPPLeft
.9525	7a		ply				ply
.9526					_FFFPPRight:
.9526	4a		lsr a				lsr 	a
.9527	88		dey				dey
.9528	d0 fc		bne $9526			bne 	_FFFPPRight
.952a	80 07		bra $9533			bra 	_FFFPPExit
.952c					_FFFPPWholeByte:
.952c	98		tya				tya 								; subtract 8 from count
.952d	38		sec				sec
.952e	e9 08		sbc #$08			sbc 	#8
.9530	a8		tay				tay
.9531	a9 00		lda #$00			lda 	#0 							; and clear all
.9533					_FFFPPExit:
.9533	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9534					FloatIntegerPart:
.9534	48		pha				pha
.9535	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.9538	f0 1f		beq $9559			beq 	_FIPExit 					; if so do nothing
.953a	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; is it zero ?
.953d	f0 17		beq $9556			beq 	_FIPZero 					; if so return zero.
.953f	20 95 95	jsr $9595			jsr 	NSNormalise 				; normalise
.9542	f0 12		beq $9556			beq 	_FIPZero 					; normalised to zero, exit zero
.9544					_FIPShift:
.9544	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9547	10 08		bpl $9551			bpl 	_FIPCheckZero
.9549	20 d5 9e	jsr $9ed5			jsr 	NSMShiftRight 				; shift mantissa right
.954c	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.954f	80 f3		bra $9544			bra 	_FIPShift
.9551					_FIPCheckZero:
.9551	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; avoid -0 problem
.9554	d0 03		bne $9559			bne 	_FIPExit 					; set to zero if mantissa zero.
.9556					_FIPZero:
.9556	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero
.9559					_FIPExit:
.9559	68		pla				pla
.955a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.955b					FloatingPointMultiply:
.955b	20 84 95	jsr $9584			jsr 	FloatPrepare 				; prepare for floats
.955e					FloatMultiply:
.955e	48		pha				pha
.955f	20 95 95	jsr $9595			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9562	f0 1b		beq $957f			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9564	e8		inx				inx
.9565	20 95 95	jsr $9595			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9568	ca		dex				dex
.9569	c9 00		cmp #$00			cmp 	#0
.956b	f0 0f		beq $957c			beq 	_FDSetZero
.956d	20 50 90	jsr $9050			jsr 	MultiplyShort 				; calculate the result.
.9570	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9573	18		clc				clc
.9574	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.9577	9d 28 04	sta $0428,x			sta 	NSExponent,x
.957a	80 03		bra $957f			bra 	_FDExit
.957c					_FDSetZero:
.957c	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero 					; return 0
.957f					_FDExit:
.957f	20 95 95	jsr $9595			jsr 	NSNormalise 				; normalise the result
.9582	68		pla				pla
.9583	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9584					FloatPrepare:
.9584	20 b7 96	jsr $96b7			jsr 	DereferenceTopTwo 			; dereference the top two values
.9587	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.958a	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.958d	29 10		and #$10			and 	#NSBIsString
.958f	d0 01		bne $9592			bne 	_FDType
.9591	60		rts				rts
.9592					_FDType:
.9592	4c 46 a0	jmp $a046			jmp 	TypeError
.9595					NSNormalise:
.9595	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.9598	29 80		and #$80			and 	#$80
.959a	09 08		ora #$08			ora 	#NSTFloat
.959c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.959f	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; if zero exit
.95a2	d0 09		bne $95ad			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95a4	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.95a7	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.95aa	a9 00		lda #$00			lda 	#0 							; set Z flag
.95ac	60		rts				rts
.95ad					_NSNormaliseOptimise:
.95ad	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95b0	d0 22		bne $95d4			bne 	_NSNormaliseLoop
.95b2	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.95b5	30 1d		bmi $95d4			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95b7	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.95ba	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95bd	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.95c0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95c3	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.95c6	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.95c9	bd 28 04	lda $0428,x			lda 	NSExponent,x
.95cc	38		sec				sec
.95cd	e9 08		sbc #$08			sbc 	#8
.95cf	9d 28 04	sta $0428,x			sta 	NSExponent,x
.95d2	80 d9		bra $95ad			bra 	_NSNormaliseOptimise
.95d4					_NSNormaliseLoop:
.95d4	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95d7	70 08		bvs $95e1			bvs 	_NSNExit 					; exit if so with Z flag clear
.95d9	20 c7 9e	jsr $9ec7			jsr 	NSMShiftLeft 				; shift mantissa left
.95dc	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.95df	80 f3		bra $95d4			bra 	_NSNormaliseLoop
.95e1					_NSNExit:
.95e1	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.95e4					AssignNumber:
.95e4	5a		phy				phy
.95e5	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.95e8	85 36		sta $36				sta 	zTemp0
.95ea	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95ed	85 37		sta $37				sta 	zTemp0+1
.95ef	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.95f2	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.95f4	9d 00 04	sta $0400,x			sta 	NSStatus,x
.95f7	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.95f9	c9 08		cmp #$08			cmp 	#NSTFloat
.95fb	f0 2a		beq $9627			beq 	_ANFloat
.95fd	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.9600	f0 05		beq $9607			beq		_ANNotFloat
.9602	e8		inx				inx
.9603	20 34 95	jsr $9534			jsr 	FloatIntegerPart 			; make it an integer
.9606	ca		dex				dex
.9607					_ANNotFloat:
.9607	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.960a	29 03		and #$03			and 	#3
.960c	d0 05		bne $9613			bne 	_ANByteWord
.960e	20 33 96	jsr $9633			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9611	80 1e		bra $9631			bra 	_ANExit
.9613					_ANByteWord:
.9613	48		pha				pha 								; save count
.9614	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.9617	92 36		sta ($36)			sta 	(zTemp0)
.9619	68		pla				pla
.961a	c9 01		cmp #$01			cmp	 	#1
.961c	f0 13		beq $9631			beq 	_ANExit
.961e	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.9621	a0 01		ldy #$01			ldy 	#1
.9623	91 36		sta ($36),y			sta 	(zTemp0),y
.9625	80 0a		bra $9631			bra 	_ANExit
.9627					_ANFloat:
.9627	20 33 96	jsr $9633			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.962a	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.962d	a0 04		ldy #$04			ldy 	#4
.962f	91 36		sta ($36),y			sta 	(zTemp0),y
.9631					_ANExit:
.9631	7a		ply				ply
.9632	60		rts				rts
.9633					_ANCopy4PackSign:
.9633	a0 03		ldy #$03			ldy 	#3
.9635	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.9638	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.963a	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.963d	91 36		sta ($36),y			sta 	(zTemp0),y
.963f	88		dey				dey
.9640	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9643	91 36		sta ($36),y			sta 	(zTemp0),y
.9645	88		dey				dey
.9646	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9649	91 36		sta ($36),y			sta 	(zTemp0),y
.964b	88		dey				dey
.964c	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.964f	91 36		sta ($36),y			sta 	(zTemp0),y
.9651	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9652					AssignString:
.9652	5a		phy				phy
.9653	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9656	85 38		sta $38				sta 	zTemp1
.9658	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.965b	85 39		sta $39				sta 	zTemp1+1
.965d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9660	85 36		sta $36				sta 	zTemp0
.9662	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9665	85 37		sta $37				sta 	zTemp0+1
.9667	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9669	b1 36		lda ($36),y			lda 	(zTemp0),y
.966b	f0 23		beq $9690			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.966d	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.966e	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9670	e9 02		sbc #$02			sbc 	#2
.9672	85 3c		sta $3c				sta 	zsTemp
.9674	a0 01		ldy #$01			ldy 	#1
.9676	b1 36		lda ($36),y			lda 	(zTemp0),y
.9678	e9 00		sbc #$00			sbc 	#0
.967a	85 3d		sta $3d				sta 	zsTemp+1
.967c	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.967e					_ASGetLength:
.967e	c8		iny				iny
.967f	b1 38		lda ($38),y			lda 	(zTemp1),y
.9681	d0 fb		bne $967e			bne 	_ASGetLength
.9683	98		tya				tya 								; is this length <= current length
.9684	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9686	90 20		bcc $96a8			bcc 	_ASCopyString
.9688	f0 1e		beq $96a8			beq 	_ASCopyString
.968a	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.968c	a0 01		ldy #$01			ldy 	#1
.968e	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9690					_ASNewStringRequired:
.9690	e8		inx				inx 								; concrete the new string.
.9691	20 9a a7	jsr $a79a			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9694	ca		dex				dex
.9695	18		clc				clc
.9696	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9699	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.969b	92 36		sta ($36)			sta 	(zTemp0)
.969d	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.96a0	69 00		adc #$00			adc 	#0
.96a2	a0 01		ldy #$01			ldy 	#1
.96a4	91 36		sta ($36),y			sta 	(zTemp0),y
.96a6	80 0d		bra $96b5			bra 	_ASExit
.96a8					_ASCopyString:
.96a8	a0 00		ldy #$00			ldy 	#0
.96aa					_ASCopyLoop:
.96aa	b1 38		lda ($38),y			lda 	(zTemp1),y
.96ac	c8		iny				iny
.96ad	c8		iny				iny
.96ae	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96b0	88		dey				dey
.96b1	c9 00		cmp #$00			cmp 	#0
.96b3	d0 f5		bne $96aa			bne 	_ASCopyLoop
.96b5					_ASExit:
.96b5	7a		ply				ply
.96b6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96b7					DereferenceTopTwo:
.96b7	e8		inx				inx
.96b8	20 bc 96	jsr $96bc			jsr 	Dereference 				; deref x+1
.96bb	ca		dex				dex  								; falls through to deref x
.96bc					Dereference:
.96bc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.96bf	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.96c1	f0 57		beq $971a			beq 	_DRFExit 					; not a reference
.96c3	5a		phy				phy
.96c4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96c7	85 36		sta $36				sta 	zTemp0
.96c9	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.96cc	85 37		sta $37				sta 	zTemp0+1
.96ce	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.96d1	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96d3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.96d6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.96d9	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96db	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96dd	f0 0f		beq $96ee			beq 	_DRFDereferenceTwo
.96df	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96e1	f0 39		beq $971c			beq 	_DRFFull
.96e3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96e6	29 03		and #$03			and 	#3
.96e8	f0 32		beq $971c			beq 	_DRFFull 					; the whole word
.96ea	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96ec	f0 07		beq $96f5			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96ee					_DRFDereferenceTwo:
.96ee	a0 01		ldy #$01			ldy 	#1
.96f0	b1 36		lda ($36),y			lda 	(zTemp0),y
.96f2	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.96f5					_DRFClear23:
.96f5	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.96f8	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.96fb	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.96fe	29 18		and #$18			and 	#NSBTypeMask
.9700	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9703	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9705	d0 12		bne $9719			bne 	_DRFNotString
.9707	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.970a	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.970d	d0 0a		bne $9719			bne 	_DRFNotString
.970f	a9 1b		lda #$1b			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9711	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.9714	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9716	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.9719					_DRFNotString
.9719	7a		ply				ply 								; restore Y and exit
.971a					_DRFExit:
.971a	60		rts				rts
.971b					_DRFNullString:
>971b	00						.byte 	0
.971c					_DRFFull:
.971c	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.971e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9720	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9723	c8		iny				iny
.9724	b1 36		lda ($36),y			lda 	(zTemp0),y
.9726	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9729	c8		iny				iny
.972a	b1 36		lda ($36),y			lda 	(zTemp0),y
.972c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.972f	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.9732	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.9735	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9737	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.973a	f0 06		beq $9742			beq 	_DRFNoExponent
.973c	c8		iny				iny 								; if not, read the exponent as well.
.973d	b1 36		lda ($36),y			lda 	(zTemp0),y
.973f	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9742					_DRFNoExponent:
.9742	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9745	10 0d		bpl $9754			bpl 	_DRFExit2 					; if not, then exit.
.9747	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9749	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.974c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.974f	09 80		ora #$80			ora 	#NSBIsNegative
.9751	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9754					_DRFExit2:
.9754	7a		ply				ply
.9755	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9756					EncodeNumberStart:
.9756	38		sec				sec
.9757	80 01		bra $975a			bra 	EncodeNumberContinue+1
.9759					EncodeNumberContinue:
.9759	18		clc				clc
.975a					EncodeNumber:
.975a	08		php				php 								; save reset.
.975b	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.975d	f0 12		beq $9771			beq 	_ENIsOkay
.975f	c9 30		cmp #$30			cmp 	#"0"
.9761	90 04		bcc $9767			bcc 	_ENBadNumber
.9763	c9 3a		cmp #$3a			cmp 	#"9"+1
.9765	90 0a		bcc $9771			bcc 	_ENIsOkay
.9767					_ENBadNumber:
.9767	28		plp				plp 								; throw saved reset
.9768	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.976b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.976d	f0 7e		beq $97ed			beq 	_ENConstructFinal
.976f					_ENFail:
.976f	18		clc				clc 								; not allowed
.9770	60		rts				rts
.9771					_ENIsOkay:
.9771	28		plp				plp 								; are we restarting
.9772	90 15		bcc $9789			bcc 	_ENNoRestart
.9774					_ENStartEncode:
.9774	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.9776	f0 0c		beq $9784			beq 	_ENFirstDP
.9778	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.977a	20 b4 9e	jsr $9eb4			jsr 	NSMSetByte
.977d	a9 01		lda #$01			lda 	#ESTA_Low
.977f					_ENExitChange:
.977f	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.9782	38		sec				sec
.9783	60		rts				rts
.9784					_ENFirstDP:
.9784	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero 					; clear integer part
.9787	80 3f		bra $97c8			bra 	_ESTASwitchFloat			; go straight to float and exi
.9789					_ENNoRestart:
.9789	48		pha				pha 								; save on stack.
.978a	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.978d	c9 01		cmp #$01			cmp 	#ESTA_Low
.978f	f0 09		beq $979a			beq  	_ESTALowState
.9791	c9 02		cmp #$02			cmp 	#ESTA_High
.9793	f0 29		beq $97be			beq 	_ESTAHighState
.9795	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9797	f0 3b		beq $97d4			beq 	_ESTADecimalState
>9799	db						.byte 	$DB 						; causes a break in the emulator
.979a					_ESTALowState:
.979a	68		pla				pla 								; get value back
.979b	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.979d	f0 29		beq $97c8			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.979f	29 0f		and #$0f			and 	#15 						; make digit
.97a1	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.97a4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97a7	0a		asl a				asl 	a
.97a8	0a		asl a				asl 	a
.97a9	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97ac	0a		asl a				asl 	a
.97ad	6d 86 04	adc $0486			adc 	DigitTemp
.97b0	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97b3	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97b5	90 05		bcc $97bc			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97b7	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97b9	8d 85 04	sta $0485			sta 	EncodeState
.97bc					_ESTANoSwitch:
.97bc	38		sec				sec
.97bd	60		rts				rts
.97be					_ESTAHighState:
.97be	68		pla				pla 								; get value back
.97bf	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97c1	f0 05		beq $97c8			beq 	_ESTASwitchFloat
.97c3	20 27 98	jsr $9827			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97c6	38		sec				sec
.97c7	60		rts				rts
.97c8					_ESTASwitchFloat:
.97c8	9c 87 04	stz $0487			stz 	DecimalCount
.97cb	e8		inx				inx 								; zero the decimal additive.
.97cc	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero
.97cf	ca		dex				dex
.97d0	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97d2	80 ab		bra $977f			bra 	_ENExitChange
.97d4					_ESTADecimalState:
.97d4	68		pla				pla 								; digit.
.97d5	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97d7	f0 96		beq $976f			beq 	_ENFail
.97d9	e8		inx				inx 								; put digit into fractional part of X+1
.97da	20 27 98	jsr $9827			jsr 	ESTAShiftDigitIntoMantissa
.97dd	ca		dex				dex
.97de	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.97e1	ad 87 04	lda $0487			lda 	DecimalCount
.97e4	c9 0b		cmp #$0b			cmp 	#11
.97e6	f0 02		beq $97ea			beq 	_ESTADSFail
.97e8	38		sec				sec
.97e9	60		rts				rts
.97ea					_ESTADSFail:
.97ea	4c 41 a0	jmp $a041			jmp 	RangeError
.97ed					_ENConstructFinal:
.97ed	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.97f0	f0 33		beq $9825			beq 	_ENCFExit 					; no decimals
.97f2	5a		phy				phy
.97f3	0a		asl a				asl 	a 							; x 4 and CLC
.97f4	0a		asl a				asl 	a
.97f5	6d 87 04	adc $0487			adc 	DecimalCount
.97f8	a8		tay				tay
.97f9	b9 00 a0	lda $a000,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.97fc	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.97ff	b9 01 a0	lda $a001,y			lda 	DecimalScalarTable-5+1,y
.9802	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9805	b9 02 a0	lda $a002,y			lda 	DecimalScalarTable-5+2,y
.9808	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.980b	b9 03 a0	lda $a003,y			lda 	DecimalScalarTable-5+3,y
.980e	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9811	b9 04 a0	lda $a004,y			lda 	DecimalScalarTable-5+4,y
.9814	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9817	a9 08		lda #$08			lda 	#NSTFloat
.9819	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.981c	7a		ply				ply
.981d	e8		inx				inx 								; multiply decimal const by decimal scalar
.981e	20 5e 95	jsr $955e			jsr 	FloatMultiply
.9821	ca		dex				dex
.9822	20 eb 93	jsr $93eb			jsr 	FloatAdd 					; add to integer part.
.9825					_ENCFExit:
.9825	18		clc				clc 								; reject the digit.
.9826	60		rts				rts
.9827					ESTAShiftDigitIntoMantissa:
.9827	29 0f		and #$0f			and 	#15 						; save digit
.9829	48		pha				pha
.982a	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.982d	48		pha				pha
.982e	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9831	48		pha				pha
.9832	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9835	48		pha				pha
.9836	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9839	48		pha				pha
.983a	20 c7 9e	jsr $9ec7			jsr 	NSMShiftLeft 				; x 2
.983d	20 c7 9e	jsr $9ec7			jsr 	NSMShiftLeft 				; x 4
.9840	18		clc				clc 								; pop mantissa and add
.9841	68		pla				pla
.9842	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9845	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9848	68		pla				pla
.9849	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.984c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.984f	68		pla				pla
.9850	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.9853	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9856	68		pla				pla
.9857	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.985a	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.985d	20 c7 9e	jsr $9ec7			jsr 	NSMShiftLeft 				; x 10
.9860	68		pla				pla 								; add digit
.9861	18		clc				clc
.9862	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9865	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9868	90 0d		bcc $9877			bcc 	_ESTASDExit
.986a	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.986d	d0 08		bne $9877			bne 	_ESTASDExit
.986f	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.9872	d0 03		bne $9877			bne 	_ESTASDExit
.9874	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.9877					_ESTASDExit:
.9877	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9878					EvaluateTerm:
.9878	b1 30		lda ($30),y			lda 	(codePtr),y
.987a	30 18		bmi $9894			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.987c	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.987e	b0 6f		bcs $98ef			bcs 	_ETVariable
.9880	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9882	90 6e		bcc $98f2			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9884	c9 3a		cmp #$3a			cmp 	#'9'+1
.9886	b0 6a		bcs $98f2			bcs 	_ETPuncUnary
.9888	20 56 97	jsr $9756			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.988b					_ETNumber:
.988b	c8		iny				iny 								; keep encoding until we have the numbers
.988c	b1 30		lda ($30),y			lda 	(codePtr),y
.988e	20 59 97	jsr $9759			jsr 	EncodeNumberContinue
.9891	b0 f8		bcs $988b			bcs 	_ETNumber 					; go back if accepted.
.9893	60		rts				rts
.9894					_ETCheckUnary:
.9894	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9896	f0 41		beq $98d9			beq 	_ETString
.9898	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.989a	f0 12		beq $98ae			beq 	_ETHexConstant
.989c	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.989e	90 0b		bcc $98ab			bcc 	_ETSyntaxError
.98a0	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.98a2	b0 07		bcs $98ab			bcs 	_ETSyntaxError
.98a4	da		phx				phx 								; push X on the stack
.98a5	0a		asl a				asl 	a 							; put vector x 2 into X
.98a6	aa		tax				tax
.98a7	c8		iny				iny 								; consume unary function token
.98a8	7c 9a 8b	jmp ($8b9a,x)			jmp 	(VectorSet0,x) 				; and do it.
.98ab					_ETSyntaxError:
.98ab	4c 3c a0	jmp $a03c			jmp 	SyntaxError
.98ae					_ETHexConstant:
.98ae	c8		iny				iny 								; skip #
.98af	c8		iny				iny 								; skip count
.98b0	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero 					; clear result
.98b3					_ETHLoop:
.98b3	b1 30		lda ($30),y			lda 	(codePtr),y
.98b5	c8		iny				iny 								; and consume
.98b6	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.98b8	f0 1e		beq $98d8			beq 	_ETHExit
.98ba	48		pha				pha 								; save on stack.
.98bb	20 c7 9e	jsr $9ec7			jsr 	NSMShiftLeft 				; x 2
.98be	20 c7 9e	jsr $9ec7			jsr 	NSMShiftLeft 				; x 4
.98c1	20 c7 9e	jsr $9ec7			jsr 	NSMShiftLeft 				; x 8
.98c4	20 c7 9e	jsr $9ec7			jsr 	NSMShiftLeft 				; x 16
.98c7	68		pla				pla 								; ASCII
.98c8	c9 41		cmp #$41			cmp 	#'A'
.98ca	90 02		bcc $98ce			bcc 	_ETHNotChar
.98cc	e9 07		sbc #$07			sbc 	#7
.98ce					_ETHNotChar:
.98ce	29 0f		and #$0f			and 	#15 						; digit now
.98d0	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98d3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98d6	80 db		bra $98b3			bra 	_ETHLoop 					; go round.
.98d8					_ETHExit:
.98d8	60		rts				rts
.98d9					_ETString:
.98d9	c8		iny				iny 								; look at length
.98da	b1 30		lda ($30),y			lda 	(codePtr),y
.98dc	48		pha				pha
.98dd	c8		iny				iny 								; first character
.98de	20 37 a6	jsr $a637			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98e1	68		pla				pla 								; restore count and save
.98e2	85 36		sta $36				sta 	zTemp0
.98e4	98		tya				tya 								; add length to Y to skip it.
.98e5	18		clc				clc
.98e6	65 36		adc $36				adc 	zTemp0
.98e8	a8		tay				tay
.98e9	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98eb	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98ee	60		rts				rts
.98ef					_ETVariable:
.98ef	4c 49 99	jmp $9949			jmp 	VariableHandler
.98f2					_ETPuncUnary:
.98f2	c8		iny				iny 								; consume the unary character
.98f3	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98f5	f0 2d		beq $9924			beq 	_ETUnaryNegate
.98f7	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98f9	f0 39		beq $9934			beq 	_ETDereference
.98fb	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.98fd	f0 43		beq $9942			beq 	_ETParenthesis
.98ff	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9901	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9903	f0 06		beq $990b			beq 	_ETIndirection
.9905	e6 36		inc $36				inc 	zTemp0
.9907	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9909	d0 a0		bne $98ab			bne 	_ETSyntaxError
.990b					_ETIndirection:
.990b	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.990d	1a		inc a				inc 	a
.990e	48		pha				pha
.990f	20 78 98	jsr $9878			jsr 	EvaluateTerm				; evaluate the term
.9912	20 bc 96	jsr $96bc			jsr 	Dereference 				; dereference it.
.9915	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.9918	d0 07		bne $9921			bne 	_ETTypeMismatch
.991a	68		pla				pla 								; indirection 1-2
.991b	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.991d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9920	60		rts				rts
.9921					_ETTypeMismatch:
.9921	4c 46 a0	jmp $a046			jmp 	TypeError
.9924					_ETUnaryNegate:
.9924	20 78 98	jsr $9878			jsr 	EvaluateTerm				; evaluate the term
.9927	20 bc 96	jsr $96bc			jsr 	Dereference 				; dereference it.
.992a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.992d	29 10		and #$10			and 	#NSTString
.992f	d0 f0		bne $9921			bne 	_ETTypeMismatch
.9931	4c 5e 9e	jmp $9e5e			jmp 	NSMNegate  					; just toggles the sign bit.
.9934					_ETDereference:
.9934	20 78 98	jsr $9878			jsr 	EvaluateTerm				; evaluate the term
.9937	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.993a	29 20		and #$20			and 	#NSBIsReference
.993c	f0 e3		beq $9921			beq 	_ETTypeMismatch
.993e	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.9941	60		rts				rts
.9942					_ETParenthesis:
.9942	20 9e 93	jsr $939e			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9945	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket 			; check for )
.9948	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9949					VariableHandler:
.9949	b1 30		lda ($30),y			lda 	(codePtr),y
.994b	18		clc				clc
.994c	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.994e	85 37		sta $37				sta 	zTemp0+1
.9950	c8		iny				iny
.9951	b1 30		lda ($30),y			lda 	(codePtr),y
.9953	85 36		sta $36				sta 	zTemp0
.9955	c8		iny				iny
.9956	18		clc				clc									; copy variable address+3 to mantissa
.9957	69 03		adc #$03			adc 	#3
.9959	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.995c	a5 37		lda $37				lda 	zTemp0+1
.995e	69 00		adc #$00			adc 	#0
.9960	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9963	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9966	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9969	9e 28 04	stz $0428,x			stz 	NSExponent,x
.996c	5a		phy				phy
.996d	a0 02		ldy #$02			ldy 	#2 							; read type
.996f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9971	7a		ply				ply
.9972	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9974	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9976	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9979	29 04		and #$04			and 	#NSBIsArray
.997b	d0 01		bne $997e			bne 	_VHArray
.997d	60		rts				rts
.997e					_VHArray:
.997e	e8		inx				inx
.997f	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9982	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9984	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9987	b1 30		lda ($30),y			lda 	(codePtr),y
.9989	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.998b	d0 06		bne $9993			bne 	_VHNoSecondIndex
.998d	c8		iny				iny 								; skip the comma
.998e	e8		inx				inx
.998f	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9992	ca		dex				dex
.9993					_VHNoSecondIndex:
.9993	ca		dex				dex 								; set X back.
.9994	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket 			; and check the right bracket.
.9997	5a		phy				phy 								; save position
.9998	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.999a	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.999c	f0 6b		beq $9a09			beq 	_VHBadIndex
.999e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.99a1	85 3e		sta $3e				sta 	zaTemp
.99a3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.99a6	85 3f		sta $3f				sta 	zaTemp+1
.99a8	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.99aa	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99ac	f0 02		beq $99b0			beq 	_VHHas2Mask
.99ae	a9 ff		lda #$ff			lda 	#$FF
.99b0					_VHHas2Mask:
.99b0	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.99b3	f0 54		beq $9a09			beq 	_VHBadIndex
.99b5	0a		asl a				asl 	a 							; carry will be set if a second index
.99b6	90 09		bcc $99c1			bcc 	_VHCheckFirstIndex
.99b8	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.99ba	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99bc	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.99bf	90 48		bcc $9a09			bcc 	_VHBadIndex
.99c1					_VHCheckFirstIndex:
.99c1	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.99c3	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99c5	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.99c8	90 3f		bcc $9a09			bcc 	_VHBadIndex
.99ca	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.99cc	64 37		stz $37				stz 	zTemp0+1
.99ce	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99d1	30 0f		bmi $99e2			bmi 	_VHNoMultiply
.99d3	da		phx				phx
.99d4	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.99d7	48		pha				pha
.99d8	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.99da	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99dc	1a		inc a				inc 	a 							; add 1 for zero base
.99dd	fa		plx				plx
.99de	20 47 9e	jsr $9e47			jsr 	Multiply8x8 				; calculate -> Z0
.99e1	fa		plx				plx
.99e2					_VHNoMultiply:
.99e2	18		clc				clc
.99e3	a5 36		lda $36				lda 	zTemp0
.99e5	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.99e8	85 36		sta $36				sta 	zTemp0
.99ea	a5 37		lda $37				lda 	zTemp0+1
.99ec	69 00		adc #$00			adc 	#0
.99ee	85 37		sta $37				sta 	zTemp0+1
.99f0	bd 00 04	lda $0400,x			lda 	NSStatus,x
.99f3	20 f0 84	jsr $84f0			jsr 	ScaleByBaseType
.99f6	18		clc				clc
.99f7	b2 3e		lda ($3e)			lda 	(zaTemp)
.99f9	65 36		adc $36				adc 	zTemp0
.99fb	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.99fe	a0 01		ldy #$01			ldy 	#1
.9a00	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9a02	65 37		adc $37				adc 	zTemp0+1
.9a04	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9a07	7a		ply				ply 								; restore position
.9a08	60		rts				rts
.9a09					_VHBadIndex:
.9a09	a9 17		lda #$17		lda	#23
.9a0b	4c ef 8d	jmp $8def		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9a0e					AbsUnary:
.9a0e	fa		plx				plx 								; restore stack pos
.9a0f	20 db 9d	jsr $9ddb			jsr 	EvaluateNumber 				; get a float or int
.9a12	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.9a15	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.9a18	29 7f		and #$7f			and 	#$7F
.9a1a	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a1d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9a1e					AllocUnary:
.9a1e	fa		plx				plx 								; restore stack pos
.9a1f	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger		; get bytes required.
.9a22	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.9a25	da		phx				phx 								; save X/Y
.9a26	5a		phy				phy
.9a27	8a		txa				txa 								; copy X into Y
.9a28	a8		tay				tay
.9a29	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.9a2c	aa		tax				tax
.9a2d	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.9a30	20 3d 9a	jsr $9a3d			jsr 	AllocateXABytes 			; allocate memory
.9a33	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.9a36	8a		txa				txa
.9a37	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.9a3a	7a		ply				ply
.9a3b	fa		plx				plx
.9a3c	60		rts				rts
.9a3d					AllocateXABytes:
.9a3d	5a		phy				phy
.9a3e	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a41	84 36		sty $36				sty 	zTemp0
.9a43	5a		phy				phy
.9a44	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.9a47	84 37		sty $37				sty 	zTemp0+1
.9a49	5a		phy				phy
.9a4a	18		clc				clc 								; add to low memory pointer
.9a4b	6d 8c 04	adc $048c			adc 	lowMemPtr
.9a4e	8d 8c 04	sta $048c			sta 	lowMemPtr
.9a51	8a		txa				txa
.9a52	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.9a55	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.9a58	b0 2f		bcs $9a89			bcs 	CISSMemory
.9a5a	20 7b 9a	jsr $9a7b			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a5d					_ClearMemory:
.9a5d	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.9a60	c5 36		cmp $36				cmp 	zTemp0
.9a62	d0 07		bne $9a6b			bne 	_CMClearNext
.9a64	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.9a67	c5 37		cmp $37				cmp 	zTemp0+1
.9a69	f0 0c		beq $9a77			beq 	_CMExit
.9a6b					_CMClearNext:
.9a6b	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a6d	92 36		sta ($36)			sta 	(zTemp0)
.9a6f	e6 36		inc $36				inc 	zTemp0
.9a71	d0 ea		bne $9a5d			bne 	_ClearMemory
.9a73	e6 37		inc $37				inc		zTemp0+1
.9a75	80 e6		bra $9a5d			bra 	_ClearMemory
.9a77					_CMExit:
.9a77	fa		plx				plx
.9a78	68		pla				pla
.9a79	7a		ply				ply
.9a7a	60		rts				rts
.9a7b					CheckIdentifierStringSpace:
.9a7b	48		pha				pha
.9a7c	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.9a7f	18		clc				clc
.9a80	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a82	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a85	b0 02		bcs $9a89			bcs 	CISSMemory
.9a87	68		pla				pla
.9a88	60		rts				rts
.9a89					CISSMemory:
.9a89	a9 06		lda #$06		lda	#6
.9a8b	4c ef 8d	jmp $8def		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a8e					AscUnary:
.9a8e	fa		plx				plx 								; restore stack pos
.9a8f	20 e6 9d	jsr $9de6			jsr 	EvaluateString 				; get a string
.9a92	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9a94	20 b4 9e	jsr $9eb4			jsr 	NSMSetByte
.9a97	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.9a9a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a9b					FracUnary:
.9a9b	fa		plx				plx 								; restore stack pos
.9a9c	20 db 9d	jsr $9ddb			jsr 	EvaluateNumber 				; get a float or int
.9a9f	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.9aa2	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9aa5	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9aa7	f0 04		beq $9aad			beq 	_IUZero
.9aa9	20 d1 94	jsr $94d1			jsr 	FloatFractionalPart
.9aac	60		rts				rts
.9aad					_IUZero:
.9aad	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero
.9ab0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9ab1					IntUnary:
.9ab1	fa		plx				plx 								; restore stack pos
.9ab2	20 db 9d	jsr $9ddb			jsr 	EvaluateNumber 				; get a float or int
.9ab5	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.9ab8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9abb	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9abd	f0 03		beq $9ac2			beq 	_IUExit
.9abf	20 34 95	jsr $9534			jsr 	FloatIntegerPart
.9ac2					_IUExit:
.9ac2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9ac3					LenUnary:
.9ac3	fa		plx				plx 								; restore stack pos
.9ac4	20 e6 9d	jsr $9de6			jsr 	EvaluateString 				; get a string
.9ac7	5a		phy				phy
.9ac8	a0 00		ldy #$00			ldy 	#0 							; find length
.9aca					_LenFind:
.9aca	b1 36		lda ($36),y			lda 	(zTemp0),y
.9acc	f0 06		beq $9ad4			beq 	_LenExit
.9ace	c8		iny				iny
.9acf	d0 f9		bne $9aca			bne 	_LenFind
.9ad1	4c 41 a0	jmp $a041			jmp 	RangeError 					; string > 255
.9ad4					_LenExit:
.9ad4	98		tya				tya
.9ad5	20 b4 9e	jsr $9eb4			jsr 	NSMSetByte
.9ad8	7a		ply				ply
.9ad9	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.9adc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9add					Unary_Min:
.9add	a9 01		lda #$01			lda 	#1
.9adf	80 02		bra $9ae3			bra 	UnaryMinMaxMain
.9ae1					Unary_Max:
.9ae1	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9ae3					UnaryMinMaxMain:
.9ae3	fa		plx				plx 								; get index on number stack
.9ae4	48		pha				pha 								; save comparator
.9ae5	20 d2 9d	jsr $9dd2			jsr 	EvaluateValue 				; get the first value.
.9ae8					_UMMMLoop:
.9ae8	b1 30		lda ($30),y			lda 	(codePtr),y
.9aea	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9aec	f0 22		beq $9b10			beq 	_UMMMDone
.9aee	20 de 8d	jsr $8dde			jsr 	CheckComma 					; must be a comma
.9af1	e8		inx				inx
.9af2	20 d2 9d	jsr $9dd2			jsr 	EvaluateValue
.9af5	ca		dex				dex
.9af6	20 89 9e	jsr $9e89			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9af9	e8		inx				inx
.9afa	20 89 9e	jsr $9e89			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9afd	e8		inx				inx
.9afe	20 a7 8e	jsr $8ea7			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9b01	ca		dex				dex
.9b02	ca		dex				dex
.9b03	85 36		sta $36				sta 	zTemp0 						; save required result
.9b05	68		pla				pla 								; get and save comparator
.9b06	48		pha				pha
.9b07	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9b09	d0 dd		bne $9ae8			bne 	_UMMMLoop
.9b0b	20 13 9b	jsr $9b13			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9b0e	80 d8		bra $9ae8			bra 	_UMMMLoop
.9b10					_UMMMDone:
.9b10	68		pla				pla 								; throw the comparator
.9b11	c8		iny				iny 								; skip )
.9b12	60		rts				rts
.9b13					ExpCopyAboveDown:
.9b13	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9b16	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b19	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9b1c	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9b1f	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9b22	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b25	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9b28	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b2b	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9b2e	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b31	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9b34	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b37	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b38					Unary_Not:
.9b38	fa		plx				plx
.9b39	20 fe 9d	jsr $9dfe			jsr 	EvaluateInteger 			; get integer
.9b3c	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.9b3f	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; zero mantissa ?
.9b42	f0 04		beq $9b48			beq 	_NotZero
.9b44	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero
.9b47	60		rts				rts
.9b48					_NotZero:
.9b48	4c 5c 8e	jmp $8e5c			jmp 	ReturnTrue
.9b4b					_UNBad:
.9b4b	4c 4b a0	jmp $a04b			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b4e					Unary_Random:
.9b4e	fa		plx				plx
.9b4f	20 cd 9b	jsr $9bcd			jsr 	Random32Bit 				; get a random number
.9b52	20 b2 9b	jsr $9bb2			jsr 	URCopyToMantissa  			; put in mantissa
.9b55	b1 30		lda ($30),y			lda 	(codePtr),y
.9b57	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b59	f0 08		beq $9b63			beq 	_URNoModulus
.9b5b	e8		inx				inx
.9b5c	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b5f	ca		dex				dex
.9b60	20 cb 8f	jsr $8fcb			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9b63					_URNoModulus:
.9b63	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9b66	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9b69	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.9b6c	60		rts				rts
.9b6d					Unary_Rnd:
.9b6d	fa		plx				plx
.9b6e	20 db 9d	jsr $9ddb			jsr 	EvaluateNumber 				; number to use.
.9b71	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket 			; closing bracket
.9b74	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b77	f0 2b		beq $9ba4			beq 	_URCopySeed
.9b79	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b7c	10 23		bpl $9ba1			bpl 	_URDontSeed
.9b7e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b81	49 17		eor #$17			eor 	#$17
.9b83	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b86	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9b89	49 a5		eor #$a5			eor 	#$A5
.9b8b	8d 89 04	sta $0489			sta 	RandomSeed+1
.9b8e	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9b91	49 c2		eor #$c2			eor 	#$C2
.9b93	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9b96	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9b99	49 9d		eor #$9d			eor 	#$9D
.9b9b	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9b9e	20 cd 9b	jsr $9bcd			jsr 	Random32Bit
.9ba1					_URDontSeed:
.9ba1	20 cd 9b	jsr $9bcd			jsr 	Random32Bit 				; generate a number.
.9ba4					_URCopySeed:
.9ba4	20 b2 9b	jsr $9bb2			jsr 	URCopyToMantissa 			; copy into mantissa
.9ba7	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9ba9	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9bac	a9 08		lda #$08			lda 	#NSTFloat
.9bae	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; positive.
.9bb1	60		rts				rts
.9bb2					URCopyToMantissa:
.9bb2	ad 88 04	lda $0488			lda 	RandomSeed+0
.9bb5	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9bb8	ad 89 04	lda $0489			lda 	RandomSeed+1
.9bbb	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9bbe	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9bc1	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9bc4	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9bc7	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9bc9	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9bcc	60		rts				rts
.9bcd					Random32Bit:
.9bcd	5a		phy				phy
.9bce	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9bd0	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9bd3	d0 03		bne $9bd8			bne 	_Random1
.9bd5	a8		tay				tay 								; if so do it 256 times
.9bd6	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9bd8					_Random1:
.9bd8	0a		asl a				asl 	a 							; LSFR RNG
.9bd9	2e 89 04	rol $0489			rol 	RandomSeed+1
.9bdc	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9bdf	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9be2	90 02		bcc $9be6			bcc 	_Random2
.9be4	49 c5		eor #$c5			eor 	#$C5
.9be6					_Random2:
.9be6	88		dey				dey
.9be7	d0 ef		bne $9bd8			bne 	_Random1
.9be9	8d 88 04	sta $0488			sta 	RandomSeed+0
.9bec	7a		ply				ply
.9bed	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9bee					SgnUnary:
.9bee	fa		plx				plx 								; restore stack pos
.9bef	20 db 9d	jsr $9ddb			jsr 	EvaluateNumber 				; get a float or int
.9bf2	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.9bf5	20 e2 9e	jsr $9ee2			jsr 	NSMIsZero 					; if zero
.9bf8	f0 10		beq $9c0a			beq 	_SGZero  					; return Int Zero
.9bfa	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9bfd	48		pha				pha
.9bfe	a9 01		lda #$01			lda 	#1 							; set to 1
.9c00	20 b4 9e	jsr $9eb4			jsr 	NSMSetByte
.9c03	68		pla				pla
.9c04	29 80		and #$80			and		#$80 						; copy the sign byte out
.9c06	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c09	60		rts				rts
.9c0a	20 b2 9e	jsr $9eb2	_SGZero:jsr 	NSMSetZero
.9c0d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9c0e					ValUnary:
.9c0e	fa		plx				plx 								; restore stack pos
.9c0f	20 24 9c	jsr $9c24			jsr 	ValMainCode 				; do the main val() code
.9c12	b0 01		bcs $9c15			bcs 	_VUError 					; couldn't convert
.9c14	60		rts				rts
.9c15					_VUError:
.9c15	4c 46 a0	jmp $a046			jmp 	TypeError
.9c18					IsValUnary:
.9c18	fa		plx				plx 								; restore stack pos
.9c19	20 24 9c	jsr $9c24			jsr 	ValMainCode 				; do the main val() code
.9c1c	b0 03		bcs $9c21			bcs 	_VUBad
.9c1e	4c 5c 8e	jmp $8e5c			jmp 	ReturnTrue
.9c21					_VUBad:
.9c21	4c 68 8e	jmp $8e68			jmp 	ReturnFalse
.9c24					ValMainCode:
.9c24	20 e6 9d	jsr $9de6			jsr 	EvaluateString 				; get a string
.9c27	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket 			; check right bracket present
.9c2a					ValEvaluateZTemp0:
.9c2a	5a		phy				phy
.9c2b	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9c2d	f0 17		beq $9c46			beq 	_VMCFail2
.9c2f	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9c31	48		pha				pha 								; save first character
.9c32	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9c34	d0 01		bne $9c37			bne 	_VMCStart
.9c36	c8		iny				iny 								; skip over -
.9c37					_VMCStart:
.9c37	38		sec				sec 								; initialise first time round.
.9c38					_VMCNext:
.9c38	c8		iny				iny 								; pre-increment
.9c39	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9c3b	f0 0c		beq $9c49			beq 	_VMCSuccess 				; successful.
.9c3d	20 5a 97	jsr $975a			jsr 	EncodeNumber 				; send it to the number-builder
.9c40	90 03		bcc $9c45			bcc 	_VMCFail 					; if failed, give up.
.9c42	18		clc				clc 								; next time round, countinue
.9c43	80 f3		bra $9c38			bra 	_VMCNext
.9c45					_VMCFail:
.9c45	68		pla				pla
.9c46					_VMCFail2:
.9c46	7a		ply				ply
.9c47	38		sec				sec
.9c48	60		rts				rts
.9c49					_VMCSuccess:
.9c49	a9 00		lda #$00			lda 	#0 							; construct final
.9c4b	20 5a 97	jsr $975a			jsr 	EncodeNumber
.9c4e	68		pla				pla
.9c4f	c9 2d		cmp #$2d			cmp 	#"-"
.9c51	d0 03		bne $9c56			bne 	_VMCNotNegative
.9c53	20 5e 9e	jsr $9e5e			jsr		NSMNegate
.9c56					_VMCNotNegative:
.9c56	7a		ply				ply
.9c57	18		clc				clc
.9c58	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c59					ChrUnary:
.9c59	fa		plx				plx 								; restore stack pos
.9c5a	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger			; get value
.9c5d	48		pha				pha
.9c5e	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.9c61	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c63	20 1b a8	jsr $a81b			jsr 	StringTempAllocate
.9c66	68		pla				pla 								; write number to it
.9c67	20 59 a8	jsr $a859			jsr 	StringTempWrite
.9c6a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c6b					SpcUnary:
.9c6b	fa		plx				plx 								; restore stack pos
.9c6c	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger			; get value
.9c6f	5a		phy				phy
.9c70	48		pha				pha 								; save count
.9c71	20 1b a8	jsr $a81b			jsr 	StringTempAllocate
.9c74	7a		ply				ply 								; to do count in Y
.9c75					_SpcLoop:
.9c75	c0 00		cpy #$00			cpy 	#0
.9c77	f0 08		beq $9c81			beq 	_SpcExit
.9c79	a9 20		lda #$20			lda 	#32
.9c7b	20 59 a8	jsr $a859			jsr 	StringTempWrite
.9c7e	88		dey				dey
.9c7f	80 f4		bra $9c75			bra 	_SPCLoop
.9c81					_SpcExit:
.9c81	7a		ply				ply
.9c82	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.9c85	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c86					Unary_Str:
.9c86	fa		plx				plx
.9c87	20 db 9d	jsr $9ddb			jsr 	EvaluateNumber  			; get number
.9c8a	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket 			; closing bracket
.9c8d	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c8f	20 a8 9c	jsr $9ca8			jsr 	ConvertNumberToString 		; do the conversion.
.9c92	a9 21		lda #$21			lda		#33 						; create buffer
.9c94	20 1b a8	jsr $a81b			jsr 	StringTempAllocate 			; allocate memory
.9c97	da		phx				phx
.9c98	a2 00		ldx #$00			ldx 	#0
.9c9a					_USCopy:
.9c9a	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9c9d	20 59 a8	jsr $a859			jsr 	StringTempWrite
.9ca0	e8		inx				inx
.9ca1	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9ca4	d0 f4		bne $9c9a			bne 	_USCopy
.9ca6	fa		plx				plx
.9ca7	60		rts				rts
.9ca8					ConvertNumberToString:
.9ca8	5a		phy				phy 								; save code position
.9ca9	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9cac	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9caf	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9cb2	10 0a		bpl $9cbe			bpl 	_CNTSNotNegative
.9cb4	29 7f		and #$7f			and 	#$7F 						; make +ve
.9cb6	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9cb9	a9 2d		lda #$2d			lda 	#"-"
.9cbb	20 24 9d	jsr $9d24			jsr 	WriteDecimalBuffer
.9cbe					_CNTSNotNegative:
.9cbe	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9cc1	f0 15		beq $9cd8			beq 	_CNTSNotFloat
.9cc3	e8		inx				inx 								; round up
.9cc4	a9 01		lda #$01			lda 	#1
.9cc6	20 b4 9e	jsr $9eb4			jsr 	NSMSetByte
.9cc9	ca		dex				dex
.9cca	bd 28 04	lda $0428,x			lda		NSExponent,x
.9ccd	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9cd0	a9 08		lda #$08			lda 	#NSTFloat
.9cd2	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9cd5	20 eb 93	jsr $93eb			jsr 	FloatAdd
.9cd8					_CNTSNotFloat:
.9cd8	20 06 9d	jsr $9d06			jsr 	MakePlusTwoString
.9cdb	20 d1 94	jsr $94d1			jsr 	FloatFractionalPart 		; get the fractional part
.9cde	20 95 95	jsr $9595			jsr 	NSNormalise					; normalise , exit if zero
.9ce1	f0 21		beq $9d04			beq 	_CNTSExit
.9ce3	a9 2e		lda #$2e			lda 	#"."
.9ce5	20 24 9d	jsr $9d24			jsr 	WriteDecimalBuffer 			; write decimal place
.9ce8					_CNTSDecimal:
.9ce8	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9ceb	30 17		bmi $9d04			bmi 	_CNTSExit
.9ced	e8		inx				inx 								; x 10.0
.9cee	a9 0a		lda #$0a			lda 	#10
.9cf0	20 b4 9e	jsr $9eb4			jsr 	NSMSetByte
.9cf3	a9 08		lda #$08			lda 	#NSTFloat
.9cf5	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9cf8	ca		dex				dex
.9cf9	20 5e 95	jsr $955e			jsr 	FloatMultiply
.9cfc	20 06 9d	jsr $9d06			jsr 	MakePlusTwoString
.9cff	20 d1 94	jsr $94d1			jsr 	FloatFractionalPart 		; get the fractional part
.9d02	80 e4		bra $9ce8			bra 	_CNTSDecimal 				; keep going.
.9d04					_CNTSExit:
.9d04	7a		ply				ply
.9d05	60		rts				rts
.9d06					MakePlusTwoString:
.9d06	da		phx				phx
.9d07	20 89 9e	jsr $9e89			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9d0a	e8		inx				inx 								; access it
.9d0b	e8		inx				inx
.9d0c	20 34 95	jsr $9534			jsr 	FloatIntegerPart 			; make it an integer
.9d0f	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9d11	20 16 93	jsr $9316			jsr 	ConvertInt32
.9d14	a2 00		ldx #$00			ldx	 	#0
.9d16					_MPTSCopy:
.9d16	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d19	20 24 9d	jsr $9d24			jsr 	WriteDecimalBuffer
.9d1c	e8		inx				inx
.9d1d	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d20	d0 f4		bne $9d16			bne 	_MPTSCopy
.9d22	fa		plx				plx
.9d23	60		rts				rts
.9d24					WriteDecimalBuffer:
.9d24	da		phx				phx
.9d25	ae 95 04	ldx $0495			ldx 	dbOffset
.9d28	9d 1c 06	sta $061c,x			sta 	DecimalBuffer,x
.9d2b	9e 1d 06	stz $061d,x			stz 	DecimalBuffer+1,x
.9d2e	ee 95 04	inc $0495			inc 	dbOffset
.9d31	fa		plx				plx
.9d32	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9d33					Unary_Left:
.9d33	fa		plx				plx
.9d34	18		clc				clc 								; only one parameter
.9d35	20 aa 9d	jsr $9daa			jsr 	SubstringInitial 			; set up.
.9d38	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9d3b	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d3e	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9d41	80 2c		bra $9d6f			bra 	SubstringMain
.9d43					Unary_Right:
.9d43	fa		plx				plx
.9d44	18		clc				clc 								; only one parameter
.9d45	20 aa 9d	jsr $9daa			jsr 	SubstringInitial 			; set up.
.9d48	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9d4b	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d4e	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9d51	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d54	b0 02		bcs $9d58			bcs 	_URNotUnderflow
.9d56	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d58					_URNotUnderFlow:
.9d58	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d5b	80 12		bra $9d6f			bra 	SubStringMain
.9d5d					Unary_Mid:
.9d5d	fa		plx				plx
.9d5e	38		sec				sec 								; two parameters
.9d5f	20 aa 9d	jsr $9daa			jsr 	SubstringInitial 			; set up.
.9d62	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d65	f0 05		beq $9d6c			beq 	_UMError
.9d67	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d6a	80 03		bra $9d6f			bra 	SubStringMain
.9d6c					_UMError:
.9d6c	4c 4b a0	jmp $a04b			jmp 	ArgumentError
.9d6f					SubStringMain:
.9d6f	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d72	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9d75	b0 2d		bcs $9da4			bcs 	_SSMNull 					; if so, return an empty string.
.9d77	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d7a	f0 28		beq $9da4			beq 	_SSMNull 					; return empty string.
.9d7c	18		clc				clc 								; add the offset +1 to the address and
.9d7d	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9d80	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9d83	85 36		sta $36				sta 	zTemp0
.9d85	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9d88	69 00		adc #$00			adc 	#0
.9d8a	85 37		sta $37				sta 	zTemp0+1
.9d8c					_SSMNoCarry:
.9d8c	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d8f	20 1b a8	jsr $a81b			jsr 	StringTempAllocate 			; allocate that many characters
.9d92	5a		phy				phy 								; save Y
.9d93	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d95					_SSMCopy:
.9d95	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d97	f0 09		beq $9da2			beq 	_SSMEString 				; no more to copy
.9d99	20 59 a8	jsr $a859			jsr 	StringTempWrite 			; and write it out.
.9d9c	c8		iny				iny
.9d9d	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9da0	d0 f3		bne $9d95			bne 	_SSMCopy
.9da2					_SSMEString:
.9da2	7a		ply				ply
.9da3					_SSMExit:
.9da3	60		rts				rts
.9da4					_SSMNull:
.9da4	a9 00		lda #$00			lda 	#0
.9da6	20 1b a8	jsr $a81b			jsr 	StringTempAllocate
.9da9	60		rts				rts
.9daa					SubstringInitial:
.9daa	da		phx				phx 								; save initial stack position
.9dab	08		php				php 								; save carry on stack indicating 2 parameters
.9dac	20 e6 9d	jsr $9de6			jsr 	EvaluateString 				; get a string
.9daf	5a		phy				phy 								; calculate length to exponent.
.9db0	a0 ff		ldy #$ff			ldy 	#$FF
.9db2					_SIFindLength:
.9db2	c8		iny				iny
.9db3	b1 36		lda ($36),y			lda 	(zTemp0),y
.9db5	d0 fb		bne $9db2			bne 	_SIFindLength
.9db7	98		tya				tya
.9db8	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9dbb	7a		ply				ply
.9dbc	e8		inx				inx
.9dbd	20 de 8d	jsr $8dde			jsr 	CheckComma 					; comma next
.9dc0	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; get next parameter
.9dc3	28		plp				plp 								; is it the last parameter ?
.9dc4	90 07		bcc $9dcd			bcc 	_SSIExit 					; if so, exit.
.9dc6	e8		inx				inx
.9dc7	20 de 8d	jsr $8dde			jsr 	CheckComma 					; comma next
.9dca	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; get last parameter
.9dcd					_SSIExit:
.9dcd	fa		plx				plx
.9dce	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket 			; check closing bracket
.9dd1	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9dd2					EvaluateValue:
.9dd2	48		pha				pha
.9dd3	20 9e 93	jsr $939e			jsr		EvaluateExpression 			; expression
.9dd6	20 bc 96	jsr $96bc			jsr 	Dereference					; derefernce it
.9dd9	68		pla				pla
.9dda	60		rts				rts
.9ddb					EvaluateNumber:
.9ddb	20 d2 9d	jsr $9dd2			jsr 	EvaluateValue 				; get a value
.9dde	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9de1	29 10		and #$10			and 	#NSBIsString
.9de3	d0 16		bne $9dfb			bne 	HelperTypeError
.9de5	60		rts				rts
.9de6					EvaluateString:
.9de6	20 d2 9d	jsr $9dd2			jsr 	EvaluateValue 				; get a value
.9de9	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9dec	29 10		and #$10			and 	#NSBIsString
.9dee	f0 0b		beq $9dfb			beq 	HelperTypeError
.9df0					CopyAddressToTemp0:
.9df0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9df3	85 36		sta $36				sta 	zTemp0
.9df5	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9df8	85 37		sta $37				sta 	zTemp0+1
.9dfa	60		rts				rts
.9dfb					HelperTypeError:
.9dfb	4c 46 a0	jmp $a046			jmp 	TypeError
.9dfe					EvaluateInteger:
.9dfe	20 db 9d	jsr $9ddb			jsr 	EvaluateNumber
.9e01	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9e04	d0 0a		bne $9e10			bne 	HelperValueError 			; if not, it's a float.
.9e06	60		rts				rts
.9e07					EvaluateUnsignedInteger:
.9e07	20 fe 9d	jsr $9dfe			jsr 	EvaluateInteger 			; check integer is +ve
.9e0a	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e0d	30 01		bmi $9e10			bmi 	HelperValueError
.9e0f	60		rts				rts
.9e10					HelperValueError:
.9e10	4c 4b a0	jmp $a04b			jmp 	ArgumentError
.9e13					Evaluate16BitInteger:
.9e13	20 07 9e	jsr $9e07			jsr	 	EvaluateUnsignedInteger		; get integer
.9e16	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e19	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e1c	d0 f2		bne $9e10			bne 	HelperValueError
.9e1e	60		rts				rts
.9e1f					Evaluate16BitIntegerSigned:
.9e1f	20 fe 9d	jsr $9dfe			jsr	 	EvaluateInteger				; get integer
.9e22	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e25	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e28	d0 e6		bne $9e10			bne 	HelperValueError
.9e2a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9e2d	10 03		bpl $9e32			bpl 	_EISNotSigned
.9e2f	20 67 9e	jsr $9e67			jsr 	NSMNegateMantissa
.9e32					_EISNotSigned:
.9e32	60		rts				rts
.9e33					Evaluate8BitInteger:
.9e33	20 07 9e	jsr $9e07			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9e36	d0 d8		bne $9e10			bne 	HelperValueError
.9e38	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9e3b	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e3e	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9e41	d0 cd		bne $9e10			bne 	HelperValueError
.9e43	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e46	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9e47					Multiply8x8:
.9e47	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9e48	85 36		sta $36			  	sta 	zTemp0
.9e4a	86 37		stx $37				stx 	zTemp0+1
.9e4c	a9 00		lda #$00			lda 	#0
.9e4e	a2 08		ldx #$08			ldx 	#8
.9e50					_M88Loop:
.9e50	90 03		bcc $9e55			bcc 	_M88NoAdd
.9e52	18		clc				clc
.9e53	65 37		adc $37				adc 	zTemp0+1
.9e55					_M88NoAdd:
.9e55	6a		ror a				ror 	a
.9e56	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9e58	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9e59	d0 f5		bne $9e50			bne 	_M88Loop
.9e5b	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9e5d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9e5e					NSMNegate:
.9e5e	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e61	49 80		eor #$80			eor 	#NSBIsNegative
.9e63	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9e66	60		rts				rts
.9e67					NSMNegateMantissa:
.9e67	38		sec				sec
.9e68	a9 00		lda #$00			lda 	#0
.9e6a	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9e6d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9e70	a9 00		lda #$00			lda 	#0
.9e72	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9e75	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9e78	a9 00		lda #$00			lda 	#0
.9e7a	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9e7d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9e80	a9 00		lda #$00			lda 	#0
.9e82	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9e85	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9e88	60		rts				rts
.9e89					NSMShiftUpTwo:
.9e89	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e8c	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9e8f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e92	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9e95	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9e98	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9e9b	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e9e	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9ea1	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9ea4	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9ea7	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9eaa	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9ead	60		rts				rts
.9eae					NSMSetZeroMantissaOnly:
.9eae	a9 00		lda #$00			lda 	#0
.9eb0	80 08		bra $9eba			bra 	NSMSetMantissa
.9eb2					NSMSetZero:
.9eb2	a9 00		lda #$00			lda 	#0
.9eb4					NSMSetByte:
.9eb4	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9eb7	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9eba					NSMSetMantissa:
.9eba	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9ebd	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9ec0	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9ec3	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9ec6	60		rts				rts
.9ec7					NSMShiftLeft:
.9ec7	18		clc				clc
.9ec8					NSMRotateLeft:
.9ec8	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9ecb	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9ece	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9ed1	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9ed4	60		rts				rts
.9ed5					NSMShiftRight:
.9ed5	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9ed8	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9edb	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9ede	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9ee1	60		rts				rts
.9ee2					NSMIsZero:
.9ee2	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9ee5	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9ee8	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9eeb	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9eee	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.ba83					TickHandler:
.ba83	5a		phy				phy 								; need to preserve Y
.ba84	20 29 ba	jsr $ba29			jsr 	SNDUpdate 					; update sound
.ba87	7a		ply				ply
.ba88	60		rts				rts
.062e					LastTick:
>062e							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9eef					Assemble_ora:
.9eef	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9ef2	01					.byte $01
.9ef3					Assemble_and:
.9ef3	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9ef6	21					.byte $21
.9ef7					Assemble_eor:
.9ef7	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9efa	41					.byte $41
.9efb					Assemble_adc:
.9efb	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9efe	61					.byte $61
.9eff					Assemble_sta:
.9eff	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9f02	81					.byte $81
.9f03					Assemble_lda:
.9f03	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9f06	a1					.byte $a1
.9f07					Assemble_cmp:
.9f07	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9f0a	c1					.byte $c1
.9f0b					Assemble_sbc:
.9f0b	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9f0e	e1					.byte $e1
.9f0f					Assemble_asl:
.9f0f	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f12	02					.byte $02
>9f13	75					.byte $75
.9f14					Assemble_rol:
.9f14	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f17	22					.byte $22
>9f18	75					.byte $75
.9f19					Assemble_lsr:
.9f19	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f1c	42					.byte $42
>9f1d	75					.byte $75
.9f1e					Assemble_ror:
.9f1e	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f21	62					.byte $62
>9f22	75					.byte $75
.9f23					Assemble_stx:
.9f23	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f26	82					.byte $82
>9f27	50					.byte $50
.9f28					Assemble_ldx:
.9f28	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f2b	a2					.byte $a2
>9f2c	d0					.byte $d0
.9f2d					Assemble_dec:
.9f2d	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f30	c2					.byte $c2
>9f31	55					.byte $55
.9f32					Assemble_inc:
.9f32	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f35	e2					.byte $e2
>9f36	55					.byte $55
.9f37					Assemble_stz:
.9f37	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f3a	60					.byte $60
>9f3b	44					.byte $44
.9f3c					Assemble_bit:
.9f3c	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f3f	20					.byte $20
>9f40	55					.byte $55
.9f41					Assemble_sty:
.9f41	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f44	80					.byte $80
>9f45	54					.byte $54
.9f46					Assemble_ldy:
.9f46	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f49	a0					.byte $a0
>9f4a	d5					.byte $d5
.9f4b					Assemble_cpy:
.9f4b	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f4e	c0					.byte $c0
>9f4f	d4					.byte $d4
.9f50					Assemble_cpx:
.9f50	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f53	e0					.byte $e0
>9f54	d0					.byte $d0
.9f55					Assemble_tsb:
.9f55	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f58	00					.byte $00
>9f59	50					.byte $50
.9f5a					Assemble_trb:
.9f5a	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f5d	10					.byte $10
>9f5e	50					.byte $50
.9f5f					Assemble_jsr:
.9f5f	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f62	14					.byte $14
>9f63	10					.byte $10
.9f64					Assemble_jmp:
.9f64	20 73 80	jsr $8073		jsr	AssembleGroup2
>9f67	40					.byte $40
>9f68	10					.byte $10
.9f69					Assemble_bpl:
.9f69	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f6c	10					.byte $10
.9f6d					Assemble_bmi:
.9f6d	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f70	30					.byte $30
.9f71					Assemble_bvc:
.9f71	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f74	50					.byte $50
.9f75					Assemble_bvs:
.9f75	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f78	70					.byte $70
.9f79					Assemble_bcc:
.9f79	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f7c	90					.byte $90
.9f7d					Assemble_bcs:
.9f7d	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f80	b0					.byte $b0
.9f81					Assemble_bne:
.9f81	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f84	d0					.byte $d0
.9f85					Assemble_beq:
.9f85	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f88	f0					.byte $f0
.9f89					Assemble_bra:
.9f89	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f8c	80					.byte $80
.9f8d					Assemble_brk:
.9f8d	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f90	00					.byte $00
.9f91					Assemble_php:
.9f91	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f94	08					.byte $08
.9f95					Assemble_clc:
.9f95	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f98	18					.byte $18
.9f99					Assemble_plp:
.9f99	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f9c	28					.byte $28
.9f9d					Assemble_sec:
.9f9d	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fa0	38					.byte $38
.9fa1					Assemble_rti:
.9fa1	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fa4	40					.byte $40
.9fa5					Assemble_pha:
.9fa5	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fa8	48					.byte $48
.9fa9					Assemble_cli:
.9fa9	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fac	58					.byte $58
.9fad					Assemble_phy:
.9fad	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fb0	5a					.byte $5a
.9fb1					Assemble_rts:
.9fb1	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fb4	60					.byte $60
.9fb5					Assemble_pla:
.9fb5	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fb8	68					.byte $68
.9fb9					Assemble_sei:
.9fb9	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fbc	78					.byte $78
.9fbd					Assemble_ply:
.9fbd	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fc0	7a					.byte $7a
.9fc1					Assemble_dey:
.9fc1	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fc4	88					.byte $88
.9fc5					Assemble_txa:
.9fc5	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fc8	8a					.byte $8a
.9fc9					Assemble_tya:
.9fc9	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fcc	98					.byte $98
.9fcd					Assemble_txs:
.9fcd	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fd0	9a					.byte $9a
.9fd1					Assemble_tay:
.9fd1	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fd4	a8					.byte $a8
.9fd5					Assemble_tax:
.9fd5	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fd8	aa					.byte $aa
.9fd9					Assemble_clv:
.9fd9	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fdc	b8					.byte $b8
.9fdd					Assemble_tsx:
.9fdd	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fe0	ba					.byte $ba
.9fe1					Assemble_iny:
.9fe1	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fe4	c8					.byte $c8
.9fe5					Assemble_dex:
.9fe5	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fe8	ca					.byte $ca
.9fe9					Assemble_cld:
.9fe9	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9fec	d8					.byte $d8
.9fed					Assemble_phx:
.9fed	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9ff0	da					.byte $da
.9ff1					Assemble_stp:
.9ff1	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9ff4	db					.byte $db
.9ff5					Assemble_inx:
.9ff5	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9ff8	e8					.byte $e8
.9ff9					Assemble_nop:
.9ff9	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9ffc	ea					.byte $ea
.9ffd					Assemble_sed:
.9ffd	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>a000	f8					.byte $f8
.a001					Assemble_plx:
.a001	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>a004	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.a005					DecimalScalarTable:
>a005	66 66 66 66				.dword $66666666 ; 0.1
>a009	de					.byte $de
>a00a	1f 85 eb 51				.dword $51eb851f ; 0.01
>a00e	db					.byte $db
>a00f	4c 37 89 41				.dword $4189374c ; 0.001
>a013	d8					.byte $d8
>a014	ac 8b db 68				.dword $68db8bac ; 0.0001
>a018	d4					.byte $d4
>a019	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>a01d	d1					.byte $d1
>a01e	83 de 1b 43				.dword $431bde83 ; 1e-06
>a022	ce					.byte $ce
>a023	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>a027	ca					.byte $ca
>a028	89 3b e6 55				.dword $55e63b89 ; 1e-08
>a02c	c7					.byte $c7
>a02d	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>a031	c4					.byte $c4
>a032	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>a036	c0					.byte $c0
>a037	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>a03b	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.a03c					SyntaxError:
.a03c	a9 02		lda #$02		lda	#2
.a03e	4c ef 8d	jmp $8def		jmp	ErrorHandler
.a041					RangeError:
.a041	a9 04		lda #$04		lda	#4
.a043	4c ef 8d	jmp $8def		jmp	ErrorHandler
.a046					TypeError:
.a046	a9 05		lda #$05		lda	#5
.a048	4c ef 8d	jmp $8def		jmp	ErrorHandler
.a04b					ArgumentError:
.a04b	a9 07		lda #$07		lda	#7
.a04d	4c ef 8d	jmp $8def		jmp	ErrorHandler
.a050					NotDoneError:
.a050	a9 0c		lda #$0c		lda	#12
.a052	4c ef 8d	jmp $8def		jmp	ErrorHandler
.a055					ErrorText:
>a055	42 72 65 61 6b 00			.text	"Break",0
>a05b	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a063	72 72 6f 72 00
>a068	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a070	20 62 79 20 7a 65 72 6f 00
>a079	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a081	61 6e 67 65 00
>a086	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a08e	6d 61 74 63 68 00
>a094	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a09c	65 6d 6f 72 79 00
>a0a2	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a0aa	61 72 67 75 6d 65 6e 74 00
>a0b3	53 74 6f 70 00				.text	"Stop",0
>a0b8	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a0c0	6f 6f 20 6c 6f 6e 67 00
>a0c8	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a0d0	6e 20 66 61 69 6c 65 64 00
>a0d9	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a0e1	61 74 61 00
>a0e5	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a0ed	65 6e 74 65 64 00
>a0f3	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a0fb	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a107	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a10f	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a11c	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a124	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a131	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a139	68 6f 75 74 20 57 68 69 6c 65 00
>a144	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a14c	68 6f 75 74 20 46 6f 72 00
>a155	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a15d	61 63 6b 20 66 75 6c 6c 00
>a166	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a16e	75 63 74 75 72 65 00
>a175	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a17d	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a18a	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a192	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a1a0	41 72 72 61 79 20 73 69			.text	"Array size",0
>a1a8	7a 65 00
>a1ab	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a1b3	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a1bb	42 75 69 6c 74 20 54 75			.text "Built Tuesday 22-Nov-2022. Build 3571."
>a1c3	65 73 64 61 79 20 32 32 2d 4e 6f 76 2d 32 30 32
>a1d3	32 2e 20 42 75 69 6c 64 20 33 35 37 31 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a1e1					RectangleCommand:
.a1e1	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a1e3	80 02		bra $a1e7			bra 	ShapeDrawCmd
.a1e5					CircleCommand:
.a1e5	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a1e7					ShapeDrawCmd:
.a1e7	20 75 a2	jsr $a275			jsr 	RunGraphicsCommand
.a1ea					ShapeDraw:
.a1ea	0d 30 06	ora $0630			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a1ed	4c 69 a2	jmp $a269			jmp 	ExecuteGraphicCommand	 	; and complete
.a1f0					SpriteCommand:
.a1f0	a2 00		ldx #$00			ldx 	#0
.a1f2	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; get image number.
.a1f5	5a		phy				phy
.a1f6	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a1f8	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a1fb	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a1fd	b0 0d		bcs $a20c			bcs 	_SCRange
.a1ff	a0 ff		ldy #$ff			ldy 	#255
.a201	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a204	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a206	7a		ply				ply
.a207	20 75 a2	jsr $a275			jsr 	RunGraphicsCommand
.a20a	80 5d		bra $a269			bra 	ExecuteGraphicCommand
.a20c					_SCRange:
.a20c	4c 41 a0	jmp $a041			jmp 	RangeError
.a20f					ImageCommand:
.a20f	a2 00		ldx #$00			ldx 	#0
.a211	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; get image number.
.a214	20 75 a2	jsr $a275			jsr 	RunGraphicsCommand
.a217					ImageRunDraw:
.a217	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a219	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a21c	ad 36 06	lda $0636			lda 	gxDrawScale
.a21f	0a		asl a				asl 	a
.a220	0a		asl a				asl 	a
.a221	0a		asl a				asl 	a
.a222	a8		tay				tay
.a223	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a225	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a228	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a22b	60		rts				rts
.a22c					TextCommand:
.a22c	a2 00		ldx #$00			ldx 	#0
.a22e	20 e6 9d	jsr $9de6			jsr 	EvaluateString 				; get text
.a231	20 75 a2	jsr $a275			jsr 	RunGraphicsCommand
.a234					TextRunDraw:
.a234	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a236	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a239	a0 00		ldy #$00			ldy 	#0
.a23b					_IRDLoop:
.a23b	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a23e	85 37		sta $37				sta 	zTemp0+1
.a240	ad 08 04	lda $0408			lda 	NSMantissa0
.a243	85 36		sta $36				sta 	zTemp0
.a245	b1 36		lda ($36),y			lda 	(zTemp0),y
.a247	f0 13		beq $a25c			beq 	_IRDExit
.a249	5a		phy				phy									; save string pos
.a24a	48		pha				pha 								; save char
.a24b	ad 36 06	lda $0636			lda 	gxDrawScale 				; get scale
.a24e	0a		asl a				asl 	a
.a24f	0a		asl a				asl 	a
.a250	0a		asl a				asl 	a
.a251	a8		tay				tay
.a252	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a254	fa		plx				plx 								; char to draw
.a255	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a258	7a		ply				ply 								; restore string pos
.a259	c8		iny				iny
.a25a	90 df		bcc $a23b			bcc 	_IRDLoop 					; go back if no error.
.a25c					_IRDExit:
.a25c	60		rts				rts
.a25d					PlotCommand:
.a25d	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a25f	20 75 a2	jsr $a275			jsr 	RunGraphicsCommand
.a262	80 05		bra $a269			bra 	ExecuteGraphicCommand
.a264					LineCommand:
.a264	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a266	20 75 a2	jsr $a275			jsr 	RunGraphicsCommand
.a269					ExecuteGraphicCommand:
.a269	0d 2f 06	ora $062f			ora 	gxCommandID 				; make a full command
.a26c	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw 				; draw it and exit
.a26f	b0 01		bcs $a272			bcs 	_EGCError
.a271	60		rts				rts
.a272					_EGCError:
.a272	4c 3c a0	jmp $a03c			jmp 	SyntaxError
.a275					RunGraphicsCommand:
.a275	8d 2f 06	sta $062f			sta 	gxCommandID					; save TODO graphics command.
.a278	68		pla				pla 								; pop handler address
.a279	fa		plx				plx
.a27a	1a		inc a				inc 	a
.a27b	d0 01		bne $a27e			bne 	_RGINoCarry
.a27d	e8		inx				inx
.a27e					_RGINoCarry:
.a27e	8d 34 06	sta $0634			sta 	GXHandler
.a281	8e 35 06	stx $0635			stx 	GXHandler+1
.a284					_RGICommandLoop:
.a284	b1 30		lda ($30),y			lda 	(codePtr),y
.a286	c8		iny				iny
.a287	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a289	f0 53		beq $a2de			beq 	_RGI_To
.a28b	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a28d	f0 55		beq $a2e4			beq 	_RGI_Here
.a28f	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a291	f0 3d		beq $a2d0			beq 	_RGI_Exit
.a293	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a295	f0 39		beq $a2d0			beq 	_RGI_Exit
.a297	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a299	f0 3e		beq $a2d9			beq 	_RGI_Frame
.a29b	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a29d	f0 33		beq $a2d2			beq 	_RGI_Solid
.a29f	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a2a1	f0 4b		beq $a2ee			beq 	_RGI_By
.a2a3	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a2a5	f0 17		beq $a2be			beq 	_RGI_Move2
.a2a7	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a2a9	f0 65		beq $a310			beq 	_RGI_Dim
.a2ab	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a2ad	f0 78		beq $a327			beq 	_RGI_Colour
.a2af	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a2b1	f0 74		beq $a327			beq 	_RGI_Colour
.a2b3	ae 2f 06	ldx $062f			ldx 	gxCommandID
.a2b6	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a2b8	d0 03		bne $a2bd			bne 	_RGI_Move 					; move
.a2ba	4c 51 a3	jmp $a351			jmp		_RGI_SpriteInstructions
.a2bd					_RGI_Move:
.a2bd	88		dey				dey 								; unpick get.
.a2be					_RGI_Move2:
.a2be	20 77 a3	jsr $a377			jsr 	GCGetCoordinatePair 		; move to here
.a2c1	20 9e a3	jsr $a39e			jsr 	GCCopyPairToStore 			; save
.a2c4	5a		phy				phy
.a2c5	20 94 a3	jsr $a394			jsr 	GCLoadAXY 					; load in
.a2c8	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a2ca	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a2cd	7a		ply				ply
.a2ce	80 b4		bra $a284			bra 	_RGICommandLoop 			; and go round
.a2d0					_RGI_Exit:
.a2d0	88		dey				dey 								; unpick : / EOL
.a2d1	60		rts				rts
.a2d2					_RGI_Solid:
.a2d2	a9 02		lda #$02			lda 	#2
.a2d4	8d 30 06	sta $0630			sta 	gxFillSolid
.a2d7	80 ab		bra $a284			bra 	_RGICommandLoop
.a2d9					_RGI_Frame:
.a2d9	9c 30 06	stz $0630			stz 	gxFillSolid
.a2dc	80 a6		bra $a284			bra 	_RGICommandLoop
.a2de					_RGI_To:
.a2de	20 77 a3	jsr $a377			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a2e1	20 9e a3	jsr $a39e			jsr 	GCCopyPairToStore
.a2e4					_RGI_Here:
.a2e4	5a		phy				phy
.a2e5	20 94 a3	jsr $a394			jsr 	GCLoadAXY 					; load it into AXY
.a2e8	20 4e a3	jsr $a34e			jsr 	_RGICallHandler 			; go do whatever it is.
.a2eb	7a		ply				ply
.a2ec	80 96		bra $a284			bra 	_RGICommandLoop 			; and go round
.a2ee					_RGI_By:
.a2ee	20 84 a3	jsr $a384			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a2f1	18		clc				clc
.a2f2	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a2f5	6d 31 06	adc $0631			adc 	gxxPos
.a2f8	8d 31 06	sta $0631			sta 	gxXPos
.a2fb	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a2fe	6d 32 06	adc $0632			adc 	gxxPos+1
.a301	8d 32 06	sta $0632			sta 	gxXPos+1
.a304	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a307	18		clc				clc
.a308	6d 33 06	adc $0633			adc 	gxYPos
.a30b	8d 33 06	sta $0633			sta 	gxYPos
.a30e	80 d4		bra $a2e4			bra 	_RGI_Here
.a310					_RGI_Dim:
.a310	a2 01		ldx #$01			ldx	 	#1
.a312	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger
.a315	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a318	c9 00		cmp #$00			cmp 	#0
.a31a	f0 2f		beq $a34b			beq 	_RGIRange
.a31c	c9 09		cmp #$09			cmp 	#8+1
.a31e	b0 2b		bcs $a34b			bcs		_RGIRange
.a320	3a		dec a				dec 	a
.a321	8d 36 06	sta $0636			sta 	gxDrawScale
.a324	4c 84 a2	jmp $a284			jmp 	_RGICommandLoop
.a327					_RGI_Colour:
.a327	a2 01		ldx #$01			ldx 	#1 							; colour
.a329	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger
.a32c	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a32e	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero
.a331	b1 30		lda ($30),y			lda 	(codePtr),y
.a333	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a335	d0 04		bne $a33b			bne 	_RGICDefaultMode
.a337	c8		iny				iny
.a338	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger
.a33b					_RGICDefaultMode:
.a33b	5a		phy				phy
.a33c	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a33e	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a341	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a344	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a347	7a		ply				ply
.a348	4c 84 a2	jmp $a284			jmp 	_RGICommandLoop 			; and go round
.a34b					_RGIRange:
.a34b	4c 41 a0	jmp $a041			jmp 	RangeError
.a34e					_RGICallHandler:
.a34e	6c 34 06	jmp ($0634)			jmp 	(GXHandler)
.a351					_RGI_SpriteInstructions:
.a351	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a353	f0 07		beq $a35c			beq 	_RGISpriteOff
.a355	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a357	f0 13		beq $a36c			beq 	_RGISetImage
.a359	4c bd a2	jmp $a2bd			jmp 	_RGI_Move
.a35c					_RGISpriteOff:
.a35c	5a		phy				phy
.a35d	a0 01		ldy #$01			ldy 	#1
.a35f	a2 00		ldx #$00			ldx 	#0
.a361					_RGIDoCommandLoop:
.a361	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a363	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a366	7a		ply				ply
.a367	b0 e2		bcs $a34b			bcs 	_RGIRange
.a369	4c 84 a2	jmp $a284			jmp 	_RGICommandLoop
.a36c					_RGISetImage:
.a36c	a2 01		ldx #$01			ldx 	#1
.a36e	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger
.a371	5a		phy				phy
.a372	aa		tax				tax
.a373	a0 00		ldy #$00			ldy 	#0
.a375	80 ea		bra $a361			bra 	_RGIDoCommandLoop
.a377					GCGetCoordinatePair:
.a377	a2 01		ldx #$01			ldx 	#1
.a379	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger
.a37c	20 de 8d	jsr $8dde			jsr 	CheckComma
.a37f	e8		inx				inx
.a380	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger
.a383	60		rts				rts
.a384					GCSignedCoordinatePair:
.a384	a2 01		ldx #$01			ldx 	#1
.a386	20 1f 9e	jsr $9e1f			jsr 	Evaluate16BitIntegerSigned
.a389	20 de 8d	jsr $8dde			jsr 	CheckComma
.a38c	e8		inx				inx
.a38d	20 1f 9e	jsr $9e1f			jsr 	Evaluate16BitIntegerSigned
.a390	60		rts				rts
.a391					_GCCPRange:
.a391	4c 41 a0	jmp $a041			jmp 	RangeError
.a394					GCLoadAXY:
.a394	ad 32 06	lda $0632			lda 	gxXPos+1
.a397	ae 31 06	ldx $0631			ldx 	gxXPos
.a39a	ac 33 06	ldy $0633			ldy 	gxYPos
.a39d	60		rts				rts
.a39e					GCCopyPairToStore:
.a39e	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a3a1	8d 31 06	sta $0631			sta 	gxXPos
.a3a4	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a3a7	8d 32 06	sta $0632			sta 	gxXPos+1
.a3aa	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a3ad	8d 33 06	sta $0633			sta 	gxYPos
.a3b0	60		rts				rts
.062f					gxCommandID:
>062f							.fill 	1
.0630					gxFillSolid:
>0630							.fill 	1
.0631					gxXPos:
>0631							.fill 	2
.0633					gxYPos:
>0633							.fill 	1
.0634					gxHandler:
>0634							.fill 	2
.0636					gxDrawScale:
>0636							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a3b1					BitmapCtrl:
.a3b1	b1 30		lda ($30),y			lda 	(codePtr),y
.a3b3	c8		iny				iny
.a3b4	a2 01		ldx #$01			ldx 	#1
.a3b6	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a3b8	f0 11		beq $a3cb			beq 	BitmapSwitch
.a3ba	ca		dex				dex
.a3bb	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a3bd	f0 0c		beq $a3cb			beq 	BitmapSwitch
.a3bf	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; get the colour
.a3c2	5a		phy				phy
.a3c3	aa		tax				tax
.a3c4	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a3c6	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a3c9	7a		ply				ply
.a3ca	60		rts				rts
.a3cb					BitmapSwitch:
.a3cb	5a		phy				phy
.a3cc	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a3ce	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a3d0	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a3d3	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a3d5	a0 00		ldy #$00			ldy 	#0
.a3d7	a2 ff		ldx #$ff			ldx 	#$FF
.a3d9	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a3dc	9c 30 06	stz $0630			stz 	gxFillSolid
.a3df	9c 31 06	stz $0631			stz 	gxXPos
.a3e2	9c 32 06	stz $0632			stz 	gxXPos+1
.a3e5	9c 33 06	stz $0633			stz 	gxYPos
.a3e8	9c 36 06	stz $0636			stz 	gxDrawScale
.a3eb	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a3ed	a2 00		ldx #$00			ldx 	#0
.a3ef	a0 00		ldy #$00			ldy 	#0
.a3f1	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a3f4	7a		ply				ply
.a3f5	60		rts				rts
.a3f6					SpritesCtrl:
.a3f6	b1 30		lda ($30),y			lda 	(codePtr),y
.a3f8	c8		iny				iny
.a3f9	a2 01		ldx #$01			ldx 	#1
.a3fb	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a3fd	f0 08		beq $a407			beq 	SpriteSwitch
.a3ff	ca		dex				dex
.a400	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a402	f0 03		beq $a407			beq 	SpriteSwitch
.a404	4c 3c a0	jmp $a03c			jmp 	SyntaxError
.a407					SpriteSwitch:
.a407	5a		phy				phy
.a408	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a40a	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a40c	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a40f	7a		ply				ply
.a410	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a411					GfxCommand:
.a411	a2 00		ldx #$00			ldx 	#0
.a413	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; command
.a416	20 de 8d	jsr $8dde			jsr 	CheckComma
.a419	e8		inx				inx
.a41a	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger 		; X
.a41d	20 de 8d	jsr $8dde			jsr 	CheckComma
.a420	e8		inx				inx
.a421	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; Y
.a424	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a427	4a		lsr a				lsr 	a
.a428	d0 16		bne $a440			bne 	_GfxError
.a42a	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a42d	b0 11		bcs $a440			bcs 	_GfxError 					; bit 7 should have been zero
.a42f	5a		phy				phy 								; save pos
.a430	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a433	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a436	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a439	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw
.a43c	b0 02		bcs $a440			bcs 	_GfxError
.a43e	7a		ply				ply 								; restore pos and exit.
.a43f	60		rts				rts
.a440					_GfxError:
.a440	4c 41 a0	jmp $a041			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a443					UnaryHit:
.a443	fa		plx				plx
.a444	a9 36		lda #$36			lda 	#zTemp0
.a446	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a449	20 de 8d	jsr $8dde			jsr 	CheckComma
.a44c	e8		inx				inx
.a44d	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a450	20 d6 8d	jsr $8dd6			jsr		CheckRightBracket
.a453	ca		dex				dex 								; fix back up again.
.a454	da		phx				phx 								; save X/Y
.a455	5a		phy				phy
.a456	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a459	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a45c	aa		tax				tax
.a45d	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a45f	20 68 ab	jsr $ab68			jsr 	GXGraphicDraw 				; calculate result
.a462	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a463	7a		ply				ply 								; restore XY
.a464	fa		plx				plx
.a465	20 b4 9e	jsr $9eb4			jsr 	NSMSetByte 					; return the hit result
.a468	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a469					PaletteCommand:
.a469	a2 00		ldx #$00			ldx 	#0
.a46b	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; colour
.a46e	20 de 8d	jsr $8dde			jsr 	CheckComma
.a471	e8		inx				inx
.a472	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger 		; r
.a475	20 de 8d	jsr $8dde			jsr 	CheckComma
.a478	e8		inx				inx
.a479	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; g
.a47c	20 de 8d	jsr $8dde			jsr 	CheckComma
.a47f	e8		inx				inx
.a480	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; b
.a483	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a486	85 36		sta $36				sta 	zTemp0
.a488	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a48a	85 37		sta $37				sta 	zTemp0+1
.a48c	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a48e	26 37		rol $37				rol	 	zTemp0+1
.a490	06 36		asl $36				asl 	zTemp0
.a492	26 37		rol $37				rol	 	zTemp0+1
.a494	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a496	85 01		sta $01				sta 	1
.a498	5a		phy				phy
.a499	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a49c	92 36		sta ($36)			sta 	(zTemp0)
.a49e	a0 01		ldy #$01			ldy 	#1
.a4a0	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a4a3	91 36		sta ($36),y			sta 	(zTemp0),y
.a4a5	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a4a8	c8		iny				iny
.a4a9	91 36		sta ($36),y			sta 	(zTemp0),y
.a4ab	7a		ply				ply
.a4ac	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a4ad					UnaryEvent:
.a4ad	fa		plx				plx
.a4ae	20 55 a5	jsr $a555			jsr 	TimerToStackX 				; timer in +0
.a4b1	e8		inx				inx  								; put reference into +1
.a4b2	20 78 98	jsr $9878			jsr 	EvaluateTerm
.a4b5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a4b8	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a4ba	d0 57		bne $a513			bne 	_UEType
.a4bc	e8		inx				inx 								; put the step in +2
.a4bd	20 de 8d	jsr $8dde			jsr 	CheckComma
.a4c0	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger
.a4c3	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.a4c6	ca		dex				dex
.a4c7	ca		dex				dex
.a4c8	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a4cb	85 36		sta $36				sta 	zTemp0
.a4cd	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a4d0	85 37		sta $37				sta 	zTemp0+1
.a4d2	5a		phy				phy
.a4d3	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a4d5	b1 36		lda ($36),y			lda 	(zTemp0),y
.a4d7	30 36		bmi $a50f			bmi 	_UEFalse 					; exit if signed.
.a4d9	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a4db	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a4de	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a4e0	c8		iny				iny
.a4e1	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a4e4	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4e6	c8		iny				iny
.a4e7	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a4ea	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4ec	90 21		bcc $a50f			bcc 	_UEFalse 					; no, return FALSE.
.a4ee	18		clc				clc
.a4ef	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a4f1	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a4f4	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a4f7	91 36		sta ($36),y			sta 	(zTemp0),y
.a4f9	c8		iny				iny
.a4fa	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a4fd	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a500	91 36		sta ($36),y			sta 	(zTemp0),y
.a502	c8		iny				iny
.a503	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a506	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a509	91 36		sta ($36),y			sta 	(zTemp0),y
.a50b	7a		ply				ply
.a50c	4c 5c 8e	jmp $8e5c			jmp 	ReturnTrue
.a50f					_UEFalse:
.a50f	7a		ply				ply 								; restore Y
.a510	4c 68 8e	jmp $8e68			jmp 	ReturnFalse 				; and return False
.a513					_UEType:
.a513	4c 46 a0	jmp $a046			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a516					UnaryJoyX:
.a516	18		clc				clc
.a517	80 01		bra $a51a			bra 	JoyMain
.a519					UnaryJoyY:
.a519	38		sec				sec
.a51a					JoyMain:
.a51a	fa		plx				plx 								; get pos
.a51b	08		php				php 								; save carry (set for Y)
.a51c	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a51f	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.a522	20 21 ab	jsr $ab21			jsr 	EXTReadController 			; read the controller.
.a525	28		plp				plp
.a526	90 02		bcc $a52a			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a528	4a		lsr a				lsr 	a
.a529	4a		lsr a				lsr 	a
.a52a					_JMNoShift:
.a52a	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a52b	b0 0a		bcs $a537			bcs 	_JMIsRight
.a52d	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a52e	b0 04		bcs $a534			bcs 	_JMIsLeft
.a530	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero 					; zero result
.a533	60		rts				rts
.a534					_JMIsLeft:
.a534	4c 5c 8e	jmp $8e5c			jmp 	ReturnTrue
.a537					_JMIsRight:
.a537	a9 01		lda #$01			lda 	#1
.a539	20 b4 9e	jsr $9eb4			jsr 	NSMSetByte
.a53c	60		rts				rts
.a53d					UnaryJoyB:
.a53d	fa		plx				plx 								; get pos
.a53e	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a541	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.a544	20 21 ab	jsr $ab21			jsr 	EXTReadController 			; read the controller.
.a547	4a		lsr a				lsr 	a
.a548	4a		lsr a				lsr 	a
.a549	4a		lsr a				lsr 	a
.a54a	4a		lsr a				lsr 	a
.a54b	29 01		and #$01			and 	#1
.a54d	20 b4 9e	jsr $9eb4			jsr 	NSMSetByte
.a550	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a551					UnaryTimer:
.a551	fa		plx				plx
.a552	20 d6 8d	jsr $8dd6			jsr 	CheckRightBracket
.a555					TimerToStackX:
.a555	20 b2 9e	jsr $9eb2			jsr 	NSMSetZero 					; zero result
.a558	64 01		stz $01				stz 	1 							; access I/O
.a55a	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a55d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a560	ad 5a d6	lda $d65a			lda 	$D65A
.a563	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a566	ad 5b d6	lda $d65b			lda 	$D65B
.a569	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a56c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a56d					MemoryDeleteLine:
.a56d	20 8c a5	jsr $a58c			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a570	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a572	a8		tay				tay
.a573					_MDDLLoop:
.a573	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a575	92 30		sta ($30)			sta 	(codePtr)
.a577	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a579	c5 3a		cmp $3a				cmp 	zTemp2
.a57b	d0 07		bne $a584			bne 	_MDLDLNext
.a57d	a5 31		lda $31				lda 	codePtr+1
.a57f	c5 3b		cmp $3b				cmp 	zTemp2+1
.a581	d0 01		bne $a584			bne 	_MDLDLNext
.a583					_MDDLExit:
.a583	60		rts				rts
.a584					_MDLDLNext:
.a584	e6 30		inc $30				inc 	codePtr						; next byte
.a586	d0 eb		bne $a573			bne 	_MDDLLoop
.a588	e6 31		inc $31				inc 	codePtr+1
.a58a	80 e7		bra $a573			bra 	_MDDLLoop
.a58c					IMemoryFindEnd:
.a58c	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a58e	85 3a		sta $3a				sta 	0+zTemp2
.a590	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a592	85 3b		sta $3b				sta 	1+zTemp2
.a594					_MDLFELoop:
.a594	b2 3a		lda ($3a)			lda 	(zTemp2)
.a596	f0 0b		beq $a5a3			beq 	_MDLFEExit
.a598	18		clc				clc
.a599	65 3a		adc $3a				adc 	zTemp2
.a59b	85 3a		sta $3a				sta 	zTemp2
.a59d	90 f5		bcc $a594			bcc 	_MDLFELoop
.a59f	e6 3b		inc $3b				inc 	zTemp2+1
.a5a1	80 f1		bra $a594			bra 	_MDLFELoop
.a5a3					_MDLFEExit:
.a5a3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a5a4					MemoryInsertLine:
.a5a4	08		php				php
.a5a5	20 8c a5	jsr $a58c			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a5a8	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a5aa	1a		inc a				inc 	a
.a5ab	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a5ad	b0 36		bcs $a5e5			bcs 	_MDLIError
.a5af	28		plp				plp
.a5b0	90 08		bcc $a5ba			bcc 	_MDLIFound
.a5b2	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a5b4	85 30		sta $30				sta 	codePtr
.a5b6	a5 3b		lda $3b				lda 	zTemp2+1
.a5b8	85 31		sta $31				sta 	codePtr+1
.a5ba					_MDLIFound:
.a5ba	ad a9 04	lda $04a9			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a5bd	a8		tay				tay
.a5be					_MDLIInsert:
.a5be	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a5c0	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a5c2	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a5c4	c5 3a		cmp $3a				cmp 	zTemp2
.a5c6	d0 06		bne $a5ce			bne 	_MDLINext
.a5c8	a5 31		lda $31				lda 	codePtr+1
.a5ca	c5 3b		cmp $3b				cmp 	zTemp2+1
.a5cc	f0 0a		beq $a5d8			beq 	_MDLIHaveSpace
.a5ce					_MDLINext:
.a5ce	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a5d0	d0 02		bne $a5d4			bne 	_MDLINoBorrow
.a5d2	c6 3b		dec $3b				dec 	zTemp2+1
.a5d4					_MDLINoBorrow:
.a5d4	c6 3a		dec $3a				dec 	zTemp2
.a5d6	80 e6		bra $a5be			bra 	_MDLIInsert
.a5d8					_MDLIHaveSpace:
.a5d8	ac a9 04	ldy $04a9			ldy 	tokenOffset 				; bytes to copy
.a5db	88		dey				dey 								; from offset-1 to 0
.a5dc					_MDLICopy:
.a5dc	b9 a9 04	lda $04a9,y			lda 	tokenOffset,y
.a5df	91 30		sta ($30),y			sta 	(codePtr),y
.a5e1	88		dey				dey
.a5e2	10 f8		bpl $a5dc			bpl 	_MDLICopy
.a5e4	60		rts				rts
.a5e5					_MDLIError:
.a5e5	a9 06		lda #$06		lda	#6
.a5e7	4c ef 8d	jmp $8def		jmp	ErrorHandler
.a5ea					MDLAppendLine:
.a5ea	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a5ec	85 36		sta $36				sta 	zTemp0
.a5ee	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5f0	85 38		sta $38				sta 	0+zTemp1
.a5f2	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5f4	85 39		sta $39				sta 	1+zTemp1
.a5f6	b2 38		lda ($38)			lda 	(zTemp1)
.a5f8	d0 0a		bne $a604			bne 	_MDLANoInitialise
.a5fa	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5fc	8d 37 06	sta $0637			sta 	0+AppendPointer
.a5ff	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a601	8d 38 06	sta $0638			sta 	1+AppendPointer
.a604					_MDLANoInitialise:
.a604	18		clc				clc
.a605	ad 37 06	lda $0637			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a608	85 38		sta $38				sta 	zTemp1
.a60a	72 36		adc ($36)			adc 	(zTemp0)
.a60c	8d 37 06	sta $0637			sta 	AppendPointer
.a60f	ad 38 06	lda $0638			lda 	AppendPointer+1
.a612	85 39		sta $39				sta 	zTemp1+1
.a614	69 00		adc #$00			adc 	#0
.a616	8d 38 06	sta $0638			sta 	AppendPointer+1
.a619	a0 00		ldy #$00			ldy 	#0
.a61b					_MDLACopy:
.a61b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a61d	91 38		sta ($38),y			sta 	(zTemp1),y
.a61f	c8		iny				iny
.a620	98		tya				tya
.a621	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a623	d0 f6		bne $a61b			bne 	_MDLACopy
.a625	a9 00		lda #$00			lda 	#0 							; end of program.
.a627	91 38		sta ($38),y			sta 	(zTemp1),y
.a629	60		rts				rts
.0637					AppendPointer:
>0637							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a62a					MemoryNew:
.a62a	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a62c	85 30		sta $30				sta 	codePtr
.a62e	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a630	85 31		sta $31				sta 	codePtr+1
.a632	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a634	92 30		sta ($30)			sta 	(codePtr)
.a636	60		rts				rts
.a637					MemoryInline:
.a637	98		tya				tya 								; put address into stack,x
.a638	18		clc				clc
.a639	65 30		adc $30				adc 	codePtr
.a63b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a63e	a5 31		lda $31				lda 	codePtr+1
.a640	69 00		adc #$00			adc 	#0
.a642	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a645	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a648	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a64b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a64c					MemorySearch:
.a64c	85 36		sta $36				sta 	zTemp0 						; save line number zTemp0
.a64e	86 37		stx $37				stx 	zTemp0+1
.a650	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a652	85 30		sta $30				sta 	codePtr
.a654	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a656	85 31		sta $31				sta 	codePtr+1
.a658					_MTAXLoop:
.a658	b2 30		lda ($30)			lda 	(codePtr)
.a65a	18		clc				clc
.a65b	f0 21		beq $a67e			beq 	_MTAXExit 					; reached end, exit with CC.
.a65d	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a65f	b1 30		lda ($30),y			lda 	(codePtr),y
.a661	38		sec				sec
.a662	e5 36		sbc $36				sbc 	zTemp0
.a664	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a666	c8		iny				iny 								; do the MSB
.a667	b1 30		lda ($30),y			lda 	(codePtr),y
.a669	e5 37		sbc $37				sbc 	zTemp0+1
.a66b	05 38		ora $38				ora 	zTemp1
.a66d	f0 0f		beq $a67e			beq 	_MTAXExit	 				; found
.a66f	b0 0d		bcs $a67e			bcs 	_MTAXExit 					; current < required exit
.a671	18		clc				clc
.a672	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.a674	65 30		adc $30				adc 	codePtr
.a676	85 30		sta $30				sta 	codePtr
.a678	90 02		bcc $a67c			bcc 	_CREExit
.a67a	e6 31		inc $31				inc 	codePtr+1
.a67c					_CREExit:
.a67c	80 da		bra $a658			bra 	_MTAXLoop
.a67e					_MTAXExit:
.a67e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a67f					UnaryPlaying:
.a67f	fa		plx				plx
.a680	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; get channel #
.a683	48		pha				pha
.a684	20 d6 8d	jsr $8dd6			jsr		CheckRightBracket
.a687	68		pla				pla
.a688	c9 04		cmp #$04			cmp 	#4
.a68a	b0 0c		bcs $a698			bcs 	_UPNotPlaying
.a68c	09 20		ora #$20			ora 	#$20 						; query playing ?
.a68e	20 f6 b9	jsr $b9f6			jsr 	SNDCommand
.a691	c9 00		cmp #$00			cmp 	#0
.a693	f0 03		beq $a698			beq 	_UPNotPlaying
.a695	4c 5c 8e	jmp $8e5c			jmp 	ReturnTrue
.a698					_UPNotPlaying:
.a698	4c 68 8e	jmp $8e68			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a69b					SoundCommand:
.a69b	b1 30		lda ($30),y			lda 	(codePtr),y
.a69d	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a69f	d0 09		bne $a6aa			bne 	_SNDMain
.a6a1	c8		iny				iny 								; skip OFF
.a6a2	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a6a4	5a		phy				phy
.a6a5	20 f6 b9	jsr $b9f6			jsr 	SNDCommand
.a6a8	7a		ply				ply
.a6a9	60		rts				rts
.a6aa					_SNDMain:
.a6aa	a2 00		ldx #$00			ldx 	#0
.a6ac	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; channel
.a6af	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a6b1	b0 50		bcs $a703			bcs 	_SndError
.a6b3	e8		inx				inx 								; do the rest in slot 1.
.a6b4	20 de 8d	jsr $8dde			jsr 	CheckComma
.a6b7	20 13 9e	jsr $9e13			jsr 	Evaluate16BitInteger 		; Pitch
.a6ba	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a6bd	c9 10		cmp #$10			cmp 	#16
.a6bf	b0 42		bcs $a703			bcs 	_SndError
.a6c1	8d 3a 06	sta $063a			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a6c4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a6c7	8d 39 06	sta $0639			sta 	SoundCommandBlock
.a6ca	20 de 8d	jsr $8dde			jsr 	CheckComma
.a6cd	20 33 9e	jsr $9e33			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a6d0	8d 3c 06	sta $063c			sta 	SoundCommandBlock+3
.a6d3	a9 0f		lda #$0f			lda 	#15
.a6d5	8d 3b 06	sta $063b			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a6d8	9c 3d 06	stz $063d			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a6db	9c 3e 06	stz $063e			stz 	SoundCommandBlock+5
.a6de	b1 30		lda ($30),y			lda 	(codePtr),y
.a6e0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a6e2	d0 10		bne $a6f4			bne 	_SNDPlay
.a6e4	c8		iny				iny
.a6e5	20 1f 9e	jsr $9e1f			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a6e8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a6eb	8d 3d 06	sta $063d			sta 	SoundCommandBlock+4
.a6ee	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a6f1	8d 3e 06	sta $063e			sta 	SoundCommandBlock+5
.a6f4					_SNDPlay:
.a6f4	5a		phy				phy
.a6f5	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a6f8	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a6fa	a2 39		ldx #$39			ldx 	#(SoundCommandBlock & $FF)
.a6fc	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a6fe	20 f6 b9	jsr $b9f6			jsr 	SNDCommand
.a701	7a		ply				ply
.a702	60		rts				rts
.a703					_SndError:
.a703	4c 41 a0	jmp $a041			jmp 	RangeError
.0639					SoundCommandBlock:
>0639							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a706					StackPushByte:
.a706	48		pha				pha 								; save byte
.a707	a5 34		lda $34				lda 	BasicStack
.a709	d0 09		bne $a714			bne 	_SPBNoBorrow
.a70b	c6 35		dec $35				dec 	BasicStack+1
.a70d	48		pha				pha
.a70e	a5 35		lda $35				lda 	BasicStack+1
.a710	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a712	90 06		bcc $a71a			bcc 	_SPBMemory
.a714					_SPBNoBorrow:
.a714	c6 34		dec $34				dec 	BasicStack
.a716	68		pla				pla 								; get back and write
.a717	92 34		sta ($34)			sta 	(BasicStack)
.a719	60		rts				rts
.a71a					_SPBMemory:
.a71a	a9 12		lda #$12		lda	#18
.a71c	4c ef 8d	jmp $8def		jmp	ErrorHandler
.a71f					StackPopByte:
.a71f	b2 34		lda ($34)			lda 	(BasicStack)
.a721	e6 34		inc $34				inc 	BasicStack
.a723	d0 02		bne $a727			bne 	_SPBNoCarry
.a725	e6 35		inc $35				inc 	BasicStack+1
.a727					_SPBNoCarry:
.a727	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a728					StackOpen:
.a728	48		pha				pha 								; save frame byte
.a729	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a72b	0a		asl a				asl 	a 							; claim twice this for storage
.a72c	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a72e	38		sec				sec 								; so basically subtracting from
.a72f	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a731	85 34		sta $34				sta 	basicStack
.a733	b0 08		bcs $a73d			bcs 	_SONoBorrow
.a735	c6 35		dec $35				dec 	basicStack+1
.a737	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a739	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a73b	90 04		bcc $a741			bcc 	_SOMemory
.a73d					_SONoBorrow:
.a73d	68		pla				pla 								; get marker back and write at TOS
.a73e	92 34		sta ($34)			sta 	(basicStack)
.a740	60		rts				rts
.a741					_SOMemory:
.a741	a9 12		lda #$12		lda	#18
.a743	4c ef 8d	jmp $8def		jmp	ErrorHandler
.a746					StackClose:
.a746	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a748	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a74a	0a		asl a				asl 	a 							; claim twice this.
.a74b	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a74d	85 34		sta $34				sta 	basicStack
.a74f	90 02		bcc $a753			bcc 	_SCExit
.a751	e6 35		inc $35				inc 	basicStack+1
.a753					_SCExit:
.a753	60		rts				rts
.a754					StackCheckFrame:
.a754	48		pha				pha
.a755					_StackRemoveLocals:
.a755	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a757	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a759	b0 05		bcs $a760			bcs 	_SCNoLocal
.a75b	20 f3 88	jsr $88f3			jsr 	LocalPopValue
.a75e	80 f5		bra $a755			bra 	_StackRemoveLocals
.a760					_SCNoLocal:
.a760	68		pla				pla
.a761	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a763	29 f0		and #$f0			and 	#$F0 						; check type bits
.a765	d0 01		bne $a768			bne 	_SCFError 					; different, we have structures mixed up
.a767	60		rts				rts
.a768					_SCFError:
.a768	8a		txa				txa 								; report error X
.a769	4c ef 8d	jmp $8def			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a76c					STKSaveCodePosition:
.a76c	5a		phy				phy
.a76d	98		tya				tya 								; save Y
.a76e	a0 05		ldy #$05			ldy 	#5
.a770	91 34		sta ($34),y			sta 	(basicStack),y
.a772	88		dey				dey 								; save Code Pointer
.a773					_STKSaveLoop:
.a773	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a776	91 34		sta ($34),y			sta 	(basicStack),y
.a778	88		dey				dey
.a779	d0 f8		bne $a773			bne 	_STKSaveLoop
.a77b	7a		ply				ply
.a77c	60		rts				rts
.a77d					STKLoadCodePosition:
.a77d	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a77f					_STKLoadLoop:
.a77f	b1 34		lda ($34),y			lda 	(basicStack),y
.a781	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a784	c8		iny				iny
.a785	c0 05		cpy #$05			cpy 	#5
.a787	d0 f6		bne $a77f			bne 	_STKLoadLoop
.a789	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a78b	a8		tay				tay
.a78c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a78d					StackReset:
.a78d	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a78f	85 34		sta $34				sta 	0+basicStack
.a791	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a793	85 35		sta $35				sta 	1+basicStack
.a795	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a797	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a799	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a79a					StringConcrete:
.a79a	5a		phy				phy 								; save position on stack
.a79b	20 7b 9a	jsr $9a7b			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a79e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a7a1	85 38		sta $38				sta 	zTemp1
.a7a3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a7a6	85 39		sta $39				sta 	zTemp1+1
.a7a8	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a7aa					_SALength:
.a7aa	c8		iny				iny
.a7ab	b1 38		lda ($38),y			lda 	(zTemp1),y
.a7ad	d0 fb		bne $a7aa			bne 	_SALength
.a7af	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a7b1	b0 3f		bcs $a7f2			bcs 	_SALengthError
.a7b3	98		tya				tya 				 				; length of the new string
.a7b4	18		clc				clc
.a7b5	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a7b7	90 02		bcc $a7bb			bcc 	_SAHaveLength
.a7b9	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a7bb					_SAHaveLength:
.a7bb	48		pha				pha 								; save length.
.a7bc	38		sec				sec
.a7bd	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a7bf	6d 8e 04	adc $048e			adc 	StringMemory
.a7c2	8d 8e 04	sta $048e			sta 	StringMemory
.a7c5	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a7c7	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a7ca	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a7cc	6d 8f 04	adc $048f			adc 	StringMemory+1
.a7cf	8d 8f 04	sta $048f			sta 	StringMemory+1
.a7d2	85 3b		sta $3b				sta 	zTemp2+1
.a7d4	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a7d7	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a7d8	38		sec				sec
.a7d9	e9 03		sbc #$03			sbc 	#3
.a7db	92 3a		sta ($3a)			sta 	(zTemp2)
.a7dd	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a7df	a0 01		ldy #$01			ldy 	#1
.a7e1	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a7e3					_SACopyNewString:
.a7e3	a0 00		ldy #$00			ldy 	#0
.a7e5					_SACopyNSLoop:
.a7e5	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a7e7	c8		iny				iny 								; write two on in string storage
.a7e8	c8		iny				iny
.a7e9	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a7eb	88		dey				dey 								; this makes it one one.
.a7ec	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a7ee	d0 f5		bne $a7e5			bne 	_SACopyNSLoop
.a7f0	7a		ply				ply
.a7f1	60		rts				rts
.a7f2					_SALengthError:
.a7f2	a9 09		lda #$09		lda	#9
.a7f4	4c ef 8d	jmp $8def		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a7f7					StringSystemInitialise:
.a7f7	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a7f9	8d 8e 04	sta $048e			sta 	0+StringMemory
.a7fc	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a7fe	8d 8f 04	sta $048f			sta 	1+StringMemory
.a801	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a804	60		rts				rts
.a805					StringSpaceInitialise:
.a805	20 7b 9a	jsr $9a7b			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a808	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a80a	8d 90 04	sta $0490			sta 	StringInitialised
.a80d	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a810	8d 91 04	sta $0491			sta 	StringTempPointer
.a813	ad 8f 04	lda $048f			lda 	StringMemory+1
.a816	3a		dec a				dec 	a
.a817	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a81a	60		rts				rts
.a81b					StringTempAllocate:
.a81b	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a81d	b0 35		bcs $a854			bcs 	_STALength
.a81f	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a822	30 05		bmi $a829			bmi 	_STAAllocate
.a824	48		pha				pha 								; save value to subtract.
.a825	20 05 a8	jsr $a805			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a828	68		pla				pla 								; restore it
.a829					_STAAllocate:
.a829	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a82b	18		clc				clc  								; deliberate allows one more
.a82c	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a82f	8d 91 04	sta $0491			sta 	StringTempPointer
.a832	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a835	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a837	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a83a	69 ff		adc #$ff			adc 	#$FF
.a83c	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a83f	85 3d		sta $3d				sta 	zsTemp+1
.a841	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a844	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a847	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a84a	a9 10		lda #$10			lda 	#NSTString
.a84c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a84f	a9 00		lda #$00			lda 	#0 							; clear the target string
.a851	92 3c		sta ($3c)			sta 	(zsTemp)
.a853	60		rts				rts
.a854					_STALength:
.a854	a9 09		lda #$09		lda	#9
.a856	4c ef 8d	jmp $8def		jmp	ErrorHandler
.a859					StringTempWrite:
.a859	48		pha				pha
.a85a	92 3c		sta ($3c)			sta 	(zsTemp)
.a85c	e6 3c		inc $3c				inc 	zsTemp
.a85e	d0 02		bne $a862			bne 	_STWNoCarry
.a860	e6 3d		inc $3d				inc 	zsTemp+1
.a862					_STWNoCarry:
.a862	a9 00		lda #$00			lda 	#0
.a864	92 3c		sta ($3c)			sta 	(zsTemp)
.a866	68		pla				pla
.a867	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a868					EXTPrintCharacter:
.a868	48		pha				pha
.a869	da		phx				phx
.a86a	5a		phy				phy
.a86b	a6 01		ldx $01				ldx 	1
.a86d	da		phx				phx
.a86e	ac 40 06	ldy $0640			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a871	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a873	30 48		bmi $a8bd			bmi 	_EXPCColour
.a875	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a877	90 4d		bcc $a8c6			bcc 	_EXPCControl
.a879	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a87b	86 01		stx $01				stx 	1
.a87d	91 40		sta ($40),y			sta 	(EXTAddress),y
.a87f	e6 01		inc $01				inc 	1 							; select colour memory
.a881	ad 41 06	lda $0641			lda 	EXTTextColour
.a884	91 40		sta ($40),y			sta 	(EXTAddress),y
.a886	c8		iny				iny 								; advance horizontal position
.a887	8c 40 06	sty $0640			sty 	EXTColumn
.a88a	cc 42 06	cpy $0642			cpy 	EXTScreenWidth 				; reached RHS ?
.a88d	90 66		bcc $a8f5			bcc 	_EXPCExit 					; no, then exit.
.a88f					_EXPCCRLF:
.a88f	ee 3f 06	inc $063f			inc 	EXTRow  					; bump row
.a892	9c 40 06	stz $0640			stz 	EXTColumn 					; back to column 0
.a895	ad 3f 06	lda $063f			lda 	EXTRow 						; check if reached the bottom ?
.a898	cd 43 06	cmp $0643			cmp 	EXTScreenHeight 			; if so, then scroll.
.a89b	f0 18		beq $a8b5			beq 	_EXPCScroll
.a89d	18		clc				clc 								; add width to address.
.a89e	a5 40		lda $40				lda 	EXTAddress
.a8a0	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a8a3	85 40		sta $40				sta 	EXTAddress
.a8a5	90 4e		bcc $a8f5			bcc 	_EXPCExit
.a8a7	e6 41		inc $41				inc 	EXTAddress+1
.a8a9	80 4a		bra $a8f5			bra 	_EXPCExit
.a8ab					_EXPCLeft:
.a8ab	ce 40 06	dec $0640			dec 	EXTColumn
.a8ae	10 45		bpl $a8f5			bpl 	_EXPCExit
.a8b0					_EXPCBegin:
.a8b0	9c 40 06	stz $0640			stz 	EXTColumn
.a8b3	80 40		bra $a8f5			bra 	_EXPCExit
.a8b5					_EXPCScroll:
.a8b5	ce 3f 06	dec $063f			dec 	EXTRow 						; the height-1 th line.
.a8b8	20 82 a9	jsr $a982			jsr 	EXTScreenScroll 			; scroll the screen
.a8bb	80 38		bra $a8f5			bra 	_EXPCExit
.a8bd					_EXPCColour:
.a8bd	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a8bf	b0 34		bcs $a8f5			bcs 	_EXPCExit
.a8c1	20 62 a9	jsr $a962			jsr 	_EXPCHandleColour
.a8c4	80 2f		bra $a8f5			bra 	_EXPCExit
.a8c6					_EXPCControl:
.a8c6	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a8c8	b0 2b		bcs $a8f5			bcs 	_EXPCExit
.a8ca	0a		asl a				asl 	a 							; double into X
.a8cb	aa		tax				tax
.a8cc	7c 40 a9	jmp ($a940,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a8cf					_EXPCUp:
.a8cf	ad 3f 06	lda $063f			lda 	EXTRow 						; already at top ?
.a8d2	f0 21		beq $a8f5			beq 	_EXPCExit
.a8d4	ce 3f 06	dec $063f			dec 	EXTRow 						; up one in position/address
.a8d7	38		sec				sec
.a8d8	a5 40		lda $40				lda 	EXTAddress
.a8da	ed 42 06	sbc $0642			sbc 	EXTScreenWidth
.a8dd	85 40		sta $40				sta 	EXTAddress
.a8df	b0 14		bcs $a8f5			bcs 	_EXPCExit
.a8e1	c6 41		dec $41				dec 	EXTAddress+1
.a8e3	80 10		bra $a8f5			bra 	_EXPCExit
.a8e5					_EXPCRight:
.a8e5	c8		iny				iny
.a8e6	8c 40 06	sty $0640			sty 	EXTColumn
.a8e9	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.a8ec	d0 07		bne $a8f5			bne 	_EXPCExit
.a8ee					_EXPCEnd:
.a8ee	ad 42 06	lda $0642			lda 	EXTScreenWidth
.a8f1	3a		dec a				dec 	a
.a8f2	8d 40 06	sta $0640			sta 	EXTColumn
.a8f5					_EXPCExit:
.a8f5	20 d7 a9	jsr $a9d7			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a8f8	68		pla				pla
.a8f9	85 01		sta $01				sta 	1
.a8fb	7a		ply				ply
.a8fc	fa		plx				plx
.a8fd	68		pla				pla
.a8fe	60		rts				rts
.a8ff					_EXPCClearScreen:
.a8ff	20 94 a9	jsr $a994			jsr		EXTClearScreenCode
.a902	80 f1		bra $a8f5			bra 	_EXPCExit
.a904					_EXPCDown:
.a904	ad 43 06	lda $0643			lda 	EXTScreenHeight 			; at the bottom
.a907	3a		dec a				dec 	a
.a908	cd 3f 06	cmp $063f			cmp 	EXTRow
.a90b	f0 e8		beq $a8f5			beq 	_EXPCExit
.a90d	ee 3f 06	inc $063f			inc 	EXTRow 						; down one in position/address
.a910	18		clc				clc
.a911	a5 40		lda $40				lda 	EXTAddress
.a913	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a916	85 40		sta $40				sta 	EXTAddress
.a918	90 db		bcc $a8f5			bcc 	_EXPCExit
.a91a	e6 41		inc $41				inc 	EXTAddress+1
.a91c	80 d7		bra $a8f5			bra 	_EXPCExit
.a91e					_EXPCTab:
.a91e	ad 40 06	lda $0640			lda 	EXTColumn 					; next tab stop
.a921	29 f8		and #$f8			and 	#$F8
.a923	18		clc				clc
.a924	69 08		adc #$08			adc 	#8
.a926	8d 40 06	sta $0640			sta 	EXTColumn
.a929	cd 42 06	cmp $0642			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a92c	90 c7		bcc $a8f5			bcc 	_EXPCExit
.a92e	80 be		bra $a8ee			bra 	_EXPCEnd
.a930					_EXPCBackSpace:
.a930	88		dey				dey
.a931	30 c2		bmi $a8f5			bmi 	_EXPCExit
.a933	ce 40 06	dec $0640			dec 	EXTColumn
.a936	a9 02		lda #$02			lda 	#2
.a938	85 01		sta $01				sta 	1
.a93a	a9 20		lda #$20			lda 	#32
.a93c	91 40		sta ($40),y			sta 	(EXTAddress),y
.a93e	80 b5		bra $a8f5			bra 	_EXPCExit
.a940					_EXPCActionTable:
>a940	f5 a8						.word 	_EXPCExit 					; 00
>a942	b0 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a944	ab a8						.word 	_EXPCLeft 					; 02 B Left
>a946	f5 a8						.word 	_EXPCExit 					; 03 <Break>
>a948	f5 a8						.word 	_EXPCExit 					; 04
>a94a	ee a8						.word 	_EXPCEnd 					; 05 E End of Line
>a94c	e5 a8						.word 	_EXPCRight 					; 06 F Right
>a94e	f5 a8						.word 	_EXPCExit 					; 07
>a950	30 a9						.word 	_EXPCBackspace 				; 08 H Backspace
>a952	1e a9						.word 	_EXPCTab 					; 09 I Tab
>a954	f5 a8						.word 	_EXPCExit 					; 0A
>a956	f5 a8						.word 	_EXPCExit 					; 0B
>a958	ff a8						.word 	_EXPCClearScreen			; 0C L CLS
>a95a	8f a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a95c	04 a9						.word 	_EXPCDown 					; 0E N Down
>a95e	f5 a8						.word 	_EXPCExit 					; 0F
>a960	cf a8						.word 	_EXPCUp 					; 10 P Up
.a962					_EXPCHandleColour
.a962	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a964	b0 16		bcs $a97c			bcs 	_EXPCBackground
.a966	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a967	0a		asl a				asl 	a
.a968	0a		asl a				asl 	a
.a969	0a		asl a				asl 	a
.a96a	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a96c					_EXPCUpdate:
.a96c	48		pha				pha 								; save new colour
.a96d	8a		txa				txa 								; get mask
.a96e	2d 41 06	and $0641			and 	EXTTextColour 				; mask out old.
.a971	8d 41 06	sta $0641			sta 	EXTTextColour
.a974	68		pla				pla 								; or in new colour
.a975	0d 41 06	ora $0641			ora 	EXTTextColour
.a978	8d 41 06	sta $0641			sta 	EXTTextColour
.a97b	60		rts				rts
.a97c					_EXPCBackground:
.a97c	29 0f		and #$0f			and 	#$0F 						; get the colour
.a97e	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a980	80 ea		bra $a96c			bra 	_EXPCUpdate
.a982					EXTScreenScroll:
.a982	a9 02		lda #$02			lda 	#2 							; select text page
.a984	85 01		sta $01				sta 	1
.a986	a9 20		lda #$20			lda		#32 						; fill with space
.a988	20 97 aa	jsr $aa97			jsr 	EXTScrollFill
.a98b	e6 01		inc $01				inc 	1 							; select colour page
.a98d	ad 41 06	lda $0641			lda 	EXTTextColour
.a990	20 97 aa	jsr $aa97			jsr 	EXTScrollFill
.a993	60		rts				rts
.a994					EXTClearScreenCode:
.a994	a9 02		lda #$02			lda 	#2 							; select text page
.a996	85 01		sta $01				sta 	1
.a998	a9 20		lda #$20			lda		#32 						; fill with space
.a99a	20 a7 a9	jsr $a9a7			jsr 	_EXTCSFill
.a99d	e6 01		inc $01				inc 	1 							; select colour page
.a99f	ad 41 06	lda $0641			lda 	EXTTextColour
.a9a2	20 a7 a9	jsr $a9a7			jsr 	_EXTCSFill
.a9a5	80 22		bra $a9c9			bra 	EXTHomeCursor
.a9a7					_EXTCSFill:
.a9a7	aa		tax				tax
.a9a8	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a9aa	85 40		sta $40				sta 	EXTAddress
.a9ac	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9ae	85 41		sta $41				sta 	EXTAddress+1
.a9b0					_EXTCSFill1:
.a9b0	a0 00		ldy #$00			ldy 	#0
.a9b2	8a		txa				txa
.a9b3					_EXTCSFill2:
.a9b3	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9b5	c8		iny				iny
.a9b6	d0 fb		bne $a9b3			bne 	_EXTCSFill2
.a9b8	e6 41		inc $41				inc 	EXTAddress+1
.a9ba	a5 41		lda $41				lda 	EXTAddress+1
.a9bc	c9 d2		cmp #$d2			cmp 	#$D2
.a9be	d0 f0		bne $a9b0			bne 	_EXTCSFill1
.a9c0	8a		txa				txa
.a9c1					_EXTCSFill3:
.a9c1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9c3	c8		iny				iny
.a9c4	c0 c0		cpy #$c0			cpy 	#$C0
.a9c6	d0 f9		bne $a9c1			bne 	_EXTCSFill3
.a9c8	60		rts				rts
.a9c9					EXTHomeCursor:
.a9c9	9c 3f 06	stz $063f			stz 	EXTRow 						; reset row & column
.a9cc	9c 40 06	stz $0640			stz 	EXTColumn
.a9cf	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a9d1	85 40		sta $40				sta 	EXTAddress
.a9d3	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9d5	85 41		sta $41				sta 	EXTAddress+1
.a9d7					EXTSetHardwareCursor:
.a9d7	64 01		stz $01				stz 	1 							; I/O Page zero
.a9d9	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a9db	8d 10 d0	sta $d010			sta 	$D010
.a9de	a9 b1		lda #$b1			lda 	#$B1
.a9e0	8d 12 d0	sta $d012			sta 	$D012
.a9e3	ad 40 06	lda $0640			lda 	EXTColumn
.a9e6	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a9e9	9c 15 d0	stz $d015			stz 	$D015
.a9ec	ad 3f 06	lda $063f			lda 	EXTRow
.a9ef	8d 16 d0	sta $d016			sta 	$D016
.a9f2	9c 17 d0	stz $d017			stz 	$D017
.a9f5	60		rts				rts
.a9f6					EXTInputLine:
.a9f6	48		pha				pha
.a9f7	da		phx				phx
.a9f8	5a		phy				phy
.a9f9	a5 01		lda $01				lda 	1 							; save I/O page
.a9fb	48		pha				pha
.a9fc					_EILLoop:
.a9fc	20 fe aa	jsr $aafe			jsr 	ExtInputSingleCharacter
.a9ff	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.aa01	f0 40		beq $aa43			beq 	_EILExit
.aa03	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.aa05	f0 1c		beq $aa23			beq 	_EILBackspace
.aa07	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.aa09	90 12		bcc $aa1d			bcc 	_EILPrintLoop
.aa0b	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.aa0d	b0 0e		bcs $aa1d			bcs 	_EILPrintLoop
.aa0f	48		pha				pha 								; save character
.aa10	a9 02		lda #$02			lda 	#2  						; insert a space
.aa12	85 01		sta $01				sta 	1
.aa14	20 85 aa	jsr $aa85			jsr 	EXTILInsert 				; insert in text screen
.aa17	e6 01		inc $01				inc 	1
.aa19	20 85 aa	jsr $aa85			jsr 	EXTILInsert 				; insert in colour screen
.aa1c	68		pla				pla 								; get character back.
.aa1d					_EILPrintLoop:
.aa1d	20 68 a8	jsr $a868			jsr 	ExtPrintCharacter
.aa20	80 da		bra $a9fc			bra 	_EILLoop
.aa22	60		rts				rts
.aa23					_EILBackspace:
.aa23	ad 40 06	lda $0640			lda 	EXTColumn					; can we backspace ?
.aa26	f0 d4		beq $a9fc			beq 	_EILLoop
.aa28	a9 02		lda #$02			lda 	#2 							; move cursor left
.aa2a	20 68 a8	jsr $a868			jsr 	EXTPrintCharacter
.aa2d	a9 02		lda #$02			lda 	#2 							; text block
.aa2f	85 01		sta $01				sta 	1
.aa31	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.aa33	20 70 aa	jsr $aa70			jsr 	EXTILDelete
.aa36	e6 01		inc $01				inc 	1 							; colour block
.aa38	ac 40 06	ldy $0640			ldy 	EXTColumn 					; get attribute of last character
.aa3b	88		dey				dey
.aa3c	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa3e	20 70 aa	jsr $aa70			jsr 	EXTILDelete 				; backspace attribute
.aa41	80 b9		bra $a9fc			bra 	_EILLoop 					; and go round.
.aa43					_EILExit:
.aa43	a9 02		lda #$02			lda 	#2 							; switch to page 2
.aa45	85 01		sta $01				sta 	1
.aa47	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa49					_EILScrapeLine:
.aa49	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa4b	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa4e	c8		iny				iny
.aa4f	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aa52	d0 f5		bne $aa49			bne 	_EILScrapeLine
.aa54					_EILTrimSpaces:
.aa54	88		dey				dey
.aa55	f0 08		beq $aa5f			beq 	_EILEndTrim
.aa57	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y
.aa5a	c9 20		cmp #$20			cmp 	#' '
.aa5c	f0 f6		beq $aa54			beq 	_EILTrimSpaces
.aa5e	c8		iny				iny 								; trim after non space character.
.aa5f					_EILEndTrim:
.aa5f	a9 00		lda #$00			lda 	#0 							; trim here.
.aa61	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa64	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa66	20 68 a8	jsr $a868			jsr 	ExtPrintCharacter
.aa69	68		pla				pla 								; reset I/O page
.aa6a	85 01		sta $01				sta 	1
.aa6c	7a		ply				ply
.aa6d	fa		plx				plx
.aa6e	68		pla				pla
.aa6f	60		rts				rts
.aa70					EXTILDelete:
.aa70	48		pha				pha 								; save the new character
.aa71	ac 40 06	ldy $0640			ldy 	EXTColumn 					; start copying from here.
.aa74					_EXTDLoop:
.aa74	c8		iny				iny 								; copy one byte down.
.aa75	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa77	88		dey				dey
.aa78	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa7a	c8		iny				iny 								; do till end of line.
.aa7b	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aa7e	90 f4		bcc $aa74			bcc 	_EXTDLoop
.aa80	88		dey				dey 	 							; write in last slot.
.aa81	68		pla				pla
.aa82	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa84	60		rts				rts
.aa85					EXTILInsert:
.aa85	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; end position
.aa88					_EXTILoop:
.aa88	88		dey				dey 								; back one
.aa89	cc 40 06	cpy $0640			cpy 	EXTColumn 					; exit if reached insert point.
.aa8c	f0 08		beq $aa96			beq 	_EXTIExit
.aa8e	88		dey				dey 								; copy one byte up.
.aa8f	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa91	c8		iny				iny
.aa92	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa94	80 f2		bra $aa88			bra 	_EXTILoop
.aa96					_EXTIExit:
.aa96	60		rts				rts
.aa97					EXTScrollFill:
.aa97	aa		tax				tax									; save value to fill with
.aa98	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa9a	48		pha				pha
.aa9b	a5 37		lda $37				lda 	zTemp0+1
.aa9d	48		pha				pha
.aa9e	a5 38		lda $38				lda 	zTemp1
.aaa0	48		pha				pha
.aaa1	a5 39		lda $39				lda 	zTemp1+1
.aaa3	48		pha				pha
.aaa4	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aaa6	85 37		sta $37				sta 	zTemp0+1
.aaa8	85 39		sta $39				sta 	zTemp1+1
.aaaa	64 36		stz $36				stz 	zTemp0
.aaac	ad 42 06	lda $0642			lda 	EXTScreenWidth
.aaaf	85 38		sta $38				sta 	zTemp1
.aab1	a0 00		ldy #$00			ldy 	#0
.aab3					_EXSFCopy1:
.aab3	b1 38		lda ($38),y			lda 	(zTemp1),y
.aab5	91 36		sta ($36),y			sta 	(zTemp0),y
.aab7	c8		iny				iny
.aab8	d0 f9		bne $aab3			bne 	_EXSFCopy1
.aaba	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aabc	e6 39		inc $39				inc 	zTemp1+1
.aabe	a5 39		lda $39				lda 	zTemp1+1
.aac0	c9 d3		cmp #$d3			cmp 	#$D3
.aac2	d0 ef		bne $aab3			bne 	_EXSFCopy1
.aac4	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; blank the bottom line.
.aac7	8a		txa				txa
.aac8					_EXSFFill1:
.aac8	88		dey				dey
.aac9	91 40		sta ($40),y			sta 	(EXTAddress),y
.aacb	c0 00		cpy #$00			cpy 	#0
.aacd	10 f9		bpl $aac8			bpl 	_EXSFFill1
.aacf	68		pla				pla
.aad0	85 39		sta $39				sta 	zTemp1+1
.aad2	68		pla				pla
.aad3	85 38		sta $38				sta 	zTemp1
.aad5	68		pla				pla
.aad6	85 37		sta $37				sta 	zTemp0+1
.aad8	68		pla				pla
.aad9	85 36		sta $36				sta 	zTemp0
.aadb	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063f					EXTRow:
>063f							.fill 	1
.0640					EXTColumn:
>0640							.fill 	1
.0641					EXTTextColour:
>0641							.fill 	1
.0642					EXTScreenWidth:
>0642							.fill 	1
.0643					EXTScreenHeight:
>0643							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aadc					EXTInitialise:
.aadc	64 01		stz $01				stz 	1 							; Access I/O
.aade	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aae1	9c 08 d0	stz $d008			stz 	$D008
.aae4	9c 09 d0	stz $d009			stz 	$D009
.aae7	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aae9	8d 58 d6	sta $d658			sta 	$D658
.aaec	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.aaee	8d 41 06	sta $0641			sta 	EXTTextColour
.aaf1	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aaf3	8d 42 06	sta $0642			sta 	EXTScreenWidth
.aaf6	a9 3c		lda #$3c			lda 	#60
.aaf8	8d 43 06	sta $0643			sta 	EXTScreenHeight
.aafb	64 01		stz $01				stz 	1
.aafd	60		rts				rts
.aafe					EXTInputSingleCharacter:
.aafe	da		phx				phx
.aaff	5a		phy				phy
.ab00					_EISCWait:
.ab00	64 01		stz $01				stz 	1 							; access I/O Page 0
.ab02	38		sec				sec 								; calculate timer - LastTick
.ab03	ad 59 d6	lda $d659			lda 	$D659
.ab06	aa		tax				tax 								; saving timer in X
.ab07	ed 2e 06	sbc $062e			sbc 	LastTick
.ab0a	c9 03		cmp #$03			cmp 	#3
.ab0c	90 06		bcc $ab14			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.ab0e	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.ab11	20 83 ba	jsr $ba83			jsr 	TickHandler 				; go do the code.
.ab14					_NoFireTick:
.ab14	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.ab17	c9 00		cmp #$00			cmp 	#0
.ab19	f0 e5		beq $ab00			beq 	_EISCWait
.ab1b	7a		ply				ply
.ab1c	fa		plx				plx
.ab1d	60		rts				rts
.ab1e					EXTBreakCheck:
.ab1e	4c e1 ff	jmp $ffe1			jmp		$FFE1
.ab21					EXTReadController:
.ab21	da		phx				phx
.ab22	a2 00		ldx #$00			ldx 	#0
.ab24	a9 05		lda #$05			lda 	#(($2D) >> 3)
.ab26	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab29	29 20		and #$20			and 	#($01 << (($2D) & 7))
.ab2b	f0 04		beq $ab31			beq 	_NoSet1
.ab2d	8a		txa				txa
.ab2e	09 01		ora #$01			ora 	#1
.ab30	aa		tax				tax
.ab31					_NoSet1:
.ab31	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab33	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab36	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab38	f0 04		beq $ab3e			beq 	_NoSet1
.ab3a	8a		txa				txa
.ab3b	09 02		ora #$02			ora 	#2
.ab3d	aa		tax				tax
.ab3e					_NoSet1:
.ab3e	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab40	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab43	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab45	f0 04		beq $ab4b			beq 	_NoSet1
.ab47	8a		txa				txa
.ab48	09 04		ora #$04			ora 	#4
.ab4a	aa		tax				tax
.ab4b					_NoSet1:
.ab4b	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab4d	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab50	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab52	f0 04		beq $ab58			beq 	_NoSet1
.ab54	8a		txa				txa
.ab55	09 08		ora #$08			ora 	#8
.ab57	aa		tax				tax
.ab58					_NoSet1:
.ab58	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab5a	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab5d	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab5f	f0 04		beq $ab65			beq 	_NoSet1
.ab61	8a		txa				txa
.ab62	09 10		ora #$10			ora 	#16
.ab64	aa		tax				tax
.ab65					_NoSet1:
.ab65	8a		txa				txa
.ab66	fa		plx				plx
.ab67	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ba89					GRVectorTable:
>ba89	63 ad					.word	GXInitialise             ; $00 Initialise
>ba8b	7d ad					.word	GXControlBitmap          ; $01 BitmapCtl
>ba8d	c5 ad					.word	GXControlSprite          ; $02 SpriteCtl
>ba8f	15 ad					.word	GXClearBitmap            ; $03 Clear
>ba91	54 af					.word	GXSetColourMode          ; $04 Colour
>ba93	1c b1					.word	GXFontHandler            ; $05 DrawFont
>ba95	64 b1					.word	GXSpriteHandler          ; $06 DrawSprite
>ba97	d0 b1					.word	GXSelect                 ; $07 SpriteUse
>ba99	f9 b1					.word	GXSelectImage            ; $08 SpriteImage
>ba9b	80 b3					.word	GXCollide                ; $09 SpriteCollide
>ba9d	c7 ab					.word	GRUndefined              ; $0a
>ba9f	c7 ab					.word	GRUndefined              ; $0b
>baa1	c7 ab					.word	GRUndefined              ; $0c
>baa3	c7 ab					.word	GRUndefined              ; $0d
>baa5	c7 ab					.word	GRUndefined              ; $0e
>baa7	c7 ab					.word	GRUndefined              ; $0f
>baa9	c7 ab					.word	GRUndefined              ; $10
>baab	c7 ab					.word	GRUndefined              ; $11
>baad	c7 ab					.word	GRUndefined              ; $12
>baaf	c7 ab					.word	GRUndefined              ; $13
>bab1	c7 ab					.word	GRUndefined              ; $14
>bab3	c7 ab					.word	GRUndefined              ; $15
>bab5	c7 ab					.word	GRUndefined              ; $16
>bab7	c7 ab					.word	GRUndefined              ; $17
>bab9	c7 ab					.word	GRUndefined              ; $18
>babb	c7 ab					.word	GRUndefined              ; $19
>babd	c7 ab					.word	GRUndefined              ; $1a
>babf	c7 ab					.word	GRUndefined              ; $1b
>bac1	c7 ab					.word	GRUndefined              ; $1c
>bac3	c7 ab					.word	GRUndefined              ; $1d
>bac5	c7 ab					.word	GRUndefined              ; $1e
>bac7	c7 ab					.word	GRUndefined              ; $1f
>bac9	c5 ab					.word	GXMove                   ; $20 Move
>bacb	22 ae					.word	GXLine                   ; $21 Line
>bacd	9d af					.word	GXFrameRectangle         ; $22 FrameRect
>bacf	9a af					.word	GXFillRectangle          ; $23 FillRect
>bad1	cc ab					.word	GXFrameCircle            ; $24 FrameCircle
>bad3	c8 ab					.word	GXFillCircle             ; $25 FillCircle
>bad5	c7 ab					.word	GRUndefined              ; $26
>bad7	c7 ab					.word	GRUndefined              ; $27
>bad9	82 af					.word	GXPlotPoint              ; $28 Plot
>badb	8f b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5fa					gxPixelBuffer = numberBuffer
.0644					gxCurrentX:
>0644							.fill 	2
.0646					gxCurrentY:
>0646							.fill 	2
.0648					gxLastX:
>0648							.fill 	2
.064a					gxLastY:
>064a							.fill 	2
.064c					gxX0:
>064c							.fill 	2
.064e					gxY0:
>064e							.fill 	2
.0650					gxX1:
>0650							.fill 	2
.0652					gxY1:
>0652							.fill 	2
.0654					gxSpritesOn:
>0654							.fill 	1
.0655					gxBitmapsOn:
>0655							.fill 	1
.0656					gxBasePage:
>0656							.fill 	1
.0657					gxSpritePage:
>0657							.fill 	1
.0658					gxHeight:
>0658							.fill 	1
.0659					gxMode:
>0659							.fill 	1
.065a					gxColour:
>065a							.fill 	1
.065b					gxEORValue:
>065b							.fill 	1
.065c					gxANDValue:
>065c							.fill 	1
.065d					gxOriginalLUTValue:
>065d							.fill 	1
.065e					gsOffset:
>065e							.fill 	1
.065f					GSCurrentSpriteID:
>065f							.fill 	1
.0660					GSCurrentSpriteAddr:
>0660							.fill 	2
.0662					GXSpriteOffsetBase:
>0662							.fill 	2
.0664					GXSpriteLow:
>0664							.fill 	64
.06a4					GXSpriteHigh:
>06a4							.fill 	64
.ab68					GXGraphicDraw:
.ab68	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab6a	b0 06		bcs $ab72			bcs 	_GDCoordinate
.ab6c	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab6e	84 37		sty $37				sty 	gxzTemp0+1
.ab70	80 4b		bra $abbd			bra 	_GDExecuteA 				; and execute
.ab72					_GDCoordinate:
.ab72	48		pha				pha 								; save AXY
.ab73	da		phx				phx
.ab74	5a		phy				phy
.ab75	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab77					_GDCopy1:
.ab77	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.ab7a	9d 48 06	sta $0648,x			sta 	gxLastX,x
.ab7d	ca		dex				dex
.ab7e	10 f7		bpl $ab77			bpl 	_GDCopy1
.ab80	68		pla				pla 								; update Y
.ab81	8d 46 06	sta $0646			sta 	gxCurrentY
.ab84	9c 47 06	stz $0647			stz 	gxCurrentY+1
.ab87	68		pla				pla
.ab88	8d 44 06	sta $0644			sta 	gxCurrentX
.ab8b	68		pla				pla 								; get A (command+X.1) back
.ab8c	48		pha				pha
.ab8d	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.ab8f	8d 45 06	sta $0645			sta 	gxCurrentX+1
.ab92	68		pla				pla 								; get command back
.ab93	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.ab95	48		pha				pha 								; push back.
.ab96	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.ab98	f0 17		beq $abb1			beq 	_GDCopyToWorkArea
.ab9a	ad 45 06	lda $0645			lda 	gxCurrentX+1 				; X < 256 X okay
.ab9d	f0 07		beq $aba6			beq 	_GDCheckY
.ab9f	ad 44 06	lda $0644			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aba2	c9 40		cmp #$40			cmp 	#64
.aba4	b0 08		bcs $abae			bcs 	_GDError1
.aba6					_GDCheckY:
.aba6	ad 46 06	lda $0646			lda 	gxCurrentY 					; check Y < Height.
.aba9	cd 58 06	cmp $0658			cmp 	gxHeight
.abac	90 03		bcc $abb1			bcc 	_GDCopyToWorkArea
.abae					_GDError1:
.abae	68		pla				pla
.abaf					_GDError2:
.abaf	38		sec				sec
.abb0	60		rts				rts
.abb1					_GDCopyToWorkArea:
.abb1	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abb3					_GDCopy2:
.abb3	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.abb6	9d 4c 06	sta $064c,x			sta 	gxX0,x
.abb9	ca		dex				dex
.abba	10 f7		bpl $abb3			bpl 	_GDCopy2
.abbc	68		pla				pla 								; get command
.abbd					_GDExecuteA:
.abbd	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abbf	b0 ee		bcs $abaf			bcs 	_GDError2
.abc1	aa		tax				tax
.abc2	7c 89 ba	jmp ($ba89,x)			jmp 	(GRVectorTable,x)
.abc5					GXMove:
.abc5	18		clc				clc
.abc6	60		rts				rts
.abc7					GRUndefined:
>abc7	db						.byte 	$DB 						; causes a break in the emulator
.abc8					GXFillCircle:
.abc8	a9 ff		lda #$ff			lda 	#255
.abca	80 02		bra $abce			bra 	GXCircle
.abcc					GXFrameCircle:
.abcc	a9 00		lda #$00			lda 	#0
.abce					GXCircle:
.abce	8d e7 06	sta $06e7			sta 	gxIsFillMode					; save Fill flag
.abd1	ad 55 06	lda $0655			lda 	gxBitmapsOn
.abd4	f0 26		beq $abfc			beq 	_GXCFail
.abd6	20 27 b4	jsr $b427			jsr 	GXSortXY 					; topleft/bottomright
.abd9	20 ff b2	jsr $b2ff			jsr 	GXOpenBitmap 				; start drawing
.abdc	20 ce ac	jsr $acce			jsr 	GXCircleSetup 				; set up for drawing
.abdf	9c e8 06	stz $06e8			stz 	gxYChanged
.abe2					_GXCircleDraw:
.abe2	ad e5 06	lda $06e5			lda 	gXCentre					; while x <= y
.abe5	cd e6 06	cmp $06e6			cmp 	gYCentre
.abe8	90 0a		bcc $abf4			bcc 	_GXCircleContinue
.abea	d0 03		bne $abef			bne 	_GXNoLast
.abec	20 01 ac	jsr $ac01			jsr 	GXPlot1
.abef					_GXNoLast:
.abef	20 07 b3	jsr $b307			jsr 	GXCloseBitmap 				; close the bitmap
.abf2	18		clc				clc
.abf3	60		rts				rts
.abf4					_GXCircleContinue:
.abf4	20 fe ab	jsr $abfe			jsr 	GXPlot2 					; draw it
.abf7	20 7b ac	jsr $ac7b			jsr 	GXCircleMove 				; adjust the coordinates
.abfa	80 e6		bra $abe2			bra 	_GXCircleDraw
.abfc					_GXCFail:
.abfc	38		sec				sec
.abfd	60		rts				rts
.abfe					GXPlot2:
.abfe	20 01 ac	jsr $ac01			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac01					GXPlot1:
.ac01	ad e6 06	lda $06e6			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac04	f0 03		beq $ac09			beq 	_GXPlot1Only
.ac06	20 25 ac	jsr $ac25			jsr 	GXPlot0 						; plot and negate
.ac09					_GXPlot1Only:
.ac09	20 25 ac	jsr $ac25			jsr 	GXPlot0 						; twice, undoing negation
.ac0c	ad e5 06	lda $06e5			lda 	gXCentre 						; swap X and Y
.ac0f	ae e6 06	ldx $06e6			ldx	 	gYCentre
.ac12	8d e6 06	sta $06e6			sta 	gYCentre
.ac15	8e e5 06	stx $06e5			stx 	gXCentre
.ac18	ad e8 06	lda $06e8			lda 	gxYChanged 						; toggle Y Changed flag
.ac1b	a9 ff		lda #$ff			lda 	#$FF
.ac1d	8d e8 06	sta $06e8			sta 	gxYChanged
.ac20	60		rts				rts
.ac21	20 25 ac	jsr $ac25			jsr 	GXPlot0 						; do once
.ac24	60		rts				rts
.ac25	ad e7 06	lda $06e7	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac28	f0 05		beq $ac2f			beq 	_GXPlot0Always
.ac2a	ad e8 06	lda $06e8			lda 	gxYChanged						; fill mode, only draw if changed.
.ac2d	f0 2d		beq $ac5c			beq 	GXPlot0Exit
.ac2f					_GXPlot0Always:
.ac2f	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac31	ad e6 06	lda $06e6			lda 	gYCentre
.ac34	20 5d ac	jsr $ac5d			jsr 	GXSubCopy
.ac37	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac39	ad e5 06	lda $06e5			lda 	gXCentre
.ac3c	20 5d ac	jsr $ac5d			jsr 	GXSubCopy
.ac3f	48		pha				pha 									; save last offset X
.ac40	20 0f b3	jsr $b30f			jsr 	GXPositionCalc 					; calculate position/offset.
.ac43	68		pla				pla
.ac44	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac45	85 36		sta $36				sta 	gxzTemp0
.ac47	64 37		stz $37				stz 	gxzTemp0+1
.ac49	26 37		rol $37				rol 	gxzTemp0+1
.ac4b	ad e7 06	lda $06e7			lda 	gxIsFillMode
.ac4e	69 80		adc #$80			adc 	#128
.ac50	20 ed af	jsr $afed			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac53	38		sec				sec 									; GY = -GY
.ac54	a9 00		lda #$00			lda 	#0
.ac56	ed e6 06	sbc $06e6			sbc 	gYCentre
.ac59	8d e6 06	sta $06e6			sta 	gYCentre
.ac5c					GXPlot0Exit:
.ac5c	60		rts				rts
.ac5d					GXSubCopy:
.ac5d	85 36		sta $36				sta 	gxzTemp0
.ac5f	64 37		stz $37				stz 	gxzTemp0+1
.ac61	29 80		and #$80			and 	#$80
.ac63	f0 02		beq $ac67			beq 	_GXNoSx
.ac65	c6 37		dec $37				dec 	gxzTemp0+1
.ac67					_GXNoSx:
.ac67	38		sec				sec
.ac68	bd 50 06	lda $0650,x			lda 	gXX1,x
.ac6b	e5 36		sbc $36				sbc 	gxzTemp0
.ac6d	9d 4c 06	sta $064c,x			sta 	gXX0,x
.ac70	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ac73	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac75	9d 4d 06	sta $064d,x			sta 	gXX0+1,x
.ac78	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ac7a	60		rts				rts
.ac7b					GXCircleMove:
.ac7b	9c e8 06	stz $06e8			stz 	gxYChanged 					; clear Y changed flag
.ac7e	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.ac80	10 0d		bpl $ac8f			bpl 	_GXEMPositive
.ac82	ee e5 06	inc $06e5			inc 	gXCentre 					; X++
.ac85	ad e5 06	lda $06e5			lda 	gXCentre
.ac88	20 ae ac	jsr $acae			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ac8b	a9 06		lda #$06			lda 	#6  						; and add 6
.ac8d	80 15		bra $aca4			bra 	_GXEMAddD
.ac8f					_GXEMPositive:
.ac8f	ee e5 06	inc $06e5			inc 	gXCentre					; X++
.ac92	ce e6 06	dec $06e6			dec 	gyCentre 					; Y--
.ac95	38		sec				sec 								; calculate X-Y
.ac96	ad e5 06	lda $06e5			lda 	gXCentre
.ac99	ed e6 06	sbc $06e6			sbc 	gYCentre
.ac9c	20 ae ac	jsr $acae			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ac9f	a9 0a		lda #$0a			lda 	#10  						; and add 10
.aca1	ce e8 06	dec $06e8			dec 	gxYChanged
.aca4					_GXEMAddD:
.aca4	18		clc				clc
.aca5	65 38		adc $38				adc 	gxzTemp1
.aca7	85 38		sta $38				sta 	gxzTemp1
.aca9	90 02		bcc $acad			bcc 	_GXEMNoCarry
.acab	e6 39		inc $39				inc 	gxzTemp1+1
.acad					_GXEMNoCarry:
.acad	60		rts				rts
.acae					_GXAdd4TimesToD:
.acae	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acb0	29 80		and #$80			and 	#$80
.acb2	f0 02		beq $acb6			beq 	_GXA4Unsigned
.acb4	a9 ff		lda #$ff			lda 	#$FF
.acb6					_GXA4Unsigned:
.acb6	85 37		sta $37				sta 	gxzTemp0+1
.acb8	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acba	26 37		rol $37				rol 	gxzTemp0+1
.acbc	06 36		asl $36				asl 	gxzTemp0
.acbe	26 37		rol $37				rol 	gxzTemp0+1
.acc0	18		clc				clc 								; add
.acc1	a5 36		lda $36				lda		gxzTemp0
.acc3	65 38		adc $38				adc 	gxzTemp1
.acc5	85 38		sta $38				sta 	gxzTemp1
.acc7	a5 37		lda $37				lda		gxzTemp0+1
.acc9	65 39		adc $39				adc 	gxzTemp1+1
.accb	85 39		sta $39				sta 	gxzTemp1+1
.accd	60		rts				rts
.acce					GXCircleSetup:
.acce	38		sec				sec
.accf	ad 52 06	lda $0652			lda 	gxY1
.acd2	ed 4e 06	sbc $064e			sbc 	gxY0
.acd5	4a		lsr a				lsr 	a
.acd6	8d e4 06	sta $06e4			sta 	gxRadius
.acd9	a2 00		ldx #$00			ldx 	#0
.acdb	20 fd ac	jsr $acfd			jsr 	_GXCalculateCentre
.acde	a2 02		ldx #$02			ldx 	#2
.ace0	20 fd ac	jsr $acfd			jsr 	_GXCalculateCentre
.ace3	9c e5 06	stz $06e5			stz 	gXCentre
.ace6	ad e4 06	lda $06e4			lda 	gxRadius
.ace9	8d e6 06	sta $06e6			sta 	gYCentre
.acec	0a		asl a				asl 	a 							; R x 2
.aced	85 36		sta $36				sta 	gxzTemp0
.acef	38		sec				sec
.acf0	a9 03		lda #$03			lda 	#3
.acf2	e5 36		sbc $36				sbc 	gxzTemp0
.acf4	85 38		sta $38				sta 	gxzTemp1
.acf6	a9 00		lda #$00			lda 	#0
.acf8	e9 00		sbc #$00			sbc 	#0
.acfa	85 39		sta $39				sta 	gxzTemp1+1
.acfc	60		rts				rts
.acfd					_GXCalculateCentre:
.acfd	38		sec				sec
.acfe	bd 50 06	lda $0650,x			lda 	gxX1,x
.ad01	7d 4c 06	adc $064c,x			adc 	gXX0,x
.ad04	9d 50 06	sta $0650,x			sta 	gXX1,x
.ad07	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ad0a	7d 4d 06	adc $064d,x			adc 	gXX0+1,x
.ad0d	4a		lsr a				lsr 	a
.ad0e	9d 51 06	sta $0651,x			sta 	gXX1+1,x
.ad11	7e 50 06	ror $0650,x			ror 	gXX1,x
.ad14	60		rts				rts
.06e4					gxRadius:
>06e4							.fill 	1
.06e5					gXCentre:
>06e5							.fill 	1
.06e6					gYCentre:
>06e6							.fill 	1
.06e7					gxIsFillMode:
>06e7							.fill 	1
.06e8					gxYChanged:
>06e8							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad15					GXClearBitmap:
.ad15	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP running.
.ad18	f0 24		beq $ad3e			beq 	_GXCBFail
.ad1a	20 ff b2	jsr $b2ff			jsr 	GXOpenBitmap 				; start access
.ad1d	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad1f	ad 58 06	lda $0658			lda 	gxHeight
.ad22	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad24	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad26					_GXCalcLastPage:
.ad26	98		tya				tya 								; add to base page
.ad27	18		clc				clc
.ad28	6d 56 06	adc $0656			adc 	gxBasePage
.ad2b	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad2d					_GXClearAll:
.ad2d	20 40 ad	jsr $ad40			jsr 	_GXClearBlock 				; clear 8k block
.ad30	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad32	a5 0b		lda $0b				lda 	GXEditSlot
.ad34	cd 56 06	cmp $0656			cmp 	gxBasePage 					; until before base page
.ad37	b0 f4		bcs $ad2d			bcs 	_GXClearAll
.ad39	20 07 b3	jsr $b307			jsr 	GXCloseBitmap	 			; stop access
.ad3c	18		clc				clc
.ad3d	60		rts				rts
.ad3e					_GXCBFail:
.ad3e	38		sec				sec
.ad3f	60		rts				rts
.ad40					_GXClearBlock:
.ad40	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad42	85 38		sta $38				sta 	0+gxzTemp1
.ad44	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad46	85 39		sta $39				sta 	1+gxzTemp1
.ad48					_GXCB0:
.ad48	a5 36		lda $36				lda 	gxzTemp0
.ad4a	a0 00		ldy #$00			ldy 	#0
.ad4c					_GXCB1:
.ad4c	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad4e	c8		iny				iny
.ad4f	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad51	c8		iny				iny
.ad52	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad54	c8		iny				iny
.ad55	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad57	c8		iny				iny
.ad58	d0 f2		bne $ad4c			bne 	_GXCB1
.ad5a	e6 39		inc $39				inc 	gxzTemp1+1
.ad5c	a5 39		lda $39				lda 	gxzTemp1+1
.ad5e	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad60	d0 e6		bne $ad48			bne 	_GXCB0
.ad62	60		rts				rts
.ad63					GXInitialise:
.ad63	64 01		stz $01				stz 	1
.ad65	a9 01		lda #$01			lda 	#1
.ad67	8d 00 d0	sta $d000			sta 	$D000
.ad6a	18		clc				clc
.ad6b	9c 54 06	stz $0654			stz 	GXSpritesOn
.ad6e	9c 55 06	stz $0655			stz 	GXBitmapsOn
.ad71	a2 0f		ldx #$0f			ldx 	#15
.ad73					_GXIClear:
.ad73	9e 44 06	stz $0644,x			stz 	gxCurrentX,x
.ad76	ca		dex				dex
.ad77	10 fa		bpl $ad73			bpl 	_GXIClear
.ad79	20 14 ae	jsr $ae14			jsr 	GXClearSpriteStore
.ad7c	60		rts				rts
.ad7d					GXControlBitmap:
.ad7d	64 01		stz $01				stz 	1
.ad7f	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad81	29 01		and #$01			and 	#1 							; set bitmap flag
.ad83	8d 55 06	sta $0655			sta 	gxBitmapsOn
.ad86	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad87	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad8a	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad8c	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ad8e	90 02		bcc $ad92			bcc 	_CBNotOn
.ad90	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.ad92					_CBNotOn:
.ad92	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad95	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ad97	29 07		and #$07			and 	#7
.ad99	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.ad9c	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad9e	d0 02		bne $ada2			bne 	_CBNotDefault
.ada0	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.ada2					_CBNotDefault:
.ada2	8d 56 06	sta $0656			sta 	gxBasePage
.ada5	20 06 ae	jsr $ae06			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ada8	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.adaa	8d 03 d1	sta $d103			sta 	$D103
.adad	a5 36		lda $36				lda 	gxzTemp0
.adaf	8d 02 d1	sta $d102			sta 	$D102
.adb2	9c 01 d1	stz $d101			stz 	$D101
.adb5	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.adb7	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.adba	29 01		and #$01			and 	#1
.adbc	f0 02		beq $adc0			beq 	_CBHaveHeight
.adbe	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.adc0					_CBHaveHeight
.adc0	8e 58 06	stx $0658			stx 	gxHeight
.adc3	18		clc				clc
.adc4	60		rts				rts
.adc5					GXControlSprite:
.adc5	64 01		stz $01				stz 	1
.adc7	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adc9	29 01		and #$01			and 	#1 							; set sprites flag
.adcb	8d 54 06	sta $0654			sta 	gxSpritesOn
.adce	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adcf	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.add2	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.add4	29 df		and #$df			and 	#$DF 						; clear sprite bit
.add6	90 02		bcc $adda			bcc 	_CSNotOn
.add8	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.adda					_CSNotOn:
.adda	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.addd	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.addf	d0 02		bne $ade3			bne 	_CSNotDefault
.ade1	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ade3					_CSNotDefault:
.ade3	8d 57 06	sta $0657			sta 	gxSpritePage
.ade6	20 06 ae	jsr $ae06			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ade9	a5 36		lda $36				lda 	zTemp0
.adeb	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase
.adee	a5 37		lda $37				lda 	zTemp0+1
.adf0	8d 63 06	sta $0663			sta 	GXSpriteOffsetBase+1
.adf3	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.adf5					_CSClear:
.adf5	9e 00 d9	stz $d900,x			stz 	$D900,x
.adf8	9e 00 da	stz $da00,x			stz 	$DA00,x
.adfb	ca		dex				dex
.adfc	d0 f7		bne $adf5			bne 	_CSClear
.adfe	9c 61 06	stz $0661			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae01	20 14 ae	jsr $ae14			jsr 	GXClearSpriteStore
.ae04	18		clc				clc
.ae05	60		rts				rts
.ae06					GXCalculateBaseAddress:
.ae06	85 36		sta $36				sta 	gxzTemp0
.ae08	64 37		stz $37				stz 	gxzTemp0+1
.ae0a	a9 05		lda #$05			lda 	#5
.ae0c					_GXShift:
.ae0c	06 36		asl $36				asl 	gxzTemp0
.ae0e	26 37		rol $37				rol 	gxzTemp0+1
.ae10	3a		dec a				dec		a
.ae11	d0 f9		bne $ae0c			bne 	_GXShift
.ae13	60		rts				rts
.ae14					GXClearSpriteStore:
.ae14	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae16					_GXCSSLoop:
.ae16	9e a4 06	stz $06a4,x			stz 	GXSpriteHigh,x
.ae19	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae1b	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.ae1e	ca		dex				dex
.ae1f	10 f5		bpl $ae16			bpl 	_GXCSSLoop
.ae21	60		rts				rts
.ae22					GXLine:
.ae22	ad 55 06	lda $0655			lda 	GXBitmapsOn
.ae25	f0 28		beq $ae4f			beq 	_GXLFail
.ae27	20 ff b2	jsr $b2ff			jsr 	GXOpenBitmap
.ae2a	20 45 b4	jsr $b445			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae2d	20 f5 ae	jsr $aef5			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae30	20 0f b3	jsr $b30f			jsr 	GXPositionCalc 				; calculate position/offset.
.ae33					_GXDrawLoop:
.ae33	ac 5e 06	ldy $065e			ldy 	gsOffset 					; draw the pixel
.ae36	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae38	2d 5c 06	and $065c			and 	gxANDValue
.ae3b	4d 5b 06	eor $065b			eor 	gxEORValue
.ae3e	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae40	20 51 ae	jsr $ae51			jsr 	GXLineIsComplete 			; is the line complete ?
.ae43	f0 05		beq $ae4a			beq 	_GXLExit
.ae45	20 6c ae	jsr $ae6c			jsr 	GXLineAdvance 				; code as per advance method
.ae48	80 e9		bra $ae33			bra 	_GXDrawLoop
.ae4a					_GXLExit:
.ae4a	20 07 b3	jsr $b307			jsr 	GXCloseBitmap
.ae4d	18		clc				clc
.ae4e	60		rts				rts
.ae4f					_GXLFail:
.ae4f	38		sec				sec
.ae50	60		rts				rts
.ae51					GXLineIsComplete:
.ae51	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger 			; is dy larger
.ae54	d0 0f		bne $ae65			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae56	ad 4c 06	lda $064c			lda 	GXX0 						; compare X, LSB and MSB
.ae59	4d 50 06	eor $0650			eor 	GXX1
.ae5c	d0 06		bne $ae64			bne 	_GXLICExit
.ae5e	ad 4d 06	lda $064d			lda 	GXX0+1
.ae61	4d 51 06	eor $0651			eor 	GXX1+1
.ae64					_GXLICExit:
.ae64	60		rts				rts
.ae65					_GXLICCompareY:
.ae65	ad 52 06	lda $0652			lda 	GXY1
.ae68	4d 4e 06	eor $064e			eor 	GXY0
.ae6b	60		rts				rts
.ae6c					GXLineAdvance:
.ae6c	18		clc				clc 								; add adjust to position
.ae6d	ad ed 06	lda $06ed			lda 	GXPosition
.ae70	6d ee 06	adc $06ee			adc 	GXAdjust
.ae73	8d ed 06	sta $06ed			sta 	GXPosition
.ae76	9c f0 06	stz $06f0			stz 	GXAddSelect 				; clear add select flag
.ae79	b0 05		bcs $ae80			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ae7b	cd ef 06	cmp $06ef			cmp 	GXTotal 					; if exceeded total
.ae7e	90 0a		bcc $ae8a			bcc 	_GXLANoExtra
.ae80					_GXLAOverflow:
.ae80	ce f0 06	dec $06f0			dec 	GXAddSelect 				; set addselect to $FF
.ae83	38		sec				sec 								; subtract total and write back
.ae84	ed ef 06	sbc $06ef			sbc 	GXTotal
.ae87	8d ed 06	sta $06ed			sta 	GXPosition
.ae8a					_GXLANoExtra:
.ae8a	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger
.ae8d	f0 0d		beq $ae9c			beq 	_GXDXLarger
.ae8f	20 ee ae	jsr $aeee			jsr 	GXIncrementY
.ae92	ad f0 06	lda $06f0			lda 	GXAddSelect
.ae95	f0 10		beq $aea7			beq 	_GXLAExit
.ae97	20 a8 ae	jsr $aea8			jsr 	GXAdjustX
.ae9a	80 0b		bra $aea7			bra 	_GXLAExit
.ae9c					_GXDXLarger:
.ae9c	20 a8 ae	jsr $aea8			jsr 	GXAdjustX
.ae9f	ad f0 06	lda $06f0			lda 	GXAddSelect
.aea2	f0 03		beq $aea7			beq 	_GXLAExit
.aea4	20 ee ae	jsr $aeee			jsr 	GXIncrementY
.aea7					_GXLAExit:
.aea7	60		rts				rts
.aea8					GXAdjustX:
.aea8	ad ec 06	lda $06ec			lda 	GXDXNegative
.aeab	10 25		bpl $aed2			bpl 	_GXAXRight
.aead	ad 4c 06	lda $064c			lda 	GXX0
.aeb0	d0 03		bne $aeb5			bne 	_GXAXNoBorrow
.aeb2	ce 4d 06	dec $064d			dec 	GXX0+1
.aeb5					_GXAXNoBorrow:
.aeb5	ce 4c 06	dec $064c			dec 	GXX0
.aeb8	ce 5e 06	dec $065e			dec 	gsOffset 					; pixel left
.aebb	ad 5e 06	lda $065e			lda 	gsOffset
.aebe	c9 ff		cmp #$ff			cmp 	#$FF
.aec0	d0 0f		bne $aed1			bne 	_GXAYExit 					; underflow
.aec2	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aec4	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aec6	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aec8	b0 07		bcs $aed1			bcs 	_GXAYExit
.aeca	18		clc				clc
.aecb	69 20		adc #$20			adc 	#$20 						; fix up
.aecd	85 3d		sta $3d				sta 	gxzScreen+1
.aecf	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aed1					_GXAYExit:
.aed1	60		rts				rts
.aed2					_GXAXRight:
.aed2	ee 4c 06	inc $064c			inc 	GXX0
.aed5	d0 03		bne $aeda			bne 	_GXAXNoCarry
.aed7	ee 4d 06	inc $064d			inc 	GXX0+1
.aeda					_GXAXNoCarry:
.aeda	ee 5e 06	inc $065e			inc 	gsOffset 					; pixel right
.aedd	d0 0e		bne $aeed			bne 	_GXAXExit 					; if not overflowed, exit.
.aedf	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.aee1	a5 3d		lda $3d				lda 	gxzScreen+1
.aee3	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.aee5	90 06		bcc $aeed			bcc 	_GXAXExit
.aee7	e9 20		sbc #$20			sbc 	#$20 						; fix up
.aee9	85 3d		sta $3d				sta 	gxzScreen+1
.aeeb	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.aeed					_GXAXExit:
.aeed	60		rts				rts
.aeee					GXIncrementY:
.aeee	ee 4e 06	inc $064e			inc 	GXY0
.aef1	20 65 b3	jsr $b365			jsr 	GXMovePositionDown
.aef4	60		rts				rts
.aef5					GXLineSetup:
.aef5	ad 52 06	lda $0652			lda 	GXY1
.aef8	38		sec				sec
.aef9	ed 4e 06	sbc $064e			sbc 	GXY0
.aefc	4a		lsr a				lsr 	a
.aefd	8d ea 06	sta $06ea			sta 	GXDiffY
.af00	9c ec 06	stz $06ec			stz 	GXDXNegative 				; clear -ve flag
.af03	38		sec				sec
.af04	ad 50 06	lda $0650			lda 	GXX1
.af07	ed 4c 06	sbc $064c			sbc 	GXX0
.af0a	8d e9 06	sta $06e9			sta 	GXDiffX
.af0d	ad 51 06	lda $0651			lda 	GXX1+1 						; calculate MSB
.af10	ed 4d 06	sbc $064d			sbc 	GXX0+1
.af13	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af14	6e e9 06	ror $06e9			ror 	GXDiffX
.af17	0a		asl a				asl 	a
.af18	10 0c		bpl $af26			bpl 	_GDXNotNegative
.af1a	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af1c	38		sec				sec
.af1d	ed e9 06	sbc $06e9			sbc 	GXDiffX
.af20	8d e9 06	sta $06e9			sta 	GXDiffX
.af23	ce ec 06	dec $06ec			dec 	GXDXNegative 				; -ve flag = $FF.
.af26					_GDXNotNegative:
.af26	9c eb 06	stz $06eb			stz 	GXIsDiffYLarger 			; clear larger flag
.af29	ad ea 06	lda $06ea			lda 	GXDiffY 					; set adjust and total.
.af2c	8d ee 06	sta $06ee			sta 	GXAdjust
.af2f	ad e9 06	lda $06e9			lda 	GXDiffX
.af32	8d ef 06	sta $06ef			sta 	GXTotal
.af35	ad ea 06	lda $06ea			lda 	GXDiffY 					; if dy > dx
.af38	cd e9 06	cmp $06e9			cmp 	GXDiffX
.af3b	90 0f		bcc $af4c			bcc 	_GDXNotLarger
.af3d	ce eb 06	dec $06eb			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af40	ad e9 06	lda $06e9			lda 	GXDiffX 					; set adjust and total other way round
.af43	8d ee 06	sta $06ee			sta 	GXAdjust
.af46	ad ea 06	lda $06ea			lda 	GXDiffY
.af49	8d ef 06	sta $06ef			sta 	GXTotal
.af4c					_GDXNotLarger:
.af4c	ad ef 06	lda $06ef			lda 	GXTotal
.af4f	4a		lsr a				lsr 	a
.af50	8d ed 06	sta $06ed			sta 	GXPosition
.af53	60		rts				rts
.06e9					GXDiffX:
>06e9							.fill 	1
.06ea					GXDiffY:
>06ea							.fill 	1
.06eb					GXIsDiffYLarger:
>06eb							.fill 	1
.06ec					GXDXNegative:
>06ec							.fill 	1
.06ed					GXPosition:
>06ed							.fill 	1
.06ee					GXAdjust:
>06ee							.fill 	1
.06ef					GXTotal:
>06ef							.fill 	1
.06f0					GXAddSelect:
>06f0							.fill 	1
.af54					GXSetColourMode:
.af54	a6 36		ldx $36				ldx 	gxzTemp0
.af56	8e 5a 06	stx $065a			stx 	gxColour 								; set colour
.af59	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af5b	8d 59 06	sta $0659			sta 	gxMode 									; set mode
.af5e	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af60	9c 5c 06	stz $065c			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af63	ae 5a 06	ldx $065a			ldx 	gxColour
.af66	8e 5b 06	stx $065b			stx 	gxEORValue
.af69	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af6b	90 03		bcc $af70			bcc 	_GXSDCNotAndColour
.af6d	8e 5c 06	stx $065c			stx 	gxANDValue
.af70					_GXSDCNotAndColour:
.af70	d0 03		bne $af75			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af72	9c 5b 06	stz $065b			stz 	gxEORValue
.af75					_GXSDCNotAnd:
.af75	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af76	90 08		bcc $af80			bcc 	_GXSDCNoFlip
.af78	ad 5c 06	lda $065c			lda	 	gxANDValue
.af7b	49 ff		eor #$ff			eor 	#$FF
.af7d	8d 5c 06	sta $065c			sta 	gxANDValue
.af80					_GXSDCNoFlip:
.af80	18		clc				clc
.af81	60		rts				rts
.af82					GXPlotPoint:
.af82	20 ff b2	jsr $b2ff			jsr 	GXOpenBitmap 				; start drawing
.af85	20 0f b3	jsr $b30f			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.af88	ac 5e 06	ldy $065e			ldy 	gsOffset
.af8b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af8d	2d 5c 06	and $065c			and 	gxANDValue
.af90	4d 5b 06	eor $065b			eor 	gxEORValue
.af93	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af95	20 07 b3	jsr $b307			jsr 	GXCloseBitmap 				; stop drawing and exit
.af98	18		clc				clc
.af99	60		rts				rts
.af9a					GXFillRectangle:
.af9a	38		sec				sec
.af9b	80 01		bra $af9e			bra 	GXRectangle
.af9d					GXFrameRectangle:
.af9d	18		clc				clc
.af9e					GXRectangle:
.af9e	ad 55 06	lda $0655			lda 	gxBitmapsOn
.afa1	f0 35		beq $afd8			beq 	_GXRFail
.afa3	08		php				php 								; save Fill flag (CS)
.afa4	20 ff b2	jsr $b2ff			jsr 	GXOpenBitmap 				; start drawing
.afa7	20 27 b4	jsr $b427			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afaa	20 0f b3	jsr $b30f			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afad	38		sec				sec 								; sec = Draw line
.afae	20 da af	jsr $afda			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afb1	ad 4e 06	lda $064e			lda 	gxY0 						; reached end of rectangle ?
.afb4	cd 52 06	cmp $0652			cmp 	gxY1
.afb7	f0 19		beq $afd2			beq 	_GXRectangleExit
.afb9					_GXRectLoop:
.afb9	20 65 b3	jsr $b365			jsr 	GXMovePositionDown 			; down one.
.afbc	ee 4e 06	inc $064e			inc 	gxY0 						; change Y pos
.afbf	ad 4e 06	lda $064e			lda 	gxY0 						; reached last line
.afc2	cd 52 06	cmp $0652			cmp 	gXY1
.afc5	f0 07		beq $afce			beq 	_GXLastLine
.afc7	28		plp				plp 								; get flag back
.afc8	08		php				php
.afc9	20 da af	jsr $afda			jsr 	GXDrawLineX1X0 				; draw horizontal line
.afcc	80 eb		bra $afb9			bra 	_GXRectLoop
.afce					_GXLastLine:
.afce	38		sec				sec
.afcf	20 da af	jsr $afda			jsr 	GXDrawLineX1X0
.afd2					_GXRectangleExit:
.afd2	68		pla				pla 								; throw fill flag.
.afd3	20 07 b3	jsr $b307			jsr 	GXCloseBitmap 				; stop drawing and exit
.afd6	18		clc				clc
.afd7	60		rts				rts
.afd8					_GXRFail:
.afd8	38		sec				sec
.afd9	60		rts				rts
.afda					GXDrawLineX1X0:
.afda	08		php				php 								; save solid/either-end
.afdb	38		sec				sec
.afdc	ad 50 06	lda $0650			lda		gXX1
.afdf	ed 4c 06	sbc $064c			sbc 	gXX0
.afe2	85 36		sta $36				sta 	gxzTemp0
.afe4	ad 51 06	lda $0651			lda 	gXX1+1
.afe7	ed 4d 06	sbc $064d			sbc 	gXX0+1
.afea	85 37		sta $37				sta 	gxzTemp0+1
.afec	28		plp				plp
.afed					GXDrawLineTemp0:
.afed	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.afef	48		pha				pha
.aff0	a5 3d		lda $3d				lda 	gxzScreen+1
.aff2	48		pha				pha
.aff3	ad 5e 06	lda $065e			lda 	gsOffset
.aff6	48		pha				pha
.aff7	a5 0b		lda $0b				lda 	GXEditSlot
.aff9	48		pha				pha
.affa	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y offset
.affd	90 1e		bcc $b01d			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.afff					_GXDLTLine:
.afff	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b001	2d 5c 06	and $065c			and 	gxANDValue
.b004	4d 5b 06	eor $065b			eor 	gxEORValue
.b007	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b009	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b00b	d0 04		bne $b011			bne 	_GXDLTNoBorrow
.b00d	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b00f	30 2e		bmi $b03f			bmi 	_GXDLTExit
.b011					_GXDLTNoBorrow:
.b011	c6 36		dec $36				dec 	gxzTemp0
.b013	c8		iny				iny 								; next slot.
.b014	d0 e9		bne $afff			bne 	_GXDLTLine
.b016	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b018	20 4d b0	jsr $b04d			jsr 	GXDLTCheckWrap				; check for new page.
.b01b	80 e2		bra $afff			bra 	_GXDLTLine
.b01d					_GXDLTEndPoints:
.b01d	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b01f	2d 5c 06	and $065c			and 	gxANDValue
.b022	4d 5b 06	eor $065b			eor 	gxEORValue
.b025	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b027	98		tya				tya 								; advance to right side
.b028	18		clc				clc
.b029	65 36		adc $36				adc 	gxzTemp0
.b02b	a8		tay				tay
.b02c	a5 3d		lda $3d				lda 	gxzScreen+1
.b02e	65 37		adc $37				adc 	gxzTemp0+1
.b030	85 3d		sta $3d				sta 	gxzScreen+1
.b032	20 4d b0	jsr $b04d			jsr 	GXDLTCheckWrap 			; fix up.
.b035	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b037	2d 5c 06	and $065c			and 	gxANDValue
.b03a	4d 5b 06	eor $065b			eor 	gxEORValue
.b03d	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b03f					_GXDLTExit:
.b03f	68		pla				pla
.b040	85 0b		sta $0b				sta 	GXEditSlot
.b042	68		pla				pla
.b043	8d 5e 06	sta $065e			sta 	gsOffset
.b046	68		pla				pla
.b047	85 3d		sta $3d				sta 	gxzScreen+1
.b049	68		pla				pla
.b04a	85 3c		sta $3c				sta 	gxzScreen
.b04c	60		rts				rts
.b04d					GXDLTCheckWrap:
.b04d	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b04f	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b051	90 06		bcc $b059			bcc 	_GXDLTCWExit
.b053	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b055	85 3d		sta $3d				sta 	gxzScreen+1
.b057	e6 0b		inc $0b				inc 	GXEditSlot
.b059					_GXDLTCWExit:
.b059	60		rts				rts
.b05a					GXDrawGraphicElement:
.b05a	8d f1 06	sta $06f1			sta 	gxSize 						; save size
.b05d	3a		dec a				dec 	a
.b05e	8d f2 06	sta $06f2			sta 	gxMask 						; and mask
.b061	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP on
.b064	f0 67		beq $b0cd			beq 	_GXSLFail
.b066	ad 4e 06	lda $064e			lda 	gxY0 						; push Y on stack
.b069	48		pha				pha
.b06a	8c f4 06	sty $06f4			sty 	gxAcquireVector+1 			; and acquisition vector
.b06d	8e f3 06	stx $06f3			stx 	gxAcquireVector
.b070	20 ff b2	jsr $b2ff			jsr 	gxOpenBitmap 				; open the bitmap.
.b073	ad f6 06	lda $06f6			lda 	gxUseMode 					; scale bits
.b076	4a		lsr a				lsr 	a
.b077	4a		lsr a				lsr 	a
.b078	4a		lsr a				lsr 	a
.b079	29 07		and #$07			and		#7
.b07b	1a		inc a				inc 	a
.b07c	8d f5 06	sta $06f5			sta 	gxScale
.b07f	64 38		stz $38				stz 	gxzTemp1					; start first line
.b081					_GXGELoop:
.b081	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b083	2c f6 06	bit $06f6			bit 	gxUseMode 					; check for flip.
.b086	10 06		bpl $b08e			bpl		_GXNoVFlip
.b088	ad f2 06	lda $06f2			lda 	gxMask
.b08b	38		sec				sec
.b08c	e5 38		sbc $38				sbc 	gxzTemp1
.b08e					_GXNoVFlip:
.b08e	aa		tax				tax 								; get the Xth line.
.b08f	20 cf b0	jsr $b0cf			jsr 	_GXCallAcquire 				; get that data.
.b092	ad f5 06	lda $06f5			lda 	gxScale 					; do scale identical copies of that line.
.b095	85 39		sta $39				sta 	gxzTemp1+1
.b097					_GXGELoop2:
.b097	ad 4e 06	lda $064e			lda 	gxY0 						; off screen
.b09a	cd 58 06	cmp $0658			cmp 	gxHeight
.b09d	b0 10		bcs $b0af			bcs 	_GXDGEExit
.b09f	20 d2 b0	jsr $b0d2			jsr 	GXRenderOneLine 			; render line
.b0a2	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0a4	d0 f1		bne $b097			bne 	_GXGELoop2
.b0a6	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0a8	a5 38		lda $38				lda 	gxzTemp1
.b0aa	cd f1 06	cmp $06f1			cmp 	gxSize
.b0ad	d0 d2		bne $b081			bne 	_GXGELoop
.b0af					_GXDGEExit:
.b0af	68		pla				pla 								; restore Y for next time
.b0b0	8d 4e 06	sta $064e			sta 	gxY0
.b0b3	ae f5 06	ldx $06f5			ldx 	gxScale 					; get scale (1-8)
.b0b6					_GXShiftLeft:
.b0b6	18		clc				clc
.b0b7	ad f1 06	lda $06f1			lda 	gxSize
.b0ba	6d 4c 06	adc $064c			adc 	gxX0
.b0bd	8d 4c 06	sta $064c			sta 	gxX0
.b0c0	90 03		bcc $b0c5			bcc 	_GXSLNoCarry
.b0c2	ee 4d 06	inc $064d			inc 	gxX0+1
.b0c5					_GXSLNoCarry:
.b0c5	ca		dex				dex
.b0c6	d0 ee		bne $b0b6			bne 	_GXShiftLeft
.b0c8	20 07 b3	jsr $b307			jsr 	GXCloseBitmap
.b0cb	18		clc				clc
.b0cc	60		rts				rts
.b0cd					_GXSLFail:
.b0cd	38		sec				sec
.b0ce	60		rts				rts
.b0cf					_GXCallAcquire:
.b0cf	6c f3 06	jmp ($06f3)			jmp 	(gxAcquireVector)
.b0d2					GXRenderOneLine:
.b0d2	20 0f b3	jsr $b30f			jsr 	GXPositionCalc 				; calculate position/offset.
.b0d5	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y contains position.
.b0d8	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b0da					_GXROLLoop1:
.b0da	ad f5 06	lda $06f5			lda 	gxScale 					; set to do 'scale' times
.b0dd	85 3b		sta $3b				sta 	gxzTemp2+1
.b0df					_GXROLLoop2:
.b0df	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b0e1	2c 59 06	bit $0659			bit 	gxMode 						; check H Flip
.b0e4	50 06		bvc $b0ec			bvc 	_GXNoHFlip
.b0e6	ad f2 06	lda $06f2			lda 	gxMask
.b0e9	38		sec				sec
.b0ea	e5 3a		sbc $3a				sbc 	gxzTemp2
.b0ec					_GXNoHFlip:
.b0ec	aa		tax				tax 								; read from the pixel buffer
.b0ed	bd fa 05	lda $05fa,x			lda 	gxPixelBuffer,x
.b0f0	d0 07		bne $b0f9			bne 	_GXDraw 					; draw if non zero
.b0f2	ad f6 06	lda $06f6			lda 	gxUseMode 					; check to see if solid background
.b0f5	29 04		and #$04			and 	#4
.b0f7	f0 0a		beq $b103			beq 	_GXZeroPixel
.b0f9					_GXDraw:
.b0f9	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b0fb	2d 5c 06	and $065c			and 	gxANDValue
.b0fe	5d fa 05	eor $05fa,x			eor 	gxPixelBuffer,x
.b101	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b103					_GXZeroPixel:
.b103	c8		iny				iny 								; advance pointer
.b104	d0 05		bne $b10b			bne 	_GXNoShift
.b106	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b108	20 4d b0	jsr $b04d			jsr 	GXDLTCheckWrap				; check for new page.
.b10b					_GXNoShift:
.b10b	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b10d	d0 d0		bne $b0df			bne 	_GXROLLoop2
.b10f	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b111	a5 3a		lda $3a				lda 	gxzTemp2
.b113	cd f1 06	cmp $06f1			cmp 	gxSize
.b116	d0 c2		bne $b0da			bne 	_GXROLLoop1
.b118	ee 4e 06	inc $064e			inc 	gxY0
.b11b	60		rts				rts
.06f1					gxSize:
>06f1							.fill 	1
.06f2					gxMask:
>06f2							.fill 	1
.06f3					gxAcquireVector:
>06f3							.fill 	2
.06f5					gxScale:
>06f5							.fill 	1
.06f6					gxUseMode:
>06f6							.fill 	1
.b11c					GXFontHandler:
.b11c	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b11e	4d 59 06	eor $0659			eor 	gxMode
.b121	8d f6 06	sta $06f6			sta 	gxUseMode
.b124	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b126	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b128	26 37		rol $37				rol	 	gxzTemp0+1
.b12a	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b12c	26 37		rol $37				rol	 	gxzTemp0+1
.b12e	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b130	26 37		rol $37				rol	 	gxzTemp0+1
.b132	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b134	09 c0		ora #$c0			ora 	#$C0
.b136	85 37		sta $37				sta 	gxzTemp0+1
.b138	a9 08		lda #$08			lda 	#8 							; size 8x8
.b13a	a2 42		ldx #$42			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b13c	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b13e	20 5a b0	jsr $b05a			jsr 	GXDrawGraphicElement
.b141	60		rts				rts
.b142					GXGetGraphicDataFont:
.b142	8a		txa				txa 								; X->Y
.b143	a8		tay				tay
.b144	a6 01		ldx $01				ldx 	1 							; preserve old value
.b146	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b148	85 01		sta $01				sta 	1
.b14a	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b14c	86 01		stx $01				stx 	1 							; put old value back.
.b14e	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b150					_GXExpand:
.b150	9e fa 05	stz $05fa,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b153	0a		asl a				asl 	a 							; shift bit 7 into C
.b154	90 08		bcc $b15e			bcc 	_GXNoPixel
.b156	48		pha				pha 								; if set, set pixel buffer to current colour.
.b157	ad 5a 06	lda $065a			lda 	gxColour
.b15a	9d fa 05	sta $05fa,x			sta 	gxPixelBuffer,x
.b15d	68		pla				pla
.b15e					_GXNoPixel:
.b15e	e8		inx				inx 								; do the whole byte.
.b15f	e0 08		cpx #$08			cpx 	#8
.b161	d0 ed		bne $b150			bne 	_GXExpand
.b163	60		rts				rts
.b164					GXSpriteHandler:
.b164	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b166	4d 59 06	eor $0659			eor 	gxMode
.b169	8d f6 06	sta $06f6			sta 	gxUseMode
.b16c	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b16e	da		phx				phx
.b16f	20 ff b2	jsr $b2ff			jsr 	GXOpenBitmap 				; can access sprite information
.b172	68		pla				pla
.b173	20 e0 b3	jsr $b3e0			jsr 	GXFindSprite 				; get the sprite address
.b176	08		php				php
.b177	20 07 b3	jsr $b307			jsr 	GXCloseBitmap
.b17a	28		plp				plp
.b17b	b0 0a		bcs $b187			bcs		_GXSHExit 					; exit if find failed.
.b17d	ad f7 06	lda $06f7			lda 	GXSizePixels 				; return size
.b180	a2 88		ldx #$88			ldx 	#GXSpriteAcquire & $FF
.b182	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b184	20 5a b0	jsr $b05a			jsr 	GXDrawGraphicElement
.b187					_GXSHExit:
.b187	60		rts				rts
.b188					GXSpriteAcquire:
.b188	ad 57 06	lda $0657			lda 	GXSpritePage				; point to base page
.b18b	85 0b		sta $0b				sta 	GXEditSlot
.b18d	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b18f	a9 00		lda #$00			lda 	#0
.b191	ae f8 06	ldx $06f8			ldx 	GXSizeBits
.b194					_GXTimesRowNumber:
.b194	18		clc				clc
.b195	65 36		adc $36				adc 	zTemp0
.b197	ca		dex				dex
.b198	10 fa		bpl $b194			bpl 	_GXTimesRowNumber
.b19a	64 37		stz $37				stz 	gxzTemp0+1
.b19c	0a		asl a				asl 	a 							; row x 2,4,6,8
.b19d	26 37		rol $37				rol 	gxzTemp0+1
.b19f	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1a0	26 37		rol $37				rol 	gxzTemp0+1
.b1a2	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1a3	26 37		rol $37				rol 	gxzTemp0+1
.b1a5	85 36		sta $36				sta 	gxzTemp0
.b1a7	18		clc				clc 								; add base address.
.b1a8	a5 36		lda $36				lda 	gxzTemp0
.b1aa	6d fa 06	adc $06fa			adc 	GXSpriteOffset
.b1ad	85 36		sta $36				sta 	gxzTemp0
.b1af	a5 37		lda $37				lda 	gxzTemp0+1
.b1b1	6d fb 06	adc $06fb			adc 	GXSpriteOffset+1
.b1b4					_GXSAFindPage:
.b1b4	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1b6	90 06		bcc $b1be			bcc 	_GXSAFoundPage
.b1b8	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1ba	e6 0b		inc $0b				inc 	GXEditSlot
.b1bc	80 f6		bra $b1b4			bra 	_GXSAFindPage
.b1be					_GXSAFoundPage:
.b1be	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1c0	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1c2	a0 00		ldy #$00			ldy 	#0
.b1c4					_GXSACopyLoop:
.b1c4	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1c6	99 fa 05	sta $05fa,y			sta 	gxPixelBuffer,y
.b1c9	c8		iny				iny
.b1ca	cc f7 06	cpy $06f7			cpy 	GXSizePixels
.b1cd	d0 f5		bne $b1c4			bne 	_GXSACopyLoop
.b1cf	60		rts				rts
.b1d0					GXSelect:
.b1d0	ad 54 06	lda $0654			lda 	gxSpritesOn
.b1d3	f0 22		beq $b1f7			beq 	_GXSFail
.b1d5	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b1d7	c9 40		cmp #$40			cmp 	#64
.b1d9	b0 1c		bcs $b1f7			bcs 	_GXSFail
.b1db	8d 5f 06	sta $065f			sta 	GSCurrentSpriteID
.b1de	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b1e0	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b1e2	06 36		asl $36				asl 	gxzTemp0
.b1e4	06 36		asl $36				asl 	gxzTemp0
.b1e6	06 36		asl $36				asl 	gxzTemp0
.b1e8	2a		rol a				rol 	a
.b1e9	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b1eb	8d 61 06	sta $0661			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b1ee	85 37		sta $37				sta 	gxzTemp0+1
.b1f0	a5 36		lda $36				lda 	gxzTemp0
.b1f2	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr
.b1f5	18		clc				clc
.b1f6	60		rts				rts
.b1f7					_GXSFail:
.b1f7	38		sec				sec
.b1f8	60		rts				rts
.b1f9					GXSelectImage:
.b1f9	ad 54 06	lda $0654			lda 	gxSpritesOn
.b1fc	f0 74		beq $b272			beq 	_GXSIFail
.b1fe	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b201	f0 6f		beq $b272			beq 	_GXSIFail 					; (checking the MSB)
.b203	64 01		stz $01				stz 	1
.b205	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b207	d0 6b		bne $b274			bne 	_GXSIHide
.b209	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b20b	48		pha				pha
.b20c	20 ff b2	jsr $b2ff			jsr 	GXOpenBitmap
.b20f	68		pla				pla
.b210	20 e0 b3	jsr $b3e0			jsr 	GXFindSprite
.b213	b0 5a		bcs $b26f			bcs 	_GXSICloseFail 				; no image
.b215	a0 01		ldy #$01			ldy 	#1
.b217	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b21a	85 36		sta $36				sta 	gxzTemp0
.b21c	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b21f	85 37		sta $37				sta 	gxzTemp0+1
.b221	ad fa 06	lda $06fa			lda 	GXSpriteOffset
.b224	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b226	18		clc				clc
.b227	ad fb 06	lda $06fb			lda 	GXSpriteOffset+1
.b22a	6d 62 06	adc $0662			adc 	GXSpriteOffsetBase
.b22d	c8		iny				iny
.b22e	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b230	ad 63 06	lda $0663			lda 	GXSpriteOffsetBase+1
.b233	69 00		adc #$00			adc 	#0
.b235	c8		iny				iny
.b236	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b238	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get raw size
.b23b	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b23d	2a		rol a				rol 	a 							; x 2
.b23e	0a		asl a				asl 	a 							; x 4
.b23f	0a		asl a				asl 	a 							; x 8
.b240	0a		asl a				asl 	a 							; x 16
.b241	0d f9 06	ora $06f9			ora 	GXSpriteLUT 				; Or with LUT
.b244	0a		asl a				asl 	a 							; 1 shift
.b245	09 01		ora #$01			ora 	#1 							; enable sprite.
.b247	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b249	20 07 b3	jsr $b307			jsr 	GXCloseBitmap
.b24c	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b24f	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b252	29 3f		and #$3f			and 	#$3F
.b254	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b257	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get bit size
.b25a	6a		ror a				ror 	a 							; shift into bits 6/7
.b25b	6a		ror a				ror 	a
.b25c	6a		ror a				ror 	a
.b25d	29 c0		and #$c0			and 	#$C0
.b25f	1d a4 06	ora $06a4,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b262	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b265	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b268	29 7f		and #$7f			and 	#$7F
.b26a	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b26d	18		clc				clc
.b26e	60		rts				rts
.b26f					_GXSICloseFail:
.b26f	20 07 b3	jsr $b307			jsr 	GXCloseBitmap
.b272					_GXSIFail:
.b272	38		sec				sec
.b273	60		rts				rts
.b274					_GXSIHide:
.b274	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b277	85 36		sta $36				sta 	gxzTemp0
.b279	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b27c	85 37		sta $37				sta 	gxzTemp0+1
.b27e	a9 00		lda #$00			lda 	#0
.b280	92 36		sta ($36)			sta 	(gxzTemp0)
.b282	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get sprite ID
.b285	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b288	09 80		ora #$80			ora 	#$80
.b28a	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b28d	18		clc				clc
.b28e	60		rts				rts
.b28f					GXMoveSprite:
.b28f	ad 54 06	lda $0654			lda 	gxSpritesOn
.b292	f0 65		beq $b2f9			beq 	_GXSIFail
.b294	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b297	f0 60		beq $b2f9			beq 	_GXSIFail
.b299	85 37		sta $37				sta 	gxzTemp0+1
.b29b	a0 04		ldy #$04			ldy 	#4
.b29d	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b2a0	85 36		sta $36				sta 	gxzTemp0
.b2a2	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2a5	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b2a8	2a		rol a				rol 	a	 						; into bits 0,1.
.b2a9	2a		rol a				rol 	a
.b2aa	2a		rol a				rol 	a
.b2ab	29 03		and #$03			and 	#3
.b2ad	aa		tax				tax
.b2ae	bd fb b2	lda $b2fb,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2b1	48		pha				pha
.b2b2	18		clc				clc
.b2b3	6d 4c 06	adc $064c			adc 	gxX0						; copy position.
.b2b6	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2b8	c8		iny				iny
.b2b9	ad 4d 06	lda $064d			lda 	gxX0+1
.b2bc	69 00		adc #$00			adc 	#0
.b2be	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2c0	c8		iny				iny
.b2c1	68		pla				pla
.b2c2	18		clc				clc
.b2c3	6d 4e 06	adc $064e			adc 	gxY0
.b2c6	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2c8	a9 00		lda #$00			lda 	#0
.b2ca	69 00		adc #$00			adc 	#0
.b2cc	c8		iny				iny
.b2cd	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2cf	4e 4d 06	lsr $064d			lsr 	gxX0+1 						; divide X by 4
.b2d2	6e 4c 06	ror $064c			ror 	gxX0
.b2d5	4e 4c 06	lsr $064c			lsr 	gxX0
.b2d8	4e 4e 06	lsr $064e			lsr 	gxY0 						; divide Y by 4
.b2db	4e 4e 06	lsr $064e			lsr 	gxY0
.b2de	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b2e1	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x
.b2e4	29 80		and #$80			and 	#$80
.b2e6	0d 4c 06	ora $064c			ora 	gxX0
.b2e9	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b2ec	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b2ef	29 c0		and #$c0			and 	#$C0
.b2f1	0d 4e 06	ora $064e			ora 	gxY0
.b2f4	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b2f7	18		clc				clc
.b2f8	60		rts				rts
.b2f9					_GXSIFail:
.b2f9	38		sec				sec
.b2fa	60		rts				rts
.b2fb					_GXMSOffset:
>b2fb	1c						.byte 	32-8/2
>b2fc	18						.byte 	32-16/2
>b2fd	14						.byte 	32-24/2
>b2fe	10						.byte 	32-32/2
.b2ff					GXOpenBitmap:
.b2ff	78		sei				sei 								; no interrupts here
.b300	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b302	8d 5d 06	sta $065d			sta 	gxOriginalLUTValue
.b305	58		cli				cli
.b306	60		rts				rts
.b307					GXCloseBitmap:
.b307	78		sei				sei
.b308	ad 5d 06	lda $065d			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b30b	85 0b		sta $0b				sta 	GXEditSlot
.b30d	58		cli				cli
.b30e	60		rts				rts
.b30f					GXPositionCalc:
.b30f	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b311	48		pha				pha
.b312	ad 4e 06	lda $064e			lda 	GXY0 						; gxzScreen = Y0
.b315	85 3c		sta $3c				sta 	gxzScreen
.b317	64 3d		stz $3d				stz 	gxzScreen+1
.b319	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b31b	26 3d		rol $3d				rol 	gxzScreen+1
.b31d	06 3c		asl $3c				asl 	gxzScreen
.b31f	26 3d		rol $3d				rol 	gxzScreen+1
.b321	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b322	65 3c		adc $3c				adc 	gxzScreen
.b324	85 3c		sta $3c				sta 	gxzScreen
.b326	90 02		bcc $b32a			bcc 	_GXPCNoCarry
.b328	e6 3d		inc $3d				inc 	gxzScreen+1
.b32a					_GXPCNoCarry:
.b32a	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b32c	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b32e	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b330	85 36		sta $36				sta 	gxzTemp0
.b332	64 3d		stz $3d				stz 	gxzScreen+1
.b334	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b336					_GXPCMultiply32:
.b336	06 3c		asl $3c				asl 	gxzScreen
.b338	26 3d		rol $3d				rol 	gxzScreen+1
.b33a	3a		dec a				dec 	a
.b33b	d0 f9		bne $b336			bne 	_GXPCMultiply32
.b33d	18		clc				clc
.b33e	ad 4c 06	lda $064c			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b341	65 3c		adc $3c				adc 	gxzScreen
.b343	8d 5e 06	sta $065e			sta 	gsOffset
.b346	ad 4d 06	lda $064d			lda 	GXX0+1
.b349	65 3d		adc $3d				adc 	gxzScreen+1
.b34b	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b34d	90 04		bcc $b353			bcc 	_GXPCNoOverflow
.b34f	29 1f		and #$1f			and 	#$1F 						; fix it up
.b351	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b353					_GXPCNoOverflow:
.b353	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b355	85 3d		sta $3d				sta 	gxzScreen+1
.b357	64 3c		stz $3c				stz 	gxzScreen
.b359	18		clc				clc
.b35a	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b35c	6d 56 06	adc $0656			adc 	gxBasePage 					; by adding the base page
.b35f	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b361	68		pla				pla
.b362	85 36		sta $36				sta 	gxzTemp0
.b364	60		rts				rts
.b365					GXMovePositionDown:
.b365	18		clc				clc 								; add 320 to offset/temp+1
.b366	ad 5e 06	lda $065e			lda 	gsOffset
.b369	69 40		adc #$40			adc 	#64
.b36b	8d 5e 06	sta $065e			sta 	gsOffset
.b36e	a5 3d		lda $3d				lda 	gxzScreen+1
.b370	69 01		adc #$01			adc 	#1
.b372	85 3d		sta $3d				sta 	gxzScreen+1
.b374	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b376	90 07		bcc $b37f			bcc 	_GXMPDExit
.b378	38		sec				sec  								; next page
.b379	e9 20		sbc #$20			sbc 	#$20
.b37b	85 3d		sta $3d				sta 	gxzScreen+1
.b37d	e6 0b		inc $0b				inc 	GXEditSlot
.b37f					_GXMPDExit:
.b37f	60		rts				rts
.b380					GXCollide:
.b380	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b382	aa		tax				tax
.b383	05 37		ora $37				ora 	gxzTemp0+1
.b385	29 c0		and #$c0			and 	#$C0
.b387	38		sec				sec
.b388	d0 53		bne $b3dd			bne 	_GXCollideFail 				; if either >= 64, fail.
.b38a	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b38c	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b38f	1d 64 06	ora $0664,x			ora 	GXSpriteLow,x
.b392	30 48		bmi $b3dc			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b394	18		clc				clc 								; need to calculate sum of sizes.
.b395	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y
.b398	7d a4 06	adc $06a4,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b39b	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b39d	6a		ror a				ror 	a 							; 5/6/7
.b39e	4a		lsr a				lsr 	a 							; 4/5/6
.b39f	4a		lsr a				lsr 	a 							; 3/4/5
.b3a0	4a		lsr a				lsr 	a 							; 2/3/4
.b3a1	18		clc				clc
.b3a2	69 08		adc #$08			adc 	#$08
.b3a4	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3a5	4a		lsr a				lsr 	a
.b3a6	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3a8	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3ab	29 3f		and #$3f			and 	#$3F
.b3ad	85 39		sta $39				sta 	gxzTemp1+1
.b3af	38		sec				sec
.b3b0	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b3b3	29 3f		and #$3f			and 	#$3F
.b3b5	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3b7	b0 03		bcs $b3bc			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3b9	49 ff		eor #$ff			eor 	#$FF
.b3bb	1a		inc a				inc 	a
.b3bc					_GXCAbs1:
.b3bc	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3be	b0 1c		bcs $b3dc			bcs 	_GXOkayFail
.b3c0	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3c2	38		sec				sec 								; calculate |x1-x0|
.b3c3	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y
.b3c6	fd 64 06	sbc $0664,x			sbc 	GXSpriteLow,x
.b3c9	b0 03		bcs $b3ce			bcs 	_GXCAbs2
.b3cb	49 ff		eor #$ff			eor 	#$FF
.b3cd	1a		inc a				inc 	a
.b3ce					_GXCAbs2:
.b3ce	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3d0	b0 0a		bcs $b3dc			bcs 	_GXOkayFail
.b3d2	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b3d4	90 02		bcc $b3d8			bcc 	_GXCHaveLowest
.b3d6	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b3d8					_GXCHaveLowest:
.b3d8	0a		asl a				asl 	a 							; scale to allow for >> 2
.b3d9	0a		asl a				asl 	a
.b3da	18		clc				clc
.b3db	60		rts				rts
.b3dc					_GXOkayFail:
.b3dc	18		clc				clc
.b3dd					_GXCollideFail:
.b3dd	a9 ff		lda #$ff			lda 	#$FF
.b3df	60		rts				rts
.b3e0					GXFindSprite:
.b3e0	aa		tax				tax
.b3e1	ad 57 06	lda $0657			lda 	GXSpritePage 				; access the base page of the sprite
.b3e4	85 0b		sta $0b				sta 	GXEditSlot
.b3e6	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b3e9	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b3ec	f0 33		beq $b421			beq 	_GXFSFail
.b3ee	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b3f1	8d fb 06	sta $06fb			sta 	GXSpriteOffset+1
.b3f4	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b3f7	48		pha				pha 								; save twice
.b3f8	48		pha				pha
.b3f9	29 03		and #$03			and 	#3 							; get sprite size
.b3fb	8d f8 06	sta $06f8			sta 	GXSizeBits 					; save raw (0-3)
.b3fe	aa		tax				tax
.b3ff	bd 23 b4	lda $b423,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b402	8d f7 06	sta $06f7			sta 	GXSizePixels 					; save (8/16/24/32)
.b405	68		pla				pla 								; get LUT
.b406	4a		lsr a				lsr		a
.b407	4a		lsr a				lsr		a
.b408	29 03		and #$03			and 	#3
.b40a	8d f9 06	sta $06f9			sta 	GXSpriteLUT
.b40d	68		pla				pla 								; address, neeeds to be x 4
.b40e	29 f0		and #$f0			and 	#$F0
.b410	8d fa 06	sta $06fa			sta 	GXSpriteOffset
.b413	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b416	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b419	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b41c	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b41f	18		clc				clc
.b420	60		rts				rts
.b421					_GXFSFail:
.b421	38		sec				sec
.b422	60		rts				rts
.b423					_GXFXSSTTable:
>b423	08 10 18 20					.byte 	8,16,24,32
.06f7					GXSizePixels:
>06f7							.fill 	1
.06f8					GXSizeBits:
>06f8							.fill 	1
.06f9					GXSpriteLUT:
>06f9							.fill 	1
.06fa					GXSpriteOffset:
>06fa							.fill 	2
.b427					GXSortXY:
.b427	20 45 b4	jsr $b445			jsr 	GXSortY 					; will be sorted on Y now
.b42a	ad 4c 06	lda $064c			lda 	gxX0 						; compare X0 v X1
.b42d	cd 50 06	cmp $0650			cmp 	gxX1
.b430	ad 4d 06	lda $064d			lda 	gXX0+1
.b433	ed 51 06	sbc $0651			sbc 	gXX1+1
.b436	90 0c		bcc $b444			bcc 	_GXSXYExit 					; X0 < X1 exit
.b438	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b43a	a0 04		ldy #$04			ldy 	#4
.b43c	20 59 b4	jsr $b459			jsr 	GXSwapXY
.b43f	e8		inx				inx
.b440	c8		iny				iny
.b441	20 59 b4	jsr $b459			jsr 	GXSwapXY
.b444					_GXSXYExit:
.b444	60		rts				rts
.b445					GXSortY:
.b445	ad 4e 06	lda $064e			lda 	gxY0 						; if Y0 >= Y1
.b448	cd 52 06	cmp $0652			cmp 	gxY1
.b44b	90 0b		bcc $b458			bcc 	_GXSYSorted
.b44d	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b44f	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b451					_GXSwap1:
.b451	20 59 b4	jsr $b459			jsr 	GXSwapXY
.b454	88		dey				dey
.b455	ca		dex				dex
.b456	10 f9		bpl $b451			bpl 	_GXSwap1
.b458					_GXSYSorted:
.b458	60		rts				rts
.b459					GXSwapXY:
.b459	bd 4c 06	lda $064c,x			lda 	gxX0,x
.b45c	48		pha				pha
.b45d	b9 4c 06	lda $064c,y			lda 	gxX0,y
.b460	9d 4c 06	sta $064c,x			sta 	gxX0,x
.b463	68		pla				pla
.b464	99 4c 06	sta $064c,y			sta 	gxX0,y
.b467	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.badd					KeywordSet0:
>badd	00 65					.text	0,$65,""               ; $80 !0:EOF
>badf	00 58					.text	0,$58,""               ; $81 !1:SH1
>bae1	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bae3	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>bae9	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>baf1	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>baf7	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>bafe	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>bb06	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>bb0d	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>bb14	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>bb1a	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>bb20	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>bb28	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>bb2f	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>bb36	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>bb3d	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>bb45	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>bb4b	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>bb51	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>bb58	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bb5e	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bb64	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bb6c	47 28
>bb6e	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>bb76	28
>bb77	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>bb7f	28
>bb80	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bb86	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bb8c	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>bb92	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>bb99	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>bba1	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bba7	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bbad	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bbb2	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bbb6	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bbbc	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bbc4	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bbcb	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bbd2	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bbda	43
>bbdb	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bbe1	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bbe7	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bbee	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bbf4	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bbf8	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bbfe	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bc06	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bc0d	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bc12	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bc19	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bc21	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bc27	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bc2c	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bc34	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bc3a	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bc40	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bc45	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bc4c	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bc52	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bc58	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bc5f	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>bc66	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>bc6b	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>bc71	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>bc78	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>bc7d	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>bc81	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>bc89	45
>bc8a	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>bc92	45
>bc93	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>bc99	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>bca0	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>bca6	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>bcac	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>bcb1	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bcb9	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>bcc0	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bcc7	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>bccf	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bcd5	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bcd9	ff					.text	$FF
.bcda					KeywordSet1:
>bcda	00 65					.text	0,$65,""               ; $80 !0:EOF
>bcdc	00 58					.text	0,$58,""               ; $81 !1:SH1
>bcde	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bce0	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bce8	4c 45
>bcea	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bcf2	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bcfa	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bcff	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $87 LIST
>bd05	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $88 NEW
>bd0a	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $89 RESTORE
>bd12	45
>bd13	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8a RUN
>bd18	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8b SPRITES
>bd20	53
>bd21	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8c STOP
>bd27	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $8d WHO
>bd2c	ff					.text	$FF
.bd2d					KeywordSet2:
>bd2d	00 65					.text	0,$65,""               ; $80 !0:EOF
>bd2f	00 58					.text	0,$58,""               ; $81 !1:SH1
>bd31	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bd33	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bd38	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bd3d	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bd42	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bd47	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bd4c	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bd51	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bd56	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bd5b	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bd60	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bd65	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bd6a	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bd6f	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bd74	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bd79	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bd7e	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bd83	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bd88	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bd8d	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bd92	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bd97	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bd9c	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bda1	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bda6	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bdab	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bdb0	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bdb5	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bdba	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bdbf	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bdc4	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bdc9	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bdce	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bdd3	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bdd8	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bddd	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bde2	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bde7	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bdec	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bdf1	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bdf6	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bdfb	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>be00	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>be05	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>be0a	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>be0f	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>be14	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>be19	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>be1e	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>be23	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>be28	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>be2d	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>be32	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>be37	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>be3c	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>be41	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>be46	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>be4b	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>be50	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>be55	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>be5a	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>be5f	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>be64	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>be69	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>be6e	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>be73	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>be78	ff					.text	$FF
.b468					ListConvertLine:
.b468	48		pha				pha 								; save indent on the stack
.b469	9c 9d 04	stz $049d			stz 	tbOffset
.b46c	9c ac 04	stz $04ac			stz 	tokenBuffer
.b46f	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b471	b1 30		lda ($30),y			lda 	(codePtr),y
.b473	aa		tax				tax
.b474	88		dey				dey
.b475	b1 30		lda ($30),y			lda 	(codePtr),y
.b477	20 01 93	jsr $9301			jsr 	LCLConvertInt16
.b47a	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b47c	86 37		stx $37				stx 	zTemp0+1
.b47e	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b480	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b483	a0 00		ldy #$00			ldy 	#0
.b485					_LCCopyNumber:
.b485	b1 36		lda ($36),y			lda 	(zTemp0),y
.b487	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b48a	c8		iny				iny
.b48b	b1 36		lda ($36),y			lda 	(zTemp0),y
.b48d	d0 f6		bne $b485			bne 	_LCCopyNumber
.b48f	68		pla				pla 								; adjustment to indent
.b490	48		pha				pha 								; save on stack
.b491	10 0c		bpl $b49f			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b493	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b494	6d a6 04	adc $04a6			adc 	listIndent
.b497	8d a6 04	sta $04a6			sta 	listIndent
.b49a	10 03		bpl $b49f			bpl 	_LCNoAdjust
.b49c	9c a6 04	stz $04a6			stz 	listIndent
.b49f					_LCNoAdjust:
.b49f	18		clc				clc		 							; work out actual indent.
.b4a0	ad a6 04	lda $04a6			lda 	listIndent
.b4a3	0a		asl a				asl 	a
.b4a4	69 06		adc #$06			adc 	#6
.b4a6	85 36		sta $36				sta 	zTemp0
.b4a8					_LCPadOut:
.b4a8	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b4aa	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b4ad	ad 9d 04	lda $049d			lda 	tbOffset
.b4b0	c5 36		cmp $36				cmp 	zTemp0
.b4b2	d0 f4		bne $b4a8			bne 	_LCPadOut
.b4b4	a0 03		ldy #$03			ldy 	#3 							; start position.
.b4b6					_LCMainLoop:
.b4b6	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b4b8	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b4bb	b1 30		lda ($30),y			lda 	(codePtr),y
.b4bd	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b4bf	f0 17		beq $b4d8			beq 	_LCExit
.b4c1	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b4c3	90 1e		bcc $b4e3			bcc 	_LCDoubles
.b4c5	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b4c7	90 2a		bcc $b4f3			bcc 	_LCShiftPunc
.b4c9	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b4cb	90 35		bcc $b502			bcc 	_LCPunctuation
.b4cd	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b4cf	90 3e		bcc $b50f			bcc 	_LCIdentifiers
.b4d1	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b4d3	90 5f		bcc $b534			bcc 	_LCTokens
.b4d5	4c 94 b5	jmp $b594			jmp 	_LCData 					; 254-5 are data objects
.b4d8					_LCExit:
.b4d8	68		pla				pla 								; get old indent adjust
.b4d9	30 07		bmi $b4e2			bmi 	_LCExit2
.b4db	18		clc				clc 								; add to indent if +ve
.b4dc	6d a6 04	adc $04a6			adc 	listIndent
.b4df	8d a6 04	sta $04a6			sta 	listIndent
.b4e2					_LCExit2:
.b4e2	60		rts				rts
.b4e3					_LCDoubles:
.b4e3	48		pha				pha
.b4e4	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b4e5	29 02		and #$02			and 	#2
.b4e7	09 3c		ora #$3c			ora 	#60 						; make < >
.b4e9	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b4ec	68		pla				pla 								; restore, do lower bit
.b4ed	29 03		and #$03			and 	#3
.b4ef	09 3c		ora #$3c			ora 	#60
.b4f1	80 0f		bra $b502			bra		_LCPunctuation 				; print, increment, loop
.b4f3					_LCShiftPunc:
.b4f3	aa		tax				tax 								; save in X
.b4f4	29 07		and #$07			and 	#7 							; lower 3 bits
.b4f6	f0 02		beq $b4fa			beq 	_LCNoAdd
.b4f8	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b4fa					_LCNoAdd:
.b4fa	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b4fc	90 02		bcc $b500			bcc 	_LCNoAdd2
.b4fe	09 20		ora #$20			ora 	#32 						; adds $20
.b500					_LCNoAdd2:
.b500	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b502					_LCPunctuation:
.b502	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b504	d0 03		bne $b509			bne 	_LCPContinue
.b506	20 db b5	jsr $b5db			jsr 	LCLDeleteLastSpace
.b509					_LCPContinue:
.b509	c8		iny				iny 								; consume character
.b50a	20 c5 b5	jsr $b5c5			jsr 	LCLWrite 					; write it out.
.b50d	80 a7		bra $b4b6			bra 	_LCMainLoop 				; go round again.
.b50f					_LCIdentifiers:
.b50f	18		clc				clc 								; convert to physical address
.b510	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b512	85 37		sta $37				sta 	zTemp0+1
.b514	c8		iny				iny
.b515	b1 30		lda ($30),y			lda 	(codePtr),y
.b517	85 36		sta $36				sta 	zTemp0
.b519	c8		iny				iny
.b51a	5a		phy				phy 								; save position
.b51b	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b51d	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b520	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b522					_LCOutIdentifier:
.b522	c8		iny				iny
.b523	b1 36		lda ($36),y			lda 	(zTemp0),y
.b525	29 7f		and #$7f			and 	#$7F
.b527	20 17 b6	jsr $b617			jsr 	LCLLowerCase
.b52a	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b52d	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b52f	10 f1		bpl $b522			bpl 	_LCOutIdentifier
.b531	7a		ply				ply 								; restore position
.b532	80 82		bra $b4b6			bra 	_LCMainLoop
.b534					_LCTokens:
.b534	aa		tax				tax 								; token in X
.b535	a9 2d		lda #$2d			lda 	#((KeywordSet2) & $FF)
.b537	85 36		sta $36				sta 	0+zTemp0
.b539	a9 bd		lda #$bd			lda 	#((KeywordSet2) >> 8)
.b53b	85 37		sta $37				sta 	1+zTemp0
.b53d	e0 82		cpx #$82			cpx 	#$82
.b53f	f0 16		beq $b557			beq 	_LCUseShift
.b541	a9 da		lda #$da			lda 	#((KeywordSet1) & $FF)
.b543	85 36		sta $36				sta 	0+zTemp0
.b545	a9 bc		lda #$bc			lda 	#((KeywordSet1) >> 8)
.b547	85 37		sta $37				sta 	1+zTemp0
.b549	e0 81		cpx #$81			cpx 	#$81
.b54b	f0 0a		beq $b557			beq 	_LCUseShift
.b54d	a9 dd		lda #$dd			lda 	#((KeywordSet0) & $FF)
.b54f	85 36		sta $36				sta 	0+zTemp0
.b551	a9 ba		lda #$ba			lda 	#((KeywordSet0) >> 8)
.b553	85 37		sta $37				sta 	1+zTemp0
.b555	80 01		bra $b558			bra 	_LCNoShift
.b557					_LCUseShift:
.b557	c8		iny				iny
.b558					_LCNoShift:
.b558	20 ef b5	jsr $b5ef			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b55b	b1 30		lda ($30),y			lda 	(codePtr),y
.b55d	aa		tax				tax 								; into X
.b55e					_LCFindText:
.b55e	ca		dex				dex
.b55f	10 0e		bpl $b56f			bpl 	_LCFoundText 				; found text.
.b561	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b563	1a		inc a				inc 	a 							; one extra for size
.b564	38		sec				sec 								; one extra for checksum
.b565	65 36		adc $36				adc 	zTemp0 						; go to next token
.b567	85 36		sta $36				sta 	zTemp0
.b569	90 f3		bcc $b55e			bcc 	_LCFindText
.b56b	e6 37		inc $37				inc 	zTemp0+1
.b56d	80 ef		bra $b55e			bra 	_LCFindText
.b56f					_LCFoundText:
.b56f	5a		phy				phy 								; save List position
.b570	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b572	aa		tax				tax
.b573	a9 83		lda #$83			lda 	#CLIToken+$80
.b575	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b578	a0 02		ldy #$02			ldy 	#2
.b57a					_LCCopyToken:
.b57a	b1 36		lda ($36),y			lda 	(zTemp0),y
.b57c	20 17 b6	jsr $b617			jsr 	LCLLowerCase
.b57f	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b582	c8		iny				iny
.b583	ca		dex				dex
.b584	d0 f4		bne $b57a			bne 	_LCCopyToken
.b586	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b588	f0 05		beq $b58f			beq 	_LCNoSpace
.b58a	a9 20		lda #$20			lda 	#' '
.b58c	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b58f					_LCNoSpace:
.b58f	7a		ply				ply 								; restore position.
.b590	c8		iny				iny 								; consume token
.b591	4c b6 b4	jmp $b4b6			jmp 	_LCMainLoop 				; and go around again.
.b594					_LCData:
.b594	48		pha				pha 								; save type $FE/$FF
.b595	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b597	c9 fe		cmp #$fe			cmp 	#$FE
.b599	f0 07		beq $b5a2			beq 	_LCHaveOpener
.b59b	a2 22		ldx #$22			ldx 	#'"'
.b59d	a9 81		lda #$81			lda 	#CLIData+$80
.b59f	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b5a2					_LCHaveOpener:
.b5a2	8a		txa				txa 								; output prefix (# or ")
.b5a3	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b5a6	c8		iny				iny 								; get count
.b5a7	b1 30		lda ($30),y			lda 	(codePtr),y
.b5a9	aa		tax				tax
.b5aa	c8		iny				iny 								; point at first character
.b5ab					_LCOutData:
.b5ab	b1 30		lda ($30),y			lda 	(codePtr),y
.b5ad	c9 00		cmp #$00			cmp 	#0
.b5af	f0 03		beq $b5b4			beq 	_LCNoPrint
.b5b1	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b5b4					_LCNoPrint:
.b5b4	c8		iny				iny
.b5b5	ca		dex				dex
.b5b6	d0 f3		bne $b5ab			bne 	_LCOutData
.b5b8	68		pla				pla 								; closing " required ?
.b5b9	c9 ff		cmp #$ff			cmp 	#$FF
.b5bb	d0 05		bne $b5c2			bne 	_LCNoQuote
.b5bd	a9 22		lda #$22			lda 	#'"'
.b5bf	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b5c2					_LCNoQuote:
.b5c2	4c b6 b4	jmp $b4b6			jmp 	_LCMainLoop
.b5c5					LCLWrite:
.b5c5	da		phx				phx
.b5c6	ae 9d 04	ldx $049d			ldx 	tbOffset
.b5c9	9d ac 04	sta $04ac,x			sta 	tokenBuffer,x
.b5cc	9e ad 04	stz $04ad,x			stz 	tokenBuffer+1,x
.b5cf	ee 9d 04	inc $049d			inc 	tbOffset
.b5d2	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b5d4	30 03		bmi $b5d9			bmi 	_LCLNoColour
.b5d6	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b5d9					_LCLNoColour:
.b5d9	fa		plx				plx
.b5da	60		rts				rts
.b5db					LCLDeleteLastSpace:
.b5db	48		pha				pha
.b5dc	da		phx				phx
.b5dd	ae 9d 04	ldx $049d			ldx 	tbOffset
.b5e0	f0 0a		beq $b5ec			beq 	_LCDLSExit
.b5e2	bd ab 04	lda $04ab,x			lda 	tokenBuffer-1,x
.b5e5	c9 20		cmp #$20			cmp 	#' '
.b5e7	d0 03		bne $b5ec			bne 	_LCDLSExit
.b5e9	ce 9d 04	dec $049d			dec 	tbOffset
.b5ec					_LCDLSExit:
.b5ec	fa		plx				plx
.b5ed	68		pla				pla
.b5ee	60		rts				rts
.b5ef					LCLCheckSpaceRequired:
.b5ef	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b5f2	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b5f4	f0 1b		beq $b611			beq 	_LCCSRSpace
.b5f6	c9 29		cmp #$29			cmp 	#')'
.b5f8	f0 17		beq $b611			beq 	_LCCSRSpace
.b5fa	c9 23		cmp #$23			cmp 	#'#'
.b5fc	f0 13		beq $b611			beq 	_LCCSRSpace
.b5fe	20 17 b6	jsr $b617			jsr 	LCLLowerCase 				; saves a little effort
.b601	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b603	90 11		bcc $b616			bcc 	_LCCSRExit
.b605	c9 3a		cmp #$3a			cmp 	#"9"+1
.b607	90 08		bcc $b611			bcc 	_LCCSRSpace
.b609	c9 61		cmp #$61			cmp 	#"a"
.b60b	90 09		bcc $b616			bcc 	_LCCSRExit
.b60d	c9 7b		cmp #$7b			cmp 	#"z"+1
.b60f	b0 05		bcs $b616			bcs 	_LCCSRExit
.b611					_LCCSRSpace:
.b611	a9 20		lda #$20			lda 	#' '
.b613	20 c5 b5	jsr $b5c5			jsr 	LCLWrite
.b616					_LCCSRExit:
.b616	60		rts				rts
.b617					LCLLowerCase:
.b617	c9 41		cmp #$41			cmp 	#"A"
.b619	90 06		bcc $b621			bcc 	_LCLLCOut
.b61b	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b61d	b0 02		bcs $b621			bcs 	_LCLLCOut
.b61f	69 20		adc #$20			adc 	#$20
.b621					_LCLLCOut:
.b621	60		rts				rts
.b622					LCLUpperCase:
.b622	c9 61		cmp #$61			cmp 	#"a"
.b624	90 06		bcc $b62c			bcc 	_LCLUCOut
.b626	c9 7b		cmp #$7b			cmp 	#"z"+1
.b628	b0 02		bcs $b62c			bcs 	_LCLUCOut
.b62a	e9 1f		sbc #$1f			sbc 	#$1F
.b62c					_LCLUCOut:
.b62c	60		rts				rts
.b62d					TOKSearchTable:
.b62d	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token.
.b62f	85 36		sta $36				sta 	zTemp0
.b631	a0 00		ldy #$00			ldy 	#0
.b633	a9 80		lda #$80			lda 	#$80 						; token #
.b635	85 38		sta $38				sta 	zTemp1
.b637					_TSTLoop:
.b637	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b639	30 49		bmi $b684			bmi 	_TSTFail 					; -ve = end of table
.b63b	f0 2e		beq $b66b			beq 	_TSTNext 					; zero, check next it's a dummy
.b63d	c8		iny				iny 								; get the hash
.b63e	b1 36		lda ($36),y			lda 	(zTemp0),y
.b640	88		dey				dey
.b641	cd 83 04	cmp $0483			cmp 	identHash 					; check they match, if not go to next
.b644	d0 25		bne $b66b			bne 	_TSTNext
.b646	ad 82 04	lda $0482			lda 	identTypeEnd 				; length of identifier
.b649	38		sec				sec
.b64a	ed 80 04	sbc $0480			sbc 	identStart
.b64d	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; no match, then return.
.b64f	d0 1a		bne $b66b			bne 	_TSTNext
.b651	5a		phy				phy 								; save Y , we might fail
.b652	c8		iny				iny 								; point to text
.b653	c8		iny				iny
.b654	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b657					_TSTCompareName:
.b657	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; compare text.
.b65a	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b65c	d0 0c		bne $b66a			bne 	_TSTNextPullY 				; fail, pullY and do next
.b65e	e8		inx				inx
.b65f	c8		iny				iny
.b660	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b663	d0 f2		bne $b657			bne 	_TSTCompareName
.b665	7a		ply				ply 								; throw Y
.b666	a5 38		lda $38				lda 	zTemp1 						; get token #
.b668	38		sec				sec 								; return with CS = passed.
.b669	60		rts				rts
.b66a					_TSTNextPullY:
.b66a	7a		ply				ply 								; restore current, fall through.
.b66b					_TSTNext:
.b66b	e6 38		inc $38				inc 	zTemp1 						; token counter
.b66d	98		tya				tya
.b66e	18		clc				clc
.b66f	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b671	1a		inc a				inc 	a 							; +1
.b672	1a		inc a				inc 	a 							; +2
.b673	a8		tay				tay
.b674	10 c1		bpl $b637			bpl 	_TSTLoop 					; if Y < $80 loop back
.b676	98		tya				tya 								; add Y to zTemp0 and reset Y
.b677	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b679	18		clc				clc  								; but have tables > 255 bytes
.b67a	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b67c	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b67e	90 b7		bcc $b637			bcc 	_TSTLoop
.b680	e6 37		inc $37				inc 	zTemp0+1
.b682	80 b3		bra $b637			bra 	_TSTLoop
.b684					_TSTFail:
.b684	18		clc				clc
.b685	60		rts				rts
.b686					TokeniseLine:
.b686	20 0e b8	jsr $b80e			jsr 	LCLFixLineBufferCase 		; fix line case
.b689	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b68b	8d a9 04	sta $04a9			sta 	tokenOffset
.b68e	9c aa 04	stz $04aa			stz 	tokenLineNumber
.b691	9c ab 04	stz $04ab			stz 	tokenLineNumber+1
.b694	a2 ff		ldx #$ff			ldx 	#$FF
.b696					_TKFindFirst:
.b696	e8		inx				inx
.b697	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b69a	f0 79		beq $b715			beq 	_TKExit
.b69c	c9 20		cmp #$20			cmp 	#' '
.b69e	90 f6		bcc $b696			bcc 	_TKFindFirst
.b6a0	c9 30		cmp #$30			cmp 	#'0'
.b6a2	90 07		bcc $b6ab			bcc 	_TKNoLineNumber
.b6a4	c9 3a		cmp #$3a			cmp 	#'9'+1
.b6a6	b0 03		bcs $b6ab			bcs 	_TKNoLineNumber
.b6a8	20 38 b8	jsr $b838			jsr 	TOKExtractLineNumber
.b6ab					_TKNoLineNumber:
.b6ab					_TKTokeniseLoop:
.b6ab	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b6ae	f0 65		beq $b715			beq 	_TKExit
.b6b0	e8		inx				inx
.b6b1	c9 20		cmp #$20			cmp 	#' '
.b6b3	f0 f6		beq $b6ab			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b6b5	ca		dex				dex 								; undo last get, A contains character, X is position.
.b6b6	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b6b8	f0 61		beq $b71b			beq 	_TKTokeniseIdentifier
.b6ba	c9 41		cmp #$41			cmp 	#'A'
.b6bc	90 04		bcc $b6c2			bcc 	_TKTokenisePunctuation
.b6be	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b6c0	90 59		bcc $b71b			bcc 	_TKTokeniseIdentifier
.b6c2					_TKTokenisePunctuation:
.b6c2	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b6c4	f0 27		beq $b6ed			beq 	_TKString
.b6c6	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant (# only appears at end of identifiers)
.b6c8	f0 28		beq $b6f2			beq 	_TKHexConstant
.b6ca	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers.
.b6cc	f0 29		beq $b6f7			beq 	_TKCheckDouble
.b6ce	c9 3e		cmp #$3e			cmp 	#'>'
.b6d0	f0 25		beq $b6f7			beq 	_TKCheckDouble
.b6d2					_TKStandardPunctuation:
.b6d2	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get it back.
.b6d5	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b6d7	90 0e		bcc $b6e7			bcc 	_TKNoShift
.b6d9	48		pha				pha 								; save
.b6da	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b6dc	85 36		sta $36				sta 	zTemp0
.b6de	68		pla				pla
.b6df	29 20		and #$20			and 	#32 						; bit 5
.b6e1	4a		lsr a				lsr 	a 							; shift into bit 3
.b6e2	4a		lsr a				lsr 	a
.b6e3	05 36		ora $36				ora 	zTemp0
.b6e5	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b6e7					_TKNoShift:
.b6e7	20 7d b8	jsr $b87d			jsr 	TOKWriteByte 				; write the punctuation character
.b6ea	e8		inx				inx 								; consume the character
.b6eb	80 be		bra $b6ab			bra 	_TKTokeniseLoop 			; and loop round again.
.b6ed					_TKString:
.b6ed	20 9d b7	jsr $b79d			jsr 	TOKTokenString
.b6f0	80 b9		bra $b6ab			bra 	_TKTokeniseLoop
.b6f2					_TKHexConstant:
.b6f2	20 d8 b7	jsr $b7d8			jsr 	TOKHexConstant
.b6f5	80 b4		bra $b6ab			bra 	_TKTokeniseLoop
.b6f7					_TKCheckDouble:
.b6f7	bd aa 05	lda $05aa,x			lda 	lineBuffer+1,x 				; get next character
.b6fa	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b6fc	90 d4		bcc $b6d2			bcc 	_TKStandardPunctuation
.b6fe	c9 3f		cmp #$3f			cmp 	#'>'+1
.b700	b0 d0		bcs $b6d2			bcs 	_TKStandardPunctuation
.b702	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b705	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b707	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b708	7d aa 05	adc $05aa,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b70b	38		sec				sec
.b70c	e9 3c		sbc #$3c			sbc 	#'<'
.b70e	20 7d b8	jsr $b87d			jsr 	TOKWriteByte 				; this is in the range 0-7
.b711	e8		inx				inx 								; consume both
.b712	e8		inx				inx
.b713	80 96		bra $b6ab			bra 	_TKTokeniseLoop
.b715	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b717	20 7d b8	jsr $b87d			jsr 	TOKWriteByte
.b71a	60		rts				rts
.b71b					_TKTokeniseIdentifier:
.b71b	8e 80 04	stx $0480			stx 	identStart 					; save start
.b71e	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b721					_TKCheckLoop:
.b721	e8		inx				inx 								; look at next, we know first is identifier.
.b722	bd a9 05	lda $05a9,x			lda  	lineBuffer,x
.b725	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b727	f0 f8		beq $b721			beq 	_TKCheckLoop
.b729	c9 30		cmp #$30			cmp	 	#"0"
.b72b	90 0c		bcc $b739			bcc 	_TKEndIdentifier
.b72d	c9 3a		cmp #$3a			cmp 	#"9"+1
.b72f	90 f0		bcc $b721			bcc 	_TKCheckLoop
.b731	c9 41		cmp #$41			cmp	 	#"A"
.b733	90 04		bcc $b739			bcc 	_TKEndIdentifier
.b735	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b737	90 e8		bcc $b721			bcc 	_TKCheckLoop
.b739					_TKEndIdentifier:
.b739	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b73c	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b73e	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b740	f0 06		beq $b748			beq 	_TKHasTypeCharacter
.b742	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b744	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b746	d0 07		bne $b74f			bne 	_TKNoTypeCharacter
.b748					_TKHasTypeCharacter:
.b748	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b74b	e8		inx				inx 								; read next
.b74c	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b74f					_TKNoTypeCharacter:
.b74f	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b751	d0 09		bne $b75c			bne 	_TKNoArray
.b753	e8		inx				inx 								; skip the (
.b754	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array)
.b757	09 04		ora #$04			ora 	#$04
.b759	8d 84 04	sta $0484			sta 	identTypeByte
.b75c					_TKNoArray:
.b75c	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b75f	20 f9 b7	jsr $b7f9			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b762	a0 ba		ldy #$ba			ldy 	#(KeywordSet0) >> 8
.b764	a9 dd		lda #$dd			lda 	#(KeywordSet0) & $FF
.b766	20 2d b6	jsr $b62d			jsr 	TOKSearchTable
.b769	a2 00		ldx #$00			ldx 	#0
.b76b	b0 1f		bcs $b78c			bcs 	_TKFoundToken
.b76d	a0 bc		ldy #$bc			ldy 	#(KeywordSet1) >> 8
.b76f	a9 da		lda #$da			lda 	#(KeywordSet1) & $FF
.b771	20 2d b6	jsr $b62d			jsr 	TOKSearchTable
.b774	a2 81		ldx #$81			ldx 	#$81
.b776	b0 14		bcs $b78c			bcs 	_TKFoundToken
.b778	a0 bd		ldy #$bd			ldy 	#(KeywordSet2) >> 8
.b77a	a9 2d		lda #$2d			lda 	#(KeywordSet2) & $FF
.b77c	20 2d b6	jsr $b62d			jsr 	TOKSearchTable
.b77f	a2 82		ldx #$82			ldx 	#$82
.b781	b0 09		bcs $b78c			bcs 	_TKFoundToken
.b783	20 89 b8	jsr $b889			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b786	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b789	4c ab b6	jmp $b6ab			jmp 	_TKTokeniseLoop 			; and go round again.
.b78c					_TKFoundToken:
.b78c	48		pha				pha 								; save token
.b78d	8a		txa				txa 								; shift in X, is there one ?
.b78e	f0 03		beq $b793			beq 	_TKNoTShift
.b790	20 7d b8	jsr $b87d			jsr 	TOKWriteByte 				; if so, write it out
.b793					_TKNoTShift:
.b793	68		pla				pla 								; restore and write token
.b794	20 7d b8	jsr $b87d			jsr 	TOKWriteByte
.b797	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b79a	4c ab b6	jmp $b6ab			jmp 	_TKTokeniseLoop 			; and go round again.
.b79d					TOKTokenString:
.b79d	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b79f	20 7d b8	jsr $b87d			jsr 	TOKWriteByte
.b7a2	e8		inx				inx									; start of quoted string.
.b7a3	da		phx				phx 								; push start of string on top
.b7a4	ca		dex				dex
.b7a5					_TSFindEnd:
.b7a5	e8		inx				inx
.b7a6	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character
.b7a9	f0 04		beq $b7af			beq 	_TSEndOfString
.b7ab	c9 22		cmp #$22			cmp 	#'"'
.b7ad	d0 f6		bne $b7a5			bne 	_TSFindEnd
.b7af					_TSEndOfString:
.b7af	7a		ply				ply  								; so now Y is first character, X is character after end.
.b7b0	48		pha				pha 								; save terminating character
.b7b1	20 b9 b7	jsr $b7b9			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b7b4	68		pla				pla 								; terminating character
.b7b5	f0 01		beq $b7b8			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b7b7	e8		inx				inx
.b7b8					_TSNotQuote:
.b7b8	60		rts				rts
.b7b9					TOKWriteBlockXY:
.b7b9	86 36		stx $36				stx 	zTemp0 						; write end character
.b7bb	98		tya				tya
.b7bc	49 ff		eor #$ff			eor 	#$FF
.b7be	38		sec				sec
.b7bf	65 36		adc $36				adc 	zTemp0
.b7c1	1a		inc a				inc 	a 							; one extra for NULL
.b7c2	20 7d b8	jsr $b87d			jsr 	TOKWriteByte
.b7c5					_TOBlockLoop:
.b7c5	c4 36		cpy $36				cpy 	zTemp0
.b7c7	f0 09		beq $b7d2			beq 	_TOBlockExit
.b7c9	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y
.b7cc	20 7d b8	jsr $b87d			jsr 	TOKWriteByte
.b7cf	c8		iny				iny
.b7d0	80 f3		bra $b7c5			bra 	_TOBlockLoop
.b7d2					_TOBlockExit:
.b7d2	a9 00		lda #$00			lda 	#0
.b7d4	20 7d b8	jsr $b87d			jsr 	TOKWriteByte
.b7d7	60		rts				rts
.b7d8					TOKHexConstant:
.b7d8	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b7da	20 7d b8	jsr $b87d			jsr 	TOKWriteByte
.b7dd	e8		inx				inx									; start of quoted string.
.b7de	da		phx				phx 								; push start of constant on top
.b7df	ca		dex				dex
.b7e0					_THFindLoop:
.b7e0	e8		inx				inx
.b7e1	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b7e4	c9 30		cmp #$30			cmp 	#"0"
.b7e6	90 0c		bcc $b7f4			bcc 	_THFoundEnd
.b7e8	c9 3a		cmp #$3a			cmp 	#"9"+1
.b7ea	90 f4		bcc $b7e0			bcc 	_THFindLoop
.b7ec	c9 41		cmp #$41			cmp 	#"A"
.b7ee	90 04		bcc $b7f4			bcc 	_THFoundEnd
.b7f0	c9 47		cmp #$47			cmp 	#"F"+1
.b7f2	90 ec		bcc $b7e0			bcc 	_THFindLoop
.b7f4					_THFoundEnd:
.b7f4	7a		ply				ply 								; restore start
.b7f5	20 b9 b7	jsr $b7b9			jsr 	TOKWriteBlockXY 			; output the block
.b7f8	60		rts				rts
.b7f9					TOKCalculateHash:
.b7f9	da		phx				phx
.b7fa	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum
.b7fd	a9 00		lda #$00			lda 	#0
.b7ff					_TCHLoop:
.b7ff	18		clc				clc
.b800	7d a9 05	adc $05a9,x			adc 	lineBuffer,x
.b803	e8		inx				inx
.b804	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b807	d0 f6		bne $b7ff			bne 	_TCHLoop
.b809	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b80c	fa		plx				plx
.b80d	60		rts				rts
.b80e					LCLFixLineBufferCase:
.b80e	a2 00		ldx #$00			ldx 	#0
.b810					_FLBCLoop:
.b810	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next character
.b813	f0 22		beq $b837			beq 	_FLBCExit 					; end of string.
.b815	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b817	f0 11		beq $b82a			beq 	_FLBCInQuotes
.b819	e8		inx				inx
.b81a	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b81c	90 f2		bcc $b810			bcc 	_FLBCLoop
.b81e	c9 7b		cmp #$7b			cmp 	#'z'+1
.b820	b0 ee		bcs $b810			bcs 	_FLBCLoop
.b822	38		sec				sec 								; make U/C
.b823	e9 20		sbc #$20			sbc 	#32
.b825	9d a8 05	sta $05a8,x			sta	 	lineBuffer-1,x 				; write back
.b828	80 e6		bra $b810			bra 	_FLBCLoop
.b82a					_FLBCInQuotes:
.b82a	e8		inx				inx 								; advance
.b82b	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next
.b82e	f0 07		beq $b837			beq 	_FLBCExit 					; exit on EOS
.b830	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b832	d0 f6		bne $b82a			bne 	_FLBCInQuotes
.b834	e8		inx				inx 								; skip over it
.b835	80 d9		bra $b810			bra 	_FLBCLoop
.b837					_FLBCExit:
.b837	60		rts				rts
.b838					TOKExtractLineNumber:
.b838	ad ab 04	lda $04ab			lda 	tokenLineNumber+1 			; push current value on stack
.b83b	48		pha				pha
.b83c	ad aa 04	lda $04aa			lda 	tokenLineNumber
.b83f	48		pha				pha
.b840	20 76 b8	jsr $b876			jsr 	_LCLNTimes2 				; line # x 4
.b843	20 76 b8	jsr $b876			jsr 	_LCLNTimes2 				; line # x 2
.b846	18		clc				clc 								; add stacked value
.b847	68		pla				pla
.b848	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b84b	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b84e	68		pla				pla
.b84f	6d ab 04	adc $04ab			adc 	tokenLineNumber+1
.b852	8d ab 04	sta $04ab			sta 	tokenLineNumber+1 			; line # x 5
.b855	20 76 b8	jsr $b876			jsr 	_LCLNTimes2 				; line # x 10
.b858	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get and consume character
.b85b	e8		inx				inx
.b85c	29 0f		and #$0f			and 	#15 						; add to line #
.b85e	18		clc				clc
.b85f	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b862	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b865	90 03		bcc $b86a			bcc 	_TLENNoCarry
.b867	ee ab 04	inc $04ab			inc 	tokenLineNumber+1
.b86a					_TLENNoCarry:
.b86a	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; more digits ?
.b86d	c9 30		cmp #$30			cmp 	#'0'
.b86f	90 04		bcc $b875			bcc 	_TLENExit
.b871	c9 3a		cmp #$3a			cmp 	#'9'+1
.b873	90 c3		bcc $b838			bcc 	TOKExtractLineNumber
.b875					_TLENExit:
.b875	60		rts				rts
.b876					_LCLNTimes2:
.b876	0e aa 04	asl $04aa			asl 	tokenLineNumber
.b879	2e ab 04	rol $04ab			rol 	tokenLineNumber+1
.b87c	60		rts				rts
.b87d					TOKWriteByte:
.b87d	da		phx				phx
.b87e	ae a9 04	ldx $04a9			ldx 	tokenOffset 				; next slot to write to
.b881	9d a9 04	sta $04a9,x			sta 	tokenOffset,x 				; write byte out
.b884	ee a9 04	inc $04a9			inc 	tokenOffset 				; advance slot.
.b887	fa		plx				plx
.b888	60		rts				rts
.b889					TOKCheckCreateVariableRecord:
.b889	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b88b	85 36		sta $36				sta 	0+zTemp0
.b88d	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b88f	85 37		sta $37				sta 	1+zTemp0
.b891					_CCVSearch:
.b891	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b893	f0 2c		beq $b8c1			beq 	_CCVFail
.b895	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b897	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b899	cd 83 04	cmp $0483			cmp 	identHash
.b89c	d0 16		bne $b8b4			bne 	_CCVNext
.b89e	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b8a0	ae 80 04	ldx $0480			ldx 	identStart
.b8a3					_CCVCompare:
.b8a3	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b8a6	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b8a8	e8		inx				inx 								; advance pointers
.b8a9	c8		iny				iny
.b8aa	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b8ab	d0 07		bne $b8b4			bne 	_CCVNext  					; didn't match go to next.
.b8ad	90 f4		bcc $b8a3			bcc 	_CCVCompare 				; not finished yet.
.b8af	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b8b2	f0 41		beq $b8f5			beq 	_CCVFound 					; yes, we were successful
.b8b4					_CCVNext:
.b8b4	18		clc				clc
.b8b5	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b8b7	65 36		adc $36				adc 	zTemp0
.b8b9	85 36		sta $36				sta 	zTemp0
.b8bb	90 d4		bcc $b891			bcc 	_CCVSearch
.b8bd	e6 37		inc $37				inc 	zTemp0+1
.b8bf	80 d0		bra $b891			bra 	_CCVSearch
.b8c1					_CCVFail:
.b8c1	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b8c3	ad 83 04	lda $0483			lda 	identHash
.b8c6	91 36		sta ($36),y			sta 	(zTemp0),y
.b8c8	c8		iny				iny 								; offset 2 is the type byte
.b8c9	ad 84 04	lda $0484			lda 	identTypeByte
.b8cc	91 36		sta ($36),y			sta 	(zTemp0),y
.b8ce	c8		iny				iny
.b8cf					_CCVData:
.b8cf	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b8d1	91 36		sta ($36),y			sta 	(zTemp0),y
.b8d3	c8		iny				iny
.b8d4	c0 08		cpy #$08			cpy 	#8
.b8d6	90 f7		bcc $b8cf			bcc 	_CCVData
.b8d8	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b8db					_CCVCopyName:
.b8db	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b8de	91 36		sta ($36),y			sta 	(zTemp0),y
.b8e0	e8		inx				inx
.b8e1	c8		iny				iny
.b8e2	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b8e5	d0 f4		bne $b8db			bne 	_CCVCopyName
.b8e7	98		tya				tya 								; patch offset
.b8e8	92 36		sta ($36)			sta 	(zTemp0)
.b8ea	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b8ec	91 36		sta ($36),y			sta 	(zTemp0),y
.b8ee	88		dey				dey
.b8ef	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b8f1	09 80		ora #$80			ora 	#$80
.b8f3	91 36		sta ($36),y			sta 	(zTemp0),y
.b8f5					_CCVFound:
.b8f5	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b8f7	38		sec				sec
.b8f8	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b8fa	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b8fc	20 7d b8	jsr $b87d			jsr 	TOKWriteByte
.b8ff	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b901	20 7d b8	jsr $b87d			jsr 	TOKWriteByte
.b904	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b905					SNDCheckChannel:
.b905	aa		tax				tax
.b906	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b909	d0 38		bne $b943			bne 	_SNDCCExit
.b90b	da		phx				phx 								; save current channel
.b90c	8a		txa				txa 								; put in A
.b90d	20 89 b9	jsr $b989			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b910	68		pla				pla 								; channel # in A
.b911	90 30		bcc $b943			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b913	a8		tay				tay 								; Y is the channel #
.b914	bd ff 06	lda $06ff,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b917	99 fe 07	sta $07fe,y			sta 	SNDPitchLow,y
.b91a	bd 00 07	lda $0700,x			lda 	SNDQueue+2,x
.b91d	99 02 08	sta $0802,y			sta 	SNDPitchHigh,y
.b920	bd 01 07	lda $0701,x			lda 	SNDQueue+3,x
.b923	99 06 08	sta $0806,y			sta 	SNDVolume,y
.b926	bd 02 07	lda $0702,x			lda 	SNDQueue+4,x
.b929	99 0a 08	sta $080a,y			sta 	SNDTimeLeft,y
.b92c	bd 03 07	lda $0703,x			lda 	SNDQueue+5,x
.b92f	99 0e 08	sta $080e,y			sta 	SNDAdjustLow,y
.b932	bd 04 07	lda $0704,x			lda 	SNDQueue+6,x
.b935	99 12 08	sta $0812,y			sta 	SNDAdjustHigh,y
.b938	5a		phy				phy 								; save channel #
.b939	20 a3 b9	jsr $b9a3			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b93c	ce fd 06	dec $06fd			dec 	SNDLength 					; reduce the queue length.
.b93f	68		pla				pla
.b940	20 44 b9	jsr $b944			jsr 	SNDUpdateNote 				; update channel A
.b943					_SNDCCExit:
.b943	60		rts				rts
.b944					SNDUpdateNote:
.b944	aa		tax				tax 								; so we can access records
.b945	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b946	0a		asl a				asl 	a
.b947	0a		asl a				asl 	a
.b948	0a		asl a				asl 	a
.b949	0a		asl a				asl 	a
.b94a	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b94d	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; are we silent
.b950	f0 2e		beq $b980			beq 	_SNDUNIsSilent
.b952	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; push channel bits on stack
.b955	48		pha				pha
.b956	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b959	29 0f		and #$0f			and 	#$0F
.b95b	0d fc 06	ora $06fc			ora 	SNDChannelBits 				; set channel bits
.b95e	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b960	20 ed b9	jsr $b9ed			jsr 	SNDWritePorts
.b963	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b966	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b969	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.b96c	4e fc 06	lsr $06fc			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b96f	6a		ror a				ror 	a
.b970	4e fc 06	lsr $06fc			lsr 	SNDChannelBits
.b973	6a		ror a				ror 	a
.b974	4a		lsr a				lsr 	a 							; put in bits 0-5
.b975	4a		lsr a				lsr 	a
.b976	20 ed b9	jsr $b9ed			jsr 	SNDWritePorts 				; write as rest of pitch register
.b979	68		pla				pla
.b97a	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b97c	20 ed b9	jsr $b9ed			jsr 	SNDWritePorts
.b97f	60		rts				rts
.b980					_SNDUNIsSilent:
.b980	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; channel bits
.b983	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b985	20 ed b9	jsr $b9ed			jsr 	SNDWritePorts 				; write to the ports
.b988	60		rts				rts
.b989					SNDFindNextNoteForA:
.b989	ac fd 06	ldy $06fd			ldy 	SNDLength 					; queue size into Y
.b98c	f0 13		beq $b9a1			beq 	_SNDFNNFail 				; queue empty.
.b98e	a2 00		ldx #$00			ldx 	#0
.b990					_SNDFNNSearch:
.b990	dd fe 06	cmp $06fe,x			cmp 	SNDQueue,x 					; does it match the channel
.b993	38		sec				sec
.b994	f0 0c		beq $b9a2			beq 	_SNDFNNExit 				; if so exit with CS.
.b996	e8		inx				inx 								; next queue slot.
.b997	e8		inx				inx
.b998	e8		inx				inx
.b999	e8		inx				inx
.b99a	e8		inx				inx
.b99b	e8		inx				inx
.b99c	e8		inx				inx
.b99d	e8		inx				inx
.b99e	88		dey				dey 								; done the whole queue
.b99f	d0 ef		bne $b990			bne 	_SNDFNNSearch 				; no, go back.
.b9a1					_SNDFNNFail:
.b9a1	18		clc				clc
.b9a2					_SNDFNNexit:
.b9a2	60		rts				rts
.b9a3					SNDDeleteXFromQueue:
.b9a3	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b9a5	f0 09		beq $b9b0			beq 	_SNDDXExit
.b9a7	bd 06 07	lda $0706,x			lda 	SNDQueue+8,x
.b9aa	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9ad	e8		inx				inx
.b9ae	80 f3		bra $b9a3			bra 	SNDDeleteXFromQueue
.b9b0					_SNDDXExit:
.b9b0	60		rts				rts
.06fc					SNDChannelBits:
>06fc							.fill 	1
.b9b1					SNDQueueRequest:
.b9b1	86 36		stx $36				stx 	zTemp0						; save queue address
.b9b3	84 37		sty $37				sty 	zTemp0+1
.b9b5	ae fd 06	ldx $06fd			ldx 	SNDLength 					; queue is full, can't take any more.
.b9b8	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b9ba	f0 21		beq $b9dd			beq 	_SNDQRExit
.b9bc	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b9be	48		pha				pha
.b9bf	8a		txa				txa  								; get offset in queue buffer/
.b9c0	0a		asl a				asl 	a
.b9c1	0a		asl a				asl 	a
.b9c2	0a		asl a				asl 	a
.b9c3	aa		tax				tax
.b9c4	68		pla				pla 								; get back and push again
.b9c5	48		pha				pha
.b9c6	9d fe 06	sta $06fe,x			sta 	SNDQueue+0,x 				; save the channel #
.b9c9	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b9cb					_SNDQCopy:
.b9cb	b1 36		lda ($36),y			lda 	(zTemp0),y
.b9cd	e8		inx				inx
.b9ce	c8		iny				iny
.b9cf	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9d2	c0 06		cpy #$06			cpy 	#6
.b9d4	d0 f5		bne $b9cb			bne 	_SNDQCopy
.b9d6	ee fd 06	inc $06fd			inc 	SNDLength 					; bump queue length.
.b9d9	68		pla				pla 								; get channel # back
.b9da	20 05 b9	jsr $b905			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b9dd					_SNDQRExit:
.b9dd	60		rts				rts
.b9de					SNDSilenceChannel:
.b9de	aa		tax				tax 								; zero time left.
.b9df	9e 0a 08	stz $080a,x			stz 	SNDTimeLeft,x
.b9e2	0a		asl a				asl 	a 							; shift into position
.b9e3	0a		asl a				asl 	a
.b9e4	0a		asl a				asl 	a
.b9e5	0a		asl a				asl 	a
.b9e6	0a		asl a				asl 	a
.b9e7	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b9e9	20 ed b9	jsr $b9ed			jsr 	SNDWritePorts
.b9ec	60		rts				rts
.b9ed					SNDWritePorts:
.b9ed	64 01		stz $01				stz 	1
.b9ef	8d 00 d6	sta $d600			sta 	$D600
.b9f2	8d 10 d6	sta $d610			sta 	$D610
.b9f5	60		rts				rts
.b9f6					SNDCommand:
.b9f6	da		phx				phx
.b9f7	5a		phy				phy
.b9f8	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b9fa	f0 1d		beq $ba19			beq 	_SNDInitialise
.b9fc	90 28		bcc $ba26			bcc 	_SNDExit
.b9fe	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.ba00	f0 17		beq $ba19			beq 	_SNDSilence
.ba02	b0 22		bcs $ba26			bcs 	_SNDExit
.ba04	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.ba06	b0 09		bcs $ba11			bcs 	_SNDQueryPlay
.ba08	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.ba0a	b0 1a		bcs $ba26			bcs 	_SNDExit
.ba0c	20 b1 b9	jsr $b9b1			jsr 	SNDQueueRequest
.ba0f	80 15		bra $ba26			bra 	_SNDExit
.ba11					_SNDQueryPlay:
.ba11	29 03		and #$03			and 	#3 							; get channel #
.ba13	aa		tax				tax
.ba14	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.ba17	80 0d		bra $ba26			bra 	_SNDExit
.ba19					_SNDInitialise:
.ba19					_SNDSilence:
.ba19	9c fd 06	stz $06fd			stz 	SNDLength 					; empty the queue.
.ba1c	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.ba1e					_SNDSilenceLoop:
.ba1e	48		pha				pha
.ba1f	20 de b9	jsr $b9de			jsr 	SNDSilenceChannel
.ba22	68		pla				pla
.ba23	3a		dec a				dec 	a
.ba24	10 f8		bpl $ba1e			bpl 	_SNDSilenceLoop
.ba26					_SNDExit:
.ba26	7a		ply				ply
.ba27	fa		plx				plx
.ba28	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fd					SNDLength:
>06fd							.fill 	1
.06fe					SNDQueue:
>06fe							.fill 	SNDQueueSize * 8
.07fe					SNDPitchLow:
>07fe							.fill 	4
.0802					SNDPitchHigh:
>0802							.fill 	4
.0806					SNDVolume:
>0806							.fill 	4
.080a					SNDTimeLeft:
>080a							.fill 	4
.080e					SNDAdjustLow:
>080e							.fill 	4
.0812					SNDAdjustHigh:
>0812							.fill 	4
.ba29					SNDUpdate:
.ba29	ad 0a 08	lda $080a			lda 	SNDTimeLeft+0 				; look at time remaining
.ba2c	f0 05		beq $ba33			beq 	_SNDUNot0 					; not playing
.ba2e	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.ba30	20 52 ba	jsr $ba52			jsr 	SNDUpdateChannel 			; update it.
.ba33					_SNDUNot0:
.ba33	ad 0b 08	lda $080b			lda 	SNDTimeLeft+1
.ba36	f0 05		beq $ba3d			beq 	_SNDUNot1
.ba38	a2 01		ldx #$01			ldx 	#1
.ba3a	20 52 ba	jsr $ba52			jsr 	SNDUpdateChannel
.ba3d					_SNDUNot1:
.ba3d	ad 0c 08	lda $080c			lda 	SNDTimeLeft+2
.ba40	f0 05		beq $ba47			beq 	_SNDUNot2
.ba42	a2 02		ldx #$02			ldx 	#2
.ba44	20 52 ba	jsr $ba52			jsr 	SNDUpdateChannel
.ba47					_SNDUNot2:
.ba47	ad 0d 08	lda $080d			lda 	SNDTimeLeft+3
.ba4a	f0 05		beq $ba51			beq 	_SNDUNot3
.ba4c	a2 03		ldx #$03			ldx 	#3
.ba4e	20 52 ba	jsr $ba52			jsr 	SNDUpdateChannel
.ba51					_SNDUNot3:
.ba51	60		rts				rts
.ba52					SNDUpdateChannel:
.ba52	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.ba54	f0 2c		beq $ba82			beq 	_SNDUCExit
.ba56	3a		dec a				dec 	a 							; decrement and update timer
.ba57	9d 0a 08	sta $080a,x			sta 	SNDTimeLeft,x
.ba5a	f0 1d		beq $ba79			beq 	_SNDUCUpdate 				; if zero, silence channel
.ba5c	bd 0e 08	lda $080e,x			lda 	SNDAdjustLow,x 				; adjust ?
.ba5f	1d 12 08	ora $0812,x			ora 	SNDAdjustHigh,x
.ba62	f0 1e		beq $ba82			beq 	_SNDUCExit 					; if zero carry on at current tone.
.ba64	18		clc				clc 								; add adjust, forcing into a 10 bit range
.ba65	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.ba68	7d 0e 08	adc $080e,x			adc 	SNDAdjustLow,x
.ba6b	9d fe 07	sta $07fe,x			sta 	SNDPitchLow,x
.ba6e	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x
.ba71	7d 12 08	adc $0812,x			adc 	SNDAdjustHigh,x
.ba74	29 03		and #$03			and 	#3
.ba76	9d 02 08	sta $0802,x			sta 	SNDPitchHigh,x
.ba79					_SNDUCUpdate:
.ba79	8a		txa				txa 								; which channel.
.ba7a	48		pha				pha
.ba7b	20 44 b9	jsr $b944			jsr 	SNDUpdateNote 				; update the current note
.ba7e	68		pla				pla
.ba7f	20 05 b9	jsr $b905			jsr 	SNDCheckChannel 			; more to do ?
.ba82					_SNDUCExit:
.ba82	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
