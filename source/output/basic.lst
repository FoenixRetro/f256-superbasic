
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Sat Dec  3 10:24:06 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$28000					 SOURCE_ADDRESS=$28000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	253
.0627					numberBuffer:
>0627							.fill 	34
.0649					decimalBuffer:
>0649							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_DEEKLPAREN                       = $87; $87 DEEK(
=$88					KWD_EVENTLPAREN                      = $88; $88 EVENT(
=$89					KWD_FALSE                            = $89; $89 FALSE
=$8a					KWD_FRACLPAREN                       = $8a; $8a FRAC(
=$8b					KWD_HITLPAREN                        = $8b; $8b HIT(
=$8c					KWD_INTLPAREN                        = $8c; $8c INT(
=$8d					KWD_ISVALLPAREN                      = $8d; $8d ISVAL(
=$8e					KWD_JOYBLPAREN                       = $8e; $8e JOYB(
=$8f					KWD_JOYXLPAREN                       = $8f; $8f JOYX(
=$90					KWD_JOYYLPAREN                       = $90; $90 JOYY(
=$91					KWD_LEFTDOLLARLPAREN                 = $91; $91 LEFT$(
=$92					KWD_LENLPAREN                        = $92; $92 LEN(
=$93					KWD_MAXLPAREN                        = $93; $93 MAX(
=$94					KWD_MIDDOLLARLPAREN                  = $94; $94 MID$(
=$95					KWD_MINLPAREN                        = $95; $95 MIN(
=$96					KWD_NOTLPAREN                        = $96; $96 NOT(
=$97					KWD_PEEKLPAREN                       = $97; $97 PEEK(
=$98					KWD_PLAYINGLPAREN                    = $98; $98 PLAYING(
=$99					KWD_RANDOMLPAREN                     = $99; $99 RANDOM(
=$9a					KWD_RIGHTDOLLARLPAREN                = $9a; $9a RIGHT$(
=$9b					KWD_RNDLPAREN                        = $9b; $9b RND(
=$9c					KWD_SGNLPAREN                        = $9c; $9c SGN(
=$9d					KWD_SPCLPAREN                        = $9d; $9d SPC(
=$9e					KWD_STRDOLLARLPAREN                  = $9e; $9e STR$(
=$9f					KWD_TIMERLPAREN                      = $9f; $9f TIMER(
=$a0					KWD_TRUE                             = $a0; $a0 TRUE
=$a1					KWD_VALLPAREN                        = $a1; $a1 VAL(
=$a2					KWD_FOR                              = $a2; $a2 FOR
=$a3					KWD_IF                               = $a3; $a3 IF
=$a4					KWD_PROC                             = $a4; $a4 PROC
=$a5					KWD_REPEAT                           = $a5; $a5 REPEAT
=$a6					KWD_WHILE                            = $a6; $a6 WHILE
=$a7					KWD_ENDIF                            = $a7; $a7 ENDIF
=$a8					KWD_ENDPROC                          = $a8; $a8 ENDPROC
=$a9					KWD_NEXT                             = $a9; $a9 NEXT
=$aa					KWD_THEN                             = $aa; $aa THEN
=$ab					KWD_UNTIL                            = $ab; $ab UNTIL
=$ac					KWD_WEND                             = $ac; $ac WEND
=$ad					KWD_BY                               = $ad; $ad BY
=$ae					KWD_CALL                             = $ae; $ae CALL
=$af					KWD_CIRCLE                           = $af; $af CIRCLE
=$b0					KWD_CLEAR                            = $b0; $b0 CLEAR
=$b1					KWD_CLS                              = $b1; $b1 CLS
=$b2					KWD_COLOR                            = $b2; $b2 COLOR
=$b3					KWD_COLOUR                           = $b3; $b3 COLOUR
=$b4					KWD_DATA                             = $b4; $b4 DATA
=$b5					KWD_DIM                              = $b5; $b5 DIM
=$b6					KWD_DOKE                             = $b6; $b6 DOKE
=$b7					KWD_DOWNTO                           = $b7; $b7 DOWNTO
=$b8					KWD_ELSE                             = $b8; $b8 ELSE
=$b9					KWD_FROM                             = $b9; $b9 FROM
=$ba					KWD_GFX                              = $ba; $ba GFX
=$bb					KWD_GOSUB                            = $bb; $bb GOSUB
=$bc					KWD_GOTO                             = $bc; $bc GOTO
=$bd					KWD_HERE                             = $bd; $bd HERE
=$be					KWD_IMAGE                            = $be; $be IMAGE
=$bf					KWD_INPUT                            = $bf; $bf INPUT
=$c0					KWD_LET                              = $c0; $c0 LET
=$c1					KWD_LINE                             = $c1; $c1 LINE
=$c2					KWD_LOCAL                            = $c2; $c2 LOCAL
=$c3					KWD_OFF                              = $c3; $c3 OFF
=$c4					KWD_ON                               = $c4; $c4 ON
=$c5					KWD_OUTLINE                          = $c5; $c5 OUTLINE
=$c6					KWD_PALETTE                          = $c6; $c6 PALETTE
=$c7					KWD_PLOT                             = $c7; $c7 PLOT
=$c8					KWD_POKE                             = $c8; $c8 POKE
=$c9					KWD_PRINT                            = $c9; $c9 PRINT
=$ca					KWD_READ                             = $ca; $ca READ
=$cb					KWD_RECT                             = $cb; $cb RECT
=$cc					KWD_REM                              = $cc; $cc REM
=$cd					KWD_RETURN                           = $cd; $cd RETURN
=$ce					KWD_SOLID                            = $ce; $ce SOLID
=$cf					KWD_SOUND                            = $cf; $cf SOUND
=$d0					KWD_SPRITE                           = $d0; $d0 SPRITE
=$d1					KWD_TEXT                             = $d1; $d1 TEXT
=$d2					KWD_TO                               = $d2; $d2 TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a2					KWC_FIRST_STRUCTURE = $a2
=$a7					KWC_FIRST_STRUCTURE_DEC = $a7
=$ac					KWC_LAST_STRUCTURE = $ac
=$83					KWC_FIRST_UNARY = $83
=$a1					KWC_LAST_UNARY = $a1

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c fd a7	jmp $a7fd		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c 96 aa	jmp $aa96		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c cc aa	jmp $aacc		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c f2 aa	jmp $aaf2		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c f5 aa	jmp $aaf5		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c ac a9	jmp $a9ac		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c 90 ab	jmp $ab90		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 7a be	jmp $be7a		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c ad be	jmp $bead		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 70 b8	jmp $b870		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c 04 bb	jmp $bb04		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.802a	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.802c	aa		tax				tax
.802d	a8		tay				tay
.802e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.8031	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8033	20 18 80	jsr $8018			jsr 	SNDCommand
.8036	a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.8038	a9 46		lda #$46			lda 	#Prompt & $FF
.803a	20 69 8f	jsr $8f69			jsr 	PrintStringXA
.803d	20 e0 89	jsr $89e0			jsr 	NewProgram 					; erase current program
.8040	4c 8e 83	jmp $838e			jmp 	WarmStart					; make same size.
.8043	4c 8e 83	jmp $838e			jmp 	WarmStart
>8046	46 32 35 36 20 42 41 53		Prompt:	.text 	"F256 BASIC "
>804e	49 43 20

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8051	52 65 6c 65 61 73 65 20			.text "Release Alpha 10 (02-Dec-22). "
>8059	41 6c 70 68 61 20 31 30 20 28 30 32 2d 44 65 63
>8069	2d 32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>806f	0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8072					AssembleGroup1:
.8072	a9 ff		lda #$ff			lda 	#$FF
.8074	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8077	80 02		bra $807b			bra 	AsmGroup12
.8079					AssembleGroup2:
.8079	a9 00		lda #$00			lda 	#$00
.807b					AsmGroup12:
.807b	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.807e	68		pla				pla 								; pop the return address to access the information following.
.807f	fa		plx				plx
.8080	20 07 81	jsr $8107			jsr 	AccessParameters 			; get opcode and save as base
.8083	8d 24 04	sta $0424			sta 	BaseOpcode
.8086	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8089	d0 08		bne $8093			bne 	_AG12HaveMask
.808b	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.808d	20 0f 81	jsr $810f			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8090	8d 25 04	sta $0425			sta 	ModeMask
.8093					_AG12HaveMask:
.8093	20 43 82	jsr $8243			jsr 	TypeAndCalculateOperand 	; get zero page type
.8096	da		phx				phx 								; save found address mode
.8097	20 73 81	jsr $8173			jsr 	AssembleModeX
.809a	fa		plx				plx  								; restore address mode
.809b	b0 0b		bcs $80a8			bcs 	_AG12Exit
.809d	20 a9 80	jsr $80a9			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.80a0	20 73 81	jsr $8173			jsr 	AssembleModeX
.80a3	b0 03		bcs $80a8			bcs 	_AG12Exit
.80a5	4c b0 9f	jmp $9fb0			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a8					_AG12Exit:
.80a8	60		rts				rts
.80a9					PromoteToAbsolute:
.80a9	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80ab	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80ad	f0 19		beq $80c8			beq 	_PTADo
.80af	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80b1	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80b3	f0 13		beq $80c8			beq 	_PTADo
.80b5	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b7	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b9	f0 0d		beq $80c8			beq 	_PTADo
.80bb	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80bd	e0 d1		cpx #$d1			cpx 	#AM_IND
.80bf	f0 07		beq $80c8			beq 	_PTADo
.80c1	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80c3	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80c5	f0 01		beq $80c8			beq 	_PTADo
.80c7	60		rts				rts
.80c8					_PTADo:
.80c8	aa		tax				tax
.80c9	60		rts				rts
.80ca					AssembleGroup3:
.80ca	68		pla				pla 								; get parameters, which is just the opcode.
.80cb	fa		plx				plx
.80cc	20 07 81	jsr $8107			jsr 	AccessParameters 			; get and output opcode
.80cf	20 1f 81	jsr $811f			jsr 	AssemblerWriteByte
.80d2	20 a7 82	jsr $82a7			jsr 	CalculateOperand 			; get a 16 bit operand
.80d5	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80d7	38		sec				sec
.80d8	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80db	48		pha				pha 								; LSB in A
.80dc	a5 60		lda $60				lda 	NSMantissa1
.80de	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80e1	aa		tax				tax 								; MSB in X
.80e2	68		pla				pla
.80e3	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80e4	69 7f		adc #$7f			adc 	#$7F
.80e6	90 01		bcc $80e9			bcc 	_AG3NoCarry
.80e8	e8		inx				inx
.80e9					_AG3NoCarry:
.80e9	38		sec				sec 								; fix back and write out anyways.
.80ea	e9 80		sbc #$80			sbc 	#$80
.80ec	20 1f 81	jsr $811f			jsr 	AssemblerWriteByte
.80ef	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80f1	f0 0a		beq $80fd			beq 	_AG3Exit
.80f3	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.80f6	29 01		and #$01			and 	#1
.80f8	f0 03		beq $80fd			beq 	_AG3Exit
.80fa	4c b5 9f	jmp $9fb5			jmp 	RangeError 					; no, branch is out of range
.80fd					_AG3Exit:
.80fd	60		rts				rts
.80fe					AssembleGroup4:
.80fe	68		pla				pla 								; pop address
.80ff	fa		plx				plx
.8100	20 07 81	jsr $8107			jsr 	AccessParameters 			; access and get first
.8103	20 1f 81	jsr $811f			jsr 	AssemblerWriteByte 			; output it.
.8106	60		rts				rts
.8107					AccessParameters:
.8107	8d 21 04	sta $0421			sta 	ParamStart
.810a	8e 22 04	stx $0422			stx 	ParamStart+1
.810d	a9 01		lda #$01			lda 	#1
.810f					GetParameter:
.810f	5a		phy				phy
.8110	a8		tay				tay
.8111	ad 21 04	lda $0421			lda 	ParamStart
.8114	85 36		sta $36				sta 	zTemp0
.8116	ad 22 04	lda $0422			lda 	ParamStart+1
.8119	85 37		sta $37				sta 	zTemp0+1
.811b	b1 36		lda ($36),y			lda 	(zTemp0),y
.811d	7a		ply				ply
.811e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811f					AssemblerWriteByte:
.811f	48		pha			pha
.8120	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8123	29 02		and #$02		and 	#2
.8125	f0 1b		beq $8142		beq 	_AWBNoPrint
.8127	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.812a	20 5d 81	jsr $815d		jsr 	PrintHex
.812d	ad 1e 04	lda $041e		lda		AssemblerAddress
.8130	20 5d 81	jsr $815d		jsr 	PrintHex
.8133	a9 20		lda #$20		lda 	#' '
.8135	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8138	68		pla			pla 									; print byte
.8139	48		pha			pha
.813a	20 5d 81	jsr $815d		jsr 	PrintHex
.813d	a9 0d		lda #$0d		lda 	#13
.813f	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8142					_AWBNoPrint:
.8142	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8145	85 36		sta $36			sta 	zTemp0
.8147	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.814a	f0 0e		beq $815a		beq 	_AWBRange
.814c	85 37		sta $37			sta 	zTemp0+1
.814e	68		pla			pla 									; write byte out
.814f	92 36		sta ($36)		sta 	(zTemp0)
.8151	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8154	d0 03		bne $8159		bne 	_AWBNoCarry
.8156	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.8159					_AWBNoCarry:
.8159	60		rts			rts
.815a					_AWBRange:
.815a	4c b5 9f	jmp $9fb5		jmp 	RangeError
.815d					PrintHex:
.815d	48		pha				pha
.815e	4a		lsr a				lsr 	a
.815f	4a		lsr a				lsr 	a
.8160	4a		lsr a				lsr 	a
.8161	4a		lsr a				lsr 	a
.8162	20 66 81	jsr $8166			jsr 	_PrintNibble
.8165	68		pla				pla
.8166					_PrintNibble:
.8166	29 0f		and #$0f			and 	#15
.8168	c9 0a		cmp #$0a			cmp 	#10
.816a	90 02		bcc $816e			bcc 	_NoShift
.816c	69 06		adc #$06			adc 	#6
.816e					_NoShift:
.816e	69 30		adc #$30			adc 	#48
.8170	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8173					AssembleModeX:
.8173	5a		phy				phy
.8174	ad 23 04	lda $0423			lda 	IsGroup1
.8177	f0 17		beq $8190			beq 	_AMXGroup2
.8179	8a		txa				txa 							; is it in group # 1
.817a	29 40		and #$40			and 	#AM_ISG1
.817c	f0 4d		beq $81cb			beq 	_AMXFail 				; no, give up.
.817e	8a		txa				txa 							; get back.
.817f	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8181	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8183	d0 22		bne $81a7			bne 	_AMXHaveInfo
.8185	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8188	c9 81		cmp #$81			cmp 	#$81
.818a	f0 3f		beq $81cb			beq 	_AMXFail
.818c	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.818e	80 17		bra $81a7			bra 	_AMXHaveInfo 			; odd design decision there.
.8190					_AMXGroup2:
.8190	8a		txa				txa 							; is it in group 2 ?
.8191	29 20		and #$20			and 	#AM_ISG2
.8193	f0 36		beq $81cb			beq 	_AMXFail 				; no, give up.
.8195	8a		txa				txa 							; get the offset into Y
.8196	29 1f		and #$1f			and 	#$1F
.8198	4a		lsr a				lsr 	a 						; make it 0-7.
.8199	4a		lsr a				lsr  	a
.819a	a8		tay				tay
.819b	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.819e					_AMXCheckOkay:
.819e	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819f	88		dey				dey
.81a0	10 fc		bpl $819e			bpl 	_AMXCheckOkay
.81a2	90 27		bcc $81cb			bcc 	_AMXFail 				; not allowed.
.81a4	8a		txa				txa  							; get mask back
.81a5	29 1f		and #$1f			and 	#$1F
.81a7					_AMXHaveInfo:
.81a7	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a9	10 04		bpl $81af			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81ab	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81ad	d0 1c		bne $81cb			bne 	_AMXFail
.81af					_AMXAnySize:
.81af	18		clc				clc 							; add offset to the base opcode
.81b0	6d 24 04	adc $0424			adc 	BaseOpcode
.81b3					_AMXOutputCode:
.81b3	20 1f 81	jsr $811f			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b6	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b8	f0 0e		beq $81c8			beq 	_AMXExit
.81ba	a5 58		lda $58				lda 	NSMantissa0 				; write LSB operand
.81bc	20 1f 81	jsr $811f			jsr 	AssemblerWriteByte
.81bf	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81c1	30 05		bmi $81c8			bmi 	_AMXExit
.81c3	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.81c5	20 1f 81	jsr $811f			jsr 	AssemblerWriteByte
.81c8					_AMXExit:
.81c8	7a		ply				ply
.81c9	38		sec				sec
.81ca	60		rts				rts
.81cb					_AMXFail:
.81cb	a0 00		ldy #$00			ldy 	#0
.81cd					_AMXCheckOddities:
.81cd	8a		txa				txa
.81ce	d9 f5 81	cmp $81f5,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d1	d0 15		bne $81e8			bne 	_AMXCONext
.81d3	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d6	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81d9	d0 0d		bne $81e8			bne 	_AMXCONext
.81db	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81dd	10 04		bpl $81e3			bpl 	_AMXCONotZero
.81df	a5 60		lda $60				lda 	NSMantissa1
.81e1	d0 05		bne $81e8			bne 	_AMXCONext
.81e3					_AMXCONotZero:
.81e3	b9 f4 81	lda $81f4,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e6	80 cb		bra $81b3			bra 	_AMXOutputCode 			; and assemble it
.81e8					_AMXCONext:
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	c8		iny				iny
.81eb	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; end of table
.81ee	d0 dd		bne $81cd			bne 	_AMXCheckOddities
.81f0					_AMXCOFail:
.81f0	7a		ply				ply
.81f1	18		clc				clc
.81f2	60		rts				rts
.81f3					ExtraOpcode:
>81f3	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>81f6	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>81f9	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fc	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81ff	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8202	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8205	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8208	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820b	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820e	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8211	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8212					LabelHere:
.8212	c8		iny				iny 								; skip .
.8213	a2 00		ldx #$00			ldx 	#0 							; get a term
.8215	20 5e 98	jsr $985e			jsr 	EvaluateTerm 				; get a term
.8218	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.821a	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821c	d0 22		bne $8240			bne 	_ALType
.821e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8220	85 36		sta $36				sta 	zTemp0
.8222	b5 60		lda $60,x			lda 	NSMantissa1,x
.8224	85 37		sta $37				sta 	zTemp0+1
.8226	5a		phy				phy 								; copy address in.
.8227	a0 01		ldy #$01			ldy 	#1
.8229	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.822c	92 36		sta ($36)			sta 	(zTemp0)
.822e	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8231	91 36		sta ($36),y			sta 	(zTemp0),y
.8233	c8		iny				iny
.8234	a9 00		lda #$00			lda 	#0
.8236	91 36		sta ($36),y			sta 	(zTemp0),y
.8238	c8		iny				iny
.8239	91 36		sta ($36),y			sta 	(zTemp0),y
.823b	c8		iny				iny
.823c	91 36		sta ($36),y			sta 	(zTemp0),y
.823e	7a		ply				ply
.823f	60		rts				rts
.8240					_ALType:
.8240	4c ba 9f	jmp $9fba			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8243					TypeAndCalculateOperand:
.8243	b1 30		lda ($30),y			lda 	(codePtr),y
.8245	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8247	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8249	f0 5b		beq $82a6			beq 	_TACOExit
.824b	c9 80		cmp #$80			cmp 	#KWC_EOL
.824d	f0 57		beq $82a6			beq 	_TACOExit
.824f	c8		iny				iny
.8250	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8252	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8254	f0 51		beq $82a7			beq 	CalculateOperand
.8256	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8258	f0 1f		beq $8279			beq 	_TACOIndirect
.825a	88		dey				dey 								; undo get of first character
.825b	20 a7 82	jsr $82a7			jsr 	CalculateOperand 			; get operand
.825e	b1 30		lda ($30),y			lda 	(codePtr),y
.8260	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8262	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8264	d0 40		bne $82a6			bne 	_TACOExit
.8266	c8		iny				iny
.8267	20 b1 82	jsr $82b1			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826a	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826c	c9 58		cmp #$58			cmp 	#'X'
.826e	f0 36		beq $82a6			beq 	_TACOExit
.8270	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8272	c9 59		cmp #$59			cmp 	#'Y'
.8274	f0 30		beq $82a6			beq 	_TACOExit
.8276					_TACOSyntax:
.8276	4c b0 9f	jmp $9fb0			jmp 	SyntaxError
.8279					_TACOIndirect:
.8279	20 a7 82	jsr $82a7			jsr 	CalculateOperand 			; get the operand
.827c	b1 30		lda ($30),y			lda 	(codePtr),y
.827e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8280	f0 17		beq $8299			beq 	_TACOIndX
.8282	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8285	b1 30		lda ($30),y			lda 	(codePtr),y
.8287	a2 d1		ldx #$d1			ldx 	#AM_IND
.8289	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828b	d0 19		bne $82a6			bne 	_TACOExit
.828d	c8		iny				iny
.828e	20 b1 82	jsr $82b1			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8291	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8293	d0 e1		bne $8276			bne 	_TACOSyntax
.8295	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8297	80 0d		bra $82a6			bra 	_TACOExit
.8299					_TACOIndX:
.8299	c8		iny				iny
.829a	20 b1 82	jsr $82b1			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.829d	c9 58		cmp #$58			cmp 	#'X' 						; check X
.829f	d0 d5		bne $8276			bne 	_TACOSyntax
.82a1	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket			; check )
.82a4	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a6					_TACOExit:
.82a6	60		rts				rts
.82a7					CalculateOperand:
.82a7	48		pha				pha
.82a8	da		phx				phx
.82a9	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ab	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger
.82ae	fa		plx				plx
.82af	68		pla				pla
.82b0	60		rts				rts
.82b1					TACOCheckXY:
.82b1	b1 30		lda ($30),y			lda 	(codePtr),y
.82b3	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b5	c9 40		cmp #$40			cmp 	#$40
.82b7	d0 21		bne $82da			bne 	_TCXYFail
.82b9	b1 30		lda ($30),y			lda 	(codePtr),y
.82bb	18		clc				clc
.82bc	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82be	85 37		sta $37				sta 	zTemp0+1
.82c0	c8		iny				iny
.82c1	b1 30		lda ($30),y			lda 	(codePtr),y
.82c3	c8		iny				iny
.82c4	85 36		sta $36				sta 	zTemp0
.82c6	5a		phy				phy 								; save position
.82c7	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82c9	b1 36		lda ($36),y			lda 	(zTemp0),y
.82cb	d0 0c		bne $82d9			bne 	_TCXYPopFail
.82cd	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82cf	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d1	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d3	f0 08		beq $82dd			beq 	_TCXYFound
.82d5	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82d7	f0 04		beq $82dd			beq 	_TCXYFound
.82d9					_TCXYPopFail:
.82d9	7a		ply				ply
.82da					_TCXYFail:
.82da	a9 00		lda #$00			lda 	#0
.82dc	60		rts				rts
.82dd					_TCXYFound:
.82dd	7a		ply				ply 								; restore position
.82de	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e1					BackloadProgram:
.82e1	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82e3	a9 32		lda #$32			lda 	#_BLLoad & $FF
.82e5	20 69 8f	jsr $8f69			jsr 	PrintStringXA
.82e8	a5 0b		lda $0b				lda 	8+3 						; save current mapping for $6000
.82ea	48		pha				pha
.82eb	a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; map source code in there.
.82ed	85 0b		sta $0b				sta 	8+3
.82ef	a9 00		lda #$00			lda 	#(($6000) & $FF)
.82f1	8d 59 06	sta $0659			sta 	0+BackLoadPointer
.82f4	a9 60		lda #$60			lda 	#(($6000) >> 8)
.82f6	8d 5a 06	sta $065a			sta 	1+BackLoadPointer
.82f9	a9 ff		lda #$ff			lda 	#$FF
.82fb	8d fa ff	sta $fffa			sta 	$FFFA
.82fe					_BPLoop:
.82fe	a2 ff		ldx #$ff			ldx 	#$FF
.8300	20 47 83	jsr $8347			jsr 	BLReadByte 					; read a byte
.8303	c9 00		cmp #$00			cmp 	#0
.8305	f0 21		beq $8328			beq 	_BPExit 					; if 0 exit
.8307	30 1f		bmi $8328			bmi 	_BPExit 					; if -ve exit
.8309					_BPCopy:
.8309	e8		inx				inx  								; copy byte into the lineBuffer
.830a	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.830d	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.8310	20 47 83	jsr $8347			jsr 	BLReadByte 					; read next byte
.8313	30 0a		bmi $831f			bmi 	_BPEndLine 					; -ve = EOL
.8315	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8317	d0 02		bne $831b			bne 	_BPNotTab
.8319	a9 20		lda #$20			lda 	#' '
.831b					_BPNotTab:
.831b	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.831d	b0 ea		bcs $8309			bcs 	_BPCopy 					; until a control character, should be 13 received.
.831f					_BPEndLine:
.831f	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.8322	38		sec				sec 								; append not insert
.8323	20 fb a4	jsr $a4fb			jsr 	MemoryInsertLine 			; append to current program
.8326	80 d6		bra $82fe			bra 	_BPLoop
.8328					_BPExit:
.8328	68		pla				pla 								; restore memory setup.
.8329	85 0b		sta $0b				sta 	8+3
.832b	9c fa ff	stz $fffa			stz 	$FFFA
.832e	20 24 84	jsr $8424			jsr 	ClearCommand 				; clear variables etc.
.8331	60		rts				rts
.8332					_BLLoad:
>8332	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>833a	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.8347					BLReadByte:
.8347	ad 59 06	lda $0659			lda 	BackLoadPointer 			; copy pointer to zTemp0
.834a	85 36		sta $36				sta 	zTemp0
.834c	ad 5a 06	lda $065a			lda 	BackLoadPointer+1
.834f	85 37		sta $37				sta 	zTemp0+1
.8351	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8353	ee 59 06	inc $0659			inc 	BackLoadPointer 			; bump pointer
.8356	d0 0e		bne $8366			bne 	_BLNoCarry
.8358	ee 5a 06	inc $065a			inc 	BackLoadPointer+1
.835b	10 09		bpl $8366			bpl 	_BLNoCarry 					; need a new page
.835d	48		pha				pha
.835e	a9 60		lda #$60			lda 	#$60 						; reset pointer
.8360	8d 5a 06	sta $065a			sta 	BackLoadPointer+1
.8363	e6 0b		inc $0b				inc 	8+3 						; next page from source.
.8365	68		pla				pla
.8366					_BLNoCarry:
.8366	c9 00		cmp #$00			cmp 	#0
.8368	60		rts				rts
.0659					BackLoadPointer:
>0659							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8369					EditProgramCode:
.8369	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; try to find the line.
.836c	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.836f	20 9f a5	jsr $a59f			jsr 	MemorySearch
.8372	90 05		bcc $8379			bcc 	_EPCNoDelete 				; reached the end : don't delete
.8374	d0 03		bne $8379			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.8376	20 c4 a4	jsr $a4c4			jsr 	MemoryDeleteLine 			; delete the line
.8379					_EPCNoDelete:
.8379	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty - we just want to delete a line.
.837c	c9 80		cmp #$80			cmp 	#KWC_EOL
.837e	f0 0d		beq $838d			beq 	_EPCNoInsert
.8380	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.8383	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8386	20 9f a5	jsr $a59f			jsr 	MemorySearch
.8389	18		clc				clc 								; insert at this point.
.838a	20 fb a4	jsr $a4fb			jsr 	MemoryInsertLine 			; insert the line
.838d					_EPCNoInsert:
.838d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.838e					WarmStart:
.838e	a2 ff		ldx #$ff			ldx 	#$FF
.8390	9a		txs				txs
.8391	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.8393	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8396	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.8399	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.839c	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number <> 0
.839f	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.83a2	d0 17		bne $83bb			bne 	_WSEditCode 				; if so,edit code.
.83a4	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero the "offset", meaning it only runs one line.
.83a7	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.83a9	85 30		sta $30				sta 	codePtr
.83ab	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.83ad	85 31		sta $31				sta 	codePtr+1
.83af	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.83b2	c9 80		cmp #$80			cmp 	#KWC_EOL
.83b4	f0 d8		beq $838e			beq 	WarmStart
.83b6	20 33 8b	jsr $8b33			jsr 	RUNCodePointerLine 			; execute that line.
.83b9	80 d3		bra $838e			bra 	WarmStart
.83bb					_WSEditCode:
.83bb	20 69 83	jsr $8369			jsr 	EditProgramCode 			; edit the program code
.83be	20 24 84	jsr $8424			jsr 	ClearCommand 				; clear all variables etc.
.83c1	80 cb		bra $838e			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.83c3					AssembleCommand:
.83c3	a2 00		ldx #$00			ldx 	#0
.83c5	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger 		; start address
.83c8	a5 58		lda $58				lda 	NSMantissa0
.83ca	8d 1e 04	sta $041e			sta 	AssemblerAddress
.83cd	a5 60		lda $60				lda 	NSMantissa1
.83cf	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.83d2	20 ff 8e	jsr $8eff			jsr 	CheckComma
.83d5	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; options 0-3
.83d8	a5 58		lda $58				lda 	NSMantissa0
.83da	8d 20 04	sta $0420			sta 	AssemblerControl
.83dd	60		rts				rts
.83de	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83df					AssertCommand:
.83df	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83e1	20 9f 9d	jsr $9d9f			jsr 	EvaluateInteger 			; the assert test
.83e4	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; exit if result is non zero.
.83e7	d0 05		bne $83ee			bne 	_ACExit
.83e9	a9 0a		lda #$0a		lda	#10
.83eb	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.83ee					_ACExit:
.83ee	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83ef					CallCommand:
.83ef	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83f1	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger
.83f4					_CCClear
.83f4	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83f5	20 32 9e	jsr $9e32			jsr 	NSMSetZero 					; these are optional sequentially.
.83f8	e0 04		cpx #$04			cpx 	#4
.83fa	d0 f8		bne $83f4			bne 	_CCClear
.83fc	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83fe					_CCCParam:
.83fe	b1 30		lda ($30),y			lda 	(codePtr),y
.8400	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8402	d0 09		bne $840d			bne 	_CCCRun6502
.8404	c8		iny				iny 								; skip comma
.8405	e8		inx				inx	 								; next level
.8406	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; get A/X/Y
.8409	e0 03		cpx #$03			cpx 	#3
.840b	90 f1		bcc $83fe			bcc 	_CCCParam 					; done all 3 ?
.840d					_CCCRun6502:
.840d	5a		phy				phy 								; save position
.840e	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.8410	85 37		sta $37				sta 	zTemp0+1
.8412	a5 58		lda $58				lda 	NSMantissa0
.8414	85 36		sta $36				sta 	zTemp0
.8416	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.8418	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.841a	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.841c	20 21 84	jsr $8421			jsr 	_CCCZTemp0 					; call zTemp0
.841f	7a		ply				ply 								; restore position and exit
.8420	60		rts				rts
.8421					_CCCZTemp0:
.8421	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.8424					ClearCommand:
.8424	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8426	85 36		sta $36				sta 	0+zTemp0
.8428	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.842a	85 37		sta $37				sta 	1+zTemp0
.842c					_ClearZeroLoop:
.842c	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.842e	f0 24		beq $8454			beq 	_ClearZeroEnd
.8430	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.8432	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8434					_ClearOneVariable:
.8434	91 36		sta ($36),y			sta 	(zTemp0),y
.8436	c8		iny				iny
.8437	c0 08		cpy #$08			cpy 	#8
.8439	d0 f9		bne $8434			bne 	_ClearOneVariable
.843b	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.843d	b1 36		lda ($36),y			lda 	(zTemp0),y
.843f	c9 18		cmp #$18			cmp 	#NSTProcedure
.8441	d0 04		bne $8447			bne 	_ClearNotProcedure
.8443	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8445	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8447					_ClearNotProcedure:
.8447	18		clc				clc 								; go to the next variable
.8448	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.844a	65 36		adc $36				adc 	zTemp0
.844c	85 36		sta $36				sta 	zTemp0
.844e	90 dc		bcc $842c			bcc 	_ClearZeroLoop
.8450	e6 37		inc $37				inc 	zTemp0+1
.8452	80 d8		bra $842c			bra 	_ClearZeroLoop
.8454					_ClearZeroEnd:
.8454	18		clc				clc
.8455	a5 36		lda $36				lda 	zTemp0
.8457	69 01		adc #$01			adc 	#1
.8459	8d 0c 04	sta $040c			sta 	lowMemPtr
.845c	a5 37		lda $37				lda 	zTemp0+1
.845e	69 00		adc #$00			adc 	#0
.8460	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.8463	20 2b a7	jsr $a72b			jsr 	StackReset
.8466	20 91 a7	jsr $a791			jsr 	StringSystemInitialise
.8469	20 9d 8d	jsr $8d9d			jsr 	ProcedureScan
.846c	20 e2 8a	jsr $8ae2			jsr 	Command_Restore
.846f	9c 1e 04	stz $041e			stz 	AssemblerAddress
.8472	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.8475	9c 20 04	stz $0420			stz 	AssemblerControl
.8478	20 45 9a	jsr $9a45			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.847b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.847c					ClearScreen:
.847c	5a		phy				phy
.847d	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.847f	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8482	7a		ply				ply
.8483	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8484					Command_Data:
.8484	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.8486	a2 80		ldx #$80			ldx 	#KWC_EOL
.8488	20 ef 8d	jsr $8def			jsr 	ScanForward
.848b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.848c					DimCommand:
.848c	b1 30		lda ($30),y			lda 	(codePtr),y
.848e	29 c0		and #$c0			and 	#$C0
.8490	c9 40		cmp #$40			cmp 	#$40
.8492	d0 7a		bne $850e			bne 	_DCSyntax 				; n o, error.
.8494	b1 30		lda ($30),y			lda 	(codePtr),y
.8496	18		clc				clc
.8497	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8499	85 3f		sta $3f				sta 	zaTemp+1
.849b	c8		iny				iny
.849c	b1 30		lda ($30),y			lda 	(codePtr),y
.849e	c8		iny				iny
.849f	85 3e		sta $3e				sta 	zaTemp
.84a1	5a		phy				phy
.84a2	a0 02		ldy #$02			ldy 	#2 						; read type byte
.84a4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a6	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.84a8	c9 18		cmp #$18			cmp 	#NSTProcedure
.84aa	f0 62		beq $850e			beq 	_DCSyntax
.84ac	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.84ae	29 04		and #$04			and 	#NSBIsArray
.84b0	f0 64		beq $8516			beq 	_DCType
.84b2	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.84b4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b6	d0 59		bne $8511			bne 	_DCRedefine
.84b8	7a		ply				ply
.84b9	20 19 85	jsr $8519			jsr 	_DCGetSize 				; get array size, check it.
.84bc	5a		phy				phy
.84bd	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.84bf	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.84c1	7a		ply				ply 							; is there a second (e.g. ,x)
.84c2	b1 30		lda ($30),y			lda 	(codePtr),y
.84c4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84c6	d0 0a		bne $84d2			bne 	_DCOneDimension
.84c8	c8		iny				iny 							; skip comma
.84c9	20 19 85	jsr $8519			jsr 	_DCGetSize 				; get 2nd array size
.84cc	5a		phy				phy
.84cd	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84cf	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84d1	7a		ply				ply
.84d2					_DCOneDimension:
.84d2	5a		phy				phy 							; save position
.84d3	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84d5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84d7	aa		tax				tax
.84d8	c8		iny				iny
.84d9	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84db	e8		inx				inx 							; bump them.
.84dc	1a		inc a				inc 	a
.84dd	20 dd 9d	jsr $9ddd			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84e0	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84e2	29 e0		and #$e0			and 	#$E0
.84e4	d0 23		bne $8509			bne 	_DCSize
.84e6	a0 02		ldy #$02			ldy 	#2 						; get base type
.84e8	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ea	20 27 85	jsr $8527			jsr 	ScaleByBaseType 		; scale by base type
.84ed	a5 36		lda $36				lda 	zTemp0
.84ef	a6 37		ldx $37				ldx 	zTemp0+1
.84f1	20 07 9a	jsr $9a07			jsr 	AllocateXABytes 		; allocate memory
.84f4	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84f6	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84f8	c8		iny				iny
.84f9	8a		txa				txa
.84fa	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84fc	7a		ply				ply 							; get position back
.84fd	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket 		; check )
.8500	b1 30		lda ($30),y			lda 	(codePtr),y
.8502	c8		iny				iny 							; consume in case
.8503	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.8505	f0 85		beq $848c			beq 	DimCommand
.8507	88		dey				dey 							; undo consume
.8508	60		rts				rts
.8509					_DCSize:
.8509	a9 16		lda #$16		lda	#22
.850b	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.850e					_DCSyntax:
.850e	4c b0 9f	jmp $9fb0			jmp 	SyntaxError
.8511					_DCRedefine:
.8511	a9 15		lda #$15		lda	#21
.8513	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.8516					_DCType:
.8516	4c ba 9f	jmp $9fba			jmp 	TypeError
.8519					_DCGetSize:
.8519	a2 00		ldx #$00			ldx 	#0 						; get first index.
.851b	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 	; get array dimension
.851e	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8520	f0 e7		beq $8509			beq 	_DCSize
.8522	c9 fe		cmp #$fe			cmp 	#254
.8524	f0 e3		beq $8509			beq 	_DCSize
.8526	60		rts				rts
.8527					ScaleByBaseType:
.8527	29 10		and #$10			and 	#NSBIsString 			; is it string
.8529	d0 19		bne $8544			bne 	_SBBTString
.852b	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.852d	48		pha				pha
.852e	a5 36		lda $36				lda 	zTemp0
.8530	48		pha				pha
.8531	06 36		asl $36				asl 	zTemp0 					; x 2
.8533	26 37		rol $37				rol 	zTemp0+1
.8535	06 36		asl $36				asl 	zTemp0 					; x 4
.8537	26 37		rol $37				rol 	zTemp0+1
.8539	68		pla				pla 							; add stacked value = x 5
.853a	65 36		adc $36				adc 	zTemp0
.853c	85 36		sta $36				sta 	zTemp0
.853e	68		pla				pla
.853f	65 37		adc $37				adc 	zTemp0+1
.8541	85 37		sta $37				sta 	zTemp0+1
.8543	60		rts				rts
.8544					_SBBTString:
.8544	06 36		asl $36				asl 	zTemp0
.8546	26 37		rol $37				rol 	zTemp0+1
.8548	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dokepoke.asm

.8549					PokeCommand:
.8549	18		clc				clc
.854a	80 01		bra $854d			bra 	DPCommand
.854c					DokeCommand:
.854c	38		sec				sec
.854d					DPCommand:
.854d	08		php				php									; save on stack, CS = Doke, CC = Poke
.854e	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8550	20 b2 9d	jsr $9db2			jsr		Evaluate16BitInteger 		; address
.8553	20 ff 8e	jsr $8eff			jsr 	CheckComma
.8556	e8		inx				inx
.8557	20 b2 9d	jsr $9db2			jsr		Evaluate16BitInteger 		; data
.855a	a5 58		lda $58				lda 	NSMantissa0 				; copy address
.855c	85 36		sta $36				sta 	zTemp0
.855e	a5 60		lda $60				lda 	NSMantissa1
.8560	85 37		sta $37				sta 	zTemp0+1
.8562	a5 59		lda $59				lda 	NSMantissa0+1 				; low byte
.8564	92 36		sta ($36)			sta 	(zTemp0)
.8566	28		plp				plp 								; done if POKE
.8567	90 08		bcc $8571			bcc 	_DPExit
.8569	5a		phy				phy 								; write high byte out.
.856a	a0 01		ldy #$01			ldy 	#1
.856c	a5 61		lda $61				lda 	NSMantissa1+1
.856e	91 36		sta ($36),y			sta 	(zTemp0),y
.8570	7a		ply				ply
.8571					_DPExit:
.8571	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8572					EndCommand:
.8572	4c 8e 83	jmp $838e			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8575					ForCommand:
.8575	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.8577	20 c5 a6	jsr $a6c5			jsr 	StackOpen
.857a	a2 00		ldx #$00			ldx 	#0
.857c	20 5e 98	jsr $985e			jsr 	EvaluateTerm
.857f	b5 50		lda $50,x			lda 	NSStatus,x
.8581	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8583	d0 47		bne $85cc			bne		_FCError
.8585	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8587	20 07 8f	jsr $8f07			jsr 	CheckNextA
.858a	e8		inx				inx
.858b	20 9f 9d	jsr $9d9f			jsr 	EvaluateInteger 			; <from> in +1
.858e	b1 30		lda ($30),y			lda 	(codePtr),y
.8590	c8		iny				iny 								; consume it
.8591	48		pha				pha 								; save on stack for later
.8592	c9 b7		cmp #$b7			cmp 	#KWD_DOWNTO
.8594	f0 04		beq $859a			beq 	_FCNoSyntax
.8596	c9 d2		cmp #$d2			cmp 	#KWD_TO
.8598	d0 35		bne $85cf			bne 	_FCSyntaxError
.859a					_FCNoSyntax:
.859a	e8		inx				inx
.859b	20 9f 9d	jsr $9d9f			jsr 	EvaluateInteger
.859e	20 0a a7	jsr $a70a			jsr 	STKSaveCodePosition 		; save loop back position
.85a1	68		pla				pla 								; restore DOWNTO or TO
.85a2	5a		phy				phy 								; save Y on the stack
.85a3	49 b7		eor #$b7			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.85a5	f0 02		beq $85a9			beq 	_FCNotDownTo
.85a7	a9 02		lda #$02			lda 	#2
.85a9					_FCNotDownTo:
.85a9	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.85aa	a0 10		ldy #$10			ldy 	#16
.85ac	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.85ae	a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.85b0	a5 58		lda $58				lda 	NSMantissa0
.85b2	91 34		sta ($34),y			sta 	(basicStack),y
.85b4	a5 60		lda $60				lda 	NSMantissa1
.85b6	c8		iny				iny
.85b7	91 34		sta ($34),y			sta 	(basicStack),y
.85b9	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.85bb	a2 01		ldx #$01			ldx 	#1
.85bd	20 d2 85	jsr $85d2			jsr 	FCIntegerToStack
.85c0	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.85c2	a2 02		ldx #$02			ldx 	#2
.85c4	20 d2 85	jsr $85d2			jsr 	FCIntegerToStack
.85c7	20 ed 85	jsr $85ed			jsr 	CopyIndexToReference
.85ca	7a		ply				ply 								; restore position
.85cb	60		rts				rts
.85cc					_FCError:
.85cc	4c ba 9f	jmp $9fba			jmp 	TypeError
.85cf					_FCSyntaxError:
.85cf	4c b0 9f	jmp $9fb0			jmp 	SyntaxError
.85d2					FCIntegerToStack:
.85d2	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.85d4	10 03		bpl $85d9			bpl	 	_FCNotNegative
.85d6	20 fb 9d	jsr $9dfb			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.85d9					_FCNotNegative:
.85d9	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.85db	91 34		sta ($34),y			sta 	(basicStack),y
.85dd	c8		iny				iny
.85de	b5 60		lda $60,x			lda 	NSMantissa1,x
.85e0	91 34		sta ($34),y			sta 	(basicStack),y
.85e2	c8		iny				iny
.85e3	b5 68		lda $68,x			lda 	NSMantissa2,x
.85e5	91 34		sta ($34),y			sta 	(basicStack),y
.85e7	c8		iny				iny
.85e8	b5 70		lda $70,x			lda 	NSMantissa3,x
.85ea	91 34		sta ($34),y			sta 	(basicStack),y
.85ec	60		rts				rts
.85ed					CopyIndexToReference:
.85ed	5a		phy				phy
.85ee	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85f0	38		sec				sec 								; (because we copy from offset 8)
.85f1	b1 34		lda ($34),y			lda 	(basicStack),y
.85f3	e9 08		sbc #$08			sbc 	#8
.85f5	85 36		sta $36				sta 	zTemp0
.85f7	c8		iny				iny
.85f8	b1 34		lda ($34),y			lda 	(basicStack),y
.85fa	e9 00		sbc #$00			sbc 	#0
.85fc	85 37		sta $37				sta 	zTemp0+1
.85fe	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.8600	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.8602	b1 34		lda ($34),y			lda 	(basicStack),y
.8604	0a		asl a				asl 	a 							; into carry
.8605	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8607	90 14		bcc $861d			bcc 	_CITRNormal
.8609	38		sec				sec
.860a					_CITRNegative:
.860a	a9 00		lda #$00			lda 	#0
.860c	f1 34		sbc ($34),y			sbc 	(basicStack),y
.860e	91 36		sta ($36),y			sta 	(zTemp0),y
.8610	c8		iny				iny
.8611	ca		dex				dex
.8612	d0 f6		bne $860a			bne 	_CITRNegative
.8614	88		dey				dey 								; look at MSB of mantissa
.8615	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.8617	09 80		ora #$80			ora 	#$80
.8619	91 36		sta ($36),y			sta 	(zTemp0),y
.861b	7a		ply				ply
.861c	60		rts				rts
.861d					_CITRNormal:
.861d	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.861f	91 36		sta ($36),y			sta 	(zTemp0),y
.8621	c8		iny				iny
.8622	ca		dex				dex
.8623	d0 f8		bne $861d			bne 	_CITRNormal
.8625	7a		ply				ply 								; and exit.
.8626	60		rts				rts
.8627					NextCommand:
.8627	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8629	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.862b	20 f2 a6	jsr $a6f2			jsr 	StackCheckFrame
.862e	5a		phy				phy
.862f	a0 10		ldy #$10			ldy 	#16 						; get the step count
.8631	b1 34		lda ($34),y			lda 	(basicStack),y
.8633	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.8635	30 02		bmi $8639			bmi 	_NCStepNeg
.8637	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8639					_NCStepNeg:
.8639	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.863b	a2 04		ldx #$04			ldx 	#4 							; count to bump
.863d	18		clc				clc
.863e					_NCBump:
.863e	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8640	91 34		sta ($34),y			sta 	(basicStack),y
.8642	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8644	c8		iny				iny 								; next byte
.8645	ca		dex				dex 								; do four times
.8646	d0 f6		bne $863e			bne 	_NCBump
.8648	20 ed 85	jsr $85ed			jsr		CopyIndexToReference		; copy it to the reference variable.
.864b	a0 10		ldy #$10			ldy 	#16 						; get step count again
.864d	b1 34		lda ($34),y			lda 	(basicStack),y
.864f	0a		asl a				asl 	a 							; sign bit to carry
.8650	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8652	85 38		sta $38				sta 	zTemp1
.8654	90 02		bcc $8658			bcc 	_NCCompRev 					; use if step is +ve
.8656	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8658					_NCCompRev:
.8658	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.865a	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.865c	85 39		sta $39				sta 	zTemp1+1
.865e	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8660	38		sec				sec
.8661					_NCCompare:
.8661	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8663	b1 34		lda ($34),y			lda 	(basicStack),y
.8665	a4 39		ldy $39				ldy 	zTemp1+1
.8667	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8669	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.866b	e6 39		inc $39				inc 	zTemp1+1
.866d	ca		dex				dex 								; do it 4 times.
.866e	d0 f1		bne $8661			bne 	_NCCompare
.8670	50 02		bvc $8674			bvc 	_NCNoOverflow 				; convert to signed comparison
.8672	49 80		eor #$80			eor 	#$80
.8674					_NCNoOverflow:
.8674	7a		ply				ply 								; restore Y position
.8675	0a		asl a				asl 	a 							; is bit 7 set.
.8676	90 04		bcc $867c			bcc 	_NCLoopback 				; if no , >= so loop back
.8678	20 e4 a6	jsr $a6e4			jsr 	StackClose 					; exit the loop
.867b	60		rts				rts
.867c					_NCLoopBack:
.867c	20 1b a7	jsr $a71b			jsr 	STKLoadCodePosition 		; loop back
.867f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8680					Command_GOSUB:
.8680	a2 00		ldx #$00			ldx 	#0
.8682	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8685	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8687	20 c5 a6	jsr $a6c5			jsr 	StackOpen 					; create frame
.868a	20 0a a7	jsr $a70a			jsr 	STKSaveCodePosition 		; save current position
.868d	4c a3 86	jmp $86a3			jmp 	GotoStackX
.8690					Command_RETURN:
.8690	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8692	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8694	20 f2 a6	jsr $a6f2			jsr 	StackCheckFrame
.8697	20 1b a7	jsr $a71b			jsr 	STKLoadCodePosition 		; restore code position
.869a	20 e4 a6	jsr $a6e4			jsr 	StackClose
.869d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.869e					GotoCommand:
.869e	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.86a0	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger
.86a3					GotoStackX:
.86a3	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.86a5	48		pha				pha 								; it is slightly inefficient, just in cases.
.86a6	b5 58		lda $58,x			lda 	NSMantissa0,x
.86a8	fa		plx				plx
.86a9	20 9f a5	jsr $a59f			jsr 	MemorySearch 				; transfer to line number AX.
.86ac	90 05		bcc $86b3			bcc 	_GotoError 					; not found, off end.
.86ae	d0 03		bne $86b3			bne 	_GotoError 					; not found exactly
.86b0	4c 2c 8b	jmp $8b2c			jmp 	RunNewLine 					; and go straight to new line code.
.86b3					_GotoError:
.86b3	a9 0d		lda #$0d		lda	#13
.86b5	4c 10 8f	jmp $8f10		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.86b8					IfCommand:
.86b8	a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.86ba	20 80 9d	jsr $9d80			jsr 	EvaluateNumber
.86bd	b1 30		lda ($30),y			lda 	(codePtr),y
.86bf	c9 aa		cmp #$aa			cmp 	#KWD_THEN  					; could be THEN <stuff>
.86c1	d0 0a		bne $86cd			bne 	_IFStructured 				; we still support it.
.86c3	c8		iny				iny 								; consume THEN
.86c4	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; is it zero
.86c7	f0 01		beq $86ca			beq 	_IfFail 					; if fail, go to next line
.86c9	60		rts				rts 								; if THEN just continue
.86ca					_IfFail:
.86ca	4c 14 8b	jmp $8b14			jmp 	EOLCommand
.86cd					_IfStructured:
.86cd	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; is it zero
.86d0	d0 07		bne $86d9			bne 	_IfExit 					; if not, then continue normally.
.86d2	a9 b8		lda #$b8			lda 	#KWD_ELSE 					; look for else/endif
.86d4	a2 a7		ldx #$a7			ldx 	#KWD_ENDIF
.86d6	20 ef 8d	jsr $8def			jsr 	ScanForward 				; and run from there
.86d9					_IfExit:
.86d9	60		rts				rts
.86da					ElseCode:
.86da	a9 a7		lda #$a7			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.86dc	aa		tax				tax 								; so just go to the structure exit
.86dd	20 ef 8d	jsr $8def			jsr 	ScanForward
.86e0	60		rts				rts
.86e1					EndIf:
.86e1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.86e2					Command_Input:
.86e2	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.86e4	8d 28 04	sta $0428			sta 	IsInputFlag
.86e7	80 03		bra $86ec			bra 	Command_IP_Main
.86e9					Command_Print:
.86e9	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.86ec					Command_IP_Main:
.86ec	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86ed					_CPLoop:
.86ed	08		php				php 								; save last action flag
.86ee	b1 30		lda ($30),y			lda 	(codePtr),y
.86f0	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86f2	f0 54		beq $8748			beq 	_CPExit
.86f4	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86f6	f0 50		beq $8748			beq 	_CPExit
.86f8	68		pla				pla 								; throw last action flag
.86f9	b1 30		lda ($30),y			lda 	(codePtr),y
.86fb	c8		iny				iny
.86fc	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86fe	f0 45		beq $8745			beq 	_CPContinueWithSameLine
.8700	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8702	f0 3c		beq $8740			beq 	_CPTab
.8704	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8706	f0 34		beq $873c			beq 	_CPNewLine
.8708	88		dey				dey 								; undo the get.
.8709	20 12 94	jsr $9412			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.870c	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.870e	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.8710	f0 0d		beq $871f			beq 	_CPIsValue 					; no, display it.
.8712	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.8715	f0 05		beq $871c			beq 	_CPIsPrint 					; otherwise display.
.8717	20 51 87	jsr $8751			jsr 	CIInputValue 				; input a value to the reference
.871a	80 20		bra $873c			bra 	_CPNewLine
.871c					_CPIsPrint:
.871c	20 d7 96	jsr $96d7			jsr 	Dereference 				; dereference if required.
.871f					_CPIsValue:
.871f	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.8721	29 10		and #$10			and 	#NSBIsString
.8723	f0 09		beq $872e			beq 	_CPNumber
.8725	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.8727	a5 58		lda $58				lda 	NSMantissa0
.8729	20 b4 87	jsr $87b4			jsr 	CPPrintStringXA
.872c	80 be		bra $86ec			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.872e					_CPNumber:
.872e	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8730	20 67 9c	jsr $9c67			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.8733	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8735	a9 49		lda #$49			lda 	#DecimalBuffer & $FF
.8737	20 b4 87	jsr $87b4			jsr 	CPPrintStringXA 			; print it.
.873a	80 b0		bra $86ec			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.873c					_CPNewLine:
.873c	a9 0d		lda #$0d			lda 	#13
.873e	80 02		bra $8742			bra 	_CPPrintChar
.8740					_CPTab:
.8740	a9 09		lda #$09			lda 	#9 							; print TAB
.8742					_CPPrintChar:
.8742	20 c7 87	jsr $87c7			jsr 	CPPrintVector
.8745					_CPContinueWithSameLine:
.8745	38		sec				sec 								; loop round with carry set, which
.8746	80 a5		bra $86ed			bra 	_CPLoop 					; will inhibit final CR
.8748					_CPExit:
.8748	28		plp				plp 								; get last action flag
.8749	b0 05		bcs $8750			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.874b	a9 0d		lda #$0d			lda 	#13 						; print new line
.874d	20 c7 87	jsr $87c7			jsr 	CPPrintVector
.8750					_CPExit2:
.8750	60		rts				rts
.8751					CIInputValue:
.8751	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8753					_CIInputLine:
.8753	20 ca 87	jsr $87ca			jsr 	CPInputVector 				; get key
.8756	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8758	f0 1f		beq $8779			beq 	_CIHaveValue
.875a	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.875c	f0 11		beq $876f			beq 	_CIBackspace
.875e	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8760	90 f1		bcc $8753			bcc 	_CIInputLine
.8762	e0 50		cpx #$50			cpx 	#80 						; max length
.8764	b0 ed		bcs $8753			bcs 	_CIInputLine
.8766	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.8769	e8		inx				inx
.876a	20 c7 87	jsr $87c7			jsr 	CPPrintVector 				; echo it.
.876d	80 e4		bra $8753			bra 	_CIInputLine
.876f					_CIBackSpace:
.876f	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8771	f0 e0		beq $8753			beq 	_CIInputLine
.8773	20 c7 87	jsr $87c7			jsr 	CPPrintVector 				; echo it.
.8776	ca		dex				dex
.8777	80 da		bra $8753			bra 	_CIInputLine
.8779					_CIHaveValue:
.8779	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.877c	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.877e	29 10		and #$10			and 	#NSBIsString
.8780	f0 17		beq $8799			beq 	_CIAssignNumber 			; assign a number
.8782	a2 01		ldx #$01			ldx 	#1
.8784	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8786	95 58		sta $58,x			sta 	NSMantissa0,x
.8788	a9 05		lda #$05			lda 	#lineBuffer >> 8
.878a	95 60		sta $60,x			sta 	NSMantissa1,x
.878c	74 68		stz $68,x			stz 	NSMantissa2,x
.878e	74 70		stz $70,x			stz 	NSMantissa3,x
.8790	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8792	95 50		sta $50,x			sta  	NSStatus,x
.8794	ca		dex				dex 								; X = 0
.8795	20 06 88	jsr $8806			jsr 	AssignVariable
.8798	60		rts				rts
.8799					_CIAssignNumber:
.8799	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.879b	85 36		sta $36				sta 	zTemp0
.879d	a9 05		lda #$05			lda 	#lineBuffer >> 8
.879f	85 37		sta $37				sta 	zTemp0+1
.87a1	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.87a3	20 e9 9b	jsr $9be9			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.87a6	90 07		bcc $87af			bcc 	_CIIsOkay
.87a8	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.87aa	20 c7 87	jsr $87c7			jsr 	CPPrintVector
.87ad	80 a2		bra $8751			bra 	CIInputValue
.87af					_CIIsOkay:
.87af	ca		dex				dex 								; X = 0
.87b0	20 06 88	jsr $8806			jsr 	AssignVariable
.87b3	60		rts				rts
.87b4					CPPrintStringXA:
.87b4	5a		phy				phy
.87b5	86 37		stx $37				stx 	zTemp0+1
.87b7	85 36		sta $36				sta 	zTemp0
.87b9	a0 00		ldy #$00			ldy 	#0
.87bb					_PSXALoop:
.87bb	b1 36		lda ($36),y			lda 	(zTemp0),y
.87bd	f0 06		beq $87c5			beq 	_PSXAExit
.87bf	20 c7 87	jsr $87c7			jsr 	CPPrintVector
.87c2	c8		iny				iny
.87c3	80 f6		bra $87bb			bra 	_PSXALoop
.87c5					_PSXAExit:
.87c5	7a		ply				ply
.87c6	60		rts				rts
.87c7					CPPrintVector:
.87c7	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.87ca					CPInputVector:
.87ca	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.87cd					LetCommand:
.87cd	a2 00		ldx #$00			ldx 	#0
.87cf	b1 30		lda ($30),y			lda 	(codePtr),y
.87d1	c9 10		cmp #$10			cmp 	#KWD_AT
.87d3	d0 14		bne $87e9			bne 	_LCStandard
.87d5	c8		iny				iny 								; skip equal
.87d6	20 5e 98	jsr $985e			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.87d9	20 d7 96	jsr $96d7			jsr 	Dereference 				; dereference it to a value
.87dc	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.87de	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.87e0	95 50		sta $50,x			sta 	NSStatus,x
.87e2	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.87e4	d0 0f		bne $87f5			bne 	_LCMain
.87e6	4c ba 9f	jmp $9fba			jmp 	TypeError 					; was a reference before.
.87e9					_LCStandard:
.87e9	ad fc 93	lda $93fc			lda 	PrecedenceLevel+"*"			; precedence > this
.87ec	20 16 94	jsr $9416			jsr 	EvaluateExpressionAtPrecedence
.87ef	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.87f1	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87f3	f0 0e		beq $8803			beq 	_LetGoProc 					; it's a procedure call.
.87f5					_LCMain:
.87f5	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87f7	20 07 8f	jsr $8f07			jsr 	CheckNextA
.87fa	e8		inx				inx 								; RHS
.87fb	20 77 9d	jsr $9d77			jsr 	EvaluateValue
.87fe	ca		dex				dex
.87ff	20 06 88	jsr $8806			jsr 	AssignVariable
.8802	60		rts				rts
.8803					_LetGoProc:
.8803	4c ea 89	jmp $89ea			jmp 	CallProcedure
.8806					AssignVariable:
.8806	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8808	48		pha				pha 								; save a copy
.8809	55 51		eor $51,x			eor 	NSStatus+1,x
.880b	29 10		and #$10			and 	#NSBIsString
.880d	d0 0b		bne $881a			bne 	_ASError
.880f	68		pla				pla 								; get back
.8810	29 10		and #$10			and 	#NSBIsString 				; check type
.8812	d0 03		bne $8817			bne 	_ASString
.8814	4c 15 96	jmp $9615			jmp 	AssignNumber
.8817					_ASString:
.8817	4c 73 96	jmp $9673			jmp 	AssignString
.881a					_ASError:
.881a	4c ba 9f	jmp $9fba			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.881d					Command_List:
.881d	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.8820	b1 30		lda ($30),y			lda 	(codePtr),y
.8822	29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.8824	c9 40		cmp #$40			cmp 	#$40  						; of code.
.8826	f0 69		beq $8891			beq 	_CLListProcedure
.8828	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.882a	64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.882c	a9 ff		lda #$ff			lda 	#$FF
.882e	85 5f		sta $5f				sta 	NSMantissa0+7
.8830	85 67		sta $67				sta 	NSMantissa1+7
.8832	b1 30		lda ($30),y			lda 	(codePtr),y
.8834	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8836	f0 1a		beq $8852			beq 	_CLSecond
.8838	20 0e 89	jsr $890e			jsr 	CLIsDigit 					; if not digit, list all
.883b	b0 20		bcs $885d			bcs 	_CLStart
.883d	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.883f	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger
.8842	b1 30		lda ($30),y			lda 	(codePtr),y
.8844	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8846	f0 0a		beq $8852			beq 	_CLSecond 					; if so go get it
.8848	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.884a	85 5f		sta $5f				sta 	NSMantissa0+7
.884c	a5 64		lda $64				lda 	NSMantissa1+4
.884e	85 67		sta $67				sta 	NSMantissa1+7
.8850	80 0b		bra $885d			bra 	_CLStart
.8852					_CLSecond:
.8852	c8		iny				iny 								; consume comma
.8853	20 0e 89	jsr $890e			jsr 	CLIsDigit 					; digit found
.8856	b0 05		bcs $885d			bcs 	_CLStart 					; if not, continue listing
.8858	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.885a	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger
.885d					_CLStart
.885d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.885f	85 30		sta $30				sta 	codePtr
.8861	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8863	85 31		sta $31				sta 	codePtr+1
.8865					_CLLoop:
.8865	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check here, as we want the option of breaking out of long lists.
.8868	f0 24		beq $888e			beq 	_CLExit
.886a	b2 30		lda ($30)			lda 	(codePtr)
.886c	f0 20		beq $888e			beq 	_CLExit
.886e	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8870	20 fd 88	jsr $88fd			jsr 	CLCompareLineNo
.8873	90 0c		bcc $8881			bcc 	_CLNext
.8875	a2 07		ldx #$07			ldx 	#7
.8877	20 fd 88	jsr $88fd			jsr 	CLCompareLineNo
.887a	f0 02		beq $887e			beq 	_CLDoThisOne
.887c	b0 03		bcs $8881			bcs 	_CLNext
.887e					_CLDoThisOne:
.887e	20 ea 88	jsr $88ea			jsr 	CLListOneLine 				; routine to list the current line.
.8881					_CLNext:
.8881	18		clc				clc
.8882	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8884	65 30		adc $30				adc 	codePtr
.8886	85 30		sta $30				sta 	codePtr
.8888	90 02		bcc $888c			bcc 	_CREExit
.888a	e6 31		inc $31				inc 	codePtr+1 					; carry
.888c					_CREExit:
.888c	80 d7		bra $8865			bra 	_CLLoop
.888e					_CLExit:
.888e	4c 8e 83	jmp $838e			jmp 	WarmStart
.8891					_CLListProcedure:
.8891	b1 30		lda ($30),y			lda 	(codePtr),y
.8893	85 38		sta $38				sta 	zTemp1
.8895	c8		iny				iny
.8896	b1 30		lda ($30),y			lda 	(codePtr),y
.8898	85 39		sta $39				sta 	zTemp1+1
.889a	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.889c	85 30		sta $30				sta 	codePtr
.889e	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88a0	85 31		sta $31				sta 	codePtr+1
.88a2					_CLLPSearch:
.88a2	b2 30		lda ($30)			lda 	(codePtr)
.88a4	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.88a6	f0 e6		beq $888e			beq 	_CLExit
.88a8	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.88aa	b1 30		lda ($30),y			lda 	(codePtr),y
.88ac	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.88ae	d0 0e		bne $88be			bne 	_CLLPNext
.88b0	c8		iny				iny 								; check if PROC this.
.88b1	b1 30		lda ($30),y			lda 	(codePtr),y
.88b3	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.88b5	d0 07		bne $88be			bne 	_CLLPNext
.88b7	c8		iny				iny
.88b8	b1 30		lda ($30),y			lda 	(codePtr),y
.88ba	c5 39		cmp $39				cmp 	zTemp1+1
.88bc	f0 0d		beq $88cb			beq 	_CLLPFound
.88be					_CLLPNext:
.88be	18		clc				clc
.88bf	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88c1	65 30		adc $30				adc 	codePtr
.88c3	85 30		sta $30				sta 	codePtr
.88c5	90 02		bcc $88c9			bcc 	_CREExit
.88c7	e6 31		inc $31				inc 	codePtr+1 					; carry
.88c9					_CREExit:
.88c9	80 d7		bra $88a2			bra 	_CLLPSearch
.88cb					_CLLPFound:
.88cb	b2 30		lda ($30)			lda 	(codePtr)
.88cd	f0 bf		beq $888e			beq 	_CLExit
.88cf	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.88d1	b1 30		lda ($30),y			lda 	(codePtr),y
.88d3	48		pha				pha
.88d4	20 ea 88	jsr $88ea			jsr 	CLListOneLine 				; list line and go forward
.88d7	18		clc				clc
.88d8	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88da	65 30		adc $30				adc 	codePtr
.88dc	85 30		sta $30				sta 	codePtr
.88de	90 02		bcc $88e2			bcc 	_CREExit
.88e0	e6 31		inc $31				inc 	codePtr+1 					; carry
.88e2					_CREExit:
.88e2	68		pla				pla 								; reached ENDPROC ?
.88e3	c9 a8		cmp #$a8			cmp 	#KWD_ENDPROC
.88e5	d0 e4		bne $88cb			bne 	_CLLPFound
.88e7	4c 8e 83	jmp $838e			jmp 	WarmStart
.88ea					CLListOneLine:
.88ea	20 52 8e	jsr $8e52			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.88ed	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.88f0	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.88f2	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.88f4	20 69 8f	jsr $8f69			jsr 	PrintStringXA
.88f7	a9 0d		lda #$0d			lda 	#13 						; new line
.88f9	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.88fc	60		rts				rts
.88fd					CLCompareLineNo:
.88fd	38		sec				sec
.88fe	a0 01		ldy #$01			ldy 	#1
.8900	b1 30		lda ($30),y			lda 	(codePtr),y
.8902	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8904	85 36		sta $36				sta 	zTemp0
.8906	c8		iny				iny
.8907	b1 30		lda ($30),y			lda 	(codePtr),y
.8909	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.890b	05 36		ora $36				ora 	zTemp0
.890d	60		rts				rts
.890e					CLIsDigit:
.890e	b1 30		lda ($30),y			lda 	(codePtr),y
.8910	c9 30		cmp #$30			cmp 	#"0"
.8912	90 03		bcc $8917			bcc	 	_CLIDExitFalse
.8914	c9 3a		cmp #$3a			cmp 	#"9"+1
.8916	60		rts				rts
.8917					_CLIDExitFalse:
.8917	38		sec				sec
.8918	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8919					Command_LOCAL:
.8919	a2 00		ldx #$00			ldx 	#0 							; at level 0
.891b	20 27 89	jsr $8927			jsr 	LocaliseNextTerm 			; convert term to a local.
.891e	b1 30		lda ($30),y			lda 	(codePtr),y
.8920	c8		iny				iny
.8921	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8923	f0 f4		beq $8919			beq 	Command_LOCAL 				; if so, localise another variable.
.8925	88		dey				dey 								; unpick pre-get
.8926	60		rts				rts
.8927					LocaliseNextTerm:
.8927	20 5e 98	jsr $985e			jsr 	EvaluateTerm 				; evaluate the term
.892a	b5 50		lda $50,x			lda 	NSStatus,x
.892c	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.892e	f0 5c		beq $898c			beq		_LNTError
.8930	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8932	85 36		sta $36				sta 	zTemp0
.8934	b5 60		lda $60,x			lda 	NSMantissa1,x
.8936	85 37		sta $37				sta  	zTemp0+1
.8938	b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.893a	29 10		and #$10			and 	#NSBIsString
.893c	d0 1e		bne $895c			bne 	_LNTPushString
.893e	5a		phy				phy
.893f	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.8941					_LNTPushNumLoop:
.8941	b1 36		lda ($36),y			lda		(zTemp0),y
.8943	20 a4 a6	jsr $a6a4			jsr 	StackPushByte
.8946	c8		iny				iny
.8947	c0 05		cpy #$05			cpy 	#5
.8949	d0 f6		bne $8941			bne 	_LNTPushNumLoop
.894b	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.894d	20 a4 a6	jsr $a6a4			jsr 	StackPushByte
.8950	a5 37		lda $37				lda 	zTemp0+1
.8952	20 a4 a6	jsr $a6a4			jsr 	StackPushByte
.8955	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.8957	20 a4 a6	jsr $a6a4			jsr 	StackPushByte
.895a	7a		ply				ply
.895b	60		rts				rts
.895c					_LNTPushString:
.895c	5a		phy				phy
.895d	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.895f	85 38		sta $38				sta 	zTemp1
.8961	a0 01		ldy #$01			ldy 	#1
.8963	b1 36		lda ($36),y			lda 	(zTemp0),y
.8965	85 39		sta $39				sta 	zTemp1+1
.8967	a0 00		ldy #$00			ldy 	#0 							; output string
.8969	c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.896b	f0 0a		beq $8977			beq 	_LNTStringOut
.896d					_LNTPushStrLoop:
.896d	b1 38		lda ($38),y			lda 	(zTemp1),y
.896f	f0 06		beq $8977			beq 	_LNTStringOut
.8971	20 a4 a6	jsr $a6a4			jsr 	StackPushByte
.8974	c8		iny				iny
.8975	80 f6		bra $896d			bra 	_LNTPushStrLoop
.8977					_LNTStringOut:
.8977	98		tya				tya									; output length (chars written).
.8978	20 a4 a6	jsr $a6a4			jsr 	StackPushByte
.897b	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.897d	20 a4 a6	jsr $a6a4			jsr 	StackPushByte
.8980	b5 60		lda $60,x			lda 	NSMantissa1,x
.8982	20 a4 a6	jsr $a6a4			jsr 	StackPushByte
.8985	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8987	20 a4 a6	jsr $a6a4			jsr 	StackPushByte
.898a	7a		ply				ply
.898b	60		rts				rts
.898c					_LNTError:
.898c	4c b0 9f	jmp $9fb0			jmp 	SyntaxError
.898f					LocalPopValue:
.898f	20 bc a6	jsr $a6bc			jsr 	StackPopByte
.8992	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8994	d0 17		bne $89ad			bne 	_LPVString
.8996	20 bc a6	jsr $a6bc			jsr 	StackPopByte 				; address
.8999	85 37		sta $37				sta 	zTemp0+1
.899b	20 bc a6	jsr $a6bc			jsr 	StackPopByte
.899e	85 36		sta $36				sta 	zTemp0
.89a0	5a		phy				phy
.89a1	a0 04		ldy #$04			ldy 	#4 							; copy back
.89a3					_LPVNumberCopy:
.89a3	20 bc a6	jsr $a6bc			jsr 	StackPopByte
.89a6	91 36		sta ($36),y			sta 	(zTemp0),y
.89a8	88		dey				dey
.89a9	10 f8		bpl $89a3			bpl 	_LPVNumberCopy
.89ab	7a		ply				ply 								; and complete
.89ac	60		rts				rts
.89ad					_LPVString:
.89ad	20 bc a6	jsr $a6bc			jsr 	StackPopByte 				; address of record copied to zTemp0
.89b0	85 37		sta $37				sta 	zTemp0+1
.89b2	20 bc a6	jsr $a6bc			jsr 	StackPopByte
.89b5	85 36		sta $36				sta 	zTemp0
.89b7	5a		phy				phy
.89b8	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.89ba	85 38		sta $38				sta 	zTemp1
.89bc	a0 01		ldy #$01			ldy 	#1
.89be	b1 36		lda ($36),y			lda 	(zTemp0),y
.89c0	85 39		sta $39				sta 	zTemp1+1
.89c2	20 bc a6	jsr $a6bc			jsr 	StackPopByte 				; # chars to get => y
.89c5	a8		tay				tay
.89c6	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.89c8	f0 0e		beq $89d8			beq 	_LPVStringCopied
.89ca	a9 00		lda #$00			lda 	#0 							; NULL on end
.89cc	91 38		sta ($38),y			sta 	(zTemp1),y
.89ce					_LPVStringCopy:
.89ce	88		dey				dey
.89cf	30 07		bmi $89d8			bmi 	_LPVStringCopied
.89d1	20 bc a6	jsr $a6bc			jsr 	StackPopByte
.89d4	91 38		sta ($38),y			sta 	(zTemp1),y
.89d6	80 f6		bra $89ce			bra 	_LPVStringCopy
.89d8					_LPVStringCopied:
.89d8	fa		plx				plx
.89d9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.89da					NewCommand:
.89da	20 e0 89	jsr $89e0			jsr 	NewProgram 					; does the actual NEW.
.89dd	4c 8e 83	jmp $838e			jmp 	WarmStart 					; and warm starts straight away.
.89e0					NewProgram:
.89e0	20 81 a5	jsr $a581			jsr 	MemoryNew
.89e3	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.89e6	20 24 84	jsr $8424			jsr 	ClearCommand 				; clear everything.
.89e9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.89ea					CallProcedure:
.89ea	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.89ec	b1 30		lda ($30),y			lda 	(codePtr),y
.89ee	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.89f0	f0 0c		beq $89fe			beq 	_CPEndParam
.89f2					_CPParamLoop:
.89f2	20 77 9d	jsr $9d77			jsr 	EvaluateValue 				; get parameter onto stack
.89f5	e8		inx				inx 								; bump next stack
.89f6	b1 30		lda ($30),y			lda 	(codePtr),y
.89f8	c8		iny				iny
.89f9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.89fb	f0 f5		beq $89f2			beq 	_CPParamLoop
.89fd	88		dey				dey 								; unpick.
.89fe					_CPEndParam:
.89fe	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8a01	c8		iny				iny									; skip right bracket
.8a02	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8a04	20 c5 a6	jsr $a6c5			jsr 	StackOpen
.8a07	20 0a a7	jsr $a70a			jsr 	STKSaveCodePosition 		; save loop position
.8a0a	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8a0c	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8a0e	a5 60		lda $60				lda 	NSMantissa1
.8a10	85 37		sta $37				sta 	zTemp0+1
.8a12	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8a14	b2 36		lda ($36)			lda 	(zTemp0)
.8a16	85 30		sta $30				sta 	safePtr
.8a18	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a1a	85 31		sta $31				sta 	safePtr+1
.8a1c	c8		iny				iny
.8a1d	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a1f	85 32		sta $32				sta 	safePtr+2
.8a21	c8		iny				iny
.8a22	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a24	85 33		sta $33				sta 	safePtr+3
.8a26	c8		iny				iny 								; get Y offset -> Y
.8a27	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a29	a8		tay				tay
.8a2a	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8a2c	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check zero parameters at the start
.8a2f	f0 13		beq $8a44			beq 	_ParamExit 					; if so, exit.
.8a31					_ParamExtract:
.8a31	ca		dex				dex 								; put a local term on the level before
.8a32	20 27 89	jsr $8927			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8a35	20 06 88	jsr $8806			jsr 	AssignVariable 				; assign stacked value to the variable.
.8a38	e8		inx				inx 								; advance to next parameter to do.
.8a39	e8		inx				inx
.8a3a	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8a3d	f0 05		beq $8a44			beq 	_ParamExit
.8a3f	20 ff 8e	jsr $8eff			jsr 	CheckComma 					; comma seperating parameters
.8a42	80 ed		bra $8a31			bra 	_ParamExtract
.8a44					_ParamExit:
.8a44	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket 			; check )
.8a47	60		rts				rts 								; and continue from here
.8a48					Command_ENDPROC:
.8a48	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8a4a	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8a4c	20 f2 a6	jsr $a6f2			jsr 	StackCheckFrame
.8a4f	20 1b a7	jsr $a71b			jsr 	STKLoadCodePosition 		; restore code position
.8a52	20 e4 a6	jsr $a6e4			jsr 	StackClose
.8a55	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8a56					Command_Read:
.8a56	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8a58	20 5e 98	jsr $985e			jsr 	EvaluateTerm
.8a5b	b5 50		lda $50,x			lda 	NSStatus,x
.8a5d	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8a5f	f0 4f		beq $8ab0			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.8a61	20 f9 8a	jsr $8af9			jsr 	SwapDataCodePtrs 			; swap code and data
.8a64	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8a67	d0 25		bne $8a8e			bne 	_CRContinueData  			; forward for the next one.
.8a69	b2 30		lda ($30)			lda 	(codePtr)
.8a6b	f0 1c		beq $8a89			beq 	_CRNoData
.8a6d					_CRKeepSearching:
.8a6d	a9 b4		lda #$b4			lda 	#KWD_DATA 					; scan for instruction
.8a6f	a2 80		ldx #$80			ldx 	#KWC_EOL
.8a71	20 ef 8d	jsr $8def			jsr 	ScanForward
.8a74	c9 b4		cmp #$b4			cmp 	#KWD_DATA 					; found data ?
.8a76	f0 16		beq $8a8e			beq 	_CRHaveData 				; found it
.8a78	18		clc				clc
.8a79	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a7b	65 30		adc $30				adc 	codePtr
.8a7d	85 30		sta $30				sta 	codePtr
.8a7f	90 02		bcc $8a83			bcc 	_CREExit
.8a81	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a83					_CREExit:
.8a83	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8a85	b2 30		lda ($30)			lda 	(codePtr)
.8a87	d0 e4		bne $8a6d			bne 	_CRKeepSearching
.8a89					_CRNoData:
.8a89	a9 0b		lda #$0b		lda	#11
.8a8b	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.8a8e					_CRHaveData:
.8a8e					_CRContinueData:
.8a8e	a2 01		ldx #$01			ldx 	#1
.8a90	20 77 9d	jsr $9d77			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a93	ca		dex				dex
.8a94	20 06 88	jsr $8806			jsr		AssignVariable 				; do the assignment
.8a97	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data flag
.8a9a	b1 30		lda ($30),y			lda 	(codePtr),y
.8a9c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.8a9e	d0 04		bne $8aa4			bne 	_CRSwapBack
.8aa0	c8		iny				iny 								; consume comma
.8aa1	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8aa4					_CRSwapBack:
.8aa4	20 f9 8a	jsr $8af9			jsr 	SwapDataCodePtrs			; swap them back.
.8aa7	b1 30		lda ($30),y			lda 	(codePtr),y
.8aa9	c8		iny				iny
.8aaa	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8aac	f0 a8		beq $8a56			beq 	Command_Read 				; if so go round again.
.8aae	88		dey				dey 								; unpick get.
.8aaf	60		rts				rts
.8ab0					_CRSyntax:
.8ab0	4c b0 9f	jmp $9fb0			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8ab3					RemCommand:
.8ab3	b1 30		lda ($30),y			lda 	(codePtr),y
.8ab5	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8ab7	d0 06		bne $8abf			bne 	_RMExit
.8ab9	c8		iny				iny 								; point to offset
.8aba	98		tya				tya 								; A = offset position
.8abb	38		sec				sec 								; add size +1 hence SEC
.8abc	71 30		adc ($30),y			adc 	(codePtr),y
.8abe	a8		tay				tay 								; make current position.
.8abf					_RMExit:
.8abf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8ac0					Command_REPEAT:
.8ac0	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8ac2	20 c5 a6	jsr $a6c5			jsr 	StackOpen
.8ac5	20 0a a7	jsr $a70a			jsr 	STKSaveCodePosition 		; save loop position
.8ac8	60		rts				rts
.8ac9					Command_UNTIL:
.8ac9	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8acb	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8acd	20 f2 a6	jsr $a6f2			jsr 	StackCheckFrame
.8ad0	a2 00		ldx #$00			ldx 	#0
.8ad2	20 80 9d	jsr $9d80			jsr 	EvaluateNumber 				; work out the number
.8ad5	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; check if zero
.8ad8	f0 04		beq $8ade			beq 	_CULoopBack 				; if so keep looping
.8ada	20 e4 a6	jsr $a6e4			jsr 	StackClose		 			; return
.8add	60		rts				rts
.8ade					_CULoopBack:
.8ade	20 1b a7	jsr $a71b			jsr 	STKLoadCodePosition 		; loop back
.8ae1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8ae2					Command_Restore:
.8ae2	20 f9 8a	jsr $8af9			jsr 	SwapDataCodePtrs 			; swap code and data
.8ae5	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ae7	85 30		sta $30				sta 	codePtr
.8ae9	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8aeb	85 31		sta $31				sta 	codePtr+1
.8aed	20 f9 8a	jsr $8af9			jsr 	SwapDataCodePtrs 			; put them back
.8af0	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8af2	8d 1b 04	sta $041b			sta 	dataPointer+4   			; (read checks not EOF)
.8af5	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8af8	60		rts				rts
.8af9					SwapDataCodePtrs:
.8af9	da		phx				phx
.8afa	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8afc					_SDCPLoop:
.8afc	b5 30		lda $30,x			lda 	safePtr,x
.8afe	48		pha				pha
.8aff	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8b02	95 30		sta $30,x			sta 	safePtr,x
.8b04	68		pla				pla
.8b05	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8b08	ca		dex				dex
.8b09	10 f1		bpl $8afc			bpl 	_SDCPLoop
.8b0b	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8b0e	8c 1b 04	sty $041b			sty 	dataPointer+4
.8b11	a8		tay				tay
.8b12	fa		plx				plx
.8b13	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8b14					EOLCommand:
.8b14	18		clc				clc
.8b15	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8b17	65 30		adc $30				adc 	codePtr
.8b19	85 30		sta $30				sta 	codePtr
.8b1b	90 02		bcc $8b1f			bcc 	_CREExit
.8b1d	e6 31		inc $31				inc 	codePtr+1 					; carry
.8b1f					_CREExit:
.8b1f	80 0b		bra $8b2c			bra 	RunNewLine
.8b21					CommandRUN:
.8b21	20 24 84	jsr $8424			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8b24	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b26	85 30		sta $30				sta 	codePtr
.8b28	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b2a	85 31		sta $31				sta 	codePtr+1
.8b2c					RUNNewLine:
.8b2c	b2 30		lda ($30)			lda 	(codePtr)
.8b2e	f0 7b		beq $8bab			beq 	CRNoProgram         		; no then END.
.8b30	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8b32	9a		txs				txs
.8b33					RUNCodePointerLine:
.8b33	a0 02		ldy #$02			ldy 	#2 							; start of program
.8b35					_CRIncMainLoop:
.8b35	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8b38	d0 22		bne $8b5c			bne 	_CRNoBreakCheck
.8b3a	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8b3d	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8b40	f0 64		beq $8ba6			beq 	_CRBreak
.8b42	a5 01		lda $01				lda 	1 							; save I/O 0
.8b44	48		pha				pha
.8b45	64 01		stz $01				stz 	1 							; access I/O Page 0
.8b47	38		sec				sec 								; calculate timer - LastTick
.8b48	ad 59 d6	lda $d659			lda 	$D659
.8b4b	aa		tax				tax 								; saving timer in X
.8b4c	ed 5b 06	sbc $065b			sbc 	LastTick
.8b4f	c9 03		cmp #$03			cmp 	#3
.8b51	90 06		bcc $8b59			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8b53	8e 5b 06	stx $065b			stx 	LastTick 					; update last timer
.8b56	20 5d 9e	jsr $9e5d			jsr 	TickHandler 							; go do the code.
.8b59					_NoFireTick:
.8b59	68		pla				pla 								; restore I/O 0
.8b5a	85 01		sta $01				sta 	1
.8b5c					_CRNoBreakCheck:
.8b5c	c8		iny				iny									; next token
.8b5d					_CRMainLoop:
.8b5d	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8b60	b1 30		lda ($30),y			lda 	(codePtr),y
.8b62	10 10		bpl $8b74			bpl 	_CRNotKeyword				; not a token.
.8b64	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8b66	b0 04		bcs $8b6c			bcs 	_CRIsKeyword
.8b68	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8b6a	b0 34		bcs $8ba0			bcs		_CRSyntaxError
.8b6c					_CRIsKeyword:
.8b6c	c8		iny				iny 								; consume command
.8b6d	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8b6e	aa		tax				tax 								; put in X for vector jump
.8b6f	20 a3 8b	jsr $8ba3			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8b72	80 e9		bra $8b5d			bra 	_CRMainLoop 				; and loop round
.8b74					_CRNotKeyword:
.8b74	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8b76	f0 bd		beq $8b35			beq 	_CRIncMainLoop
.8b78	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8b7a	90 05		bcc $8b81			bcc 	_CRNotVariable
.8b7c					_CRGoLet:
.8b7c	20 cd 87	jsr $87cd			jsr 	LetCommand
.8b7f	80 dc		bra $8b5d			bra 	_CRMainLoop
.8b81					_CRNotVariable:
.8b81	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8b83	f0 f7		beq $8b7c			beq 	_CRGoLet
.8b85	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8b87	f0 f3		beq $8b7c			beq 	_CRGoLet
.8b89	c9 21		cmp #$21			cmp 	#KWD_PLING
.8b8b	f0 ef		beq $8b7c			beq 	_CRGoLet
.8b8d	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8b8f	f0 09		beq $8b9a			beq 	_CRGoRem
.8b91	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8b93	d0 0b		bne $8ba0			bne 	_CRSyntaxError
.8b95	20 12 82	jsr $8212			jsr 	LabelHere
.8b98	80 c3		bra $8b5d			bra 	_CRMainLoop
.8b9a					_CRGoRem:
.8b9a	c8		iny				iny
.8b9b	20 b3 8a	jsr $8ab3			jsr 	RemCommand
.8b9e	80 bd		bra $8b5d			bra 	_CRMainLoop
.8ba0					_CRSyntaxError:
.8ba0	4c b0 9f	jmp $9fb0			jmp 	SyntaxError
.8ba3					_CRCallVector0:
.8ba3	7c 42 8c	jmp ($8c42,x)			jmp 	(VectorSet0,x)
.8ba6					_CRBreak:
.8ba6	a9 01		lda #$01		lda	#1
.8ba8	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.8bab					CRNoProgram:
.8bab	4c 72 85	jmp $8572			jmp 	EndCommand
.8bae					Shift1Command:
.8bae	b1 30		lda ($30),y			lda 	(codePtr),y
.8bb0	c8		iny				iny
.8bb1	0a		asl a				asl 	a
.8bb2	aa		tax				tax
.8bb3	7c e8 8c	jmp ($8ce8,x)			jmp 	(VectorSet1,x)
.8bb6					Shift2Command:
.8bb6	b1 30		lda ($30),y			lda 	(codePtr),y
.8bb8	c8		iny				iny
.8bb9	0a		asl a				asl 	a
.8bba	aa		tax				tax
.8bbb	7c 10 8d	jmp ($8d10,x)			jmp 	(VectorSet2,x)
.8bbe					Unused1:
.8bbe					Unused2:
.8bbe					Unused3:
.8bbe					Unused4:
.8bbe	4c b0 9f	jmp $9fb0			jmp 	SyntaxError
>8bc1							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8bc2					VectorSetPunc:
>8bc2	c8 91					.word	ShiftLeft                        ; $00 <<
>8bc4	b3 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8bc6	a9 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8bc8	b0 9f					.word	SyntaxError                      ; $03 !!3
>8bca	b0 9f					.word	SyntaxError                      ; $04 ><
>8bcc	bd 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8bce	cb 91					.word	ShiftRight                       ; $06 >>
>8bd0	b0 9f					.word	SyntaxError                      ; $07 !!7
>8bd2	b0 9f					.word	SyntaxError                      ; $08 !!8
>8bd4	b0 9f					.word	SyntaxError                      ; $09 !!9
>8bd6	b0 9f					.word	SyntaxError                      ; $0a !!10
>8bd8	b0 9f					.word	SyntaxError                      ; $0b !!11
>8bda	b0 9f					.word	SyntaxError                      ; $0c !!12
>8bdc	b0 9f					.word	SyntaxError                      ; $0d !!13
>8bde	b0 9f					.word	SyntaxError                      ; $0e !!14
>8be0	b0 9f					.word	SyntaxError                      ; $0f !!15
>8be2	b0 9f					.word	SyntaxError                      ; $10 @
>8be4	b0 9f					.word	SyntaxError                      ; $11 !!17
>8be6	b0 9f					.word	SyntaxError                      ; $12 !!18
>8be8	b0 9f					.word	SyntaxError                      ; $13 [
>8bea	74 90					.word	IntegerDivide                    ; $14 \
>8bec	b0 9f					.word	SyntaxError                      ; $15 ]
>8bee	06 93					.word	EorInteger                       ; $16 ^
>8bf0	b0 9f					.word	SyntaxError                      ; $17 _
>8bf2	b0 9f					.word	SyntaxError                      ; $18 `
>8bf4	b0 9f					.word	SyntaxError                      ; $19 !!25
>8bf6	b0 9f					.word	SyntaxError                      ; $1a !!26
>8bf8	b0 9f					.word	SyntaxError                      ; $1b {
>8bfa	d1 92					.word	OraInteger                       ; $1c |
>8bfc	b0 9f					.word	SyntaxError                      ; $1d }
>8bfe	b0 9f					.word	SyntaxError                      ; $1e ~
>8c00	b0 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8c02	b0 9f					.word	SyntaxError                      ; $20
>8c04	3b 93					.word	WordIndirect                     ; $21 !
>8c06	b0 9f					.word	SyntaxError                      ; $22 "
>8c08	b0 9f					.word	SyntaxError                      ; $23 #
>8c0a	b0 9f					.word	SyntaxError                      ; $24 $
>8c0c	b5 90					.word	IntegerModulus                   ; $25 %
>8c0e	9c 92					.word	AndInteger                       ; $26 &
>8c10	b0 9f					.word	SyntaxError                      ; $27 '
>8c12	b0 9f					.word	SyntaxError                      ; $28 (
>8c14	b0 9f					.word	SyntaxError                      ; $29 )
>8c16	23 91					.word	MulInteger                       ; $2a *
>8c18	3e 92					.word	AddInteger                       ; $2b +
>8c1a	b0 9f					.word	SyntaxError                      ; $2c ,
>8c1c	77 92					.word	SubInteger                       ; $2d -
>8c1e	b0 9f					.word	SyntaxError                      ; $2e .
>8c20	f5 94					.word	FDivideCommand                   ; $2f /
>8c22	b0 9f					.word	SyntaxError                      ; $30 0
>8c24	b0 9f					.word	SyntaxError                      ; $31 1
>8c26	b0 9f					.word	SyntaxError                      ; $32 2
>8c28	b0 9f					.word	SyntaxError                      ; $33 3
>8c2a	b0 9f					.word	SyntaxError                      ; $34 4
>8c2c	b0 9f					.word	SyntaxError                      ; $35 5
>8c2e	b0 9f					.word	SyntaxError                      ; $36 6
>8c30	b0 9f					.word	SyntaxError                      ; $37 7
>8c32	b0 9f					.word	SyntaxError                      ; $38 8
>8c34	b0 9f					.word	SyntaxError                      ; $39 9
>8c36	b0 9f					.word	SyntaxError                      ; $3a :
>8c38	b0 9f					.word	SyntaxError                      ; $3b ;
>8c3a	95 8f					.word	BinaryCompareLess                ; $3c <
>8c3c	8b 8f					.word	BinaryCompareEqual               ; $3d =
>8c3e	9f 8f					.word	BinaryCompareGreater             ; $3e >
>8c40	5d 93					.word	ByteIndirect                     ; $3f ?
.8c42					VectorSet0:
>8c42	14 8b					.word	EOLCommand                       ; $80 !0:EOF
>8c44	ae 8b					.word	Shift1Command                    ; $81 !1:SH1
>8c46	b6 8b					.word	Shift2Command                    ; $82 !2:SH2
>8c48	da 99					.word	AbsUnary                         ; $83 ABS(
>8c4a	e8 99					.word	AllocUnary                       ; $84 ALLOC(
>8c4c	58 9a					.word	AscUnary                         ; $85 ASC(
>8c4e	18 9c					.word	ChrUnary                         ; $86 CHR$(
>8c50	68 9a					.word	DeekUnary                        ; $87 DEEK(
>8c52	01 a4					.word	UnaryEvent                       ; $88 EVENT(
>8c54	87 8f					.word	UnaryFalse                       ; $89 FALSE
>8c56	7a 9a					.word	FracUnary                        ; $8a FRAC(
>8c58	9d a3					.word	UnaryHit                         ; $8b HIT(
>8c5a	8f 9a					.word	IntUnary                         ; $8c INT(
>8c5c	d7 9b					.word	IsValUnary                       ; $8d ISVAL(
>8c5e	85 a4					.word	UnaryJoyB                        ; $8e JOYB(
>8c60	5e a4					.word	UnaryJoyX                        ; $8f JOYX(
>8c62	61 a4					.word	UnaryJoyY                        ; $90 JOYY(
>8c64	eb 9c					.word	Unary_Left                       ; $91 LEFT$(
>8c66	a0 9a					.word	LenUnary                         ; $92 LEN(
>8c68	be 9a					.word	Unary_Max                        ; $93 MAX(
>8c6a	0d 9d					.word	Unary_Mid                        ; $94 MID$(
>8c6c	ba 9a					.word	Unary_Min                        ; $95 MIN(
>8c6e	09 9b					.word	Unary_Not                        ; $96 NOT(
>8c70	65 9a					.word	PeekUnary                        ; $97 PEEK(
>8c72	22 a6					.word	UnaryPlaying                     ; $98 PLAYING(
>8c74	1c 9b					.word	Unary_Random                     ; $99 RANDOM(
>8c76	f8 9c					.word	Unary_Right                      ; $9a RIGHT$(
>8c78	39 9b					.word	Unary_Rnd                        ; $9b RND(
>8c7a	af 9b					.word	SgnUnary                         ; $9c SGN(
>8c7c	2a 9c					.word	SpcUnary                         ; $9d SPC(
>8c7e	45 9c					.word	Unary_Str                        ; $9e STR$(
>8c80	ab a4					.word	UnaryTimer                       ; $9f TIMER(
>8c82	7c 8f					.word	UnaryTrue                        ; $a0 TRUE
>8c84	cd 9b					.word	ValUnary                         ; $a1 VAL(
>8c86	75 85					.word	ForCommand                       ; $a2 FOR
>8c88	b8 86					.word	IfCommand                        ; $a3 IF
>8c8a	be 8b					.word	Unused1                          ; $a4 PROC
>8c8c	c0 8a					.word	Command_REPEAT                   ; $a5 REPEAT
>8c8e	65 8e					.word	Command_WHILE                    ; $a6 WHILE
>8c90	e1 86					.word	EndIf                            ; $a7 ENDIF
>8c92	48 8a					.word	Command_ENDPROC                  ; $a8 ENDPROC
>8c94	27 86					.word	NextCommand                      ; $a9 NEXT
>8c96	be 8b					.word	Unused4                          ; $aa THEN
>8c98	c9 8a					.word	Command_UNTIL                    ; $ab UNTIL
>8c9a	86 8e					.word	Command_WEND                     ; $ac WEND
>8c9c	b0 9f					.word	SyntaxError                      ; $ad BY
>8c9e	ef 83					.word	CallCommand                      ; $ae CALL
>8ca0	51 a1					.word	CircleCommand                    ; $af CIRCLE
>8ca2	24 84					.word	ClearCommand                     ; $b0 CLEAR
>8ca4	7c 84					.word	ClearScreen                      ; $b1 CLS
>8ca6	b0 9f					.word	SyntaxError                      ; $b2 COLOR
>8ca8	b0 9f					.word	SyntaxError                      ; $b3 COLOUR
>8caa	84 84					.word	Command_Data                     ; $b4 DATA
>8cac	8c 84					.word	DimCommand                       ; $b5 DIM
>8cae	4c 85					.word	DokeCommand                      ; $b6 DOKE
>8cb0	be 8b					.word	Unused3                          ; $b7 DOWNTO
>8cb2	da 86					.word	ElseCode                         ; $b8 ELSE
>8cb4	b0 9f					.word	SyntaxError                      ; $b9 FROM
>8cb6	70 a3					.word	GfxCommand                       ; $ba GFX
>8cb8	80 86					.word	Command_GOSUB                    ; $bb GOSUB
>8cba	9e 86					.word	GotoCommand                      ; $bc GOTO
>8cbc	b0 9f					.word	SyntaxError                      ; $bd HERE
>8cbe	7a a1					.word	ImageCommand                     ; $be IMAGE
>8cc0	e2 86					.word	Command_Input                    ; $bf INPUT
>8cc2	cd 87					.word	LetCommand                       ; $c0 LET
>8cc4	cc a1					.word	LineCommand                      ; $c1 LINE
>8cc6	19 89					.word	Command_LOCAL                    ; $c2 LOCAL
>8cc8	b0 9f					.word	SyntaxError                      ; $c3 OFF
>8cca	b0 9f					.word	SyntaxError                      ; $c4 ON
>8ccc	b0 9f					.word	SyntaxError                      ; $c5 OUTLINE
>8cce	c1 a3					.word	PaletteCommand                   ; $c6 PALETTE
>8cd0	c5 a1					.word	PlotCommand                      ; $c7 PLOT
>8cd2	49 85					.word	PokeCommand                      ; $c8 POKE
>8cd4	e9 86					.word	Command_Print                    ; $c9 PRINT
>8cd6	56 8a					.word	Command_Read                     ; $ca READ
>8cd8	4d a1					.word	RectangleCommand                 ; $cb RECT
>8cda	b3 8a					.word	RemCommand                       ; $cc REM
>8cdc	90 86					.word	Command_RETURN                   ; $cd RETURN
>8cde	b0 9f					.word	SyntaxError                      ; $ce SOLID
>8ce0	3e a6					.word	SoundCommand                     ; $cf SOUND
>8ce2	5c a1					.word	SpriteCommand                    ; $d0 SPRITE
>8ce4	96 a1					.word	TextCommand                      ; $d1 TEXT
>8ce6	be 8b					.word	Unused2                          ; $d2 TO
.8ce8					VectorSet1:
>8ce8	b0 9f					.word	SyntaxError                      ; $80 !0:EOF
>8cea	b0 9f					.word	SyntaxError                      ; $81 !1:SH1
>8cec	b0 9f					.word	SyntaxError                      ; $82 !2:SH2
>8cee	c3 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8cf0	df 83					.word	AssertCommand                    ; $84 ASSERT
>8cf2	10 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8cf4	72 85					.word	EndCommand                       ; $86 END
>8cf6	f6 a5					.word	Explode                          ; $87 EXPLODE
>8cf8	a2 a4					.word	GoCommand                        ; $88 GO
>8cfa	1d 88					.word	Command_List                     ; $89 LIST
>8cfc	99 a4					.word	LoadCommand                      ; $8a LOAD
>8cfe	da 89					.word	NewCommand                       ; $8b NEW
>8d00	d2 a5					.word	PingCommand                      ; $8c PING
>8d02	e2 8a					.word	Command_Restore                  ; $8d RESTORE
>8d04	21 8b					.word	CommandRUN                       ; $8e RUN
>8d06	ea a5					.word	ShootCommand                     ; $8f SHOOT
>8d08	55 a3					.word	SpritesCtrl                      ; $90 SPRITES
>8d0a	98 8d					.word	StopCommand                      ; $91 STOP
>8d0c	94 8e					.word	WhoCommand                       ; $92 WHO
>8d0e	de a5					.word	ZapCommand                       ; $93 ZAP
.8d10					VectorSet2:
>8d10	b0 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d12	b0 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d14	b0 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d16	6f 9e					.word	Assemble_adc                     ; $83 ADC
>8d18	67 9e					.word	Assemble_and                     ; $84 AND
>8d1a	83 9e					.word	Assemble_asl                     ; $85 ASL
>8d1c	ed 9e					.word	Assemble_bcc                     ; $86 BCC
>8d1e	f1 9e					.word	Assemble_bcs                     ; $87 BCS
>8d20	f9 9e					.word	Assemble_beq                     ; $88 BEQ
>8d22	b0 9e					.word	Assemble_bit                     ; $89 BIT
>8d24	e1 9e					.word	Assemble_bmi                     ; $8a BMI
>8d26	f5 9e					.word	Assemble_bne                     ; $8b BNE
>8d28	dd 9e					.word	Assemble_bpl                     ; $8c BPL
>8d2a	fd 9e					.word	Assemble_bra                     ; $8d BRA
>8d2c	01 9f					.word	Assemble_brk                     ; $8e BRK
>8d2e	e5 9e					.word	Assemble_bvc                     ; $8f BVC
>8d30	e9 9e					.word	Assemble_bvs                     ; $90 BVS
>8d32	09 9f					.word	Assemble_clc                     ; $91 CLC
>8d34	5d 9f					.word	Assemble_cld                     ; $92 CLD
>8d36	1d 9f					.word	Assemble_cli                     ; $93 CLI
>8d38	4d 9f					.word	Assemble_clv                     ; $94 CLV
>8d3a	7b 9e					.word	Assemble_cmp                     ; $95 CMP
>8d3c	c4 9e					.word	Assemble_cpx                     ; $96 CPX
>8d3e	bf 9e					.word	Assemble_cpy                     ; $97 CPY
>8d40	a1 9e					.word	Assemble_dec                     ; $98 DEC
>8d42	59 9f					.word	Assemble_dex                     ; $99 DEX
>8d44	35 9f					.word	Assemble_dey                     ; $9a DEY
>8d46	6b 9e					.word	Assemble_eor                     ; $9b EOR
>8d48	a6 9e					.word	Assemble_inc                     ; $9c INC
>8d4a	69 9f					.word	Assemble_inx                     ; $9d INX
>8d4c	55 9f					.word	Assemble_iny                     ; $9e INY
>8d4e	d8 9e					.word	Assemble_jmp                     ; $9f JMP
>8d50	d3 9e					.word	Assemble_jsr                     ; $a0 JSR
>8d52	77 9e					.word	Assemble_lda                     ; $a1 LDA
>8d54	9c 9e					.word	Assemble_ldx                     ; $a2 LDX
>8d56	ba 9e					.word	Assemble_ldy                     ; $a3 LDY
>8d58	8d 9e					.word	Assemble_lsr                     ; $a4 LSR
>8d5a	6d 9f					.word	Assemble_nop                     ; $a5 NOP
>8d5c	63 9e					.word	Assemble_ora                     ; $a6 ORA
>8d5e	19 9f					.word	Assemble_pha                     ; $a7 PHA
>8d60	05 9f					.word	Assemble_php                     ; $a8 PHP
>8d62	61 9f					.word	Assemble_phx                     ; $a9 PHX
>8d64	21 9f					.word	Assemble_phy                     ; $aa PHY
>8d66	29 9f					.word	Assemble_pla                     ; $ab PLA
>8d68	0d 9f					.word	Assemble_plp                     ; $ac PLP
>8d6a	75 9f					.word	Assemble_plx                     ; $ad PLX
>8d6c	31 9f					.word	Assemble_ply                     ; $ae PLY
>8d6e	88 9e					.word	Assemble_rol                     ; $af ROL
>8d70	92 9e					.word	Assemble_ror                     ; $b0 ROR
>8d72	15 9f					.word	Assemble_rti                     ; $b1 RTI
>8d74	25 9f					.word	Assemble_rts                     ; $b2 RTS
>8d76	7f 9e					.word	Assemble_sbc                     ; $b3 SBC
>8d78	11 9f					.word	Assemble_sec                     ; $b4 SEC
>8d7a	71 9f					.word	Assemble_sed                     ; $b5 SED
>8d7c	2d 9f					.word	Assemble_sei                     ; $b6 SEI
>8d7e	73 9e					.word	Assemble_sta                     ; $b7 STA
>8d80	65 9f					.word	Assemble_stp                     ; $b8 STP
>8d82	97 9e					.word	Assemble_stx                     ; $b9 STX
>8d84	b5 9e					.word	Assemble_sty                     ; $ba STY
>8d86	ab 9e					.word	Assemble_stz                     ; $bb STZ
>8d88	49 9f					.word	Assemble_tax                     ; $bc TAX
>8d8a	45 9f					.word	Assemble_tay                     ; $bd TAY
>8d8c	ce 9e					.word	Assemble_trb                     ; $be TRB
>8d8e	c9 9e					.word	Assemble_tsb                     ; $bf TSB
>8d90	51 9f					.word	Assemble_tsx                     ; $c0 TSX
>8d92	39 9f					.word	Assemble_txa                     ; $c1 TXA
>8d94	41 9f					.word	Assemble_txs                     ; $c2 TXS
>8d96	3d 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8d98					StopCommand:
.8d98	a9 08		lda #$08		lda	#8
.8d9a	4c 10 8f	jmp $8f10		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8d9d					ProcedureScan:
.8d9d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8d9f	85 30		sta $30				sta 	codePtr
.8da1	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8da3	85 31		sta $31				sta 	codePtr+1
.8da5					_PSLoop:
.8da5	b2 30		lda ($30)			lda 	(codePtr)
.8da7	f0 42		beq $8deb			beq 	_PSExit
.8da9	a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.8dab	b1 30		lda ($30),y			lda 	(codePtr),y
.8dad	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8daf	d0 2d		bne $8dde			bne 	_PSNext
.8db1	c8		iny				iny 								; get the address of the record to zTemp0 and
.8db2	b1 30		lda ($30),y			lda 	(codePtr),y
.8db4	29 c0		and #$c0			and 	#$C0
.8db6	c9 40		cmp #$40			cmp 	#$40
.8db8	d0 32		bne $8dec			bne 	_PSSyntax
.8dba	b1 30		lda ($30),y			lda 	(codePtr),y
.8dbc	18		clc				clc
.8dbd	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8dbf	85 37		sta $37				sta 	zTemp0+1
.8dc1	c8		iny				iny 								; LSB
.8dc2	b1 30		lda ($30),y			lda 	(codePtr),y
.8dc4	85 36		sta $36				sta 	zTemp0
.8dc6	c8		iny				iny 								; character after variable call.
.8dc7	98		tya				tya 								; save Y offset at +7 (exponent slot)
.8dc8	a0 07		ldy #$07			ldy 	#7
.8dca	91 36		sta ($36),y			sta 	(zTemp0),y
.8dcc	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8dce	a0 02		ldy #$02			ldy 	#2
.8dd0	91 36		sta ($36),y			sta 	(zTemp0),y
.8dd2	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.8dd4					_PSCopy:
.8dd4	b5 30		lda $30,x			lda 	safePtr,x
.8dd6	c8		iny				iny
.8dd7	91 36		sta ($36),y			sta 	(zTemp0),y
.8dd9	e8		inx				inx
.8dda	e0 04		cpx #$04			cpx 	#4
.8ddc	d0 f6		bne $8dd4			bne 	_PSCopy
.8dde					_PSNext:
.8dde	18		clc				clc
.8ddf	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8de1	65 30		adc $30				adc 	codePtr
.8de3	85 30		sta $30				sta 	codePtr
.8de5	90 02		bcc $8de9			bcc 	_CREExit
.8de7	e6 31		inc $31				inc 	codePtr+1 					; carry
.8de9					_CREExit:
.8de9	80 ba		bra $8da5			bra 	_PSLoop
.8deb					_PSExit:
.8deb	60		rts				rts
.8dec					_PSSyntax:
.8dec	4c b0 9f	jmp $9fb0			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8def					ScanForward:
.8def	64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.8df1	86 37		stx $37				stx 	zTemp0+1
.8df3	85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.8df5					_ScanLoop:
.8df5	b1 30		lda ($30),y			lda 	(codePtr),y
.8df7	c8		iny				iny
.8df8	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8dfa	d0 0e		bne $8e0a			bne 	_ScanGoNext
.8dfc	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8dfe	f0 04		beq $8e04			beq 	_ScanMatch
.8e00	c5 37		cmp $37				cmp 	zTemp0+1
.8e02	d0 06		bne $8e0a			bne 	_ScanGoNext
.8e04					_ScanMatch:
.8e04	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8e06	d0 01		bne $8e09			bne 	_ScanNotEndEOL
.8e08	88		dey				dey
.8e09					_ScanNotEndEOL:
.8e09	60		rts				rts
.8e0a					_ScanGoNext:
.8e0a	20 0f 8e	jsr $8e0f			jsr  	ScanForwardOne 				; allows for shifts and so on.
.8e0d	80 e6		bra $8df5			bra 	_ScanLoop
.8e0f					ScanForwardOne:
.8e0f	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.8e11	90 3e		bcc $8e51			bcc 	_SFWExit
.8e13	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.8e15	90 18		bcc $8e2f			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.8e17	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.8e19	b0 2f		bcs $8e4a			bcs 	_ScanSkipData
.8e1b	c9 a2		cmp #$a2			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8e1d	90 32		bcc $8e51			bcc 	_SFWExit 					; if not, ordinary keywords.
.8e1f	c9 ad		cmp #$ad			cmp 	#KWC_LAST_STRUCTURE+1
.8e21	b0 2e		bcs $8e51			bcs 	_SFWExit
.8e23	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8e25	c9 a7		cmp #$a7			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8e27	b0 28		bcs $8e51			bcs 	_SFWExit
.8e29	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8e2b	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8e2d	80 22		bra $8e51			bra 	_SFWExit
.8e2f					_ScanSkipOne:
.8e2f	c8		iny				iny 								; consume the extra one.
.8e30	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8e32	d0 1d		bne $8e51			bne 	_SFWExit
.8e34	18		clc				clc
.8e35	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e37	65 30		adc $30				adc 	codePtr
.8e39	85 30		sta $30				sta 	codePtr
.8e3b	90 02		bcc $8e3f			bcc 	_CREExit
.8e3d	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e3f					_CREExit:
.8e3f	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8e41	b2 30		lda ($30)			lda 	(codePtr)
.8e43	d0 0c		bne $8e51			bne 	_SFWExit 					; if not zero, more to scan
.8e45	a9 13		lda #$13		lda	#19
.8e47	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.8e4a					_ScanSkipData:
.8e4a	88		dey				dey 								; point at data token
.8e4b	c8		iny				iny 								; point to offset
.8e4c	98		tya				tya 								; A = offset position
.8e4d	38		sec				sec 								; add size +1 hence SEC
.8e4e	71 30		adc ($30),y			adc 	(codePtr),y
.8e50	a8		tay				tay 								; make current position.
.8e51					_SFWExit:
.8e51	60		rts				rts
.8e52					ScanGetCurrentLineStep:
.8e52	64 38		stz $38				stz 	zTemp1
.8e54	a0 03		ldy #$03			ldy 	#3
.8e56					_SGCLSLoop:
.8e56	b1 30		lda ($30),y			lda 	(codePtr),y
.8e58	c8		iny				iny
.8e59	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8e5b	f0 05		beq $8e62			beq 	_SGCLSExit
.8e5d	20 0f 8e	jsr $8e0f			jsr 	ScanForwardOne
.8e60	80 f4		bra $8e56			bra 	_SGCLSLoop
.8e62					_SGCLSExit:
.8e62	a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.8e64	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8e65					Command_WHILE:
.8e65	5a		phy				phy 								; save position of the test
.8e66	a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.8e68	20 80 9d	jsr $9d80			jsr 	EvaluateNumber
.8e6b	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; check if zero
.8e6e	f0 0e		beq $8e7e			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.8e70	98		tya				tya 								; position *after* test.
.8e71	7a		ply				ply 								; restore position before test, at WHILE
.8e72	88		dey				dey 								; so we execute the WHILE command again.
.8e73	48		pha				pha 								; push after test on the stack
.8e74	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8e76	20 c5 a6	jsr $a6c5			jsr 	StackOpen
.8e79	20 0a a7	jsr $a70a			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.8e7c	7a		ply				ply 								; restore the position *after* the test
.8e7d	60		rts				rts
.8e7e					_WHExitLoop:
.8e7e	68		pla				pla 								; throw post loop position
.8e7f	a9 ac		lda #$ac			lda 	#KWD_WEND 					; scan forward past WEND
.8e81	aa		tax				tax
.8e82	20 ef 8d	jsr $8def			jsr 	ScanForward
.8e85	60		rts				rts
.8e86					Command_WEND:
.8e86	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.8e88	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.8e8a	20 f2 a6	jsr $a6f2			jsr 	StackCheckFrame
.8e8d	20 1b a7	jsr $a71b			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.8e90	20 e4 a6	jsr $a6e4			jsr 	StackClose		 			; erase the frame
.8e93	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8e94					WhoCommand:
.8e94	a2 8e		ldx #$8e			ldx 	#(_WHOMessage >> 8)
.8e96	a9 9c		lda #$9c			lda 	#(_WHOMessage & $FF)
.8e98	20 69 8f	jsr $8f69			jsr 	PrintStringXA
.8e9b	60		rts				rts
.8e9c					_WHOMessage:
>8e9c	81						.byte 	$81
>8e9d	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8ea5	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8eb2	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8eba	20 41 6c 6c 61 69 72 65 0d
>8ec3	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8ecb	4f 62 65 72 72 65 75 74 65 72 0d
>8ed6	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8ede	62 73 6f 6e 0d
>8ee3	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8eeb	65 69 6e 67 61 72 74 6e 65 72 0d
>8ef6	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8ef7					CheckRightBracket:
.8ef7	b1 30		lda ($30),y			lda 	(codePtr),y
.8ef9	c8		iny				iny
.8efa	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8efc	d0 0f		bne $8f0d			bne 	CNAFail
.8efe	60		rts				rts
.8eff					CheckComma:
.8eff	b1 30		lda ($30),y			lda 	(codePtr),y
.8f01	c8		iny				iny
.8f02	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8f04	d0 07		bne $8f0d			bne 	CNAFail
.8f06	60		rts				rts
.8f07					CheckNextA:
.8f07	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8f09	d0 02		bne $8f0d			bne 	CNAFail
.8f0b	c8		iny				iny 								; skip character
.8f0c	60		rts				rts 								; and exit
.8f0d					CNAFail:
.8f0d	4c b0 9f	jmp $9fb0			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8f10					ErrorHandler:
.8f10	a8		tay				tay 								; find the error text
.8f11	f0 49		beq $8f5c			beq 	_EHEnd
.8f13	a2 00		ldx #$00			ldx 	#0
.8f15	a9 c9		lda #$c9			lda 	#((ErrorText) & $FF)
.8f17	85 36		sta $36				sta 	0+zTemp0
.8f19	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8f1b	85 37		sta $37				sta 	1+zTemp0
.8f1d					_EHFind:
.8f1d	88		dey				dey 								; keep looking through text
.8f1e	f0 0e		beq $8f2e			beq 	_EHFound
.8f20					_EHFindZero:
.8f20	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8f22	e6 36		inc $36				inc 	zTemp0
.8f24	d0 02		bne $8f28			bne 	_EHFNoCarry
.8f26	e6 37		inc $37				inc 	zTemp0+1
.8f28					_EHFNoCarry:
.8f28	c9 00		cmp #$00			cmp 	#0
.8f2a	d0 f4		bne $8f20			bne 	_EHFindZero
.8f2c	80 ef		bra $8f1d			bra 	_EHFind
.8f2e					_EHFound:
.8f2e	a5 36		lda $36				lda 	zTemp0 						; print message
.8f30	a6 37		ldx $37				ldx 	zTemp0+1
.8f32	20 69 8f	jsr $8f69			jsr 	PrintStringXA
.8f35	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8f37	b1 30		lda ($30),y			lda 	(codePtr),y
.8f39	d0 05		bne $8f40			bne 	_EHAtMsg
.8f3b	c8		iny				iny
.8f3c	b1 30		lda ($30),y			lda 	(codePtr),y
.8f3e	f0 17		beq $8f57			beq 	_EHCREnd
.8f40					_EHAtMsg:
.8f40	a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8f42	a9 5f		lda #$5f			lda 	#_AtMsg & $FF
.8f44	20 69 8f	jsr $8f69			jsr 	PrintStringXA
.8f47	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f49	b1 30		lda ($30),y			lda 	(codePtr),y
.8f4b	48		pha				pha
.8f4c	c8		iny				iny
.8f4d	b1 30		lda ($30),y			lda 	(codePtr),y
.8f4f	aa		tax				tax
.8f50	68		pla				pla
.8f51	20 7f 93	jsr $937f			jsr 	ConvertInt16 				; convert XA to string
.8f54	20 69 8f	jsr $8f69			jsr 	PrintStringXA 				; and print it.
.8f57					_EHCREnd:
.8f57	a9 0d		lda #$0d			lda 	#13 						; new line
.8f59	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f5c					_EHEnd:
.8f5c	4c 8e 83	jmp $838e			jmp 	WarmStart
>8f5f	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8f67	20 00
.8f69					PrintStringXA:
.8f69	5a		phy				phy
.8f6a	86 37		stx $37				stx 	zTemp0+1
.8f6c	85 36		sta $36				sta 	zTemp0
.8f6e	a0 00		ldy #$00			ldy 	#0
.8f70					_PSXALoop:
.8f70	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f72	f0 06		beq $8f7a			beq 	_PSXAExit
.8f74	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f77	c8		iny				iny
.8f78	80 f6		bra $8f70			bra 	_PSXALoop
.8f7a					_PSXAExit:
.8f7a	7a		ply				ply
.8f7b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f7c					UnaryTrue:
.8f7c	fa		plx				plx
.8f7d					ReturnTrue:
.8f7d	a9 01		lda #$01			lda 	#1  						; set to 1
.8f7f	20 34 9e	jsr $9e34			jsr 	NSMSetByte
.8f82	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f84	95 50		sta $50,x			sta 	NSStatus,x
.8f86	60		rts				rts
.8f87					UnaryFalse:
.8f87	fa		plx				plx
.8f88					ReturnFalse:
.8f88	4c 32 9e	jmp $9e32			jmp 	NSMSetZero 					; set it all to zero
.8f8b					BinaryCompareEqual:
.8f8b	fa		plx				plx
.8f8c	20 c7 8f	jsr $8fc7			jsr 	CompareBaseCode
.8f8f	c9 00		cmp #$00			cmp 	#0
.8f91	f0 ea		beq $8f7d			beq 	ReturnTrue
.8f93	80 f3		bra $8f88			bra 	ReturnFalse
.8f95					BinaryCompareLess:
.8f95	fa		plx				plx
.8f96	20 c7 8f	jsr $8fc7			jsr 	CompareBaseCode
.8f99	c9 ff		cmp #$ff			cmp 	#$FF
.8f9b	f0 e0		beq $8f7d			beq 	ReturnTrue
.8f9d	80 e9		bra $8f88			bra 	ReturnFalse
.8f9f					BinaryCompareGreater:
.8f9f	fa		plx				plx
.8fa0	20 c7 8f	jsr $8fc7			jsr 	CompareBaseCode
.8fa3	c9 01		cmp #$01			cmp 	#1
.8fa5	f0 d6		beq $8f7d			beq 	ReturnTrue
.8fa7	80 df		bra $8f88			bra 	ReturnFalse
.8fa9					BinaryCompareNotEqual:
.8fa9	fa		plx				plx
.8faa	20 c7 8f	jsr $8fc7			jsr 	CompareBaseCode
.8fad	c9 00		cmp #$00			cmp 	#0
.8faf	d0 cc		bne $8f7d			bne 	ReturnTrue
.8fb1	80 d5		bra $8f88			bra 	ReturnFalse
.8fb3					BinaryCompareLessEqual:
.8fb3	fa		plx				plx
.8fb4	20 c7 8f	jsr $8fc7			jsr 	CompareBaseCode
.8fb7	c9 01		cmp #$01			cmp 	#1
.8fb9	d0 c2		bne $8f7d			bne 	ReturnTrue
.8fbb	80 cb		bra $8f88			bra 	ReturnFalse
.8fbd					BinaryCompareGreaterEqual:
.8fbd	fa		plx				plx
.8fbe	20 c7 8f	jsr $8fc7			jsr 	CompareBaseCode
.8fc1	c9 ff		cmp #$ff			cmp 	#$FF
.8fc3	d0 b8		bne $8f7d			bne 	ReturnTrue
.8fc5	80 c1		bra $8f88			bra 	ReturnFalse
.8fc7					CompareBaseCode:
.8fc7	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; make both values if references.
.8fca	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8fcc	15 51		ora $51,x			ora 	NSStatus+1,x
.8fce	29 10		and #$10			and 	#NSTString
.8fd0	d0 37		bne $9009			bne 	_CBCString 					; if so do string code, which will check if both.
.8fd2	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8fd4	15 79		ora $79,x			ora 	NSExponent+1,x
.8fd6	d0 34		bne $900c			bne 	_CBCFloat
.8fd8	b5 50		lda $50,x			lda 	NSStatus,x
.8fda	15 51		ora $51,x			ora 	NSStatus+1,x
.8fdc	29 08		and #$08			and 	#NSTFloat
.8fde	d0 2c		bne $900c			bne 	_CBCFloat
.8fe0	20 0f 90	jsr $900f			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8fe3	e8		inx				inx
.8fe4	20 0f 90	jsr $900f			jsr 	CompareFixMinusZero
.8fe7	ca		dex				dex
.8fe8	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8fea	55 51		eor $51,x			eor 	NSStatus+1,x
.8fec	10 0a		bpl $8ff8			bpl 	_CDCSameSign
.8fee	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8ff0	30 14		bmi $9006			bmi 	_CBCLess 					; return $FF
.8ff2					_CBCGreater:
.8ff2	a9 01		lda #$01			lda 	#1
.8ff4	60		rts				rts
.8ff5					_CBCEqual:
.8ff5	a9 00		lda #$00			lda 	#0
.8ff7	60		rts				rts
.8ff8					_CDCSameSign:
.8ff8	20 24 92	jsr $9224			jsr 	SubTopTwoStack 				; unsigned subtract
.8ffb	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; or the mantissa together
.8ffe	f0 f5		beq $8ff5			beq 	_CBCEqual 					; -0 == 0
.9000	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.9002	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.9004	10 ec		bpl $8ff2			bpl 	_CBCGreater
.9006					_CBCLess:
.9006	a9 ff		lda #$ff			lda 	#$FF
.9008	60		rts				rts
.9009					_CBCString:
.9009	4c 95 91	jmp $9195			jmp 	CompareStrings
.900c					_CBCFloat:
.900c	4c df 94	jmp $94df			jmp 	CompareFloat
.900f					CompareFixMinusZero:
.900f	20 54 9e	jsr $9e54			jsr 	NSMIsZero
.9012	d0 02		bne $9016			bne 	_CFXMZNotZero
.9014	74 50		stz $50,x			stz 	NSStatus,x
.9016					_CFXMZNotZero:
.9016	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9017					StringConcat:
.9017	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9019	35 51		and $51,x			and 	NSStatus+1,x
.901b	29 18		and #$18			and 	#NSBTypeMask
.901d	c9 10		cmp #$10			cmp 	#NSTString
.901f	d0 50		bne $9071			bne		_SCType
.9021	64 38		stz $38				stz 	zTemp1 						; counting total length
.9023	e8		inx				inx
.9024	20 42 90	jsr $9042			jsr 	_SCSetupZ0 					; setup for second
.9027	20 4b 90	jsr $904b			jsr 	_SCLengthZ0 				; length for second
.902a	ca		dex				dex
.902b	20 42 90	jsr $9042			jsr 	_SCSetupZ0 					; setup for first
.902e	20 4b 90	jsr $904b			jsr 	_SCLengthZ0 				; length for first
.9031	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.9033	20 b5 a7	jsr $a7b5			jsr 	StringTempAllocate
.9036	20 62 90	jsr $9062			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9039	e8		inx				inx
.903a	20 42 90	jsr $9042			jsr 	_SCSetupZ0 					; copy second out
.903d	20 62 90	jsr $9062			jsr 	_SCCopy
.9040	ca		dex				dex
.9041	60		rts				rts
.9042					_SCSetupZ0:
.9042	b5 58		lda $58,x			lda 	NSMantissa0,x
.9044	85 36		sta $36				sta 	zTemp0
.9046	b5 60		lda $60,x			lda 	NSMantissa1,x
.9048	85 37		sta $37				sta 	zTemp0+1
.904a	60		rts				rts
.904b					_SCLengthZ0:
.904b	5a		phy				phy
.904c	a0 00		ldy #$00			ldy 	#0
.904e					_SCLenLoop:
.904e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9050	f0 0e		beq $9060			beq 	_SCLExit
.9052	c8		iny				iny
.9053	e6 38		inc $38				inc 	zTemp1
.9055	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9057	c9 fd		cmp #$fd			cmp 	#253
.9059	d0 f3		bne $904e			bne		_SCLenLoop
.905b	a9 09		lda #$09		lda	#9
.905d	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.9060					_SCLExit:
.9060	7a		ply				ply
.9061	60		rts				rts
.9062					_SCCopy:
.9062	5a		phy				phy
.9063	a0 00		ldy #$00			ldy 	#0
.9065					_SCCopyLoop:
.9065	b1 36		lda ($36),y			lda 	(zTemp0),y
.9067	f0 06		beq $906f			beq 	_SCCExit
.9069	20 ee a7	jsr $a7ee			jsr 	StringTempWrite
.906c	c8		iny				iny
.906d	80 f6		bra $9065			bra 	_SCCopyLoop
.906f					_SCCExit:
.906f	7a		ply				ply
.9070	60		rts				rts
.9071					_SCType:
.9071	4c ba 9f	jmp $9fba			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.9074					IntegerDivide:
.9074	fa		plx				plx
.9075	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9077	15 51		ora $51,x			ora 	NSStatus+1,x
.9079	0a		asl a				asl 	a 							; shift reference bit into sign bit
.907a	0a		asl a				asl 	a
.907b	10 05		bpl $9082			bpl 	_NotRef
.907d	48		pha				pha
.907e	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9081	68		pla				pla
.9082					_NotRef:
.9082	0a		asl a				asl 	a
.9083	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9085	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9087	15 79		ora $79,x			ora 	NSExponent+1,x
.9089	f0 03		beq $908e			beq 	_IntegerCode 				; if clear, then we have two integers
.908b	4c ba 9f	jmp $9fba			jmp 	TypeError 					; anything else, type mismatch.
.908e					_IntegerCode:
.908e	20 a8 90	jsr $90a8			jsr 	CheckDivideZero 			; do div zero check
.9091	20 da 90	jsr $90da			jsr 	Int32Divide 				; do the division
.9094	20 8b 91	jsr $918b			jsr 	CalculateSign 				; calculate result sign
.9097					NSMCopyPlusTwoToZero:
.9097	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9099	95 58		sta $58,x			sta 	NSMantissa0,x
.909b	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.909d	95 60		sta $60,x			sta 	NSMantissa1,x
.909f	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.90a1	95 68		sta $68,x			sta 	NSMantissa2,x
.90a3	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.90a5	95 70		sta $70,x			sta 	NSMantissa3,x
.90a7	60		rts				rts
.90a8					CheckDivideZero:
.90a8	e8		inx				inx
.90a9	20 54 9e	jsr $9e54			jsr 	NSMIsZero
.90ac	f0 02		beq $90b0			beq 	_CDVError
.90ae	ca		dex				dex
.90af	60		rts				rts
.90b0					_CDVError:
.90b0	a9 03		lda #$03		lda	#3
.90b2	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.90b5					IntegerModulus:
.90b5	fa		plx				plx
.90b6	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90b8	15 51		ora $51,x			ora 	NSStatus+1,x
.90ba	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90bb	0a		asl a				asl 	a
.90bc	10 05		bpl $90c3			bpl 	_NotRef
.90be	48		pha				pha
.90bf	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90c2	68		pla				pla
.90c3					_NotRef:
.90c3	0a		asl a				asl 	a
.90c4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90c6	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90c8	15 79		ora $79,x			ora 	NSExponent+1,x
.90ca	f0 03		beq $90cf			beq 	_IntegerCode 				; if clear, then we have two integers
.90cc	4c ba 9f	jmp $9fba			jmp 	TypeError 					; anything else, type mismatch.
.90cf					_IntegerCode:
.90cf					IntegerModulusNoCheck:
.90cf	20 a8 90	jsr $90a8			jsr 	CheckDivideZero 			; do div zero check
.90d2	20 da 90	jsr $90da			jsr 	Int32Divide 				; do the division
.90d5	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.90d7	56 50		lsr $50,x			lsr 	NSStatus,x
.90d9	60		rts				rts
.90da					Int32Divide:
.90da	48		pha				pha 								; save AXY
.90db	5a		phy				phy
.90dc	20 15 9e	jsr $9e15			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90df	20 2e 9e	jsr $9e2e			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.90e2	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.90e4					_I32DivideLoop:
.90e4	e8		inx				inx
.90e5	e8		inx				inx
.90e6	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.90e9	ca		dex				dex
.90ea	ca		dex				dex
.90eb	20 42 9e	jsr $9e42			jsr 	NSMRotateLeft
.90ee	20 19 91	jsr $9119			jsr 	DivideCheckSubtract 		; check if subtract possible
.90f1	90 02		bcc $90f5			bcc 	_I32DivideNoCarryIn
.90f3	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.90f5					_I32DivideNoCarryIn:
.90f5	88		dey				dey 								; loop round till division completed.
.90f6	d0 ec		bne $90e4			bne 	_I32DivideLoop
.90f8	7a		ply				ply 								; restore AXY and exit
.90f9	68		pla				pla
.90fa	60		rts				rts
.90fb					Int32ShiftDivide:
.90fb	48		pha				pha 								; save AY
.90fc	5a		phy				phy
.90fd	e8		inx				inx 								; clear S[X+2]
.90fe	e8		inx				inx
.90ff	20 32 9e	jsr $9e32			jsr 	NSMSetZero
.9102	ca		dex				dex
.9103	ca		dex				dex
.9104	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9106					_I32SDLoop:
.9106	20 19 91	jsr $9119			jsr 	DivideCheckSubtract 		; check if subtract possible
.9109	e8		inx				inx
.910a	e8		inx				inx
.910b	20 42 9e	jsr $9e42			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.910e	ca		dex				dex
.910f	ca		dex				dex
.9110	20 42 9e	jsr $9e42			jsr 	NSMRotateLeft
.9113	88		dey				dey 	 							; do 31 times
.9114	d0 f0		bne $9106			bne 	_I32SDLoop
.9116	7a		ply				ply 								; restore AY and exit
.9117	68		pla				pla
.9118	60		rts				rts
.9119					DivideCheckSubtract:
.9119	20 24 92	jsr $9224			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.911c	b0 04		bcs $9122			bcs 	_DCSExit 					; if carry set, then could do, exit
.911e	20 0a 92	jsr $920a			jsr 	AddTopTwoStack 				; add it back in
.9121	18		clc				clc 								; and return False
.9122					_DCSExit:
.9122	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9123					MulInteger:
.9123	fa		plx				plx
.9124	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9126	15 51		ora $51,x			ora 	NSStatus+1,x
.9128	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9129	0a		asl a				asl 	a
.912a	10 05		bpl $9131			bpl 	_NotRef
.912c	48		pha				pha
.912d	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9130	68		pla				pla
.9131					_NotRef:
.9131	0a		asl a				asl 	a 							; put MSB of type into A:7
.9132	30 09		bmi $913d			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9134	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9136	15 79		ora $79,x			ora 	NSExponent+1,x
.9138	f0 06		beq $9140			beq 	_IntegerCode 				; if clear, then we have two integers
.913a	4c a1 95	jmp $95a1			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.913d					_StringData:
.913d	4c c4 9f	jmp $9fc4			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9140					_IntegerCode:
.9140	20 4d 91	jsr $914d			jsr 	MultiplyShort
.9143	c9 00		cmp #$00			cmp 	#0
.9145	f0 05		beq $914c			beq 	_MIExit
.9147	a9 04		lda #$04		lda	#4
.9149	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.914c					_MIExit:
.914c	60		rts				rts
.914d					MultiplyShort:
.914d	5a		phy				phy 								; save Y
.914e	20 15 9e	jsr $9e15			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9151	20 2e 9e	jsr $9e2e			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9154	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9156					_I32MLoop:
.9156	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9158	15 62		ora $62,x			ora 	NSMantissa1+2,x
.915a	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.915c	15 72		ora $72,x			ora 	NSMantissa3+2,x
.915e	f0 25		beq $9185			beq 	_I32MExit 					; exit if zero
.9160	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9162	29 01		and #$01			and 	#1
.9164	f0 0d		beq $9173			beq 	_I32MNoAdd
.9166	20 0a 92	jsr $920a			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9169	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.916b	10 06		bpl $9173			bpl 	_I32MNoAdd
.916d					_I32ShiftRight:
.916d	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift S[X] right
.9170	c8		iny				iny 								; increment shift count
.9171	80 09		bra $917c			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9173					_I32MNoAdd:
.9173	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9175	70 f6		bvs $916d			bvs 	_I32ShiftRight 				; instead.
.9177	e8		inx				inx
.9178	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.917b	ca		dex				dex
.917c					_I32MShiftUpper:
.917c	e8		inx				inx 								; shift S[X+2] right
.917d	e8		inx				inx
.917e	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight
.9181	ca		dex				dex
.9182	ca		dex				dex
.9183	80 d1		bra $9156			bra 	_I32MLoop 					; try again.
.9185					_I32MExit:
.9185	20 8b 91	jsr $918b			jsr 	CalculateSign
.9188	98		tya				tya 								; shift in A
.9189	7a		ply				ply 								; restore Y and exit
.918a	60		rts				rts
.918b					CalculateSign:
.918b	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.918d	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.918f	55 51		eor $51,x			eor 	NSStatus+1,x
.9191	0a		asl a				asl 	a 							; shift bit 7 into carry
.9192	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.9194	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9195					CompareStrings:
.9195	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.9197	35 51		and $51,x			and 	NSStatus+1,x
.9199	29 10		and #$10			and 	#NSBIsString
.919b	f0 28		beq $91c5			beq 	_CSTypeError
.919d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.919f	85 36		sta $36				sta 	zTemp0
.91a1	b5 60		lda $60,x			lda 	NSMantissa1,x
.91a3	85 37		sta $37				sta 	zTemp0+1
.91a5	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.91a7	85 38		sta $38				sta 	zTemp1
.91a9	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.91ab	85 39		sta $39				sta 	zTemp1+1
.91ad	5a		phy				phy 								; save Y so we can access strings
.91ae	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.91b0					_CSLoop:
.91b0	c8		iny				iny
.91b1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.91b3	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.91b5	d0 06		bne $91bd			bne 	_CSDifferent
.91b7	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.91b9	d0 f5		bne $91b0			bne 	_CSLoop 					; still comparing
.91bb					_CSExit:
.91bb	7a		ply				ply 								; reached end, return zero in A from EOS
.91bc	60		rts				rts
.91bd					_CSDifferent:
.91bd	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.91bf	90 fa		bcc $91bb			bcc		_CSExit
.91c1	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.91c3	80 f6		bra $91bb			bra 	_CSExit
.91c5					_CSTypeError:
.91c5	4c ba 9f	jmp $9fba			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.91c8					ShiftLeft:
.91c8	38		sec				sec 								; common code, carry determines which way.
.91c9	80 01		bra $91cc			bra 	ShiftMain
.91cb					ShiftRight:
.91cb	18		clc				clc
.91cc					ShiftMain:
.91cc	fa		plx				plx 								; restore X
.91cd	08		php				php 								; save direction
.91ce	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91d0	15 51		ora $51,x			ora 	NSStatus+1,x
.91d2	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91d3	0a		asl a				asl 	a
.91d4	10 05		bpl $91db			bpl 	_NotRef
.91d6	48		pha				pha
.91d7	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91da	68		pla				pla
.91db					_NotRef:
.91db	0a		asl a				asl 	a
.91dc	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91de	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91e0	15 79		ora $79,x			ora 	NSExponent+1,x
.91e2	f0 03		beq $91e7			beq 	_IntegerCode 				; if clear, then we have two integers
.91e4	4c ba 9f	jmp $9fba			jmp 	TypeError 					; anything else, type mismatch.
.91e7					_IntegerCode:
.91e7	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.91e9	29 e0		and #$e0			and 	#$E0
.91eb	15 61		ora $61,x			ora 	NSMantissa1+1,x
.91ed	15 69		ora $69,x			ora 	NSMantissa2+1,x
.91ef	15 71		ora $71,x			ora 	NSMantissa3+1,x
.91f1	d0 12		bne $9205			bne 	_SMExit0 					; if >= 32 it will always return zero.
.91f3					_SMLoop:
.91f3	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.91f5	30 11		bmi $9208			bmi 	_SMExit 					; exit if done.
.91f7	28		plp				plp 								; restore direction setting
.91f8	08		php				php
.91f9	90 05		bcc $9200			bcc 	_SMRight
.91fb	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; shift left if CS
.91fe	80 f3		bra $91f3			bra 	_SMLoop
.9200					_SMRight:
.9200	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift right if CC
.9203	80 ee		bra $91f3			bra 	_SMLoop
.9205					_SMExit0:
.9205	20 32 9e	jsr $9e32			jsr 	NSMSetZero 					; return zero.
.9208					_SMExit:
.9208	28		plp				plp 								; throw direction
.9209	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.920a					AddTopTwoStack:
.920a	18		clc				clc
.920b	b5 58		lda $58,x			lda		NSMantissa0,x
.920d	75 59		adc $59,x			adc 		NSMantissa0+1,x
.920f	95 58		sta $58,x			sta 	NSMantissa0,x
.9211	b5 60		lda $60,x			lda		NSMantissa1,x
.9213	75 61		adc $61,x			adc 		NSMantissa1+1,x
.9215	95 60		sta $60,x			sta 	NSMantissa1,x
.9217	b5 68		lda $68,x			lda		NSMantissa2,x
.9219	75 69		adc $69,x			adc 		NSMantissa2+1,x
.921b	95 68		sta $68,x			sta 	NSMantissa2,x
.921d	b5 70		lda $70,x			lda		NSMantissa3,x
.921f	75 71		adc $71,x			adc 		NSMantissa3+1,x
.9221	95 70		sta $70,x			sta 	NSMantissa3,x
.9223	60		rts				rts
.9224					SubTopTwoStack:
.9224	38		sec				sec
.9225	b5 58		lda $58,x			lda		NSMantissa0,x
.9227	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9229	95 58		sta $58,x			sta 	NSMantissa0,x
.922b	b5 60		lda $60,x			lda		NSMantissa1,x
.922d	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.922f	95 60		sta $60,x			sta 	NSMantissa1,x
.9231	b5 68		lda $68,x			lda		NSMantissa2,x
.9233	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.9235	95 68		sta $68,x			sta 	NSMantissa2,x
.9237	b5 70		lda $70,x			lda		NSMantissa3,x
.9239	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.923b	95 70		sta $70,x			sta 	NSMantissa3,x
.923d	60		rts				rts
.923e					AddInteger:
.923e	fa		plx				plx
.923f	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9241	15 51		ora $51,x			ora 	NSStatus+1,x
.9243	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9244	0a		asl a				asl 	a
.9245	10 05		bpl $924c			bpl 	_NotRef
.9247	48		pha				pha
.9248	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.924b	68		pla				pla
.924c					_NotRef:
.924c	0a		asl a				asl 	a 							; put MSB of type into A:7
.924d	30 09		bmi $9258			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.924f	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9251	15 79		ora $79,x			ora 	NSExponent+1,x
.9253	f0 06		beq $925b			beq 	_IntegerCode 				; if clear, then we have two integers
.9255	4c 51 94	jmp $9451			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9258					_StringData:
.9258	4c 17 90	jmp $9017			jmp 	StringConcat							; at least one string - don't know both are strings.
.925b					_IntegerCode:
.925b					AddCode:
.925b	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.925d	55 51		eor $51,x			eor 	NSStatus+1,x
.925f	10 a9		bpl $920a			bpl 	AddTopTwoStack
.9261	20 24 92	jsr $9224			jsr 	SubTopTwoStack 				; do a physical subtraction
.9264	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9266	10 07		bpl $926f			bpl 	_AddExit
.9268	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.926a	95 50		sta $50,x			sta 	NSStatus,x
.926c	20 fb 9d	jsr $9dfb			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.926f					_AddExit:
.926f	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; check for -0
.9272	d0 02		bne $9276			bne 	_AddNonZero
.9274	74 50		stz $50,x			stz 	NSStatus,x
.9276					_AddNonZero:
.9276	60		rts				rts
.9277					SubInteger:
.9277	fa		plx				plx
.9278	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.927a	15 51		ora $51,x			ora 	NSStatus+1,x
.927c	0a		asl a				asl 	a 							; shift reference bit into sign bit
.927d	0a		asl a				asl 	a
.927e	10 05		bpl $9285			bpl 	_NotRef
.9280	48		pha				pha
.9281	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9284	68		pla				pla
.9285					_NotRef:
.9285	0a		asl a				asl 	a 							; put MSB of type into A:7
.9286	30 09		bmi $9291			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9288	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.928a	15 79		ora $79,x			ora 	NSExponent+1,x
.928c	f0 06		beq $9294			beq 	_IntegerCode 				; if clear, then we have two integers
.928e	4c 56 94	jmp $9456			jmp 	FloatingPointSub 							; otherwise at least one float.
.9291					_StringData:
.9291	4c c4 9f	jmp $9fc4			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9294					_IntegerCode:
.9294	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.9296	49 80		eor #$80			eor 	#$80
.9298	95 51		sta $51,x			sta 	NSStatus+1,x
.929a	80 bf		bra $925b			bra 	AddCode 					; and do the same code as add.
.929c					AndInteger:
.929c	fa		plx				plx
.929d	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.929f	15 51		ora $51,x			ora 	NSStatus+1,x
.92a1	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92a2	0a		asl a				asl 	a
.92a3	10 05		bpl $92aa			bpl 	_NotRef
.92a5	48		pha				pha
.92a6	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92a9	68		pla				pla
.92aa					_NotRef:
.92aa	0a		asl a				asl 	a
.92ab	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92ad	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92af	15 79		ora $79,x			ora 	NSExponent+1,x
.92b1	f0 03		beq $92b6			beq 	_IntegerCode 				; if clear, then we have two integers
.92b3	4c ba 9f	jmp $9fba			jmp 	TypeError 					; anything else, type mismatch.
.92b6					_IntegerCode:
.92b6	b5 58		lda $58,x			lda		NSMantissa0,x
.92b8	35 59		and $59,x			and 		NSMantissa0+1,x
.92ba	95 58		sta $58,x			sta 	NSMantissa0,x
.92bc	b5 60		lda $60,x			lda		NSMantissa1,x
.92be	35 61		and $61,x			and 		NSMantissa1+1,x
.92c0	95 60		sta $60,x			sta 	NSMantissa1,x
.92c2	b5 68		lda $68,x			lda		NSMantissa2,x
.92c4	35 69		and $69,x			and 		NSMantissa2+1,x
.92c6	95 68		sta $68,x			sta 	NSMantissa2,x
.92c8	b5 70		lda $70,x			lda		NSMantissa3,x
.92ca	35 71		and $71,x			and 		NSMantissa3+1,x
.92cc	95 70		sta $70,x			sta 	NSMantissa3,x
.92ce	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92d0	60		rts				rts
.92d1					OraInteger:
.92d1	fa		plx				plx
.92d2	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92d4	15 51		ora $51,x			ora 	NSStatus+1,x
.92d6	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92d7	0a		asl a				asl 	a
.92d8	10 05		bpl $92df			bpl 	_NotRef
.92da	48		pha				pha
.92db	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92de	68		pla				pla
.92df					_NotRef:
.92df	0a		asl a				asl 	a
.92e0	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92e2	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92e4	15 79		ora $79,x			ora 	NSExponent+1,x
.92e6	f0 03		beq $92eb			beq 	_IntegerCode 				; if clear, then we have two integers
.92e8	4c ba 9f	jmp $9fba			jmp 	TypeError 					; anything else, type mismatch.
.92eb					_IntegerCode:
.92eb	b5 58		lda $58,x			lda		NSMantissa0,x
.92ed	15 59		ora $59,x			ora 		NSMantissa0+1,x
.92ef	95 58		sta $58,x			sta 	NSMantissa0,x
.92f1	b5 60		lda $60,x			lda		NSMantissa1,x
.92f3	15 61		ora $61,x			ora 		NSMantissa1+1,x
.92f5	95 60		sta $60,x			sta 	NSMantissa1,x
.92f7	b5 68		lda $68,x			lda		NSMantissa2,x
.92f9	15 69		ora $69,x			ora 		NSMantissa2+1,x
.92fb	95 68		sta $68,x			sta 	NSMantissa2,x
.92fd	b5 70		lda $70,x			lda		NSMantissa3,x
.92ff	15 71		ora $71,x			ora 		NSMantissa3+1,x
.9301	95 70		sta $70,x			sta 	NSMantissa3,x
.9303	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9305	60		rts				rts
.9306					EorInteger:
.9306	fa		plx				plx
.9307	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9309	15 51		ora $51,x			ora 	NSStatus+1,x
.930b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.930c	0a		asl a				asl 	a
.930d	10 05		bpl $9314			bpl 	_NotRef
.930f	48		pha				pha
.9310	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9313	68		pla				pla
.9314					_NotRef:
.9314	0a		asl a				asl 	a
.9315	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9317	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9319	15 79		ora $79,x			ora 	NSExponent+1,x
.931b	f0 03		beq $9320			beq 	_IntegerCode 				; if clear, then we have two integers
.931d	4c ba 9f	jmp $9fba			jmp 	TypeError 					; anything else, type mismatch.
.9320					_IntegerCode:
.9320	b5 58		lda $58,x			lda		NSMantissa0,x
.9322	55 59		eor $59,x			eor 		NSMantissa0+1,x
.9324	95 58		sta $58,x			sta 	NSMantissa0,x
.9326	b5 60		lda $60,x			lda		NSMantissa1,x
.9328	55 61		eor $61,x			eor 		NSMantissa1+1,x
.932a	95 60		sta $60,x			sta 	NSMantissa1,x
.932c	b5 68		lda $68,x			lda		NSMantissa2,x
.932e	55 69		eor $69,x			eor 		NSMantissa2+1,x
.9330	95 68		sta $68,x			sta 	NSMantissa2,x
.9332	b5 70		lda $70,x			lda		NSMantissa3,x
.9334	55 71		eor $71,x			eor 		NSMantissa3+1,x
.9336	95 70		sta $70,x			sta 	NSMantissa3,x
.9338	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.933a	60		rts				rts
.933b					WordIndirect:
.933b	fa		plx				plx
.933c	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.933e	15 51		ora $51,x			ora 	NSStatus+1,x
.9340	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9341	0a		asl a				asl 	a
.9342	10 05		bpl $9349			bpl 	_NotRef
.9344	48		pha				pha
.9345	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9348	68		pla				pla
.9349					_NotRef:
.9349	0a		asl a				asl 	a
.934a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.934c	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.934e	15 79		ora $79,x			ora 	NSExponent+1,x
.9350	f0 03		beq $9355			beq 	_IntegerCode 				; if clear, then we have two integers
.9352	4c ba 9f	jmp $9fba			jmp 	TypeError 					; anything else, type mismatch.
.9355					_IntegerCode:
.9355	20 5b 92	jsr $925b			jsr 	AddCode 					; add the two values
.9358	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.935a	95 50		sta $50,x			sta 	NSStatus,x
.935c	60		rts				rts
.935d					ByteIndirect:
.935d	fa		plx				plx
.935e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9360	15 51		ora $51,x			ora 	NSStatus+1,x
.9362	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9363	0a		asl a				asl 	a
.9364	10 05		bpl $936b			bpl 	_NotRef
.9366	48		pha				pha
.9367	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.936a	68		pla				pla
.936b					_NotRef:
.936b	0a		asl a				asl 	a
.936c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.936e	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9370	15 79		ora $79,x			ora 	NSExponent+1,x
.9372	f0 03		beq $9377			beq 	_IntegerCode 				; if clear, then we have two integers
.9374	4c ba 9f	jmp $9fba			jmp 	TypeError 					; anything else, type mismatch.
.9377					_IntegerCode:
.9377	20 5b 92	jsr $925b			jsr 	AddCode 					; add the two values
.937a	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.937c	95 50		sta $50,x			sta 	NSStatus,x
.937e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.937f					ConvertInt16:
.937f	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.9381	86 60		stx $60				stx 	NSMantissa1
.9383	64 68		stz $68				stz 	NSMantissa2
.9385	64 70		stz $70				stz 	NSMantissa3
.9387	64 50		stz $50				stz 	NSStatus 					; positive integer
.9389	a2 00		ldx #$00			ldx 	#0 							; stack level
.938b	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.938d	80 00		bra $938f			bra 	ConvertInt32
.938f					ConvertInt32:
.938f	5a		phy				phy
.9390	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9392	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.9394	10 08		bpl $939e			bpl 	_CI32NotNeg
.9396	48		pha				pha
.9397	a9 2d		lda #$2d			lda 	#'-'
.9399	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.939c	c8		iny				iny
.939d	68		pla				pla
.939e					_CI32NotNeg:
.939e	20 ac 93	jsr $93ac			jsr 	_CI32DivideConvert 			; recursive conversion
.93a1	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.93a3	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.93a6	7a		ply				ply
.93a7	a2 06		ldx #$06			ldx 	#NumberBuffer >> 8 			; return address in XA
.93a9	a9 27		lda #$27			lda 	#NumberBuffer & $FF
.93ab	60		rts				rts
.93ac					_CI32DivideConvert:
.93ac	e8		inx				inx 								; write to next slot up
.93ad	20 34 9e	jsr $9e34			jsr 	NSMSetByte 		 			; write the base out.
.93b0	ca		dex				dex
.93b1	20 da 90	jsr $90da			jsr 	Int32Divide 				; divide
.93b4	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.93b6	48		pha				pha
.93b7	20 97 90	jsr $9097			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.93ba	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; is it zero ?
.93bd	f0 05		beq $93c4			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.93bf	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.93c1	20 ac 93	jsr $93ac			jsr 	_CI32DivideConvert 			; and recusrively call.
.93c4					_CI32NoRecurse:
.93c4	68		pla				pla 								; remainder
.93c5	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.93c7	90 02		bcc $93cb			bcc 	_CI32NotHex
.93c9	69 26		adc #$26			adc 	#6+32
.93cb					_CI32NotHex:
.93cb	69 30		adc #$30			adc 	#48
.93cd	99 27 06	sta $0627,y			sta 	NumberBuffer,y 				; write out and exit
.93d0	c8		iny				iny
.93d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.93d2					PrecedenceLevel:
>93d2	04					.byte	 4	; $00 <<
>93d3	02					.byte	 2	; $01 <=
>93d4	02					.byte	 2	; $02 <>
>93d5	00					.byte	 0	; $03 !!3
>93d6	00					.byte	 0	; $04 ><
>93d7	02					.byte	 2	; $05 >=
>93d8	04					.byte	 4	; $06 >>
>93d9	00					.byte	 0	; $07 !!7
>93da	00					.byte	 0	; $08 !!8
>93db	00					.byte	 0	; $09 !!9
>93dc	00					.byte	 0	; $0a !!10
>93dd	00					.byte	 0	; $0b !!11
>93de	00					.byte	 0	; $0c !!12
>93df	00					.byte	 0	; $0d !!13
>93e0	00					.byte	 0	; $0e !!14
>93e1	00					.byte	 0	; $0f !!15
>93e2	00					.byte	 0	; $10 @
>93e3	00					.byte	 0	; $11 !!17
>93e4	00					.byte	 0	; $12 !!18
>93e5	00					.byte	 0	; $13 [
>93e6	04					.byte	 4	; $14 \
>93e7	00					.byte	 0	; $15 ]
>93e8	01					.byte	 1	; $16 ^
>93e9	00					.byte	 0	; $17 _
>93ea	00					.byte	 0	; $18 `
>93eb	00					.byte	 0	; $19 !!25
>93ec	00					.byte	 0	; $1a !!26
>93ed	00					.byte	 0	; $1b {
>93ee	01					.byte	 1	; $1c |
>93ef	00					.byte	 0	; $1d }
>93f0	00					.byte	 0	; $1e ~
>93f1	00					.byte	 0	; $1f [7m<7F>[m
>93f2	00					.byte	 0	; $20
>93f3	05					.byte	 5	; $21 !
>93f4	00					.byte	 0	; $22 "
>93f5	00					.byte	 0	; $23 #
>93f6	05					.byte	 5	; $24 $
>93f7	04					.byte	 4	; $25 %
>93f8	01					.byte	 1	; $26 &
>93f9	00					.byte	 0	; $27 '
>93fa	00					.byte	 0	; $28 (
>93fb	00					.byte	 0	; $29 )
>93fc	04					.byte	 4	; $2a *
>93fd	03					.byte	 3	; $2b +
>93fe	00					.byte	 0	; $2c ,
>93ff	03					.byte	 3	; $2d -
>9400	00					.byte	 0	; $2e .
>9401	04					.byte	 4	; $2f /
>9402	00					.byte	 0	; $30 0
>9403	00					.byte	 0	; $31 1
>9404	00					.byte	 0	; $32 2
>9405	00					.byte	 0	; $33 3
>9406	00					.byte	 0	; $34 4
>9407	00					.byte	 0	; $35 5
>9408	00					.byte	 0	; $36 6
>9409	00					.byte	 0	; $37 7
>940a	00					.byte	 0	; $38 8
>940b	00					.byte	 0	; $39 9
>940c	00					.byte	 0	; $3a :
>940d	00					.byte	 0	; $3b ;
>940e	02					.byte	 2	; $3c <
>940f	02					.byte	 2	; $3d =
>9410	02					.byte	 2	; $3e >
>9411	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9412					EvaluateExpressionAt0:
.9412	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9414					EvaluateExpression:
.9414	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9416					EvaluateExpressionAtPrecedence:
.9416	48		pha				pha 								; save precedence level
.9417	20 5e 98	jsr $985e			jsr 	EvaluateTerm 				; evaluate term into level X.
.941a	68		pla				pla 								; restore precedence level.
.941b					_EXPRLoop:
.941b	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.941d	b1 30		lda ($30),y			lda 	(codePtr),y
.941f	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9421	b0 25		bcs $9448			bcs 	_EXPRExit
.9423	da		phx				phx 								; read the operator precedence
.9424	aa		tax				tax
.9425	bd d2 93	lda $93d2,x			lda 	PrecedenceLevel,x
.9428	fa		plx				plx
.9429	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.942b	f0 1b		beq $9448			beq 	_EXPRExit
.942d	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.942f	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9431	c5 37		cmp $37				cmp 	zTemp0+1
.9433	b0 13		bcs $9448			bcs		_EXPRExit 					; if current >= operator exit
.9435	48		pha				pha 								; save current precedence.
.9436	b1 30		lda ($30),y			lda 	(codePtr),y
.9438	c8		iny				iny
.9439	48		pha				pha
.943a	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.943c	e8		inx				inx 								; work out the right hand side.
.943d	20 16 94	jsr $9416			jsr 	EvaluateExpressionAtPrecedence
.9440	ca		dex				dex
.9441	68		pla				pla 								; get operator, call the code.
.9442	20 4b 94	jsr $944b			jsr 	_EXPRCaller
.9445	68		pla				pla 								; restore precedence level
.9446	80 d3		bra $941b			bra 	_EXPRLoop 					; and go round.
.9448					_EXPRExit:
.9448	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.944a	60		rts				rts
.944b					_EXPRCaller:
.944b	da		phx				phx 								; save on stack, first thing is to restore it
.944c	0a		asl a				asl 	a 							; double so can use vectors into X
.944d	aa		tax				tax
.944e	7c c2 8b	jmp ($8bc2,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9451					FloatingPointAdd:
.9451	20 c7 95	jsr $95c7			jsr 	FloatPrepare 				; prepare for floats
.9454	80 09		bra $945f			bra 	FloatAdd
.9456					FloatingPointSub:
.9456	20 c7 95	jsr $95c7			jsr 	FloatPrepare 				; prepare for floats
.9459					FloatSubtract:
.9459	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.945b	49 80		eor #$80			eor 	#$80
.945d	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.945f					FloatAdd:
.945f	48		pha				pha
.9460	5a		phy				phy
.9461	20 d6 95	jsr $95d6			jsr 	NSNormalise 				; normalise S[X]
.9464	f0 51		beq $94b7			beq 	_FAReturn1
.9466	e8		inx				inx 								; normalise S[X+1]
.9467	20 d6 95	jsr $95d6			jsr 	NSNormalise
.946a	ca		dex				dex
.946b	c9 00		cmp #$00			cmp 	#0
.946d	f0 60		beq $94cf			beq 	_FAExit 					; if so, just return A
.946f	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.9471	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.9473	f0 18		beq $948d			beq 	_FAExponentsEqual
.9475	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.9477	a8		tay				tay
.9478	38		sec				sec 								; do a signed comparison of the exponents.
.9479	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.947b	50 02		bvc $947f			bvc 	_FANoSignedChange
.947d	49 80		eor #$80			eor 	#$80
.947f					_FANoSignedChange:
.947f	29 80		and #$80			and 	#$80
.9481	10 02		bpl $9485			bpl 	_FAHaveMax
.9483	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.9485					_FAHaveMax:
.9485	20 d2 94	jsr $94d2			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9488	e8		inx				inx
.9489	20 d2 94	jsr $94d2			jsr 	_FAShiftToExponent
.948c	ca		dex				dex
.948d					_FAExponentsEqual:
.948d	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.948f	55 51		eor $51,x			eor 	NSStatus+1,x
.9491	30 0e		bmi $94a1			bmi 	_FADifferentSigns
.9493	20 0a 92	jsr $920a			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9496	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9498	10 35		bpl $94cf			bpl 	_FAExit 					; if no, we are done.
.949a	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.949d	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.949f	80 2e		bra $94cf			bra 	_FAExit
.94a1					_FADifferentSigns:
.94a1	20 24 92	jsr $9224			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.94a4	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.94a6	10 06		bpl $94ae			bpl 	_FACheckZero 				; if no, check for -0
.94a8	20 f4 9d	jsr $9df4			jsr 	NSMNegate 					; netate result
.94ab	20 fb 9d	jsr $9dfb			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.94ae					_FACheckZero:
.94ae	20 54 9e	jsr $9e54			jsr 	NSMIsZero	 				; check for -0
.94b1	d0 1c		bne $94cf			bne 	_FAExit
.94b3	74 50		stz $50,x			stz 	NSStatus,x
.94b5	80 18		bra $94cf			bra 	_FAExit
.94b7					_FAReturn1:
.94b7	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.94b9	95 58		sta $58,x			sta 	NSMantissa0,x
.94bb	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.94bd	95 60		sta $60,x			sta 	NSMantissa1,x
.94bf	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.94c1	95 68		sta $68,x			sta 	NSMantissa2,x
.94c3	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.94c5	95 70		sta $70,x			sta 	NSMantissa3,x
.94c7	b5 79		lda $79,x			lda 	NSExponent+1,x
.94c9	95 78		sta $78,x			sta 	NSExponent,x
.94cb	b5 51		lda $51,x			lda 	NSStatus+1,x
.94cd	95 50		sta $50,x			sta 	NSStatus,x
.94cf					_FAExit:
.94cf	7a		ply				ply
.94d0	68		pla				pla
.94d1	60		rts				rts
.94d2					_FAShiftToExponent:
.94d2					_FAShiftToExponent2:
.94d2	98		tya				tya 								; compare Y to exponent
.94d3	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.94d5	f0 07		beq $94de			beq 	_FASEExit 					; exit if so.
.94d7	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight	 			; shift the mantissa right
.94da	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.94dc	80 f4		bra $94d2			bra 	_FAShiftToExponent2
.94de					_FASEExit:
.94de	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94df					CompareFloat:
.94df	20 59 94	jsr $9459			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94e2	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94e4	29 f8		and #$f8			and 	#$F8
.94e6	15 68		ora $68,x			ora 	NSMantissa2,x
.94e8	15 70		ora $70,x			ora 	NSMantissa3,x
.94ea	f0 08		beq $94f4			beq 	_FCExit 					; zero, so approximately identical
.94ec	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94ee	34 50		bit $50,x			bit 	NSStatus,x
.94f0	10 02		bpl $94f4			bpl 	_FCExit
.94f2					_FCNegative:
.94f2	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94f4					_FCExit:
.94f4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94f5					FDivideCommand:
.94f5	fa		plx				plx	 								; restore stack position
.94f6	20 c7 95	jsr $95c7			jsr 	FloatPrepare 				; prepare for floats
.94f9					FloatDivide:
.94f9	48		pha				pha
.94fa	e8		inx				inx
.94fb	20 d6 95	jsr $95d6			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94fe	ca		dex				dex
.94ff	c9 00		cmp #$00			cmp 	#0
.9501	f0 1d		beq $9520			beq 	_FDZero
.9503	20 d6 95	jsr $95d6			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9506	f0 16		beq $951e			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9508	20 fb 90	jsr $90fb			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.950b	20 97 90	jsr $9097			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.950e	20 d6 95	jsr $95d6			jsr		NSNormalise 				; renormalise
.9511	20 8b 91	jsr $918b			jsr 	CalculateSign 				; calculate result sign
.9514	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.9516	38		sec				sec
.9517	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9519	38		sec				sec
.951a	e9 1e		sbc #$1e			sbc 	#30
.951c	95 78		sta $78,x			sta 	NSExponent,x
.951e					_FDExit:
.951e	68		pla				pla
.951f	60		rts				rts
.9520					_FDZero:
.9520	a9 03		lda #$03		lda	#3
.9522	4c 10 8f	jmp $8f10		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9525					FloatFractionalPart:
.9525	5a		phy				phy
.9526	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9528	29 7f		and #$7f			and 	#$7F
.952a	95 50		sta $50,x			sta 	NSStatus,x
.952c	20 d6 95	jsr $95d6			jsr 	NSNormalise
.952f	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9531	38		sec				sec
.9532	e9 e0		sbc #$e0			sbc 	#$E0
.9534	90 29		bcc $955f			bcc 	_FFPExit 					; already fractional
.9536	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9538	b0 22		bcs $955c			bcs 	_FFPZero
.953a	a8		tay				tay 								; put count to do in Y
.953b	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.953d	20 61 95	jsr $9561			jsr 	_FFPPartial
.9540	95 70		sta $70,x			sta 	NSMantissa3,x
.9542	b5 68		lda $68,x			lda 	NSMantissa2,x
.9544	20 61 95	jsr $9561			jsr 	_FFPPartial
.9547	95 68		sta $68,x			sta 	NSMantissa2,x
.9549	b5 60		lda $60,x			lda 	NSMantissa1,x
.954b	20 61 95	jsr $9561			jsr 	_FFPPartial
.954e	95 60		sta $60,x			sta 	NSMantissa1,x
.9550	b5 58		lda $58,x			lda 	NSMantissa0,x
.9552	20 61 95	jsr $9561			jsr 	_FFPPartial
.9555	95 58		sta $58,x			sta 	NSMantissa0,x
.9557	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; zeroed check.
.955a	d0 03		bne $955f			bne 	_FFPExit
.955c					_FFPZero:
.955c	20 32 9e	jsr $9e32			jsr 	NSMSetZero
.955f					_FFPExit:
.955f	7a		ply				ply
.9560	60		rts				rts
.9561					_FFPPartial:
.9561	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9563	f0 17		beq $957c			beq 	_FFFPPExit
.9565	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9567	b0 0c		bcs $9575			bcs 	_FFFPPWholeByte
.9569	5a		phy				phy
.956a					_FFFPPLeft:
.956a	0a		asl a				asl 	a
.956b	88		dey				dey
.956c	d0 fc		bne $956a			bne 	_FFFPPLeft
.956e	7a		ply				ply
.956f					_FFFPPRight:
.956f	4a		lsr a				lsr 	a
.9570	88		dey				dey
.9571	d0 fc		bne $956f			bne 	_FFFPPRight
.9573	80 07		bra $957c			bra 	_FFFPPExit
.9575					_FFFPPWholeByte:
.9575	98		tya				tya 								; subtract 8 from count
.9576	38		sec				sec
.9577	e9 08		sbc #$08			sbc 	#8
.9579	a8		tay				tay
.957a	a9 00		lda #$00			lda 	#0 							; and clear all
.957c					_FFFPPExit:
.957c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.957d					FloatIntegerPart:
.957d	48		pha				pha
.957e	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.9580	f0 1d		beq $959f			beq 	_FIPExit 					; if so do nothing
.9582	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; is it zero ?
.9585	f0 15		beq $959c			beq 	_FIPZero 					; if so return zero.
.9587	20 d6 95	jsr $95d6			jsr 	NSNormalise 				; normalise
.958a	f0 10		beq $959c			beq 	_FIPZero 					; normalised to zero, exit zero
.958c					_FIPShift:
.958c	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.958e	10 07		bpl $9597			bpl 	_FIPCheckZero
.9590	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift mantissa right
.9593	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.9595	80 f5		bra $958c			bra 	_FIPShift
.9597					_FIPCheckZero:
.9597	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; avoid -0 problem
.959a	d0 03		bne $959f			bne 	_FIPExit 					; set to zero if mantissa zero.
.959c					_FIPZero:
.959c	20 32 9e	jsr $9e32			jsr 	NSMSetZero
.959f					_FIPExit:
.959f	68		pla				pla
.95a0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.95a1					FloatingPointMultiply:
.95a1	20 c7 95	jsr $95c7			jsr 	FloatPrepare 				; prepare for floats
.95a4					FloatMultiply:
.95a4	48		pha				pha
.95a5	20 d6 95	jsr $95d6			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.95a8	f0 18		beq $95c2			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.95aa	e8		inx				inx
.95ab	20 d6 95	jsr $95d6			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.95ae	ca		dex				dex
.95af	c9 00		cmp #$00			cmp 	#0
.95b1	f0 0c		beq $95bf			beq 	_FDSetZero
.95b3	20 4d 91	jsr $914d			jsr 	MultiplyShort 				; calculate the result.
.95b6	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.95b8	18		clc				clc
.95b9	75 79		adc $79,x			adc 	NSExponent+1,x
.95bb	95 78		sta $78,x			sta 	NSExponent,x
.95bd	80 03		bra $95c2			bra 	_FDExit
.95bf					_FDSetZero:
.95bf	20 32 9e	jsr $9e32			jsr 	NSMSetZero 					; return 0
.95c2					_FDExit:
.95c2	20 d6 95	jsr $95d6			jsr 	NSNormalise 				; normalise the result
.95c5	68		pla				pla
.95c6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95c7					FloatPrepare:
.95c7	20 d2 96	jsr $96d2			jsr 	DereferenceTopTwo 			; dereference the top two values
.95ca	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.95cc	15 51		ora $51,x			ora 	NSStatus+1,x
.95ce	29 10		and #$10			and 	#NSBIsString
.95d0	d0 01		bne $95d3			bne 	_FDType
.95d2	60		rts				rts
.95d3					_FDType:
.95d3	4c ba 9f	jmp $9fba			jmp 	TypeError
.95d6					NSNormalise:
.95d6	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.95d8	29 80		and #$80			and 	#$80
.95da	09 08		ora #$08			ora 	#NSTFloat
.95dc	95 50		sta $50,x			sta 	NSStatus,x
.95de	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; if zero exit
.95e1	d0 07		bne $95ea			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95e3	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.95e5	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.95e7	a9 00		lda #$00			lda 	#0 							; set Z flag
.95e9	60		rts				rts
.95ea					_NSNormaliseOptimise:
.95ea	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95ec	d0 19		bne $9607			bne 	_NSNormaliseLoop
.95ee	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.95f0	30 15		bmi $9607			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95f2	95 70		sta $70,x			sta 	NSMantissa3,x
.95f4	b5 60		lda $60,x			lda 	NSMantissa1,x
.95f6	95 68		sta $68,x			sta 	NSMantissa2,x
.95f8	b5 58		lda $58,x			lda 	NSMantissa0,x
.95fa	95 60		sta $60,x			sta 	NSMantissa1,x
.95fc	74 58		stz $58,x			stz 	NSMantissa0,x
.95fe	b5 78		lda $78,x			lda 	NSExponent,x
.9600	38		sec				sec
.9601	e9 08		sbc #$08			sbc 	#8
.9603	95 78		sta $78,x			sta 	NSExponent,x
.9605	80 e3		bra $95ea			bra 	_NSNormaliseOptimise
.9607					_NSNormaliseLoop:
.9607	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9609	70 07		bvs $9612			bvs 	_NSNExit 					; exit if so with Z flag clear
.960b	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; shift mantissa left
.960e	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.9610	80 f5		bra $9607			bra 	_NSNormaliseLoop
.9612					_NSNExit:
.9612	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9614	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9615					AssignNumber:
.9615	5a		phy				phy
.9616	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9618	85 36		sta $36				sta 	zTemp0
.961a	b5 60		lda $60,x			lda 	NSMantissa1,x
.961c	85 37		sta $37				sta 	zTemp0+1
.961e	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9620	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9622	95 50		sta $50,x			sta 	NSStatus,x
.9624	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9626	c9 08		cmp #$08			cmp 	#NSTFloat
.9628	f0 24		beq $964e			beq 	_ANFloat
.962a	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.962c	f0 03		beq $9631			beq		_ANNotFloat
.962e	4c b5 9f	jmp $9fb5			jmp 	RangeError					; if it is, report an error.
.9631					_ANNotFloat:
.9631	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.9633	29 03		and #$03			and 	#3
.9635	d0 05		bne $963c			bne 	_ANByteWord
.9637	20 59 96	jsr $9659			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.963a	80 1b		bra $9657			bra 	_ANExit
.963c					_ANByteWord:
.963c	48		pha				pha 								; save count
.963d	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.963f	92 36		sta ($36)			sta 	(zTemp0)
.9641	68		pla				pla
.9642	c9 01		cmp #$01			cmp	 	#1
.9644	f0 11		beq $9657			beq 	_ANExit
.9646	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9648	a0 01		ldy #$01			ldy 	#1
.964a	91 36		sta ($36),y			sta 	(zTemp0),y
.964c	80 09		bra $9657			bra 	_ANExit
.964e					_ANFloat:
.964e	20 59 96	jsr $9659			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9651	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9653	a0 04		ldy #$04			ldy 	#4
.9655	91 36		sta ($36),y			sta 	(zTemp0),y
.9657					_ANExit:
.9657	7a		ply				ply
.9658	60		rts				rts
.9659					_ANCopy4PackSign:
.9659	a0 03		ldy #$03			ldy 	#3
.965b	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.965d	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.965f	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9661	91 36		sta ($36),y			sta 	(zTemp0),y
.9663	88		dey				dey
.9664	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9666	91 36		sta ($36),y			sta 	(zTemp0),y
.9668	88		dey				dey
.9669	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.966b	91 36		sta ($36),y			sta 	(zTemp0),y
.966d	88		dey				dey
.966e	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9670	91 36		sta ($36),y			sta 	(zTemp0),y
.9672	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9673					AssignString:
.9673	5a		phy				phy
.9674	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9676	85 38		sta $38				sta 	zTemp1
.9678	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.967a	85 39		sta $39				sta 	zTemp1+1
.967c	b5 58		lda $58,x			lda 	NSMantissa0,x
.967e	85 36		sta $36				sta 	zTemp0
.9680	b5 60		lda $60,x			lda 	NSMantissa1,x
.9682	85 37		sta $37				sta 	zTemp0+1
.9684	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9686	b1 36		lda ($36),y			lda 	(zTemp0),y
.9688	f0 23		beq $96ad			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.968a	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.968b	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.968d	e9 02		sbc #$02			sbc 	#2
.968f	85 3c		sta $3c				sta 	zsTemp
.9691	a0 01		ldy #$01			ldy 	#1
.9693	b1 36		lda ($36),y			lda 	(zTemp0),y
.9695	e9 00		sbc #$00			sbc 	#0
.9697	85 3d		sta $3d				sta 	zsTemp+1
.9699	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.969b					_ASGetLength:
.969b	c8		iny				iny
.969c	b1 38		lda ($38),y			lda 	(zTemp1),y
.969e	d0 fb		bne $969b			bne 	_ASGetLength
.96a0	98		tya				tya 								; is this length <= current length
.96a1	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.96a3	90 1e		bcc $96c3			bcc 	_ASCopyString
.96a5	f0 1c		beq $96c3			beq 	_ASCopyString
.96a7	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.96a9	a0 01		ldy #$01			ldy 	#1
.96ab	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96ad					_ASNewStringRequired:
.96ad	e8		inx				inx 								; concrete the new string.
.96ae	20 38 a7	jsr $a738			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.96b1	ca		dex				dex
.96b2	18		clc				clc
.96b3	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96b5	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96b7	92 36		sta ($36)			sta 	(zTemp0)
.96b9	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96bb	69 00		adc #$00			adc 	#0
.96bd	a0 01		ldy #$01			ldy 	#1
.96bf	91 36		sta ($36),y			sta 	(zTemp0),y
.96c1	80 0d		bra $96d0			bra 	_ASExit
.96c3					_ASCopyString:
.96c3	a0 00		ldy #$00			ldy 	#0
.96c5					_ASCopyLoop:
.96c5	b1 38		lda ($38),y			lda 	(zTemp1),y
.96c7	c8		iny				iny
.96c8	c8		iny				iny
.96c9	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96cb	88		dey				dey
.96cc	c9 00		cmp #$00			cmp 	#0
.96ce	d0 f5		bne $96c5			bne 	_ASCopyLoop
.96d0					_ASExit:
.96d0	7a		ply				ply
.96d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96d2					DereferenceTopTwo:
.96d2	e8		inx				inx
.96d3	20 d7 96	jsr $96d7			jsr 	Dereference 				; deref x+1
.96d6	ca		dex				dex  								; falls through to deref x
.96d7					Dereference:
.96d7	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.96d9	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.96db	f0 48		beq $9725			beq 	_DRFExit 					; not a reference, so exit.
.96dd	5a		phy				phy
.96de	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96e0	85 36		sta $36				sta 	zTemp0
.96e2	b5 60		lda $60,x			lda 	NSMantissa1,x
.96e4	85 37		sta $37				sta 	zTemp0+1
.96e6	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.96e8	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96ea	95 58		sta $58,x			sta 	NSMantissa0,x
.96ec	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.96ee	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96f0	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96f2	f0 0e		beq $9702			beq 	_DRFDereferenceTwo
.96f4	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96f6	f0 2f		beq $9727			beq 	_DRFFull
.96f8	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96fa	29 03		and #$03			and 	#3
.96fc	f0 29		beq $9727			beq 	_DRFFull 					; the whole word
.96fe	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9700	f0 06		beq $9708			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9702					_DRFDereferenceTwo:
.9702	a0 01		ldy #$01			ldy 	#1
.9704	b1 36		lda ($36),y			lda 	(zTemp0),y
.9706	95 60		sta $60,x			sta 	NSMantissa1,x
.9708					_DRFClear23:
.9708	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.970a	74 70		stz $70,x			stz 	NSMantissa3,x
.970c	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.970e	29 18		and #$18			and 	#NSBTypeMask
.9710	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9712	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9714	d0 0e		bne $9724			bne 	_DRFNotString
.9716	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9718	15 60		ora $60,x			ora 	NSMantissa1,x
.971a	d0 08		bne $9724			bne 	_DRFNotString
.971c	a9 26		lda #$26			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.971e	95 58		sta $58,x			sta 	NSMantissa0,X
.9720	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9722	95 60		sta $60,x			sta 	NSMantissa1,X
.9724					_DRFNotString
.9724	7a		ply				ply 								; restore Y and exit
.9725					_DRFExit:
.9725	60		rts				rts
.9726					_DRFNullString:
>9726	00						.byte 	0
.9727					_DRFFull:
.9727	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9729	b1 36		lda ($36),y			lda 	(zTemp0),y
.972b	95 60		sta $60,x			sta 	NSMantissa1,x
.972d	c8		iny				iny
.972e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9730	95 68		sta $68,x			sta 	NSMantissa2,x
.9732	c8		iny				iny
.9733	b1 36		lda ($36),y			lda 	(zTemp0),y
.9735	95 70		sta $70,x			sta 	NSMantissa3,x
.9737	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.9739	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.973b	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.973d	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.973f	f0 05		beq $9746			beq 	_DRFNoExponent
.9741	c8		iny				iny 								; if not, read the exponent as well.
.9742	b1 36		lda ($36),y			lda 	(zTemp0),y
.9744	95 78		sta $78,x			sta 	NSExponent,x
.9746					_DRFNoExponent:
.9746	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9748	10 0a		bpl $9754			bpl 	_DRFExit2 					; if not, then exit.
.974a	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.974c	95 70		sta $70,x			sta 	NSMantissa3,x
.974e	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9750	09 80		ora #$80			ora 	#NSBIsNegative
.9752	95 50		sta $50,x			sta 	NSStatus,x
.9754					_DRFExit2:
.9754	7a		ply				ply
.9755	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9756					EncodeNumberStart:
.9756	38		sec				sec
.9757	80 01		bra $975a			bra 	EncodeNumberContinue+1
.9759					EncodeNumberContinue:
.9759	18		clc				clc
.975a					EncodeNumber:
.975a	08		php				php 								; save reset flag.
.975b	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.975d	f0 12		beq $9771			beq 	_ENIsOkay
.975f	c9 30		cmp #$30			cmp 	#"0"
.9761	90 04		bcc $9767			bcc 	_ENBadNumber
.9763	c9 3a		cmp #$3a			cmp 	#"9"+1
.9765	90 0a		bcc $9771			bcc 	_ENIsOkay
.9767					_ENBadNumber:
.9767	28		plp				plp 								; throw saved reset
.9768	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.976b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.976d	f0 7b		beq $97ea			beq 	_ENConstructFinal
.976f					_ENFail:
.976f	18		clc				clc 								; not allowed
.9770	60		rts				rts
.9771					_ENIsOkay:
.9771	28		plp				plp 								; are we restarting
.9772	90 15		bcc $9789			bcc 	_ENNoRestart
.9774					_ENStartEncode:
.9774	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.9776	f0 0c		beq $9784			beq 	_ENFirstDP
.9778	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.977a	20 34 9e	jsr $9e34			jsr 	NSMSetByte 					; in single byte mode.
.977d	a9 01		lda #$01			lda 	#ESTA_Low
.977f					_ENExitChange:
.977f	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.9782	38		sec				sec
.9783	60		rts				rts
.9784					_ENFirstDP:
.9784	20 32 9e	jsr $9e32			jsr 	NSMSetZero 					; clear integer part
.9787	80 3c		bra $97c5			bra 	_ESTASwitchFloat			; go straight to float and exi
.9789					_ENNoRestart:
.9789	48		pha				pha 								; save digit or DP on stack.
.978a	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.978d	c9 01		cmp #$01			cmp 	#ESTA_Low
.978f	f0 09		beq $979a			beq  	_ESTALowState
.9791	c9 02		cmp #$02			cmp 	#ESTA_High
.9793	f0 26		beq $97bb			beq 	_ESTAHighState
.9795	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9797	f0 38		beq $97d1			beq 	_ESTADecimalState
>9799	db						.byte 	$DB 						; causes a break in the emulator
.979a					_ESTALowState:
.979a	68		pla				pla 								; get value back
.979b	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.979d	f0 26		beq $97c5			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.979f	29 0f		and #$0f			and 	#15 						; make digit
.97a1	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.97a4	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97a6	0a		asl a				asl 	a
.97a7	0a		asl a				asl 	a
.97a8	75 58		adc $58,x			adc 	NSMantissa0,x
.97aa	0a		asl a				asl 	a
.97ab	6d 06 04	adc $0406			adc 	DigitTemp
.97ae	95 58		sta $58,x			sta 	NSMantissa0,x
.97b0	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97b2	90 05		bcc $97b9			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97b4	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97b6	8d 05 04	sta $0405			sta 	EncodeState
.97b9					_ESTANoSwitch:
.97b9	38		sec				sec
.97ba	60		rts				rts
.97bb					_ESTAHighState:
.97bb	68		pla				pla 								; get value back
.97bc	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97be	f0 05		beq $97c5			beq 	_ESTASwitchFloat
.97c0	20 1e 98	jsr $981e			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97c3	38		sec				sec
.97c4	60		rts				rts
.97c5					_ESTASwitchFloat:
.97c5	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.97c8	e8		inx				inx 								; zero the decimal additive.
.97c9	20 32 9e	jsr $9e32			jsr 	NSMSetZero
.97cc	ca		dex				dex
.97cd	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97cf	80 ae		bra $977f			bra 	_ENExitChange
.97d1					_ESTADecimalState:
.97d1	68		pla				pla 								; digit.
.97d2	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97d4	f0 99		beq $976f			beq 	_ENFail
.97d6	e8		inx				inx 								; put digit into fractional part of X+1
.97d7	20 1e 98	jsr $981e			jsr 	ESTAShiftDigitIntoMantissa
.97da	ca		dex				dex
.97db	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.97de	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.97e1	c9 0b		cmp #$0b			cmp 	#11
.97e3	f0 02		beq $97e7			beq 	_ESTADSFail
.97e5	38		sec				sec
.97e6	60		rts				rts
.97e7					_ESTADSFail:
.97e7	4c b5 9f	jmp $9fb5			jmp 	RangeError
.97ea					_ENConstructFinal:
.97ea	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.97ed	f0 2d		beq $981c			beq 	_ENCFExit 					; no decimals
.97ef	5a		phy				phy
.97f0	0a		asl a				asl 	a 							; x 4 and CLC
.97f1	0a		asl a				asl 	a
.97f2	6d 07 04	adc $0407			adc 	DecimalCount
.97f5	a8		tay				tay
.97f6	b9 74 9f	lda $9f74,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.97f9	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.97fb	b9 75 9f	lda $9f75,y			lda 	DecimalScalarTable-5+1,y
.97fe	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9800	b9 76 9f	lda $9f76,y			lda 	DecimalScalarTable-5+2,y
.9803	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9805	b9 77 9f	lda $9f77,y			lda 	DecimalScalarTable-5+3,y
.9808	95 72		sta $72,x			sta 	NSMantissa3+2,x
.980a	b9 78 9f	lda $9f78,y			lda 	DecimalScalarTable-5+4,y
.980d	95 7a		sta $7a,x			sta 	NSExponent+2,x
.980f	a9 08		lda #$08			lda 	#NSTFloat
.9811	95 52		sta $52,x			sta 	NSStatus+2,x
.9813	7a		ply				ply
.9814	e8		inx				inx 								; multiply decimal const by decimal scalar
.9815	20 a4 95	jsr $95a4			jsr 	FloatMultiply
.9818	ca		dex				dex
.9819	20 5f 94	jsr $945f			jsr 	FloatAdd 					; add to integer part.
.981c					_ENCFExit:
.981c	18		clc				clc 								; reject the digit.
.981d	60		rts				rts
.981e					ESTAShiftDigitIntoMantissa:
.981e	29 0f		and #$0f			and 	#15 						; save digit
.9820	48		pha				pha
.9821	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9823	48		pha				pha
.9824	b5 68		lda $68,x			lda 	NSMantissa2,x
.9826	48		pha				pha
.9827	b5 60		lda $60,x			lda 	NSMantissa1,x
.9829	48		pha				pha
.982a	b5 58		lda $58,x			lda 	NSMantissa0,x
.982c	48		pha				pha
.982d	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 2
.9830	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 4
.9833	18		clc				clc 								; pop mantissa and add
.9834	68		pla				pla
.9835	75 58		adc $58,x			adc 	NSMantissa0,x
.9837	95 58		sta $58,x			sta 	NSMantissa0,x
.9839	68		pla				pla
.983a	75 60		adc $60,x			adc 	NSMantissa1,x
.983c	95 60		sta $60,x			sta 	NSMantissa1,x
.983e	68		pla				pla
.983f	75 68		adc $68,x			adc 	NSMantissa2,x
.9841	95 68		sta $68,x			sta 	NSMantissa2,x
.9843	68		pla				pla
.9844	75 70		adc $70,x			adc 	NSMantissa3,x
.9846	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9848	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 10
.984b	68		pla				pla 								; add digit
.984c	18		clc				clc
.984d	75 58		adc $58,x			adc 	NSMantissa0,x
.984f	95 58		sta $58,x			sta 	NSMantissa0,x
.9851	90 0a		bcc $985d			bcc 	_ESTASDExit
.9853	f6 60		inc $60,x			inc 	NSMantissa1,x
.9855	d0 06		bne $985d			bne 	_ESTASDExit
.9857	f6 68		inc $68,x			inc 	NSMantissa2,x
.9859	d0 02		bne $985d			bne 	_ESTASDExit
.985b	f6 70		inc $70,x			inc 	NSMantissa3,x
.985d					_ESTASDExit:
.985d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.985e					EvaluateTerm:
.985e	b1 30		lda ($30),y			lda 	(codePtr),y
.9860	30 18		bmi $987a			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9862	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9864	b0 6c		bcs $98d2			bcs 	_ETVariable
.9866	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9868	90 6b		bcc $98d5			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.986a	c9 3a		cmp #$3a			cmp 	#'9'+1
.986c	b0 67		bcs $98d5			bcs 	_ETPuncUnary
.986e	20 56 97	jsr $9756			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9871					_ETNumber:
.9871	c8		iny				iny 								; keep encoding until we have the numbers
.9872	b1 30		lda ($30),y			lda 	(codePtr),y
.9874	20 59 97	jsr $9759			jsr 	EncodeNumberContinue
.9877	b0 f8		bcs $9871			bcs 	_ETNumber 					; go back if accepted.
.9879	60		rts				rts
.987a					_ETCheckUnary:
.987a	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.987c	f0 3f		beq $98bd			beq 	_ETString
.987e	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9880	f0 12		beq $9894			beq 	_ETHexConstant
.9882	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9884	90 0b		bcc $9891			bcc 	_ETSyntaxError
.9886	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1
.9888	b0 07		bcs $9891			bcs 	_ETSyntaxError
.988a	da		phx				phx 								; push X on the stack
.988b	0a		asl a				asl 	a 							; put vector x 2 into X
.988c	aa		tax				tax
.988d	c8		iny				iny 								; consume unary function token
.988e	7c 42 8c	jmp ($8c42,x)			jmp 	(VectorSet0,x) 				; and do it.
.9891					_ETSyntaxError:
.9891	4c b0 9f	jmp $9fb0			jmp 	SyntaxError
.9894					_ETHexConstant:
.9894	c8		iny				iny 								; skip #
.9895	c8		iny				iny 								; skip count
.9896	20 32 9e	jsr $9e32			jsr 	NSMSetZero 					; clear result
.9899					_ETHLoop:
.9899	b1 30		lda ($30),y			lda 	(codePtr),y
.989b	c8		iny				iny 								; and consume
.989c	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.989e	f0 1c		beq $98bc			beq 	_ETHExit
.98a0	48		pha				pha 								; save on stack.
.98a1	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 2
.98a4	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 4
.98a7	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 8
.98aa	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 16
.98ad	68		pla				pla 								; ASCII
.98ae	c9 41		cmp #$41			cmp 	#'A'
.98b0	90 02		bcc $98b4			bcc 	_ETHNotChar
.98b2	e9 07		sbc #$07			sbc 	#7
.98b4					_ETHNotChar:
.98b4	29 0f		and #$0f			and 	#15 						; digit now
.98b6	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98b8	95 58		sta $58,x			sta 	NSMantissa0,x
.98ba	80 dd		bra $9899			bra 	_ETHLoop 					; go round.
.98bc					_ETHExit:
.98bc	60		rts				rts
.98bd					_ETString:
.98bd	c8		iny				iny 								; look at length
.98be	b1 30		lda ($30),y			lda 	(codePtr),y
.98c0	48		pha				pha
.98c1	c8		iny				iny 								; first character
.98c2	20 8e a5	jsr $a58e			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98c5	68		pla				pla 								; restore count and save
.98c6	85 36		sta $36				sta 	zTemp0
.98c8	98		tya				tya 								; add length to Y to skip it.
.98c9	18		clc				clc
.98ca	65 36		adc $36				adc 	zTemp0
.98cc	a8		tay				tay
.98cd	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98cf	95 50		sta $50,x			sta 	NSStatus,x
.98d1	60		rts				rts
.98d2					_ETVariable:
.98d2	4c 27 99	jmp $9927			jmp 	VariableHandler
.98d5					_ETPuncUnary:
.98d5	c8		iny				iny 								; consume the unary character
.98d6	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98d8	f0 2b		beq $9905			beq 	_ETUnaryNegate
.98da	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98dc	f0 36		beq $9914			beq 	_ETDereference
.98de	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.98e0	f0 3e		beq $9920			beq 	_ETParenthesis
.98e2	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.98e4	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.98e6	f0 06		beq $98ee			beq 	_ETIndirection
.98e8	e6 36		inc $36				inc 	zTemp0
.98ea	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.98ec	d0 a3		bne $9891			bne 	_ETSyntaxError
.98ee					_ETIndirection:
.98ee	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.98f0	1a		inc a				inc 	a
.98f1	48		pha				pha
.98f2	20 5e 98	jsr $985e			jsr 	EvaluateTerm				; evaluate the term
.98f5	20 d7 96	jsr $96d7			jsr 	Dereference 				; dereference it.
.98f8	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.98fa	d0 06		bne $9902			bne 	_ETTypeMismatch
.98fc	68		pla				pla 								; indirection 1-2
.98fd	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.98ff	95 50		sta $50,x			sta 	NSStatus,x
.9901	60		rts				rts
.9902					_ETTypeMismatch:
.9902	4c ba 9f	jmp $9fba			jmp 	TypeError
.9905					_ETUnaryNegate:
.9905	20 5e 98	jsr $985e			jsr 	EvaluateTerm				; evaluate the term
.9908	20 d7 96	jsr $96d7			jsr 	Dereference 				; dereference it.
.990b	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.990d	29 10		and #$10			and 	#NSTString
.990f	d0 f1		bne $9902			bne 	_ETTypeMismatch
.9911	4c f4 9d	jmp $9df4			jmp 	NSMNegate  					; just toggles the sign bit.
.9914					_ETDereference:
.9914	20 5e 98	jsr $985e			jsr 	EvaluateTerm				; evaluate the term
.9917	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9919	29 20		and #$20			and 	#NSBIsReference
.991b	f0 e5		beq $9902			beq 	_ETTypeMismatch
.991d	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.991f	60		rts				rts
.9920					_ETParenthesis:
.9920	20 14 94	jsr $9414			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9923	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket 			; check for )
.9926	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9927					VariableHandler:
.9927	b1 30		lda ($30),y			lda 	(codePtr),y
.9929	18		clc				clc
.992a	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.992c	85 37		sta $37				sta 	zTemp0+1
.992e	c8		iny				iny
.992f	b1 30		lda ($30),y			lda 	(codePtr),y
.9931	85 36		sta $36				sta 	zTemp0
.9933	c8		iny				iny
.9934	18		clc				clc									; copy variable address+3 to mantissa
.9935	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.9937	95 58		sta $58,x			sta 	NSMantissa0,x
.9939	a5 37		lda $37				lda 	zTemp0+1
.993b	69 00		adc #$00			adc 	#0
.993d	95 60		sta $60,x			sta 	NSMantissa1,x
.993f	74 68		stz $68,x			stz 	NSMantissa2,x
.9941	74 70		stz $70,x			stz 	NSMantissa3,x
.9943	74 78		stz $78,x			stz 	NSExponent,x
.9945	5a		phy				phy
.9946	a0 02		ldy #$02			ldy 	#2 							; read type
.9948	b1 36		lda ($36),y			lda 	(zTemp0),y
.994a	7a		ply				ply
.994b	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.994d	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.994f	95 50		sta $50,x			sta 	NSStatus,x
.9951	29 04		and #$04			and 	#NSBIsArray
.9953	d0 01		bne $9956			bne 	_VHArray
.9955	60		rts				rts
.9956					_VHArray:
.9956	e8		inx				inx
.9957	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; get the 1st index.
.995a	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.995c	95 51		sta $51,x			sta 	NSStatus+1,x
.995e	b1 30		lda ($30),y			lda 	(codePtr),y
.9960	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9962	d0 06		bne $996a			bne 	_VHNoSecondIndex
.9964	c8		iny				iny 								; skip the comma
.9965	e8		inx				inx
.9966	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9969	ca		dex				dex
.996a					_VHNoSecondIndex:
.996a	ca		dex				dex 								; set X back.
.996b	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket 			; and check the right bracket.
.996e	5a		phy				phy 								; save position
.996f	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9971	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9973	f0 60		beq $99d5			beq 	_VHBadIndex
.9975	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.9977	85 3e		sta $3e				sta 	zaTemp
.9979	b5 60		lda $60,x			lda 	NSMantissa1,x
.997b	85 3f		sta $3f				sta 	zaTemp+1
.997d	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.997f	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9981	f0 02		beq $9985			beq 	_VHHas2Mask
.9983	a9 ff		lda #$ff			lda 	#$FF
.9985					_VHHas2Mask:
.9985	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9987	f0 4c		beq $99d5			beq 	_VHBadIndex
.9989	0a		asl a				asl 	a 							; carry will be set if a second index
.998a	90 08		bcc $9994			bcc 	_VHCheckFirstIndex
.998c	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.998e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9990	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.9992	90 41		bcc $99d5			bcc 	_VHBadIndex
.9994					_VHCheckFirstIndex:
.9994	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9996	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9998	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.999a	90 39		bcc $99d5			bcc 	_VHBadIndex
.999c	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.999e	64 37		stz $37				stz 	zTemp0+1
.99a0	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99a2	30 0e		bmi $99b2			bmi 	_VHNoMultiply
.99a4	da		phx				phx
.99a5	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.99a7	48		pha				pha
.99a8	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.99aa	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99ac	1a		inc a				inc 	a 							; add 1 for zero base
.99ad	fa		plx				plx
.99ae	20 dd 9d	jsr $9ddd			jsr 	Multiply8x8 				; calculate -> Z0
.99b1	fa		plx				plx
.99b2					_VHNoMultiply:
.99b2	18		clc				clc
.99b3	a5 36		lda $36				lda 	zTemp0
.99b5	75 59		adc $59,x			adc 	NSMantissa0+1,x
.99b7	85 36		sta $36				sta 	zTemp0
.99b9	a5 37		lda $37				lda 	zTemp0+1
.99bb	69 00		adc #$00			adc 	#0
.99bd	85 37		sta $37				sta 	zTemp0+1
.99bf	b5 50		lda $50,x			lda 	NSStatus,x
.99c1	20 27 85	jsr $8527			jsr 	ScaleByBaseType
.99c4	18		clc				clc
.99c5	b2 3e		lda ($3e)			lda 	(zaTemp)
.99c7	65 36		adc $36				adc 	zTemp0
.99c9	95 58		sta $58,x			sta 	NSMantissa0,x
.99cb	a0 01		ldy #$01			ldy 	#1
.99cd	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99cf	65 37		adc $37				adc 	zTemp0+1
.99d1	95 60		sta $60,x			sta 	NSMantissa1,x
.99d3	7a		ply				ply 								; restore position
.99d4	60		rts				rts
.99d5					_VHBadIndex:
.99d5	a9 17		lda #$17		lda	#23
.99d7	4c 10 8f	jmp $8f10		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.99da					AbsUnary:
.99da	fa		plx				plx 								; restore stack pos
.99db	20 80 9d	jsr $9d80			jsr 	EvaluateNumber 				; get a float or int
.99de	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.99e1	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.99e3	29 7f		and #$7f			and 	#$7F
.99e5	95 50		sta $50,x			sta 	NSStatus,x
.99e7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.99e8					AllocUnary:
.99e8	fa		plx				plx 								; restore stack pos
.99e9	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger		; get bytes required.
.99ec	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.99ef	da		phx				phx 								; save X/Y
.99f0	5a		phy				phy
.99f1	8a		txa				txa 								; copy X into Y
.99f2	a8		tay				tay
.99f3	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.99f6	aa		tax				tax
.99f7	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.99fa	20 07 9a	jsr $9a07			jsr 	AllocateXABytes 			; allocate memory
.99fd	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.9a00	8a		txa				txa 	 							; typing is 16 bit integer.
.9a01	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.9a04	7a		ply				ply
.9a05	fa		plx				plx
.9a06	60		rts				rts
.9a07					AllocateXABytes:
.9a07	5a		phy				phy
.9a08	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a0b	84 36		sty $36				sty 	zTemp0
.9a0d	5a		phy				phy
.9a0e	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.9a11	84 37		sty $37				sty 	zTemp0+1
.9a13	5a		phy				phy
.9a14	18		clc				clc 								; add to low memory pointer
.9a15	6d 0c 04	adc $040c			adc 	lowMemPtr
.9a18	8d 0c 04	sta $040c			sta 	lowMemPtr
.9a1b	8a		txa				txa
.9a1c	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9a1f	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9a22	b0 2f		bcs $9a53			bcs 	CISSMemory
.9a24	20 45 9a	jsr $9a45			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a27					_ClearMemory:
.9a27	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.9a2a	c5 36		cmp $36				cmp 	zTemp0
.9a2c	d0 07		bne $9a35			bne 	_CMClearNext
.9a2e	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9a31	c5 37		cmp $37				cmp 	zTemp0+1
.9a33	f0 0c		beq $9a41			beq 	_CMExit
.9a35					_CMClearNext:
.9a35	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a37	92 36		sta ($36)			sta 	(zTemp0)
.9a39	e6 36		inc $36				inc 	zTemp0
.9a3b	d0 ea		bne $9a27			bne 	_ClearMemory
.9a3d	e6 37		inc $37				inc		zTemp0+1
.9a3f	80 e6		bra $9a27			bra 	_ClearMemory
.9a41					_CMExit:
.9a41	fa		plx				plx
.9a42	68		pla				pla
.9a43	7a		ply				ply
.9a44	60		rts				rts
.9a45					CheckIdentifierStringSpace:
.9a45	48		pha				pha
.9a46	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a49	18		clc				clc
.9a4a	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a4c	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a4f	b0 02		bcs $9a53			bcs 	CISSMemory
.9a51	68		pla				pla
.9a52	60		rts				rts
.9a53					CISSMemory:
.9a53	a9 06		lda #$06		lda	#6
.9a55	4c 10 8f	jmp $8f10		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a58					AscUnary:
.9a58	fa		plx				plx 								; restore stack pos
.9a59	20 8a 9d	jsr $9d8a			jsr 	EvaluateString 				; get a string
.9a5c	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a5e	20 34 9e	jsr $9e34			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a61	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.9a64	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/deekpeek.asm

.9a65					PeekUnary:
.9a65	18		clc				clc
.9a66	80 01		bra $9a69			bra 	DPUnary
.9a68					DeekUnary:
.9a68	38		sec				sec
.9a69					DPUnary:
.9a69	fa		plx				plx 								; restore position.
.9a6a	08		php				php									; save on stack, CS = Deek, CC = Peek
.9a6b	20 b2 9d	jsr $9db2			jsr		Evaluate16BitInteger 		; address as constant.
.9a6e	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.9a71	28		plp				plp 								; function back.
.9a72	a9 21		lda #$21			lda 	#NSBIsReference+NSTInteger+1 ; 1 byte read
.9a74	90 01		bcc $9a77			bcc 	_DPUpdate
.9a76	1a		inc a				inc 	a 							; 2 byte read
.9a77					_DPUpdate:
.9a77	95 50		sta $50,x			sta 	NSStatus,x 					; set to 1/2 byte reference.
.9a79	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a7a					FracUnary:
.9a7a	fa		plx				plx 								; restore stack pos
.9a7b	20 80 9d	jsr $9d80			jsr 	EvaluateNumber 				; get a float or int
.9a7e	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.9a81	b5 50		lda $50,x			lda 	NSStatus,x
.9a83	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a85	f0 04		beq $9a8b			beq 	_IUZero
.9a87	20 25 95	jsr $9525			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9a8a	60		rts				rts
.9a8b					_IUZero:
.9a8b	20 32 9e	jsr $9e32			jsr 	NSMSetZero
.9a8e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a8f					IntUnary:
.9a8f	fa		plx				plx 								; restore stack pos
.9a90	20 80 9d	jsr $9d80			jsr 	EvaluateNumber 				; get a float or int
.9a93	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.9a96	b5 50		lda $50,x			lda 	NSStatus,x
.9a98	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a9a	f0 03		beq $9a9f			beq 	_IUExit
.9a9c	20 7d 95	jsr $957d			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9a9f					_IUExit:
.9a9f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9aa0					LenUnary:
.9aa0	fa		plx				plx 								; restore stack pos
.9aa1	20 8a 9d	jsr $9d8a			jsr 	EvaluateString 				; get a string
.9aa4	5a		phy				phy
.9aa5	a0 00		ldy #$00			ldy 	#0 							; find length
.9aa7					_LenFind:
.9aa7	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9aa9	f0 06		beq $9ab1			beq 	_LenExit
.9aab	c8		iny				iny
.9aac	d0 f9		bne $9aa7			bne 	_LenFind
.9aae	4c b5 9f	jmp $9fb5			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9ab1					_LenExit:
.9ab1	98		tya				tya		 							; return length
.9ab2	20 34 9e	jsr $9e34			jsr 	NSMSetByte
.9ab5	7a		ply				ply
.9ab6	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.9ab9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9aba					Unary_Min:
.9aba	a9 01		lda #$01			lda 	#1
.9abc	80 02		bra $9ac0			bra 	UnaryMinMaxMain
.9abe					Unary_Max:
.9abe	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9ac0					UnaryMinMaxMain:
.9ac0	fa		plx				plx 								; get index on number stack
.9ac1	48		pha				pha 								; save comparator
.9ac2	20 77 9d	jsr $9d77			jsr 	EvaluateValue 				; get the first value.
.9ac5					_UMMMLoop:
.9ac5	b1 30		lda ($30),y			lda 	(codePtr),y
.9ac7	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9ac9	f0 22		beq $9aed			beq 	_UMMMDone
.9acb	20 ff 8e	jsr $8eff			jsr 	CheckComma 					; must be a comma
.9ace	e8		inx				inx
.9acf	20 77 9d	jsr $9d77			jsr 	EvaluateValue
.9ad2	ca		dex				dex
.9ad3	20 15 9e	jsr $9e15			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9ad6	e8		inx				inx
.9ad7	20 15 9e	jsr $9e15			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9ada	e8		inx				inx
.9adb	20 c7 8f	jsr $8fc7			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9ade	ca		dex				dex
.9adf	ca		dex				dex
.9ae0	85 36		sta $36				sta 	zTemp0 						; save required result
.9ae2	68		pla				pla 								; get and save comparator
.9ae3	48		pha				pha
.9ae4	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9ae6	d0 dd		bne $9ac5			bne 	_UMMMLoop
.9ae8	20 f0 9a	jsr $9af0			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9aeb	80 d8		bra $9ac5			bra 	_UMMMLoop
.9aed					_UMMMDone:
.9aed	68		pla				pla 								; throw the comparator
.9aee	c8		iny				iny 								; skip )
.9aef	60		rts				rts
.9af0					ExpCopyAboveDown:
.9af0	b5 51		lda $51,x			lda 	NSStatus+1,x
.9af2	95 50		sta $50,x			sta 	NSStatus,x
.9af4	b5 79		lda $79,x			lda 	NSExponent+1,x
.9af6	95 78		sta $78,x			sta 	NSExponent,x
.9af8	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9afa	95 58		sta $58,x			sta 	NSMantissa0,x
.9afc	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9afe	95 60		sta $60,x			sta 	NSMantissa1,x
.9b00	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9b02	95 68		sta $68,x			sta 	NSMantissa2,x
.9b04	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9b06	95 70		sta $70,x			sta 	NSMantissa3,x
.9b08	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b09					Unary_Not:
.9b09	fa		plx				plx
.9b0a	20 9f 9d	jsr $9d9f			jsr 	EvaluateInteger 			; get integer
.9b0d	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.9b10	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; zero mantissa ?
.9b13	f0 04		beq $9b19			beq 	_NotZero
.9b15	20 32 9e	jsr $9e32			jsr 	NSMSetZero
.9b18	60		rts				rts
.9b19					_NotZero:
.9b19	4c 7d 8f	jmp $8f7d			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b1c					Unary_Random:
.9b1c	fa		plx				plx
.9b1d	20 8e 9b	jsr $9b8e			jsr 	Random32Bit 				; get a random number
.9b20	20 77 9b	jsr $9b77			jsr 	URCopyToMantissa  			; put in mantissa
.9b23	b1 30		lda ($30),y			lda 	(codePtr),y
.9b25	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b27	f0 08		beq $9b31			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9b29	e8		inx				inx
.9b2a	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b2d	ca		dex				dex
.9b2e	20 cf 90	jsr $90cf			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9b31					_URNoModulus:
.9b31	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9b33	74 78		stz $78,x			stz 	NSExponent,x
.9b35	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.9b38	60		rts				rts
.9b39					Unary_Rnd:
.9b39	fa		plx				plx
.9b3a	20 80 9d	jsr $9d80			jsr 	EvaluateNumber 				; number to use.
.9b3d	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket 			; closing bracket
.9b40	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b43	f0 26		beq $9b6b			beq 	_URCopySeed
.9b45	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b47	10 1f		bpl $9b68			bpl 	_URDontSeed
.9b49	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b4b	49 17		eor #$17			eor 	#$17
.9b4d	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b50	b5 60		lda $60,x			lda 	NSMantissa1,x
.9b52	49 a5		eor #$a5			eor 	#$A5
.9b54	8d 09 04	sta $0409			sta 	RandomSeed+1
.9b57	b5 68		lda $68,x			lda 	NSMantissa2,x
.9b59	49 c2		eor #$c2			eor 	#$C2
.9b5b	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9b5e	b5 70		lda $70,x			lda 	NSMantissa3,x
.9b60	49 9d		eor #$9d			eor 	#$9D
.9b62	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9b65	20 8e 9b	jsr $9b8e			jsr 	Random32Bit
.9b68					_URDontSeed:
.9b68	20 8e 9b	jsr $9b8e			jsr 	Random32Bit 				; generate a number
.9b6b					_URCopySeed:
.9b6b	20 77 9b	jsr $9b77			jsr 	URCopyToMantissa 			; copy into mantissa
.9b6e	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b70	95 78		sta $78,x			sta 	NSExponent,x
.9b72	a9 08		lda #$08			lda 	#NSTFloat
.9b74	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9b76	60		rts				rts
.9b77					URCopyToMantissa:
.9b77	ad 08 04	lda $0408			lda 	RandomSeed+0
.9b7a	95 58		sta $58,x			sta 	NSMantissa0,x
.9b7c	ad 09 04	lda $0409			lda 	RandomSeed+1
.9b7f	95 60		sta $60,x			sta 	NSMantissa1,x
.9b81	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b84	95 68		sta $68,x			sta 	NSMantissa2,x
.9b86	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b89	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b8b	95 70		sta $70,x			sta 	NSMantissa3,x
.9b8d	60		rts				rts
.9b8e					Random32Bit:
.9b8e	5a		phy				phy
.9b8f	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b91	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9b94	d0 03		bne $9b99			bne 	_Random1
.9b96	a8		tay				tay 								; if so do it 256 times
.9b97	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b99					_Random1:
.9b99	0a		asl a				asl 	a 							; LSFR RNG
.9b9a	2e 09 04	rol $0409			rol 	RandomSeed+1
.9b9d	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9ba0	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9ba3	90 02		bcc $9ba7			bcc 	_Random2
.9ba5	49 c5		eor #$c5			eor 	#$C5
.9ba7					_Random2:
.9ba7	88		dey				dey
.9ba8	d0 ef		bne $9b99			bne 	_Random1
.9baa	8d 08 04	sta $0408			sta 	RandomSeed+0
.9bad	7a		ply				ply
.9bae	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9baf					SgnUnary:
.9baf	fa		plx				plx 								; restore stack pos
.9bb0	20 80 9d	jsr $9d80			jsr 	EvaluateNumber 				; get a float or int
.9bb3	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.9bb6	20 54 9e	jsr $9e54			jsr 	NSMIsZero 					; if zero
.9bb9	f0 0e		beq $9bc9			beq 	_SGZero  					; return Int Zero
.9bbb	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9bbd	48		pha				pha
.9bbe	a9 01		lda #$01			lda 	#1 							; set to 1
.9bc0	20 34 9e	jsr $9e34			jsr 	NSMSetByte
.9bc3	68		pla				pla
.9bc4	29 80		and #$80			and		#$80 						; copy the sign byte out
.9bc6	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9bc8	60		rts				rts
.9bc9	20 32 9e	jsr $9e32	_SGZero:jsr 	NSMSetZero
.9bcc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9bcd					ValUnary:
.9bcd	fa		plx				plx 								; restore stack pos
.9bce	20 e3 9b	jsr $9be3			jsr 	ValMainCode 				; do the main val() code
.9bd1	b0 01		bcs $9bd4			bcs 	_VUError 					; couldn't convert
.9bd3	60		rts				rts
.9bd4					_VUError:
.9bd4	4c ba 9f	jmp $9fba			jmp 	TypeError
.9bd7					IsValUnary:
.9bd7	fa		plx				plx 								; restore stack pos
.9bd8	20 e3 9b	jsr $9be3			jsr 	ValMainCode 				; do the main val() code
.9bdb	b0 03		bcs $9be0			bcs 	_VUBad
.9bdd	4c 7d 8f	jmp $8f7d			jmp 	ReturnTrue
.9be0					_VUBad:
.9be0	4c 88 8f	jmp $8f88			jmp 	ReturnFalse
.9be3					ValMainCode:
.9be3	20 8a 9d	jsr $9d8a			jsr 	EvaluateString 				; get a string
.9be6	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket 			; check right bracket present
.9be9					ValEvaluateZTemp0:
.9be9	5a		phy				phy
.9bea	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9bec	f0 17		beq $9c05			beq 	_VMCFail2
.9bee	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9bf0	48		pha				pha 								; save first character
.9bf1	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9bf3	d0 01		bne $9bf6			bne 	_VMCStart
.9bf5	c8		iny				iny 								; skip over -
.9bf6					_VMCStart:
.9bf6	38		sec				sec 								; initialise first time round.
.9bf7					_VMCNext:
.9bf7	c8		iny				iny 								; pre-increment
.9bf8	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9bfa	f0 0c		beq $9c08			beq 	_VMCSuccess 				; successful.
.9bfc	20 5a 97	jsr $975a			jsr 	EncodeNumber 				; send it to the number-builder
.9bff	90 03		bcc $9c04			bcc 	_VMCFail 					; if failed, give up.
.9c01	18		clc				clc 								; next time round, countinue
.9c02	80 f3		bra $9bf7			bra 	_VMCNext
.9c04					_VMCFail:
.9c04	68		pla				pla
.9c05					_VMCFail2:
.9c05	7a		ply				ply
.9c06	38		sec				sec
.9c07	60		rts				rts
.9c08					_VMCSuccess:
.9c08	a9 00		lda #$00			lda 	#0 							; construct final
.9c0a	20 5a 97	jsr $975a			jsr 	EncodeNumber 				; by sending a duff value.
.9c0d	68		pla				pla 								; if it was -ve
.9c0e	c9 2d		cmp #$2d			cmp 	#"-"
.9c10	d0 03		bne $9c15			bne 	_VMCNotNegative
.9c12	20 f4 9d	jsr $9df4			jsr		NSMNegate 					; negate it.
.9c15					_VMCNotNegative:
.9c15	7a		ply				ply
.9c16	18		clc				clc
.9c17	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c18					ChrUnary:
.9c18	fa		plx				plx 								; restore stack pos
.9c19	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9c1c	48		pha				pha
.9c1d	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.9c20	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c22	20 b5 a7	jsr $a7b5			jsr 	StringTempAllocate
.9c25	68		pla				pla 								; write number to it
.9c26	20 ee a7	jsr $a7ee			jsr 	StringTempWrite
.9c29	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c2a					SpcUnary:
.9c2a	fa		plx				plx 								; restore stack pos
.9c2b	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger			; get value
.9c2e	5a		phy				phy
.9c2f	48		pha				pha 								; save count
.9c30	20 b5 a7	jsr $a7b5			jsr 	StringTempAllocate
.9c33	7a		ply				ply 								; to do count in Y
.9c34					_SpcLoop:
.9c34	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9c36	f0 08		beq $9c40			beq 	_SpcExit
.9c38	a9 20		lda #$20			lda 	#32
.9c3a	20 ee a7	jsr $a7ee			jsr 	StringTempWrite
.9c3d	88		dey				dey
.9c3e	80 f4		bra $9c34			bra 	_SPCLoop
.9c40					_SpcExit:
.9c40	7a		ply				ply
.9c41	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.9c44	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c45					Unary_Str:
.9c45	fa		plx				plx
.9c46	20 80 9d	jsr $9d80			jsr 	EvaluateNumber  			; get number
.9c49	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket 			; closing bracket
.9c4c	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c4e	20 67 9c	jsr $9c67			jsr 	ConvertNumberToString 		; do the conversion.
.9c51	a9 21		lda #$21			lda		#33 						; create buffer
.9c53	20 b5 a7	jsr $a7b5			jsr 	StringTempAllocate 			; allocate memory
.9c56	da		phx				phx  								; copy the converted string into the buffer.
.9c57	a2 00		ldx #$00			ldx 	#0
.9c59					_USCopy:
.9c59	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c5c	20 ee a7	jsr $a7ee			jsr 	StringTempWrite
.9c5f	e8		inx				inx
.9c60	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c63	d0 f4		bne $9c59			bne 	_USCopy
.9c65	fa		plx				plx
.9c66	60		rts				rts
.9c67					ConvertNumberToString:
.9c67	5a		phy				phy 								; save code position
.9c68	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9c6b	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9c6e	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9c70	10 09		bpl $9c7b			bpl 	_CNTSNotNegative
.9c72	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c74	95 50		sta $50,x			sta 	NSStatus,x
.9c76	a9 2d		lda #$2d			lda 	#"-"
.9c78	20 dc 9c	jsr $9cdc			jsr 	WriteDecimalBuffer
.9c7b					_CNTSNotNegative:
.9c7b	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9c7d	f0 12		beq $9c91			beq 	_CNTSNotFloat
.9c7f	e8		inx				inx 								; round up so we don't get too many 6.999999
.9c80	a9 01		lda #$01			lda 	#1
.9c82	20 34 9e	jsr $9e34			jsr 	NSMSetByte
.9c85	ca		dex				dex
.9c86	b5 78		lda $78,x			lda		NSExponent,x
.9c88	95 79		sta $79,x			sta 	NSExponent+1,x
.9c8a	a9 08		lda #$08			lda 	#NSTFloat
.9c8c	95 51		sta $51,x			sta 	NSStatus+1,x
.9c8e	20 5f 94	jsr $945f			jsr 	FloatAdd
.9c91					_CNTSNotFloat:
.9c91	20 be 9c	jsr $9cbe			jsr 	MakePlusTwoString 			; do the integer part.
.9c94	20 25 95	jsr $9525			jsr 	FloatFractionalPart 		; get the fractional part
.9c97	20 d6 95	jsr $95d6			jsr 	NSNormalise					; normalise , exit if zero
.9c9a	f0 20		beq $9cbc			beq 	_CNTSExit
.9c9c	a9 2e		lda #$2e			lda 	#"."
.9c9e	20 dc 9c	jsr $9cdc			jsr 	WriteDecimalBuffer 			; write decimal place
.9ca1					_CNTSDecimal:
.9ca1	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9ca4	30 16		bmi $9cbc			bmi 	_CNTSExit
.9ca6	e8		inx				inx 								; x 10.0
.9ca7	a9 0a		lda #$0a			lda 	#10
.9ca9	20 34 9e	jsr $9e34			jsr 	NSMSetByte
.9cac	a9 08		lda #$08			lda 	#NSTFloat
.9cae	95 50		sta $50,x			sta 	NSStatus,x
.9cb0	ca		dex				dex
.9cb1	20 a4 95	jsr $95a4			jsr 	FloatMultiply
.9cb4	20 be 9c	jsr $9cbe			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9cb7	20 25 95	jsr $9525			jsr 	FloatFractionalPart 		; get the fractional part
.9cba	80 e5		bra $9ca1			bra 	_CNTSDecimal 				; keep going.
.9cbc					_CNTSExit:
.9cbc	7a		ply				ply
.9cbd	60		rts				rts
.9cbe					MakePlusTwoString:
.9cbe	da		phx				phx
.9cbf	20 15 9e	jsr $9e15			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9cc2	e8		inx				inx 								; access it
.9cc3	e8		inx				inx
.9cc4	20 7d 95	jsr $957d			jsr 	FloatIntegerPart 			; make it an integer
.9cc7	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9cc9	20 8f 93	jsr $938f			jsr 	ConvertInt32
.9ccc	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9cce					_MPTSCopy:
.9cce	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cd1	20 dc 9c	jsr $9cdc			jsr 	WriteDecimalBuffer
.9cd4	e8		inx				inx
.9cd5	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cd8	d0 f4		bne $9cce			bne 	_MPTSCopy
.9cda	fa		plx				plx
.9cdb	60		rts				rts
.9cdc					WriteDecimalBuffer:
.9cdc	da		phx				phx
.9cdd	ae 15 04	ldx $0415			ldx 	dbOffset
.9ce0	9d 49 06	sta $0649,x			sta 	DecimalBuffer,x
.9ce3	9e 4a 06	stz $064a,x			stz 	DecimalBuffer+1,x
.9ce6	ee 15 04	inc $0415			inc 	dbOffset
.9ce9	fa		plx				plx
.9cea	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9ceb					Unary_Left:
.9ceb	fa		plx				plx
.9cec	18		clc				clc 								; only one parameter
.9ced	20 50 9d	jsr $9d50			jsr 	SubstringInitial 			; set up.
.9cf0	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9cf2	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9cf4	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9cf6	80 25		bra $9d1d			bra 	SubstringMain
.9cf8					Unary_Right:
.9cf8	fa		plx				plx
.9cf9	18		clc				clc 								; only one parameter
.9cfa	20 50 9d	jsr $9d50			jsr 	SubstringInitial 			; set up.
.9cfd	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9cff	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d01	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9d03	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d05	b0 02		bcs $9d09			bcs 	_URNotUnderflow
.9d07	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d09					_URNotUnderFlow:
.9d09	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d0b	80 10		bra $9d1d			bra 	SubStringMain
.9d0d					Unary_Mid:
.9d0d	fa		plx				plx
.9d0e	38		sec				sec 								; two parameters
.9d0f	20 50 9d	jsr $9d50			jsr 	SubstringInitial 			; set up.
.9d12	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d14	f0 04		beq $9d1a			beq 	_UMError
.9d16	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d18	80 03		bra $9d1d			bra 	SubStringMain
.9d1a					_UMError:
.9d1a	4c bf 9f	jmp $9fbf			jmp 	ArgumentError
.9d1d					SubStringMain:
.9d1d	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d1f	d5 78		cmp $78,x			cmp 	NSExponent,x
.9d21	b0 27		bcs $9d4a			bcs 	_SSMNull 					; if so, return an empty string.
.9d23	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d25	f0 23		beq $9d4a			beq 	_SSMNull 					; return empty string.
.9d27	18		clc				clc 								; add the offset +1 to the address and
.9d28	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9d2a	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9d2c	85 36		sta $36				sta 	zTemp0
.9d2e	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9d30	69 00		adc #$00			adc 	#0
.9d32	85 37		sta $37				sta 	zTemp0+1
.9d34					_SSMNoCarry:
.9d34	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d36	20 b5 a7	jsr $a7b5			jsr 	StringTempAllocate 			; allocate that many characters
.9d39	5a		phy				phy 								; save Y
.9d3a	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d3c					_SSMCopy:
.9d3c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d3e	f0 08		beq $9d48			beq 	_SSMEString 				; no more to copy
.9d40	20 ee a7	jsr $a7ee			jsr 	StringTempWrite 			; and write it out.
.9d43	c8		iny				iny
.9d44	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9d46	d0 f4		bne $9d3c			bne 	_SSMCopy
.9d48					_SSMEString:
.9d48	7a		ply				ply
.9d49					_SSMExit:
.9d49	60		rts				rts
.9d4a					_SSMNull:
.9d4a	a9 00		lda #$00			lda 	#0
.9d4c	20 b5 a7	jsr $a7b5			jsr 	StringTempAllocate
.9d4f	60		rts				rts
.9d50					SubstringInitial:
.9d50	da		phx				phx 								; save initial stack position
.9d51	08		php				php 								; save carry on stack indicating 2 parameters
.9d52	20 8a 9d	jsr $9d8a			jsr 	EvaluateString 				; get a string
.9d55	5a		phy				phy 								; calculate length to exponent.
.9d56	a0 ff		ldy #$ff			ldy 	#$FF
.9d58					_SIFindLength:
.9d58	c8		iny				iny
.9d59	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d5b	d0 fb		bne $9d58			bne 	_SIFindLength
.9d5d	98		tya				tya
.9d5e	95 78		sta $78,x			sta 	NSExponent,x
.9d60	7a		ply				ply
.9d61	e8		inx				inx
.9d62	20 ff 8e	jsr $8eff			jsr 	CheckComma 					; comma next
.9d65	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; get next parameter
.9d68	28		plp				plp 								; is it the last parameter ?
.9d69	90 07		bcc $9d72			bcc 	_SSIExit 					; if so, exit.
.9d6b	e8		inx				inx
.9d6c	20 ff 8e	jsr $8eff			jsr 	CheckComma 					; comma next
.9d6f	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; get last parameter
.9d72					_SSIExit:
.9d72	fa		plx				plx
.9d73	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket 			; check closing bracket
.9d76	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d77					EvaluateValue:
.9d77	48		pha				pha
.9d78	20 14 94	jsr $9414			jsr		EvaluateExpression 			; expression
.9d7b	20 d7 96	jsr $96d7			jsr 	Dereference					; derefernce it
.9d7e	68		pla				pla
.9d7f	60		rts				rts
.9d80					EvaluateNumber:
.9d80	20 77 9d	jsr $9d77			jsr 	EvaluateValue 				; get a value
.9d83	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d85	29 10		and #$10			and 	#NSBIsString
.9d87	d0 13		bne $9d9c			bne 	HelperTypeError
.9d89	60		rts				rts
.9d8a					EvaluateString:
.9d8a	20 77 9d	jsr $9d77			jsr 	EvaluateValue 				; get a value
.9d8d	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d8f	29 10		and #$10			and 	#NSBIsString
.9d91	f0 09		beq $9d9c			beq 	HelperTypeError
.9d93					CopyAddressToTemp0:
.9d93	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d95	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9d97	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d99	85 37		sta $37				sta 	zTemp0+1
.9d9b	60		rts				rts
.9d9c					HelperTypeError:
.9d9c	4c ba 9f	jmp $9fba			jmp 	TypeError
.9d9f					EvaluateInteger:
.9d9f	20 80 9d	jsr $9d80			jsr 	EvaluateNumber
.9da2	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9da4	d0 09		bne $9daf			bne 	HelperValueError 			; if not, it's a float.
.9da6	60		rts				rts
.9da7					EvaluateUnsignedInteger:
.9da7	20 9f 9d	jsr $9d9f			jsr 	EvaluateInteger 			; check integer is +ve
.9daa	b5 50		lda $50,x			lda 	NSStatus,x
.9dac	30 01		bmi $9daf			bmi 	HelperValueError
.9dae	60		rts				rts
.9daf					HelperValueError:
.9daf	4c bf 9f	jmp $9fbf			jmp 	ArgumentError
.9db2					Evaluate16BitInteger:
.9db2	20 a7 9d	jsr $9da7			jsr	 	EvaluateUnsignedInteger		; get integer
.9db5	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9db7	15 68		ora $68,x			ora 	NSMantissa2,x
.9db9	d0 f4		bne $9daf			bne 	HelperValueError
.9dbb	60		rts				rts
.9dbc					Evaluate16BitIntegerSigned:
.9dbc	20 9f 9d	jsr $9d9f			jsr	 	EvaluateInteger				; get integer
.9dbf	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9dc1	15 68		ora $68,x			ora 	NSMantissa2,x
.9dc3	d0 ea		bne $9daf			bne 	HelperValueError
.9dc5	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9dc7	10 03		bpl $9dcc			bpl 	_EISNotSigned
.9dc9	20 fb 9d	jsr $9dfb			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9dcc					_EISNotSigned:
.9dcc	60		rts				rts
.9dcd					Evaluate8BitInteger:
.9dcd	20 a7 9d	jsr $9da7			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9dd0	d0 dd		bne $9daf			bne 	HelperValueError
.9dd2	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9dd4	15 68		ora $68,x			ora 	NSMantissa2,x
.9dd6	15 60		ora $60,x			ora 	NSMantissa1,x
.9dd8	d0 d5		bne $9daf			bne 	HelperValueError
.9dda	b5 58		lda $58,x			lda 	NSMantissa0,x
.9ddc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9ddd					Multiply8x8:
.9ddd	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dde	85 36		sta $36			  	sta 	zTemp0
.9de0	86 37		stx $37				stx 	zTemp0+1
.9de2	a9 00		lda #$00			lda 	#0
.9de4	a2 08		ldx #$08			ldx 	#8
.9de6					_M88Loop:
.9de6	90 03		bcc $9deb			bcc 	_M88NoAdd
.9de8	18		clc				clc
.9de9	65 37		adc $37				adc 	zTemp0+1
.9deb					_M88NoAdd:
.9deb	6a		ror a				ror 	a
.9dec	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dee	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9def	d0 f5		bne $9de6			bne 	_M88Loop
.9df1	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9df3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9df4					NSMNegate:
.9df4	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9df6	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9df8	95 50		sta $50,x			sta 	NSStatus,x
.9dfa	60		rts				rts
.9dfb					NSMNegateMantissa:
.9dfb	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9dfc	a9 00		lda #$00			lda 	#0
.9dfe	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9e00	95 58		sta $58,x			sta 	NSMantissa0,x
.9e02	a9 00		lda #$00			lda 	#0
.9e04	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9e06	95 60		sta $60,x			sta 	NSMantissa1,x
.9e08	a9 00		lda #$00			lda 	#0
.9e0a	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9e0c	95 68		sta $68,x			sta 	NSMantissa2,x
.9e0e	a9 00		lda #$00			lda 	#0
.9e10	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9e12	95 70		sta $70,x			sta 	NSMantissa3,x
.9e14	60		rts				rts
.9e15					NSMShiftUpTwo:
.9e15	b5 58		lda $58,x			lda 	NSMantissa0,x
.9e17	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9e19	b5 60		lda $60,x			lda 	NSMantissa1,x
.9e1b	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9e1d	b5 68		lda $68,x			lda 	NSMantissa2,x
.9e1f	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9e21	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e23	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9e25	b5 78		lda $78,x			lda 	NSExponent,x
.9e27	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9e29	b5 50		lda $50,x			lda 	NSStatus,x
.9e2b	95 52		sta $52,x			sta 	NSStatus+2,x
.9e2d	60		rts				rts
.9e2e					NSMSetZeroMantissaOnly:
.9e2e	a9 00		lda #$00			lda 	#0
.9e30	80 06		bra $9e38			bra 	NSMSetMantissa
.9e32					NSMSetZero:
.9e32	a9 00		lda #$00			lda 	#0
.9e34					NSMSetByte:
.9e34	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e36	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9e38					NSMSetMantissa:
.9e38	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9e3a	74 60		stz $60,x			stz 	NSMantissa1,x
.9e3c	74 68		stz $68,x			stz 	NSMantissa2,x
.9e3e	74 70		stz $70,x			stz 	NSMantissa3,x
.9e40	60		rts				rts
.9e41					NSMShiftLeft:
.9e41	18		clc				clc
.9e42					NSMRotateLeft:
.9e42	36 58		rol $58,x			rol 	NSMantissa0,x
.9e44	36 60		rol $60,x			rol		NSMantissa1,x
.9e46	36 68		rol $68,x			rol		NSMantissa2,x
.9e48	36 70		rol $70,x			rol		NSMantissa3,x
.9e4a	60		rts				rts
.9e4b					NSMShiftRight:
.9e4b	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9e4d	76 68		ror $68,x			ror		NSMantissa2,x
.9e4f	76 60		ror $60,x			ror		NSMantissa1,x
.9e51	76 58		ror $58,x			ror		NSMantissa0,x
.9e53	60		rts				rts
.9e54					NSMIsZero:
.9e54	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e56	15 68		ora $68,x			ora		NSMantissa2,x
.9e58	15 60		ora $60,x			ora		NSMantissa1,x
.9e5a	15 58		ora $58,x			ora		NSMantissa0,x
.9e5c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9e5d					TickHandler:
.9e5d	5a		phy				phy 								; need to preserve Y
.9e5e	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9e61	7a		ply				ply
.9e62	60		rts				rts
.065b					LastTick:
>065b							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e63					Assemble_ora:
.9e63	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e66	01					.byte $01
.9e67					Assemble_and:
.9e67	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e6a	21					.byte $21
.9e6b					Assemble_eor:
.9e6b	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e6e	41					.byte $41
.9e6f					Assemble_adc:
.9e6f	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e72	61					.byte $61
.9e73					Assemble_sta:
.9e73	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e76	81					.byte $81
.9e77					Assemble_lda:
.9e77	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e7a	a1					.byte $a1
.9e7b					Assemble_cmp:
.9e7b	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e7e	c1					.byte $c1
.9e7f					Assemble_sbc:
.9e7f	20 72 80	jsr $8072		jsr	AssembleGroup1
>9e82	e1					.byte $e1
.9e83					Assemble_asl:
.9e83	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e86	02					.byte $02
>9e87	75					.byte $75
.9e88					Assemble_rol:
.9e88	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e8b	22					.byte $22
>9e8c	75					.byte $75
.9e8d					Assemble_lsr:
.9e8d	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e90	42					.byte $42
>9e91	75					.byte $75
.9e92					Assemble_ror:
.9e92	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e95	62					.byte $62
>9e96	75					.byte $75
.9e97					Assemble_stx:
.9e97	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e9a	82					.byte $82
>9e9b	50					.byte $50
.9e9c					Assemble_ldx:
.9e9c	20 79 80	jsr $8079		jsr	AssembleGroup2
>9e9f	a2					.byte $a2
>9ea0	d0					.byte $d0
.9ea1					Assemble_dec:
.9ea1	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ea4	c2					.byte $c2
>9ea5	55					.byte $55
.9ea6					Assemble_inc:
.9ea6	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ea9	e2					.byte $e2
>9eaa	55					.byte $55
.9eab					Assemble_stz:
.9eab	20 79 80	jsr $8079		jsr	AssembleGroup2
>9eae	60					.byte $60
>9eaf	44					.byte $44
.9eb0					Assemble_bit:
.9eb0	20 79 80	jsr $8079		jsr	AssembleGroup2
>9eb3	20					.byte $20
>9eb4	55					.byte $55
.9eb5					Assemble_sty:
.9eb5	20 79 80	jsr $8079		jsr	AssembleGroup2
>9eb8	80					.byte $80
>9eb9	54					.byte $54
.9eba					Assemble_ldy:
.9eba	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ebd	a0					.byte $a0
>9ebe	d5					.byte $d5
.9ebf					Assemble_cpy:
.9ebf	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ec2	c0					.byte $c0
>9ec3	d4					.byte $d4
.9ec4					Assemble_cpx:
.9ec4	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ec7	e0					.byte $e0
>9ec8	d0					.byte $d0
.9ec9					Assemble_tsb:
.9ec9	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ecc	00					.byte $00
>9ecd	50					.byte $50
.9ece					Assemble_trb:
.9ece	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ed1	10					.byte $10
>9ed2	50					.byte $50
.9ed3					Assemble_jsr:
.9ed3	20 79 80	jsr $8079		jsr	AssembleGroup2
>9ed6	14					.byte $14
>9ed7	10					.byte $10
.9ed8					Assemble_jmp:
.9ed8	20 79 80	jsr $8079		jsr	AssembleGroup2
>9edb	40					.byte $40
>9edc	10					.byte $10
.9edd					Assemble_bpl:
.9edd	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ee0	10					.byte $10
.9ee1					Assemble_bmi:
.9ee1	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ee4	30					.byte $30
.9ee5					Assemble_bvc:
.9ee5	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ee8	50					.byte $50
.9ee9					Assemble_bvs:
.9ee9	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9eec	70					.byte $70
.9eed					Assemble_bcc:
.9eed	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ef0	90					.byte $90
.9ef1					Assemble_bcs:
.9ef1	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ef4	b0					.byte $b0
.9ef5					Assemble_bne:
.9ef5	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9ef8	d0					.byte $d0
.9ef9					Assemble_beq:
.9ef9	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9efc	f0					.byte $f0
.9efd					Assemble_bra:
.9efd	20 ca 80	jsr $80ca		jsr	AssembleGroup3
>9f00	80					.byte $80
.9f01					Assemble_brk:
.9f01	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f04	00					.byte $00
.9f05					Assemble_php:
.9f05	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f08	08					.byte $08
.9f09					Assemble_clc:
.9f09	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f0c	18					.byte $18
.9f0d					Assemble_plp:
.9f0d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f10	28					.byte $28
.9f11					Assemble_sec:
.9f11	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f14	38					.byte $38
.9f15					Assemble_rti:
.9f15	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f18	40					.byte $40
.9f19					Assemble_pha:
.9f19	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f1c	48					.byte $48
.9f1d					Assemble_cli:
.9f1d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f20	58					.byte $58
.9f21					Assemble_phy:
.9f21	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f24	5a					.byte $5a
.9f25					Assemble_rts:
.9f25	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f28	60					.byte $60
.9f29					Assemble_pla:
.9f29	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f2c	68					.byte $68
.9f2d					Assemble_sei:
.9f2d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f30	78					.byte $78
.9f31					Assemble_ply:
.9f31	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f34	7a					.byte $7a
.9f35					Assemble_dey:
.9f35	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f38	88					.byte $88
.9f39					Assemble_txa:
.9f39	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f3c	8a					.byte $8a
.9f3d					Assemble_tya:
.9f3d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f40	98					.byte $98
.9f41					Assemble_txs:
.9f41	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f44	9a					.byte $9a
.9f45					Assemble_tay:
.9f45	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f48	a8					.byte $a8
.9f49					Assemble_tax:
.9f49	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f4c	aa					.byte $aa
.9f4d					Assemble_clv:
.9f4d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f50	b8					.byte $b8
.9f51					Assemble_tsx:
.9f51	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f54	ba					.byte $ba
.9f55					Assemble_iny:
.9f55	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f58	c8					.byte $c8
.9f59					Assemble_dex:
.9f59	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f5c	ca					.byte $ca
.9f5d					Assemble_cld:
.9f5d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f60	d8					.byte $d8
.9f61					Assemble_phx:
.9f61	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f64	da					.byte $da
.9f65					Assemble_stp:
.9f65	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f68	db					.byte $db
.9f69					Assemble_inx:
.9f69	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f6c	e8					.byte $e8
.9f6d					Assemble_nop:
.9f6d	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f70	ea					.byte $ea
.9f71					Assemble_sed:
.9f71	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f74	f8					.byte $f8
.9f75					Assemble_plx:
.9f75	20 fe 80	jsr $80fe		jsr	AssembleGroup4
>9f78	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f79					DecimalScalarTable:
>9f79	66 66 66 66				.dword $66666666 ; 0.1
>9f7d	de					.byte $de
>9f7e	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f82	db					.byte $db
>9f83	4c 37 89 41				.dword $4189374c ; 0.001
>9f87	d8					.byte $d8
>9f88	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f8c	d4					.byte $d4
>9f8d	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f91	d1					.byte $d1
>9f92	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f96	ce					.byte $ce
>9f97	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f9b	ca					.byte $ca
>9f9c	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9fa0	c7					.byte $c7
>9fa1	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9fa5	c4					.byte $c4
>9fa6	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9faa	c0					.byte $c0
>9fab	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9faf	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fb0					SyntaxError:
.9fb0	a9 02		lda #$02		lda	#2
.9fb2	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.9fb5					RangeError:
.9fb5	a9 04		lda #$04		lda	#4
.9fb7	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.9fba					TypeError:
.9fba	a9 05		lda #$05		lda	#5
.9fbc	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.9fbf					ArgumentError:
.9fbf	a9 07		lda #$07		lda	#7
.9fc1	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.9fc4					NotDoneError:
.9fc4	a9 0c		lda #$0c		lda	#12
.9fc6	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.9fc9					ErrorText:
>9fc9	42 72 65 61 6b 00			.text	"Break",0
>9fcf	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fd7	72 72 6f 72 00
>9fdc	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fe4	20 62 79 20 7a 65 72 6f 00
>9fed	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9ff5	61 6e 67 65 00
>9ffa	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a002	6d 61 74 63 68 00
>a008	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a010	65 6d 6f 72 79 00
>a016	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a01e	61 72 67 75 6d 65 6e 74 00
>a027	53 74 6f 70 00				.text	"Stop",0
>a02c	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a034	6f 6f 20 6c 6f 6e 67 00
>a03c	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a044	6e 20 66 61 69 6c 65 64 00
>a04d	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a055	61 74 61 00
>a059	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a061	65 6e 74 65 64 00
>a067	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a06f	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a07b	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a083	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a090	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a098	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a0a5	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0ad	68 6f 75 74 20 57 68 69 6c 65 00
>a0b8	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0c0	68 6f 75 74 20 46 6f 72 00
>a0c9	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0d1	61 63 6b 20 66 75 6c 6c 00
>a0da	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0e2	75 63 74 75 72 65 00
>a0e9	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0f1	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a0fe	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a106	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a114	41 72 72 61 79 20 73 69			.text	"Array size",0
>a11c	7a 65 00
>a11f	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a127	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a12f	52 65 6c 65 61 73 65 20			.text "Release Alpha 10 (02-Dec-22). "
>a137	41 6c 70 68 61 20 31 30 20 28 30 32 2d 44 65 63
>a147	2d 32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a14d					RectangleCommand:
.a14d	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a14f	80 02		bra $a153			bra 	ShapeDrawCmd
.a151					CircleCommand:
.a151	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a153					ShapeDrawCmd:
.a153	20 dd a1	jsr $a1dd			jsr 	RunGraphicsCommand
.a156					ShapeDraw:
.a156	0d 5d 06	ora $065d			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a159	4c d1 a1	jmp $a1d1			jmp 	ExecuteGraphicCommand	 	; and complete
.a15c					SpriteCommand:
.a15c	a2 00		ldx #$00			ldx 	#0
.a15e	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; get image number.
.a161	5a		phy				phy
.a162	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a164	a6 58		ldx $58				ldx 	NSMantissa0
.a166	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a168	b0 0d		bcs $a177			bcs 	_SCRange
.a16a	a0 ff		ldy #$ff			ldy 	#255
.a16c	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a16f	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a171	7a		ply				ply
.a172	20 dd a1	jsr $a1dd			jsr 	RunGraphicsCommand
.a175	80 5a		bra $a1d1			bra 	ExecuteGraphicCommand
.a177					_SCRange:
.a177	4c b5 9f	jmp $9fb5			jmp 	RangeError
.a17a					ImageCommand:
.a17a	a2 00		ldx #$00			ldx 	#0
.a17c	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; get image number.
.a17f	20 dd a1	jsr $a1dd			jsr 	RunGraphicsCommand
.a182					ImageRunDraw:
.a182	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a184	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a187	ad 63 06	lda $0663			lda 	gxDrawScale
.a18a	0a		asl a				asl 	a
.a18b	0a		asl a				asl 	a
.a18c	0a		asl a				asl 	a
.a18d	a8		tay				tay
.a18e	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a190	a6 58		ldx $58				ldx 	NSMantissa0
.a192	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a195	60		rts				rts
.a196					TextCommand:
.a196	a2 00		ldx #$00			ldx 	#0
.a198	20 8a 9d	jsr $9d8a			jsr 	EvaluateString 				; get text
.a19b	20 dd a1	jsr $a1dd			jsr 	RunGraphicsCommand
.a19e					TextRunDraw:
.a19e	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1a0	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1a3	a0 00		ldy #$00			ldy 	#0
.a1a5					_IRDLoop:
.a1a5	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a1a7	85 37		sta $37				sta 	zTemp0+1
.a1a9	a5 58		lda $58				lda 	NSMantissa0
.a1ab	85 36		sta $36				sta 	zTemp0
.a1ad	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1af	f0 13		beq $a1c4			beq 	_IRDExit
.a1b1	5a		phy				phy									; save string pos
.a1b2	48		pha				pha 								; save char
.a1b3	ad 63 06	lda $0663			lda 	gxDrawScale 				; get scale
.a1b6	0a		asl a				asl 	a
.a1b7	0a		asl a				asl 	a
.a1b8	0a		asl a				asl 	a
.a1b9	a8		tay				tay
.a1ba	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1bc	fa		plx				plx 								; char to draw
.a1bd	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1c0	7a		ply				ply 								; restore string pos
.a1c1	c8		iny				iny
.a1c2	90 e1		bcc $a1a5			bcc 	_IRDLoop 					; go back if no error.
.a1c4					_IRDExit:
.a1c4	60		rts				rts
.a1c5					PlotCommand:
.a1c5	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1c7	20 dd a1	jsr $a1dd			jsr 	RunGraphicsCommand
.a1ca	80 05		bra $a1d1			bra 	ExecuteGraphicCommand
.a1cc					LineCommand:
.a1cc	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1ce	20 dd a1	jsr $a1dd			jsr 	RunGraphicsCommand
.a1d1					ExecuteGraphicCommand:
.a1d1	0d 5c 06	ora $065c			ora 	gxCommandID 				; make a full command
.a1d4	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a1d7	b0 01		bcs $a1da			bcs 	_EGCError
.a1d9	60		rts				rts
.a1da					_EGCError:
.a1da	4c b0 9f	jmp $9fb0			jmp 	SyntaxError
.a1dd					RunGraphicsCommand:
.a1dd	8d 5c 06	sta $065c			sta 	gxCommandID					; save TODO graphics command.
.a1e0	68		pla				pla 								; pop handler address
.a1e1	fa		plx				plx
.a1e2	1a		inc a				inc 	a
.a1e3	d0 01		bne $a1e6			bne 	_RGINoCarry
.a1e5	e8		inx				inx
.a1e6					_RGINoCarry:
.a1e6	8d 61 06	sta $0661			sta 	GXHandler
.a1e9	8e 62 06	stx $0662			stx 	GXHandler+1
.a1ec					_RGICommandLoop:
.a1ec	b1 30		lda ($30),y			lda 	(codePtr),y
.a1ee	c8		iny				iny
.a1ef	c9 d2		cmp #$d2			cmp 	#KWD_TO						; is it TO x,y
.a1f1	f0 53		beq $a246			beq 	_RGI_To
.a1f3	c9 bd		cmp #$bd			cmp 	#KWD_HERE 					; do it here.
.a1f5	f0 55		beq $a24c			beq 	_RGI_Here
.a1f7	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a1f9	f0 3d		beq $a238			beq 	_RGI_Exit
.a1fb	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a1fd	f0 39		beq $a238			beq 	_RGI_Exit
.a1ff	c9 c5		cmp #$c5			cmp 	#KWD_OUTLINE 				; solid or outline
.a201	f0 3e		beq $a241			beq 	_RGI_Frame
.a203	c9 ce		cmp #$ce			cmp 	#KWD_SOLID
.a205	f0 33		beq $a23a			beq 	_RGI_Solid
.a207	c9 ad		cmp #$ad			cmp 	#KWD_BY 					; by offset
.a209	f0 4b		beq $a256			beq 	_RGI_By
.a20b	c9 b9		cmp #$b9			cmp 	#KWD_FROM 					; from
.a20d	f0 17		beq $a226			beq 	_RGI_Move2
.a20f	c9 b5		cmp #$b5			cmp 	#KWD_DIM 					; dim (set scale)
.a211	f0 62		beq $a275			beq 	_RGI_Dim
.a213	c9 b3		cmp #$b3			cmp 	#KWD_COLOUR 				; colour or Color
.a215	f0 74		beq $a28b			beq 	_RGI_Colour
.a217	c9 b2		cmp #$b2			cmp 	#KWD_COLOR
.a219	f0 70		beq $a28b			beq 	_RGI_Colour
.a21b	ae 5c 06	ldx $065c			ldx 	gxCommandID
.a21e	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a220	d0 03		bne $a225			bne 	_RGI_Move 					; move
.a222	4c b3 a2	jmp $a2b3			jmp		_RGI_SpriteInstructions
.a225					_RGI_Move:
.a225	88		dey				dey 								; unpick get.
.a226					_RGI_Move2:
.a226	20 d9 a2	jsr $a2d9			jsr 	GCGetCoordinatePair 		; move to here
.a229	20 00 a3	jsr $a300			jsr 	GCCopyPairToStore 			; save
.a22c	5a		phy				phy
.a22d	20 f6 a2	jsr $a2f6			jsr 	GCLoadAXY 					; load in
.a230	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a232	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a235	7a		ply				ply
.a236	80 b4		bra $a1ec			bra 	_RGICommandLoop 			; and go round
.a238					_RGI_Exit:
.a238	88		dey				dey 								; unpick : / EOL
.a239	60		rts				rts
.a23a					_RGI_Solid:
.a23a	a9 02		lda #$02			lda 	#2
.a23c	8d 5d 06	sta $065d			sta 	gxFillSolid
.a23f	80 ab		bra $a1ec			bra 	_RGICommandLoop
.a241					_RGI_Frame:
.a241	9c 5d 06	stz $065d			stz 	gxFillSolid
.a244	80 a6		bra $a1ec			bra 	_RGICommandLoop
.a246					_RGI_To:
.a246	20 d9 a2	jsr $a2d9			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a249	20 00 a3	jsr $a300			jsr 	GCCopyPairToStore
.a24c					_RGI_Here:
.a24c	5a		phy				phy
.a24d	20 f6 a2	jsr $a2f6			jsr 	GCLoadAXY 					; load it into AXY
.a250	20 b0 a2	jsr $a2b0			jsr 	_RGICallHandler 			; go do whatever it is.
.a253	7a		ply				ply
.a254	80 96		bra $a1ec			bra 	_RGICommandLoop 			; and go round
.a256					_RGI_By:
.a256	20 e6 a2	jsr $a2e6			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a259	18		clc				clc
.a25a	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a25c	6d 5e 06	adc $065e			adc 	gxxPos
.a25f	8d 5e 06	sta $065e			sta 	gxXPos
.a262	a5 61		lda $61				lda 	NSMantissa1+1
.a264	6d 5f 06	adc $065f			adc 	gxxPos+1
.a267	8d 5f 06	sta $065f			sta 	gxXPos+1
.a26a	a5 5a		lda $5a				lda 	NSMantissa0+2
.a26c	18		clc				clc
.a26d	6d 60 06	adc $0660			adc 	gxYPos
.a270	8d 60 06	sta $0660			sta 	gxYPos
.a273	80 d7		bra $a24c			bra 	_RGI_Here
.a275					_RGI_Dim:
.a275	a2 01		ldx #$01			ldx	 	#1
.a277	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger
.a27a	a5 59		lda $59				lda 	NSMantissa0+1
.a27c	c9 00		cmp #$00			cmp 	#0
.a27e	f0 2d		beq $a2ad			beq 	_RGIRange
.a280	c9 09		cmp #$09			cmp 	#8+1
.a282	b0 29		bcs $a2ad			bcs		_RGIRange
.a284	3a		dec a				dec 	a
.a285	8d 63 06	sta $0663			sta 	gxDrawScale
.a288	4c ec a1	jmp $a1ec			jmp 	_RGICommandLoop
.a28b					_RGI_Colour:
.a28b	a2 01		ldx #$01			ldx 	#1 							; colour
.a28d	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger
.a290	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a292	20 32 9e	jsr $9e32			jsr 	NSMSetZero
.a295	b1 30		lda ($30),y			lda 	(codePtr),y
.a297	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a299	d0 04		bne $a29f			bne 	_RGICDefaultMode
.a29b	c8		iny				iny
.a29c	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger
.a29f					_RGICDefaultMode:
.a29f	5a		phy				phy
.a2a0	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2a2	a6 59		ldx $59				ldx 	NSMantissa0+1
.a2a4	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2a6	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2a9	7a		ply				ply
.a2aa	4c ec a1	jmp $a1ec			jmp 	_RGICommandLoop 			; and go round
.a2ad					_RGIRange:
.a2ad	4c b5 9f	jmp $9fb5			jmp 	RangeError
.a2b0					_RGICallHandler:
.a2b0	6c 61 06	jmp ($0661)			jmp 	(GXHandler)
.a2b3					_RGI_SpriteInstructions:
.a2b3	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a2b5	f0 07		beq $a2be			beq 	_RGISpriteOff
.a2b7	c9 be		cmp #$be			cmp 	#KWD_IMAGE
.a2b9	f0 13		beq $a2ce			beq 	_RGISetImage
.a2bb	4c 25 a2	jmp $a225			jmp 	_RGI_Move
.a2be					_RGISpriteOff:
.a2be	5a		phy				phy
.a2bf	a0 01		ldy #$01			ldy 	#1
.a2c1	a2 00		ldx #$00			ldx 	#0
.a2c3					_RGIDoCommandLoop:
.a2c3	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2c5	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2c8	7a		ply				ply
.a2c9	b0 e2		bcs $a2ad			bcs 	_RGIRange
.a2cb	4c ec a1	jmp $a1ec			jmp 	_RGICommandLoop
.a2ce					_RGISetImage:
.a2ce	a2 01		ldx #$01			ldx 	#1
.a2d0	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger
.a2d3	5a		phy				phy
.a2d4	aa		tax				tax
.a2d5	a0 00		ldy #$00			ldy 	#0
.a2d7	80 ea		bra $a2c3			bra 	_RGIDoCommandLoop
.a2d9					GCGetCoordinatePair:
.a2d9	a2 01		ldx #$01			ldx 	#1
.a2db	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger
.a2de	20 ff 8e	jsr $8eff			jsr 	CheckComma
.a2e1	e8		inx				inx
.a2e2	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger
.a2e5	60		rts				rts
.a2e6					GCSignedCoordinatePair:
.a2e6	a2 01		ldx #$01			ldx 	#1
.a2e8	20 bc 9d	jsr $9dbc			jsr 	Evaluate16BitIntegerSigned
.a2eb	20 ff 8e	jsr $8eff			jsr 	CheckComma
.a2ee	e8		inx				inx
.a2ef	20 bc 9d	jsr $9dbc			jsr 	Evaluate16BitIntegerSigned
.a2f2	60		rts				rts
.a2f3					_GCCPRange:
.a2f3	4c b5 9f	jmp $9fb5			jmp 	RangeError
.a2f6					GCLoadAXY:
.a2f6	ad 5f 06	lda $065f			lda 	gxXPos+1
.a2f9	ae 5e 06	ldx $065e			ldx 	gxXPos
.a2fc	ac 60 06	ldy $0660			ldy 	gxYPos
.a2ff	60		rts				rts
.a300					GCCopyPairToStore:
.a300	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a302	8d 5e 06	sta $065e			sta 	gxXPos
.a305	a5 61		lda $61				lda 	NSMantissa1+1
.a307	8d 5f 06	sta $065f			sta 	gxXPos+1
.a30a	a5 5a		lda $5a				lda 	NSMantissa0+2
.a30c	8d 60 06	sta $0660			sta 	gxYPos
.a30f	60		rts				rts
.065c					gxCommandID:
>065c							.fill 	1
.065d					gxFillSolid:
>065d							.fill 	1
.065e					gxXPos:
>065e							.fill 	2
.0660					gxYPos:
>0660							.fill 	1
.0661					gxHandler:
>0661							.fill 	2
.0663					gxDrawScale:
>0663							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a310					BitmapCtrl:
.a310	b1 30		lda ($30),y			lda 	(codePtr),y
.a312	c8		iny				iny
.a313	a2 01		ldx #$01			ldx 	#1
.a315	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a317	f0 11		beq $a32a			beq 	BitmapSwitch
.a319	ca		dex				dex
.a31a	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a31c	f0 0c		beq $a32a			beq 	BitmapSwitch
.a31e	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; get the colour
.a321	5a		phy				phy
.a322	aa		tax				tax
.a323	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a325	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a328	7a		ply				ply
.a329	60		rts				rts
.a32a					BitmapSwitch:
.a32a	5a		phy				phy
.a32b	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a32d	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a32f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a332	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a334	a0 00		ldy #$00			ldy 	#0
.a336	a2 ff		ldx #$ff			ldx 	#$FF
.a338	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a33b	9c 5d 06	stz $065d			stz 	gxFillSolid
.a33e	9c 5e 06	stz $065e			stz 	gxXPos
.a341	9c 5f 06	stz $065f			stz 	gxXPos+1
.a344	9c 60 06	stz $0660			stz 	gxYPos
.a347	9c 63 06	stz $0663			stz 	gxDrawScale
.a34a	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a34c	a2 00		ldx #$00			ldx 	#0
.a34e	a0 00		ldy #$00			ldy 	#0
.a350	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a353	7a		ply				ply
.a354	60		rts				rts
.a355					SpritesCtrl:
.a355	b1 30		lda ($30),y			lda 	(codePtr),y
.a357	c8		iny				iny
.a358	a2 01		ldx #$01			ldx 	#1
.a35a	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a35c	f0 08		beq $a366			beq 	SpriteSwitch
.a35e	ca		dex				dex
.a35f	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a361	f0 03		beq $a366			beq 	SpriteSwitch
.a363	4c b0 9f	jmp $9fb0			jmp 	SyntaxError
.a366					SpriteSwitch:
.a366	5a		phy				phy
.a367	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a369	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a36b	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a36e	7a		ply				ply
.a36f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a370					GfxCommand:
.a370	a2 00		ldx #$00			ldx 	#0
.a372	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; command
.a375	20 ff 8e	jsr $8eff			jsr 	CheckComma
.a378	e8		inx				inx
.a379	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger 		; X
.a37c	20 ff 8e	jsr $8eff			jsr 	CheckComma
.a37f	e8		inx				inx
.a380	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; Y
.a383	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a385	4a		lsr a				lsr 	a
.a386	d0 12		bne $a39a			bne 	_GfxError
.a388	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a38a	b0 0e		bcs $a39a			bcs 	_GfxError 					; bit 7 should have been zero
.a38c	5a		phy				phy 								; save pos
.a38d	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a38f	a6 59		ldx $59				ldx 	NSMantissa0+1
.a391	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a393	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a396	b0 02		bcs $a39a			bcs 	_GfxError
.a398	7a		ply				ply 								; restore pos and exit.
.a399	60		rts				rts
.a39a					_GfxError:
.a39a	4c b5 9f	jmp $9fb5			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a39d					UnaryHit:
.a39d	fa		plx				plx
.a39e	a9 36		lda #$36			lda 	#zTemp0
.a3a0	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3a3	20 ff 8e	jsr $8eff			jsr 	CheckComma
.a3a6	e8		inx				inx
.a3a7	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3aa	20 f7 8e	jsr $8ef7			jsr		CheckRightBracket
.a3ad	ca		dex				dex 								; fix back up again.
.a3ae	da		phx				phx 								; save X/Y
.a3af	5a		phy				phy
.a3b0	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3b2	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3b4	aa		tax				tax
.a3b5	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3b7	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a3ba	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3bb	7a		ply				ply 								; restore XY
.a3bc	fa		plx				plx
.a3bd	20 34 9e	jsr $9e34			jsr 	NSMSetByte 					; return the hit result
.a3c0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3c1					PaletteCommand:
.a3c1	a2 00		ldx #$00			ldx 	#0
.a3c3	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; colour
.a3c6	20 ff 8e	jsr $8eff			jsr 	CheckComma
.a3c9	e8		inx				inx
.a3ca	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger 		; r
.a3cd	20 ff 8e	jsr $8eff			jsr 	CheckComma
.a3d0	e8		inx				inx
.a3d1	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; g
.a3d4	20 ff 8e	jsr $8eff			jsr 	CheckComma
.a3d7	e8		inx				inx
.a3d8	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; b
.a3db	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a3dd	85 36		sta $36				sta 	zTemp0
.a3df	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a3e1	85 37		sta $37				sta 	zTemp0+1
.a3e3	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a3e5	26 37		rol $37				rol	 	zTemp0+1
.a3e7	06 36		asl $36				asl 	zTemp0
.a3e9	26 37		rol $37				rol	 	zTemp0+1
.a3eb	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a3ed	85 01		sta $01				sta 	1
.a3ef	5a		phy				phy
.a3f0	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a3f2	92 36		sta ($36)			sta 	(zTemp0)
.a3f4	a0 01		ldy #$01			ldy 	#1
.a3f6	a5 5a		lda $5a				lda 	NSMantissa0+2
.a3f8	91 36		sta ($36),y			sta 	(zTemp0),y
.a3fa	a5 59		lda $59				lda 	NSMantissa0+1
.a3fc	c8		iny				iny
.a3fd	91 36		sta ($36),y			sta 	(zTemp0),y
.a3ff	7a		ply				ply
.a400	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a401					UnaryEvent:
.a401	fa		plx				plx
.a402	20 af a4	jsr $a4af			jsr 	TimerToStackX 				; timer in +0
.a405	e8		inx				inx  								; put reference into +1
.a406	20 5e 98	jsr $985e			jsr 	EvaluateTerm
.a409	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a40b	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a40d	d0 4c		bne $a45b			bne 	_UEType
.a40f	e8		inx				inx 								; put the step in +2
.a410	20 ff 8e	jsr $8eff			jsr 	CheckComma
.a413	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger
.a416	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.a419	ca		dex				dex
.a41a	ca		dex				dex
.a41b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a41d	85 36		sta $36				sta 	zTemp0
.a41f	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a421	85 37		sta $37				sta 	zTemp0+1
.a423	5a		phy				phy
.a424	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a426	b1 36		lda ($36),y			lda 	(zTemp0),y
.a428	30 2d		bmi $a457			bmi 	_UEFalse 					; exit if signed.
.a42a	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a42c	b5 58		lda $58,x			lda 	NSMantissa0,x
.a42e	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a430	c8		iny				iny
.a431	b5 60		lda $60,x			lda 	NSMantissa1,x
.a433	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a435	c8		iny				iny
.a436	b5 68		lda $68,x			lda 	NSMantissa2,x
.a438	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a43a	90 1b		bcc $a457			bcc 	_UEFalse 					; no, return FALSE.
.a43c	18		clc				clc
.a43d	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a43f	b5 58		lda $58,x			lda 	NSMantissa0,x
.a441	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a443	91 36		sta ($36),y			sta 	(zTemp0),y
.a445	c8		iny				iny
.a446	b5 60		lda $60,x			lda 	NSMantissa1,x
.a448	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a44a	91 36		sta ($36),y			sta 	(zTemp0),y
.a44c	c8		iny				iny
.a44d	b5 68		lda $68,x			lda 	NSMantissa2,x
.a44f	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a451	91 36		sta ($36),y			sta 	(zTemp0),y
.a453	7a		ply				ply
.a454	4c 7d 8f	jmp $8f7d			jmp 	ReturnTrue
.a457					_UEFalse:
.a457	7a		ply				ply 								; restore Y
.a458	4c 88 8f	jmp $8f88			jmp 	ReturnFalse 				; and return False
.a45b					_UEType:
.a45b	4c ba 9f	jmp $9fba			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a45e					UnaryJoyX:
.a45e	18		clc				clc
.a45f	80 01		bra $a462			bra 	JoyMain
.a461					UnaryJoyY:
.a461	38		sec				sec
.a462					JoyMain:
.a462	fa		plx				plx 								; get pos
.a463	08		php				php 								; save carry (set for Y)
.a464	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a467	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.a46a	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a46d	28		plp				plp
.a46e	90 02		bcc $a472			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a470	4a		lsr a				lsr 	a
.a471	4a		lsr a				lsr 	a
.a472					_JMNoShift:
.a472	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a473	b0 0a		bcs $a47f			bcs 	_JMIsRight
.a475	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a476	b0 04		bcs $a47c			bcs 	_JMIsLeft
.a478	20 32 9e	jsr $9e32			jsr 	NSMSetZero 					; zero result
.a47b	60		rts				rts
.a47c					_JMIsLeft:
.a47c	4c 7d 8f	jmp $8f7d			jmp 	ReturnTrue
.a47f					_JMIsRight:
.a47f	a9 01		lda #$01			lda 	#1
.a481	20 34 9e	jsr $9e34			jsr 	NSMSetByte
.a484	60		rts				rts
.a485					UnaryJoyB:
.a485	fa		plx				plx 								; get pos
.a486	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a489	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.a48c	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a48f	4a		lsr a				lsr 	a
.a490	4a		lsr a				lsr 	a
.a491	4a		lsr a				lsr 	a
.a492	4a		lsr a				lsr 	a
.a493	29 01		and #$01			and 	#1
.a495	20 34 9e	jsr $9e34			jsr 	NSMSetByte
.a498	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a499					LoadCommand:
.a499	20 e0 89	jsr $89e0			jsr 	NewProgram
.a49c	20 e1 82	jsr $82e1			jsr 	BackLoadProgram
.a49f	4c 8e 83	jmp $838e			jmp 	WarmStart
.a4a2					GoCommand:
.a4a2	20 e0 89	jsr $89e0			jsr 	NewProgram
.a4a5	20 e1 82	jsr $82e1			jsr 	BackLoadProgram
.a4a8	4c 21 8b	jmp $8b21			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4ab					UnaryTimer:
.a4ab	fa		plx				plx
.a4ac	20 f7 8e	jsr $8ef7			jsr 	CheckRightBracket
.a4af					TimerToStackX:
.a4af	20 32 9e	jsr $9e32			jsr 	NSMSetZero 					; zero result
.a4b2	64 01		stz $01				stz 	1 							; access I/O
.a4b4	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4b7	95 58		sta $58,x			sta 	NSMantissa0,x
.a4b9	ad 5a d6	lda $d65a			lda 	$D65A
.a4bc	95 60		sta $60,x			sta 	NSMantissa1,x
.a4be	ad 5b d6	lda $d65b			lda 	$D65B
.a4c1	95 68		sta $68,x			sta 	NSMantissa2,x
.a4c3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4c4					MemoryDeleteLine:
.a4c4	20 e3 a4	jsr $a4e3			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4c7	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4c9	a8		tay				tay
.a4ca					_MDDLLoop:
.a4ca	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4cc	92 30		sta ($30)			sta 	(codePtr)
.a4ce	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4d0	c5 3a		cmp $3a				cmp 	zTemp2
.a4d2	d0 07		bne $a4db			bne 	_MDLDLNext
.a4d4	a5 31		lda $31				lda 	codePtr+1
.a4d6	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4d8	d0 01		bne $a4db			bne 	_MDLDLNext
.a4da					_MDDLExit:
.a4da	60		rts				rts
.a4db					_MDLDLNext:
.a4db	e6 30		inc $30				inc 	codePtr						; next byte
.a4dd	d0 eb		bne $a4ca			bne 	_MDDLLoop
.a4df	e6 31		inc $31				inc 	codePtr+1
.a4e1	80 e7		bra $a4ca			bra 	_MDDLLoop
.a4e3					IMemoryFindEnd:
.a4e3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4e5	85 3a		sta $3a				sta 	0+zTemp2
.a4e7	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4e9	85 3b		sta $3b				sta 	1+zTemp2
.a4eb					_MDLFELoop:
.a4eb	b2 3a		lda ($3a)			lda 	(zTemp2)
.a4ed	f0 0b		beq $a4fa			beq 	_MDLFEExit
.a4ef	18		clc				clc
.a4f0	65 3a		adc $3a				adc 	zTemp2
.a4f2	85 3a		sta $3a				sta 	zTemp2
.a4f4	90 f5		bcc $a4eb			bcc 	_MDLFELoop
.a4f6	e6 3b		inc $3b				inc 	zTemp2+1
.a4f8	80 f1		bra $a4eb			bra 	_MDLFELoop
.a4fa					_MDLFEExit:
.a4fa	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a4fb					MemoryInsertLine:
.a4fb	08		php				php
.a4fc	20 e3 a4	jsr $a4e3			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4ff	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a501	1a		inc a				inc 	a
.a502	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a504	b0 36		bcs $a53c			bcs 	_MDLIError
.a506	28		plp				plp
.a507	90 08		bcc $a511			bcc 	_MDLIFound
.a509	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a50b	85 30		sta $30				sta 	codePtr
.a50d	a5 3b		lda $3b				lda 	zTemp2+1
.a50f	85 31		sta $31				sta 	codePtr+1
.a511					_MDLIFound:
.a511	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a514	a8		tay				tay
.a515					_MDLIInsert:
.a515	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a517	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a519	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a51b	c5 3a		cmp $3a				cmp 	zTemp2
.a51d	d0 06		bne $a525			bne 	_MDLINext
.a51f	a5 31		lda $31				lda 	codePtr+1
.a521	c5 3b		cmp $3b				cmp 	zTemp2+1
.a523	f0 0a		beq $a52f			beq 	_MDLIHaveSpace
.a525					_MDLINext:
.a525	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a527	d0 02		bne $a52b			bne 	_MDLINoBorrow
.a529	c6 3b		dec $3b				dec 	zTemp2+1
.a52b					_MDLINoBorrow:
.a52b	c6 3a		dec $3a				dec 	zTemp2
.a52d	80 e6		bra $a515			bra 	_MDLIInsert
.a52f					_MDLIHaveSpace:
.a52f	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a532	88		dey				dey 								; from offset-1 to 0
.a533					_MDLICopy:
.a533	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a536	91 30		sta ($30),y			sta 	(codePtr),y
.a538	88		dey				dey
.a539	10 f8		bpl $a533			bpl 	_MDLICopy
.a53b	60		rts				rts
.a53c					_MDLIError:
.a53c	a9 06		lda #$06		lda	#6
.a53e	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.a541					MDLAppendLine:
.a541	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a543	85 36		sta $36				sta 	zTemp0
.a545	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a547	85 38		sta $38				sta 	0+zTemp1
.a549	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a54b	85 39		sta $39				sta 	1+zTemp1
.a54d	b2 38		lda ($38)			lda 	(zTemp1)
.a54f	d0 0a		bne $a55b			bne 	_MDLANoInitialise
.a551	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a553	8d 64 06	sta $0664			sta 	0+AppendPointer
.a556	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a558	8d 65 06	sta $0665			sta 	1+AppendPointer
.a55b					_MDLANoInitialise:
.a55b	18		clc				clc
.a55c	ad 64 06	lda $0664			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a55f	85 38		sta $38				sta 	zTemp1
.a561	72 36		adc ($36)			adc 	(zTemp0)
.a563	8d 64 06	sta $0664			sta 	AppendPointer
.a566	ad 65 06	lda $0665			lda 	AppendPointer+1
.a569	85 39		sta $39				sta 	zTemp1+1
.a56b	69 00		adc #$00			adc 	#0
.a56d	8d 65 06	sta $0665			sta 	AppendPointer+1
.a570	a0 00		ldy #$00			ldy 	#0
.a572					_MDLACopy:
.a572	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a574	91 38		sta ($38),y			sta 	(zTemp1),y
.a576	c8		iny				iny
.a577	98		tya				tya
.a578	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a57a	d0 f6		bne $a572			bne 	_MDLACopy
.a57c	a9 00		lda #$00			lda 	#0 							; end of program.
.a57e	91 38		sta ($38),y			sta 	(zTemp1),y
.a580	60		rts				rts
.0664					AppendPointer:
>0664							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a581					MemoryNew:
.a581	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a583	85 30		sta $30				sta 	codePtr
.a585	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a587	85 31		sta $31				sta 	codePtr+1
.a589	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a58b	92 30		sta ($30)			sta 	(codePtr)
.a58d	60		rts				rts
.a58e					MemoryInline:
.a58e	98		tya				tya 								; put address into stack,x
.a58f	18		clc				clc  								; get the offset, add codePtr
.a590	65 30		adc $30				adc 	codePtr
.a592	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a594	a5 31		lda $31				lda 	codePtr+1
.a596	69 00		adc #$00			adc 	#0
.a598	95 60		sta $60,x			sta 	NSMantissa1,x
.a59a	74 68		stz $68,x			stz 	NSMantissa2,x
.a59c	74 70		stz $70,x			stz 	NSMantissa3,x
.a59e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a59f					MemorySearch:
.a59f	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a5a1	86 37		stx $37				stx 	zTemp0+1
.a5a3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a5	85 30		sta $30				sta 	codePtr
.a5a7	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5a9	85 31		sta $31				sta 	codePtr+1
.a5ab					_MTAXLoop:
.a5ab	b2 30		lda ($30)			lda 	(codePtr)
.a5ad	18		clc				clc
.a5ae	f0 21		beq $a5d1			beq 	_MTAXExit 					; reached end, exit with CC.
.a5b0	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5b2	b1 30		lda ($30),y			lda 	(codePtr),y
.a5b4	38		sec				sec
.a5b5	e5 36		sbc $36				sbc 	zTemp0
.a5b7	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5b9	c8		iny				iny 								; do the MSB
.a5ba	b1 30		lda ($30),y			lda 	(codePtr),y
.a5bc	e5 37		sbc $37				sbc 	zTemp0+1
.a5be	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a5c0	f0 0f		beq $a5d1			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a5c2	b0 0d		bcs $a5d1			bcs 	_MTAXExit 					; current < required exit
.a5c4	18		clc				clc
.a5c5	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a5c7	65 30		adc $30				adc 	codePtr
.a5c9	85 30		sta $30				sta 	codePtr
.a5cb	90 02		bcc $a5cf			bcc 	_CREExit
.a5cd	e6 31		inc $31				inc 	codePtr+1 					; carry
.a5cf					_CREExit:
.a5cf	80 da		bra $a5ab			bra 	_MTAXLoop
.a5d1					_MTAXExit:
.a5d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/effects.asm

.a5d2					PingCommand:
.a5d2	5a		phy				phy 								; save pos
.a5d3	a9 01		lda #$01			lda 	#1 						; push channel.
.a5d5	48		pha				pha
.a5d6	a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.a5d8	a2 03		ldx #$03			ldx 	#3 						; length
.a5da	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5dc	80 24		bra $a602			bra 	SoundEffectCommand
.a5de					ZapCommand:
.a5de	5a		phy				phy 								; save pos
.a5df	a9 01		lda #$01			lda 	#1 						; push channel.
.a5e1	48		pha				pha
.a5e2	a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.a5e4	a2 05		ldx #$05			ldx 	#5 						; length
.a5e6	a0 14		ldy #$14			ldy 	#20 						; slide LSB
.a5e8	80 18		bra $a602			bra 	SoundEffectCommand
.a5ea					ShootCommand:
.a5ea	5a		phy				phy 								; save pos
.a5eb	a9 03		lda #$03			lda 	#3 						; push channel.
.a5ed	48		pha				pha
.a5ee	a9 20		lda #$20			lda 	#32 						; pitch LSB
.a5f0	a2 02		ldx #$02			ldx 	#2 						; length
.a5f2	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5f4	80 0c		bra $a602			bra 	SoundEffectCommand
.a5f6					Explode:
.a5f6	5a		phy				phy 								; save pos
.a5f7	a9 03		lda #$03			lda 	#3 						; push channel.
.a5f9	48		pha				pha
.a5fa	a9 50		lda #$50			lda 	#80 						; pitch LSB
.a5fc	a2 05		ldx #$05			ldx 	#5 						; length
.a5fe	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a600	80 00		bra $a602			bra 	SoundEffectCommand
.a602					SoundEffectCommand:
.a602	8d 66 06	sta $0666			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.a605	9c 67 06	stz $0667			stz 	SoundCommandBlock+1
.a608	a9 0f		lda #$0f			lda 	#15
.a60a	8d 68 06	sta $0668			sta 	SoundCommandBlock+2
.a60d	8e 69 06	stx $0669			stx 	SoundCommandBlock+3
.a610	8c 6a 06	sty $066a			sty 	SoundCommandBlock+4
.a613	9c 6b 06	stz $066b			stz 	SoundCommandBlock+5
.a616	68		pla				pla
.a617	09 10		ora #$10			ora 	#$10  						; execute command $11
.a619	a2 66		ldx #$66			ldx 	#(SoundCommandBlock & $FF)
.a61b	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a61d	20 18 80	jsr $8018			jsr 	SNDCommand
.a620	7a		ply				ply
.a621	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a622					UnaryPlaying:
.a622	fa		plx				plx
.a623	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; get channel #
.a626	48		pha				pha
.a627	20 f7 8e	jsr $8ef7			jsr		CheckRightBracket
.a62a	68		pla				pla
.a62b	c9 04		cmp #$04			cmp 	#4
.a62d	b0 0c		bcs $a63b			bcs 	_UPNotPlaying
.a62f	09 20		ora #$20			ora 	#$20 						; query playing ?
.a631	20 18 80	jsr $8018			jsr 	SNDCommand
.a634	c9 00		cmp #$00			cmp 	#0
.a636	f0 03		beq $a63b			beq 	_UPNotPlaying
.a638	4c 7d 8f	jmp $8f7d			jmp 	ReturnTrue
.a63b					_UPNotPlaying:
.a63b	4c 88 8f	jmp $8f88			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a63e					SoundCommand:
.a63e	b1 30		lda ($30),y			lda 	(codePtr),y
.a640	c9 c3		cmp #$c3			cmp 	#KWD_OFF 					; SOUND OFF ?
.a642	d0 09		bne $a64d			bne 	_SNDMain
.a644	c8		iny				iny 								; skip OFF
.a645	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a647	5a		phy				phy
.a648	20 18 80	jsr $8018			jsr 	SNDCommand
.a64b	7a		ply				ply
.a64c	60		rts				rts
.a64d					_SNDMain:
.a64d	a2 00		ldx #$00			ldx 	#0
.a64f	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; channel
.a652	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a654	b0 4b		bcs $a6a1			bcs 	_SndError
.a656	e8		inx				inx 								; do the rest in slot 1.
.a657	20 ff 8e	jsr $8eff			jsr 	CheckComma
.a65a	20 b2 9d	jsr $9db2			jsr 	Evaluate16BitInteger 		; Pitch
.a65d	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a65f	c9 10		cmp #$10			cmp 	#16
.a661	b0 3e		bcs $a6a1			bcs 	_SndError
.a663	8d 67 06	sta $0667			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a666	b5 58		lda $58,x			lda 	NSMantissa0,x
.a668	8d 66 06	sta $0666			sta 	SoundCommandBlock
.a66b	20 ff 8e	jsr $8eff			jsr 	CheckComma
.a66e	20 cd 9d	jsr $9dcd			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a671	8d 69 06	sta $0669			sta 	SoundCommandBlock+3
.a674	a9 0f		lda #$0f			lda 	#15
.a676	8d 68 06	sta $0668			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a679	9c 6a 06	stz $066a			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a67c	9c 6b 06	stz $066b			stz 	SoundCommandBlock+5
.a67f	b1 30		lda ($30),y			lda 	(codePtr),y
.a681	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a683	d0 0e		bne $a693			bne 	_SNDPlay
.a685	c8		iny				iny
.a686	20 bc 9d	jsr $9dbc			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a689	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a68b	8d 6a 06	sta $066a			sta 	SoundCommandBlock+4
.a68e	b5 60		lda $60,x			lda 	NSMantissa1,x
.a690	8d 6b 06	sta $066b			sta 	SoundCommandBlock+5
.a693					_SNDPlay:
.a693	5a		phy				phy
.a694	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a696	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a698	a2 66		ldx #$66			ldx 	#(SoundCommandBlock & $FF)
.a69a	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a69c	20 18 80	jsr $8018			jsr 	SNDCommand
.a69f	7a		ply				ply
.a6a0	60		rts				rts
.a6a1					_SndError:
.a6a1	4c b5 9f	jmp $9fb5			jmp 	RangeError
.0666					SoundCommandBlock:
>0666							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a6a4					StackPushByte:
.a6a4	48		pha				pha 								; save byte on stack
.a6a5	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a6a7	d0 08		bne $a6b1			bne 	_SPBNoBorrow
.a6a9	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a6ab	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a6ad	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6af	90 06		bcc $a6b7			bcc 	_SPBMemory
.a6b1					_SPBNoBorrow:
.a6b1	c6 34		dec $34				dec 	BasicStack
.a6b3	68		pla				pla 								; get back and write
.a6b4	92 34		sta ($34)			sta 	(BasicStack)
.a6b6	60		rts				rts
.a6b7					_SPBMemory:
.a6b7	a9 12		lda #$12		lda	#18
.a6b9	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.a6bc					StackPopByte:
.a6bc	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a6be	e6 34		inc $34				inc 	BasicStack
.a6c0	d0 02		bne $a6c4			bne 	_SPBNoCarry
.a6c2	e6 35		inc $35				inc 	BasicStack+1
.a6c4					_SPBNoCarry:
.a6c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a6c5					StackOpen:
.a6c5	48		pha				pha 								; save frame byte
.a6c6	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a6c8	0a		asl a				asl 	a 							; claim twice this for storage
.a6c9	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a6cb	38		sec				sec 								; so basically subtracting from
.a6cc	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a6ce	85 34		sta $34				sta 	basicStack
.a6d0	b0 09		bcs $a6db			bcs 	_SONoBorrow
>a6d2	db						.byte 	$DB 						; causes a break in the emulator
.a6d3	c6 35		dec $35				dec 	basicStack+1
.a6d5	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a6d7	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6d9	90 04		bcc $a6df			bcc 	_SOMemory
.a6db					_SONoBorrow:
.a6db	68		pla				pla 								; get marker back and write at TOS
.a6dc	92 34		sta ($34)			sta 	(basicStack)
.a6de	60		rts				rts
.a6df					_SOMemory:
.a6df	a9 12		lda #$12		lda	#18
.a6e1	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.a6e4					StackClose:
.a6e4	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6e6	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6e8	0a		asl a				asl 	a 							; claim twice this.
.a6e9	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6eb	85 34		sta $34				sta 	basicStack
.a6ed	90 02		bcc $a6f1			bcc 	_SCExit
.a6ef	e6 35		inc $35				inc 	basicStack+1
.a6f1					_SCExit:
.a6f1	60		rts				rts
.a6f2					StackCheckFrame:
.a6f2	48		pha				pha
.a6f3					_StackRemoveLocals:
.a6f3	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6f5	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a6f7	b0 05		bcs $a6fe			bcs 	_SCNoLocal
.a6f9	20 8f 89	jsr $898f			jsr 	LocalPopValue 				; restore the local value
.a6fc	80 f5		bra $a6f3			bra 	_StackRemoveLocals 			; gr round again
.a6fe					_SCNoLocal:
.a6fe	68		pla				pla 								; get the frame check.
.a6ff	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a701	29 f0		and #$f0			and 	#$F0 						; check type bits
.a703	d0 01		bne $a706			bne 	_SCFError 					; different, we have structures mixed up
.a705	60		rts				rts
.a706					_SCFError:
.a706	8a		txa				txa 								; report error X
.a707	4c 10 8f	jmp $8f10			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a70a					STKSaveCodePosition:
.a70a	5a		phy				phy
.a70b	98		tya				tya 								; save Y
.a70c	a0 05		ldy #$05			ldy 	#5
.a70e	91 34		sta ($34),y			sta 	(basicStack),y
.a710	88		dey				dey 								; save Code Pointer
.a711					_STKSaveLoop:
.a711	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a714	91 34		sta ($34),y			sta 	(basicStack),y
.a716	88		dey				dey
.a717	d0 f8		bne $a711			bne 	_STKSaveLoop
.a719	7a		ply				ply
.a71a	60		rts				rts
.a71b					STKLoadCodePosition:
.a71b	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a71d					_STKLoadLoop:
.a71d	b1 34		lda ($34),y			lda 	(basicStack),y
.a71f	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a722	c8		iny				iny
.a723	c0 05		cpy #$05			cpy 	#5
.a725	d0 f6		bne $a71d			bne 	_STKLoadLoop
.a727	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a729	a8		tay				tay
.a72a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a72b					StackReset:
.a72b	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a72d	85 34		sta $34				sta 	0+basicStack
.a72f	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a731	85 35		sta $35				sta 	1+basicStack
.a733	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a735	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a737	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a738					StringConcrete:
.a738	5a		phy				phy 								; save position on stack
.a739	20 45 9a	jsr $9a45			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a73c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a73e	85 38		sta $38				sta 	zTemp1
.a740	b5 60		lda $60,x			lda 	NSMantissa1,x
.a742	85 39		sta $39				sta 	zTemp1+1
.a744	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a746					_SALength:
.a746	c8		iny				iny
.a747	b1 38		lda ($38),y			lda 	(zTemp1),y
.a749	d0 fb		bne $a746			bne 	_SALength
.a74b	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a74d	b0 3d		bcs $a78c			bcs 	_SALengthError
.a74f	98		tya				tya 				 				; length of the new string
.a750	18		clc				clc
.a751	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a753	90 02		bcc $a757			bcc 	_SAHaveLength
.a755	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a757					_SAHaveLength:
.a757	48		pha				pha 								; save length.
.a758	38		sec				sec
.a759	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a75b	6d 0e 04	adc $040e			adc 	StringMemory
.a75e	8d 0e 04	sta $040e			sta 	StringMemory
.a761	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a763	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a765	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a767	6d 0f 04	adc $040f			adc 	StringMemory+1
.a76a	8d 0f 04	sta $040f			sta 	StringMemory+1
.a76d	85 3b		sta $3b				sta 	zTemp2+1
.a76f	95 60		sta $60,x			sta 	NSMantissa1,x
.a771	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a772	38		sec				sec
.a773	e9 03		sbc #$03			sbc 	#3
.a775	92 3a		sta ($3a)			sta 	(zTemp2)
.a777	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a779	a0 01		ldy #$01			ldy 	#1
.a77b	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a77d					_SACopyNewString:
.a77d	a0 00		ldy #$00			ldy 	#0
.a77f					_SACopyNSLoop:
.a77f	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a781	c8		iny				iny 								; write two on in string storage
.a782	c8		iny				iny
.a783	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a785	88		dey				dey 								; this makes it one one.
.a786	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a788	d0 f5		bne $a77f			bne 	_SACopyNSLoop
.a78a	7a		ply				ply
.a78b	60		rts				rts
.a78c					_SALengthError:
.a78c	a9 09		lda #$09		lda	#9
.a78e	4c 10 8f	jmp $8f10		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a791					StringSystemInitialise:
.a791	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a793	8d 0e 04	sta $040e			sta 	0+StringMemory
.a796	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a798	8d 0f 04	sta $040f			sta 	1+StringMemory
.a79b	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a79e	60		rts				rts
.a79f					StringSpaceInitialise:
.a79f	20 45 9a	jsr $9a45			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7a2	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a7a4	8d 10 04	sta $0410			sta 	StringInitialised
.a7a7	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a7aa	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a7ad	ad 0f 04	lda $040f			lda 	StringMemory+1
.a7b0	3a		dec a				dec 	a
.a7b1	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7b4	60		rts				rts
.a7b5					StringTempAllocate:
.a7b5	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a7b7	b0 30		bcs $a7e9			bcs 	_STALength
.a7b9	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a7bc	30 05		bmi $a7c3			bmi 	_STAAllocate
.a7be	48		pha				pha 								; save value to subtract.
.a7bf	20 9f a7	jsr $a79f			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a7c2	68		pla				pla 								; restore it
.a7c3					_STAAllocate:
.a7c3	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a7c5	18		clc				clc  								; deliberate allows one more
.a7c6	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a7c9	8d 11 04	sta $0411			sta 	StringTempPointer
.a7cc	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a7ce	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a7d0	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a7d3	69 ff		adc #$ff			adc 	#$FF
.a7d5	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7d8	85 3d		sta $3d				sta 	zsTemp+1
.a7da	95 60		sta $60,x			sta 	NSMantissa1,x
.a7dc	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a7de	74 70		stz $70,x			stz 	NSMantissa3,x
.a7e0	a9 10		lda #$10			lda 	#NSTString
.a7e2	95 50		sta $50,x			sta 	NSStatus,x
.a7e4	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7e6	92 3c		sta ($3c)			sta 	(zsTemp)
.a7e8	60		rts				rts
.a7e9					_STALength:
.a7e9	a9 09		lda #$09		lda	#9
.a7eb	4c 10 8f	jmp $8f10		jmp	ErrorHandler
.a7ee					StringTempWrite:
.a7ee	48		pha				pha
.a7ef	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a7f1	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a7f3	d0 02		bne $a7f7			bne 	_STWNoCarry
.a7f5	e6 3d		inc $3d				inc 	zsTemp+1
.a7f7					_STWNoCarry:
.a7f7	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a7f9	92 3c		sta ($3c)			sta 	(zsTemp)
.a7fb	68		pla				pla
.a7fc	60		rts				rts

;******  Return to file: _basic.asm

.a7fd					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7fd					Export_EXTPrintCharacter:
.a7fd					PAGEDPrintCharacter:
.a7fd	48		pha				pha
.a7fe	da		phx				phx
.a7ff	5a		phy				phy
.a800	a6 01		ldx $01				ldx 	1
.a802	da		phx				phx
.a803	ac 6d 06	ldy $066d			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a806	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a808	30 48		bmi $a852			bmi 	_EXPCColour
.a80a	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a80c	90 4d		bcc $a85b			bcc 	_EXPCControl
.a80e	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a810	86 01		stx $01				stx 	1
.a812	91 40		sta ($40),y			sta 	(EXTAddress),y
.a814	e6 01		inc $01				inc 	1 							; select colour memory
.a816	ad 6e 06	lda $066e			lda 	EXTTextColour
.a819	91 40		sta ($40),y			sta 	(EXTAddress),y
.a81b	c8		iny				iny 								; advance horizontal position
.a81c	8c 6d 06	sty $066d			sty 	EXTColumn
.a81f	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth 				; reached RHS ?
.a822	90 63		bcc $a887			bcc 	_EXPCExit 					; no, then exit.
.a824					_EXPCCRLF:
.a824	ee 6c 06	inc $066c			inc 	EXTRow  					; bump row
.a827	9c 6d 06	stz $066d			stz 	EXTColumn 					; back to column 0
.a82a	ad 6c 06	lda $066c			lda 	EXTRow 						; check if reached the bottom ?
.a82d	cd 70 06	cmp $0670			cmp 	EXTScreenHeight 			; if so, then scroll.
.a830	f0 18		beq $a84a			beq 	_EXPCScroll
.a832	18		clc				clc 								; add width to address.
.a833	a5 40		lda $40				lda 	EXTAddress
.a835	6d 6f 06	adc $066f			adc 	EXTScreenWidth
.a838	85 40		sta $40				sta 	EXTAddress
.a83a	90 4b		bcc $a887			bcc 	_EXPCExit
.a83c	e6 41		inc $41				inc 	EXTAddress+1
.a83e	80 47		bra $a887			bra 	_EXPCExit
.a840					_EXPCLeft:
.a840	ce 6d 06	dec $066d			dec 	EXTColumn
.a843	10 42		bpl $a887			bpl 	_EXPCExit
.a845					_EXPCBegin:
.a845	9c 6d 06	stz $066d			stz 	EXTColumn
.a848	80 3d		bra $a887			bra 	_EXPCExit
.a84a					_EXPCScroll:
.a84a	ce 6c 06	dec $066c			dec 	EXTRow 						; the height-1 th line.
.a84d	20 38 a9	jsr $a938			jsr 	EXTScreenScroll 			; scroll the screen
.a850	80 35		bra $a887			bra 	_EXPCExit
.a852					_EXPCColour:
.a852	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a854	b0 31		bcs $a887			bcs 	_EXPCExit
.a856	20 18 a9	jsr $a918			jsr 	_EXPCHandleColour
.a859	80 2c		bra $a887			bra 	_EXPCExit
.a85b					_EXPCControl:
.a85b	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a85d	b0 28		bcs $a887			bcs 	_EXPCExit
.a85f	0a		asl a				asl 	a 							; double into X
.a860	aa		tax				tax
.a861	7c f6 a8	jmp ($a8f6,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a864					_EXPCUp:
.a864	ad 6c 06	lda $066c			lda 	EXTRow 						; already at top ?
.a867	f0 1e		beq $a887			beq 	_EXPCExit
.a869	ce 6c 06	dec $066c			dec 	EXTRow 						; up one in position/address
.a86c	38		sec				sec
.a86d	a5 40		lda $40				lda 	EXTAddress
.a86f	ed 6f 06	sbc $066f			sbc 	EXTScreenWidth
.a872	85 40		sta $40				sta 	EXTAddress
.a874	b0 11		bcs $a887			bcs 	_EXPCExit
.a876	c6 41		dec $41				dec 	EXTAddress+1
.a878	80 0d		bra $a887			bra 	_EXPCExit
.a87a					_EXPCRight:
.a87a	c8		iny				iny
.a87b	8c 6d 06	sty $066d			sty 	EXTColumn
.a87e	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth
.a881	d0 04		bne $a887			bne 	_EXPCExit
.a883	88		dey				dey
.a884					_EXPCSetColumnY:
.a884	8c 6d 06	sty $066d			sty 	EXTColumn
.a887					_EXPCExit:
.a887	20 8d a9	jsr $a98d			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a88a	68		pla				pla
.a88b	85 01		sta $01				sta 	1
.a88d	7a		ply				ply
.a88e	fa		plx				plx
.a88f	68		pla				pla
.a890	60		rts				rts
.a891					_EXPCClearScreen:
.a891	20 4a a9	jsr $a94a			jsr		EXTClearScreenCode
.a894	80 f1		bra $a887			bra 	_EXPCExit
.a896					_EXPCDown:
.a896	ad 70 06	lda $0670			lda 	EXTScreenHeight 			; at the bottom
.a899	3a		dec a				dec 	a
.a89a	cd 6c 06	cmp $066c			cmp 	EXTRow
.a89d	f0 e8		beq $a887			beq 	_EXPCExit
.a89f	ee 6c 06	inc $066c			inc 	EXTRow 						; down one in position/address
.a8a2	18		clc				clc
.a8a3	a5 40		lda $40				lda 	EXTAddress
.a8a5	6d 6f 06	adc $066f			adc 	EXTScreenWidth
.a8a8	85 40		sta $40				sta 	EXTAddress
.a8aa	90 db		bcc $a887			bcc 	_EXPCExit
.a8ac	e6 41		inc $41				inc 	EXTAddress+1
.a8ae	80 d7		bra $a887			bra 	_EXPCExit
.a8b0					_EXPCTab:
.a8b0	ad 6d 06	lda $066d			lda 	EXTColumn 					; next tab stop
.a8b3	29 f8		and #$f8			and 	#$F8
.a8b5	18		clc				clc
.a8b6	69 08		adc #$08			adc 	#8
.a8b8	8d 6d 06	sta $066d			sta 	EXTColumn
.a8bb	cd 6f 06	cmp $066f			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a8be	90 c7		bcc $a887			bcc 	_EXPCExit
.a8c0	80 10		bra $a8d2			bra 	_EXPCEnd
.a8c2					_EXPCBackSpace:
.a8c2	88		dey				dey
.a8c3	30 c2		bmi $a887			bmi 	_EXPCExit
.a8c5	ce 6d 06	dec $066d			dec 	EXTColumn
.a8c8	a9 02		lda #$02			lda 	#2
.a8ca	85 01		sta $01				sta 	1
.a8cc	a9 20		lda #$20			lda 	#32
.a8ce	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8d0	80 b5		bra $a887			bra 	_EXPCExit
.a8d2					_EXPCEnd:
.a8d2	a9 02		lda #$02			lda 	#2 							; access text screen
.a8d4	85 01		sta $01				sta 	1
.a8d6	ac 6f 06	ldy $066f			ldy 	EXTScreenWidth 				; point to last character
.a8d9	88		dey				dey
.a8da					_EXPCEndSearch:
.a8da	88		dey				dey 								; if past start, move to col 0.
.a8db	30 06		bmi $a8e3			bmi 	_EXPCFound
.a8dd	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a8df	c9 20		cmp #$20			cmp 	#' '
.a8e1	f0 f7		beq $a8da			beq 	_EXPCEndSearch
.a8e3					_EXPCFound:
.a8e3	c8		iny				iny 								; move to following cell.
.a8e4	80 9e		bra $a884			bra 	_EXPCSetColumnY
.a8e6					_EXPCClearEOL:
.a8e6	a9 02		lda #$02			lda 	#2 							; access character RAM
.a8e8	85 01		sta $01				sta 	1
.a8ea	a9 20		lda #$20			lda 	#' ' 						; write space
.a8ec	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8ee	c8		iny				iny
.a8ef	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth 				; until RHS of screen.
.a8f2	90 f2		bcc $a8e6			bcc 	_EXPCClearEOL
.a8f4	80 91		bra $a887			bra 	_EXPCExit
.a8f6					_EXPCActionTable:
>a8f6	87 a8						.word 	_EXPCExit 					; 00
>a8f8	45 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8fa	40 a8						.word 	_EXPCLeft 					; 02 B Left
>a8fc	87 a8						.word 	_EXPCExit 					; 03 <Break>
>a8fe	87 a8						.word 	_EXPCExit 					; 04
>a900	d2 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a902	7a a8						.word 	_EXPCRight 					; 06 F Right
>a904	87 a8						.word 	_EXPCExit 					; 07
>a906	c2 a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a908	b0 a8						.word 	_EXPCTab 					; 09 I Tab
>a90a	87 a8						.word 	_EXPCExit 					; 0A
>a90c	e6 a8						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a90e	91 a8						.word 	_EXPCClearScreen			; 0C L CLS
>a910	24 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a912	96 a8						.word 	_EXPCDown 					; 0E N Down
>a914	87 a8						.word 	_EXPCExit 					; 0F
>a916	64 a8						.word 	_EXPCUp 					; 10 P Up
.a918					_EXPCHandleColour
.a918	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a91a	b0 16		bcs $a932			bcs 	_EXPCBackground
.a91c	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a91d	0a		asl a				asl 	a
.a91e	0a		asl a				asl 	a
.a91f	0a		asl a				asl 	a
.a920	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a922					_EXPCUpdate:
.a922	48		pha				pha 								; save new colour
.a923	8a		txa				txa 								; get mask
.a924	2d 6e 06	and $066e			and 	EXTTextColour 				; mask out old.
.a927	8d 6e 06	sta $066e			sta 	EXTTextColour
.a92a	68		pla				pla 								; or in new colour
.a92b	0d 6e 06	ora $066e			ora 	EXTTextColour
.a92e	8d 6e 06	sta $066e			sta 	EXTTextColour
.a931	60		rts				rts
.a932					_EXPCBackground:
.a932	29 0f		and #$0f			and 	#$0F 						; get the colour
.a934	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a936	80 ea		bra $a922			bra 	_EXPCUpdate
.a938					EXTScreenScroll:
.a938	a9 02		lda #$02			lda 	#2 							; select text page
.a93a	85 01		sta $01				sta 	1
.a93c	a9 20		lda #$20			lda		#32 						; fill with space
.a93e	20 51 aa	jsr $aa51			jsr 	EXTScrollFill
.a941	e6 01		inc $01				inc 	1 							; select colour page
.a943	ad 6e 06	lda $066e			lda 	EXTTextColour
.a946	20 51 aa	jsr $aa51			jsr 	EXTScrollFill
.a949	60		rts				rts
.a94a					EXTClearScreenCode:
.a94a	a9 02		lda #$02			lda 	#2 							; select text page
.a94c	85 01		sta $01				sta 	1
.a94e	a9 20		lda #$20			lda		#32 						; fill with space
.a950	20 5d a9	jsr $a95d			jsr 	_EXTCSFill
.a953	e6 01		inc $01				inc 	1 							; select colour page
.a955	ad 6e 06	lda $066e			lda 	EXTTextColour
.a958	20 5d a9	jsr $a95d			jsr 	_EXTCSFill
.a95b	80 22		bra $a97f			bra 	EXTHomeCursor
.a95d					_EXTCSFill:
.a95d	aa		tax				tax
.a95e	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a960	85 40		sta $40				sta 	EXTAddress
.a962	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a964	85 41		sta $41				sta 	EXTAddress+1
.a966					_EXTCSFill1:
.a966	a0 00		ldy #$00			ldy 	#0
.a968	8a		txa				txa
.a969					_EXTCSFill2:
.a969	91 40		sta ($40),y			sta 	(EXTAddress),y
.a96b	c8		iny				iny
.a96c	d0 fb		bne $a969			bne 	_EXTCSFill2
.a96e	e6 41		inc $41				inc 	EXTAddress+1
.a970	a5 41		lda $41				lda 	EXTAddress+1
.a972	c9 d2		cmp #$d2			cmp 	#$D2
.a974	d0 f0		bne $a966			bne 	_EXTCSFill1
.a976	8a		txa				txa
.a977					_EXTCSFill3:
.a977	91 40		sta ($40),y			sta 	(EXTAddress),y
.a979	c8		iny				iny
.a97a	c0 c0		cpy #$c0			cpy 	#$C0
.a97c	d0 f9		bne $a977			bne 	_EXTCSFill3
.a97e	60		rts				rts
.a97f					EXTHomeCursor:
.a97f	9c 6c 06	stz $066c			stz 	EXTRow 						; reset row & column
.a982	9c 6d 06	stz $066d			stz 	EXTColumn
.a985	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a987	85 40		sta $40				sta 	EXTAddress
.a989	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a98b	85 41		sta $41				sta 	EXTAddress+1
.a98d					EXTSetHardwareCursor:
.a98d	64 01		stz $01				stz 	1 							; I/O Page zero
.a98f	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a991	8d 10 d0	sta $d010			sta 	$D010
.a994	a9 b1		lda #$b1			lda 	#$B1
.a996	8d 12 d0	sta $d012			sta 	$D012
.a999	ad 6d 06	lda $066d			lda 	EXTColumn
.a99c	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a99f	9c 15 d0	stz $d015			stz 	$D015
.a9a2	ad 6c 06	lda $066c			lda 	EXTRow
.a9a5	8d 16 d0	sta $d016			sta 	$D016
.a9a8	9c 17 d0	stz $d017			stz 	$D017
.a9ab	60		rts				rts
.a9ac					Export_EXTInputLine:
.a9ac	48		pha				pha
.a9ad	da		phx				phx
.a9ae	5a		phy				phy
.a9af	a5 01		lda $01				lda 	1 							; save I/O page
.a9b1	48		pha				pha
.a9b2					_EILLoop:
.a9b2	20 cc aa	jsr $aacc			jsr 	PagedInputSingleCharacter
.a9b5	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a9b7	f0 44		beq $a9fd			beq 	_EILExit
.a9b9	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a9bb	f0 2a		beq $a9e7			beq 	_EILDelete
.a9bd	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a9bf	f0 1c		beq $a9dd			beq 	_EILBackspace
.a9c1	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a9c3	90 12		bcc $a9d7			bcc 	_EILPrintLoop
.a9c5	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a9c7	b0 0e		bcs $a9d7			bcs 	_EILPrintLoop
.a9c9	48		pha				pha 								; save character
.a9ca	a9 02		lda #$02			lda 	#2  						; insert a space
.a9cc	85 01		sta $01				sta 	1
.a9ce	20 3f aa	jsr $aa3f			jsr 	EXTILInsert 				; insert in text screen
.a9d1	e6 01		inc $01				inc 	1
.a9d3	20 3f aa	jsr $aa3f			jsr 	EXTILInsert 				; insert in colour screen
.a9d6	68		pla				pla 								; get character back.
.a9d7					_EILPrintLoop:
.a9d7	20 fd a7	jsr $a7fd			jsr 	PagedPrintCharacter
.a9da	80 d6		bra $a9b2			bra 	_EILLoop
.a9dc	60		rts				rts
.a9dd					_EILBackspace:
.a9dd	ad 6d 06	lda $066d			lda 	EXTColumn					; can we backspace ?
.a9e0	f0 d0		beq $a9b2			beq 	_EILLoop
.a9e2	a9 02		lda #$02			lda 	#2 							; move cursor left
.a9e4	20 fd a7	jsr $a7fd			jsr 	PagedPrintCharacter
.a9e7					_EILDelete
.a9e7	a9 02		lda #$02			lda 	#2 							; text block
.a9e9	85 01		sta $01				sta 	1
.a9eb	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a9ed	20 2a aa	jsr $aa2a			jsr 	EXTILDelete
.a9f0	e6 01		inc $01				inc 	1 							; colour block
.a9f2	ac 6d 06	ldy $066d			ldy 	EXTColumn 					; get attribute of last character
.a9f5	88		dey				dey
.a9f6	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9f8	20 2a aa	jsr $aa2a			jsr 	EXTILDelete 				; backspace attribute
.a9fb	80 b5		bra $a9b2			bra 	_EILLoop 					; and go round.
.a9fd					_EILExit:
.a9fd	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a9ff	85 01		sta $01				sta 	1
.aa01	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa03					_EILScrapeLine:
.aa03	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa05	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa08	c8		iny				iny
.aa09	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth
.aa0c	d0 f5		bne $aa03			bne 	_EILScrapeLine
.aa0e					_EILTrimSpaces:
.aa0e	88		dey				dey
.aa0f	f0 08		beq $aa19			beq 	_EILEndTrim
.aa11	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.aa14	c9 20		cmp #$20			cmp 	#' '
.aa16	f0 f6		beq $aa0e			beq 	_EILTrimSpaces
.aa18	c8		iny				iny 								; trim after non space character.
.aa19					_EILEndTrim:
.aa19	a9 00		lda #$00			lda 	#0 							; trim here.
.aa1b	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa1e	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa20	20 fd a7	jsr $a7fd			jsr 	PagedPrintCharacter
.aa23	68		pla				pla 								; reset I/O page
.aa24	85 01		sta $01				sta 	1
.aa26	7a		ply				ply
.aa27	fa		plx				plx
.aa28	68		pla				pla
.aa29	60		rts				rts
.aa2a					EXTILDelete:
.aa2a	48		pha				pha 								; save the new character
.aa2b	ac 6d 06	ldy $066d			ldy 	EXTColumn 					; start copying from here.
.aa2e					_EXTDLoop:
.aa2e	c8		iny				iny 								; copy one byte down.
.aa2f	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa31	88		dey				dey
.aa32	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa34	c8		iny				iny 								; do till end of line.
.aa35	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth
.aa38	90 f4		bcc $aa2e			bcc 	_EXTDLoop
.aa3a	88		dey				dey 	 							; write in last slot.
.aa3b	68		pla				pla
.aa3c	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa3e	60		rts				rts
.aa3f					EXTILInsert:
.aa3f	ac 6f 06	ldy $066f			ldy 	EXTScreenWidth 				; end position
.aa42					_EXTILoop:
.aa42	88		dey				dey 								; back one
.aa43	cc 6d 06	cpy $066d			cpy 	EXTColumn 					; exit if reached insert point.
.aa46	f0 08		beq $aa50			beq 	_EXTIExit
.aa48	88		dey				dey 								; copy one byte up.
.aa49	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa4b	c8		iny				iny
.aa4c	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa4e	80 f2		bra $aa42			bra 	_EXTILoop
.aa50					_EXTIExit:
.aa50	60		rts				rts
.aa51					EXTScrollFill:
.aa51	aa		tax				tax									; save value to fill with
.aa52	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa54	48		pha				pha
.aa55	a5 37		lda $37				lda 	zTemp0+1
.aa57	48		pha				pha
.aa58	a5 38		lda $38				lda 	zTemp1
.aa5a	48		pha				pha
.aa5b	a5 39		lda $39				lda 	zTemp1+1
.aa5d	48		pha				pha
.aa5e	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa60	85 37		sta $37				sta 	zTemp0+1
.aa62	85 39		sta $39				sta 	zTemp1+1
.aa64	64 36		stz $36				stz 	zTemp0
.aa66	ad 6f 06	lda $066f			lda 	EXTScreenWidth
.aa69	85 38		sta $38				sta 	zTemp1
.aa6b	a0 00		ldy #$00			ldy 	#0
.aa6d					_EXSFCopy1:
.aa6d	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa6f	91 36		sta ($36),y			sta 	(zTemp0),y
.aa71	c8		iny				iny
.aa72	d0 f9		bne $aa6d			bne 	_EXSFCopy1
.aa74	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa76	e6 39		inc $39				inc 	zTemp1+1
.aa78	a5 39		lda $39				lda 	zTemp1+1
.aa7a	c9 d3		cmp #$d3			cmp 	#$D3
.aa7c	d0 ef		bne $aa6d			bne 	_EXSFCopy1
.aa7e	ac 6f 06	ldy $066f			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa81	8a		txa				txa
.aa82					_EXSFFill1:
.aa82	88		dey				dey
.aa83	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa85	c0 00		cpy #$00			cpy 	#0
.aa87	10 f9		bpl $aa82			bpl 	_EXSFFill1
.aa89	68		pla				pla
.aa8a	85 39		sta $39				sta 	zTemp1+1
.aa8c	68		pla				pla
.aa8d	85 38		sta $38				sta 	zTemp1
.aa8f	68		pla				pla
.aa90	85 37		sta $37				sta 	zTemp0+1
.aa92	68		pla				pla
.aa93	85 36		sta $36				sta 	zTemp0
.aa95	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.066c					EXTRow:
>066c							.fill 	1
.066d					EXTColumn:
>066d							.fill 	1
.066e					EXTTextColour:
>066e							.fill 	1
.066f					EXTScreenWidth:
>066f							.fill 	1
.0670					EXTScreenHeight:
>0670							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa96					Export_EXTInitialise:
.aa96	64 01		stz $01				stz 	1 							; Access I/O page 0
.aa98	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa9b	9c 08 d0	stz $d008			stz 	$D008
.aa9e	9c 09 d0	stz $d009			stz 	$D009
.aaa1	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aaa3	8d 58 d6	sta $d658			sta 	$D658
.aaa6	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.aaa8	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.aaaa	ad 00 c0	lda $c000			lda 	$C000
.aaad	8d 6e 06	sta $066e			sta 	EXTTextColour
.aab0	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aab2	8d 6f 06	sta $066f			sta 	EXTScreenWidth
.aab5	a9 3c		lda #$3c			lda 	#60
.aab7	8d 70 06	sta $0670			sta 	EXTScreenHeight
.aaba	20 7f a9	jsr $a97f			jsr 	EXTHomeCursor 				; home cursor
.aabd					_EXMoveDown:
.aabd	a9 0d		lda #$0d			lda 	#13
.aabf	20 fd a7	jsr $a7fd			jsr 	PAGEDPrintCharacter
.aac2	ad 6c 06	lda $066c			lda 	EXTRow
.aac5	c9 06		cmp #$06			cmp 	#6
.aac7	d0 f4		bne $aabd			bne 	_EXMoveDown
.aac9	64 01		stz $01				stz 	1
.aacb	60		rts				rts
.aacc					Export_EXTInputSingleCharacter:
.aacc					PagedInputSingleCharacter:
.aacc	da		phx				phx
.aacd	5a		phy				phy
.aace					_EISCWait:
.aace	a5 01		lda $01				lda 	1 							; save I/O 0
.aad0	48		pha				pha
.aad1	64 01		stz $01				stz 	1 							; access I/O Page 0
.aad3	38		sec				sec 								; calculate timer - LastTick
.aad4	ad 59 d6	lda $d659			lda 	$D659
.aad7	aa		tax				tax 								; saving timer in X
.aad8	ed 5b 06	sbc $065b			sbc 	LastTick
.aadb	c9 03		cmp #$03			cmp 	#3
.aadd	90 06		bcc $aae5			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aadf	8e 5b 06	stx $065b			stx 	LastTick 					; update last timer
.aae2	20 ad be	jsr $bead			jsr 	PagedSNDUpdate 							; go do the code.
.aae5					_NoFireTick:
.aae5	68		pla				pla 								; restore I/O 0
.aae6	85 01		sta $01				sta 	1
.aae8	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.aaeb	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.aaed	f0 df		beq $aace			beq 	_EISCWait
.aaef	7a		ply				ply
.aaf0	fa		plx				plx
.aaf1	60		rts				rts
.aaf2					Export_EXTBreakCheck:
.aaf2	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aaf5					Export_EXTReadController:
.aaf5	da		phx				phx
.aaf6	a2 00		ldx #$00			ldx 	#0
.aaf8	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aafa	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aafd	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aaff	f0 04		beq $ab05			beq 	_NoSet1
.ab01	8a		txa				txa
.ab02	09 01		ora #$01			ora 	#1
.ab04	aa		tax				tax
.ab05					_NoSet1:
.ab05	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab07	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab0a	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab0c	f0 04		beq $ab12			beq 	_NoSet1
.ab0e	8a		txa				txa
.ab0f	09 02		ora #$02			ora 	#2
.ab11	aa		tax				tax
.ab12					_NoSet1:
.ab12	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab14	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab17	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab19	f0 04		beq $ab1f			beq 	_NoSet1
.ab1b	8a		txa				txa
.ab1c	09 04		ora #$04			ora 	#4
.ab1e	aa		tax				tax
.ab1f					_NoSet1:
.ab1f	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab21	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab24	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab26	f0 04		beq $ab2c			beq 	_NoSet1
.ab28	8a		txa				txa
.ab29	09 08		ora #$08			ora 	#8
.ab2b	aa		tax				tax
.ab2c					_NoSet1:
.ab2c	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab2e	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab31	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab33	f0 04		beq $ab39			beq 	_NoSet1
.ab35	8a		txa				txa
.ab36	09 10		ora #$10			ora 	#16
.ab38	aa		tax				tax
.ab39					_NoSet1:
.ab39	8a		txa				txa
.ab3a	fa		plx				plx
.ab3b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ab3c					GRVectorTable:
>ab3c	8b ad					.word	GXInitialise             ; $00 Initialise
>ab3e	a5 ad					.word	GXControlBitmap          ; $01 BitmapCtl
>ab40	ed ad					.word	GXControlSprite          ; $02 SpriteCtl
>ab42	3d ad					.word	GXClearBitmap            ; $03 Clear
>ab44	7c af					.word	GXSetColourMode          ; $04 Colour
>ab46	44 b1					.word	GXFontHandler            ; $05 DrawFont
>ab48	8c b1					.word	GXSpriteHandler          ; $06 DrawSprite
>ab4a	fd b1					.word	GXSelect                 ; $07 SpriteUse
>ab4c	26 b2					.word	GXSelectImage            ; $08 SpriteImage
>ab4e	ad b3					.word	GXCollide                ; $09 SpriteCollide
>ab50	ef ab					.word	GRUndefined              ; $0a
>ab52	ef ab					.word	GRUndefined              ; $0b
>ab54	ef ab					.word	GRUndefined              ; $0c
>ab56	ef ab					.word	GRUndefined              ; $0d
>ab58	ef ab					.word	GRUndefined              ; $0e
>ab5a	ef ab					.word	GRUndefined              ; $0f
>ab5c	ef ab					.word	GRUndefined              ; $10
>ab5e	ef ab					.word	GRUndefined              ; $11
>ab60	ef ab					.word	GRUndefined              ; $12
>ab62	ef ab					.word	GRUndefined              ; $13
>ab64	ef ab					.word	GRUndefined              ; $14
>ab66	ef ab					.word	GRUndefined              ; $15
>ab68	ef ab					.word	GRUndefined              ; $16
>ab6a	ef ab					.word	GRUndefined              ; $17
>ab6c	ef ab					.word	GRUndefined              ; $18
>ab6e	ef ab					.word	GRUndefined              ; $19
>ab70	ef ab					.word	GRUndefined              ; $1a
>ab72	ef ab					.word	GRUndefined              ; $1b
>ab74	ef ab					.word	GRUndefined              ; $1c
>ab76	ef ab					.word	GRUndefined              ; $1d
>ab78	ef ab					.word	GRUndefined              ; $1e
>ab7a	ef ab					.word	GRUndefined              ; $1f
>ab7c	ed ab					.word	GXMove                   ; $20 Move
>ab7e	4a ae					.word	GXLine                   ; $21 Line
>ab80	c5 af					.word	GXFrameRectangle         ; $22 FrameRect
>ab82	c2 af					.word	GXFillRectangle          ; $23 FillRect
>ab84	f4 ab					.word	GXFrameCircle            ; $24 FrameCircle
>ab86	f0 ab					.word	GXFillCircle             ; $25 FillCircle
>ab88	ef ab					.word	GRUndefined              ; $26
>ab8a	ef ab					.word	GRUndefined              ; $27
>ab8c	aa af					.word	GXPlotPoint              ; $28 Plot
>ab8e	bc b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$627					gxPixelBuffer = numberBuffer
.0671					gxCurrentX:
>0671							.fill 	2
.0673					gxCurrentY:
>0673							.fill 	2
.0675					gxLastX:
>0675							.fill 	2
.0677					gxLastY:
>0677							.fill 	2
.0679					gxX0:
>0679							.fill 	2
.067b					gxY0:
>067b							.fill 	2
.067d					gxX1:
>067d							.fill 	2
.067f					gxY1:
>067f							.fill 	2
.0681					gxSpritesOn:
>0681							.fill 	1
.0682					gxBitmapsOn:
>0682							.fill 	1
.0683					gxBasePage:
>0683							.fill 	1
.0684					gxSpritePage:
>0684							.fill 	1
.0685					gxHeight:
>0685							.fill 	1
.0686					gxMode:
>0686							.fill 	1
.0687					gxColour:
>0687							.fill 	1
.0688					gxEORValue:
>0688							.fill 	1
.0689					gxANDValue:
>0689							.fill 	1
.068a					gxOriginalLUTValue:
>068a							.fill 	1
.068b					gsOffset:
>068b							.fill 	1
.068c					GSCurrentSpriteID:
>068c							.fill 	1
.068d					GSCurrentSpriteAddr:
>068d							.fill 	2
.068f					GXSpriteOffsetBase:
>068f							.fill 	2
.0691					GXSpriteLow:
>0691							.fill 	64
.06d1					GXSpriteHigh:
>06d1							.fill 	64
.ab90					Export_GXGraphicDraw:
.ab90	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab92	b0 06		bcs $ab9a			bcs 	_GDCoordinate
.ab94	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab96	84 37		sty $37				sty 	gxzTemp0+1
.ab98	80 4b		bra $abe5			bra 	_GDExecuteA 				; and execute
.ab9a					_GDCoordinate:
.ab9a	48		pha				pha 								; save AXY
.ab9b	da		phx				phx
.ab9c	5a		phy				phy
.ab9d	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab9f					_GDCopy1:
.ab9f	bd 71 06	lda $0671,x			lda 	gxCurrentX,x
.aba2	9d 75 06	sta $0675,x			sta 	gxLastX,x
.aba5	ca		dex				dex
.aba6	10 f7		bpl $ab9f			bpl 	_GDCopy1
.aba8	68		pla				pla 								; update Y
.aba9	8d 73 06	sta $0673			sta 	gxCurrentY
.abac	9c 74 06	stz $0674			stz 	gxCurrentY+1
.abaf	68		pla				pla
.abb0	8d 71 06	sta $0671			sta 	gxCurrentX
.abb3	68		pla				pla 								; get A (command+X.1) back
.abb4	48		pha				pha
.abb5	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.abb7	8d 72 06	sta $0672			sta 	gxCurrentX+1
.abba	68		pla				pla 								; get command back
.abbb	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abbd	48		pha				pha 								; push back.
.abbe	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abc0	f0 17		beq $abd9			beq 	_GDCopyToWorkArea
.abc2	ad 72 06	lda $0672			lda 	gxCurrentX+1 				; X < 256 X okay
.abc5	f0 07		beq $abce			beq 	_GDCheckY
.abc7	ad 71 06	lda $0671			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abca	c9 40		cmp #$40			cmp 	#64
.abcc	b0 08		bcs $abd6			bcs 	_GDError1
.abce					_GDCheckY:
.abce	ad 73 06	lda $0673			lda 	gxCurrentY 					; check Y < Height.
.abd1	cd 85 06	cmp $0685			cmp 	gxHeight
.abd4	90 03		bcc $abd9			bcc 	_GDCopyToWorkArea
.abd6					_GDError1:
.abd6	68		pla				pla
.abd7					_GDError2:
.abd7	38		sec				sec
.abd8	60		rts				rts
.abd9					_GDCopyToWorkArea:
.abd9	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abdb					_GDCopy2:
.abdb	bd 71 06	lda $0671,x			lda 	gxCurrentX,x
.abde	9d 79 06	sta $0679,x			sta 	gxX0,x
.abe1	ca		dex				dex
.abe2	10 f7		bpl $abdb			bpl 	_GDCopy2
.abe4	68		pla				pla 								; get command
.abe5					_GDExecuteA:
.abe5	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abe7	b0 ee		bcs $abd7			bcs 	_GDError2
.abe9	aa		tax				tax
.abea	7c 3c ab	jmp ($ab3c,x)			jmp 	(GRVectorTable,x)
.abed					GXMove:
.abed	18		clc				clc
.abee	60		rts				rts
.abef					GRUndefined:
>abef	db						.byte 	$DB 						; causes a break in the emulator
.abf0					GXFillCircle:
.abf0	a9 ff		lda #$ff			lda 	#255
.abf2	80 02		bra $abf6			bra 	GXCircle
.abf4					GXFrameCircle:
.abf4	a9 00		lda #$00			lda 	#0
.abf6					GXCircle:
.abf6	8d 14 07	sta $0714			sta 	gxIsFillMode					; save Fill flag
.abf9	ad 82 06	lda $0682			lda 	gxBitmapsOn
.abfc	f0 26		beq $ac24			beq 	_GXCFail
.abfe	20 54 b4	jsr $b454			jsr 	GXSortXY 					; topleft/bottomright
.ac01	20 2c b3	jsr $b32c			jsr 	GXOpenBitmap 				; start drawing
.ac04	20 f6 ac	jsr $acf6			jsr 	GXCircleSetup 				; set up for drawing
.ac07	9c 15 07	stz $0715			stz 	gxYChanged
.ac0a					_GXCircleDraw:
.ac0a	ad 12 07	lda $0712			lda 	gXCentre					; while x <= y
.ac0d	cd 13 07	cmp $0713			cmp 	gYCentre
.ac10	90 0a		bcc $ac1c			bcc 	_GXCircleContinue
.ac12	d0 03		bne $ac17			bne 	_GXNoLast
.ac14	20 29 ac	jsr $ac29			jsr 	GXPlot1
.ac17					_GXNoLast:
.ac17	20 34 b3	jsr $b334			jsr 	GXCloseBitmap 				; close the bitmap
.ac1a	18		clc				clc
.ac1b	60		rts				rts
.ac1c					_GXCircleContinue:
.ac1c	20 26 ac	jsr $ac26			jsr 	GXPlot2 					; draw it
.ac1f	20 a3 ac	jsr $aca3			jsr 	GXCircleMove 				; adjust the coordinates
.ac22	80 e6		bra $ac0a			bra 	_GXCircleDraw
.ac24					_GXCFail:
.ac24	38		sec				sec
.ac25	60		rts				rts
.ac26					GXPlot2:
.ac26	20 29 ac	jsr $ac29			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac29					GXPlot1:
.ac29	ad 13 07	lda $0713			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac2c	f0 03		beq $ac31			beq 	_GXPlot1Only
.ac2e	20 4d ac	jsr $ac4d			jsr 	GXPlot0 						; plot and negate
.ac31					_GXPlot1Only:
.ac31	20 4d ac	jsr $ac4d			jsr 	GXPlot0 						; twice, undoing negation
.ac34	ad 12 07	lda $0712			lda 	gXCentre 						; swap X and Y
.ac37	ae 13 07	ldx $0713			ldx	 	gYCentre
.ac3a	8d 13 07	sta $0713			sta 	gYCentre
.ac3d	8e 12 07	stx $0712			stx 	gXCentre
.ac40	ad 15 07	lda $0715			lda 	gxYChanged 						; toggle Y Changed flag
.ac43	a9 ff		lda #$ff			lda 	#$FF
.ac45	8d 15 07	sta $0715			sta 	gxYChanged
.ac48	60		rts				rts
.ac49	20 4d ac	jsr $ac4d			jsr 	GXPlot0 						; do once
.ac4c	60		rts				rts
.ac4d	ad 14 07	lda $0714	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac50	f0 05		beq $ac57			beq 	_GXPlot0Always
.ac52	ad 15 07	lda $0715			lda 	gxYChanged						; fill mode, only draw if changed.
.ac55	f0 2d		beq $ac84			beq 	GXPlot0Exit
.ac57					_GXPlot0Always:
.ac57	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac59	ad 13 07	lda $0713			lda 	gYCentre
.ac5c	20 85 ac	jsr $ac85			jsr 	GXSubCopy
.ac5f	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac61	ad 12 07	lda $0712			lda 	gXCentre
.ac64	20 85 ac	jsr $ac85			jsr 	GXSubCopy
.ac67	48		pha				pha 									; save last offset X
.ac68	20 3c b3	jsr $b33c			jsr 	GXPositionCalc 					; calculate position/offset.
.ac6b	68		pla				pla
.ac6c	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac6d	85 36		sta $36				sta 	gxzTemp0
.ac6f	64 37		stz $37				stz 	gxzTemp0+1
.ac71	26 37		rol $37				rol 	gxzTemp0+1
.ac73	ad 14 07	lda $0714			lda 	gxIsFillMode
.ac76	69 80		adc #$80			adc 	#128
.ac78	20 15 b0	jsr $b015			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac7b	38		sec				sec 									; GY = -GY
.ac7c	a9 00		lda #$00			lda 	#0
.ac7e	ed 13 07	sbc $0713			sbc 	gYCentre
.ac81	8d 13 07	sta $0713			sta 	gYCentre
.ac84					GXPlot0Exit:
.ac84	60		rts				rts
.ac85					GXSubCopy:
.ac85	85 36		sta $36				sta 	gxzTemp0
.ac87	64 37		stz $37				stz 	gxzTemp0+1
.ac89	29 80		and #$80			and 	#$80
.ac8b	f0 02		beq $ac8f			beq 	_GXNoSx
.ac8d	c6 37		dec $37				dec 	gxzTemp0+1
.ac8f					_GXNoSx:
.ac8f	38		sec				sec
.ac90	bd 7d 06	lda $067d,x			lda 	gXX1,x
.ac93	e5 36		sbc $36				sbc 	gxzTemp0
.ac95	9d 79 06	sta $0679,x			sta 	gXX0,x
.ac98	bd 7e 06	lda $067e,x			lda 	gXX1+1,x
.ac9b	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac9d	9d 7a 06	sta $067a,x			sta 	gXX0+1,x
.aca0	a5 36		lda $36				lda 	gxzTemp0 						; return A
.aca2	60		rts				rts
.aca3					GXCircleMove:
.aca3	9c 15 07	stz $0715			stz 	gxYChanged 					; clear Y changed flag
.aca6	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.aca8	10 0d		bpl $acb7			bpl 	_GXEMPositive
.acaa	ee 12 07	inc $0712			inc 	gXCentre 					; X++
.acad	ad 12 07	lda $0712			lda 	gXCentre
.acb0	20 d6 ac	jsr $acd6			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acb3	a9 06		lda #$06			lda 	#6  						; and add 6
.acb5	80 15		bra $accc			bra 	_GXEMAddD
.acb7					_GXEMPositive:
.acb7	ee 12 07	inc $0712			inc 	gXCentre					; X++
.acba	ce 13 07	dec $0713			dec 	gyCentre 					; Y--
.acbd	38		sec				sec 								; calculate X-Y
.acbe	ad 12 07	lda $0712			lda 	gXCentre
.acc1	ed 13 07	sbc $0713			sbc 	gYCentre
.acc4	20 d6 ac	jsr $acd6			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acc7	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acc9	ce 15 07	dec $0715			dec 	gxYChanged
.accc					_GXEMAddD:
.accc	18		clc				clc
.accd	65 38		adc $38				adc 	gxzTemp1
.accf	85 38		sta $38				sta 	gxzTemp1
.acd1	90 02		bcc $acd5			bcc 	_GXEMNoCarry
.acd3	e6 39		inc $39				inc 	gxzTemp1+1
.acd5					_GXEMNoCarry:
.acd5	60		rts				rts
.acd6					_GXAdd4TimesToD:
.acd6	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acd8	29 80		and #$80			and 	#$80
.acda	f0 02		beq $acde			beq 	_GXA4Unsigned
.acdc	a9 ff		lda #$ff			lda 	#$FF
.acde					_GXA4Unsigned:
.acde	85 37		sta $37				sta 	gxzTemp0+1
.ace0	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ace2	26 37		rol $37				rol 	gxzTemp0+1
.ace4	06 36		asl $36				asl 	gxzTemp0
.ace6	26 37		rol $37				rol 	gxzTemp0+1
.ace8	18		clc				clc 								; add
.ace9	a5 36		lda $36				lda		gxzTemp0
.aceb	65 38		adc $38				adc 	gxzTemp1
.aced	85 38		sta $38				sta 	gxzTemp1
.acef	a5 37		lda $37				lda		gxzTemp0+1
.acf1	65 39		adc $39				adc 	gxzTemp1+1
.acf3	85 39		sta $39				sta 	gxzTemp1+1
.acf5	60		rts				rts
.acf6					GXCircleSetup:
.acf6	38		sec				sec
.acf7	ad 7f 06	lda $067f			lda 	gxY1
.acfa	ed 7b 06	sbc $067b			sbc 	gxY0
.acfd	4a		lsr a				lsr 	a
.acfe	8d 11 07	sta $0711			sta 	gxRadius
.ad01	a2 00		ldx #$00			ldx 	#0
.ad03	20 25 ad	jsr $ad25			jsr 	_GXCalculateCentre
.ad06	a2 02		ldx #$02			ldx 	#2
.ad08	20 25 ad	jsr $ad25			jsr 	_GXCalculateCentre
.ad0b	9c 12 07	stz $0712			stz 	gXCentre
.ad0e	ad 11 07	lda $0711			lda 	gxRadius
.ad11	8d 13 07	sta $0713			sta 	gYCentre
.ad14	0a		asl a				asl 	a 							; R x 2
.ad15	85 36		sta $36				sta 	gxzTemp0
.ad17	38		sec				sec
.ad18	a9 03		lda #$03			lda 	#3
.ad1a	e5 36		sbc $36				sbc 	gxzTemp0
.ad1c	85 38		sta $38				sta 	gxzTemp1
.ad1e	a9 00		lda #$00			lda 	#0
.ad20	e9 00		sbc #$00			sbc 	#0
.ad22	85 39		sta $39				sta 	gxzTemp1+1
.ad24	60		rts				rts
.ad25					_GXCalculateCentre:
.ad25	38		sec				sec
.ad26	bd 7d 06	lda $067d,x			lda 	gxX1,x
.ad29	7d 79 06	adc $0679,x			adc 	gXX0,x
.ad2c	9d 7d 06	sta $067d,x			sta 	gXX1,x
.ad2f	bd 7e 06	lda $067e,x			lda 	gXX1+1,x
.ad32	7d 7a 06	adc $067a,x			adc 	gXX0+1,x
.ad35	4a		lsr a				lsr 	a
.ad36	9d 7e 06	sta $067e,x			sta 	gXX1+1,x
.ad39	7e 7d 06	ror $067d,x			ror 	gXX1,x
.ad3c	60		rts				rts
.0711					gxRadius:
>0711							.fill 	1
.0712					gXCentre:
>0712							.fill 	1
.0713					gYCentre:
>0713							.fill 	1
.0714					gxIsFillMode:
>0714							.fill 	1
.0715					gxYChanged:
>0715							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad3d					GXClearBitmap:
.ad3d	ad 82 06	lda $0682			lda 	gxBitmapsOn 				; check BMP running.
.ad40	f0 24		beq $ad66			beq 	_GXCBFail
.ad42	20 2c b3	jsr $b32c			jsr 	GXOpenBitmap 				; start access
.ad45	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad47	ad 85 06	lda $0685			lda 	gxHeight
.ad4a	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad4c	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad4e					_GXCalcLastPage:
.ad4e	98		tya				tya 								; add to base page
.ad4f	18		clc				clc
.ad50	6d 83 06	adc $0683			adc 	gxBasePage
.ad53	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad55					_GXClearAll:
.ad55	20 68 ad	jsr $ad68			jsr 	_GXClearBlock 				; clear 8k block
.ad58	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad5a	a5 0b		lda $0b				lda 	GXEditSlot
.ad5c	cd 83 06	cmp $0683			cmp 	gxBasePage 					; until before base page
.ad5f	b0 f4		bcs $ad55			bcs 	_GXClearAll
.ad61	20 34 b3	jsr $b334			jsr 	GXCloseBitmap	 			; stop access
.ad64	18		clc				clc
.ad65	60		rts				rts
.ad66					_GXCBFail:
.ad66	38		sec				sec
.ad67	60		rts				rts
.ad68					_GXClearBlock:
.ad68	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad6a	85 38		sta $38				sta 	0+gxzTemp1
.ad6c	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad6e	85 39		sta $39				sta 	1+gxzTemp1
.ad70					_GXCB0:
.ad70	a5 36		lda $36				lda 	gxzTemp0
.ad72	a0 00		ldy #$00			ldy 	#0
.ad74					_GXCB1:
.ad74	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad76	c8		iny				iny
.ad77	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad79	c8		iny				iny
.ad7a	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad7c	c8		iny				iny
.ad7d	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad7f	c8		iny				iny
.ad80	d0 f2		bne $ad74			bne 	_GXCB1
.ad82	e6 39		inc $39				inc 	gxzTemp1+1
.ad84	a5 39		lda $39				lda 	gxzTemp1+1
.ad86	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad88	d0 e6		bne $ad70			bne 	_GXCB0
.ad8a	60		rts				rts
.ad8b					GXInitialise:
.ad8b	64 01		stz $01				stz 	1
.ad8d	a9 01		lda #$01			lda 	#1
.ad8f	8d 00 d0	sta $d000			sta 	$D000
.ad92	18		clc				clc
.ad93	9c 81 06	stz $0681			stz 	GXSpritesOn
.ad96	9c 82 06	stz $0682			stz 	GXBitmapsOn
.ad99	a2 0f		ldx #$0f			ldx 	#15
.ad9b					_GXIClear:
.ad9b	9e 71 06	stz $0671,x			stz 	gxCurrentX,x
.ad9e	ca		dex				dex
.ad9f	10 fa		bpl $ad9b			bpl 	_GXIClear
.ada1	20 3c ae	jsr $ae3c			jsr 	GXClearSpriteStore
.ada4	60		rts				rts
.ada5					GXControlBitmap:
.ada5	64 01		stz $01				stz 	1
.ada7	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ada9	29 01		and #$01			and 	#1 							; set bitmap flag
.adab	8d 82 06	sta $0682			sta 	gxBitmapsOn
.adae	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adaf	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adb2	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adb4	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.adb6	90 02		bcc $adba			bcc 	_CBNotOn
.adb8	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.adba					_CBNotOn:
.adba	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adbd	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.adbf	29 07		and #$07			and 	#7
.adc1	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adc4	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adc6	d0 02		bne $adca			bne 	_CBNotDefault
.adc8	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adca					_CBNotDefault:
.adca	8d 83 06	sta $0683			sta 	gxBasePage
.adcd	20 2e ae	jsr $ae2e			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.add0	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.add2	8d 03 d1	sta $d103			sta 	$D103
.add5	a5 36		lda $36				lda 	gxzTemp0
.add7	8d 02 d1	sta $d102			sta 	$D102
.adda	9c 01 d1	stz $d101			stz 	$D101
.addd	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.addf	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ade2	29 01		and #$01			and 	#1
.ade4	f0 02		beq $ade8			beq 	_CBHaveHeight
.ade6	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ade8					_CBHaveHeight
.ade8	8e 85 06	stx $0685			stx 	gxHeight
.adeb	18		clc				clc
.adec	60		rts				rts
.aded					GXControlSprite:
.aded	64 01		stz $01				stz 	1
.adef	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adf1	29 01		and #$01			and 	#1 							; set sprites flag
.adf3	8d 81 06	sta $0681			sta 	gxSpritesOn
.adf6	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adf7	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adfa	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adfc	29 df		and #$df			and 	#$DF 						; clear sprite bit
.adfe	90 02		bcc $ae02			bcc 	_CSNotOn
.ae00	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ae02					_CSNotOn:
.ae02	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ae05	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ae07	d0 02		bne $ae0b			bne 	_CSNotDefault
.ae09	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ae0b					_CSNotDefault:
.ae0b	8d 84 06	sta $0684			sta 	gxSpritePage
.ae0e	20 2e ae	jsr $ae2e			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae11	a5 36		lda $36				lda 	zTemp0
.ae13	8d 8f 06	sta $068f			sta 	GXSpriteOffsetBase
.ae16	a5 37		lda $37				lda 	zTemp0+1
.ae18	8d 90 06	sta $0690			sta 	GXSpriteOffsetBase+1
.ae1b	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae1d					_CSClear:
.ae1d	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae20	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae23	ca		dex				dex
.ae24	d0 f7		bne $ae1d			bne 	_CSClear
.ae26	9c 8e 06	stz $068e			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae29	20 3c ae	jsr $ae3c			jsr 	GXClearSpriteStore
.ae2c	18		clc				clc
.ae2d	60		rts				rts
.ae2e					GXCalculateBaseAddress:
.ae2e	85 36		sta $36				sta 	gxzTemp0
.ae30	64 37		stz $37				stz 	gxzTemp0+1
.ae32	a9 05		lda #$05			lda 	#5
.ae34					_GXShift:
.ae34	06 36		asl $36				asl 	gxzTemp0
.ae36	26 37		rol $37				rol 	gxzTemp0+1
.ae38	3a		dec a				dec		a
.ae39	d0 f9		bne $ae34			bne 	_GXShift
.ae3b	60		rts				rts
.ae3c					GXClearSpriteStore:
.ae3c	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae3e					_GXCSSLoop:
.ae3e	9e d1 06	stz $06d1,x			stz 	GXSpriteHigh,x
.ae41	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae43	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.ae46	ca		dex				dex
.ae47	10 f5		bpl $ae3e			bpl 	_GXCSSLoop
.ae49	60		rts				rts
.ae4a					GXLine:
.ae4a	ad 82 06	lda $0682			lda 	GXBitmapsOn
.ae4d	f0 28		beq $ae77			beq 	_GXLFail
.ae4f	20 2c b3	jsr $b32c			jsr 	GXOpenBitmap
.ae52	20 72 b4	jsr $b472			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae55	20 1d af	jsr $af1d			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae58	20 3c b3	jsr $b33c			jsr 	GXPositionCalc 				; calculate position/offset.
.ae5b					_GXDrawLoop:
.ae5b	ac 8b 06	ldy $068b			ldy 	gsOffset 					; draw the pixel
.ae5e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae60	2d 89 06	and $0689			and 	gxANDValue
.ae63	4d 88 06	eor $0688			eor 	gxEORValue
.ae66	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae68	20 79 ae	jsr $ae79			jsr 	GXLineIsComplete 			; is the line complete ?
.ae6b	f0 05		beq $ae72			beq 	_GXLExit
.ae6d	20 94 ae	jsr $ae94			jsr 	GXLineAdvance 				; code as per advance method
.ae70	80 e9		bra $ae5b			bra 	_GXDrawLoop
.ae72					_GXLExit:
.ae72	20 34 b3	jsr $b334			jsr 	GXCloseBitmap
.ae75	18		clc				clc
.ae76	60		rts				rts
.ae77					_GXLFail:
.ae77	38		sec				sec
.ae78	60		rts				rts
.ae79					GXLineIsComplete:
.ae79	ad 18 07	lda $0718			lda 	GXIsDiffYLarger 			; is dy larger
.ae7c	d0 0f		bne $ae8d			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae7e	ad 79 06	lda $0679			lda 	GXX0 						; compare X, LSB and MSB
.ae81	4d 7d 06	eor $067d			eor 	GXX1
.ae84	d0 06		bne $ae8c			bne 	_GXLICExit
.ae86	ad 7a 06	lda $067a			lda 	GXX0+1
.ae89	4d 7e 06	eor $067e			eor 	GXX1+1
.ae8c					_GXLICExit:
.ae8c	60		rts				rts
.ae8d					_GXLICCompareY:
.ae8d	ad 7f 06	lda $067f			lda 	GXY1
.ae90	4d 7b 06	eor $067b			eor 	GXY0
.ae93	60		rts				rts
.ae94					GXLineAdvance:
.ae94	18		clc				clc 								; add adjust to position
.ae95	ad 1a 07	lda $071a			lda 	GXPosition
.ae98	6d 1b 07	adc $071b			adc 	GXAdjust
.ae9b	8d 1a 07	sta $071a			sta 	GXPosition
.ae9e	9c 1d 07	stz $071d			stz 	GXAddSelect 				; clear add select flag
.aea1	b0 05		bcs $aea8			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.aea3	cd 1c 07	cmp $071c			cmp 	GXTotal 					; if exceeded total
.aea6	90 0a		bcc $aeb2			bcc 	_GXLANoExtra
.aea8					_GXLAOverflow:
.aea8	ce 1d 07	dec $071d			dec 	GXAddSelect 				; set addselect to $FF
.aeab	38		sec				sec 								; subtract total and write back
.aeac	ed 1c 07	sbc $071c			sbc 	GXTotal
.aeaf	8d 1a 07	sta $071a			sta 	GXPosition
.aeb2					_GXLANoExtra:
.aeb2	ad 18 07	lda $0718			lda 	GXIsDiffYLarger
.aeb5	f0 0d		beq $aec4			beq 	_GXDXLarger
.aeb7	20 16 af	jsr $af16			jsr 	GXIncrementY
.aeba	ad 1d 07	lda $071d			lda 	GXAddSelect
.aebd	f0 10		beq $aecf			beq 	_GXLAExit
.aebf	20 d0 ae	jsr $aed0			jsr 	GXAdjustX
.aec2	80 0b		bra $aecf			bra 	_GXLAExit
.aec4					_GXDXLarger:
.aec4	20 d0 ae	jsr $aed0			jsr 	GXAdjustX
.aec7	ad 1d 07	lda $071d			lda 	GXAddSelect
.aeca	f0 03		beq $aecf			beq 	_GXLAExit
.aecc	20 16 af	jsr $af16			jsr 	GXIncrementY
.aecf					_GXLAExit:
.aecf	60		rts				rts
.aed0					GXAdjustX:
.aed0	ad 19 07	lda $0719			lda 	GXDXNegative
.aed3	10 25		bpl $aefa			bpl 	_GXAXRight
.aed5	ad 79 06	lda $0679			lda 	GXX0
.aed8	d0 03		bne $aedd			bne 	_GXAXNoBorrow
.aeda	ce 7a 06	dec $067a			dec 	GXX0+1
.aedd					_GXAXNoBorrow:
.aedd	ce 79 06	dec $0679			dec 	GXX0
.aee0	ce 8b 06	dec $068b			dec 	gsOffset 					; pixel left
.aee3	ad 8b 06	lda $068b			lda 	gsOffset
.aee6	c9 ff		cmp #$ff			cmp 	#$FF
.aee8	d0 0f		bne $aef9			bne 	_GXAYExit 					; underflow
.aeea	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aeec	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aeee	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aef0	b0 07		bcs $aef9			bcs 	_GXAYExit
.aef2	18		clc				clc
.aef3	69 20		adc #$20			adc 	#$20 						; fix up
.aef5	85 3d		sta $3d				sta 	gxzScreen+1
.aef7	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aef9					_GXAYExit:
.aef9	60		rts				rts
.aefa					_GXAXRight:
.aefa	ee 79 06	inc $0679			inc 	GXX0
.aefd	d0 03		bne $af02			bne 	_GXAXNoCarry
.aeff	ee 7a 06	inc $067a			inc 	GXX0+1
.af02					_GXAXNoCarry:
.af02	ee 8b 06	inc $068b			inc 	gsOffset 					; pixel right
.af05	d0 0e		bne $af15			bne 	_GXAXExit 					; if not overflowed, exit.
.af07	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.af09	a5 3d		lda $3d				lda 	gxzScreen+1
.af0b	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.af0d	90 06		bcc $af15			bcc 	_GXAXExit
.af0f	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af11	85 3d		sta $3d				sta 	gxzScreen+1
.af13	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af15					_GXAXExit:
.af15	60		rts				rts
.af16					GXIncrementY:
.af16	ee 7b 06	inc $067b			inc 	GXY0
.af19	20 92 b3	jsr $b392			jsr 	GXMovePositionDown
.af1c	60		rts				rts
.af1d					GXLineSetup:
.af1d	ad 7f 06	lda $067f			lda 	GXY1
.af20	38		sec				sec
.af21	ed 7b 06	sbc $067b			sbc 	GXY0
.af24	4a		lsr a				lsr 	a
.af25	8d 17 07	sta $0717			sta 	GXDiffY
.af28	9c 19 07	stz $0719			stz 	GXDXNegative 				; clear -ve flag
.af2b	38		sec				sec
.af2c	ad 7d 06	lda $067d			lda 	GXX1
.af2f	ed 79 06	sbc $0679			sbc 	GXX0
.af32	8d 16 07	sta $0716			sta 	GXDiffX
.af35	ad 7e 06	lda $067e			lda 	GXX1+1 						; calculate MSB
.af38	ed 7a 06	sbc $067a			sbc 	GXX0+1
.af3b	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af3c	6e 16 07	ror $0716			ror 	GXDiffX
.af3f	0a		asl a				asl 	a
.af40	10 0c		bpl $af4e			bpl 	_GDXNotNegative
.af42	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af44	38		sec				sec
.af45	ed 16 07	sbc $0716			sbc 	GXDiffX
.af48	8d 16 07	sta $0716			sta 	GXDiffX
.af4b	ce 19 07	dec $0719			dec 	GXDXNegative 				; -ve flag = $FF.
.af4e					_GDXNotNegative:
.af4e	9c 18 07	stz $0718			stz 	GXIsDiffYLarger 			; clear larger flag
.af51	ad 17 07	lda $0717			lda 	GXDiffY 					; set adjust and total.
.af54	8d 1b 07	sta $071b			sta 	GXAdjust
.af57	ad 16 07	lda $0716			lda 	GXDiffX
.af5a	8d 1c 07	sta $071c			sta 	GXTotal
.af5d	ad 17 07	lda $0717			lda 	GXDiffY 					; if dy > dx
.af60	cd 16 07	cmp $0716			cmp 	GXDiffX
.af63	90 0f		bcc $af74			bcc 	_GDXNotLarger
.af65	ce 18 07	dec $0718			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af68	ad 16 07	lda $0716			lda 	GXDiffX 					; set adjust and total other way round
.af6b	8d 1b 07	sta $071b			sta 	GXAdjust
.af6e	ad 17 07	lda $0717			lda 	GXDiffY
.af71	8d 1c 07	sta $071c			sta 	GXTotal
.af74					_GDXNotLarger:
.af74	ad 1c 07	lda $071c			lda 	GXTotal
.af77	4a		lsr a				lsr 	a
.af78	8d 1a 07	sta $071a			sta 	GXPosition
.af7b	60		rts				rts
.0716					GXDiffX:
>0716							.fill 	1
.0717					GXDiffY:
>0717							.fill 	1
.0718					GXIsDiffYLarger:
>0718							.fill 	1
.0719					GXDXNegative:
>0719							.fill 	1
.071a					GXPosition:
>071a							.fill 	1
.071b					GXAdjust:
>071b							.fill 	1
.071c					GXTotal:
>071c							.fill 	1
.071d					GXAddSelect:
>071d							.fill 	1
.af7c					GXSetColourMode:
.af7c	a6 36		ldx $36				ldx 	gxzTemp0
.af7e	8e 87 06	stx $0687			stx 	gxColour 								; set colour
.af81	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af83	8d 86 06	sta $0686			sta 	gxMode 									; set mode
.af86	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af88	9c 89 06	stz $0689			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af8b	ae 87 06	ldx $0687			ldx 	gxColour
.af8e	8e 88 06	stx $0688			stx 	gxEORValue
.af91	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af93	90 03		bcc $af98			bcc 	_GXSDCNotAndColour
.af95	8e 89 06	stx $0689			stx 	gxANDValue
.af98					_GXSDCNotAndColour:
.af98	d0 03		bne $af9d			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af9a	9c 88 06	stz $0688			stz 	gxEORValue
.af9d					_GXSDCNotAnd:
.af9d	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af9e	90 08		bcc $afa8			bcc 	_GXSDCNoFlip
.afa0	ad 89 06	lda $0689			lda	 	gxANDValue
.afa3	49 ff		eor #$ff			eor 	#$FF
.afa5	8d 89 06	sta $0689			sta 	gxANDValue
.afa8					_GXSDCNoFlip:
.afa8	18		clc				clc
.afa9	60		rts				rts
.afaa					GXPlotPoint:
.afaa	20 2c b3	jsr $b32c			jsr 	GXOpenBitmap 				; start drawing
.afad	20 3c b3	jsr $b33c			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afb0	ac 8b 06	ldy $068b			ldy 	gsOffset
.afb3	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afb5	2d 89 06	and $0689			and 	gxANDValue
.afb8	4d 88 06	eor $0688			eor 	gxEORValue
.afbb	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afbd	20 34 b3	jsr $b334			jsr 	GXCloseBitmap 				; stop drawing and exit
.afc0	18		clc				clc
.afc1	60		rts				rts
.afc2					GXFillRectangle:
.afc2	38		sec				sec
.afc3	80 01		bra $afc6			bra 	GXRectangle
.afc5					GXFrameRectangle:
.afc5	18		clc				clc
.afc6					GXRectangle:
.afc6	ad 82 06	lda $0682			lda 	gxBitmapsOn
.afc9	f0 35		beq $b000			beq 	_GXRFail
.afcb	08		php				php 								; save Fill flag (CS)
.afcc	20 2c b3	jsr $b32c			jsr 	GXOpenBitmap 				; start drawing
.afcf	20 54 b4	jsr $b454			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afd2	20 3c b3	jsr $b33c			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afd5	38		sec				sec 								; sec = Draw line
.afd6	20 02 b0	jsr $b002			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afd9	ad 7b 06	lda $067b			lda 	gxY0 						; reached end of rectangle ?
.afdc	cd 7f 06	cmp $067f			cmp 	gxY1
.afdf	f0 19		beq $affa			beq 	_GXRectangleExit
.afe1					_GXRectLoop:
.afe1	20 92 b3	jsr $b392			jsr 	GXMovePositionDown 			; down one.
.afe4	ee 7b 06	inc $067b			inc 	gxY0 						; change Y pos
.afe7	ad 7b 06	lda $067b			lda 	gxY0 						; reached last line
.afea	cd 7f 06	cmp $067f			cmp 	gXY1
.afed	f0 07		beq $aff6			beq 	_GXLastLine
.afef	28		plp				plp 								; get flag back
.aff0	08		php				php
.aff1	20 02 b0	jsr $b002			jsr 	GXDrawLineX1X0 				; draw horizontal line
.aff4	80 eb		bra $afe1			bra 	_GXRectLoop
.aff6					_GXLastLine:
.aff6	38		sec				sec
.aff7	20 02 b0	jsr $b002			jsr 	GXDrawLineX1X0
.affa					_GXRectangleExit:
.affa	68		pla				pla 								; throw fill flag.
.affb	20 34 b3	jsr $b334			jsr 	GXCloseBitmap 				; stop drawing and exit
.affe	18		clc				clc
.afff	60		rts				rts
.b000					_GXRFail:
.b000	38		sec				sec
.b001	60		rts				rts
.b002					GXDrawLineX1X0:
.b002	08		php				php 								; save solid/either-end
.b003	38		sec				sec
.b004	ad 7d 06	lda $067d			lda		gXX1
.b007	ed 79 06	sbc $0679			sbc 	gXX0
.b00a	85 36		sta $36				sta 	gxzTemp0
.b00c	ad 7e 06	lda $067e			lda 	gXX1+1
.b00f	ed 7a 06	sbc $067a			sbc 	gXX0+1
.b012	85 37		sta $37				sta 	gxzTemp0+1
.b014	28		plp				plp
.b015					GXDrawLineTemp0:
.b015	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b017	48		pha				pha
.b018	a5 3d		lda $3d				lda 	gxzScreen+1
.b01a	48		pha				pha
.b01b	ad 8b 06	lda $068b			lda 	gsOffset
.b01e	48		pha				pha
.b01f	a5 0b		lda $0b				lda 	GXEditSlot
.b021	48		pha				pha
.b022	ac 8b 06	ldy $068b			ldy 	gsOffset 					; Y offset
.b025	90 1e		bcc $b045			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b027					_GXDLTLine:
.b027	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b029	2d 89 06	and $0689			and 	gxANDValue
.b02c	4d 88 06	eor $0688			eor 	gxEORValue
.b02f	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b031	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b033	d0 04		bne $b039			bne 	_GXDLTNoBorrow
.b035	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b037	30 2e		bmi $b067			bmi 	_GXDLTExit
.b039					_GXDLTNoBorrow:
.b039	c6 36		dec $36				dec 	gxzTemp0
.b03b	c8		iny				iny 								; next slot.
.b03c	d0 e9		bne $b027			bne 	_GXDLTLine
.b03e	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b040	20 75 b0	jsr $b075			jsr 	GXDLTCheckWrap				; check for new page.
.b043	80 e2		bra $b027			bra 	_GXDLTLine
.b045					_GXDLTEndPoints:
.b045	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b047	2d 89 06	and $0689			and 	gxANDValue
.b04a	4d 88 06	eor $0688			eor 	gxEORValue
.b04d	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b04f	98		tya				tya 								; advance to right side
.b050	18		clc				clc
.b051	65 36		adc $36				adc 	gxzTemp0
.b053	a8		tay				tay
.b054	a5 3d		lda $3d				lda 	gxzScreen+1
.b056	65 37		adc $37				adc 	gxzTemp0+1
.b058	85 3d		sta $3d				sta 	gxzScreen+1
.b05a	20 75 b0	jsr $b075			jsr 	GXDLTCheckWrap 			; fix up.
.b05d	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b05f	2d 89 06	and $0689			and 	gxANDValue
.b062	4d 88 06	eor $0688			eor 	gxEORValue
.b065	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b067					_GXDLTExit:
.b067	68		pla				pla
.b068	85 0b		sta $0b				sta 	GXEditSlot
.b06a	68		pla				pla
.b06b	8d 8b 06	sta $068b			sta 	gsOffset
.b06e	68		pla				pla
.b06f	85 3d		sta $3d				sta 	gxzScreen+1
.b071	68		pla				pla
.b072	85 3c		sta $3c				sta 	gxzScreen
.b074	60		rts				rts
.b075					GXDLTCheckWrap:
.b075	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b077	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b079	90 06		bcc $b081			bcc 	_GXDLTCWExit
.b07b	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b07d	85 3d		sta $3d				sta 	gxzScreen+1
.b07f	e6 0b		inc $0b				inc 	GXEditSlot
.b081					_GXDLTCWExit:
.b081	60		rts				rts
.b082					GXDrawGraphicElement:
.b082	8d 1e 07	sta $071e			sta 	gxSize 						; save size
.b085	3a		dec a				dec 	a
.b086	8d 1f 07	sta $071f			sta 	gxMask 						; and mask
.b089	ad 82 06	lda $0682			lda 	gxBitmapsOn 				; check BMP on
.b08c	f0 67		beq $b0f5			beq 	_GXSLFail
.b08e	ad 7b 06	lda $067b			lda 	gxY0 						; push Y on stack
.b091	48		pha				pha
.b092	8c 21 07	sty $0721			sty 	gxAcquireVector+1 			; and acquisition vector
.b095	8e 20 07	stx $0720			stx 	gxAcquireVector
.b098	20 2c b3	jsr $b32c			jsr 	gxOpenBitmap 				; open the bitmap.
.b09b	ad 23 07	lda $0723			lda 	gxUseMode 					; scale bits
.b09e	4a		lsr a				lsr 	a
.b09f	4a		lsr a				lsr 	a
.b0a0	4a		lsr a				lsr 	a
.b0a1	29 07		and #$07			and		#7
.b0a3	1a		inc a				inc 	a
.b0a4	8d 22 07	sta $0722			sta 	gxScale
.b0a7	64 38		stz $38				stz 	gxzTemp1					; start first line
.b0a9					_GXGELoop:
.b0a9	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b0ab	2c 23 07	bit $0723			bit 	gxUseMode 					; check for flip.
.b0ae	10 06		bpl $b0b6			bpl		_GXNoVFlip
.b0b0	ad 1f 07	lda $071f			lda 	gxMask
.b0b3	38		sec				sec
.b0b4	e5 38		sbc $38				sbc 	gxzTemp1
.b0b6					_GXNoVFlip:
.b0b6	aa		tax				tax 								; get the Xth line.
.b0b7	20 f7 b0	jsr $b0f7			jsr 	_GXCallAcquire 				; get that data.
.b0ba	ad 22 07	lda $0722			lda 	gxScale 					; do scale identical copies of that line.
.b0bd	85 39		sta $39				sta 	gxzTemp1+1
.b0bf					_GXGELoop2:
.b0bf	ad 7b 06	lda $067b			lda 	gxY0 						; off screen
.b0c2	cd 85 06	cmp $0685			cmp 	gxHeight
.b0c5	b0 10		bcs $b0d7			bcs 	_GXDGEExit
.b0c7	20 fa b0	jsr $b0fa			jsr 	GXRenderOneLine 			; render line
.b0ca	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0cc	d0 f1		bne $b0bf			bne 	_GXGELoop2
.b0ce	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0d0	a5 38		lda $38				lda 	gxzTemp1
.b0d2	cd 1e 07	cmp $071e			cmp 	gxSize
.b0d5	d0 d2		bne $b0a9			bne 	_GXGELoop
.b0d7					_GXDGEExit:
.b0d7	68		pla				pla 								; restore Y for next time
.b0d8	8d 7b 06	sta $067b			sta 	gxY0
.b0db	ae 22 07	ldx $0722			ldx 	gxScale 					; get scale (1-8)
.b0de					_GXShiftLeft:
.b0de	18		clc				clc
.b0df	ad 1e 07	lda $071e			lda 	gxSize
.b0e2	6d 79 06	adc $0679			adc 	gxX0
.b0e5	8d 79 06	sta $0679			sta 	gxX0
.b0e8	90 03		bcc $b0ed			bcc 	_GXSLNoCarry
.b0ea	ee 7a 06	inc $067a			inc 	gxX0+1
.b0ed					_GXSLNoCarry:
.b0ed	ca		dex				dex
.b0ee	d0 ee		bne $b0de			bne 	_GXShiftLeft
.b0f0	20 34 b3	jsr $b334			jsr 	GXCloseBitmap
.b0f3	18		clc				clc
.b0f4	60		rts				rts
.b0f5					_GXSLFail:
.b0f5	38		sec				sec
.b0f6	60		rts				rts
.b0f7					_GXCallAcquire:
.b0f7	6c 20 07	jmp ($0720)			jmp 	(gxAcquireVector)
.b0fa					GXRenderOneLine:
.b0fa	20 3c b3	jsr $b33c			jsr 	GXPositionCalc 				; calculate position/offset.
.b0fd	ac 8b 06	ldy $068b			ldy 	gsOffset 					; Y contains position.
.b100	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b102					_GXROLLoop1:
.b102	ad 22 07	lda $0722			lda 	gxScale 					; set to do 'scale' times
.b105	85 3b		sta $3b				sta 	gxzTemp2+1
.b107					_GXROLLoop2:
.b107	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b109	2c 86 06	bit $0686			bit 	gxMode 						; check H Flip
.b10c	50 06		bvc $b114			bvc 	_GXNoHFlip
.b10e	ad 1f 07	lda $071f			lda 	gxMask
.b111	38		sec				sec
.b112	e5 3a		sbc $3a				sbc 	gxzTemp2
.b114					_GXNoHFlip:
.b114	aa		tax				tax 								; read from the pixel buffer
.b115	bd 27 06	lda $0627,x			lda 	gxPixelBuffer,x
.b118	d0 07		bne $b121			bne 	_GXDraw 					; draw if non zero
.b11a	ad 23 07	lda $0723			lda 	gxUseMode 					; check to see if solid background
.b11d	29 04		and #$04			and 	#4
.b11f	f0 0a		beq $b12b			beq 	_GXZeroPixel
.b121					_GXDraw:
.b121	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b123	2d 89 06	and $0689			and 	gxANDValue
.b126	5d 27 06	eor $0627,x			eor 	gxPixelBuffer,x
.b129	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b12b					_GXZeroPixel:
.b12b	c8		iny				iny 								; advance pointer
.b12c	d0 05		bne $b133			bne 	_GXNoShift
.b12e	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b130	20 75 b0	jsr $b075			jsr 	GXDLTCheckWrap				; check for new page.
.b133					_GXNoShift:
.b133	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b135	d0 d0		bne $b107			bne 	_GXROLLoop2
.b137	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b139	a5 3a		lda $3a				lda 	gxzTemp2
.b13b	cd 1e 07	cmp $071e			cmp 	gxSize
.b13e	d0 c2		bne $b102			bne 	_GXROLLoop1
.b140	ee 7b 06	inc $067b			inc 	gxY0
.b143	60		rts				rts
.071e					gxSize:
>071e							.fill 	1
.071f					gxMask:
>071f							.fill 	1
.0720					gxAcquireVector:
>0720							.fill 	2
.0722					gxScale:
>0722							.fill 	1
.0723					gxUseMode:
>0723							.fill 	1
.b144					GXFontHandler:
.b144	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b146	4d 86 06	eor $0686			eor 	gxMode
.b149	8d 23 07	sta $0723			sta 	gxUseMode
.b14c	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b14e	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b150	26 37		rol $37				rol	 	gxzTemp0+1
.b152	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b154	26 37		rol $37				rol	 	gxzTemp0+1
.b156	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b158	26 37		rol $37				rol	 	gxzTemp0+1
.b15a	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b15c	09 c0		ora #$c0			ora 	#$C0
.b15e	85 37		sta $37				sta 	gxzTemp0+1
.b160	a9 08		lda #$08			lda 	#8 							; size 8x8
.b162	a2 6a		ldx #$6a			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b164	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b166	20 82 b0	jsr $b082			jsr 	GXDrawGraphicElement
.b169	60		rts				rts
.b16a					GXGetGraphicDataFont:
.b16a	8a		txa				txa 								; X->Y
.b16b	a8		tay				tay
.b16c	a6 01		ldx $01				ldx 	1 							; preserve old value
.b16e	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b170	85 01		sta $01				sta 	1
.b172	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b174	86 01		stx $01				stx 	1 							; put old value back.
.b176	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b178					_GXExpand:
.b178	9e 27 06	stz $0627,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b17b	0a		asl a				asl 	a 							; shift bit 7 into C
.b17c	90 08		bcc $b186			bcc 	_GXNoPixel
.b17e	48		pha				pha 								; if set, set pixel buffer to current colour.
.b17f	ad 87 06	lda $0687			lda 	gxColour
.b182	9d 27 06	sta $0627,x			sta 	gxPixelBuffer,x
.b185	68		pla				pla
.b186					_GXNoPixel:
.b186	e8		inx				inx 								; do the whole byte.
.b187	e0 08		cpx #$08			cpx 	#8
.b189	d0 ed		bne $b178			bne 	_GXExpand
.b18b	60		rts				rts
.b18c					GXSpriteHandler:
.b18c	ad 81 06	lda $0681			lda 	gxSpritesOn 				; sprites on ?
.b18f	f0 23		beq $b1b4			beq 	_GXSHExit
.b191	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b193	4d 86 06	eor $0686			eor 	gxMode
.b196	8d 23 07	sta $0723			sta 	gxUseMode
.b199	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b19b	da		phx				phx
.b19c	20 2c b3	jsr $b32c			jsr 	GXOpenBitmap 				; can access sprite information
.b19f	68		pla				pla
.b1a0	20 0d b4	jsr $b40d			jsr 	GXFindSprite 				; get the sprite address
.b1a3	08		php				php
.b1a4	20 34 b3	jsr $b334			jsr 	GXCloseBitmap
.b1a7	28		plp				plp
.b1a8	b0 0a		bcs $b1b4			bcs		_GXSHExit 					; exit if find failed.
.b1aa	ad 24 07	lda $0724			lda 	GXSizePixels 				; return size
.b1ad	a2 b5		ldx #$b5			ldx 	#GXSpriteAcquire & $FF
.b1af	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b1b1	20 82 b0	jsr $b082			jsr 	GXDrawGraphicElement
.b1b4					_GXSHExit:
.b1b4	60		rts				rts
.b1b5					GXSpriteAcquire:
.b1b5	ad 84 06	lda $0684			lda 	GXSpritePage				; point to base page
.b1b8	85 0b		sta $0b				sta 	GXEditSlot
.b1ba	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1bc	a9 00		lda #$00			lda 	#0
.b1be	ae 25 07	ldx $0725			ldx 	GXSizeBits
.b1c1					_GXTimesRowNumber:
.b1c1	18		clc				clc
.b1c2	65 36		adc $36				adc 	zTemp0
.b1c4	ca		dex				dex
.b1c5	10 fa		bpl $b1c1			bpl 	_GXTimesRowNumber
.b1c7	64 37		stz $37				stz 	gxzTemp0+1
.b1c9	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1ca	26 37		rol $37				rol 	gxzTemp0+1
.b1cc	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1cd	26 37		rol $37				rol 	gxzTemp0+1
.b1cf	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1d0	26 37		rol $37				rol 	gxzTemp0+1
.b1d2	85 36		sta $36				sta 	gxzTemp0
.b1d4	18		clc				clc 								; add base address.
.b1d5	a5 36		lda $36				lda 	gxzTemp0
.b1d7	6d 27 07	adc $0727			adc 	GXSpriteOffset
.b1da	85 36		sta $36				sta 	gxzTemp0
.b1dc	a5 37		lda $37				lda 	gxzTemp0+1
.b1de	6d 28 07	adc $0728			adc 	GXSpriteOffset+1
.b1e1					_GXSAFindPage:
.b1e1	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1e3	90 06		bcc $b1eb			bcc 	_GXSAFoundPage
.b1e5	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1e7	e6 0b		inc $0b				inc 	GXEditSlot
.b1e9	80 f6		bra $b1e1			bra 	_GXSAFindPage
.b1eb					_GXSAFoundPage:
.b1eb	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1ed	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1ef	a0 00		ldy #$00			ldy 	#0
.b1f1					_GXSACopyLoop:
.b1f1	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1f3	99 27 06	sta $0627,y			sta 	gxPixelBuffer,y
.b1f6	c8		iny				iny
.b1f7	cc 24 07	cpy $0724			cpy 	GXSizePixels
.b1fa	d0 f5		bne $b1f1			bne 	_GXSACopyLoop
.b1fc	60		rts				rts
.b1fd					GXSelect:
.b1fd	ad 81 06	lda $0681			lda 	gxSpritesOn
.b200	f0 22		beq $b224			beq 	_GXSFail
.b202	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b204	c9 40		cmp #$40			cmp 	#64
.b206	b0 1c		bcs $b224			bcs 	_GXSFail
.b208	8d 8c 06	sta $068c			sta 	GSCurrentSpriteID
.b20b	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b20d	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b20f	06 36		asl $36				asl 	gxzTemp0
.b211	06 36		asl $36				asl 	gxzTemp0
.b213	06 36		asl $36				asl 	gxzTemp0
.b215	2a		rol a				rol 	a
.b216	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b218	8d 8e 06	sta $068e			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b21b	85 37		sta $37				sta 	gxzTemp0+1
.b21d	a5 36		lda $36				lda 	gxzTemp0
.b21f	8d 8d 06	sta $068d			sta 	GSCurrentSpriteAddr
.b222	18		clc				clc
.b223	60		rts				rts
.b224					_GXSFail:
.b224	38		sec				sec
.b225	60		rts				rts
.b226					GXSelectImage:
.b226	ad 81 06	lda $0681			lda 	gxSpritesOn
.b229	f0 74		beq $b29f			beq 	_GXSIFail
.b22b	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b22e	f0 6f		beq $b29f			beq 	_GXSIFail 					; (checking the MSB)
.b230	64 01		stz $01				stz 	1
.b232	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b234	d0 6b		bne $b2a1			bne 	_GXSIHide
.b236	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b238	48		pha				pha
.b239	20 2c b3	jsr $b32c			jsr 	GXOpenBitmap
.b23c	68		pla				pla
.b23d	20 0d b4	jsr $b40d			jsr 	GXFindSprite
.b240	b0 5a		bcs $b29c			bcs 	_GXSICloseFail 				; no image
.b242	a0 01		ldy #$01			ldy 	#1
.b244	ad 8d 06	lda $068d			lda 	GSCurrentSpriteAddr
.b247	85 36		sta $36				sta 	gxzTemp0
.b249	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1
.b24c	85 37		sta $37				sta 	gxzTemp0+1
.b24e	ad 27 07	lda $0727			lda 	GXSpriteOffset
.b251	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b253	18		clc				clc
.b254	ad 28 07	lda $0728			lda 	GXSpriteOffset+1
.b257	6d 8f 06	adc $068f			adc 	GXSpriteOffsetBase
.b25a	c8		iny				iny
.b25b	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b25d	ad 90 06	lda $0690			lda 	GXSpriteOffsetBase+1
.b260	69 00		adc #$00			adc 	#0
.b262	c8		iny				iny
.b263	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b265	ad 25 07	lda $0725			lda 	GXSizeBits 					; get raw size
.b268	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b26a	2a		rol a				rol 	a 							; x 2
.b26b	0a		asl a				asl 	a 							; x 4
.b26c	0a		asl a				asl 	a 							; x 8
.b26d	0a		asl a				asl 	a 							; x 16
.b26e	0d 26 07	ora $0726			ora 	GXSpriteLUT 				; Or with LUT
.b271	0a		asl a				asl 	a 							; 1 shift
.b272	09 01		ora #$01			ora 	#1 							; enable sprite.
.b274	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b276	20 34 b3	jsr $b334			jsr 	GXCloseBitmap
.b279	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b27c	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b27f	29 3f		and #$3f			and 	#$3F
.b281	9d d1 06	sta $06d1,x			sta 	GXSpriteHigh,x
.b284	ad 25 07	lda $0725			lda 	GXSizeBits 					; get bit size
.b287	6a		ror a				ror 	a 							; shift into bits 6/7
.b288	6a		ror a				ror 	a
.b289	6a		ror a				ror 	a
.b28a	29 c0		and #$c0			and 	#$C0
.b28c	1d d1 06	ora $06d1,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b28f	9d d1 06	sta $06d1,x			sta 	GXSpriteHigh,x
.b292	bd 91 06	lda $0691,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b295	29 7f		and #$7f			and 	#$7F
.b297	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.b29a	18		clc				clc
.b29b	60		rts				rts
.b29c					_GXSICloseFail:
.b29c	20 34 b3	jsr $b334			jsr 	GXCloseBitmap
.b29f					_GXSIFail:
.b29f	38		sec				sec
.b2a0	60		rts				rts
.b2a1					_GXSIHide:
.b2a1	ad 8d 06	lda $068d			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b2a4	85 36		sta $36				sta 	gxzTemp0
.b2a6	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1
.b2a9	85 37		sta $37				sta 	gxzTemp0+1
.b2ab	a9 00		lda #$00			lda 	#0
.b2ad	92 36		sta ($36)			sta 	(gxzTemp0)
.b2af	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; get sprite ID
.b2b2	bd 91 06	lda $0691,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2b5	09 80		ora #$80			ora 	#$80
.b2b7	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.b2ba	18		clc				clc
.b2bb	60		rts				rts
.b2bc					GXMoveSprite:
.b2bc	ad 81 06	lda $0681			lda 	gxSpritesOn
.b2bf	f0 65		beq $b326			beq 	_GXSIFail
.b2c1	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2c4	f0 60		beq $b326			beq 	_GXSIFail
.b2c6	85 37		sta $37				sta 	gxzTemp0+1
.b2c8	a0 04		ldy #$04			ldy 	#4
.b2ca	ad 8d 06	lda $068d			lda 	GSCurrentSpriteAddr
.b2cd	85 36		sta $36				sta 	gxzTemp0
.b2cf	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2d2	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x
.b2d5	2a		rol a				rol 	a	 						; into bits 0,1.
.b2d6	2a		rol a				rol 	a
.b2d7	2a		rol a				rol 	a
.b2d8	29 03		and #$03			and 	#3
.b2da	aa		tax				tax
.b2db	bd 28 b3	lda $b328,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2de	48		pha				pha
.b2df	18		clc				clc
.b2e0	6d 79 06	adc $0679			adc 	gxX0						; copy position.
.b2e3	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e5	c8		iny				iny
.b2e6	ad 7a 06	lda $067a			lda 	gxX0+1
.b2e9	69 00		adc #$00			adc 	#0
.b2eb	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2ed	c8		iny				iny
.b2ee	68		pla				pla
.b2ef	18		clc				clc
.b2f0	6d 7b 06	adc $067b			adc 	gxY0
.b2f3	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f5	a9 00		lda #$00			lda 	#0
.b2f7	69 00		adc #$00			adc 	#0
.b2f9	c8		iny				iny
.b2fa	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2fc	4e 7a 06	lsr $067a			lsr 	gxX0+1 						; divide X by 4
.b2ff	6e 79 06	ror $0679			ror 	gxX0
.b302	4e 79 06	lsr $0679			lsr 	gxX0
.b305	4e 7b 06	lsr $067b			lsr 	gxY0 						; divide Y by 4
.b308	4e 7b 06	lsr $067b			lsr 	gxY0
.b30b	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b30e	bd 91 06	lda $0691,x			lda 	GXSpriteLow,x
.b311	29 80		and #$80			and 	#$80
.b313	0d 79 06	ora $0679			ora 	gxX0
.b316	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.b319	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x
.b31c	29 c0		and #$c0			and 	#$C0
.b31e	0d 7b 06	ora $067b			ora 	gxY0
.b321	9d d1 06	sta $06d1,x			sta 	GXSpriteHigh,x
.b324	18		clc				clc
.b325	60		rts				rts
.b326					_GXSIFail:
.b326	38		sec				sec
.b327	60		rts				rts
.b328					_GXMSOffset:
>b328	1c						.byte 	32-8/2
>b329	18						.byte 	32-16/2
>b32a	14						.byte 	32-24/2
>b32b	10						.byte 	32-32/2
.b32c					GXOpenBitmap:
.b32c	78		sei				sei 								; no interrupts here
.b32d	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b32f	8d 8a 06	sta $068a			sta 	gxOriginalLUTValue
.b332	58		cli				cli
.b333	60		rts				rts
.b334					GXCloseBitmap:
.b334	78		sei				sei
.b335	ad 8a 06	lda $068a			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b338	85 0b		sta $0b				sta 	GXEditSlot
.b33a	58		cli				cli
.b33b	60		rts				rts
.b33c					GXPositionCalc:
.b33c	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b33e	48		pha				pha
.b33f	ad 7b 06	lda $067b			lda 	GXY0 						; gxzScreen = Y0
.b342	85 3c		sta $3c				sta 	gxzScreen
.b344	64 3d		stz $3d				stz 	gxzScreen+1
.b346	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b348	26 3d		rol $3d				rol 	gxzScreen+1
.b34a	06 3c		asl $3c				asl 	gxzScreen
.b34c	26 3d		rol $3d				rol 	gxzScreen+1
.b34e	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b34f	65 3c		adc $3c				adc 	gxzScreen
.b351	85 3c		sta $3c				sta 	gxzScreen
.b353	90 02		bcc $b357			bcc 	_GXPCNoCarry
.b355	e6 3d		inc $3d				inc 	gxzScreen+1
.b357					_GXPCNoCarry:
.b357	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b359	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b35b	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b35d	85 36		sta $36				sta 	gxzTemp0
.b35f	64 3d		stz $3d				stz 	gxzScreen+1
.b361	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b363					_GXPCMultiply32:
.b363	06 3c		asl $3c				asl 	gxzScreen
.b365	26 3d		rol $3d				rol 	gxzScreen+1
.b367	3a		dec a				dec 	a
.b368	d0 f9		bne $b363			bne 	_GXPCMultiply32
.b36a	18		clc				clc
.b36b	ad 79 06	lda $0679			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b36e	65 3c		adc $3c				adc 	gxzScreen
.b370	8d 8b 06	sta $068b			sta 	gsOffset
.b373	ad 7a 06	lda $067a			lda 	GXX0+1
.b376	65 3d		adc $3d				adc 	gxzScreen+1
.b378	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b37a	90 04		bcc $b380			bcc 	_GXPCNoOverflow
.b37c	29 1f		and #$1f			and 	#$1F 						; fix it up
.b37e	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b380					_GXPCNoOverflow:
.b380	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b382	85 3d		sta $3d				sta 	gxzScreen+1
.b384	64 3c		stz $3c				stz 	gxzScreen
.b386	18		clc				clc
.b387	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b389	6d 83 06	adc $0683			adc 	gxBasePage 					; by adding the base page
.b38c	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b38e	68		pla				pla
.b38f	85 36		sta $36				sta 	gxzTemp0
.b391	60		rts				rts
.b392					GXMovePositionDown:
.b392	18		clc				clc 								; add 320 to offset/temp+1
.b393	ad 8b 06	lda $068b			lda 	gsOffset
.b396	69 40		adc #$40			adc 	#64
.b398	8d 8b 06	sta $068b			sta 	gsOffset
.b39b	a5 3d		lda $3d				lda 	gxzScreen+1
.b39d	69 01		adc #$01			adc 	#1
.b39f	85 3d		sta $3d				sta 	gxzScreen+1
.b3a1	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b3a3	90 07		bcc $b3ac			bcc 	_GXMPDExit
.b3a5	38		sec				sec  								; next page
.b3a6	e9 20		sbc #$20			sbc 	#$20
.b3a8	85 3d		sta $3d				sta 	gxzScreen+1
.b3aa	e6 0b		inc $0b				inc 	GXEditSlot
.b3ac					_GXMPDExit:
.b3ac	60		rts				rts
.b3ad					GXCollide:
.b3ad	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b3af	aa		tax				tax
.b3b0	05 37		ora $37				ora 	gxzTemp0+1
.b3b2	29 c0		and #$c0			and 	#$C0
.b3b4	38		sec				sec
.b3b5	d0 53		bne $b40a			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3b7	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3b9	b9 91 06	lda $0691,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3bc	1d 91 06	ora $0691,x			ora 	GXSpriteLow,x
.b3bf	30 48		bmi $b409			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3c1	18		clc				clc 								; need to calculate sum of sizes.
.b3c2	b9 d1 06	lda $06d1,y			lda 	GXSpriteHigh,y
.b3c5	7d d1 06	adc $06d1,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3c8	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3ca	6a		ror a				ror 	a 							; 5/6/7
.b3cb	4a		lsr a				lsr 	a 							; 4/5/6
.b3cc	4a		lsr a				lsr 	a 							; 3/4/5
.b3cd	4a		lsr a				lsr 	a 							; 2/3/4
.b3ce	18		clc				clc
.b3cf	69 08		adc #$08			adc 	#$08
.b3d1	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3d2	4a		lsr a				lsr 	a
.b3d3	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3d5	b9 d1 06	lda $06d1,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3d8	29 3f		and #$3f			and 	#$3F
.b3da	85 39		sta $39				sta 	gxzTemp1+1
.b3dc	38		sec				sec
.b3dd	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x
.b3e0	29 3f		and #$3f			and 	#$3F
.b3e2	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3e4	b0 03		bcs $b3e9			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3e6	49 ff		eor #$ff			eor 	#$FF
.b3e8	1a		inc a				inc 	a
.b3e9					_GXCAbs1:
.b3e9	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3eb	b0 1c		bcs $b409			bcs 	_GXOkayFail
.b3ed	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3ef	38		sec				sec 								; calculate |x1-x0|
.b3f0	b9 91 06	lda $0691,y			lda 	GXSpriteLow,y
.b3f3	fd 91 06	sbc $0691,x			sbc 	GXSpriteLow,x
.b3f6	b0 03		bcs $b3fb			bcs 	_GXCAbs2
.b3f8	49 ff		eor #$ff			eor 	#$FF
.b3fa	1a		inc a				inc 	a
.b3fb					_GXCAbs2:
.b3fb	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3fd	b0 0a		bcs $b409			bcs 	_GXOkayFail
.b3ff	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b401	90 02		bcc $b405			bcc 	_GXCHaveLowest
.b403	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b405					_GXCHaveLowest:
.b405	0a		asl a				asl 	a 							; scale to allow for >> 2
.b406	0a		asl a				asl 	a
.b407	18		clc				clc
.b408	60		rts				rts
.b409					_GXOkayFail:
.b409	18		clc				clc
.b40a					_GXCollideFail:
.b40a	a9 ff		lda #$ff			lda 	#$FF
.b40c	60		rts				rts
.b40d					GXFindSprite:
.b40d	aa		tax				tax
.b40e	ad 84 06	lda $0684			lda 	GXSpritePage 				; access the base page of the sprite
.b411	85 0b		sta $0b				sta 	GXEditSlot
.b413	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b416	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b419	f0 33		beq $b44e			beq 	_GXFSFail
.b41b	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b41e	8d 28 07	sta $0728			sta 	GXSpriteOffset+1
.b421	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b424	48		pha				pha 								; save twice
.b425	48		pha				pha
.b426	29 03		and #$03			and 	#3 							; get sprite size
.b428	8d 25 07	sta $0725			sta 	GXSizeBits 					; save raw (0-3)
.b42b	aa		tax				tax
.b42c	bd 50 b4	lda $b450,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b42f	8d 24 07	sta $0724			sta 	GXSizePixels 					; save (8/16/24/32)
.b432	68		pla				pla 								; get LUT
.b433	4a		lsr a				lsr		a
.b434	4a		lsr a				lsr		a
.b435	29 03		and #$03			and 	#3
.b437	8d 26 07	sta $0726			sta 	GXSpriteLUT
.b43a	68		pla				pla 								; address, neeeds to be x 4
.b43b	29 f0		and #$f0			and 	#$F0
.b43d	8d 27 07	sta $0727			sta 	GXSpriteOffset
.b440	0e 27 07	asl $0727			asl 	GXSpriteOffset
.b443	2e 28 07	rol $0728			rol 	GXSpriteOffset+1
.b446	0e 27 07	asl $0727			asl 	GXSpriteOffset
.b449	2e 28 07	rol $0728			rol 	GXSpriteOffset+1
.b44c	18		clc				clc
.b44d	60		rts				rts
.b44e					_GXFSFail:
.b44e	38		sec				sec
.b44f	60		rts				rts
.b450					_GXFXSSTTable:
>b450	08 10 18 20					.byte 	8,16,24,32
.0724					GXSizePixels:
>0724							.fill 	1
.0725					GXSizeBits:
>0725							.fill 	1
.0726					GXSpriteLUT:
>0726							.fill 	1
.0727					GXSpriteOffset:
>0727							.fill 	2
.b454					GXSortXY:
.b454	20 72 b4	jsr $b472			jsr 	GXSortY 					; will be sorted on Y now
.b457	ad 79 06	lda $0679			lda 	gxX0 						; compare X0 v X1
.b45a	cd 7d 06	cmp $067d			cmp 	gxX1
.b45d	ad 7a 06	lda $067a			lda 	gXX0+1
.b460	ed 7e 06	sbc $067e			sbc 	gXX1+1
.b463	90 0c		bcc $b471			bcc 	_GXSXYExit 					; X0 < X1 exit
.b465	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b467	a0 04		ldy #$04			ldy 	#4
.b469	20 86 b4	jsr $b486			jsr 	GXSwapXY
.b46c	e8		inx				inx
.b46d	c8		iny				iny
.b46e	20 86 b4	jsr $b486			jsr 	GXSwapXY
.b471					_GXSXYExit:
.b471	60		rts				rts
.b472					GXSortY:
.b472	ad 7b 06	lda $067b			lda 	gxY0 						; if Y0 >= Y1
.b475	cd 7f 06	cmp $067f			cmp 	gxY1
.b478	90 0b		bcc $b485			bcc 	_GXSYSorted
.b47a	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b47c	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b47e					_GXSwap1:
.b47e	20 86 b4	jsr $b486			jsr 	GXSwapXY
.b481	88		dey				dey
.b482	ca		dex				dex
.b483	10 f9		bpl $b47e			bpl 	_GXSwap1
.b485					_GXSYSorted:
.b485	60		rts				rts
.b486					GXSwapXY:
.b486	bd 79 06	lda $0679,x			lda 	gxX0,x
.b489	48		pha				pha
.b48a	b9 79 06	lda $0679,y			lda 	gxX0,y
.b48d	9d 79 06	sta $0679,x			sta 	gxX0,x
.b490	68		pla				pla
.b491	99 79 06	sta $0679,y			sta 	gxX0,y
.b494	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b495					KeywordSet0:
>b495	00 65					.text	0,$65,""               ; $80 !0:EOF
>b497	00 58					.text	0,$58,""               ; $81 !1:SH1
>b499	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b49b	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b4a1	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b4a9	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b4af	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b4b6	05 41 44 45 45 4b 28			.text	5,$41,"DEEK("          ; $87 DEEK(
>b4bd	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $88 EVENT(
>b4c5	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $89 FALSE
>b4cc	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $8a FRAC(
>b4d3	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8b HIT(
>b4d9	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8c INT(
>b4df	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8d ISVAL(
>b4e7	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8e JOYB(
>b4ee	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8f JOYX(
>b4f5	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $90 JOYY(
>b4fc	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $91 LEFT$(
>b504	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $92 LEN(
>b50a	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $93 MAX(
>b510	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $94 MID$(
>b517	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $95 MIN(
>b51d	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $96 NOT(
>b523	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $97 PEEK(
>b52a	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $98 PLAYING(
>b532	47 28
>b534	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $99 RANDOM(
>b53c	28
>b53d	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $9a RIGHT$(
>b545	28
>b546	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $9b RND(
>b54c	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9c SGN(
>b552	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9d SPC(
>b558	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9e STR$(
>b55f	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9f TIMER(
>b567	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $a0 TRUE
>b56d	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $a1 VAL(
>b573	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a2 FOR
>b578	02 8f 49 46				.text	2,$8f,"IF"             ; $a3 IF
>b57c	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a4 PROC
>b582	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a5 REPEAT
>b58a	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a6 WHILE
>b591	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a7 ENDIF
>b598	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a8 ENDPROC
>b5a0	43
>b5a1	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a9 NEXT
>b5a7	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $aa THEN
>b5ad	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $ab UNTIL
>b5b4	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ac WEND
>b5ba	02 9b 42 59				.text	2,$9b,"BY"             ; $ad BY
>b5be	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ae CALL
>b5c4	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $af CIRCLE
>b5cc	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $b0 CLEAR
>b5d3	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $b1 CLS
>b5d8	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b2 COLOR
>b5df	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b3 COLOUR
>b5e7	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b4 DATA
>b5ed	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b5 DIM
>b5f2	04 23 44 4f 4b 45			.text	4,$23,"DOKE"           ; $b6 DOKE
>b5f8	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b7 DOWNTO
>b600	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b8 ELSE
>b606	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b9 FROM
>b60c	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $ba GFX
>b611	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $bb GOSUB
>b618	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $bc GOTO
>b61e	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $bd HERE
>b624	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $be IMAGE
>b62b	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bf INPUT
>b632	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c0 LET
>b637	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c1 LINE
>b63d	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c2 LOCAL
>b644	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c3 OFF
>b649	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c4 ON
>b64d	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c5 OUTLINE
>b655	45
>b656	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c6 PALETTE
>b65e	45
>b65f	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c7 PLOT
>b665	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $c8 POKE
>b66b	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c9 PRINT
>b672	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $ca READ
>b678	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $cb RECT
>b67e	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $cc REM
>b683	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $cd RETURN
>b68b	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ce SOLID
>b692	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cf SOUND
>b699	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d0 SPRITE
>b6a1	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $d1 TEXT
>b6a7	02 a3 54 4f				.text	2,$a3,"TO"             ; $d2 TO
>b6ab	ff					.text	$FF
.b6ac					KeywordSet1:
>b6ac	00 65					.text	0,$65,""               ; $80 !0:EOF
>b6ae	00 58					.text	0,$58,""               ; $81 !1:SH1
>b6b0	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b6b2	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b6ba	4c 45
>b6bc	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b6c4	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b6cc	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b6d1	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $87 EXPLODE
>b6d9	45
>b6da	02 96 47 4f				.text	2,$96,"GO"             ; $88 GO
>b6de	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $89 LIST
>b6e4	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $8a LOAD
>b6ea	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8b NEW
>b6ef	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $8c PING
>b6f5	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8d RESTORE
>b6fd	45
>b6fe	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8e RUN
>b703	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $8f SHOOT
>b70a	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $90 SPRITES
>b712	53
>b713	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $91 STOP
>b719	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $92 WHO
>b71e	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $93 ZAP
>b723	ff					.text	$FF
.b724					KeywordSet2:
>b724	00 65					.text	0,$65,""               ; $80 !0:EOF
>b726	00 58					.text	0,$58,""               ; $81 !1:SH1
>b728	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b72a	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b72f	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b734	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b739	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b73e	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b743	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b748	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b74d	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b752	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b757	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b75c	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b761	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b766	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b76b	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b770	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b775	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b77a	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b77f	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b784	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b789	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b78e	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b793	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b798	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b79d	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b7a2	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b7a7	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b7ac	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b7b1	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b7b6	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b7bb	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b7c0	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b7c5	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b7ca	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b7cf	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b7d4	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b7d9	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b7de	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b7e3	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b7e8	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b7ed	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b7f2	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b7f7	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b7fc	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b801	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b806	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b80b	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b810	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b815	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b81a	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b81f	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b824	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b829	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b82e	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b833	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b838	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b83d	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b842	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b847	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b84c	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b851	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b856	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b85b	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b860	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b865	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b86a	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b86f	ff					.text	$FF
.b870					Export_TKListConvertLine:
.b870	48		pha				pha 								; save indent on the stack
.b871	9c 1d 04	stz $041d			stz 	tbOffset
.b874	9c 2d 04	stz $042d			stz 	tokenBuffer
.b877	9c 29 04	stz $0429			stz 	currentListColour
.b87a	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b87c	20 f9 b9	jsr $b9f9			jsr 	LCLWriteColour
.b87f	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b881	b1 30		lda ($30),y			lda 	(codePtr),y
.b883	aa		tax				tax
.b884	88		dey				dey
.b885	b1 30		lda ($30),y			lda 	(codePtr),y
.b887	20 6a ba	jsr $ba6a			jsr 	LCLWriteNumberXA
.b88a	68		pla				pla 								; adjustment to indent
.b88b	48		pha				pha 								; save on stack
.b88c	10 0c		bpl $b89a			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b88e	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b88f	6d 26 04	adc $0426			adc 	listIndent
.b892	8d 26 04	sta $0426			sta 	listIndent
.b895	10 03		bpl $b89a			bpl 	_LCNoAdjust
.b897	9c 26 04	stz $0426			stz 	listIndent
.b89a					_LCNoAdjust:
.b89a	18		clc				clc		 							; work out actual indent.
.b89b	ad 26 04	lda $0426			lda 	listIndent
.b89e	0a		asl a				asl 	a
.b89f	69 07		adc #$07			adc 	#7
.b8a1	85 36		sta $36				sta 	zTemp0
.b8a3					_LCPadOut:
.b8a3	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b8a5	20 02 ba	jsr $ba02			jsr 	LCLWrite
.b8a8	ad 1d 04	lda $041d			lda 	tbOffset
.b8ab	c5 36		cmp $36				cmp 	zTemp0
.b8ad	d0 f4		bne $b8a3			bne 	_LCPadOut
.b8af	a0 03		ldy #$03			ldy 	#3 							; start position.
.b8b1					_LCMainLoop:
.b8b1	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b8b3	20 f9 b9	jsr $b9f9			jsr 	LCLWriteColour
.b8b6	b1 30		lda ($30),y			lda 	(codePtr),y
.b8b8	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b8ba	f0 17		beq $b8d3			beq 	_LCExit
.b8bc	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b8be	90 1e		bcc $b8de			bcc 	_LCDoubles
.b8c0	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b8c2	90 2a		bcc $b8ee			bcc 	_LCShiftPunc
.b8c4	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b8c6	90 35		bcc $b8fd			bcc 	_LCPunctuation
.b8c8	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b8ca	90 51		bcc $b91d			bcc 	_LCIdentifiers
.b8cc	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b8ce	90 73		bcc $b943			bcc 	_LCTokens
.b8d0	4c a3 b9	jmp $b9a3			jmp 	_LCData 					; 254-5 are data objects
.b8d3					_LCExit:
.b8d3	68		pla				pla 								; get old indent adjust
.b8d4	30 07		bmi $b8dd			bmi 	_LCExit2
.b8d6	18		clc				clc 								; add to indent if +ve
.b8d7	6d 26 04	adc $0426			adc 	listIndent
.b8da	8d 26 04	sta $0426			sta 	listIndent
.b8dd					_LCExit2:
.b8dd	60		rts				rts
.b8de					_LCDoubles:
.b8de	48		pha				pha
.b8df	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b8e0	29 02		and #$02			and 	#2
.b8e2	09 3c		ora #$3c			ora 	#60 						; make < >
.b8e4	20 02 ba	jsr $ba02			jsr 	LCLWrite
.b8e7	68		pla				pla 								; restore, do lower bit
.b8e8	29 03		and #$03			and 	#3
.b8ea	09 3c		ora #$3c			ora 	#60
.b8ec	80 0f		bra $b8fd			bra		_LCPunctuation 				; print, increment, loop
.b8ee					_LCShiftPunc:
.b8ee	aa		tax				tax 								; save in X
.b8ef	29 07		and #$07			and 	#7 							; lower 3 bits
.b8f1	f0 02		beq $b8f5			beq 	_LCNoAdd
.b8f3	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b8f5					_LCNoAdd:
.b8f5	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b8f7	90 02		bcc $b8fb			bcc 	_LCNoAdd2
.b8f9	09 20		ora #$20			ora 	#32 						; adds $20
.b8fb					_LCNoAdd2:
.b8fb	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b8fd					_LCPunctuation:
.b8fd	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b8ff	d0 03		bne $b904			bne 	_LCPContinue
.b901	20 18 ba	jsr $ba18			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b904					_LCPContinue:
.b904	c9 2e		cmp #$2e			cmp 	#'.'
.b906	f0 08		beq $b910			beq 	_LCPIsConstant
.b908	c9 30		cmp #$30			cmp 	#'0'
.b90a	90 0b		bcc $b917			bcc 	_LCPNotConstant
.b90c	c9 3a		cmp #$3a			cmp 	#'9'+1
.b90e	b0 07		bcs $b917			bcs 	_LCPNotConstant
.b910					_LCPIsConstant:
.b910	48		pha				pha
.b911	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b913	20 f9 b9	jsr $b9f9			jsr 	LCLWriteColour
.b916	68		pla				pla
.b917					_LCPNotConstant:
.b917	c8		iny				iny 								; consume character
.b918	20 02 ba	jsr $ba02			jsr 	LCLWrite 					; write it out.
.b91b	80 94		bra $b8b1			bra 	_LCMainLoop 				; go round again.
.b91d					_LCIdentifiers:
.b91d	18		clc				clc 								; convert to physical address
.b91e	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b920	85 37		sta $37				sta 	zTemp0+1
.b922	c8		iny				iny
.b923	b1 30		lda ($30),y			lda 	(codePtr),y
.b925	85 36		sta $36				sta 	zTemp0
.b927	c8		iny				iny
.b928	5a		phy				phy 								; save position
.b929	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b92b	20 f9 b9	jsr $b9f9			jsr 	LCLWriteColour
.b92e	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b930					_LCOutIdentifier:
.b930	c8		iny				iny
.b931	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b933	29 7f		and #$7f			and 	#$7F
.b935	20 54 ba	jsr $ba54			jsr 	LCLLowerCase
.b938	20 02 ba	jsr $ba02			jsr 	LCLWrite
.b93b	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b93d	10 f1		bpl $b930			bpl 	_LCOutIdentifier
.b93f	7a		ply				ply 								; restore position
.b940	4c b1 b8	jmp $b8b1			jmp 	_LCMainLoop
.b943					_LCTokens:
.b943	aa		tax				tax 								; token in X
.b944	a9 24		lda #$24			lda 	#((KeywordSet2) & $FF)
.b946	85 36		sta $36				sta 	0+zTemp0
.b948	a9 b7		lda #$b7			lda 	#((KeywordSet2) >> 8)
.b94a	85 37		sta $37				sta 	1+zTemp0
.b94c	e0 82		cpx #$82			cpx 	#$82
.b94e	f0 16		beq $b966			beq 	_LCUseShift
.b950	a9 ac		lda #$ac			lda 	#((KeywordSet1) & $FF)
.b952	85 36		sta $36				sta 	0+zTemp0
.b954	a9 b6		lda #$b6			lda 	#((KeywordSet1) >> 8)
.b956	85 37		sta $37				sta 	1+zTemp0
.b958	e0 81		cpx #$81			cpx 	#$81
.b95a	f0 0a		beq $b966			beq 	_LCUseShift
.b95c	a9 95		lda #$95			lda 	#((KeywordSet0) & $FF)
.b95e	85 36		sta $36				sta 	0+zTemp0
.b960	a9 b4		lda #$b4			lda 	#((KeywordSet0) >> 8)
.b962	85 37		sta $37				sta 	1+zTemp0
.b964	80 01		bra $b967			bra 	_LCNoShift
.b966					_LCUseShift:
.b966	c8		iny				iny
.b967					_LCNoShift:
.b967	20 2c ba	jsr $ba2c			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b96a	b1 30		lda ($30),y			lda 	(codePtr),y
.b96c	aa		tax				tax 								; into X
.b96d					_LCFindText:
.b96d	ca		dex				dex
.b96e	10 0e		bpl $b97e			bpl 	_LCFoundText 				; found text.
.b970	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b972	1a		inc a				inc 	a 							; one extra for size
.b973	38		sec				sec 								; one extra for checksum
.b974	65 36		adc $36				adc 	zTemp0 						; go to next token
.b976	85 36		sta $36				sta 	zTemp0
.b978	90 f3		bcc $b96d			bcc 	_LCFindText
.b97a	e6 37		inc $37				inc 	zTemp0+1
.b97c	80 ef		bra $b96d			bra 	_LCFindText
.b97e					_LCFoundText:
.b97e	5a		phy				phy 								; save List position
.b97f	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b981	aa		tax				tax
.b982	a9 83		lda #$83			lda 	#CLIToken+$80
.b984	20 f9 b9	jsr $b9f9			jsr 	LCLWriteColour
.b987	a0 02		ldy #$02			ldy 	#2
.b989					_LCCopyToken:
.b989	b1 36		lda ($36),y			lda 	(zTemp0),y
.b98b	20 54 ba	jsr $ba54			jsr 	LCLLowerCase
.b98e	20 02 ba	jsr $ba02			jsr 	LCLWrite
.b991	c8		iny				iny
.b992	ca		dex				dex
.b993	d0 f4		bne $b989			bne 	_LCCopyToken
.b995	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b997	f0 05		beq $b99e			beq 	_LCNoSpace
.b999	a9 20		lda #$20			lda 	#' '
.b99b	20 02 ba	jsr $ba02			jsr 	LCLWrite
.b99e					_LCNoSpace:
.b99e	7a		ply				ply 								; restore position.
.b99f	c8		iny				iny 								; consume token
.b9a0	4c b1 b8	jmp $b8b1			jmp 	_LCMainLoop 				; and go around again.
.b9a3					_LCData:
.b9a3	48		pha				pha 								; save type $FE/$FF
.b9a4	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b9a6	c9 fe		cmp #$fe			cmp 	#$FE
.b9a8	f0 22		beq $b9cc			beq 	_LCHaveOpener
.b9aa	a2 22		ldx #$22			ldx 	#'"'
.b9ac	a9 81		lda #$81			lda 	#CLIData+$80
.b9ae	20 f9 b9	jsr $b9f9			jsr 	LCLWriteColour
.b9b1	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b9b3	d0 17		bne $b9cc			bne 	_LCHaveOpener
.b9b5	88		dey				dey 								; what precedes it ?
.b9b6	b1 30		lda ($30),y			lda 	(codePtr),y
.b9b8	c8		iny				iny
.b9b9	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b9bb	d0 0f		bne $b9cc			bne 	_LCHaveOpener
.b9bd	a9 09		lda #$09			lda 	#9 							; tab
.b9bf	20 02 ba	jsr $ba02			jsr 	LCLWrite
.b9c2	a9 97		lda #$97			lda 	#$90+CLIBComment
.b9c4	20 02 ba	jsr $ba02			jsr 	LCLWrite
.b9c7	a9 80		lda #$80			lda 	#CLIFComment+$80
.b9c9	20 f9 b9	jsr $b9f9			jsr 	LCLWriteColour
.b9cc					_LCHaveOpener:
.b9cc	8a		txa				txa 								; output prefix (# or ")
.b9cd	20 02 ba	jsr $ba02			jsr 	LCLWrite
.b9d0	c8		iny				iny 								; get count
.b9d1	b1 30		lda ($30),y			lda 	(codePtr),y
.b9d3	aa		tax				tax
.b9d4	c8		iny				iny 								; point at first character
.b9d5					_LCOutData:
.b9d5	b1 30		lda ($30),y			lda 	(codePtr),y
.b9d7	c9 00		cmp #$00			cmp 	#0
.b9d9	f0 03		beq $b9de			beq 	_LCNoPrint
.b9db	20 02 ba	jsr $ba02			jsr 	LCLWrite
.b9de					_LCNoPrint:
.b9de	c8		iny				iny
.b9df	ca		dex				dex
.b9e0	d0 f3		bne $b9d5			bne 	_LCOutData
.b9e2	68		pla				pla 								; closing " required ?
.b9e3	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b9e5	d0 0f		bne $b9f6			bne 	_LCNoQuote
.b9e7	a9 22		lda #$22			lda 	#'"'
.b9e9	20 02 ba	jsr $ba02			jsr 	LCLWrite
.b9ec	ad 6e 06	lda $066e			lda 	EXTTextColour
.b9ef	29 0f		and #$0f			and 	#$0F
.b9f1	09 90		ora #$90			ora 	#$90
.b9f3	20 02 ba	jsr $ba02			jsr 	LCLWrite
.b9f6					_LCNoQuote:
.b9f6	4c b1 b8	jmp $b8b1			jmp 	_LCMainLoop
.b9f9					LCLWriteColour:
.b9f9	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b9fc	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b9ff	d0 01		bne $ba02			bne 	LCLWrite 					; if different, output it
.ba01	60		rts				rts
.ba02					LCLWrite:
.ba02	da		phx				phx
.ba03	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.ba06	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.ba09	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.ba0c	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.ba0f	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.ba11	30 03		bmi $ba16			bmi 	_LCLNoColour
.ba13	8d 27 04	sta $0427			sta 	LCLastCharacter
.ba16					_LCLNoColour:
.ba16	fa		plx				plx
.ba17	60		rts				rts
.ba18					LCLDeleteLastSpace:
.ba18	48		pha				pha
.ba19	da		phx				phx
.ba1a	ae 1d 04	ldx $041d			ldx 	tbOffset
.ba1d	f0 0a		beq $ba29			beq 	_LCDLSExit
.ba1f	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.ba22	c9 20		cmp #$20			cmp 	#' '
.ba24	d0 03		bne $ba29			bne 	_LCDLSExit
.ba26	ce 1d 04	dec $041d			dec 	tbOffset
.ba29					_LCDLSExit:
.ba29	fa		plx				plx
.ba2a	68		pla				pla
.ba2b	60		rts				rts
.ba2c					LCLCheckSpaceRequired:
.ba2c	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.ba2f	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.ba31	f0 1b		beq $ba4e			beq 	_LCCSRSpace
.ba33	c9 29		cmp #$29			cmp 	#')'
.ba35	f0 17		beq $ba4e			beq 	_LCCSRSpace
.ba37	c9 23		cmp #$23			cmp 	#'#'
.ba39	f0 13		beq $ba4e			beq 	_LCCSRSpace
.ba3b	20 54 ba	jsr $ba54			jsr 	LCLLowerCase 				; saves a little effort
.ba3e	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.ba40	90 11		bcc $ba53			bcc 	_LCCSRExit
.ba42	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba44	90 08		bcc $ba4e			bcc 	_LCCSRSpace
.ba46	c9 61		cmp #$61			cmp 	#"a"
.ba48	90 09		bcc $ba53			bcc 	_LCCSRExit
.ba4a	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba4c	b0 05		bcs $ba53			bcs 	_LCCSRExit
.ba4e					_LCCSRSpace:
.ba4e	a9 20		lda #$20			lda 	#' '
.ba50	20 02 ba	jsr $ba02			jsr 	LCLWrite
.ba53					_LCCSRExit:
.ba53	60		rts				rts
.ba54					LCLLowerCase:
.ba54	c9 41		cmp #$41			cmp 	#"A"
.ba56	90 06		bcc $ba5e			bcc 	_LCLLCOut
.ba58	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba5a	b0 02		bcs $ba5e			bcs 	_LCLLCOut
.ba5c	69 20		adc #$20			adc 	#$20
.ba5e					_LCLLCOut:
.ba5e	60		rts				rts
.ba5f					LCLUpperCase:
.ba5f	c9 61		cmp #$61			cmp 	#"a"
.ba61	90 06		bcc $ba69			bcc 	_LCLUCOut
.ba63	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba65	b0 02		bcs $ba69			bcs 	_LCLUCOut
.ba67	e9 1f		sbc #$1f			sbc 	#$1F
.ba69					_LCLUCOut:
.ba69	60		rts				rts
.ba6a					LCLWriteNumberXA:
.ba6a	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.ba6c					_LCLWNLoop1:
.ba6c	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.ba6e					_LCLWNLoop2:
.ba6e	48		pha				pha 								; save initial LSB
.ba6f	38		sec				sec
.ba70	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.ba72	f9 a3 ba	sbc $baa3,y			sbc 	_LCLWNTable,y
.ba75	48		pha				pha
.ba76	8a		txa				txa
.ba77	f9 a4 ba	sbc $baa4,y			sbc 	_LCLWNTable+1,y
.ba7a	90 07		bcc $ba83			bcc 	_LCLWNUnderflow
.ba7c	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.ba7e	aa		tax				tax 								; update X
.ba7f	68		pla				pla 								; restore A
.ba80	7a		ply				ply 								; throw original
.ba81	80 eb		bra $ba6e			bra 	_LCLWNLoop2 				; try again.
.ba83					_LCLWNUnderflow:
.ba83	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.ba85	d0 06		bne $ba8d			bne 	_LCLWNOut
.ba87	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.ba8a	3a		dec a				dec 	a
.ba8b	f0 04		beq $ba91			beq 	_LCLWNNext
.ba8d					_LCLWNOut:
.ba8d	98		tya				tya
.ba8e	20 9d ba	jsr $ba9d			jsr 	_LCLWNOutDigit
.ba91					_LCLWNNext:
.ba91	7a		ply				ply 							 	; restore original value.
.ba92	68		pla				pla
.ba93	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.ba95	c8		iny				iny
.ba96	c8		iny				iny
.ba97	84 37		sty $37				sty 	zTemp0+1
.ba99	c0 08		cpy #$08			cpy 	#8 							; done all 4
.ba9b	d0 cf		bne $ba6c			bne 	_LCLWNLoop1
.ba9d					_LCLWNOutDigit:
.ba9d	09 30		ora #$30			ora 	#'0'
.ba9f	20 02 ba	jsr $ba02			jsr 	LCLWrite
.baa2	60		rts				rts
.baa3					_LCLWNTable:
>baa3	10 27						.word 	10000
>baa5	e8 03						.word 	1000
>baa7	64 00						.word 	100
>baa9	0a 00						.word 	10
.baab					TOKSearchTable:
.baab	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.baad	85 36		sta $36				sta 	zTemp0
.baaf	a0 00		ldy #$00			ldy 	#0
.bab1	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.bab3	85 38		sta $38				sta 	zTemp1
.bab5					_TSTLoop:
.bab5	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.bab7	30 49		bmi $bb02			bmi 	_TSTFail 					; -ve = end of table, so fail.
.bab9	f0 2e		beq $bae9			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.babb	c8		iny				iny 								; get the hash
.babc	b1 36		lda ($36),y			lda 	(zTemp0),y
.babe	88		dey				dey
.babf	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.bac2	d0 25		bne $bae9			bne 	_TSTNext
.bac4	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.bac7	38		sec				sec
.bac8	ed 00 04	sbc $0400			sbc 	identStart
.bacb	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.bacd	d0 1a		bne $bae9			bne 	_TSTNext
.bacf	5a		phy				phy 								; save Y , we might fail to match.
.bad0	c8		iny				iny 								; point to text
.bad1	c8		iny				iny
.bad2	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.bad5					_TSTCompareName:
.bad5	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.bad8	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.bada	d0 0c		bne $bae8			bne 	_TSTNextPullY 				; fail, pullY and do next
.badc	e8		inx				inx
.badd	c8		iny				iny
.bade	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.bae1	d0 f2		bne $bad5			bne 	_TSTCompareName
.bae3	7a		ply				ply 								; throw Y
.bae4	a5 38		lda $38				lda 	zTemp1 						; get token #
.bae6	38		sec				sec 								; return with CS = passed.
.bae7	60		rts				rts
.bae8					_TSTNextPullY:
.bae8	7a		ply				ply 								; restore current, fall through.
.bae9					_TSTNext:
.bae9	e6 38		inc $38				inc 	zTemp1 						; token counter
.baeb	98		tya				tya
.baec	18		clc				clc
.baed	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.baef	1a		inc a				inc 	a 							; +1
.baf0	1a		inc a				inc 	a 							; +2
.baf1	a8		tay				tay
.baf2	10 c1		bpl $bab5			bpl 	_TSTLoop 					; if Y < $80 loop back
.baf4	98		tya				tya 								; add Y to zTemp0 and reset Y
.baf5	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.baf7	18		clc				clc  								; but have tables > 255 bytes
.baf8	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.bafa	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.bafc	90 b7		bcc $bab5			bcc 	_TSTLoop
.bafe	e6 37		inc $37				inc 	zTemp0+1
.bb00	80 b3		bra $bab5			bra 	_TSTLoop
.bb02					_TSTFail:
.bb02	18		clc				clc
.bb03	60		rts				rts
.bb04					Export_TKTokeniseLine:
.bb04	20 8c bc	jsr $bc8c			jsr 	LCLFixLineBufferCase 		; fix line case
.bb07	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.bb09	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.bb0c	9c 2b 04	stz $042b			stz 	tokenLineNumber
.bb0f	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.bb12	a2 ff		ldx #$ff			ldx 	#$FF
.bb14					_TKFindFirst:
.bb14	e8		inx				inx
.bb15	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bb18	f0 79		beq $bb93			beq 	_TKExit
.bb1a	c9 20		cmp #$20			cmp 	#' '
.bb1c	90 f6		bcc $bb14			bcc 	_TKFindFirst
.bb1e	c9 30		cmp #$30			cmp 	#'0'
.bb20	90 07		bcc $bb29			bcc 	_TKNoLineNumber
.bb22	c9 3a		cmp #$3a			cmp 	#'9'+1
.bb24	b0 03		bcs $bb29			bcs 	_TKNoLineNumber
.bb26	20 b6 bc	jsr $bcb6			jsr 	TOKExtractLineNumber
.bb29					_TKNoLineNumber:
.bb29					_TKTokeniseLoop:
.bb29	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.bb2c	f0 65		beq $bb93			beq 	_TKExit
.bb2e	e8		inx				inx
.bb2f	c9 20		cmp #$20			cmp 	#' '
.bb31	f0 f6		beq $bb29			beq 	_TKTokeniseLoop 			; keep looping if space found.
.bb33	ca		dex				dex 								; undo last get, A contains character, X is position.
.bb34	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.bb36	f0 61		beq $bb99			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.bb38	c9 41		cmp #$41			cmp 	#'A'
.bb3a	90 04		bcc $bb40			bcc 	_TKTokenisePunctuation
.bb3c	c9 5b		cmp #$5b			cmp 	#'Z'+1
.bb3e	90 59		bcc $bb99			bcc 	_TKTokeniseIdentifier
.bb40					_TKTokenisePunctuation:
.bb40	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.bb42	f0 27		beq $bb6b			beq 	_TKString
.bb44	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.bb46	f0 28		beq $bb70			beq 	_TKHexConstant
.bb48	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.bb4a	f0 29		beq $bb75			beq 	_TKCheckDouble
.bb4c	c9 3e		cmp #$3e			cmp 	#'>'
.bb4e	f0 25		beq $bb75			beq 	_TKCheckDouble
.bb50					_TKStandardPunctuation:
.bb50	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.bb53	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.bb55	90 0e		bcc $bb65			bcc 	_TKNoShift
.bb57	48		pha				pha 								; save. we are about to convert this punctuation token from
.bb58	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.bb5a	85 36		sta $36				sta 	zTemp0
.bb5c	68		pla				pla
.bb5d	29 20		and #$20			and 	#32 						; bit 5
.bb5f	4a		lsr a				lsr 	a 							; shift into bit 3
.bb60	4a		lsr a				lsr 	a
.bb61	05 36		ora $36				ora 	zTemp0
.bb63	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.bb65					_TKNoShift:
.bb65	20 fb bc	jsr $bcfb			jsr 	TOKWriteByte 				; write the punctuation character
.bb68	e8		inx				inx 								; consume the character
.bb69	80 be		bra $bb29			bra 	_TKTokeniseLoop 			; and loop round again.
.bb6b					_TKString:
.bb6b	20 1b bc	jsr $bc1b			jsr 	TOKTokenString
.bb6e	80 b9		bra $bb29			bra 	_TKTokeniseLoop
.bb70					_TKHexConstant:
.bb70	20 56 bc	jsr $bc56			jsr 	TOKHexConstant
.bb73	80 b4		bra $bb29			bra 	_TKTokeniseLoop
.bb75					_TKCheckDouble:
.bb75	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.bb78	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.bb7a	90 d4		bcc $bb50			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.bb7c	c9 3f		cmp #$3f			cmp 	#'>'+1
.bb7e	b0 d0		bcs $bb50			bcs 	_TKStandardPunctuation
.bb80	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.bb83	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.bb85	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.bb86	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.bb89	38		sec				sec
.bb8a	e9 3c		sbc #$3c			sbc 	#'<'
.bb8c	20 fb bc	jsr $bcfb			jsr 	TOKWriteByte 				; this is in the range 0-7
.bb8f	e8		inx				inx 								; consume both
.bb90	e8		inx				inx
.bb91	80 96		bra $bb29			bra 	_TKTokeniseLoop
.bb93	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.bb95	20 fb bc	jsr $bcfb			jsr 	TOKWriteByte
.bb98	60		rts				rts
.bb99					_TKTokeniseIdentifier:
.bb99	8e 00 04	stx $0400			stx 	identStart 					; save start
.bb9c	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.bb9f					_TKCheckLoop:
.bb9f	e8		inx				inx 								; look at next, we know first is identifier already.
.bba0	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.bba3	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.bba5	f0 f8		beq $bb9f			beq 	_TKCheckLoop
.bba7	c9 30		cmp #$30			cmp	 	#"0"
.bba9	90 0c		bcc $bbb7			bcc 	_TKEndIdentifier
.bbab	c9 3a		cmp #$3a			cmp 	#"9"+1
.bbad	90 f0		bcc $bb9f			bcc 	_TKCheckLoop
.bbaf	c9 41		cmp #$41			cmp	 	#"A"
.bbb1	90 04		bcc $bbb7			bcc 	_TKEndIdentifier
.bbb3	c9 5b		cmp #$5b			cmp 	#"Z"+1
.bbb5	90 e8		bcc $bb9f			bcc 	_TKCheckLoop
.bbb7					_TKEndIdentifier:
.bbb7	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.bbba	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.bbbc	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.bbbe	f0 06		beq $bbc6			beq 	_TKHasTypeCharacter
.bbc0	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.bbc2	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.bbc4	d0 07		bne $bbcd			bne 	_TKNoTypeCharacter
.bbc6					_TKHasTypeCharacter:
.bbc6	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.bbc9	e8		inx				inx 								; consume the type character
.bbca	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bbcd					_TKNoTypeCharacter:
.bbcd	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.bbcf	d0 09		bne $bbda			bne 	_TKNoArray
.bbd1	e8		inx				inx 								; skip the (
.bbd2	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.bbd5	09 04		ora #$04			ora 	#$04
.bbd7	8d 04 04	sta $0404			sta 	identTypeByte
.bbda					_TKNoArray:
.bbda	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.bbdd	20 77 bc	jsr $bc77			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.bbe0	a0 b4		ldy #$b4			ldy 	#(KeywordSet0) >> 8
.bbe2	a9 95		lda #$95			lda 	#(KeywordSet0) & $FF
.bbe4	20 ab ba	jsr $baab			jsr 	TOKSearchTable
.bbe7	a2 00		ldx #$00			ldx 	#0
.bbe9	b0 1f		bcs $bc0a			bcs 	_TKFoundToken
.bbeb	a0 b6		ldy #$b6			ldy 	#(KeywordSet1) >> 8
.bbed	a9 ac		lda #$ac			lda 	#(KeywordSet1) & $FF
.bbef	20 ab ba	jsr $baab			jsr 	TOKSearchTable
.bbf2	a2 81		ldx #$81			ldx 	#$81
.bbf4	b0 14		bcs $bc0a			bcs 	_TKFoundToken
.bbf6	a0 b7		ldy #$b7			ldy 	#(KeywordSet2) >> 8
.bbf8	a9 24		lda #$24			lda 	#(KeywordSet2) & $FF
.bbfa	20 ab ba	jsr $baab			jsr 	TOKSearchTable
.bbfd	a2 82		ldx #$82			ldx 	#$82
.bbff	b0 09		bcs $bc0a			bcs 	_TKFoundToken
.bc01	20 07 bd	jsr $bd07			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bc04	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc07	4c 29 bb	jmp $bb29			jmp 	_TKTokeniseLoop 			; and go round again.
.bc0a					_TKFoundToken:
.bc0a	48		pha				pha 								; save token
.bc0b	8a		txa				txa 								; shift in X, is there one ?
.bc0c	f0 03		beq $bc11			beq 	_TKNoTShift
.bc0e	20 fb bc	jsr $bcfb			jsr 	TOKWriteByte 				; if so, write it out
.bc11					_TKNoTShift:
.bc11	68		pla				pla 								; restore and write token
.bc12	20 fb bc	jsr $bcfb			jsr 	TOKWriteByte
.bc15	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc18	4c 29 bb	jmp $bb29			jmp 	_TKTokeniseLoop 			; and go round again.
.bc1b					TOKTokenString:
.bc1b	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bc1d	20 fb bc	jsr $bcfb			jsr 	TOKWriteByte
.bc20	e8		inx				inx									; start of quoted string.
.bc21	da		phx				phx 								; push start of string on top
.bc22	ca		dex				dex 								; because we pre-increment
.bc23					_TSFindEnd:
.bc23	e8		inx				inx
.bc24	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bc27	f0 04		beq $bc2d			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bc29	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bc2b	d0 f6		bne $bc23			bne 	_TSFindEnd
.bc2d					_TSEndOfString:
.bc2d	7a		ply				ply  								; so now Y is first character, X is character after end.
.bc2e	48		pha				pha 								; save terminating character
.bc2f	20 37 bc	jsr $bc37			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bc32	68		pla				pla 								; terminating character
.bc33	f0 01		beq $bc36			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bc35	e8		inx				inx
.bc36					_TSNotQuote:
.bc36	60		rts				rts
.bc37					TOKWriteBlockXY:
.bc37	86 36		stx $36				stx 	zTemp0 						; save end character
.bc39	98		tya				tya 								; use 2's complement to work out the byte size
.bc3a	49 ff		eor #$ff			eor 	#$FF
.bc3c	38		sec				sec
.bc3d	65 36		adc $36				adc 	zTemp0
.bc3f	1a		inc a				inc 	a 							; one extra for NULL
.bc40	20 fb bc	jsr $bcfb			jsr 	TOKWriteByte
.bc43					_TOBlockLoop:
.bc43	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bc45	f0 09		beq $bc50			beq 	_TOBlockExit
.bc47	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bc4a	20 fb bc	jsr $bcfb			jsr 	TOKWriteByte
.bc4d	c8		iny				iny
.bc4e	80 f3		bra $bc43			bra 	_TOBlockLoop
.bc50					_TOBlockExit:
.bc50	a9 00		lda #$00			lda 	#0 							; add NULL.
.bc52	20 fb bc	jsr $bcfb			jsr 	TOKWriteByte
.bc55	60		rts				rts
.bc56					TOKHexConstant:
.bc56	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bc58	20 fb bc	jsr $bcfb			jsr 	TOKWriteByte
.bc5b	e8		inx				inx									; start of quoted string.
.bc5c	da		phx				phx 								; push start of constant on top
.bc5d	ca		dex				dex
.bc5e					_THFindLoop:
.bc5e	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bc5f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bc62	c9 30		cmp #$30			cmp 	#"0"
.bc64	90 0c		bcc $bc72			bcc 	_THFoundEnd
.bc66	c9 3a		cmp #$3a			cmp 	#"9"+1
.bc68	90 f4		bcc $bc5e			bcc 	_THFindLoop
.bc6a	c9 41		cmp #$41			cmp 	#"A"
.bc6c	90 04		bcc $bc72			bcc 	_THFoundEnd
.bc6e	c9 47		cmp #$47			cmp 	#"F"+1
.bc70	90 ec		bcc $bc5e			bcc 	_THFindLoop
.bc72					_THFoundEnd:
.bc72	7a		ply				ply 								; restore start
.bc73	20 37 bc	jsr $bc37			jsr 	TOKWriteBlockXY 			; output the block
.bc76	60		rts				rts
.bc77					TOKCalculateHash:
.bc77	da		phx				phx
.bc78	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bc7b	a9 00		lda #$00			lda 	#0
.bc7d					_TCHLoop:
.bc7d	18		clc				clc
.bc7e	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bc81	e8		inx				inx
.bc82	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bc85	d0 f6		bne $bc7d			bne 	_TCHLoop
.bc87	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bc8a	fa		plx				plx
.bc8b	60		rts				rts
.bc8c					LCLFixLineBufferCase:
.bc8c	a2 00		ldx #$00			ldx 	#0
.bc8e					_FLBCLoop:
.bc8e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bc91	f0 22		beq $bcb5			beq 	_FLBCExit 					; end of string.
.bc93	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bc95	f0 11		beq $bca8			beq 	_FLBCInQuotes
.bc97	e8		inx				inx
.bc98	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bc9a	90 f2		bcc $bc8e			bcc 	_FLBCLoop
.bc9c	c9 7b		cmp #$7b			cmp 	#'z'+1
.bc9e	b0 ee		bcs $bc8e			bcs 	_FLBCLoop
.bca0	38		sec				sec 								; make U/C
.bca1	e9 20		sbc #$20			sbc 	#32
.bca3	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bca6	80 e6		bra $bc8e			bra 	_FLBCLoop
.bca8					_FLBCInQuotes:
.bca8	e8		inx				inx 								; advance
.bca9	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bcac	f0 07		beq $bcb5			beq 	_FLBCExit 					; exit on EOS
.bcae	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bcb0	d0 f6		bne $bca8			bne 	_FLBCInQuotes
.bcb2	e8		inx				inx 								; skip over it
.bcb3	80 d9		bra $bc8e			bra 	_FLBCLoop
.bcb5					_FLBCExit:
.bcb5	60		rts				rts
.bcb6					TOKExtractLineNumber:
.bcb6	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bcb9	48		pha				pha
.bcba	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bcbd	48		pha				pha
.bcbe	20 f4 bc	jsr $bcf4			jsr 	_LCLNTimes2 				; line # x 2
.bcc1	20 f4 bc	jsr $bcf4			jsr 	_LCLNTimes2 				; line # x 4
.bcc4	18		clc				clc 								; add stacked value
.bcc5	68		pla				pla
.bcc6	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcc9	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bccc	68		pla				pla
.bccd	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bcd0	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bcd3	20 f4 bc	jsr $bcf4			jsr 	_LCLNTimes2 				; line # x 10
.bcd6	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bcd9	e8		inx				inx
.bcda	29 0f		and #$0f			and 	#15 						; add to line #
.bcdc	18		clc				clc
.bcdd	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bce0	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bce3	90 03		bcc $bce8			bcc 	_TLENNoCarry
.bce5	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bce8					_TLENNoCarry:
.bce8	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bceb	c9 30		cmp #$30			cmp 	#'0'
.bced	90 04		bcc $bcf3			bcc 	_TLENExit
.bcef	c9 3a		cmp #$3a			cmp 	#'9'+1
.bcf1	90 c3		bcc $bcb6			bcc 	TOKExtractLineNumber
.bcf3					_TLENExit:
.bcf3	60		rts				rts
.bcf4					_LCLNTimes2:
.bcf4	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bcf7	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bcfa	60		rts				rts
.bcfb					TOKWriteByte:
.bcfb	da		phx				phx
.bcfc	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bcff	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bd02	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bd05	fa		plx				plx
.bd06	60		rts				rts
.bd07					TOKCheckCreateVariableRecord:
.bd07	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bd09	85 36		sta $36				sta 	0+zTemp0
.bd0b	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bd0d	85 37		sta $37				sta 	1+zTemp0
.bd0f					_CCVSearch:
.bd0f	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bd11	f0 2c		beq $bd3f			beq 	_CCVFail
.bd13	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bd15	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bd17	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bd1a	d0 16		bne $bd32			bne 	_CCVNext
.bd1c	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bd1e	ae 00 04	ldx $0400			ldx 	identStart
.bd21					_CCVCompare:
.bd21	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bd24	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bd26	e8		inx				inx 								; advance pointers
.bd27	c8		iny				iny
.bd28	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bd29	d0 07		bne $bd32			bne 	_CCVNext  					; didn't match go to next.
.bd2b	90 f4		bcc $bd21			bcc 	_CCVCompare 				; not finished yet.
.bd2d	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bd30	f0 41		beq $bd73			beq 	_CCVFound 					; yes, we were successful
.bd32					_CCVNext:
.bd32	18		clc				clc 								; go to next record.
.bd33	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bd35	65 36		adc $36				adc 	zTemp0
.bd37	85 36		sta $36				sta 	zTemp0
.bd39	90 d4		bcc $bd0f			bcc 	_CCVSearch
.bd3b	e6 37		inc $37				inc 	zTemp0+1
.bd3d	80 d0		bra $bd0f			bra 	_CCVSearch
.bd3f					_CCVFail:
.bd3f	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bd41	ad 03 04	lda $0403			lda 	identHash
.bd44	91 36		sta ($36),y			sta 	(zTemp0),y
.bd46	c8		iny				iny 								; offset 2 is the type byte
.bd47	ad 04 04	lda $0404			lda 	identTypeByte
.bd4a	91 36		sta ($36),y			sta 	(zTemp0),y
.bd4c	c8		iny				iny
.bd4d					_CCVData:
.bd4d	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bd4f	91 36		sta ($36),y			sta 	(zTemp0),y
.bd51	c8		iny				iny
.bd52	c0 08		cpy #$08			cpy 	#8
.bd54	90 f7		bcc $bd4d			bcc 	_CCVData
.bd56	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bd59					_CCVCopyName:
.bd59	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bd5c	91 36		sta ($36),y			sta 	(zTemp0),y
.bd5e	e8		inx				inx
.bd5f	c8		iny				iny
.bd60	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bd63	d0 f4		bne $bd59			bne 	_CCVCopyName
.bd65	98		tya				tya 								; patch offset
.bd66	92 36		sta ($36)			sta 	(zTemp0)
.bd68	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bd6a	91 36		sta ($36),y			sta 	(zTemp0),y
.bd6c	88		dey				dey
.bd6d	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bd6f	09 80		ora #$80			ora 	#$80
.bd71	91 36		sta ($36),y			sta 	(zTemp0),y
.bd73					_CCVFound:
.bd73	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bd75	38		sec				sec
.bd76	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bd78	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bd7a	20 fb bc	jsr $bcfb			jsr 	TOKWriteByte
.bd7d	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bd7f	20 fb bc	jsr $bcfb			jsr 	TOKWriteByte
.bd82	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bd83					SNDCheckChannel:
.bd83	aa		tax				tax
.bd84	bd 37 08	lda $0837,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bd87	d0 38		bne $bdc1			bne 	_SNDCCExit
.bd89	da		phx				phx 								; save current channel
.bd8a	8a		txa				txa 								; put in A
.bd8b	20 07 be	jsr $be07			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bd8e	68		pla				pla 								; channel # in A
.bd8f	90 30		bcc $bdc1			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bd91	a8		tay				tay 								; Y is the channel #
.bd92	bd 2c 07	lda $072c,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bd95	99 2b 08	sta $082b,y			sta 	SNDPitchLow,y
.bd98	bd 2d 07	lda $072d,x			lda 	SNDQueue+2,x
.bd9b	99 2f 08	sta $082f,y			sta 	SNDPitchHigh,y
.bd9e	bd 2e 07	lda $072e,x			lda 	SNDQueue+3,x
.bda1	99 33 08	sta $0833,y			sta 	SNDVolume,y
.bda4	bd 2f 07	lda $072f,x			lda 	SNDQueue+4,x
.bda7	99 37 08	sta $0837,y			sta 	SNDTimeLeft,y
.bdaa	bd 30 07	lda $0730,x			lda 	SNDQueue+5,x
.bdad	99 3b 08	sta $083b,y			sta 	SNDAdjustLow,y
.bdb0	bd 31 07	lda $0731,x			lda 	SNDQueue+6,x
.bdb3	99 3f 08	sta $083f,y			sta 	SNDAdjustHigh,y
.bdb6	5a		phy				phy 								; save channel #
.bdb7	20 21 be	jsr $be21			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bdba	ce 2a 07	dec $072a			dec 	SNDLength 					; reduce the queue length.
.bdbd	68		pla				pla
.bdbe	20 c2 bd	jsr $bdc2			jsr 	SNDUpdateNote 				; update channel A
.bdc1					_SNDCCExit:
.bdc1	60		rts				rts
.bdc2					SNDUpdateNote:
.bdc2	aa		tax				tax 								; so we can access records
.bdc3	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bdc4	0a		asl a				asl 	a
.bdc5	0a		asl a				asl 	a
.bdc6	0a		asl a				asl 	a
.bdc7	0a		asl a				asl 	a
.bdc8	8d 29 07	sta $0729			sta 	SNDChannelBits
.bdcb	bd 37 08	lda $0837,x			lda 	SNDTimeLeft,x 				; are we silent
.bdce	f0 2e		beq $bdfe			beq 	_SNDUNIsSilent
.bdd0	ad 29 07	lda $0729			lda 	SNDChannelBits 				; push channel bits on stack
.bdd3	48		pha				pha
.bdd4	bd 2b 08	lda $082b,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bdd7	29 0f		and #$0f			and 	#$0F
.bdd9	0d 29 07	ora $0729			ora 	SNDChannelBits 				; set channel bits
.bddc	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bdde	20 6b be	jsr $be6b			jsr 	SNDWritePorts
.bde1	bd 2f 08	lda $082f,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bde4	8d 29 07	sta $0729			sta 	SNDChannelBits
.bde7	bd 2b 08	lda $082b,x			lda 	SNDPitchLow,x
.bdea	4e 29 07	lsr $0729			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bded	6a		ror a				ror 	a
.bdee	4e 29 07	lsr $0729			lsr 	SNDChannelBits
.bdf1	6a		ror a				ror 	a
.bdf2	4a		lsr a				lsr 	a 							; put in bits 0-5
.bdf3	4a		lsr a				lsr 	a
.bdf4	20 6b be	jsr $be6b			jsr 	SNDWritePorts 				; write as rest of pitch register
.bdf7	68		pla				pla
.bdf8	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.bdfa	20 6b be	jsr $be6b			jsr 	SNDWritePorts
.bdfd	60		rts				rts
.bdfe					_SNDUNIsSilent:
.bdfe	ad 29 07	lda $0729			lda 	SNDChannelBits 				; channel bits
.be01	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.be03	20 6b be	jsr $be6b			jsr 	SNDWritePorts 				; write to the ports
.be06	60		rts				rts
.be07					SNDFindNextNoteForA:
.be07	ac 2a 07	ldy $072a			ldy 	SNDLength 					; queue size into Y
.be0a	f0 13		beq $be1f			beq 	_SNDFNNFail 				; queue empty.
.be0c	a2 00		ldx #$00			ldx 	#0
.be0e					_SNDFNNSearch:
.be0e	dd 2b 07	cmp $072b,x			cmp 	SNDQueue,x 					; does it match the channel
.be11	38		sec				sec
.be12	f0 0c		beq $be20			beq 	_SNDFNNExit 				; if so exit with CS.
.be14	e8		inx				inx 								; next queue slot.
.be15	e8		inx				inx
.be16	e8		inx				inx
.be17	e8		inx				inx
.be18	e8		inx				inx
.be19	e8		inx				inx
.be1a	e8		inx				inx
.be1b	e8		inx				inx
.be1c	88		dey				dey 								; done the whole queue
.be1d	d0 ef		bne $be0e			bne 	_SNDFNNSearch 				; no, go back.
.be1f					_SNDFNNFail:
.be1f	18		clc				clc
.be20					_SNDFNNexit:
.be20	60		rts				rts
.be21					SNDDeleteXFromQueue:
.be21	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.be23	f0 09		beq $be2e			beq 	_SNDDXExit
.be25	bd 33 07	lda $0733,x			lda 	SNDQueue+8,x
.be28	9d 2b 07	sta $072b,x			sta 	SNDQueue,x
.be2b	e8		inx				inx
.be2c	80 f3		bra $be21			bra 	SNDDeleteXFromQueue
.be2e					_SNDDXExit:
.be2e	60		rts				rts
.0729					SNDChannelBits:
>0729							.fill 	1
.be2f					SNDQueueRequest:
.be2f	86 36		stx $36				stx 	zTemp0						; save queue address
.be31	84 37		sty $37				sty 	zTemp0+1
.be33	ae 2a 07	ldx $072a			ldx 	SNDLength 					; queue is full, can't take any more.
.be36	e0 20		cpx #$20			cpx 	#SNDQueueSize
.be38	f0 21		beq $be5b			beq 	_SNDQRExit
.be3a	29 03		and #$03			and 	#3	 						; channel # and push on stack
.be3c	48		pha				pha
.be3d	8a		txa				txa  								; get offset in queue buffer/
.be3e	0a		asl a				asl 	a
.be3f	0a		asl a				asl 	a
.be40	0a		asl a				asl 	a
.be41	aa		tax				tax
.be42	68		pla				pla 								; get back and push again
.be43	48		pha				pha
.be44	9d 2b 07	sta $072b,x			sta 	SNDQueue+0,x 				; save the channel #
.be47	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.be49					_SNDQCopy:
.be49	b1 36		lda ($36),y			lda 	(zTemp0),y
.be4b	e8		inx				inx
.be4c	c8		iny				iny
.be4d	9d 2b 07	sta $072b,x			sta 	SNDQueue,x
.be50	c0 06		cpy #$06			cpy 	#6
.be52	d0 f5		bne $be49			bne 	_SNDQCopy
.be54	ee 2a 07	inc $072a			inc 	SNDLength 					; bump queue length.
.be57	68		pla				pla 								; get channel # back
.be58	20 83 bd	jsr $bd83			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.be5b					_SNDQRExit:
.be5b	60		rts				rts
.be5c					SNDSilenceChannel:
.be5c	aa		tax				tax 								; zero time left.
.be5d	9e 37 08	stz $0837,x			stz 	SNDTimeLeft,x
.be60	0a		asl a				asl 	a 							; shift into position
.be61	0a		asl a				asl 	a
.be62	0a		asl a				asl 	a
.be63	0a		asl a				asl 	a
.be64	0a		asl a				asl 	a
.be65	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.be67	20 6b be	jsr $be6b			jsr 	SNDWritePorts
.be6a	60		rts				rts
.be6b					SNDWritePorts:
.be6b	da		phx				phx 								; save X
.be6c	a6 01		ldx $01				ldx 	1 							; save I/O status
.be6e	64 01		stz $01				stz 	1 							; access I/O page 0
.be70	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.be73	8d 10 d6	sta $d610			sta 	$D610
.be76	86 01		stx $01				stx 	1 							; restore I/O
.be78	fa		plx				plx 								; restore X
.be79	60		rts				rts
.be7a					Export_SNDCommand:
.be7a	da		phx				phx 								; save XY
.be7b	5a		phy				phy
.be7c	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.be7e	f0 1d		beq $be9d			beq 	_SNDInitialise
.be80	90 28		bcc $beaa			bcc 	_SNDExit
.be82	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.be84	f0 17		beq $be9d			beq 	_SNDSilence
.be86	b0 22		bcs $beaa			bcs 	_SNDExit
.be88	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.be8a	b0 09		bcs $be95			bcs 	_SNDQueryPlay
.be8c	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.be8e	b0 1a		bcs $beaa			bcs 	_SNDExit
.be90	20 2f be	jsr $be2f			jsr 	SNDQueueRequest
.be93	80 15		bra $beaa			bra 	_SNDExit
.be95					_SNDQueryPlay:
.be95	29 03		and #$03			and 	#3 							; get channel #
.be97	aa		tax				tax
.be98	bd 37 08	lda $0837,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.be9b	80 0d		bra $beaa			bra 	_SNDExit
.be9d					_SNDInitialise:
.be9d					_SNDSilence:
.be9d	9c 2a 07	stz $072a			stz 	SNDLength 					; empty the queue.
.bea0	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.bea2					_SNDSilenceLoop:
.bea2	48		pha				pha
.bea3	20 5c be	jsr $be5c			jsr 	SNDSilenceChannel
.bea6	68		pla				pla
.bea7	3a		dec a				dec 	a
.bea8	10 f8		bpl $bea2			bpl 	_SNDSilenceLoop
.beaa					_SNDExit:
.beaa	7a		ply				ply
.beab	fa		plx				plx
.beac	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.072a					SNDLength:
>072a							.fill 	1
.072b					SNDQueue:
>072b							.fill 	SNDQueueSize * 8
.082b					SNDPitchLow:
>082b							.fill 	4
.082f					SNDPitchHigh:
>082f							.fill 	4
.0833					SNDVolume:
>0833							.fill 	4
.0837					SNDTimeLeft:
>0837							.fill 	4
.083b					SNDAdjustLow:
>083b							.fill 	4
.083f					SNDAdjustHigh:
>083f							.fill 	4
.bead					Export_SNDUpdate:
.bead					PagedSNDUpdate:
.bead	ad 37 08	lda $0837			lda 	SNDTimeLeft+0 				; look at time remaining
.beb0	f0 05		beq $beb7			beq 	_SNDUNot0 					; not playing
.beb2	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.beb4	20 d6 be	jsr $bed6			jsr 	SNDUpdateChannel 			; update it.
.beb7					_SNDUNot0:
.beb7	ad 38 08	lda $0838			lda 	SNDTimeLeft+1
.beba	f0 05		beq $bec1			beq 	_SNDUNot1
.bebc	a2 01		ldx #$01			ldx 	#1
.bebe	20 d6 be	jsr $bed6			jsr 	SNDUpdateChannel
.bec1					_SNDUNot1:
.bec1	ad 39 08	lda $0839			lda 	SNDTimeLeft+2
.bec4	f0 05		beq $becb			beq 	_SNDUNot2
.bec6	a2 02		ldx #$02			ldx 	#2
.bec8	20 d6 be	jsr $bed6			jsr 	SNDUpdateChannel
.becb					_SNDUNot2:
.becb	ad 3a 08	lda $083a			lda 	SNDTimeLeft+3
.bece	f0 05		beq $bed5			beq 	_SNDUNot3
.bed0	a2 03		ldx #$03			ldx 	#3
.bed2	20 d6 be	jsr $bed6			jsr 	SNDUpdateChannel
.bed5					_SNDUNot3:
.bed5	60		rts				rts
.bed6					SNDUpdateChannel:
.bed6	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.bed8	f0 2c		beq $bf06			beq 	_SNDUCExit
.beda	3a		dec a				dec 	a 							; decrement and update timer
.bedb	9d 37 08	sta $0837,x			sta 	SNDTimeLeft,x
.bede	f0 1d		beq $befd			beq 	_SNDUCUpdate 				; if zero, silence channel
.bee0	bd 3b 08	lda $083b,x			lda 	SNDAdjustLow,x 				; adjust ?
.bee3	1d 3f 08	ora $083f,x			ora 	SNDAdjustHigh,x
.bee6	f0 1e		beq $bf06			beq 	_SNDUCExit 					; if zero carry on at current tone.
.bee8	18		clc				clc 								; add adjust, forcing into a 10 bit range
.bee9	bd 2b 08	lda $082b,x			lda 	SNDPitchLow,x
.beec	7d 3b 08	adc $083b,x			adc 	SNDAdjustLow,x
.beef	9d 2b 08	sta $082b,x			sta 	SNDPitchLow,x
.bef2	bd 2f 08	lda $082f,x			lda 	SNDPitchHigh,x
.bef5	7d 3f 08	adc $083f,x			adc 	SNDAdjustHigh,x
.bef8	29 03		and #$03			and 	#3
.befa	9d 2f 08	sta $082f,x			sta 	SNDPitchHigh,x
.befd					_SNDUCUpdate:
.befd	8a		txa				txa 								; which channel.
.befe	48		pha				pha
.beff	20 c2 bd	jsr $bdc2			jsr 	SNDUpdateNote 				; update the current note
.bf02	68		pla				pla
.bf03	20 83 bd	jsr $bd83			jsr 	SNDCheckChannel 			; more to do ?
.bf06					_SNDUCExit:
.bf06	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
