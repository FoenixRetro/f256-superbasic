
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Wed Nov 23 19:34:17 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					isInputFlag:
>04a8							.fill 	1
.04a9					tokenOffset:
>04a9							.fill 	1
.04aa					tokenLineNumber:
>04aa							.fill 	2
.04ac					tokenBuffer:
>04ac							.fill 	253
.05a9					lineBuffer:
>05a9							.fill 	MaxLineSize+1
.05fa					numberBuffer:
>05fa							.fill 	34
.061c					decimalBuffer:
>061c							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 f8 aa	jsr $aaf8			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt display
.8008	a9 1f		lda #$1f			lda 	#(Prompt & $FF)
.800a	20 50 8e	jsr $8e50			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 12 ba	jsr $ba12			jsr 	SNDCommand
.8019	20 47 89	jsr $8947			jsr 	NewProgram 					; erase current program
.801c	4c 57 83	jmp $8357			jmp 	WarmStart
>801f	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>8027	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>8037	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8040	42 75 69 6c 74 20 57 65			.text "Built Wednesday 23-Nov-2022. Build 3579."
>8048	64 6e 65 73 64 61 79 20 32 33 2d 4e 6f 76 2d 32
>8058	30 32 32 2e 20 42 75 69 6c 64 20 33 35 37 39 2e

;******  Return to file: ./common/aa.system/00start.asm

>8068	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806b					AssembleGroup1:
.806b	a9 ff		lda #$ff			lda 	#$FF
.806d	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8070	80 02		bra $8074			bra 	AsmGroup12
.8072					AssembleGroup2:
.8072	a9 00		lda #$00			lda 	#$00
.8074					AsmGroup12:
.8074	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.8077	68		pla				pla 								; pop the return address to access the information following.
.8078	fa		plx				plx
.8079	20 02 81	jsr $8102			jsr 	AccessParameters 			; get opcode and save as base
.807c	8d a4 04	sta $04a4			sta 	BaseOpcode
.807f	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8082	d0 08		bne $808c			bne 	_AG12HaveMask
.8084	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8086	20 0a 81	jsr $810a			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8089	8d a5 04	sta $04a5			sta 	ModeMask
.808c					_AG12HaveMask:
.808c	20 45 82	jsr $8245			jsr 	TypeAndCalculateOperand 	; get zero page type
.808f	da		phx				phx 								; save found address mode
.8090	20 6e 81	jsr $816e			jsr 	AssembleModeX
.8093	fa		plx				plx  								; restore address mode
.8094	b0 0b		bcs $80a1			bcs 	_AG12Exit
.8096	20 a2 80	jsr $80a2			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8099	20 6e 81	jsr $816e			jsr 	AssembleModeX
.809c	b0 03		bcs $80a1			bcs 	_AG12Exit
.809e	4c 44 a0	jmp $a044			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a1					_AG12Exit:
.80a1	60		rts				rts
.80a2					PromoteToAbsolute:
.80a2	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a4	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a6	f0 19		beq $80c1			beq 	_PTADo
.80a8	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80aa	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80ac	f0 13		beq $80c1			beq 	_PTADo
.80ae	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b0	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b2	f0 0d		beq $80c1			beq 	_PTADo
.80b4	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b6	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b8	f0 07		beq $80c1			beq 	_PTADo
.80ba	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bc	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80be	f0 01		beq $80c1			beq 	_PTADo
.80c0	60		rts				rts
.80c1					_PTADo:
.80c1	aa		tax				tax
.80c2	60		rts				rts
.80c3					AssembleGroup3:
.80c3	68		pla				pla 								; get parameters, which is just the opcode.
.80c4	fa		plx				plx
.80c5	20 02 81	jsr $8102			jsr 	AccessParameters 			; get and output opcode
.80c8	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.80cb	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get a 16 bit operand
.80ce	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d1	38		sec				sec
.80d2	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d5	48		pha				pha 								; LSB in A
.80d6	ad 10 04	lda $0410			lda 	NSMantissa1
.80d9	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80dc	aa		tax				tax 								; MSB in X
.80dd	68		pla				pla
.80de	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80df	69 7f		adc #$7f			adc 	#$7F
.80e1	90 01		bcc $80e4			bcc 	_AG3NoCarry
.80e3	e8		inx				inx
.80e4					_AG3NoCarry:
.80e4	38		sec				sec 								; fix back and write out anyways.
.80e5	e9 80		sbc #$80			sbc 	#$80
.80e7	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.80ea	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ec	f0 0a		beq $80f8			beq 	_AG3Exit
.80ee	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f1	29 01		and #$01			and 	#1
.80f3	f0 03		beq $80f8			beq 	_AG3Exit
.80f5	4c 49 a0	jmp $a049			jmp 	RangeError 					; no, branch is out of range
.80f8					_AG3Exit:
.80f8	60		rts				rts
.80f9					AssembleGroup4:
.80f9	68		pla				pla 								; pop address
.80fa	fa		plx				plx
.80fb	20 02 81	jsr $8102			jsr 	AccessParameters 			; access and get first
.80fe	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte 			; output it.
.8101	60		rts				rts
.8102					AccessParameters:
.8102	8d a1 04	sta $04a1			sta 	ParamStart
.8105	8e a2 04	stx $04a2			stx 	ParamStart+1
.8108	a9 01		lda #$01			lda 	#1
.810a					GetParameter:
.810a	5a		phy				phy
.810b	a8		tay				tay
.810c	ad a1 04	lda $04a1			lda 	ParamStart
.810f	85 36		sta $36				sta 	zTemp0
.8111	ad a2 04	lda $04a2			lda 	ParamStart+1
.8114	85 37		sta $37				sta 	zTemp0+1
.8116	b1 36		lda ($36),y			lda 	(zTemp0),y
.8118	7a		ply				ply
.8119	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811a					AssemblerWriteByte:
.811a	48		pha			pha
.811b	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.811e	29 02		and #$02		and 	#2
.8120	f0 1b		beq $813d		beq 	_AWBNoPrint
.8122	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8125	20 58 81	jsr $8158		jsr 	PrintHex
.8128	ad 9e 04	lda $049e		lda		AssemblerAddress
.812b	20 58 81	jsr $8158		jsr 	PrintHex
.812e	a9 20		lda #$20		lda 	#' '
.8130	20 84 a8	jsr $a884		jsr 	EXTPrintCharacter
.8133	68		pla			pla 									; print byte
.8134	48		pha			pha
.8135	20 58 81	jsr $8158		jsr 	PrintHex
.8138	a9 0d		lda #$0d		lda 	#13
.813a	20 84 a8	jsr $a884		jsr 	EXTPrintCharacter
.813d					_AWBNoPrint:
.813d	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8140	85 36		sta $36			sta 	zTemp0
.8142	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8145	f0 0e		beq $8155		beq 	_AWBRange
.8147	85 37		sta $37			sta 	zTemp0+1
.8149	68		pla			pla 									; write byte out
.814a	92 36		sta ($36)		sta 	(zTemp0)
.814c	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.814f	d0 03		bne $8154		bne 	_AWBNoCarry
.8151	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8154					_AWBNoCarry:
.8154	60		rts			rts
.8155					_AWBRange:
.8155	4c 49 a0	jmp $a049		jmp 	RangeError
.8158					PrintHex:
.8158	48		pha				pha
.8159	4a		lsr a				lsr 	a
.815a	4a		lsr a				lsr 	a
.815b	4a		lsr a				lsr 	a
.815c	4a		lsr a				lsr 	a
.815d	20 61 81	jsr $8161			jsr 	_PrintNibble
.8160	68		pla				pla
.8161					_PrintNibble:
.8161	29 0f		and #$0f			and 	#15
.8163	c9 0a		cmp #$0a			cmp 	#10
.8165	90 02		bcc $8169			bcc 	_NoShift
.8167	69 06		adc #$06			adc 	#6
.8169					_NoShift:
.8169	69 30		adc #$30			adc 	#48
.816b	4c 84 a8	jmp $a884			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.816e					AssembleModeX:
.816e	5a		phy				phy
.816f	ad a3 04	lda $04a3			lda 	IsGroup1
.8172	f0 17		beq $818b			beq 	_AMXGroup2
.8174	8a		txa				txa 							; is it in group # 1
.8175	29 40		and #$40			and 	#AM_ISG1
.8177	f0 50		beq $81c9			beq 	_AMXFail 				; no, give up.
.8179	8a		txa				txa 							; get back.
.817a	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817c	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.817e	d0 22		bne $81a2			bne 	_AMXHaveInfo
.8180	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8183	c9 81		cmp #$81			cmp 	#$81
.8185	f0 42		beq $81c9			beq 	_AMXFail
.8187	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.8189	80 17		bra $81a2			bra 	_AMXHaveInfo 			; odd design decision there.
.818b					_AMXGroup2:
.818b	8a		txa				txa 							; is it in group 2 ?
.818c	29 20		and #$20			and 	#AM_ISG2
.818e	f0 39		beq $81c9			beq 	_AMXFail 				; no, give up.
.8190	8a		txa				txa 							; get the offset into Y
.8191	29 1f		and #$1f			and 	#$1F
.8193	4a		lsr a				lsr 	a 						; make it 0-7.
.8194	4a		lsr a				lsr  	a
.8195	a8		tay				tay
.8196	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.8199					_AMXCheckOkay:
.8199	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819a	88		dey				dey
.819b	10 fc		bpl $8199			bpl 	_AMXCheckOkay
.819d	90 2a		bcc $81c9			bcc 	_AMXFail 				; not allowed.
.819f	8a		txa				txa  							; get mask back
.81a0	29 1f		and #$1f			and 	#$1F
.81a2					_AMXHaveInfo:
.81a2	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a4	10 05		bpl $81ab			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a6	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81a9	d0 1e		bne $81c9			bne 	_AMXFail
.81ab					_AMXAnySize:
.81ab	18		clc				clc 							; add offset to the base opcode
.81ac	6d a4 04	adc $04a4			adc 	BaseOpcode
.81af					_AMXOutputCode:
.81af	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b2	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b4	f0 10		beq $81c6			beq 	_AMXExit
.81b6	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81b9	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.81bc	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81be	30 06		bmi $81c6			bmi 	_AMXExit
.81c0	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c3	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.81c6					_AMXExit:
.81c6	7a		ply				ply
.81c7	38		sec				sec
.81c8	60		rts				rts
.81c9					_AMXFail:
.81c9	a0 00		ldy #$00			ldy 	#0
.81cb					_AMXCheckOddities:
.81cb	8a		txa				txa
.81cc	d9 f4 81	cmp $81f4,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81cf	d0 16		bne $81e7			bne 	_AMXCONext
.81d1	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d4	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81d7	d0 0e		bne $81e7			bne 	_AMXCONext
.81d9	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81db	10 05		bpl $81e2			bpl 	_AMXCONotZero
.81dd	ad 10 04	lda $0410			lda 	NSMantissa1
.81e0	d0 05		bne $81e7			bne 	_AMXCONext
.81e2					_AMXCONotZero:
.81e2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e5	80 c8		bra $81af			bra 	_AMXOutputCode 			; and assemble it
.81e7					_AMXCONext:
.81e7	c8		iny				iny
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; end of table
.81ed	d0 dc		bne $81cb			bne 	_AMXCheckOddities
.81ef					_AMXCOFail:
.81ef	7a		ply				ply
.81f0	18		clc				clc
.81f1	60		rts				rts
.81f2					ExtraOpcode:
>81f2	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f5	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f8	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fb	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81fe	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8201	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8204	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8207	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820a	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820d	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8210	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8211					LabelHere:
.8211	c8		iny				iny 								; skip .
.8212	a2 00		ldx #$00			ldx 	#0 							; get a term
.8214	20 80 98	jsr $9880			jsr 	EvaluateTerm 				; get a term
.8217	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821a	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821c	d0 24		bne $8242			bne 	_ALType
.821e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8221	85 36		sta $36				sta 	zTemp0
.8223	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8226	85 37		sta $37				sta 	zTemp0+1
.8228	5a		phy				phy 								; copy address in.
.8229	a0 01		ldy #$01			ldy 	#1
.822b	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.822e	92 36		sta ($36)			sta 	(zTemp0)
.8230	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8233	91 36		sta ($36),y			sta 	(zTemp0),y
.8235	c8		iny				iny
.8236	a9 00		lda #$00			lda 	#0
.8238	91 36		sta ($36),y			sta 	(zTemp0),y
.823a	c8		iny				iny
.823b	91 36		sta ($36),y			sta 	(zTemp0),y
.823d	c8		iny				iny
.823e	91 36		sta ($36),y			sta 	(zTemp0),y
.8240	7a		ply				ply
.8241	60		rts				rts
.8242					_ALType:
.8242	4c 4e a0	jmp $a04e			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8245					TypeAndCalculateOperand:
.8245	b1 30		lda ($30),y			lda 	(codePtr),y
.8247	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8249	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824b	f0 5b		beq $82a8			beq 	_TACOExit
.824d	c9 80		cmp #$80			cmp 	#KWC_EOL
.824f	f0 57		beq $82a8			beq 	_TACOExit
.8251	c8		iny				iny
.8252	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8254	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8256	f0 51		beq $82a9			beq 	CalculateOperand
.8258	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825a	f0 1f		beq $827b			beq 	_TACOIndirect
.825c	88		dey				dey 								; undo get of first character
.825d	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get operand
.8260	b1 30		lda ($30),y			lda 	(codePtr),y
.8262	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8264	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8266	d0 40		bne $82a8			bne 	_TACOExit
.8268	c8		iny				iny
.8269	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826c	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826e	c9 58		cmp #$58			cmp 	#'X'
.8270	f0 36		beq $82a8			beq 	_TACOExit
.8272	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8274	c9 59		cmp #$59			cmp 	#'Y'
.8276	f0 30		beq $82a8			beq 	_TACOExit
.8278					_TACOSyntax:
.8278	4c 44 a0	jmp $a044			jmp 	SyntaxError
.827b					_TACOIndirect:
.827b	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get the operand
.827e	b1 30		lda ($30),y			lda 	(codePtr),y
.8280	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8282	f0 17		beq $829b			beq 	_TACOIndX
.8284	20 de 8d	jsr $8dde			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8287	b1 30		lda ($30),y			lda 	(codePtr),y
.8289	a2 d1		ldx #$d1			ldx 	#AM_IND
.828b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828d	d0 19		bne $82a8			bne 	_TACOExit
.828f	c8		iny				iny
.8290	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8293	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8295	d0 e1		bne $8278			bne 	_TACOSyntax
.8297	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8299	80 0d		bra $82a8			bra 	_TACOExit
.829b					_TACOIndX:
.829b	c8		iny				iny
.829c	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.829f	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a1	d0 d5		bne $8278			bne 	_TACOSyntax
.82a3	20 de 8d	jsr $8dde			jsr 	CheckRightBracket			; check )
.82a6	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a8					_TACOExit:
.82a8	60		rts				rts
.82a9					CalculateOperand:
.82a9	48		pha				pha
.82aa	da		phx				phx
.82ab	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ad	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger
.82b0	fa		plx				plx
.82b1	68		pla				pla
.82b2	60		rts				rts
.82b3					TACOCheckXY:
.82b3	b1 30		lda ($30),y			lda 	(codePtr),y
.82b5	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b7	c9 40		cmp #$40			cmp 	#$40
.82b9	d0 21		bne $82dc			bne 	_TCXYFail
.82bb	b1 30		lda ($30),y			lda 	(codePtr),y
.82bd	18		clc				clc
.82be	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c0	85 37		sta $37				sta 	zTemp0+1
.82c2	c8		iny				iny
.82c3	b1 30		lda ($30),y			lda 	(codePtr),y
.82c5	c8		iny				iny
.82c6	85 36		sta $36				sta 	zTemp0
.82c8	5a		phy				phy 								; save position
.82c9	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cb	b1 36		lda ($36),y			lda 	(zTemp0),y
.82cd	d0 0c		bne $82db			bne 	_TCXYPopFail
.82cf	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d1	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d3	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d5	f0 08		beq $82df			beq 	_TCXYFound
.82d7	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82d9	f0 04		beq $82df			beq 	_TCXYFound
.82db					_TCXYPopFail:
.82db	7a		ply				ply
.82dc					_TCXYFail:
.82dc	a9 00		lda #$00			lda 	#0
.82de	60		rts				rts
.82df					_TCXYFound:
.82df	7a		ply				ply 								; restore position
.82e0	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e3					BackloadProgram:
.82e3	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e5	8d 2c 06	sta $062c			sta 	0+BackLoadPointer
.82e8	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82ea	8d 2d 06	sta $062d			sta 	1+BackLoadPointer
.82ed					_BPLoop:
.82ed	a2 ff		ldx #$ff			ldx 	#$FF
.82ef	20 1b 83	jsr $831b			jsr 	BLReadByte 					; read a byte
.82f2	c9 00		cmp #$00			cmp 	#0
.82f4	f0 21		beq $8317			beq 	_BPExit 					; if 0 exit
.82f6	30 1f		bmi $8317			bmi 	_BPExit 					; if -ve exit
.82f8					_BPCopy:
.82f8	e8		inx				inx  								; copy byte into the lineBuffer
.82f9	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.82fc	9e aa 05	stz $05aa,x			stz 	lineBuffer+1,x
.82ff	20 1b 83	jsr $831b			jsr 	BLReadByte 					; read next byte
.8302	30 0a		bmi $830e			bmi 	_BPEndLine 					; -ve = EOL
.8304	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8306	d0 02		bne $830a			bne 	_BPNotTab
.8308	a9 20		lda #$20			lda 	#' '
.830a					_BPNotTab:
.830a	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.830c	b0 ea		bcs $82f8			bcs 	_BPCopy 					; until a control character, should be 13 received.
.830e					_BPEndLine:
.830e	20 a2 b6	jsr $b6a2			jsr 	TokeniseLine 				; tokenise the line.
.8311	38		sec				sec 								; append not insert
.8312	20 c0 a5	jsr $a5c0			jsr 	MemoryInsertLine 			; append to current program
.8315	80 d6		bra $82ed			bra 	_BPLoop
.8317					_BPExit:
.8317	20 f0 83	jsr $83f0			jsr 	ClearCommand 				; clear variables etc.
.831a	60		rts				rts
.831b					BLReadByte:
.831b	ad 2c 06	lda $062c			lda 	BackLoadPointer 			; copy pointer to zTemp0
.831e	85 36		sta $36				sta 	zTemp0
.8320	ad 2d 06	lda $062d			lda 	BackLoadPointer+1
.8323	85 37		sta $37				sta 	zTemp0+1
.8325	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8327	ee 2c 06	inc $062c			inc 	BackLoadPointer 			; bump pointer
.832a	d0 03		bne $832f			bne 	_BLNoCarry
.832c	ee 2d 06	inc $062d			inc 	BackLoadPointer+1
.832f					_BLNoCarry:
.832f	c9 00		cmp #$00			cmp 	#0
.8331	60		rts				rts
.062c					BackLoadPointer:
>062c							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8332					EditProgramCode:
.8332	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line.
.8335	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1
.8338	20 68 a6	jsr $a668			jsr 	MemorySearch
.833b	90 05		bcc $8342			bcc 	_EPCNoDelete 				; reached the end don't delete
.833d	d0 03		bne $8342			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.833f	20 89 a5	jsr $a589			jsr 	MemoryDeleteLine 			; delete the line
.8342					_EPCNoDelete:
.8342	ad ac 04	lda $04ac			lda 	TokenBuffer 				; buffer empty
.8345	c9 80		cmp #$80			cmp 	#KWC_EOL
.8347	f0 0d		beq $8356			beq 	_EPCNoInsert
.8349	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line - it cannot exist.
.834c	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.834f	20 68 a6	jsr $a668			jsr 	MemorySearch
.8352	18		clc				clc 								; insert at this point.
.8353	20 c0 a5	jsr $a5c0			jsr 	MemoryInsertLine 			; insert the line
.8356					_EPCNoInsert:
.8356	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8357					WarmStart:
.8357	a2 ff		ldx #$ff			ldx 	#$FF
.8359	9a		txs				txs
.835a	20 12 aa	jsr $aa12			jsr 	EXTInputLine 				; get line to lineBuffer
.835d	20 a2 b6	jsr $b6a2			jsr 	TokeniseLine 				; tokenise the line
.8360	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; line number ?
.8363	0d ab 04	ora $04ab			ora 	TokenLineNumber+1
.8366	d0 17		bne $837f			bne 	_WSEditCode 				; if so,edit code.
.8368	9c a9 04	stz $04a9			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.836b	a9 a9		lda #$a9			lda 	#((TokenOffset) & $FF)
.836d	85 30		sta $30				sta 	codePtr
.836f	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8371	85 31		sta $31				sta 	codePtr+1
.8373	ad ac 04	lda $04ac			lda 	TokenBuffer 				; nothing to run
.8376	c9 80		cmp #$80			cmp 	#KWC_EOL
.8378	f0 dd		beq $8357			beq 	WarmStart
.837a	20 98 8a	jsr $8a98			jsr 	RUNCodePointerLine 			; execute that line.
.837d	80 d8		bra $8357			bra 	WarmStart
.837f					_WSEditCode:
.837f	20 32 83	jsr $8332			jsr 	EditProgramCode
.8382	20 f0 83	jsr $83f0			jsr 	ClearCommand
.8385	80 d0		bra $8357			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8387					AssembleCommand:
.8387	a2 00		ldx #$00			ldx 	#0
.8389	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger 		; start address
.838c	ad 08 04	lda $0408			lda 	NSMantissa0
.838f	8d 9e 04	sta $049e			sta 	AssemblerAddress
.8392	ad 10 04	lda $0410			lda 	NSMantissa1
.8395	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.8398	20 e6 8d	jsr $8de6			jsr 	CheckComma
.839b	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; options
.839e	ad 08 04	lda $0408			lda 	NSMantissa0
.83a1	8d a0 04	sta $04a0			sta 	AssemblerControl
.83a4	60		rts				rts
.83a5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83a6					AssertCommand:
.83a6	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83a8	20 06 9e	jsr $9e06			jsr 	EvaluateInteger 			; the assert test
.83ab	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; exit if result is non zero.
.83ae	d0 05		bne $83b5			bne 	_ACExit
.83b0	a9 0a		lda #$0a		lda	#10
.83b2	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.83b5					_ACExit:
.83b5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83b6					CallCommand:
.83b6	a2 00		ldx #$00			ldx 	#0
.83b8	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger
.83bb					_CCClear
.83bb	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83bc	20 ba 9e	jsr $9eba			jsr 	NSMSetZero
.83bf	e0 04		cpx #$04			cpx 	#4
.83c1	d0 f8		bne $83bb			bne 	_CCClear
.83c3	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83c5					_CCCParam:
.83c5	b1 30		lda ($30),y			lda 	(codePtr),y
.83c7	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83c9	d0 09		bne $83d4			bne 	_CCCRun6502
.83cb	c8		iny				iny 								; skip comma
.83cc	e8		inx				inx	 								; next level
.83cd	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83d0	e0 03		cpx #$03			cpx 	#3
.83d2	90 f1		bcc $83c5			bcc 	_CCCParam 					; done all 3 ?
.83d4					_CCCRun6502:
.83d4	5a		phy				phy 								; save position
.83d5	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83d8	85 37		sta $37				sta 	zTemp0+1
.83da	ad 08 04	lda $0408			lda 	NSMantissa0
.83dd	85 36		sta $36				sta 	zTemp0
.83df	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83e2	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83e5	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83e8	20 ed 83	jsr $83ed			jsr 	_CCCZTemp0 					; call zTemp0
.83eb	7a		ply				ply 								; restore position and exit
.83ec	60		rts				rts
.83ed					_CCCZTemp0:
.83ed	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83f0					ClearCommand:
.83f0	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83f2	85 36		sta $36				sta 	0+zTemp0
.83f4	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f6	85 37		sta $37				sta 	1+zTemp0
.83f8					_ClearZeroLoop:
.83f8	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.83fa	f0 24		beq $8420			beq 	_ClearZeroEnd
.83fc	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83fe	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8400					_ClearOneVariable:
.8400	91 36		sta ($36),y			sta 	(zTemp0),y
.8402	c8		iny				iny
.8403	c0 08		cpy #$08			cpy 	#8
.8405	d0 f9		bne $8400			bne 	_ClearOneVariable
.8407	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8409	b1 36		lda ($36),y			lda 	(zTemp0),y
.840b	c9 18		cmp #$18			cmp 	#NSTProcedure
.840d	d0 04		bne $8413			bne 	_ClearNotProcedure
.840f	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8411	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8413					_ClearNotProcedure:
.8413	18		clc				clc 								; go to the next variable
.8414	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8416	65 36		adc $36				adc 	zTemp0
.8418	85 36		sta $36				sta 	zTemp0
.841a	90 dc		bcc $83f8			bcc 	_ClearZeroLoop
.841c	e6 37		inc $37				inc 	zTemp0+1
.841e	80 d8		bra $83f8			bra 	_ClearZeroLoop
.8420					_ClearZeroEnd:
.8420	18		clc				clc
.8421	a5 36		lda $36				lda 	zTemp0
.8423	69 01		adc #$01			adc 	#1
.8425	8d 8c 04	sta $048c			sta 	lowMemPtr
.8428	a5 37		lda $37				lda 	zTemp0+1
.842a	69 00		adc #$00			adc 	#0
.842c	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.842f	20 a9 a7	jsr $a7a9			jsr 	StackReset
.8432	20 13 a8	jsr $a813			jsr 	StringSystemInitialise
.8435	20 e7 8c	jsr $8ce7			jsr 	ProcedureScan
.8438	20 47 8a	jsr $8a47			jsr 	Command_Restore
.843b	9c 9e 04	stz $049e			stz 	AssemblerAddress
.843e	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.8441	9c a0 04	stz $04a0			stz 	AssemblerControl
.8444	20 83 9a	jsr $9a83			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8447	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8448					ClearScreen:
.8448	5a		phy				phy
.8449	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.844b	20 84 a8	jsr $a884			jsr 	EXTPrintCharacter
.844e	7a		ply				ply
.844f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8450					Command_Data:
.8450	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8452	a2 80		ldx #$80			ldx 	#KWC_EOL
.8454	20 39 8d	jsr $8d39			jsr 	ScanForward
.8457	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8458					DimCommand:
.8458	b1 30		lda ($30),y			lda 	(codePtr),y
.845a	29 c0		and #$c0			and 	#$C0
.845c	c9 40		cmp #$40			cmp 	#$40
.845e	d0 7a		bne $84da			bne 	_DCSyntax
.8460	b1 30		lda ($30),y			lda 	(codePtr),y
.8462	18		clc				clc
.8463	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8465	85 3f		sta $3f				sta 	zaTemp+1
.8467	c8		iny				iny
.8468	b1 30		lda ($30),y			lda 	(codePtr),y
.846a	c8		iny				iny
.846b	85 3e		sta $3e				sta 	zaTemp
.846d	5a		phy				phy
.846e	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8470	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8472	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8474	c9 18		cmp #$18			cmp 	#NSTProcedure
.8476	f0 62		beq $84da			beq 	_DCSyntax
.8478	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.847a	29 04		and #$04			and 	#NSBIsArray
.847c	f0 64		beq $84e2			beq 	_DCType
.847e	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8480	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8482	d0 59		bne $84dd			bne 	_DCRedefine
.8484	7a		ply				ply
.8485	20 e5 84	jsr $84e5			jsr 	_DCGetSize 				; get array size, check it.
.8488	5a		phy				phy
.8489	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.848b	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.848d	7a		ply				ply 							; is there a second (e.g. ,x)
.848e	b1 30		lda ($30),y			lda 	(codePtr),y
.8490	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8492	d0 0a		bne $849e			bne 	_DCOneDimension
.8494	c8		iny				iny 							; skip comma
.8495	20 e5 84	jsr $84e5			jsr 	_DCGetSize 				; get 2nd array size
.8498	5a		phy				phy
.8499	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.849b	91 3e		sta ($3e),y			sta 	(zaTemp),y
.849d	7a		ply				ply
.849e					_DCOneDimension:
.849e	5a		phy				phy 							; save position
.849f	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84a1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a3	aa		tax				tax
.84a4	c8		iny				iny
.84a5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a7	e8		inx				inx 							; bump them.
.84a8	1a		inc a				inc 	a
.84a9	20 4f 9e	jsr $9e4f			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84ac	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84ae	29 e0		and #$e0			and 	#$E0
.84b0	d0 23		bne $84d5			bne 	_DCSize
.84b2	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b6	20 f3 84	jsr $84f3			jsr 	ScaleByBaseType 		; scale by base type
.84b9	a5 36		lda $36				lda 	zTemp0
.84bb	a6 37		ldx $37				ldx 	zTemp0+1
.84bd	20 45 9a	jsr $9a45			jsr 	AllocateXABytes 		; allocate memory
.84c0	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84c2	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c4	c8		iny				iny
.84c5	8a		txa				txa
.84c6	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c8	7a		ply				ply 							; get position back
.84c9	20 de 8d	jsr $8dde			jsr 	CheckRightBracket 		; check )
.84cc	b1 30		lda ($30),y			lda 	(codePtr),y
.84ce	c8		iny				iny 							; consume in case
.84cf	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84d1	f0 85		beq $8458			beq 	DimCommand
.84d3	88		dey				dey 							; undo consume
.84d4	60		rts				rts
.84d5					_DCSize:
.84d5	a9 16		lda #$16		lda	#22
.84d7	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.84da					_DCSyntax:
.84da	4c 44 a0	jmp $a044			jmp 	SyntaxError
.84dd					_DCRedefine:
.84dd	a9 15		lda #$15		lda	#21
.84df	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.84e2					_DCType:
.84e2	4c 4e a0	jmp $a04e			jmp 	TypeError
.84e5					_DCGetSize:
.84e5	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84e7	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 	; get array dimension
.84ea	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84ec	f0 e7		beq $84d5			beq 	_DCSize
.84ee	c9 fe		cmp #$fe			cmp 	#254
.84f0	f0 e3		beq $84d5			beq 	_DCSize
.84f2	60		rts				rts
.84f3					ScaleByBaseType:
.84f3	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f5	d0 19		bne $8510			bne 	_SBBTString
.84f7	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84f9	48		pha				pha
.84fa	a5 36		lda $36				lda 	zTemp0
.84fc	48		pha				pha
.84fd	06 36		asl $36				asl 	zTemp0 					; x 2
.84ff	26 37		rol $37				rol 	zTemp0+1
.8501	06 36		asl $36				asl 	zTemp0 					; x 4
.8503	26 37		rol $37				rol 	zTemp0+1
.8505	68		pla				pla 							; add stacked value = x 5
.8506	65 36		adc $36				adc 	zTemp0
.8508	85 36		sta $36				sta 	zTemp0
.850a	68		pla				pla
.850b	65 37		adc $37				adc 	zTemp0+1
.850d	85 37		sta $37				sta 	zTemp0+1
.850f	60		rts				rts
.8510					_SBBTString:
.8510	06 36		asl $36				asl 	zTemp0
.8512	26 37		rol $37				rol 	zTemp0+1
.8514	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8515					EndCommand:
.8515	4c 57 83	jmp $8357			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8518					ForCommand:
.8518	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.851a	20 44 a7	jsr $a744			jsr 	StackOpen
.851d	a2 00		ldx #$00			ldx 	#0
.851f	20 80 98	jsr $9880			jsr 	EvaluateTerm
.8522	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8525	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8527	d0 49		bne $8572			bne		_FCError
.8529	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.852b	20 ee 8d	jsr $8dee			jsr 	CheckNextA
.852e	e8		inx				inx
.852f	20 06 9e	jsr $9e06			jsr 	EvaluateInteger 			; <from> in +1
.8532	b1 30		lda ($30),y			lda 	(codePtr),y
.8534	c8		iny				iny 								; consume it
.8535	48		pha				pha 								; save on stack for later
.8536	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8538	f0 04		beq $853e			beq 	_FCNoSyntax
.853a	c9 ce		cmp #$ce			cmp 	#KWD_TO
.853c	d0 37		bne $8575			bne 	_FCSyntaxError
.853e					_FCNoSyntax:
.853e	e8		inx				inx
.853f	20 06 9e	jsr $9e06			jsr 	EvaluateInteger
.8542	20 88 a7	jsr $a788			jsr 	STKSaveCodePosition 		; save loop back position
.8545	68		pla				pla 								; restore DOWNTO or TO
.8546	5a		phy				phy 								; save Y on the stack
.8547	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8549	f0 02		beq $854d			beq 	_FCNotDownTo
.854b	a9 02		lda #$02			lda 	#2
.854d					_FCNotDownTo:
.854d	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.854e	a0 10		ldy #$10			ldy 	#16
.8550	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8552	a0 06		ldy #$06			ldy 	#6
.8554	ad 08 04	lda $0408			lda 	NSMantissa0
.8557	91 34		sta ($34),y			sta 	(basicStack),y
.8559	ad 10 04	lda $0410			lda 	NSMantissa1
.855c	c8		iny				iny
.855d	91 34		sta ($34),y			sta 	(basicStack),y
.855f	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8561	a2 01		ldx #$01			ldx 	#1
.8563	20 78 85	jsr $8578			jsr 	FCIntegerToStack
.8566	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8568	a2 02		ldx #$02			ldx 	#2
.856a	20 78 85	jsr $8578			jsr 	FCIntegerToStack
.856d	20 98 85	jsr $8598			jsr 	CopyIndexToReference
.8570	7a		ply				ply 								; restore position
.8571	60		rts				rts
.8572					_FCError:
.8572	4c 4e a0	jmp $a04e			jmp 	TypeError
.8575					_FCSyntaxError:
.8575	4c 44 a0	jmp $a044			jmp 	SyntaxError
.8578					FCIntegerToStack:
.8578	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.857b	10 03		bpl $8580			bpl	 	_FCNotNegative
.857d	20 6f 9e	jsr $9e6f			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8580					_FCNotNegative:
.8580	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8583	91 34		sta ($34),y			sta 	(basicStack),y
.8585	c8		iny				iny
.8586	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8589	91 34		sta ($34),y			sta 	(basicStack),y
.858b	c8		iny				iny
.858c	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.858f	91 34		sta ($34),y			sta 	(basicStack),y
.8591	c8		iny				iny
.8592	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.8595	91 34		sta ($34),y			sta 	(basicStack),y
.8597	60		rts				rts
.8598					CopyIndexToReference:
.8598	5a		phy				phy
.8599	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.859b	38		sec				sec 								; (because we copy from offset 8)
.859c	b1 34		lda ($34),y			lda 	(basicStack),y
.859e	e9 08		sbc #$08			sbc 	#8
.85a0	85 36		sta $36				sta 	zTemp0
.85a2	c8		iny				iny
.85a3	b1 34		lda ($34),y			lda 	(basicStack),y
.85a5	e9 00		sbc #$00			sbc 	#0
.85a7	85 37		sta $37				sta 	zTemp0+1
.85a9	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85ab	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85ad	b1 34		lda ($34),y			lda 	(basicStack),y
.85af	0a		asl a				asl 	a 							; into carry
.85b0	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85b2	90 14		bcc $85c8			bcc 	_CITRNormal
.85b4	38		sec				sec
.85b5					_CITRNegative:
.85b5	a9 00		lda #$00			lda 	#0
.85b7	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85b9	91 36		sta ($36),y			sta 	(zTemp0),y
.85bb	c8		iny				iny
.85bc	ca		dex				dex
.85bd	d0 f6		bne $85b5			bne 	_CITRNegative
.85bf	88		dey				dey 								; look at MSB of mantissa
.85c0	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85c2	09 80		ora #$80			ora 	#$80
.85c4	91 36		sta ($36),y			sta 	(zTemp0),y
.85c6	7a		ply				ply
.85c7	60		rts				rts
.85c8					_CITRNormal:
.85c8	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85ca	91 36		sta ($36),y			sta 	(zTemp0),y
.85cc	c8		iny				iny
.85cd	ca		dex				dex
.85ce	d0 f8		bne $85c8			bne 	_CITRNormal
.85d0	7a		ply				ply 								; and exit.
.85d1	60		rts				rts
.85d2					NextCommand:
.85d2	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85d4	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d6	20 70 a7	jsr $a770			jsr 	StackCheckFrame
.85d9	5a		phy				phy
.85da	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85dc	b1 34		lda ($34),y			lda 	(basicStack),y
.85de	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85e0	30 02		bmi $85e4			bmi 	_NCStepNeg
.85e2	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85e4					_NCStepNeg:
.85e4	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e6	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85e8	18		clc				clc
.85e9					_NCBump:
.85e9	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85eb	91 34		sta ($34),y			sta 	(basicStack),y
.85ed	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85ef	c8		iny				iny 								; next byte
.85f0	ca		dex				dex 								; do four times
.85f1	d0 f6		bne $85e9			bne 	_NCBump
.85f3	20 98 85	jsr $8598			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f6	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85f8	b1 34		lda ($34),y			lda 	(basicStack),y
.85fa	0a		asl a				asl 	a 							; sign bit to carry
.85fb	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85fd	85 38		sta $38				sta 	zTemp1
.85ff	90 02		bcc $8603			bcc 	_NCCompRev 					; use if step is +ve
.8601	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8603					_NCCompRev:
.8603	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8605	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8607	85 39		sta $39				sta 	zTemp1+1
.8609	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.860b	38		sec				sec
.860c					_NCCompare:
.860c	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.860e	b1 34		lda ($34),y			lda 	(basicStack),y
.8610	a4 39		ldy $39				ldy 	zTemp1+1
.8612	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8614	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8616	e6 39		inc $39				inc 	zTemp1+1
.8618	ca		dex				dex 								; do it 4 times.
.8619	d0 f1		bne $860c			bne 	_NCCompare
.861b	50 02		bvc $861f			bvc 	_NCNoOverflow 				; convert to signed comparison
.861d	49 80		eor #$80			eor 	#$80
.861f					_NCNoOverflow:
.861f	7a		ply				ply 								; restore Y position
.8620	0a		asl a				asl 	a 							; is bit 7 set.
.8621	90 04		bcc $8627			bcc 	_NCLoopback 				; if no , >= so loop back
.8623	20 62 a7	jsr $a762			jsr 	StackClose 					; exit the loop
.8626	60		rts				rts
.8627					_NCLoopBack:
.8627	20 99 a7	jsr $a799			jsr 	STKLoadCodePosition 		; loop back
.862a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.862b					Command_GOSUB:
.862b	a2 00		ldx #$00			ldx 	#0
.862d	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8630	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8632	20 44 a7	jsr $a744			jsr 	StackOpen 					; create frame
.8635	20 88 a7	jsr $a788			jsr 	STKSaveCodePosition 		; save current position
.8638	4c 4e 86	jmp $864e			jmp 	GotoStackX
.863b					Command_RETURN:
.863b	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.863d	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.863f	20 70 a7	jsr $a770			jsr 	StackCheckFrame
.8642	20 99 a7	jsr $a799			jsr 	STKLoadCodePosition 		; restore code position
.8645	20 62 a7	jsr $a762			jsr 	StackClose
.8648	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8649					GotoCommand:
.8649	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.864b	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger
.864e					GotoStackX:
.864e	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8651	48		pha				pha 								; it is slightly inefficient, just in cases.
.8652	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8655	fa		plx				plx
.8656	20 68 a6	jsr $a668			jsr 	MemorySearch 				; transfer to line number AX.
.8659	90 05		bcc $8660			bcc 	_GotoError 					; not found, off end.
.865b	d0 03		bne $8660			bne 	_GotoError 					; not found exactly
.865d	4c 91 8a	jmp $8a91			jmp 	RunNewLine 					; and go straight to new line code.
.8660					_GotoError:
.8660	a9 0d		lda #$0d		lda	#13
.8662	4c f7 8d	jmp $8df7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8665					IfCommand:
.8665	a2 00		ldx #$00			ldx 	#0 							; If what.
.8667	20 e3 9d	jsr $9de3			jsr 	EvaluateNumber
.866a	b1 30		lda ($30),y			lda 	(codePtr),y
.866c	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.866e	d0 0a		bne $867a			bne 	_IFStructured
.8670	c8		iny				iny 								; consume THEN
.8671	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; is it zero
.8674	f0 01		beq $8677			beq 	_IfFail 					; if fail, go to next line
.8676	60		rts				rts 								; if THEN just continue
.8677					_IfFail:
.8677	4c 79 8a	jmp $8a79			jmp 	EOLCommand
.867a					_IfStructured:
.867a	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; is it zero
.867d	d0 07		bne $8686			bne 	_IfExit 					; if not, then continue normally.
.867f	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8681	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8683	20 39 8d	jsr $8d39			jsr 	ScanForward 				; and run from there/
.8686					_IfExit:
.8686	60		rts				rts
.8687					ElseCode:
.8687	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8689	aa		tax				tax 								; so just go to the structure exit
.868a	20 39 8d	jsr $8d39			jsr 	ScanForward
.868d	60		rts				rts
.868e					EndIf:
.868e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.868f					Command_Input:
.868f	a9 ff		lda #$ff			lda 	#$FF
.8691	8d a8 04	sta $04a8			sta 	IsInputFlag
.8694	80 03		bra $8699			bra 	Command_IP_Main
.8696					Command_Print:
.8696	9c a8 04	stz $04a8			stz 	IsInputFlag
.8699					Command_IP_Main:
.8699	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.869a					_CPLoop:
.869a	08		php				php 								; save last action flag
.869b	b1 30		lda ($30),y			lda 	(codePtr),y
.869d	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.869f	f0 58		beq $86f9			beq 	_CPExit
.86a1	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86a3	f0 54		beq $86f9			beq 	_CPExit
.86a5	68		pla				pla 								; throw last action flag
.86a6	b1 30		lda ($30),y			lda 	(codePtr),y
.86a8	c8		iny				iny
.86a9	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86ab	f0 49		beq $86f6			beq 	_CPContinueWithSameLine
.86ad	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86af	f0 40		beq $86f1			beq 	_CPTab
.86b1	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86b3	f0 38		beq $86ed			beq 	_CPNewLine
.86b5	88		dey				dey 								; undo the get.
.86b6	20 a4 93	jsr $93a4			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86b9	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; read the status
.86bc	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86be	f0 0d		beq $86cd			beq 	_CPIsValue
.86c0	ad a8 04	lda $04a8			lda 	IsInputFlag 				; if print, dereference and print.
.86c3	f0 05		beq $86ca			beq 	_CPIsPrint
.86c5	20 02 87	jsr $8702			jsr 	CIInputValue 				; input a value to the reference
.86c8	80 23		bra $86ed			bra 	_CPNewLine
.86ca					_CPIsPrint:
.86ca	20 c4 96	jsr $96c4			jsr 	Dereference
.86cd					_CPIsValue:
.86cd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.86d0	29 10		and #$10			and 	#NSBIsString
.86d2	f0 0b		beq $86df			beq 	_CPNumber
.86d4	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.86d7	ad 08 04	lda $0408			lda 	NSMantissa0
.86da	20 6b 87	jsr $876b			jsr 	CPPrintStringXA
.86dd	80 ba		bra $8699			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86df					_CPNumber:
.86df	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86e1	20 b0 9c	jsr $9cb0			jsr 	ConvertNumberToString 		; convert to string
.86e4	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.86e6	a9 1c		lda #$1c			lda 	#DecimalBuffer & $FF
.86e8	20 6b 87	jsr $876b			jsr 	CPPrintStringXA
.86eb	80 ac		bra $8699			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86ed					_CPNewLine:
.86ed	a9 0d		lda #$0d			lda 	#13
.86ef	80 02		bra $86f3			bra 	_CPPrintChar
.86f1					_CPTab:
.86f1	a9 09		lda #$09			lda 	#9 							; print TAB
.86f3					_CPPrintChar:
.86f3	20 7e 87	jsr $877e			jsr 	CPPrintVector
.86f6					_CPContinueWithSameLine:
.86f6	38		sec				sec 								; loop round with carry set, which
.86f7	80 a1		bra $869a			bra 	_CPLoop 					; will inhibit final CR
.86f9					_CPExit:
.86f9	28		plp				plp 								; get last action flag
.86fa	b0 05		bcs $8701			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.86fc	a9 0d		lda #$0d			lda 	#13 						; print new line
.86fe	20 7e 87	jsr $877e			jsr 	CPPrintVector
.8701					_CPExit2:
.8701	60		rts				rts
.8702					CIInputValue:
.8702	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8704					_CIInputLine:
.8704	20 81 87	jsr $8781			jsr 	CPInputVector 				; get key
.8707	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8709	f0 1f		beq $872a			beq 	_CIHaveValue
.870b	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.870d	f0 11		beq $8720			beq 	_CIBackspace
.870f	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8711	90 f1		bcc $8704			bcc 	_CIInputLine
.8713	e0 50		cpx #$50			cpx 	#80 						; max length
.8715	b0 ed		bcs $8704			bcs 	_CIInputLine
.8717	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.871a	e8		inx				inx
.871b	20 7e 87	jsr $877e			jsr 	CPPrintVector 				; echo it.
.871e	80 e4		bra $8704			bra 	_CIInputLine
.8720					_CIBackSpace:
.8720	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8722	f0 e0		beq $8704			beq 	_CIInputLine
.8724	20 7e 87	jsr $877e			jsr 	CPPrintVector 				; echo it.
.8727	ca		dex				dex
.8728	80 da		bra $8704			bra 	_CIInputLine
.872a					_CIHaveValue:
.872a	9e a9 05	stz $05a9,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.872d	ad 00 04	lda $0400			lda 	NSStatus 					; was it a string assignment
.8730	29 10		and #$10			and 	#NSBIsString
.8732	f0 1c		beq $8750			beq 	_CIAssignNumber 			; assign a number
.8734	a2 01		ldx #$01			ldx 	#1
.8736	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.8738	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.873b	a9 05		lda #$05			lda 	#lineBuffer >> 8
.873d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8740	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.8743	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.8746	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8748	9d 00 04	sta $0400,x			sta  	NSStatus,x
.874b	ca		dex				dex 								; X = 0
.874c	20 c0 87	jsr $87c0			jsr 	AssignVariable
.874f	60		rts				rts
.8750					_CIAssignNumber:
.8750	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.8752	85 36		sta $36				sta 	zTemp0
.8754	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8756	85 37		sta $37				sta 	zTemp0+1
.8758	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.875a	20 32 9c	jsr $9c32			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.875d	90 07		bcc $8766			bcc 	_CIIsOkay
.875f	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8761	20 7e 87	jsr $877e			jsr 	CPPrintVector
.8764	80 9c		bra $8702			bra 	CIInputValue
.8766					_CIIsOkay:
.8766	ca		dex				dex 								; X = 0
.8767	20 c0 87	jsr $87c0			jsr 	AssignVariable
.876a	60		rts				rts
.876b					CPPrintStringXA:
.876b	5a		phy				phy
.876c	86 37		stx $37				stx 	zTemp0+1
.876e	85 36		sta $36				sta 	zTemp0
.8770	a0 00		ldy #$00			ldy 	#0
.8772					_PSXALoop:
.8772	b1 36		lda ($36),y			lda 	(zTemp0),y
.8774	f0 06		beq $877c			beq 	_PSXAExit
.8776	20 7e 87	jsr $877e			jsr 	CPPrintVector
.8779	c8		iny				iny
.877a	80 f6		bra $8772			bra 	_PSXALoop
.877c					_PSXAExit:
.877c	7a		ply				ply
.877d	60		rts				rts
.877e					CPPrintVector:
.877e	4c 84 a8	jmp $a884			jmp 	EXTPrintCharacter
.8781					CPInputVector:
.8781	4c 1a ab	jmp $ab1a			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8784					LetCommand:
.8784	a2 00		ldx #$00			ldx 	#0
.8786	b1 30		lda ($30),y			lda 	(codePtr),y
.8788	c9 10		cmp #$10			cmp 	#KWD_AT
.878a	d0 16		bne $87a2			bne 	_LCStandard
.878c	c8		iny				iny 								; skip equal
.878d	20 80 98	jsr $9880			jsr 	EvaluateTerm 				; get a number
.8790	20 c4 96	jsr $96c4			jsr 	Dereference 				; dereference it
.8793	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.8796	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8798	9d 00 04	sta $0400,x			sta 	NSStatus,x
.879b	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.879d	d0 10		bne $87af			bne 	_LCMain
.879f	4c 4e a0	jmp $a04e			jmp 	TypeError 					; was a reference before.
.87a2					_LCStandard:
.87a2	ad 8e 93	lda $938e			lda 	PrecedenceLevel+"*"			; precedence > this
.87a5	20 a8 93	jsr $93a8			jsr 	EvaluateExpressionAtPrecedence
.87a8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.87ab	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87ad	f0 0e		beq $87bd			beq 	_LetGoProc 					; it's a procedure call.
.87af					_LCMain:
.87af	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87b1	20 ee 8d	jsr $8dee			jsr 	CheckNextA
.87b4	e8		inx				inx 								; RHS
.87b5	20 da 9d	jsr $9dda			jsr 	EvaluateValue
.87b8	ca		dex				dex
.87b9	20 c0 87	jsr $87c0			jsr 	AssignVariable
.87bc	60		rts				rts
.87bd					_LetGoProc:
.87bd	4c 51 89	jmp $8951			jmp 	CallProcedure
.87c0					AssignVariable:
.87c0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.87c3	48		pha				pha 								; save a copy
.87c4	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.87c7	29 10		and #$10			and 	#NSBIsString
.87c9	d0 0b		bne $87d6			bne 	_ASError
.87cb	68		pla				pla 								; get back
.87cc	29 10		and #$10			and 	#NSBIsString 				; check type
.87ce	d0 03		bne $87d3			bne 	_ASString
.87d0	4c ec 95	jmp $95ec			jmp 	AssignNumber
.87d3					_ASString:
.87d3	4c 5a 96	jmp $965a			jmp 	AssignString
.87d6					_ASError:
.87d6	4c 4e a0	jmp $a04e			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87d9					Command_List:
.87d9	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.87dc	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87df	9c 14 04	stz $0414			stz 	NSMantissa1+4
.87e2	a9 ff		lda #$ff			lda 	#$FF
.87e4	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.87e7	8d 17 04	sta $0417			sta 	NSMantissa1+7
.87ea	b1 30		lda ($30),y			lda 	(codePtr),y
.87ec	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87ee	f0 1e		beq $880e			beq 	_CLSecond
.87f0	20 6f 88	jsr $886f			jsr 	CLIsDigit 					; if not digit, list all
.87f3	b0 24		bcs $8819			bcs 	_CLStart
.87f5	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.87f7	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger
.87fa	b1 30		lda ($30),y			lda 	(codePtr),y
.87fc	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87fe	f0 0e		beq $880e			beq 	_CLSecond 					; if so go get it
.8800	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.8803	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.8806	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8809	8d 17 04	sta $0417			sta 	NSMantissa1+7
.880c	80 0b		bra $8819			bra 	_CLStart
.880e					_CLSecond:
.880e	c8		iny				iny 								; consume comma
.880f	20 6f 88	jsr $886f			jsr 	CLIsDigit 					; digit found
.8812	b0 05		bcs $8819			bcs 	_CLStart 					; if not, continue listing
.8814	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8816	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger
.8819					_CLStart
.8819	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.881b	85 30		sta $30				sta 	codePtr
.881d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.881f	85 31		sta $31				sta 	codePtr+1
.8821					_CLLoop:
.8821	20 3a ab	jsr $ab3a			jsr 	EXTBreakCheck 				; break check
.8824	f0 33		beq $8859			beq 	_CLExit
.8826	b2 30		lda ($30)			lda 	(codePtr)
.8828	f0 2f		beq $8859			beq 	_CLExit
.882a	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.882c	20 5c 88	jsr $885c			jsr 	CLCompareLineNo
.882f	90 1b		bcc $884c			bcc 	_CLNext
.8831	a2 07		ldx #$07			ldx 	#7
.8833	20 5c 88	jsr $885c			jsr 	CLCompareLineNo
.8836	f0 02		beq $883a			beq 	_CLDoThisOne
.8838	b0 12		bcs $884c			bcs 	_CLNext
.883a					_CLDoThisOne:
.883a	20 9c 8d	jsr $8d9c			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.883d	20 84 b4	jsr $b484			jsr 	ListConvertLine 			; convert line into token Buffer
.8840	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8842	a9 ac		lda #$ac			lda 	#(tokenBuffer & $FF)
.8844	20 50 8e	jsr $8e50			jsr 	PrintStringXA
.8847	a9 0d		lda #$0d			lda 	#13 						; new line
.8849	20 84 a8	jsr $a884			jsr 	EXTPrintCharacter
.884c					_CLNext:
.884c	18		clc				clc
.884d	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.884f	65 30		adc $30				adc 	codePtr
.8851	85 30		sta $30				sta 	codePtr
.8853	90 02		bcc $8857			bcc 	_CREExit
.8855	e6 31		inc $31				inc 	codePtr+1 					; carry
.8857					_CREExit:
.8857	80 c8		bra $8821			bra 	_CLLoop
.8859					_CLExit:
.8859	4c 57 83	jmp $8357			jmp 	WarmStart
.885c					CLCompareLineNo:
.885c	38		sec				sec
.885d	a0 01		ldy #$01			ldy 	#1
.885f	b1 30		lda ($30),y			lda 	(codePtr),y
.8861	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.8864	85 36		sta $36				sta 	zTemp0
.8866	c8		iny				iny
.8867	b1 30		lda ($30),y			lda 	(codePtr),y
.8869	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.886c	05 36		ora $36				ora 	zTemp0
.886e	60		rts				rts
.886f					CLIsDigit:
.886f	b1 30		lda ($30),y			lda 	(codePtr),y
.8871	c9 30		cmp #$30			cmp 	#"0"
.8873	90 03		bcc $8878			bcc	 	_CLIDExitFalse
.8875	c9 3a		cmp #$3a			cmp 	#"9"+1
.8877	60		rts				rts
.8878					_CLIDExitFalse:
.8878	38		sec				sec
.8879	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.887a					Command_LOCAL:
.887a	a2 00		ldx #$00			ldx 	#0 							; at level 0
.887c	20 88 88	jsr $8888			jsr 	LocaliseNextTerm 			; convert term to a local.
.887f	b1 30		lda ($30),y			lda 	(codePtr),y
.8881	c8		iny				iny
.8882	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8884	f0 f4		beq $887a			beq 	Command_LOCAL
.8886	88		dey				dey 								; unpick pre-get
.8887	60		rts				rts
.8888					LocaliseNextTerm:
.8888	20 80 98	jsr $9880			jsr 	EvaluateTerm 				; evaluate the term
.888b	bd 00 04	lda $0400,x			lda 	NSStatus,x
.888e	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.8890	f0 61		beq $88f3			beq		_LNTError
.8892	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8895	85 36		sta $36				sta 	zTemp0
.8897	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.889a	85 37		sta $37				sta  	zTemp0+1
.889c	bd 00 04	lda $0400,x			lda 	NSStatus,x
.889f	29 10		and #$10			and 	#NSBIsString
.88a1	d0 1e		bne $88c1			bne 	_LNTPushString
.88a3	5a		phy				phy
.88a4	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.88a6					_LNTPushNumLoop:
.88a6	b1 36		lda ($36),y			lda		(zTemp0),y
.88a8	20 22 a7	jsr $a722			jsr 	StackPushByte
.88ab	c8		iny				iny
.88ac	c0 05		cpy #$05			cpy 	#5
.88ae	d0 f6		bne $88a6			bne 	_LNTPushNumLoop
.88b0	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.88b2	20 22 a7	jsr $a722			jsr 	StackPushByte
.88b5	a5 37		lda $37				lda 	zTemp0+1
.88b7	20 22 a7	jsr $a722			jsr 	StackPushByte
.88ba	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88bc	20 22 a7	jsr $a722			jsr 	StackPushByte
.88bf	7a		ply				ply
.88c0	60		rts				rts
.88c1					_LNTPushString:
.88c1	5a		phy				phy
.88c2	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88c4	85 38		sta $38				sta 	zTemp1
.88c6	a0 01		ldy #$01			ldy 	#1
.88c8	b1 36		lda ($36),y			lda 	(zTemp0),y
.88ca	85 39		sta $39				sta 	zTemp1+1
.88cc	a0 00		ldy #$00			ldy 	#0 							; output string
.88ce	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88d0	f0 0a		beq $88dc			beq 	_LNTStringOut
.88d2					_LNTPushStrLoop:
.88d2	b1 38		lda ($38),y			lda 	(zTemp1),y
.88d4	f0 06		beq $88dc			beq 	_LNTStringOut
.88d6	20 22 a7	jsr $a722			jsr 	StackPushByte
.88d9	c8		iny				iny
.88da	80 f6		bra $88d2			bra 	_LNTPushStrLoop
.88dc					_LNTStringOut:
.88dc	98		tya				tya									; output length
.88dd	20 22 a7	jsr $a722			jsr 	StackPushByte
.88e0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.88e3	20 22 a7	jsr $a722			jsr 	StackPushByte
.88e6	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.88e9	20 22 a7	jsr $a722			jsr 	StackPushByte
.88ec	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.88ee	20 22 a7	jsr $a722			jsr 	StackPushByte
.88f1	7a		ply				ply
.88f2	60		rts				rts
.88f3					_LNTError:
.88f3	4c 44 a0	jmp $a044			jmp 	SyntaxError
.88f6					LocalPopValue:
.88f6	20 3b a7	jsr $a73b			jsr 	StackPopByte
.88f9	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.88fb	d0 17		bne $8914			bne 	_LPVString
.88fd	20 3b a7	jsr $a73b			jsr 	StackPopByte 				; address
.8900	85 37		sta $37				sta 	zTemp0+1
.8902	20 3b a7	jsr $a73b			jsr 	StackPopByte
.8905	85 36		sta $36				sta 	zTemp0
.8907	5a		phy				phy
.8908	a0 04		ldy #$04			ldy 	#4 							; copy back
.890a					_LPVNumberCopy:
.890a	20 3b a7	jsr $a73b			jsr 	StackPopByte
.890d	91 36		sta ($36),y			sta 	(zTemp0),y
.890f	88		dey				dey
.8910	10 f8		bpl $890a			bpl 	_LPVNumberCopy
.8912	7a		ply				ply 								; and complete
.8913	60		rts				rts
.8914					_LPVString:
.8914	20 3b a7	jsr $a73b			jsr 	StackPopByte 				; address of record => zTemp0
.8917	85 37		sta $37				sta 	zTemp0+1
.8919	20 3b a7	jsr $a73b			jsr 	StackPopByte
.891c	85 36		sta $36				sta 	zTemp0
.891e	5a		phy				phy
.891f	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8921	85 38		sta $38				sta 	zTemp1
.8923	a0 01		ldy #$01			ldy 	#1
.8925	b1 36		lda ($36),y			lda 	(zTemp0),y
.8927	85 39		sta $39				sta 	zTemp1+1
.8929	20 3b a7	jsr $a73b			jsr 	StackPopByte 				; # to get => y
.892c	a8		tay				tay
.892d	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.892f	f0 0e		beq $893f			beq 	_LPVStringCopied
.8931	a9 00		lda #$00			lda 	#0 							; NULL on end
.8933	91 38		sta ($38),y			sta 	(zTemp1),y
.8935					_LPVStringCopy:
.8935	88		dey				dey
.8936	30 07		bmi $893f			bmi 	_LPVStringCopied
.8938	20 3b a7	jsr $a73b			jsr 	StackPopByte
.893b	91 38		sta ($38),y			sta 	(zTemp1),y
.893d	80 f6		bra $8935			bra 	_LPVStringCopy
.893f					_LPVStringCopied:
.893f	fa		plx				plx
.8940	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8941					NewCommand:
.8941	20 47 89	jsr $8947			jsr 	NewProgram 					; does the actual NEW.
.8944	4c 57 83	jmp $8357			jmp 	WarmStart 					; and warm starts straight away.
.8947					NewProgram:
.8947	20 46 a6	jsr $a646			jsr 	MemoryNew
.894a	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.894d	20 f0 83	jsr $83f0			jsr 	ClearCommand 				; clear everything.
.8950	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8951					CallProcedure:
.8951	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8953	b1 30		lda ($30),y			lda 	(codePtr),y
.8955	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8957	f0 0c		beq $8965			beq 	_CPEndParam
.8959					_CPParamLoop:
.8959	20 da 9d	jsr $9dda			jsr 	EvaluateValue 				; get parameter onto stack
.895c	e8		inx				inx 								; bump next stack
.895d	b1 30		lda ($30),y			lda 	(codePtr),y
.895f	c8		iny				iny
.8960	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8962	f0 f5		beq $8959			beq 	_CPParamLoop
.8964	88		dey				dey 								; unpick.
.8965					_CPEndParam:
.8965	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.8968	c8		iny				iny									; skip right bracket
.8969	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.896b	20 44 a7	jsr $a744			jsr 	StackOpen
.896e	20 88 a7	jsr $a788			jsr 	STKSaveCodePosition 		; save loop position
.8971	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8974	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8976	ad 10 04	lda $0410			lda 	NSMantissa1
.8979	85 37		sta $37				sta 	zTemp0+1
.897b	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.897d	b2 36		lda ($36)			lda 	(zTemp0)
.897f	85 30		sta $30				sta 	safePtr
.8981	b1 36		lda ($36),y			lda 	(zTemp0),y
.8983	85 31		sta $31				sta 	safePtr+1
.8985	c8		iny				iny
.8986	b1 36		lda ($36),y			lda 	(zTemp0),y
.8988	85 32		sta $32				sta 	safePtr+2
.898a	c8		iny				iny
.898b	b1 36		lda ($36),y			lda 	(zTemp0),y
.898d	85 33		sta $33				sta 	safePtr+3
.898f	c8		iny				iny 								; get Y offset -> Y
.8990	b1 36		lda ($36),y			lda 	(zTemp0),y
.8992	a8		tay				tay
.8993	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8995	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.8998	f0 13		beq $89ad			beq 	_ParamExit 					; if so, exit.
.899a					_ParamExtract:
.899a	ca		dex				dex 								; put a local term on the level before
.899b	20 88 88	jsr $8888			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.899e	20 c0 87	jsr $87c0			jsr 	AssignVariable 				; assign stacked value to the variable.
.89a1	e8		inx				inx 								; advance to next parameter to do.
.89a2	e8		inx				inx
.89a3	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.89a6	f0 05		beq $89ad			beq 	_ParamExit
.89a8	20 e6 8d	jsr $8de6			jsr 	CheckComma 					; comma seperating parameters
.89ab	80 ed		bra $899a			bra 	_ParamExtract
.89ad					_ParamExit:
.89ad	20 de 8d	jsr $8dde			jsr 	CheckRightBracket 			; check )
.89b0	60		rts				rts 								; and continue from here
.89b1					Command_ENDPROC:
.89b1	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.89b3	a2 14		ldx #$14			ldx 	#ERRID_PROC
.89b5	20 70 a7	jsr $a770			jsr 	StackCheckFrame
.89b8	20 99 a7	jsr $a799			jsr 	STKLoadCodePosition 		; restore code position
.89bb	20 62 a7	jsr $a762			jsr 	StackClose
.89be	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89bf					Command_Read:
.89bf	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89c1	20 80 98	jsr $9880			jsr 	EvaluateTerm
.89c4	bd 00 04	lda $0400,x			lda 	NSStatus,x
.89c7	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89c9	f0 4a		beq $8a15			beq 	_CRSyntax 					; check reference (bit 0)
.89cb	20 5e 8a	jsr $8a5e			jsr 	SwapDataCodePtrs 			; swap code and data
.89ce	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89d1	d0 20		bne $89f3			bne 	_CRContinueData
.89d3					_CRKeepSearching:
.89d3	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89d5	aa		tax				tax
.89d6	20 39 8d	jsr $8d39			jsr 	ScanForward
.89d9	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.89db	f0 16		beq $89f3			beq 	_CRHaveData 				; found it
.89dd	18		clc				clc
.89de	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.89e0	65 30		adc $30				adc 	codePtr
.89e2	85 30		sta $30				sta 	codePtr
.89e4	90 02		bcc $89e8			bcc 	_CREExit
.89e6	e6 31		inc $31				inc 	codePtr+1 					; carry
.89e8					_CREExit:
.89e8	a0 03		ldy #$03			ldy 	#3 							; start of line.
.89ea	b2 30		lda ($30)			lda 	(codePtr)
.89ec	d0 e5		bne $89d3			bne 	_CRKeepSearching
.89ee	a9 0b		lda #$0b		lda	#11
.89f0	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.89f3					_CRHaveData:
.89f3					_CRContinueData:
.89f3	a2 01		ldx #$01			ldx 	#1
.89f5	20 da 9d	jsr $9dda			jsr 	EvaluateValue 				; evaluate value into slot # 1
.89f8	ca		dex				dex
.89f9	20 c0 87	jsr $87c0			jsr		AssignVariable 				; do the assignment
.89fc	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.89ff	b1 30		lda ($30),y			lda 	(codePtr),y
.8a01	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a03	d0 04		bne $8a09			bne 	_CRSwapBack
.8a05	c8		iny				iny 								; consume comma
.8a06	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8a09					_CRSwapBack:
.8a09	20 5e 8a	jsr $8a5e			jsr 	SwapDataCodePtrs			; swap them back.
.8a0c	b1 30		lda ($30),y			lda 	(codePtr),y
.8a0e	c8		iny				iny
.8a0f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a11	f0 ac		beq $89bf			beq 	Command_Read 				; if so go round again.
.8a13	88		dey				dey 								; unpick get.
.8a14	60		rts				rts
.8a15					_CRSyntax:
.8a15	4c 44 a0	jmp $a044			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a18					RemCommand:
.8a18	b1 30		lda ($30),y			lda 	(codePtr),y
.8a1a	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a1c	d0 06		bne $8a24			bne 	_RMExit
.8a1e	c8		iny				iny 								; point to offset
.8a1f	98		tya				tya 								; A = offset position
.8a20	38		sec				sec 								; add size +1 hence SEC
.8a21	71 30		adc ($30),y			adc 	(codePtr),y
.8a23	a8		tay				tay 								; make current position.
.8a24					_RMExit:
.8a24	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a25					Command_REPEAT:
.8a25	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a27	20 44 a7	jsr $a744			jsr 	StackOpen
.8a2a	20 88 a7	jsr $a788			jsr 	STKSaveCodePosition 		; save loop position
.8a2d	60		rts				rts
.8a2e					Command_UNTIL:
.8a2e	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a30	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a32	20 70 a7	jsr $a770			jsr 	StackCheckFrame
.8a35	a2 00		ldx #$00			ldx 	#0
.8a37	20 e3 9d	jsr $9de3			jsr 	EvaluateNumber 				; work out the number
.8a3a	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; check if zero
.8a3d	f0 04		beq $8a43			beq 	_CULoopBack 				; if so keep looping
.8a3f	20 62 a7	jsr $a762			jsr 	StackClose		 			; return
.8a42	60		rts				rts
.8a43					_CULoopBack:
.8a43	20 99 a7	jsr $a799			jsr 	STKLoadCodePosition 		; loop back
.8a46	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a47					Command_Restore:
.8a47	20 5e 8a	jsr $8a5e			jsr 	SwapDataCodePtrs 			; swap code and data
.8a4a	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a4c	85 30		sta $30				sta 	codePtr
.8a4e	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a50	85 31		sta $31				sta 	codePtr+1
.8a52	20 5e 8a	jsr $8a5e			jsr 	SwapDataCodePtrs 			; put them back
.8a55	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a57	8d 9b 04	sta $049b			sta 	dataPointer+4
.8a5a	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.8a5d	60		rts				rts
.8a5e					SwapDataCodePtrs:
.8a5e	da		phx				phx
.8a5f	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a61					_SDCPLoop:
.8a61	b5 30		lda $30,x			lda 	safePtr,x
.8a63	48		pha				pha
.8a64	bd 97 04	lda $0497,x			lda 	dataPointer,x
.8a67	95 30		sta $30,x			sta 	safePtr,x
.8a69	68		pla				pla
.8a6a	9d 97 04	sta $0497,x			sta 	dataPointer,x
.8a6d	ca		dex				dex
.8a6e	10 f1		bpl $8a61			bpl 	_SDCPLoop
.8a70	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.8a73	8c 9b 04	sty $049b			sty 	dataPointer+4
.8a76	a8		tay				tay
.8a77	fa		plx				plx
.8a78	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a79					EOLCommand:
.8a79	18		clc				clc
.8a7a	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a7c	65 30		adc $30				adc 	codePtr
.8a7e	85 30		sta $30				sta 	codePtr
.8a80	90 02		bcc $8a84			bcc 	_CREExit
.8a82	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a84					_CREExit:
.8a84	80 0b		bra $8a91			bra 	RunNewLine
.8a86					CommandRUN:
.8a86	20 f0 83	jsr $83f0			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a89	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a8b	85 30		sta $30				sta 	codePtr
.8a8d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a8f	85 31		sta $31				sta 	codePtr+1
.8a91					RUNNewLine:
.8a91	b2 30		lda ($30)			lda 	(codePtr)
.8a93	f0 72		beq $8b07			beq 	CRNoProgram         		; no then END.
.8a95	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a97	9a		txs				txs
.8a98					RUNCodePointerLine:
.8a98	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a9a					_CRIncMainLoop:
.8a9a	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8a9d	d0 19		bne $8ab8			bne 	_CRNoBreakCheck
.8a9f	20 3a ab	jsr $ab3a			jsr 	EXTBreakCheck 				; break check
.8aa2	f0 5e		beq $8b02			beq 	_CRBreak
.8aa4	64 01		stz $01				stz 	1 							; access I/O Page 0
.8aa6	38		sec				sec 								; calculate timer - LastTick
.8aa7	ad 59 d6	lda $d659			lda 	$D659
.8aaa	aa		tax				tax 								; saving timer in X
.8aab	ed 2e 06	sbc $062e			sbc 	LastTick
.8aae	c9 03		cmp #$03			cmp 	#3
.8ab0	90 06		bcc $8ab8			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8ab2	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.8ab5	20 9f ba	jsr $ba9f			jsr 	TickHandler 				; go do the code.
.8ab8					_NoFireTick:
.8ab8					_CRNoBreakCheck:
.8ab8	c8		iny				iny
.8ab9					_CRMainLoop:
.8ab9	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8abc	b1 30		lda ($30),y			lda 	(codePtr),y
.8abe	10 10		bpl $8ad0			bpl 	_CRNotKeyword
.8ac0	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8ac2	b0 04		bcs $8ac8			bcs 	_CRIsKeyword
.8ac4	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8ac6	b0 34		bcs $8afc			bcs		_CRSyntaxError
.8ac8					_CRIsKeyword:
.8ac8	c8		iny				iny 								; consume command
.8ac9	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8aca	aa		tax				tax 								; put in X for vector jump
.8acb	20 ff 8a	jsr $8aff			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8ace	80 e9		bra $8ab9			bra 	_CRMainLoop 				; and loop round
.8ad0					_CRNotKeyword:
.8ad0	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8ad2	f0 c6		beq $8a9a			beq 	_CRIncMainLoop
.8ad4	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8ad6	90 05		bcc $8add			bcc 	_CRNotVariable
.8ad8					_CRGoLet:
.8ad8	20 84 87	jsr $8784			jsr 	LetCommand
.8adb	80 dc		bra $8ab9			bra 	_CRMainLoop
.8add					_CRNotVariable:
.8add	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8adf	f0 f7		beq $8ad8			beq 	_CRGoLet
.8ae1	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8ae3	f0 f3		beq $8ad8			beq 	_CRGoLet
.8ae5	c9 21		cmp #$21			cmp 	#KWD_PLING
.8ae7	f0 ef		beq $8ad8			beq 	_CRGoLet
.8ae9	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8aeb	f0 09		beq $8af6			beq 	_CRGoRem
.8aed	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8aef	d0 0b		bne $8afc			bne 	_CRSyntaxError
.8af1	20 11 82	jsr $8211			jsr 	LabelHere
.8af4	80 c3		bra $8ab9			bra 	_CRMainLoop
.8af6					_CRGoRem:
.8af6	c8		iny				iny
.8af7	20 18 8a	jsr $8a18			jsr 	RemCommand
.8afa	80 bd		bra $8ab9			bra 	_CRMainLoop
.8afc					_CRSyntaxError:
.8afc	4c 44 a0	jmp $a044			jmp 	SyntaxError
.8aff					_CRCallVector0:
.8aff	7c 9e 8b	jmp ($8b9e,x)			jmp 	(VectorSet0,x)
.8b02					_CRBreak:
.8b02	a9 01		lda #$01		lda	#1
.8b04	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.8b07					CRNoProgram:
.8b07	4c 15 85	jmp $8515			jmp 	EndCommand
.8b0a					Shift1Command:
.8b0a	b1 30		lda ($30),y			lda 	(codePtr),y
.8b0c	c8		iny				iny
.8b0d	0a		asl a				asl 	a
.8b0e	aa		tax				tax
.8b0f	7c 3c 8c	jmp ($8c3c,x)			jmp 	(VectorSet1,x)
.8b12					Shift2Command:
.8b12	b1 30		lda ($30),y			lda 	(codePtr),y
.8b14	c8		iny				iny
.8b15	0a		asl a				asl 	a
.8b16	aa		tax				tax
.8b17	7c 5a 8c	jmp ($8c5a,x)			jmp 	(VectorSet2,x)
.8b1a					Unused1:
.8b1a					Unused2:
.8b1a					Unused3:
.8b1a					Unused4:
.8b1a	4c 44 a0	jmp $a044			jmp 	SyntaxError
>8b1d							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b1e					VectorSetPunc:
>8b1e	e4 90					.word	ShiftLeft                        ; $00 <<
>8b20	9b 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8b22	91 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8b24	44 a0					.word	SyntaxError                      ; $03 !!3
>8b26	44 a0					.word	SyntaxError                      ; $04 ><
>8b28	a5 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b2a	e7 90					.word	ShiftRight                       ; $06 >>
>8b2c	44 a0					.word	SyntaxError                      ; $07 !!7
>8b2e	44 a0					.word	SyntaxError                      ; $08 !!8
>8b30	44 a0					.word	SyntaxError                      ; $09 !!9
>8b32	44 a0					.word	SyntaxError                      ; $0a !!10
>8b34	44 a0					.word	SyntaxError                      ; $0b !!11
>8b36	44 a0					.word	SyntaxError                      ; $0c !!12
>8b38	44 a0					.word	SyntaxError                      ; $0d !!13
>8b3a	44 a0					.word	SyntaxError                      ; $0e !!14
>8b3c	44 a0					.word	SyntaxError                      ; $0f !!15
>8b3e	44 a0					.word	SyntaxError                      ; $10 @
>8b40	44 a0					.word	SyntaxError                      ; $11 !!17
>8b42	44 a0					.word	SyntaxError                      ; $12 !!18
>8b44	44 a0					.word	SyntaxError                      ; $13 [
>8b46	68 8f					.word	IntegerDivide                    ; $14 \
>8b48	44 a0					.word	SyntaxError                      ; $15 ]
>8b4a	75 92					.word	EorInteger                       ; $16 ^
>8b4c	44 a0					.word	SyntaxError                      ; $17 _
>8b4e	44 a0					.word	SyntaxError                      ; $18 `
>8b50	44 a0					.word	SyntaxError                      ; $19 !!25
>8b52	44 a0					.word	SyntaxError                      ; $1a !!26
>8b54	44 a0					.word	SyntaxError                      ; $1b {
>8b56	2f 92					.word	OraInteger                       ; $1c |
>8b58	44 a0					.word	SyntaxError                      ; $1d }
>8b5a	44 a0					.word	SyntaxError                      ; $1e ~
>8b5c	44 a0					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b5e	44 a0					.word	SyntaxError                      ; $20
>8b60	bb 92					.word	WordIndirect                     ; $21 !
>8b62	44 a0					.word	SyntaxError                      ; $22 "
>8b64	44 a0					.word	SyntaxError                      ; $23 #
>8b66	44 a0					.word	SyntaxError                      ; $24 $
>8b68	b5 8f					.word	IntegerModulus                   ; $25 %
>8b6a	e9 91					.word	AndInteger                       ; $26 &
>8b6c	44 a0					.word	SyntaxError                      ; $27 '
>8b6e	44 a0					.word	SyntaxError                      ; $28 (
>8b70	44 a0					.word	SyntaxError                      ; $29 )
>8b72	2a 90					.word	MulInteger                       ; $2a *
>8b74	7b 91					.word	AddInteger                       ; $2b +
>8b76	44 a0					.word	SyntaxError                      ; $2c ,
>8b78	be 91					.word	SubInteger                       ; $2d -
>8b7a	44 a0					.word	SyntaxError                      ; $2e .
>8b7c	a6 94					.word	FDivideCommand                   ; $2f /
>8b7e	44 a0					.word	SyntaxError                      ; $30 0
>8b80	44 a0					.word	SyntaxError                      ; $31 1
>8b82	44 a0					.word	SyntaxError                      ; $32 2
>8b84	44 a0					.word	SyntaxError                      ; $33 3
>8b86	44 a0					.word	SyntaxError                      ; $34 4
>8b88	44 a0					.word	SyntaxError                      ; $35 5
>8b8a	44 a0					.word	SyntaxError                      ; $36 6
>8b8c	44 a0					.word	SyntaxError                      ; $37 7
>8b8e	44 a0					.word	SyntaxError                      ; $38 8
>8b90	44 a0					.word	SyntaxError                      ; $39 9
>8b92	44 a0					.word	SyntaxError                      ; $3a :
>8b94	44 a0					.word	SyntaxError                      ; $3b ;
>8b96	7d 8e					.word	BinaryCompareLess                ; $3c <
>8b98	73 8e					.word	BinaryCompareEqual               ; $3d =
>8b9a	87 8e					.word	BinaryCompareGreater             ; $3e >
>8b9c	e2 92					.word	ByteIndirect                     ; $3f ?
.8b9e					VectorSet0:
>8b9e	79 8a					.word	EOLCommand                       ; $80 !0:EOF
>8ba0	0a 8b					.word	Shift1Command                    ; $81 !1:SH1
>8ba2	12 8b					.word	Shift2Command                    ; $82 !2:SH2
>8ba4	16 9a					.word	AbsUnary                         ; $83 ABS(
>8ba6	26 9a					.word	AllocUnary                       ; $84 ALLOC(
>8ba8	96 9a					.word	AscUnary                         ; $85 ASC(
>8baa	61 9c					.word	ChrUnary                         ; $86 CHR$(
>8bac	b7 a4					.word	UnaryEvent                       ; $87 EVENT(
>8bae	6f 8e					.word	UnaryFalse                       ; $88 FALSE
>8bb0	a3 9a					.word	FracUnary                        ; $89 FRAC(
>8bb2	4d a4					.word	UnaryHit                         ; $8a HIT(
>8bb4	b9 9a					.word	IntUnary                         ; $8b INT(
>8bb6	20 9c					.word	IsValUnary                       ; $8c ISVAL(
>8bb8	47 a5					.word	UnaryJoyB                        ; $8d JOYB(
>8bba	20 a5					.word	UnaryJoyX                        ; $8e JOYX(
>8bbc	23 a5					.word	UnaryJoyY                        ; $8f JOYY(
>8bbe	3b 9d					.word	Unary_Left                       ; $90 LEFT$(
>8bc0	cb 9a					.word	LenUnary                         ; $91 LEN(
>8bc2	e9 9a					.word	Unary_Max                        ; $92 MAX(
>8bc4	65 9d					.word	Unary_Mid                        ; $93 MID$(
>8bc6	e5 9a					.word	Unary_Min                        ; $94 MIN(
>8bc8	40 9b					.word	Unary_Not                        ; $95 NOT(
>8bca	9b a6					.word	UnaryPlaying                     ; $96 PLAYING(
>8bcc	56 9b					.word	Unary_Random                     ; $97 RANDOM(
>8bce	4b 9d					.word	Unary_Right                      ; $98 RIGHT$(
>8bd0	75 9b					.word	Unary_Rnd                        ; $99 RND(
>8bd2	f6 9b					.word	SgnUnary                         ; $9a SGN(
>8bd4	73 9c					.word	SpcUnary                         ; $9b SPC(
>8bd6	8e 9c					.word	Unary_Str                        ; $9c STR$(
>8bd8	6d a5					.word	UnaryTimer                       ; $9d TIMER(
>8bda	63 8e					.word	UnaryTrue                        ; $9e TRUE
>8bdc	16 9c					.word	ValUnary                         ; $9f VAL(
>8bde	18 85					.word	ForCommand                       ; $a0 FOR
>8be0	65 86					.word	IfCommand                        ; $a1 IF
>8be2	1a 8b					.word	Unused1                          ; $a2 PROC
>8be4	25 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8be6	af 8d					.word	Command_WHILE                    ; $a4 WHILE
>8be8	8e 86					.word	EndIf                            ; $a5 ENDIF
>8bea	b1 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8bec	d2 85					.word	NextCommand                      ; $a7 NEXT
>8bee	1a 8b					.word	Unused4                          ; $a8 THEN
>8bf0	2e 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8bf2	d0 8d					.word	Command_WEND                     ; $aa WEND
>8bf4	44 a0					.word	SyntaxError                      ; $ab BY
>8bf6	b6 83					.word	CallCommand                      ; $ac CALL
>8bf8	ef a1					.word	CircleCommand                    ; $ad CIRCLE
>8bfa	f0 83					.word	ClearCommand                     ; $ae CLEAR
>8bfc	48 84					.word	ClearScreen                      ; $af CLS
>8bfe	44 a0					.word	SyntaxError                      ; $b0 COLOR
>8c00	44 a0					.word	SyntaxError                      ; $b1 COLOUR
>8c02	50 84					.word	Command_Data                     ; $b2 DATA
>8c04	58 84					.word	DimCommand                       ; $b3 DIM
>8c06	1a 8b					.word	Unused3                          ; $b4 DOWNTO
>8c08	87 86					.word	ElseCode                         ; $b5 ELSE
>8c0a	44 a0					.word	SyntaxError                      ; $b6 FROM
>8c0c	1b a4					.word	GfxCommand                       ; $b7 GFX
>8c0e	2b 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c10	49 86					.word	GotoCommand                      ; $b9 GOTO
>8c12	44 a0					.word	SyntaxError                      ; $ba HERE
>8c14	19 a2					.word	ImageCommand                     ; $bb IMAGE
>8c16	8f 86					.word	Command_Input                    ; $bc INPUT
>8c18	84 87					.word	LetCommand                       ; $bd LET
>8c1a	6e a2					.word	LineCommand                      ; $be LINE
>8c1c	7a 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c1e	44 a0					.word	SyntaxError                      ; $c0 OFF
>8c20	44 a0					.word	SyntaxError                      ; $c1 ON
>8c22	44 a0					.word	SyntaxError                      ; $c2 OUTLINE
>8c24	73 a4					.word	PaletteCommand                   ; $c3 PALETTE
>8c26	67 a2					.word	PlotCommand                      ; $c4 PLOT
>8c28	96 86					.word	Command_Print                    ; $c5 PRINT
>8c2a	bf 89					.word	Command_Read                     ; $c6 READ
>8c2c	eb a1					.word	RectangleCommand                 ; $c7 RECT
>8c2e	18 8a					.word	RemCommand                       ; $c8 REM
>8c30	3b 86					.word	Command_RETURN                   ; $c9 RETURN
>8c32	44 a0					.word	SyntaxError                      ; $ca SOLID
>8c34	b7 a6					.word	SoundCommand                     ; $cb SOUND
>8c36	fa a1					.word	SpriteCommand                    ; $cc SPRITE
>8c38	36 a2					.word	TextCommand                      ; $cd TEXT
>8c3a	1a 8b					.word	Unused2                          ; $ce TO
.8c3c					VectorSet1:
>8c3c	44 a0					.word	SyntaxError                      ; $80 !0:EOF
>8c3e	44 a0					.word	SyntaxError                      ; $81 !1:SH1
>8c40	44 a0					.word	SyntaxError                      ; $82 !2:SH2
>8c42	87 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c44	a6 83					.word	AssertCommand                    ; $84 ASSERT
>8c46	bb a3					.word	BitmapCtrl                       ; $85 BITMAP
>8c48	15 85					.word	EndCommand                       ; $86 END
>8c4a	64 a5					.word	GoCommand                        ; $87 GO
>8c4c	d9 87					.word	Command_List                     ; $88 LIST
>8c4e	5b a5					.word	LoadCommand                      ; $89 LOAD
>8c50	41 89					.word	NewCommand                       ; $8a NEW
>8c52	47 8a					.word	Command_Restore                  ; $8b RESTORE
>8c54	86 8a					.word	CommandRUN                       ; $8c RUN
>8c56	00 a4					.word	SpritesCtrl                      ; $8d SPRITES
>8c58	e2 8c					.word	StopCommand                      ; $8e STOP
.8c5a					VectorSet2:
>8c5a	44 a0					.word	SyntaxError                      ; $80 !0:EOF
>8c5c	44 a0					.word	SyntaxError                      ; $81 !1:SH1
>8c5e	44 a0					.word	SyntaxError                      ; $82 !2:SH2
>8c60	03 9f					.word	Assemble_adc                     ; $83 ADC
>8c62	fb 9e					.word	Assemble_and                     ; $84 AND
>8c64	17 9f					.word	Assemble_asl                     ; $85 ASL
>8c66	81 9f					.word	Assemble_bcc                     ; $86 BCC
>8c68	85 9f					.word	Assemble_bcs                     ; $87 BCS
>8c6a	8d 9f					.word	Assemble_beq                     ; $88 BEQ
>8c6c	44 9f					.word	Assemble_bit                     ; $89 BIT
>8c6e	75 9f					.word	Assemble_bmi                     ; $8a BMI
>8c70	89 9f					.word	Assemble_bne                     ; $8b BNE
>8c72	71 9f					.word	Assemble_bpl                     ; $8c BPL
>8c74	91 9f					.word	Assemble_bra                     ; $8d BRA
>8c76	95 9f					.word	Assemble_brk                     ; $8e BRK
>8c78	79 9f					.word	Assemble_bvc                     ; $8f BVC
>8c7a	7d 9f					.word	Assemble_bvs                     ; $90 BVS
>8c7c	9d 9f					.word	Assemble_clc                     ; $91 CLC
>8c7e	f1 9f					.word	Assemble_cld                     ; $92 CLD
>8c80	b1 9f					.word	Assemble_cli                     ; $93 CLI
>8c82	e1 9f					.word	Assemble_clv                     ; $94 CLV
>8c84	0f 9f					.word	Assemble_cmp                     ; $95 CMP
>8c86	58 9f					.word	Assemble_cpx                     ; $96 CPX
>8c88	53 9f					.word	Assemble_cpy                     ; $97 CPY
>8c8a	35 9f					.word	Assemble_dec                     ; $98 DEC
>8c8c	ed 9f					.word	Assemble_dex                     ; $99 DEX
>8c8e	c9 9f					.word	Assemble_dey                     ; $9a DEY
>8c90	ff 9e					.word	Assemble_eor                     ; $9b EOR
>8c92	3a 9f					.word	Assemble_inc                     ; $9c INC
>8c94	fd 9f					.word	Assemble_inx                     ; $9d INX
>8c96	e9 9f					.word	Assemble_iny                     ; $9e INY
>8c98	6c 9f					.word	Assemble_jmp                     ; $9f JMP
>8c9a	67 9f					.word	Assemble_jsr                     ; $a0 JSR
>8c9c	0b 9f					.word	Assemble_lda                     ; $a1 LDA
>8c9e	30 9f					.word	Assemble_ldx                     ; $a2 LDX
>8ca0	4e 9f					.word	Assemble_ldy                     ; $a3 LDY
>8ca2	21 9f					.word	Assemble_lsr                     ; $a4 LSR
>8ca4	01 a0					.word	Assemble_nop                     ; $a5 NOP
>8ca6	f7 9e					.word	Assemble_ora                     ; $a6 ORA
>8ca8	ad 9f					.word	Assemble_pha                     ; $a7 PHA
>8caa	99 9f					.word	Assemble_php                     ; $a8 PHP
>8cac	f5 9f					.word	Assemble_phx                     ; $a9 PHX
>8cae	b5 9f					.word	Assemble_phy                     ; $aa PHY
>8cb0	bd 9f					.word	Assemble_pla                     ; $ab PLA
>8cb2	a1 9f					.word	Assemble_plp                     ; $ac PLP
>8cb4	09 a0					.word	Assemble_plx                     ; $ad PLX
>8cb6	c5 9f					.word	Assemble_ply                     ; $ae PLY
>8cb8	1c 9f					.word	Assemble_rol                     ; $af ROL
>8cba	26 9f					.word	Assemble_ror                     ; $b0 ROR
>8cbc	a9 9f					.word	Assemble_rti                     ; $b1 RTI
>8cbe	b9 9f					.word	Assemble_rts                     ; $b2 RTS
>8cc0	13 9f					.word	Assemble_sbc                     ; $b3 SBC
>8cc2	a5 9f					.word	Assemble_sec                     ; $b4 SEC
>8cc4	05 a0					.word	Assemble_sed                     ; $b5 SED
>8cc6	c1 9f					.word	Assemble_sei                     ; $b6 SEI
>8cc8	07 9f					.word	Assemble_sta                     ; $b7 STA
>8cca	f9 9f					.word	Assemble_stp                     ; $b8 STP
>8ccc	2b 9f					.word	Assemble_stx                     ; $b9 STX
>8cce	49 9f					.word	Assemble_sty                     ; $ba STY
>8cd0	3f 9f					.word	Assemble_stz                     ; $bb STZ
>8cd2	dd 9f					.word	Assemble_tax                     ; $bc TAX
>8cd4	d9 9f					.word	Assemble_tay                     ; $bd TAY
>8cd6	62 9f					.word	Assemble_trb                     ; $be TRB
>8cd8	5d 9f					.word	Assemble_tsb                     ; $bf TSB
>8cda	e5 9f					.word	Assemble_tsx                     ; $c0 TSX
>8cdc	cd 9f					.word	Assemble_txa                     ; $c1 TXA
>8cde	d5 9f					.word	Assemble_txs                     ; $c2 TXS
>8ce0	d1 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8ce2					StopCommand:
.8ce2	a9 08		lda #$08		lda	#8
.8ce4	4c f7 8d	jmp $8df7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8ce7					ProcedureScan:
.8ce7	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ce9	85 30		sta $30				sta 	codePtr
.8ceb	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8ced	85 31		sta $31				sta 	codePtr+1
.8cef					_PSLoop:
.8cef	b2 30		lda ($30)			lda 	(codePtr)
.8cf1	f0 42		beq $8d35			beq 	_PSExit
.8cf3	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8cf5	b1 30		lda ($30),y			lda 	(codePtr),y
.8cf7	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8cf9	d0 2d		bne $8d28			bne 	_PSNext
.8cfb	c8		iny				iny 								; get the address of the record to zTemp0 and
.8cfc	b1 30		lda ($30),y			lda 	(codePtr),y
.8cfe	29 c0		and #$c0			and 	#$C0
.8d00	c9 40		cmp #$40			cmp 	#$40
.8d02	d0 32		bne $8d36			bne 	_PSSyntax
.8d04	b1 30		lda ($30),y			lda 	(codePtr),y
.8d06	18		clc				clc
.8d07	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d09	85 37		sta $37				sta 	zTemp0+1
.8d0b	c8		iny				iny 								; LSB
.8d0c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d0e	85 36		sta $36				sta 	zTemp0
.8d10	c8		iny				iny 								; character after variable call.
.8d11	98		tya				tya 								; save Y offset at +7
.8d12	a0 07		ldy #$07			ldy 	#7
.8d14	91 36		sta ($36),y			sta 	(zTemp0),y
.8d16	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d18	a0 02		ldy #$02			ldy 	#2
.8d1a	91 36		sta ($36),y			sta 	(zTemp0),y
.8d1c	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d1e					_PSCopy:
.8d1e	b5 30		lda $30,x			lda 	safePtr,x
.8d20	c8		iny				iny
.8d21	91 36		sta ($36),y			sta 	(zTemp0),y
.8d23	e8		inx				inx
.8d24	e0 04		cpx #$04			cpx 	#4
.8d26	d0 f6		bne $8d1e			bne 	_PSCopy
.8d28					_PSNext:
.8d28	18		clc				clc
.8d29	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d2b	65 30		adc $30				adc 	codePtr
.8d2d	85 30		sta $30				sta 	codePtr
.8d2f	90 02		bcc $8d33			bcc 	_CREExit
.8d31	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d33					_CREExit:
.8d33	80 ba		bra $8cef			bra 	_PSLoop
.8d35					_PSExit:
.8d35	60		rts				rts
.8d36					_PSSyntax:
.8d36	4c 44 a0	jmp $a044			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d39					ScanForward:
.8d39	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d3b	86 37		stx $37				stx 	zTemp0+1
.8d3d	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d3f					_ScanLoop:
.8d3f	b1 30		lda ($30),y			lda 	(codePtr),y
.8d41	c8		iny				iny
.8d42	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d44	d0 0e		bne $8d54			bne 	_ScanGoNext
.8d46	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d48	f0 04		beq $8d4e			beq 	_ScanMatch
.8d4a	c5 37		cmp $37				cmp 	zTemp0+1
.8d4c	d0 06		bne $8d54			bne 	_ScanGoNext
.8d4e					_ScanMatch:
.8d4e	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d50	d0 01		bne $8d53			bne 	_ScanNotEndEOL
.8d52	88		dey				dey
.8d53					_ScanNotEndEOL:
.8d53	60		rts				rts
.8d54					_ScanGoNext:
.8d54	20 59 8d	jsr $8d59			jsr  	ScanForwardOne
.8d57	80 e6		bra $8d3f			bra 	_ScanLoop
.8d59					ScanForwardOne:
.8d59	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d5b	90 3e		bcc $8d9b			bcc 	_SFWExit
.8d5d	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d5f	90 18		bcc $8d79			bcc 	_ScanSkipOne
.8d61	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d63	b0 2f		bcs $8d94			bcs 	_ScanSkipData
.8d65	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d67	90 32		bcc $8d9b			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d69	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d6b	b0 2e		bcs $8d9b			bcs 	_SFWExit
.8d6d	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d6f	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d71	b0 28		bcs $8d9b			bcs 	_SFWExit
.8d73	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d75	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8d77	80 22		bra $8d9b			bra 	_SFWExit
.8d79					_ScanSkipOne:
.8d79	c8		iny				iny 								; consume the extra one.
.8d7a	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8d7c	d0 1d		bne $8d9b			bne 	_SFWExit
.8d7e	18		clc				clc
.8d7f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d81	65 30		adc $30				adc 	codePtr
.8d83	85 30		sta $30				sta 	codePtr
.8d85	90 02		bcc $8d89			bcc 	_CREExit
.8d87	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d89					_CREExit:
.8d89	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8d8b	b2 30		lda ($30)			lda 	(codePtr)
.8d8d	d0 0c		bne $8d9b			bne 	_SFWExit 					; if not zero, more to scan
.8d8f	a9 13		lda #$13		lda	#19
.8d91	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.8d94					_ScanSkipData:
.8d94	88		dey				dey 								; point at data token
.8d95	c8		iny				iny 								; point to offset
.8d96	98		tya				tya 								; A = offset position
.8d97	38		sec				sec 								; add size +1 hence SEC
.8d98	71 30		adc ($30),y			adc 	(codePtr),y
.8d9a	a8		tay				tay 								; make current position.
.8d9b					_SFWExit:
.8d9b	60		rts				rts
.8d9c					ScanGetCurrentLineStep:
.8d9c	64 38		stz $38				stz 	zTemp1
.8d9e	a0 03		ldy #$03			ldy 	#3
.8da0					_SGCLSLoop:
.8da0	b1 30		lda ($30),y			lda 	(codePtr),y
.8da2	c8		iny				iny
.8da3	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8da5	f0 05		beq $8dac			beq 	_SGCLSExit
.8da7	20 59 8d	jsr $8d59			jsr 	ScanForwardOne
.8daa	80 f4		bra $8da0			bra 	_SGCLSLoop
.8dac					_SGCLSExit:
.8dac	a5 38		lda $38				lda 	zTemp1
.8dae	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8daf					Command_WHILE:
.8daf	5a		phy				phy 								; save position of the test
.8db0	a2 00		ldx #$00			ldx 	#0
.8db2	20 e3 9d	jsr $9de3			jsr 	EvaluateNumber 				; work out the number
.8db5	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; check if zero
.8db8	f0 0e		beq $8dc8			beq 	_WHExitLoop 				; if so exit the loop
.8dba	98		tya				tya 								; position *after* test.
.8dbb	7a		ply				ply 								; restore position before test, at WHILE
.8dbc	88		dey				dey
.8dbd	48		pha				pha 								; push after test on the stack
.8dbe	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8dc0	20 44 a7	jsr $a744			jsr 	StackOpen
.8dc3	20 88 a7	jsr $a788			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8dc6	7a		ply				ply 								; restore the position *after* the test
.8dc7	60		rts				rts
.8dc8					_WHExitLoop:
.8dc8	68		pla				pla 								; throw post loop position
.8dc9	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8dcb	aa		tax				tax
.8dcc	20 39 8d	jsr $8d39			jsr 	ScanForward
.8dcf	60		rts				rts
.8dd0					Command_WEND:
.8dd0	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8dd2	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8dd4	20 70 a7	jsr $a770			jsr 	StackCheckFrame
.8dd7	20 99 a7	jsr $a799			jsr 	STKLoadCodePosition 		; loop back
.8dda	20 62 a7	jsr $a762			jsr 	StackClose		 			; erase the frame
.8ddd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8dde					CheckRightBracket:
.8dde	b1 30		lda ($30),y			lda 	(codePtr),y
.8de0	c8		iny				iny
.8de1	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8de3	d0 0f		bne $8df4			bne 	CNAFail
.8de5	60		rts				rts
.8de6					CheckComma:
.8de6	b1 30		lda ($30),y			lda 	(codePtr),y
.8de8	c8		iny				iny
.8de9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8deb	d0 07		bne $8df4			bne 	CNAFail
.8ded	60		rts				rts
.8dee					CheckNextA:
.8dee	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8df0	d0 02		bne $8df4			bne 	CNAFail
.8df2	c8		iny				iny 								; skip character
.8df3	60		rts				rts 								; and exit
.8df4					CNAFail:
.8df4	4c 44 a0	jmp $a044			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8df7					ErrorHandler:
.8df7	a8		tay				tay 								; find the error text
.8df8	f0 49		beq $8e43			beq 	_EHEnd
.8dfa	a2 00		ldx #$00			ldx 	#0
.8dfc	a9 5d		lda #$5d			lda 	#((ErrorText) & $FF)
.8dfe	85 36		sta $36				sta 	0+zTemp0
.8e00	a9 a0		lda #$a0			lda 	#((ErrorText) >> 8)
.8e02	85 37		sta $37				sta 	1+zTemp0
.8e04					_EHFind:
.8e04	88		dey				dey 								; found the error text ?
.8e05	f0 0e		beq $8e15			beq 	_EHFound
.8e07					_EHFindZero:
.8e07	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e09	e6 36		inc $36				inc 	zTemp0
.8e0b	d0 02		bne $8e0f			bne 	_EHFNoCarry
.8e0d	e6 37		inc $37				inc 	zTemp0+1
.8e0f					_EHFNoCarry:
.8e0f	c9 00		cmp #$00			cmp 	#0
.8e11	d0 f4		bne $8e07			bne 	_EHFindZero
.8e13	80 ef		bra $8e04			bra 	_EHFind
.8e15					_EHFound:
.8e15	a5 36		lda $36				lda 	zTemp0 						; print message
.8e17	a6 37		ldx $37				ldx 	zTemp0+1
.8e19	20 50 8e	jsr $8e50			jsr 	PrintStringXA
.8e1c	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8e1e	b1 30		lda ($30),y			lda 	(codePtr),y
.8e20	d0 05		bne $8e27			bne 	_EHAtMsg
.8e22	c8		iny				iny
.8e23	b1 30		lda ($30),y			lda 	(codePtr),y
.8e25	f0 17		beq $8e3e			beq 	_EHCREnd
.8e27					_EHAtMsg:
.8e27	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8e29	a9 46		lda #$46			lda 	#_AtMsg & $FF
.8e2b	20 50 8e	jsr $8e50			jsr 	PrintStringXA
.8e2e	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8e30	b1 30		lda ($30),y			lda 	(codePtr),y
.8e32	48		pha				pha
.8e33	c8		iny				iny
.8e34	b1 30		lda ($30),y			lda 	(codePtr),y
.8e36	aa		tax				tax
.8e37	68		pla				pla
.8e38	20 09 93	jsr $9309			jsr 	LCLConvertInt16 				; convert XA to string
.8e3b	20 50 8e	jsr $8e50			jsr 	PrintStringXA 				; and print it.
.8e3e					_EHCREnd:
.8e3e	a9 0d		lda #$0d			lda 	#13 						; new line
.8e40	20 84 a8	jsr $a884			jsr 	EXTPrintCharacter
.8e43					_EHEnd:
.8e43	4c 57 83	jmp $8357			jmp 	WarmStart
>8e46	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8e4e	20 00
.8e50					PrintStringXA:
.8e50	5a		phy				phy
.8e51	86 37		stx $37				stx 	zTemp0+1
.8e53	85 36		sta $36				sta 	zTemp0
.8e55	a0 00		ldy #$00			ldy 	#0
.8e57					_PSXALoop:
.8e57	b1 36		lda ($36),y			lda 	(zTemp0),y
.8e59	f0 06		beq $8e61			beq 	_PSXAExit
.8e5b	20 84 a8	jsr $a884			jsr 	EXTPrintCharacter
.8e5e	c8		iny				iny
.8e5f	80 f6		bra $8e57			bra 	_PSXALoop
.8e61					_PSXAExit:
.8e61	7a		ply				ply
.8e62	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8e63					UnaryTrue:
.8e63	fa		plx				plx
.8e64					ReturnTrue:
.8e64	a9 01		lda #$01			lda 	#1  						; set to 1
.8e66	20 bc 9e	jsr $9ebc			jsr 	NSMSetByte
.8e69	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8e6b	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8e6e	60		rts				rts
.8e6f					UnaryFalse:
.8e6f	fa		plx				plx
.8e70					ReturnFalse:
.8e70	4c ba 9e	jmp $9eba			jmp 	NSMSetZero 					; set it all to zero
.8e73					BinaryCompareEqual:
.8e73	fa		plx				plx
.8e74	20 af 8e	jsr $8eaf			jsr 	CompareBaseCode
.8e77	c9 00		cmp #$00			cmp 	#0
.8e79	f0 e9		beq $8e64			beq 	ReturnTrue
.8e7b	80 f3		bra $8e70			bra 	ReturnFalse
.8e7d					BinaryCompareLess:
.8e7d	fa		plx				plx
.8e7e	20 af 8e	jsr $8eaf			jsr 	CompareBaseCode
.8e81	c9 ff		cmp #$ff			cmp 	#$FF
.8e83	f0 df		beq $8e64			beq 	ReturnTrue
.8e85	80 e9		bra $8e70			bra 	ReturnFalse
.8e87					BinaryCompareGreater:
.8e87	fa		plx				plx
.8e88	20 af 8e	jsr $8eaf			jsr 	CompareBaseCode
.8e8b	c9 01		cmp #$01			cmp 	#1
.8e8d	f0 d5		beq $8e64			beq 	ReturnTrue
.8e8f	80 df		bra $8e70			bra 	ReturnFalse
.8e91					BinaryCompareNotEqual:
.8e91	fa		plx				plx
.8e92	20 af 8e	jsr $8eaf			jsr 	CompareBaseCode
.8e95	c9 00		cmp #$00			cmp 	#0
.8e97	d0 cb		bne $8e64			bne 	ReturnTrue
.8e99	80 d5		bra $8e70			bra 	ReturnFalse
.8e9b					BinaryCompareLessEqual:
.8e9b	fa		plx				plx
.8e9c	20 af 8e	jsr $8eaf			jsr 	CompareBaseCode
.8e9f	c9 01		cmp #$01			cmp 	#1
.8ea1	d0 c1		bne $8e64			bne 	ReturnTrue
.8ea3	80 cb		bra $8e70			bra 	ReturnFalse
.8ea5					BinaryCompareGreaterEqual:
.8ea5	fa		plx				plx
.8ea6	20 af 8e	jsr $8eaf			jsr 	CompareBaseCode
.8ea9	c9 ff		cmp #$ff			cmp 	#$FF
.8eab	d0 b7		bne $8e64			bne 	ReturnTrue
.8ead	80 c1		bra $8e70			bra 	ReturnFalse
.8eaf					CompareBaseCode:
.8eaf	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; make both values if references.
.8eb2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8eb5	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8eb8	29 10		and #$10			and 	#NSTString
.8eba	d0 40		bne $8efc			bne 	_CBCString
.8ebc	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8ebf	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8ec2	d0 3b		bne $8eff			bne 	_CBCFloat
.8ec4	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8ec7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8eca	29 08		and #$08			and 	#NSTFloat
.8ecc	d0 31		bne $8eff			bne 	_CBCFloat
.8ece	20 02 8f	jsr $8f02			jsr 	CompareFixMinusZero
.8ed1	e8		inx				inx
.8ed2	20 02 8f	jsr $8f02			jsr 	CompareFixMinusZero
.8ed5	ca		dex				dex
.8ed6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8ed9	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8edc	10 0b		bpl $8ee9			bpl 	_CDCSameSign
.8ede	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8ee1	30 16		bmi $8ef9			bmi 	_CBCLess 					; return $FF
.8ee3					_CBCGreater:
.8ee3	a9 01		lda #$01			lda 	#1
.8ee5	60		rts				rts
.8ee6					_CBCEqual:
.8ee6	a9 00		lda #$00			lda 	#0
.8ee8	60		rts				rts
.8ee9					_CDCSameSign:
.8ee9	20 55 91	jsr $9155			jsr 	SubTopTwoStack 				; unsigned subtract
.8eec	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; or the mantissa together
.8eef	f0 f5		beq $8ee6			beq 	_CBCEqual 					; -0 == 0
.8ef1	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8ef4	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8ef7	10 ea		bpl $8ee3			bpl 	_CBCGreater
.8ef9					_CBCLess:
.8ef9	a9 ff		lda #$ff			lda 	#$FF
.8efb	60		rts				rts
.8efc					_CBCString:
.8efc	4c ab 90	jmp $90ab			jmp 	CompareStrings
.8eff					_CBCFloat:
.8eff	4c 8c 94	jmp $948c			jmp 	CompareFloat
.8f02					CompareFixMinusZero:
.8f02	20 ea 9e	jsr $9eea			jsr 	NSMIsZero
.8f05	d0 03		bne $8f0a			bne 	_CFXMZNotZero
.8f07	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8f0a					_CFXMZNotZero:
.8f0a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f0b					StringConcat:
.8f0b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8f0e	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8f11	29 18		and #$18			and 	#NSBTypeMask
.8f13	c9 10		cmp #$10			cmp 	#NSTString
.8f15	d0 4e		bne $8f65			bne		_SCType
.8f17	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f19	e8		inx				inx
.8f1a	20 38 8f	jsr $8f38			jsr 	_SCSetupZ0 					; setup for second
.8f1d	20 43 8f	jsr $8f43			jsr 	_SCLengthZ0 				; length for second
.8f20	ca		dex				dex
.8f21	20 38 8f	jsr $8f38			jsr 	_SCSetupZ0 					; setup for first
.8f24	20 43 8f	jsr $8f43			jsr 	_SCLengthZ0 				; length for first
.8f27	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8f29	20 37 a8	jsr $a837			jsr 	StringTempAllocate
.8f2c	20 56 8f	jsr $8f56			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8f2f	e8		inx				inx
.8f30	20 38 8f	jsr $8f38			jsr 	_SCSetupZ0 					; copy second out
.8f33	20 56 8f	jsr $8f56			jsr 	_SCCopy
.8f36	ca		dex				dex
.8f37	60		rts				rts
.8f38					_SCSetupZ0:
.8f38	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8f3b	85 36		sta $36				sta 	zTemp0
.8f3d	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8f40	85 37		sta $37				sta 	zTemp0+1
.8f42	60		rts				rts
.8f43					_SCLengthZ0:
.8f43	5a		phy				phy
.8f44	a0 00		ldy #$00			ldy 	#0
.8f46					_SCLenLoop:
.8f46	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f48	f0 0a		beq $8f54			beq 	_SCLExit
.8f4a	c8		iny				iny
.8f4b	e6 38		inc $38				inc 	zTemp1
.8f4d	10 f7		bpl $8f46			bpl		_SCLenLoop
.8f4f	a9 09		lda #$09		lda	#9
.8f51	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.8f54					_SCLExit:
.8f54	7a		ply				ply
.8f55	60		rts				rts
.8f56					_SCCopy:
.8f56	5a		phy				phy
.8f57	a0 00		ldy #$00			ldy 	#0
.8f59					_SCCopyLoop:
.8f59	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f5b	f0 06		beq $8f63			beq 	_SCCExit
.8f5d	20 75 a8	jsr $a875			jsr 	StringTempWrite
.8f60	c8		iny				iny
.8f61	80 f6		bra $8f59			bra 	_SCCopyLoop
.8f63					_SCCExit:
.8f63	7a		ply				ply
.8f64	60		rts				rts
.8f65					_SCType:
.8f65	4c 4e a0	jmp $a04e			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8f68					IntegerDivide:
.8f68	fa		plx				plx
.8f69	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f6c	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f6f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f70	0a		asl a				asl 	a
.8f71	10 05		bpl $8f78			bpl 	_NotRef
.8f73	48		pha				pha
.8f74	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f77	68		pla				pla
.8f78					_NotRef:
.8f78	0a		asl a				asl 	a
.8f79	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f7b	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f7e	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f81	f0 03		beq $8f86			beq 	_IntegerCode 				; if clear, then we have two integers
.8f83	4c 4e a0	jmp $a04e			jmp 	TypeError 					; anything else, type mismatch.
.8f86					_IntegerCode:
.8f86	20 a8 8f	jsr $8fa8			jsr 	CheckDivideZero 			; do div zero check
.8f89	20 e0 8f	jsr $8fe0			jsr 	Int32Divide 				; do the division
.8f8c	20 9d 90	jsr $909d			jsr 	CalculateSign 				; calculate result sign
.8f8f					NSMCopyPlusTwoToZero:
.8f8f	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f92	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8f95	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8f98	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8f9b	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8f9e	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8fa1	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8fa4	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8fa7	60		rts				rts
.8fa8					CheckDivideZero:
.8fa8	e8		inx				inx
.8fa9	20 ea 9e	jsr $9eea			jsr 	NSMIsZero
.8fac	f0 02		beq $8fb0			beq 	_CDVError
.8fae	ca		dex				dex
.8faf	60		rts				rts
.8fb0					_CDVError:
.8fb0	a9 03		lda #$03		lda	#3
.8fb2	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.8fb5					IntegerModulus:
.8fb5	fa		plx				plx
.8fb6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8fb9	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8fbc	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fbd	0a		asl a				asl 	a
.8fbe	10 05		bpl $8fc5			bpl 	_NotRef
.8fc0	48		pha				pha
.8fc1	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fc4	68		pla				pla
.8fc5					_NotRef:
.8fc5	0a		asl a				asl 	a
.8fc6	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8fc8	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fcb	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fce	f0 03		beq $8fd3			beq 	_IntegerCode 				; if clear, then we have two integers
.8fd0	4c 4e a0	jmp $a04e			jmp 	TypeError 					; anything else, type mismatch.
.8fd3					_IntegerCode:
.8fd3					IntegerModulusNoCheck:
.8fd3	20 a8 8f	jsr $8fa8			jsr 	CheckDivideZero 			; do div zero check
.8fd6	20 e0 8f	jsr $8fe0			jsr 	Int32Divide 				; do the division
.8fd9	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8fdc	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8fdf	60		rts				rts
.8fe0					Int32Divide:
.8fe0	48		pha				pha 								; save AXY
.8fe1	5a		phy				phy
.8fe2	20 91 9e	jsr $9e91			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fe5	20 b6 9e	jsr $9eb6			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8fe8	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8fea					_I32DivideLoop:
.8fea	e8		inx				inx
.8feb	e8		inx				inx
.8fec	20 cf 9e	jsr $9ecf			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8fef	ca		dex				dex
.8ff0	ca		dex				dex
.8ff1	20 d0 9e	jsr $9ed0			jsr 	NSMRotateLeft
.8ff4	20 20 90	jsr $9020			jsr 	DivideCheckSubtract 		; check if subtract possible
.8ff7	90 03		bcc $8ffc			bcc 	_I32DivideNoCarryIn
.8ff9	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8ffc					_I32DivideNoCarryIn:
.8ffc	88		dey				dey 								; loop round till division completed.
.8ffd	d0 eb		bne $8fea			bne 	_I32DivideLoop
.8fff	7a		ply				ply 								; restore AXY and exit
.9000	68		pla				pla
.9001	60		rts				rts
.9002					Int32ShiftDivide:
.9002	48		pha				pha 								; save AY
.9003	5a		phy				phy
.9004	e8		inx				inx 								; clear S[X+2]
.9005	e8		inx				inx
.9006	20 ba 9e	jsr $9eba			jsr 	NSMSetZero
.9009	ca		dex				dex
.900a	ca		dex				dex
.900b	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.900d					_I32SDLoop:
.900d	20 20 90	jsr $9020			jsr 	DivideCheckSubtract 		; check if subtract possible
.9010	e8		inx				inx
.9011	e8		inx				inx
.9012	20 d0 9e	jsr $9ed0			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.9015	ca		dex				dex
.9016	ca		dex				dex
.9017	20 d0 9e	jsr $9ed0			jsr 	NSMRotateLeft
.901a	88		dey				dey 	 							; do 31 times
.901b	d0 f0		bne $900d			bne 	_I32SDLoop
.901d	7a		ply				ply 								; restore AY and exit
.901e	68		pla				pla
.901f	60		rts				rts
.9020					DivideCheckSubtract:
.9020	20 55 91	jsr $9155			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9023	b0 04		bcs $9029			bcs 	_DCSExit 					; if carry set, then could do, exit
.9025	20 2f 91	jsr $912f			jsr 	AddTopTwoStack 				; add it back in
.9028	18		clc				clc 								; and return False
.9029					_DCSExit:
.9029	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.902a					MulInteger:
.902a	fa		plx				plx
.902b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.902e	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9031	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9032	0a		asl a				asl 	a
.9033	10 05		bpl $903a			bpl 	_NotRef
.9035	48		pha				pha
.9036	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9039	68		pla				pla
.903a					_NotRef:
.903a	0a		asl a				asl 	a 							; put MSB of type into A:7
.903b	30 0b		bmi $9048			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.903d	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9040	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9043	f0 06		beq $904b			beq 	_IntegerCode 				; if clear, then we have two integers
.9045	4c 63 95	jmp $9563			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9048					_StringData:
.9048	4c 58 a0	jmp $a058			jmp 	NotDoneError							; at least one string - don't know both are strings.
.904b					_IntegerCode:
.904b	20 58 90	jsr $9058			jsr 	MultiplyShort
.904e	c9 00		cmp #$00			cmp 	#0
.9050	f0 05		beq $9057			beq 	_MIExit
.9052	a9 04		lda #$04		lda	#4
.9054	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.9057					_MIExit:
.9057	60		rts				rts
.9058					MultiplyShort:
.9058	5a		phy				phy 								; save Y
.9059	20 91 9e	jsr $9e91			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.905c	20 b6 9e	jsr $9eb6			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.905f	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9061					_I32MLoop:
.9061	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9064	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.9067	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.906a	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.906d	f0 28		beq $9097			beq 	_I32MExit 					; exit if zero
.906f	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9072	29 01		and #$01			and 	#1
.9074	f0 0e		beq $9084			beq 	_I32MNoAdd
.9076	20 2f 91	jsr $912f			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9079	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.907c	10 06		bpl $9084			bpl 	_I32MNoAdd
.907e					_I32ShiftRight:
.907e	20 dd 9e	jsr $9edd			jsr 	NSMShiftRight 				; shift S[X] right
.9081	c8		iny				iny 								; increment shift count
.9082	80 0a		bra $908e			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9084					_I32MNoAdd:
.9084	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9087	70 f5		bvs $907e			bvs 	_I32ShiftRight 				; instead.
.9089	e8		inx				inx
.908a	20 cf 9e	jsr $9ecf			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.908d	ca		dex				dex
.908e					_I32MShiftUpper:
.908e	e8		inx				inx 								; shift S[X+2] right
.908f	e8		inx				inx
.9090	20 dd 9e	jsr $9edd			jsr 	NSMShiftRight
.9093	ca		dex				dex
.9094	ca		dex				dex
.9095	80 ca		bra $9061			bra 	_I32MLoop 					; try again.
.9097					_I32MExit:
.9097	20 9d 90	jsr $909d			jsr 	CalculateSign
.909a	98		tya				tya 								; shift in A
.909b	7a		ply				ply 								; restore Y and exit
.909c	60		rts				rts
.909d					CalculateSign:
.909d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.90a0	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.90a3	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.90a6	0a		asl a				asl 	a 							; shift bit 7 into carry
.90a7	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.90aa	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.90ab					CompareStrings:
.90ab	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.90ae	3d 01 04	and $0401,x			and 	NSStatus+1,x
.90b1	29 10		and #$10			and 	#NSBIsString
.90b3	f0 2c		beq $90e1			beq 	_CSTypeError
.90b5	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.90b8	85 36		sta $36				sta 	zTemp0
.90ba	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.90bd	85 37		sta $37				sta 	zTemp0+1
.90bf	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.90c2	85 38		sta $38				sta 	zTemp1
.90c4	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.90c7	85 39		sta $39				sta 	zTemp1+1
.90c9	5a		phy				phy 								; save Y so we can access strings
.90ca	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.90cc					_CSLoop:
.90cc	c8		iny				iny
.90cd	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.90cf	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.90d1	d0 06		bne $90d9			bne 	_CSDifferent
.90d3	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.90d5	d0 f5		bne $90cc			bne 	_CSLoop 					; still comparing
.90d7					_CSExit:
.90d7	7a		ply				ply 								; reached end, return zero in A from EOS
.90d8	60		rts				rts
.90d9					_CSDifferent:
.90d9	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.90db	90 fa		bcc $90d7			bcc		_CSExit
.90dd	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.90df	80 f6		bra $90d7			bra 	_CSExit
.90e1					_CSTypeError:
.90e1	4c 4e a0	jmp $a04e			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.90e4					ShiftLeft:
.90e4	38		sec				sec
.90e5	80 01		bra $90e8			bra 	ShiftMain
.90e7					ShiftRight:
.90e7	18		clc				clc
.90e8					ShiftMain:
.90e8	fa		plx				plx 								; restore X
.90e9	08		php				php 								; save direction
.90ea	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90ed	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90f0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90f1	0a		asl a				asl 	a
.90f2	10 05		bpl $90f9			bpl 	_NotRef
.90f4	48		pha				pha
.90f5	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90f8	68		pla				pla
.90f9					_NotRef:
.90f9	0a		asl a				asl 	a
.90fa	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90fc	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90ff	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9102	f0 03		beq $9107			beq 	_IntegerCode 				; if clear, then we have two integers
.9104	4c 4e a0	jmp $a04e			jmp 	TypeError 					; anything else, type mismatch.
.9107					_IntegerCode:
.9107	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.910a	29 e0		and #$e0			and 	#$E0
.910c	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.910f	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.9112	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9115	d0 13		bne $912a			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9117					_SMLoop:
.9117	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.911a	30 11		bmi $912d			bmi 	_SMExit 					; exit if done.
.911c	28		plp				plp 								; restore direcition setting
.911d	08		php				php
.911e	90 05		bcc $9125			bcc 	_SMRight
.9120	20 cf 9e	jsr $9ecf			jsr 	NSMShiftLeft 				; shift left if CS
.9123	80 f2		bra $9117			bra 	_SMLoop
.9125					_SMRight:
.9125	20 dd 9e	jsr $9edd			jsr 	NSMShiftRight 				; shift right if CC
.9128	80 ed		bra $9117			bra 	_SMLoop
.912a					_SMExit0:
.912a	20 ba 9e	jsr $9eba			jsr 	NSMSetZero 					; return zero.
.912d					_SMExit:
.912d	28		plp				plp 								; throw direction
.912e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.912f					AddTopTwoStack:
.912f	18		clc				clc
.9130	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9133	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.9136	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9139	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.913c	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.913f	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9142	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9145	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.9148	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.914b	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.914e	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.9151	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9154	60		rts				rts
.9155					SubTopTwoStack:
.9155	38		sec				sec
.9156	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9159	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.915c	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.915f	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9162	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.9165	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9168	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.916b	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.916e	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9171	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9174	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.9177	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.917a	60		rts				rts
.917b					AddInteger:
.917b	fa		plx				plx
.917c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.917f	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9182	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9183	0a		asl a				asl 	a
.9184	10 05		bpl $918b			bpl 	_NotRef
.9186	48		pha				pha
.9187	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.918a	68		pla				pla
.918b					_NotRef:
.918b	0a		asl a				asl 	a 							; put MSB of type into A:7
.918c	30 0b		bmi $9199			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.918e	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9191	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9194	f0 06		beq $919c			beq 	_IntegerCode 				; if clear, then we have two integers
.9196	4c e3 93	jmp $93e3			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9199					_StringData:
.9199	4c 0b 8f	jmp $8f0b			jmp 	StringConcat							; at least one string - don't know both are strings.
.919c					_IntegerCode:
.919c					AddCode:
.919c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.919f	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.91a2	10 8b		bpl $912f			bpl 	AddTopTwoStack
.91a4	20 55 91	jsr $9155			jsr 	SubTopTwoStack 				; do a physical subtraction
.91a7	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.91aa	10 09		bpl $91b5			bpl 	_AddExit
.91ac	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.91af	9d 00 04	sta $0400,x			sta 	NSStatus,x
.91b2	20 6f 9e	jsr $9e6f			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.91b5					_AddExit:
.91b5	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; check for -0
.91b8	d0 03		bne $91bd			bne 	_AddNonZero
.91ba	9e 00 04	stz $0400,x			stz 	NSStatus,x
.91bd					_AddNonZero:
.91bd	60		rts				rts
.91be					SubInteger:
.91be	fa		plx				plx
.91bf	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91c2	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91c5	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91c6	0a		asl a				asl 	a
.91c7	10 05		bpl $91ce			bpl 	_NotRef
.91c9	48		pha				pha
.91ca	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91cd	68		pla				pla
.91ce					_NotRef:
.91ce	0a		asl a				asl 	a 							; put MSB of type into A:7
.91cf	30 0b		bmi $91dc			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91d1	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91d4	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91d7	f0 06		beq $91df			beq 	_IntegerCode 				; if clear, then we have two integers
.91d9	4c e8 93	jmp $93e8			jmp 	FloatingPointSub 							; otherwise at least one float.
.91dc					_StringData:
.91dc	4c 58 a0	jmp $a058			jmp 	NotDoneError							; at least one string - don't know both are strings.
.91df					_IntegerCode:
.91df	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.91e2	49 80		eor #$80			eor 	#$80
.91e4	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.91e7	80 b3		bra $919c			bra 	AddCode 					; and do the same code as add.
.91e9					AndInteger:
.91e9	fa		plx				plx
.91ea	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91ed	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91f0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91f1	0a		asl a				asl 	a
.91f2	10 05		bpl $91f9			bpl 	_NotRef
.91f4	48		pha				pha
.91f5	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f8	68		pla				pla
.91f9					_NotRef:
.91f9	0a		asl a				asl 	a
.91fa	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91fc	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91ff	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9202	f0 03		beq $9207			beq 	_IntegerCode 				; if clear, then we have two integers
.9204	4c 4e a0	jmp $a04e			jmp 	TypeError 					; anything else, type mismatch.
.9207					_IntegerCode:
.9207	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.920a	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.920d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9210	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9213	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.9216	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9219	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.921c	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.921f	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9222	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9225	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.9228	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.922b	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.922e	60		rts				rts
.922f					OraInteger:
.922f	fa		plx				plx
.9230	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9233	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9236	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9237	0a		asl a				asl 	a
.9238	10 05		bpl $923f			bpl 	_NotRef
.923a	48		pha				pha
.923b	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.923e	68		pla				pla
.923f					_NotRef:
.923f	0a		asl a				asl 	a
.9240	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9242	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9245	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9248	f0 03		beq $924d			beq 	_IntegerCode 				; if clear, then we have two integers
.924a	4c 4e a0	jmp $a04e			jmp 	TypeError 					; anything else, type mismatch.
.924d					_IntegerCode:
.924d	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9250	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.9253	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9256	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9259	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.925c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.925f	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9262	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.9265	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9268	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.926b	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.926e	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9271	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9274	60		rts				rts
.9275					EorInteger:
.9275	fa		plx				plx
.9276	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9279	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.927c	0a		asl a				asl 	a 							; shift reference bit into sign bit
.927d	0a		asl a				asl 	a
.927e	10 05		bpl $9285			bpl 	_NotRef
.9280	48		pha				pha
.9281	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9284	68		pla				pla
.9285					_NotRef:
.9285	0a		asl a				asl 	a
.9286	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9288	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.928b	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.928e	f0 03		beq $9293			beq 	_IntegerCode 				; if clear, then we have two integers
.9290	4c 4e a0	jmp $a04e			jmp 	TypeError 					; anything else, type mismatch.
.9293					_IntegerCode:
.9293	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9296	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.9299	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.929c	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.929f	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.92a2	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.92a5	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.92a8	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.92ab	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.92ae	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.92b1	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.92b4	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.92b7	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.92ba	60		rts				rts
.92bb					WordIndirect:
.92bb	fa		plx				plx
.92bc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92bf	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92c2	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92c3	0a		asl a				asl 	a
.92c4	10 05		bpl $92cb			bpl 	_NotRef
.92c6	48		pha				pha
.92c7	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92ca	68		pla				pla
.92cb					_NotRef:
.92cb	0a		asl a				asl 	a
.92cc	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92ce	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92d1	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92d4	f0 03		beq $92d9			beq 	_IntegerCode 				; if clear, then we have two integers
.92d6	4c 4e a0	jmp $a04e			jmp 	TypeError 					; anything else, type mismatch.
.92d9					_IntegerCode:
.92d9	20 9c 91	jsr $919c			jsr 	AddCode 					; add the two values
.92dc	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.92de	9d 00 04	sta $0400,x			sta 	NSStatus,x
.92e1	60		rts				rts
.92e2					ByteIndirect:
.92e2	fa		plx				plx
.92e3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92e6	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92e9	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92ea	0a		asl a				asl 	a
.92eb	10 05		bpl $92f2			bpl 	_NotRef
.92ed	48		pha				pha
.92ee	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92f1	68		pla				pla
.92f2					_NotRef:
.92f2	0a		asl a				asl 	a
.92f3	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92f5	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92f8	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92fb	f0 03		beq $9300			beq 	_IntegerCode 				; if clear, then we have two integers
.92fd	4c 4e a0	jmp $a04e			jmp 	TypeError 					; anything else, type mismatch.
.9300					_IntegerCode:
.9300	20 9c 91	jsr $919c			jsr 	AddCode 					; add the two values
.9303	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9305	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9308	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9309					LCLConvertInt16:
.9309	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.930c	8e 10 04	stx $0410			stx 	NSMantissa1
.930f	9c 18 04	stz $0418			stz 	NSMantissa2
.9312	9c 20 04	stz $0420			stz 	NSMantissa3
.9315	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.9318	a2 00		ldx #$00			ldx 	#0 							; stack level
.931a	a9 0a		lda #$0a			lda 	#10 						; base
.931c	80 00		bra $931e			bra 	ConvertInt32
.931e					ConvertInt32:
.931e	5a		phy				phy
.931f	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9321	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.9324	10 08		bpl $932e			bpl 	_CI32NotNeg
.9326	48		pha				pha
.9327	a9 2d		lda #$2d			lda 	#'-'
.9329	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.932c	c8		iny				iny
.932d	68		pla				pla
.932e					_CI32NotNeg:
.932e	20 3c 93	jsr $933c			jsr 	_CI32DivideConvert 			; recursive conversion
.9331	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9333	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.9336	7a		ply				ply
.9337	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.9339	a9 fa		lda #$fa			lda 	#NumberBuffer & $FF
.933b	60		rts				rts
.933c					_CI32DivideConvert:
.933c	e8		inx				inx 								; write to next slot up
.933d	20 bc 9e	jsr $9ebc			jsr 	NSMSetByte
.9340	ca		dex				dex
.9341	20 e0 8f	jsr $8fe0			jsr 	Int32Divide 				; divide
.9344	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.9347	48		pha				pha
.9348	20 8f 8f	jsr $8f8f			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.934b	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; is it zero ?
.934e	f0 06		beq $9356			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9350	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9353	20 3c 93	jsr $933c			jsr 	_CI32DivideConvert 			; and recusrively call.
.9356					_CI32NoRecurse:
.9356	68		pla				pla 								; remainder
.9357	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.9359	90 02		bcc $935d			bcc 	_CI32NotHex
.935b	69 26		adc #$26			adc 	#6+32
.935d					_CI32NotHex:
.935d	69 30		adc #$30			adc 	#48
.935f	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y 				; write out and exit
.9362	c8		iny				iny
.9363	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9364					PrecedenceLevel:
>9364	04					.byte	 4	; $00 <<
>9365	02					.byte	 2	; $01 <=
>9366	02					.byte	 2	; $02 <>
>9367	00					.byte	 0	; $03 !!3
>9368	00					.byte	 0	; $04 ><
>9369	02					.byte	 2	; $05 >=
>936a	04					.byte	 4	; $06 >>
>936b	00					.byte	 0	; $07 !!7
>936c	00					.byte	 0	; $08 !!8
>936d	00					.byte	 0	; $09 !!9
>936e	00					.byte	 0	; $0a !!10
>936f	00					.byte	 0	; $0b !!11
>9370	00					.byte	 0	; $0c !!12
>9371	00					.byte	 0	; $0d !!13
>9372	00					.byte	 0	; $0e !!14
>9373	00					.byte	 0	; $0f !!15
>9374	00					.byte	 0	; $10 @
>9375	00					.byte	 0	; $11 !!17
>9376	00					.byte	 0	; $12 !!18
>9377	00					.byte	 0	; $13 [
>9378	04					.byte	 4	; $14 \
>9379	00					.byte	 0	; $15 ]
>937a	01					.byte	 1	; $16 ^
>937b	00					.byte	 0	; $17 _
>937c	00					.byte	 0	; $18 `
>937d	00					.byte	 0	; $19 !!25
>937e	00					.byte	 0	; $1a !!26
>937f	00					.byte	 0	; $1b {
>9380	01					.byte	 1	; $1c |
>9381	00					.byte	 0	; $1d }
>9382	00					.byte	 0	; $1e ~
>9383	00					.byte	 0	; $1f [7m<7F>[m
>9384	00					.byte	 0	; $20
>9385	05					.byte	 5	; $21 !
>9386	00					.byte	 0	; $22 "
>9387	00					.byte	 0	; $23 #
>9388	05					.byte	 5	; $24 $
>9389	04					.byte	 4	; $25 %
>938a	01					.byte	 1	; $26 &
>938b	00					.byte	 0	; $27 '
>938c	00					.byte	 0	; $28 (
>938d	00					.byte	 0	; $29 )
>938e	04					.byte	 4	; $2a *
>938f	03					.byte	 3	; $2b +
>9390	00					.byte	 0	; $2c ,
>9391	03					.byte	 3	; $2d -
>9392	00					.byte	 0	; $2e .
>9393	04					.byte	 4	; $2f /
>9394	00					.byte	 0	; $30 0
>9395	00					.byte	 0	; $31 1
>9396	00					.byte	 0	; $32 2
>9397	00					.byte	 0	; $33 3
>9398	00					.byte	 0	; $34 4
>9399	00					.byte	 0	; $35 5
>939a	00					.byte	 0	; $36 6
>939b	00					.byte	 0	; $37 7
>939c	00					.byte	 0	; $38 8
>939d	00					.byte	 0	; $39 9
>939e	00					.byte	 0	; $3a :
>939f	00					.byte	 0	; $3b ;
>93a0	02					.byte	 2	; $3c <
>93a1	02					.byte	 2	; $3d =
>93a2	02					.byte	 2	; $3e >
>93a3	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93a4					EvaluateExpressionAt0:
.93a4	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93a6					EvaluateExpression:
.93a6	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93a8					EvaluateExpressionAtPrecedence:
.93a8	48		pha				pha 								; save precedence level
.93a9	20 80 98	jsr $9880			jsr 	EvaluateTerm 				; evaluate term into level X.
.93ac	68		pla				pla 								; restore precedence level.
.93ad					_EXPRLoop:
.93ad	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.93af	b1 30		lda ($30),y			lda 	(codePtr),y
.93b1	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.93b3	b0 25		bcs $93da			bcs 	_EXPRExit
.93b5	da		phx				phx 								; read the operator precedence
.93b6	aa		tax				tax
.93b7	bd 64 93	lda $9364,x			lda 	PrecedenceLevel,x
.93ba	fa		plx				plx
.93bb	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.93bd	f0 1b		beq $93da			beq 	_EXPRExit
.93bf	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93c1	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93c3	c5 37		cmp $37				cmp 	zTemp0+1
.93c5	b0 13		bcs $93da			bcs		_EXPRExit 					; if current >= operator exit
.93c7	48		pha				pha 								; save current precedence.
.93c8	b1 30		lda ($30),y			lda 	(codePtr),y
.93ca	c8		iny				iny
.93cb	48		pha				pha
.93cc	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93ce	e8		inx				inx 								; work out the right hand side.
.93cf	20 a8 93	jsr $93a8			jsr 	EvaluateExpressionAtPrecedence
.93d2	ca		dex				dex
.93d3	68		pla				pla 								; get operator, call the code.
.93d4	20 dd 93	jsr $93dd			jsr 	_EXPRCaller
.93d7	68		pla				pla 								; restore precedence level
.93d8	80 d3		bra $93ad			bra 	_EXPRLoop 					; and go round.
.93da					_EXPRExit:
.93da	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93dc	60		rts				rts
.93dd					_EXPRCaller:
.93dd	da		phx				phx 								; save on stack, first thing is to restore it
.93de	0a		asl a				asl 	a 							; double so can use vectors into X
.93df	aa		tax				tax
.93e0	7c 1e 8b	jmp ($8b1e,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.93e3					FloatingPointAdd:
.93e3	20 8c 95	jsr $958c			jsr 	FloatPrepare 				; prepare for floats
.93e6	80 0b		bra $93f3			bra 	FloatAdd
.93e8					FloatingPointSub:
.93e8	20 8c 95	jsr $958c			jsr 	FloatPrepare 				; prepare for floats
.93eb					FloatSubtract:
.93eb	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.93ee	49 80		eor #$80			eor 	#$80
.93f0	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.93f3					FloatAdd:
.93f3	48		pha				pha
.93f4	5a		phy				phy
.93f5	20 9d 95	jsr $959d			jsr 	NSNormalise 				; normalise S[X]
.93f8	f0 5c		beq $9456			beq 	_FAReturn1
.93fa	e8		inx				inx 								; normalise S[X+1]
.93fb	20 9d 95	jsr $959d			jsr 	NSNormalise
.93fe	ca		dex				dex
.93ff	c9 00		cmp #$00			cmp 	#0
.9401	f0 77		beq $947a			beq 	_FAExit 					; if so, just return A
.9403	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.9406	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.9409	f0 1b		beq $9426			beq 	_FAExponentsEqual
.940b	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.940e	a8		tay				tay
.940f	38		sec				sec 								; do a signed comparison of the exponents.
.9410	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9413	50 02		bvc $9417			bvc 	_FANoSignedChange
.9415	49 80		eor #$80			eor 	#$80
.9417					_FANoSignedChange:
.9417	29 80		and #$80			and 	#$80
.9419	10 03		bpl $941e			bpl 	_FAHaveMax
.941b	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.941e					_FAHaveMax:
.941e	20 7d 94	jsr $947d			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9421	e8		inx				inx
.9422	20 7d 94	jsr $947d			jsr 	_FAShiftToExponent
.9425	ca		dex				dex
.9426					_FAExponentsEqual:
.9426	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.9429	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.942c	30 10		bmi $943e			bmi 	_FADifferentSigns
.942e	20 2f 91	jsr $912f			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9431	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9434	10 44		bpl $947a			bpl 	_FAExit 					; if no, we are done.
.9436	20 dd 9e	jsr $9edd			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9439	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.943c	80 3c		bra $947a			bra 	_FAExit
.943e					_FADifferentSigns:
.943e	20 55 91	jsr $9155			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9441	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.9444	10 06		bpl $944c			bpl 	_FACheckZero 				; if no, check for -0
.9446	20 66 9e	jsr $9e66			jsr 	NSMNegate 					; netate result
.9449	20 6f 9e	jsr $9e6f			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.944c					_FACheckZero:
.944c	20 ea 9e	jsr $9eea			jsr 	NSMIsZero	 				; check for -0
.944f	d0 29		bne $947a			bne 	_FAExit
.9451	9e 00 04	stz $0400,x			stz 	NSStatus,x
.9454	80 24		bra $947a			bra 	_FAExit
.9456					_FAReturn1:
.9456	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9459	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.945c	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.945f	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9462	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9465	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9468	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.946b	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.946e	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9471	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9474	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9477	9d 00 04	sta $0400,x			sta 	NSStatus,x
.947a					_FAExit:
.947a	7a		ply				ply
.947b	68		pla				pla
.947c	60		rts				rts
.947d					_FAShiftToExponent:
.947d					_FAShiftToExponent2:
.947d	98		tya				tya 								; compare Y to exponent
.947e	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9481	f0 08		beq $948b			beq 	_FASEExit 					; exit if so.
.9483	20 dd 9e	jsr $9edd			jsr 	NSMShiftRight	 			; shift the mantissa right
.9486	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.9489	80 f2		bra $947d			bra 	_FAShiftToExponent2
.948b					_FASEExit:
.948b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.948c					CompareFloat:
.948c	20 eb 93	jsr $93eb			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.948f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9492	29 f8		and #$f8			and 	#$F8
.9494	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9497	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.949a	f0 09		beq $94a5			beq 	_FCExit 					; zero, so approximately identical
.949c	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.949e	3c 00 04	bit $0400,x			bit 	NSStatus,x
.94a1	10 02		bpl $94a5			bpl 	_FCExit
.94a3					_FCNegative:
.94a3	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94a5					_FCExit:
.94a5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94a6					FDivideCommand:
.94a6	fa		plx				plx	 								; restore stack position
.94a7	20 8c 95	jsr $958c			jsr 	FloatPrepare 				; prepare for floats
.94aa					FloatDivide:
.94aa	48		pha				pha
.94ab	e8		inx				inx
.94ac	20 9d 95	jsr $959d			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94af	ca		dex				dex
.94b0	c9 00		cmp #$00			cmp 	#0
.94b2	f0 20		beq $94d4			beq 	_FDZero
.94b4	20 9d 95	jsr $959d			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94b7	f0 19		beq $94d2			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94b9	20 02 90	jsr $9002			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94bc	20 8f 8f	jsr $8f8f			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94bf	20 9d 95	jsr $959d			jsr		NSNormalise 				; renormalise
.94c2	20 9d 90	jsr $909d			jsr 	CalculateSign 				; calculate result sign
.94c5	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.94c8	38		sec				sec
.94c9	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.94cc	38		sec				sec
.94cd	e9 1e		sbc #$1e			sbc 	#30
.94cf	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94d2					_FDExit:
.94d2	68		pla				pla
.94d3	60		rts				rts
.94d4					_FDZero:
.94d4	a9 03		lda #$03		lda	#3
.94d6	4c f7 8d	jmp $8df7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.94d9					FloatFractionalPart:
.94d9	5a		phy				phy
.94da	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.94dd	29 7f		and #$7f			and 	#$7F
.94df	9d 00 04	sta $0400,x			sta 	NSStatus,x
.94e2	20 9d 95	jsr $959d			jsr 	NSNormalise
.94e5	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.94e8	38		sec				sec
.94e9	e9 e0		sbc #$e0			sbc 	#$E0
.94eb	90 31		bcc $951e			bcc 	_FFPExit 					; already fractional
.94ed	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.94ef	b0 2a		bcs $951b			bcs 	_FFPZero
.94f1	a8		tay				tay 								; put count to do in Y
.94f2	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.94f5	20 20 95	jsr $9520			jsr 	_FFPPartial
.94f8	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.94fb	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.94fe	20 20 95	jsr $9520			jsr 	_FFPPartial
.9501	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9504	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9507	20 20 95	jsr $9520			jsr 	_FFPPartial
.950a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.950d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9510	20 20 95	jsr $9520			jsr 	_FFPPartial
.9513	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9516	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; zeroed check.
.9519	d0 03		bne $951e			bne 	_FFPExit
.951b					_FFPZero:
.951b	20 ba 9e	jsr $9eba			jsr 	NSMSetZero
.951e					_FFPExit:
.951e	7a		ply				ply
.951f	60		rts				rts
.9520					_FFPPartial:
.9520	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9522	f0 17		beq $953b			beq 	_FFFPPExit
.9524	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9526	b0 0c		bcs $9534			bcs 	_FFFPPWholeByte
.9528	5a		phy				phy
.9529					_FFFPPLeft:
.9529	0a		asl a				asl 	a
.952a	88		dey				dey
.952b	d0 fc		bne $9529			bne 	_FFFPPLeft
.952d	7a		ply				ply
.952e					_FFFPPRight:
.952e	4a		lsr a				lsr 	a
.952f	88		dey				dey
.9530	d0 fc		bne $952e			bne 	_FFFPPRight
.9532	80 07		bra $953b			bra 	_FFFPPExit
.9534					_FFFPPWholeByte:
.9534	98		tya				tya 								; subtract 8 from count
.9535	38		sec				sec
.9536	e9 08		sbc #$08			sbc 	#8
.9538	a8		tay				tay
.9539	a9 00		lda #$00			lda 	#0 							; and clear all
.953b					_FFFPPExit:
.953b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.953c					FloatIntegerPart:
.953c	48		pha				pha
.953d	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.9540	f0 1f		beq $9561			beq 	_FIPExit 					; if so do nothing
.9542	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; is it zero ?
.9545	f0 17		beq $955e			beq 	_FIPZero 					; if so return zero.
.9547	20 9d 95	jsr $959d			jsr 	NSNormalise 				; normalise
.954a	f0 12		beq $955e			beq 	_FIPZero 					; normalised to zero, exit zero
.954c					_FIPShift:
.954c	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.954f	10 08		bpl $9559			bpl 	_FIPCheckZero
.9551	20 dd 9e	jsr $9edd			jsr 	NSMShiftRight 				; shift mantissa right
.9554	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.9557	80 f3		bra $954c			bra 	_FIPShift
.9559					_FIPCheckZero:
.9559	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; avoid -0 problem
.955c	d0 03		bne $9561			bne 	_FIPExit 					; set to zero if mantissa zero.
.955e					_FIPZero:
.955e	20 ba 9e	jsr $9eba			jsr 	NSMSetZero
.9561					_FIPExit:
.9561	68		pla				pla
.9562	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9563					FloatingPointMultiply:
.9563	20 8c 95	jsr $958c			jsr 	FloatPrepare 				; prepare for floats
.9566					FloatMultiply:
.9566	48		pha				pha
.9567	20 9d 95	jsr $959d			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.956a	f0 1b		beq $9587			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.956c	e8		inx				inx
.956d	20 9d 95	jsr $959d			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9570	ca		dex				dex
.9571	c9 00		cmp #$00			cmp 	#0
.9573	f0 0f		beq $9584			beq 	_FDSetZero
.9575	20 58 90	jsr $9058			jsr 	MultiplyShort 				; calculate the result.
.9578	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.957b	18		clc				clc
.957c	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.957f	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9582	80 03		bra $9587			bra 	_FDExit
.9584					_FDSetZero:
.9584	20 ba 9e	jsr $9eba			jsr 	NSMSetZero 					; return 0
.9587					_FDExit:
.9587	20 9d 95	jsr $959d			jsr 	NSNormalise 				; normalise the result
.958a	68		pla				pla
.958b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.958c					FloatPrepare:
.958c	20 bf 96	jsr $96bf			jsr 	DereferenceTopTwo 			; dereference the top two values
.958f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.9592	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9595	29 10		and #$10			and 	#NSBIsString
.9597	d0 01		bne $959a			bne 	_FDType
.9599	60		rts				rts
.959a					_FDType:
.959a	4c 4e a0	jmp $a04e			jmp 	TypeError
.959d					NSNormalise:
.959d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.95a0	29 80		and #$80			and 	#$80
.95a2	09 08		ora #$08			ora 	#NSTFloat
.95a4	9d 00 04	sta $0400,x			sta 	NSStatus,x
.95a7	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; if zero exit
.95aa	d0 09		bne $95b5			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95ac	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.95af	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.95b2	a9 00		lda #$00			lda 	#0 							; set Z flag
.95b4	60		rts				rts
.95b5					_NSNormaliseOptimise:
.95b5	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95b8	d0 22		bne $95dc			bne 	_NSNormaliseLoop
.95ba	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.95bd	30 1d		bmi $95dc			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95bf	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.95c2	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95c5	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.95c8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95cb	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.95ce	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.95d1	bd 28 04	lda $0428,x			lda 	NSExponent,x
.95d4	38		sec				sec
.95d5	e9 08		sbc #$08			sbc 	#8
.95d7	9d 28 04	sta $0428,x			sta 	NSExponent,x
.95da	80 d9		bra $95b5			bra 	_NSNormaliseOptimise
.95dc					_NSNormaliseLoop:
.95dc	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95df	70 08		bvs $95e9			bvs 	_NSNExit 					; exit if so with Z flag clear
.95e1	20 cf 9e	jsr $9ecf			jsr 	NSMShiftLeft 				; shift mantissa left
.95e4	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.95e7	80 f3		bra $95dc			bra 	_NSNormaliseLoop
.95e9					_NSNExit:
.95e9	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95eb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.95ec					AssignNumber:
.95ec	5a		phy				phy
.95ed	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.95f0	85 36		sta $36				sta 	zTemp0
.95f2	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95f5	85 37		sta $37				sta 	zTemp0+1
.95f7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.95fa	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.95fc	9d 00 04	sta $0400,x			sta 	NSStatus,x
.95ff	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9601	c9 08		cmp #$08			cmp 	#NSTFloat
.9603	f0 2a		beq $962f			beq 	_ANFloat
.9605	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.9608	f0 05		beq $960f			beq		_ANNotFloat
.960a	e8		inx				inx
.960b	20 3c 95	jsr $953c			jsr 	FloatIntegerPart 			; make it an integer
.960e	ca		dex				dex
.960f					_ANNotFloat:
.960f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.9612	29 03		and #$03			and 	#3
.9614	d0 05		bne $961b			bne 	_ANByteWord
.9616	20 3b 96	jsr $963b			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9619	80 1e		bra $9639			bra 	_ANExit
.961b					_ANByteWord:
.961b	48		pha				pha 								; save count
.961c	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.961f	92 36		sta ($36)			sta 	(zTemp0)
.9621	68		pla				pla
.9622	c9 01		cmp #$01			cmp	 	#1
.9624	f0 13		beq $9639			beq 	_ANExit
.9626	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.9629	a0 01		ldy #$01			ldy 	#1
.962b	91 36		sta ($36),y			sta 	(zTemp0),y
.962d	80 0a		bra $9639			bra 	_ANExit
.962f					_ANFloat:
.962f	20 3b 96	jsr $963b			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9632	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9635	a0 04		ldy #$04			ldy 	#4
.9637	91 36		sta ($36),y			sta 	(zTemp0),y
.9639					_ANExit:
.9639	7a		ply				ply
.963a	60		rts				rts
.963b					_ANCopy4PackSign:
.963b	a0 03		ldy #$03			ldy 	#3
.963d	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.9640	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9642	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9645	91 36		sta ($36),y			sta 	(zTemp0),y
.9647	88		dey				dey
.9648	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.964b	91 36		sta ($36),y			sta 	(zTemp0),y
.964d	88		dey				dey
.964e	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9651	91 36		sta ($36),y			sta 	(zTemp0),y
.9653	88		dey				dey
.9654	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9657	91 36		sta ($36),y			sta 	(zTemp0),y
.9659	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.965a					AssignString:
.965a	5a		phy				phy
.965b	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.965e	85 38		sta $38				sta 	zTemp1
.9660	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9663	85 39		sta $39				sta 	zTemp1+1
.9665	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9668	85 36		sta $36				sta 	zTemp0
.966a	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.966d	85 37		sta $37				sta 	zTemp0+1
.966f	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9671	b1 36		lda ($36),y			lda 	(zTemp0),y
.9673	f0 23		beq $9698			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9675	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9676	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9678	e9 02		sbc #$02			sbc 	#2
.967a	85 3c		sta $3c				sta 	zsTemp
.967c	a0 01		ldy #$01			ldy 	#1
.967e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9680	e9 00		sbc #$00			sbc 	#0
.9682	85 3d		sta $3d				sta 	zsTemp+1
.9684	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9686					_ASGetLength:
.9686	c8		iny				iny
.9687	b1 38		lda ($38),y			lda 	(zTemp1),y
.9689	d0 fb		bne $9686			bne 	_ASGetLength
.968b	98		tya				tya 								; is this length <= current length
.968c	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.968e	90 20		bcc $96b0			bcc 	_ASCopyString
.9690	f0 1e		beq $96b0			beq 	_ASCopyString
.9692	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9694	a0 01		ldy #$01			ldy 	#1
.9696	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9698					_ASNewStringRequired:
.9698	e8		inx				inx 								; concrete the new string.
.9699	20 b6 a7	jsr $a7b6			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.969c	ca		dex				dex
.969d	18		clc				clc
.969e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96a1	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96a3	92 36		sta ($36)			sta 	(zTemp0)
.96a5	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.96a8	69 00		adc #$00			adc 	#0
.96aa	a0 01		ldy #$01			ldy 	#1
.96ac	91 36		sta ($36),y			sta 	(zTemp0),y
.96ae	80 0d		bra $96bd			bra 	_ASExit
.96b0					_ASCopyString:
.96b0	a0 00		ldy #$00			ldy 	#0
.96b2					_ASCopyLoop:
.96b2	b1 38		lda ($38),y			lda 	(zTemp1),y
.96b4	c8		iny				iny
.96b5	c8		iny				iny
.96b6	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96b8	88		dey				dey
.96b9	c9 00		cmp #$00			cmp 	#0
.96bb	d0 f5		bne $96b2			bne 	_ASCopyLoop
.96bd					_ASExit:
.96bd	7a		ply				ply
.96be	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96bf					DereferenceTopTwo:
.96bf	e8		inx				inx
.96c0	20 c4 96	jsr $96c4			jsr 	Dereference 				; deref x+1
.96c3	ca		dex				dex  								; falls through to deref x
.96c4					Dereference:
.96c4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.96c7	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.96c9	f0 57		beq $9722			beq 	_DRFExit 					; not a reference
.96cb	5a		phy				phy
.96cc	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96cf	85 36		sta $36				sta 	zTemp0
.96d1	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.96d4	85 37		sta $37				sta 	zTemp0+1
.96d6	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.96d9	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96db	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.96de	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.96e1	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96e3	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96e5	f0 0f		beq $96f6			beq 	_DRFDereferenceTwo
.96e7	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96e9	f0 39		beq $9724			beq 	_DRFFull
.96eb	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96ee	29 03		and #$03			and 	#3
.96f0	f0 32		beq $9724			beq 	_DRFFull 					; the whole word
.96f2	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96f4	f0 07		beq $96fd			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96f6					_DRFDereferenceTwo:
.96f6	a0 01		ldy #$01			ldy 	#1
.96f8	b1 36		lda ($36),y			lda 	(zTemp0),y
.96fa	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.96fd					_DRFClear23:
.96fd	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9700	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9703	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.9706	29 18		and #$18			and 	#NSBTypeMask
.9708	9d 00 04	sta $0400,x			sta 	NSStatus,x
.970b	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.970d	d0 12		bne $9721			bne 	_DRFNotString
.970f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.9712	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9715	d0 0a		bne $9721			bne 	_DRFNotString
.9717	a9 23		lda #$23			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9719	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.971c	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.971e	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.9721					_DRFNotString
.9721	7a		ply				ply 								; restore Y and exit
.9722					_DRFExit:
.9722	60		rts				rts
.9723					_DRFNullString:
>9723	00						.byte 	0
.9724					_DRFFull:
.9724	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9726	b1 36		lda ($36),y			lda 	(zTemp0),y
.9728	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.972b	c8		iny				iny
.972c	b1 36		lda ($36),y			lda 	(zTemp0),y
.972e	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9731	c8		iny				iny
.9732	b1 36		lda ($36),y			lda 	(zTemp0),y
.9734	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9737	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.973a	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.973d	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.973f	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.9742	f0 06		beq $974a			beq 	_DRFNoExponent
.9744	c8		iny				iny 								; if not, read the exponent as well.
.9745	b1 36		lda ($36),y			lda 	(zTemp0),y
.9747	9d 28 04	sta $0428,x			sta 	NSExponent,x
.974a					_DRFNoExponent:
.974a	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.974d	10 0d		bpl $975c			bpl 	_DRFExit2 					; if not, then exit.
.974f	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9751	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9754	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.9757	09 80		ora #$80			ora 	#NSBIsNegative
.9759	9d 00 04	sta $0400,x			sta 	NSStatus,x
.975c					_DRFExit2:
.975c	7a		ply				ply
.975d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.975e					EncodeNumberStart:
.975e	38		sec				sec
.975f	80 01		bra $9762			bra 	EncodeNumberContinue+1
.9761					EncodeNumberContinue:
.9761	18		clc				clc
.9762					EncodeNumber:
.9762	08		php				php 								; save reset.
.9763	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9765	f0 12		beq $9779			beq 	_ENIsOkay
.9767	c9 30		cmp #$30			cmp 	#"0"
.9769	90 04		bcc $976f			bcc 	_ENBadNumber
.976b	c9 3a		cmp #$3a			cmp 	#"9"+1
.976d	90 0a		bcc $9779			bcc 	_ENIsOkay
.976f					_ENBadNumber:
.976f	28		plp				plp 								; throw saved reset
.9770	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.9773	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9775	f0 7e		beq $97f5			beq 	_ENConstructFinal
.9777					_ENFail:
.9777	18		clc				clc 								; not allowed
.9778	60		rts				rts
.9779					_ENIsOkay:
.9779	28		plp				plp 								; are we restarting
.977a	90 15		bcc $9791			bcc 	_ENNoRestart
.977c					_ENStartEncode:
.977c	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.977e	f0 0c		beq $978c			beq 	_ENFirstDP
.9780	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.9782	20 bc 9e	jsr $9ebc			jsr 	NSMSetByte
.9785	a9 01		lda #$01			lda 	#ESTA_Low
.9787					_ENExitChange:
.9787	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.978a	38		sec				sec
.978b	60		rts				rts
.978c					_ENFirstDP:
.978c	20 ba 9e	jsr $9eba			jsr 	NSMSetZero 					; clear integer part
.978f	80 3f		bra $97d0			bra 	_ESTASwitchFloat			; go straight to float and exi
.9791					_ENNoRestart:
.9791	48		pha				pha 								; save on stack.
.9792	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.9795	c9 01		cmp #$01			cmp 	#ESTA_Low
.9797	f0 09		beq $97a2			beq  	_ESTALowState
.9799	c9 02		cmp #$02			cmp 	#ESTA_High
.979b	f0 29		beq $97c6			beq 	_ESTAHighState
.979d	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.979f	f0 3b		beq $97dc			beq 	_ESTADecimalState
>97a1	db						.byte 	$DB 						; causes a break in the emulator
.97a2					_ESTALowState:
.97a2	68		pla				pla 								; get value back
.97a3	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.97a5	f0 29		beq $97d0			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.97a7	29 0f		and #$0f			and 	#15 						; make digit
.97a9	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.97ac	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97af	0a		asl a				asl 	a
.97b0	0a		asl a				asl 	a
.97b1	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97b4	0a		asl a				asl 	a
.97b5	6d 86 04	adc $0486			adc 	DigitTemp
.97b8	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97bb	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97bd	90 05		bcc $97c4			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97bf	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97c1	8d 85 04	sta $0485			sta 	EncodeState
.97c4					_ESTANoSwitch:
.97c4	38		sec				sec
.97c5	60		rts				rts
.97c6					_ESTAHighState:
.97c6	68		pla				pla 								; get value back
.97c7	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97c9	f0 05		beq $97d0			beq 	_ESTASwitchFloat
.97cb	20 2f 98	jsr $982f			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97ce	38		sec				sec
.97cf	60		rts				rts
.97d0					_ESTASwitchFloat:
.97d0	9c 87 04	stz $0487			stz 	DecimalCount
.97d3	e8		inx				inx 								; zero the decimal additive.
.97d4	20 ba 9e	jsr $9eba			jsr 	NSMSetZero
.97d7	ca		dex				dex
.97d8	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97da	80 ab		bra $9787			bra 	_ENExitChange
.97dc					_ESTADecimalState:
.97dc	68		pla				pla 								; digit.
.97dd	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97df	f0 96		beq $9777			beq 	_ENFail
.97e1	e8		inx				inx 								; put digit into fractional part of X+1
.97e2	20 2f 98	jsr $982f			jsr 	ESTAShiftDigitIntoMantissa
.97e5	ca		dex				dex
.97e6	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.97e9	ad 87 04	lda $0487			lda 	DecimalCount
.97ec	c9 0b		cmp #$0b			cmp 	#11
.97ee	f0 02		beq $97f2			beq 	_ESTADSFail
.97f0	38		sec				sec
.97f1	60		rts				rts
.97f2					_ESTADSFail:
.97f2	4c 49 a0	jmp $a049			jmp 	RangeError
.97f5					_ENConstructFinal:
.97f5	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.97f8	f0 33		beq $982d			beq 	_ENCFExit 					; no decimals
.97fa	5a		phy				phy
.97fb	0a		asl a				asl 	a 							; x 4 and CLC
.97fc	0a		asl a				asl 	a
.97fd	6d 87 04	adc $0487			adc 	DecimalCount
.9800	a8		tay				tay
.9801	b9 08 a0	lda $a008,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9804	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9807	b9 09 a0	lda $a009,y			lda 	DecimalScalarTable-5+1,y
.980a	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.980d	b9 0a a0	lda $a00a,y			lda 	DecimalScalarTable-5+2,y
.9810	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9813	b9 0b a0	lda $a00b,y			lda 	DecimalScalarTable-5+3,y
.9816	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9819	b9 0c a0	lda $a00c,y			lda 	DecimalScalarTable-5+4,y
.981c	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.981f	a9 08		lda #$08			lda 	#NSTFloat
.9821	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9824	7a		ply				ply
.9825	e8		inx				inx 								; multiply decimal const by decimal scalar
.9826	20 66 95	jsr $9566			jsr 	FloatMultiply
.9829	ca		dex				dex
.982a	20 f3 93	jsr $93f3			jsr 	FloatAdd 					; add to integer part.
.982d					_ENCFExit:
.982d	18		clc				clc 								; reject the digit.
.982e	60		rts				rts
.982f					ESTAShiftDigitIntoMantissa:
.982f	29 0f		and #$0f			and 	#15 						; save digit
.9831	48		pha				pha
.9832	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9835	48		pha				pha
.9836	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9839	48		pha				pha
.983a	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.983d	48		pha				pha
.983e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9841	48		pha				pha
.9842	20 cf 9e	jsr $9ecf			jsr 	NSMShiftLeft 				; x 2
.9845	20 cf 9e	jsr $9ecf			jsr 	NSMShiftLeft 				; x 4
.9848	18		clc				clc 								; pop mantissa and add
.9849	68		pla				pla
.984a	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.984d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9850	68		pla				pla
.9851	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.9854	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9857	68		pla				pla
.9858	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.985b	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.985e	68		pla				pla
.985f	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.9862	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.9865	20 cf 9e	jsr $9ecf			jsr 	NSMShiftLeft 				; x 10
.9868	68		pla				pla 								; add digit
.9869	18		clc				clc
.986a	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.986d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9870	90 0d		bcc $987f			bcc 	_ESTASDExit
.9872	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.9875	d0 08		bne $987f			bne 	_ESTASDExit
.9877	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.987a	d0 03		bne $987f			bne 	_ESTASDExit
.987c	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.987f					_ESTASDExit:
.987f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9880					EvaluateTerm:
.9880	b1 30		lda ($30),y			lda 	(codePtr),y
.9882	30 18		bmi $989c			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9884	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9886	b0 6f		bcs $98f7			bcs 	_ETVariable
.9888	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.988a	90 6e		bcc $98fa			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.988c	c9 3a		cmp #$3a			cmp 	#'9'+1
.988e	b0 6a		bcs $98fa			bcs 	_ETPuncUnary
.9890	20 5e 97	jsr $975e			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9893					_ETNumber:
.9893	c8		iny				iny 								; keep encoding until we have the numbers
.9894	b1 30		lda ($30),y			lda 	(codePtr),y
.9896	20 61 97	jsr $9761			jsr 	EncodeNumberContinue
.9899	b0 f8		bcs $9893			bcs 	_ETNumber 					; go back if accepted.
.989b	60		rts				rts
.989c					_ETCheckUnary:
.989c	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.989e	f0 41		beq $98e1			beq 	_ETString
.98a0	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.98a2	f0 12		beq $98b6			beq 	_ETHexConstant
.98a4	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.98a6	90 0b		bcc $98b3			bcc 	_ETSyntaxError
.98a8	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.98aa	b0 07		bcs $98b3			bcs 	_ETSyntaxError
.98ac	da		phx				phx 								; push X on the stack
.98ad	0a		asl a				asl 	a 							; put vector x 2 into X
.98ae	aa		tax				tax
.98af	c8		iny				iny 								; consume unary function token
.98b0	7c 9e 8b	jmp ($8b9e,x)			jmp 	(VectorSet0,x) 				; and do it.
.98b3					_ETSyntaxError:
.98b3	4c 44 a0	jmp $a044			jmp 	SyntaxError
.98b6					_ETHexConstant:
.98b6	c8		iny				iny 								; skip #
.98b7	c8		iny				iny 								; skip count
.98b8	20 ba 9e	jsr $9eba			jsr 	NSMSetZero 					; clear result
.98bb					_ETHLoop:
.98bb	b1 30		lda ($30),y			lda 	(codePtr),y
.98bd	c8		iny				iny 								; and consume
.98be	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.98c0	f0 1e		beq $98e0			beq 	_ETHExit
.98c2	48		pha				pha 								; save on stack.
.98c3	20 cf 9e	jsr $9ecf			jsr 	NSMShiftLeft 				; x 2
.98c6	20 cf 9e	jsr $9ecf			jsr 	NSMShiftLeft 				; x 4
.98c9	20 cf 9e	jsr $9ecf			jsr 	NSMShiftLeft 				; x 8
.98cc	20 cf 9e	jsr $9ecf			jsr 	NSMShiftLeft 				; x 16
.98cf	68		pla				pla 								; ASCII
.98d0	c9 41		cmp #$41			cmp 	#'A'
.98d2	90 02		bcc $98d6			bcc 	_ETHNotChar
.98d4	e9 07		sbc #$07			sbc 	#7
.98d6					_ETHNotChar:
.98d6	29 0f		and #$0f			and 	#15 						; digit now
.98d8	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98db	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98de	80 db		bra $98bb			bra 	_ETHLoop 					; go round.
.98e0					_ETHExit:
.98e0	60		rts				rts
.98e1					_ETString:
.98e1	c8		iny				iny 								; look at length
.98e2	b1 30		lda ($30),y			lda 	(codePtr),y
.98e4	48		pha				pha
.98e5	c8		iny				iny 								; first character
.98e6	20 53 a6	jsr $a653			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98e9	68		pla				pla 								; restore count and save
.98ea	85 36		sta $36				sta 	zTemp0
.98ec	98		tya				tya 								; add length to Y to skip it.
.98ed	18		clc				clc
.98ee	65 36		adc $36				adc 	zTemp0
.98f0	a8		tay				tay
.98f1	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98f3	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98f6	60		rts				rts
.98f7					_ETVariable:
.98f7	4c 51 99	jmp $9951			jmp 	VariableHandler
.98fa					_ETPuncUnary:
.98fa	c8		iny				iny 								; consume the unary character
.98fb	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98fd	f0 2d		beq $992c			beq 	_ETUnaryNegate
.98ff	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9901	f0 39		beq $993c			beq 	_ETDereference
.9903	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9905	f0 43		beq $994a			beq 	_ETParenthesis
.9907	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9909	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.990b	f0 06		beq $9913			beq 	_ETIndirection
.990d	e6 36		inc $36				inc 	zTemp0
.990f	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9911	d0 a0		bne $98b3			bne 	_ETSyntaxError
.9913					_ETIndirection:
.9913	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9915	1a		inc a				inc 	a
.9916	48		pha				pha
.9917	20 80 98	jsr $9880			jsr 	EvaluateTerm				; evaluate the term
.991a	20 c4 96	jsr $96c4			jsr 	Dereference 				; dereference it.
.991d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.9920	d0 07		bne $9929			bne 	_ETTypeMismatch
.9922	68		pla				pla 								; indirection 1-2
.9923	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9925	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9928	60		rts				rts
.9929					_ETTypeMismatch:
.9929	4c 4e a0	jmp $a04e			jmp 	TypeError
.992c					_ETUnaryNegate:
.992c	20 80 98	jsr $9880			jsr 	EvaluateTerm				; evaluate the term
.992f	20 c4 96	jsr $96c4			jsr 	Dereference 				; dereference it.
.9932	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.9935	29 10		and #$10			and 	#NSTString
.9937	d0 f0		bne $9929			bne 	_ETTypeMismatch
.9939	4c 66 9e	jmp $9e66			jmp 	NSMNegate  					; just toggles the sign bit.
.993c					_ETDereference:
.993c	20 80 98	jsr $9880			jsr 	EvaluateTerm				; evaluate the term
.993f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.9942	29 20		and #$20			and 	#NSBIsReference
.9944	f0 e3		beq $9929			beq 	_ETTypeMismatch
.9946	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.9949	60		rts				rts
.994a					_ETParenthesis:
.994a	20 a6 93	jsr $93a6			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.994d	20 de 8d	jsr $8dde			jsr 	CheckRightBracket 			; check for )
.9950	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9951					VariableHandler:
.9951	b1 30		lda ($30),y			lda 	(codePtr),y
.9953	18		clc				clc
.9954	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9956	85 37		sta $37				sta 	zTemp0+1
.9958	c8		iny				iny
.9959	b1 30		lda ($30),y			lda 	(codePtr),y
.995b	85 36		sta $36				sta 	zTemp0
.995d	c8		iny				iny
.995e	18		clc				clc									; copy variable address+3 to mantissa
.995f	69 03		adc #$03			adc 	#3
.9961	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9964	a5 37		lda $37				lda 	zTemp0+1
.9966	69 00		adc #$00			adc 	#0
.9968	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.996b	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.996e	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9971	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9974	5a		phy				phy
.9975	a0 02		ldy #$02			ldy 	#2 							; read type
.9977	b1 36		lda ($36),y			lda 	(zTemp0),y
.9979	7a		ply				ply
.997a	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.997c	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.997e	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9981	29 04		and #$04			and 	#NSBIsArray
.9983	d0 01		bne $9986			bne 	_VHArray
.9985	60		rts				rts
.9986					_VHArray:
.9986	e8		inx				inx
.9987	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; get the 1st index.
.998a	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.998c	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.998f	b1 30		lda ($30),y			lda 	(codePtr),y
.9991	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9993	d0 06		bne $999b			bne 	_VHNoSecondIndex
.9995	c8		iny				iny 								; skip the comma
.9996	e8		inx				inx
.9997	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.999a	ca		dex				dex
.999b					_VHNoSecondIndex:
.999b	ca		dex				dex 								; set X back.
.999c	20 de 8d	jsr $8dde			jsr 	CheckRightBracket 			; and check the right bracket.
.999f	5a		phy				phy 								; save position
.99a0	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.99a2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99a4	f0 6b		beq $9a11			beq 	_VHBadIndex
.99a6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.99a9	85 3e		sta $3e				sta 	zaTemp
.99ab	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.99ae	85 3f		sta $3f				sta 	zaTemp+1
.99b0	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.99b2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99b4	f0 02		beq $99b8			beq 	_VHHas2Mask
.99b6	a9 ff		lda #$ff			lda 	#$FF
.99b8					_VHHas2Mask:
.99b8	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.99bb	f0 54		beq $9a11			beq 	_VHBadIndex
.99bd	0a		asl a				asl 	a 							; carry will be set if a second index
.99be	90 09		bcc $99c9			bcc 	_VHCheckFirstIndex
.99c0	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.99c2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99c4	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.99c7	90 48		bcc $9a11			bcc 	_VHBadIndex
.99c9					_VHCheckFirstIndex:
.99c9	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.99cb	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99cd	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.99d0	90 3f		bcc $9a11			bcc 	_VHBadIndex
.99d2	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.99d4	64 37		stz $37				stz 	zTemp0+1
.99d6	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99d9	30 0f		bmi $99ea			bmi 	_VHNoMultiply
.99db	da		phx				phx
.99dc	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.99df	48		pha				pha
.99e0	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.99e2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99e4	1a		inc a				inc 	a 							; add 1 for zero base
.99e5	fa		plx				plx
.99e6	20 4f 9e	jsr $9e4f			jsr 	Multiply8x8 				; calculate -> Z0
.99e9	fa		plx				plx
.99ea					_VHNoMultiply:
.99ea	18		clc				clc
.99eb	a5 36		lda $36				lda 	zTemp0
.99ed	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.99f0	85 36		sta $36				sta 	zTemp0
.99f2	a5 37		lda $37				lda 	zTemp0+1
.99f4	69 00		adc #$00			adc 	#0
.99f6	85 37		sta $37				sta 	zTemp0+1
.99f8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.99fb	20 f3 84	jsr $84f3			jsr 	ScaleByBaseType
.99fe	18		clc				clc
.99ff	b2 3e		lda ($3e)			lda 	(zaTemp)
.9a01	65 36		adc $36				adc 	zTemp0
.9a03	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a06	a0 01		ldy #$01			ldy 	#1
.9a08	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9a0a	65 37		adc $37				adc 	zTemp0+1
.9a0c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9a0f	7a		ply				ply 								; restore position
.9a10	60		rts				rts
.9a11					_VHBadIndex:
.9a11	a9 17		lda #$17		lda	#23
.9a13	4c f7 8d	jmp $8df7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9a16					AbsUnary:
.9a16	fa		plx				plx 								; restore stack pos
.9a17	20 e3 9d	jsr $9de3			jsr 	EvaluateNumber 				; get a float or int
.9a1a	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.9a1d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.9a20	29 7f		and #$7f			and 	#$7F
.9a22	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a25	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9a26					AllocUnary:
.9a26	fa		plx				plx 								; restore stack pos
.9a27	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger		; get bytes required.
.9a2a	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.9a2d	da		phx				phx 								; save X/Y
.9a2e	5a		phy				phy
.9a2f	8a		txa				txa 								; copy X into Y
.9a30	a8		tay				tay
.9a31	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.9a34	aa		tax				tax
.9a35	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.9a38	20 45 9a	jsr $9a45			jsr 	AllocateXABytes 			; allocate memory
.9a3b	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.9a3e	8a		txa				txa
.9a3f	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.9a42	7a		ply				ply
.9a43	fa		plx				plx
.9a44	60		rts				rts
.9a45					AllocateXABytes:
.9a45	5a		phy				phy
.9a46	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a49	84 36		sty $36				sty 	zTemp0
.9a4b	5a		phy				phy
.9a4c	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.9a4f	84 37		sty $37				sty 	zTemp0+1
.9a51	5a		phy				phy
.9a52	18		clc				clc 								; add to low memory pointer
.9a53	6d 8c 04	adc $048c			adc 	lowMemPtr
.9a56	8d 8c 04	sta $048c			sta 	lowMemPtr
.9a59	8a		txa				txa
.9a5a	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.9a5d	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.9a60	b0 2f		bcs $9a91			bcs 	CISSMemory
.9a62	20 83 9a	jsr $9a83			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a65					_ClearMemory:
.9a65	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.9a68	c5 36		cmp $36				cmp 	zTemp0
.9a6a	d0 07		bne $9a73			bne 	_CMClearNext
.9a6c	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.9a6f	c5 37		cmp $37				cmp 	zTemp0+1
.9a71	f0 0c		beq $9a7f			beq 	_CMExit
.9a73					_CMClearNext:
.9a73	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a75	92 36		sta ($36)			sta 	(zTemp0)
.9a77	e6 36		inc $36				inc 	zTemp0
.9a79	d0 ea		bne $9a65			bne 	_ClearMemory
.9a7b	e6 37		inc $37				inc		zTemp0+1
.9a7d	80 e6		bra $9a65			bra 	_ClearMemory
.9a7f					_CMExit:
.9a7f	fa		plx				plx
.9a80	68		pla				pla
.9a81	7a		ply				ply
.9a82	60		rts				rts
.9a83					CheckIdentifierStringSpace:
.9a83	48		pha				pha
.9a84	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.9a87	18		clc				clc
.9a88	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a8a	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a8d	b0 02		bcs $9a91			bcs 	CISSMemory
.9a8f	68		pla				pla
.9a90	60		rts				rts
.9a91					CISSMemory:
.9a91	a9 06		lda #$06		lda	#6
.9a93	4c f7 8d	jmp $8df7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a96					AscUnary:
.9a96	fa		plx				plx 								; restore stack pos
.9a97	20 ee 9d	jsr $9dee			jsr 	EvaluateString 				; get a string
.9a9a	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9a9c	20 bc 9e	jsr $9ebc			jsr 	NSMSetByte
.9a9f	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.9aa2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9aa3					FracUnary:
.9aa3	fa		plx				plx 								; restore stack pos
.9aa4	20 e3 9d	jsr $9de3			jsr 	EvaluateNumber 				; get a float or int
.9aa7	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.9aaa	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9aad	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9aaf	f0 04		beq $9ab5			beq 	_IUZero
.9ab1	20 d9 94	jsr $94d9			jsr 	FloatFractionalPart
.9ab4	60		rts				rts
.9ab5					_IUZero:
.9ab5	20 ba 9e	jsr $9eba			jsr 	NSMSetZero
.9ab8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9ab9					IntUnary:
.9ab9	fa		plx				plx 								; restore stack pos
.9aba	20 e3 9d	jsr $9de3			jsr 	EvaluateNumber 				; get a float or int
.9abd	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.9ac0	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ac3	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9ac5	f0 03		beq $9aca			beq 	_IUExit
.9ac7	20 3c 95	jsr $953c			jsr 	FloatIntegerPart
.9aca					_IUExit:
.9aca	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9acb					LenUnary:
.9acb	fa		plx				plx 								; restore stack pos
.9acc	20 ee 9d	jsr $9dee			jsr 	EvaluateString 				; get a string
.9acf	5a		phy				phy
.9ad0	a0 00		ldy #$00			ldy 	#0 							; find length
.9ad2					_LenFind:
.9ad2	b1 36		lda ($36),y			lda 	(zTemp0),y
.9ad4	f0 06		beq $9adc			beq 	_LenExit
.9ad6	c8		iny				iny
.9ad7	d0 f9		bne $9ad2			bne 	_LenFind
.9ad9	4c 49 a0	jmp $a049			jmp 	RangeError 					; string > 255
.9adc					_LenExit:
.9adc	98		tya				tya
.9add	20 bc 9e	jsr $9ebc			jsr 	NSMSetByte
.9ae0	7a		ply				ply
.9ae1	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.9ae4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9ae5					Unary_Min:
.9ae5	a9 01		lda #$01			lda 	#1
.9ae7	80 02		bra $9aeb			bra 	UnaryMinMaxMain
.9ae9					Unary_Max:
.9ae9	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9aeb					UnaryMinMaxMain:
.9aeb	fa		plx				plx 								; get index on number stack
.9aec	48		pha				pha 								; save comparator
.9aed	20 da 9d	jsr $9dda			jsr 	EvaluateValue 				; get the first value.
.9af0					_UMMMLoop:
.9af0	b1 30		lda ($30),y			lda 	(codePtr),y
.9af2	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9af4	f0 22		beq $9b18			beq 	_UMMMDone
.9af6	20 e6 8d	jsr $8de6			jsr 	CheckComma 					; must be a comma
.9af9	e8		inx				inx
.9afa	20 da 9d	jsr $9dda			jsr 	EvaluateValue
.9afd	ca		dex				dex
.9afe	20 91 9e	jsr $9e91			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9b01	e8		inx				inx
.9b02	20 91 9e	jsr $9e91			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9b05	e8		inx				inx
.9b06	20 af 8e	jsr $8eaf			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9b09	ca		dex				dex
.9b0a	ca		dex				dex
.9b0b	85 36		sta $36				sta 	zTemp0 						; save required result
.9b0d	68		pla				pla 								; get and save comparator
.9b0e	48		pha				pha
.9b0f	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9b11	d0 dd		bne $9af0			bne 	_UMMMLoop
.9b13	20 1b 9b	jsr $9b1b			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9b16	80 d8		bra $9af0			bra 	_UMMMLoop
.9b18					_UMMMDone:
.9b18	68		pla				pla 								; throw the comparator
.9b19	c8		iny				iny 								; skip )
.9b1a	60		rts				rts
.9b1b					ExpCopyAboveDown:
.9b1b	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9b1e	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b21	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9b24	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9b27	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9b2a	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b2d	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9b30	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b33	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9b36	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b39	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9b3c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b3f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b40					Unary_Not:
.9b40	fa		plx				plx
.9b41	20 06 9e	jsr $9e06			jsr 	EvaluateInteger 			; get integer
.9b44	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.9b47	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; zero mantissa ?
.9b4a	f0 04		beq $9b50			beq 	_NotZero
.9b4c	20 ba 9e	jsr $9eba			jsr 	NSMSetZero
.9b4f	60		rts				rts
.9b50					_NotZero:
.9b50	4c 64 8e	jmp $8e64			jmp 	ReturnTrue
.9b53					_UNBad:
.9b53	4c 53 a0	jmp $a053			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b56					Unary_Random:
.9b56	fa		plx				plx
.9b57	20 d5 9b	jsr $9bd5			jsr 	Random32Bit 				; get a random number
.9b5a	20 ba 9b	jsr $9bba			jsr 	URCopyToMantissa  			; put in mantissa
.9b5d	b1 30		lda ($30),y			lda 	(codePtr),y
.9b5f	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b61	f0 08		beq $9b6b			beq 	_URNoModulus
.9b63	e8		inx				inx
.9b64	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b67	ca		dex				dex
.9b68	20 d3 8f	jsr $8fd3			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9b6b					_URNoModulus:
.9b6b	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9b6e	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9b71	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.9b74	60		rts				rts
.9b75					Unary_Rnd:
.9b75	fa		plx				plx
.9b76	20 e3 9d	jsr $9de3			jsr 	EvaluateNumber 				; number to use.
.9b79	20 de 8d	jsr $8dde			jsr 	CheckRightBracket 			; closing bracket
.9b7c	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b7f	f0 2b		beq $9bac			beq 	_URCopySeed
.9b81	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b84	10 23		bpl $9ba9			bpl 	_URDontSeed
.9b86	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b89	49 17		eor #$17			eor 	#$17
.9b8b	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b8e	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9b91	49 a5		eor #$a5			eor 	#$A5
.9b93	8d 89 04	sta $0489			sta 	RandomSeed+1
.9b96	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9b99	49 c2		eor #$c2			eor 	#$C2
.9b9b	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9b9e	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9ba1	49 9d		eor #$9d			eor 	#$9D
.9ba3	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9ba6	20 d5 9b	jsr $9bd5			jsr 	Random32Bit
.9ba9					_URDontSeed:
.9ba9	20 d5 9b	jsr $9bd5			jsr 	Random32Bit 				; generate a number.
.9bac					_URCopySeed:
.9bac	20 ba 9b	jsr $9bba			jsr 	URCopyToMantissa 			; copy into mantissa
.9baf	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9bb1	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9bb4	a9 08		lda #$08			lda 	#NSTFloat
.9bb6	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; positive.
.9bb9	60		rts				rts
.9bba					URCopyToMantissa:
.9bba	ad 88 04	lda $0488			lda 	RandomSeed+0
.9bbd	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9bc0	ad 89 04	lda $0489			lda 	RandomSeed+1
.9bc3	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9bc6	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9bc9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9bcc	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9bcf	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9bd1	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9bd4	60		rts				rts
.9bd5					Random32Bit:
.9bd5	5a		phy				phy
.9bd6	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9bd8	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9bdb	d0 03		bne $9be0			bne 	_Random1
.9bdd	a8		tay				tay 								; if so do it 256 times
.9bde	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9be0					_Random1:
.9be0	0a		asl a				asl 	a 							; LSFR RNG
.9be1	2e 89 04	rol $0489			rol 	RandomSeed+1
.9be4	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9be7	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9bea	90 02		bcc $9bee			bcc 	_Random2
.9bec	49 c5		eor #$c5			eor 	#$C5
.9bee					_Random2:
.9bee	88		dey				dey
.9bef	d0 ef		bne $9be0			bne 	_Random1
.9bf1	8d 88 04	sta $0488			sta 	RandomSeed+0
.9bf4	7a		ply				ply
.9bf5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9bf6					SgnUnary:
.9bf6	fa		plx				plx 								; restore stack pos
.9bf7	20 e3 9d	jsr $9de3			jsr 	EvaluateNumber 				; get a float or int
.9bfa	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.9bfd	20 ea 9e	jsr $9eea			jsr 	NSMIsZero 					; if zero
.9c00	f0 10		beq $9c12			beq 	_SGZero  					; return Int Zero
.9c02	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9c05	48		pha				pha
.9c06	a9 01		lda #$01			lda 	#1 							; set to 1
.9c08	20 bc 9e	jsr $9ebc			jsr 	NSMSetByte
.9c0b	68		pla				pla
.9c0c	29 80		and #$80			and		#$80 						; copy the sign byte out
.9c0e	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c11	60		rts				rts
.9c12	20 ba 9e	jsr $9eba	_SGZero:jsr 	NSMSetZero
.9c15	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9c16					ValUnary:
.9c16	fa		plx				plx 								; restore stack pos
.9c17	20 2c 9c	jsr $9c2c			jsr 	ValMainCode 				; do the main val() code
.9c1a	b0 01		bcs $9c1d			bcs 	_VUError 					; couldn't convert
.9c1c	60		rts				rts
.9c1d					_VUError:
.9c1d	4c 4e a0	jmp $a04e			jmp 	TypeError
.9c20					IsValUnary:
.9c20	fa		plx				plx 								; restore stack pos
.9c21	20 2c 9c	jsr $9c2c			jsr 	ValMainCode 				; do the main val() code
.9c24	b0 03		bcs $9c29			bcs 	_VUBad
.9c26	4c 64 8e	jmp $8e64			jmp 	ReturnTrue
.9c29					_VUBad:
.9c29	4c 70 8e	jmp $8e70			jmp 	ReturnFalse
.9c2c					ValMainCode:
.9c2c	20 ee 9d	jsr $9dee			jsr 	EvaluateString 				; get a string
.9c2f	20 de 8d	jsr $8dde			jsr 	CheckRightBracket 			; check right bracket present
.9c32					ValEvaluateZTemp0:
.9c32	5a		phy				phy
.9c33	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9c35	f0 17		beq $9c4e			beq 	_VMCFail2
.9c37	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9c39	48		pha				pha 								; save first character
.9c3a	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9c3c	d0 01		bne $9c3f			bne 	_VMCStart
.9c3e	c8		iny				iny 								; skip over -
.9c3f					_VMCStart:
.9c3f	38		sec				sec 								; initialise first time round.
.9c40					_VMCNext:
.9c40	c8		iny				iny 								; pre-increment
.9c41	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9c43	f0 0c		beq $9c51			beq 	_VMCSuccess 				; successful.
.9c45	20 62 97	jsr $9762			jsr 	EncodeNumber 				; send it to the number-builder
.9c48	90 03		bcc $9c4d			bcc 	_VMCFail 					; if failed, give up.
.9c4a	18		clc				clc 								; next time round, countinue
.9c4b	80 f3		bra $9c40			bra 	_VMCNext
.9c4d					_VMCFail:
.9c4d	68		pla				pla
.9c4e					_VMCFail2:
.9c4e	7a		ply				ply
.9c4f	38		sec				sec
.9c50	60		rts				rts
.9c51					_VMCSuccess:
.9c51	a9 00		lda #$00			lda 	#0 							; construct final
.9c53	20 62 97	jsr $9762			jsr 	EncodeNumber
.9c56	68		pla				pla
.9c57	c9 2d		cmp #$2d			cmp 	#"-"
.9c59	d0 03		bne $9c5e			bne 	_VMCNotNegative
.9c5b	20 66 9e	jsr $9e66			jsr		NSMNegate
.9c5e					_VMCNotNegative:
.9c5e	7a		ply				ply
.9c5f	18		clc				clc
.9c60	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c61					ChrUnary:
.9c61	fa		plx				plx 								; restore stack pos
.9c62	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger			; get value
.9c65	48		pha				pha
.9c66	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.9c69	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c6b	20 37 a8	jsr $a837			jsr 	StringTempAllocate
.9c6e	68		pla				pla 								; write number to it
.9c6f	20 75 a8	jsr $a875			jsr 	StringTempWrite
.9c72	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c73					SpcUnary:
.9c73	fa		plx				plx 								; restore stack pos
.9c74	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger			; get value
.9c77	5a		phy				phy
.9c78	48		pha				pha 								; save count
.9c79	20 37 a8	jsr $a837			jsr 	StringTempAllocate
.9c7c	7a		ply				ply 								; to do count in Y
.9c7d					_SpcLoop:
.9c7d	c0 00		cpy #$00			cpy 	#0
.9c7f	f0 08		beq $9c89			beq 	_SpcExit
.9c81	a9 20		lda #$20			lda 	#32
.9c83	20 75 a8	jsr $a875			jsr 	StringTempWrite
.9c86	88		dey				dey
.9c87	80 f4		bra $9c7d			bra 	_SPCLoop
.9c89					_SpcExit:
.9c89	7a		ply				ply
.9c8a	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.9c8d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c8e					Unary_Str:
.9c8e	fa		plx				plx
.9c8f	20 e3 9d	jsr $9de3			jsr 	EvaluateNumber  			; get number
.9c92	20 de 8d	jsr $8dde			jsr 	CheckRightBracket 			; closing bracket
.9c95	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c97	20 b0 9c	jsr $9cb0			jsr 	ConvertNumberToString 		; do the conversion.
.9c9a	a9 21		lda #$21			lda		#33 						; create buffer
.9c9c	20 37 a8	jsr $a837			jsr 	StringTempAllocate 			; allocate memory
.9c9f	da		phx				phx
.9ca0	a2 00		ldx #$00			ldx 	#0
.9ca2					_USCopy:
.9ca2	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9ca5	20 75 a8	jsr $a875			jsr 	StringTempWrite
.9ca8	e8		inx				inx
.9ca9	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9cac	d0 f4		bne $9ca2			bne 	_USCopy
.9cae	fa		plx				plx
.9caf	60		rts				rts
.9cb0					ConvertNumberToString:
.9cb0	5a		phy				phy 								; save code position
.9cb1	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9cb4	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9cb7	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9cba	10 0a		bpl $9cc6			bpl 	_CNTSNotNegative
.9cbc	29 7f		and #$7f			and 	#$7F 						; make +ve
.9cbe	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9cc1	a9 2d		lda #$2d			lda 	#"-"
.9cc3	20 2c 9d	jsr $9d2c			jsr 	WriteDecimalBuffer
.9cc6					_CNTSNotNegative:
.9cc6	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9cc9	f0 15		beq $9ce0			beq 	_CNTSNotFloat
.9ccb	e8		inx				inx 								; round up
.9ccc	a9 01		lda #$01			lda 	#1
.9cce	20 bc 9e	jsr $9ebc			jsr 	NSMSetByte
.9cd1	ca		dex				dex
.9cd2	bd 28 04	lda $0428,x			lda		NSExponent,x
.9cd5	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9cd8	a9 08		lda #$08			lda 	#NSTFloat
.9cda	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9cdd	20 f3 93	jsr $93f3			jsr 	FloatAdd
.9ce0					_CNTSNotFloat:
.9ce0	20 0e 9d	jsr $9d0e			jsr 	MakePlusTwoString
.9ce3	20 d9 94	jsr $94d9			jsr 	FloatFractionalPart 		; get the fractional part
.9ce6	20 9d 95	jsr $959d			jsr 	NSNormalise					; normalise , exit if zero
.9ce9	f0 21		beq $9d0c			beq 	_CNTSExit
.9ceb	a9 2e		lda #$2e			lda 	#"."
.9ced	20 2c 9d	jsr $9d2c			jsr 	WriteDecimalBuffer 			; write decimal place
.9cf0					_CNTSDecimal:
.9cf0	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9cf3	30 17		bmi $9d0c			bmi 	_CNTSExit
.9cf5	e8		inx				inx 								; x 10.0
.9cf6	a9 0a		lda #$0a			lda 	#10
.9cf8	20 bc 9e	jsr $9ebc			jsr 	NSMSetByte
.9cfb	a9 08		lda #$08			lda 	#NSTFloat
.9cfd	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9d00	ca		dex				dex
.9d01	20 66 95	jsr $9566			jsr 	FloatMultiply
.9d04	20 0e 9d	jsr $9d0e			jsr 	MakePlusTwoString
.9d07	20 d9 94	jsr $94d9			jsr 	FloatFractionalPart 		; get the fractional part
.9d0a	80 e4		bra $9cf0			bra 	_CNTSDecimal 				; keep going.
.9d0c					_CNTSExit:
.9d0c	7a		ply				ply
.9d0d	60		rts				rts
.9d0e					MakePlusTwoString:
.9d0e	da		phx				phx
.9d0f	20 91 9e	jsr $9e91			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9d12	e8		inx				inx 								; access it
.9d13	e8		inx				inx
.9d14	20 3c 95	jsr $953c			jsr 	FloatIntegerPart 			; make it an integer
.9d17	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9d19	20 1e 93	jsr $931e			jsr 	ConvertInt32
.9d1c	a2 00		ldx #$00			ldx	 	#0
.9d1e					_MPTSCopy:
.9d1e	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d21	20 2c 9d	jsr $9d2c			jsr 	WriteDecimalBuffer
.9d24	e8		inx				inx
.9d25	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d28	d0 f4		bne $9d1e			bne 	_MPTSCopy
.9d2a	fa		plx				plx
.9d2b	60		rts				rts
.9d2c					WriteDecimalBuffer:
.9d2c	da		phx				phx
.9d2d	ae 95 04	ldx $0495			ldx 	dbOffset
.9d30	9d 1c 06	sta $061c,x			sta 	DecimalBuffer,x
.9d33	9e 1d 06	stz $061d,x			stz 	DecimalBuffer+1,x
.9d36	ee 95 04	inc $0495			inc 	dbOffset
.9d39	fa		plx				plx
.9d3a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9d3b					Unary_Left:
.9d3b	fa		plx				plx
.9d3c	18		clc				clc 								; only one parameter
.9d3d	20 b2 9d	jsr $9db2			jsr 	SubstringInitial 			; set up.
.9d40	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9d43	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d46	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9d49	80 2c		bra $9d77			bra 	SubstringMain
.9d4b					Unary_Right:
.9d4b	fa		plx				plx
.9d4c	18		clc				clc 								; only one parameter
.9d4d	20 b2 9d	jsr $9db2			jsr 	SubstringInitial 			; set up.
.9d50	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9d53	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d56	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9d59	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d5c	b0 02		bcs $9d60			bcs 	_URNotUnderflow
.9d5e	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d60					_URNotUnderFlow:
.9d60	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d63	80 12		bra $9d77			bra 	SubStringMain
.9d65					Unary_Mid:
.9d65	fa		plx				plx
.9d66	38		sec				sec 								; two parameters
.9d67	20 b2 9d	jsr $9db2			jsr 	SubstringInitial 			; set up.
.9d6a	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d6d	f0 05		beq $9d74			beq 	_UMError
.9d6f	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d72	80 03		bra $9d77			bra 	SubStringMain
.9d74					_UMError:
.9d74	4c 53 a0	jmp $a053			jmp 	ArgumentError
.9d77					SubStringMain:
.9d77	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d7a	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9d7d	b0 2d		bcs $9dac			bcs 	_SSMNull 					; if so, return an empty string.
.9d7f	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d82	f0 28		beq $9dac			beq 	_SSMNull 					; return empty string.
.9d84	18		clc				clc 								; add the offset +1 to the address and
.9d85	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9d88	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9d8b	85 36		sta $36				sta 	zTemp0
.9d8d	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9d90	69 00		adc #$00			adc 	#0
.9d92	85 37		sta $37				sta 	zTemp0+1
.9d94					_SSMNoCarry:
.9d94	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d97	20 37 a8	jsr $a837			jsr 	StringTempAllocate 			; allocate that many characters
.9d9a	5a		phy				phy 								; save Y
.9d9b	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d9d					_SSMCopy:
.9d9d	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d9f	f0 09		beq $9daa			beq 	_SSMEString 				; no more to copy
.9da1	20 75 a8	jsr $a875			jsr 	StringTempWrite 			; and write it out.
.9da4	c8		iny				iny
.9da5	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9da8	d0 f3		bne $9d9d			bne 	_SSMCopy
.9daa					_SSMEString:
.9daa	7a		ply				ply
.9dab					_SSMExit:
.9dab	60		rts				rts
.9dac					_SSMNull:
.9dac	a9 00		lda #$00			lda 	#0
.9dae	20 37 a8	jsr $a837			jsr 	StringTempAllocate
.9db1	60		rts				rts
.9db2					SubstringInitial:
.9db2	da		phx				phx 								; save initial stack position
.9db3	08		php				php 								; save carry on stack indicating 2 parameters
.9db4	20 ee 9d	jsr $9dee			jsr 	EvaluateString 				; get a string
.9db7	5a		phy				phy 								; calculate length to exponent.
.9db8	a0 ff		ldy #$ff			ldy 	#$FF
.9dba					_SIFindLength:
.9dba	c8		iny				iny
.9dbb	b1 36		lda ($36),y			lda 	(zTemp0),y
.9dbd	d0 fb		bne $9dba			bne 	_SIFindLength
.9dbf	98		tya				tya
.9dc0	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9dc3	7a		ply				ply
.9dc4	e8		inx				inx
.9dc5	20 e6 8d	jsr $8de6			jsr 	CheckComma 					; comma next
.9dc8	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; get next parameter
.9dcb	28		plp				plp 								; is it the last parameter ?
.9dcc	90 07		bcc $9dd5			bcc 	_SSIExit 					; if so, exit.
.9dce	e8		inx				inx
.9dcf	20 e6 8d	jsr $8de6			jsr 	CheckComma 					; comma next
.9dd2	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; get last parameter
.9dd5					_SSIExit:
.9dd5	fa		plx				plx
.9dd6	20 de 8d	jsr $8dde			jsr 	CheckRightBracket 			; check closing bracket
.9dd9	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9dda					EvaluateValue:
.9dda	48		pha				pha
.9ddb	20 a6 93	jsr $93a6			jsr		EvaluateExpression 			; expression
.9dde	20 c4 96	jsr $96c4			jsr 	Dereference					; derefernce it
.9de1	68		pla				pla
.9de2	60		rts				rts
.9de3					EvaluateNumber:
.9de3	20 da 9d	jsr $9dda			jsr 	EvaluateValue 				; get a value
.9de6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9de9	29 10		and #$10			and 	#NSBIsString
.9deb	d0 16		bne $9e03			bne 	HelperTypeError
.9ded	60		rts				rts
.9dee					EvaluateString:
.9dee	20 da 9d	jsr $9dda			jsr 	EvaluateValue 				; get a value
.9df1	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9df4	29 10		and #$10			and 	#NSBIsString
.9df6	f0 0b		beq $9e03			beq 	HelperTypeError
.9df8					CopyAddressToTemp0:
.9df8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9dfb	85 36		sta $36				sta 	zTemp0
.9dfd	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e00	85 37		sta $37				sta 	zTemp0+1
.9e02	60		rts				rts
.9e03					HelperTypeError:
.9e03	4c 4e a0	jmp $a04e			jmp 	TypeError
.9e06					EvaluateInteger:
.9e06	20 e3 9d	jsr $9de3			jsr 	EvaluateNumber
.9e09	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9e0c	d0 0a		bne $9e18			bne 	HelperValueError 			; if not, it's a float.
.9e0e	60		rts				rts
.9e0f					EvaluateUnsignedInteger:
.9e0f	20 06 9e	jsr $9e06			jsr 	EvaluateInteger 			; check integer is +ve
.9e12	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e15	30 01		bmi $9e18			bmi 	HelperValueError
.9e17	60		rts				rts
.9e18					HelperValueError:
.9e18	4c 53 a0	jmp $a053			jmp 	ArgumentError
.9e1b					Evaluate16BitInteger:
.9e1b	20 0f 9e	jsr $9e0f			jsr	 	EvaluateUnsignedInteger		; get integer
.9e1e	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e21	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e24	d0 f2		bne $9e18			bne 	HelperValueError
.9e26	60		rts				rts
.9e27					Evaluate16BitIntegerSigned:
.9e27	20 06 9e	jsr $9e06			jsr	 	EvaluateInteger				; get integer
.9e2a	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e2d	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e30	d0 e6		bne $9e18			bne 	HelperValueError
.9e32	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9e35	10 03		bpl $9e3a			bpl 	_EISNotSigned
.9e37	20 6f 9e	jsr $9e6f			jsr 	NSMNegateMantissa
.9e3a					_EISNotSigned:
.9e3a	60		rts				rts
.9e3b					Evaluate8BitInteger:
.9e3b	20 0f 9e	jsr $9e0f			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9e3e	d0 d8		bne $9e18			bne 	HelperValueError
.9e40	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9e43	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e46	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9e49	d0 cd		bne $9e18			bne 	HelperValueError
.9e4b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e4e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9e4f					Multiply8x8:
.9e4f	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9e50	85 36		sta $36			  	sta 	zTemp0
.9e52	86 37		stx $37				stx 	zTemp0+1
.9e54	a9 00		lda #$00			lda 	#0
.9e56	a2 08		ldx #$08			ldx 	#8
.9e58					_M88Loop:
.9e58	90 03		bcc $9e5d			bcc 	_M88NoAdd
.9e5a	18		clc				clc
.9e5b	65 37		adc $37				adc 	zTemp0+1
.9e5d					_M88NoAdd:
.9e5d	6a		ror a				ror 	a
.9e5e	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9e60	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9e61	d0 f5		bne $9e58			bne 	_M88Loop
.9e63	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9e65	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9e66					NSMNegate:
.9e66	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e69	49 80		eor #$80			eor 	#NSBIsNegative
.9e6b	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9e6e	60		rts				rts
.9e6f					NSMNegateMantissa:
.9e6f	38		sec				sec
.9e70	a9 00		lda #$00			lda 	#0
.9e72	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9e75	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9e78	a9 00		lda #$00			lda 	#0
.9e7a	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9e7d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9e80	a9 00		lda #$00			lda 	#0
.9e82	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9e85	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9e88	a9 00		lda #$00			lda 	#0
.9e8a	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9e8d	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9e90	60		rts				rts
.9e91					NSMShiftUpTwo:
.9e91	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e94	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9e97	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e9a	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9e9d	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9ea0	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9ea3	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9ea6	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9ea9	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9eac	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9eaf	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9eb2	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9eb5	60		rts				rts
.9eb6					NSMSetZeroMantissaOnly:
.9eb6	a9 00		lda #$00			lda 	#0
.9eb8	80 08		bra $9ec2			bra 	NSMSetMantissa
.9eba					NSMSetZero:
.9eba	a9 00		lda #$00			lda 	#0
.9ebc					NSMSetByte:
.9ebc	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9ebf	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9ec2					NSMSetMantissa:
.9ec2	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9ec5	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9ec8	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9ecb	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9ece	60		rts				rts
.9ecf					NSMShiftLeft:
.9ecf	18		clc				clc
.9ed0					NSMRotateLeft:
.9ed0	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9ed3	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9ed6	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9ed9	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9edc	60		rts				rts
.9edd					NSMShiftRight:
.9edd	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9ee0	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9ee3	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9ee6	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9ee9	60		rts				rts
.9eea					NSMIsZero:
.9eea	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9eed	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9ef0	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9ef3	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9ef6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.ba9f					TickHandler:
.ba9f	5a		phy				phy 								; need to preserve Y
.baa0	20 45 ba	jsr $ba45			jsr 	SNDUpdate 					; update sound
.baa3	7a		ply				ply
.baa4	60		rts				rts
.062e					LastTick:
>062e							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9ef7					Assemble_ora:
.9ef7	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9efa	01					.byte $01
.9efb					Assemble_and:
.9efb	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9efe	21					.byte $21
.9eff					Assemble_eor:
.9eff	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9f02	41					.byte $41
.9f03					Assemble_adc:
.9f03	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9f06	61					.byte $61
.9f07					Assemble_sta:
.9f07	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9f0a	81					.byte $81
.9f0b					Assemble_lda:
.9f0b	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9f0e	a1					.byte $a1
.9f0f					Assemble_cmp:
.9f0f	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9f12	c1					.byte $c1
.9f13					Assemble_sbc:
.9f13	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9f16	e1					.byte $e1
.9f17					Assemble_asl:
.9f17	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f1a	02					.byte $02
>9f1b	75					.byte $75
.9f1c					Assemble_rol:
.9f1c	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f1f	22					.byte $22
>9f20	75					.byte $75
.9f21					Assemble_lsr:
.9f21	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f24	42					.byte $42
>9f25	75					.byte $75
.9f26					Assemble_ror:
.9f26	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f29	62					.byte $62
>9f2a	75					.byte $75
.9f2b					Assemble_stx:
.9f2b	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f2e	82					.byte $82
>9f2f	50					.byte $50
.9f30					Assemble_ldx:
.9f30	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f33	a2					.byte $a2
>9f34	d0					.byte $d0
.9f35					Assemble_dec:
.9f35	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f38	c2					.byte $c2
>9f39	55					.byte $55
.9f3a					Assemble_inc:
.9f3a	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f3d	e2					.byte $e2
>9f3e	55					.byte $55
.9f3f					Assemble_stz:
.9f3f	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f42	60					.byte $60
>9f43	44					.byte $44
.9f44					Assemble_bit:
.9f44	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f47	20					.byte $20
>9f48	55					.byte $55
.9f49					Assemble_sty:
.9f49	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f4c	80					.byte $80
>9f4d	54					.byte $54
.9f4e					Assemble_ldy:
.9f4e	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f51	a0					.byte $a0
>9f52	d5					.byte $d5
.9f53					Assemble_cpy:
.9f53	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f56	c0					.byte $c0
>9f57	d4					.byte $d4
.9f58					Assemble_cpx:
.9f58	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f5b	e0					.byte $e0
>9f5c	d0					.byte $d0
.9f5d					Assemble_tsb:
.9f5d	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f60	00					.byte $00
>9f61	50					.byte $50
.9f62					Assemble_trb:
.9f62	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f65	10					.byte $10
>9f66	50					.byte $50
.9f67					Assemble_jsr:
.9f67	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f6a	14					.byte $14
>9f6b	10					.byte $10
.9f6c					Assemble_jmp:
.9f6c	20 72 80	jsr $8072		jsr	AssembleGroup2
>9f6f	40					.byte $40
>9f70	10					.byte $10
.9f71					Assemble_bpl:
.9f71	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f74	10					.byte $10
.9f75					Assemble_bmi:
.9f75	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f78	30					.byte $30
.9f79					Assemble_bvc:
.9f79	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f7c	50					.byte $50
.9f7d					Assemble_bvs:
.9f7d	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f80	70					.byte $70
.9f81					Assemble_bcc:
.9f81	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f84	90					.byte $90
.9f85					Assemble_bcs:
.9f85	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f88	b0					.byte $b0
.9f89					Assemble_bne:
.9f89	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f8c	d0					.byte $d0
.9f8d					Assemble_beq:
.9f8d	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f90	f0					.byte $f0
.9f91					Assemble_bra:
.9f91	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f94	80					.byte $80
.9f95					Assemble_brk:
.9f95	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f98	00					.byte $00
.9f99					Assemble_php:
.9f99	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f9c	08					.byte $08
.9f9d					Assemble_clc:
.9f9d	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fa0	18					.byte $18
.9fa1					Assemble_plp:
.9fa1	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fa4	28					.byte $28
.9fa5					Assemble_sec:
.9fa5	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fa8	38					.byte $38
.9fa9					Assemble_rti:
.9fa9	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fac	40					.byte $40
.9fad					Assemble_pha:
.9fad	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fb0	48					.byte $48
.9fb1					Assemble_cli:
.9fb1	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fb4	58					.byte $58
.9fb5					Assemble_phy:
.9fb5	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fb8	5a					.byte $5a
.9fb9					Assemble_rts:
.9fb9	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fbc	60					.byte $60
.9fbd					Assemble_pla:
.9fbd	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fc0	68					.byte $68
.9fc1					Assemble_sei:
.9fc1	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fc4	78					.byte $78
.9fc5					Assemble_ply:
.9fc5	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fc8	7a					.byte $7a
.9fc9					Assemble_dey:
.9fc9	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fcc	88					.byte $88
.9fcd					Assemble_txa:
.9fcd	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fd0	8a					.byte $8a
.9fd1					Assemble_tya:
.9fd1	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fd4	98					.byte $98
.9fd5					Assemble_txs:
.9fd5	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fd8	9a					.byte $9a
.9fd9					Assemble_tay:
.9fd9	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fdc	a8					.byte $a8
.9fdd					Assemble_tax:
.9fdd	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fe0	aa					.byte $aa
.9fe1					Assemble_clv:
.9fe1	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fe4	b8					.byte $b8
.9fe5					Assemble_tsx:
.9fe5	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fe8	ba					.byte $ba
.9fe9					Assemble_iny:
.9fe9	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9fec	c8					.byte $c8
.9fed					Assemble_dex:
.9fed	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9ff0	ca					.byte $ca
.9ff1					Assemble_cld:
.9ff1	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9ff4	d8					.byte $d8
.9ff5					Assemble_phx:
.9ff5	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9ff8	da					.byte $da
.9ff9					Assemble_stp:
.9ff9	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9ffc	db					.byte $db
.9ffd					Assemble_inx:
.9ffd	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>a000	e8					.byte $e8
.a001					Assemble_nop:
.a001	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>a004	ea					.byte $ea
.a005					Assemble_sed:
.a005	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>a008	f8					.byte $f8
.a009					Assemble_plx:
.a009	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>a00c	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.a00d					DecimalScalarTable:
>a00d	66 66 66 66				.dword $66666666 ; 0.1
>a011	de					.byte $de
>a012	1f 85 eb 51				.dword $51eb851f ; 0.01
>a016	db					.byte $db
>a017	4c 37 89 41				.dword $4189374c ; 0.001
>a01b	d8					.byte $d8
>a01c	ac 8b db 68				.dword $68db8bac ; 0.0001
>a020	d4					.byte $d4
>a021	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>a025	d1					.byte $d1
>a026	83 de 1b 43				.dword $431bde83 ; 1e-06
>a02a	ce					.byte $ce
>a02b	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>a02f	ca					.byte $ca
>a030	89 3b e6 55				.dword $55e63b89 ; 1e-08
>a034	c7					.byte $c7
>a035	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>a039	c4					.byte $c4
>a03a	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>a03e	c0					.byte $c0
>a03f	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>a043	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.a044					SyntaxError:
.a044	a9 02		lda #$02		lda	#2
.a046	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.a049					RangeError:
.a049	a9 04		lda #$04		lda	#4
.a04b	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.a04e					TypeError:
.a04e	a9 05		lda #$05		lda	#5
.a050	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.a053					ArgumentError:
.a053	a9 07		lda #$07		lda	#7
.a055	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.a058					NotDoneError:
.a058	a9 0c		lda #$0c		lda	#12
.a05a	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.a05d					ErrorText:
>a05d	42 72 65 61 6b 00			.text	"Break",0
>a063	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a06b	72 72 6f 72 00
>a070	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a078	20 62 79 20 7a 65 72 6f 00
>a081	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a089	61 6e 67 65 00
>a08e	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a096	6d 61 74 63 68 00
>a09c	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a0a4	65 6d 6f 72 79 00
>a0aa	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a0b2	61 72 67 75 6d 65 6e 74 00
>a0bb	53 74 6f 70 00				.text	"Stop",0
>a0c0	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a0c8	6f 6f 20 6c 6f 6e 67 00
>a0d0	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a0d8	6e 20 66 61 69 6c 65 64 00
>a0e1	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a0e9	61 74 61 00
>a0ed	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a0f5	65 6e 74 65 64 00
>a0fb	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a103	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a10f	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a117	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a124	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a12c	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a139	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a141	68 6f 75 74 20 57 68 69 6c 65 00
>a14c	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a154	68 6f 75 74 20 46 6f 72 00
>a15d	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a165	61 63 6b 20 66 75 6c 6c 00
>a16e	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a176	75 63 74 75 72 65 00
>a17d	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a185	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a192	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a19a	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a1a8	41 72 72 61 79 20 73 69			.text	"Array size",0
>a1b0	7a 65 00
>a1b3	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a1bb	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a1c3	42 75 69 6c 74 20 57 65			.text "Built Wednesday 23-Nov-2022. Build 3579."
>a1cb	64 6e 65 73 64 61 79 20 32 33 2d 4e 6f 76 2d 32
>a1db	30 32 32 2e 20 42 75 69 6c 64 20 33 35 37 39 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a1eb					RectangleCommand:
.a1eb	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a1ed	80 02		bra $a1f1			bra 	ShapeDrawCmd
.a1ef					CircleCommand:
.a1ef	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a1f1					ShapeDrawCmd:
.a1f1	20 7f a2	jsr $a27f			jsr 	RunGraphicsCommand
.a1f4					ShapeDraw:
.a1f4	0d 30 06	ora $0630			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a1f7	4c 73 a2	jmp $a273			jmp 	ExecuteGraphicCommand	 	; and complete
.a1fa					SpriteCommand:
.a1fa	a2 00		ldx #$00			ldx 	#0
.a1fc	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; get image number.
.a1ff	5a		phy				phy
.a200	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a202	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a205	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a207	b0 0d		bcs $a216			bcs 	_SCRange
.a209	a0 ff		ldy #$ff			ldy 	#255
.a20b	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a20e	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a210	7a		ply				ply
.a211	20 7f a2	jsr $a27f			jsr 	RunGraphicsCommand
.a214	80 5d		bra $a273			bra 	ExecuteGraphicCommand
.a216					_SCRange:
.a216	4c 49 a0	jmp $a049			jmp 	RangeError
.a219					ImageCommand:
.a219	a2 00		ldx #$00			ldx 	#0
.a21b	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; get image number.
.a21e	20 7f a2	jsr $a27f			jsr 	RunGraphicsCommand
.a221					ImageRunDraw:
.a221	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a223	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a226	ad 36 06	lda $0636			lda 	gxDrawScale
.a229	0a		asl a				asl 	a
.a22a	0a		asl a				asl 	a
.a22b	0a		asl a				asl 	a
.a22c	a8		tay				tay
.a22d	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a22f	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a232	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a235	60		rts				rts
.a236					TextCommand:
.a236	a2 00		ldx #$00			ldx 	#0
.a238	20 ee 9d	jsr $9dee			jsr 	EvaluateString 				; get text
.a23b	20 7f a2	jsr $a27f			jsr 	RunGraphicsCommand
.a23e					TextRunDraw:
.a23e	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a240	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a243	a0 00		ldy #$00			ldy 	#0
.a245					_IRDLoop:
.a245	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a248	85 37		sta $37				sta 	zTemp0+1
.a24a	ad 08 04	lda $0408			lda 	NSMantissa0
.a24d	85 36		sta $36				sta 	zTemp0
.a24f	b1 36		lda ($36),y			lda 	(zTemp0),y
.a251	f0 13		beq $a266			beq 	_IRDExit
.a253	5a		phy				phy									; save string pos
.a254	48		pha				pha 								; save char
.a255	ad 36 06	lda $0636			lda 	gxDrawScale 				; get scale
.a258	0a		asl a				asl 	a
.a259	0a		asl a				asl 	a
.a25a	0a		asl a				asl 	a
.a25b	a8		tay				tay
.a25c	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a25e	fa		plx				plx 								; char to draw
.a25f	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a262	7a		ply				ply 								; restore string pos
.a263	c8		iny				iny
.a264	90 df		bcc $a245			bcc 	_IRDLoop 					; go back if no error.
.a266					_IRDExit:
.a266	60		rts				rts
.a267					PlotCommand:
.a267	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a269	20 7f a2	jsr $a27f			jsr 	RunGraphicsCommand
.a26c	80 05		bra $a273			bra 	ExecuteGraphicCommand
.a26e					LineCommand:
.a26e	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a270	20 7f a2	jsr $a27f			jsr 	RunGraphicsCommand
.a273					ExecuteGraphicCommand:
.a273	0d 2f 06	ora $062f			ora 	gxCommandID 				; make a full command
.a276	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw 				; draw it and exit
.a279	b0 01		bcs $a27c			bcs 	_EGCError
.a27b	60		rts				rts
.a27c					_EGCError:
.a27c	4c 44 a0	jmp $a044			jmp 	SyntaxError
.a27f					RunGraphicsCommand:
.a27f	8d 2f 06	sta $062f			sta 	gxCommandID					; save TODO graphics command.
.a282	68		pla				pla 								; pop handler address
.a283	fa		plx				plx
.a284	1a		inc a				inc 	a
.a285	d0 01		bne $a288			bne 	_RGINoCarry
.a287	e8		inx				inx
.a288					_RGINoCarry:
.a288	8d 34 06	sta $0634			sta 	GXHandler
.a28b	8e 35 06	stx $0635			stx 	GXHandler+1
.a28e					_RGICommandLoop:
.a28e	b1 30		lda ($30),y			lda 	(codePtr),y
.a290	c8		iny				iny
.a291	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a293	f0 53		beq $a2e8			beq 	_RGI_To
.a295	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a297	f0 55		beq $a2ee			beq 	_RGI_Here
.a299	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a29b	f0 3d		beq $a2da			beq 	_RGI_Exit
.a29d	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a29f	f0 39		beq $a2da			beq 	_RGI_Exit
.a2a1	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a2a3	f0 3e		beq $a2e3			beq 	_RGI_Frame
.a2a5	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a2a7	f0 33		beq $a2dc			beq 	_RGI_Solid
.a2a9	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a2ab	f0 4b		beq $a2f8			beq 	_RGI_By
.a2ad	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a2af	f0 17		beq $a2c8			beq 	_RGI_Move2
.a2b1	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a2b3	f0 65		beq $a31a			beq 	_RGI_Dim
.a2b5	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a2b7	f0 78		beq $a331			beq 	_RGI_Colour
.a2b9	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a2bb	f0 74		beq $a331			beq 	_RGI_Colour
.a2bd	ae 2f 06	ldx $062f			ldx 	gxCommandID
.a2c0	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a2c2	d0 03		bne $a2c7			bne 	_RGI_Move 					; move
.a2c4	4c 5b a3	jmp $a35b			jmp		_RGI_SpriteInstructions
.a2c7					_RGI_Move:
.a2c7	88		dey				dey 								; unpick get.
.a2c8					_RGI_Move2:
.a2c8	20 81 a3	jsr $a381			jsr 	GCGetCoordinatePair 		; move to here
.a2cb	20 a8 a3	jsr $a3a8			jsr 	GCCopyPairToStore 			; save
.a2ce	5a		phy				phy
.a2cf	20 9e a3	jsr $a39e			jsr 	GCLoadAXY 					; load in
.a2d2	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a2d4	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a2d7	7a		ply				ply
.a2d8	80 b4		bra $a28e			bra 	_RGICommandLoop 			; and go round
.a2da					_RGI_Exit:
.a2da	88		dey				dey 								; unpick : / EOL
.a2db	60		rts				rts
.a2dc					_RGI_Solid:
.a2dc	a9 02		lda #$02			lda 	#2
.a2de	8d 30 06	sta $0630			sta 	gxFillSolid
.a2e1	80 ab		bra $a28e			bra 	_RGICommandLoop
.a2e3					_RGI_Frame:
.a2e3	9c 30 06	stz $0630			stz 	gxFillSolid
.a2e6	80 a6		bra $a28e			bra 	_RGICommandLoop
.a2e8					_RGI_To:
.a2e8	20 81 a3	jsr $a381			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a2eb	20 a8 a3	jsr $a3a8			jsr 	GCCopyPairToStore
.a2ee					_RGI_Here:
.a2ee	5a		phy				phy
.a2ef	20 9e a3	jsr $a39e			jsr 	GCLoadAXY 					; load it into AXY
.a2f2	20 58 a3	jsr $a358			jsr 	_RGICallHandler 			; go do whatever it is.
.a2f5	7a		ply				ply
.a2f6	80 96		bra $a28e			bra 	_RGICommandLoop 			; and go round
.a2f8					_RGI_By:
.a2f8	20 8e a3	jsr $a38e			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a2fb	18		clc				clc
.a2fc	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a2ff	6d 31 06	adc $0631			adc 	gxxPos
.a302	8d 31 06	sta $0631			sta 	gxXPos
.a305	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a308	6d 32 06	adc $0632			adc 	gxxPos+1
.a30b	8d 32 06	sta $0632			sta 	gxXPos+1
.a30e	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a311	18		clc				clc
.a312	6d 33 06	adc $0633			adc 	gxYPos
.a315	8d 33 06	sta $0633			sta 	gxYPos
.a318	80 d4		bra $a2ee			bra 	_RGI_Here
.a31a					_RGI_Dim:
.a31a	a2 01		ldx #$01			ldx	 	#1
.a31c	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger
.a31f	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a322	c9 00		cmp #$00			cmp 	#0
.a324	f0 2f		beq $a355			beq 	_RGIRange
.a326	c9 09		cmp #$09			cmp 	#8+1
.a328	b0 2b		bcs $a355			bcs		_RGIRange
.a32a	3a		dec a				dec 	a
.a32b	8d 36 06	sta $0636			sta 	gxDrawScale
.a32e	4c 8e a2	jmp $a28e			jmp 	_RGICommandLoop
.a331					_RGI_Colour:
.a331	a2 01		ldx #$01			ldx 	#1 							; colour
.a333	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger
.a336	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a338	20 ba 9e	jsr $9eba			jsr 	NSMSetZero
.a33b	b1 30		lda ($30),y			lda 	(codePtr),y
.a33d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a33f	d0 04		bne $a345			bne 	_RGICDefaultMode
.a341	c8		iny				iny
.a342	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger
.a345					_RGICDefaultMode:
.a345	5a		phy				phy
.a346	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a348	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a34b	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a34e	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a351	7a		ply				ply
.a352	4c 8e a2	jmp $a28e			jmp 	_RGICommandLoop 			; and go round
.a355					_RGIRange:
.a355	4c 49 a0	jmp $a049			jmp 	RangeError
.a358					_RGICallHandler:
.a358	6c 34 06	jmp ($0634)			jmp 	(GXHandler)
.a35b					_RGI_SpriteInstructions:
.a35b	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a35d	f0 07		beq $a366			beq 	_RGISpriteOff
.a35f	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a361	f0 13		beq $a376			beq 	_RGISetImage
.a363	4c c7 a2	jmp $a2c7			jmp 	_RGI_Move
.a366					_RGISpriteOff:
.a366	5a		phy				phy
.a367	a0 01		ldy #$01			ldy 	#1
.a369	a2 00		ldx #$00			ldx 	#0
.a36b					_RGIDoCommandLoop:
.a36b	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a36d	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a370	7a		ply				ply
.a371	b0 e2		bcs $a355			bcs 	_RGIRange
.a373	4c 8e a2	jmp $a28e			jmp 	_RGICommandLoop
.a376					_RGISetImage:
.a376	a2 01		ldx #$01			ldx 	#1
.a378	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger
.a37b	5a		phy				phy
.a37c	aa		tax				tax
.a37d	a0 00		ldy #$00			ldy 	#0
.a37f	80 ea		bra $a36b			bra 	_RGIDoCommandLoop
.a381					GCGetCoordinatePair:
.a381	a2 01		ldx #$01			ldx 	#1
.a383	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger
.a386	20 e6 8d	jsr $8de6			jsr 	CheckComma
.a389	e8		inx				inx
.a38a	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger
.a38d	60		rts				rts
.a38e					GCSignedCoordinatePair:
.a38e	a2 01		ldx #$01			ldx 	#1
.a390	20 27 9e	jsr $9e27			jsr 	Evaluate16BitIntegerSigned
.a393	20 e6 8d	jsr $8de6			jsr 	CheckComma
.a396	e8		inx				inx
.a397	20 27 9e	jsr $9e27			jsr 	Evaluate16BitIntegerSigned
.a39a	60		rts				rts
.a39b					_GCCPRange:
.a39b	4c 49 a0	jmp $a049			jmp 	RangeError
.a39e					GCLoadAXY:
.a39e	ad 32 06	lda $0632			lda 	gxXPos+1
.a3a1	ae 31 06	ldx $0631			ldx 	gxXPos
.a3a4	ac 33 06	ldy $0633			ldy 	gxYPos
.a3a7	60		rts				rts
.a3a8					GCCopyPairToStore:
.a3a8	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a3ab	8d 31 06	sta $0631			sta 	gxXPos
.a3ae	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a3b1	8d 32 06	sta $0632			sta 	gxXPos+1
.a3b4	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a3b7	8d 33 06	sta $0633			sta 	gxYPos
.a3ba	60		rts				rts
.062f					gxCommandID:
>062f							.fill 	1
.0630					gxFillSolid:
>0630							.fill 	1
.0631					gxXPos:
>0631							.fill 	2
.0633					gxYPos:
>0633							.fill 	1
.0634					gxHandler:
>0634							.fill 	2
.0636					gxDrawScale:
>0636							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a3bb					BitmapCtrl:
.a3bb	b1 30		lda ($30),y			lda 	(codePtr),y
.a3bd	c8		iny				iny
.a3be	a2 01		ldx #$01			ldx 	#1
.a3c0	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a3c2	f0 11		beq $a3d5			beq 	BitmapSwitch
.a3c4	ca		dex				dex
.a3c5	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a3c7	f0 0c		beq $a3d5			beq 	BitmapSwitch
.a3c9	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; get the colour
.a3cc	5a		phy				phy
.a3cd	aa		tax				tax
.a3ce	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a3d0	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a3d3	7a		ply				ply
.a3d4	60		rts				rts
.a3d5					BitmapSwitch:
.a3d5	5a		phy				phy
.a3d6	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a3d8	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a3da	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a3dd	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a3df	a0 00		ldy #$00			ldy 	#0
.a3e1	a2 ff		ldx #$ff			ldx 	#$FF
.a3e3	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a3e6	9c 30 06	stz $0630			stz 	gxFillSolid
.a3e9	9c 31 06	stz $0631			stz 	gxXPos
.a3ec	9c 32 06	stz $0632			stz 	gxXPos+1
.a3ef	9c 33 06	stz $0633			stz 	gxYPos
.a3f2	9c 36 06	stz $0636			stz 	gxDrawScale
.a3f5	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a3f7	a2 00		ldx #$00			ldx 	#0
.a3f9	a0 00		ldy #$00			ldy 	#0
.a3fb	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a3fe	7a		ply				ply
.a3ff	60		rts				rts
.a400					SpritesCtrl:
.a400	b1 30		lda ($30),y			lda 	(codePtr),y
.a402	c8		iny				iny
.a403	a2 01		ldx #$01			ldx 	#1
.a405	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a407	f0 08		beq $a411			beq 	SpriteSwitch
.a409	ca		dex				dex
.a40a	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a40c	f0 03		beq $a411			beq 	SpriteSwitch
.a40e	4c 44 a0	jmp $a044			jmp 	SyntaxError
.a411					SpriteSwitch:
.a411	5a		phy				phy
.a412	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a414	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a416	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a419	7a		ply				ply
.a41a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a41b					GfxCommand:
.a41b	a2 00		ldx #$00			ldx 	#0
.a41d	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; command
.a420	20 e6 8d	jsr $8de6			jsr 	CheckComma
.a423	e8		inx				inx
.a424	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger 		; X
.a427	20 e6 8d	jsr $8de6			jsr 	CheckComma
.a42a	e8		inx				inx
.a42b	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; Y
.a42e	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a431	4a		lsr a				lsr 	a
.a432	d0 16		bne $a44a			bne 	_GfxError
.a434	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a437	b0 11		bcs $a44a			bcs 	_GfxError 					; bit 7 should have been zero
.a439	5a		phy				phy 								; save pos
.a43a	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a43d	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a440	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a443	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw
.a446	b0 02		bcs $a44a			bcs 	_GfxError
.a448	7a		ply				ply 								; restore pos and exit.
.a449	60		rts				rts
.a44a					_GfxError:
.a44a	4c 49 a0	jmp $a049			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a44d					UnaryHit:
.a44d	fa		plx				plx
.a44e	a9 36		lda #$36			lda 	#zTemp0
.a450	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a453	20 e6 8d	jsr $8de6			jsr 	CheckComma
.a456	e8		inx				inx
.a457	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a45a	20 de 8d	jsr $8dde			jsr		CheckRightBracket
.a45d	ca		dex				dex 								; fix back up again.
.a45e	da		phx				phx 								; save X/Y
.a45f	5a		phy				phy
.a460	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a463	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a466	aa		tax				tax
.a467	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a469	20 84 ab	jsr $ab84			jsr 	GXGraphicDraw 				; calculate result
.a46c	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a46d	7a		ply				ply 								; restore XY
.a46e	fa		plx				plx
.a46f	20 bc 9e	jsr $9ebc			jsr 	NSMSetByte 					; return the hit result
.a472	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a473					PaletteCommand:
.a473	a2 00		ldx #$00			ldx 	#0
.a475	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; colour
.a478	20 e6 8d	jsr $8de6			jsr 	CheckComma
.a47b	e8		inx				inx
.a47c	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger 		; r
.a47f	20 e6 8d	jsr $8de6			jsr 	CheckComma
.a482	e8		inx				inx
.a483	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; g
.a486	20 e6 8d	jsr $8de6			jsr 	CheckComma
.a489	e8		inx				inx
.a48a	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; b
.a48d	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a490	85 36		sta $36				sta 	zTemp0
.a492	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a494	85 37		sta $37				sta 	zTemp0+1
.a496	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a498	26 37		rol $37				rol	 	zTemp0+1
.a49a	06 36		asl $36				asl 	zTemp0
.a49c	26 37		rol $37				rol	 	zTemp0+1
.a49e	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a4a0	85 01		sta $01				sta 	1
.a4a2	5a		phy				phy
.a4a3	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a4a6	92 36		sta ($36)			sta 	(zTemp0)
.a4a8	a0 01		ldy #$01			ldy 	#1
.a4aa	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a4ad	91 36		sta ($36),y			sta 	(zTemp0),y
.a4af	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a4b2	c8		iny				iny
.a4b3	91 36		sta ($36),y			sta 	(zTemp0),y
.a4b5	7a		ply				ply
.a4b6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a4b7					UnaryEvent:
.a4b7	fa		plx				plx
.a4b8	20 71 a5	jsr $a571			jsr 	TimerToStackX 				; timer in +0
.a4bb	e8		inx				inx  								; put reference into +1
.a4bc	20 80 98	jsr $9880			jsr 	EvaluateTerm
.a4bf	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a4c2	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a4c4	d0 57		bne $a51d			bne 	_UEType
.a4c6	e8		inx				inx 								; put the step in +2
.a4c7	20 e6 8d	jsr $8de6			jsr 	CheckComma
.a4ca	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger
.a4cd	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.a4d0	ca		dex				dex
.a4d1	ca		dex				dex
.a4d2	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a4d5	85 36		sta $36				sta 	zTemp0
.a4d7	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a4da	85 37		sta $37				sta 	zTemp0+1
.a4dc	5a		phy				phy
.a4dd	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a4df	b1 36		lda ($36),y			lda 	(zTemp0),y
.a4e1	30 36		bmi $a519			bmi 	_UEFalse 					; exit if signed.
.a4e3	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a4e5	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a4e8	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a4ea	c8		iny				iny
.a4eb	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a4ee	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4f0	c8		iny				iny
.a4f1	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a4f4	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4f6	90 21		bcc $a519			bcc 	_UEFalse 					; no, return FALSE.
.a4f8	18		clc				clc
.a4f9	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a4fb	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a4fe	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a501	91 36		sta ($36),y			sta 	(zTemp0),y
.a503	c8		iny				iny
.a504	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a507	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a50a	91 36		sta ($36),y			sta 	(zTemp0),y
.a50c	c8		iny				iny
.a50d	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a510	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a513	91 36		sta ($36),y			sta 	(zTemp0),y
.a515	7a		ply				ply
.a516	4c 64 8e	jmp $8e64			jmp 	ReturnTrue
.a519					_UEFalse:
.a519	7a		ply				ply 								; restore Y
.a51a	4c 70 8e	jmp $8e70			jmp 	ReturnFalse 				; and return False
.a51d					_UEType:
.a51d	4c 4e a0	jmp $a04e			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a520					UnaryJoyX:
.a520	18		clc				clc
.a521	80 01		bra $a524			bra 	JoyMain
.a523					UnaryJoyY:
.a523	38		sec				sec
.a524					JoyMain:
.a524	fa		plx				plx 								; get pos
.a525	08		php				php 								; save carry (set for Y)
.a526	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a529	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.a52c	20 3d ab	jsr $ab3d			jsr 	EXTReadController 			; read the controller.
.a52f	28		plp				plp
.a530	90 02		bcc $a534			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a532	4a		lsr a				lsr 	a
.a533	4a		lsr a				lsr 	a
.a534					_JMNoShift:
.a534	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a535	b0 0a		bcs $a541			bcs 	_JMIsRight
.a537	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a538	b0 04		bcs $a53e			bcs 	_JMIsLeft
.a53a	20 ba 9e	jsr $9eba			jsr 	NSMSetZero 					; zero result
.a53d	60		rts				rts
.a53e					_JMIsLeft:
.a53e	4c 64 8e	jmp $8e64			jmp 	ReturnTrue
.a541					_JMIsRight:
.a541	a9 01		lda #$01			lda 	#1
.a543	20 bc 9e	jsr $9ebc			jsr 	NSMSetByte
.a546	60		rts				rts
.a547					UnaryJoyB:
.a547	fa		plx				plx 								; get pos
.a548	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a54b	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.a54e	20 3d ab	jsr $ab3d			jsr 	EXTReadController 			; read the controller.
.a551	4a		lsr a				lsr 	a
.a552	4a		lsr a				lsr 	a
.a553	4a		lsr a				lsr 	a
.a554	4a		lsr a				lsr 	a
.a555	29 01		and #$01			and 	#1
.a557	20 bc 9e	jsr $9ebc			jsr 	NSMSetByte
.a55a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a55b					LoadCommand:
.a55b	20 47 89	jsr $8947			jsr 	NewProgram
.a55e	20 e3 82	jsr $82e3			jsr 	BackLoadProgram
.a561	4c 57 83	jmp $8357			jmp 	WarmStart
.a564					GoCommand:
.a564	20 47 89	jsr $8947			jsr 	NewProgram
.a567	20 e3 82	jsr $82e3			jsr 	BackLoadProgram
.a56a	4c 86 8a	jmp $8a86			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a56d					UnaryTimer:
.a56d	fa		plx				plx
.a56e	20 de 8d	jsr $8dde			jsr 	CheckRightBracket
.a571					TimerToStackX:
.a571	20 ba 9e	jsr $9eba			jsr 	NSMSetZero 					; zero result
.a574	64 01		stz $01				stz 	1 							; access I/O
.a576	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a579	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a57c	ad 5a d6	lda $d65a			lda 	$D65A
.a57f	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a582	ad 5b d6	lda $d65b			lda 	$D65B
.a585	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a588	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a589					MemoryDeleteLine:
.a589	20 a8 a5	jsr $a5a8			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a58c	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a58e	a8		tay				tay
.a58f					_MDDLLoop:
.a58f	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a591	92 30		sta ($30)			sta 	(codePtr)
.a593	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a595	c5 3a		cmp $3a				cmp 	zTemp2
.a597	d0 07		bne $a5a0			bne 	_MDLDLNext
.a599	a5 31		lda $31				lda 	codePtr+1
.a59b	c5 3b		cmp $3b				cmp 	zTemp2+1
.a59d	d0 01		bne $a5a0			bne 	_MDLDLNext
.a59f					_MDDLExit:
.a59f	60		rts				rts
.a5a0					_MDLDLNext:
.a5a0	e6 30		inc $30				inc 	codePtr						; next byte
.a5a2	d0 eb		bne $a58f			bne 	_MDDLLoop
.a5a4	e6 31		inc $31				inc 	codePtr+1
.a5a6	80 e7		bra $a58f			bra 	_MDDLLoop
.a5a8					IMemoryFindEnd:
.a5a8	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5aa	85 3a		sta $3a				sta 	0+zTemp2
.a5ac	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5ae	85 3b		sta $3b				sta 	1+zTemp2
.a5b0					_MDLFELoop:
.a5b0	b2 3a		lda ($3a)			lda 	(zTemp2)
.a5b2	f0 0b		beq $a5bf			beq 	_MDLFEExit
.a5b4	18		clc				clc
.a5b5	65 3a		adc $3a				adc 	zTemp2
.a5b7	85 3a		sta $3a				sta 	zTemp2
.a5b9	90 f5		bcc $a5b0			bcc 	_MDLFELoop
.a5bb	e6 3b		inc $3b				inc 	zTemp2+1
.a5bd	80 f1		bra $a5b0			bra 	_MDLFELoop
.a5bf					_MDLFEExit:
.a5bf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a5c0					MemoryInsertLine:
.a5c0	08		php				php
.a5c1	20 a8 a5	jsr $a5a8			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a5c4	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a5c6	1a		inc a				inc 	a
.a5c7	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a5c9	b0 36		bcs $a601			bcs 	_MDLIError
.a5cb	28		plp				plp
.a5cc	90 08		bcc $a5d6			bcc 	_MDLIFound
.a5ce	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a5d0	85 30		sta $30				sta 	codePtr
.a5d2	a5 3b		lda $3b				lda 	zTemp2+1
.a5d4	85 31		sta $31				sta 	codePtr+1
.a5d6					_MDLIFound:
.a5d6	ad a9 04	lda $04a9			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a5d9	a8		tay				tay
.a5da					_MDLIInsert:
.a5da	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a5dc	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a5de	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a5e0	c5 3a		cmp $3a				cmp 	zTemp2
.a5e2	d0 06		bne $a5ea			bne 	_MDLINext
.a5e4	a5 31		lda $31				lda 	codePtr+1
.a5e6	c5 3b		cmp $3b				cmp 	zTemp2+1
.a5e8	f0 0a		beq $a5f4			beq 	_MDLIHaveSpace
.a5ea					_MDLINext:
.a5ea	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a5ec	d0 02		bne $a5f0			bne 	_MDLINoBorrow
.a5ee	c6 3b		dec $3b				dec 	zTemp2+1
.a5f0					_MDLINoBorrow:
.a5f0	c6 3a		dec $3a				dec 	zTemp2
.a5f2	80 e6		bra $a5da			bra 	_MDLIInsert
.a5f4					_MDLIHaveSpace:
.a5f4	ac a9 04	ldy $04a9			ldy 	tokenOffset 				; bytes to copy
.a5f7	88		dey				dey 								; from offset-1 to 0
.a5f8					_MDLICopy:
.a5f8	b9 a9 04	lda $04a9,y			lda 	tokenOffset,y
.a5fb	91 30		sta ($30),y			sta 	(codePtr),y
.a5fd	88		dey				dey
.a5fe	10 f8		bpl $a5f8			bpl 	_MDLICopy
.a600	60		rts				rts
.a601					_MDLIError:
.a601	a9 06		lda #$06		lda	#6
.a603	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.a606					MDLAppendLine:
.a606	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a608	85 36		sta $36				sta 	zTemp0
.a60a	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a60c	85 38		sta $38				sta 	0+zTemp1
.a60e	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a610	85 39		sta $39				sta 	1+zTemp1
.a612	b2 38		lda ($38)			lda 	(zTemp1)
.a614	d0 0a		bne $a620			bne 	_MDLANoInitialise
.a616	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a618	8d 37 06	sta $0637			sta 	0+AppendPointer
.a61b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a61d	8d 38 06	sta $0638			sta 	1+AppendPointer
.a620					_MDLANoInitialise:
.a620	18		clc				clc
.a621	ad 37 06	lda $0637			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a624	85 38		sta $38				sta 	zTemp1
.a626	72 36		adc ($36)			adc 	(zTemp0)
.a628	8d 37 06	sta $0637			sta 	AppendPointer
.a62b	ad 38 06	lda $0638			lda 	AppendPointer+1
.a62e	85 39		sta $39				sta 	zTemp1+1
.a630	69 00		adc #$00			adc 	#0
.a632	8d 38 06	sta $0638			sta 	AppendPointer+1
.a635	a0 00		ldy #$00			ldy 	#0
.a637					_MDLACopy:
.a637	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a639	91 38		sta ($38),y			sta 	(zTemp1),y
.a63b	c8		iny				iny
.a63c	98		tya				tya
.a63d	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a63f	d0 f6		bne $a637			bne 	_MDLACopy
.a641	a9 00		lda #$00			lda 	#0 							; end of program.
.a643	91 38		sta ($38),y			sta 	(zTemp1),y
.a645	60		rts				rts
.0637					AppendPointer:
>0637							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a646					MemoryNew:
.a646	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a648	85 30		sta $30				sta 	codePtr
.a64a	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a64c	85 31		sta $31				sta 	codePtr+1
.a64e	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a650	92 30		sta ($30)			sta 	(codePtr)
.a652	60		rts				rts
.a653					MemoryInline:
.a653	98		tya				tya 								; put address into stack,x
.a654	18		clc				clc  								; get the offset, add codePtr
.a655	65 30		adc $30				adc 	codePtr
.a657	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a65a	a5 31		lda $31				lda 	codePtr+1
.a65c	69 00		adc #$00			adc 	#0
.a65e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a661	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a664	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a667	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a668					MemorySearch:
.a668	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a66a	86 37		stx $37				stx 	zTemp0+1
.a66c	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a66e	85 30		sta $30				sta 	codePtr
.a670	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a672	85 31		sta $31				sta 	codePtr+1
.a674					_MTAXLoop:
.a674	b2 30		lda ($30)			lda 	(codePtr)
.a676	18		clc				clc
.a677	f0 21		beq $a69a			beq 	_MTAXExit 					; reached end, exit with CC.
.a679	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a67b	b1 30		lda ($30),y			lda 	(codePtr),y
.a67d	38		sec				sec
.a67e	e5 36		sbc $36				sbc 	zTemp0
.a680	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a682	c8		iny				iny 								; do the MSB
.a683	b1 30		lda ($30),y			lda 	(codePtr),y
.a685	e5 37		sbc $37				sbc 	zTemp0+1
.a687	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a689	f0 0f		beq $a69a			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a68b	b0 0d		bcs $a69a			bcs 	_MTAXExit 					; current < required exit
.a68d	18		clc				clc
.a68e	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a690	65 30		adc $30				adc 	codePtr
.a692	85 30		sta $30				sta 	codePtr
.a694	90 02		bcc $a698			bcc 	_CREExit
.a696	e6 31		inc $31				inc 	codePtr+1 					; carry
.a698					_CREExit:
.a698	80 da		bra $a674			bra 	_MTAXLoop
.a69a					_MTAXExit:
.a69a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a69b					UnaryPlaying:
.a69b	fa		plx				plx
.a69c	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; get channel #
.a69f	48		pha				pha
.a6a0	20 de 8d	jsr $8dde			jsr		CheckRightBracket
.a6a3	68		pla				pla
.a6a4	c9 04		cmp #$04			cmp 	#4
.a6a6	b0 0c		bcs $a6b4			bcs 	_UPNotPlaying
.a6a8	09 20		ora #$20			ora 	#$20 						; query playing ?
.a6aa	20 12 ba	jsr $ba12			jsr 	SNDCommand
.a6ad	c9 00		cmp #$00			cmp 	#0
.a6af	f0 03		beq $a6b4			beq 	_UPNotPlaying
.a6b1	4c 64 8e	jmp $8e64			jmp 	ReturnTrue
.a6b4					_UPNotPlaying:
.a6b4	4c 70 8e	jmp $8e70			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a6b7					SoundCommand:
.a6b7	b1 30		lda ($30),y			lda 	(codePtr),y
.a6b9	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a6bb	d0 09		bne $a6c6			bne 	_SNDMain
.a6bd	c8		iny				iny 								; skip OFF
.a6be	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a6c0	5a		phy				phy
.a6c1	20 12 ba	jsr $ba12			jsr 	SNDCommand
.a6c4	7a		ply				ply
.a6c5	60		rts				rts
.a6c6					_SNDMain:
.a6c6	a2 00		ldx #$00			ldx 	#0
.a6c8	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; channel
.a6cb	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a6cd	b0 50		bcs $a71f			bcs 	_SndError
.a6cf	e8		inx				inx 								; do the rest in slot 1.
.a6d0	20 e6 8d	jsr $8de6			jsr 	CheckComma
.a6d3	20 1b 9e	jsr $9e1b			jsr 	Evaluate16BitInteger 		; Pitch
.a6d6	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a6d9	c9 10		cmp #$10			cmp 	#16
.a6db	b0 42		bcs $a71f			bcs 	_SndError
.a6dd	8d 3a 06	sta $063a			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a6e0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a6e3	8d 39 06	sta $0639			sta 	SoundCommandBlock
.a6e6	20 e6 8d	jsr $8de6			jsr 	CheckComma
.a6e9	20 3b 9e	jsr $9e3b			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a6ec	8d 3c 06	sta $063c			sta 	SoundCommandBlock+3
.a6ef	a9 0f		lda #$0f			lda 	#15
.a6f1	8d 3b 06	sta $063b			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a6f4	9c 3d 06	stz $063d			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a6f7	9c 3e 06	stz $063e			stz 	SoundCommandBlock+5
.a6fa	b1 30		lda ($30),y			lda 	(codePtr),y
.a6fc	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a6fe	d0 10		bne $a710			bne 	_SNDPlay
.a700	c8		iny				iny
.a701	20 27 9e	jsr $9e27			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a704	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a707	8d 3d 06	sta $063d			sta 	SoundCommandBlock+4
.a70a	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a70d	8d 3e 06	sta $063e			sta 	SoundCommandBlock+5
.a710					_SNDPlay:
.a710	5a		phy				phy
.a711	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a714	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a716	a2 39		ldx #$39			ldx 	#(SoundCommandBlock & $FF)
.a718	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a71a	20 12 ba	jsr $ba12			jsr 	SNDCommand
.a71d	7a		ply				ply
.a71e	60		rts				rts
.a71f					_SndError:
.a71f	4c 49 a0	jmp $a049			jmp 	RangeError
.0639					SoundCommandBlock:
>0639							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a722					StackPushByte:
.a722	48		pha				pha 								; save byte
.a723	a5 34		lda $34				lda 	BasicStack
.a725	d0 09		bne $a730			bne 	_SPBNoBorrow
.a727	c6 35		dec $35				dec 	BasicStack+1
.a729	48		pha				pha
.a72a	a5 35		lda $35				lda 	BasicStack+1
.a72c	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a72e	90 06		bcc $a736			bcc 	_SPBMemory
.a730					_SPBNoBorrow:
.a730	c6 34		dec $34				dec 	BasicStack
.a732	68		pla				pla 								; get back and write
.a733	92 34		sta ($34)			sta 	(BasicStack)
.a735	60		rts				rts
.a736					_SPBMemory:
.a736	a9 12		lda #$12		lda	#18
.a738	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.a73b					StackPopByte:
.a73b	b2 34		lda ($34)			lda 	(BasicStack)
.a73d	e6 34		inc $34				inc 	BasicStack
.a73f	d0 02		bne $a743			bne 	_SPBNoCarry
.a741	e6 35		inc $35				inc 	BasicStack+1
.a743					_SPBNoCarry:
.a743	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a744					StackOpen:
.a744	48		pha				pha 								; save frame byte
.a745	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a747	0a		asl a				asl 	a 							; claim twice this for storage
.a748	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a74a	38		sec				sec 								; so basically subtracting from
.a74b	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a74d	85 34		sta $34				sta 	basicStack
.a74f	b0 08		bcs $a759			bcs 	_SONoBorrow
.a751	c6 35		dec $35				dec 	basicStack+1
.a753	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a755	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a757	90 04		bcc $a75d			bcc 	_SOMemory
.a759					_SONoBorrow:
.a759	68		pla				pla 								; get marker back and write at TOS
.a75a	92 34		sta ($34)			sta 	(basicStack)
.a75c	60		rts				rts
.a75d					_SOMemory:
.a75d	a9 12		lda #$12		lda	#18
.a75f	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.a762					StackClose:
.a762	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a764	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a766	0a		asl a				asl 	a 							; claim twice this.
.a767	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a769	85 34		sta $34				sta 	basicStack
.a76b	90 02		bcc $a76f			bcc 	_SCExit
.a76d	e6 35		inc $35				inc 	basicStack+1
.a76f					_SCExit:
.a76f	60		rts				rts
.a770					StackCheckFrame:
.a770	48		pha				pha
.a771					_StackRemoveLocals:
.a771	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a773	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a775	b0 05		bcs $a77c			bcs 	_SCNoLocal
.a777	20 f6 88	jsr $88f6			jsr 	LocalPopValue
.a77a	80 f5		bra $a771			bra 	_StackRemoveLocals
.a77c					_SCNoLocal:
.a77c	68		pla				pla
.a77d	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a77f	29 f0		and #$f0			and 	#$F0 						; check type bits
.a781	d0 01		bne $a784			bne 	_SCFError 					; different, we have structures mixed up
.a783	60		rts				rts
.a784					_SCFError:
.a784	8a		txa				txa 								; report error X
.a785	4c f7 8d	jmp $8df7			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a788					STKSaveCodePosition:
.a788	5a		phy				phy
.a789	98		tya				tya 								; save Y
.a78a	a0 05		ldy #$05			ldy 	#5
.a78c	91 34		sta ($34),y			sta 	(basicStack),y
.a78e	88		dey				dey 								; save Code Pointer
.a78f					_STKSaveLoop:
.a78f	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a792	91 34		sta ($34),y			sta 	(basicStack),y
.a794	88		dey				dey
.a795	d0 f8		bne $a78f			bne 	_STKSaveLoop
.a797	7a		ply				ply
.a798	60		rts				rts
.a799					STKLoadCodePosition:
.a799	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a79b					_STKLoadLoop:
.a79b	b1 34		lda ($34),y			lda 	(basicStack),y
.a79d	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a7a0	c8		iny				iny
.a7a1	c0 05		cpy #$05			cpy 	#5
.a7a3	d0 f6		bne $a79b			bne 	_STKLoadLoop
.a7a5	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a7a7	a8		tay				tay
.a7a8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a7a9					StackReset:
.a7a9	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a7ab	85 34		sta $34				sta 	0+basicStack
.a7ad	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a7af	85 35		sta $35				sta 	1+basicStack
.a7b1	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a7b3	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a7b5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a7b6					StringConcrete:
.a7b6	5a		phy				phy 								; save position on stack
.a7b7	20 83 9a	jsr $9a83			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7ba	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a7bd	85 38		sta $38				sta 	zTemp1
.a7bf	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a7c2	85 39		sta $39				sta 	zTemp1+1
.a7c4	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a7c6					_SALength:
.a7c6	c8		iny				iny
.a7c7	b1 38		lda ($38),y			lda 	(zTemp1),y
.a7c9	d0 fb		bne $a7c6			bne 	_SALength
.a7cb	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a7cd	b0 3f		bcs $a80e			bcs 	_SALengthError
.a7cf	98		tya				tya 				 				; length of the new string
.a7d0	18		clc				clc
.a7d1	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a7d3	90 02		bcc $a7d7			bcc 	_SAHaveLength
.a7d5	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a7d7					_SAHaveLength:
.a7d7	48		pha				pha 								; save length.
.a7d8	38		sec				sec
.a7d9	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a7db	6d 8e 04	adc $048e			adc 	StringMemory
.a7de	8d 8e 04	sta $048e			sta 	StringMemory
.a7e1	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a7e3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a7e6	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a7e8	6d 8f 04	adc $048f			adc 	StringMemory+1
.a7eb	8d 8f 04	sta $048f			sta 	StringMemory+1
.a7ee	85 3b		sta $3b				sta 	zTemp2+1
.a7f0	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a7f3	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a7f4	38		sec				sec
.a7f5	e9 03		sbc #$03			sbc 	#3
.a7f7	92 3a		sta ($3a)			sta 	(zTemp2)
.a7f9	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a7fb	a0 01		ldy #$01			ldy 	#1
.a7fd	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a7ff					_SACopyNewString:
.a7ff	a0 00		ldy #$00			ldy 	#0
.a801					_SACopyNSLoop:
.a801	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a803	c8		iny				iny 								; write two on in string storage
.a804	c8		iny				iny
.a805	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a807	88		dey				dey 								; this makes it one one.
.a808	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a80a	d0 f5		bne $a801			bne 	_SACopyNSLoop
.a80c	7a		ply				ply
.a80d	60		rts				rts
.a80e					_SALengthError:
.a80e	a9 09		lda #$09		lda	#9
.a810	4c f7 8d	jmp $8df7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a813					StringSystemInitialise:
.a813	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a815	8d 8e 04	sta $048e			sta 	0+StringMemory
.a818	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a81a	8d 8f 04	sta $048f			sta 	1+StringMemory
.a81d	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a820	60		rts				rts
.a821					StringSpaceInitialise:
.a821	20 83 9a	jsr $9a83			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a824	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a826	8d 90 04	sta $0490			sta 	StringInitialised
.a829	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a82c	8d 91 04	sta $0491			sta 	StringTempPointer
.a82f	ad 8f 04	lda $048f			lda 	StringMemory+1
.a832	3a		dec a				dec 	a
.a833	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a836	60		rts				rts
.a837					StringTempAllocate:
.a837	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a839	b0 35		bcs $a870			bcs 	_STALength
.a83b	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a83e	30 05		bmi $a845			bmi 	_STAAllocate
.a840	48		pha				pha 								; save value to subtract.
.a841	20 21 a8	jsr $a821			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a844	68		pla				pla 								; restore it
.a845					_STAAllocate:
.a845	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a847	18		clc				clc  								; deliberate allows one more
.a848	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a84b	8d 91 04	sta $0491			sta 	StringTempPointer
.a84e	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a851	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a853	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a856	69 ff		adc #$ff			adc 	#$FF
.a858	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a85b	85 3d		sta $3d				sta 	zsTemp+1
.a85d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a860	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a863	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a866	a9 10		lda #$10			lda 	#NSTString
.a868	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a86b	a9 00		lda #$00			lda 	#0 							; clear the target string
.a86d	92 3c		sta ($3c)			sta 	(zsTemp)
.a86f	60		rts				rts
.a870					_STALength:
.a870	a9 09		lda #$09		lda	#9
.a872	4c f7 8d	jmp $8df7		jmp	ErrorHandler
.a875					StringTempWrite:
.a875	48		pha				pha
.a876	92 3c		sta ($3c)			sta 	(zsTemp)
.a878	e6 3c		inc $3c				inc 	zsTemp
.a87a	d0 02		bne $a87e			bne 	_STWNoCarry
.a87c	e6 3d		inc $3d				inc 	zsTemp+1
.a87e					_STWNoCarry:
.a87e	a9 00		lda #$00			lda 	#0
.a880	92 3c		sta ($3c)			sta 	(zsTemp)
.a882	68		pla				pla
.a883	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a884					EXTPrintCharacter:
.a884	48		pha				pha
.a885	da		phx				phx
.a886	5a		phy				phy
.a887	a6 01		ldx $01				ldx 	1
.a889	da		phx				phx
.a88a	ac 40 06	ldy $0640			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a88d	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a88f	30 48		bmi $a8d9			bmi 	_EXPCColour
.a891	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a893	90 4d		bcc $a8e2			bcc 	_EXPCControl
.a895	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a897	86 01		stx $01				stx 	1
.a899	91 40		sta ($40),y			sta 	(EXTAddress),y
.a89b	e6 01		inc $01				inc 	1 							; select colour memory
.a89d	ad 41 06	lda $0641			lda 	EXTTextColour
.a8a0	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8a2	c8		iny				iny 								; advance horizontal position
.a8a3	8c 40 06	sty $0640			sty 	EXTColumn
.a8a6	cc 42 06	cpy $0642			cpy 	EXTScreenWidth 				; reached RHS ?
.a8a9	90 66		bcc $a911			bcc 	_EXPCExit 					; no, then exit.
.a8ab					_EXPCCRLF:
.a8ab	ee 3f 06	inc $063f			inc 	EXTRow  					; bump row
.a8ae	9c 40 06	stz $0640			stz 	EXTColumn 					; back to column 0
.a8b1	ad 3f 06	lda $063f			lda 	EXTRow 						; check if reached the bottom ?
.a8b4	cd 43 06	cmp $0643			cmp 	EXTScreenHeight 			; if so, then scroll.
.a8b7	f0 18		beq $a8d1			beq 	_EXPCScroll
.a8b9	18		clc				clc 								; add width to address.
.a8ba	a5 40		lda $40				lda 	EXTAddress
.a8bc	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a8bf	85 40		sta $40				sta 	EXTAddress
.a8c1	90 4e		bcc $a911			bcc 	_EXPCExit
.a8c3	e6 41		inc $41				inc 	EXTAddress+1
.a8c5	80 4a		bra $a911			bra 	_EXPCExit
.a8c7					_EXPCLeft:
.a8c7	ce 40 06	dec $0640			dec 	EXTColumn
.a8ca	10 45		bpl $a911			bpl 	_EXPCExit
.a8cc					_EXPCBegin:
.a8cc	9c 40 06	stz $0640			stz 	EXTColumn
.a8cf	80 40		bra $a911			bra 	_EXPCExit
.a8d1					_EXPCScroll:
.a8d1	ce 3f 06	dec $063f			dec 	EXTRow 						; the height-1 th line.
.a8d4	20 9e a9	jsr $a99e			jsr 	EXTScreenScroll 			; scroll the screen
.a8d7	80 38		bra $a911			bra 	_EXPCExit
.a8d9					_EXPCColour:
.a8d9	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a8db	b0 34		bcs $a911			bcs 	_EXPCExit
.a8dd	20 7e a9	jsr $a97e			jsr 	_EXPCHandleColour
.a8e0	80 2f		bra $a911			bra 	_EXPCExit
.a8e2					_EXPCControl:
.a8e2	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a8e4	b0 2b		bcs $a911			bcs 	_EXPCExit
.a8e6	0a		asl a				asl 	a 							; double into X
.a8e7	aa		tax				tax
.a8e8	7c 5c a9	jmp ($a95c,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a8eb					_EXPCUp:
.a8eb	ad 3f 06	lda $063f			lda 	EXTRow 						; already at top ?
.a8ee	f0 21		beq $a911			beq 	_EXPCExit
.a8f0	ce 3f 06	dec $063f			dec 	EXTRow 						; up one in position/address
.a8f3	38		sec				sec
.a8f4	a5 40		lda $40				lda 	EXTAddress
.a8f6	ed 42 06	sbc $0642			sbc 	EXTScreenWidth
.a8f9	85 40		sta $40				sta 	EXTAddress
.a8fb	b0 14		bcs $a911			bcs 	_EXPCExit
.a8fd	c6 41		dec $41				dec 	EXTAddress+1
.a8ff	80 10		bra $a911			bra 	_EXPCExit
.a901					_EXPCRight:
.a901	c8		iny				iny
.a902	8c 40 06	sty $0640			sty 	EXTColumn
.a905	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.a908	d0 07		bne $a911			bne 	_EXPCExit
.a90a					_EXPCEnd:
.a90a	ad 42 06	lda $0642			lda 	EXTScreenWidth
.a90d	3a		dec a				dec 	a
.a90e	8d 40 06	sta $0640			sta 	EXTColumn
.a911					_EXPCExit:
.a911	20 f3 a9	jsr $a9f3			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a914	68		pla				pla
.a915	85 01		sta $01				sta 	1
.a917	7a		ply				ply
.a918	fa		plx				plx
.a919	68		pla				pla
.a91a	60		rts				rts
.a91b					_EXPCClearScreen:
.a91b	20 b0 a9	jsr $a9b0			jsr		EXTClearScreenCode
.a91e	80 f1		bra $a911			bra 	_EXPCExit
.a920					_EXPCDown:
.a920	ad 43 06	lda $0643			lda 	EXTScreenHeight 			; at the bottom
.a923	3a		dec a				dec 	a
.a924	cd 3f 06	cmp $063f			cmp 	EXTRow
.a927	f0 e8		beq $a911			beq 	_EXPCExit
.a929	ee 3f 06	inc $063f			inc 	EXTRow 						; down one in position/address
.a92c	18		clc				clc
.a92d	a5 40		lda $40				lda 	EXTAddress
.a92f	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a932	85 40		sta $40				sta 	EXTAddress
.a934	90 db		bcc $a911			bcc 	_EXPCExit
.a936	e6 41		inc $41				inc 	EXTAddress+1
.a938	80 d7		bra $a911			bra 	_EXPCExit
.a93a					_EXPCTab:
.a93a	ad 40 06	lda $0640			lda 	EXTColumn 					; next tab stop
.a93d	29 f8		and #$f8			and 	#$F8
.a93f	18		clc				clc
.a940	69 08		adc #$08			adc 	#8
.a942	8d 40 06	sta $0640			sta 	EXTColumn
.a945	cd 42 06	cmp $0642			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a948	90 c7		bcc $a911			bcc 	_EXPCExit
.a94a	80 be		bra $a90a			bra 	_EXPCEnd
.a94c					_EXPCBackSpace:
.a94c	88		dey				dey
.a94d	30 c2		bmi $a911			bmi 	_EXPCExit
.a94f	ce 40 06	dec $0640			dec 	EXTColumn
.a952	a9 02		lda #$02			lda 	#2
.a954	85 01		sta $01				sta 	1
.a956	a9 20		lda #$20			lda 	#32
.a958	91 40		sta ($40),y			sta 	(EXTAddress),y
.a95a	80 b5		bra $a911			bra 	_EXPCExit
.a95c					_EXPCActionTable:
>a95c	11 a9						.word 	_EXPCExit 					; 00
>a95e	cc a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a960	c7 a8						.word 	_EXPCLeft 					; 02 B Left
>a962	11 a9						.word 	_EXPCExit 					; 03 <Break>
>a964	11 a9						.word 	_EXPCExit 					; 04
>a966	0a a9						.word 	_EXPCEnd 					; 05 E End of Line
>a968	01 a9						.word 	_EXPCRight 					; 06 F Right
>a96a	11 a9						.word 	_EXPCExit 					; 07
>a96c	4c a9						.word 	_EXPCBackspace 				; 08 H Backspace
>a96e	3a a9						.word 	_EXPCTab 					; 09 I Tab
>a970	11 a9						.word 	_EXPCExit 					; 0A
>a972	11 a9						.word 	_EXPCExit 					; 0B
>a974	1b a9						.word 	_EXPCClearScreen			; 0C L CLS
>a976	ab a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a978	20 a9						.word 	_EXPCDown 					; 0E N Down
>a97a	11 a9						.word 	_EXPCExit 					; 0F
>a97c	eb a8						.word 	_EXPCUp 					; 10 P Up
.a97e					_EXPCHandleColour
.a97e	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a980	b0 16		bcs $a998			bcs 	_EXPCBackground
.a982	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a983	0a		asl a				asl 	a
.a984	0a		asl a				asl 	a
.a985	0a		asl a				asl 	a
.a986	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a988					_EXPCUpdate:
.a988	48		pha				pha 								; save new colour
.a989	8a		txa				txa 								; get mask
.a98a	2d 41 06	and $0641			and 	EXTTextColour 				; mask out old.
.a98d	8d 41 06	sta $0641			sta 	EXTTextColour
.a990	68		pla				pla 								; or in new colour
.a991	0d 41 06	ora $0641			ora 	EXTTextColour
.a994	8d 41 06	sta $0641			sta 	EXTTextColour
.a997	60		rts				rts
.a998					_EXPCBackground:
.a998	29 0f		and #$0f			and 	#$0F 						; get the colour
.a99a	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a99c	80 ea		bra $a988			bra 	_EXPCUpdate
.a99e					EXTScreenScroll:
.a99e	a9 02		lda #$02			lda 	#2 							; select text page
.a9a0	85 01		sta $01				sta 	1
.a9a2	a9 20		lda #$20			lda		#32 						; fill with space
.a9a4	20 b3 aa	jsr $aab3			jsr 	EXTScrollFill
.a9a7	e6 01		inc $01				inc 	1 							; select colour page
.a9a9	ad 41 06	lda $0641			lda 	EXTTextColour
.a9ac	20 b3 aa	jsr $aab3			jsr 	EXTScrollFill
.a9af	60		rts				rts
.a9b0					EXTClearScreenCode:
.a9b0	a9 02		lda #$02			lda 	#2 							; select text page
.a9b2	85 01		sta $01				sta 	1
.a9b4	a9 20		lda #$20			lda		#32 						; fill with space
.a9b6	20 c3 a9	jsr $a9c3			jsr 	_EXTCSFill
.a9b9	e6 01		inc $01				inc 	1 							; select colour page
.a9bb	ad 41 06	lda $0641			lda 	EXTTextColour
.a9be	20 c3 a9	jsr $a9c3			jsr 	_EXTCSFill
.a9c1	80 22		bra $a9e5			bra 	EXTHomeCursor
.a9c3					_EXTCSFill:
.a9c3	aa		tax				tax
.a9c4	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a9c6	85 40		sta $40				sta 	EXTAddress
.a9c8	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9ca	85 41		sta $41				sta 	EXTAddress+1
.a9cc					_EXTCSFill1:
.a9cc	a0 00		ldy #$00			ldy 	#0
.a9ce	8a		txa				txa
.a9cf					_EXTCSFill2:
.a9cf	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9d1	c8		iny				iny
.a9d2	d0 fb		bne $a9cf			bne 	_EXTCSFill2
.a9d4	e6 41		inc $41				inc 	EXTAddress+1
.a9d6	a5 41		lda $41				lda 	EXTAddress+1
.a9d8	c9 d2		cmp #$d2			cmp 	#$D2
.a9da	d0 f0		bne $a9cc			bne 	_EXTCSFill1
.a9dc	8a		txa				txa
.a9dd					_EXTCSFill3:
.a9dd	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9df	c8		iny				iny
.a9e0	c0 c0		cpy #$c0			cpy 	#$C0
.a9e2	d0 f9		bne $a9dd			bne 	_EXTCSFill3
.a9e4	60		rts				rts
.a9e5					EXTHomeCursor:
.a9e5	9c 3f 06	stz $063f			stz 	EXTRow 						; reset row & column
.a9e8	9c 40 06	stz $0640			stz 	EXTColumn
.a9eb	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a9ed	85 40		sta $40				sta 	EXTAddress
.a9ef	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9f1	85 41		sta $41				sta 	EXTAddress+1
.a9f3					EXTSetHardwareCursor:
.a9f3	64 01		stz $01				stz 	1 							; I/O Page zero
.a9f5	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a9f7	8d 10 d0	sta $d010			sta 	$D010
.a9fa	a9 b1		lda #$b1			lda 	#$B1
.a9fc	8d 12 d0	sta $d012			sta 	$D012
.a9ff	ad 40 06	lda $0640			lda 	EXTColumn
.aa02	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.aa05	9c 15 d0	stz $d015			stz 	$D015
.aa08	ad 3f 06	lda $063f			lda 	EXTRow
.aa0b	8d 16 d0	sta $d016			sta 	$D016
.aa0e	9c 17 d0	stz $d017			stz 	$D017
.aa11	60		rts				rts
.aa12					EXTInputLine:
.aa12	48		pha				pha
.aa13	da		phx				phx
.aa14	5a		phy				phy
.aa15	a5 01		lda $01				lda 	1 							; save I/O page
.aa17	48		pha				pha
.aa18					_EILLoop:
.aa18	20 1a ab	jsr $ab1a			jsr 	ExtInputSingleCharacter
.aa1b	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.aa1d	f0 40		beq $aa5f			beq 	_EILExit
.aa1f	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.aa21	f0 1c		beq $aa3f			beq 	_EILBackspace
.aa23	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.aa25	90 12		bcc $aa39			bcc 	_EILPrintLoop
.aa27	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.aa29	b0 0e		bcs $aa39			bcs 	_EILPrintLoop
.aa2b	48		pha				pha 								; save character
.aa2c	a9 02		lda #$02			lda 	#2  						; insert a space
.aa2e	85 01		sta $01				sta 	1
.aa30	20 a1 aa	jsr $aaa1			jsr 	EXTILInsert 				; insert in text screen
.aa33	e6 01		inc $01				inc 	1
.aa35	20 a1 aa	jsr $aaa1			jsr 	EXTILInsert 				; insert in colour screen
.aa38	68		pla				pla 								; get character back.
.aa39					_EILPrintLoop:
.aa39	20 84 a8	jsr $a884			jsr 	ExtPrintCharacter
.aa3c	80 da		bra $aa18			bra 	_EILLoop
.aa3e	60		rts				rts
.aa3f					_EILBackspace:
.aa3f	ad 40 06	lda $0640			lda 	EXTColumn					; can we backspace ?
.aa42	f0 d4		beq $aa18			beq 	_EILLoop
.aa44	a9 02		lda #$02			lda 	#2 							; move cursor left
.aa46	20 84 a8	jsr $a884			jsr 	EXTPrintCharacter
.aa49	a9 02		lda #$02			lda 	#2 							; text block
.aa4b	85 01		sta $01				sta 	1
.aa4d	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.aa4f	20 8c aa	jsr $aa8c			jsr 	EXTILDelete
.aa52	e6 01		inc $01				inc 	1 							; colour block
.aa54	ac 40 06	ldy $0640			ldy 	EXTColumn 					; get attribute of last character
.aa57	88		dey				dey
.aa58	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa5a	20 8c aa	jsr $aa8c			jsr 	EXTILDelete 				; backspace attribute
.aa5d	80 b9		bra $aa18			bra 	_EILLoop 					; and go round.
.aa5f					_EILExit:
.aa5f	a9 02		lda #$02			lda 	#2 							; switch to page 2
.aa61	85 01		sta $01				sta 	1
.aa63	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa65					_EILScrapeLine:
.aa65	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa67	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa6a	c8		iny				iny
.aa6b	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aa6e	d0 f5		bne $aa65			bne 	_EILScrapeLine
.aa70					_EILTrimSpaces:
.aa70	88		dey				dey
.aa71	f0 08		beq $aa7b			beq 	_EILEndTrim
.aa73	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y
.aa76	c9 20		cmp #$20			cmp 	#' '
.aa78	f0 f6		beq $aa70			beq 	_EILTrimSpaces
.aa7a	c8		iny				iny 								; trim after non space character.
.aa7b					_EILEndTrim:
.aa7b	a9 00		lda #$00			lda 	#0 							; trim here.
.aa7d	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa80	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa82	20 84 a8	jsr $a884			jsr 	ExtPrintCharacter
.aa85	68		pla				pla 								; reset I/O page
.aa86	85 01		sta $01				sta 	1
.aa88	7a		ply				ply
.aa89	fa		plx				plx
.aa8a	68		pla				pla
.aa8b	60		rts				rts
.aa8c					EXTILDelete:
.aa8c	48		pha				pha 								; save the new character
.aa8d	ac 40 06	ldy $0640			ldy 	EXTColumn 					; start copying from here.
.aa90					_EXTDLoop:
.aa90	c8		iny				iny 								; copy one byte down.
.aa91	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa93	88		dey				dey
.aa94	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa96	c8		iny				iny 								; do till end of line.
.aa97	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aa9a	90 f4		bcc $aa90			bcc 	_EXTDLoop
.aa9c	88		dey				dey 	 							; write in last slot.
.aa9d	68		pla				pla
.aa9e	91 40		sta ($40),y			sta 	(EXTAddress),y
.aaa0	60		rts				rts
.aaa1					EXTILInsert:
.aaa1	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; end position
.aaa4					_EXTILoop:
.aaa4	88		dey				dey 								; back one
.aaa5	cc 40 06	cpy $0640			cpy 	EXTColumn 					; exit if reached insert point.
.aaa8	f0 08		beq $aab2			beq 	_EXTIExit
.aaaa	88		dey				dey 								; copy one byte up.
.aaab	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aaad	c8		iny				iny
.aaae	91 40		sta ($40),y			sta 	(EXTAddress),y
.aab0	80 f2		bra $aaa4			bra 	_EXTILoop
.aab2					_EXTIExit:
.aab2	60		rts				rts
.aab3					EXTScrollFill:
.aab3	aa		tax				tax									; save value to fill with
.aab4	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aab6	48		pha				pha
.aab7	a5 37		lda $37				lda 	zTemp0+1
.aab9	48		pha				pha
.aaba	a5 38		lda $38				lda 	zTemp1
.aabc	48		pha				pha
.aabd	a5 39		lda $39				lda 	zTemp1+1
.aabf	48		pha				pha
.aac0	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aac2	85 37		sta $37				sta 	zTemp0+1
.aac4	85 39		sta $39				sta 	zTemp1+1
.aac6	64 36		stz $36				stz 	zTemp0
.aac8	ad 42 06	lda $0642			lda 	EXTScreenWidth
.aacb	85 38		sta $38				sta 	zTemp1
.aacd	a0 00		ldy #$00			ldy 	#0
.aacf					_EXSFCopy1:
.aacf	b1 38		lda ($38),y			lda 	(zTemp1),y
.aad1	91 36		sta ($36),y			sta 	(zTemp0),y
.aad3	c8		iny				iny
.aad4	d0 f9		bne $aacf			bne 	_EXSFCopy1
.aad6	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aad8	e6 39		inc $39				inc 	zTemp1+1
.aada	a5 39		lda $39				lda 	zTemp1+1
.aadc	c9 d3		cmp #$d3			cmp 	#$D3
.aade	d0 ef		bne $aacf			bne 	_EXSFCopy1
.aae0	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; blank the bottom line.
.aae3	8a		txa				txa
.aae4					_EXSFFill1:
.aae4	88		dey				dey
.aae5	91 40		sta ($40),y			sta 	(EXTAddress),y
.aae7	c0 00		cpy #$00			cpy 	#0
.aae9	10 f9		bpl $aae4			bpl 	_EXSFFill1
.aaeb	68		pla				pla
.aaec	85 39		sta $39				sta 	zTemp1+1
.aaee	68		pla				pla
.aaef	85 38		sta $38				sta 	zTemp1
.aaf1	68		pla				pla
.aaf2	85 37		sta $37				sta 	zTemp0+1
.aaf4	68		pla				pla
.aaf5	85 36		sta $36				sta 	zTemp0
.aaf7	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063f					EXTRow:
>063f							.fill 	1
.0640					EXTColumn:
>0640							.fill 	1
.0641					EXTTextColour:
>0641							.fill 	1
.0642					EXTScreenWidth:
>0642							.fill 	1
.0643					EXTScreenHeight:
>0643							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aaf8					EXTInitialise:
.aaf8	64 01		stz $01				stz 	1 							; Access I/O
.aafa	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aafd	9c 08 d0	stz $d008			stz 	$D008
.ab00	9c 09 d0	stz $d009			stz 	$D009
.ab03	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.ab05	8d 58 d6	sta $d658			sta 	$D658
.ab08	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.ab0a	8d 41 06	sta $0641			sta 	EXTTextColour
.ab0d	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.ab0f	8d 42 06	sta $0642			sta 	EXTScreenWidth
.ab12	a9 3c		lda #$3c			lda 	#60
.ab14	8d 43 06	sta $0643			sta 	EXTScreenHeight
.ab17	64 01		stz $01				stz 	1
.ab19	60		rts				rts
.ab1a					EXTInputSingleCharacter:
.ab1a	da		phx				phx
.ab1b	5a		phy				phy
.ab1c					_EISCWait:
.ab1c	64 01		stz $01				stz 	1 							; access I/O Page 0
.ab1e	38		sec				sec 								; calculate timer - LastTick
.ab1f	ad 59 d6	lda $d659			lda 	$D659
.ab22	aa		tax				tax 								; saving timer in X
.ab23	ed 2e 06	sbc $062e			sbc 	LastTick
.ab26	c9 03		cmp #$03			cmp 	#3
.ab28	90 06		bcc $ab30			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.ab2a	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.ab2d	20 9f ba	jsr $ba9f			jsr 	TickHandler 				; go do the code.
.ab30					_NoFireTick:
.ab30	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.ab33	c9 00		cmp #$00			cmp 	#0
.ab35	f0 e5		beq $ab1c			beq 	_EISCWait
.ab37	7a		ply				ply
.ab38	fa		plx				plx
.ab39	60		rts				rts
.ab3a					EXTBreakCheck:
.ab3a	4c e1 ff	jmp $ffe1			jmp		$FFE1
.ab3d					EXTReadController:
.ab3d	da		phx				phx
.ab3e	a2 00		ldx #$00			ldx 	#0
.ab40	a9 05		lda #$05			lda 	#(($2D) >> 3)
.ab42	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab45	29 20		and #$20			and 	#($01 << (($2D) & 7))
.ab47	f0 04		beq $ab4d			beq 	_NoSet1
.ab49	8a		txa				txa
.ab4a	09 01		ora #$01			ora 	#1
.ab4c	aa		tax				tax
.ab4d					_NoSet1:
.ab4d	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab4f	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab52	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab54	f0 04		beq $ab5a			beq 	_NoSet1
.ab56	8a		txa				txa
.ab57	09 02		ora #$02			ora 	#2
.ab59	aa		tax				tax
.ab5a					_NoSet1:
.ab5a	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab5c	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab5f	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab61	f0 04		beq $ab67			beq 	_NoSet1
.ab63	8a		txa				txa
.ab64	09 04		ora #$04			ora 	#4
.ab66	aa		tax				tax
.ab67					_NoSet1:
.ab67	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab69	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab6c	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab6e	f0 04		beq $ab74			beq 	_NoSet1
.ab70	8a		txa				txa
.ab71	09 08		ora #$08			ora 	#8
.ab73	aa		tax				tax
.ab74					_NoSet1:
.ab74	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab76	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab79	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab7b	f0 04		beq $ab81			beq 	_NoSet1
.ab7d	8a		txa				txa
.ab7e	09 10		ora #$10			ora 	#16
.ab80	aa		tax				tax
.ab81					_NoSet1:
.ab81	8a		txa				txa
.ab82	fa		plx				plx
.ab83	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.baa5					GRVectorTable:
>baa5	7f ad					.word	GXInitialise             ; $00 Initialise
>baa7	99 ad					.word	GXControlBitmap          ; $01 BitmapCtl
>baa9	e1 ad					.word	GXControlSprite          ; $02 SpriteCtl
>baab	31 ad					.word	GXClearBitmap            ; $03 Clear
>baad	70 af					.word	GXSetColourMode          ; $04 Colour
>baaf	38 b1					.word	GXFontHandler            ; $05 DrawFont
>bab1	80 b1					.word	GXSpriteHandler          ; $06 DrawSprite
>bab3	ec b1					.word	GXSelect                 ; $07 SpriteUse
>bab5	15 b2					.word	GXSelectImage            ; $08 SpriteImage
>bab7	9c b3					.word	GXCollide                ; $09 SpriteCollide
>bab9	e3 ab					.word	GRUndefined              ; $0a
>babb	e3 ab					.word	GRUndefined              ; $0b
>babd	e3 ab					.word	GRUndefined              ; $0c
>babf	e3 ab					.word	GRUndefined              ; $0d
>bac1	e3 ab					.word	GRUndefined              ; $0e
>bac3	e3 ab					.word	GRUndefined              ; $0f
>bac5	e3 ab					.word	GRUndefined              ; $10
>bac7	e3 ab					.word	GRUndefined              ; $11
>bac9	e3 ab					.word	GRUndefined              ; $12
>bacb	e3 ab					.word	GRUndefined              ; $13
>bacd	e3 ab					.word	GRUndefined              ; $14
>bacf	e3 ab					.word	GRUndefined              ; $15
>bad1	e3 ab					.word	GRUndefined              ; $16
>bad3	e3 ab					.word	GRUndefined              ; $17
>bad5	e3 ab					.word	GRUndefined              ; $18
>bad7	e3 ab					.word	GRUndefined              ; $19
>bad9	e3 ab					.word	GRUndefined              ; $1a
>badb	e3 ab					.word	GRUndefined              ; $1b
>badd	e3 ab					.word	GRUndefined              ; $1c
>badf	e3 ab					.word	GRUndefined              ; $1d
>bae1	e3 ab					.word	GRUndefined              ; $1e
>bae3	e3 ab					.word	GRUndefined              ; $1f
>bae5	e1 ab					.word	GXMove                   ; $20 Move
>bae7	3e ae					.word	GXLine                   ; $21 Line
>bae9	b9 af					.word	GXFrameRectangle         ; $22 FrameRect
>baeb	b6 af					.word	GXFillRectangle          ; $23 FillRect
>baed	e8 ab					.word	GXFrameCircle            ; $24 FrameCircle
>baef	e4 ab					.word	GXFillCircle             ; $25 FillCircle
>baf1	e3 ab					.word	GRUndefined              ; $26
>baf3	e3 ab					.word	GRUndefined              ; $27
>baf5	9e af					.word	GXPlotPoint              ; $28 Plot
>baf7	ab b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5fa					gxPixelBuffer = numberBuffer
.0644					gxCurrentX:
>0644							.fill 	2
.0646					gxCurrentY:
>0646							.fill 	2
.0648					gxLastX:
>0648							.fill 	2
.064a					gxLastY:
>064a							.fill 	2
.064c					gxX0:
>064c							.fill 	2
.064e					gxY0:
>064e							.fill 	2
.0650					gxX1:
>0650							.fill 	2
.0652					gxY1:
>0652							.fill 	2
.0654					gxSpritesOn:
>0654							.fill 	1
.0655					gxBitmapsOn:
>0655							.fill 	1
.0656					gxBasePage:
>0656							.fill 	1
.0657					gxSpritePage:
>0657							.fill 	1
.0658					gxHeight:
>0658							.fill 	1
.0659					gxMode:
>0659							.fill 	1
.065a					gxColour:
>065a							.fill 	1
.065b					gxEORValue:
>065b							.fill 	1
.065c					gxANDValue:
>065c							.fill 	1
.065d					gxOriginalLUTValue:
>065d							.fill 	1
.065e					gsOffset:
>065e							.fill 	1
.065f					GSCurrentSpriteID:
>065f							.fill 	1
.0660					GSCurrentSpriteAddr:
>0660							.fill 	2
.0662					GXSpriteOffsetBase:
>0662							.fill 	2
.0664					GXSpriteLow:
>0664							.fill 	64
.06a4					GXSpriteHigh:
>06a4							.fill 	64
.ab84					GXGraphicDraw:
.ab84	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab86	b0 06		bcs $ab8e			bcs 	_GDCoordinate
.ab88	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab8a	84 37		sty $37				sty 	gxzTemp0+1
.ab8c	80 4b		bra $abd9			bra 	_GDExecuteA 				; and execute
.ab8e					_GDCoordinate:
.ab8e	48		pha				pha 								; save AXY
.ab8f	da		phx				phx
.ab90	5a		phy				phy
.ab91	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab93					_GDCopy1:
.ab93	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.ab96	9d 48 06	sta $0648,x			sta 	gxLastX,x
.ab99	ca		dex				dex
.ab9a	10 f7		bpl $ab93			bpl 	_GDCopy1
.ab9c	68		pla				pla 								; update Y
.ab9d	8d 46 06	sta $0646			sta 	gxCurrentY
.aba0	9c 47 06	stz $0647			stz 	gxCurrentY+1
.aba3	68		pla				pla
.aba4	8d 44 06	sta $0644			sta 	gxCurrentX
.aba7	68		pla				pla 								; get A (command+X.1) back
.aba8	48		pha				pha
.aba9	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.abab	8d 45 06	sta $0645			sta 	gxCurrentX+1
.abae	68		pla				pla 								; get command back
.abaf	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abb1	48		pha				pha 								; push back.
.abb2	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abb4	f0 17		beq $abcd			beq 	_GDCopyToWorkArea
.abb6	ad 45 06	lda $0645			lda 	gxCurrentX+1 				; X < 256 X okay
.abb9	f0 07		beq $abc2			beq 	_GDCheckY
.abbb	ad 44 06	lda $0644			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abbe	c9 40		cmp #$40			cmp 	#64
.abc0	b0 08		bcs $abca			bcs 	_GDError1
.abc2					_GDCheckY:
.abc2	ad 46 06	lda $0646			lda 	gxCurrentY 					; check Y < Height.
.abc5	cd 58 06	cmp $0658			cmp 	gxHeight
.abc8	90 03		bcc $abcd			bcc 	_GDCopyToWorkArea
.abca					_GDError1:
.abca	68		pla				pla
.abcb					_GDError2:
.abcb	38		sec				sec
.abcc	60		rts				rts
.abcd					_GDCopyToWorkArea:
.abcd	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abcf					_GDCopy2:
.abcf	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.abd2	9d 4c 06	sta $064c,x			sta 	gxX0,x
.abd5	ca		dex				dex
.abd6	10 f7		bpl $abcf			bpl 	_GDCopy2
.abd8	68		pla				pla 								; get command
.abd9					_GDExecuteA:
.abd9	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abdb	b0 ee		bcs $abcb			bcs 	_GDError2
.abdd	aa		tax				tax
.abde	7c a5 ba	jmp ($baa5,x)			jmp 	(GRVectorTable,x)
.abe1					GXMove:
.abe1	18		clc				clc
.abe2	60		rts				rts
.abe3					GRUndefined:
>abe3	db						.byte 	$DB 						; causes a break in the emulator
.abe4					GXFillCircle:
.abe4	a9 ff		lda #$ff			lda 	#255
.abe6	80 02		bra $abea			bra 	GXCircle
.abe8					GXFrameCircle:
.abe8	a9 00		lda #$00			lda 	#0
.abea					GXCircle:
.abea	8d e7 06	sta $06e7			sta 	gxIsFillMode					; save Fill flag
.abed	ad 55 06	lda $0655			lda 	gxBitmapsOn
.abf0	f0 26		beq $ac18			beq 	_GXCFail
.abf2	20 43 b4	jsr $b443			jsr 	GXSortXY 					; topleft/bottomright
.abf5	20 1b b3	jsr $b31b			jsr 	GXOpenBitmap 				; start drawing
.abf8	20 ea ac	jsr $acea			jsr 	GXCircleSetup 				; set up for drawing
.abfb	9c e8 06	stz $06e8			stz 	gxYChanged
.abfe					_GXCircleDraw:
.abfe	ad e5 06	lda $06e5			lda 	gXCentre					; while x <= y
.ac01	cd e6 06	cmp $06e6			cmp 	gYCentre
.ac04	90 0a		bcc $ac10			bcc 	_GXCircleContinue
.ac06	d0 03		bne $ac0b			bne 	_GXNoLast
.ac08	20 1d ac	jsr $ac1d			jsr 	GXPlot1
.ac0b					_GXNoLast:
.ac0b	20 23 b3	jsr $b323			jsr 	GXCloseBitmap 				; close the bitmap
.ac0e	18		clc				clc
.ac0f	60		rts				rts
.ac10					_GXCircleContinue:
.ac10	20 1a ac	jsr $ac1a			jsr 	GXPlot2 					; draw it
.ac13	20 97 ac	jsr $ac97			jsr 	GXCircleMove 				; adjust the coordinates
.ac16	80 e6		bra $abfe			bra 	_GXCircleDraw
.ac18					_GXCFail:
.ac18	38		sec				sec
.ac19	60		rts				rts
.ac1a					GXPlot2:
.ac1a	20 1d ac	jsr $ac1d			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac1d					GXPlot1:
.ac1d	ad e6 06	lda $06e6			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac20	f0 03		beq $ac25			beq 	_GXPlot1Only
.ac22	20 41 ac	jsr $ac41			jsr 	GXPlot0 						; plot and negate
.ac25					_GXPlot1Only:
.ac25	20 41 ac	jsr $ac41			jsr 	GXPlot0 						; twice, undoing negation
.ac28	ad e5 06	lda $06e5			lda 	gXCentre 						; swap X and Y
.ac2b	ae e6 06	ldx $06e6			ldx	 	gYCentre
.ac2e	8d e6 06	sta $06e6			sta 	gYCentre
.ac31	8e e5 06	stx $06e5			stx 	gXCentre
.ac34	ad e8 06	lda $06e8			lda 	gxYChanged 						; toggle Y Changed flag
.ac37	a9 ff		lda #$ff			lda 	#$FF
.ac39	8d e8 06	sta $06e8			sta 	gxYChanged
.ac3c	60		rts				rts
.ac3d	20 41 ac	jsr $ac41			jsr 	GXPlot0 						; do once
.ac40	60		rts				rts
.ac41	ad e7 06	lda $06e7	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac44	f0 05		beq $ac4b			beq 	_GXPlot0Always
.ac46	ad e8 06	lda $06e8			lda 	gxYChanged						; fill mode, only draw if changed.
.ac49	f0 2d		beq $ac78			beq 	GXPlot0Exit
.ac4b					_GXPlot0Always:
.ac4b	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac4d	ad e6 06	lda $06e6			lda 	gYCentre
.ac50	20 79 ac	jsr $ac79			jsr 	GXSubCopy
.ac53	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac55	ad e5 06	lda $06e5			lda 	gXCentre
.ac58	20 79 ac	jsr $ac79			jsr 	GXSubCopy
.ac5b	48		pha				pha 									; save last offset X
.ac5c	20 2b b3	jsr $b32b			jsr 	GXPositionCalc 					; calculate position/offset.
.ac5f	68		pla				pla
.ac60	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac61	85 36		sta $36				sta 	gxzTemp0
.ac63	64 37		stz $37				stz 	gxzTemp0+1
.ac65	26 37		rol $37				rol 	gxzTemp0+1
.ac67	ad e7 06	lda $06e7			lda 	gxIsFillMode
.ac6a	69 80		adc #$80			adc 	#128
.ac6c	20 09 b0	jsr $b009			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac6f	38		sec				sec 									; GY = -GY
.ac70	a9 00		lda #$00			lda 	#0
.ac72	ed e6 06	sbc $06e6			sbc 	gYCentre
.ac75	8d e6 06	sta $06e6			sta 	gYCentre
.ac78					GXPlot0Exit:
.ac78	60		rts				rts
.ac79					GXSubCopy:
.ac79	85 36		sta $36				sta 	gxzTemp0
.ac7b	64 37		stz $37				stz 	gxzTemp0+1
.ac7d	29 80		and #$80			and 	#$80
.ac7f	f0 02		beq $ac83			beq 	_GXNoSx
.ac81	c6 37		dec $37				dec 	gxzTemp0+1
.ac83					_GXNoSx:
.ac83	38		sec				sec
.ac84	bd 50 06	lda $0650,x			lda 	gXX1,x
.ac87	e5 36		sbc $36				sbc 	gxzTemp0
.ac89	9d 4c 06	sta $064c,x			sta 	gXX0,x
.ac8c	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ac8f	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac91	9d 4d 06	sta $064d,x			sta 	gXX0+1,x
.ac94	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ac96	60		rts				rts
.ac97					GXCircleMove:
.ac97	9c e8 06	stz $06e8			stz 	gxYChanged 					; clear Y changed flag
.ac9a	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.ac9c	10 0d		bpl $acab			bpl 	_GXEMPositive
.ac9e	ee e5 06	inc $06e5			inc 	gXCentre 					; X++
.aca1	ad e5 06	lda $06e5			lda 	gXCentre
.aca4	20 ca ac	jsr $acca			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.aca7	a9 06		lda #$06			lda 	#6  						; and add 6
.aca9	80 15		bra $acc0			bra 	_GXEMAddD
.acab					_GXEMPositive:
.acab	ee e5 06	inc $06e5			inc 	gXCentre					; X++
.acae	ce e6 06	dec $06e6			dec 	gyCentre 					; Y--
.acb1	38		sec				sec 								; calculate X-Y
.acb2	ad e5 06	lda $06e5			lda 	gXCentre
.acb5	ed e6 06	sbc $06e6			sbc 	gYCentre
.acb8	20 ca ac	jsr $acca			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acbb	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acbd	ce e8 06	dec $06e8			dec 	gxYChanged
.acc0					_GXEMAddD:
.acc0	18		clc				clc
.acc1	65 38		adc $38				adc 	gxzTemp1
.acc3	85 38		sta $38				sta 	gxzTemp1
.acc5	90 02		bcc $acc9			bcc 	_GXEMNoCarry
.acc7	e6 39		inc $39				inc 	gxzTemp1+1
.acc9					_GXEMNoCarry:
.acc9	60		rts				rts
.acca					_GXAdd4TimesToD:
.acca	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.accc	29 80		and #$80			and 	#$80
.acce	f0 02		beq $acd2			beq 	_GXA4Unsigned
.acd0	a9 ff		lda #$ff			lda 	#$FF
.acd2					_GXA4Unsigned:
.acd2	85 37		sta $37				sta 	gxzTemp0+1
.acd4	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acd6	26 37		rol $37				rol 	gxzTemp0+1
.acd8	06 36		asl $36				asl 	gxzTemp0
.acda	26 37		rol $37				rol 	gxzTemp0+1
.acdc	18		clc				clc 								; add
.acdd	a5 36		lda $36				lda		gxzTemp0
.acdf	65 38		adc $38				adc 	gxzTemp1
.ace1	85 38		sta $38				sta 	gxzTemp1
.ace3	a5 37		lda $37				lda		gxzTemp0+1
.ace5	65 39		adc $39				adc 	gxzTemp1+1
.ace7	85 39		sta $39				sta 	gxzTemp1+1
.ace9	60		rts				rts
.acea					GXCircleSetup:
.acea	38		sec				sec
.aceb	ad 52 06	lda $0652			lda 	gxY1
.acee	ed 4e 06	sbc $064e			sbc 	gxY0
.acf1	4a		lsr a				lsr 	a
.acf2	8d e4 06	sta $06e4			sta 	gxRadius
.acf5	a2 00		ldx #$00			ldx 	#0
.acf7	20 19 ad	jsr $ad19			jsr 	_GXCalculateCentre
.acfa	a2 02		ldx #$02			ldx 	#2
.acfc	20 19 ad	jsr $ad19			jsr 	_GXCalculateCentre
.acff	9c e5 06	stz $06e5			stz 	gXCentre
.ad02	ad e4 06	lda $06e4			lda 	gxRadius
.ad05	8d e6 06	sta $06e6			sta 	gYCentre
.ad08	0a		asl a				asl 	a 							; R x 2
.ad09	85 36		sta $36				sta 	gxzTemp0
.ad0b	38		sec				sec
.ad0c	a9 03		lda #$03			lda 	#3
.ad0e	e5 36		sbc $36				sbc 	gxzTemp0
.ad10	85 38		sta $38				sta 	gxzTemp1
.ad12	a9 00		lda #$00			lda 	#0
.ad14	e9 00		sbc #$00			sbc 	#0
.ad16	85 39		sta $39				sta 	gxzTemp1+1
.ad18	60		rts				rts
.ad19					_GXCalculateCentre:
.ad19	38		sec				sec
.ad1a	bd 50 06	lda $0650,x			lda 	gxX1,x
.ad1d	7d 4c 06	adc $064c,x			adc 	gXX0,x
.ad20	9d 50 06	sta $0650,x			sta 	gXX1,x
.ad23	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ad26	7d 4d 06	adc $064d,x			adc 	gXX0+1,x
.ad29	4a		lsr a				lsr 	a
.ad2a	9d 51 06	sta $0651,x			sta 	gXX1+1,x
.ad2d	7e 50 06	ror $0650,x			ror 	gXX1,x
.ad30	60		rts				rts
.06e4					gxRadius:
>06e4							.fill 	1
.06e5					gXCentre:
>06e5							.fill 	1
.06e6					gYCentre:
>06e6							.fill 	1
.06e7					gxIsFillMode:
>06e7							.fill 	1
.06e8					gxYChanged:
>06e8							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad31					GXClearBitmap:
.ad31	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP running.
.ad34	f0 24		beq $ad5a			beq 	_GXCBFail
.ad36	20 1b b3	jsr $b31b			jsr 	GXOpenBitmap 				; start access
.ad39	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad3b	ad 58 06	lda $0658			lda 	gxHeight
.ad3e	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad40	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad42					_GXCalcLastPage:
.ad42	98		tya				tya 								; add to base page
.ad43	18		clc				clc
.ad44	6d 56 06	adc $0656			adc 	gxBasePage
.ad47	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad49					_GXClearAll:
.ad49	20 5c ad	jsr $ad5c			jsr 	_GXClearBlock 				; clear 8k block
.ad4c	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad4e	a5 0b		lda $0b				lda 	GXEditSlot
.ad50	cd 56 06	cmp $0656			cmp 	gxBasePage 					; until before base page
.ad53	b0 f4		bcs $ad49			bcs 	_GXClearAll
.ad55	20 23 b3	jsr $b323			jsr 	GXCloseBitmap	 			; stop access
.ad58	18		clc				clc
.ad59	60		rts				rts
.ad5a					_GXCBFail:
.ad5a	38		sec				sec
.ad5b	60		rts				rts
.ad5c					_GXClearBlock:
.ad5c	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad5e	85 38		sta $38				sta 	0+gxzTemp1
.ad60	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad62	85 39		sta $39				sta 	1+gxzTemp1
.ad64					_GXCB0:
.ad64	a5 36		lda $36				lda 	gxzTemp0
.ad66	a0 00		ldy #$00			ldy 	#0
.ad68					_GXCB1:
.ad68	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad6a	c8		iny				iny
.ad6b	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad6d	c8		iny				iny
.ad6e	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad70	c8		iny				iny
.ad71	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad73	c8		iny				iny
.ad74	d0 f2		bne $ad68			bne 	_GXCB1
.ad76	e6 39		inc $39				inc 	gxzTemp1+1
.ad78	a5 39		lda $39				lda 	gxzTemp1+1
.ad7a	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad7c	d0 e6		bne $ad64			bne 	_GXCB0
.ad7e	60		rts				rts
.ad7f					GXInitialise:
.ad7f	64 01		stz $01				stz 	1
.ad81	a9 01		lda #$01			lda 	#1
.ad83	8d 00 d0	sta $d000			sta 	$D000
.ad86	18		clc				clc
.ad87	9c 54 06	stz $0654			stz 	GXSpritesOn
.ad8a	9c 55 06	stz $0655			stz 	GXBitmapsOn
.ad8d	a2 0f		ldx #$0f			ldx 	#15
.ad8f					_GXIClear:
.ad8f	9e 44 06	stz $0644,x			stz 	gxCurrentX,x
.ad92	ca		dex				dex
.ad93	10 fa		bpl $ad8f			bpl 	_GXIClear
.ad95	20 30 ae	jsr $ae30			jsr 	GXClearSpriteStore
.ad98	60		rts				rts
.ad99					GXControlBitmap:
.ad99	64 01		stz $01				stz 	1
.ad9b	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad9d	29 01		and #$01			and 	#1 							; set bitmap flag
.ad9f	8d 55 06	sta $0655			sta 	gxBitmapsOn
.ada2	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ada3	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ada6	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ada8	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.adaa	90 02		bcc $adae			bcc 	_CBNotOn
.adac	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.adae					_CBNotOn:
.adae	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adb1	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.adb3	29 07		and #$07			and 	#7
.adb5	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adb8	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adba	d0 02		bne $adbe			bne 	_CBNotDefault
.adbc	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adbe					_CBNotDefault:
.adbe	8d 56 06	sta $0656			sta 	gxBasePage
.adc1	20 22 ae	jsr $ae22			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adc4	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.adc6	8d 03 d1	sta $d103			sta 	$D103
.adc9	a5 36		lda $36				lda 	gxzTemp0
.adcb	8d 02 d1	sta $d102			sta 	$D102
.adce	9c 01 d1	stz $d101			stz 	$D101
.add1	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.add3	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.add6	29 01		and #$01			and 	#1
.add8	f0 02		beq $addc			beq 	_CBHaveHeight
.adda	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.addc					_CBHaveHeight
.addc	8e 58 06	stx $0658			stx 	gxHeight
.addf	18		clc				clc
.ade0	60		rts				rts
.ade1					GXControlSprite:
.ade1	64 01		stz $01				stz 	1
.ade3	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ade5	29 01		and #$01			and 	#1 							; set sprites flag
.ade7	8d 54 06	sta $0654			sta 	gxSpritesOn
.adea	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adeb	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adee	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adf0	29 df		and #$df			and 	#$DF 						; clear sprite bit
.adf2	90 02		bcc $adf6			bcc 	_CSNotOn
.adf4	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.adf6					_CSNotOn:
.adf6	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adf9	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adfb	d0 02		bne $adff			bne 	_CSNotDefault
.adfd	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.adff					_CSNotDefault:
.adff	8d 57 06	sta $0657			sta 	gxSpritePage
.ae02	20 22 ae	jsr $ae22			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae05	a5 36		lda $36				lda 	zTemp0
.ae07	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase
.ae0a	a5 37		lda $37				lda 	zTemp0+1
.ae0c	8d 63 06	sta $0663			sta 	GXSpriteOffsetBase+1
.ae0f	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae11					_CSClear:
.ae11	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae14	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae17	ca		dex				dex
.ae18	d0 f7		bne $ae11			bne 	_CSClear
.ae1a	9c 61 06	stz $0661			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae1d	20 30 ae	jsr $ae30			jsr 	GXClearSpriteStore
.ae20	18		clc				clc
.ae21	60		rts				rts
.ae22					GXCalculateBaseAddress:
.ae22	85 36		sta $36				sta 	gxzTemp0
.ae24	64 37		stz $37				stz 	gxzTemp0+1
.ae26	a9 05		lda #$05			lda 	#5
.ae28					_GXShift:
.ae28	06 36		asl $36				asl 	gxzTemp0
.ae2a	26 37		rol $37				rol 	gxzTemp0+1
.ae2c	3a		dec a				dec		a
.ae2d	d0 f9		bne $ae28			bne 	_GXShift
.ae2f	60		rts				rts
.ae30					GXClearSpriteStore:
.ae30	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae32					_GXCSSLoop:
.ae32	9e a4 06	stz $06a4,x			stz 	GXSpriteHigh,x
.ae35	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae37	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.ae3a	ca		dex				dex
.ae3b	10 f5		bpl $ae32			bpl 	_GXCSSLoop
.ae3d	60		rts				rts
.ae3e					GXLine:
.ae3e	ad 55 06	lda $0655			lda 	GXBitmapsOn
.ae41	f0 28		beq $ae6b			beq 	_GXLFail
.ae43	20 1b b3	jsr $b31b			jsr 	GXOpenBitmap
.ae46	20 61 b4	jsr $b461			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae49	20 11 af	jsr $af11			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae4c	20 2b b3	jsr $b32b			jsr 	GXPositionCalc 				; calculate position/offset.
.ae4f					_GXDrawLoop:
.ae4f	ac 5e 06	ldy $065e			ldy 	gsOffset 					; draw the pixel
.ae52	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae54	2d 5c 06	and $065c			and 	gxANDValue
.ae57	4d 5b 06	eor $065b			eor 	gxEORValue
.ae5a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae5c	20 6d ae	jsr $ae6d			jsr 	GXLineIsComplete 			; is the line complete ?
.ae5f	f0 05		beq $ae66			beq 	_GXLExit
.ae61	20 88 ae	jsr $ae88			jsr 	GXLineAdvance 				; code as per advance method
.ae64	80 e9		bra $ae4f			bra 	_GXDrawLoop
.ae66					_GXLExit:
.ae66	20 23 b3	jsr $b323			jsr 	GXCloseBitmap
.ae69	18		clc				clc
.ae6a	60		rts				rts
.ae6b					_GXLFail:
.ae6b	38		sec				sec
.ae6c	60		rts				rts
.ae6d					GXLineIsComplete:
.ae6d	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger 			; is dy larger
.ae70	d0 0f		bne $ae81			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae72	ad 4c 06	lda $064c			lda 	GXX0 						; compare X, LSB and MSB
.ae75	4d 50 06	eor $0650			eor 	GXX1
.ae78	d0 06		bne $ae80			bne 	_GXLICExit
.ae7a	ad 4d 06	lda $064d			lda 	GXX0+1
.ae7d	4d 51 06	eor $0651			eor 	GXX1+1
.ae80					_GXLICExit:
.ae80	60		rts				rts
.ae81					_GXLICCompareY:
.ae81	ad 52 06	lda $0652			lda 	GXY1
.ae84	4d 4e 06	eor $064e			eor 	GXY0
.ae87	60		rts				rts
.ae88					GXLineAdvance:
.ae88	18		clc				clc 								; add adjust to position
.ae89	ad ed 06	lda $06ed			lda 	GXPosition
.ae8c	6d ee 06	adc $06ee			adc 	GXAdjust
.ae8f	8d ed 06	sta $06ed			sta 	GXPosition
.ae92	9c f0 06	stz $06f0			stz 	GXAddSelect 				; clear add select flag
.ae95	b0 05		bcs $ae9c			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ae97	cd ef 06	cmp $06ef			cmp 	GXTotal 					; if exceeded total
.ae9a	90 0a		bcc $aea6			bcc 	_GXLANoExtra
.ae9c					_GXLAOverflow:
.ae9c	ce f0 06	dec $06f0			dec 	GXAddSelect 				; set addselect to $FF
.ae9f	38		sec				sec 								; subtract total and write back
.aea0	ed ef 06	sbc $06ef			sbc 	GXTotal
.aea3	8d ed 06	sta $06ed			sta 	GXPosition
.aea6					_GXLANoExtra:
.aea6	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger
.aea9	f0 0d		beq $aeb8			beq 	_GXDXLarger
.aeab	20 0a af	jsr $af0a			jsr 	GXIncrementY
.aeae	ad f0 06	lda $06f0			lda 	GXAddSelect
.aeb1	f0 10		beq $aec3			beq 	_GXLAExit
.aeb3	20 c4 ae	jsr $aec4			jsr 	GXAdjustX
.aeb6	80 0b		bra $aec3			bra 	_GXLAExit
.aeb8					_GXDXLarger:
.aeb8	20 c4 ae	jsr $aec4			jsr 	GXAdjustX
.aebb	ad f0 06	lda $06f0			lda 	GXAddSelect
.aebe	f0 03		beq $aec3			beq 	_GXLAExit
.aec0	20 0a af	jsr $af0a			jsr 	GXIncrementY
.aec3					_GXLAExit:
.aec3	60		rts				rts
.aec4					GXAdjustX:
.aec4	ad ec 06	lda $06ec			lda 	GXDXNegative
.aec7	10 25		bpl $aeee			bpl 	_GXAXRight
.aec9	ad 4c 06	lda $064c			lda 	GXX0
.aecc	d0 03		bne $aed1			bne 	_GXAXNoBorrow
.aece	ce 4d 06	dec $064d			dec 	GXX0+1
.aed1					_GXAXNoBorrow:
.aed1	ce 4c 06	dec $064c			dec 	GXX0
.aed4	ce 5e 06	dec $065e			dec 	gsOffset 					; pixel left
.aed7	ad 5e 06	lda $065e			lda 	gsOffset
.aeda	c9 ff		cmp #$ff			cmp 	#$FF
.aedc	d0 0f		bne $aeed			bne 	_GXAYExit 					; underflow
.aede	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aee0	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aee2	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aee4	b0 07		bcs $aeed			bcs 	_GXAYExit
.aee6	18		clc				clc
.aee7	69 20		adc #$20			adc 	#$20 						; fix up
.aee9	85 3d		sta $3d				sta 	gxzScreen+1
.aeeb	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aeed					_GXAYExit:
.aeed	60		rts				rts
.aeee					_GXAXRight:
.aeee	ee 4c 06	inc $064c			inc 	GXX0
.aef1	d0 03		bne $aef6			bne 	_GXAXNoCarry
.aef3	ee 4d 06	inc $064d			inc 	GXX0+1
.aef6					_GXAXNoCarry:
.aef6	ee 5e 06	inc $065e			inc 	gsOffset 					; pixel right
.aef9	d0 0e		bne $af09			bne 	_GXAXExit 					; if not overflowed, exit.
.aefb	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.aefd	a5 3d		lda $3d				lda 	gxzScreen+1
.aeff	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.af01	90 06		bcc $af09			bcc 	_GXAXExit
.af03	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af05	85 3d		sta $3d				sta 	gxzScreen+1
.af07	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af09					_GXAXExit:
.af09	60		rts				rts
.af0a					GXIncrementY:
.af0a	ee 4e 06	inc $064e			inc 	GXY0
.af0d	20 81 b3	jsr $b381			jsr 	GXMovePositionDown
.af10	60		rts				rts
.af11					GXLineSetup:
.af11	ad 52 06	lda $0652			lda 	GXY1
.af14	38		sec				sec
.af15	ed 4e 06	sbc $064e			sbc 	GXY0
.af18	4a		lsr a				lsr 	a
.af19	8d ea 06	sta $06ea			sta 	GXDiffY
.af1c	9c ec 06	stz $06ec			stz 	GXDXNegative 				; clear -ve flag
.af1f	38		sec				sec
.af20	ad 50 06	lda $0650			lda 	GXX1
.af23	ed 4c 06	sbc $064c			sbc 	GXX0
.af26	8d e9 06	sta $06e9			sta 	GXDiffX
.af29	ad 51 06	lda $0651			lda 	GXX1+1 						; calculate MSB
.af2c	ed 4d 06	sbc $064d			sbc 	GXX0+1
.af2f	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af30	6e e9 06	ror $06e9			ror 	GXDiffX
.af33	0a		asl a				asl 	a
.af34	10 0c		bpl $af42			bpl 	_GDXNotNegative
.af36	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af38	38		sec				sec
.af39	ed e9 06	sbc $06e9			sbc 	GXDiffX
.af3c	8d e9 06	sta $06e9			sta 	GXDiffX
.af3f	ce ec 06	dec $06ec			dec 	GXDXNegative 				; -ve flag = $FF.
.af42					_GDXNotNegative:
.af42	9c eb 06	stz $06eb			stz 	GXIsDiffYLarger 			; clear larger flag
.af45	ad ea 06	lda $06ea			lda 	GXDiffY 					; set adjust and total.
.af48	8d ee 06	sta $06ee			sta 	GXAdjust
.af4b	ad e9 06	lda $06e9			lda 	GXDiffX
.af4e	8d ef 06	sta $06ef			sta 	GXTotal
.af51	ad ea 06	lda $06ea			lda 	GXDiffY 					; if dy > dx
.af54	cd e9 06	cmp $06e9			cmp 	GXDiffX
.af57	90 0f		bcc $af68			bcc 	_GDXNotLarger
.af59	ce eb 06	dec $06eb			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af5c	ad e9 06	lda $06e9			lda 	GXDiffX 					; set adjust and total other way round
.af5f	8d ee 06	sta $06ee			sta 	GXAdjust
.af62	ad ea 06	lda $06ea			lda 	GXDiffY
.af65	8d ef 06	sta $06ef			sta 	GXTotal
.af68					_GDXNotLarger:
.af68	ad ef 06	lda $06ef			lda 	GXTotal
.af6b	4a		lsr a				lsr 	a
.af6c	8d ed 06	sta $06ed			sta 	GXPosition
.af6f	60		rts				rts
.06e9					GXDiffX:
>06e9							.fill 	1
.06ea					GXDiffY:
>06ea							.fill 	1
.06eb					GXIsDiffYLarger:
>06eb							.fill 	1
.06ec					GXDXNegative:
>06ec							.fill 	1
.06ed					GXPosition:
>06ed							.fill 	1
.06ee					GXAdjust:
>06ee							.fill 	1
.06ef					GXTotal:
>06ef							.fill 	1
.06f0					GXAddSelect:
>06f0							.fill 	1
.af70					GXSetColourMode:
.af70	a6 36		ldx $36				ldx 	gxzTemp0
.af72	8e 5a 06	stx $065a			stx 	gxColour 								; set colour
.af75	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af77	8d 59 06	sta $0659			sta 	gxMode 									; set mode
.af7a	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af7c	9c 5c 06	stz $065c			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af7f	ae 5a 06	ldx $065a			ldx 	gxColour
.af82	8e 5b 06	stx $065b			stx 	gxEORValue
.af85	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af87	90 03		bcc $af8c			bcc 	_GXSDCNotAndColour
.af89	8e 5c 06	stx $065c			stx 	gxANDValue
.af8c					_GXSDCNotAndColour:
.af8c	d0 03		bne $af91			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af8e	9c 5b 06	stz $065b			stz 	gxEORValue
.af91					_GXSDCNotAnd:
.af91	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af92	90 08		bcc $af9c			bcc 	_GXSDCNoFlip
.af94	ad 5c 06	lda $065c			lda	 	gxANDValue
.af97	49 ff		eor #$ff			eor 	#$FF
.af99	8d 5c 06	sta $065c			sta 	gxANDValue
.af9c					_GXSDCNoFlip:
.af9c	18		clc				clc
.af9d	60		rts				rts
.af9e					GXPlotPoint:
.af9e	20 1b b3	jsr $b31b			jsr 	GXOpenBitmap 				; start drawing
.afa1	20 2b b3	jsr $b32b			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afa4	ac 5e 06	ldy $065e			ldy 	gsOffset
.afa7	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afa9	2d 5c 06	and $065c			and 	gxANDValue
.afac	4d 5b 06	eor $065b			eor 	gxEORValue
.afaf	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afb1	20 23 b3	jsr $b323			jsr 	GXCloseBitmap 				; stop drawing and exit
.afb4	18		clc				clc
.afb5	60		rts				rts
.afb6					GXFillRectangle:
.afb6	38		sec				sec
.afb7	80 01		bra $afba			bra 	GXRectangle
.afb9					GXFrameRectangle:
.afb9	18		clc				clc
.afba					GXRectangle:
.afba	ad 55 06	lda $0655			lda 	gxBitmapsOn
.afbd	f0 35		beq $aff4			beq 	_GXRFail
.afbf	08		php				php 								; save Fill flag (CS)
.afc0	20 1b b3	jsr $b31b			jsr 	GXOpenBitmap 				; start drawing
.afc3	20 43 b4	jsr $b443			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afc6	20 2b b3	jsr $b32b			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afc9	38		sec				sec 								; sec = Draw line
.afca	20 f6 af	jsr $aff6			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afcd	ad 4e 06	lda $064e			lda 	gxY0 						; reached end of rectangle ?
.afd0	cd 52 06	cmp $0652			cmp 	gxY1
.afd3	f0 19		beq $afee			beq 	_GXRectangleExit
.afd5					_GXRectLoop:
.afd5	20 81 b3	jsr $b381			jsr 	GXMovePositionDown 			; down one.
.afd8	ee 4e 06	inc $064e			inc 	gxY0 						; change Y pos
.afdb	ad 4e 06	lda $064e			lda 	gxY0 						; reached last line
.afde	cd 52 06	cmp $0652			cmp 	gXY1
.afe1	f0 07		beq $afea			beq 	_GXLastLine
.afe3	28		plp				plp 								; get flag back
.afe4	08		php				php
.afe5	20 f6 af	jsr $aff6			jsr 	GXDrawLineX1X0 				; draw horizontal line
.afe8	80 eb		bra $afd5			bra 	_GXRectLoop
.afea					_GXLastLine:
.afea	38		sec				sec
.afeb	20 f6 af	jsr $aff6			jsr 	GXDrawLineX1X0
.afee					_GXRectangleExit:
.afee	68		pla				pla 								; throw fill flag.
.afef	20 23 b3	jsr $b323			jsr 	GXCloseBitmap 				; stop drawing and exit
.aff2	18		clc				clc
.aff3	60		rts				rts
.aff4					_GXRFail:
.aff4	38		sec				sec
.aff5	60		rts				rts
.aff6					GXDrawLineX1X0:
.aff6	08		php				php 								; save solid/either-end
.aff7	38		sec				sec
.aff8	ad 50 06	lda $0650			lda		gXX1
.affb	ed 4c 06	sbc $064c			sbc 	gXX0
.affe	85 36		sta $36				sta 	gxzTemp0
.b000	ad 51 06	lda $0651			lda 	gXX1+1
.b003	ed 4d 06	sbc $064d			sbc 	gXX0+1
.b006	85 37		sta $37				sta 	gxzTemp0+1
.b008	28		plp				plp
.b009					GXDrawLineTemp0:
.b009	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b00b	48		pha				pha
.b00c	a5 3d		lda $3d				lda 	gxzScreen+1
.b00e	48		pha				pha
.b00f	ad 5e 06	lda $065e			lda 	gsOffset
.b012	48		pha				pha
.b013	a5 0b		lda $0b				lda 	GXEditSlot
.b015	48		pha				pha
.b016	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y offset
.b019	90 1e		bcc $b039			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b01b					_GXDLTLine:
.b01b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b01d	2d 5c 06	and $065c			and 	gxANDValue
.b020	4d 5b 06	eor $065b			eor 	gxEORValue
.b023	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b025	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b027	d0 04		bne $b02d			bne 	_GXDLTNoBorrow
.b029	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b02b	30 2e		bmi $b05b			bmi 	_GXDLTExit
.b02d					_GXDLTNoBorrow:
.b02d	c6 36		dec $36				dec 	gxzTemp0
.b02f	c8		iny				iny 								; next slot.
.b030	d0 e9		bne $b01b			bne 	_GXDLTLine
.b032	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b034	20 69 b0	jsr $b069			jsr 	GXDLTCheckWrap				; check for new page.
.b037	80 e2		bra $b01b			bra 	_GXDLTLine
.b039					_GXDLTEndPoints:
.b039	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b03b	2d 5c 06	and $065c			and 	gxANDValue
.b03e	4d 5b 06	eor $065b			eor 	gxEORValue
.b041	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b043	98		tya				tya 								; advance to right side
.b044	18		clc				clc
.b045	65 36		adc $36				adc 	gxzTemp0
.b047	a8		tay				tay
.b048	a5 3d		lda $3d				lda 	gxzScreen+1
.b04a	65 37		adc $37				adc 	gxzTemp0+1
.b04c	85 3d		sta $3d				sta 	gxzScreen+1
.b04e	20 69 b0	jsr $b069			jsr 	GXDLTCheckWrap 			; fix up.
.b051	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b053	2d 5c 06	and $065c			and 	gxANDValue
.b056	4d 5b 06	eor $065b			eor 	gxEORValue
.b059	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b05b					_GXDLTExit:
.b05b	68		pla				pla
.b05c	85 0b		sta $0b				sta 	GXEditSlot
.b05e	68		pla				pla
.b05f	8d 5e 06	sta $065e			sta 	gsOffset
.b062	68		pla				pla
.b063	85 3d		sta $3d				sta 	gxzScreen+1
.b065	68		pla				pla
.b066	85 3c		sta $3c				sta 	gxzScreen
.b068	60		rts				rts
.b069					GXDLTCheckWrap:
.b069	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b06b	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b06d	90 06		bcc $b075			bcc 	_GXDLTCWExit
.b06f	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b071	85 3d		sta $3d				sta 	gxzScreen+1
.b073	e6 0b		inc $0b				inc 	GXEditSlot
.b075					_GXDLTCWExit:
.b075	60		rts				rts
.b076					GXDrawGraphicElement:
.b076	8d f1 06	sta $06f1			sta 	gxSize 						; save size
.b079	3a		dec a				dec 	a
.b07a	8d f2 06	sta $06f2			sta 	gxMask 						; and mask
.b07d	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP on
.b080	f0 67		beq $b0e9			beq 	_GXSLFail
.b082	ad 4e 06	lda $064e			lda 	gxY0 						; push Y on stack
.b085	48		pha				pha
.b086	8c f4 06	sty $06f4			sty 	gxAcquireVector+1 			; and acquisition vector
.b089	8e f3 06	stx $06f3			stx 	gxAcquireVector
.b08c	20 1b b3	jsr $b31b			jsr 	gxOpenBitmap 				; open the bitmap.
.b08f	ad f6 06	lda $06f6			lda 	gxUseMode 					; scale bits
.b092	4a		lsr a				lsr 	a
.b093	4a		lsr a				lsr 	a
.b094	4a		lsr a				lsr 	a
.b095	29 07		and #$07			and		#7
.b097	1a		inc a				inc 	a
.b098	8d f5 06	sta $06f5			sta 	gxScale
.b09b	64 38		stz $38				stz 	gxzTemp1					; start first line
.b09d					_GXGELoop:
.b09d	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b09f	2c f6 06	bit $06f6			bit 	gxUseMode 					; check for flip.
.b0a2	10 06		bpl $b0aa			bpl		_GXNoVFlip
.b0a4	ad f2 06	lda $06f2			lda 	gxMask
.b0a7	38		sec				sec
.b0a8	e5 38		sbc $38				sbc 	gxzTemp1
.b0aa					_GXNoVFlip:
.b0aa	aa		tax				tax 								; get the Xth line.
.b0ab	20 eb b0	jsr $b0eb			jsr 	_GXCallAcquire 				; get that data.
.b0ae	ad f5 06	lda $06f5			lda 	gxScale 					; do scale identical copies of that line.
.b0b1	85 39		sta $39				sta 	gxzTemp1+1
.b0b3					_GXGELoop2:
.b0b3	ad 4e 06	lda $064e			lda 	gxY0 						; off screen
.b0b6	cd 58 06	cmp $0658			cmp 	gxHeight
.b0b9	b0 10		bcs $b0cb			bcs 	_GXDGEExit
.b0bb	20 ee b0	jsr $b0ee			jsr 	GXRenderOneLine 			; render line
.b0be	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0c0	d0 f1		bne $b0b3			bne 	_GXGELoop2
.b0c2	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0c4	a5 38		lda $38				lda 	gxzTemp1
.b0c6	cd f1 06	cmp $06f1			cmp 	gxSize
.b0c9	d0 d2		bne $b09d			bne 	_GXGELoop
.b0cb					_GXDGEExit:
.b0cb	68		pla				pla 								; restore Y for next time
.b0cc	8d 4e 06	sta $064e			sta 	gxY0
.b0cf	ae f5 06	ldx $06f5			ldx 	gxScale 					; get scale (1-8)
.b0d2					_GXShiftLeft:
.b0d2	18		clc				clc
.b0d3	ad f1 06	lda $06f1			lda 	gxSize
.b0d6	6d 4c 06	adc $064c			adc 	gxX0
.b0d9	8d 4c 06	sta $064c			sta 	gxX0
.b0dc	90 03		bcc $b0e1			bcc 	_GXSLNoCarry
.b0de	ee 4d 06	inc $064d			inc 	gxX0+1
.b0e1					_GXSLNoCarry:
.b0e1	ca		dex				dex
.b0e2	d0 ee		bne $b0d2			bne 	_GXShiftLeft
.b0e4	20 23 b3	jsr $b323			jsr 	GXCloseBitmap
.b0e7	18		clc				clc
.b0e8	60		rts				rts
.b0e9					_GXSLFail:
.b0e9	38		sec				sec
.b0ea	60		rts				rts
.b0eb					_GXCallAcquire:
.b0eb	6c f3 06	jmp ($06f3)			jmp 	(gxAcquireVector)
.b0ee					GXRenderOneLine:
.b0ee	20 2b b3	jsr $b32b			jsr 	GXPositionCalc 				; calculate position/offset.
.b0f1	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y contains position.
.b0f4	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b0f6					_GXROLLoop1:
.b0f6	ad f5 06	lda $06f5			lda 	gxScale 					; set to do 'scale' times
.b0f9	85 3b		sta $3b				sta 	gxzTemp2+1
.b0fb					_GXROLLoop2:
.b0fb	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b0fd	2c 59 06	bit $0659			bit 	gxMode 						; check H Flip
.b100	50 06		bvc $b108			bvc 	_GXNoHFlip
.b102	ad f2 06	lda $06f2			lda 	gxMask
.b105	38		sec				sec
.b106	e5 3a		sbc $3a				sbc 	gxzTemp2
.b108					_GXNoHFlip:
.b108	aa		tax				tax 								; read from the pixel buffer
.b109	bd fa 05	lda $05fa,x			lda 	gxPixelBuffer,x
.b10c	d0 07		bne $b115			bne 	_GXDraw 					; draw if non zero
.b10e	ad f6 06	lda $06f6			lda 	gxUseMode 					; check to see if solid background
.b111	29 04		and #$04			and 	#4
.b113	f0 0a		beq $b11f			beq 	_GXZeroPixel
.b115					_GXDraw:
.b115	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b117	2d 5c 06	and $065c			and 	gxANDValue
.b11a	5d fa 05	eor $05fa,x			eor 	gxPixelBuffer,x
.b11d	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b11f					_GXZeroPixel:
.b11f	c8		iny				iny 								; advance pointer
.b120	d0 05		bne $b127			bne 	_GXNoShift
.b122	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b124	20 69 b0	jsr $b069			jsr 	GXDLTCheckWrap				; check for new page.
.b127					_GXNoShift:
.b127	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b129	d0 d0		bne $b0fb			bne 	_GXROLLoop2
.b12b	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b12d	a5 3a		lda $3a				lda 	gxzTemp2
.b12f	cd f1 06	cmp $06f1			cmp 	gxSize
.b132	d0 c2		bne $b0f6			bne 	_GXROLLoop1
.b134	ee 4e 06	inc $064e			inc 	gxY0
.b137	60		rts				rts
.06f1					gxSize:
>06f1							.fill 	1
.06f2					gxMask:
>06f2							.fill 	1
.06f3					gxAcquireVector:
>06f3							.fill 	2
.06f5					gxScale:
>06f5							.fill 	1
.06f6					gxUseMode:
>06f6							.fill 	1
.b138					GXFontHandler:
.b138	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b13a	4d 59 06	eor $0659			eor 	gxMode
.b13d	8d f6 06	sta $06f6			sta 	gxUseMode
.b140	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b142	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b144	26 37		rol $37				rol	 	gxzTemp0+1
.b146	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b148	26 37		rol $37				rol	 	gxzTemp0+1
.b14a	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b14c	26 37		rol $37				rol	 	gxzTemp0+1
.b14e	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b150	09 c0		ora #$c0			ora 	#$C0
.b152	85 37		sta $37				sta 	gxzTemp0+1
.b154	a9 08		lda #$08			lda 	#8 							; size 8x8
.b156	a2 5e		ldx #$5e			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b158	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b15a	20 76 b0	jsr $b076			jsr 	GXDrawGraphicElement
.b15d	60		rts				rts
.b15e					GXGetGraphicDataFont:
.b15e	8a		txa				txa 								; X->Y
.b15f	a8		tay				tay
.b160	a6 01		ldx $01				ldx 	1 							; preserve old value
.b162	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b164	85 01		sta $01				sta 	1
.b166	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b168	86 01		stx $01				stx 	1 							; put old value back.
.b16a	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b16c					_GXExpand:
.b16c	9e fa 05	stz $05fa,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b16f	0a		asl a				asl 	a 							; shift bit 7 into C
.b170	90 08		bcc $b17a			bcc 	_GXNoPixel
.b172	48		pha				pha 								; if set, set pixel buffer to current colour.
.b173	ad 5a 06	lda $065a			lda 	gxColour
.b176	9d fa 05	sta $05fa,x			sta 	gxPixelBuffer,x
.b179	68		pla				pla
.b17a					_GXNoPixel:
.b17a	e8		inx				inx 								; do the whole byte.
.b17b	e0 08		cpx #$08			cpx 	#8
.b17d	d0 ed		bne $b16c			bne 	_GXExpand
.b17f	60		rts				rts
.b180					GXSpriteHandler:
.b180	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b182	4d 59 06	eor $0659			eor 	gxMode
.b185	8d f6 06	sta $06f6			sta 	gxUseMode
.b188	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b18a	da		phx				phx
.b18b	20 1b b3	jsr $b31b			jsr 	GXOpenBitmap 				; can access sprite information
.b18e	68		pla				pla
.b18f	20 fc b3	jsr $b3fc			jsr 	GXFindSprite 				; get the sprite address
.b192	08		php				php
.b193	20 23 b3	jsr $b323			jsr 	GXCloseBitmap
.b196	28		plp				plp
.b197	b0 0a		bcs $b1a3			bcs		_GXSHExit 					; exit if find failed.
.b199	ad f7 06	lda $06f7			lda 	GXSizePixels 				; return size
.b19c	a2 a4		ldx #$a4			ldx 	#GXSpriteAcquire & $FF
.b19e	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b1a0	20 76 b0	jsr $b076			jsr 	GXDrawGraphicElement
.b1a3					_GXSHExit:
.b1a3	60		rts				rts
.b1a4					GXSpriteAcquire:
.b1a4	ad 57 06	lda $0657			lda 	GXSpritePage				; point to base page
.b1a7	85 0b		sta $0b				sta 	GXEditSlot
.b1a9	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1ab	a9 00		lda #$00			lda 	#0
.b1ad	ae f8 06	ldx $06f8			ldx 	GXSizeBits
.b1b0					_GXTimesRowNumber:
.b1b0	18		clc				clc
.b1b1	65 36		adc $36				adc 	zTemp0
.b1b3	ca		dex				dex
.b1b4	10 fa		bpl $b1b0			bpl 	_GXTimesRowNumber
.b1b6	64 37		stz $37				stz 	gxzTemp0+1
.b1b8	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1b9	26 37		rol $37				rol 	gxzTemp0+1
.b1bb	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1bc	26 37		rol $37				rol 	gxzTemp0+1
.b1be	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1bf	26 37		rol $37				rol 	gxzTemp0+1
.b1c1	85 36		sta $36				sta 	gxzTemp0
.b1c3	18		clc				clc 								; add base address.
.b1c4	a5 36		lda $36				lda 	gxzTemp0
.b1c6	6d fa 06	adc $06fa			adc 	GXSpriteOffset
.b1c9	85 36		sta $36				sta 	gxzTemp0
.b1cb	a5 37		lda $37				lda 	gxzTemp0+1
.b1cd	6d fb 06	adc $06fb			adc 	GXSpriteOffset+1
.b1d0					_GXSAFindPage:
.b1d0	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1d2	90 06		bcc $b1da			bcc 	_GXSAFoundPage
.b1d4	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1d6	e6 0b		inc $0b				inc 	GXEditSlot
.b1d8	80 f6		bra $b1d0			bra 	_GXSAFindPage
.b1da					_GXSAFoundPage:
.b1da	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1dc	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1de	a0 00		ldy #$00			ldy 	#0
.b1e0					_GXSACopyLoop:
.b1e0	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1e2	99 fa 05	sta $05fa,y			sta 	gxPixelBuffer,y
.b1e5	c8		iny				iny
.b1e6	cc f7 06	cpy $06f7			cpy 	GXSizePixels
.b1e9	d0 f5		bne $b1e0			bne 	_GXSACopyLoop
.b1eb	60		rts				rts
.b1ec					GXSelect:
.b1ec	ad 54 06	lda $0654			lda 	gxSpritesOn
.b1ef	f0 22		beq $b213			beq 	_GXSFail
.b1f1	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b1f3	c9 40		cmp #$40			cmp 	#64
.b1f5	b0 1c		bcs $b213			bcs 	_GXSFail
.b1f7	8d 5f 06	sta $065f			sta 	GSCurrentSpriteID
.b1fa	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b1fc	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b1fe	06 36		asl $36				asl 	gxzTemp0
.b200	06 36		asl $36				asl 	gxzTemp0
.b202	06 36		asl $36				asl 	gxzTemp0
.b204	2a		rol a				rol 	a
.b205	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b207	8d 61 06	sta $0661			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b20a	85 37		sta $37				sta 	gxzTemp0+1
.b20c	a5 36		lda $36				lda 	gxzTemp0
.b20e	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr
.b211	18		clc				clc
.b212	60		rts				rts
.b213					_GXSFail:
.b213	38		sec				sec
.b214	60		rts				rts
.b215					GXSelectImage:
.b215	ad 54 06	lda $0654			lda 	gxSpritesOn
.b218	f0 74		beq $b28e			beq 	_GXSIFail
.b21a	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b21d	f0 6f		beq $b28e			beq 	_GXSIFail 					; (checking the MSB)
.b21f	64 01		stz $01				stz 	1
.b221	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b223	d0 6b		bne $b290			bne 	_GXSIHide
.b225	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b227	48		pha				pha
.b228	20 1b b3	jsr $b31b			jsr 	GXOpenBitmap
.b22b	68		pla				pla
.b22c	20 fc b3	jsr $b3fc			jsr 	GXFindSprite
.b22f	b0 5a		bcs $b28b			bcs 	_GXSICloseFail 				; no image
.b231	a0 01		ldy #$01			ldy 	#1
.b233	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b236	85 36		sta $36				sta 	gxzTemp0
.b238	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b23b	85 37		sta $37				sta 	gxzTemp0+1
.b23d	ad fa 06	lda $06fa			lda 	GXSpriteOffset
.b240	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b242	18		clc				clc
.b243	ad fb 06	lda $06fb			lda 	GXSpriteOffset+1
.b246	6d 62 06	adc $0662			adc 	GXSpriteOffsetBase
.b249	c8		iny				iny
.b24a	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b24c	ad 63 06	lda $0663			lda 	GXSpriteOffsetBase+1
.b24f	69 00		adc #$00			adc 	#0
.b251	c8		iny				iny
.b252	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b254	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get raw size
.b257	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b259	2a		rol a				rol 	a 							; x 2
.b25a	0a		asl a				asl 	a 							; x 4
.b25b	0a		asl a				asl 	a 							; x 8
.b25c	0a		asl a				asl 	a 							; x 16
.b25d	0d f9 06	ora $06f9			ora 	GXSpriteLUT 				; Or with LUT
.b260	0a		asl a				asl 	a 							; 1 shift
.b261	09 01		ora #$01			ora 	#1 							; enable sprite.
.b263	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b265	20 23 b3	jsr $b323			jsr 	GXCloseBitmap
.b268	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b26b	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b26e	29 3f		and #$3f			and 	#$3F
.b270	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b273	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get bit size
.b276	6a		ror a				ror 	a 							; shift into bits 6/7
.b277	6a		ror a				ror 	a
.b278	6a		ror a				ror 	a
.b279	29 c0		and #$c0			and 	#$C0
.b27b	1d a4 06	ora $06a4,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b27e	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b281	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b284	29 7f		and #$7f			and 	#$7F
.b286	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b289	18		clc				clc
.b28a	60		rts				rts
.b28b					_GXSICloseFail:
.b28b	20 23 b3	jsr $b323			jsr 	GXCloseBitmap
.b28e					_GXSIFail:
.b28e	38		sec				sec
.b28f	60		rts				rts
.b290					_GXSIHide:
.b290	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b293	85 36		sta $36				sta 	gxzTemp0
.b295	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b298	85 37		sta $37				sta 	gxzTemp0+1
.b29a	a9 00		lda #$00			lda 	#0
.b29c	92 36		sta ($36)			sta 	(gxzTemp0)
.b29e	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get sprite ID
.b2a1	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2a4	09 80		ora #$80			ora 	#$80
.b2a6	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b2a9	18		clc				clc
.b2aa	60		rts				rts
.b2ab					GXMoveSprite:
.b2ab	ad 54 06	lda $0654			lda 	gxSpritesOn
.b2ae	f0 65		beq $b315			beq 	_GXSIFail
.b2b0	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2b3	f0 60		beq $b315			beq 	_GXSIFail
.b2b5	85 37		sta $37				sta 	gxzTemp0+1
.b2b7	a0 04		ldy #$04			ldy 	#4
.b2b9	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b2bc	85 36		sta $36				sta 	gxzTemp0
.b2be	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2c1	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b2c4	2a		rol a				rol 	a	 						; into bits 0,1.
.b2c5	2a		rol a				rol 	a
.b2c6	2a		rol a				rol 	a
.b2c7	29 03		and #$03			and 	#3
.b2c9	aa		tax				tax
.b2ca	bd 17 b3	lda $b317,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2cd	48		pha				pha
.b2ce	18		clc				clc
.b2cf	6d 4c 06	adc $064c			adc 	gxX0						; copy position.
.b2d2	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2d4	c8		iny				iny
.b2d5	ad 4d 06	lda $064d			lda 	gxX0+1
.b2d8	69 00		adc #$00			adc 	#0
.b2da	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2dc	c8		iny				iny
.b2dd	68		pla				pla
.b2de	18		clc				clc
.b2df	6d 4e 06	adc $064e			adc 	gxY0
.b2e2	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e4	a9 00		lda #$00			lda 	#0
.b2e6	69 00		adc #$00			adc 	#0
.b2e8	c8		iny				iny
.b2e9	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2eb	4e 4d 06	lsr $064d			lsr 	gxX0+1 						; divide X by 4
.b2ee	6e 4c 06	ror $064c			ror 	gxX0
.b2f1	4e 4c 06	lsr $064c			lsr 	gxX0
.b2f4	4e 4e 06	lsr $064e			lsr 	gxY0 						; divide Y by 4
.b2f7	4e 4e 06	lsr $064e			lsr 	gxY0
.b2fa	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b2fd	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x
.b300	29 80		and #$80			and 	#$80
.b302	0d 4c 06	ora $064c			ora 	gxX0
.b305	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b308	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b30b	29 c0		and #$c0			and 	#$C0
.b30d	0d 4e 06	ora $064e			ora 	gxY0
.b310	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b313	18		clc				clc
.b314	60		rts				rts
.b315					_GXSIFail:
.b315	38		sec				sec
.b316	60		rts				rts
.b317					_GXMSOffset:
>b317	1c						.byte 	32-8/2
>b318	18						.byte 	32-16/2
>b319	14						.byte 	32-24/2
>b31a	10						.byte 	32-32/2
.b31b					GXOpenBitmap:
.b31b	78		sei				sei 								; no interrupts here
.b31c	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b31e	8d 5d 06	sta $065d			sta 	gxOriginalLUTValue
.b321	58		cli				cli
.b322	60		rts				rts
.b323					GXCloseBitmap:
.b323	78		sei				sei
.b324	ad 5d 06	lda $065d			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b327	85 0b		sta $0b				sta 	GXEditSlot
.b329	58		cli				cli
.b32a	60		rts				rts
.b32b					GXPositionCalc:
.b32b	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b32d	48		pha				pha
.b32e	ad 4e 06	lda $064e			lda 	GXY0 						; gxzScreen = Y0
.b331	85 3c		sta $3c				sta 	gxzScreen
.b333	64 3d		stz $3d				stz 	gxzScreen+1
.b335	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b337	26 3d		rol $3d				rol 	gxzScreen+1
.b339	06 3c		asl $3c				asl 	gxzScreen
.b33b	26 3d		rol $3d				rol 	gxzScreen+1
.b33d	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b33e	65 3c		adc $3c				adc 	gxzScreen
.b340	85 3c		sta $3c				sta 	gxzScreen
.b342	90 02		bcc $b346			bcc 	_GXPCNoCarry
.b344	e6 3d		inc $3d				inc 	gxzScreen+1
.b346					_GXPCNoCarry:
.b346	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b348	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b34a	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b34c	85 36		sta $36				sta 	gxzTemp0
.b34e	64 3d		stz $3d				stz 	gxzScreen+1
.b350	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b352					_GXPCMultiply32:
.b352	06 3c		asl $3c				asl 	gxzScreen
.b354	26 3d		rol $3d				rol 	gxzScreen+1
.b356	3a		dec a				dec 	a
.b357	d0 f9		bne $b352			bne 	_GXPCMultiply32
.b359	18		clc				clc
.b35a	ad 4c 06	lda $064c			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b35d	65 3c		adc $3c				adc 	gxzScreen
.b35f	8d 5e 06	sta $065e			sta 	gsOffset
.b362	ad 4d 06	lda $064d			lda 	GXX0+1
.b365	65 3d		adc $3d				adc 	gxzScreen+1
.b367	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b369	90 04		bcc $b36f			bcc 	_GXPCNoOverflow
.b36b	29 1f		and #$1f			and 	#$1F 						; fix it up
.b36d	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b36f					_GXPCNoOverflow:
.b36f	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b371	85 3d		sta $3d				sta 	gxzScreen+1
.b373	64 3c		stz $3c				stz 	gxzScreen
.b375	18		clc				clc
.b376	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b378	6d 56 06	adc $0656			adc 	gxBasePage 					; by adding the base page
.b37b	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b37d	68		pla				pla
.b37e	85 36		sta $36				sta 	gxzTemp0
.b380	60		rts				rts
.b381					GXMovePositionDown:
.b381	18		clc				clc 								; add 320 to offset/temp+1
.b382	ad 5e 06	lda $065e			lda 	gsOffset
.b385	69 40		adc #$40			adc 	#64
.b387	8d 5e 06	sta $065e			sta 	gsOffset
.b38a	a5 3d		lda $3d				lda 	gxzScreen+1
.b38c	69 01		adc #$01			adc 	#1
.b38e	85 3d		sta $3d				sta 	gxzScreen+1
.b390	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b392	90 07		bcc $b39b			bcc 	_GXMPDExit
.b394	38		sec				sec  								; next page
.b395	e9 20		sbc #$20			sbc 	#$20
.b397	85 3d		sta $3d				sta 	gxzScreen+1
.b399	e6 0b		inc $0b				inc 	GXEditSlot
.b39b					_GXMPDExit:
.b39b	60		rts				rts
.b39c					GXCollide:
.b39c	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b39e	aa		tax				tax
.b39f	05 37		ora $37				ora 	gxzTemp0+1
.b3a1	29 c0		and #$c0			and 	#$C0
.b3a3	38		sec				sec
.b3a4	d0 53		bne $b3f9			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3a6	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3a8	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3ab	1d 64 06	ora $0664,x			ora 	GXSpriteLow,x
.b3ae	30 48		bmi $b3f8			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3b0	18		clc				clc 								; need to calculate sum of sizes.
.b3b1	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y
.b3b4	7d a4 06	adc $06a4,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3b7	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3b9	6a		ror a				ror 	a 							; 5/6/7
.b3ba	4a		lsr a				lsr 	a 							; 4/5/6
.b3bb	4a		lsr a				lsr 	a 							; 3/4/5
.b3bc	4a		lsr a				lsr 	a 							; 2/3/4
.b3bd	18		clc				clc
.b3be	69 08		adc #$08			adc 	#$08
.b3c0	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3c1	4a		lsr a				lsr 	a
.b3c2	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3c4	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3c7	29 3f		and #$3f			and 	#$3F
.b3c9	85 39		sta $39				sta 	gxzTemp1+1
.b3cb	38		sec				sec
.b3cc	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b3cf	29 3f		and #$3f			and 	#$3F
.b3d1	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3d3	b0 03		bcs $b3d8			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3d5	49 ff		eor #$ff			eor 	#$FF
.b3d7	1a		inc a				inc 	a
.b3d8					_GXCAbs1:
.b3d8	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3da	b0 1c		bcs $b3f8			bcs 	_GXOkayFail
.b3dc	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3de	38		sec				sec 								; calculate |x1-x0|
.b3df	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y
.b3e2	fd 64 06	sbc $0664,x			sbc 	GXSpriteLow,x
.b3e5	b0 03		bcs $b3ea			bcs 	_GXCAbs2
.b3e7	49 ff		eor #$ff			eor 	#$FF
.b3e9	1a		inc a				inc 	a
.b3ea					_GXCAbs2:
.b3ea	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3ec	b0 0a		bcs $b3f8			bcs 	_GXOkayFail
.b3ee	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b3f0	90 02		bcc $b3f4			bcc 	_GXCHaveLowest
.b3f2	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b3f4					_GXCHaveLowest:
.b3f4	0a		asl a				asl 	a 							; scale to allow for >> 2
.b3f5	0a		asl a				asl 	a
.b3f6	18		clc				clc
.b3f7	60		rts				rts
.b3f8					_GXOkayFail:
.b3f8	18		clc				clc
.b3f9					_GXCollideFail:
.b3f9	a9 ff		lda #$ff			lda 	#$FF
.b3fb	60		rts				rts
.b3fc					GXFindSprite:
.b3fc	aa		tax				tax
.b3fd	ad 57 06	lda $0657			lda 	GXSpritePage 				; access the base page of the sprite
.b400	85 0b		sta $0b				sta 	GXEditSlot
.b402	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b405	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b408	f0 33		beq $b43d			beq 	_GXFSFail
.b40a	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b40d	8d fb 06	sta $06fb			sta 	GXSpriteOffset+1
.b410	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b413	48		pha				pha 								; save twice
.b414	48		pha				pha
.b415	29 03		and #$03			and 	#3 							; get sprite size
.b417	8d f8 06	sta $06f8			sta 	GXSizeBits 					; save raw (0-3)
.b41a	aa		tax				tax
.b41b	bd 3f b4	lda $b43f,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b41e	8d f7 06	sta $06f7			sta 	GXSizePixels 					; save (8/16/24/32)
.b421	68		pla				pla 								; get LUT
.b422	4a		lsr a				lsr		a
.b423	4a		lsr a				lsr		a
.b424	29 03		and #$03			and 	#3
.b426	8d f9 06	sta $06f9			sta 	GXSpriteLUT
.b429	68		pla				pla 								; address, neeeds to be x 4
.b42a	29 f0		and #$f0			and 	#$F0
.b42c	8d fa 06	sta $06fa			sta 	GXSpriteOffset
.b42f	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b432	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b435	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b438	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b43b	18		clc				clc
.b43c	60		rts				rts
.b43d					_GXFSFail:
.b43d	38		sec				sec
.b43e	60		rts				rts
.b43f					_GXFXSSTTable:
>b43f	08 10 18 20					.byte 	8,16,24,32
.06f7					GXSizePixels:
>06f7							.fill 	1
.06f8					GXSizeBits:
>06f8							.fill 	1
.06f9					GXSpriteLUT:
>06f9							.fill 	1
.06fa					GXSpriteOffset:
>06fa							.fill 	2
.b443					GXSortXY:
.b443	20 61 b4	jsr $b461			jsr 	GXSortY 					; will be sorted on Y now
.b446	ad 4c 06	lda $064c			lda 	gxX0 						; compare X0 v X1
.b449	cd 50 06	cmp $0650			cmp 	gxX1
.b44c	ad 4d 06	lda $064d			lda 	gXX0+1
.b44f	ed 51 06	sbc $0651			sbc 	gXX1+1
.b452	90 0c		bcc $b460			bcc 	_GXSXYExit 					; X0 < X1 exit
.b454	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b456	a0 04		ldy #$04			ldy 	#4
.b458	20 75 b4	jsr $b475			jsr 	GXSwapXY
.b45b	e8		inx				inx
.b45c	c8		iny				iny
.b45d	20 75 b4	jsr $b475			jsr 	GXSwapXY
.b460					_GXSXYExit:
.b460	60		rts				rts
.b461					GXSortY:
.b461	ad 4e 06	lda $064e			lda 	gxY0 						; if Y0 >= Y1
.b464	cd 52 06	cmp $0652			cmp 	gxY1
.b467	90 0b		bcc $b474			bcc 	_GXSYSorted
.b469	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b46b	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b46d					_GXSwap1:
.b46d	20 75 b4	jsr $b475			jsr 	GXSwapXY
.b470	88		dey				dey
.b471	ca		dex				dex
.b472	10 f9		bpl $b46d			bpl 	_GXSwap1
.b474					_GXSYSorted:
.b474	60		rts				rts
.b475					GXSwapXY:
.b475	bd 4c 06	lda $064c,x			lda 	gxX0,x
.b478	48		pha				pha
.b479	b9 4c 06	lda $064c,y			lda 	gxX0,y
.b47c	9d 4c 06	sta $064c,x			sta 	gxX0,x
.b47f	68		pla				pla
.b480	99 4c 06	sta $064c,y			sta 	gxX0,y
.b483	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.baf9					KeywordSet0:
>baf9	00 65					.text	0,$65,""               ; $80 !0:EOF
>bafb	00 58					.text	0,$58,""               ; $81 !1:SH1
>bafd	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>baff	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>bb05	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>bb0d	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>bb13	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>bb1a	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>bb22	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>bb29	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>bb30	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>bb36	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>bb3c	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>bb44	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>bb4b	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>bb52	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>bb59	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>bb61	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>bb67	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>bb6d	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>bb74	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bb7a	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bb80	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bb88	47 28
>bb8a	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>bb92	28
>bb93	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>bb9b	28
>bb9c	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bba2	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bba8	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>bbae	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>bbb5	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>bbbd	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bbc3	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bbc9	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bbce	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bbd2	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bbd8	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bbe0	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bbe7	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bbee	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bbf6	43
>bbf7	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bbfd	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bc03	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bc0a	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bc10	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bc14	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bc1a	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bc22	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bc29	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bc2e	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bc35	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bc3d	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bc43	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bc48	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bc50	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bc56	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bc5c	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bc61	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bc68	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bc6e	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bc74	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bc7b	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>bc82	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>bc87	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>bc8d	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>bc94	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>bc99	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>bc9d	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>bca5	45
>bca6	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>bcae	45
>bcaf	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>bcb5	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>bcbc	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>bcc2	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>bcc8	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>bccd	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bcd5	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>bcdc	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bce3	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>bceb	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bcf1	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bcf5	ff					.text	$FF
.bcf6					KeywordSet1:
>bcf6	00 65					.text	0,$65,""               ; $80 !0:EOF
>bcf8	00 58					.text	0,$58,""               ; $81 !1:SH1
>bcfa	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bcfc	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bd04	4c 45
>bd06	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bd0e	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bd16	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bd1b	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>bd1f	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>bd25	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>bd2b	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>bd30	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>bd38	45
>bd39	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>bd3e	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>bd46	53
>bd47	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>bd4d	ff					.text	$FF
.bd4e					KeywordSet2:
>bd4e	00 65					.text	0,$65,""               ; $80 !0:EOF
>bd50	00 58					.text	0,$58,""               ; $81 !1:SH1
>bd52	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bd54	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bd59	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bd5e	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bd63	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bd68	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bd6d	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bd72	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bd77	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bd7c	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bd81	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bd86	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bd8b	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bd90	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bd95	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bd9a	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bd9f	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bda4	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bda9	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bdae	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bdb3	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bdb8	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bdbd	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bdc2	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bdc7	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bdcc	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bdd1	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bdd6	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bddb	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bde0	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bde5	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bdea	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bdef	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bdf4	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bdf9	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bdfe	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>be03	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>be08	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>be0d	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>be12	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>be17	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>be1c	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>be21	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>be26	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>be2b	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>be30	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>be35	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>be3a	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>be3f	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>be44	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>be49	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>be4e	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>be53	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>be58	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>be5d	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>be62	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>be67	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>be6c	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>be71	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>be76	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>be7b	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>be80	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>be85	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>be8a	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>be8f	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>be94	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>be99	ff					.text	$FF
.b484					ListConvertLine:
.b484	48		pha				pha 								; save indent on the stack
.b485	9c 9d 04	stz $049d			stz 	tbOffset
.b488	9c ac 04	stz $04ac			stz 	tokenBuffer
.b48b	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b48d	b1 30		lda ($30),y			lda 	(codePtr),y
.b48f	aa		tax				tax
.b490	88		dey				dey
.b491	b1 30		lda ($30),y			lda 	(codePtr),y
.b493	20 09 93	jsr $9309			jsr 	LCLConvertInt16
.b496	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b498	86 37		stx $37				stx 	zTemp0+1
.b49a	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b49c	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b49f	a0 00		ldy #$00			ldy 	#0
.b4a1					_LCCopyNumber:
.b4a1	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4a3	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b4a6	c8		iny				iny
.b4a7	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4a9	d0 f6		bne $b4a1			bne 	_LCCopyNumber
.b4ab	68		pla				pla 								; adjustment to indent
.b4ac	48		pha				pha 								; save on stack
.b4ad	10 0c		bpl $b4bb			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b4af	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b4b0	6d a6 04	adc $04a6			adc 	listIndent
.b4b3	8d a6 04	sta $04a6			sta 	listIndent
.b4b6	10 03		bpl $b4bb			bpl 	_LCNoAdjust
.b4b8	9c a6 04	stz $04a6			stz 	listIndent
.b4bb					_LCNoAdjust:
.b4bb	18		clc				clc		 							; work out actual indent.
.b4bc	ad a6 04	lda $04a6			lda 	listIndent
.b4bf	0a		asl a				asl 	a
.b4c0	69 06		adc #$06			adc 	#6
.b4c2	85 36		sta $36				sta 	zTemp0
.b4c4					_LCPadOut:
.b4c4	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b4c6	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b4c9	ad 9d 04	lda $049d			lda 	tbOffset
.b4cc	c5 36		cmp $36				cmp 	zTemp0
.b4ce	d0 f4		bne $b4c4			bne 	_LCPadOut
.b4d0	a0 03		ldy #$03			ldy 	#3 							; start position.
.b4d2					_LCMainLoop:
.b4d2	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b4d4	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b4d7	b1 30		lda ($30),y			lda 	(codePtr),y
.b4d9	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b4db	f0 17		beq $b4f4			beq 	_LCExit
.b4dd	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b4df	90 1e		bcc $b4ff			bcc 	_LCDoubles
.b4e1	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b4e3	90 2a		bcc $b50f			bcc 	_LCShiftPunc
.b4e5	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b4e7	90 35		bcc $b51e			bcc 	_LCPunctuation
.b4e9	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b4eb	90 3e		bcc $b52b			bcc 	_LCIdentifiers
.b4ed	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b4ef	90 5f		bcc $b550			bcc 	_LCTokens
.b4f1	4c b0 b5	jmp $b5b0			jmp 	_LCData 					; 254-5 are data objects
.b4f4					_LCExit:
.b4f4	68		pla				pla 								; get old indent adjust
.b4f5	30 07		bmi $b4fe			bmi 	_LCExit2
.b4f7	18		clc				clc 								; add to indent if +ve
.b4f8	6d a6 04	adc $04a6			adc 	listIndent
.b4fb	8d a6 04	sta $04a6			sta 	listIndent
.b4fe					_LCExit2:
.b4fe	60		rts				rts
.b4ff					_LCDoubles:
.b4ff	48		pha				pha
.b500	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b501	29 02		and #$02			and 	#2
.b503	09 3c		ora #$3c			ora 	#60 						; make < >
.b505	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b508	68		pla				pla 								; restore, do lower bit
.b509	29 03		and #$03			and 	#3
.b50b	09 3c		ora #$3c			ora 	#60
.b50d	80 0f		bra $b51e			bra		_LCPunctuation 				; print, increment, loop
.b50f					_LCShiftPunc:
.b50f	aa		tax				tax 								; save in X
.b510	29 07		and #$07			and 	#7 							; lower 3 bits
.b512	f0 02		beq $b516			beq 	_LCNoAdd
.b514	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b516					_LCNoAdd:
.b516	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b518	90 02		bcc $b51c			bcc 	_LCNoAdd2
.b51a	09 20		ora #$20			ora 	#32 						; adds $20
.b51c					_LCNoAdd2:
.b51c	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b51e					_LCPunctuation:
.b51e	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b520	d0 03		bne $b525			bne 	_LCPContinue
.b522	20 f7 b5	jsr $b5f7			jsr 	LCLDeleteLastSpace
.b525					_LCPContinue:
.b525	c8		iny				iny 								; consume character
.b526	20 e1 b5	jsr $b5e1			jsr 	LCLWrite 					; write it out.
.b529	80 a7		bra $b4d2			bra 	_LCMainLoop 				; go round again.
.b52b					_LCIdentifiers:
.b52b	18		clc				clc 								; convert to physical address
.b52c	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b52e	85 37		sta $37				sta 	zTemp0+1
.b530	c8		iny				iny
.b531	b1 30		lda ($30),y			lda 	(codePtr),y
.b533	85 36		sta $36				sta 	zTemp0
.b535	c8		iny				iny
.b536	5a		phy				phy 								; save position
.b537	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b539	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b53c	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b53e					_LCOutIdentifier:
.b53e	c8		iny				iny
.b53f	b1 36		lda ($36),y			lda 	(zTemp0),y
.b541	29 7f		and #$7f			and 	#$7F
.b543	20 33 b6	jsr $b633			jsr 	LCLLowerCase
.b546	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b549	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b54b	10 f1		bpl $b53e			bpl 	_LCOutIdentifier
.b54d	7a		ply				ply 								; restore position
.b54e	80 82		bra $b4d2			bra 	_LCMainLoop
.b550					_LCTokens:
.b550	aa		tax				tax 								; token in X
.b551	a9 4e		lda #$4e			lda 	#((KeywordSet2) & $FF)
.b553	85 36		sta $36				sta 	0+zTemp0
.b555	a9 bd		lda #$bd			lda 	#((KeywordSet2) >> 8)
.b557	85 37		sta $37				sta 	1+zTemp0
.b559	e0 82		cpx #$82			cpx 	#$82
.b55b	f0 16		beq $b573			beq 	_LCUseShift
.b55d	a9 f6		lda #$f6			lda 	#((KeywordSet1) & $FF)
.b55f	85 36		sta $36				sta 	0+zTemp0
.b561	a9 bc		lda #$bc			lda 	#((KeywordSet1) >> 8)
.b563	85 37		sta $37				sta 	1+zTemp0
.b565	e0 81		cpx #$81			cpx 	#$81
.b567	f0 0a		beq $b573			beq 	_LCUseShift
.b569	a9 f9		lda #$f9			lda 	#((KeywordSet0) & $FF)
.b56b	85 36		sta $36				sta 	0+zTemp0
.b56d	a9 ba		lda #$ba			lda 	#((KeywordSet0) >> 8)
.b56f	85 37		sta $37				sta 	1+zTemp0
.b571	80 01		bra $b574			bra 	_LCNoShift
.b573					_LCUseShift:
.b573	c8		iny				iny
.b574					_LCNoShift:
.b574	20 0b b6	jsr $b60b			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b577	b1 30		lda ($30),y			lda 	(codePtr),y
.b579	aa		tax				tax 								; into X
.b57a					_LCFindText:
.b57a	ca		dex				dex
.b57b	10 0e		bpl $b58b			bpl 	_LCFoundText 				; found text.
.b57d	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b57f	1a		inc a				inc 	a 							; one extra for size
.b580	38		sec				sec 								; one extra for checksum
.b581	65 36		adc $36				adc 	zTemp0 						; go to next token
.b583	85 36		sta $36				sta 	zTemp0
.b585	90 f3		bcc $b57a			bcc 	_LCFindText
.b587	e6 37		inc $37				inc 	zTemp0+1
.b589	80 ef		bra $b57a			bra 	_LCFindText
.b58b					_LCFoundText:
.b58b	5a		phy				phy 								; save List position
.b58c	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b58e	aa		tax				tax
.b58f	a9 83		lda #$83			lda 	#CLIToken+$80
.b591	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b594	a0 02		ldy #$02			ldy 	#2
.b596					_LCCopyToken:
.b596	b1 36		lda ($36),y			lda 	(zTemp0),y
.b598	20 33 b6	jsr $b633			jsr 	LCLLowerCase
.b59b	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b59e	c8		iny				iny
.b59f	ca		dex				dex
.b5a0	d0 f4		bne $b596			bne 	_LCCopyToken
.b5a2	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b5a4	f0 05		beq $b5ab			beq 	_LCNoSpace
.b5a6	a9 20		lda #$20			lda 	#' '
.b5a8	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b5ab					_LCNoSpace:
.b5ab	7a		ply				ply 								; restore position.
.b5ac	c8		iny				iny 								; consume token
.b5ad	4c d2 b4	jmp $b4d2			jmp 	_LCMainLoop 				; and go around again.
.b5b0					_LCData:
.b5b0	48		pha				pha 								; save type $FE/$FF
.b5b1	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b5b3	c9 fe		cmp #$fe			cmp 	#$FE
.b5b5	f0 07		beq $b5be			beq 	_LCHaveOpener
.b5b7	a2 22		ldx #$22			ldx 	#'"'
.b5b9	a9 81		lda #$81			lda 	#CLIData+$80
.b5bb	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b5be					_LCHaveOpener:
.b5be	8a		txa				txa 								; output prefix (# or ")
.b5bf	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b5c2	c8		iny				iny 								; get count
.b5c3	b1 30		lda ($30),y			lda 	(codePtr),y
.b5c5	aa		tax				tax
.b5c6	c8		iny				iny 								; point at first character
.b5c7					_LCOutData:
.b5c7	b1 30		lda ($30),y			lda 	(codePtr),y
.b5c9	c9 00		cmp #$00			cmp 	#0
.b5cb	f0 03		beq $b5d0			beq 	_LCNoPrint
.b5cd	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b5d0					_LCNoPrint:
.b5d0	c8		iny				iny
.b5d1	ca		dex				dex
.b5d2	d0 f3		bne $b5c7			bne 	_LCOutData
.b5d4	68		pla				pla 								; closing " required ?
.b5d5	c9 ff		cmp #$ff			cmp 	#$FF
.b5d7	d0 05		bne $b5de			bne 	_LCNoQuote
.b5d9	a9 22		lda #$22			lda 	#'"'
.b5db	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b5de					_LCNoQuote:
.b5de	4c d2 b4	jmp $b4d2			jmp 	_LCMainLoop
.b5e1					LCLWrite:
.b5e1	da		phx				phx
.b5e2	ae 9d 04	ldx $049d			ldx 	tbOffset
.b5e5	9d ac 04	sta $04ac,x			sta 	tokenBuffer,x
.b5e8	9e ad 04	stz $04ad,x			stz 	tokenBuffer+1,x
.b5eb	ee 9d 04	inc $049d			inc 	tbOffset
.b5ee	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b5f0	30 03		bmi $b5f5			bmi 	_LCLNoColour
.b5f2	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b5f5					_LCLNoColour:
.b5f5	fa		plx				plx
.b5f6	60		rts				rts
.b5f7					LCLDeleteLastSpace:
.b5f7	48		pha				pha
.b5f8	da		phx				phx
.b5f9	ae 9d 04	ldx $049d			ldx 	tbOffset
.b5fc	f0 0a		beq $b608			beq 	_LCDLSExit
.b5fe	bd ab 04	lda $04ab,x			lda 	tokenBuffer-1,x
.b601	c9 20		cmp #$20			cmp 	#' '
.b603	d0 03		bne $b608			bne 	_LCDLSExit
.b605	ce 9d 04	dec $049d			dec 	tbOffset
.b608					_LCDLSExit:
.b608	fa		plx				plx
.b609	68		pla				pla
.b60a	60		rts				rts
.b60b					LCLCheckSpaceRequired:
.b60b	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b60e	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b610	f0 1b		beq $b62d			beq 	_LCCSRSpace
.b612	c9 29		cmp #$29			cmp 	#')'
.b614	f0 17		beq $b62d			beq 	_LCCSRSpace
.b616	c9 23		cmp #$23			cmp 	#'#'
.b618	f0 13		beq $b62d			beq 	_LCCSRSpace
.b61a	20 33 b6	jsr $b633			jsr 	LCLLowerCase 				; saves a little effort
.b61d	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b61f	90 11		bcc $b632			bcc 	_LCCSRExit
.b621	c9 3a		cmp #$3a			cmp 	#"9"+1
.b623	90 08		bcc $b62d			bcc 	_LCCSRSpace
.b625	c9 61		cmp #$61			cmp 	#"a"
.b627	90 09		bcc $b632			bcc 	_LCCSRExit
.b629	c9 7b		cmp #$7b			cmp 	#"z"+1
.b62b	b0 05		bcs $b632			bcs 	_LCCSRExit
.b62d					_LCCSRSpace:
.b62d	a9 20		lda #$20			lda 	#' '
.b62f	20 e1 b5	jsr $b5e1			jsr 	LCLWrite
.b632					_LCCSRExit:
.b632	60		rts				rts
.b633					LCLLowerCase:
.b633	c9 41		cmp #$41			cmp 	#"A"
.b635	90 06		bcc $b63d			bcc 	_LCLLCOut
.b637	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b639	b0 02		bcs $b63d			bcs 	_LCLLCOut
.b63b	69 20		adc #$20			adc 	#$20
.b63d					_LCLLCOut:
.b63d	60		rts				rts
.b63e					LCLUpperCase:
.b63e	c9 61		cmp #$61			cmp 	#"a"
.b640	90 06		bcc $b648			bcc 	_LCLUCOut
.b642	c9 7b		cmp #$7b			cmp 	#"z"+1
.b644	b0 02		bcs $b648			bcs 	_LCLUCOut
.b646	e9 1f		sbc #$1f			sbc 	#$1F
.b648					_LCLUCOut:
.b648	60		rts				rts
.b649					TOKSearchTable:
.b649	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b64b	85 36		sta $36				sta 	zTemp0
.b64d	a0 00		ldy #$00			ldy 	#0
.b64f	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b651	85 38		sta $38				sta 	zTemp1
.b653					_TSTLoop:
.b653	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b655	30 49		bmi $b6a0			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b657	f0 2e		beq $b687			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b659	c8		iny				iny 								; get the hash
.b65a	b1 36		lda ($36),y			lda 	(zTemp0),y
.b65c	88		dey				dey
.b65d	cd 83 04	cmp $0483			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b660	d0 25		bne $b687			bne 	_TSTNext
.b662	ad 82 04	lda $0482			lda 	identTypeEnd 				; get length of identifier from end-start
.b665	38		sec				sec
.b666	ed 80 04	sbc $0480			sbc 	identStart
.b669	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b66b	d0 1a		bne $b687			bne 	_TSTNext
.b66d	5a		phy				phy 								; save Y , we might fail to match.
.b66e	c8		iny				iny 								; point to text
.b66f	c8		iny				iny
.b670	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b673					_TSTCompareName:
.b673	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; compare text.
.b676	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b678	d0 0c		bne $b686			bne 	_TSTNextPullY 				; fail, pullY and do next
.b67a	e8		inx				inx
.b67b	c8		iny				iny
.b67c	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b67f	d0 f2		bne $b673			bne 	_TSTCompareName
.b681	7a		ply				ply 								; throw Y
.b682	a5 38		lda $38				lda 	zTemp1 						; get token #
.b684	38		sec				sec 								; return with CS = passed.
.b685	60		rts				rts
.b686					_TSTNextPullY:
.b686	7a		ply				ply 								; restore current, fall through.
.b687					_TSTNext:
.b687	e6 38		inc $38				inc 	zTemp1 						; token counter
.b689	98		tya				tya
.b68a	18		clc				clc
.b68b	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b68d	1a		inc a				inc 	a 							; +1
.b68e	1a		inc a				inc 	a 							; +2
.b68f	a8		tay				tay
.b690	10 c1		bpl $b653			bpl 	_TSTLoop 					; if Y < $80 loop back
.b692	98		tya				tya 								; add Y to zTemp0 and reset Y
.b693	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b695	18		clc				clc  								; but have tables > 255 bytes
.b696	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b698	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b69a	90 b7		bcc $b653			bcc 	_TSTLoop
.b69c	e6 37		inc $37				inc 	zTemp0+1
.b69e	80 b3		bra $b653			bra 	_TSTLoop
.b6a0					_TSTFail:
.b6a0	18		clc				clc
.b6a1	60		rts				rts
.b6a2					TokeniseLine:
.b6a2	20 2a b8	jsr $b82a			jsr 	LCLFixLineBufferCase 		; fix line case
.b6a5	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b6a7	8d a9 04	sta $04a9			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b6aa	9c aa 04	stz $04aa			stz 	tokenLineNumber
.b6ad	9c ab 04	stz $04ab			stz 	tokenLineNumber+1
.b6b0	a2 ff		ldx #$ff			ldx 	#$FF
.b6b2					_TKFindFirst:
.b6b2	e8		inx				inx
.b6b3	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b6b6	f0 79		beq $b731			beq 	_TKExit
.b6b8	c9 20		cmp #$20			cmp 	#' '
.b6ba	90 f6		bcc $b6b2			bcc 	_TKFindFirst
.b6bc	c9 30		cmp #$30			cmp 	#'0'
.b6be	90 07		bcc $b6c7			bcc 	_TKNoLineNumber
.b6c0	c9 3a		cmp #$3a			cmp 	#'9'+1
.b6c2	b0 03		bcs $b6c7			bcs 	_TKNoLineNumber
.b6c4	20 54 b8	jsr $b854			jsr 	TOKExtractLineNumber
.b6c7					_TKNoLineNumber:
.b6c7					_TKTokeniseLoop:
.b6c7	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b6ca	f0 65		beq $b731			beq 	_TKExit
.b6cc	e8		inx				inx
.b6cd	c9 20		cmp #$20			cmp 	#' '
.b6cf	f0 f6		beq $b6c7			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b6d1	ca		dex				dex 								; undo last get, A contains character, X is position.
.b6d2	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b6d4	f0 61		beq $b737			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.b6d6	c9 41		cmp #$41			cmp 	#'A'
.b6d8	90 04		bcc $b6de			bcc 	_TKTokenisePunctuation
.b6da	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b6dc	90 59		bcc $b737			bcc 	_TKTokeniseIdentifier
.b6de					_TKTokenisePunctuation:
.b6de	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b6e0	f0 27		beq $b709			beq 	_TKString
.b6e2	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.b6e4	f0 28		beq $b70e			beq 	_TKHexConstant
.b6e6	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.b6e8	f0 29		beq $b713			beq 	_TKCheckDouble
.b6ea	c9 3e		cmp #$3e			cmp 	#'>'
.b6ec	f0 25		beq $b713			beq 	_TKCheckDouble
.b6ee					_TKStandardPunctuation:
.b6ee	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get the punctuation token back.
.b6f1	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b6f3	90 0e		bcc $b703			bcc 	_TKNoShift
.b6f5	48		pha				pha 								; save. we are about to convert this punctuation token from
.b6f6	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b6f8	85 36		sta $36				sta 	zTemp0
.b6fa	68		pla				pla
.b6fb	29 20		and #$20			and 	#32 						; bit 5
.b6fd	4a		lsr a				lsr 	a 							; shift into bit 3
.b6fe	4a		lsr a				lsr 	a
.b6ff	05 36		ora $36				ora 	zTemp0
.b701	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b703					_TKNoShift:
.b703	20 99 b8	jsr $b899			jsr 	TOKWriteByte 				; write the punctuation character
.b706	e8		inx				inx 								; consume the character
.b707	80 be		bra $b6c7			bra 	_TKTokeniseLoop 			; and loop round again.
.b709					_TKString:
.b709	20 b9 b7	jsr $b7b9			jsr 	TOKTokenString
.b70c	80 b9		bra $b6c7			bra 	_TKTokeniseLoop
.b70e					_TKHexConstant:
.b70e	20 f4 b7	jsr $b7f4			jsr 	TOKHexConstant
.b711	80 b4		bra $b6c7			bra 	_TKTokeniseLoop
.b713					_TKCheckDouble:
.b713	bd aa 05	lda $05aa,x			lda 	lineBuffer+1,x 				; get next character
.b716	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b718	90 d4		bcc $b6ee			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.b71a	c9 3f		cmp #$3f			cmp 	#'>'+1
.b71c	b0 d0		bcs $b6ee			bcs 	_TKStandardPunctuation
.b71e	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b721	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b723	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b724	7d aa 05	adc $05aa,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b727	38		sec				sec
.b728	e9 3c		sbc #$3c			sbc 	#'<'
.b72a	20 99 b8	jsr $b899			jsr 	TOKWriteByte 				; this is in the range 0-7
.b72d	e8		inx				inx 								; consume both
.b72e	e8		inx				inx
.b72f	80 96		bra $b6c7			bra 	_TKTokeniseLoop
.b731	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b733	20 99 b8	jsr $b899			jsr 	TOKWriteByte
.b736	60		rts				rts
.b737					_TKTokeniseIdentifier:
.b737	8e 80 04	stx $0480			stx 	identStart 					; save start
.b73a	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b73d					_TKCheckLoop:
.b73d	e8		inx				inx 								; look at next, we know first is identifier already.
.b73e	bd a9 05	lda $05a9,x			lda  	lineBuffer,x
.b741	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b743	f0 f8		beq $b73d			beq 	_TKCheckLoop
.b745	c9 30		cmp #$30			cmp	 	#"0"
.b747	90 0c		bcc $b755			bcc 	_TKEndIdentifier
.b749	c9 3a		cmp #$3a			cmp 	#"9"+1
.b74b	90 f0		bcc $b73d			bcc 	_TKCheckLoop
.b74d	c9 41		cmp #$41			cmp	 	#"A"
.b74f	90 04		bcc $b755			bcc 	_TKEndIdentifier
.b751	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b753	90 e8		bcc $b73d			bcc 	_TKCheckLoop
.b755					_TKEndIdentifier:
.b755	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b758	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b75a	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b75c	f0 06		beq $b764			beq 	_TKHasTypeCharacter
.b75e	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b760	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b762	d0 07		bne $b76b			bne 	_TKNoTypeCharacter
.b764					_TKHasTypeCharacter:
.b764	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b767	e8		inx				inx 								; consume the type character
.b768	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b76b					_TKNoTypeCharacter:
.b76b	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b76d	d0 09		bne $b778			bne 	_TKNoArray
.b76f	e8		inx				inx 								; skip the (
.b770	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.b773	09 04		ora #$04			ora 	#$04
.b775	8d 84 04	sta $0484			sta 	identTypeByte
.b778					_TKNoArray:
.b778	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b77b	20 15 b8	jsr $b815			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b77e	a0 ba		ldy #$ba			ldy 	#(KeywordSet0) >> 8
.b780	a9 f9		lda #$f9			lda 	#(KeywordSet0) & $FF
.b782	20 49 b6	jsr $b649			jsr 	TOKSearchTable
.b785	a2 00		ldx #$00			ldx 	#0
.b787	b0 1f		bcs $b7a8			bcs 	_TKFoundToken
.b789	a0 bc		ldy #$bc			ldy 	#(KeywordSet1) >> 8
.b78b	a9 f6		lda #$f6			lda 	#(KeywordSet1) & $FF
.b78d	20 49 b6	jsr $b649			jsr 	TOKSearchTable
.b790	a2 81		ldx #$81			ldx 	#$81
.b792	b0 14		bcs $b7a8			bcs 	_TKFoundToken
.b794	a0 bd		ldy #$bd			ldy 	#(KeywordSet2) >> 8
.b796	a9 4e		lda #$4e			lda 	#(KeywordSet2) & $FF
.b798	20 49 b6	jsr $b649			jsr 	TOKSearchTable
.b79b	a2 82		ldx #$82			ldx 	#$82
.b79d	b0 09		bcs $b7a8			bcs 	_TKFoundToken
.b79f	20 a5 b8	jsr $b8a5			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b7a2	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b7a5	4c c7 b6	jmp $b6c7			jmp 	_TKTokeniseLoop 			; and go round again.
.b7a8					_TKFoundToken:
.b7a8	48		pha				pha 								; save token
.b7a9	8a		txa				txa 								; shift in X, is there one ?
.b7aa	f0 03		beq $b7af			beq 	_TKNoTShift
.b7ac	20 99 b8	jsr $b899			jsr 	TOKWriteByte 				; if so, write it out
.b7af					_TKNoTShift:
.b7af	68		pla				pla 								; restore and write token
.b7b0	20 99 b8	jsr $b899			jsr 	TOKWriteByte
.b7b3	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b7b6	4c c7 b6	jmp $b6c7			jmp 	_TKTokeniseLoop 			; and go round again.
.b7b9					TOKTokenString:
.b7b9	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b7bb	20 99 b8	jsr $b899			jsr 	TOKWriteByte
.b7be	e8		inx				inx									; start of quoted string.
.b7bf	da		phx				phx 								; push start of string on top
.b7c0	ca		dex				dex 								; because we pre-increment
.b7c1					_TSFindEnd:
.b7c1	e8		inx				inx
.b7c2	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character
.b7c5	f0 04		beq $b7cb			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.b7c7	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.b7c9	d0 f6		bne $b7c1			bne 	_TSFindEnd
.b7cb					_TSEndOfString:
.b7cb	7a		ply				ply  								; so now Y is first character, X is character after end.
.b7cc	48		pha				pha 								; save terminating character
.b7cd	20 d5 b7	jsr $b7d5			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b7d0	68		pla				pla 								; terminating character
.b7d1	f0 01		beq $b7d4			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b7d3	e8		inx				inx
.b7d4					_TSNotQuote:
.b7d4	60		rts				rts
.b7d5					TOKWriteBlockXY:
.b7d5	86 36		stx $36				stx 	zTemp0 						; save end character
.b7d7	98		tya				tya 								; use 2's complement to work out the byte size
.b7d8	49 ff		eor #$ff			eor 	#$FF
.b7da	38		sec				sec
.b7db	65 36		adc $36				adc 	zTemp0
.b7dd	1a		inc a				inc 	a 							; one extra for NULL
.b7de	20 99 b8	jsr $b899			jsr 	TOKWriteByte
.b7e1					_TOBlockLoop:
.b7e1	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.b7e3	f0 09		beq $b7ee			beq 	_TOBlockExit
.b7e5	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y 				; write byte out.
.b7e8	20 99 b8	jsr $b899			jsr 	TOKWriteByte
.b7eb	c8		iny				iny
.b7ec	80 f3		bra $b7e1			bra 	_TOBlockLoop
.b7ee					_TOBlockExit:
.b7ee	a9 00		lda #$00			lda 	#0 							; add NULL.
.b7f0	20 99 b8	jsr $b899			jsr 	TOKWriteByte
.b7f3	60		rts				rts
.b7f4					TOKHexConstant:
.b7f4	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b7f6	20 99 b8	jsr $b899			jsr 	TOKWriteByte
.b7f9	e8		inx				inx									; start of quoted string.
.b7fa	da		phx				phx 								; push start of constant on top
.b7fb	ca		dex				dex
.b7fc					_THFindLoop:
.b7fc	e8		inx				inx 	 							; this is stored in a block, so find out how long
.b7fd	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; the hex constant is.
.b800	c9 30		cmp #$30			cmp 	#"0"
.b802	90 0c		bcc $b810			bcc 	_THFoundEnd
.b804	c9 3a		cmp #$3a			cmp 	#"9"+1
.b806	90 f4		bcc $b7fc			bcc 	_THFindLoop
.b808	c9 41		cmp #$41			cmp 	#"A"
.b80a	90 04		bcc $b810			bcc 	_THFoundEnd
.b80c	c9 47		cmp #$47			cmp 	#"F"+1
.b80e	90 ec		bcc $b7fc			bcc 	_THFindLoop
.b810					_THFoundEnd:
.b810	7a		ply				ply 								; restore start
.b811	20 d5 b7	jsr $b7d5			jsr 	TOKWriteBlockXY 			; output the block
.b814	60		rts				rts
.b815					TOKCalculateHash:
.b815	da		phx				phx
.b816	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.b819	a9 00		lda #$00			lda 	#0
.b81b					_TCHLoop:
.b81b	18		clc				clc
.b81c	7d a9 05	adc $05a9,x			adc 	lineBuffer,x
.b81f	e8		inx				inx
.b820	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b823	d0 f6		bne $b81b			bne 	_TCHLoop
.b825	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b828	fa		plx				plx
.b829	60		rts				rts
.b82a					LCLFixLineBufferCase:
.b82a	a2 00		ldx #$00			ldx 	#0
.b82c					_FLBCLoop:
.b82c	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next character
.b82f	f0 22		beq $b853			beq 	_FLBCExit 					; end of string.
.b831	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b833	f0 11		beq $b846			beq 	_FLBCInQuotes
.b835	e8		inx				inx
.b836	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b838	90 f2		bcc $b82c			bcc 	_FLBCLoop
.b83a	c9 7b		cmp #$7b			cmp 	#'z'+1
.b83c	b0 ee		bcs $b82c			bcs 	_FLBCLoop
.b83e	38		sec				sec 								; make U/C
.b83f	e9 20		sbc #$20			sbc 	#32
.b841	9d a8 05	sta $05a8,x			sta	 	lineBuffer-1,x 				; write back
.b844	80 e6		bra $b82c			bra 	_FLBCLoop
.b846					_FLBCInQuotes:
.b846	e8		inx				inx 								; advance
.b847	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next
.b84a	f0 07		beq $b853			beq 	_FLBCExit 					; exit on EOS
.b84c	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b84e	d0 f6		bne $b846			bne 	_FLBCInQuotes
.b850	e8		inx				inx 								; skip over it
.b851	80 d9		bra $b82c			bra 	_FLBCLoop
.b853					_FLBCExit:
.b853	60		rts				rts
.b854					TOKExtractLineNumber:
.b854	ad ab 04	lda $04ab			lda 	tokenLineNumber+1 			; push current value on stack
.b857	48		pha				pha
.b858	ad aa 04	lda $04aa			lda 	tokenLineNumber
.b85b	48		pha				pha
.b85c	20 92 b8	jsr $b892			jsr 	_LCLNTimes2 				; line # x 2
.b85f	20 92 b8	jsr $b892			jsr 	_LCLNTimes2 				; line # x 4
.b862	18		clc				clc 								; add stacked value
.b863	68		pla				pla
.b864	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b867	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b86a	68		pla				pla
.b86b	6d ab 04	adc $04ab			adc 	tokenLineNumber+1
.b86e	8d ab 04	sta $04ab			sta 	tokenLineNumber+1 			; line # x 5
.b871	20 92 b8	jsr $b892			jsr 	_LCLNTimes2 				; line # x 10
.b874	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get and consume character
.b877	e8		inx				inx
.b878	29 0f		and #$0f			and 	#15 						; add to line #
.b87a	18		clc				clc
.b87b	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b87e	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b881	90 03		bcc $b886			bcc 	_TLENNoCarry
.b883	ee ab 04	inc $04ab			inc 	tokenLineNumber+1
.b886					_TLENNoCarry:
.b886	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; more digits ?
.b889	c9 30		cmp #$30			cmp 	#'0'
.b88b	90 04		bcc $b891			bcc 	_TLENExit
.b88d	c9 3a		cmp #$3a			cmp 	#'9'+1
.b88f	90 c3		bcc $b854			bcc 	TOKExtractLineNumber
.b891					_TLENExit:
.b891	60		rts				rts
.b892					_LCLNTimes2:
.b892	0e aa 04	asl $04aa			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.b895	2e ab 04	rol $04ab			rol 	tokenLineNumber+1
.b898	60		rts				rts
.b899					TOKWriteByte:
.b899	da		phx				phx
.b89a	ae a9 04	ldx $04a9			ldx 	tokenOffset 				; next slot to write to
.b89d	9d a9 04	sta $04a9,x			sta 	tokenOffset,x 				; write byte out
.b8a0	ee a9 04	inc $04a9			inc 	tokenOffset 				; advance slot.
.b8a3	fa		plx				plx
.b8a4	60		rts				rts
.b8a5					TOKCheckCreateVariableRecord:
.b8a5	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b8a7	85 36		sta $36				sta 	0+zTemp0
.b8a9	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b8ab	85 37		sta $37				sta 	1+zTemp0
.b8ad					_CCVSearch:
.b8ad	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b8af	f0 2c		beq $b8dd			beq 	_CCVFail
.b8b1	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b8b3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b8b5	cd 83 04	cmp $0483			cmp 	identHash
.b8b8	d0 16		bne $b8d0			bne 	_CCVNext
.b8ba	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b8bc	ae 80 04	ldx $0480			ldx 	identStart
.b8bf					_CCVCompare:
.b8bf	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b8c2	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b8c4	e8		inx				inx 								; advance pointers
.b8c5	c8		iny				iny
.b8c6	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b8c7	d0 07		bne $b8d0			bne 	_CCVNext  					; didn't match go to next.
.b8c9	90 f4		bcc $b8bf			bcc 	_CCVCompare 				; not finished yet.
.b8cb	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b8ce	f0 41		beq $b911			beq 	_CCVFound 					; yes, we were successful
.b8d0					_CCVNext:
.b8d0	18		clc				clc
.b8d1	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b8d3	65 36		adc $36				adc 	zTemp0
.b8d5	85 36		sta $36				sta 	zTemp0
.b8d7	90 d4		bcc $b8ad			bcc 	_CCVSearch
.b8d9	e6 37		inc $37				inc 	zTemp0+1
.b8db	80 d0		bra $b8ad			bra 	_CCVSearch
.b8dd					_CCVFail:
.b8dd	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b8df	ad 83 04	lda $0483			lda 	identHash
.b8e2	91 36		sta ($36),y			sta 	(zTemp0),y
.b8e4	c8		iny				iny 								; offset 2 is the type byte
.b8e5	ad 84 04	lda $0484			lda 	identTypeByte
.b8e8	91 36		sta ($36),y			sta 	(zTemp0),y
.b8ea	c8		iny				iny
.b8eb					_CCVData:
.b8eb	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b8ed	91 36		sta ($36),y			sta 	(zTemp0),y
.b8ef	c8		iny				iny
.b8f0	c0 08		cpy #$08			cpy 	#8
.b8f2	90 f7		bcc $b8eb			bcc 	_CCVData
.b8f4	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b8f7					_CCVCopyName:
.b8f7	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b8fa	91 36		sta ($36),y			sta 	(zTemp0),y
.b8fc	e8		inx				inx
.b8fd	c8		iny				iny
.b8fe	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b901	d0 f4		bne $b8f7			bne 	_CCVCopyName
.b903	98		tya				tya 								; patch offset
.b904	92 36		sta ($36)			sta 	(zTemp0)
.b906	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b908	91 36		sta ($36),y			sta 	(zTemp0),y
.b90a	88		dey				dey
.b90b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b90d	09 80		ora #$80			ora 	#$80
.b90f	91 36		sta ($36),y			sta 	(zTemp0),y
.b911					_CCVFound:
.b911	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b913	38		sec				sec
.b914	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b916	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b918	20 99 b8	jsr $b899			jsr 	TOKWriteByte
.b91b	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b91d	20 99 b8	jsr $b899			jsr 	TOKWriteByte
.b920	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b921					SNDCheckChannel:
.b921	aa		tax				tax
.b922	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b925	d0 38		bne $b95f			bne 	_SNDCCExit
.b927	da		phx				phx 								; save current channel
.b928	8a		txa				txa 								; put in A
.b929	20 a5 b9	jsr $b9a5			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b92c	68		pla				pla 								; channel # in A
.b92d	90 30		bcc $b95f			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b92f	a8		tay				tay 								; Y is the channel #
.b930	bd ff 06	lda $06ff,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b933	99 fe 07	sta $07fe,y			sta 	SNDPitchLow,y
.b936	bd 00 07	lda $0700,x			lda 	SNDQueue+2,x
.b939	99 02 08	sta $0802,y			sta 	SNDPitchHigh,y
.b93c	bd 01 07	lda $0701,x			lda 	SNDQueue+3,x
.b93f	99 06 08	sta $0806,y			sta 	SNDVolume,y
.b942	bd 02 07	lda $0702,x			lda 	SNDQueue+4,x
.b945	99 0a 08	sta $080a,y			sta 	SNDTimeLeft,y
.b948	bd 03 07	lda $0703,x			lda 	SNDQueue+5,x
.b94b	99 0e 08	sta $080e,y			sta 	SNDAdjustLow,y
.b94e	bd 04 07	lda $0704,x			lda 	SNDQueue+6,x
.b951	99 12 08	sta $0812,y			sta 	SNDAdjustHigh,y
.b954	5a		phy				phy 								; save channel #
.b955	20 bf b9	jsr $b9bf			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b958	ce fd 06	dec $06fd			dec 	SNDLength 					; reduce the queue length.
.b95b	68		pla				pla
.b95c	20 60 b9	jsr $b960			jsr 	SNDUpdateNote 				; update channel A
.b95f					_SNDCCExit:
.b95f	60		rts				rts
.b960					SNDUpdateNote:
.b960	aa		tax				tax 								; so we can access records
.b961	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b962	0a		asl a				asl 	a
.b963	0a		asl a				asl 	a
.b964	0a		asl a				asl 	a
.b965	0a		asl a				asl 	a
.b966	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b969	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; are we silent
.b96c	f0 2e		beq $b99c			beq 	_SNDUNIsSilent
.b96e	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; push channel bits on stack
.b971	48		pha				pha
.b972	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b975	29 0f		and #$0f			and 	#$0F
.b977	0d fc 06	ora $06fc			ora 	SNDChannelBits 				; set channel bits
.b97a	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b97c	20 09 ba	jsr $ba09			jsr 	SNDWritePorts
.b97f	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b982	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b985	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.b988	4e fc 06	lsr $06fc			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b98b	6a		ror a				ror 	a
.b98c	4e fc 06	lsr $06fc			lsr 	SNDChannelBits
.b98f	6a		ror a				ror 	a
.b990	4a		lsr a				lsr 	a 							; put in bits 0-5
.b991	4a		lsr a				lsr 	a
.b992	20 09 ba	jsr $ba09			jsr 	SNDWritePorts 				; write as rest of pitch register
.b995	68		pla				pla
.b996	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b998	20 09 ba	jsr $ba09			jsr 	SNDWritePorts
.b99b	60		rts				rts
.b99c					_SNDUNIsSilent:
.b99c	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; channel bits
.b99f	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b9a1	20 09 ba	jsr $ba09			jsr 	SNDWritePorts 				; write to the ports
.b9a4	60		rts				rts
.b9a5					SNDFindNextNoteForA:
.b9a5	ac fd 06	ldy $06fd			ldy 	SNDLength 					; queue size into Y
.b9a8	f0 13		beq $b9bd			beq 	_SNDFNNFail 				; queue empty.
.b9aa	a2 00		ldx #$00			ldx 	#0
.b9ac					_SNDFNNSearch:
.b9ac	dd fe 06	cmp $06fe,x			cmp 	SNDQueue,x 					; does it match the channel
.b9af	38		sec				sec
.b9b0	f0 0c		beq $b9be			beq 	_SNDFNNExit 				; if so exit with CS.
.b9b2	e8		inx				inx 								; next queue slot.
.b9b3	e8		inx				inx
.b9b4	e8		inx				inx
.b9b5	e8		inx				inx
.b9b6	e8		inx				inx
.b9b7	e8		inx				inx
.b9b8	e8		inx				inx
.b9b9	e8		inx				inx
.b9ba	88		dey				dey 								; done the whole queue
.b9bb	d0 ef		bne $b9ac			bne 	_SNDFNNSearch 				; no, go back.
.b9bd					_SNDFNNFail:
.b9bd	18		clc				clc
.b9be					_SNDFNNexit:
.b9be	60		rts				rts
.b9bf					SNDDeleteXFromQueue:
.b9bf	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b9c1	f0 09		beq $b9cc			beq 	_SNDDXExit
.b9c3	bd 06 07	lda $0706,x			lda 	SNDQueue+8,x
.b9c6	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9c9	e8		inx				inx
.b9ca	80 f3		bra $b9bf			bra 	SNDDeleteXFromQueue
.b9cc					_SNDDXExit:
.b9cc	60		rts				rts
.06fc					SNDChannelBits:
>06fc							.fill 	1
.b9cd					SNDQueueRequest:
.b9cd	86 36		stx $36				stx 	zTemp0						; save queue address
.b9cf	84 37		sty $37				sty 	zTemp0+1
.b9d1	ae fd 06	ldx $06fd			ldx 	SNDLength 					; queue is full, can't take any more.
.b9d4	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b9d6	f0 21		beq $b9f9			beq 	_SNDQRExit
.b9d8	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b9da	48		pha				pha
.b9db	8a		txa				txa  								; get offset in queue buffer/
.b9dc	0a		asl a				asl 	a
.b9dd	0a		asl a				asl 	a
.b9de	0a		asl a				asl 	a
.b9df	aa		tax				tax
.b9e0	68		pla				pla 								; get back and push again
.b9e1	48		pha				pha
.b9e2	9d fe 06	sta $06fe,x			sta 	SNDQueue+0,x 				; save the channel #
.b9e5	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b9e7					_SNDQCopy:
.b9e7	b1 36		lda ($36),y			lda 	(zTemp0),y
.b9e9	e8		inx				inx
.b9ea	c8		iny				iny
.b9eb	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9ee	c0 06		cpy #$06			cpy 	#6
.b9f0	d0 f5		bne $b9e7			bne 	_SNDQCopy
.b9f2	ee fd 06	inc $06fd			inc 	SNDLength 					; bump queue length.
.b9f5	68		pla				pla 								; get channel # back
.b9f6	20 21 b9	jsr $b921			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b9f9					_SNDQRExit:
.b9f9	60		rts				rts
.b9fa					SNDSilenceChannel:
.b9fa	aa		tax				tax 								; zero time left.
.b9fb	9e 0a 08	stz $080a,x			stz 	SNDTimeLeft,x
.b9fe	0a		asl a				asl 	a 							; shift into position
.b9ff	0a		asl a				asl 	a
.ba00	0a		asl a				asl 	a
.ba01	0a		asl a				asl 	a
.ba02	0a		asl a				asl 	a
.ba03	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.ba05	20 09 ba	jsr $ba09			jsr 	SNDWritePorts
.ba08	60		rts				rts
.ba09					SNDWritePorts:
.ba09	64 01		stz $01				stz 	1
.ba0b	8d 00 d6	sta $d600			sta 	$D600
.ba0e	8d 10 d6	sta $d610			sta 	$D610
.ba11	60		rts				rts
.ba12					SNDCommand:
.ba12	da		phx				phx
.ba13	5a		phy				phy
.ba14	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.ba16	f0 1d		beq $ba35			beq 	_SNDInitialise
.ba18	90 28		bcc $ba42			bcc 	_SNDExit
.ba1a	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.ba1c	f0 17		beq $ba35			beq 	_SNDSilence
.ba1e	b0 22		bcs $ba42			bcs 	_SNDExit
.ba20	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.ba22	b0 09		bcs $ba2d			bcs 	_SNDQueryPlay
.ba24	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.ba26	b0 1a		bcs $ba42			bcs 	_SNDExit
.ba28	20 cd b9	jsr $b9cd			jsr 	SNDQueueRequest
.ba2b	80 15		bra $ba42			bra 	_SNDExit
.ba2d					_SNDQueryPlay:
.ba2d	29 03		and #$03			and 	#3 							; get channel #
.ba2f	aa		tax				tax
.ba30	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.ba33	80 0d		bra $ba42			bra 	_SNDExit
.ba35					_SNDInitialise:
.ba35					_SNDSilence:
.ba35	9c fd 06	stz $06fd			stz 	SNDLength 					; empty the queue.
.ba38	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.ba3a					_SNDSilenceLoop:
.ba3a	48		pha				pha
.ba3b	20 fa b9	jsr $b9fa			jsr 	SNDSilenceChannel
.ba3e	68		pla				pla
.ba3f	3a		dec a				dec 	a
.ba40	10 f8		bpl $ba3a			bpl 	_SNDSilenceLoop
.ba42					_SNDExit:
.ba42	7a		ply				ply
.ba43	fa		plx				plx
.ba44	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fd					SNDLength:
>06fd							.fill 	1
.06fe					SNDQueue:
>06fe							.fill 	SNDQueueSize * 8
.07fe					SNDPitchLow:
>07fe							.fill 	4
.0802					SNDPitchHigh:
>0802							.fill 	4
.0806					SNDVolume:
>0806							.fill 	4
.080a					SNDTimeLeft:
>080a							.fill 	4
.080e					SNDAdjustLow:
>080e							.fill 	4
.0812					SNDAdjustHigh:
>0812							.fill 	4
.ba45					SNDUpdate:
.ba45	ad 0a 08	lda $080a			lda 	SNDTimeLeft+0 				; look at time remaining
.ba48	f0 05		beq $ba4f			beq 	_SNDUNot0 					; not playing
.ba4a	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.ba4c	20 6e ba	jsr $ba6e			jsr 	SNDUpdateChannel 			; update it.
.ba4f					_SNDUNot0:
.ba4f	ad 0b 08	lda $080b			lda 	SNDTimeLeft+1
.ba52	f0 05		beq $ba59			beq 	_SNDUNot1
.ba54	a2 01		ldx #$01			ldx 	#1
.ba56	20 6e ba	jsr $ba6e			jsr 	SNDUpdateChannel
.ba59					_SNDUNot1:
.ba59	ad 0c 08	lda $080c			lda 	SNDTimeLeft+2
.ba5c	f0 05		beq $ba63			beq 	_SNDUNot2
.ba5e	a2 02		ldx #$02			ldx 	#2
.ba60	20 6e ba	jsr $ba6e			jsr 	SNDUpdateChannel
.ba63					_SNDUNot2:
.ba63	ad 0d 08	lda $080d			lda 	SNDTimeLeft+3
.ba66	f0 05		beq $ba6d			beq 	_SNDUNot3
.ba68	a2 03		ldx #$03			ldx 	#3
.ba6a	20 6e ba	jsr $ba6e			jsr 	SNDUpdateChannel
.ba6d					_SNDUNot3:
.ba6d	60		rts				rts
.ba6e					SNDUpdateChannel:
.ba6e	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.ba70	f0 2c		beq $ba9e			beq 	_SNDUCExit
.ba72	3a		dec a				dec 	a 							; decrement and update timer
.ba73	9d 0a 08	sta $080a,x			sta 	SNDTimeLeft,x
.ba76	f0 1d		beq $ba95			beq 	_SNDUCUpdate 				; if zero, silence channel
.ba78	bd 0e 08	lda $080e,x			lda 	SNDAdjustLow,x 				; adjust ?
.ba7b	1d 12 08	ora $0812,x			ora 	SNDAdjustHigh,x
.ba7e	f0 1e		beq $ba9e			beq 	_SNDUCExit 					; if zero carry on at current tone.
.ba80	18		clc				clc 								; add adjust, forcing into a 10 bit range
.ba81	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.ba84	7d 0e 08	adc $080e,x			adc 	SNDAdjustLow,x
.ba87	9d fe 07	sta $07fe,x			sta 	SNDPitchLow,x
.ba8a	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x
.ba8d	7d 12 08	adc $0812,x			adc 	SNDAdjustHigh,x
.ba90	29 03		and #$03			and 	#3
.ba92	9d 02 08	sta $0802,x			sta 	SNDPitchHigh,x
.ba95					_SNDUCUpdate:
.ba95	8a		txa				txa 								; which channel.
.ba96	48		pha				pha
.ba97	20 60 b9	jsr $b960			jsr 	SNDUpdateNote 				; update the current note
.ba9a	68		pla				pla
.ba9b	20 21 b9	jsr $b921			jsr 	SNDCheckChannel 			; more to do ?
.ba9e					_SNDUCExit:
.ba9e	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
