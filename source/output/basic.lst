
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$34000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" "-D TILEMAP_ADDRESS=\$24000" "-D TILEIMAGES_ADDRESS=\$26000" -q -b -Wall -c -C -D HARDWARE=0 -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Sat Jun 21 15:22:30 2025

;Offset	;PC	;Hex		;Monitor	;Source

;******  Command line definitions

=0						AUTORUN=0
=$e000						 MONITOR_ADDRESS=$E000
=$f000						 LOCKOUT_ADDRESS=$F000
=$34000						 BASIC_ADDRESS=$34000
=$28000						 SOURCE_ADDRESS=$28000
=$30000						 SPRITE_ADDRESS=$30000
=$24000						 TILEMAP_ADDRESS=$24000
=$26000						 TILEIMAGES_ADDRESS=$26000
=0						HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30						ZeroPageMandatory = $30
=$50						ZeroPagePreference = $50
=$200						ArgumentStorage = $200
=$400						ControlStorage = $400
=$420						MemoryStorage = $420
=$2000						BasicStart = $2000
=$8000						BasicEnd = $8000
=$8000						CodeStart = $8000
=$1000						VariableSpace = $1000
=$2000						EndVariableSpace = $2000
=16						MathStackSize = 16
=512						BasicStackSize = 512
=3584						BasicStackBase = $1000-BasicStackSize
=80						MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030						codePtr:
>0030								.fill 	4
.0034						basicStack:
>0034								.fill 	2
.0036						zTemp0:
>0036								.fill 	2
.0038						zTemp1:
>0038								.fill 	2
.003a						zTemp2:
>003a								.fill 	2
.003c						zsTemp:
>003c								.fill 	2
.003e						zaTemp:
>003e								.fill 	2
=$30						safePtr = codePtr 							; minimise direct tinkering
=$80						NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20						NSBIsReference = $20 						; bit 5 : is a reference
=$10						NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18						NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03						NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04						NSBIsArray = $04
=$00						NSTInteger = $00 							; base types for bits 3..4
=$08						NSTFloat = $08
=$10						NSTString = $10
=$18						NSTProcedure = $18
.0050						NSStatus:
>0050								.fill 	MathStackSize
.0060						NSMantissa0:
>0060								.fill 	MathStackSize 				; (this is my integer mantissa system)
.0070						NSMantissa1:
>0070								.fill 	MathStackSize
.0080						NSMantissa2:
>0080								.fill 	MathStackSize
.0090						NSMantissa3:
>0090								.fill 	MathStackSize
.00a0						NSExponent:
>00a0								.fill 	MathStackSize
.0420						identStart:
>0420								.fill 	1
.0421						identTypeStart:
>0421								.fill 	1
.0422						identTypeEnd:
>0422								.fill 	1
.0423						identHash:
>0423								.fill 	1
.0424						identTypeByte:
>0424								.fill 	1	 						; (see tokenising.pdf)
.0425						encodeState:
>0425								.fill 	1
.0426						digitTemp:
>0426								.fill 	1
.0427						decimalCount:
>0427								.fill 	1
.0428						lowMemPtr:
>0428								.fill 	2
.042a						stringMemory:
>042a								.fill 	2
.042c						stringInitialised:
>042c								.fill 	1
.042d						stringTempPointer:
>042d								.fill 	2
.042f						breakCheck:
>042f								.fill 	1
.0430						decimalPlaces:
>0430								.fill 	1
.0431						dbOffset:
>0431								.fill 	1
.0432						lastParameter:
>0432								.fill 	1
.0433						dataPointer:
>0433								.fill 	5
.0438						inDataStatement:
>0438								.fill 	1
.0439						tbOffset:
>0439								.fill 	1
.043a						AssemblerAddress:
>043a								.fill 	2
.043c						AssemblerControl:
>043c								.fill 	1
.043d						ParamStart:
>043d								.fill 	2
.043f						IsGroup1:
>043f								.fill 	1
.0440						BaseOpcode:
>0440								.fill 	1
.0441						ModeMask:
>0441								.fill 	1
.0442						listIndent:
>0442								.fill 	1
.0443						lcLastCharacter:
>0443								.fill 	1
.0444						isPrintFlag:
>0444								.fill 	1
.0445						currentListColour:
>0445								.fill 	1
.0446						tokenOffset:
>0446								.fill 	1
.0447						tokenLineNumber:
>0447								.fill 	2
.0449						tokenBuffer:
>0449								.fill 	253
.0546						lineBuffer:
>0546								.fill 	253
.0643						numberBuffer:
>0643								.fill 	34
.0665						decimalBuffer:
>0665								.fill 	16
.0675						programChanged:
>0675								.fill	1							; tracks whether program has been changed since last save

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80						AM_ISZP = $80
=$40						AM_ISG1 = $40
=$20						AM_ISG2 = $20
=224						AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228						AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40						AM_ACC = AM_ISG2+$08
=108						AM_ABS = AM_ISG1+AM_ISG2+$0C
=208						AM_INDY = AM_ISZP+AM_ISG1+$10
=244						AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120						AM_ABSY = AM_ISG1+AM_ISG2+$18
=124						AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209						AM_IND = AM_ISZP+AM_ISG1+$11
=$80						AM_ZEROY = AM_ISZP
=$01						AM_INDABS = $01
=$02						AM_INDABSX = $02
=192						AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1						ERRID_BREAK = 1
=2						ERRID_SYNTAX = 2
=3						ERRID_DIVZERO = 3
=4						ERRID_RANGE = 4
=5						ERRID_TYPE = 5
=6						ERRID_MEMORY = 6
=7						ERRID_ARGUMENT = 7
=8						ERRID_STOP = 8
=9						ERRID_STRING = 9
=10						ERRID_ASSERT = 10
=11						ERRID_DATA = 11
=12						ERRID_NOTDONE = 12
=13						ERRID_LINE = 13
=14						ERRID_GOSUB = 14
=15						ERRID_REPEAT = 15
=16						ERRID_WHILE = 16
=17						ERRID_FOR = 17
=18						ERRID_STACK = 18
=19						ERRID_STRUCT = 19
=20						ERRID_PROC = 20
=21						ERRID_REDEFINE = 21
=22						ERRID_ARRAYSIZE = 22
=23						ERRID_ARRAYIDX = 23
=24						ERRID_ARRAYDEC = 24
=25						ERRID_NOTFOUND = 25
=26						ERRID_DRIVEIO = 26
=27						ERRID_VERIFY = 27
=28						ERRID_NOPROGRAM = 28
=29						ERRID_PARAMETERS = 29
=30						ERRID_TOOCOMPLEX = 30
=31						ERRID_INITERROR = 31

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00						KWD_LESSLESS                         = $00; $00 <<
=$01						KWD_LESSEQUAL                        = $01; $01 <=
=$02						KWD_LESSGREATER                      = $02; $02 <>
=$03						KWD_PLINGPLING3                      = $03; $03 !!3
=$04						KWD_GREATERLESS                      = $04; $04 ><
=$05						KWD_GREATEREQUAL                     = $05; $05 >=
=$06						KWD_GREATERGREATER                   = $06; $06 >>
=$07						KWD_PLINGPLING7                      = $07; $07 !!7
=$08						KWD_PLINGPLING8                      = $08; $08 !!8
=$09						KWD_PLINGPLING9                      = $09; $09 !!9
=$0a						KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b						KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c						KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d						KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e						KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f						KWD_PLINGPLING15                     = $0f; $0f !!15
=$10						KWD_ATCH                             = $10; $10 @
=$11						KWD_PLINGPLING17                     = $11; $11 !!17
=$12						KWD_PLINGPLING18                     = $12; $12 !!18
=$13						KWD_LSQPAREN                         = $13; $13 [
=$14						KWD_BACKSLASH                        = $14; $14 \
=$15						KWD_RSQPAREN                         = $15; $15 ]
=$16						KWD_HAT                              = $16; $16 ^
=$17						KWD_UNDERSCORE                       = $17; $17 _
=$18						KWD_BQUOTE                           = $18; $18 `
=$19						KWD_PLINGPLING25                     = $19; $19 !!25
=$1a						KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b						KWD_LCURLY                           = $1b; $1b {
=$1c						KWD_BAR                              = $1c; $1c |
=$1d						KWD_RCURLY                           = $1d; $1d }
=$1e						KWD_TILDE                            = $1e; $1e ~
=$21						KWD_PLING                            = $21; $21 !
=$22						KWD_DQUOTE                           = $22; $22 "
=$23						KWD_HASH                             = $23; $23 #
=$24						KWD_DOLLAR                           = $24; $24 $
=$25						KWD_PERCENT                          = $25; $25 %
=$26						KWD_AMPERSAND                        = $26; $26 &
=$27						KWD_QUOTE                            = $27; $27 '
=$28						KWD_LPAREN                           = $28; $28 (
=$29						KWD_RPAREN                           = $29; $29 )
=$2a						KWD_STAR                             = $2a; $2a *
=$2b						KWD_PLUS                             = $2b; $2b +
=$2c						KWD_COMMA                            = $2c; $2c ,
=$2d						KWD_MINUS                            = $2d; $2d -
=$2e						KWD_PERIOD                           = $2e; $2e .
=$2f						KWD_SLASH                            = $2f; $2f /
=$30						KWD_0                                = $30; $30 0
=$31						KWD_1                                = $31; $31 1
=$32						KWD_2                                = $32; $32 2
=$33						KWD_3                                = $33; $33 3
=$34						KWD_4                                = $34; $34 4
=$35						KWD_5                                = $35; $35 5
=$36						KWD_6                                = $36; $36 6
=$37						KWD_7                                = $37; $37 7
=$38						KWD_8                                = $38; $38 8
=$39						KWD_9                                = $39; $39 9
=$3a						KWD_COLON                            = $3a; $3a :
=$3b						KWD_SEMICOLON                        = $3b; $3b ;
=$3c						KWD_LESS                             = $3c; $3c <
=$3d						KWD_EQUAL                            = $3d; $3d =
=$3e						KWD_GREATER                          = $3e; $3e >
=$3f						KWD_QMARK                            = $3f; $3f ?
=$83						KWD_ABSLPAREN                        = $83; $83 ABS(
=$84						KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85						KWD_ASCLPAREN                        = $85; $85 ASC(
=$86						KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87						KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88						KWD_FALSE                            = $88; $88 FALSE
=$89						KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a						KWD_GETDOLLARLPAREN                  = $8a; $8a GET$(
=$8b						KWD_GETLPAREN                        = $8b; $8b GET(
=$8c						KWD_GETDATEDOLLARLPAREN              = $8c; $8c GETDATE$(
=$8d						KWD_GETTIMEDOLLARLPAREN              = $8d; $8d GETTIME$(
=$8e						KWD_HITLPAREN                        = $8e; $8e HIT(
=$8f						KWD_INKEYDOLLARLPAREN                = $8f; $8f INKEY$(
=$90						KWD_INKEYLPAREN                      = $90; $90 INKEY(
=$91						KWD_INTLPAREN                        = $91; $91 INT(
=$92						KWD_ISVALLPAREN                      = $92; $92 ISVAL(
=$93						KWD_ITEMCOUNTLPAREN                  = $93; $93 ITEMCOUNT(
=$94						KWD_ITEMGETDOLLARLPAREN              = $94; $94 ITEMGET$(
=$95						KWD_JOYBLPAREN                       = $95; $95 JOYB(
=$96						KWD_JOYXLPAREN                       = $96; $96 JOYX(
=$97						KWD_JOYYLPAREN                       = $97; $97 JOYY(
=$98						KWD_KEYDOWNLPAREN                    = $98; $98 KEYDOWN(
=$99						KWD_LEFTDOLLARLPAREN                 = $99; $99 LEFT$(
=$9a						KWD_LENLPAREN                        = $9a; $9a LEN(
=$9b						KWD_MAXLPAREN                        = $9b; $9b MAX(
=$9c						KWD_MIDDOLLARLPAREN                  = $9c; $9c MID$(
=$9d						KWD_MINLPAREN                        = $9d; $9d MIN(
=$9e						KWD_NOTLPAREN                        = $9e; $9e NOT(
=$9f						KWD_PEEKLPAREN                       = $9f; $9f PEEK(
=$a0						KWD_PEEKDLPAREN                      = $a0; $a0 PEEKD(
=$a1						KWD_PEEKLLPAREN                      = $a1; $a1 PEEKL(
=$a2						KWD_PEEKWLPAREN                      = $a2; $a2 PEEKW(
=$a3						KWD_PLAYINGLPAREN                    = $a3; $a3 PLAYING(
=$a4						KWD_RANDOMLPAREN                     = $a4; $a4 RANDOM(
=$a5						KWD_RIGHTDOLLARLPAREN                = $a5; $a5 RIGHT$(
=$a6						KWD_RNDLPAREN                        = $a6; $a6 RND(
=$a7						KWD_SGNLPAREN                        = $a7; $a7 SGN(
=$a8						KWD_SPCLPAREN                        = $a8; $a8 SPC(
=$a9						KWD_STRDOLLARLPAREN                  = $a9; $a9 STR$(
=$aa						KWD_TILELPAREN                       = $aa; $aa TILE(
=$ab						KWD_TIMERLPAREN                      = $ab; $ab TIMER(
=$ac						KWD_TRUE                             = $ac; $ac TRUE
=$ad						KWD_VALLPAREN                        = $ad; $ad VAL(
=$ae						KWD_FOR                              = $ae; $ae FOR
=$af						KWD_IF                               = $af; $af IF
=$b0						KWD_PROC                             = $b0; $b0 PROC
=$b1						KWD_REPEAT                           = $b1; $b1 REPEAT
=$b2						KWD_WHILE                            = $b2; $b2 WHILE
=$b3						KWD_ENDIF                            = $b3; $b3 ENDIF
=$b4						KWD_ENDPROC                          = $b4; $b4 ENDPROC
=$b5						KWD_NEXT                             = $b5; $b5 NEXT
=$b6						KWD_THEN                             = $b6; $b6 THEN
=$b7						KWD_UNTIL                            = $b7; $b7 UNTIL
=$b8						KWD_WEND                             = $b8; $b8 WEND
=$b9						KWD_AT                               = $b9; $b9 AT
=$ba						KWD_BY                               = $ba; $ba BY
=$bb						KWD_CALL                             = $bb; $bb CALL
=$bc						KWD_CIRCLE                           = $bc; $bc CIRCLE
=$bd						KWD_CLEAR                            = $bd; $bd CLEAR
=$be						KWD_COLOR                            = $be; $be COLOR
=$bf						KWD_COLOUR                           = $bf; $bf COLOUR
=$c0						KWD_DATA                             = $c0; $c0 DATA
=$c1						KWD_DIM                              = $c1; $c1 DIM
=$c2						KWD_DOWNTO                           = $c2; $c2 DOWNTO
=$c3						KWD_ELSE                             = $c3; $c3 ELSE
=$c4						KWD_FROM                             = $c4; $c4 FROM
=$c5						KWD_GFX                              = $c5; $c5 GFX
=$c6						KWD_HERE                             = $c6; $c6 HERE
=$c7						KWD_IMAGE                            = $c7; $c7 IMAGE
=$c8						KWD_LET                              = $c8; $c8 LET
=$c9						KWD_LINE                             = $c9; $c9 LINE
=$ca						KWD_LOCAL                            = $ca; $ca LOCAL
=$cb						KWD_MEMCOPY                          = $cb; $cb MEMCOPY
=$cc						KWD_OFF                              = $cc; $cc OFF
=$cd						KWD_ON                               = $cd; $cd ON
=$ce						KWD_OUTLINE                          = $ce; $ce OUTLINE
=$cf						KWD_PALETTE                          = $cf; $cf PALETTE
=$d0						KWD_PLOT                             = $d0; $d0 PLOT
=$d1						KWD_POKE                             = $d1; $d1 POKE
=$d2						KWD_POKED                            = $d2; $d2 POKED
=$d3						KWD_POKEL                            = $d3; $d3 POKEL
=$d4						KWD_POKEW                            = $d4; $d4 POKEW
=$d5						KWD_READ                             = $d5; $d5 READ
=$d6						KWD_RECT                             = $d6; $d6 RECT
=$d7						KWD_REM                              = $d7; $d7 REM
=$d8						KWD_SOLID                            = $d8; $d8 SOLID
=$d9						KWD_SOUND                            = $d9; $d9 SOUND
=$da						KWD_SPRITE                           = $da; $da SPRITE
=$db						KWD_STEP                             = $db; $db STEP
=$dc						KWD_TEXT                             = $dc; $dc TEXT
=$dd						KWD_TO                               = $dd; $dd TO
=$83						KWD1_ASSEMBLE                         = $83; $83 ASSEMBLE
=$84						KWD1_ASSERT                           = $84; $84 ASSERT
=$85						KWD1_BITMAP                           = $85; $85 BITMAP
=$86						KWD1_BLOAD                            = $86; $86 BLOAD
=$87						KWD1_BSAVE                            = $87; $87 BSAVE
=$88						KWD1_CLS                              = $88; $88 CLS
=$89						KWD1_CPRINT                           = $89; $89 CPRINT
=$8a						KWD1_CURSOR                           = $8a; $8a CURSOR
=$8b						KWD1_DIR                              = $8b; $8b DIR
=$8c						KWD1_DRIVE                            = $8c; $8c DRIVE
=$8d						KWD1_END                              = $8d; $8d END
=$8e						KWD1_EXPLODE                          = $8e; $8e EXPLODE
=$8f						KWD1_GO                               = $8f; $8f GO
=$90						KWD1_GOSUB                            = $90; $90 GOSUB
=$91						KWD1_GOTO                             = $91; $91 GOTO
=$92						KWD1_HIMEM                            = $92; $92 HIMEM
=$93						KWD1_INPUT                            = $93; $93 INPUT
=$94						KWD1_LIST                             = $94; $94 LIST
=$95						KWD1_LOAD                             = $95; $95 LOAD
=$96						KWD1_MDELTA                           = $96; $96 MDELTA
=$97						KWD1_MOUSE                            = $97; $97 MOUSE
=$98						KWD1_NEW                              = $98; $98 NEW
=$99						KWD1_OPTION                           = $99; $99 OPTION
=$9a						KWD1_PING                             = $9a; $9a PING
=$9b						KWD1_PRINT                            = $9b; $9b PRINT
=$9c						KWD1_RESTORE                          = $9c; $9c RESTORE
=$9d						KWD1_RETURN                           = $9d; $9d RETURN
=$9e						KWD1_RUN                              = $9e; $9e RUN
=$9f						KWD1_SAVE                             = $9f; $9f SAVE
=$a0						KWD1_SETDATE                          = $a0; $a0 SETDATE
=$a1						KWD1_SETTIME                          = $a1; $a1 SETTIME
=$a2						KWD1_SHOOT                            = $a2; $a2 SHOOT
=$a3						KWD1_SPRITES                          = $a3; $a3 SPRITES
=$a4						KWD1_STOP                             = $a4; $a4 STOP
=$a5						KWD1_TILE                             = $a5; $a5 TILE
=$a6						KWD1_TILES                            = $a6; $a6 TILES
=$a7						KWD1_TRY                              = $a7; $a7 TRY
=$a8						KWD1_VERIFY                           = $a8; $a8 VERIFY
=$a9						KWD1_XGO                              = $a9; $a9 XGO
=$aa						KWD1_XLOAD                            = $aa; $aa XLOAD
=$ab						KWD1_ZAP                              = $ab; $ab ZAP

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80						KWC_EOL = $80
=$81						KWC_SHIFT1 = $81
=$82						KWC_SHIFT2 = $82
=$ff						KWC_STRING = $FF
=$fe						KWC_HEXCONST = $FE
=$ae						KWC_FIRST_STRUCTURE = $ae
=$b3						KWC_FIRST_STRUCTURE_DEC = $b3
=$b8						KWC_LAST_STRUCTURE = $b8
=$83						KWC_FIRST_UNARY = $83
=$ad						KWC_LAST_UNARY = $ad

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0						STK_GOSUB = $E0
=$d0						STK_FOR = $D0
=$c0						STK_REPEAT = $C0
=$b0						STK_PROC = $B0
=$a0						STK_WHILE = $A0
=$01						STK_LOCALN = $01
=$02						STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000						F256Header:
>8000		f2 56						.text	$f2,$56         			; Signature
>8002		04						.byte   4               			; 4 blocks
>8003		04						.byte   4               			; mount at $8000
>8004		40 80						.word   Boot 	      				; Start here
>8006		01						.byte   1 			               	; version
>8007		00						.byte   0               			; reserved
>8008		00						.byte   0               			; reserved
>8009		00						.byte   0               			; reserved
>800a		62 61 73 69 63 00				.text   "basic",0 					; name of program.
>8010		00						.text   0							; arguments
>8011		54 68 65 20 53 75 70 65				.text	"The SuperBASIC environment.",0	; description
>8019		72 42 41 53 49 43 20 65 6e 76 69 72 6f 6e 6d 65
>8029		6e 74 2e 00
.8040		4c a7 80	jmp $80a7	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/.build/_exports.module.asm

=1						PagingEnabled = 1
.8043						EXTInitialise:
.8043		e6 0d		inc $0d			inc 8+5
.8045		20 e6 a1	jsr $a1e6		jsr	Export_EXTInitialise
.8048		08		php			php
.8049		c6 0d		dec $0d			dec 8+5
.804b		28		plp			plp
.804c		60		rts			rts
.804d						EXTPrintCharacter:
.804d		e6 0d		inc $0d			inc 8+5
.804f		20 0b a0	jsr $a00b		jsr	Export_EXTPrintCharacter
.8052		08		php			php
.8053		c6 0d		dec $0d			dec 8+5
.8055		28		plp			plp
.8056		60		rts			rts
.8057						EXTPrintNoControl:
.8057		e6 0d		inc $0d			inc 8+5
.8059		20 00 a0	jsr $a000		jsr	Export_EXTPrintNoControl
.805c		08		php			php
.805d		c6 0d		dec $0d			dec 8+5
.805f		28		plp			plp
.8060		60		rts			rts
.8061						EXTSetCurrentLine:
.8061		e6 0d		inc $0d			inc 8+5
.8063		20 d1 a1	jsr $a1d1		jsr	Export_EXTSetCurrentLine
.8066		08		php			php
.8067		c6 0d		dec $0d			dec 8+5
.8069		28		plp			plp
.806a		60		rts			rts
.806b						SNDCommand:
.806b		e6 0d		inc $0d			inc 8+5
.806d		20 d0 b9	jsr $b9d0		jsr	Export_SNDCommand
.8070		08		php			php
.8071		c6 0d		dec $0d			dec 8+5
.8073		28		plp			plp
.8074		60		rts			rts
.8075						SNDUpdate:
.8075		e6 0d		inc $0d			inc 8+5
.8077		20 03 ba	jsr $ba03		jsr	Export_SNDUpdate
.807a		08		php			php
.807b		c6 0d		dec $0d			dec 8+5
.807d		28		plp			plp
.807e		60		rts			rts
.807f						TKInitialise:
.807f		e6 0d		inc $0d			inc 8+5
.8081		20 5d b3	jsr $b35d		jsr	Export_TKInitialise
.8084		08		php			php
.8085		c6 0d		dec $0d			dec 8+5
.8087		28		plp			plp
.8088		60		rts			rts
.8089						TKListConvertLine:
.8089		e6 0d		inc $0d			inc 8+5
.808b		20 69 b3	jsr $b369		jsr	Export_TKListConvertLine
.808e		08		php			php
.808f		c6 0d		dec $0d			dec 8+5
.8091		28		plp			plp
.8092		60		rts			rts
.8093						TKTokeniseLine:
.8093		e6 0d		inc $0d			inc 8+5
.8095		20 15 b6	jsr $b615		jsr	Export_TKTokeniseLine
.8098		08		php			php
.8099		c6 0d		dec $0d			dec 8+5
.809b		28		plp			plp
.809c		60		rts			rts
.809d						GXGraphicDraw:
.809d		e6 0d		inc $0d			inc 8+5
.809f		20 7f a3	jsr $a37f		jsr	Export_GXGraphicDraw
.80a2		08		php			php
.80a3		c6 0d		dec $0d			dec 8+5
.80a5		28		plp			plp
.80a6		60		rts			rts

;******  Return to file: ./common/aa.system/00start.asm

.80a7		a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.80a9		9a		txs				txs
.80aa		20 43 80	jsr $8043			jsr 	EXTInitialise 				; hardware initialise
.80ad		a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.80af		09 80		ora #$80			ora 	#$80
.80b1		85 00		sta $00				sta 	0
.80b3		ad 02 20	lda $2002			lda 	$2002 						; if $2002..5 is BT65 then jump to $2000
.80b6		c9 42		cmp #$42			cmp 	#"B"
.80b8		d0 18		bne $80d2			bne 	_NoMachineCode
.80ba		ad 03 20	lda $2003			lda 	$2003
.80bd		c9 54		cmp #$54			cmp 	#"T"
.80bf		d0 11		bne $80d2			bne 	_NoMachineCode
.80c1		ad 04 20	lda $2004			lda 	$2004
.80c4		c9 36		cmp #$36			cmp 	#"6"
.80c6		d0 0a		bne $80d2			bne 	_NoMachineCode
.80c8		ad 05 20	lda $2005			lda 	$2005
.80cb		c9 35		cmp #$35			cmp 	#"5"
.80cd		d0 03		bne $80d2			bne 	_NoMachineCode
.80cf		4c 00 20	jmp $2000			jmp 	$2000
.80d2						_NoMachineCode:
.80d2		a9 00		lda #$00			lda 	#0 							; zero the default drive.
.80d4		20 41 84	jsr $8441			jsr 	KNLSetDrive
.80d7		20 7f 80	jsr $807f			jsr 	TKInitialise 				; initialise tokeniser.
.80da		a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.80dc		aa		tax				tax
.80dd		a8		tay				tay
.80de		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.80e1		a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.80e3		20 6b 80	jsr $806b			jsr 	SNDCommand
.80e6		a9 8d		lda #$8d			lda 	#128+13 					; Display FPGA information.
.80e8		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.80eb		a9 09		lda #$09			lda 	#9
.80ed		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.80f0		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.80f3		64 01		stz $01				stz 	1
.80f5		ad ad d6	lda $d6ad			lda 	$D6AD
.80f8		20 1b 86	jsr $861b			jsr 	PrintHex
.80fb		ad ac d6	lda $d6ac			lda 	$D6AC
.80fe		20 1b 86	jsr $861b			jsr 	PrintHex
.8101		ad ab d6	lda $d6ab			lda 	$D6AB
.8104		20 1b 86	jsr $861b			jsr 	PrintHex
.8107		ad aa d6	lda $d6aa			lda 	$D6AA
.810a		20 1b 86	jsr $861b			jsr 	PrintHex
.810d		a9 20		lda #$20			lda 	#32
.810f		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8112		ad a8 d6	lda $d6a8			lda 	$D6A8
.8115		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8118		ad a9 d6	lda $d6a9			lda 	$D6A9
.811b		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.811e		a9 0d		lda #$0d			lda 	#13 						; display Kernel information
.8120		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8123		a9 09		lda #$09			lda 	#9
.8125		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8128		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.812b		a9 08		lda #$08			lda 	#$08
.812d		a2 e0		ldx #$e0			ldx 	#$E0
.812f		20 ac 95	jsr $95ac			jsr 	PrintStringXA
.8132		a2 81		ldx #$81			ldx 	#Prompt >> 8 				; display prompt
.8134		a9 45		lda #$45			lda 	#Prompt & $FF
.8136		20 ac 95	jsr $95ac			jsr 	PrintStringXA
.8139		20 f6 82	jsr $82f6			jsr 	ResetIOTracking 			; reset the I/O tracking.
.813c		20 75 8f	jsr $8f75			jsr 	NewProgram 					; erase current program
.813f		4c 12 89	jmp $8912			jmp 	WarmStart					; make same size.
.8142		4c 12 89	jmp $8912			jmp 	WarmStart
>8145		0d				Prompt:	.text 	13

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8146		09 09 32 31 2f 30 36 2f			.text 9,9,"21/06/25 01e"
>814e		32 35 20 30 31 65

;******  Return to file: ./common/aa.system/00start.asm

>8154		0d 0d 0d 00					.text 	13,13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/events.asm

.8158						ProcessEvents:
.8158		20 85 84	jsr $8485			jsr 	KNLSetEventPointer
.815b		20 ff 82	jsr $82ff			jsr     GetNextEvent 				; get next event
.815e		b0 53		bcs $81b3			bcs 	_PEExitZ 					; nothing left to process.
.8160		ad be 07	lda $07be			lda 	KNLEvent.type 				; go back if event not key.pressed.
.8163		c9 52		cmp #$52	                cmp     #kernel.event.timer.EXPIRED
.8165		f0 24		beq $818b	                beq     _PEIsTimer
.8167		c9 0a		cmp #$0a			cmp     #kernel.event.key.RELEASED
.8169		f0 27		beq $8192			beq     _PEIsRelease
.816b		c9 08		cmp #$08			cmp 	#kernel.event.key.PRESSED
.816d		d0 e9		bne $8158			bne 	ProcessEvents
.816f		ad c4 07	lda $07c4			lda	KNLEvent.key.flags 			; is KNLEvent.key.flags = 0 ?
.8172		30 20		bmi $8194			bmi 	_PEIsRaw
.8174		d0 e2		bne $8158			bne 	ProcessEvents
.8176		ad c3 07	lda $07c3			lda 	KNLEvent.key.ascii 			; is it Ctrl+C
.8179		c9 03		cmp #$03			cmp 	#3
.817b		f0 33		beq $81b0			beq 	_PEReturnBreak  			; no, keep going.
.817d		da		phx				phx
.817e		ae c1 07	ldx $07c1	                ldx     KNLEvent.key.keyboard
.8181		d0 05		bne $8188	                bne     +
.8183		aa		tax		                tax
.8184		20 fd 81	jsr $81fd	                jsr     StartRepeatTimerForKey
.8187		8a		txa		                txa
.8188		fa		plx		+               plx
.8189		80 14		bra $819f			bra 	_PEQueueA
.818b						_PEIsTimer:
.818b		20 20 82	jsr $8220	                jsr     HandleRepeatTimerEvent
.818e		b0 c8		bcs $8158	                bcs     ProcessEvents
.8190		80 0d		bra $819f	                bra     _PEQueueA
.8192						_PEIsRelease:
.8192		80 c4		bra $8158	                bra     ProcessEvents
.8194						_PEIsRaw:
.8194		ad c3 07	lda $07c3			lda 	KNLEvent.key.ascii 			; return pseudo ascii value if F1-F12
.8197		c9 81		cmp #$81			cmp 	#129
.8199		90 bd		bcc $8158			bcc		ProcessEvents
.819b		c9 8d		cmp #$8d			cmp 	#140+1
.819d		b0 b9		bcs $8158			bcs 	ProcessEvents
.819f						_PEQueueA:
.819f		da		phx				phx
.81a0		ae 80 06	ldx $0680			ldx 	KeyboardQueueEntries 		; get keyboard queue size into X
.81a3		e0 08		cpx #$08			cpx 	#KBDQueueSize 				; if full, then ignore
.81a5		f0 06		beq $81ad			beq 	_PENoQueue
.81a7		9d 78 06	sta $0678,x			sta 	KeyboardQueue,x 			; write into queue
.81aa		ee 80 06	inc $0680			inc 	KeyboardQueueEntries 		; bump count
.81ad						_PENoQueue:
.81ad		fa		plx				plx
.81ae		80 a8		bra $8158			bra 	ProcessEvents
.81b0						_PEReturnBreak:
.81b0		a9 ff		lda #$ff			lda 	#255 						; return with NZ state
.81b2		60		rts				rts
.81b3						_PEExitZ:
.81b3		a9 00		lda #$00			lda 	#0
.81b5		60		rts				rts
.81b6						PopKeyboardQueue:
.81b6		ad 80 06	lda $0680			lda 	KeyboardQueueEntries 		; get keyboard queue entries.
.81b9		f0 17		beq $81d2			beq 	_PKQExit 					; zero, then exit.
.81bb		ad 78 06	lda $0678			lda 	KeyboardQueue 				; save head of keyboard queue
.81be		48		pha				pha
.81bf		da		phx				phx 								; drop head of queue
.81c0		a2 00		ldx #$00			ldx 	#0
.81c2						_PKQLoop:
.81c2		bd 79 06	lda $0679,x			lda 	KeyboardQueue+1,x 			; shift everything back one.
.81c5		9d 78 06	sta $0678,x			sta 	KeyboardQueue,x  			; not efficient but doesn't matter.
.81c8		e8		inx				inx
.81c9		e0 07		cpx #$07			cpx 	#7
.81cb		d0 f5		bne $81c2			bne 	_PKQLoop
.81cd		fa		plx				plx
.81ce		ce 80 06	dec $0680			dec 	KeyboardQueueEntries 		; one fewer in queue.
.81d1		68		pla				pla 								; restore head of queue.
.81d2						_PKQExit:
.81d2		60		rts				rts
.81d3						KNLGetKeyPressed:
.81d3		a5 01		lda $01				lda 	1 							; save I/O 0
.81d5		48		pha				pha
.81d6		64 01		stz $01				stz 	1 							; access I/O Page 0
.81d8		38		sec				sec 								; calculate timer - LastTick
.81d9		ad 59 d6	lda $d659			lda 	$D659
.81dc		cd 81 06	cmp $0681			cmp 	LastTick
.81df		f0 06		beq $81e7			beq 	_NoFireTick 				; if < 3 clocks don't fire.
.81e1		8d 81 06	sta $0681			sta 	LastTick 					; update last timer
.81e4		20 ee 82	jsr $82ee			jsr 	TickHandler 							; go do the code.
.81e7						_NoFireTick:
.81e7		68		pla				pla 								; restore I/O 0
.81e8		85 01		sta $01				sta 	1
.81ea		ad 80 06	lda $0680			lda 	KeyboardQueueEntries 		; something in the queue
.81ed		d0 c7		bne $81b6			bne 	PopKeyboardQueue 			; if so, pop and return it
.81ef		20 58 81	jsr $8158			jsr 	ProcessEvents 				; process any outstanding events
.81f2		a9 00		lda #$00			lda 	#0
.81f4		60		rts				rts
.81f5						KNLGetSingleCharacter:
.81f5		20 d3 81	jsr $81d3			jsr 	KNLGetKeyPressed
.81f8		c9 00		cmp #$00			cmp 	#0
.81fa		f0 f9		beq $81f5			beq 	KNLGetSingleCharacter
.81fc		60		rts				rts
>0000						key             .byte   ?   ; Key-code to repeat.
>0001						cookie          .byte   ?   ; Timer ID.
.81fd						StartRepeatTimerForKey
.81fd		8d 76 06	sta $0676	                sta     repeat.key
.8200		ee 77 06	inc $0677	                inc     repeat.cookie
.8203		a9 80		lda #$80	                lda     #kernel.args.timer.FRAMES | kernel.args.timer.QUERY
.8205		85 f3		sta $f3		                sta     kernel.args.timer.units
.8207		20 f0 ff	jsr $fff0	                jsr     kernel.Clock.SetTimer
.820a		69 1e		adc #$1e	                adc     #30
.820c		80 04		bra $8212	                bra     ScheduleRepeatEvent
.820e						StopRepeat
.820e		ee 77 06	inc $0677	                inc     repeat.cookie
.8211		60		rts		                rts
.8212						ScheduleRepeatEvent
.8212		85 f4		sta $f4		                sta     kernel.args.timer.absolute
.8214		a9 00		lda #$00	                lda     #kernel.args.timer.FRAMES
.8216		85 f3		sta $f3		                sta     kernel.args.timer.units
.8218		ad 77 06	lda $0677	                lda     repeat.cookie
.821b		85 f5		sta $f5		                sta     kernel.args.timer.cookie
.821d		4c f0 ff	jmp $fff0	                jmp     kernel.Clock.SetTimer
.8220						HandleRepeatTimerEvent
.8220		ad c2 07	lda $07c2	                lda     KNLEvent.timer.cookie
.8223		cd 77 06	cmp $0677	                cmp     repeat.cookie
.8226		f0 02		beq $822a	                beq     _repeat
.8228		38		sec		                sec
.8229		60		rts		                rts
.822a						_repeat
.822a		ad c1 07	lda $07c1	                lda     KNLEvent.timer.value
.822d		18		clc		                clc
.822e		69 03		adc #$03	                adc     #3
.8230		20 12 82	jsr $8212	                jsr     ScheduleRepeatEvent
.8233		ad 76 06	lda $0676	                lda     repeat.key
.8236		18		clc		                clc
.8237		60		rts		                rts
.0676						repeat:
>0676						key             .byte   ?   ; Key-code to repeat.
>0677						cookie          .byte   ?   ; Timer ID.
=8						KBDQueueSize = 8
.0678						KeyboardQueue:
>0678								.fill 	KBDQueueSize
.0680						KeyboardQueueEntries:
>0680								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/input.asm

.8238						InputLine:
.8238		48		pha				pha
.8239		da		phx				phx
.823a		5a		phy				phy
.823b		a5 01		lda $01				lda 	1 							; save I/O page
.823d		48		pha				pha
.823e						_EILLoop:
.823e		20 f5 81	jsr $81f5			jsr 	KNLGetSingleCharacter 		; get one single character
.8241		c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.8243		f0 53		beq $8298			beq 	_EILExit
.8245		c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.8247		f0 39		beq $8282			beq 	_EILDelete
.8249		c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.824b		f0 2b		beq $8278			beq 	_EILBackspace
.824d		c9 20		cmp #$20			cmp 	#' '						; < space, print it
.824f		90 21		bcc $8272			bcc 	_EILPrintLoop
.8251		c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.8253		b0 1d		bcs $8272			bcs 	_EILPrintLoop
.8255		aa		tax				tax 								; save character in X
.8256		a9 02		lda #$02			lda	 	#2 							; screen character memory
.8258		85 01		sta $01				sta 	1
.825a		ac ed 07	ldy $07ed			ldy 	EXTScreenWidth 				; read the last character.
.825d		88		dey				dey
.825e		b1 40		lda ($40),y			lda 	(EXTAddress),y
.8260		c9 20		cmp #$20			cmp 	#' ' 						; if not space then reject.
.8262		d0 da		bne $823e			bne 	_EILLoop
.8264		da		phx				phx 								; save character on stack
.8265		a9 02		lda #$02			lda 	#2  						; insert a space
.8267		85 01		sta $01				sta 	1
.8269		20 dc 82	jsr $82dc			jsr 	EXTILInsert 				; insert in text screen
.826c		e6 01		inc $01				inc 	1
.826e		20 dc 82	jsr $82dc			jsr 	EXTILInsert 				; insert in colour screen
.8271		68		pla				pla 								; get character back.
.8272						_EILPrintLoop:
.8272		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8275		80 c7		bra $823e			bra 	_EILLoop
.8277		60		rts				rts
.8278						_EILBackspace:
.8278		ad eb 07	lda $07eb			lda 	EXTColumn					; can we backspace ?
.827b		f0 c1		beq $823e			beq 	_EILLoop
.827d		a9 02		lda #$02			lda 	#2 							; move cursor left
.827f		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8282						_EILDelete
.8282		a9 02		lda #$02			lda 	#2 							; text block
.8284		85 01		sta $01				sta 	1
.8286		a9 20		lda #$20			lda 	#' ' 						; backspace text.
.8288		20 c7 82	jsr $82c7			jsr 	EXTILDelete
.828b		e6 01		inc $01				inc 	1 							; colour block
.828d		ac eb 07	ldy $07eb			ldy 	EXTColumn 					; get attribute of last character
.8290		88		dey				dey
.8291		b1 40		lda ($40),y			lda 	(EXTAddress),y
.8293		20 c7 82	jsr $82c7			jsr 	EXTILDelete 				; backspace attribute
.8296		80 a6		bra $823e			bra 	_EILLoop 					; and go round.
.8298						_EILExit:
.8298		a9 02		lda #$02			lda 	#2 							; switch to page 2
.829a		85 01		sta $01				sta 	1
.829c		a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.829e						_EILScrapeLine:
.829e		b1 40		lda ($40),y			lda 	(EXTAddress),y
.82a0		99 46 05	sta $0546,y			sta 	lineBuffer,y
.82a3		c8		iny				iny
.82a4		cc ed 07	cpy $07ed			cpy 	EXTScreenWidth
.82a7		d0 f5		bne $829e			bne 	_EILScrapeLine
.82a9						_EILTrimSpaces:
.82a9		88		dey				dey
.82aa		c0 ff		cpy #$ff			cpy 	#$FF 						; back past the start
.82ac		f0 07		beq $82b5			beq 	_EILEndTrim		 			; zero the input line.
.82ae		b9 46 05	lda $0546,y			lda 	lineBuffer,y
.82b1		c9 20		cmp #$20			cmp 	#' '
.82b3		f0 f4		beq $82a9			beq 	_EILTrimSpaces 				; if fail this found non space character
.82b5						_EILEndTrim:
.82b5		c8		iny				iny 								; trim after non space character.
.82b6		a9 00		lda #$00			lda 	#0 							; trim here.
.82b8		99 46 05	sta $0546,y			sta 	lineBuffer,y
.82bb		a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.82bd		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.82c0		68		pla				pla 								; reset I/O page
.82c1		85 01		sta $01				sta 	1
.82c3		7a		ply				ply
.82c4		fa		plx				plx
.82c5		68		pla				pla
.82c6		60		rts				rts
.82c7						EXTILDelete:
.82c7		48		pha				pha 								; save the new character
.82c8		ac eb 07	ldy $07eb			ldy 	EXTColumn 					; start copying from here.
.82cb						_EXTDLoop:
.82cb		c8		iny				iny 								; copy one byte down.
.82cc		b1 40		lda ($40),y			lda 	(EXTAddress),y
.82ce		88		dey				dey
.82cf		91 40		sta ($40),y			sta 	(EXTAddress),y
.82d1		c8		iny				iny 								; do till end of line.
.82d2		cc ed 07	cpy $07ed			cpy 	EXTScreenWidth
.82d5		90 f4		bcc $82cb			bcc 	_EXTDLoop
.82d7		88		dey				dey 	 							; write in last slot.
.82d8		68		pla				pla
.82d9		91 40		sta ($40),y			sta 	(EXTAddress),y
.82db		60		rts				rts
.82dc						EXTILInsert:
.82dc		ac ed 07	ldy $07ed			ldy 	EXTScreenWidth 				; end position
.82df						_EXTILoop:
.82df		88		dey				dey 								; back one
.82e0		cc eb 07	cpy $07eb			cpy 	EXTColumn 					; exit if reached insert point.
.82e3		f0 08		beq $82ed			beq 	_EXTIExit
.82e5		88		dey				dey 								; copy one byte up.
.82e6		b1 40		lda ($40),y			lda 	(EXTAddress),y
.82e8		c8		iny				iny
.82e9		91 40		sta ($40),y			sta 	(EXTAddress),y
.82eb		80 f2		bra $82df			bra 	_EXTILoop
.82ed						_EXTIExit:
.82ed		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/ticktask.asm

.82ee						TickHandler:
.82ee		da		phx				phx
.82ef		5a		phy				phy 								; need to preserve Y
.82f0		20 75 80	jsr $8075			jsr 	SNDUpdate 					; update sound
.82f3		7a		ply				ply
.82f4		fa		plx				plx
.82f5		60		rts				rts
.0681						LastTick:
>0681								.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/trackio.asm

.82f6						ResetIOTracking:
.82f6		a2 3a		ldx #$3a			ldx 	#GNEEnd-GNEBegin-1
.82f8						_RIOLoop:
.82f8		9e 82 06	stz $0682,x			stz 	GNEBegin,x
.82fb		ca		dex				dex
.82fc		10 fa		bpl $82f8			bpl 	_RIOLoop
.82fe		60		rts				rts
.82ff						GetNextEvent:
.82ff		20 00 ff	jsr $ff00			jsr 	kernel.NextEvent 			; get event
.8302		08		php				php									; save yes/no flag.
.8303		b0 29		bcs $832e			bcs 	_GNEExit
.8305		48		pha				pha 								; save registers
.8306		da		phx				phx
.8307		5a		phy				phy
.8308		ad be 07	lda $07be			lda 	KNLEvent.type	 			; check for PRESSED or RELEASED
.830b		c9 08		cmp #$08			cmp 	#kernel.event.key.PRESSED
.830d		f0 04		beq $8313			beq 	_GNEKeyEvent
.830f		c9 0a		cmp #$0a			cmp 	#kernel.event.key.RELEASED
.8311		d0 08		bne $831b			bne 	_GNECheckMouseEvent
.8313						_GNEKeyEvent:
.8313		20 ed 83	jsr $83ed			jsr 	ProcessKeyboardEvent 		; process keyboard up/down.
.8316		20 0c 84	jsr $840c			jsr 	UpdateKeyboardJoystick 		; update the keyboard-joystick.
.8319		80 10		bra $832b			bra 	_GNEEventExit
.831b						_GNECheckMouseEvent:
.831b		c9 0c		cmp #$0c			cmp 	#kernel.event.mouse.DELTA 	; check for move events
.831d		d0 05		bne $8324			bne 	_GNENotDelta
.831f		20 30 83	jsr $8330			jsr 	ProcessMouseDeltaEvent 		; process them.
.8322		80 07		bra $832b			bra 	_GNEEventExit
.8324						_GNENotDelta:
.8324		c9 0e		cmp #$0e			cmp 	#kernel.event.mouse.CLICKS 	; check for click events
.8326		d0 03		bne $832b			bne 	_GNEEventExit
.8328		20 5f 83	jsr $835f			jsr 	ProcessMouseClickEvent 		; process them.
.832b						_GNEEventExit:
.832b		7a		ply				ply 								; restore registers
.832c		fa		plx				plx
.832d		68		pla				pla
.832e						_GNEExit:
.832e		28		plp				plp
.832f		60		rts				rts
.8330						ProcessMouseDeltaEvent:
.8330		a2 23		ldx #$23			ldx 	#MouseDeltaX-GNEBegin
.8332		ad c1 07	lda $07c1			lda 	KNLEvent.mouse.delta.x
.8335		20 86 83	jsr $8386			jsr 	PMKAdjustTotal
.8338		20 c9 83	jsr $83c9			jsr 	PMKAddSubtract
.833b		ad c2 07	lda $07c2			lda 	KNLEvent.mouse.delta.y
.833e		20 86 83	jsr $8386			jsr 	PMKAdjustTotal
.8341		20 c9 83	jsr $83c9			jsr 	PMKAddSubtract
.8344		ad c3 07	lda $07c3			lda 	KNLEvent.mouse.delta.z
.8347		20 86 83	jsr $8386			jsr 	PMKAdjustTotal
.834a		20 c9 83	jsr $83c9			jsr 	PMKAddSubtract
.834d		ad c4 07	lda $07c4			lda 	KNLEvent.mouse.delta.buttons
.8350		a2 35		ldx #$35			ldx 	#MouseStatusX-GNEBegin
.8352		20 74 83	jsr $8374			jsr 	PMKOutputButton
.8355		20 74 83	jsr $8374			jsr 	PMKOutputButton
.8358		20 74 83	jsr $8374			jsr 	PMKOutputButton
.835b		20 95 83	jsr $8395			jsr 	PMKClipMouseCoord
.835e		60		rts				rts
.835f						ProcessMouseClickEvent:
.835f		a2 29		ldx #$29			ldx 	#MouseCountInner-GNEBegin
.8361		ad c1 07	lda $07c1			lda 	KNLEvent.mouse.clicks.inner
.8364		20 cd 83	jsr $83cd			jsr 	PMKAdd
.8367		ad c2 07	lda $07c2			lda 	KNLEvent.mouse.clicks.middle
.836a		20 cd 83	jsr $83cd			jsr 	PMKAdd
.836d		ad c3 07	lda $07c3			lda 	KNLEvent.mouse.clicks.outer
.8370		20 cd 83	jsr $83cd			jsr 	PMKAdd
.8373		60		rts				rts
.8374						PMKOutputButton:
.8374		9e 82 06	stz $0682,x			stz 	GNEBegin,x 					; button to zero
.8377		9e 83 06	stz $0683,x			stz 	GNEBegin+1,x
.837a		6a		ror a				ror 	a 							; shift LSB into carry
.837b		90 06		bcc $8383			bcc 	_PMKOBExit
.837d		de 82 06	dec $0682,x			dec 	GNEBegin,x 					; if set then set to -1
.8380		de 83 06	dec $0683,x			dec 	GNEBegin+1,x
.8383						_PMKOBExit:
.8383		e8		inx				inx  								; next button
.8384		e8		inx				inx
.8385		60		rts				rts
.8386						PMKAdjustTotal:
.8386		48		pha				pha 								; save offset A index X
.8387		da		phx				phx
.8388		48		pha				pha 								; point X to the position
.8389		8a		txa				txa
.838a		18		clc				clc
.838b		69 0c		adc #$0c			adc 	#MousePosX-MouseDeltaX
.838d		aa		tax				tax
.838e		68		pla				pla
.838f		20 c9 83	jsr $83c9			jsr 	PMKAddSubtract 				; reuse the addition code.
.8392		fa		plx				plx 								; restore XA
.8393		68		pla				pla
.8394		60		rts				rts
.8395						PMKClipMouseCoord:
.8395		a2 00		ldx #$00			ldx 	#0
.8397						_PCMCLoop:
.8397		bd b2 06	lda $06b2,x			lda 	MousePosX+1,x 				; check if -ve
.839a		10 06		bpl $83a2			bpl 	_PCMCNotNeg
.839c		9e b1 06	stz $06b1,x			stz 	MousePosX,x 				; if so zero position.
.839f		9e b2 06	stz $06b2,x			stz 	MousePosX+1,x
.83a2						_PCMCNotNeg:
.83a2		bd b1 06	lda $06b1,x			lda 	MousePosX,x 				; compare pos vs extent
.83a5		dd c3 83	cmp $83c3,x			cmp 	_PCMCExtent,x
.83a8		bd b2 06	lda $06b2,x			lda 	MousePosX+1,x
.83ab		fd c4 83	sbc $83c4,x			sbc 	_PCMCExtent+1,x
.83ae		90 0c		bcc $83bc			bcc 	_PCMCNotOver 				; in range ?
.83b0		bd c3 83	lda $83c3,x			lda 	_PCMCExtent,x 				; no, set to X limit.
.83b3		9d b1 06	sta $06b1,x			sta 	MousePosX,x
.83b6		bd c4 83	lda $83c4,x			lda 	_PCMCExtent+1,x
.83b9		9d b2 06	sta $06b2,x			sta 	MousePosX+1,x
.83bc						_PCMCNotOver:
.83bc		e8		inx				inx
.83bd		e8		inx				inx
.83be		e0 06		cpx #$06			cpx 	#3*2
.83c0		d0 d5		bne $8397			bne 	_PCMCLoop
.83c2		60		rts				rts
.83c3						_PCMCExtent:
>83c3		3f 01 ef 00 ff 00				.word 	319,239,255
.83c9						PMKAddSubtract:
.83c9		c9 00		cmp #$00			cmp 	#0 							; subtracting ?
.83cb		30 0e		bmi $83db			bmi 	PMKSubtract
.83cd						PMKAdd:
.83cd		18		clc				clc
.83ce		7d 82 06	adc $0682,x			adc 	GNEBegin,x
.83d1		9d 82 06	sta $0682,x			sta 	GNEBegin,x
.83d4		90 14		bcc $83ea			bcc 	PMKExit
.83d6		fe 83 06	inc $0683,x			inc 	GNEBegin+1,x
.83d9		80 0f		bra $83ea			bra 	PMKExit
.83db						PMKSubtract:
.83db		18		clc				clc
.83dc		7d 82 06	adc $0682,x			adc 	GNEBegin,x
.83df		9d 82 06	sta $0682,x			sta 	GNEBegin,x
.83e2		bd 83 06	lda $0683,x			lda 	GNEBegin+1,x
.83e5		69 ff		adc #$ff			adc 	#$FF
.83e7		9d 83 06	sta $0683,x			sta 	GNEBegin+1,x
.83ea						PMKExit:
.83ea		e8		inx				inx 								; next slot ?
.83eb		e8		inx				inx
.83ec		60		rts				rts
.83ed						ProcessKeyboardEvent:
.83ed		ad c2 07	lda $07c2			lda 	KNLEvent.key.raw 			; raw key code.
.83f0		20 2d 84	jsr $842d			jsr 	KeyboardConvertXA  			; convert to index in X, mask in A
.83f3		ac be 07	ldy $07be			ldy 	KNLEvent.type
.83f6		c0 0a		cpy #$0a			cpy 	#kernel.event.key.RELEASED 	; check if pressed/released
.83f8		f0 07		beq $8401			beq 	_PKERelease
.83fa		1d 83 06	ora $0683,x			ora 	KeyStatus,x 				; set bit
.83fd		9d 83 06	sta $0683,x			sta 	KeyStatus,x
.8400		60		rts				rts
.8401						_PKERelease:
.8401		49 ff		eor #$ff			eor 	#$FF						; clear bit
.8403		3d 83 06	and $0683,x			and 	KeyStatus,x
.8406		9d 83 06	sta $0683,x			sta 	KeyStatus,x
.8409		4c 0e 82	jmp $820e			jmp     StopRepeat      ; See events.asm.
.840c						UpdateKeyboardJoystick:
.840c		9c a4 06	stz $06a4			stz 	KeyJoystick
.840f		a2 00		ldx #$00			ldx 	#0
.8411						_UKJLoop:
.8411		bd 28 84	lda $8428,x			lda 	_UKJKeys,x 					; which key
.8414		29 1f		and #$1f			and 	#$1F
.8416		a8		tay				tay
.8417		b9 83 06	lda $0683,y			lda 	KeyStatus,y 				; get status
.841a		29 10		and #$10			and 	#$10 						; letters always bit 4 (actually ASCII of L/C)
.841c		18		clc				clc  								; set C if bit set
.841d		69 ff		adc #$ff			adc 	#$FF
.841f		2e a4 06	rol $06a4			rol 	KeyJoystick 				; shift into place
.8422		e8		inx				inx
.8423		e0 05		cpx #$05			cpx 	#5 							; do all 5
.8425		d0 ea		bne $8411			bne 	_UKJLoop
.8427		60		rts				rts
.8428						_UKJKeys:
>8428		4c 58 5a 4d 4b					.byte	'L','X','Z','M','K'
.842d						KeyboardConvertXA:
.842d		a2 01		ldx #$01			ldx 	#1 							; set the mask temp to %00000001
.842f		8e a3 06	stx $06a3			stx 	KeyMaskTemp
.8432						_KCCALoop:
.8432		18		clc				clc
.8433		69 20		adc #$20			adc 	#$20 						; upper 3 bits are the mask, if causes CS A will be in the range 00-1F
.8435		b0 05		bcs $843c			bcs 	_KCCADone
.8437		0e a3 06	asl $06a3			asl 	KeyMaskTemp 				; shift the mask temp
.843a		80 f6		bra $8432			bra 	_KCCALoop
.843c						_KCCADone:
.843c		aa		tax				tax 								; table entry in X
.843d		ad a3 06	lda $06a3			lda 	KeyMaskTemp 				; mask temp in A.
.8440		60		rts				rts
.0682						GNEBegin:
.0682						CMDMouseFlag:
>0682								.fill 	1
.0683						KeyStatus:
>0683								.fill 	32
.06a3						KeyMaskTemp:
>06a3								.fill 	1
.06a4						KeyJoystick:
>06a4								.fill 	1
.06a5						MouseDeltaX:
>06a5								.fill 	2
.06a7						MouseDeltaY:
>06a7								.fill 	2
.06a9						MouseDeltaZ:
>06a9								.fill 	2
.06ab						MouseCountInner:
>06ab								.fill 	2
.06ad						MouseCountMiddle:
>06ad								.fill 	2
.06af						MouseCountOuter:
>06af								.fill 	2
.06b1						MousePosX:
>06b1								.fill 	2
.06b3						MousePosY:
>06b3								.fill 	2
.06b5						MousePosZ:
>06b5								.fill 	2
.06b7						MouseStatusX:
>06b7								.fill 	2
.06b9						MouseStatusY:
>06b9								.fill 	2
.06bb						MouseStatusZ:
>06bb								.fill 	2
.06bd						GNEEnd:

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/wrapper.asm

=56						KERR_GENERAL = kernel.event.file.ERROR 		; Event $38
=50						KERR_CLOSED = kernel.event.file.CLOSED 		; Event $32
=40						KERR_NOTFOUND = kernel.event.file.NOT_FOUND ; Event $28
=48						KERR_EOF = kernel.event.file.EOF 			; Event $30
=64						KNLReadBufferLen = 64 								; read buffer size.
.8441						KNLSetDrive:
.8441		8d bd 07	sta $07bd			sta 	KNLDefaultDrive
.8444		60		rts				rts
.8445						KNLOpenFileWrite:
.8445		48		pha				pha
.8446		a9 01		lda #$01			lda 	#kernel.args.file.open.WRITE
.8448		80 03		bra $844d			bra 	KNLOpenStart
.844a						KNLOpenFileRead:
.844a		48		pha				pha
.844b		a9 00		lda #$00			lda     #kernel.args.file.open.READ ; set READ mode.
.844d						KNLOpenStart:
.844d		85 f5		sta $f5				sta     kernel.args.file.open.mode
.844f		68		pla				pla
.8450		5a		phy				phy
.8451		20 90 84	jsr $8490			jsr 	KNLSetupFileName
.8454		20 85 84	jsr $8485			jsr 	KNLSetEventPointer
.8457		ad bd 07	lda $07bd			lda 	KNLDefaultDrive 			; currently drive zero only.
.845a		85 f3		sta $f3				sta 	kernel.args.file.open.drive
.845c		20 5c ff	jsr $ff5c			jsr     kernel.File.Open 			; open the file and exit.
.845f		b0 1c		bcs $847d			bcs     _kernel_error
.8461		a8		tay				tay
.8462						_loop
.8462		20 0c ff	jsr $ff0c			jsr     kernel.Yield    			; event wait
.8465		20 ff 82	jsr $82ff			jsr     GetNextEvent
.8468		b0 f8		bcs $8462			bcs     _loop
.846a		ad be 07	lda $07be			lda 	KNLEvent.type
.846d		c9 2a		cmp #$2a			cmp     #kernel.event.file.OPENED
.846f		f0 10		beq $8481			beq 	_success
.8471		c9 28		cmp #$28			cmp     #kernel.event.file.NOT_FOUND
.8473		f0 0e		beq $8483			beq 	_exit
.8475		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR
.8477		d0 e9		bne $8462			bne 	_loop
.8479		a9 28		lda #$28			lda		#kernel.event.file.NOT_FOUND
.847b		80 06		bra $8483			bra		_exit
.847d						_kernel_error
.847d		a9 38		lda #$38			lda     #kernel.event.file.ERROR
.847f		80 02		bra $8483			bra		_exit
.8481						_success
.8481		98		tya				tya
.8482		18		clc				clc
.8483						_exit
.8483		7a		ply				ply
.8484		60		rts				rts
.8485						KNLSetEventPointer:
.8485		48		pha				pha
.8486		a9 be		lda #$be			lda     #KNLEvent & $FF 			; tell kernel where to store event data
.8488		85 f0		sta $f0				sta     kernel.args.events+0
.848a		a9 07		lda #$07			lda     #KNLEvent >> 8
.848c		85 f1		sta $f1				sta     kernel.args.events+1
.848e		68		pla				pla
.848f		60		rts				rts
.8490						KNLSetupFileName:
.8490		5a		phy				phy 								; save Y on stack
.8491		85 36		sta $36				sta 	zTemp0 						; save filename position in temp, and in kenrel slot
.8493		86 37		stx $37				stx 	zTemp0+1
.8495		85 fb		sta $fb				sta     kernel.args.file.open.fname+0
.8497		86 fc		stx $fc				stx     kernel.args.file.open.fname+1
.8499		a0 ff		ldy #$ff			ldy 	#$FF 						; get the filename length => Kernel slot
.849b						_KNLGetLength:
.849b		c8		iny				iny
.849c		b1 36		lda ($36),y			lda 	(zTemp0),y
.849e		d0 fb		bne $849b			bne 	_KNLGetLength
.84a0		84 fd		sty $fd				sty 	kernel.args.file.open.fname_len
.84a2		7a		ply				ply
.84a3		60		rts				rts
.84a4						KNLReadBlock:
.84a4		85 f3		sta $f3				sta     kernel.args.file.read.stream
.84a6		86 f4		stx $f4				stx     kernel.args.file.read.buflen
.84a8		20 60 ff	jsr $ff60			jsr     kernel.File.Read 			; read request
.84ab		a9 38		lda #$38			lda     #kernel.event.file.ERROR    ; Kernel out of events/buffers; shouldn't happen
.84ad		b0 2e		bcs $84dd			bcs     _KGNBExitFail               ; report as general error
.84af						_KGRBEventLoop:
.84af		20 0c ff	jsr $ff0c			jsr     kernel.Yield    			; event wait
.84b2		20 ff 82	jsr $82ff			jsr     GetNextEvent
.84b5		b0 f8		bcs $84af			bcs     _KGRBEventLoop
.84b7		ad be 07	lda $07be			lda 	KNLEvent.type 				; get event
.84ba		c9 2c		cmp #$2c			cmp     #kernel.event.file.DATA 	; data, return data
.84bc		f0 0a		beq $84c8			beq     _KNLRBGetNextByte
.84be		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR  	; errors on file i/o, return as appropriate.
.84c0		f0 1b		beq $84dd			beq 	_KGNBExitFail
.84c2		c9 30		cmp #$30			cmp     #kernel.event.file.EOF
.84c4		f0 17		beq $84dd			beq 	_KGNBExitFail
.84c6		80 e7		bra $84af			bra 	_KGRBEventLoop
.84c8						_KNLRBGetNextByte:
.84c8		a9 bd		lda #$bd			lda     #<KNLReadBuffer 			; Set the target buffer
.84ca		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.84cc		a9 06		lda #$06			lda     #>KNLReadBuffer
.84ce		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.84d0		ad c4 07	lda $07c4			lda     KNLEvent.file.data.read 	; Set the target length
.84d3		85 fd		sta $fd				sta     kernel.args.recv.buflen
.84d5		20 04 ff	jsr $ff04			jsr     kernel.ReadData		       	; Get the data from the kernel  (Synchronous call, no error)
.84d8		ad c4 07	lda $07c4			lda     KNLEvent.file.data.read 	; Return # of bytes read (in A)
.84db		18		clc				clc
.84dc		60		rts				rts
.84dd						_KGNBExitFail:
.84dd		38		sec				sec
.84de		60		rts				rts
.84df						KNLWriteBlock:
.84df		da		phx				phx
.84e0		5a		phy				phy
.84e1		85 f3		sta $f3				sta     kernel.args.file.write.stream ; save the stream.
.84e3		a5 36		lda $36				lda     zTemp0 						; save the data location.
.84e5		85 fb		sta $fb				sta     kernel.args.file.write.buf+0
.84e7		a5 37		lda $37				lda     zTemp0+1
.84e9		85 fc		sta $fc				sta     kernel.args.file.write.buf+1
.84eb		86 fd		stx $fd				stx     kernel.args.file.write.buflen ; Set the buffer length
.84ed		20 64 ff	jsr $ff64			jsr     kernel.File.Write 			; write it out.
.84f0		a9 38		lda #$38			lda 	#kernel.event.file.ERROR 	; in case it fails.
.84f2		b0 21		bcs $8515			bcs 	_KWBFailed
.84f4						_KNLWLoop:
.84f4		20 0c ff	jsr $ff0c			jsr     kernel.Yield
.84f7		20 ff 82	jsr $82ff			jsr     GetNextEvent
.84fa		b0 f8		bcs $84f4			bcs     _KNLWLoop
.84fc		ad be 07	lda $07be			lda     KNLEvent.type 				; various errors.
.84ff		c9 32		cmp #$32			cmp     #kernel.event.file.CLOSED
.8501		f0 12		beq $8515			beq 	_KWBFailed
.8503		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR
.8505		f0 0e		beq $8515			beq 	_KWBFailed
.8507		c9 30		cmp #$30			cmp     #kernel.event.file.EOF
.8509		f0 0a		beq $8515			beq 	_KWBFailed
.850b		c9 2e		cmp #$2e			cmp     #kernel.event.file.WROTE 	; wait until block write succeeds
.850d		d0 e5		bne $84f4			bne 	_KNLWLoop
.850f		18		clc				clc
.8510		ad c4 07	lda $07c4			lda    KNLEvent.file.wrote.wrote 	; get bytes written.
.8513		80 01		bra $8516			bra 	_KWBExit
.8515						_KWBFailed:
.8515		38		sec				sec
.8516						_KWBExit:
.8516		7a		ply				ply
.8517		fa		plx				plx
.8518		60		rts				rts
.8519						KNLCloseFile:
.8519		85 f3		sta $f3				sta     kernel.args.file.close.stream
.851b		20 68 ff	jsr $ff68			jsr     kernel.File.Close
.851e		60		rts				rts
.851f						KNLReadController:
.851f		da		phx				phx
.8520		a6 01		ldx $01				ldx 	1 							; save current I/O in X
.8522		64 01		stz $01				stz 	1 							; switch to I/O 0
.8524		ad 00 dc	lda $dc00			lda 	$DC00  						; read VIA register
.8527		49 ff		eor #$ff			eor 	#$FF 						; make active '1'
.8529		0d a4 06	ora $06a4			ora 	KeyJoystick 				; use key joystick.
.852c		86 01		stx $01				stx 	1 							; repair old I/O and exit
.852e		fa		plx				plx
.852f		60		rts				rts
.06bd						KNLReadBuffer:
>06bd								.fill   256
.07bd						KNLDefaultDrive:
>07bd								.byte 	?
.07be						KNLEvent
>07be						type        .byte   ?   ; Enum above
>07bf						buf         .byte   ?   ; page id or zero
>07c0						ext         .byte   ?   ; page id or zero
.07c1						key
>07c1						keyboard    .byte   ?   ; Keyboard ID
>07c2						raw         .byte   ?   ; Raw key ID
>07c3						ascii       .byte   ?   ; ASCII value
>07c4						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.07c1						mouse
.07c1						delta
>07c1						x           .byte   ?
>07c2						y           .byte   ?
>07c3						z           .byte   ?
>07c4						buttons     .byte   ?
.07c1						clicks
>07c1						inner       .byte   ?
>07c2						middle      .byte   ?
>07c3						outer       .byte   ?
.07c1						joystick
>07c1						joy0        .byte   ?
>07c2						joy1        .byte   ?
.07c1						udp
>07c1						token       .byte   ?   ; TODO: break out into fields
.07c1						tcp
>07c1						len         .byte   ?   ; Raw packet length.
.07c1						file
>07c1						stream      .byte   ?
>07c2						cookie      .byte   ?
.07c3						data
>07c3						requested   .byte   ?   ; Requested number of bytes to read
>07c4						read        .byte   ?   ; Number of bytes actually read
.07c3						wrote
>07c3						requested   .byte   ?   ; Requested number of bytes to read
>07c4						wrote       .byte   ?   ; Number of bytes actually read
.07c1						directory
>07c1						stream      .byte   ?
>07c2						cookie      .byte   ?
.07c3						volume
>07c3						len         .byte   ?   ; Length of volname (in buf)
>07c4						flags       .byte   ?   ; block size, text encoding
.07c3						file
>07c3						len         .byte   ?
>07c4						flags       .byte   ?   ; block scale, text encoding, approx size
.07c3						free
>07c3						flags       .byte   ?   ; block scale, text encoding, approx size
.07c1						timer
>07c1						value       .byte   ?
>07c2						cookie      .byte   ?

;******  Return to file: _basic.asm


;******  Processing file: ./common/api/api.asm

>ff00						NextEvent   .fill   4   ; Copy the next event into user-space.
>ff04						ReadData    .fill   4   ; Copy primary bulk event data into user-space
>ff08						ReadExt     .fill   4   ; Copy secondary bolk event data into user-space
>ff0c						Yield       .fill   4   ; Give unused time to the kernel.
>ff10						Putch       .fill   4   ; deprecated
>ff14						RunBlock    .fill   4   ; Chain to resident program by block ID.
>ff18						RunNamed    .fill   4   ; Chain to resident program by name.
>ff1c						            .fill   4   ; reserved
>ff20						List        .fill   4   ; Returns a bit-set of available block-accessible devices.
>ff24						GetName     .fill   4   ; Gets the hardware level name of the given block device or media.
>ff28						GetSize     .fill   4   ; Get the number of raw sectors (48 bits) for the given device
>ff2c						Read        .fill   4   ; Read a raw sector (48 bit LBA)
>ff30						Write       .fill   4   ; Write a raw sector (48 bit LBA)
>ff34						Format      .fill   4   ; Perform a low-level format if the media support it.
>ff38						Export      .fill   4   ; Update the FileSystem table with the partition table (if present).
>ff3c						List        .fill   4   ; Returns a bit-set of available logical devices.
>ff40						GetSize     .fill   4   ; Get the size of the partition or logical device in sectors.
>ff44						MkFS        .fill   4   ; Creates a new file-system on the logical device.
>ff48						CheckFS     .fill   4   ; Checks the file-system for errors and corrects them.
>ff4c						Mount       .fill   4   ; Mark the file-system as available for File and Directory operations.
>ff50						Unmount     .fill   4   ; Mark the file-system as unavailable for File and Directory operations.
>ff54						ReadBlock   .fill   4   ; Read a partition-local raw sector on an unmounted device.
>ff58						WriteBlock  .fill   4   ; Write a partition-local raw sector on an unmounted device.
>ff5c						Open        .fill   4   ; Open the given file for read, create, or append.
>ff60						Read        .fill   4   ; Request bytes from a file opened for reading.
>ff64						Write       .fill   4   ; Write bytes to a file opened for create or append.
>ff68						Close       .fill   4   ; Close an open file.
>ff6c						Rename      .fill   4   ; Rename a closed file.
>ff70						Delete      .fill   4   ; Delete a closed file.
>ff74						Seek        .fill   4   ; Seek to a specific position in a file.
>ff78						Open        .fill   4   ; Open a directory for reading.
>ff7c						Read        .fill   4   ; Read a directory entry; may also return VOLUME and FREE events.
>ff80						Close       .fill   4   ; Close a directory once finished reading.
>ff84						MkDir       .fill   4   ; Create a directory
>ff88						RmDir       .fill   4   ; Delete a directory
>ff8c						            .fill   4   ; call gate
>ff90						GetIP       .fill   4   ; Get the local IP address.
>ff94						SetIP       .fill   4   ; Set the local IP address.
>ff98						GetDNS      .fill   4   ; Get the configured DNS IP address.
>ff9c						SetDNS      .fill   4   ; Set the configured DNS IP address.
>ffa0						SendICMP    .fill   4
>ffa4						Match       .fill   4
>ffa8						Init        .fill   4
>ffac						Send        .fill   4
>ffb0						Recv        .fill   4
>ffb4						Open        .fill   4
>ffb8						Accept      .fill   4
>ffbc						Reject      .fill   4
>ffc0						Send        .fill   4
>ffc4						Recv        .fill   4
>ffc8						Close       .fill   4
>ffcc						Reset       .fill   4   ; Re-init the display
>ffd0						GetSize     .fill   4   ; Returns rows/cols in kernel args.
>ffd4						DrawRow     .fill   4   ; Draw text/color buffers left-to-right
>ffd8						DrawColumn  .fill   4   ; Draw text/color buffers top-to-bottom
>ffdc						GetTime     .fill   4
>ffe0						SetTime     .fill   4
>ffe4						            .fill   12  ; 65816 vectors
>fff0						SetTimer    .fill   4
.00f0						args
.00f0						events
>00f0						dest        .word       ?   ; GetNextEvent copies event data here
>00f2						pending     .byte       ?   ; Negative count of pending events
.00f3						end
.00f3						run
>00f3						block_id    .byte   ?
.00f3						recv
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.00f3						fs
.00f3						format
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.00f3						mkfs
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.00f3						file
.00f3						open
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>00f5						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.00f3						read
>00f3						stream      .byte       ?
>00f4						buflen      .byte       ?
.00f3						write
>00f3						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.00f3						seek
>00f3						stream      .byte       ?
>00f4						position    .dword      ?
.00f3						close
>00f3						stream      .byte       ?
.00f3						rename
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.00f3						delete
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>00f5						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.00f3						directory
.00f3						open
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.00f3						read
>00f3						stream      .byte       ?
>00f4						buflen      .byte       ?
.00f3						close
>00f3						stream      .byte       ?
.00f3						mkdir
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.00f3						rmdir
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.00f3						display
>00f3						x           .byte       ?   ; coordinate or size
>00f4						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
.00f3						net
=$fb						socket      = args.buf
>00f3						src_port    .word       ?
>00f5						dest_port   .word       ?
>00f7						dest_ip     .fill       4
>00f3						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
.00f3						config
.00f3						timer
>00f3						units       .byte       ?
=0						FRAMES      = 0
=1						SECONDS     = 1
=128						QUERY       = 128
>00f4						absolute    .byte       ?
>00f5						cookie      .byte       ?
=$f8						ext         = $f8
=$fa						extlen      = $fa
=$fb						buf         = $fb
=$fd						buflen      = $fd
=$fe						ptr         = $fe
.0000						events
>0000						dest        .word       ?   ; GetNextEvent copies event data here
>0002						pending     .byte       ?   ; Negative count of pending events
.0003						end
.0003						run
>0003						block_id    .byte   ?
.0003						recv
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0003						fs
.0003						format
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0003						mkfs
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0003						file
.0003						open
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0005						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0003						read
>0003						stream      .byte       ?
>0004						buflen      .byte       ?
.0003						write
>0003						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0003						seek
>0003						stream      .byte       ?
>0004						position    .dword      ?
.0003						close
>0003						stream      .byte       ?
.0003						rename
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.0003						delete
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0005						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0003						directory
.0003						open
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0003						read
>0003						stream      .byte       ?
>0004						buflen      .byte       ?
.0003						close
>0003						stream      .byte       ?
.0003						mkdir
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0003						rmdir
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0003						display
>0003						x           .byte       ?   ; coordinate or size
>0004						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
.0003						net
=$fb						socket      = args.buf
>0003						src_port    .word       ?
>0005						dest_port   .word       ?
>0007						dest_ip     .fill       4
>0003						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
.0003						config
.0003						timer
>0003						units       .byte       ?
=0						FRAMES      = 0
=1						SECONDS     = 1
=128						QUERY       = 128
>0004						absolute    .byte       ?
>0005						cookie      .byte       ?
=$f8						ext         = $f8
=$fa						extlen      = $fa
=$fb						buf         = $fb
=$fd						buflen      = $fd
=$fe						ptr         = $fe
>0000						dest        .word       ?   ; GetNextEvent copies event data here
>0002						pending     .byte       ?   ; Negative count of pending events
.0003						end
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
>0000						block_id    .byte   ?
.0000						format
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0000						mkfs
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0000						open
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0000						read
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						write
>0000						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0000						seek
>0000						stream      .byte       ?
>0001						position    .dword      ?
.0000						close
>0000						stream      .byte       ?
.0000						rename
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.0000						delete
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
>0000						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
>0000						stream      .byte       ?
>0001						position    .dword      ?
>0000						stream      .byte       ?
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fnane       = args.buf
=$fd						fname_len   = args.buflen
.0000						open
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0000						read
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						close
>0000						stream      .byte       ?
.0000						mkdir
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0000						rmdir
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
>0000						stream      .byte       ?
>0000						x           .byte       ?   ; coordinate or size
>0001						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
=$fb						socket      = args.buf
>0000						src_port    .word       ?
>0002						dest_port   .word       ?
>0004						dest_ip     .fill       4
>0000						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
>0000						units       .byte       ?
=0						FRAMES      = 0
=1						SECONDS     = 1
=128						QUERY       = 128
>0001						absolute    .byte       ?
>0002						cookie      .byte       ?
>0000						century     .byte       ?
>0001						year        .byte       ?
>0002						month       .byte       ?
>0003						day         .byte       ?
>0004						hours       .byte       ?
>0005						minutes     .byte       ?
>0006						seconds     .byte       ?
>0007						centis      .byte       ?
.0008						size
>0000						            .word   ?   ; Reserved
>0002						            .word   ?   ; Deprecated
>0004						JOYSTICK    .word   ?   ; Game Controller changes.
>0006						DEVICE      .word   ?   ; Device added/removed.
>0008						PRESSED     .word   ?   ; Key pressed
>000a						RELEASED    .word   ?   ; Key released.
>000c						DELTA       .word   ?   ; Regular mouse move and button state
>000e						CLICKS      .word   ?   ; Click counts
>0010						NAME        .word   ?
>0012						SIZE        .word   ?
>0014						DATA        .word   ?   ; The read request has succeeded.
>0016						WROTE       .word   ?   ; The write request has completed.
>0018						FORMATTED   .word   ?   ; The low-level format has completed.
>001a						ERROR       .word   ?
>001c						SIZE        .word   ?
>001e						CREATED     .word   ?
>0020						CHECKED     .word   ?
>0022						DATA        .word   ?   ; The read request has succeeded.
>0024						WROTE       .word   ?   ; The write request has completed.
>0026						ERROR       .word   ?
>0028						NOT_FOUND   .word   ?   ; The file file was not found.
>002a						OPENED      .word   ?   ; The file was successfully opened.
>002c						DATA        .word   ?   ; The read request has succeeded.
>002e						WROTE       .word   ?   ; The write request has completed.
>0030						EOF         .word   ?   ; All file data has been read.
>0032						CLOSED      .word   ?   ; The close request has completed.
>0034						RENAMED     .word   ?   ; The rename request has completed.
>0036						DELETED     .word   ?   ; The delete request has completed.
>0038						ERROR       .word   ?   ; An error occured; close the file if opened.
>003a						SEEK        .word   ?   ; The seek request has completed.
>003c						OPENED      .word   ?   ; The directory open request succeeded.
>003e						VOLUME      .word   ?   ; A volume record was found.
>0040						FILE        .word   ?   ; A file record was found.
>0042						FREE        .word   ?   ; A file-system free-space record was found.
>0044						EOF         .word   ?   ; All data has been read.
>0046						CLOSED      .word   ?   ; The directory file has been closed.
>0048						ERROR       .word   ?   ; An error occured; user should close.
>004a						CREATED     .word   ?   ; The directory has been created.
>004c						DELETED     .word   ?   ; The directory has been deleted.
>004e						TCP         .word   ?
>0050						UDP         .word   ?
>0052						EXPIRED     .word   ?
>0054						TICK        .word   ?
>0000						type        .byte   ?   ; Enum above
>0001						buf         .byte   ?   ; page id or zero
>0002						ext         .byte   ?   ; page id or zero
.0003						key
>0003						keyboard    .byte   ?   ; Keyboard ID
>0004						raw         .byte   ?   ; Raw key ID
>0005						ascii       .byte   ?   ; ASCII value
>0006						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.0003						mouse
.0003						delta
>0003						x           .byte   ?
>0004						y           .byte   ?
>0005						z           .byte   ?
>0006						buttons     .byte   ?
.0003						clicks
>0003						inner       .byte   ?
>0004						middle      .byte   ?
>0005						outer       .byte   ?
.0003						joystick
>0003						joy0        .byte   ?
>0004						joy1        .byte   ?
.0003						udp
>0003						token       .byte   ?   ; TODO: break out into fields
.0003						tcp
>0003						len         .byte   ?   ; Raw packet length.
.0003						file
>0003						stream      .byte   ?
>0004						cookie      .byte   ?
.0005						data
>0005						requested   .byte   ?   ; Requested number of bytes to read
>0006						read        .byte   ?   ; Number of bytes actually read
.0005						wrote
>0005						requested   .byte   ?   ; Requested number of bytes to read
>0006						wrote       .byte   ?   ; Number of bytes actually read
.0003						directory
>0003						stream      .byte   ?
>0004						cookie      .byte   ?
.0005						volume
>0005						len         .byte   ?   ; Length of volname (in buf)
>0006						flags       .byte   ?   ; block size, text encoding
.0005						file
>0005						len         .byte   ?
>0006						flags       .byte   ?   ; block scale, text encoding, approx size
.0005						free
>0005						flags       .byte   ?   ; block scale, text encoding, approx size
.0003						timer
>0003						value       .byte   ?
>0004						cookie      .byte   ?
>0000						keyboard    .byte   ?   ; Keyboard ID
>0001						raw         .byte   ?   ; Raw key ID
>0002						ascii       .byte   ?   ; ASCII value
>0003						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.0000						delta
>0000						x           .byte   ?
>0001						y           .byte   ?
>0002						z           .byte   ?
>0003						buttons     .byte   ?
.0000						clicks
>0000						inner       .byte   ?
>0001						middle      .byte   ?
>0002						outer       .byte   ?
>0000						x           .byte   ?
>0001						y           .byte   ?
>0002						z           .byte   ?
>0003						buttons     .byte   ?
>0000						inner       .byte   ?
>0001						middle      .byte   ?
>0002						outer       .byte   ?
>0000						joy0        .byte   ?
>0001						joy1        .byte   ?
>0000						stream      .byte   ?
>0001						cookie      .byte   ?
.0002						data
>0002						requested   .byte   ?   ; Requested number of bytes to read
>0003						read        .byte   ?   ; Number of bytes actually read
.0002						wrote
>0002						requested   .byte   ?   ; Requested number of bytes to read
>0003						wrote       .byte   ?   ; Number of bytes actually read
>0000						requested   .byte   ?   ; Requested number of bytes to read
>0001						read        .byte   ?   ; Number of bytes actually read
>0000						requested   .byte   ?   ; Requested number of bytes to read
>0001						wrote       .byte   ?   ; Number of bytes actually read
>0000						stream      .byte   ?
>0001						cookie      .byte   ?
.0002						volume
>0002						len         .byte   ?   ; Length of volname (in buf)
>0003						flags       .byte   ?   ; block size, text encoding
.0002						file
>0002						len         .byte   ?
>0003						flags       .byte   ?   ; block scale, text encoding, approx size
.0002						free
>0002						flags       .byte   ?   ; block scale, text encoding, approx size
>0000						len         .byte   ?   ; Length of volname (in buf)
>0001						flags       .byte   ?   ; block size, text encoding
>0000						len         .byte   ?
>0001						flags       .byte   ?   ; block scale, text encoding, approx size
>0000						flags       .byte   ?   ; block scale, text encoding, approx size
>0000						free        .fill   6   ; blocks used/free
>0000						token       .byte   ?   ; TODO: break out into fields
>0000						len         .byte   ?   ; Raw packet length.
>0000						value       .byte   ?
>0001						cookie      .byte   ?

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8530						AssembleGroup1:
.8530		a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.8532		8d 41 04	sta $0441			sta 	ModeMask 					; initialise the mode mask - all for all
.8535		80 02		bra $8539			bra 	AsmGroup12
.8537						AssembleGroup2:
.8537		a9 00		lda #$00			lda 	#$00 						; flag for group 2
.8539						AsmGroup12:
.8539		8d 3f 04	sta $043f			sta 	IsGroup1 					; save the 'group 1' flag
.853c		68		pla				pla 								; pop the return address to access the information following.
.853d		fa		plx				plx
.853e		20 c5 85	jsr $85c5			jsr 	AccessParameters 			; get opcode and save as base
.8541		8d 40 04	sta $0440			sta 	BaseOpcode
.8544		ad 3f 04	lda $043f			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8547		d0 08		bne $8551			bne 	_AG12HaveMask
.8549		a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.854b		20 cd 85	jsr $85cd			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.854e		8d 41 04	sta $0441			sta 	ModeMask
.8551						_AG12HaveMask:
.8551		20 01 87	jsr $8701			jsr 	TypeAndCalculateOperand 	; get zero page type
.8554		da		phx				phx 								; save found address mode
.8555		20 31 86	jsr $8631			jsr 	AssembleModeX
.8558		fa		plx				plx  								; restore address mode
.8559		b0 0b		bcs $8566			bcs 	_AG12Exit
.855b		20 67 85	jsr $8567			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.855e		20 31 86	jsr $8631			jsr 	AssembleModeX
.8561		b0 03		bcs $8566			bcs 	_AG12Exit
.8563		4c 2e a6	jmp $a62e			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8566						_AG12Exit:
.8566		60		rts				rts
.8567						PromoteToAbsolute:
.8567		a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.8569		e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.856b		f0 19		beq $8586			beq 	_PTADo
.856d		a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.856f		e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.8571		f0 13		beq $8586			beq 	_PTADo
.8573		a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.8575		e0 80		cpx #$80			cpx 	#AM_ZEROY
.8577		f0 0d		beq $8586			beq 	_PTADo
.8579		a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.857b		e0 d1		cpx #$d1			cpx 	#AM_IND
.857d		f0 07		beq $8586			beq 	_PTADo
.857f		a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8581		e0 c0		cpx #$c0			cpx 	#AM_INDX
.8583		f0 01		beq $8586			beq 	_PTADo
.8585		60		rts				rts
.8586						_PTADo:
.8586		aa		tax				tax
.8587		60		rts				rts
.8588						AssembleGroup3:
.8588		68		pla				pla 								; get parameters, which is just the opcode.
.8589		fa		plx				plx
.858a		20 c5 85	jsr $85c5			jsr 	AccessParameters 			; get and output opcode
.858d		20 dd 85	jsr $85dd			jsr 	AssemblerWriteByte
.8590		20 65 87	jsr $8765			jsr 	CalculateOperand 			; get a 16 bit operand
.8593		a5 60		lda $60				lda 	NSMantissa0 				; calculate the offset
.8595		38		sec				sec
.8596		ed 3a 04	sbc $043a			sbc 	AssemblerAddress
.8599		48		pha				pha 								; LSB in A
.859a		a5 70		lda $70				lda 	NSMantissa1
.859c		ed 3b 04	sbc $043b			sbc 	AssemblerAddress+1
.859f		aa		tax				tax 								; MSB in X
.85a0		68		pla				pla
.85a1		18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.85a2		69 7f		adc #$7f			adc 	#$7F
.85a4		90 01		bcc $85a7			bcc 	_AG3NoCarry
.85a6		e8		inx				inx
.85a7						_AG3NoCarry:
.85a7		38		sec				sec 								; fix back and write out anyways.
.85a8		e9 80		sbc #$80			sbc 	#$80
.85aa		20 dd 85	jsr $85dd			jsr 	AssemblerWriteByte
.85ad		e0 00		cpx #$00			cpx 	#0 							; was it in range
.85af		f0 0a		beq $85bb			beq 	_AG3Exit
.85b1		ad 3c 04	lda $043c			lda 	AssemblerControl 			; are we allowing bad values ?
.85b4		29 01		and #$01			and 	#1
.85b6		f0 03		beq $85bb			beq 	_AG3Exit
.85b8		4c 33 a6	jmp $a633			jmp 	RangeError 					; no, branch is out of range
.85bb						_AG3Exit:
.85bb		60		rts				rts
.85bc						AssembleGroup4:
.85bc		68		pla				pla 								; pop address
.85bd		fa		plx				plx
.85be		20 c5 85	jsr $85c5			jsr 	AccessParameters 			; access and get first
.85c1		20 dd 85	jsr $85dd			jsr 	AssemblerWriteByte 			; output it.
.85c4		60		rts				rts
.85c5						AccessParameters:
.85c5		8d 3d 04	sta $043d			sta 	ParamStart
.85c8		8e 3e 04	stx $043e			stx 	ParamStart+1
.85cb		a9 01		lda #$01			lda 	#1
.85cd						GetParameter:
.85cd		5a		phy				phy
.85ce		a8		tay				tay
.85cf		ad 3d 04	lda $043d			lda 	ParamStart
.85d2		85 36		sta $36				sta 	zTemp0
.85d4		ad 3e 04	lda $043e			lda 	ParamStart+1
.85d7		85 37		sta $37				sta 	zTemp0+1
.85d9		b1 36		lda ($36),y			lda 	(zTemp0),y
.85db		7a		ply				ply
.85dc		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.85dd						AssemblerWriteByte:
.85dd		48		pha			pha
.85de		ad 3c 04	lda $043c		lda 	AssemblerControl 				; check printing bytes ?
.85e1		29 02		and #$02		and 	#2
.85e3		f0 1b		beq $8600		beq 	_AWBNoPrint
.85e5		ad 3b 04	lda $043b		lda		AssemblerAddress+1 				; print address
.85e8		20 1b 86	jsr $861b		jsr 	PrintHex
.85eb		ad 3a 04	lda $043a		lda		AssemblerAddress
.85ee		20 1b 86	jsr $861b		jsr 	PrintHex
.85f1		a9 20		lda #$20		lda 	#' '
.85f3		20 4d 80	jsr $804d		jsr 	EXTPrintCharacter
.85f6		68		pla			pla 									; print byte
.85f7		48		pha			pha
.85f8		20 1b 86	jsr $861b		jsr 	PrintHex
.85fb		a9 0d		lda #$0d		lda 	#13
.85fd		20 4d 80	jsr $804d		jsr 	EXTPrintCharacter
.8600						_AWBNoPrint:
.8600		ad 3a 04	lda $043a		lda		AssemblerAddress				; copy address to zTemp0
.8603		85 36		sta $36			sta 	zTemp0
.8605		ad 3b 04	lda $043b		lda		AssemblerAddress+1
.8608		f0 0e		beq $8618		beq 	_AWBRange
.860a		85 37		sta $37			sta 	zTemp0+1
.860c		68		pla			pla 									; write byte out
.860d		92 36		sta ($36)		sta 	(zTemp0)
.860f		ee 3a 04	inc $043a		inc 	AssemblerAddress 				; bump address
.8612		d0 03		bne $8617		bne 	_AWBNoCarry
.8614		ee 3b 04	inc $043b		inc 	AssemblerAddress+1
.8617						_AWBNoCarry:
.8617		60		rts			rts
.8618						_AWBRange:
.8618		4c 33 a6	jmp $a633		jmp 	RangeError
.861b						PrintHex:
.861b		48		pha				pha
.861c		4a		lsr a				lsr 	a
.861d		4a		lsr a				lsr 	a
.861e		4a		lsr a				lsr 	a
.861f		4a		lsr a				lsr 	a
.8620		20 24 86	jsr $8624			jsr 	_PrintNibble
.8623		68		pla				pla
.8624						_PrintNibble:
.8624		29 0f		and #$0f			and 	#15
.8626		c9 0a		cmp #$0a			cmp 	#10
.8628		90 02		bcc $862c			bcc 	_NoShift
.862a		69 06		adc #$06			adc 	#6
.862c						_NoShift:
.862c		69 30		adc #$30			adc 	#48
.862e		4c 4d 80	jmp $804d			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8631						AssembleModeX:
.8631		5a		phy				phy
.8632		ad 3f 04	lda $043f			lda 	IsGroup1
.8635		f0 17		beq $864e			beq 	_AMXGroup2
.8637		8a		txa				txa 							; is it in group # 1
.8638		29 40		and #$40			and 	#AM_ISG1
.863a		f0 4d		beq $8689			beq 	_AMXFail 				; no, give up.
.863c		8a		txa				txa 							; get back.
.863d		29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.863f		e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8641		d0 22		bne $8665			bne 	_AMXHaveInfo
.8643		ad 40 04	lda $0440			lda 	BaseOpcode 				; cannot store immediate.
.8646		c9 81		cmp #$81			cmp 	#$81
.8648		f0 3f		beq $8689			beq 	_AMXFail
.864a		a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.864c		80 17		bra $8665			bra 	_AMXHaveInfo 			; odd design decision there.
.864e						_AMXGroup2:
.864e		8a		txa				txa 							; is it in group 2 ?
.864f		29 20		and #$20			and 	#AM_ISG2
.8651		f0 36		beq $8689			beq 	_AMXFail 				; no, give up.
.8653		8a		txa				txa 							; get the offset into Y
.8654		29 1f		and #$1f			and 	#$1F
.8656		4a		lsr a				lsr 	a 						; make it 0-7.
.8657		4a		lsr a				lsr  	a
.8658		a8		tay				tay
.8659		ad 41 04	lda $0441			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.865c						_AMXCheckOkay:
.865c		0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.865d		88		dey				dey
.865e		10 fc		bpl $865c			bpl 	_AMXCheckOkay
.8660		90 27		bcc $8689			bcc 	_AMXFail 				; not allowed.
.8662		8a		txa				txa  							; get mask back
.8663		29 1f		and #$1f			and 	#$1F
.8665						_AMXHaveInfo:
.8665		e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.8667		10 04		bpl $866d			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.8669		a4 70		ldy $70				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.866b		d0 1c		bne $8689			bne 	_AMXFail
.866d						_AMXAnySize:
.866d		18		clc				clc 							; add offset to the base opcode
.866e		6d 40 04	adc $0440			adc 	BaseOpcode
.8671						_AMXOutputCode:
.8671		20 dd 85	jsr $85dd			jsr 	AssemblerWriteByte 		; write the opcode out.
.8674		e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.8676		f0 0e		beq $8686			beq 	_AMXExit
.8678		a5 60		lda $60				lda 	NSMantissa0 			; write LSB operand
.867a		20 dd 85	jsr $85dd			jsr 	AssemblerWriteByte
.867d		e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.867f		30 05		bmi $8686			bmi 	_AMXExit
.8681		a5 70		lda $70				lda 	NSMantissa1 			; write MSB operand
.8683		20 dd 85	jsr $85dd			jsr 	AssemblerWriteByte
.8686						_AMXExit:
.8686		7a		ply				ply
.8687		38		sec				sec
.8688		60		rts				rts
.8689						_AMXFail:
.8689		a0 00		ldy #$00			ldy 	#0
.868b						_AMXCheckOddities:
.868b		8a		txa				txa
.868c		d9 b3 86	cmp $86b3,y			cmp 	ExtraOpcode+2,y 		; match address mode
.868f		d0 15		bne $86a6			bne 	_AMXCONext
.8691		b9 b1 86	lda $86b1,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.8694		cd 40 04	cmp $0440			cmp 	BaseOpcode
.8697		d0 0d		bne $86a6			bne 	_AMXCONext
.8699		e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.869b		10 04		bpl $86a1			bpl 	_AMXCONotZero
.869d		a5 70		lda $70				lda 	NSMantissa1
.869f		d0 05		bne $86a6			bne 	_AMXCONext
.86a1						_AMXCONotZero:
.86a1		b9 b2 86	lda $86b2,y			lda 	ExtraOpcode+1,y 		; get new opcode
.86a4		80 cb		bra $8671			bra 	_AMXOutputCode 			; and assemble it
.86a6						_AMXCONext:
.86a6		c8		iny				iny
.86a7		c8		iny				iny
.86a8		c8		iny				iny
.86a9		b9 b1 86	lda $86b1,y			lda 	ExtraOpcode+0,y 		; end of table
.86ac		d0 dd		bne $868b			bne 	_AMXCheckOddities
.86ae						_AMXCOFail:
.86ae		7a		ply				ply
.86af		18		clc				clc
.86b0		60		rts				rts
.86b1						ExtraOpcode:
>86b1		40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>86b4		40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>86b7		a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>86ba		a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>86bd		82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>86c0		e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>86c3		c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>86c6		20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>86c9		60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>86cc		60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>86cf		00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.86d0						LabelHere:
.86d0		c8		iny				iny 								; skip .
.86d1		a2 00		ldx #$00			ldx 	#0 							; get a term
.86d3		20 aa 9e	jsr $9eaa			jsr 	EvaluateTerm
.86d6		a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.86d8		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.86da		d0 22		bne $86fe			bne 	_ALType 					; otherwise typing error
.86dc		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.86de		85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.86e0		b5 70		lda $70,x			lda 	NSMantissa1,x
.86e2		85 37		sta $37				sta 	zTemp0+1
.86e4		5a		phy				phy 								; copy address in (64k)
.86e5		a0 01		ldy #$01			ldy 	#1
.86e7		ad 3a 04	lda $043a			lda	 	AssemblerAddress
.86ea		92 36		sta ($36)			sta 	(zTemp0)
.86ec		ad 3b 04	lda $043b			lda	 	AssemblerAddress+1
.86ef		91 36		sta ($36),y			sta 	(zTemp0),y
.86f1		c8		iny				iny
.86f2		a9 00		lda #$00			lda 	#0 							; zero the rest.
.86f4		91 36		sta ($36),y			sta 	(zTemp0),y
.86f6		c8		iny				iny
.86f7		91 36		sta ($36),y			sta 	(zTemp0),y
.86f9		c8		iny				iny
.86fa		91 36		sta ($36),y			sta 	(zTemp0),y
.86fc		7a		ply				ply
.86fd		60		rts				rts
.86fe						_ALType:
.86fe		4c 38 a6	jmp $a638			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8701						TypeAndCalculateOperand:
.8701		b1 30		lda ($30),y			lda 	(codePtr),y
.8703		a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8705		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8707		f0 5b		beq $8764			beq 	_TACOExit
.8709		c9 80		cmp #$80			cmp 	#KWC_EOL
.870b		f0 57		beq $8764			beq 	_TACOExit
.870d		c8		iny				iny
.870e		a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8710		c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8712		f0 51		beq $8765			beq 	CalculateOperand
.8714		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8716		f0 1f		beq $8737			beq 	_TACOIndirect
.8718		88		dey				dey 								; undo get of first character
.8719		20 65 87	jsr $8765			jsr 	CalculateOperand 			; get operand
.871c		b1 30		lda ($30),y			lda 	(codePtr),y
.871e		a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8720		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8722		d0 40		bne $8764			bne 	_TACOExit
.8724		c8		iny				iny
.8725		20 6f 87	jsr $876f			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8728		a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.872a		c9 58		cmp #$58			cmp 	#'X'
.872c		f0 36		beq $8764			beq 	_TACOExit
.872e		a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8730		c9 59		cmp #$59			cmp 	#'Y'
.8732		f0 30		beq $8764			beq 	_TACOExit
.8734						_TACOSyntax:
.8734		4c 2e a6	jmp $a62e			jmp 	SyntaxError
.8737						_TACOIndirect:
.8737		20 65 87	jsr $8765			jsr 	CalculateOperand 			; get the operand
.873a		b1 30		lda ($30),y			lda 	(codePtr),y
.873c		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.873e		f0 17		beq $8757			beq 	_TACOIndX
.8740		20 34 95	jsr $9534			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8743		b1 30		lda ($30),y			lda 	(codePtr),y
.8745		a2 d1		ldx #$d1			ldx 	#AM_IND
.8747		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.8749		d0 19		bne $8764			bne 	_TACOExit
.874b		c8		iny				iny
.874c		20 6f 87	jsr $876f			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.874f		c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8751		d0 e1		bne $8734			bne 	_TACOSyntax
.8753		a2 d0		ldx #$d0			ldx 	#AM_INDY
.8755		80 0d		bra $8764			bra 	_TACOExit
.8757						_TACOIndX:
.8757		c8		iny				iny
.8758		20 6f 87	jsr $876f			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.875b		c9 58		cmp #$58			cmp 	#'X' 						; check X
.875d		d0 d5		bne $8734			bne 	_TACOSyntax
.875f		20 34 95	jsr $9534			jsr 	CheckRightBracket			; check )
.8762		a2 c0		ldx #$c0			ldx 	#AM_INDX
.8764						_TACOExit:
.8764		60		rts				rts
.8765						CalculateOperand:
.8765		48		pha				pha
.8766		da		phx				phx
.8767		a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.8769		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger
.876c		fa		plx				plx
.876d		68		pla				pla
.876e		60		rts				rts
.876f						TACOCheckXY:
.876f		b1 30		lda ($30),y			lda 	(codePtr),y
.8771		29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.8773		c9 40		cmp #$40			cmp 	#$40
.8775		d0 21		bne $8798			bne 	_TCXYFail
.8777		b1 30		lda ($30),y			lda 	(codePtr),y
.8779		18		clc				clc
.877a		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.877c		85 37		sta $37				sta 	zTemp0+1
.877e		c8		iny				iny
.877f		b1 30		lda ($30),y			lda 	(codePtr),y
.8781		c8		iny				iny
.8782		85 36		sta $36				sta 	zTemp0
.8784		5a		phy				phy 								; save position
.8785		a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.8787		b1 36		lda ($36),y			lda 	(zTemp0),y
.8789		d0 0c		bne $8797			bne 	_TCXYPopFail
.878b		a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.878d		b1 36		lda ($36),y			lda 	(zTemp0),y
.878f		c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.8791		f0 08		beq $879b			beq 	_TCXYFound
.8793		c9 d9		cmp #$d9			cmp 	#'Y'+$80
.8795		f0 04		beq $879b			beq 	_TCXYFound
.8797						_TCXYPopFail:
.8797		7a		ply				ply
.8798						_TCXYFail:
.8798		a9 00		lda #$00			lda 	#0
.879a		60		rts				rts
.879b						_TCXYFound:
.879b		7a		ply				ply 								; restore position
.879c		29 7f		and #$7f			and 	#$7F 						; throw bit 7
.879e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.879f						BackloadProgram:
.879f		20 75 8f	jsr $8f75			jsr 	NewProgram 					; does the actual NEW.
.87a2		a2 87		ldx #$87			ldx 	#_BLLoad >> 8
.87a4		a9 ff		lda #$ff			lda 	#_BLLoad & $FF
.87a6		20 ac 95	jsr $95ac			jsr 	PrintStringXA
.87a9		a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; start page
.87ab		8d c5 07	sta $07c5			sta 	BackLoadPage
.87ae		a9 00		lda #$00			lda 	#(($6000) & $FF)
.87b0		8d c6 07	sta $07c6			sta 	0+BackLoadPointer
.87b3		a9 60		lda #$60			lda 	#(($6000) >> 8)
.87b5		8d c7 07	sta $07c7			sta 	1+BackLoadPointer
.87b8		9c c8 07	stz $07c8			stz 	BackLoadLast 				; reset backload last.
.87bb		9c c9 07	stz $07c9			stz 	BackLoadLast+1
.87be		a9 ff		lda #$ff			lda 	#$FF
.87c0		8d fa ff	sta $fffa			sta 	$FFFA
.87c3						_BPLoop:
.87c3		a2 ff		ldx #$ff			ldx 	#$FF
.87c5		20 34 88	jsr $8834			jsr 	BLReadByte 					; read a byte
.87c8		c9 00		cmp #$00			cmp 	#0
.87ca		f0 2c		beq $87f8			beq 	_BPExit 					; if 0 exit
.87cc		30 2a		bmi $87f8			bmi 	_BPExit 					; if -ve exit
.87ce						_BPCopy:
.87ce		e8		inx				inx  								; copy byte into the lineBuffer
.87cf		9d 46 05	sta $0546,x			sta 	lineBuffer,x
.87d2		9e 47 05	stz $0547,x			stz 	lineBuffer+1,x
.87d5		20 34 88	jsr $8834			jsr 	BLReadByte 					; read next byte
.87d8		30 0a		bmi $87e4			bmi 	_BPEndLine 					; -ve = EOL
.87da		c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.87dc		d0 02		bne $87e0			bne 	_BPNotTab
.87de		a9 20		lda #$20			lda 	#' '
.87e0						_BPNotTab:
.87e0		c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.87e2		b0 ea		bcs $87ce			bcs 	_BPCopy 					; until a control character, should be 13 received.
.87e4						_BPEndLine:
.87e4		20 93 80	jsr $8093			jsr 	TKTokeniseLine 				; tokenise the line.
.87e7		ad 47 04	lda $0447			lda 	tokenLineNumber 			; line number = 0
.87ea		0d 48 04	ora $0448			ora 	tokenLineNumber+1
.87ed		f0 d4		beq $87c3			beq 	_BPLoop 					; not legal code, blank line or maybe a comment.
.87ef		20 14 88	jsr $8814			jsr 	BLCheckLast 				; check last backload okay.
.87f2		38		sec				sec 								; append not insert
.87f3		20 71 a8	jsr $a871			jsr 	MemoryInsertLine 			; append to current program
.87f6		80 cb		bra $87c3			bra 	_BPLoop
.87f8						_BPExit:
.87f8		9c fa ff	stz $fffa			stz 	$FFFA
.87fb		20 d9 93	jsr $93d9			jsr 	ClearSystem 				; clear variables etc.
.87fe		60		rts				rts
.87ff						_BLLoad:
>87ff		4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8807		66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.8814						BLCheckLast:
.8814		ad c8 07	lda $07c8			lda 	BackLoadLast 				; check last < current
.8817		cd 47 04	cmp $0447			cmp 	tokenLineNumber
.881a		ad c9 07	lda $07c9			lda 	BackLoadLast+1
.881d		ed 48 04	sbc $0448			sbc 	tokenLineNumber+1
.8820		b0 0d		bcs $882f			bcs 	_BLCheckFail
.8822		ad 47 04	lda $0447			lda 	tokenLineNumber 			; update
.8825		8d c8 07	sta $07c8			sta 	BackLoadLast
.8828		ad 48 04	lda $0448			lda 	tokenLineNumber+1
.882b		8d c9 07	sta $07c9			sta 	BackLoadLast+1
.882e		60		rts				rts
.882f						_BLCheckFail:
.882f		a9 02		lda #$02		lda	#2
.8831		4c 4d 95	jmp $954d		jmp	ErrorHandler
.8834						BLReadByte:
.8834		da		phx				phx
.8835		a6 0b		ldx $0b				ldx 	8+3 						; save current mapping for $6000 in X
.8837		ad c5 07	lda $07c5			lda 	BackLoadPage	 			; set current page
.883a		85 0b		sta $0b				sta 	8+3
.883c		ad c6 07	lda $07c6			lda 	BackLoadPointer 			; copy pointer to zTemp0
.883f		85 36		sta $36				sta 	zTemp0
.8841		ad c7 07	lda $07c7			lda 	BackLoadPointer+1
.8844		85 37		sta $37				sta 	zTemp0+1
.8846		b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8848		ee c6 07	inc $07c6			inc 	BackLoadPointer 			; bump pointer
.884b		d0 0f		bne $885c			bne 	_BLNoCarry
.884d		ee c7 07	inc $07c7			inc 	BackLoadPointer+1
.8850		10 0a		bpl $885c			bpl 	_BLNoCarry 					; need a new page
.8852		48		pha				pha
.8853		a9 60		lda #$60			lda 	#$60 						; reset pointer
.8855		8d c7 07	sta $07c7			sta 	BackLoadPointer+1
.8858		ee c5 07	inc $07c5			inc 	BackLoadPage 				; next page from source.
.885b		68		pla				pla
.885c						_BLNoCarry:
.885c		86 0b		stx $0b				stx 	8+3 						; restore mapping, then X.
.885e		fa		plx				plx
.885f		c9 00		cmp #$00			cmp 	#0
.8861		60		rts				rts
.07c5						BackLoadPage:
>07c5								.fill  	1
.07c6						BackLoadPointer:
>07c6								.fill 	2
.07c8						BackLoadLast:
>07c8								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8862						EditProgramCode:
.8862		ad 47 04	lda $0447			lda 	tokenLineNumber 			; try to find the line.
.8865		ae 48 04	ldx $0448			ldx 	tokenLineNumber+1
.8868		20 15 a9	jsr $a915			jsr 	MemorySearch
.886b		90 05		bcc $8872			bcc 	_EPCNoDelete 				; reached the end : don't delete
.886d		d0 03		bne $8872			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.886f		20 3a a8	jsr $a83a			jsr 	MemoryDeleteLine 			; delete the line
.8872						_EPCNoDelete:
.8872		ad 49 04	lda $0449			lda 	tokenBuffer 				; buffer empty - we just want to delete a line.
.8875		c9 80		cmp #$80			cmp 	#KWC_EOL
.8877		f0 0d		beq $8886			beq 	_EPCNoInsert
.8879		ad 47 04	lda $0447			lda 	tokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.887c		ae 48 04	ldx $0448			ldx 	tokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.887f		20 15 a9	jsr $a915			jsr 	MemorySearch
.8882		18		clc				clc 								; insert at this point.
.8883		20 71 a8	jsr $a871			jsr 	MemoryInsertLine 			; insert the line
.8886						_EPCNoInsert:
.8886		a9 01		lda #$01			lda		#1
.8888		8d 75 06	sta $0675			sta		programChanged				; mark program changed
.888b		60		rts				rts
.888c						ResetTokenBuffer:
.888c		a9 03		lda #$03			lda		#3					; reset the token buffer to empty
.888e		8d 46 04	sta $0446			sta		tokenOffset			; (3 bytes for line number & offset)
.8891		9c 47 04	stz $0447			stz		tokenLineNumber
.8894		9c 48 04	stz $0448			stz		tokenLineNumber+1
.8897		a9 46		lda #$46			lda 	#((tokenOffset) & $FF)
.8899		85 30		sta $30				sta 	codePtr
.889b		a9 04		lda #$04			lda 	#((tokenOffset) >> 8)
.889d		85 31		sta $31				sta 	codePtr+1
.889f		60		rts				rts
.88a0						IsDestructiveActionOK:
.88a0		ad 75 06	lda $0675			lda		programChanged
.88a3		f0 31		beq $88d6			beq		_ok_exit
.88a5		a2 88		ldx #$88			ldx 	#_continue >> 8 	; print confirmation prompt
.88a7		a9 e4		lda #$e4			lda 	#_continue & $FF
.88a9		20 ac 95	jsr $95ac			jsr 	PrintStringXA
.88ac						_next_char
.88ac		20 f5 81	jsr $81f5			jsr		KNLGetSingleCharacter
.88af		c9 79		cmp #$79			cmp		#'y'
.88b1		f0 16		beq $88c9			beq		_ok
.88b3		c9 59		cmp #$59			cmp		#'Y'
.88b5		f0 12		beq $88c9			beq		_ok
.88b7		c9 1b		cmp #$1b			cmp		#27
.88b9		f0 1d		beq $88d8			beq		_not_ok
.88bb		c9 6e		cmp #$6e			cmp		#'n'
.88bd		f0 19		beq $88d8			beq		_not_ok
.88bf		c9 4e		cmp #$4e			cmp		#'N'
.88c1		f0 15		beq $88d8			beq		_not_ok
.88c3		c9 0d		cmp #$0d			cmp		#13
.88c5		f0 11		beq $88d8			beq		_not_ok
.88c7		80 e3		bra $88ac			bra		_next_char
.88c9						_ok:
.88c9		a9 59		lda #$59			lda		#'Y'
.88cb		20 4d 80	jsr $804d			jsr		EXTPrintCharacter
.88ce		a9 0d		lda #$0d			lda		#13
.88d0		20 4d 80	jsr $804d			jsr		EXTPrintCharacter
.88d3		9c 75 06	stz $0675			stz		programChanged
.88d6						_ok_exit:
.88d6		18		clc				clc
.88d7		60		rts				rts
.88d8						_not_ok:
.88d8		a9 4e		lda #$4e			lda		#'N'
.88da		20 4d 80	jsr $804d			jsr		EXTPrintCharacter
.88dd		a9 0d		lda #$0d			lda		#13
.88df		20 4d 80	jsr $804d			jsr		EXTPrintCharacter
.88e2		38		sec				sec
.88e3		60		rts				rts
.88e4						_continue:
>88e4		50 72 6f 67 72 61 6d 20				.text	"Program has unsaved changes, continue (y/N)? ",0
>88ec		68 61 73 20 75 6e 73 61 76 65 64 20 63 68 61 6e
>88fc		67 65 73 2c 20 63 6f 6e 74 69 6e 75 65 20 28 79
>890c		2f 4e 29 3f 20 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8912						WarmStart:
.8912		a2 ff		ldx #$ff			ldx 	#$FF
.8914		9a		txs				txs
.8915		a9 89		lda #$89			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.8917		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.891a		20 38 82	jsr $8238			jsr 	InputLine 					; get line to lineBuffer
.891d		ad 46 05	lda $0546			lda 	lineBuffer 					; first character is slash
.8920		c9 2f		cmp #$2f			cmp 	#"/"
.8922		d0 07		bne $892b			bne 	_WSNotSlash
.8924		a2 05		ldx #$05			ldx 	#(lineBuffer+1) >> 8 		; boot rest of line.
.8926		a9 47		lda #$47			lda 	#(lineBuffer+1) & $FF
.8928		4c 98 ad	jmp $ad98			jmp 	BootXA
.892b						_WSNotSlash:
.892b		20 93 80	jsr $8093			jsr 	TKTokeniseLine 				; tokenise the line
.892e		ad 47 04	lda $0447			lda 	tokenLineNumber 			; line number <> 0
.8931		0d 48 04	ora $0448			ora 	tokenLineNumber+1
.8934		d0 17		bne $894d			bne 	_WSEditCode 				; if so,edit code.
.8936		9c 46 04	stz $0446			stz 	tokenOffset 				; zero the "offset", meaning it only runs one line.
.8939		a9 46		lda #$46			lda 	#((tokenOffset) & $FF)
.893b		85 30		sta $30				sta 	codePtr
.893d		a9 04		lda #$04			lda 	#((tokenOffset) >> 8)
.893f		85 31		sta $31				sta 	codePtr+1
.8941		ad 49 04	lda $0449			lda 	tokenBuffer 				; nothing to run
.8944		c9 80		cmp #$80			cmp 	#KWC_EOL
.8946		f0 ca		beq $8912			beq 	WarmStart
.8948		20 30 91	jsr $9130			jsr 	RUNCodePointerLine 			; execute that line.
.894b		80 c5		bra $8912			bra 	WarmStart
.894d						_WSEditCode:
.894d		20 62 88	jsr $8862			jsr 	EditProgramCode 			; edit the program code
.8950		20 d9 93	jsr $93d9			jsr 	ClearSystem 				; clear all variables etc.
.8953		80 bd		bra $8912			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8955						AssembleCommand:
.8955		a2 00		ldx #$00			ldx 	#0
.8957		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger 		; start address
.895a		a5 60		lda $60				lda 	NSMantissa0
.895c		8d 3a 04	sta $043a			sta 	AssemblerAddress
.895f		a5 70		lda $70				lda 	NSMantissa1
.8961		8d 3b 04	sta $043b			sta 	AssemblerAddress+1
.8964		20 3c 95	jsr $953c			jsr 	CheckComma
.8967		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; options 0-3
.896a		a5 60		lda $60				lda 	NSMantissa0
.896c		8d 3c 04	sta $043c			sta 	AssemblerControl
.896f		60		rts				rts
.8970		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.8971						AssertCommand:
.8971		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8973		20 23 a4	jsr $a423			jsr 	EvaluateInteger 			; the assert test
.8976		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; exit if result is non zero.
.8979		d0 05		bne $8980			bne 	_ACExit
.897b		a9 0a		lda #$0a		lda	#10
.897d		4c 4d 95	jmp $954d		jmp	ErrorHandler
.8980						_ACExit:
.8980		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.8981						CallCommand:
.8981		a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.8983		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger
.8986						_CCClear
.8986		e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.8987		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero 					; these are optional sequentially.
.898a		e0 04		cpx #$04			cpx 	#4
.898c		d0 f8		bne $8986			bne 	_CCClear
.898e		a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.8990						_CCCParam:
.8990		b1 30		lda ($30),y			lda 	(codePtr),y
.8992		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8994		d0 09		bne $899f			bne 	_CCCRun6502
.8996		c8		iny				iny 								; skip comma
.8997		e8		inx				inx	 								; next level
.8998		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; get A/X/Y
.899b		e0 03		cpx #$03			cpx 	#3
.899d		90 f1		bcc $8990			bcc 	_CCCParam 					; done all 3 ?
.899f						_CCCRun6502:
.899f		5a		phy				phy 								; save position
.89a0		a5 70		lda $70				lda 	NSMantissa1 				; put address in zTemp0
.89a2		85 37		sta $37				sta 	zTemp0+1
.89a4		a5 60		lda $60				lda 	NSMantissa0
.89a6		85 36		sta $36				sta 	zTemp0
.89a8		a5 61		lda $61				lda 	NSMantissa0+1 				; get registers into A X Y
.89aa		a6 62		ldx $62				ldx 	NSMantissa0+2
.89ac		a4 63		ldy $63				ldy 	NSMantissa0+3
.89ae		20 b3 89	jsr $89b3			jsr 	_CCCZTemp0 					; call zTemp0
.89b1		7a		ply				ply 								; restore position and exit
.89b2		60		rts				rts
.89b3						_CCCZTemp0:
.89b3		6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.89b6						Command_Data:
.89b6		a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.89b8		a2 80		ldx #$80			ldx 	#KWC_EOL
.89ba		20 8f 94	jsr $948f			jsr 	ScanForward
.89bd		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.89be						DimCommand:
.89be		b1 30		lda ($30),y			lda 	(codePtr),y
.89c0		29 c0		and #$c0			and 	#$C0
.89c2		c9 40		cmp #$40			cmp 	#$40
.89c4		d0 7a		bne $8a40			bne 	_DCSyntax 				; n o, error.
.89c6		b1 30		lda ($30),y			lda 	(codePtr),y
.89c8		18		clc				clc
.89c9		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.89cb		85 3f		sta $3f				sta 	zaTemp+1
.89cd		c8		iny				iny
.89ce		b1 30		lda ($30),y			lda 	(codePtr),y
.89d0		c8		iny				iny
.89d1		85 3e		sta $3e				sta 	zaTemp
.89d3		5a		phy				phy
.89d4		a0 02		ldy #$02			ldy 	#2 						; read type byte
.89d6		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.89d8		29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.89da		c9 18		cmp #$18			cmp 	#NSTProcedure
.89dc		f0 62		beq $8a40			beq 	_DCSyntax
.89de		b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.89e0		29 04		and #$04			and 	#NSBIsArray
.89e2		f0 64		beq $8a48			beq 	_DCType
.89e4		a0 04		ldy #$04			ldy 	#4 						; check not already defined
.89e6		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.89e8		d0 59		bne $8a43			bne 	_DCRedefine
.89ea		7a		ply				ply
.89eb		20 4b 8a	jsr $8a4b			jsr 	_DCGetSize 				; get array size, check it.
.89ee		5a		phy				phy
.89ef		a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.89f1		91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.89f3		7a		ply				ply 							; is there a second (e.g. ,x)
.89f4		b1 30		lda ($30),y			lda 	(codePtr),y
.89f6		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.89f8		d0 0a		bne $8a04			bne 	_DCOneDimension
.89fa		c8		iny				iny 							; skip comma
.89fb		20 4b 8a	jsr $8a4b			jsr 	_DCGetSize 				; get 2nd array size
.89fe		5a		phy				phy
.89ff		a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8a01		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8a03		7a		ply				ply
.8a04						_DCOneDimension:
.8a04		5a		phy				phy 							; save position
.8a05		a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.8a07		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8a09		aa		tax				tax
.8a0a		c8		iny				iny
.8a0b		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8a0d		e8		inx				inx 							; bump them.
.8a0e		1a		inc a				inc 	a
.8a0f		20 61 a4	jsr $a461			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.8a12		a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.8a14		29 e0		and #$e0			and 	#$E0
.8a16		d0 23		bne $8a3b			bne 	_DCSize
.8a18		a0 02		ldy #$02			ldy 	#2 						; get base type
.8a1a		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8a1c		20 59 8a	jsr $8a59			jsr 	ScaleByBaseType 		; scale by base type
.8a1f		a5 36		lda $36				lda 	zTemp0
.8a21		a6 37		ldx $37				ldx 	zTemp0+1
.8a23		20 58 a0	jsr $a058			jsr 	AllocateXABytes 		; allocate memory
.8a26		a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.8a28		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8a2a		c8		iny				iny
.8a2b		8a		txa				txa
.8a2c		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8a2e		7a		ply				ply 							; get position back
.8a2f		20 34 95	jsr $9534			jsr 	CheckRightBracket 		; check )
.8a32		b1 30		lda ($30),y			lda 	(codePtr),y
.8a34		c8		iny				iny 							; consume in case
.8a35		c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.8a37		f0 85		beq $89be			beq 	DimCommand
.8a39		88		dey				dey 							; undo consume
.8a3a		60		rts				rts
.8a3b						_DCSize:
.8a3b		a9 16		lda #$16		lda	#22
.8a3d		4c 4d 95	jmp $954d		jmp	ErrorHandler
.8a40						_DCSyntax:
.8a40		4c 2e a6	jmp $a62e			jmp 	SyntaxError
.8a43						_DCRedefine:
.8a43		a9 15		lda #$15		lda	#21
.8a45		4c 4d 95	jmp $954d		jmp	ErrorHandler
.8a48						_DCType:
.8a48		4c 38 a6	jmp $a638			jmp 	TypeError
.8a4b						_DCGetSize:
.8a4b		a2 00		ldx #$00			ldx 	#0 						; get first index.
.8a4d		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 	; get array dimension
.8a50		c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8a52		f0 e7		beq $8a3b			beq 	_DCSize
.8a54		c9 fe		cmp #$fe			cmp 	#254
.8a56		f0 e3		beq $8a3b			beq 	_DCSize
.8a58		60		rts				rts
.8a59						ScaleByBaseType:
.8a59		29 10		and #$10			and 	#NSBIsString 			; is it string
.8a5b		d0 19		bne $8a76			bne 	_SBBTString
.8a5d		a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8a5f		48		pha				pha
.8a60		a5 36		lda $36				lda 	zTemp0
.8a62		48		pha				pha
.8a63		06 36		asl $36				asl 	zTemp0 					; x 2
.8a65		26 37		rol $37				rol 	zTemp0+1
.8a67		06 36		asl $36				asl 	zTemp0 					; x 4
.8a69		26 37		rol $37				rol 	zTemp0+1
.8a6b		68		pla				pla 							; add stacked value = x 5
.8a6c		65 36		adc $36				adc 	zTemp0
.8a6e		85 36		sta $36				sta 	zTemp0
.8a70		68		pla				pla
.8a71		65 37		adc $37				adc 	zTemp0+1
.8a73		85 37		sta $37				sta 	zTemp0+1
.8a75		60		rts				rts
.8a76						_SBBTString:
.8a76		06 36		asl $36				asl 	zTemp0
.8a78		26 37		rol $37				rol 	zTemp0+1
.8a7a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8a7b						EndCommand:
.8a7b		4c 12 89	jmp $8912			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8a7e						ForCommand:
.8a7e		a9 db		lda #$db	                lda     #STK_FOR+11             ; allocate 22 bytes on the return stack (see above).
.8a80		20 cd b6	jsr $b6cd	                jsr     StackOpen
.8a83		a2 00		ldx #$00	                ldx     #0
.8a85		20 aa 9e	jsr $9eaa	                jsr     EvaluateTerm
.8a88		b5 50		lda $50,x	                lda     NSStatus,x
.8a8a		c9 20		cmp #$20	                cmp     #NSBIsReference+NSTInteger ; do we have an integer 4 byte reference.
.8a8c		d0 76		bne $8b04	                bne     _FCError
.8a8e		a9 3d		lda #$3d	                lda     #KWD_EQUAL              ; =
.8a90		20 44 95	jsr $9544	                jsr     CheckNextA
.8a93		e8		inx		                inx
.8a94		20 23 a4	jsr $a423	                jsr     EvaluateInteger         ; <from> in +1
.8a97		b1 30		lda ($30),y			lda 	(codePtr),y
.8a99		b1 30		lda ($30),y	                lda     (codePtr),y
.8a9b		85 3a		sta $3a		                sta     zTemp2                  ; save keyword for later
.8a9d		c8		iny		                iny                             ; consume it
.8a9e		c9 c2		cmp #$c2	                cmp     #KWD_DOWNTO
.8aa0		f0 04		beq $8aa6	                beq     _FCNoSyntax
.8aa2		c9 dd		cmp #$dd	                cmp     #KWD_TO
.8aa4		d0 61		bne $8b07	                bne     _FCSyntaxError
.8aa6						_FCNoSyntax:
.8aa6		e8		inx		                inx
.8aa7		20 23 a4	jsr $a423	                jsr     EvaluateInteger
.8aaa		5a		phy		                phy                             ; save current position
.8aab		a5 3a		lda $3a		                lda     zTemp2                  ; restore DOWNTO or TO
.8aad		49 c2		eor #$c2	                eor     #KWD_DOWNTO             ; 0 if DOWNTO, #0 if TO
.8aaf		f0 02		beq $8ab3	                beq     _FCNotDownTo
.8ab1		a9 02		lda #$02	                lda     #2
.8ab3						_FCNotDownTo:
.8ab3		a0 10		ldy #$10	                ldy     #16
.8ab5		3a		dec a		                dec     a                       ; 255 if DOWNTO, 1 if TO
.8ab6		91 34		sta ($34),y	                sta     (basicStack),y          ; store -1 or 1 in the Basic Stack.
.8ab8		30 02		bmi $8abc	                bmi     _FCNegativeStep
.8aba		a9 00		lda #$00	                lda     #0                      ; next bytes are 0 for a step of 1
.8abc						_FCNegativeStep:
.8abc		c8		iny		                iny
.8abd		91 34		sta ($34),y	                sta     (basicStack),y          ; store rest of step in Basic Stack
.8abf		c8		iny		                iny
.8ac0		91 34		sta ($34),y	                sta     (basicStack),y
.8ac2		c8		iny		                iny
.8ac3		91 34		sta ($34),y	                sta     (basicStack),y
.8ac5		a0 06		ldy #$06	                ldy     #6                      ; this is the address of the loop variable.
.8ac7		a5 60		lda $60		                lda     NSMantissa0
.8ac9		91 34		sta ($34),y	                sta     (basicStack),y
.8acb		a5 70		lda $70		                lda     NSMantissa1
.8acd		c8		iny		                iny
.8ace		91 34		sta ($34),y	                sta     (basicStack),y
.8ad0		a0 08		ldy #$08	                ldy     #8                      ; set initial index value
.8ad2		a2 01		ldx #$01	                ldx     #1
.8ad4		20 0a 8b	jsr $8b0a	                jsr     FCIntegerToStack
.8ad7		a0 0c		ldy #$0c	                ldy     #12                     ; set the terminal value
.8ad9		a2 02		ldx #$02	                ldx     #2
.8adb		20 0a 8b	jsr $8b0a	                jsr     FCIntegerToStack
.8ade		7a		ply		                ply                             ; restore position
.8adf		b1 30		lda ($30),y	                lda     (codePtr),y
.8ae1		c9 db		cmp #$db	                cmp     #KWD_STEP               ; check for optional STEP
.8ae3		d0 18		bne $8afd	                bne     _FCNoStep
.8ae5		c8		iny		                iny                             ; consume STEP
.8ae6		a2 00		ldx #$00	                ldx     #0
.8ae8		20 23 a4	jsr $a423	                jsr     EvaluateInteger         ; get the step value
.8aeb		a5 3a		lda $3a		                lda     zTemp2                  ; restore DOWNTO or TO
.8aed		c9 c2		cmp #$c2	                cmp     #KWD_DOWNTO
.8aef		d0 03		bne $8af4	                bne    _FCStoreStep
.8af1		20 7f a4	jsr $a47f	                jsr     NSMNegateMantissa       ; if DOWNTO, negate the step value
.8af4						_FCStoreStep:
.8af4		5a		phy		                phy                             ; save the new position
.8af5		a0 10		ldy #$10	                ldy     #16                     ; set the step value
.8af7		a2 00		ldx #$00	                ldx     #0                      ; FIXME: not needed if x was unchanged
.8af9		20 0a 8b	jsr $8b0a	                jsr     FCIntegerToStack
.8afc		7a		ply		                ply                             ; restore position
.8afd						_FCNoStep:
.8afd		20 12 b7	jsr $b712	                jsr     STKSaveCodePosition     ; save loop back position
.8b00		20 25 8b	jsr $8b25	                jsr     CopyIndexToReference
.8b03		60		rts		                rts
.8b04						_FCError:
.8b04		4c 38 a6	jmp $a638	                jmp     TypeError
.8b07						_FCSyntaxError:
.8b07		4c 2e a6	jmp $a62e	                jmp     SyntaxError
.8b0a						FCIntegerToStack:
.8b0a		34 50		bit $50,x	                bit     NSStatus,x              ; is the value negative
.8b0c		10 03		bpl $8b11	                bpl     _FCNotNegative
.8b0e		20 7f a4	jsr $a47f	                jsr     NSMNegateMantissa       ; if so 2's complement the mantissa
.8b11						_FCNotNegative:
.8b11		b5 60		lda $60,x	                lda     NSMantissa0,x           ; copy out to the basic stack
.8b13		91 34		sta ($34),y	                sta     (basicStack),y
.8b15		c8		iny		                iny
.8b16		b5 70		lda $70,x	                lda     NSMantissa1,x
.8b18		91 34		sta ($34),y	                sta     (basicStack),y
.8b1a		c8		iny		                iny
.8b1b		b5 80		lda $80,x	                lda     NSMantissa2,x
.8b1d		91 34		sta ($34),y	                sta     (basicStack),y
.8b1f		c8		iny		                iny
.8b20		b5 90		lda $90,x	                lda     NSMantissa3,x
.8b22		91 34		sta ($34),y	                sta     (basicStack),y
.8b24		60		rts		                rts
.8b25						CopyIndexToReference:
.8b25		5a		phy		                phy
.8b26		a0 06		ldy #$06	                ldy     #6                      ; copy address-8 to write to zTemp0
.8b28		38		sec		                sec                             ; (because we copy from offset 8)
.8b29		b1 34		lda ($34),y	                lda     (basicStack),y
.8b2b		e9 08		sbc #$08	                sbc     #8
.8b2d		85 36		sta $36		                sta     zTemp0
.8b2f		c8		iny		                iny
.8b30		b1 34		lda ($34),y	                lda     (basicStack),y
.8b32		e9 00		sbc #$00	                sbc     #0
.8b34		85 37		sta $37		                sta     zTemp0+1
.8b36		a2 04		ldx #$04	                ldx     #4                      ; this is the copy counter/
.8b38		a0 0b		ldy #$0b	                ldy     #8+3                    ; the MSB of the mantissa
.8b3a		b1 34		lda ($34),y	                lda     (basicStack),y
.8b3c		0a		asl a		                asl     a                       ; into carry
.8b3d		a0 08		ldy #$08	                ldy     #8                      ; where to copy from.
.8b3f		90 14		bcc $8b55	                bcc     _CITRNormal
.8b41		38		sec		                sec
.8b42						_CITRNegative:
.8b42		a9 00		lda #$00	                lda     #0
.8b44		f1 34		sbc ($34),y	                sbc     (basicStack),y
.8b46		91 36		sta ($36),y	                sta     (zTemp0),y
.8b48		c8		iny		                iny
.8b49		ca		dex		                dex
.8b4a		d0 f6		bne $8b42	                bne     _CITRNegative
.8b4c		88		dey		                dey                             ; look at MSB of mantissa
.8b4d		b1 36		lda ($36),y	                lda     (zTemp0),y              ; set the MSB as negative packed.
.8b4f		09 80		ora #$80	                ora     #$80
.8b51		91 36		sta ($36),y	                sta     (zTemp0),y
.8b53		7a		ply		                ply
.8b54		60		rts		                rts
.8b55						_CITRNormal:
.8b55		b1 34		lda ($34),y	                lda     (basicStack),y          ; copy without negation.
.8b57		91 36		sta ($36),y	                sta     (zTemp0),y
.8b59		c8		iny		                iny
.8b5a		ca		dex		                dex
.8b5b		d0 f8		bne $8b55	                bne     _CITRNormal
.8b5d		7a		ply		                ply                             ; and exit.
.8b5e		60		rts		                rts
.8b5f						NextCommand:
.8b5f		a9 db		lda #$db	                lda     #STK_FOR+11             ; check FOR is TOS
.8b61		a2 11		ldx #$11	                ldx     #ERRID_FOR              ; this error
.8b63		20 fa b6	jsr $b6fa	                jsr     StackCheckFrame
.8b66		5a		phy		                phy
.8b67		a5 34		lda $34		                lda     basicStack              ; Pointer to step
.8b69		18		clc		                clc
.8b6a		69 08		adc #$08	                adc     #8
.8b6c		85 38		sta $38		                sta     zTemp1
.8b6e		a5 35		lda $35		                lda     basicStack+1
.8b70		69 00		adc #$00	                adc     #0
.8b72		85 39		sta $39		                sta     zTemp1+1
.8b74		a0 08		ldy #$08	                ldy     #8                      ; offset to bump
.8b76		a2 04		ldx #$04	                ldx     #4                      ; Four bytes to add
.8b78		18		clc		                clc
.8b79						_NCBump:
.8b79		b1 34		lda ($34),y	                lda     (basicStack),y          ; get index
.8b7b		71 38		adc ($38),y	                adc     (zTemp1),y              ; add step
.8b7d		91 34		sta ($34),y	                sta     (basicStack),y
.8b7f		c8		iny		                iny                             ; next byte
.8b80		ca		dex		                dex                             ; are we done yet?
.8b81		d0 f6		bne $8b79	                bne     _NCBump
.8b83		20 25 8b	jsr $8b25	                jsr     CopyIndexToReference    ; copy it to the reference variable.
.8b86		a0 13		ldy #$13	                ldy     #19                     ; get MSB of step count
.8b88		b1 34		lda ($34),y	                lda     (basicStack),y
.8b8a		0a		asl a		                asl     a                       ; sign bit to carry
.8b8b		a9 0c		lda #$0c	                lda     #12                     ; offset of LHS = terminal offset
.8b8d		85 38		sta $38		                sta     zTemp1
.8b8f		90 02		bcc $8b93	                bcc     _NCCompRev              ; use if step is +ve
.8b91		a9 08		lda #$08	                lda     #8                      ; now the LHS = index value
.8b93						_NCCompRev:
.8b93		85 38		sta $38		                sta     zTemp1                  ; so zTemp0 is the index for LHS
.8b95		49 04		eor #$04	                eor     #(8^12)                 ; and zTemp0+1 is the index for RHS
.8b97		85 39		sta $39		                sta     zTemp1+1
.8b99		a2 04		ldx #$04	                ldx     #4                      ; bytes to compare
.8b9b		38		sec		                sec
.8b9c						_NCCompare:
.8b9c		a4 38		ldy $38		                ldy     zTemp1                  ; do compare using the two indices
.8b9e		b1 34		lda ($34),y	                lda     (basicStack),y
.8ba0		a4 39		ldy $39		                ldy     zTemp1+1
.8ba2		f1 34		sbc ($34),y	                sbc     (basicStack),y
.8ba4		e6 38		inc $38		                inc     zTemp1                  ; bump the indices (inc,dex do not change C or V)
.8ba6		e6 39		inc $39		                inc     zTemp1+1
.8ba8		ca		dex		                dex                             ; do it 4 times.
.8ba9		d0 f1		bne $8b9c	                bne     _NCCompare
.8bab		50 02		bvc $8baf	                bvc     _NCNoOverflow           ; convert to signed comparison
.8bad		49 80		eor #$80	                eor     #$80
.8baf						_NCNoOverflow:
.8baf		7a		ply		                ply                             ; restore Y position
.8bb0		0a		asl a		                asl     a                       ; is bit 7 set.
.8bb1		90 04		bcc $8bb7	                bcc     _NCLoopBack             ; if no , >= so loop back
.8bb3		20 ec b6	jsr $b6ec	                jsr     StackClose              ; exit the loop
.8bb6		60		rts		                rts
.8bb7						_NCLoopBack:
.8bb7		20 23 b7	jsr $b723	                jsr     STKLoadCodePosition     ; loop back
.8bba		60		rts		                rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8bbb						Command_GOSUB:
.8bbb		a2 00		ldx #$00			ldx 	#0
.8bbd		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8bc0		a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8bc2		20 cd b6	jsr $b6cd			jsr 	StackOpen 					; create frame
.8bc5		20 12 b7	jsr $b712			jsr 	STKSaveCodePosition 		; save current position
.8bc8		4c de 8b	jmp $8bde			jmp 	GotoStackX
.8bcb						Command_RETURN:
.8bcb		a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8bcd		a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8bcf		20 fa b6	jsr $b6fa			jsr 	StackCheckFrame
.8bd2		20 23 b7	jsr $b723			jsr 	STKLoadCodePosition 		; restore code position
.8bd5		20 ec b6	jsr $b6ec			jsr 	StackClose
.8bd8		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8bd9						GotoCommand:
.8bd9		a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8bdb		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger
.8bde						GotoStackX:
.8bde		b5 70		lda $70,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8be0		48		pha				pha 								; it is slightly inefficient, just in cases.
.8be1		b5 60		lda $60,x			lda 	NSMantissa0,x
.8be3		fa		plx				plx
.8be4		20 15 a9	jsr $a915			jsr 	MemorySearch 				; transfer to line number AX.
.8be7		90 05		bcc $8bee			bcc 	_GotoError 					; not found, off end.
.8be9		d0 03		bne $8bee			bne 	_GotoError 					; not found exactly
.8beb		4c 29 91	jmp $9129			jmp 	RunNewLine 					; and go straight to new line code.
.8bee						_GotoError:
.8bee		a9 0d		lda #$0d		lda	#13
.8bf0		4c 4d 95	jmp $954d		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8bf3						IfCommand:
.8bf3		a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.8bf5		20 04 a4	jsr $a404			jsr 	EvaluateNumber
.8bf8		b1 30		lda ($30),y			lda 	(codePtr),y
.8bfa		c9 b6		cmp #$b6			cmp 	#KWD_THEN  					; could be THEN <stuff>
.8bfc		d0 0a		bne $8c08			bne 	_IfStructured 				; we still support it.
.8bfe		c8		iny				iny 								; consume THEN
.8bff		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; is it zero
.8c02		f0 01		beq $8c05			beq 	_IfFail 					; if fail, go to next line
.8c04		60		rts				rts 								; if THEN just continue
.8c05						_IfFail:
.8c05		4c 04 91	jmp $9104			jmp 	EOLCommand
.8c08						_IfStructured:
.8c08		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; is it zero
.8c0b		d0 07		bne $8c14			bne 	_IfExit 					; if not, then continue normally.
.8c0d		a9 c3		lda #$c3			lda 	#KWD_ELSE 					; look for else/endif
.8c0f		a2 b3		ldx #$b3			ldx 	#KWD_ENDIF
.8c11		20 8f 94	jsr $948f			jsr 	ScanForward 				; and run from there
.8c14						_IfExit:
.8c14		60		rts				rts
.8c15						ElseCode:
.8c15		a9 b3		lda #$b3			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8c17		aa		tax				tax 								; so just go to the structure exit
.8c18		20 8f 94	jsr $948f			jsr 	ScanForward
.8c1b		60		rts				rts
.8c1c						EndIf:
.8c1c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8c1d						Command_Input:
.8c1d		9c 44 04	stz $0444			stz 	isPrintFlag
.8c20		80 0c		bra $8c2e			bra 	Command_IP_Main
.8c22						Command_CPrint:
.8c22		a9 7f		lda #$7f			lda 	#$7F
.8c24		8d 44 04	sta $0444			sta 	isPrintFlag 				; set input flag to character mode
.8c27		80 05		bra $8c2e			bra 	Command_IP_Main
.8c29						Command_Print:
.8c29		a9 ff		lda #$ff			lda 	#$FF
.8c2b		8d 44 04	sta $0444			sta 	isPrintFlag 				; set input flag
.8c2e						Command_IP_Main:
.8c2e		18		clc				clc
.8c2f						_CPLoop:
.8c2f		08		php				php 								; save last action flag
.8c30		b1 30		lda ($30),y			lda 	(codePtr),y
.8c32		c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8c34		f0 5d		beq $8c93			beq 	_CPExit
.8c36		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8c38		f0 59		beq $8c93			beq 	_CPExit
.8c3a		68		pla				pla 								; throw last action flag
.8c3b		b1 30		lda ($30),y			lda 	(codePtr),y
.8c3d		c8		iny				iny
.8c3e		c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.8c40		f0 4e		beq $8c90			beq 	_CPContinueWithSameLine
.8c42		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8c44		f0 45		beq $8c8b			beq 	_CPTab
.8c46		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8c48		f0 3d		beq $8c87			beq 	_CPNewLine
.8c4a		c9 b9		cmp #$b9			cmp 	#KWD_AT 					; `at` modifier
.8c4c		f0 34		beq $8c82			beq 	_CPAtModifier
.8c4e		88		dey				dey 								; undo the get
.8c4f		20 55 9a	jsr $9a55			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.8c52		b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.8c54		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.8c56		f0 0d		beq $8c65			beq 	_CPIsValue 					; no, display it
.8c58		ad 44 04	lda $0444			lda 	isPrintFlag 				; if print, dereference and print
.8c5b		d0 05		bne $8c62			bne 	_CPIsPrint 					; otherwise display.
.8c5d		20 9c 8c	jsr $8c9c			jsr 	CIInputValue 				; input a value to the reference
.8c60		80 25		bra $8c87			bra 	_CPNewLine
.8c62						_CPIsPrint:
.8c62		20 23 9d	jsr $9d23			jsr 	Dereference 				; dereference if required.
.8c65						_CPIsValue:
.8c65		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.8c67		29 10		and #$10			and 	#NSBIsString
.8c69		f0 09		beq $8c74			beq 	_CPNumber
.8c6b		a6 70		ldx $70				ldx 	NSMantissa1 				; string, print the text.
.8c6d		a5 60		lda $60				lda 	NSMantissa0
.8c6f		20 ff 8c	jsr $8cff			jsr 	CPPrintStringXA
.8c72		80 ba		bra $8c2e			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8c74						_CPNumber:
.8c74		a9 05		lda #$05			lda 	#5 							; maximum decimals
.8c76		20 eb a2	jsr $a2eb			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.8c79		a2 06		ldx #$06			ldx 	#decimalBuffer >> 8
.8c7b		a9 65		lda #$65			lda 	#decimalBuffer & $FF
.8c7d		20 ff 8c	jsr $8cff			jsr 	CPPrintStringXA 			; print it.
.8c80		80 ac		bra $8c2e			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8c82						_CPAtModifier:
.8c82		20 20 8d	jsr $8d20			jsr 	CPPrintAt			        ; subroutine to keep `_CPLoop` within branch range
.8c85		80 a7		bra $8c2e			bra 	Command_IP_Main
.8c87						_CPNewLine:
.8c87		a9 0d		lda #$0d			lda 	#13
.8c89		80 02		bra $8c8d			bra 	_CPPrintCharDirect
.8c8b						_CPTab:
.8c8b		a9 09		lda #$09			lda 	#9 							; print TAB
.8c8d						_CPPrintCharDirect:
.8c8d		20 1a 8d	jsr $8d1a			jsr 	CPPVControl 				; print TAB/CR using the non PETSCII
.8c90						_CPContinueWithSameLine:
.8c90		38		sec				sec 								; loop round with carry set, which
.8c91		80 9c		bra $8c2f			bra 	_CPLoop 					; will inhibit final CR
.8c93						_CPExit:
.8c93		28		plp				plp 								; get last action flag
.8c94		b0 05		bcs $8c9b			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8c96		a9 0d		lda #$0d			lda 	#13 						; print new line
.8c98		20 1a 8d	jsr $8d1a			jsr 	CPPVControl
.8c9b						_CPExit2:
.8c9b		60		rts				rts
.8c9c						CIInputValue:
.8c9c		a2 00		ldx #$00			ldx 	#0 							; input a line.
.8c9e						_CIInputLine:
.8c9e		20 1d 8d	jsr $8d1d			jsr 	CPInputVector 				; get key
.8ca1		c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8ca3		f0 1f		beq $8cc4			beq 	_CIHaveValue
.8ca5		c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8ca7		f0 11		beq $8cba			beq 	_CIBackspace
.8ca9		c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8cab		90 f1		bcc $8c9e			bcc 	_CIInputLine
.8cad		e0 50		cpx #$50			cpx 	#80 						; max length
.8caf		b0 ed		bcs $8c9e			bcs 	_CIInputLine
.8cb1		9d 46 05	sta $0546,x			sta 	lineBuffer,x
.8cb4		e8		inx				inx
.8cb5		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter 			; echo it.
.8cb8		80 e4		bra $8c9e			bra 	_CIInputLine
.8cba						_CIBackspace:
.8cba		e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8cbc		f0 e0		beq $8c9e			beq 	_CIInputLine
.8cbe		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter 			; echo it.
.8cc1		ca		dex				dex
.8cc2		80 da		bra $8c9e			bra 	_CIInputLine
.8cc4						_CIHaveValue:
.8cc4		9e 46 05	stz $0546,x			stz 	lineBuffer,x 				; ASCIIZ string now in line buffer.
.8cc7		a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8cc9		29 10		and #$10			and 	#NSBIsString
.8ccb		f0 17		beq $8ce4			beq 	_CIAssignNumber 			; assign a number
.8ccd		a2 01		ldx #$01			ldx 	#1
.8ccf		a9 46		lda #$46			lda 	#lineBuffer & $FF 			; set up to point to new string
.8cd1		95 60		sta $60,x			sta 	NSMantissa0,x
.8cd3		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8cd5		95 70		sta $70,x			sta 	NSMantissa1,x
.8cd7		74 80		stz $80,x			stz 	NSMantissa2,x
.8cd9		74 90		stz $90,x			stz 	NSMantissa3,x
.8cdb		a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8cdd		95 50		sta $50,x			sta  	NSStatus,x
.8cdf		ca		dex				dex 								; X = 0
.8ce0		20 7f 8d	jsr $8d7f			jsr 	AssignVariable
.8ce3		60		rts				rts
.8ce4						_CIAssignNumber:
.8ce4		a9 46		lda #$46			lda 	#lineBuffer & $FF 			; set up to point to new string
.8ce6		85 36		sta $36				sta 	zTemp0
.8ce8		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8cea		85 37		sta $37				sta 	zTemp0+1
.8cec		a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8cee		20 cb a1	jsr $a1cb			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8cf1		90 07		bcc $8cfa			bcc 	_CIIsOkay
.8cf3		a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8cf5		20 12 8d	jsr $8d12			jsr 	CPPrintVector
.8cf8		80 a2		bra $8c9c			bra 	CIInputValue
.8cfa						_CIIsOkay:
.8cfa		ca		dex				dex 								; X = 0
.8cfb		20 7f 8d	jsr $8d7f			jsr 	AssignVariable
.8cfe		60		rts				rts
.8cff						CPPrintStringXA:
.8cff		5a		phy				phy
.8d00		86 37		stx $37				stx 	zTemp0+1
.8d02		85 36		sta $36				sta 	zTemp0
.8d04		a0 00		ldy #$00			ldy 	#0
.8d06						_PSXALoop:
.8d06		b1 36		lda ($36),y			lda 	(zTemp0),y
.8d08		f0 06		beq $8d10			beq 	_PSXAExit
.8d0a		20 12 8d	jsr $8d12			jsr 	CPPrintVector
.8d0d		c8		iny				iny
.8d0e		80 f6		bra $8d06			bra 	_PSXALoop
.8d10						_PSXAExit:
.8d10		7a		ply				ply
.8d11		60		rts				rts
.8d12						CPPrintVector:
.8d12		2c 44 04	bit $0444			bit 	isPrintFlag 				; check if char only mode and call appropriate handler
.8d15		30 03		bmi $8d1a			bmi 	CPPVControl
.8d17		4c 57 80	jmp $8057			jmp 	EXTPrintNoControl
.8d1a						CPPVControl:
.8d1a		4c 4d 80	jmp $804d			jmp 	EXTPrintCharacter
.8d1d						CPInputVector:
.8d1d		4c f5 81	jmp $81f5			jmp 	KNLGetSingleCharacter
.8d20						CPPrintAt:
.8d20		a2 00		ldx #$00			ldx		#0 							; bottom stack level
.8d22		20 51 a4	jsr $a451			jsr		Evaluate8BitInteger         ; parse row into `A`
.8d25		cd ee 07	cmp $07ee			cmp		EXTScreenHeight				; check if row is within valid range
.8d28		b0 19		bcs $8d43			bcs		_range_error
.8d2a		48		pha				pha									; save it on the stack
.8d2b		20 3c 95	jsr $953c			jsr		CheckComma					; ensure the next character is a comma
.8d2e		20 51 a4	jsr $a451			jsr		Evaluate8BitInteger			; parse column into `A`
.8d31		cd ed 07	cmp $07ed			cmp		EXTScreenWidth				; check if column is within valid range
.8d34		b0 0d		bcs $8d43			bcs		_range_error
.8d36		8d eb 07	sta $07eb			sta     EXTColumn					; save column into `EXTColumn`
.8d39		68		pla				pla                                 ; restore row into `A`
.8d3a		8d ea 07	sta $07ea			sta     EXTRow						; save row into `EXTRow`
.8d3d		5a		phy				phy
.8d3e		20 61 80	jsr $8061			jsr 	EXTSetCurrentLine         	; set current line address to `EXTRow`
.8d41		7a		ply		        ply
.8d42		60		rts				rts
.8d43						_range_error:
.8d43		4c 33 a6	jmp $a633			jmp 	RangeError 					; branch to range error handler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8d46						LetCommand:
.8d46		a2 00		ldx #$00			ldx 	#0
.8d48		b1 30		lda ($30),y			lda 	(codePtr),y
.8d4a		c9 10		cmp #$10			cmp 	#KWD_ATCH
.8d4c		d0 14		bne $8d62			bne 	_LCStandard
.8d4e		c8		iny				iny 								; skip equal
.8d4f		20 aa 9e	jsr $9eaa			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.8d52		20 23 9d	jsr $9d23			jsr 	Dereference 				; dereference it to a value
.8d55		b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.8d57		49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8d59		95 50		sta $50,x			sta 	NSStatus,x
.8d5b		29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8d5d		d0 0f		bne $8d6e			bne 	_LCMain
.8d5f		4c 38 a6	jmp $a638			jmp 	TypeError 					; was a reference before.
.8d62						_LCStandard:
.8d62		ad 3f 9a	lda $9a3f			lda 	PrecedenceLevel+"*"			; precedence > this
.8d65		20 59 9a	jsr $9a59			jsr 	EvaluateExpressionAtPrecedence
.8d68		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.8d6a		c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.8d6c		f0 0e		beq $8d7c			beq 	_LetGoProc 					; it's a procedure call.
.8d6e						_LCMain:
.8d6e		a9 3d		lda #$3d			lda 	#"=" 						; check =
.8d70		20 44 95	jsr $9544			jsr 	CheckNextA
.8d73		e8		inx				inx 								; RHS
.8d74		20 fb a3	jsr $a3fb			jsr 	EvaluateValue
.8d77		ca		dex				dex
.8d78		20 7f 8d	jsr $8d7f			jsr 	AssignVariable
.8d7b		60		rts				rts
.8d7c						_LetGoProc:
.8d7c		4c d1 8f	jmp $8fd1			jmp 	CallProcedure
.8d7f						AssignVariable:
.8d7f		b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8d81		48		pha				pha 								; save a copy
.8d82		55 51		eor $51,x			eor 	NSStatus+1,x
.8d84		29 10		and #$10			and 	#NSBIsString
.8d86		d0 0b		bne $8d93			bne 	_ASError
.8d88		68		pla				pla 								; get back
.8d89		29 10		and #$10			and 	#NSBIsString 				; check type
.8d8b		d0 03		bne $8d90			bne 	_ASString
.8d8d		4c 61 9c	jmp $9c61			jmp 	AssignNumber
.8d90						_ASString:
.8d90		4c bf 9c	jmp $9cbf			jmp 	AssignString
.8d93						_ASError:
.8d93		4c 38 a6	jmp $a638			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.8d96						Command_List:
.8d96		9c 42 04	stz $0442			stz 	listIndent 					; reset indent.
.8d99		a9 3f		lda #$3f			lda 	#$3F 						; silence at list.
.8d9b		20 6b 80	jsr $806b			jsr 	SNDCommand
.8d9e		b1 30		lda ($30),y			lda 	(codePtr),y
.8da0		29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.8da2		c9 40		cmp #$40			cmp 	#$40  						; of code.
.8da4		f0 72		beq $8e18			beq 	_CLListProcedure
.8da6		64 64		stz $64				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.8da8		64 74		stz $74				stz 	NSMantissa1+4 				; these are the default top and bottom.
.8daa		a9 ff		lda #$ff			lda 	#$FF
.8dac		85 67		sta $67				sta 	NSMantissa0+7
.8dae		85 77		sta $77				sta 	NSMantissa1+7
.8db0		b1 30		lda ($30),y			lda 	(codePtr),y
.8db2		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8db4		f0 1a		beq $8dd0			beq 	_CLSecond
.8db6		20 9e 8e	jsr $8e9e			jsr 	CLIsDigit 					; if not digit, list all
.8db9		b0 20		bcs $8ddb			bcs 	_CLStart
.8dbb		a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8dbd		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger
.8dc0		b1 30		lda ($30),y			lda 	(codePtr),y
.8dc2		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8dc4		f0 0a		beq $8dd0			beq 	_CLSecond 					; if so go get it
.8dc6		a5 64		lda $64				lda 	NSMantissa0+4 				; copy 4->7
.8dc8		85 67		sta $67				sta 	NSMantissa0+7
.8dca		a5 74		lda $74				lda 	NSMantissa1+4
.8dcc		85 77		sta $77				sta 	NSMantissa1+7
.8dce		80 0b		bra $8ddb			bra 	_CLStart
.8dd0						_CLSecond:
.8dd0		c8		iny				iny 								; consume comma
.8dd1		20 9e 8e	jsr $8e9e			jsr 	CLIsDigit 					; digit found
.8dd4		b0 05		bcs $8ddb			bcs 	_CLStart 					; if not, continue listing
.8dd6		a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8dd8		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger
.8ddb						_CLStart
.8ddb		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ddd		85 30		sta $30				sta 	codePtr
.8ddf		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8de1		85 31		sta $31				sta 	codePtr+1
.8de3						_CLLoop:
.8de3		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.8de5		f0 03		beq $8dea			beq 	_NoEvents					; if zero, skip with Z flag set.
.8de7		20 58 81	jsr $8158			jsr 	ProcessEvents
.8dea						_NoEvents:
.8dea		d0 27		bne $8e13			bne 	_CLBreak
.8dec		b2 30		lda ($30)			lda 	(codePtr)
.8dee		f0 20		beq $8e10			beq 	_CLExit
.8df0		a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8df2		20 8d 8e	jsr $8e8d			jsr 	CLCompareLineNo
.8df5		90 0c		bcc $8e03			bcc 	_CLNext
.8df7		a2 07		ldx #$07			ldx 	#7
.8df9		20 8d 8e	jsr $8e8d			jsr 	CLCompareLineNo
.8dfc		f0 02		beq $8e00			beq 	_CLDoThisOne
.8dfe		b0 03		bcs $8e03			bcs 	_CLNext
.8e00						_CLDoThisOne:
.8e00		20 7a 8e	jsr $8e7a			jsr 	CLListOneLine 				; routine to list the current line.
.8e03						_CLNext:
.8e03		18		clc				clc
.8e04		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e06		65 30		adc $30				adc 	codePtr
.8e08		85 30		sta $30				sta 	codePtr
.8e0a		90 02		bcc $8e0e			bcc 	_CREExit
.8e0c		e6 31		inc $31				inc 	codePtr+1 					; carry
.8e0e						_CREExit:
.8e0e		80 d3		bra $8de3			bra 	_CLLoop
.8e10						_CLExit:
.8e10		4c 12 89	jmp $8912			jmp 	WarmStart
.8e13						_CLBreak:
.8e13		a9 01		lda #$01		lda	#1
.8e15		4c 4d 95	jmp $954d		jmp	ErrorHandler
.8e18						_CLListProcedure:
.8e18		b1 30		lda ($30),y			lda 	(codePtr),y
.8e1a		85 38		sta $38				sta 	zTemp1
.8e1c		c8		iny				iny
.8e1d		b1 30		lda ($30),y			lda 	(codePtr),y
.8e1f		85 39		sta $39				sta 	zTemp1+1
.8e21		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8e23		85 30		sta $30				sta 	codePtr
.8e25		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8e27		85 31		sta $31				sta 	codePtr+1
.8e29						_CLLPSearch:
.8e29		b2 30		lda ($30)			lda 	(codePtr)
.8e2b		c9 00		cmp #$00			cmp 	#0 							; if zero, end
.8e2d		f0 e1		beq $8e10			beq 	_CLExit
.8e2f		a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.8e31		b1 30		lda ($30),y			lda 	(codePtr),y
.8e33		c9 b0		cmp #$b0			cmp 	#KWD_PROC
.8e35		d0 0e		bne $8e45			bne 	_CLLPNext
.8e37		c8		iny				iny 								; check if PROC this.
.8e38		b1 30		lda ($30),y			lda 	(codePtr),y
.8e3a		c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8e3c		d0 07		bne $8e45			bne 	_CLLPNext
.8e3e		c8		iny				iny
.8e3f		b1 30		lda ($30),y			lda 	(codePtr),y
.8e41		c5 39		cmp $39				cmp 	zTemp1+1
.8e43		f0 0d		beq $8e52			beq 	_CLLPFound
.8e45						_CLLPNext:
.8e45		18		clc				clc
.8e46		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e48		65 30		adc $30				adc 	codePtr
.8e4a		85 30		sta $30				sta 	codePtr
.8e4c		90 02		bcc $8e50			bcc 	_CREExit
.8e4e		e6 31		inc $31				inc 	codePtr+1 					; carry
.8e50						_CREExit:
.8e50		80 d7		bra $8e29			bra 	_CLLPSearch
.8e52						_CLLPFound:
.8e52		b2 30		lda ($30)			lda 	(codePtr)
.8e54		f0 ba		beq $8e10			beq 	_CLExit
.8e56		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.8e58		f0 03		beq $8e5d			beq 	_NoEvents					; if zero, skip with Z flag set.
.8e5a		20 58 81	jsr $8158			jsr 	ProcessEvents
.8e5d						_NoEvents:
.8e5d		d0 b4		bne $8e13			bne 	_CLBreak
.8e5f		a0 03		ldy #$03			ldy 	#3 							; get first keyword
.8e61		b1 30		lda ($30),y			lda 	(codePtr),y
.8e63		48		pha				pha
.8e64		20 7a 8e	jsr $8e7a			jsr 	CLListOneLine 				; list line and go forward
.8e67		18		clc				clc
.8e68		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e6a		65 30		adc $30				adc 	codePtr
.8e6c		85 30		sta $30				sta 	codePtr
.8e6e		90 02		bcc $8e72			bcc 	_CREExit
.8e70		e6 31		inc $31				inc 	codePtr+1 					; carry
.8e72						_CREExit:
.8e72		68		pla				pla 								; reached ENDPROC ?
.8e73		c9 b4		cmp #$b4			cmp 	#KWD_ENDPROC
.8e75		d0 db		bne $8e52			bne 	_CLLPFound
.8e77		4c 12 89	jmp $8912			jmp 	WarmStart
.8e7a						CLListOneLine:
.8e7a		20 f2 94	jsr $94f2			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8e7d		20 89 80	jsr $8089			jsr 	TKListConvertLine 			; convert line into token Buffer
.8e80		a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8e82		a9 49		lda #$49			lda 	#(tokenBuffer & $FF)
.8e84		20 ac 95	jsr $95ac			jsr 	PrintStringXA
.8e87		a9 0d		lda #$0d			lda 	#13 						; new line
.8e89		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8e8c		60		rts				rts
.8e8d						CLCompareLineNo:
.8e8d		38		sec				sec
.8e8e		a0 01		ldy #$01			ldy 	#1
.8e90		b1 30		lda ($30),y			lda 	(codePtr),y
.8e92		f5 60		sbc $60,x			sbc 	NSMantissa0,x
.8e94		85 36		sta $36				sta 	zTemp0
.8e96		c8		iny				iny
.8e97		b1 30		lda ($30),y			lda 	(codePtr),y
.8e99		f5 70		sbc $70,x			sbc 	NSMantissa1,x
.8e9b		05 36		ora $36				ora 	zTemp0
.8e9d		60		rts				rts
.8e9e						CLIsDigit:
.8e9e		b1 30		lda ($30),y			lda 	(codePtr),y
.8ea0		c9 30		cmp #$30			cmp 	#"0"
.8ea2		90 03		bcc $8ea7			bcc	 	_CLIDExitFalse
.8ea4		c9 3a		cmp #$3a			cmp 	#"9"+1
.8ea6		60		rts				rts
.8ea7						_CLIDExitFalse:
.8ea7		38		sec				sec
.8ea8		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8ea9						Command_LOCAL:
.8ea9		a2 00		ldx #$00			ldx 	#0 							; at level 0
.8eab		20 b7 8e	jsr $8eb7			jsr 	LocaliseNextTerm 			; convert term to a local.
.8eae		b1 30		lda ($30),y			lda 	(codePtr),y
.8eb0		c8		iny				iny
.8eb1		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8eb3		f0 f4		beq $8ea9			beq 	Command_LOCAL 				; if so, localise another variable.
.8eb5		88		dey				dey 								; unpick pre-get
.8eb6		60		rts				rts
.8eb7						LocaliseNextTerm:
.8eb7		20 aa 9e	jsr $9eaa			jsr 	EvaluateTerm 				; evaluate the term
.8eba		b5 50		lda $50,x			lda 	NSStatus,x
.8ebc		29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.8ebe		f0 5c		beq $8f1c			beq		_LNTError
.8ec0		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8ec2		85 36		sta $36				sta 	zTemp0
.8ec4		b5 70		lda $70,x			lda 	NSMantissa1,x
.8ec6		85 37		sta $37				sta  	zTemp0+1
.8ec8		b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.8eca		29 10		and #$10			and 	#NSBIsString
.8ecc		d0 1e		bne $8eec			bne 	_LNTPushString
.8ece		5a		phy				phy
.8ecf		a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.8ed1						_LNTPushNumLoop:
.8ed1		b1 36		lda ($36),y			lda		(zTemp0),y
.8ed3		20 ac b6	jsr $b6ac			jsr 	StackPushByte
.8ed6		c8		iny				iny
.8ed7		c0 05		cpy #$05			cpy 	#5
.8ed9		d0 f6		bne $8ed1			bne 	_LNTPushNumLoop
.8edb		a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.8edd		20 ac b6	jsr $b6ac			jsr 	StackPushByte
.8ee0		a5 37		lda $37				lda 	zTemp0+1
.8ee2		20 ac b6	jsr $b6ac			jsr 	StackPushByte
.8ee5		a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.8ee7		20 ac b6	jsr $b6ac			jsr 	StackPushByte
.8eea		7a		ply				ply
.8eeb		60		rts				rts
.8eec						_LNTPushString:
.8eec		5a		phy				phy
.8eed		b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.8eef		85 38		sta $38				sta 	zTemp1
.8ef1		a0 01		ldy #$01			ldy 	#1
.8ef3		b1 36		lda ($36),y			lda 	(zTemp0),y
.8ef5		85 39		sta $39				sta 	zTemp1+1
.8ef7		a0 00		ldy #$00			ldy 	#0 							; output string
.8ef9		c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.8efb		f0 0a		beq $8f07			beq 	_LNTStringOut
.8efd						_LNTPushStrLoop:
.8efd		b1 38		lda ($38),y			lda 	(zTemp1),y
.8eff		f0 06		beq $8f07			beq 	_LNTStringOut
.8f01		20 ac b6	jsr $b6ac			jsr 	StackPushByte
.8f04		c8		iny				iny
.8f05		80 f6		bra $8efd			bra 	_LNTPushStrLoop
.8f07						_LNTStringOut:
.8f07		98		tya				tya									; output length (chars written).
.8f08		20 ac b6	jsr $b6ac			jsr 	StackPushByte
.8f0b		b5 60		lda $60,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.8f0d		20 ac b6	jsr $b6ac			jsr 	StackPushByte
.8f10		b5 70		lda $70,x			lda 	NSMantissa1,x
.8f12		20 ac b6	jsr $b6ac			jsr 	StackPushByte
.8f15		a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8f17		20 ac b6	jsr $b6ac			jsr 	StackPushByte
.8f1a		7a		ply				ply
.8f1b		60		rts				rts
.8f1c						_LNTError:
.8f1c		4c 2e a6	jmp $a62e			jmp 	SyntaxError
.8f1f						LocalPopValue:
.8f1f		20 c4 b6	jsr $b6c4			jsr 	StackPopByte
.8f22		c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8f24		d0 17		bne $8f3d			bne 	_LPVString
.8f26		20 c4 b6	jsr $b6c4			jsr 	StackPopByte 				; address
.8f29		85 37		sta $37				sta 	zTemp0+1
.8f2b		20 c4 b6	jsr $b6c4			jsr 	StackPopByte
.8f2e		85 36		sta $36				sta 	zTemp0
.8f30		5a		phy				phy
.8f31		a0 04		ldy #$04			ldy 	#4 							; copy back
.8f33						_LPVNumberCopy:
.8f33		20 c4 b6	jsr $b6c4			jsr 	StackPopByte
.8f36		91 36		sta ($36),y			sta 	(zTemp0),y
.8f38		88		dey				dey
.8f39		10 f8		bpl $8f33			bpl 	_LPVNumberCopy
.8f3b		7a		ply				ply 								; and complete
.8f3c		60		rts				rts
.8f3d						_LPVString:
.8f3d		20 c4 b6	jsr $b6c4			jsr 	StackPopByte 				; address of record copied to zTemp0
.8f40		85 37		sta $37				sta 	zTemp0+1
.8f42		20 c4 b6	jsr $b6c4			jsr 	StackPopByte
.8f45		85 36		sta $36				sta 	zTemp0
.8f47		5a		phy				phy
.8f48		b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.8f4a		85 38		sta $38				sta 	zTemp1
.8f4c		a0 01		ldy #$01			ldy 	#1
.8f4e		b1 36		lda ($36),y			lda 	(zTemp0),y
.8f50		85 39		sta $39				sta 	zTemp1+1
.8f52		20 c4 b6	jsr $b6c4			jsr 	StackPopByte 				; # chars to get => y
.8f55		a8		tay				tay
.8f56		a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8f58		f0 0e		beq $8f68			beq 	_LPVStringCopied
.8f5a		a9 00		lda #$00			lda 	#0 							; NULL on end
.8f5c		91 38		sta ($38),y			sta 	(zTemp1),y
.8f5e						_LPVStringCopy:
.8f5e		88		dey				dey
.8f5f		30 07		bmi $8f68			bmi 	_LPVStringCopied
.8f61		20 c4 b6	jsr $b6c4			jsr 	StackPopByte
.8f64		91 38		sta ($38),y			sta 	(zTemp1),y
.8f66		80 f6		bra $8f5e			bra 	_LPVStringCopy
.8f68						_LPVStringCopied:
.8f68		fa		plx				plx
.8f69		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8f6a						NewCommand:
.8f6a		20 a0 88	jsr $88a0			jsr		IsDestructiveActionOK
.8f6d		b0 03		bcs $8f72			bcs		_not_ok
.8f6f		20 75 8f	jsr $8f75			jsr 	NewProgram 					; does the actual NEW.
.8f72						_not_ok:
.8f72		4c 12 89	jmp $8912			jmp 	WarmStart 					; and warm starts straight away.
.8f75						NewProgram:
.8f75		20 f7 a8	jsr $a8f7			jsr 	MemoryNew
.8f78		9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8f7b		20 d9 93	jsr $93d9			jsr 	ClearSystem					; clear everything.
.8f7e		9c 75 06	stz $0675			stz		programChanged
.8f81		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/option.asm

.8f82						OptionCommand:
.8f82		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8f84		20 51 a4	jsr $a451			jsr		Evaluate8BitInteger 		; address
.8f87		48		pha				pha
.8f88		20 3c 95	jsr $953c			jsr 	CheckComma
.8f8b		e8		inx				inx
.8f8c		20 51 a4	jsr $a451			jsr		Evaluate8BitInteger 		; data
.8f8f		fa		plx				plx
.8f90		9d 00 04	sta $0400,x			sta 	ControlStorage,x
.8f93		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/poke.asm

.8f94						PokeBCommand:
.8f94		a9 01		lda #$01			lda 	#1
.8f96		80 0c		bra $8fa4			bra 	PokeCommand
.8f98						PokeWCommand:
.8f98		a9 02		lda #$02			lda 	#2
.8f9a		80 08		bra $8fa4			bra 	PokeCommand
.8f9c						PokeLCommand:
.8f9c		a9 03		lda #$03			lda 	#3
.8f9e		80 04		bra $8fa4			bra 	PokeCommand
.8fa0						PokeDCommand:
.8fa0		a9 04		lda #$04			lda 	#4
.8fa2		80 00		bra $8fa4			bra 	PokeCommand
.8fa4						PokeCommand:
.8fa4		48		pha				pha 								; save count on stack
.8fa5		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8fa7		20 36 a4	jsr $a436			jsr		Evaluate16BitInteger 		; address
.8faa		20 3c 95	jsr $953c			jsr 	CheckComma
.8fad		e8		inx				inx
.8fae		20 23 a4	jsr $a423			jsr		EvaluateInteger 			; data
.8fb1		a5 60		lda $60				lda 	NSMantissa0 				; copy address
.8fb3		85 36		sta $36				sta 	zTemp0
.8fb5		a5 70		lda $70				lda 	NSMantissa1
.8fb7		85 37		sta $37				sta 	zTemp0+1
.8fb9		68		pla				pla 								; count -> zTemp1
.8fba		85 38		sta $38				sta 	zTemp1
.8fbc		5a		phy				phy 								; save Y position.
.8fbd		a0 00		ldy #$00			ldy 	#0 							; index to write
.8fbf		a2 00		ldx #$00			ldx 	#0 							; index to read
.8fc1						_PCLoop:
.8fc1		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; read byte from mantissa and copy out
.8fc3		91 36		sta ($36),y			sta 	(zTemp0),y
.8fc5		c8		iny				iny 								; next byte to write
.8fc6		8a		txa				txa 								; next byte to read - stack layout in 04data.inc
.8fc7		18		clc				clc
.8fc8		69 10		adc #$10			adc 	#MathStackSize
.8fca		aa		tax				tax
.8fcb		c6 38		dec $38				dec 	zTemp1 						; done them all
.8fcd		d0 f2		bne $8fc1			bne 	_PCLoop
.8fcf		7a		ply				ply 								; restore position.
.8fd0		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2						ParameterStackPos = 2
.8fd1						CallProcedure:
.8fd1		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8fd3		b1 30		lda ($30),y			lda 	(codePtr),y
.8fd5		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8fd7		f0 10		beq $8fe9			beq 	_CPEndParam
.8fd9						_CPParamLoop:
.8fd9		20 fb a3	jsr $a3fb			jsr 	EvaluateValue 				; get parameter onto stack
.8fdc		e8		inx				inx 								; bump next stack
.8fdd		e0 10		cpx #$10			cpx		#MathStackSize				; check if parameters overflow stack
.8fdf		b0 52		bcs $9033			bge		_TooManyParam
.8fe1		b1 30		lda ($30),y			lda 	(codePtr),y
.8fe3		c8		iny				iny
.8fe4		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8fe6		f0 f1		beq $8fd9			beq 	_CPParamLoop
.8fe8		88		dey				dey 								; unpick.
.8fe9						_CPEndParam:
.8fe9		8e 32 04	stx $0432			stx 	lastParameter 				; save the last parameters index.
.8fec		c8		iny				iny									; skip right bracket
.8fed		a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8fef		20 cd b6	jsr $b6cd			jsr 	StackOpen
.8ff2		20 12 b7	jsr $b712			jsr 	STKSaveCodePosition 		; save loop position
.8ff5		a5 60		lda $60				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8ff7		85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8ff9		a5 70		lda $70				lda 	NSMantissa1
.8ffb		85 37		sta $37				sta 	zTemp0+1
.8ffd		a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8fff		b2 36		lda ($36)			lda 	(zTemp0)
.9001		85 30		sta $30				sta 	safePtr
.9003		b1 36		lda ($36),y			lda 	(zTemp0),y
.9005		85 31		sta $31				sta 	safePtr+1
.9007		c8		iny				iny
.9008		b1 36		lda ($36),y			lda 	(zTemp0),y
.900a		85 32		sta $32				sta 	safePtr+2
.900c		c8		iny				iny
.900d		b1 36		lda ($36),y			lda 	(zTemp0),y
.900f		85 33		sta $33				sta 	safePtr+3
.9011		c8		iny				iny 								; get Y offset -> Y
.9012		b1 36		lda ($36),y			lda 	(zTemp0),y
.9014		a8		tay				tay
.9015		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.9017		ec 32 04	cpx $0432			cpx	 	lastParameter 				; check zero parameters at the start
.901a		f0 13		beq $902f			beq 	_ParamExit 					; if so, exit.
.901c						_ParamExtract:
.901c		ca		dex				dex 								; put a local term on the level before
.901d		20 b7 8e	jsr $8eb7			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.9020		20 7f 8d	jsr $8d7f			jsr 	AssignVariable 				; assign stacked value to the variable.
.9023		e8		inx				inx 								; advance to next parameter to do.
.9024		e8		inx				inx
.9025		ec 32 04	cpx $0432			cpx 	lastParameter 				; are we done ?
.9028		f0 05		beq $902f			beq 	_ParamExit
.902a		20 3c 95	jsr $953c			jsr 	CheckComma 					; comma seperating parameters
.902d		80 ed		bra $901c			bra 	_ParamExtract
.902f						_ParamExit:
.902f		20 34 95	jsr $9534			jsr 	CheckRightBracket 			; check )
.9032		60		rts				rts 								; and continue from here
.9033						_TooManyParam:
.9033								error
.9033		a9 1d		lda #$1d		lda	#29
.9035		4c 4d 95	jmp $954d		jmp	ErrorHandler
.9038						Command_ENDPROC:
.9038		a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.903a		a2 14		ldx #$14			ldx 	#ERRID_PROC
.903c		20 fa b6	jsr $b6fa			jsr 	StackCheckFrame
.903f		20 23 b7	jsr $b723			jsr 	STKLoadCodePosition 		; restore code position
.9042		20 ec b6	jsr $b6ec			jsr 	StackClose
.9045		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.9046						Command_Read:
.9046		a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.9048		20 aa 9e	jsr $9eaa			jsr 	EvaluateTerm
.904b		b5 50		lda $50,x			lda 	NSStatus,x
.904d		29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.904f		f0 4f		beq $90a0			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.9051		20 e9 90	jsr $90e9			jsr 	SwapDataCodePtrs 			; swap code and data
.9054		ad 38 04	lda $0438			lda 	inDataStatement 			; if in a data statement, we don't need to search
.9057		d0 25		bne $907e			bne 	_CRContinueData  			; forward for the next one.
.9059		b2 30		lda ($30)			lda 	(codePtr)
.905b		f0 1c		beq $9079			beq 	_CRNoData
.905d						_CRKeepSearching:
.905d		a9 c0		lda #$c0			lda 	#KWD_DATA 					; scan for instruction
.905f		a2 80		ldx #$80			ldx 	#KWC_EOL
.9061		20 8f 94	jsr $948f			jsr 	ScanForward
.9064		c9 c0		cmp #$c0			cmp 	#KWD_DATA 					; found data ?
.9066		f0 16		beq $907e			beq 	_CRHaveData 				; found it
.9068		18		clc				clc
.9069		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.906b		65 30		adc $30				adc 	codePtr
.906d		85 30		sta $30				sta 	codePtr
.906f		90 02		bcc $9073			bcc 	_CREExit
.9071		e6 31		inc $31				inc 	codePtr+1 					; carry
.9073						_CREExit:
.9073		a0 03		ldy #$03			ldy 	#3 							; start of line.
.9075		b2 30		lda ($30)			lda 	(codePtr)
.9077		d0 e4		bne $905d			bne 	_CRKeepSearching
.9079						_CRNoData:
.9079		a9 0b		lda #$0b		lda	#11
.907b		4c 4d 95	jmp $954d		jmp	ErrorHandler
.907e						_CRHaveData:
.907e						_CRContinueData:
.907e		a2 01		ldx #$01			ldx 	#1
.9080		20 fb a3	jsr $a3fb			jsr 	EvaluateValue 				; evaluate value into slot # 1
.9083		ca		dex				dex
.9084		20 7f 8d	jsr $8d7f			jsr		AssignVariable 				; do the assignment
.9087		9c 38 04	stz $0438			stz 	inDataStatement 			; clear in data flag
.908a		b1 30		lda ($30),y			lda 	(codePtr),y
.908c		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.908e		d0 04		bne $9094			bne 	_CRSwapBack
.9090		c8		iny				iny 								; consume comma
.9091		ee 38 04	inc $0438			inc 	inDataStatement 			; set in data statement currently.
.9094						_CRSwapBack:
.9094		20 e9 90	jsr $90e9			jsr 	SwapDataCodePtrs			; swap them back.
.9097		b1 30		lda ($30),y			lda 	(codePtr),y
.9099		c8		iny				iny
.909a		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.909c		f0 a8		beq $9046			beq 	Command_Read 				; if so go round again.
.909e		88		dey				dey 								; unpick get.
.909f		60		rts				rts
.90a0						_CRSyntax:
.90a0		4c 2e a6	jmp $a62e			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.90a3						RemCommand:
.90a3		b1 30		lda ($30),y			lda 	(codePtr),y
.90a5		c9 ff		cmp #$ff			cmp 	#KWC_STRING
.90a7		d0 06		bne $90af			bne 	_RMExit
.90a9		c8		iny				iny 								; point to offset
.90aa		98		tya				tya 								; A = offset position
.90ab		38		sec				sec 								; add size +1 hence SEC
.90ac		71 30		adc ($30),y			adc 	(codePtr),y
.90ae		a8		tay				tay 								; make current position.
.90af						_RMExit:
.90af		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.90b0						Command_REPEAT:
.90b0		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.90b2		20 cd b6	jsr $b6cd			jsr 	StackOpen
.90b5		20 12 b7	jsr $b712			jsr 	STKSaveCodePosition 		; save loop position
.90b8		60		rts				rts
.90b9						Command_UNTIL:
.90b9		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.90bb		a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.90bd		20 fa b6	jsr $b6fa			jsr 	StackCheckFrame
.90c0		a2 00		ldx #$00			ldx 	#0
.90c2		20 04 a4	jsr $a404			jsr 	EvaluateNumber 				; work out the number
.90c5		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; check if zero
.90c8		f0 04		beq $90ce			beq 	_CULoopBack 				; if so keep looping
.90ca		20 ec b6	jsr $b6ec			jsr 	StackClose		 			; return
.90cd		60		rts				rts
.90ce						_CULoopBack:
.90ce		20 23 b7	jsr $b723			jsr 	STKLoadCodePosition 		; loop back
.90d1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.90d2						Command_Restore:
.90d2		20 e9 90	jsr $90e9			jsr 	SwapDataCodePtrs 			; swap code and data
.90d5		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.90d7		85 30		sta $30				sta 	codePtr
.90d9		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.90db		85 31		sta $31				sta 	codePtr+1
.90dd		20 e9 90	jsr $90e9			jsr 	SwapDataCodePtrs 			; put them back
.90e0		a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.90e2		8d 37 04	sta $0437			sta 	dataPointer+4   			; (read checks not EOF)
.90e5		9c 38 04	stz $0438			stz 	inDataStatement 			; not in data statement
.90e8		60		rts				rts
.90e9						SwapDataCodePtrs:
.90e9		da		phx				phx
.90ea		a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.90ec						_SDCPLoop:
.90ec		b5 30		lda $30,x			lda 	safePtr,x
.90ee		48		pha				pha
.90ef		bd 33 04	lda $0433,x			lda 	dataPointer,x
.90f2		95 30		sta $30,x			sta 	safePtr,x
.90f4		68		pla				pla
.90f5		9d 33 04	sta $0433,x			sta 	dataPointer,x
.90f8		ca		dex				dex
.90f9		10 f1		bpl $90ec			bpl 	_SDCPLoop
.90fb		ad 37 04	lda $0437			lda 	dataPointer+4 				; swap Y position over.
.90fe		8c 37 04	sty $0437			sty 	dataPointer+4
.9101		a8		tay				tay
.9102		fa		plx				plx
.9103		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.9104						EOLCommand:
.9104		18		clc				clc
.9105		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.9107		65 30		adc $30				adc 	codePtr
.9109		85 30		sta $30				sta 	codePtr
.910b		90 02		bcc $910f			bcc 	_CREExit
.910d		e6 31		inc $31				inc 	codePtr+1 					; carry
.910f						_CREExit:
.910f		80 18		bra $9129			bra 	RunNewLine
.9111						CommandRUNOptLoad:
.9111		b1 30		lda ($30),y			lda 	(codePtr),y
.9113		c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL / : just RUN
.9115		f0 07		beq $911e			beq 	RunCurrentProgram
.9117		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.9119		f0 03		beq $911e			beq 	RunCurrentProgram
.911b		20 73 b0	jsr $b073			jsr 	LoadFile 					; load expected name file.
.911e						RunCurrentProgram:
.911e		20 d9 93	jsr $93d9			jsr 	ClearSystem 				; clear variable/stacks/etc.
.9121		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.9123		85 30		sta $30				sta 	codePtr
.9125		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.9127		85 31		sta $31				sta 	codePtr+1
.9129						RunNewLine:
.9129		b2 30		lda ($30)			lda 	(codePtr)
.912b		f0 74		beq $91a1			beq 	CRNoProgram         		; no then END.
.912d		a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.912f		9a		txs				txs
.9130						RUNCodePointerLine:
.9130		a0 02		ldy #$02			ldy 	#2 							; start of program
.9132						_CRIncMainLoop:
.9132		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.9134		f0 03		beq $9139			beq 	_NoEvents					; if zero, skip with Z flag set.
.9136		20 58 81	jsr $8158			jsr 	ProcessEvents
.9139						_NoEvents:
.9139		d0 61		bne $919c			bne 	_CRBreak
.913b		a5 01		lda $01				lda 	1 							; save I/O 0
.913d		48		pha				pha
.913e		64 01		stz $01				stz 	1 							; access I/O Page 0
.9140		38		sec				sec 								; calculate timer - LastTick
.9141		ad 59 d6	lda $d659			lda 	$D659
.9144		cd 81 06	cmp $0681			cmp 	LastTick
.9147		f0 06		beq $914f			beq 	_NoFireTick 				; if < 3 clocks don't fire.
.9149		8d 81 06	sta $0681			sta 	LastTick 					; update last timer
.914c		20 ee 82	jsr $82ee			jsr 	TickHandler 							; go do the code.
.914f						_NoFireTick:
.914f		68		pla				pla 								; restore I/O 0
.9150		85 01		sta $01				sta 	1
.9152						_CRNoBreakCheck:
.9152		c8		iny				iny									; next token
.9153						_CRMainLoop:
.9153		9c 2c 04	stz $042c			stz 	stringInitialised 			; clear the temporary string initialised flag.
.9156		b1 30		lda ($30),y			lda 	(codePtr),y
.9158		10 10		bpl $916a			bpl 	_CRNotKeyword				; not a token.
.915a		c9 ae		cmp #$ae			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.915c		b0 04		bcs $9162			bcs 	_CRIsKeyword
.915e		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.9160		b0 34		bcs $9196			bcs		_CRSyntaxError
.9162						_CRIsKeyword:
.9162		c8		iny				iny 								; consume command
.9163		0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.9164		aa		tax				tax 								; put in X for vector jump
.9165		20 99 91	jsr $9199			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.9168		80 e9		bra $9153			bra 	_CRMainLoop 				; and loop round
.916a						_CRNotKeyword:
.916a		c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.916c		f0 c4		beq $9132			beq 	_CRIncMainLoop
.916e		c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.9170		90 05		bcc $9177			bcc 	_CRNotVariable
.9172						_CRGoLet:
.9172		20 46 8d	jsr $8d46			jsr 	LetCommand
.9175		80 dc		bra $9153			bra 	_CRMainLoop
.9177						_CRNotVariable:
.9177		c9 10		cmp #$10			cmp 	#KWD_ATCH 					; handle @
.9179		f0 f7		beq $9172			beq 	_CRGoLet
.917b		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.917d		f0 f3		beq $9172			beq 	_CRGoLet
.917f		c9 21		cmp #$21			cmp 	#KWD_PLING
.9181		f0 ef		beq $9172			beq 	_CRGoLet
.9183		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.9185		f0 09		beq $9190			beq 	_CRGoRem
.9187		c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.9189		d0 0b		bne $9196			bne 	_CRSyntaxError
.918b		20 d0 86	jsr $86d0			jsr 	LabelHere
.918e		80 c3		bra $9153			bra 	_CRMainLoop
.9190						_CRGoRem:
.9190		c8		iny				iny
.9191		20 a3 90	jsr $90a3			jsr 	RemCommand
.9194		80 bd		bra $9153			bra 	_CRMainLoop
.9196						_CRSyntaxError:
.9196		4c 2e a6	jmp $a62e			jmp 	SyntaxError
.9199						_CRCallVector0:
.9199		7c 38 92	jmp ($9238,x)			jmp 	(VectorSet0,x)
.919c						_CRBreak:
.919c		a9 01		lda #$01		lda	#1
.919e		4c 4d 95	jmp $954d		jmp	ErrorHandler
.91a1						CRNoProgram:
.91a1		4c 7b 8a	jmp $8a7b			jmp 	EndCommand
.91a4						Shift1Command:
.91a4		b1 30		lda ($30),y			lda 	(codePtr),y
.91a6		c8		iny				iny
.91a7		0a		asl a				asl 	a
.91a8		aa		tax				tax
.91a9		7c f4 92	jmp ($92f4,x)			jmp 	(VectorSet1,x)
.91ac						Shift2Command:
.91ac		b1 30		lda ($30),y			lda 	(codePtr),y
.91ae		c8		iny				iny
.91af		0a		asl a				asl 	a
.91b0		aa		tax				tax
.91b1		7c 4c 93	jmp ($934c,x)			jmp 	(VectorSet2,x)
.91b4						Unused1:
.91b4						Unused2:
.91b4						Unused3:
.91b4						Unused4:
.91b4						Unused5:
.91b4		4c 2e a6	jmp $a62e			jmp 	SyntaxError
>91b7								.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.91b8						VectorSetPunc:
>91b8		0b 98					.word	ShiftLeft                        ; $00 <<
>91ba		f6 95					.word	BinaryCompareLessEqual           ; $01 <=
>91bc		ec 95					.word	BinaryCompareNotEqual            ; $02 <>
>91be		2e a6					.word	SyntaxError                      ; $03 !!3
>91c0		2e a6					.word	SyntaxError                      ; $04 ><
>91c2		00 96					.word	BinaryCompareGreaterEqual        ; $05 >=
>91c4		0e 98					.word	ShiftRight                       ; $06 >>
>91c6		2e a6					.word	SyntaxError                      ; $07 !!7
>91c8		2e a6					.word	SyntaxError                      ; $08 !!8
>91ca		2e a6					.word	SyntaxError                      ; $09 !!9
>91cc		2e a6					.word	SyntaxError                      ; $0a !!10
>91ce		2e a6					.word	SyntaxError                      ; $0b !!11
>91d0		2e a6					.word	SyntaxError                      ; $0c !!12
>91d2		2e a6					.word	SyntaxError                      ; $0d !!13
>91d4		2e a6					.word	SyntaxError                      ; $0e !!14
>91d6		2e a6					.word	SyntaxError                      ; $0f !!15
>91d8		2e a6					.word	SyntaxError                      ; $10 @
>91da		2e a6					.word	SyntaxError                      ; $11 !!17
>91dc		2e a6					.word	SyntaxError                      ; $12 !!18
>91de		2e a6					.word	SyntaxError                      ; $13 [
>91e0		b7 96					.word	IntegerDivide                    ; $14 \
>91e2		2e a6					.word	SyntaxError                      ; $15 ]
>91e4		49 99					.word	EorInteger                       ; $16 ^
>91e6		2e a6					.word	SyntaxError                      ; $17 _
>91e8		2e a6					.word	SyntaxError                      ; $18 `
>91ea		2e a6					.word	SyntaxError                      ; $19 !!25
>91ec		2e a6					.word	SyntaxError                      ; $1a !!26
>91ee		2e a6					.word	SyntaxError                      ; $1b {
>91f0		14 99					.word	OraInteger                       ; $1c |
>91f2		2e a6					.word	SyntaxError                      ; $1d }
>91f4		2e a6					.word	SyntaxError                      ; $1e ~
>91f6		2e a6					.word	SyntaxError                      ; $1f <7F>
>91f8		2e a6					.word	SyntaxError                      ; $20
>91fa		7e 99					.word	WordIndirect                     ; $21 !
>91fc		2e a6					.word	SyntaxError                      ; $22 "
>91fe		2e a6					.word	SyntaxError                      ; $23 #
>9200		2e a6					.word	SyntaxError                      ; $24 $
>9202		f8 96					.word	IntegerModulus                   ; $25 %
>9204		df 98					.word	AndInteger                       ; $26 &
>9206		2e a6					.word	SyntaxError                      ; $27 '
>9208		2e a6					.word	SyntaxError                      ; $28 (
>920a		2e a6					.word	SyntaxError                      ; $29 )
>920c		66 97					.word	MulInteger                       ; $2a *
>920e		81 98					.word	AddInteger                       ; $2b +
>9210		2e a6					.word	SyntaxError                      ; $2c ,
>9212		ba 98					.word	SubInteger                       ; $2d -
>9214		2e a6					.word	SyntaxError                      ; $2e .
>9216		41 9b					.word	FDivideCommand                   ; $2f /
>9218		2e a6					.word	SyntaxError                      ; $30 0
>921a		2e a6					.word	SyntaxError                      ; $31 1
>921c		2e a6					.word	SyntaxError                      ; $32 2
>921e		2e a6					.word	SyntaxError                      ; $33 3
>9220		2e a6					.word	SyntaxError                      ; $34 4
>9222		2e a6					.word	SyntaxError                      ; $35 5
>9224		2e a6					.word	SyntaxError                      ; $36 6
>9226		2e a6					.word	SyntaxError                      ; $37 7
>9228		2e a6					.word	SyntaxError                      ; $38 8
>922a		2e a6					.word	SyntaxError                      ; $39 9
>922c		2e a6					.word	SyntaxError                      ; $3a :
>922e		2e a6					.word	SyntaxError                      ; $3b ;
>9230		d8 95					.word	BinaryCompareLess                ; $3c <
>9232		ce 95					.word	BinaryCompareEqual               ; $3d =
>9234		e2 95					.word	BinaryCompareGreater             ; $3e >
>9236		a0 99					.word	ByteIndirect                     ; $3f ?
.9238						VectorSet0:
>9238		04 91					.word	EOLCommand                       ; $80 !0:EOF
>923a		a4 91					.word	Shift1Command                    ; $81 !1:SH1
>923c		ac 91					.word	Shift2Command                    ; $82 !2:SH2
>923e		2b a0					.word	AbsUnary                         ; $83 ABS(
>9240		39 a0					.word	AllocUnary                       ; $84 ALLOC(
>9242		a9 a0					.word	AscUnary                         ; $85 ASC(
>9244		fa a1					.word	ChrUnary                         ; $86 CHR$(
>9246		05 ae					.word	UnaryEvent                       ; $87 EVENT(
>9248		ca 95					.word	UnaryFalse                       ; $88 FALSE
>924a		b6 a0					.word	FracUnary                        ; $89 FRAC(
>924c		2b b5					.word	ChrGet                           ; $8a GET$(
>924e		10 b5					.word	AscGet                           ; $8b GET(
>9250		ba b4					.word	UnaryGetDate                     ; $8c GETDATE$(
>9252		b6 b4					.word	UnaryGetTime                     ; $8d GETTIME$(
>9254		5e ac					.word	UnaryHit                         ; $8e HIT(
>9256		32 b5					.word	ChrInkey                         ; $8f INKEY$(
>9258		20 b5					.word	AscInkey                         ; $90 INKEY(
>925a		cb a0					.word	IntUnary                         ; $91 INT(
>925c		b9 a1					.word	IsValUnary                       ; $92 ISVAL(
>925e		0c a2					.word	ItemCountUnary                   ; $93 ITEMCOUNT(
>9260		30 a2					.word	ItemGetUnary                     ; $94 ITEMGET$(
>9262		8d b2					.word	UnaryJoyB                        ; $95 JOYB(
>9264		66 b2					.word	UnaryJoyX                        ; $96 JOYX(
>9266		69 b2					.word	UnaryJoyY                        ; $97 JOYY(
>9268		4b b5					.word	KeyDown                          ; $98 KEYDOWN(
>926a		6f a3					.word	Unary_Left                       ; $99 LEFT$(
>926c		dc a0					.word	LenUnary                         ; $9a LEN(
>926e		fa a0					.word	Unary_Max                        ; $9b MAX(
>9270		91 a3					.word	Unary_Mid                        ; $9c MID$(
>9272		f6 a0					.word	Unary_Min                        ; $9d MIN(
>9274		45 a1					.word	Unary_Not                        ; $9e NOT(
>9276		58 a1					.word	PeekByteUnary                    ; $9f PEEK(
>9278		64 a1					.word	PeekDUnary                       ; $a0 PEEKD(
>927a		60 a1					.word	PeekLUnary                       ; $a1 PEEKL(
>927c		5c a1					.word	PeekWUnary                       ; $a2 PEEKW(
>927e		2a b6					.word	UnaryPlaying                     ; $a3 PLAYING(
>9280		65 b5					.word	Unary_Random                     ; $a4 RANDOM(
>9282		7c a3					.word	Unary_Right                      ; $a5 RIGHT$(
>9284		7f b5					.word	Unary_Rnd                        ; $a6 RND(
>9286		91 a1					.word	SgnUnary                         ; $a7 SGN(
>9288		ae a2					.word	SpcUnary                         ; $a8 SPC(
>928a		c9 a2					.word	Unary_Str                        ; $a9 STR$(
>928c		3d ad					.word	TileRead                         ; $aa TILE(
>928e		9d b4					.word	UnaryTimer                       ; $ab TIMER(
>9290		bf 95					.word	UnaryTrue                        ; $ac TRUE
>9292		af a1					.word	ValUnary                         ; $ad VAL(
>9294		7e 8a					.word	ForCommand                       ; $ae FOR
>9296		f3 8b					.word	IfCommand                        ; $af IF
>9298		b4 91					.word	Unused1                          ; $b0 PROC
>929a		b0 90					.word	Command_REPEAT                   ; $b1 REPEAT
>929c		05 95					.word	Command_WHILE                    ; $b2 WHILE
>929e		1c 8c					.word	EndIf                            ; $b3 ENDIF
>92a0		38 90					.word	Command_ENDPROC                  ; $b4 ENDPROC
>92a2		5f 8b					.word	NextCommand                      ; $b5 NEXT
>92a4		b4 91					.word	Unused4                          ; $b6 THEN
>92a6		b9 90					.word	Command_UNTIL                    ; $b7 UNTIL
>92a8		26 95					.word	Command_WEND                     ; $b8 WEND
>92aa		2e a6					.word	SyntaxError                      ; $b9 AT
>92ac		2e a6					.word	SyntaxError                      ; $ba BY
>92ae		81 89					.word	CallCommand                      ; $bb CALL
>92b0		4c a9					.word	CircleCommand                    ; $bc CIRCLE
>92b2		2e a6					.word	SyntaxError                      ; $bd CLEAR
>92b4		2e a6					.word	SyntaxError                      ; $be COLOR
>92b6		2e a6					.word	SyntaxError                      ; $bf COLOUR
>92b8		b6 89					.word	Command_Data                     ; $c0 DATA
>92ba		be 89					.word	DimCommand                       ; $c1 DIM
>92bc		b4 91					.word	Unused3                          ; $c2 DOWNTO
>92be		15 8c					.word	ElseCode                         ; $c3 ELSE
>92c0		2e a6					.word	SyntaxError                      ; $c4 FROM
>92c2		31 ac					.word	GfxCommand                       ; $c5 GFX
>92c4		2e a6					.word	SyntaxError                      ; $c6 HERE
>92c6		75 a9					.word	ImageCommand                     ; $c7 IMAGE
>92c8		46 8d					.word	LetCommand                       ; $c8 LET
>92ca		c7 a9					.word	LineCommand                      ; $c9 LINE
>92cc		a9 8e					.word	Command_LOCAL                    ; $ca LOCAL
>92ce		9f b2					.word	MCCommand                        ; $cb MEMCOPY
>92d0		2e a6					.word	SyntaxError                      ; $cc OFF
>92d2		2e a6					.word	SyntaxError                      ; $cd ON
>92d4		2e a6					.word	SyntaxError                      ; $ce OUTLINE
>92d6		82 ac					.word	PaletteCommand                   ; $cf PALETTE
>92d8		c0 a9					.word	PlotCommand                      ; $d0 PLOT
>92da		94 8f					.word	PokeBCommand                     ; $d1 POKE
>92dc		a0 8f					.word	PokeDCommand                     ; $d2 POKED
>92de		9c 8f					.word	PokeLCommand                     ; $d3 POKEL
>92e0		98 8f					.word	PokeWCommand                     ; $d4 POKEW
>92e2		46 90					.word	Command_Read                     ; $d5 READ
>92e4		48 a9					.word	RectangleCommand                 ; $d6 RECT
>92e6		a3 90					.word	RemCommand                       ; $d7 REM
>92e8		2e a6					.word	SyntaxError                      ; $d8 SOLID
>92ea		46 b6					.word	SoundCommand                     ; $d9 SOUND
>92ec		57 a9					.word	SpriteCommand                    ; $da SPRITE
>92ee		b4 91					.word	Unused5                          ; $db STEP
>92f0		91 a9					.word	TextCommand                      ; $dc TEXT
>92f2		b4 91					.word	Unused2                          ; $dd TO
.92f4						VectorSet1:
>92f4		2e a6					.word	SyntaxError                      ; $80 !0:EOF
>92f6		2e a6					.word	SyntaxError                      ; $81 !1:SH1
>92f8		2e a6					.word	SyntaxError                      ; $82 !2:SH2
>92fa		55 89					.word	AssembleCommand                  ; $83 ASSEMBLE
>92fc		71 89					.word	AssertCommand                    ; $84 ASSERT
>92fe		22 ab					.word	BitmapCtrl                       ; $85 BITMAP
>9300		62 ae					.word	Command_BLoad                    ; $86 BLOAD
>9302		0e af					.word	Command_BSave                    ; $87 BSAVE
>9304		58 ad					.word	ClearScreen                      ; $88 CLS
>9306		22 8c					.word	Command_CPrint                   ; $89 CPRINT
>9308		60 ad					.word	CursorControl                    ; $8a CURSOR
>930a		91 af					.word	Command_Dir                      ; $8b DIR
>930c		61 b0					.word	Command_Drive                    ; $8c DRIVE
>930e		7b 8a					.word	EndCommand                       ; $8d END
>9310		fe b5					.word	Explode                          ; $8e EXPLODE
>9312		2e a6					.word	SyntaxError                      ; $8f GO
>9314		bb 8b					.word	Command_GOSUB                    ; $90 GOSUB
>9316		d9 8b					.word	GotoCommand                      ; $91 GOTO
>9318		2e a6					.word	SyntaxError                      ; $92 HIMEM
>931a		1d 8c					.word	Command_Input                    ; $93 INPUT
>931c		96 8d					.word	Command_List                     ; $94 LIST
>931e		68 b0					.word	Command_Load                     ; $95 LOAD
>9320		b3 b3					.word	MouseDeltaStatus                 ; $96 MDELTA
>9322		af b3					.word	MouseStatus                      ; $97 MOUSE
>9324		6a 8f					.word	NewCommand                       ; $98 NEW
>9326		82 8f					.word	OptionCommand                    ; $99 OPTION
>9328		da b5					.word	PingCommand                      ; $9a PING
>932a		29 8c					.word	Command_Print                    ; $9b PRINT
>932c		d2 90					.word	Command_Restore                  ; $9c RESTORE
>932e		cb 8b					.word	Command_RETURN                   ; $9d RETURN
>9330		11 91					.word	CommandRUNOptLoad                ; $9e RUN
>9332		3f b1					.word	Command_Save                     ; $9f SAVE
>9334		29 b4					.word	CommandSetDate                   ; $a0 SETDATE
>9336		2d b4					.word	CommandSetTime                   ; $a1 SETTIME
>9338		f2 b5					.word	ShootCommand                     ; $a2 SHOOT
>933a		7c ab					.word	SpritesCtrl                      ; $a3 SPRITES
>933c		d4 93					.word	StopCommand                      ; $a4 STOP
>933e		c2 ac					.word	TileCommand                      ; $a5 TILE
>9340		a4 ab					.word	TilesCtrl                        ; $a6 TILES
>9342		c9 b1					.word	Command_Try                      ; $a7 TRY
>9344		06 b2					.word	Command_VERIFY                   ; $a8 VERIFY
>9346		8f ad					.word	XGoCommand                       ; $a9 XGO
>9348		86 ad					.word	XLoadCommand                     ; $aa XLOAD
>934a		e6 b5					.word	ZapCommand                       ; $ab ZAP
.934c						VectorSet2:
>934c		2e a6					.word	SyntaxError                      ; $80 !0:EOF
>934e		2e a6					.word	SyntaxError                      ; $81 !1:SH1
>9350		2e a6					.word	SyntaxError                      ; $82 !2:SH2
>9352		ed a4					.word	Assemble_adc                     ; $83 ADC
>9354		e5 a4					.word	Assemble_and                     ; $84 AND
>9356		01 a5					.word	Assemble_asl                     ; $85 ASL
>9358		6b a5					.word	Assemble_bcc                     ; $86 BCC
>935a		6f a5					.word	Assemble_bcs                     ; $87 BCS
>935c		77 a5					.word	Assemble_beq                     ; $88 BEQ
>935e		2e a5					.word	Assemble_bit                     ; $89 BIT
>9360		5f a5					.word	Assemble_bmi                     ; $8a BMI
>9362		73 a5					.word	Assemble_bne                     ; $8b BNE
>9364		5b a5					.word	Assemble_bpl                     ; $8c BPL
>9366		7b a5					.word	Assemble_bra                     ; $8d BRA
>9368		7f a5					.word	Assemble_brk                     ; $8e BRK
>936a		63 a5					.word	Assemble_bvc                     ; $8f BVC
>936c		67 a5					.word	Assemble_bvs                     ; $90 BVS
>936e		87 a5					.word	Assemble_clc                     ; $91 CLC
>9370		db a5					.word	Assemble_cld                     ; $92 CLD
>9372		9b a5					.word	Assemble_cli                     ; $93 CLI
>9374		cb a5					.word	Assemble_clv                     ; $94 CLV
>9376		f9 a4					.word	Assemble_cmp                     ; $95 CMP
>9378		42 a5					.word	Assemble_cpx                     ; $96 CPX
>937a		3d a5					.word	Assemble_cpy                     ; $97 CPY
>937c		1f a5					.word	Assemble_dec                     ; $98 DEC
>937e		d7 a5					.word	Assemble_dex                     ; $99 DEX
>9380		b3 a5					.word	Assemble_dey                     ; $9a DEY
>9382		e9 a4					.word	Assemble_eor                     ; $9b EOR
>9384		24 a5					.word	Assemble_inc                     ; $9c INC
>9386		e7 a5					.word	Assemble_inx                     ; $9d INX
>9388		d3 a5					.word	Assemble_iny                     ; $9e INY
>938a		56 a5					.word	Assemble_jmp                     ; $9f JMP
>938c		51 a5					.word	Assemble_jsr                     ; $a0 JSR
>938e		f5 a4					.word	Assemble_lda                     ; $a1 LDA
>9390		1a a5					.word	Assemble_ldx                     ; $a2 LDX
>9392		38 a5					.word	Assemble_ldy                     ; $a3 LDY
>9394		0b a5					.word	Assemble_lsr                     ; $a4 LSR
>9396		eb a5					.word	Assemble_nop                     ; $a5 NOP
>9398		e1 a4					.word	Assemble_ora                     ; $a6 ORA
>939a		97 a5					.word	Assemble_pha                     ; $a7 PHA
>939c		83 a5					.word	Assemble_php                     ; $a8 PHP
>939e		df a5					.word	Assemble_phx                     ; $a9 PHX
>93a0		9f a5					.word	Assemble_phy                     ; $aa PHY
>93a2		a7 a5					.word	Assemble_pla                     ; $ab PLA
>93a4		8b a5					.word	Assemble_plp                     ; $ac PLP
>93a6		f3 a5					.word	Assemble_plx                     ; $ad PLX
>93a8		af a5					.word	Assemble_ply                     ; $ae PLY
>93aa		06 a5					.word	Assemble_rol                     ; $af ROL
>93ac		10 a5					.word	Assemble_ror                     ; $b0 ROR
>93ae		93 a5					.word	Assemble_rti                     ; $b1 RTI
>93b0		a3 a5					.word	Assemble_rts                     ; $b2 RTS
>93b2		fd a4					.word	Assemble_sbc                     ; $b3 SBC
>93b4		8f a5					.word	Assemble_sec                     ; $b4 SEC
>93b6		ef a5					.word	Assemble_sed                     ; $b5 SED
>93b8		ab a5					.word	Assemble_sei                     ; $b6 SEI
>93ba		f1 a4					.word	Assemble_sta                     ; $b7 STA
>93bc		e3 a5					.word	Assemble_stp                     ; $b8 STP
>93be		15 a5					.word	Assemble_stx                     ; $b9 STX
>93c0		33 a5					.word	Assemble_sty                     ; $ba STY
>93c2		29 a5					.word	Assemble_stz                     ; $bb STZ
>93c4		c7 a5					.word	Assemble_tax                     ; $bc TAX
>93c6		c3 a5					.word	Assemble_tay                     ; $bd TAY
>93c8		4c a5					.word	Assemble_trb                     ; $be TRB
>93ca		47 a5					.word	Assemble_tsb                     ; $bf TSB
>93cc		cf a5					.word	Assemble_tsx                     ; $c0 TSX
>93ce		b7 a5					.word	Assemble_txa                     ; $c1 TXA
>93d0		bf a5					.word	Assemble_txs                     ; $c2 TXS
>93d2		bb a5					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.93d4						StopCommand:
.93d4		a9 08		lda #$08		lda	#8
.93d6		4c 4d 95	jmp $954d		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/clear.asm

.93d9						ClearSystem:
.93d9		a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.93db		85 36		sta $36				sta 	0+zTemp0
.93dd		a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.93df		85 37		sta $37				sta 	1+zTemp0
.93e1						_ClearZeroLoop:
.93e1		b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.93e3		f0 24		beq $9409			beq 	_ClearZeroEnd
.93e5		a0 03		ldy #$03			ldy 	#3 							; erase the variables
.93e7		a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.93e9						_ClearOneVariable:
.93e9		91 36		sta ($36),y			sta 	(zTemp0),y
.93eb		c8		iny				iny
.93ec		c0 08		cpy #$08			cpy 	#8
.93ee		d0 f9		bne $93e9			bne 	_ClearOneVariable
.93f0		a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.93f2		b1 36		lda ($36),y			lda 	(zTemp0),y
.93f4		c9 18		cmp #$18			cmp 	#NSTProcedure
.93f6		d0 04		bne $93fc			bne 	_ClearNotProcedure
.93f8		a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.93fa		91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.93fc						_ClearNotProcedure:
.93fc		18		clc				clc 								; go to the next variable
.93fd		b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.93ff		65 36		adc $36				adc 	zTemp0
.9401		85 36		sta $36				sta 	zTemp0
.9403		90 dc		bcc $93e1			bcc 	_ClearZeroLoop
.9405		e6 37		inc $37				inc 	zTemp0+1
.9407		80 d8		bra $93e1			bra 	_ClearZeroLoop
.9409						_ClearZeroEnd:
.9409		18		clc				clc
.940a		a5 36		lda $36				lda 	zTemp0
.940c		69 01		adc #$01			adc 	#1
.940e		8d 28 04	sta $0428			sta 	lowMemPtr
.9411		a5 37		lda $37				lda 	zTemp0+1
.9413		69 00		adc #$00			adc 	#0
.9415		8d 29 04	sta $0429			sta 	lowMemPtr+1
.9418		20 33 b7	jsr $b733			jsr 	StackReset
.941b		20 99 b7	jsr $b799			jsr 	StringSystemInitialise
.941e		20 37 94	jsr $9437			jsr 	ProcedureScan
.9421		20 d2 90	jsr $90d2			jsr 	Command_Restore
.9424		9c 3a 04	stz $043a			stz 	AssemblerAddress
.9427		9c 3b 04	stz $043b			stz 	AssemblerAddress+1
.942a		9c 3c 04	stz $043c			stz 	AssemblerControl
.942d		9c 80 06	stz $0680			stz 	KeyboardQueueEntries
.9430		20 96 a0	jsr $a096			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9433		20 0b ab	jsr $ab0b			jsr 	ResetBitmapSpritesTiles
.9436		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.9437						ProcedureScan:
.9437		20 e9 90	jsr $90e9			jsr 	SwapDataCodePtrs 			; swap code and data
.943a		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.943c		85 30		sta $30				sta 	codePtr
.943e		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.9440		85 31		sta $31				sta 	codePtr+1
.9442						_PSLoop:
.9442		b2 30		lda ($30)			lda 	(codePtr)
.9444		f0 42		beq $9488			beq 	_PSExit
.9446		a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.9448		b1 30		lda ($30),y			lda 	(codePtr),y
.944a		c9 b0		cmp #$b0			cmp 	#KWD_PROC
.944c		d0 2d		bne $947b			bne 	_PSNext
.944e		c8		iny				iny 								; get the address of the record to zTemp0 and
.944f		b1 30		lda ($30),y			lda 	(codePtr),y
.9451		29 c0		and #$c0			and 	#$C0
.9453		c9 40		cmp #$40			cmp 	#$40
.9455		d0 35		bne $948c			bne 	_PSSyntax
.9457		b1 30		lda ($30),y			lda 	(codePtr),y
.9459		18		clc				clc
.945a		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.945c		85 37		sta $37				sta 	zTemp0+1
.945e		c8		iny				iny 								; LSB
.945f		b1 30		lda ($30),y			lda 	(codePtr),y
.9461		85 36		sta $36				sta 	zTemp0
.9463		c8		iny				iny 								; character after variable call.
.9464		98		tya				tya 								; save Y offset at +7 (exponent slot)
.9465		a0 07		ldy #$07			ldy 	#7
.9467		91 36		sta ($36),y			sta 	(zTemp0),y
.9469		a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.946b		a0 02		ldy #$02			ldy 	#2
.946d		91 36		sta ($36),y			sta 	(zTemp0),y
.946f		a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.9471						_PSCopy:
.9471		b5 30		lda $30,x			lda 	safePtr,x
.9473		c8		iny				iny
.9474		91 36		sta ($36),y			sta 	(zTemp0),y
.9476		e8		inx				inx
.9477		e0 04		cpx #$04			cpx 	#4
.9479		d0 f6		bne $9471			bne 	_PSCopy
.947b						_PSNext:
.947b		18		clc				clc
.947c		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.947e		65 30		adc $30				adc 	codePtr
.9480		85 30		sta $30				sta 	codePtr
.9482		90 02		bcc $9486			bcc 	_CREExit
.9484		e6 31		inc $31				inc 	codePtr+1 					; carry
.9486						_CREExit:
.9486		80 ba		bra $9442			bra 	_PSLoop
.9488						_PSExit:
.9488		20 e9 90	jsr $90e9			jsr 	SwapDataCodePtrs 			; swap code and data
.948b		60		rts				rts
.948c						_PSSyntax:
.948c		4c 2e a6	jmp $a62e			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.948f						ScanForward:
.948f		64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.9491		86 37		stx $37				stx 	zTemp0+1
.9493		85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.9495						_ScanLoop:
.9495		b1 30		lda ($30),y			lda 	(codePtr),y
.9497		c8		iny				iny
.9498		a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.949a		d0 0e		bne $94aa			bne 	_ScanGoNext
.949c		c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.949e		f0 04		beq $94a4			beq 	_ScanMatch
.94a0		c5 37		cmp $37				cmp 	zTemp0+1
.94a2		d0 06		bne $94aa			bne 	_ScanGoNext
.94a4						_ScanMatch:
.94a4		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.94a6		d0 01		bne $94a9			bne 	_ScanNotEndEOL
.94a8		88		dey				dey
.94a9						_ScanNotEndEOL:
.94a9		60		rts				rts
.94aa						_ScanGoNext:
.94aa		20 af 94	jsr $94af			jsr  	ScanForwardOne 				; allows for shifts and so on.
.94ad		80 e6		bra $9495			bra 	_ScanLoop
.94af						ScanForwardOne:
.94af		c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.94b1		90 3e		bcc $94f1			bcc 	_SFWExit
.94b3		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.94b5		90 18		bcc $94cf			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.94b7		c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.94b9		b0 2f		bcs $94ea			bcs 	_ScanSkipData
.94bb		c9 ae		cmp #$ae			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.94bd		90 32		bcc $94f1			bcc 	_SFWExit 					; if not, ordinary keywords.
.94bf		c9 b9		cmp #$b9			cmp 	#KWC_LAST_STRUCTURE+1
.94c1		b0 2e		bcs $94f1			bcs 	_SFWExit
.94c3		c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.94c5		c9 b3		cmp #$b3			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.94c7		b0 28		bcs $94f1			bcs 	_SFWExit
.94c9		e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.94cb		e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.94cd		80 22		bra $94f1			bra 	_SFWExit
.94cf						_ScanSkipOne:
.94cf		c8		iny				iny 								; consume the extra one.
.94d0		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.94d2		d0 1d		bne $94f1			bne 	_SFWExit
.94d4		18		clc				clc
.94d5		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.94d7		65 30		adc $30				adc 	codePtr
.94d9		85 30		sta $30				sta 	codePtr
.94db		90 02		bcc $94df			bcc 	_CREExit
.94dd		e6 31		inc $31				inc 	codePtr+1 					; carry
.94df						_CREExit:
.94df		a0 03		ldy #$03			ldy 	#3 							; scan start position.
.94e1		b2 30		lda ($30)			lda 	(codePtr)
.94e3		d0 0c		bne $94f1			bne 	_SFWExit 					; if not zero, more to scan
.94e5		a9 13		lda #$13		lda	#19
.94e7		4c 4d 95	jmp $954d		jmp	ErrorHandler
.94ea						_ScanSkipData:
.94ea		88		dey				dey 								; point at data token
.94eb		c8		iny				iny 								; point to offset
.94ec		98		tya				tya 								; A = offset position
.94ed		38		sec				sec 								; add size +1 hence SEC
.94ee		71 30		adc ($30),y			adc 	(codePtr),y
.94f0		a8		tay				tay 								; make current position.
.94f1						_SFWExit:
.94f1		60		rts				rts
.94f2						ScanGetCurrentLineStep:
.94f2		64 38		stz $38				stz 	zTemp1
.94f4		a0 03		ldy #$03			ldy 	#3
.94f6						_SGCLSLoop:
.94f6		b1 30		lda ($30),y			lda 	(codePtr),y
.94f8		c8		iny				iny
.94f9		c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.94fb		f0 05		beq $9502			beq 	_SGCLSExit
.94fd		20 af 94	jsr $94af			jsr 	ScanForwardOne
.9500		80 f4		bra $94f6			bra 	_SGCLSLoop
.9502						_SGCLSExit:
.9502		a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.9504		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.9505						Command_WHILE:
.9505		5a		phy				phy 								; save position of the test
.9506		a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.9508		20 04 a4	jsr $a404			jsr 	EvaluateNumber
.950b		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; check if zero
.950e		f0 0e		beq $951e			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.9510		98		tya				tya 								; position *after* test.
.9511		7a		ply				ply 								; restore position before test, at WHILE
.9512		88		dey				dey 								; so we execute the WHILE command again.
.9513		48		pha				pha 								; push after test on the stack
.9514		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.9516		20 cd b6	jsr $b6cd			jsr 	StackOpen
.9519		20 12 b7	jsr $b712			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.951c		7a		ply				ply 								; restore the position *after* the test
.951d		60		rts				rts
.951e						_WHExitLoop:
.951e		68		pla				pla 								; throw post loop position
.951f		a9 b8		lda #$b8			lda 	#KWD_WEND 					; scan forward past WEND
.9521		aa		tax				tax
.9522		20 8f 94	jsr $948f			jsr 	ScanForward
.9525		60		rts				rts
.9526						Command_WEND:
.9526		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.9528		a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.952a		20 fa b6	jsr $b6fa			jsr 	StackCheckFrame
.952d		20 23 b7	jsr $b723			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.9530		20 ec b6	jsr $b6ec			jsr 	StackClose		 			; erase the frame
.9533		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.9534						CheckRightBracket:
.9534		b1 30		lda ($30),y			lda 	(codePtr),y
.9536		c8		iny				iny
.9537		c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.9539		d0 0f		bne $954a			bne 	CNAFail
.953b		60		rts				rts
.953c						CheckComma:
.953c		b1 30		lda ($30),y			lda 	(codePtr),y
.953e		c8		iny				iny
.953f		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.9541		d0 07		bne $954a			bne 	CNAFail
.9543		60		rts				rts
.9544						CheckNextA:
.9544		d1 30		cmp ($30),y			cmp 	(codePtr),y
.9546		d0 02		bne $954a			bne 	CNAFail
.9548		c8		iny				iny 								; skip character
.9549		60		rts				rts 								; and exit
.954a						CNAFail:
.954a		4c 2e a6	jmp $a62e			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.954d						ErrorHandler:
.954d		48		pha				pha 								; save error #
.954e		a8		tay				tay 								; find the error text
.954f		f0 4e		beq $959f			beq 	_EHEnd
.9551		a2 00		ldx #$00			ldx 	#0
.9553		a9 47		lda #$47			lda 	#((ErrorText) & $FF)
.9555		85 36		sta $36				sta 	0+zTemp0
.9557		a9 a6		lda #$a6			lda 	#((ErrorText) >> 8)
.9559		85 37		sta $37				sta 	1+zTemp0
.955b						_EHFind:
.955b		88		dey				dey 								; keep looking through text
.955c		f0 0e		beq $956c			beq 	_EHFound
.955e						_EHFindZero:
.955e		b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.9560		e6 36		inc $36				inc 	zTemp0
.9562		d0 02		bne $9566			bne 	_EHFNoCarry
.9564		e6 37		inc $37				inc 	zTemp0+1
.9566						_EHFNoCarry:
.9566		c9 00		cmp #$00			cmp 	#0
.9568		d0 f4		bne $955e			bne 	_EHFindZero
.956a		80 ef		bra $955b			bra 	_EHFind
.956c						_EHFound:
.956c		a5 36		lda $36				lda 	zTemp0 						; print message
.956e		a6 37		ldx $37				ldx 	zTemp0+1
.9570		20 ac 95	jsr $95ac			jsr 	PrintStringXA
.9573		68		pla				pla  								; check if error is 'open structure'
.9574		c9 13		cmp #$13			cmp 	#ERRID_STRUCT
.9576		f0 22		beq $959a			beq 	_EHCREnd
.9578		a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.957a		b1 30		lda ($30),y			lda 	(codePtr),y
.957c		d0 05		bne $9583			bne 	_EHAtMsg
.957e		c8		iny				iny
.957f		b1 30		lda ($30),y			lda 	(codePtr),y
.9581		f0 17		beq $959a			beq 	_EHCREnd
.9583						_EHAtMsg:
.9583		a2 95		ldx #$95			ldx 	#_AtMsg >> 8 				; print " at "
.9585		a9 a2		lda #$a2			lda 	#_AtMsg & $FF
.9587		20 ac 95	jsr $95ac			jsr 	PrintStringXA
.958a		a0 01		ldy #$01			ldy 	#1 							; line number into XA
.958c		b1 30		lda ($30),y			lda 	(codePtr),y
.958e		48		pha				pha
.958f		c8		iny				iny
.9590		b1 30		lda ($30),y			lda 	(codePtr),y
.9592		aa		tax				tax
.9593		68		pla				pla
.9594		20 c2 99	jsr $99c2			jsr 	ConvertInt16 				; convert XA to string
.9597		20 ac 95	jsr $95ac			jsr 	PrintStringXA 				; and print it.
.959a						_EHCREnd:
.959a		a9 0d		lda #$0d			lda 	#13 						; new line
.959c		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.959f						_EHEnd:
.959f		4c 12 89	jmp $8912			jmp 	WarmStart
>95a2		20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>95aa		20 00
.95ac						PrintStringXA:
.95ac		5a		phy				phy
.95ad		86 37		stx $37				stx 	zTemp0+1
.95af		85 36		sta $36				sta 	zTemp0
.95b1		a0 00		ldy #$00			ldy 	#0
.95b3						_PSXALoop:
.95b3		b1 36		lda ($36),y			lda 	(zTemp0),y
.95b5		f0 06		beq $95bd			beq 	_PSXAExit
.95b7		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.95ba		c8		iny				iny
.95bb		80 f6		bra $95b3			bra 	_PSXALoop
.95bd						_PSXAExit:
.95bd		7a		ply				ply
.95be		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.95bf						UnaryTrue:
.95bf		fa		plx				plx
.95c0						ReturnTrue:
.95c0		a9 01		lda #$01			lda 	#1  						; set to 1
.95c2		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte
.95c5		a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.95c7		95 50		sta $50,x			sta 	NSStatus,x
.95c9		60		rts				rts
.95ca						UnaryFalse:
.95ca		fa		plx				plx
.95cb						ReturnFalse:
.95cb		4c b6 a4	jmp $a4b6			jmp 	NSMSetZero 					; set it all to zero
.95ce						BinaryCompareEqual:
.95ce		fa		plx				plx
.95cf		20 0a 96	jsr $960a			jsr 	CompareBaseCode
.95d2		c9 00		cmp #$00			cmp 	#0
.95d4		f0 ea		beq $95c0			beq 	ReturnTrue
.95d6		80 f3		bra $95cb			bra 	ReturnFalse
.95d8						BinaryCompareLess:
.95d8		fa		plx				plx
.95d9		20 0a 96	jsr $960a			jsr 	CompareBaseCode
.95dc		c9 ff		cmp #$ff			cmp 	#$FF
.95de		f0 e0		beq $95c0			beq 	ReturnTrue
.95e0		80 e9		bra $95cb			bra 	ReturnFalse
.95e2						BinaryCompareGreater:
.95e2		fa		plx				plx
.95e3		20 0a 96	jsr $960a			jsr 	CompareBaseCode
.95e6		c9 01		cmp #$01			cmp 	#1
.95e8		f0 d6		beq $95c0			beq 	ReturnTrue
.95ea		80 df		bra $95cb			bra 	ReturnFalse
.95ec						BinaryCompareNotEqual:
.95ec		fa		plx				plx
.95ed		20 0a 96	jsr $960a			jsr 	CompareBaseCode
.95f0		c9 00		cmp #$00			cmp 	#0
.95f2		d0 cc		bne $95c0			bne 	ReturnTrue
.95f4		80 d5		bra $95cb			bra 	ReturnFalse
.95f6						BinaryCompareLessEqual:
.95f6		fa		plx				plx
.95f7		20 0a 96	jsr $960a			jsr 	CompareBaseCode
.95fa		c9 01		cmp #$01			cmp 	#1
.95fc		d0 c2		bne $95c0			bne 	ReturnTrue
.95fe		80 cb		bra $95cb			bra 	ReturnFalse
.9600						BinaryCompareGreaterEqual:
.9600		fa		plx				plx
.9601		20 0a 96	jsr $960a			jsr 	CompareBaseCode
.9604		c9 ff		cmp #$ff			cmp 	#$FF
.9606		d0 b8		bne $95c0			bne 	ReturnTrue
.9608		80 c1		bra $95cb			bra 	ReturnFalse
.960a						CompareBaseCode:
.960a		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; make both values if references.
.960d		b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.960f		15 51		ora $51,x			ora 	NSStatus+1,x
.9611		29 10		and #$10			and 	#NSTString
.9613		d0 37		bne $964c			bne 	_CBCString 					; if so do string code, which will check if both.
.9615		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check both are integers
.9617		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9619		d0 34		bne $964f			bne 	_CBCFloat
.961b		b5 50		lda $50,x			lda 	NSStatus,x
.961d		15 51		ora $51,x			ora 	NSStatus+1,x
.961f		29 08		and #$08			and 	#NSTFloat
.9621		d0 2c		bne $964f			bne 	_CBCFloat
.9623		20 52 96	jsr $9652			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.9626		e8		inx				inx
.9627		20 52 96	jsr $9652			jsr 	CompareFixMinusZero
.962a		ca		dex				dex
.962b		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.962d		55 51		eor $51,x			eor 	NSStatus+1,x
.962f		10 0a		bpl $963b			bpl 	_CDCSameSign
.9631		b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.9633		30 14		bmi $9649			bmi 	_CBCLess 					; return $FF
.9635						_CBCGreater:
.9635		a9 01		lda #$01			lda 	#1
.9637		60		rts				rts
.9638						_CBCEqual:
.9638		a9 00		lda #$00			lda 	#0
.963a		60		rts				rts
.963b						_CDCSameSign:
.963b		20 67 98	jsr $9867			jsr 	SubTopTwoStack 				; unsigned subtract
.963e		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; or the mantissa together
.9641		f0 f5		beq $9638			beq 	_CBCEqual 					; -0 == 0
.9643		b5 90		lda $90,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.9645		55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.9647		10 ec		bpl $9635			bpl 	_CBCGreater
.9649						_CBCLess:
.9649		a9 ff		lda #$ff			lda 	#$FF
.964b		60		rts				rts
.964c						_CBCString:
.964c		4c d8 97	jmp $97d8			jmp 	CompareStrings
.964f						_CBCFloat:
.964f		4c 2b 9b	jmp $9b2b			jmp 	CompareFloat
.9652						CompareFixMinusZero:
.9652		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero
.9655		d0 02		bne $9659			bne 	_CFXMZNotZero
.9657		74 50		stz $50,x			stz 	NSStatus,x
.9659						_CFXMZNotZero:
.9659		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.965a						StringConcat:
.965a		b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.965c		35 51		and $51,x			and 	NSStatus+1,x
.965e		29 18		and #$18			and 	#NSBTypeMask
.9660		c9 10		cmp #$10			cmp 	#NSTString
.9662		d0 50		bne $96b4			bne		_SCType
.9664		64 38		stz $38				stz 	zTemp1 						; counting total length
.9666		e8		inx				inx
.9667		20 85 96	jsr $9685			jsr 	_SCSetupZ0 					; setup for second
.966a		20 8e 96	jsr $968e			jsr 	_SCLengthZ0 				; length for second
.966d		ca		dex				dex
.966e		20 85 96	jsr $9685			jsr 	_SCSetupZ0 					; setup for first
.9671		20 8e 96	jsr $968e			jsr 	_SCLengthZ0 				; length for first
.9674		a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.9676		20 bd b7	jsr $b7bd			jsr 	StringTempAllocate
.9679		20 a5 96	jsr $96a5			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.967c		e8		inx				inx
.967d		20 85 96	jsr $9685			jsr 	_SCSetupZ0 					; copy second out
.9680		20 a5 96	jsr $96a5			jsr 	_SCCopy
.9683		ca		dex				dex
.9684		60		rts				rts
.9685						_SCSetupZ0:
.9685		b5 60		lda $60,x			lda 	NSMantissa0,x
.9687		85 36		sta $36				sta 	zTemp0
.9689		b5 70		lda $70,x			lda 	NSMantissa1,x
.968b		85 37		sta $37				sta 	zTemp0+1
.968d		60		rts				rts
.968e						_SCLengthZ0:
.968e		5a		phy				phy
.968f		a0 00		ldy #$00			ldy 	#0
.9691						_SCLenLoop:
.9691		b1 36		lda ($36),y			lda 	(zTemp0),y
.9693		f0 0e		beq $96a3			beq 	_SCLExit
.9695		c8		iny				iny
.9696		e6 38		inc $38				inc 	zTemp1
.9698		a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.969a		c9 fd		cmp #$fd			cmp 	#253
.969c		d0 f3		bne $9691			bne		_SCLenLoop
.969e		a9 09		lda #$09		lda	#9
.96a0		4c 4d 95	jmp $954d		jmp	ErrorHandler
.96a3						_SCLExit:
.96a3		7a		ply				ply
.96a4		60		rts				rts
.96a5						_SCCopy:
.96a5		5a		phy				phy
.96a6		a0 00		ldy #$00			ldy 	#0
.96a8						_SCCopyLoop:
.96a8		b1 36		lda ($36),y			lda 	(zTemp0),y
.96aa		f0 06		beq $96b2			beq 	_SCCExit
.96ac		20 f6 b7	jsr $b7f6			jsr 	StringTempWrite
.96af		c8		iny				iny
.96b0		80 f6		bra $96a8			bra 	_SCCopyLoop
.96b2						_SCCExit:
.96b2		7a		ply				ply
.96b3		60		rts				rts
.96b4						_SCType:
.96b4		4c 38 a6	jmp $a638			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.96b7						IntegerDivide:
.96b7		fa		plx				plx
.96b8		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.96ba		15 51		ora $51,x			ora 	NSStatus+1,x
.96bc		0a		asl a				asl 	a 							; shift reference bit into sign bit
.96bd		0a		asl a				asl 	a
.96be		10 05		bpl $96c5			bpl 	_NotRef
.96c0		48		pha				pha
.96c1		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.96c4		68		pla				pla
.96c5						_NotRef:
.96c5		0a		asl a				asl 	a
.96c6		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.96c8		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.96ca		15 a1		ora $a1,x			ora 	NSExponent+1,x
.96cc		f0 03		beq $96d1			beq 	_IntegerCode 				; if clear, then we have two integers
.96ce		4c 38 a6	jmp $a638			jmp 	TypeError 					; anything else, type mismatch.
.96d1						_IntegerCode:
.96d1		20 eb 96	jsr $96eb			jsr 	CheckDivideZero 			; do div zero check
.96d4		20 1d 97	jsr $971d			jsr 	Int32Divide 				; do the division
.96d7		20 ce 97	jsr $97ce			jsr 	CalculateSign 				; calculate result sign
.96da						NSMCopyPlusTwoToZero:
.96da		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.96dc		95 60		sta $60,x			sta 	NSMantissa0,x
.96de		b5 72		lda $72,x			lda 	NSMantissa1+2,x
.96e0		95 70		sta $70,x			sta 	NSMantissa1,x
.96e2		b5 82		lda $82,x			lda 	NSMantissa2+2,x
.96e4		95 80		sta $80,x			sta 	NSMantissa2,x
.96e6		b5 92		lda $92,x			lda 	NSMantissa3+2,x
.96e8		95 90		sta $90,x			sta 	NSMantissa3,x
.96ea		60		rts				rts
.96eb						CheckDivideZero:
.96eb		e8		inx				inx
.96ec		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero
.96ef		f0 02		beq $96f3			beq 	_CDVError
.96f1		ca		dex				dex
.96f2		60		rts				rts
.96f3						_CDVError:
.96f3		a9 03		lda #$03		lda	#3
.96f5		4c 4d 95	jmp $954d		jmp	ErrorHandler
.96f8						IntegerModulus:
.96f8		fa		plx				plx
.96f9		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.96fb		15 51		ora $51,x			ora 	NSStatus+1,x
.96fd		0a		asl a				asl 	a 							; shift reference bit into sign bit
.96fe		0a		asl a				asl 	a
.96ff		10 05		bpl $9706			bpl 	_NotRef
.9701		48		pha				pha
.9702		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9705		68		pla				pla
.9706						_NotRef:
.9706		0a		asl a				asl 	a
.9707		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9709		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.970b		15 a1		ora $a1,x			ora 	NSExponent+1,x
.970d		f0 03		beq $9712			beq 	_IntegerCode 				; if clear, then we have two integers
.970f		4c 38 a6	jmp $a638			jmp 	TypeError 					; anything else, type mismatch.
.9712						_IntegerCode:
.9712						IntegerModulusNoCheck:
.9712		20 eb 96	jsr $96eb			jsr 	CheckDivideZero 			; do div zero check
.9715		20 1d 97	jsr $971d			jsr 	Int32Divide 				; do the division
.9718		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.971a		56 50		lsr $50,x			lsr 	NSStatus,x
.971c		60		rts				rts
.971d						Int32Divide:
.971d		48		pha				pha 								; save AXY
.971e		5a		phy				phy
.971f		20 99 a4	jsr $a499			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9722		20 b2 a4	jsr $a4b2			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.9725		a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.9727						_I32DivideLoop:
.9727		e8		inx				inx
.9728		e8		inx				inx
.9729		20 c5 a4	jsr $a4c5			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.972c		ca		dex				dex
.972d		ca		dex				dex
.972e		20 c6 a4	jsr $a4c6			jsr 	NSMRotateLeft
.9731		20 5c 97	jsr $975c			jsr 	DivideCheckSubtract 		; check if subtract possible
.9734		90 02		bcc $9738			bcc 	_I32DivideNoCarryIn
.9736		f6 62		inc $62,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9738						_I32DivideNoCarryIn:
.9738		88		dey				dey 								; loop round till division completed.
.9739		d0 ec		bne $9727			bne 	_I32DivideLoop
.973b		7a		ply				ply 								; restore AXY and exit
.973c		68		pla				pla
.973d		60		rts				rts
.973e						Int32ShiftDivide:
.973e		48		pha				pha 								; save AY
.973f		5a		phy				phy
.9740		e8		inx				inx 								; clear S[X+2]
.9741		e8		inx				inx
.9742		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero
.9745		ca		dex				dex
.9746		ca		dex				dex
.9747		a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9749						_I32SDLoop:
.9749		20 5c 97	jsr $975c			jsr 	DivideCheckSubtract 		; check if subtract possible
.974c		e8		inx				inx
.974d		e8		inx				inx
.974e		20 c6 a4	jsr $a4c6			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.9751		ca		dex				dex
.9752		ca		dex				dex
.9753		20 c6 a4	jsr $a4c6			jsr 	NSMRotateLeft
.9756		88		dey				dey 	 							; do 31 times
.9757		d0 f0		bne $9749			bne 	_I32SDLoop
.9759		7a		ply				ply 								; restore AY and exit
.975a		68		pla				pla
.975b		60		rts				rts
.975c						DivideCheckSubtract:
.975c		20 67 98	jsr $9867			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.975f		b0 04		bcs $9765			bcs 	_DCSExit 					; if carry set, then could do, exit
.9761		20 4d 98	jsr $984d			jsr 	AddTopTwoStack 				; add it back in
.9764		18		clc				clc 								; and return False
.9765						_DCSExit:
.9765		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9766						MulInteger:
.9766		fa		plx				plx
.9767		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9769		15 51		ora $51,x			ora 	NSStatus+1,x
.976b		0a		asl a				asl 	a 							; shift reference bit into sign bit
.976c		0a		asl a				asl 	a
.976d		10 05		bpl $9774			bpl 	_NotRef
.976f		48		pha				pha
.9770		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9773		68		pla				pla
.9774						_NotRef:
.9774		0a		asl a				asl 	a 							; put MSB of type into A:7
.9775		30 09		bmi $9780			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9777		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9779		15 a1		ora $a1,x			ora 	NSExponent+1,x
.977b		f0 06		beq $9783			beq 	_IntegerCode 				; if clear, then we have two integers
.977d		4c ed 9b	jmp $9bed			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9780						_StringData:
.9780		4c 42 a6	jmp $a642			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9783						_IntegerCode:
.9783		20 90 97	jsr $9790			jsr 	MultiplyShort
.9786		c9 00		cmp #$00			cmp 	#0
.9788		f0 05		beq $978f			beq 	_MIExit
.978a		a9 04		lda #$04		lda	#4
.978c		4c 4d 95	jmp $954d		jmp	ErrorHandler
.978f						_MIExit:
.978f		60		rts				rts
.9790						MultiplyShort:
.9790		5a		phy				phy 								; save Y
.9791		20 99 a4	jsr $a499			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9794		20 b2 a4	jsr $a4b2			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9797		a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9799						_I32MLoop:
.9799		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.979b		15 72		ora $72,x			ora 	NSMantissa1+2,x
.979d		15 82		ora $82,x			ora 	NSMantissa2+2,x
.979f		15 92		ora $92,x			ora 	NSMantissa3+2,x
.97a1		f0 25		beq $97c8			beq 	_I32MExit 					; exit if zero
.97a3		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.97a5		29 01		and #$01			and 	#1
.97a7		f0 0d		beq $97b6			beq 	_I32MNoAdd
.97a9		20 4d 98	jsr $984d			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.97ac		b5 90		lda $90,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.97ae		10 06		bpl $97b6			bpl 	_I32MNoAdd
.97b0						_I32ShiftRight:
.97b0		20 cf a4	jsr $a4cf			jsr 	NSMShiftRight 				; shift S[X] right
.97b3		c8		iny				iny 								; increment shift count
.97b4		80 09		bra $97bf			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.97b6						_I32MNoAdd:
.97b6		34 91		bit $91,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.97b8		70 f6		bvs $97b0			bvs 	_I32ShiftRight 				; instead.
.97ba		e8		inx				inx
.97bb		20 c5 a4	jsr $a4c5			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.97be		ca		dex				dex
.97bf						_I32MShiftUpper:
.97bf		e8		inx				inx 								; shift S[X+2] right
.97c0		e8		inx				inx
.97c1		20 cf a4	jsr $a4cf			jsr 	NSMShiftRight
.97c4		ca		dex				dex
.97c5		ca		dex				dex
.97c6		80 d1		bra $9799			bra 	_I32MLoop 					; try again.
.97c8						_I32MExit:
.97c8		20 ce 97	jsr $97ce			jsr 	CalculateSign
.97cb		98		tya				tya 								; shift in A
.97cc		7a		ply				ply 								; restore Y and exit
.97cd		60		rts				rts
.97ce						CalculateSign:
.97ce		b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.97d0		16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.97d2		55 51		eor $51,x			eor 	NSStatus+1,x
.97d4		0a		asl a				asl 	a 							; shift bit 7 into carry
.97d5		76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.97d7		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.97d8						CompareStrings:
.97d8		b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.97da		35 51		and $51,x			and 	NSStatus+1,x
.97dc		29 10		and #$10			and 	#NSBIsString
.97de		f0 28		beq $9808			beq 	_CSTypeError
.97e0		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.97e2		85 36		sta $36				sta 	zTemp0
.97e4		b5 70		lda $70,x			lda 	NSMantissa1,x
.97e6		85 37		sta $37				sta 	zTemp0+1
.97e8		b5 61		lda $61,x			lda 	NSMantissa0+1,x
.97ea		85 38		sta $38				sta 	zTemp1
.97ec		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.97ee		85 39		sta $39				sta 	zTemp1+1
.97f0		5a		phy				phy 								; save Y so we can access strings
.97f1		a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.97f3						_CSLoop:
.97f3		c8		iny				iny
.97f4		b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.97f6		d1 38		cmp ($38),y			cmp 	(zTemp1),y
.97f8		d0 06		bne $9800			bne 	_CSDifferent
.97fa		c9 00		cmp #$00			cmp 	#0 							; reached end ?
.97fc		d0 f5		bne $97f3			bne 	_CSLoop 					; still comparing
.97fe						_CSExit:
.97fe		7a		ply				ply 								; reached end, return zero in A from EOS
.97ff		60		rts				rts
.9800						_CSDifferent:
.9800		a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.9802		90 fa		bcc $97fe			bcc		_CSExit
.9804		a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9806		80 f6		bra $97fe			bra 	_CSExit
.9808						_CSTypeError:
.9808		4c 38 a6	jmp $a638			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.980b						ShiftLeft:
.980b		38		sec				sec 								; common code, carry determines which way.
.980c		80 01		bra $980f			bra 	ShiftMain
.980e						ShiftRight:
.980e		18		clc				clc
.980f						ShiftMain:
.980f		fa		plx				plx 								; restore X
.9810		08		php				php 								; save direction
.9811		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9813		15 51		ora $51,x			ora 	NSStatus+1,x
.9815		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9816		0a		asl a				asl 	a
.9817		10 05		bpl $981e			bpl 	_NotRef
.9819		48		pha				pha
.981a		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.981d		68		pla				pla
.981e						_NotRef:
.981e		0a		asl a				asl 	a
.981f		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9821		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9823		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9825		f0 03		beq $982a			beq 	_IntegerCode 				; if clear, then we have two integers
.9827		4c 38 a6	jmp $a638			jmp 	TypeError 					; anything else, type mismatch.
.982a						_IntegerCode:
.982a		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; check number < 32
.982c		29 e0		and #$e0			and 	#$E0
.982e		15 71		ora $71,x			ora 	NSMantissa1+1,x
.9830		15 81		ora $81,x			ora 	NSMantissa2+1,x
.9832		15 91		ora $91,x			ora 	NSMantissa3+1,x
.9834		d0 12		bne $9848			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9836						_SMLoop:
.9836		d6 61		dec $61,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9838		30 11		bmi $984b			bmi 	_SMExit 					; exit if done.
.983a		28		plp				plp 								; restore direction setting
.983b		08		php				php
.983c		90 05		bcc $9843			bcc 	_SMRight
.983e		20 c5 a4	jsr $a4c5			jsr 	NSMShiftLeft 				; shift left if CS
.9841		80 f3		bra $9836			bra 	_SMLoop
.9843						_SMRight:
.9843		20 cf a4	jsr $a4cf			jsr 	NSMShiftRight 				; shift right if CC
.9846		80 ee		bra $9836			bra 	_SMLoop
.9848						_SMExit0:
.9848		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero 					; return zero.
.984b						_SMExit:
.984b		28		plp				plp 								; throw direction
.984c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.984d						AddTopTwoStack:
.984d		18		clc				clc
.984e		b5 60		lda $60,x			lda		NSMantissa0,x
.9850		75 61		adc $61,x			adc 		NSMantissa0+1,x
.9852		95 60		sta $60,x			sta 	NSMantissa0,x
.9854		b5 70		lda $70,x			lda		NSMantissa1,x
.9856		75 71		adc $71,x			adc 		NSMantissa1+1,x
.9858		95 70		sta $70,x			sta 	NSMantissa1,x
.985a		b5 80		lda $80,x			lda		NSMantissa2,x
.985c		75 81		adc $81,x			adc 		NSMantissa2+1,x
.985e		95 80		sta $80,x			sta 	NSMantissa2,x
.9860		b5 90		lda $90,x			lda		NSMantissa3,x
.9862		75 91		adc $91,x			adc 		NSMantissa3+1,x
.9864		95 90		sta $90,x			sta 	NSMantissa3,x
.9866		60		rts				rts
.9867						SubTopTwoStack:
.9867		38		sec				sec
.9868		b5 60		lda $60,x			lda		NSMantissa0,x
.986a		f5 61		sbc $61,x			sbc 		NSMantissa0+1,x
.986c		95 60		sta $60,x			sta 	NSMantissa0,x
.986e		b5 70		lda $70,x			lda		NSMantissa1,x
.9870		f5 71		sbc $71,x			sbc 		NSMantissa1+1,x
.9872		95 70		sta $70,x			sta 	NSMantissa1,x
.9874		b5 80		lda $80,x			lda		NSMantissa2,x
.9876		f5 81		sbc $81,x			sbc 		NSMantissa2+1,x
.9878		95 80		sta $80,x			sta 	NSMantissa2,x
.987a		b5 90		lda $90,x			lda		NSMantissa3,x
.987c		f5 91		sbc $91,x			sbc 		NSMantissa3+1,x
.987e		95 90		sta $90,x			sta 	NSMantissa3,x
.9880		60		rts				rts
.9881						AddInteger:
.9881		fa		plx				plx
.9882		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9884		15 51		ora $51,x			ora 	NSStatus+1,x
.9886		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9887		0a		asl a				asl 	a
.9888		10 05		bpl $988f			bpl 	_NotRef
.988a		48		pha				pha
.988b		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.988e		68		pla				pla
.988f						_NotRef:
.988f		0a		asl a				asl 	a 							; put MSB of type into A:7
.9890		30 09		bmi $989b			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9892		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9894		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9896		f0 06		beq $989e			beq 	_IntegerCode 				; if clear, then we have two integers
.9898		4c 9d 9a	jmp $9a9d			jmp 	FloatingPointAdd 							; otherwise at least one float.
.989b						_StringData:
.989b		4c 5a 96	jmp $965a			jmp 	StringConcat							; at least one string - don't know both are strings.
.989e						_IntegerCode:
.989e						AddCode:
.989e		b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.98a0		55 51		eor $51,x			eor 	NSStatus+1,x
.98a2		10 a9		bpl $984d			bpl 	AddTopTwoStack
.98a4		20 67 98	jsr $9867			jsr 	SubTopTwoStack 				; do a physical subtraction
.98a7		34 90		bit $90,x			bit 	NSMantissa3,x 				; result is +ve, okay
.98a9		10 07		bpl $98b2			bpl 	_AddExit
.98ab		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.98ad		95 50		sta $50,x			sta 	NSStatus,x
.98af		20 7f a4	jsr $a47f			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.98b2						_AddExit:
.98b2		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; check for -0
.98b5		d0 02		bne $98b9			bne 	_AddNonZero
.98b7		74 50		stz $50,x			stz 	NSStatus,x
.98b9						_AddNonZero:
.98b9		60		rts				rts
.98ba						SubInteger:
.98ba		fa		plx				plx
.98bb		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.98bd		15 51		ora $51,x			ora 	NSStatus+1,x
.98bf		0a		asl a				asl 	a 							; shift reference bit into sign bit
.98c0		0a		asl a				asl 	a
.98c1		10 05		bpl $98c8			bpl 	_NotRef
.98c3		48		pha				pha
.98c4		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.98c7		68		pla				pla
.98c8						_NotRef:
.98c8		0a		asl a				asl 	a 							; put MSB of type into A:7
.98c9		30 09		bmi $98d4			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.98cb		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.98cd		15 a1		ora $a1,x			ora 	NSExponent+1,x
.98cf		f0 06		beq $98d7			beq 	_IntegerCode 				; if clear, then we have two integers
.98d1		4c a2 9a	jmp $9aa2			jmp 	FloatingPointSub 							; otherwise at least one float.
.98d4						_StringData:
.98d4		4c 42 a6	jmp $a642			jmp 	NotDoneError							; at least one string - don't know both are strings.
.98d7						_IntegerCode:
.98d7		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.98d9		49 80		eor #$80			eor 	#$80
.98db		95 51		sta $51,x			sta 	NSStatus+1,x
.98dd		80 bf		bra $989e			bra 	AddCode 					; and do the same code as add.
.98df						AndInteger:
.98df		fa		plx				plx
.98e0		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.98e2		15 51		ora $51,x			ora 	NSStatus+1,x
.98e4		0a		asl a				asl 	a 							; shift reference bit into sign bit
.98e5		0a		asl a				asl 	a
.98e6		10 05		bpl $98ed			bpl 	_NotRef
.98e8		48		pha				pha
.98e9		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.98ec		68		pla				pla
.98ed						_NotRef:
.98ed		0a		asl a				asl 	a
.98ee		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.98f0		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.98f2		15 a1		ora $a1,x			ora 	NSExponent+1,x
.98f4		f0 03		beq $98f9			beq 	_IntegerCode 				; if clear, then we have two integers
.98f6		4c 38 a6	jmp $a638			jmp 	TypeError 					; anything else, type mismatch.
.98f9						_IntegerCode:
.98f9		b5 60		lda $60,x			lda		NSMantissa0,x
.98fb		35 61		and $61,x			and 		NSMantissa0+1,x
.98fd		95 60		sta $60,x			sta 	NSMantissa0,x
.98ff		b5 70		lda $70,x			lda		NSMantissa1,x
.9901		35 71		and $71,x			and 		NSMantissa1+1,x
.9903		95 70		sta $70,x			sta 	NSMantissa1,x
.9905		b5 80		lda $80,x			lda		NSMantissa2,x
.9907		35 81		and $81,x			and 		NSMantissa2+1,x
.9909		95 80		sta $80,x			sta 	NSMantissa2,x
.990b		b5 90		lda $90,x			lda		NSMantissa3,x
.990d		35 91		and $91,x			and 		NSMantissa3+1,x
.990f		95 90		sta $90,x			sta 	NSMantissa3,x
.9911		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9913		60		rts				rts
.9914						OraInteger:
.9914		fa		plx				plx
.9915		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9917		15 51		ora $51,x			ora 	NSStatus+1,x
.9919		0a		asl a				asl 	a 							; shift reference bit into sign bit
.991a		0a		asl a				asl 	a
.991b		10 05		bpl $9922			bpl 	_NotRef
.991d		48		pha				pha
.991e		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9921		68		pla				pla
.9922						_NotRef:
.9922		0a		asl a				asl 	a
.9923		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9925		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9927		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9929		f0 03		beq $992e			beq 	_IntegerCode 				; if clear, then we have two integers
.992b		4c 38 a6	jmp $a638			jmp 	TypeError 					; anything else, type mismatch.
.992e						_IntegerCode:
.992e		b5 60		lda $60,x			lda		NSMantissa0,x
.9930		15 61		ora $61,x			ora 		NSMantissa0+1,x
.9932		95 60		sta $60,x			sta 	NSMantissa0,x
.9934		b5 70		lda $70,x			lda		NSMantissa1,x
.9936		15 71		ora $71,x			ora 		NSMantissa1+1,x
.9938		95 70		sta $70,x			sta 	NSMantissa1,x
.993a		b5 80		lda $80,x			lda		NSMantissa2,x
.993c		15 81		ora $81,x			ora 		NSMantissa2+1,x
.993e		95 80		sta $80,x			sta 	NSMantissa2,x
.9940		b5 90		lda $90,x			lda		NSMantissa3,x
.9942		15 91		ora $91,x			ora 		NSMantissa3+1,x
.9944		95 90		sta $90,x			sta 	NSMantissa3,x
.9946		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9948		60		rts				rts
.9949						EorInteger:
.9949		fa		plx				plx
.994a		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.994c		15 51		ora $51,x			ora 	NSStatus+1,x
.994e		0a		asl a				asl 	a 							; shift reference bit into sign bit
.994f		0a		asl a				asl 	a
.9950		10 05		bpl $9957			bpl 	_NotRef
.9952		48		pha				pha
.9953		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9956		68		pla				pla
.9957						_NotRef:
.9957		0a		asl a				asl 	a
.9958		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.995a		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.995c		15 a1		ora $a1,x			ora 	NSExponent+1,x
.995e		f0 03		beq $9963			beq 	_IntegerCode 				; if clear, then we have two integers
.9960		4c 38 a6	jmp $a638			jmp 	TypeError 					; anything else, type mismatch.
.9963						_IntegerCode:
.9963		b5 60		lda $60,x			lda		NSMantissa0,x
.9965		55 61		eor $61,x			eor 		NSMantissa0+1,x
.9967		95 60		sta $60,x			sta 	NSMantissa0,x
.9969		b5 70		lda $70,x			lda		NSMantissa1,x
.996b		55 71		eor $71,x			eor 		NSMantissa1+1,x
.996d		95 70		sta $70,x			sta 	NSMantissa1,x
.996f		b5 80		lda $80,x			lda		NSMantissa2,x
.9971		55 81		eor $81,x			eor 		NSMantissa2+1,x
.9973		95 80		sta $80,x			sta 	NSMantissa2,x
.9975		b5 90		lda $90,x			lda		NSMantissa3,x
.9977		55 91		eor $91,x			eor 		NSMantissa3+1,x
.9979		95 90		sta $90,x			sta 	NSMantissa3,x
.997b		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.997d		60		rts				rts
.997e						WordIndirect:
.997e		fa		plx				plx
.997f		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9981		15 51		ora $51,x			ora 	NSStatus+1,x
.9983		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9984		0a		asl a				asl 	a
.9985		10 05		bpl $998c			bpl 	_NotRef
.9987		48		pha				pha
.9988		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.998b		68		pla				pla
.998c						_NotRef:
.998c		0a		asl a				asl 	a
.998d		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.998f		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9991		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9993		f0 03		beq $9998			beq 	_IntegerCode 				; if clear, then we have two integers
.9995		4c 38 a6	jmp $a638			jmp 	TypeError 					; anything else, type mismatch.
.9998						_IntegerCode:
.9998		20 9e 98	jsr $989e			jsr 	AddCode 					; add the two values
.999b		a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.999d		95 50		sta $50,x			sta 	NSStatus,x
.999f		60		rts				rts
.99a0						ByteIndirect:
.99a0		fa		plx				plx
.99a1		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.99a3		15 51		ora $51,x			ora 	NSStatus+1,x
.99a5		0a		asl a				asl 	a 							; shift reference bit into sign bit
.99a6		0a		asl a				asl 	a
.99a7		10 05		bpl $99ae			bpl 	_NotRef
.99a9		48		pha				pha
.99aa		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.99ad		68		pla				pla
.99ae						_NotRef:
.99ae		0a		asl a				asl 	a
.99af		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.99b1		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.99b3		15 a1		ora $a1,x			ora 	NSExponent+1,x
.99b5		f0 03		beq $99ba			beq 	_IntegerCode 				; if clear, then we have two integers
.99b7		4c 38 a6	jmp $a638			jmp 	TypeError 					; anything else, type mismatch.
.99ba						_IntegerCode:
.99ba		20 9e 98	jsr $989e			jsr 	AddCode 					; add the two values
.99bd		a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.99bf		95 50		sta $50,x			sta 	NSStatus,x
.99c1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.99c2						ConvertInt16:
.99c2		85 60		sta $60				sta 	NSMantissa0 				; set up as 32 bit conversion
.99c4		86 70		stx $70				stx 	NSMantissa1
.99c6		64 80		stz $80				stz 	NSMantissa2
.99c8		64 90		stz $90				stz 	NSMantissa3
.99ca		64 50		stz $50				stz 	NSStatus 					; positive integer
.99cc		a2 00		ldx #$00			ldx 	#0 							; stack level
.99ce		a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.99d0		80 00		bra $99d2			bra 	ConvertInt32
.99d2						ConvertInt32:
.99d2		5a		phy				phy
.99d3		a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.99d5		24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.99d7		10 08		bpl $99e1			bpl 	_CI32NotNeg
.99d9		48		pha				pha
.99da		a9 2d		lda #$2d			lda 	#'-'
.99dc		99 43 06	sta $0643,y			sta 	numberBuffer,y
.99df		c8		iny				iny
.99e0		68		pla				pla
.99e1						_CI32NotNeg:
.99e1		20 ef 99	jsr $99ef			jsr 	_CI32DivideConvert 			; recursive conversion
.99e4		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.99e6		99 43 06	sta $0643,y			sta 	numberBuffer,y
.99e9		7a		ply				ply
.99ea		a2 06		ldx #$06			ldx 	#numberBuffer >> 8 			; return address in XA
.99ec		a9 43		lda #$43			lda 	#numberBuffer & $FF
.99ee		60		rts				rts
.99ef						_CI32DivideConvert:
.99ef		e8		inx				inx 								; write to next slot up
.99f0		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte 		 			; write the base out.
.99f3		ca		dex				dex
.99f4		20 1d 97	jsr $971d			jsr 	Int32Divide 				; divide
.99f7		b5 60		lda $60,x			lda 	NSMantissa0,x 				; save remainder
.99f9		48		pha				pha
.99fa		20 da 96	jsr $96da			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.99fd		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; is it zero ?
.9a00		f0 05		beq $9a07			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9a02		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9a04		20 ef 99	jsr $99ef			jsr 	_CI32DivideConvert 			; and recusrively call.
.9a07						_CI32NoRecurse:
.9a07		68		pla				pla 								; remainder
.9a08		c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.9a0a		90 02		bcc $9a0e			bcc 	_CI32NotHex
.9a0c		69 26		adc #$26			adc 	#6+32
.9a0e						_CI32NotHex:
.9a0e		69 30		adc #$30			adc 	#48
.9a10		99 43 06	sta $0643,y			sta 	numberBuffer,y 				; write out and exit
.9a13		c8		iny				iny
.9a14		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9a15						PrecedenceLevel:
>9a15		04					.byte	 4	; $00 <<
>9a16		02					.byte	 2	; $01 <=
>9a17		02					.byte	 2	; $02 <>
>9a18		00					.byte	 0	; $03 !!3
>9a19		00					.byte	 0	; $04 ><
>9a1a		02					.byte	 2	; $05 >=
>9a1b		04					.byte	 4	; $06 >>
>9a1c		00					.byte	 0	; $07 !!7
>9a1d		00					.byte	 0	; $08 !!8
>9a1e		00					.byte	 0	; $09 !!9
>9a1f		00					.byte	 0	; $0a !!10
>9a20		00					.byte	 0	; $0b !!11
>9a21		00					.byte	 0	; $0c !!12
>9a22		00					.byte	 0	; $0d !!13
>9a23		00					.byte	 0	; $0e !!14
>9a24		00					.byte	 0	; $0f !!15
>9a25		00					.byte	 0	; $10 @
>9a26		00					.byte	 0	; $11 !!17
>9a27		00					.byte	 0	; $12 !!18
>9a28		00					.byte	 0	; $13 [
>9a29		04					.byte	 4	; $14 \
>9a2a		00					.byte	 0	; $15 ]
>9a2b		01					.byte	 1	; $16 ^
>9a2c		00					.byte	 0	; $17 _
>9a2d		00					.byte	 0	; $18 `
>9a2e		00					.byte	 0	; $19 !!25
>9a2f		00					.byte	 0	; $1a !!26
>9a30		00					.byte	 0	; $1b {
>9a31		01					.byte	 1	; $1c |
>9a32		00					.byte	 0	; $1d }
>9a33		00					.byte	 0	; $1e ~
>9a34		00					.byte	 0	; $1f <7F>
>9a35		00					.byte	 0	; $20
>9a36		05					.byte	 5	; $21 !
>9a37		00					.byte	 0	; $22 "
>9a38		00					.byte	 0	; $23 #
>9a39		05					.byte	 5	; $24 $
>9a3a		04					.byte	 4	; $25 %
>9a3b		01					.byte	 1	; $26 &
>9a3c		00					.byte	 0	; $27 '
>9a3d		00					.byte	 0	; $28 (
>9a3e		00					.byte	 0	; $29 )
>9a3f		04					.byte	 4	; $2a *
>9a40		03					.byte	 3	; $2b +
>9a41		00					.byte	 0	; $2c ,
>9a42		03					.byte	 3	; $2d -
>9a43		00					.byte	 0	; $2e .
>9a44		04					.byte	 4	; $2f /
>9a45		00					.byte	 0	; $30 0
>9a46		00					.byte	 0	; $31 1
>9a47		00					.byte	 0	; $32 2
>9a48		00					.byte	 0	; $33 3
>9a49		00					.byte	 0	; $34 4
>9a4a		00					.byte	 0	; $35 5
>9a4b		00					.byte	 0	; $36 6
>9a4c		00					.byte	 0	; $37 7
>9a4d		00					.byte	 0	; $38 8
>9a4e		00					.byte	 0	; $39 9
>9a4f		00					.byte	 0	; $3a :
>9a50		00					.byte	 0	; $3b ;
>9a51		02					.byte	 2	; $3c <
>9a52		02					.byte	 2	; $3d =
>9a53		02					.byte	 2	; $3e >
>9a54		05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9a55						EvaluateExpressionAt0:
.9a55		a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9a57						EvaluateExpression:
.9a57		a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9a59						EvaluateExpressionAtPrecedence:
.9a59		48		pha				pha 								; save precedence level
.9a5a		20 aa 9e	jsr $9eaa			jsr 	EvaluateTerm 				; evaluate term into level X.
.9a5d		68		pla				pla 								; restore precedence level.
.9a5e						_EXPRLoop:
.9a5e		85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9a60		b1 30		lda ($30),y			lda 	(codePtr),y
.9a62		c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9a64		b0 25		bcs $9a8b			bcs 	_EXPRExit
.9a66		da		phx				phx 								; read the operator precedence
.9a67		aa		tax				tax
.9a68		bd 15 9a	lda $9a15,x			lda 	PrecedenceLevel,x
.9a6b		fa		plx				plx
.9a6c		c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9a6e		f0 1b		beq $9a8b			beq 	_EXPRExit
.9a70		85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9a72		a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9a74		c5 37		cmp $37				cmp 	zTemp0+1
.9a76		b0 13		bcs $9a8b			bcs		_EXPRExit 					; if current >= operator exit
.9a78		48		pha				pha 								; save current precedence.
.9a79		b1 30		lda ($30),y			lda 	(codePtr),y
.9a7b		c8		iny				iny
.9a7c		48		pha				pha
.9a7d		a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9a7f		e8		inx				inx 								; work out the right hand side.
.9a80		20 59 9a	jsr $9a59			jsr 	EvaluateExpressionAtPrecedence
.9a83		ca		dex				dex
.9a84		68		pla				pla 								; get operator, call the code.
.9a85		20 8e 9a	jsr $9a8e			jsr 	_EXPRCaller
.9a88		68		pla				pla 								; restore precedence level
.9a89		80 d3		bra $9a5e			bra 	_EXPRLoop 					; and go round.
.9a8b						_EXPRExit:
.9a8b		a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9a8d		60		rts				rts
.9a8e						_EXPRCaller:
.9a8e		e0 10		cpx #$10			cpx		#MathStackSize
.9a90		b0 06		bcs $9a98			bge		_EXPRTooComplex
.9a92		da		phx				phx 								; save on stack, first thing is to restore it
.9a93		0a		asl a				asl 	a 							; double so can use vectors into X
.9a94		aa		tax				tax
.9a95		7c b8 91	jmp ($91b8,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.
.9a98						_EXPRTooComplex:
.9a98		a9 1e		lda #$1e		lda	#30
.9a9a		4c 4d 95	jmp $954d		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9a9d						FloatingPointAdd:
.9a9d		20 13 9c	jsr $9c13			jsr 	FloatPrepare 				; prepare for floats
.9aa0		80 09		bra $9aab			bra 	FloatAdd
.9aa2						FloatingPointSub:
.9aa2		20 13 9c	jsr $9c13			jsr 	FloatPrepare 				; prepare for floats
.9aa5						FloatSubtract:
.9aa5		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9aa7		49 80		eor #$80			eor 	#$80
.9aa9		95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9aab						FloatAdd:
.9aab		48		pha				pha
.9aac		5a		phy				phy
.9aad		20 22 9c	jsr $9c22			jsr 	NSNormalise 				; normalise S[X]
.9ab0		f0 51		beq $9b03			beq 	_FAReturn1
.9ab2		e8		inx				inx 								; normalise S[X+1]
.9ab3		20 22 9c	jsr $9c22			jsr 	NSNormalise
.9ab6		ca		dex				dex
.9ab7		c9 00		cmp #$00			cmp 	#0
.9ab9		f0 60		beq $9b1b			beq 	_FAExit 					; if so, just return A
.9abb		b5 a0		lda $a0,x			lda 	NSExponent,x 				; are the exponents the same ?
.9abd		d5 a1		cmp $a1,x			cmp 	NSExponent+1,x
.9abf		f0 18		beq $9ad9			beq 	_FAExponentsEqual
.9ac1		b5 a0		lda $a0,x			lda 	NSExponent,x 				; work out the larger exponent
.9ac3		a8		tay				tay
.9ac4		38		sec				sec 								; do a signed comparison of the exponents.
.9ac5		f5 a1		sbc $a1,x			sbc 	NSExponent+1,x
.9ac7		50 02		bvc $9acb			bvc 	_FANoSignedChange
.9ac9		49 80		eor #$80			eor 	#$80
.9acb						_FANoSignedChange:
.9acb		29 80		and #$80			and 	#$80
.9acd		10 02		bpl $9ad1			bpl 	_FAHaveMax
.9acf		b4 a1		ldy $a1,x			ldy 	NSExponent+1,x
.9ad1						_FAHaveMax:
.9ad1		20 1e 9b	jsr $9b1e			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9ad4		e8		inx				inx
.9ad5		20 1e 9b	jsr $9b1e			jsr 	_FAShiftToExponent
.9ad8		ca		dex				dex
.9ad9						_FAExponentsEqual:
.9ad9		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9adb		55 51		eor $51,x			eor 	NSStatus+1,x
.9add		30 0e		bmi $9aed			bmi 	_FADifferentSigns
.9adf		20 4d 98	jsr $984d			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9ae2		b5 90		lda $90,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9ae4		10 35		bpl $9b1b			bpl 	_FAExit 					; if no, we are done.
.9ae6		20 cf a4	jsr $a4cf			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9ae9		f6 a0		inc $a0,x			inc 	NSExponent,x 				; bump the exponent and exit
.9aeb		80 2e		bra $9b1b			bra 	_FAExit
.9aed						_FADifferentSigns:
.9aed		20 67 98	jsr $9867			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9af0		b5 90		lda $90,x			lda 	NSMantissa3,x 				; is the result negative ?
.9af2		10 06		bpl $9afa			bpl 	_FACheckZero 				; if no, check for -0
.9af4		20 78 a4	jsr $a478			jsr 	NSMNegate 					; netate result
.9af7		20 7f a4	jsr $a47f			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9afa						_FACheckZero:
.9afa		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero	 				; check for -0
.9afd		d0 1c		bne $9b1b			bne 	_FAExit
.9aff		74 50		stz $50,x			stz 	NSStatus,x
.9b01		80 18		bra $9b1b			bra 	_FAExit
.9b03						_FAReturn1:
.9b03		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.9b05		95 60		sta $60,x			sta 	NSMantissa0,x
.9b07		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.9b09		95 70		sta $70,x			sta 	NSMantissa1,x
.9b0b		b5 81		lda $81,x			lda 	NSMantissa2+1,x
.9b0d		95 80		sta $80,x			sta 	NSMantissa2,x
.9b0f		b5 91		lda $91,x			lda 	NSMantissa3+1,x
.9b11		95 90		sta $90,x			sta 	NSMantissa3,x
.9b13		b5 a1		lda $a1,x			lda 	NSExponent+1,x
.9b15		95 a0		sta $a0,x			sta 	NSExponent,x
.9b17		b5 51		lda $51,x			lda 	NSStatus+1,x
.9b19		95 50		sta $50,x			sta 	NSStatus,x
.9b1b						_FAExit:
.9b1b		7a		ply				ply
.9b1c		68		pla				pla
.9b1d		60		rts				rts
.9b1e						_FAShiftToExponent:
.9b1e						_FAShiftToExponent2:
.9b1e		98		tya				tya 								; compare Y to exponent
.9b1f		d5 a0		cmp $a0,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9b21		f0 07		beq $9b2a			beq 	_FASEExit 					; exit if so.
.9b23		20 cf a4	jsr $a4cf			jsr 	NSMShiftRight	 			; shift the mantissa right
.9b26		f6 a0		inc $a0,x			inc 	NSExponent,x 				; increment exponent
.9b28		80 f4		bra $9b1e			bra 	_FAShiftToExponent2
.9b2a						_FASEExit:
.9b2a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9b2b						CompareFloat:
.9b2b		20 a5 9a	jsr $9aa5			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9b2e		b5 70		lda $70,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9b30		29 f8		and #$f8			and 	#$F8
.9b32		15 80		ora $80,x			ora 	NSMantissa2,x
.9b34		15 90		ora $90,x			ora 	NSMantissa3,x
.9b36		f0 08		beq $9b40			beq 	_FCExit 					; zero, so approximately identical
.9b38		a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9b3a		34 50		bit $50,x			bit 	NSStatus,x
.9b3c		10 02		bpl $9b40			bpl 	_FCExit
.9b3e						_FCNegative:
.9b3e		a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9b40						_FCExit:
.9b40		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9b41						FDivideCommand:
.9b41		fa		plx				plx	 								; restore stack position
.9b42		20 13 9c	jsr $9c13			jsr 	FloatPrepare 				; prepare for floats
.9b45						FloatDivide:
.9b45		48		pha				pha
.9b46		e8		inx				inx
.9b47		20 22 9c	jsr $9c22			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9b4a		ca		dex				dex
.9b4b		c9 00		cmp #$00			cmp 	#0
.9b4d		f0 1d		beq $9b6c			beq 	_FDZero
.9b4f		20 22 9c	jsr $9c22			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9b52		f0 16		beq $9b6a			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9b54		20 3e 97	jsr $973e			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.9b57		20 da 96	jsr $96da			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9b5a		20 22 9c	jsr $9c22			jsr		NSNormalise 				; renormalise
.9b5d		20 ce 97	jsr $97ce			jsr 	CalculateSign 				; calculate result sign
.9b60		b5 a0		lda $a0,x			lda 	NSExponent,x 				; calculate exponent
.9b62		38		sec				sec
.9b63		f5 a1		sbc $a1,x			sbc 	NSExponent+1,x
.9b65		38		sec				sec
.9b66		e9 1e		sbc #$1e			sbc 	#30
.9b68		95 a0		sta $a0,x			sta 	NSExponent,x
.9b6a						_FDExit:
.9b6a		68		pla				pla
.9b6b		60		rts				rts
.9b6c						_FDZero:
.9b6c		a9 03		lda #$03		lda	#3
.9b6e		4c 4d 95	jmp $954d		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9b71						FloatFractionalPart:
.9b71		5a		phy				phy
.9b72		b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9b74		29 7f		and #$7f			and 	#$7F
.9b76		95 50		sta $50,x			sta 	NSStatus,x
.9b78		20 22 9c	jsr $9c22			jsr 	NSNormalise
.9b7b		b5 a0		lda $a0,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9b7d		38		sec				sec
.9b7e		e9 e0		sbc #$e0			sbc 	#$E0
.9b80		90 29		bcc $9bab			bcc 	_FFPExit 					; already fractional
.9b82		c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9b84		b0 22		bcs $9ba8			bcs 	_FFPZero
.9b86		a8		tay				tay 								; put count to do in Y
.9b87		b5 90		lda $90,x			lda 	NSMantissa3,x 				; do each in turn.
.9b89		20 ad 9b	jsr $9bad			jsr 	_FFPPartial
.9b8c		95 90		sta $90,x			sta 	NSMantissa3,x
.9b8e		b5 80		lda $80,x			lda 	NSMantissa2,x
.9b90		20 ad 9b	jsr $9bad			jsr 	_FFPPartial
.9b93		95 80		sta $80,x			sta 	NSMantissa2,x
.9b95		b5 70		lda $70,x			lda 	NSMantissa1,x
.9b97		20 ad 9b	jsr $9bad			jsr 	_FFPPartial
.9b9a		95 70		sta $70,x			sta 	NSMantissa1,x
.9b9c		b5 60		lda $60,x			lda 	NSMantissa0,x
.9b9e		20 ad 9b	jsr $9bad			jsr 	_FFPPartial
.9ba1		95 60		sta $60,x			sta 	NSMantissa0,x
.9ba3		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; zeroed check.
.9ba6		d0 03		bne $9bab			bne 	_FFPExit
.9ba8						_FFPZero:
.9ba8		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero
.9bab						_FFPExit:
.9bab		7a		ply				ply
.9bac		60		rts				rts
.9bad						_FFPPartial:
.9bad		c0 00		cpy #$00			cpy 	#0 							; no more to do
.9baf		f0 17		beq $9bc8			beq 	_FFFPPExit
.9bb1		c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9bb3		b0 0c		bcs $9bc1			bcs 	_FFFPPWholeByte
.9bb5		5a		phy				phy
.9bb6						_FFFPPLeft:
.9bb6		0a		asl a				asl 	a
.9bb7		88		dey				dey
.9bb8		d0 fc		bne $9bb6			bne 	_FFFPPLeft
.9bba		7a		ply				ply
.9bbb						_FFFPPRight:
.9bbb		4a		lsr a				lsr 	a
.9bbc		88		dey				dey
.9bbd		d0 fc		bne $9bbb			bne 	_FFFPPRight
.9bbf		80 07		bra $9bc8			bra 	_FFFPPExit
.9bc1						_FFFPPWholeByte:
.9bc1		98		tya				tya 								; subtract 8 from count
.9bc2		38		sec				sec
.9bc3		e9 08		sbc #$08			sbc 	#8
.9bc5		a8		tay				tay
.9bc6		a9 00		lda #$00			lda 	#0 							; and clear all
.9bc8						_FFFPPExit:
.9bc8		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9bc9						FloatIntegerPart:
.9bc9		48		pha				pha
.9bca		b5 a0		lda $a0,x			lda 	NSExponent,x 				; is it integer already ?
.9bcc		f0 1d		beq $9beb			beq 	_FIPExit 					; if so do nothing
.9bce		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; is it zero ?
.9bd1		f0 15		beq $9be8			beq 	_FIPZero 					; if so return zero.
.9bd3		20 22 9c	jsr $9c22			jsr 	NSNormalise 				; normalise
.9bd6		f0 10		beq $9be8			beq 	_FIPZero 					; normalised to zero, exit zero
.9bd8						_FIPShift:
.9bd8		b5 a0		lda $a0,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9bda		10 07		bpl $9be3			bpl 	_FIPCheckZero
.9bdc		20 cf a4	jsr $a4cf			jsr 	NSMShiftRight 				; shift mantissa right
.9bdf		f6 a0		inc $a0,x			inc 	NSExponent,x 				; bump exponent
.9be1		80 f5		bra $9bd8			bra 	_FIPShift
.9be3						_FIPCheckZero:
.9be3		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; avoid -0 problem
.9be6		d0 03		bne $9beb			bne 	_FIPExit 					; set to zero if mantissa zero.
.9be8						_FIPZero:
.9be8		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero
.9beb						_FIPExit:
.9beb		68		pla				pla
.9bec		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9bed						FloatingPointMultiply:
.9bed		20 13 9c	jsr $9c13			jsr 	FloatPrepare 				; prepare for floats
.9bf0						FloatMultiply:
.9bf0		48		pha				pha
.9bf1		20 22 9c	jsr $9c22			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9bf4		f0 18		beq $9c0e			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.9bf6		e8		inx				inx
.9bf7		20 22 9c	jsr $9c22			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9bfa		ca		dex				dex
.9bfb		c9 00		cmp #$00			cmp 	#0
.9bfd		f0 0c		beq $9c0b			beq 	_FDSetZero
.9bff		20 90 97	jsr $9790			jsr 	MultiplyShort 				; calculate the result.
.9c02		75 a0		adc $a0,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9c04		18		clc				clc
.9c05		75 a1		adc $a1,x			adc 	NSExponent+1,x
.9c07		95 a0		sta $a0,x			sta 	NSExponent,x
.9c09		80 03		bra $9c0e			bra 	_FDExit
.9c0b						_FDSetZero:
.9c0b		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero 					; return 0
.9c0e						_FDExit:
.9c0e		20 22 9c	jsr $9c22			jsr 	NSNormalise 				; normalise the result
.9c11		68		pla				pla
.9c12		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9c13						FloatPrepare:
.9c13		20 1e 9d	jsr $9d1e			jsr 	DereferenceTopTwo 			; dereference the top two values
.9c16		b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.9c18		15 51		ora $51,x			ora 	NSStatus+1,x
.9c1a		29 10		and #$10			and 	#NSBIsString
.9c1c		d0 01		bne $9c1f			bne 	_FDType
.9c1e		60		rts				rts
.9c1f						_FDType:
.9c1f		4c 38 a6	jmp $a638			jmp 	TypeError
.9c22						NSNormalise:
.9c22		b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.9c24		29 80		and #$80			and 	#$80
.9c26		09 08		ora #$08			ora 	#NSTFloat
.9c28		95 50		sta $50,x			sta 	NSStatus,x
.9c2a		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; if zero exit
.9c2d		d0 07		bne $9c36			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.9c2f		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9c31		76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.9c33		a9 00		lda #$00			lda 	#0 							; set Z flag
.9c35		60		rts				rts
.9c36						_NSNormaliseOptimise:
.9c36		b5 90		lda $90,x			lda 	NSMantissa3,x 				; upper byte zero ?
.9c38		d0 19		bne $9c53			bne 	_NSNormaliseLoop
.9c3a		b5 80		lda $80,x			lda 	NSMantissa2,x 				; byte normalise
.9c3c		30 15		bmi $9c53			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9c3e		95 90		sta $90,x			sta 	NSMantissa3,x
.9c40		b5 70		lda $70,x			lda 	NSMantissa1,x
.9c42		95 80		sta $80,x			sta 	NSMantissa2,x
.9c44		b5 60		lda $60,x			lda 	NSMantissa0,x
.9c46		95 70		sta $70,x			sta 	NSMantissa1,x
.9c48		74 60		stz $60,x			stz 	NSMantissa0,x
.9c4a		b5 a0		lda $a0,x			lda 	NSExponent,x
.9c4c		38		sec				sec
.9c4d		e9 08		sbc #$08			sbc 	#8
.9c4f		95 a0		sta $a0,x			sta 	NSExponent,x
.9c51		80 e3		bra $9c36			bra 	_NSNormaliseOptimise
.9c53						_NSNormaliseLoop:
.9c53		34 90		bit $90,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9c55		70 07		bvs $9c5e			bvs 	_NSNExit 					; exit if so with Z flag clear
.9c57		20 c5 a4	jsr $a4c5			jsr 	NSMShiftLeft 				; shift mantissa left
.9c5a		d6 a0		dec $a0,x			dec 	NSExponent,x 				; adjust exponent
.9c5c		80 f5		bra $9c53			bra 	_NSNormaliseLoop
.9c5e						_NSNExit:
.9c5e		a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9c60		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9c61						AssignNumber:
.9c61		5a		phy				phy
.9c62		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9c64		85 36		sta $36				sta 	zTemp0
.9c66		b5 70		lda $70,x			lda 	NSMantissa1,x
.9c68		85 37		sta $37				sta 	zTemp0+1
.9c6a		b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9c6c		29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9c6e		95 50		sta $50,x			sta 	NSStatus,x
.9c70		29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9c72		c9 08		cmp #$08			cmp 	#NSTFloat
.9c74		f0 24		beq $9c9a			beq 	_ANFloat
.9c76		b5 a1		lda $a1,x			lda		NSExponent+1,x 				; is it a float
.9c78		f0 03		beq $9c7d			beq		_ANNotFloat
.9c7a		4c 33 a6	jmp $a633			jmp 	RangeError					; if it is, report an error.
.9c7d						_ANNotFloat:
.9c7d		b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.9c7f		29 03		and #$03			and 	#3
.9c81		d0 05		bne $9c88			bne 	_ANByteWord
.9c83		20 a5 9c	jsr $9ca5			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9c86		80 1b		bra $9ca3			bra 	_ANExit
.9c88						_ANByteWord:
.9c88		48		pha				pha 								; save count
.9c89		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; do byte
.9c8b		92 36		sta ($36)			sta 	(zTemp0)
.9c8d		68		pla				pla
.9c8e		c9 01		cmp #$01			cmp	 	#1
.9c90		f0 11		beq $9ca3			beq 	_ANExit
.9c92		b5 71		lda $71,x			lda 	NSMantissa1+1,x 			; do word
.9c94		a0 01		ldy #$01			ldy 	#1
.9c96		91 36		sta ($36),y			sta 	(zTemp0),y
.9c98		80 09		bra $9ca3			bra 	_ANExit
.9c9a						_ANFloat:
.9c9a		20 a5 9c	jsr $9ca5			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9c9d		b5 a1		lda $a1,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9c9f		a0 04		ldy #$04			ldy 	#4
.9ca1		91 36		sta ($36),y			sta 	(zTemp0),y
.9ca3						_ANExit:
.9ca3		7a		ply				ply
.9ca4		60		rts				rts
.9ca5						_ANCopy4PackSign:
.9ca5		a0 03		ldy #$03			ldy 	#3
.9ca7		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.9ca9		29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9cab		15 91		ora $91,x			ora 	NSMantissa3+1,x
.9cad		91 36		sta ($36),y			sta 	(zTemp0),y
.9caf		88		dey				dey
.9cb0		b5 81		lda $81,x			lda 	NSMantissa2+1,x
.9cb2		91 36		sta ($36),y			sta 	(zTemp0),y
.9cb4		88		dey				dey
.9cb5		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.9cb7		91 36		sta ($36),y			sta 	(zTemp0),y
.9cb9		88		dey				dey
.9cba		b5 61		lda $61,x			lda 	NSMantissa0+1,x
.9cbc		91 36		sta ($36),y			sta 	(zTemp0),y
.9cbe		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9cbf						AssignString:
.9cbf		5a		phy				phy
.9cc0		b5 61		lda $61,x			lda 	NSMantissa0+1,x
.9cc2		85 38		sta $38				sta 	zTemp1
.9cc4		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.9cc6		85 39		sta $39				sta 	zTemp1+1
.9cc8		b5 60		lda $60,x			lda 	NSMantissa0,x
.9cca		85 36		sta $36				sta 	zTemp0
.9ccc		b5 70		lda $70,x			lda 	NSMantissa1,x
.9cce		85 37		sta $37				sta 	zTemp0+1
.9cd0		a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9cd2		b1 36		lda ($36),y			lda 	(zTemp0),y
.9cd4		f0 23		beq $9cf9			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9cd6		38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9cd7		b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9cd9		e9 02		sbc #$02			sbc 	#2
.9cdb		85 3c		sta $3c				sta 	zsTemp
.9cdd		a0 01		ldy #$01			ldy 	#1
.9cdf		b1 36		lda ($36),y			lda 	(zTemp0),y
.9ce1		e9 00		sbc #$00			sbc 	#0
.9ce3		85 3d		sta $3d				sta 	zsTemp+1
.9ce5		a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9ce7						_ASGetLength:
.9ce7		c8		iny				iny
.9ce8		b1 38		lda ($38),y			lda 	(zTemp1),y
.9cea		d0 fb		bne $9ce7			bne 	_ASGetLength
.9cec		98		tya				tya 								; is this length <= current length
.9ced		d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9cef		90 1e		bcc $9d0f			bcc 	_ASCopyString
.9cf1		f0 1c		beq $9d0f			beq 	_ASCopyString
.9cf3		a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9cf5		a0 01		ldy #$01			ldy 	#1
.9cf7		91 3c		sta ($3c),y			sta 	(zsTemp),y
.9cf9						_ASNewStringRequired:
.9cf9		e8		inx				inx 								; concrete the new string.
.9cfa		20 40 b7	jsr $b740			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9cfd		ca		dex				dex
.9cfe		18		clc				clc
.9cff		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9d01		69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9d03		92 36		sta ($36)			sta 	(zTemp0)
.9d05		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.9d07		69 00		adc #$00			adc 	#0
.9d09		a0 01		ldy #$01			ldy 	#1
.9d0b		91 36		sta ($36),y			sta 	(zTemp0),y
.9d0d		80 0d		bra $9d1c			bra 	_ASExit
.9d0f						_ASCopyString:
.9d0f		a0 00		ldy #$00			ldy 	#0
.9d11						_ASCopyLoop:
.9d11		b1 38		lda ($38),y			lda 	(zTemp1),y
.9d13		c8		iny				iny
.9d14		c8		iny				iny
.9d15		91 3c		sta ($3c),y			sta 	(zsTemp),y
.9d17		88		dey				dey
.9d18		c9 00		cmp #$00			cmp 	#0
.9d1a		d0 f5		bne $9d11			bne 	_ASCopyLoop
.9d1c						_ASExit:
.9d1c		7a		ply				ply
.9d1d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9d1e						DereferenceTopTwo:
.9d1e		e8		inx				inx
.9d1f		20 23 9d	jsr $9d23			jsr 	Dereference 				; deref x+1
.9d22		ca		dex				dex  								; falls through to deref x
.9d23						Dereference:
.9d23		b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.9d25		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.9d27		f0 48		beq $9d71			beq 	_DRFExit 					; not a reference, so exit.
.9d29		5a		phy				phy
.9d2a		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9d2c		85 36		sta $36				sta 	zTemp0
.9d2e		b5 70		lda $70,x			lda 	NSMantissa1,x
.9d30		85 37		sta $37				sta 	zTemp0+1
.9d32		74 70		stz $70,x			stz 	NSMantissa1,x 				; clear second byte.
.9d34		b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.9d36		95 60		sta $60,x			sta 	NSMantissa0,x
.9d38		b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.9d3a		29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9d3c		c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9d3e		f0 0e		beq $9d4e			beq 	_DRFDereferenceTwo
.9d40		c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9d42		f0 2f		beq $9d73			beq 	_DRFFull
.9d44		b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9d46		29 03		and #$03			and 	#3
.9d48		f0 29		beq $9d73			beq 	_DRFFull 					; the whole word
.9d4a		c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9d4c		f0 06		beq $9d54			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9d4e						_DRFDereferenceTwo:
.9d4e		a0 01		ldy #$01			ldy 	#1
.9d50		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d52		95 70		sta $70,x			sta 	NSMantissa1,x
.9d54						_DRFClear23:
.9d54		74 80		stz $80,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9d56		74 90		stz $90,x			stz 	NSMantissa3,x
.9d58		b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.9d5a		29 18		and #$18			and 	#NSBTypeMask
.9d5c		95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9d5e		c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9d60		d0 0e		bne $9d70			bne 	_DRFNotString
.9d62		b5 60		lda $60,x			lda 	NSMantissa0,x 				; check address is zero
.9d64		15 70		ora $70,x			ora 	NSMantissa1,x
.9d66		d0 08		bne $9d70			bne 	_DRFNotString
.9d68		a9 72		lda #$72			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9d6a		95 60		sta $60,x			sta 	NSMantissa0,x
.9d6c		a9 9d		lda #$9d			lda 	#_DRFNullString >> 8
.9d6e		95 70		sta $70,x			sta 	NSMantissa1,x
.9d70						_DRFNotString
.9d70		7a		ply				ply 								; restore Y and exit
.9d71						_DRFExit:
.9d71		60		rts				rts
.9d72						_DRFNullString:
>9d72		00						.byte 	0
.9d73						_DRFFull:
.9d73		a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9d75		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d77		95 70		sta $70,x			sta 	NSMantissa1,x
.9d79		c8		iny				iny
.9d7a		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d7c		95 80		sta $80,x			sta 	NSMantissa2,x
.9d7e		c8		iny				iny
.9d7f		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d81		95 90		sta $90,x			sta 	NSMantissa3,x
.9d83		74 a0		stz $a0,x			stz 	NSExponent,x 				; clear exponent.
.9d85		b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.9d87		29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9d89		95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.9d8b		f0 05		beq $9d92			beq 	_DRFNoExponent
.9d8d		c8		iny				iny 								; if not, read the exponent as well.
.9d8e		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d90		95 a0		sta $a0,x			sta 	NSExponent,x
.9d92						_DRFNoExponent:
.9d92		b5 90		lda $90,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9d94		10 0a		bpl $9da0			bpl 	_DRFExit2 					; if not, then exit.
.9d96		29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9d98		95 90		sta $90,x			sta 	NSMantissa3,x
.9d9a		b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9d9c		09 80		ora #$80			ora 	#NSBIsNegative
.9d9e		95 50		sta $50,x			sta 	NSStatus,x
.9da0						_DRFExit2:
.9da0		7a		ply				ply
.9da1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1						ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2						ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3						ESTA_Decimal = 3 							; fractional part.
.9da2						EncodeNumberStart:
.9da2		38		sec				sec
.9da3		80 01		bra $9da6			bra 	EncodeNumberContinue+1
.9da5						EncodeNumberContinue:
.9da5		18		clc				clc
.9da6						EncodeNumber:
.9da6		08		php				php 								; save reset flag.
.9da7		c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9da9		f0 12		beq $9dbd			beq 	_ENIsOkay
.9dab		c9 30		cmp #$30			cmp 	#"0"
.9dad		90 04		bcc $9db3			bcc 	_ENBadNumber
.9daf		c9 3a		cmp #$3a			cmp 	#"9"+1
.9db1		90 0a		bcc $9dbd			bcc 	_ENIsOkay
.9db3						_ENBadNumber:
.9db3		28		plp				plp 								; throw saved reset
.9db4		ad 25 04	lda $0425			lda 	encodeState 				; if in decimal mode, construct final number
.9db7		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9db9		f0 7b		beq $9e36			beq 	_ENConstructFinal
.9dbb						_ENFail:
.9dbb		18		clc				clc 								; not allowed
.9dbc		60		rts				rts
.9dbd						_ENIsOkay:
.9dbd		28		plp				plp 								; are we restarting
.9dbe		90 15		bcc $9dd5			bcc 	_ENNoRestart
.9dc0						_ENStartEncode:
.9dc0		c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.9dc2		f0 0c		beq $9dd0			beq 	_ENFirstDP
.9dc4		29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.9dc6		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte 					; in single byte mode.
.9dc9		a9 01		lda #$01			lda 	#ESTA_Low
.9dcb						_ENExitChange:
.9dcb		8d 25 04	sta $0425			sta 	encodeState 				; save new state
.9dce		38		sec				sec
.9dcf		60		rts				rts
.9dd0						_ENFirstDP:
.9dd0		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero 					; clear integer part
.9dd3		80 3c		bra $9e11			bra 	_ESTASwitchFloat			; go straight to float and exi
.9dd5						_ENNoRestart:
.9dd5		48		pha				pha 								; save digit or DP on stack.
.9dd6		ad 25 04	lda $0425			lda 	encodeState 				; get current state
.9dd9		c9 01		cmp #$01			cmp 	#ESTA_Low
.9ddb		f0 09		beq $9de6			beq  	_ESTALowState
.9ddd		c9 02		cmp #$02			cmp 	#ESTA_High
.9ddf		f0 26		beq $9e07			beq 	_ESTAHighState
.9de1		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9de3		f0 38		beq $9e1d			beq 	_ESTADecimalState
>9de5		db						.byte 	$DB 						; causes a break in the emulator
.9de6						_ESTALowState:
.9de6		68		pla				pla 								; get value back
.9de7		c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9de9		f0 26		beq $9e11			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9deb		29 0f		and #$0f			and 	#15 						; make digit
.9ded		8d 26 04	sta $0426			sta 	digitTemp 					; save it.
.9df0		b5 60		lda $60,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9df2		0a		asl a				asl 	a
.9df3		0a		asl a				asl 	a
.9df4		75 60		adc $60,x			adc 	NSMantissa0,x
.9df6		0a		asl a				asl 	a
.9df7		6d 26 04	adc $0426			adc 	digitTemp
.9dfa		95 60		sta $60,x			sta 	NSMantissa0,x
.9dfc		c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.9dfe		90 05		bcc $9e05			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.9e00		a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.9e02		8d 25 04	sta $0425			sta 	encodeState
.9e05						_ESTANoSwitch:
.9e05		38		sec				sec
.9e06		60		rts				rts
.9e07						_ESTAHighState:
.9e07		68		pla				pla 								; get value back
.9e08		c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.9e0a		f0 05		beq $9e11			beq 	_ESTASwitchFloat
.9e0c		20 6a 9e	jsr $9e6a			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9e0f		38		sec				sec
.9e10		60		rts				rts
.9e11						_ESTASwitchFloat:
.9e11		9c 27 04	stz $0427			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.9e14		e8		inx				inx 								; zero the decimal additive.
.9e15		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero
.9e18		ca		dex				dex
.9e19		a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9e1b		80 ae		bra $9dcb			bra 	_ENExitChange
.9e1d						_ESTADecimalState:
.9e1d		68		pla				pla 								; digit.
.9e1e		c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9e20		f0 99		beq $9dbb			beq 	_ENFail
.9e22		e8		inx				inx 								; put digit into fractional part of X+1
.9e23		20 6a 9e	jsr $9e6a			jsr 	ESTAShiftDigitIntoMantissa
.9e26		ca		dex				dex
.9e27		ee 27 04	inc $0427			inc 	decimalCount 				; bump the count of decimals
.9e2a		ad 27 04	lda $0427			lda 	decimalCount 				; too many decimal digits.
.9e2d		c9 0b		cmp #$0b			cmp 	#11
.9e2f		f0 02		beq $9e33			beq 	_ESTADSFail
.9e31		38		sec				sec
.9e32		60		rts				rts
.9e33						_ESTADSFail:
.9e33		4c 33 a6	jmp $a633			jmp 	RangeError
.9e36						_ENConstructFinal:
.9e36		ad 27 04	lda $0427			lda 	decimalCount 				; get decimal count
.9e39		f0 2d		beq $9e68			beq 	_ENCFExit 					; no decimals
.9e3b		5a		phy				phy
.9e3c		0a		asl a				asl 	a 							; x 4 and CLC
.9e3d		0a		asl a				asl 	a
.9e3e		6d 27 04	adc $0427			adc 	decimalCount
.9e41		a8		tay				tay
.9e42		b9 f2 a5	lda $a5f2,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9e45		95 62		sta $62,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.9e47		b9 f3 a5	lda $a5f3,y			lda 	DecimalScalarTable-5+1,y
.9e4a		95 72		sta $72,x			sta 	NSMantissa1+2,x
.9e4c		b9 f4 a5	lda $a5f4,y			lda 	DecimalScalarTable-5+2,y
.9e4f		95 82		sta $82,x			sta 	NSMantissa2+2,x
.9e51		b9 f5 a5	lda $a5f5,y			lda 	DecimalScalarTable-5+3,y
.9e54		95 92		sta $92,x			sta 	NSMantissa3+2,x
.9e56		b9 f6 a5	lda $a5f6,y			lda 	DecimalScalarTable-5+4,y
.9e59		95 a2		sta $a2,x			sta 	NSExponent+2,x
.9e5b		a9 08		lda #$08			lda 	#NSTFloat
.9e5d		95 52		sta $52,x			sta 	NSStatus+2,x
.9e5f		7a		ply				ply
.9e60		e8		inx				inx 								; multiply decimal const by decimal scalar
.9e61		20 f0 9b	jsr $9bf0			jsr 	FloatMultiply
.9e64		ca		dex				dex
.9e65		20 ab 9a	jsr $9aab			jsr 	FloatAdd 					; add to integer part.
.9e68						_ENCFExit:
.9e68		18		clc				clc 								; reject the digit.
.9e69		60		rts				rts
.9e6a						ESTAShiftDigitIntoMantissa:
.9e6a		29 0f		and #$0f			and 	#15 						; save digit
.9e6c		48		pha				pha
.9e6d		b5 90		lda $90,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9e6f		48		pha				pha
.9e70		b5 80		lda $80,x			lda 	NSMantissa2,x
.9e72		48		pha				pha
.9e73		b5 70		lda $70,x			lda 	NSMantissa1,x
.9e75		48		pha				pha
.9e76		b5 60		lda $60,x			lda 	NSMantissa0,x
.9e78		48		pha				pha
.9e79		20 c5 a4	jsr $a4c5			jsr 	NSMShiftLeft 				; x 2
.9e7c		20 c5 a4	jsr $a4c5			jsr 	NSMShiftLeft 				; x 4
.9e7f		18		clc				clc 								; pop mantissa and add
.9e80		68		pla				pla
.9e81		75 60		adc $60,x			adc 	NSMantissa0,x
.9e83		95 60		sta $60,x			sta 	NSMantissa0,x
.9e85		68		pla				pla
.9e86		75 70		adc $70,x			adc 	NSMantissa1,x
.9e88		95 70		sta $70,x			sta 	NSMantissa1,x
.9e8a		68		pla				pla
.9e8b		75 80		adc $80,x			adc 	NSMantissa2,x
.9e8d		95 80		sta $80,x			sta 	NSMantissa2,x
.9e8f		68		pla				pla
.9e90		75 90		adc $90,x			adc 	NSMantissa3,x
.9e92		95 90		sta $90,x			sta 	NSMantissa3,x 				; x 5
.9e94		20 c5 a4	jsr $a4c5			jsr 	NSMShiftLeft 				; x 10
.9e97		68		pla				pla 								; add digit
.9e98		18		clc				clc
.9e99		75 60		adc $60,x			adc 	NSMantissa0,x
.9e9b		95 60		sta $60,x			sta 	NSMantissa0,x
.9e9d		90 0a		bcc $9ea9			bcc 	_ESTASDExit
.9e9f		f6 70		inc $70,x			inc 	NSMantissa1,x
.9ea1		d0 06		bne $9ea9			bne 	_ESTASDExit
.9ea3		f6 80		inc $80,x			inc 	NSMantissa2,x
.9ea5		d0 02		bne $9ea9			bne 	_ESTASDExit
.9ea7		f6 90		inc $90,x			inc 	NSMantissa3,x
.9ea9						_ESTASDExit:
.9ea9		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9eaa						EvaluateTerm:
.9eaa		b1 30		lda ($30),y			lda 	(codePtr),y
.9eac		30 18		bmi $9ec6			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9eae		c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9eb0		b0 6c		bcs $9f1e			bcs 	_ETVariable
.9eb2		c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9eb4		90 6b		bcc $9f21			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9eb6		c9 3a		cmp #$3a			cmp 	#'9'+1
.9eb8		b0 67		bcs $9f21			bcs 	_ETPuncUnary
.9eba		20 a2 9d	jsr $9da2			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9ebd						_ETNumber:
.9ebd		c8		iny				iny 								; keep encoding until we have the numbers
.9ebe		b1 30		lda ($30),y			lda 	(codePtr),y
.9ec0		20 a5 9d	jsr $9da5			jsr 	EncodeNumberContinue
.9ec3		b0 f8		bcs $9ebd			bcs 	_ETNumber 					; go back if accepted.
.9ec5		60		rts				rts
.9ec6						_ETCheckUnary:
.9ec6		c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9ec8		f0 3f		beq $9f09			beq 	_ETString
.9eca		c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9ecc		f0 12		beq $9ee0			beq 	_ETHexConstant
.9ece		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9ed0		90 0b		bcc $9edd			bcc 	_ETSyntaxError
.9ed2		c9 ae		cmp #$ae			cmp 	#KWC_LAST_UNARY+1
.9ed4		b0 07		bcs $9edd			bcs 	_ETSyntaxError
.9ed6		da		phx				phx 								; push X on the stack
.9ed7		0a		asl a				asl 	a 							; put vector x 2 into X
.9ed8		aa		tax				tax
.9ed9		c8		iny				iny 								; consume unary function token
.9eda		7c 38 92	jmp ($9238,x)			jmp 	(VectorSet0,x) 				; and do it.
.9edd						_ETSyntaxError:
.9edd		4c 2e a6	jmp $a62e			jmp 	SyntaxError
.9ee0						_ETHexConstant:
.9ee0		c8		iny				iny 								; skip #
.9ee1		c8		iny				iny 								; skip count
.9ee2		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero 					; clear result
.9ee5						_ETHLoop:
.9ee5		b1 30		lda ($30),y			lda 	(codePtr),y
.9ee7		c8		iny				iny 								; and consume
.9ee8		c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9eea		f0 1c		beq $9f08			beq 	_ETHExit
.9eec		48		pha				pha 								; save on stack.
.9eed		20 c5 a4	jsr $a4c5			jsr 	NSMShiftLeft 				; x 2
.9ef0		20 c5 a4	jsr $a4c5			jsr 	NSMShiftLeft 				; x 4
.9ef3		20 c5 a4	jsr $a4c5			jsr 	NSMShiftLeft 				; x 8
.9ef6		20 c5 a4	jsr $a4c5			jsr 	NSMShiftLeft 				; x 16
.9ef9		68		pla				pla 								; ASCII
.9efa		c9 41		cmp #$41			cmp 	#'A'
.9efc		90 02		bcc $9f00			bcc 	_ETHNotChar
.9efe		e9 07		sbc #$07			sbc 	#7
.9f00						_ETHNotChar:
.9f00		29 0f		and #$0f			and 	#15 						; digit now
.9f02		15 60		ora $60,x			ora 	NSMantissa0,x 				; put in LS Nibble
.9f04		95 60		sta $60,x			sta 	NSMantissa0,x
.9f06		80 dd		bra $9ee5			bra 	_ETHLoop 					; go round.
.9f08						_ETHExit:
.9f08		60		rts				rts
.9f09						_ETString:
.9f09		c8		iny				iny 								; look at length
.9f0a		b1 30		lda ($30),y			lda 	(codePtr),y
.9f0c		48		pha				pha
.9f0d		c8		iny				iny 								; first character
.9f0e		20 04 a9	jsr $a904			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9f11		68		pla				pla 								; restore count and save
.9f12		85 36		sta $36				sta 	zTemp0
.9f14		98		tya				tya 								; add length to Y to skip it.
.9f15		18		clc				clc
.9f16		65 36		adc $36				adc 	zTemp0
.9f18		a8		tay				tay
.9f19		a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9f1b		95 50		sta $50,x			sta 	NSStatus,x
.9f1d		60		rts				rts
.9f1e						_ETVariable:
.9f1e		4c 73 9f	jmp $9f73			jmp 	VariableHandler
.9f21						_ETPuncUnary:
.9f21		c8		iny				iny 								; consume the unary character
.9f22		c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9f24		f0 2b		beq $9f51			beq 	_ETUnaryNegate
.9f26		c9 10		cmp #$10			cmp 	#KWD_ATCH 					; @ reference -> constant
.9f28		f0 36		beq $9f60			beq 	_ETDereference
.9f2a		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9f2c		f0 3e		beq $9f6c			beq 	_ETParenthesis
.9f2e		64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9f30		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9f32		f0 06		beq $9f3a			beq 	_ETIndirection
.9f34		e6 36		inc $36				inc 	zTemp0
.9f36		c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9f38		d0 a3		bne $9edd			bne 	_ETSyntaxError
.9f3a						_ETIndirection:
.9f3a		a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9f3c		1a		inc a				inc 	a
.9f3d		48		pha				pha
.9f3e		20 aa 9e	jsr $9eaa			jsr 	EvaluateTerm				; evaluate the term
.9f41		20 23 9d	jsr $9d23			jsr 	Dereference 				; dereference it.
.9f44		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.9f46		d0 06		bne $9f4e			bne 	_ETTypeMismatch
.9f48		68		pla				pla 								; indirection 1-2
.9f49		09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9f4b		95 50		sta $50,x			sta 	NSStatus,x
.9f4d		60		rts				rts
.9f4e						_ETTypeMismatch:
.9f4e		4c 38 a6	jmp $a638			jmp 	TypeError
.9f51						_ETUnaryNegate:
.9f51		20 aa 9e	jsr $9eaa			jsr 	EvaluateTerm				; evaluate the term
.9f54		20 23 9d	jsr $9d23			jsr 	Dereference 				; dereference it.
.9f57		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.9f59		29 10		and #$10			and 	#NSTString
.9f5b		d0 f1		bne $9f4e			bne 	_ETTypeMismatch
.9f5d		4c 78 a4	jmp $a478			jmp 	NSMNegate  					; just toggles the sign bit.
.9f60						_ETDereference:
.9f60		20 aa 9e	jsr $9eaa			jsr 	EvaluateTerm				; evaluate the term
.9f63		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9f65		29 20		and #$20			and 	#NSBIsReference
.9f67		f0 e5		beq $9f4e			beq 	_ETTypeMismatch
.9f69		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9f6b		60		rts				rts
.9f6c						_ETParenthesis:
.9f6c		20 57 9a	jsr $9a57			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9f6f		20 34 95	jsr $9534			jsr 	CheckRightBracket 			; check for )
.9f72		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9f73						VariableHandler:
.9f73		b1 30		lda ($30),y			lda 	(codePtr),y
.9f75		18		clc				clc
.9f76		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9f78		85 37		sta $37				sta 	zTemp0+1
.9f7a		c8		iny				iny
.9f7b		b1 30		lda ($30),y			lda 	(codePtr),y
.9f7d		85 36		sta $36				sta 	zTemp0
.9f7f		c8		iny				iny
.9f80		18		clc				clc									; copy variable address+3 to mantissa
.9f81		69 03		adc #$03			adc 	#3 							; this is the address of the data.
.9f83		95 60		sta $60,x			sta 	NSMantissa0,x
.9f85		a5 37		lda $37				lda 	zTemp0+1
.9f87		69 00		adc #$00			adc 	#0
.9f89		95 70		sta $70,x			sta 	NSMantissa1,x
.9f8b		74 80		stz $80,x			stz 	NSMantissa2,x
.9f8d		74 90		stz $90,x			stz 	NSMantissa3,x
.9f8f		74 a0		stz $a0,x			stz 	NSExponent,x
.9f91		5a		phy				phy
.9f92		a0 02		ldy #$02			ldy 	#2 							; read type
.9f94		b1 36		lda ($36),y			lda 	(zTemp0),y
.9f96		7a		ply				ply
.9f97		29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9f99		09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9f9b		95 50		sta $50,x			sta 	NSStatus,x
.9f9d		29 04		and #$04			and 	#NSBIsArray
.9f9f		d0 01		bne $9fa2			bne 	_VHArray
.9fa1		60		rts				rts
.9fa2						_VHArray:
.9fa2		e8		inx				inx
.9fa3		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9fa6		a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9fa8		95 51		sta $51,x			sta 	NSStatus+1,x
.9faa		b1 30		lda ($30),y			lda 	(codePtr),y
.9fac		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9fae		d0 06		bne $9fb6			bne 	_VHNoSecondIndex
.9fb0		c8		iny				iny 								; skip the comma
.9fb1		e8		inx				inx
.9fb2		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9fb5		ca		dex				dex
.9fb6						_VHNoSecondIndex:
.9fb6		ca		dex				dex 								; set X back.
.9fb7		20 34 95	jsr $9534			jsr 	CheckRightBracket 			; and check the right bracket.
.9fba		5a		phy				phy 								; save position
.9fbb		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy record address to zaTemp (moved 6/12/22)
.9fbd		85 3e		sta $3e				sta 	zaTemp
.9fbf		b5 70		lda $70,x			lda 	NSMantissa1,x
.9fc1		85 3f		sta $3f				sta 	zaTemp+1
.9fc3		a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9fc5		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fc7		f0 5d		beq $a026			beq 	_VHBadArray
.9fc9		a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9fcb		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fcd		f0 02		beq $9fd1			beq 	_VHHas2Mask
.9fcf		a9 ff		lda #$ff			lda 	#$FF
.9fd1						_VHHas2Mask:
.9fd1		d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9fd3		f0 4c		beq $a021			beq 	_VHBadIndex
.9fd5		0a		asl a				asl 	a 							; carry will be set if a second index
.9fd6		90 08		bcc $9fe0			bcc 	_VHCheckFirstIndex
.9fd8		a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9fda		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fdc		d5 62		cmp $62,x			cmp 	NSMantissa0+2,x
.9fde		90 41		bcc $a021			bcc 	_VHBadIndex
.9fe0						_VHCheckFirstIndex:
.9fe0		a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9fe2		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fe4		d5 61		cmp $61,x			cmp 	NSMantissa0+1,x
.9fe6		90 39		bcc $a021			bcc 	_VHBadIndex
.9fe8		64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9fea		64 37		stz $37				stz 	zTemp0+1
.9fec		b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9fee		30 0e		bmi $9ffe			bmi 	_VHNoMultiply
.9ff0		da		phx				phx
.9ff1		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9ff3		48		pha				pha
.9ff4		a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9ff6		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9ff8		1a		inc a				inc 	a 							; add 1 for zero base
.9ff9		fa		plx				plx
.9ffa		20 61 a4	jsr $a461			jsr 	Multiply8x8 				; calculate -> Z0
.9ffd		fa		plx				plx
.9ffe						_VHNoMultiply:
.9ffe		18		clc				clc
.9fff		a5 36		lda $36				lda 	zTemp0
.a001		75 61		adc $61,x			adc 	NSMantissa0+1,x
.a003		85 36		sta $36				sta 	zTemp0
.a005		a5 37		lda $37				lda 	zTemp0+1
.a007		69 00		adc #$00			adc 	#0
.a009		85 37		sta $37				sta 	zTemp0+1
.a00b		b5 50		lda $50,x			lda 	NSStatus,x
.a00d		20 59 8a	jsr $8a59			jsr 	ScaleByBaseType
.a010		18		clc				clc
.a011		b2 3e		lda ($3e)			lda 	(zaTemp)
.a013		65 36		adc $36				adc 	zTemp0
.a015		95 60		sta $60,x			sta 	NSMantissa0,x
.a017		a0 01		ldy #$01			ldy 	#1
.a019		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.a01b		65 37		adc $37				adc 	zTemp0+1
.a01d		95 70		sta $70,x			sta 	NSMantissa1,x
.a01f		7a		ply				ply 								; restore position
.a020		60		rts				rts
.a021						_VHBadIndex:
.a021		a9 17		lda #$17		lda	#23
.a023		4c 4d 95	jmp $954d		jmp	ErrorHandler
.a026						_VHBadArray:
.a026		a9 18		lda #$18		lda	#24
.a028		4c 4d 95	jmp $954d		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.a02b						AbsUnary:
.a02b		fa		plx				plx 								; restore stack pos
.a02c		20 04 a4	jsr $a404			jsr 	EvaluateNumber 				; get a float or int
.a02f		20 34 95	jsr $9534			jsr 	CheckRightBracket
.a032		b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.a034		29 7f		and #$7f			and 	#$7F
.a036		95 50		sta $50,x			sta 	NSStatus,x
.a038		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.a039						AllocUnary:
.a039		fa		plx				plx 								; restore stack pos
.a03a		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger		; get bytes required.
.a03d		20 34 95	jsr $9534			jsr 	CheckRightBracket
.a040		da		phx				phx 								; save X/Y
.a041		5a		phy				phy
.a042		8a		txa				txa 								; copy X into Y
.a043		a8		tay				tay
.a044		b9 70 00	lda $0070,y			lda		NSMantissa1,y 				; get size into XA
.a047		aa		tax				tax
.a048		b9 60 00	lda $0060,y			lda 	NSMantissa0,y
.a04b		20 58 a0	jsr $a058			jsr 	AllocateXABytes 			; allocate memory
.a04e		99 60 00	sta $0060,y			sta 	NSMantissa0,y 				; write address out.
.a051		8a		txa				txa 	 							; typing is 16 bit integer.
.a052		99 70 00	sta $0070,y			sta 	NSMantissa1,y
.a055		7a		ply				ply
.a056		fa		plx				plx
.a057		60		rts				rts
.a058						AllocateXABytes:
.a058		5a		phy				phy
.a059		ac 28 04	ldy $0428			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.a05c		84 36		sty $36				sty 	zTemp0
.a05e		5a		phy				phy
.a05f		ac 29 04	ldy $0429			ldy 	lowMemPtr+1
.a062		84 37		sty $37				sty 	zTemp0+1
.a064		5a		phy				phy
.a065		18		clc				clc 								; add to low memory pointer
.a066		6d 28 04	adc $0428			adc 	lowMemPtr
.a069		8d 28 04	sta $0428			sta 	lowMemPtr
.a06c		8a		txa				txa
.a06d		6d 29 04	adc $0429			adc 	lowMemPtr+1
.a070		8d 29 04	sta $0429			sta 	lowMemPtr+1
.a073		b0 2f		bcs $a0a4			bcs 	CISSMemory
.a075		20 96 a0	jsr $a096			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.a078						_ClearMemory:
.a078		ad 28 04	lda $0428			lda 	lowMemPtr 					; cleared all memory allocated
.a07b		c5 36		cmp $36				cmp 	zTemp0
.a07d		d0 07		bne $a086			bne 	_CMClearNext
.a07f		ad 29 04	lda $0429			lda 	lowMemPtr+1
.a082		c5 37		cmp $37				cmp 	zTemp0+1
.a084		f0 0c		beq $a092			beq 	_CMExit
.a086						_CMClearNext:
.a086		a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.a088		92 36		sta ($36)			sta 	(zTemp0)
.a08a		e6 36		inc $36				inc 	zTemp0
.a08c		d0 ea		bne $a078			bne 	_ClearMemory
.a08e		e6 37		inc $37				inc		zTemp0+1
.a090		80 e6		bra $a078			bra 	_ClearMemory
.a092						_CMExit:
.a092		fa		plx				plx
.a093		68		pla				pla
.a094		7a		ply				ply
.a095		60		rts				rts
.a096						CheckIdentifierStringSpace:
.a096		48		pha				pha
.a097		ad 29 04	lda $0429			lda 	lowMemPtr+1 				; get low memory pointer
.a09a		18		clc				clc
.a09b		69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.a09d		cd 2b 04	cmp $042b			cmp 	stringMemory+1 				; is it >= StringMemory
.a0a0		b0 02		bcs $a0a4			bcs 	CISSMemory
.a0a2		68		pla				pla
.a0a3		60		rts				rts
.a0a4						CISSMemory:
.a0a4		a9 06		lda #$06		lda	#6
.a0a6		4c 4d 95	jmp $954d		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.a0a9						AscUnary:
.a0a9		fa		plx				plx 								; restore stack pos
.a0aa		20 0e a4	jsr $a40e			jsr 	EvaluateString 				; get a string
.a0ad		b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.a0af		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte 					; ASC("") will return zero.
.a0b2		20 34 95	jsr $9534			jsr 	CheckRightBracket
.a0b5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.a0b6						FracUnary:
.a0b6		fa		plx				plx 								; restore stack pos
.a0b7		20 04 a4	jsr $a404			jsr 	EvaluateNumber 				; get a float or int
.a0ba		20 34 95	jsr $9534			jsr 	CheckRightBracket
.a0bd		b5 50		lda $50,x			lda 	NSStatus,x
.a0bf		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.a0c1		f0 04		beq $a0c7			beq 	_IUZero
.a0c3		20 71 9b	jsr $9b71			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.a0c6		60		rts				rts
.a0c7						_IUZero:
.a0c7		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero
.a0ca		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.a0cb						IntUnary:
.a0cb		fa		plx				plx 								; restore stack pos
.a0cc		20 04 a4	jsr $a404			jsr 	EvaluateNumber 				; get a float or int
.a0cf		20 34 95	jsr $9534			jsr 	CheckRightBracket
.a0d2		b5 50		lda $50,x			lda 	NSStatus,x
.a0d4		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.a0d6		f0 03		beq $a0db			beq 	_IUExit
.a0d8		20 c9 9b	jsr $9bc9			jsr 	FloatIntegerPart 			; if it is get the integer part.
.a0db						_IUExit:
.a0db		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.a0dc						LenUnary:
.a0dc		fa		plx				plx 								; restore stack pos
.a0dd		20 0e a4	jsr $a40e			jsr 	EvaluateString 				; get a string
.a0e0		5a		phy				phy
.a0e1		a0 00		ldy #$00			ldy 	#0 							; find length
.a0e3						_LenFind:
.a0e3		b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.a0e5		f0 06		beq $a0ed			beq 	_LenExit
.a0e7		c8		iny				iny
.a0e8		d0 f9		bne $a0e3			bne 	_LenFind
.a0ea		4c 33 a6	jmp $a633			jmp 	RangeError 					; string > 255 - no trailing NULL.
.a0ed						_LenExit:
.a0ed		98		tya				tya		 							; return length
.a0ee		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte
.a0f1		7a		ply				ply
.a0f2		20 34 95	jsr $9534			jsr 	CheckRightBracket
.a0f5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.a0f6						Unary_Min:
.a0f6		a9 01		lda #$01			lda 	#1
.a0f8		80 02		bra $a0fc			bra 	UnaryMinMaxMain
.a0fa						Unary_Max:
.a0fa		a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.a0fc						UnaryMinMaxMain:
.a0fc		fa		plx				plx 								; get index on number stack
.a0fd		48		pha				pha 								; save comparator
.a0fe		20 fb a3	jsr $a3fb			jsr 	EvaluateValue 				; get the first value.
.a101						_UMMMLoop:
.a101		b1 30		lda ($30),y			lda 	(codePtr),y
.a103		c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.a105		f0 22		beq $a129			beq 	_UMMMDone
.a107		20 3c 95	jsr $953c			jsr 	CheckComma 					; must be a comma
.a10a		e8		inx				inx
.a10b		20 fb a3	jsr $a3fb			jsr 	EvaluateValue
.a10e		ca		dex				dex
.a10f		20 99 a4	jsr $a499			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.a112		e8		inx				inx
.a113		20 99 a4	jsr $a499			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.a116		e8		inx				inx
.a117		20 0a 96	jsr $960a			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.a11a		ca		dex				dex
.a11b		ca		dex				dex
.a11c		85 36		sta $36				sta 	zTemp0 						; save required result
.a11e		68		pla				pla 								; get and save comparator
.a11f		48		pha				pha
.a120		c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.a122		d0 dd		bne $a101			bne 	_UMMMLoop
.a124		20 2c a1	jsr $a12c			jsr 	ExpCopyAboveDown 			; copy next up slot down
.a127		80 d8		bra $a101			bra 	_UMMMLoop
.a129						_UMMMDone:
.a129		68		pla				pla 								; throw the comparator
.a12a		c8		iny				iny 								; skip )
.a12b		60		rts				rts
.a12c						ExpCopyAboveDown:
.a12c		b5 51		lda $51,x			lda 	NSStatus+1,x
.a12e		95 50		sta $50,x			sta 	NSStatus,x
.a130		b5 a1		lda $a1,x			lda 	NSExponent+1,x
.a132		95 a0		sta $a0,x			sta 	NSExponent,x
.a134		b5 61		lda $61,x			lda 	NSMantissa0+1,x
.a136		95 60		sta $60,x			sta 	NSMantissa0,x
.a138		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.a13a		95 70		sta $70,x			sta 	NSMantissa1,x
.a13c		b5 81		lda $81,x			lda 	NSMantissa2+1,x
.a13e		95 80		sta $80,x			sta 	NSMantissa2,x
.a140		b5 91		lda $91,x			lda 	NSMantissa3+1,x
.a142		95 90		sta $90,x			sta 	NSMantissa3,x
.a144		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.a145						Unary_Not:
.a145		fa		plx				plx
.a146		20 23 a4	jsr $a423			jsr 	EvaluateInteger 			; get integer
.a149		20 34 95	jsr $9534			jsr 	CheckRightBracket
.a14c		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; zero mantissa ?
.a14f		f0 04		beq $a155			beq 	_NotZero
.a151		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero
.a154		60		rts				rts
.a155						_NotZero:
.a155		4c c0 95	jmp $95c0			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/peek.asm

.a158						PeekByteUnary:
.a158		a9 01		lda #$01			lda 	#1
.a15a		80 0a		bra $a166			bra 	PeekUnary
.a15c						PeekWUnary:
.a15c		a9 02		lda #$02			lda 	#2
.a15e		80 06		bra $a166			bra 	PeekUnary
.a160						PeekLUnary:
.a160		a9 03		lda #$03			lda 	#3
.a162		80 02		bra $a166			bra 	PeekUnary
.a164						PeekDUnary:
.a164		a9 04		lda #$04			lda 	#4
.a166						PeekUnary:
.a166		fa		plx				plx 								; restore position.
.a167		48		pha				pha 								; save count to copy on stack
.a168		20 36 a4	jsr $a436			jsr		Evaluate16BitInteger 		; address as constant.
.a16b		20 34 95	jsr $9534			jsr 	CheckRightBracket
.a16e		b5 60		lda $60,x			lda 	NSMantissa0,x 				; save mantissa in zTemp0 as address
.a170		85 36		sta $36				sta 	zTemp0
.a172		b5 70		lda $70,x			lda 	NSMantissa1,x
.a174		85 37		sta $37				sta 	zTemp0+1
.a176		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero 					; clear the result to zero.
.a179		68		pla				pla 								; count in zTemp2
.a17a		85 3a		sta $3a				sta 	zTemp2
.a17c		da		phx				phx 								; save stack position and offset of read
.a17d		5a		phy				phy
.a17e		a0 00		ldy #$00			ldy 	#0 							; byte read offset.
.a180						_PULoop:
.a180		b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next byte, write to mantissa0,x
.a182		95 60		sta $60,x			sta 	NSMantissa0,x 				; we change X not the index before it.
.a184		c8		iny				iny 								; next byte to write
.a185		8a		txa				txa 								; next byte to read - stack layout in 04data.inc
.a186		18		clc				clc
.a187		69 10		adc #$10			adc 	#MathStackSize
.a189		aa		tax				tax
.a18a		c6 3a		dec $3a				dec 	zTemp2 						; done them all
.a18c		d0 f2		bne $a180			bne 	_PULoop
.a18e		7a		ply				ply 								; restore stack/code pos and exit.
.a18f		fa		plx				plx
.a190		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.a191						SgnUnary:
.a191		fa		plx				plx 								; restore stack pos
.a192		20 04 a4	jsr $a404			jsr 	EvaluateNumber 				; get a float or int
.a195		20 34 95	jsr $9534			jsr 	CheckRightBracket
.a198		20 d8 a4	jsr $a4d8			jsr 	NSMIsZero 					; if zero
.a19b		f0 0e		beq $a1ab			beq 	_SGZero  					; return Int Zero
.a19d		b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.a19f		48		pha				pha
.a1a0		a9 01		lda #$01			lda 	#1 							; set to 1
.a1a2		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte
.a1a5		68		pla				pla
.a1a6		29 80		and #$80			and		#$80 						; copy the sign byte out
.a1a8		95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.a1aa		60		rts				rts
.a1ab		20 b6 a4	jsr $a4b6	_SGZero:jsr 	NSMSetZero
.a1ae		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.a1af						ValUnary:
.a1af		fa		plx				plx 								; restore stack pos
.a1b0		20 c5 a1	jsr $a1c5			jsr 	ValMainCode 				; do the main val() code
.a1b3		b0 01		bcs $a1b6			bcs 	_VUError 					; couldn't convert
.a1b5		60		rts				rts
.a1b6						_VUError:
.a1b6		4c 38 a6	jmp $a638			jmp 	TypeError
.a1b9						IsValUnary:
.a1b9		fa		plx				plx 								; restore stack pos
.a1ba		20 c5 a1	jsr $a1c5			jsr 	ValMainCode 				; do the main val() code
.a1bd		b0 03		bcs $a1c2			bcs 	_VUBad
.a1bf		4c c0 95	jmp $95c0			jmp 	ReturnTrue
.a1c2						_VUBad:
.a1c2		4c cb 95	jmp $95cb			jmp 	ReturnFalse
.a1c5						ValMainCode:
.a1c5		20 0e a4	jsr $a40e			jsr 	EvaluateString 				; get a string
.a1c8		20 34 95	jsr $9534			jsr 	CheckRightBracket 			; check right bracket present
.a1cb						ValEvaluateZTemp0:
.a1cb		5a		phy				phy
.a1cc		b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.a1ce		f0 17		beq $a1e7			beq 	_VMCFail2
.a1d0		a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.a1d2		48		pha				pha 								; save first character
.a1d3		c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.a1d5		d0 01		bne $a1d8			bne 	_VMCStart
.a1d7		c8		iny				iny 								; skip over -
.a1d8						_VMCStart:
.a1d8		38		sec				sec 								; initialise first time round.
.a1d9						_VMCNext:
.a1d9		c8		iny				iny 								; pre-increment
.a1da		b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.a1dc		f0 0c		beq $a1ea			beq 	_VMCSuccess 				; successful.
.a1de		20 a6 9d	jsr $9da6			jsr 	EncodeNumber 				; send it to the number-builder
.a1e1		90 03		bcc $a1e6			bcc 	_VMCFail 					; if failed, give up.
.a1e3		18		clc				clc 								; next time round, countinue
.a1e4		80 f3		bra $a1d9			bra 	_VMCNext
.a1e6						_VMCFail:
.a1e6		68		pla				pla
.a1e7						_VMCFail2:
.a1e7		7a		ply				ply
.a1e8		38		sec				sec
.a1e9		60		rts				rts
.a1ea						_VMCSuccess:
.a1ea		a9 00		lda #$00			lda 	#0 							; construct final
.a1ec		20 a6 9d	jsr $9da6			jsr 	EncodeNumber 				; by sending a duff value.
.a1ef		68		pla				pla 								; if it was -ve
.a1f0		c9 2d		cmp #$2d			cmp 	#"-"
.a1f2		d0 03		bne $a1f7			bne 	_VMCNotNegative
.a1f4		20 78 a4	jsr $a478			jsr		NSMNegate 					; negate it.
.a1f7						_VMCNotNegative:
.a1f7		7a		ply				ply
.a1f8		18		clc				clc
.a1f9		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.a1fa						ChrUnary:
.a1fa		fa		plx				plx 								; restore stack pos
.a1fb		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.a1fe		48		pha				pha
.a1ff		20 34 95	jsr $9534			jsr 	CheckRightBracket
.a202		a9 01		lda #$01			lda 	#1 							; allocate space for one char
.a204		20 bd b7	jsr $b7bd			jsr 	StringTempAllocate
.a207		68		pla				pla 								; write number to it
.a208		20 f6 b7	jsr $b7f6			jsr 	StringTempWrite
.a20b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/items.asm

.a20c						ItemCountUnary:
.a20c		fa		plx				plx
.a20d		20 0e a4	jsr $a40e			jsr 	EvaluateString
.a210		e8		inx				inx
.a211		20 84 a2	jsr $a284			jsr 	ICGetSeperator
.a214		ca		dex				dex
.a215		20 a5 a2	jsr $a2a5			jsr 	ICSetPointer 				; zTemp0 = (string)
.a218		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero 					; zero the result.
.a21b		5a		phy				phy
.a21c		a0 ff		ldy #$ff			ldy 	#$FF 						; loop counting seperators in mantissa
.a21e						_ICULoop:
.a21e		c8		iny				iny
.a21f		b1 36		lda ($36),y			lda 	(zTemp0),y
.a221		cd ca 07	cmp $07ca			cmp 	ICSeperator
.a224		d0 02		bne $a228			bne 	_ICUNoMatch
.a226		f6 60		inc $60,x			inc 	NSMantissa0,x
.a228						_ICUNoMatch:
.a228		c9 00		cmp #$00			cmp 	#0
.a22a		d0 f2		bne $a21e			bne 	_ICULoop
.a22c		f6 60		inc $60,x			inc 	NSMantissa0,x 				; +1
.a22e		7a		ply				ply
.a22f		60		rts				rts
.a230						ItemGetUnary:
.a230		fa		plx				plx
.a231		20 0e a4	jsr $a40e			jsr 	EvaluateString 				; search string
.a234		20 3c 95	jsr $953c			jsr 	CheckComma
.a237		e8		inx				inx 								; get count
.a238		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.a23b		c9 00		cmp #$00			cmp 	#0 							; must be > 0, index starts at 1.
.a23d		f0 61		beq $a2a0			beq 	ICGSRange
.a23f		e8		inx				inx 								; get seperator.
.a240		20 84 a2	jsr $a284			jsr 	ICGetSeperator
.a243		ca		dex				dex
.a244		ca		dex				dex
.a245		5a		phy				phy
.a246		20 a5 a2	jsr $a2a5			jsr 	ICSetPointer 				; zTemp0 points to string.
.a249		a0 00		ldy #$00			ldy 	#0
.a24b		d6 61		dec $61,x			dec 	NSMantissa0+1,x 			; first element.
.a24d		f0 0e		beq $a25d			beq 	_IGUFoundStart
.a24f						_IGUFindNext:
.a24f		b1 36		lda ($36),y			lda 	(zTemp0),y		 			; next
.a251		f0 4d		beq $a2a0			beq 	ICGSRange 					; eol, not found.
.a253		c8		iny				iny
.a254		cd ca 07	cmp $07ca			cmp 	ICSeperator 				; until found a seperator (or EOS)
.a257		d0 f6		bne $a24f			bne 	_IGUFindNext
.a259		d6 61		dec $61,x			dec 	NSMantissa0+1,x
.a25b		d0 f2		bne $a24f			bne 	_IGUFindNext
.a25d						_IGUFoundStart:
.a25d		84 38		sty $38				sty 	zTemp1 						; save start
.a25f		88		dey				dey
.a260						_IGUFindLength:
.a260		c8		iny				iny 								; forward till seperator/EOS
.a261		b1 36		lda ($36),y			lda 	(zTemp0),y
.a263		f0 05		beq $a26a			beq 	_IGUFoundLength
.a265		cd ca 07	cmp $07ca			cmp 	ICSeperator
.a268		d0 f6		bne $a260			bne 	_IGUFindLength
.a26a						_IGUFoundLength:
.a26a		84 39		sty $39				sty 	zTemp1+1 					; save end of copy string
.a26c		98		tya				tya 								; calculate length of new string.
.a26d		38		sec				sec
.a26e		e5 38		sbc $38				sbc 	zTemp1
.a270		20 bd b7	jsr $b7bd			jsr 	StringTempAllocate 			; allocate bytes for it.
.a273		a4 38		ldy $38				ldy 	zTemp1
.a275						_IGUCopySub:
.a275		c4 39		cpy $39				cpy 	zTemp1+1
.a277		f0 08		beq $a281			beq 	_IGUCopyOver
.a279		b1 36		lda ($36),y			lda 	(zTemp0),y
.a27b		20 f6 b7	jsr $b7f6			jsr 	StringTempWrite
.a27e		c8		iny				iny
.a27f		80 f4		bra $a275			bra 	_IGUCopySub
.a281						_IGUCopyOver:
.a281		7a		ply				ply
.a282		60		rts				rts
>a283		db						.byte 	$DB 						; causes a break in the emulator
.a284						ICGetSeperator:
.a284		20 3c 95	jsr $953c			jsr 	CheckComma 					; preceding comma
.a287		20 0e a4	jsr $a40e			jsr 	EvaluateString 				; seperator string
.a28a		20 a5 a2	jsr $a2a5			jsr 	ICSetPointer 				; access it
.a28d		b2 36		lda ($36)			lda 	(zTemp0) 					; get sep char
.a28f		8d ca 07	sta $07ca			sta 	ICSeperator
.a292		f0 0c		beq $a2a0			beq 	ICGSRange 					; check LEN(seperator) = 1
.a294		5a		phy				phy
.a295		a0 01		ldy #$01			ldy 	#1
.a297		b1 36		lda ($36),y			lda 	(zTemp0),y
.a299		d0 05		bne $a2a0			bne 	ICGSRange
.a29b		7a		ply				ply
.a29c		20 34 95	jsr $9534			jsr 	CheckRightBracket 			; check following )
.a29f		60		rts				rts
.a2a0						ICGSRange:
.a2a0		a9 04		lda #$04		lda	#4
.a2a2		4c 4d 95	jmp $954d		jmp	ErrorHandler
.a2a5						ICSetPointer:
.a2a5		b5 60		lda $60,x			lda 	NSMantissa0,x 				; set zTemp0 to point to it.
.a2a7		85 36		sta $36				sta 	zTemp0
.a2a9		b5 70		lda $70,x			lda 	NSMantissa1,x
.a2ab		85 37		sta $37				sta 	zTemp0+1
.a2ad		60		rts				rts
.07ca						ICSeperator:
>07ca								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.a2ae						SpcUnary:
.a2ae		fa		plx				plx 								; restore stack pos
.a2af		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger			; get value
.a2b2		5a		phy				phy
.a2b3		48		pha				pha 								; save count
.a2b4		20 bd b7	jsr $b7bd			jsr 	StringTempAllocate
.a2b7		7a		ply				ply 								; to do count in Y
.a2b8						_SpcLoop:
.a2b8		c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.a2ba		f0 08		beq $a2c4			beq 	_SpcExit
.a2bc		a9 20		lda #$20			lda 	#32
.a2be		20 f6 b7	jsr $b7f6			jsr 	StringTempWrite
.a2c1		88		dey				dey
.a2c2		80 f4		bra $a2b8			bra 	_SpcLoop
.a2c4						_SpcExit:
.a2c4		7a		ply				ply
.a2c5		20 34 95	jsr $9534			jsr 	CheckRightBracket
.a2c8		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.a2c9						Unary_Str:
.a2c9		fa		plx				plx
.a2ca		20 04 a4	jsr $a404			jsr 	EvaluateNumber  			; get number
.a2cd		20 34 95	jsr $9534			jsr 	CheckRightBracket 			; closing bracket
.a2d0		a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.a2d2		20 eb a2	jsr $a2eb			jsr 	ConvertNumberToString 		; do the conversion.
.a2d5		a9 21		lda #$21			lda		#33 						; create buffer
.a2d7		20 bd b7	jsr $b7bd			jsr 	StringTempAllocate 			; allocate memory
.a2da		da		phx				phx  								; copy the converted string into the buffer.
.a2db		a2 00		ldx #$00			ldx 	#0
.a2dd						_USCopy:
.a2dd		bd 65 06	lda $0665,x			lda 	decimalBuffer,x
.a2e0		20 f6 b7	jsr $b7f6			jsr 	StringTempWrite
.a2e3		e8		inx				inx
.a2e4		bd 65 06	lda $0665,x			lda 	decimalBuffer,x
.a2e7		d0 f4		bne $a2dd			bne 	_USCopy
.a2e9		fa		plx				plx
.a2ea		60		rts				rts
.a2eb						ConvertNumberToString:
.a2eb		5a		phy				phy 								; save code position
.a2ec		8d 30 04	sta $0430			sta 	decimalPlaces	 			; save number of DPs.
.a2ef		9c 31 04	stz $0431			stz 	dbOffset 					; offset into decimal buffer = start.
.a2f2		b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.a2f4		10 09		bpl $a2ff			bpl 	_CNTSNotNegative
.a2f6		29 7f		and #$7f			and 	#$7F 						; make +ve
.a2f8		95 50		sta $50,x			sta 	NSStatus,x
.a2fa		a9 2d		lda #$2d			lda 	#"-"
.a2fc		20 60 a3	jsr $a360			jsr 	WriteDecimalBuffer
.a2ff						_CNTSNotNegative:
.a2ff		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check if decimal
.a301		f0 12		beq $a315			beq 	_CNTSNotFloat
.a303		e8		inx				inx 								; round up so we don't get too many 6.999999
.a304		a9 01		lda #$01			lda 	#1
.a306		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte
.a309		ca		dex				dex
.a30a		b5 a0		lda $a0,x			lda		NSExponent,x
.a30c		95 a1		sta $a1,x			sta 	NSExponent+1,x
.a30e		a9 08		lda #$08			lda 	#NSTFloat
.a310		95 51		sta $51,x			sta 	NSStatus+1,x
.a312		20 ab 9a	jsr $9aab			jsr 	FloatAdd
.a315						_CNTSNotFloat:
.a315		20 42 a3	jsr $a342			jsr 	MakePlusTwoString 			; do the integer part.
.a318		20 71 9b	jsr $9b71			jsr 	FloatFractionalPart 		; get the fractional part
.a31b		20 22 9c	jsr $9c22			jsr 	NSNormalise					; normalise , exit if zero
.a31e		f0 20		beq $a340			beq 	_CNTSExit
.a320		a9 2e		lda #$2e			lda 	#"."
.a322		20 60 a3	jsr $a360			jsr 	WriteDecimalBuffer 			; write decimal place
.a325						_CNTSDecimal:
.a325		ce 30 04	dec $0430			dec 	decimalPlaces 				; done all the decimals
.a328		30 16		bmi $a340			bmi 	_CNTSExit
.a32a		e8		inx				inx 								; x 10.0
.a32b		a9 0a		lda #$0a			lda 	#10
.a32d		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte
.a330		a9 08		lda #$08			lda 	#NSTFloat
.a332		95 50		sta $50,x			sta 	NSStatus,x
.a334		ca		dex				dex
.a335		20 f0 9b	jsr $9bf0			jsr 	FloatMultiply
.a338		20 42 a3	jsr $a342			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.a33b		20 71 9b	jsr $9b71			jsr 	FloatFractionalPart 		; get the fractional part
.a33e		80 e5		bra $a325			bra 	_CNTSDecimal 				; keep going.
.a340						_CNTSExit:
.a340		7a		ply				ply
.a341		60		rts				rts
.a342						MakePlusTwoString:
.a342		da		phx				phx
.a343		20 99 a4	jsr $a499			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.a346		e8		inx				inx 								; access it
.a347		e8		inx				inx
.a348		20 c9 9b	jsr $9bc9			jsr 	FloatIntegerPart 			; make it an integer
.a34b		a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.a34d		20 d2 99	jsr $99d2			jsr 	ConvertInt32
.a350		a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.a352						_MPTSCopy:
.a352		bd 43 06	lda $0643,x			lda 	numberBuffer,x
.a355		20 60 a3	jsr $a360			jsr 	WriteDecimalBuffer
.a358		e8		inx				inx
.a359		bd 43 06	lda $0643,x			lda 	numberBuffer,x
.a35c		d0 f4		bne $a352			bne 	_MPTSCopy
.a35e		fa		plx				plx
.a35f		60		rts				rts
.a360						WriteDecimalBuffer:
.a360		da		phx				phx
.a361		ae 31 04	ldx $0431			ldx 	dbOffset
.a364		9d 65 06	sta $0665,x			sta 	decimalBuffer,x
.a367		9e 66 06	stz $0666,x			stz 	decimalBuffer+1,x
.a36a		ee 31 04	inc $0431			inc 	dbOffset
.a36d		fa		plx				plx
.a36e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.a36f						Unary_Left:
.a36f		fa		plx				plx
.a370		18		clc				clc 								; only one parameter
.a371		20 d4 a3	jsr $a3d4			jsr 	SubstringInitial 			; set up.
.a374		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.a376		95 62		sta $62,x			sta 	NSMantissa0+2,x
.a378		74 61		stz $61,x			stz 	NSMantissa0+1,x 			; Start is zero.
.a37a		80 25		bra $a3a1			bra 	SubstringMain
.a37c						Unary_Right:
.a37c		fa		plx				plx
.a37d		18		clc				clc 								; only one parameter
.a37e		20 d4 a3	jsr $a3d4			jsr 	SubstringInitial 			; set up.
.a381		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; length => param 2
.a383		95 62		sta $62,x			sta 	NSMantissa0+2,x
.a385		b5 a0		lda $a0,x			lda 	NSExponent,x 				; total length
.a387		f5 61		sbc $61,x			sbc 	NSMantissa0+1,x 			; length - required.
.a389		b0 02		bcs $a38d			bcs 	_URNotUnderflow
.a38b		a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.a38d						_URNotUnderflow:
.a38d		95 61		sta $61,x			sta 	NSMantissa0+1,x 			; this is the start position
.a38f		80 10		bra $a3a1			bra 	SubstringMain
.a391						Unary_Mid:
.a391		fa		plx				plx
.a392		38		sec				sec 								; two parameters
.a393		20 d4 a3	jsr $a3d4			jsr 	SubstringInitial 			; set up.
.a396		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.a398		f0 04		beq $a39e			beq 	_UMError
.a39a		d6 61		dec $61,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.a39c		80 03		bra $a3a1			bra 	SubstringMain
.a39e						_UMError:
.a39e		4c 3d a6	jmp $a63d			jmp 	ArgumentError
.a3a1						SubstringMain:
.a3a1		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.a3a3		d5 a0		cmp $a0,x			cmp 	NSExponent,x
.a3a5		b0 27		bcs $a3ce			bcs 	_SSMNull 					; if so, return an empty string.
.a3a7		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.a3a9		f0 23		beq $a3ce			beq 	_SSMNull 					; return empty string.
.a3ab		18		clc				clc 								; add the offset +1 to the address and
.a3ac		b5 60		lda $60,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.a3ae		75 61		adc $61,x			adc 	NSMantissa0+1,x
.a3b0		85 36		sta $36				sta 	zTemp0
.a3b2		b5 70		lda $70,x			lda	 	NSMantissa1,x
.a3b4		69 00		adc #$00			adc 	#0
.a3b6		85 37		sta $37				sta 	zTemp0+1
.a3b8						_SSMNoCarry:
.a3b8		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; characters required.
.a3ba		20 bd b7	jsr $b7bd			jsr 	StringTempAllocate 			; allocate that many characters
.a3bd		5a		phy				phy 								; save Y
.a3be		a0 00		ldy #$00			ldy 	#0 							; start copying in.
.a3c0						_SSMCopy:
.a3c0		b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.a3c2		f0 08		beq $a3cc			beq 	_SSMEString 				; no more to copy
.a3c4		20 f6 b7	jsr $b7f6			jsr 	StringTempWrite 			; and write it out.
.a3c7		c8		iny				iny
.a3c8		d6 62		dec $62,x			dec 	NSMantissa0+2,x
.a3ca		d0 f4		bne $a3c0			bne 	_SSMCopy
.a3cc						_SSMEString:
.a3cc		7a		ply				ply
.a3cd						_SSMExit:
.a3cd		60		rts				rts
.a3ce						_SSMNull:
.a3ce		a9 00		lda #$00			lda 	#0
.a3d0		20 bd b7	jsr $b7bd			jsr 	StringTempAllocate
.a3d3		60		rts				rts
.a3d4						SubstringInitial:
.a3d4		da		phx				phx 								; save initial stack position
.a3d5		08		php				php 								; save carry on stack indicating 2 parameters
.a3d6		20 0e a4	jsr $a40e			jsr 	EvaluateString 				; get a string
.a3d9		5a		phy				phy 								; calculate length to exponent.
.a3da		a0 ff		ldy #$ff			ldy 	#$FF
.a3dc						_SIFindLength:
.a3dc		c8		iny				iny
.a3dd		b1 36		lda ($36),y			lda 	(zTemp0),y
.a3df		d0 fb		bne $a3dc			bne 	_SIFindLength
.a3e1		98		tya				tya
.a3e2		95 a0		sta $a0,x			sta 	NSExponent,x
.a3e4		7a		ply				ply
.a3e5		e8		inx				inx
.a3e6		20 3c 95	jsr $953c			jsr 	CheckComma 					; comma next
.a3e9		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; get next parameter
.a3ec		28		plp				plp 								; is it the last parameter ?
.a3ed		90 07		bcc $a3f6			bcc 	_SSIExit 					; if so, exit.
.a3ef		e8		inx				inx
.a3f0		20 3c 95	jsr $953c			jsr 	CheckComma 					; comma next
.a3f3		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; get last parameter
.a3f6						_SSIExit:
.a3f6		fa		plx				plx
.a3f7		20 34 95	jsr $9534			jsr 	CheckRightBracket 			; check closing bracket
.a3fa		60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.a3fb						EvaluateValue:
.a3fb		48		pha				pha
.a3fc		20 57 9a	jsr $9a57			jsr		EvaluateExpression 			; expression
.a3ff		20 23 9d	jsr $9d23			jsr 	Dereference					; derefernce it
.a402		68		pla				pla
.a403		60		rts				rts
.a404						EvaluateNumber:
.a404		20 fb a3	jsr $a3fb			jsr 	EvaluateValue 				; get a value
.a407		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.a409		29 10		and #$10			and 	#NSBIsString
.a40b		d0 13		bne $a420			bne 	HelperTypeError
.a40d		60		rts				rts
.a40e						EvaluateString:
.a40e		20 fb a3	jsr $a3fb			jsr 	EvaluateValue 				; get a value
.a411		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.a413		29 10		and #$10			and 	#NSBIsString
.a415		f0 09		beq $a420			beq 	HelperTypeError
.a417						CopyAddressToTemp0:
.a417		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.a419		85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.a41b		b5 70		lda $70,x			lda 	NSMantissa1,x
.a41d		85 37		sta $37				sta 	zTemp0+1
.a41f		60		rts				rts
.a420						HelperTypeError:
.a420		4c 38 a6	jmp $a638			jmp 	TypeError
.a423						EvaluateInteger:
.a423		20 04 a4	jsr $a404			jsr 	EvaluateNumber
.a426		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check exponent is zero
.a428		d0 09		bne $a433			bne 	HelperValueError 			; if not, it's a float.
.a42a		60		rts				rts
.a42b						EvaluateUnsignedInteger:
.a42b		20 23 a4	jsr $a423			jsr 	EvaluateInteger 			; check integer is +ve
.a42e		b5 50		lda $50,x			lda 	NSStatus,x
.a430		30 01		bmi $a433			bmi 	HelperValueError
.a432		60		rts				rts
.a433						HelperValueError:
.a433		4c 3d a6	jmp $a63d			jmp 	ArgumentError
.a436						Evaluate16BitInteger:
.a436		20 2b a4	jsr $a42b			jsr	 	EvaluateUnsignedInteger		; get integer
.a439		b5 90		lda $90,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.a43b		15 80		ora $80,x			ora 	NSMantissa2,x
.a43d		d0 f4		bne $a433			bne 	HelperValueError
.a43f		60		rts				rts
.a440						Evaluate16BitIntegerSigned:
.a440		20 23 a4	jsr $a423			jsr	 	EvaluateInteger				; get integer
.a443		b5 90		lda $90,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.a445		15 80		ora $80,x			ora 	NSMantissa2,x
.a447		d0 ea		bne $a433			bne 	HelperValueError
.a449		b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.a44b		10 03		bpl $a450			bpl 	_EISNotSigned
.a44d		20 7f a4	jsr $a47f			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.a450						_EISNotSigned:
.a450		60		rts				rts
.a451						Evaluate8BitInteger:
.a451		20 2b a4	jsr $a42b			jsr	 	EvaluateUnsignedInteger 	; get an integer
.a454		d0 dd		bne $a433			bne 	HelperValueError
.a456		b5 90		lda $90,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.a458		15 80		ora $80,x			ora 	NSMantissa2,x
.a45a		15 70		ora $70,x			ora 	NSMantissa1,x
.a45c		d0 d5		bne $a433			bne 	HelperValueError
.a45e		b5 60		lda $60,x			lda 	NSMantissa0,x
.a460		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.a461						Multiply8x8:
.a461		4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.a462		85 36		sta $36			  	sta 	zTemp0
.a464		86 37		stx $37				stx 	zTemp0+1
.a466		a9 00		lda #$00			lda 	#0
.a468		a2 08		ldx #$08			ldx 	#8
.a46a						_M88Loop:
.a46a		90 03		bcc $a46f			bcc 	_M88NoAdd
.a46c		18		clc				clc
.a46d		65 37		adc $37				adc 	zTemp0+1
.a46f						_M88NoAdd:
.a46f		6a		ror a				ror 	a
.a470		66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.a472		ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.a473		d0 f5		bne $a46a			bne 	_M88Loop
.a475		85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.a477		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.a478						NSMNegate:
.a478		b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.a47a		49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.a47c		95 50		sta $50,x			sta 	NSStatus,x
.a47e		60		rts				rts
.a47f						NSMNegateMantissa:
.a47f		38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.a480		a9 00		lda #$00			lda 	#0
.a482		f5 60		sbc $60,x			sbc 	NSMantissa0,x
.a484		95 60		sta $60,x			sta 	NSMantissa0,x
.a486		a9 00		lda #$00			lda 	#0
.a488		f5 70		sbc $70,x			sbc 	NSMantissa1,x
.a48a		95 70		sta $70,x			sta 	NSMantissa1,x
.a48c		a9 00		lda #$00			lda 	#0
.a48e		f5 80		sbc $80,x			sbc 	NSMantissa2,x
.a490		95 80		sta $80,x			sta 	NSMantissa2,x
.a492		a9 00		lda #$00			lda 	#0
.a494		f5 90		sbc $90,x			sbc 	NSMantissa3,x
.a496		95 90		sta $90,x			sta 	NSMantissa3,x
.a498		60		rts				rts
.a499						NSMShiftUpTwo:
.a499		b5 60		lda $60,x			lda 	NSMantissa0,x
.a49b		95 62		sta $62,x			sta 	NSMantissa0+2,x
.a49d		b5 70		lda $70,x			lda 	NSMantissa1,x
.a49f		95 72		sta $72,x			sta 	NSMantissa1+2,x
.a4a1		b5 80		lda $80,x			lda 	NSMantissa2,x
.a4a3		95 82		sta $82,x			sta 	NSMantissa2+2,x
.a4a5		b5 90		lda $90,x			lda 	NSMantissa3,x
.a4a7		95 92		sta $92,x			sta 	NSMantissa3+2,x
.a4a9		b5 a0		lda $a0,x			lda 	NSExponent,x
.a4ab		95 a2		sta $a2,x			sta 	NSExponent+2,x
.a4ad		b5 50		lda $50,x			lda 	NSStatus,x
.a4af		95 52		sta $52,x			sta 	NSStatus+2,x
.a4b1		60		rts				rts
.a4b2						NSMSetZeroMantissaOnly:
.a4b2		a9 00		lda #$00			lda 	#0
.a4b4		80 06		bra $a4bc			bra 	NSMSetMantissa
.a4b6						NSMSetZero:
.a4b6		a9 00		lda #$00			lda 	#0
.a4b8						NSMSetByte:
.a4b8		74 a0		stz $a0,x			stz 	NSExponent,x 				; zero exponent, as integer.
.a4ba		74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.a4bc						NSMSetMantissa:
.a4bc		95 60		sta $60,x			sta 	NSMantissa0,x 				; mantissa
.a4be		74 70		stz $70,x			stz 	NSMantissa1,x
.a4c0		74 80		stz $80,x			stz 	NSMantissa2,x
.a4c2		74 90		stz $90,x			stz 	NSMantissa3,x
.a4c4		60		rts				rts
.a4c5						NSMShiftLeft:
.a4c5		18		clc				clc
.a4c6						NSMRotateLeft:
.a4c6		36 60		rol $60,x			rol 	NSMantissa0,x
.a4c8		36 70		rol $70,x			rol		NSMantissa1,x
.a4ca		36 80		rol $80,x			rol		NSMantissa2,x
.a4cc		36 90		rol $90,x			rol		NSMantissa3,x
.a4ce		60		rts				rts
.a4cf						NSMShiftRight:
.a4cf		56 90		lsr $90,x			lsr 	NSMantissa3,x
.a4d1		76 80		ror $80,x			ror		NSMantissa2,x
.a4d3		76 70		ror $70,x			ror		NSMantissa1,x
.a4d5		76 60		ror $60,x			ror		NSMantissa0,x
.a4d7		60		rts				rts
.a4d8						NSMIsZero:
.a4d8		b5 90		lda $90,x			lda 	NSMantissa3,x
.a4da		15 80		ora $80,x			ora		NSMantissa2,x
.a4dc		15 70		ora $70,x			ora		NSMantissa1,x
.a4de		15 60		ora $60,x			ora		NSMantissa0,x
.a4e0		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.a4e1						Assemble_ora:
.a4e1		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4e4		01					.byte $01
.a4e5						Assemble_and:
.a4e5		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4e8		21					.byte $21
.a4e9						Assemble_eor:
.a4e9		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4ec		41					.byte $41
.a4ed						Assemble_adc:
.a4ed		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4f0		61					.byte $61
.a4f1						Assemble_sta:
.a4f1		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4f4		81					.byte $81
.a4f5						Assemble_lda:
.a4f5		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4f8		a1					.byte $a1
.a4f9						Assemble_cmp:
.a4f9		20 30 85	jsr $8530		jsr	AssembleGroup1
>a4fc		c1					.byte $c1
.a4fd						Assemble_sbc:
.a4fd		20 30 85	jsr $8530		jsr	AssembleGroup1
>a500		e1					.byte $e1
.a501						Assemble_asl:
.a501		20 37 85	jsr $8537		jsr	AssembleGroup2
>a504		02					.byte $02
>a505		75					.byte $75
.a506						Assemble_rol:
.a506		20 37 85	jsr $8537		jsr	AssembleGroup2
>a509		22					.byte $22
>a50a		75					.byte $75
.a50b						Assemble_lsr:
.a50b		20 37 85	jsr $8537		jsr	AssembleGroup2
>a50e		42					.byte $42
>a50f		75					.byte $75
.a510						Assemble_ror:
.a510		20 37 85	jsr $8537		jsr	AssembleGroup2
>a513		62					.byte $62
>a514		75					.byte $75
.a515						Assemble_stx:
.a515		20 37 85	jsr $8537		jsr	AssembleGroup2
>a518		82					.byte $82
>a519		50					.byte $50
.a51a						Assemble_ldx:
.a51a		20 37 85	jsr $8537		jsr	AssembleGroup2
>a51d		a2					.byte $a2
>a51e		d0					.byte $d0
.a51f						Assemble_dec:
.a51f		20 37 85	jsr $8537		jsr	AssembleGroup2
>a522		c2					.byte $c2
>a523		55					.byte $55
.a524						Assemble_inc:
.a524		20 37 85	jsr $8537		jsr	AssembleGroup2
>a527		e2					.byte $e2
>a528		55					.byte $55
.a529						Assemble_stz:
.a529		20 37 85	jsr $8537		jsr	AssembleGroup2
>a52c		60					.byte $60
>a52d		44					.byte $44
.a52e						Assemble_bit:
.a52e		20 37 85	jsr $8537		jsr	AssembleGroup2
>a531		20					.byte $20
>a532		55					.byte $55
.a533						Assemble_sty:
.a533		20 37 85	jsr $8537		jsr	AssembleGroup2
>a536		80					.byte $80
>a537		54					.byte $54
.a538						Assemble_ldy:
.a538		20 37 85	jsr $8537		jsr	AssembleGroup2
>a53b		a0					.byte $a0
>a53c		d5					.byte $d5
.a53d						Assemble_cpy:
.a53d		20 37 85	jsr $8537		jsr	AssembleGroup2
>a540		c0					.byte $c0
>a541		d4					.byte $d4
.a542						Assemble_cpx:
.a542		20 37 85	jsr $8537		jsr	AssembleGroup2
>a545		e0					.byte $e0
>a546		d0					.byte $d0
.a547						Assemble_tsb:
.a547		20 37 85	jsr $8537		jsr	AssembleGroup2
>a54a		00					.byte $00
>a54b		50					.byte $50
.a54c						Assemble_trb:
.a54c		20 37 85	jsr $8537		jsr	AssembleGroup2
>a54f		10					.byte $10
>a550		50					.byte $50
.a551						Assemble_jsr:
.a551		20 37 85	jsr $8537		jsr	AssembleGroup2
>a554		14					.byte $14
>a555		10					.byte $10
.a556						Assemble_jmp:
.a556		20 37 85	jsr $8537		jsr	AssembleGroup2
>a559		40					.byte $40
>a55a		10					.byte $10
.a55b						Assemble_bpl:
.a55b		20 88 85	jsr $8588		jsr	AssembleGroup3
>a55e		10					.byte $10
.a55f						Assemble_bmi:
.a55f		20 88 85	jsr $8588		jsr	AssembleGroup3
>a562		30					.byte $30
.a563						Assemble_bvc:
.a563		20 88 85	jsr $8588		jsr	AssembleGroup3
>a566		50					.byte $50
.a567						Assemble_bvs:
.a567		20 88 85	jsr $8588		jsr	AssembleGroup3
>a56a		70					.byte $70
.a56b						Assemble_bcc:
.a56b		20 88 85	jsr $8588		jsr	AssembleGroup3
>a56e		90					.byte $90
.a56f						Assemble_bcs:
.a56f		20 88 85	jsr $8588		jsr	AssembleGroup3
>a572		b0					.byte $b0
.a573						Assemble_bne:
.a573		20 88 85	jsr $8588		jsr	AssembleGroup3
>a576		d0					.byte $d0
.a577						Assemble_beq:
.a577		20 88 85	jsr $8588		jsr	AssembleGroup3
>a57a		f0					.byte $f0
.a57b						Assemble_bra:
.a57b		20 88 85	jsr $8588		jsr	AssembleGroup3
>a57e		80					.byte $80
.a57f						Assemble_brk:
.a57f		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a582		00					.byte $00
.a583						Assemble_php:
.a583		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a586		08					.byte $08
.a587						Assemble_clc:
.a587		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a58a		18					.byte $18
.a58b						Assemble_plp:
.a58b		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a58e		28					.byte $28
.a58f						Assemble_sec:
.a58f		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a592		38					.byte $38
.a593						Assemble_rti:
.a593		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a596		40					.byte $40
.a597						Assemble_pha:
.a597		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a59a		48					.byte $48
.a59b						Assemble_cli:
.a59b		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a59e		58					.byte $58
.a59f						Assemble_phy:
.a59f		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5a2		5a					.byte $5a
.a5a3						Assemble_rts:
.a5a3		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5a6		60					.byte $60
.a5a7						Assemble_pla:
.a5a7		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5aa		68					.byte $68
.a5ab						Assemble_sei:
.a5ab		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5ae		78					.byte $78
.a5af						Assemble_ply:
.a5af		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5b2		7a					.byte $7a
.a5b3						Assemble_dey:
.a5b3		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5b6		88					.byte $88
.a5b7						Assemble_txa:
.a5b7		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5ba		8a					.byte $8a
.a5bb						Assemble_tya:
.a5bb		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5be		98					.byte $98
.a5bf						Assemble_txs:
.a5bf		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5c2		9a					.byte $9a
.a5c3						Assemble_tay:
.a5c3		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5c6		a8					.byte $a8
.a5c7						Assemble_tax:
.a5c7		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5ca		aa					.byte $aa
.a5cb						Assemble_clv:
.a5cb		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5ce		b8					.byte $b8
.a5cf						Assemble_tsx:
.a5cf		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5d2		ba					.byte $ba
.a5d3						Assemble_iny:
.a5d3		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5d6		c8					.byte $c8
.a5d7						Assemble_dex:
.a5d7		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5da		ca					.byte $ca
.a5db						Assemble_cld:
.a5db		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5de		d8					.byte $d8
.a5df						Assemble_phx:
.a5df		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5e2		da					.byte $da
.a5e3						Assemble_stp:
.a5e3		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5e6		db					.byte $db
.a5e7						Assemble_inx:
.a5e7		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5ea		e8					.byte $e8
.a5eb						Assemble_nop:
.a5eb		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5ee		ea					.byte $ea
.a5ef						Assemble_sed:
.a5ef		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5f2		f8					.byte $f8
.a5f3						Assemble_plx:
.a5f3		20 bc 85	jsr $85bc		jsr	AssembleGroup4
>a5f6		fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.a5f7						DecimalScalarTable:
>a5f7		66 66 66 66				.dword $66666666 ; 0.1
>a5fb		de					.byte $de
>a5fc		1f 85 eb 51				.dword $51eb851f ; 0.01
>a600		db					.byte $db
>a601		4c 37 89 41				.dword $4189374c ; 0.001
>a605		d8					.byte $d8
>a606		ac 8b db 68				.dword $68db8bac ; 0.0001
>a60a		d4					.byte $d4
>a60b		24 d6 e2 53				.dword $53e2d624 ; 1e-05
>a60f		d1					.byte $d1
>a610		83 de 1b 43				.dword $431bde83 ; 1e-06
>a614		ce					.byte $ce
>a615		6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>a619		ca					.byte $ca
>a61a		89 3b e6 55				.dword $55e63b89 ; 1e-08
>a61e		c7					.byte $c7
>a61f		a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>a623		c4					.byte $c4
>a624		67 7f f3 6d				.dword $6df37f67 ; 1e-10
>a628		c0					.byte $c0
>a629		86 ff f5 57				.dword $57f5ff86 ; 1e-11
>a62d		bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.a62e						SyntaxError:
.a62e		a9 02		lda #$02		lda	#2
.a630		4c 4d 95	jmp $954d		jmp	ErrorHandler
.a633						RangeError:
.a633		a9 04		lda #$04		lda	#4
.a635		4c 4d 95	jmp $954d		jmp	ErrorHandler
.a638						TypeError:
.a638		a9 05		lda #$05		lda	#5
.a63a		4c 4d 95	jmp $954d		jmp	ErrorHandler
.a63d						ArgumentError:
.a63d		a9 07		lda #$07		lda	#7
.a63f		4c 4d 95	jmp $954d		jmp	ErrorHandler
.a642						NotDoneError:
.a642		a9 0c		lda #$0c		lda	#12
.a644		4c 4d 95	jmp $954d		jmp	ErrorHandler
.a647						ErrorText:
>a647		42 72 65 61 6b 00			.text	"Break",0
>a64d		53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a655		72 72 6f 72 00
>a65a		44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a662		20 62 79 20 7a 65 72 6f 00
>a66b		4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a673		61 6e 67 65 00
>a678		54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a680		6d 61 74 63 68 00
>a686		4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a68e		65 6d 6f 72 79 00
>a694		49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a69c		61 72 67 75 6d 65 6e 74 00
>a6a5		53 74 6f 70 00				.text	"Stop",0
>a6aa		53 74 72 69 6e 67 20 74			.text	"String too long",0
>a6b2		6f 6f 20 6c 6f 6e 67 00
>a6ba		41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a6c2		6e 20 66 61 69 6c 65 64 00
>a6cb		4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a6d3		61 74 61 00
>a6d7		55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a6df		65 6e 74 65 64 00
>a6e5		4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a6ed		6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a6f9		52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a701		69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a70e		55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a716		74 68 6f 75 74 20 52 65 70 65 61 74 00
>a723		57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a72b		68 6f 75 74 20 57 68 69 6c 65 00
>a736		4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a73e		68 6f 75 74 20 46 6f 72 00
>a747		42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a74f		61 63 6b 20 66 75 6c 6c 00
>a758		4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a760		75 63 74 75 72 65 00
>a767		45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a76f		77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a77c		41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a784		72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a792		41 72 72 61 79 20 73 69			.text	"Array size",0
>a79a		7a 65 00
>a79d		42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a7a5		79 20 69 6e 64 65 78 00
>a7ad		41 72 72 61 79 20 6e 6f			.text	"Array not declared",0
>a7b5		74 20 64 65 63 6c 61 72 65 64 00
>a7c0		46 69 6c 65 20 6e 6f 74			.text	"File not found",0
>a7c8		20 66 6f 75 6e 64 00
>a7cf		53 74 6f 72 61 67 65 20			.text	"Storage error",0
>a7d7		65 72 72 6f 72 00
>a7dd		56 65 72 69 66 79 20 66			.text	"Verify failed",0
>a7e5		61 69 6c 65 64 00
>a7eb		50 72 6f 67 72 61 6d 20			.text	"Program not found",0
>a7f3		6e 6f 74 20 66 6f 75 6e 64 00
>a7fd		54 6f 6f 20 6d 61 6e 79			.text	"Too many parameters",0
>a805		20 70 61 72 61 6d 65 74 65 72 73 00
>a811		46 6f 72 6d 75 6c 61 20			.text	"Formula too complex",0
>a819		74 6f 6f 20 63 6f 6d 70 6c 65 78 00
>a825		49 6e 69 74 69 61 6c 69			.text	"Initialization error",0
>a82d		7a 61 74 69 6f 6e 20 65 72 72 6f 72 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>e76b		09 09 32 31 2f 30 36 2f			.text 9,9,"21/06/25 01e"
>e773		32 35 20 30 31 65

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/delete.asm

.a83a						MemoryDeleteLine:
.a83a		20 59 a8	jsr $a859			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a83d		b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a83f		a8		tay				tay
.a840						_MDDLLoop:
.a840		b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a842		92 30		sta ($30)			sta 	(codePtr)
.a844		a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a846		c5 3a		cmp $3a				cmp 	zTemp2 						; has codePtr (copyFrom) reached the last byte to copy.
.a848		d0 07		bne $a851			bne 	_MDLDLNext
.a84a		a5 31		lda $31				lda 	codePtr+1
.a84c		c5 3b		cmp $3b				cmp 	zTemp2+1
.a84e		d0 01		bne $a851			bne 	_MDLDLNext
.a850						_MDDLExit:
.a850		60		rts				rts
.a851						_MDLDLNext:
.a851		e6 30		inc $30				inc 	codePtr						; next byte
.a853		d0 eb		bne $a840			bne 	_MDDLLoop
.a855		e6 31		inc $31				inc 	codePtr+1
.a857		80 e7		bra $a840			bra 	_MDDLLoop
.a859						IMemoryFindEnd:
.a859		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a85b		85 3a		sta $3a				sta 	0+zTemp2
.a85d		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a85f		85 3b		sta $3b				sta 	1+zTemp2
.a861						_MDLFELoop:
.a861		b2 3a		lda ($3a)			lda 	(zTemp2) 					; scan forward using offsets.
.a863		f0 0b		beq $a870			beq 	_MDLFEExit
.a865		18		clc				clc
.a866		65 3a		adc $3a				adc 	zTemp2
.a868		85 3a		sta $3a				sta 	zTemp2
.a86a		90 f5		bcc $a861			bcc 	_MDLFELoop
.a86c		e6 3b		inc $3b				inc 	zTemp2+1
.a86e		80 f1		bra $a861			bra 	_MDLFELoop
.a870						_MDLFEExit:
.a870		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/insert.asm

.a871						MemoryInsertLine:
.a871		08		php				php
.a872		20 59 a8	jsr $a859			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a875		a5 3b		lda $3b				lda 	zTemp2+1 					; is there space for the new line ?
.a877		1a		inc a				inc 	a
.a878		c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a87a		b0 36		bcs $a8b2			bcs 	_MDLIError 					; no, fail.
.a87c		28		plp				plp 								; do at a specific point or the end ?
.a87d		90 08		bcc $a887			bcc 	_MDLIFound 					; if specific point already set.
.a87f		a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append, so put on the
.a881		85 30		sta $30				sta 	codePtr 					; end.
.a883		a5 3b		lda $3b				lda 	zTemp2+1
.a885		85 31		sta $31				sta 	codePtr+1
.a887						_MDLIFound:
.a887		ad 46 04	lda $0446			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a88a		a8		tay				tay
.a88b						_MDLIInsert:
.a88b		b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case (copying link 0)
.a88d		91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a88f		a5 30		lda $30				lda 	codePtr 					; reached insert point ?
.a891		c5 3a		cmp $3a				cmp 	zTemp2
.a893		d0 06		bne $a89b			bne 	_MDLINext
.a895		a5 31		lda $31				lda 	codePtr+1
.a897		c5 3b		cmp $3b				cmp 	zTemp2+1
.a899		f0 0a		beq $a8a5			beq 	_MDLIHaveSpace
.a89b						_MDLINext:
.a89b		a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards opening up space.
.a89d		d0 02		bne $a8a1			bne 	_MDLINoBorrow
.a89f		c6 3b		dec $3b				dec 	zTemp2+1
.a8a1						_MDLINoBorrow:
.a8a1		c6 3a		dec $3a				dec 	zTemp2
.a8a3		80 e6		bra $a88b			bra 	_MDLIInsert
.a8a5						_MDLIHaveSpace:
.a8a5		ac 46 04	ldy $0446			ldy 	tokenOffset 				; bytes to copy
.a8a8		88		dey				dey 								; from offset-1 (last written) to the end of the buffer.
.a8a9						_MDLICopy:
.a8a9		b9 46 04	lda $0446,y			lda 	tokenOffset,y
.a8ac		91 30		sta ($30),y			sta 	(codePtr),y
.a8ae		88		dey				dey
.a8af		10 f8		bpl $a8a9			bpl 	_MDLICopy
.a8b1		60		rts				rts
.a8b2						_MDLIError:
.a8b2		a9 06		lda #$06		lda	#6
.a8b4		4c 4d 95	jmp $954d		jmp	ErrorHandler
.a8b7						MDLAppendLine:
.a8b7		86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a8b9		85 36		sta $36				sta 	zTemp0
.a8bb		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a8bd		85 38		sta $38				sta 	0+zTemp1
.a8bf		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a8c1		85 39		sta $39				sta 	1+zTemp1
.a8c3		b2 38		lda ($38)			lda 	(zTemp1)
.a8c5		d0 0a		bne $a8d1			bne 	_MDLANoInitialise
.a8c7		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a8c9		8d cb 07	sta $07cb			sta 	0+AppendPointer
.a8cc		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a8ce		8d cc 07	sta $07cc			sta 	1+AppendPointer
.a8d1						_MDLANoInitialise:
.a8d1		18		clc				clc
.a8d2		ad cb 07	lda $07cb			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a8d5		85 38		sta $38				sta 	zTemp1
.a8d7		72 36		adc ($36)			adc 	(zTemp0)
.a8d9		8d cb 07	sta $07cb			sta 	AppendPointer
.a8dc		ad cc 07	lda $07cc			lda 	AppendPointer+1
.a8df		85 39		sta $39				sta 	zTemp1+1
.a8e1		69 00		adc #$00			adc 	#0
.a8e3		8d cc 07	sta $07cc			sta 	AppendPointer+1
.a8e6		a0 00		ldy #$00			ldy 	#0
.a8e8						_MDLACopy:
.a8e8		b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a8ea		91 38		sta ($38),y			sta 	(zTemp1),y
.a8ec		c8		iny				iny
.a8ed		98		tya				tya
.a8ee		d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a8f0		d0 f6		bne $a8e8			bne 	_MDLACopy
.a8f2		a9 00		lda #$00			lda 	#0 							; end of program.
.a8f4		91 38		sta ($38),y			sta 	(zTemp1),y
.a8f6		60		rts				rts
.07cb						AppendPointer:
>07cb								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/memory.asm

.a8f7						MemoryNew:
.a8f7		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a8f9		85 30		sta $30				sta 	codePtr
.a8fb		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a8fd		85 31		sta $31				sta 	codePtr+1
.a8ff		a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a901		92 30		sta ($30)			sta 	(codePtr)
.a903		60		rts				rts
.a904						MemoryInline:
.a904		98		tya				tya 								; put address into stack,x
.a905		18		clc				clc  								; get the offset, add codePtr
.a906		65 30		adc $30				adc 	codePtr
.a908		95 60		sta $60,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a90a		a5 31		lda $31				lda 	codePtr+1
.a90c		69 00		adc #$00			adc 	#0
.a90e		95 70		sta $70,x			sta 	NSMantissa1,x
.a910		74 80		stz $80,x			stz 	NSMantissa2,x
.a912		74 90		stz $90,x			stz 	NSMantissa3,x
.a914		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/search.asm

.a915						MemorySearch:
.a915		85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a917		86 37		stx $37				stx 	zTemp0+1
.a919		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a91b		85 30		sta $30				sta 	codePtr
.a91d		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a91f		85 31		sta $31				sta 	codePtr+1
.a921						_MTAXLoop:
.a921		b2 30		lda ($30)			lda 	(codePtr)
.a923		18		clc				clc
.a924		f0 21		beq $a947			beq 	_MTAXExit 					; reached end, exit with CC.
.a926		a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a928		b1 30		lda ($30),y			lda 	(codePtr),y
.a92a		38		sec				sec
.a92b		e5 36		sbc $36				sbc 	zTemp0
.a92d		85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a92f		c8		iny				iny 								; do the MSB
.a930		b1 30		lda ($30),y			lda 	(codePtr),y
.a932		e5 37		sbc $37				sbc 	zTemp0+1
.a934		05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a936		f0 0f		beq $a947			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a938		b0 0d		bcs $a947			bcs 	_MTAXExit 					; current < required exit
.a93a		18		clc				clc
.a93b		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a93d		65 30		adc $30				adc 	codePtr
.a93f		85 30		sta $30				sta 	codePtr
.a941		90 02		bcc $a945			bcc 	_CREExit
.a943		e6 31		inc $31				inc 	codePtr+1 					; carry
.a945						_CREExit:
.a945		80 da		bra $a921			bra 	_MTAXLoop
.a947						_MTAXExit:
.a947		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gcommand.asm

.a948						RectangleCommand:
.a948		a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a94a		80 02		bra $a94e			bra 	ShapeDrawCmd
.a94c						CircleCommand:
.a94c		a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a94e						ShapeDrawCmd:
.a94e		20 d8 a9	jsr $a9d8			jsr 	RunGraphicsCommand
.a951						ShapeDraw:
.a951		0d ce 07	ora $07ce			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a954		4c cc a9	jmp $a9cc			jmp 	ExecuteGraphicCommand	 	; and complete
.a957						SpriteCommand:
.a957		a2 00		ldx #$00			ldx 	#0
.a959		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; get image number.
.a95c		5a		phy				phy
.a95d		a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a95f		a6 60		ldx $60				ldx 	NSMantissa0
.a961		e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a963		b0 0d		bcs $a972			bcs 	_SCRange
.a965		a0 ff		ldy #$ff			ldy 	#255
.a967		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.a96a		a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a96c		7a		ply				ply
.a96d		20 d8 a9	jsr $a9d8			jsr 	RunGraphicsCommand
.a970		80 5a		bra $a9cc			bra 	ExecuteGraphicCommand
.a972						_SCRange:
.a972		4c 33 a6	jmp $a633			jmp 	RangeError
.a975						ImageCommand:
.a975		a2 00		ldx #$00			ldx 	#0
.a977		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; get image number.
.a97a		20 d8 a9	jsr $a9d8			jsr 	RunGraphicsCommand
.a97d						ImageRunDraw:
.a97d		09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a97f		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.a982		ad d4 07	lda $07d4			lda 	gxDrawScale
.a985		0a		asl a				asl 	a
.a986		0a		asl a				asl 	a
.a987		0a		asl a				asl 	a
.a988		a8		tay				tay
.a989		a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a98b		a6 60		ldx $60				ldx 	NSMantissa0
.a98d		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.a990		60		rts				rts
.a991						TextCommand:
.a991		a2 00		ldx #$00			ldx 	#0
.a993		20 0e a4	jsr $a40e			jsr 	EvaluateString 				; get text
.a996		20 d8 a9	jsr $a9d8			jsr 	RunGraphicsCommand
.a999						TextRunDraw:
.a999		09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a99b		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.a99e		a0 00		ldy #$00			ldy 	#0
.a9a0						_IRDLoop:
.a9a0		a5 70		lda $70				lda 	NSMantissa1 				; access character
.a9a2		85 37		sta $37				sta 	zTemp0+1
.a9a4		a5 60		lda $60				lda 	NSMantissa0
.a9a6		85 36		sta $36				sta 	zTemp0
.a9a8		b1 36		lda ($36),y			lda 	(zTemp0),y
.a9aa		f0 13		beq $a9bf			beq 	_IRDExit
.a9ac		5a		phy				phy									; save string pos
.a9ad		48		pha				pha 								; save char
.a9ae		ad d4 07	lda $07d4			lda 	gxDrawScale 				; get scale
.a9b1		0a		asl a				asl 	a
.a9b2		0a		asl a				asl 	a
.a9b3		0a		asl a				asl 	a
.a9b4		a8		tay				tay
.a9b5		a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a9b7		fa		plx				plx 								; char to draw
.a9b8		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.a9bb		7a		ply				ply 								; restore string pos
.a9bc		c8		iny				iny
.a9bd		90 e1		bcc $a9a0			bcc 	_IRDLoop 					; go back if no error.
.a9bf						_IRDExit:
.a9bf		60		rts				rts
.a9c0						PlotCommand:
.a9c0		a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a9c2		20 d8 a9	jsr $a9d8			jsr 	RunGraphicsCommand
.a9c5		80 05		bra $a9cc			bra 	ExecuteGraphicCommand
.a9c7						LineCommand:
.a9c7		a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a9c9		20 d8 a9	jsr $a9d8			jsr 	RunGraphicsCommand
.a9cc						ExecuteGraphicCommand:
.a9cc		0d cd 07	ora $07cd			ora 	gxCommandID 				; make a full command
.a9cf		20 9d 80	jsr $809d			jsr 	GXGraphicDraw 				; draw it and exit
.a9d2		b0 01		bcs $a9d5			bcs 	_EGCError
.a9d4		60		rts				rts
.a9d5						_EGCError:
.a9d5		4c 2e a6	jmp $a62e			jmp 	SyntaxError
.a9d8						RunGraphicsCommand:
.a9d8		8d cd 07	sta $07cd			sta 	gxCommandID					; save TODO graphics command.
.a9db		68		pla				pla 								; pop handler address
.a9dc		fa		plx				plx
.a9dd		1a		inc a				inc 	a
.a9de		d0 01		bne $a9e1			bne 	_RGINoCarry
.a9e0		e8		inx				inx
.a9e1						_RGINoCarry:
.a9e1		8d d2 07	sta $07d2			sta 	gxHandler
.a9e4		8e d3 07	stx $07d3			stx 	gxHandler+1
.a9e7						_RGICommandLoop:
.a9e7		b1 30		lda ($30),y			lda 	(codePtr),y
.a9e9		c8		iny				iny
.a9ea		c9 dd		cmp #$dd			cmp 	#KWD_TO						; is it TO x,y
.a9ec		f0 53		beq $aa41			beq 	_RGI_To
.a9ee		c9 c6		cmp #$c6			cmp 	#KWD_HERE 					; do it here.
.a9f0		f0 55		beq $aa47			beq 	_RGI_Here
.a9f2		c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a9f4		f0 3d		beq $aa33			beq 	_RGI_Exit
.a9f6		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a9f8		f0 39		beq $aa33			beq 	_RGI_Exit
.a9fa		c9 ce		cmp #$ce			cmp 	#KWD_OUTLINE 				; solid or outline
.a9fc		f0 3e		beq $aa3c			beq 	_RGI_Frame
.a9fe		c9 d8		cmp #$d8			cmp 	#KWD_SOLID
.aa00		f0 33		beq $aa35			beq 	_RGI_Solid
.aa02		c9 ba		cmp #$ba			cmp 	#KWD_BY 					; by offset
.aa04		f0 4b		beq $aa51			beq 	_RGI_By
.aa06		c9 c4		cmp #$c4			cmp 	#KWD_FROM 					; from
.aa08		f0 17		beq $aa21			beq 	_RGI_Move2
.aa0a		c9 c1		cmp #$c1			cmp 	#KWD_DIM 					; dim (set scale)
.aa0c		f0 62		beq $aa70			beq 	_RGI_Dim
.aa0e		c9 bf		cmp #$bf			cmp 	#KWD_COLOUR 				; colour or Color
.aa10		f0 74		beq $aa86			beq 	_RGI_Colour
.aa12		c9 be		cmp #$be			cmp 	#KWD_COLOR
.aa14		f0 70		beq $aa86			beq 	_RGI_Colour
.aa16		ae cd 07	ldx $07cd			ldx 	gxCommandID
.aa19		e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.aa1b		d0 03		bne $aa20			bne 	_RGI_Move 					; move
.aa1d		4c ae aa	jmp $aaae			jmp		_RGI_SpriteInstructions
.aa20						_RGI_Move:
.aa20		88		dey				dey 								; unpick get.
.aa21						_RGI_Move2:
.aa21		20 d4 aa	jsr $aad4			jsr 	GCGetCoordinatePair 		; move to here
.aa24		20 fb aa	jsr $aafb			jsr 	GCCopyPairToStore 			; save
.aa27		5a		phy				phy
.aa28		20 f1 aa	jsr $aaf1			jsr 	GCLoadAXY 					; load in
.aa2b		09 40		ora #$40			ora 	#GCMD_Move 					; move there
.aa2d		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.aa30		7a		ply				ply
.aa31		80 b4		bra $a9e7			bra 	_RGICommandLoop 			; and go round
.aa33						_RGI_Exit:
.aa33		88		dey				dey 								; unpick : / EOL
.aa34		60		rts				rts
.aa35						_RGI_Solid:
.aa35		a9 02		lda #$02			lda 	#2
.aa37		8d ce 07	sta $07ce			sta 	gxFillSolid
.aa3a		80 ab		bra $a9e7			bra 	_RGICommandLoop
.aa3c						_RGI_Frame:
.aa3c		9c ce 07	stz $07ce			stz 	gxFillSolid
.aa3f		80 a6		bra $a9e7			bra 	_RGICommandLoop
.aa41						_RGI_To:
.aa41		20 d4 aa	jsr $aad4			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.aa44		20 fb aa	jsr $aafb			jsr 	GCCopyPairToStore
.aa47						_RGI_Here:
.aa47		5a		phy				phy
.aa48		20 f1 aa	jsr $aaf1			jsr 	GCLoadAXY 					; load it into AXY
.aa4b		20 ab aa	jsr $aaab			jsr 	_RGICallHandler 			; go do whatever it is.
.aa4e		7a		ply				ply
.aa4f		80 96		bra $a9e7			bra 	_RGICommandLoop 			; and go round
.aa51						_RGI_By:
.aa51		20 e1 aa	jsr $aae1			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.aa54		18		clc				clc
.aa55		a5 61		lda $61				lda 	NSMantissa0+1 				; copy it into space.
.aa57		6d cf 07	adc $07cf			adc 	gxXPos
.aa5a		8d cf 07	sta $07cf			sta 	gxXPos
.aa5d		a5 71		lda $71				lda 	NSMantissa1+1
.aa5f		6d d0 07	adc $07d0			adc 	gxXPos+1
.aa62		8d d0 07	sta $07d0			sta 	gxXPos+1
.aa65		a5 62		lda $62				lda 	NSMantissa0+2
.aa67		18		clc				clc
.aa68		6d d1 07	adc $07d1			adc 	gxYPos
.aa6b		8d d1 07	sta $07d1			sta 	gxYPos
.aa6e		80 d7		bra $aa47			bra 	_RGI_Here
.aa70						_RGI_Dim:
.aa70		a2 01		ldx #$01			ldx	 	#1
.aa72		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.aa75		a5 61		lda $61				lda 	NSMantissa0+1
.aa77		c9 00		cmp #$00			cmp 	#0
.aa79		f0 2d		beq $aaa8			beq 	_RGIRange
.aa7b		c9 09		cmp #$09			cmp 	#8+1
.aa7d		b0 29		bcs $aaa8			bcs		_RGIRange
.aa7f		3a		dec a				dec 	a
.aa80		8d d4 07	sta $07d4			sta 	gxDrawScale
.aa83		4c e7 a9	jmp $a9e7			jmp 	_RGICommandLoop
.aa86						_RGI_Colour:
.aa86		a2 01		ldx #$01			ldx 	#1 							; colour
.aa88		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.aa8b		a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.aa8d		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero
.aa90		b1 30		lda ($30),y			lda 	(codePtr),y
.aa92		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.aa94		d0 04		bne $aa9a			bne 	_RGICDefaultMode
.aa96		c8		iny				iny
.aa97		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.aa9a						_RGICDefaultMode:
.aa9a		5a		phy				phy
.aa9b		a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.aa9d		a6 61		ldx $61				ldx 	NSMantissa0+1
.aa9f		a4 62		ldy $62				ldy 	NSMantissa0+2
.aaa1		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.aaa4		7a		ply				ply
.aaa5		4c e7 a9	jmp $a9e7			jmp 	_RGICommandLoop 			; and go round
.aaa8						_RGIRange:
.aaa8		4c 33 a6	jmp $a633			jmp 	RangeError
.aaab						_RGICallHandler:
.aaab		6c d2 07	jmp ($07d2)			jmp 	(gxHandler)
.aaae						_RGI_SpriteInstructions:
.aaae		c9 cc		cmp #$cc			cmp 	#KWD_OFF
.aab0		f0 07		beq $aab9			beq 	_RGISpriteOff
.aab2		c9 c7		cmp #$c7			cmp 	#KWD_IMAGE
.aab4		f0 13		beq $aac9			beq 	_RGISetImage
.aab6		4c 20 aa	jmp $aa20			jmp 	_RGI_Move
.aab9						_RGISpriteOff:
.aab9		5a		phy				phy
.aaba		a0 01		ldy #$01			ldy 	#1
.aabc		a2 00		ldx #$00			ldx 	#0
.aabe						_RGIDoCommandLoop:
.aabe		a9 10		lda #$10			lda 	#GCMD_SpriteImage
.aac0		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.aac3		7a		ply				ply
.aac4		b0 e2		bcs $aaa8			bcs 	_RGIRange
.aac6		4c e7 a9	jmp $a9e7			jmp 	_RGICommandLoop
.aac9						_RGISetImage:
.aac9		a2 01		ldx #$01			ldx 	#1
.aacb		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.aace		5a		phy				phy
.aacf		aa		tax				tax
.aad0		a0 00		ldy #$00			ldy 	#0
.aad2		80 ea		bra $aabe			bra 	_RGIDoCommandLoop
.aad4						GCGetCoordinatePair:
.aad4		a2 01		ldx #$01			ldx 	#1
.aad6		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger
.aad9		20 3c 95	jsr $953c			jsr 	CheckComma
.aadc		e8		inx				inx
.aadd		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger
.aae0		60		rts				rts
.aae1						GCSignedCoordinatePair:
.aae1		a2 01		ldx #$01			ldx 	#1
.aae3		20 40 a4	jsr $a440			jsr 	Evaluate16BitIntegerSigned
.aae6		20 3c 95	jsr $953c			jsr 	CheckComma
.aae9		e8		inx				inx
.aaea		20 40 a4	jsr $a440			jsr 	Evaluate16BitIntegerSigned
.aaed		60		rts				rts
.aaee						_GCCPRange:
.aaee		4c 33 a6	jmp $a633			jmp 	RangeError
.aaf1						GCLoadAXY:
.aaf1		ad d0 07	lda $07d0			lda 	gxXPos+1
.aaf4		ae cf 07	ldx $07cf			ldx 	gxXPos
.aaf7		ac d1 07	ldy $07d1			ldy 	gxYPos
.aafa		60		rts				rts
.aafb						GCCopyPairToStore:
.aafb		a5 61		lda $61				lda 	NSMantissa0+1 				; copy it into space.
.aafd		8d cf 07	sta $07cf			sta 	gxXPos
.ab00		a5 71		lda $71				lda 	NSMantissa1+1
.ab02		8d d0 07	sta $07d0			sta 	gxXPos+1
.ab05		a5 62		lda $62				lda 	NSMantissa0+2
.ab07		8d d1 07	sta $07d1			sta 	gxYPos
.ab0a		60		rts				rts
.07cd						gxCommandID:
>07cd								.fill 	1
.07ce						gxFillSolid:
>07ce								.fill 	1
.07cf						gxXPos:
>07cf								.fill 	2
.07d1						gxYPos:
>07d1								.fill 	1
.07d2						gxHandler:
>07d2								.fill 	2
.07d4						gxDrawScale:
>07d4								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gcontrol.asm

.ab0b						ResetBitmapSpritesTiles:
.ab0b		9c d5 07	stz $07d5			stz 	BitmapPageNumber
.ab0e		9c d6 07	stz $07d6			stz 	SpritePageNumber
.ab11		9c d7 07	stz $07d7			stz 	TileMapPageNumber
.ab14		9c d8 07	stz $07d8			stz 	TileImagePageNumber
.ab17		a9 40		lda #$40			lda 	#64
.ab19		8d d9 07	sta $07d9			sta 	TileMapWidth
.ab1c		a9 20		lda #$20			lda 	#32
.ab1e		8d da 07	sta $07da			sta 	TileMapHeight
.ab21		60		rts				rts
.ab22						BitmapCtrl:
.ab22						BitmapCtrlLoop:
.ab22		b1 30		lda ($30),y			lda 	(codePtr),y
.ab24		c8		iny				iny
.ab25		a2 01		ldx #$01			ldx 	#1
.ab27		c9 cd		cmp #$cd			cmp 	#KWD_ON
.ab29		f0 24		beq $ab4f			beq 	BitmapSwitch
.ab2b		ca		dex				dex
.ab2c		c9 cc		cmp #$cc			cmp 	#KWD_OFF
.ab2e		f0 1f		beq $ab4f			beq 	BitmapSwitch
.ab30		c9 b9		cmp #$b9			cmp 	#KWD_AT  					; set address
.ab32		f0 13		beq $ab47			beq 	BitmapAddress
.ab34		c9 bd		cmp #$bd			cmp 	#KWD_CLEAR
.ab36		f0 02		beq $ab3a			beq 	BitmapClear
.ab38		88		dey				dey
.ab39		60		rts				rts
.ab3a						BitmapClear:
.ab3a		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; get the colour
.ab3d		5a		phy				phy
.ab3e		aa		tax				tax
.ab3f		a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.ab41		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ab44		7a		ply				ply
.ab45		80 db		bra $ab22			bra 	BitmapCtrlLoop
.ab47						BitmapAddress:
.ab47		20 13 ac	jsr $ac13			jsr 	GetPageNumber
.ab4a		8d d5 07	sta $07d5			sta 	BitmapPageNumber
.ab4d		80 d3		bra $ab22			bra 	BitmapCtrlLoop
.ab4f						BitmapSwitch:
.ab4f		5a		phy				phy
.ab50		ac d5 07	ldy $07d5			ldy 	BitmapPageNumber 			; gfx 1,on/off,0
.ab53		a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.ab55		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ab58		a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.ab5a		a0 00		ldy #$00			ldy 	#0
.ab5c		a2 ff		ldx #$ff			ldx 	#$FF
.ab5e		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ab61		9c ce 07	stz $07ce			stz 	gxFillSolid
.ab64		9c cf 07	stz $07cf			stz 	gxXPos
.ab67		9c d0 07	stz $07d0			stz 	gxXPos+1
.ab6a		9c d1 07	stz $07d1			stz 	gxYPos
.ab6d		9c d4 07	stz $07d4			stz 	gxDrawScale
.ab70		a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.ab72		a2 00		ldx #$00			ldx 	#0
.ab74		a0 00		ldy #$00			ldy 	#0
.ab76		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ab79		7a		ply				ply
.ab7a		80 a6		bra $ab22			bra 	BitmapCtrlLoop
.ab7c						SpritesCtrl:
.ab7c						SpritesCtrlLoop:
.ab7c		b1 30		lda ($30),y			lda 	(codePtr),y
.ab7e		c8		iny				iny
.ab7f		a2 01		ldx #$01			ldx 	#1
.ab81		c9 cd		cmp #$cd			cmp 	#KWD_ON
.ab83		f0 13		beq $ab98			beq 	SpriteSwitch
.ab85		ca		dex				dex
.ab86		c9 cc		cmp #$cc			cmp 	#KWD_OFF
.ab88		f0 0e		beq $ab98			beq 	SpriteSwitch
.ab8a		c9 b9		cmp #$b9			cmp 	#KWD_AT
.ab8c		f0 02		beq $ab90			beq 	SpriteSetAddress
.ab8e		88		dey				dey
.ab8f		60		rts				rts
.ab90						SpriteSetAddress:
.ab90		20 13 ac	jsr $ac13			jsr 	GetPageNumber
.ab93		8d d6 07	sta $07d6			sta 	SpritePageNumber
.ab96		80 e4		bra $ab7c			bra 	SpritesCtrlLoop
.ab98						SpriteSwitch:
.ab98		5a		phy				phy
.ab99		ac d6 07	ldy $07d6			ldy 	SpritePageNumber 			; gfx 2,on/off,0
.ab9c		a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.ab9e		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.aba1		7a		ply				ply
.aba2		80 d8		bra $ab7c			bra 	SpritesCtrlLoop
.aba4						TilesCtrl:
.aba4						TilesCtrlLoop:
.aba4		b1 30		lda ($30),y			lda 	(codePtr),y
.aba6		c8		iny				iny
.aba7		a2 80		ldx #$80			ldx 	#$80
.aba9		c9 cd		cmp #$cd			cmp 	#KWD_ON
.abab		f0 34		beq $abe1			beq 	TileSwitch
.abad		a2 00		ldx #$00			ldx 	#$00
.abaf		c9 cc		cmp #$cc			cmp 	#KWD_OFF
.abb1		f0 2e		beq $abe1			beq 	TileSwitch
.abb3		c9 b9		cmp #$b9			cmp 	#KWD_AT
.abb5		f0 19		beq $abd0			beq 	TileSetAddress
.abb7		c9 c1		cmp #$c1			cmp 	#KWD_DIM
.abb9		f0 02		beq $abbd			beq 	TileSetSize
.abbb		88		dey				dey
.abbc		60		rts				rts
.abbd						TileSetSize:
.abbd		a2 00		ldx #$00			ldx 	#0
.abbf		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.abc2		8d d9 07	sta $07d9			sta 	TileMapWidth
.abc5		20 3c 95	jsr $953c			jsr 	CheckComma
.abc8		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.abcb		8d da 07	sta $07da			sta 	TileMapHeight
.abce		80 d4		bra $aba4			bra 	TilesCtrlLoop
.abd0						TileSetAddress:
.abd0		20 13 ac	jsr $ac13			jsr 	GetPageNumber 				; map page
.abd3		8d d7 07	sta $07d7			sta 	TileMapPageNumber
.abd6		20 3c 95	jsr $953c			jsr 	CheckComma
.abd9		20 13 ac	jsr $ac13			jsr 	GetPageNumber 				; image page
.abdc		8d d8 07	sta $07d8			sta 	TileImagePageNumber
.abdf		80 c3		bra $aba4			bra 	TilesCtrlLoop
.abe1						TileSwitch:
.abe1		5a		phy				phy
.abe2		da		phx				phx 								; set the on/off state and the pages.
.abe3		8a		txa				txa
.abe4		0d d7 07	ora $07d7			ora 	TileMapPageNumber
.abe7		aa		tax				tax
.abe8		ac d8 07	ldy $07d8			ldy 	TileImagePageNumber
.abeb		a9 14		lda #$14			lda 	#GCMD_TileCtl
.abed		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.abf0		fa		plx				plx
.abf1		10 b1		bpl $aba4			bpl 	TilesCtrlLoop 				; nothing else.
.abf3		a9 16		lda #$16			lda 	#GCMD_TileSize 				; set size of tile map.
.abf5		ae d9 07	ldx $07d9			ldx 	TileMapWidth
.abf8		ac da 07	ldy $07da			ldy 	TileMapHeight
.abfb		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.abfe		a9 18		lda #$18			lda 	#GCMD_TileScrollX 			; reset scroll
.ac00		20 0c ac	jsr $ac0c			jsr 	_TileResetScroll
.ac03		a9 1a		lda #$1a			lda 	#GCMD_TileScrollY
.ac05		20 0c ac	jsr $ac0c			jsr 	_TileResetScroll
.ac08		7a		ply				ply
.ac09		4c a4 ab	jmp $aba4			jmp 	TilesCtrlLoop
.ac0c						_TileResetScroll:
.ac0c		a2 00		ldx #$00			ldx 	#0
.ac0e		a0 00		ldy #$00			ldy 	#0
.ac10		4c 9d 80	jmp $809d			jmp 	GXGraphicDraw
.ac13						GetPageNumber:
.ac13		a2 00		ldx #$00			ldx 	#0
.ac15		20 2b a4	jsr $a42b			jsr 	EvaluateUnsignedInteger 	; evaluate where to go.
.ac18		a5 70		lda $70				lda 	NSMantissa1 				; check on page
.ac1a		29 1f		and #$1f			and 	#$1F
.ac1c		05 60		ora $60				ora 	NSMantissa0
.ac1e		d0 0c		bne $ac2c			bne 	_GPNError
.ac20		a5 80		lda $80				lda 	NSMantissa2
.ac22		06 70		asl $70				asl 	NSMantissa1					; get page number
.ac24		2a		rol a				rol 	a
.ac25		06 70		asl $70				asl 	NSMantissa1
.ac27		2a		rol a				rol 	a
.ac28		06 70		asl $70				asl 	NSMantissa1
.ac2a		2a		rol a				rol 	a
.ac2b		60		rts				rts
.ac2c						_GPNError:
.ac2c		a9 07		lda #$07		lda	#7
.ac2e		4c 4d 95	jmp $954d		jmp	ErrorHandler
.07d5						BitmapPageNumber:
>07d5								.fill 	1
.07d6						SpritePageNumber:
>07d6								.fill 	1
.07d7						TileMapPageNumber:
>07d7								.fill 	1
.07d8						TileImagePageNumber:
>07d8								.fill 	1
.07d9						TileMapWidth:
>07d9								.fill 	1
.07da						TileMapHeight:
>07da								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gfx.asm

.ac31						GfxCommand:
.ac31		a2 00		ldx #$00			ldx 	#0
.ac33		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; command
.ac36		20 3c 95	jsr $953c			jsr 	CheckComma
.ac39		e8		inx				inx
.ac3a		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger 		; X
.ac3d		20 3c 95	jsr $953c			jsr 	CheckComma
.ac40		e8		inx				inx
.ac41		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; Y
.ac44		a5 71		lda $71				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.ac46		4a		lsr a				lsr 	a
.ac47		d0 12		bne $ac5b			bne 	_GfxError
.ac49		26 60		rol $60				rol 	NSMantissa0 				; rotate into command
.ac4b		b0 0e		bcs $ac5b			bcs 	_GfxError 					; bit 7 should have been zero
.ac4d		5a		phy				phy 								; save pos
.ac4e		a5 60		lda $60				lda 	NSMantissa0 				; do the command
.ac50		a6 61		ldx $61				ldx 	NSMantissa0+1
.ac52		a4 62		ldy $62				ldy 	NSMantissa0+2
.ac54		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ac57		b0 02		bcs $ac5b			bcs 	_GfxError
.ac59		7a		ply				ply 								; restore pos and exit.
.ac5a		60		rts				rts
.ac5b						_GfxError:
.ac5b		4c 33 a6	jmp $a633			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/hit.asm

.ac5e						UnaryHit:
.ac5e		fa		plx				plx
.ac5f		a9 36		lda #$36			lda 	#zTemp0
.ac61		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; get sprite number 0
.ac64		20 3c 95	jsr $953c			jsr 	CheckComma
.ac67		e8		inx				inx
.ac68		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; get sprite number 1
.ac6b		20 34 95	jsr $9534			jsr		CheckRightBracket
.ac6e		ca		dex				dex 								; fix back up again.
.ac6f		da		phx				phx 								; save X/Y
.ac70		5a		phy				phy
.ac71		b4 61		ldy $61,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.ac73		b5 60		lda $60,x			lda 	NSMantissa0,x
.ac75		aa		tax				tax
.ac76		a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.ac78		20 9d 80	jsr $809d			jsr 	GXGraphicDraw 				; calculate result
.ac7b		1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.ac7c		7a		ply				ply 								; restore XY
.ac7d		fa		plx				plx
.ac7e		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte 					; return the hit result
.ac81		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/palette.asm

.ac82						PaletteCommand:
.ac82		a2 00		ldx #$00			ldx 	#0
.ac84		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; colour
.ac87		20 3c 95	jsr $953c			jsr 	CheckComma
.ac8a		e8		inx				inx
.ac8b		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger 		; r
.ac8e		20 3c 95	jsr $953c			jsr 	CheckComma
.ac91		e8		inx				inx
.ac92		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; g
.ac95		20 3c 95	jsr $953c			jsr 	CheckComma
.ac98		e8		inx				inx
.ac99		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; b
.ac9c		a5 60		lda $60				lda 	NSMantissa0 				; get colour #
.ac9e		85 36		sta $36				sta 	zTemp0
.aca0		a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.aca2		85 37		sta $37				sta 	zTemp0+1
.aca4		06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.aca6		26 37		rol $37				rol	 	zTemp0+1
.aca8		06 36		asl $36				asl 	zTemp0
.acaa		26 37		rol $37				rol	 	zTemp0+1
.acac		a9 01		lda #$01			lda 	#1 							; I/O Page 2
.acae		85 01		sta $01				sta 	1
.acb0		5a		phy				phy
.acb1		a5 63		lda $63				lda 	NSMantissa0+3 				; fix to r,g,b
.acb3		92 36		sta ($36)			sta 	(zTemp0)
.acb5		a0 01		ldy #$01			ldy 	#1
.acb7		a5 62		lda $62				lda 	NSMantissa0+2
.acb9		91 36		sta ($36),y			sta 	(zTemp0),y
.acbb		a5 61		lda $61				lda 	NSMantissa0+1
.acbd		c8		iny				iny
.acbe		91 36		sta ($36),y			sta 	(zTemp0),y
.acc0		7a		ply				ply
.acc1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/tile.asm

.acc2						TileCommand:
.acc2		b1 30		lda ($30),y			lda 	(codePtr),y
.acc4		c8		iny				iny
.acc5		c9 b9		cmp #$b9			cmp 	#KWD_AT
.acc7		f0 0a		beq $acd3			beq 	_TileSetPos
.acc9		c9 d0		cmp #$d0			cmp 	#KWD_PLOT
.accb		f0 15		beq $ace2			beq 	_TilePlot
.accd		c9 dd		cmp #$dd			cmp 	#KWD_TO
.accf		f0 40		beq $ad11			beq 	_TileScroll
.acd1		88		dey				dey
.acd2		60		rts				rts
.acd3						_TileSetPos:
.acd3		a2 00		ldx #$00			ldx 	#0 							; location to XA
.acd5		20 31 ad	jsr $ad31			jsr 	TileGetPair
.acd8		5a		phy				phy 								; call routine
.acd9		a8		tay				tay
.acda		a9 1c		lda #$1c			lda 	#GCMD_TilePos
.acdc		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.acdf		7a		ply				ply
.ace0		80 e0		bra $acc2			bra 	TileCommand 				; loop round
.ace2						_TilePlot:
.ace2		a2 00		ldx #$00			ldx 	#0
.ace4		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; tile to print
.ace7		a9 01		lda #$01			lda 	#1
.ace9		85 61		sta $61				sta 	NSMantissa0+1 				; default repeat count.
.aceb		a2 01		ldx #$01			ldx 	#1
.aced		b1 30		lda ($30),y			lda 	(codePtr),y
.acef		c9 c9		cmp #$c9			cmp 	#KWD_LINE
.acf1		d0 04		bne $acf7			bne 	_TileNoRepeat
.acf3		c8		iny				iny 								; skip LINE
.acf4		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; evaluate count
.acf7						_TileNoRepeat:
.acf7						_TileOutLoop:
.acf7		a5 61		lda $61				lda 	NSMantissa0+1 				; complete ?
.acf9		f0 0d		beq $ad08			beq 	_TileCheckAgain 			; check , <repeats>
.acfb		c6 61		dec $61				dec 	NSMantissa0+1 				; dec count
.acfd		a9 1e		lda #$1e			lda 	#GCMD_TileWrite				; set up to write tile.
.acff		a6 60		ldx $60				ldx 	NSMantissa0
.ad01		5a		phy				phy 								; call preserving Y
.ad02		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ad05		7a		ply				ply
.ad06		80 ef		bra $acf7			bra 	_TileOutLoop
.ad08						_TileCheckAgain:
.ad08		b1 30		lda ($30),y			lda 	(codePtr),y
.ad0a		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.ad0c		d0 b4		bne $acc2			bne 	TileCommand 				; no, do again
.ad0e		c8		iny				iny 								; consume comma
.ad0f		80 d1		bra $ace2			bra 	_TilePlot 					; and loop round.
.ad11						_TileScroll:
.ad11		a9 18		lda #$18			lda 	#GCMD_TileScrollX 			; do X
.ad13		20 20 ad	jsr $ad20			jsr 	_TileSetScroll
.ad16		20 3c 95	jsr $953c			jsr 	CheckComma
.ad19		a9 1a		lda #$1a			lda 	#GCMD_TileScrollY 			; do Y
.ad1b		20 20 ad	jsr $ad20			jsr 	_TileSetScroll
.ad1e		80 a2		bra $acc2			bra 	TileCommand
.ad20						_TileSetScroll:
.ad20		48		pha				pha 								; save command on stack
.ad21		a2 00		ldx #$00			ldx 	#0 							; get value to scroll to
.ad23		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger
.ad26		68		pla				pla 								; restore command
.ad27		5a		phy				phy 								; save Y code pos
.ad28		a6 60		ldx $60				ldx 	NSMantissa0 				; YX = scroll value
.ad2a		a4 70		ldy $70				ldy 	NSMantissa1
.ad2c		20 9d 80	jsr $809d			jsr 	GXGraphicDraw 				; do command
.ad2f		7a		ply				ply 								; restore code pos
.ad30		60		rts				rts
.ad31						TileGetPair:
.ad31		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.ad34		48		pha				pha
.ad35		20 3c 95	jsr $953c			jsr 	CheckComma
.ad38		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.ad3b		fa		plx				plx
.ad3c		60		rts				rts
.ad3d						TileRead:
.ad3d		fa		plx				plx 								; current stack pos (where the result goes)
.ad3e		da		phx				phx 								; save it back again
.ad3f		e8		inx				inx   								; space to evaluate coordinates
.ad40		20 31 ad	jsr $ad31			jsr 	TileGetPair 				; X A are the coordinates
.ad43		5a		phy				phy 								; save code position
.ad44		a8		tay				tay 								; X Y are the coordinates.
.ad45		a9 1c		lda #$1c			lda 	#GCMD_TilePos 				; set the read position.
.ad47		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ad4a		a9 20		lda #$20			lda 	#GCMD_TileRead 				; read the tile there
.ad4c		20 9d 80	jsr $809d			jsr 	GXGraphicDraw
.ad4f		7a		ply				ply 								; restore code and stack positions
.ad50		fa		plx				plx
.ad51		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte 					; set the result.
.ad54		20 34 95	jsr $9534			jsr 	CheckRightBracket 			; check for )
.ad57		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/hardware/cls.asm

.ad58						ClearScreen:
.ad58		5a		phy				phy
.ad59		a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.ad5b		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.ad5e		7a		ply				ply
.ad5f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/hardware/cursor.asm

.ad60						CursorControl:
.ad60		a2 00		ldx #$00			ldx 	#0
.ad62		b1 30		lda ($30),y			lda 	(codePtr),y
.ad64		c8		iny				iny
.ad65		c9 cc		cmp #$cc			cmp 	#KWD_OFF
.ad67		f0 08		beq $ad71			beq 	_CCOnOff
.ad69		e8		inx				inx
.ad6a		c9 cd		cmp #$cd			cmp 	#KWD_ON
.ad6c		f0 03		beq $ad71			beq 	_CCOnOff
.ad6e		4c 2e a6	jmp $a62e			jmp 	SyntaxError
.ad71						_CCOnOff:
.ad71		a5 01		lda $01				lda 	1 							; save current I/O
.ad73		48		pha				pha
.ad74		64 01		stz $01				stz 	1 		 					; page 0.
.ad76		ad 10 d0	lda $d010			lda 	$D010 						; read Cursor control register
.ad79		29 fe		and #$fe			and 	#$FE 						; clear enable bit
.ad7b		86 36		stx $36				stx 	zTemp0 						; put bit back in
.ad7d		05 36		ora $36				ora 	zTemp0
.ad7f		8d 10 d0	sta $d010			sta 	$D010
.ad82		68		pla				pla 	 							; switch I/O back
.ad83		85 01		sta $01				sta 	1
.ad85		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/crossdev.asm

.ad86						XLoadCommand:
.ad86		20 75 8f	jsr $8f75			jsr 	NewProgram
.ad89		20 9f 87	jsr $879f			jsr 	BackloadProgram
.ad8c		4c 12 89	jmp $8912			jmp 	WarmStart
.ad8f						XGoCommand:
.ad8f		20 75 8f	jsr $8f75			jsr 	NewProgram
.ad92		20 9f 87	jsr $879f			jsr 	BackloadProgram
.ad95		4c 1e 91	jmp $911e			jmp 	RunCurrentProgram

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/dos.asm

>0200						ArgumentStrings .fill 128
>0280						ArgumentArray   .fill (8+1)*2		; DOS provides a maximum of 8 tokens
.ad98						BootXA:
.ad98		48		pha				pha
.ad99		da		phx				phx
.ad9a		20 a0 88	jsr $88a0			jsr		IsDestructiveActionOK
.ad9d		fa		plx				plx
.ad9e		68		pla				pla
.ad9f		90 03		bcc $ada4			bcc		_action_ok
.ada1		4c 12 89	jmp $8912			jmp		WarmStart
.ada4						_action_ok:
.ada4		85 36		sta $36				sta		zTemp0+0
.ada6		86 37		stx $37				stx		zTemp0+1
.ada8		a2 00		ldx #$00			ldx		#0
.adaa		a0 00		ldy #$00			ldy		#0
.adac						_copy_next_string:
.adac		98		tya				tya
.adad		18		clc				clc
.adae		69 00		adc #$00			adc		#<ArgumentStrings
.adb0		9d 80 02	sta $0280,x			sta		ArgumentArray,x
.adb3		e8		inx				inx
.adb4		a9 02		lda #$02			lda		#>ArgumentStrings
.adb6		69 00		adc #$00			adc		#0
.adb8		9d 80 02	sta $0280,x			sta		ArgumentArray,x
.adbb		e8		inx				inx
.adbc						_copy_string:
.adbc		b1 36		lda ($36),y			lda		(zTemp0),y
.adbe		f0 1a		beq $adda			beq		_copy_done
.adc0		c9 20		cmp #$20			cmp		#' '
.adc2		f0 06		beq $adca			beq		_skip_spaces
.adc4		99 00 02	sta $0200,y			sta		ArgumentStrings,y
.adc7		c8		iny				iny
.adc8		80 f2		bra $adbc			bra		_copy_string
.adca						_skip_spaces:
.adca		a9 00		lda #$00			lda		#0
.adcc		99 00 02	sta $0200,y			sta		ArgumentStrings,y
.adcf		c8		iny				iny
.add0		b1 36		lda ($36),y			lda		(zTemp0),y
.add2		f0 06		beq $adda			beq		_copy_done
.add4		c9 20		cmp #$20			cmp		#' '
.add6		f0 f2		beq $adca			beq		_skip_spaces
.add8		80 d2		bra $adac			bra		_copy_next_string
.adda						_copy_done:
.adda		a9 00		lda #$00			lda		#0
.addc		99 00 02	sta $0200,y			sta		ArgumentStrings,y
.addf		86 fa		stx $fa				stx		kernel.args.extlen
.ade1		9e 80 02	stz $0280,x			stz		ArgumentArray,x
.ade4		9e 81 02	stz $0281,x			stz		ArgumentArray+1,x
.ade7		a9 80		lda #$80			lda		#<ArgumentArray
.ade9		85 f8		sta $f8				sta		kernel.args.ext
.adeb		a9 02		lda #$02			lda		#>ArgumentArray
.aded		85 f9		sta $f9				sta		kernel.args.ext+1
.adef		a9 00		lda #$00			lda		#<ArgumentStrings
.adf1		85 fb		sta $fb				sta		kernel.args.buf
.adf3		a9 02		lda #$02			lda		#>ArgumentStrings
.adf5		85 fc		sta $fc				sta		kernel.args.buf+1
.adf7		20 18 ff	jsr $ff18			jsr		kernel.RunNamed
.adfa		20 8c 88	jsr $888c			jsr		ResetTokenBuffer
.adfd		a9 1c		lda #$1c		lda	#28
.adff		4c 4d 95	jmp $954d		jmp	ErrorHandler
.ae02		4c 12 89	jmp $8912			jmp		WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/event.asm

.ae05						UnaryEvent:
.ae05		fa		plx				plx
.ae06		20 a1 b4	jsr $b4a1			jsr 	TimerToStackX 				; timer in +0
.ae09		e8		inx				inx  								; put reference into +1
.ae0a		20 aa 9e	jsr $9eaa			jsr 	EvaluateTerm
.ae0d		b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.ae0f		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.ae11		d0 4c		bne $ae5f			bne 	_UEType
.ae13		e8		inx				inx 								; put the step in +2
.ae14		20 3c 95	jsr $953c			jsr 	CheckComma
.ae17		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger
.ae1a		20 34 95	jsr $9534			jsr 	CheckRightBracket
.ae1d		ca		dex				dex
.ae1e		ca		dex				dex
.ae1f		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.ae21		85 36		sta $36				sta 	zTemp0
.ae23		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.ae25		85 37		sta $37				sta 	zTemp0+1
.ae27		5a		phy				phy
.ae28		a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.ae2a		b1 36		lda ($36),y			lda 	(zTemp0),y
.ae2c		30 2d		bmi $ae5b			bmi 	_UEFalse 					; exit if signed.
.ae2e		a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.ae30		b5 60		lda $60,x			lda 	NSMantissa0,x
.ae32		d1 36		cmp ($36),y			cmp 	(zTemp0),y
.ae34		c8		iny				iny
.ae35		b5 70		lda $70,x			lda 	NSMantissa1,x
.ae37		f1 36		sbc ($36),y			sbc		(zTemp0),y
.ae39		c8		iny				iny
.ae3a		b5 80		lda $80,x			lda 	NSMantissa2,x
.ae3c		f1 36		sbc ($36),y			sbc		(zTemp0),y
.ae3e		90 1b		bcc $ae5b			bcc 	_UEFalse 					; no, return FALSE.
.ae40		18		clc				clc
.ae41		a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.ae43		b5 60		lda $60,x			lda 	NSMantissa0,x
.ae45		75 62		adc $62,x			adc 	NSMantissa0+2,x
.ae47		91 36		sta ($36),y			sta 	(zTemp0),y
.ae49		c8		iny				iny
.ae4a		b5 70		lda $70,x			lda 	NSMantissa1,x
.ae4c		75 72		adc $72,x			adc 	NSMantissa1+2,x
.ae4e		91 36		sta ($36),y			sta 	(zTemp0),y
.ae50		c8		iny				iny
.ae51		b5 80		lda $80,x			lda 	NSMantissa2,x
.ae53		75 82		adc $82,x			adc 	NSMantissa2+2,x
.ae55		91 36		sta ($36),y			sta 	(zTemp0),y
.ae57		7a		ply				ply
.ae58		4c c0 95	jmp $95c0			jmp 	ReturnTrue
.ae5b						_UEFalse:
.ae5b		7a		ply				ply 								; restore Y
.ae5c		4c cb 95	jmp $95cb			jmp 	ReturnFalse 				; and return False
.ae5f						_UEType:
.ae5f		4c 38 a6	jmp $a638			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/bload.asm

.ae62						Command_BLoad:
.ae62		20 6d ae	jsr $ae6d			jsr 	BLOADHandler
.ae65		c9 00		cmp #$00			cmp 	#0
.ae67		d0 01		bne $ae6a			bne 	_BLError
.ae69		60		rts				rts
.ae6a						_BLError:
.ae6a		4c c1 b0	jmp $b0c1			jmp 	CLErrorHandler
.ae6d						BLOADHandler:
.ae6d		a2 00		ldx #$00			ldx 	#0
.ae6f		20 0e a4	jsr $a40e			jsr 	EvaluateString 				; file name to load
.ae72		20 3c 95	jsr $953c			jsr 	CheckComma 					; consume comma
.ae75		e8		inx				inx
.ae76		20 23 a4	jsr $a423			jsr 	EvaluateInteger 			; load address (full physical address)
.ae79		5a		phy				phy
.ae7a		a5 60		lda $60				lda 	NSMantissa0					; file name -> XA
.ae7c		a6 70		ldx $70				ldx 	NSMantissa1
.ae7e		20 4a 84	jsr $844a			jsr 	KNLOpenFileRead 			; open file for reading
.ae81		b0 50		bcs $aed3			bcs 	_BLErrorExit 				; error, so fail.
.ae83		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.ae86		a2 01		ldx #$01			ldx 	#1 							; address is in slot # 1
.ae88		20 d5 ae	jsr $aed5			jsr 	BLOpenPhysicalMemory 		; open for access.
.ae8b						_BLReadFile:
.ae8b		ad df 07	lda $07df			lda 	BasicFileStream
.ae8e		a2 40		ldx #$40			ldx     #KNLReadBufferLen 			; set bytes to read.
.ae90		20 a4 84	jsr $84a4			jsr 	KNLReadBlock 				; read next block
.ae93		b0 22		bcs $aeb7			bcs 	_BLFileError 				; file error, which might be EOF.
.ae95		c9 00		cmp #$00			cmp 	#0 							; read nothing.
.ae97		f0 f2		beq $ae8b			beq 	_BLReadFile
.ae99		8d dd 07	sta $07dd			sta 	BLCopyCounter 				; counter.
.ae9c		ac dc 07	ldy $07dc			ldy 	BLYOffset 					; copy the buffer out here
.ae9f		a2 00		ldx #$00			ldx 	#0 							; offset in buffer.
.aea1						_BLCopyLoop:
.aea1		bd bd 06	lda $06bd,x			lda 	KNLReadBuffer,x 			; copy byte and advance
.aea4		91 3a		sta ($3a),y			sta 	(zTemp2),y
.aea6		c8		iny				iny
.aea7		d0 03		bne $aeac			bne 	_BLNoAdjust 				; check changed 256 byte or 8k page.
.aea9		20 fd ae	jsr $aefd			jsr 	BLAdvancePhysicalMemory
.aeac						_BLNoAdjust:
.aeac		e8		inx				inx
.aead		ce dd 07	dec $07dd			dec 	BLCopyCounter
.aeb0		d0 ef		bne $aea1			bne 	_BLCopyLoop
.aeb2		8c dc 07	sty $07dc			sty 	BLYOffset 					; update Y offset
.aeb5		80 d4		bra $ae8b			bra 	_BLReadFile 				; go ask for more.
.aeb7						_BLFileError:
.aeb7		c9 30		cmp #$30			cmp 	#KERR_EOF 					; End of file
.aeb9		d0 0d		bne $aec8			bne 	_BLErrorHandler				; no, it's an actual error
.aebb		20 f7 ae	jsr $aef7			jsr 	BLClosePhysicalMemory 		; close the access.
.aebe		ad df 07	lda $07df			lda 	BasicFileStream 			; close the file
.aec1		20 19 85	jsr $8519			jsr 	KNLCloseFile
.aec4		a9 00		lda #$00			lda 	#0 							; and return zero.
.aec6		7a		ply				ply
.aec7		60		rts				rts
.aec8						_BLErrorHandler:
.aec8		48		pha				pha 								; save code
.aec9		20 f7 ae	jsr $aef7			jsr 	BLClosePhysicalMemory 		; close access
.aecc		ad df 07	lda $07df			lda 	BasicFileStream 			; close the open file
.aecf		20 19 85	jsr $8519			jsr 	KNLCloseFile
.aed2		68		pla				pla 								; get error code
.aed3						_BLErrorExit:
.aed3		7a		ply				ply 								; restore position and exit.
.aed4		60		rts				rts
=3						BLAccessPage = 3 							; page to use for actual memory.
.aed5						BLOpenPhysicalMemory:
.aed5		a5 0b		lda $0b				lda 	BLAccessPage+8 				; save current mapping
.aed7		8d db 07	sta $07db			sta 	BLNormalMapping
.aeda		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy address, 13 bit adjusted for page -> (zTemp2),BLYOffset
.aedc		8d dc 07	sta $07dc			sta 	BLYOffset 					; zTemp2 0 is *always* zero.
.aedf		64 3a		stz $3a				stz 	zTemp2
.aee1		b5 70		lda $70,x			lda 	NSMantissa1,x
.aee3		29 1f		and #$1f			and 	#$1F
.aee5		09 60		ora #$60			ora 	#BLAccessPage << 5
.aee7		85 3b		sta $3b				sta 	zTemp2+1
.aee9		b5 80		lda $80,x			lda 	NSMantissa2,x 				; shift M2:M1 right 3 times to give page # required
.aeeb		16 70		asl $70,x			asl 	NSMantissa1,x
.aeed		2a		rol a				rol 	a
.aeee		16 70		asl $70,x			asl 	NSMantissa1,x
.aef0		2a		rol a				rol 	a
.aef1		16 70		asl $70,x			asl 	NSMantissa1,x
.aef3		2a		rol a				rol 	a
.aef4		85 0b		sta $0b				sta 	BLAccessPage+8 				; access that page
.aef6		60		rts				rts
.aef7						BLClosePhysicalMemory:
.aef7		ad db 07	lda $07db			lda 	BLNormalMapping
.aefa		85 0b		sta $0b				sta 	BLAccessPage+8
.aefc		60		rts				rts
.aefd						BLAdvancePhysicalMemory:
.aefd		48		pha				pha
.aefe		e6 3b		inc $3b				inc		zTemp2+1 					; bump MSB
.af00		a5 3b		lda $3b				lda 	zTemp2+1
.af02		c9 80		cmp #$80			cmp 	#(BLAccessPage+1) << 5 		; reached next page ?
.af04		d0 06		bne $af0c			bne 	_BLAPMExit 					; (e.g. end of the mapped page.)
.af06		e6 0b		inc $0b				inc 	BLAccessPage+8 				; next physical page
.af08		a9 60		lda #$60			lda 	#BLAccessPage << 5 			; page back to start of transfer page
.af0a		85 3b		sta $3b				sta 	zTemp2+1
.af0c						_BLAPMExit:
.af0c		68		pla				pla
.af0d		60		rts				rts
.07db						BLNormalMapping:
>07db								.fill 	1
.07dc						BLYOffset:
>07dc								.fill 	1
.07dd						BLCopyCounter:
>07dd								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/bsave.asm

.af0e						Command_BSave:
.af0e		20 19 af	jsr $af19			jsr 	BSaveHandler
.af11		c9 00		cmp #$00			cmp 	#0
.af13		d0 01		bne $af16			bne 	_BSError
.af15		60		rts				rts
.af16						_BSError:
.af16		4c c1 b0	jmp $b0c1			jmp 	CLErrorHandler
.af19						BSaveHandler:
.af19		a2 00		ldx #$00			ldx 	#0
.af1b		20 0e a4	jsr $a40e			jsr 	EvaluateString 				; file name to load
.af1e		20 3c 95	jsr $953c			jsr 	CheckComma 					; consume comma
.af21		e8		inx				inx
.af22		20 23 a4	jsr $a423			jsr 	EvaluateInteger 			; load address (full physical address)
.af25		20 3c 95	jsr $953c			jsr 	CheckComma 					; consume comma
.af28		e8		inx				inx
.af29		20 23 a4	jsr $a423			jsr 	EvaluateInteger 			; data length (3 bytes only)
.af2c		5a		phy				phy
.af2d		a5 60		lda $60				lda 	NSMantissa0					; file name -> XA
.af2f		a6 70		ldx $70				ldx 	NSMantissa1
.af31		20 45 84	jsr $8445			jsr 	KNLOpenFileWrite 			; open file for reading
.af34		b0 47		bcs $af7d			bcs 	_BSErrorExit 				; error, so fail.
.af36		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.af39		a2 01		ldx #$01			ldx 	#1 							; address is in slot # 1
.af3b		20 d5 ae	jsr $aed5			jsr 	BLOpenPhysicalMemory 		; open for access.
.af3e		a2 00		ldx #$00			ldx 	#0 							; number of bytes in kernel buffer
.af40		ac dc 07	ldy $07dc			ldy 	BLYOffset 					; used for data offset.
.af43						_BSWriteToFileLoop:
.af43		38		sec				sec 								; pre decrement count.
.af44		a5 62		lda $62				lda 	NSMantissa0+2
.af46		e9 01		sbc #$01			sbc 	#1
.af48		85 62		sta $62				sta 	NSMantissa0+2
.af4a		a5 72		lda $72				lda 	NSMantissa1+2
.af4c		e9 00		sbc #$00			sbc 	#0
.af4e		85 72		sta $72				sta 	NSMantissa1+2
.af50		a5 82		lda $82				lda 	NSMantissa2+2
.af52		e9 00		sbc #$00			sbc 	#0
.af54		85 82		sta $82				sta 	NSMantissa2+2
.af56		30 15		bmi $af6d			bmi 	_BSFileComplete 			; undercounted, so exit.
.af58		b1 3a		lda ($3a),y			lda 	(zTemp2),y 					; get byte to save
.af5a		9d bd 06	sta $06bd,x			sta 	KNLReadBuffer,x 			; save in the buffer and bump buffer index
.af5d		e8		inx				inx
.af5e		c8		iny				iny 								; next byte
.af5f		d0 03		bne $af64			bne 	_BSNoCheck
.af61		20 fd ae	jsr $aefd			jsr 	BLAdvancePhysicalMemory 	; check not gone to next page.
.af64						_BSNoCheck:
.af64		e0 40		cpx #$40			cpx 	#KNLReadBufferLen 			; done the whole buffer
.af66		d0 db		bne $af43			bne 	_BSWriteToFileLoop 			; no , do the next byte.
.af68		20 7f af	jsr $af7f			jsr 	BSFlushBuffer 				; yes, flush the buffer
.af6b		80 d6		bra $af43			bra 	_BSWriteToFileLoop 			; and keep on going
.af6d						_BSFileComplete:
.af6d		20 7f af	jsr $af7f			jsr 	BSFlushBuffer 				; write the buffer remainder.
.af70		20 f7 ae	jsr $aef7			jsr 	BLClosePhysicalMemory 		; close the access.
.af73		ad df 07	lda $07df			lda 	BasicFileStream 			; close the file
.af76		20 19 85	jsr $8519			jsr 	KNLCloseFile
.af79		a9 00		lda #$00			lda 	#0
.af7b		7a		ply				ply
.af7c		60		rts				rts
.af7d						_BSErrorExit:
.af7d		7a		ply				ply
.af7e		60		rts				rts
.af7f						BSFlushBuffer:
.af7f		e0 00		cpx #$00			cpx 	#0 							; buffer empty ?
.af81		f0 0d		beq $af90			beq 	_BSFBExit 					; if so, exit.
.af83		a9 bd		lda #$bd			lda 	#KNLReadBuffer & $FF 		; where to write from.
.af85		85 36		sta $36				sta 	zTemp0
.af87		a9 06		lda #$06			lda 	#KNLReadBuffer >> 8
.af89		85 37		sta $37				sta 	zTemp0+1 					; # of bytes in X
.af8b		20 83 b1	jsr $b183			jsr 	CLWriteByteBlock 			; write it.
.af8e		a2 00		ldx #$00			ldx 	#0 							; buffer is empty.
.af90						_BSFBExit:
.af90		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/dir.asm

.af91						Command_Dir:
.af91		ad bd 07	lda $07bd			lda     KNLDefaultDrive				; set drive to list.
.af94		85 f3		sta $f3				sta     kernel.args.directory.open.drive
.af96		64 fd		stz $fd				stz     kernel.args.directory.open.path_len
.af98		20 78 ff	jsr $ff78			jsr     kernel.Directory.Open
.af9b		b0 4f		bcs $afec			bcs     _CDExit
.af9d						_CDEventLoop:
.af9d		20 0c ff	jsr $ff0c			jsr     kernel.Yield        		; Polite, not actually needed.
.afa0		20 ff 82	jsr $82ff			jsr     GetNextEvent
.afa3		b0 f8		bcs $af9d			bcs     _CDEventLoop
.afa5		ad be 07	lda $07be			lda     KNLEvent.type
.afa8		c9 46		cmp #$46			cmp     #kernel.event.directory.CLOSED
.afaa		f0 40		beq $afec			beq    	_CDExit
.afac		20 b1 af	jsr $afb1			jsr     _CDMessages 				; handle various messages
.afaf		80 ec		bra $af9d			bra     _CDEventLoop
.afb1						_CDMessages:
.afb1		c9 3c		cmp #$3c			cmp     #kernel.event.directory.OPENED
.afb3		f0 15		beq $afca			beq     _CDEVRead
.afb5		c9 3e		cmp #$3e			cmp     #kernel.event.directory.VOLUME
.afb7		f0 19		beq $afd2			beq     _CDEVVolume
.afb9		c9 40		cmp #$40			cmp     #kernel.event.directory.FILE
.afbb		f0 32		beq $afef			beq     _CDEVFile
.afbd		c9 42		cmp #$42			cmp     #kernel.event.directory.FREE
.afbf		f0 70		beq $b031			beq     _CDEVFree
.afc1		c9 44		cmp #$44			cmp     #kernel.event.directory.EOF
.afc3		f0 6e		beq $b033			beq     _CDEVEOF
.afc5		c9 48		cmp #$48			cmp     #kernel.event.directory.ERROR
.afc7		f0 6a		beq $b033			beq     _CDEVEOF
.afc9		60		rts				rts
.afca						_CDEVRead:
.afca		ad c1 07	lda $07c1			lda     KNLEvent.directory.stream
.afcd		85 f3		sta $f3				sta     kernel.args.directory.read.stream
.afcf		4c 7c ff	jmp $ff7c			jmp     kernel.Directory.Read
.afd2						_CDEVVolume:
.afd2		a9 5b		lda #$5b			lda 	#"["
.afd4		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afd7		ad c3 07	lda $07c3			lda     KNLEvent.directory.volume.len
.afda		20 3b b0	jsr $b03b			jsr     _CDReadData
.afdd		20 ac 95	jsr $95ac			jsr 	PrintStringXA
.afe0		a9 5d		lda #$5d			lda 	#"]"
.afe2		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afe5		a9 0d		lda #$0d			lda 	#13
.afe7		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afea		80 de		bra $afca			bra     _CDEVRead
.afec						_CDExit:
.afec		4c 12 89	jmp $8912			jmp 	WarmStart
.afef						_CDEVFile:
.afef		a9 20		lda #$20			lda 	#32
.aff1		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.aff4		ad c3 07	lda $07c3			lda     KNLEvent.directory.file.len
.aff7		48		pha				pha
.aff8		20 3b b0	jsr $b03b			jsr     _CDReadData
.affb		20 ac 95	jsr $95ac			jsr 	PrintStringXA
.affe		68		pla				pla
.afff		49 ff		eor #$ff			eor 	#$FF
.b001		38		sec				sec
.b002		69 10		adc #$10			adc 	#16
.b004		aa		tax				tax
.b005						_CDEVTab:
.b005		a9 20		lda #$20			lda 	#32
.b007		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.b00a		ca		dex				dex
.b00b		10 f8		bpl $b005			bpl 	_CDEVTab
.b00d		20 52 b0	jsr $b052			jsr 	_CDReadExtended
.b010		ad 46 05	lda $0546			lda 	lineBuffer
.b013		ae 47 05	ldx $0547			ldx 	lineBuffer+1
.b016		20 c2 99	jsr $99c2			jsr 	ConvertInt16
.b019		20 ac 95	jsr $95ac			jsr 	PrintStringXA
.b01c		a2 b0		ldx #$b0			ldx 	#_CDEVFMessage >> 8
.b01e		a9 25		lda #$25			lda 	#_CDEVFMessage & $FF
.b020		20 ac 95	jsr $95ac			jsr 	PrintStringXA
.b023		80 a5		bra $afca			bra     _CDEVRead
.b025						_CDEVFMessage:
>b025		20 62 6c 6f 63 6b 28 73				.text 	" block(s).",13,0
>b02d		29 2e 0d 00
.b031						_CDEVFree:
.b031		80 00		bra $b033			bra     _CDEVEOF
.b033						_CDEVEOF:
.b033		ad c1 07	lda $07c1			lda     KNLEvent.directory.stream
.b036		85 f3		sta $f3				sta     kernel.args.directory.close.stream
.b038		4c 80 ff	jmp $ff80			jmp     kernel.Directory.Close
.b03b						_CDReadData:
.b03b		85 fd		sta $fd				sta     kernel.args.recv.buflen
.b03d		a9 46		lda #$46			lda     #lineBuffer & $FF
.b03f		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.b041		a9 05		lda #$05			lda     #lineBuffer >> 8
.b043		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.b045		20 04 ff	jsr $ff04			jsr     kernel.ReadData
.b048		a6 fd		ldx $fd				ldx     kernel.args.recv.buflen
.b04a		9e 46 05	stz $0546,x			stz     lineBuffer,x
.b04d		a9 46		lda #$46			lda 	#lineBuffer & $FF
.b04f		a2 05		ldx #$05			ldx 	#lineBuffer >> 8
.b051		60		rts				rts
.b052						_CDReadExtended:
.b052		a9 02		lda #$02			lda     #2
.b054		85 fd		sta $fd				sta     kernel.args.recv.buflen
.b056		a9 46		lda #$46			lda     #lineBuffer & $FF
.b058		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.b05a		a9 05		lda #$05			lda     #lineBuffer >> 8
.b05c		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.b05e		4c 08 ff	jmp $ff08			jmp     kernel.ReadExt

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/drive.asm

.b061						Command_Drive:
.b061		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.b064		20 41 84	jsr $8441			jsr 	KNLSetDrive
.b067		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/load.asm

.b068						Command_Load:
.b068		20 a0 88	jsr $88a0			jsr		IsDestructiveActionOK
.b06b		b0 03		bcs $b070			bcs		_not_ok
.b06d		20 73 b0	jsr $b073			jsr 	LoadFile
.b070						_not_ok
.b070		4c 12 89	jmp $8912			jmp		WarmStart
.b073						LoadFile:
.b073		20 0e a4	jsr $a40e			jsr 	EvaluateString 				; file name to load
.b076		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.b078		a5 36		lda $36				lda 	zTemp0
.b07a		20 4a 84	jsr $844a			jsr 	KNLOpenFileRead 			; open file for reading
.b07d		b0 42		bcs $b0c1			bcs 	CLErrorHandler 				; error, so fail.
.b07f		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.b082		20 11 b1	jsr $b111			jsr     LoadReadByteInit            ; Init reader with the stream
.b085		20 75 8f	jsr $8f75			jsr 	NewProgram 					; does the actual NEW.
.b088		9c de 07	stz $07de			stz 	LoadEOFFlag 				; clear EOF Flag.
.b08b						_CLLoop:
.b08b		20 cf b0	jsr $b0cf			jsr 	LoadReadLine 				; get next line.
.b08e		f0 10		beq $b0a0			beq 	_CLExit 					; end, exit.
.b090		20 93 80	jsr $8093			jsr 	TKTokeniseLine 				; tokenise the line.
.b093		ad 47 04	lda $0447			lda 	tokenLineNumber 			; line number = 0
.b096		0d 48 04	ora $0448			ora 	tokenLineNumber+1
.b099		f0 f0		beq $b08b			beq 	_CLLoop 					; not legal code, blank line or maybe a comment.
.b09b		20 62 88	jsr $8862			jsr 	EditProgramCode 			; do the editing etc.
.b09e		80 eb		bra $b08b			bra 	_CLLoop
.b0a0						_CLExit:
.b0a0		ad df 07	lda $07df			lda 	BasicFileStream
.b0a3		20 19 85	jsr $8519			jsr 	KNLCloseFile
.b0a6						CLComplete:
.b0a6		a9 ae		lda #$ae			lda 	#_CLCMsg & $FF
.b0a8		a2 b0		ldx #$b0			ldx 	#_CLCMsg >> 8
.b0aa		20 ac 95	jsr $95ac			jsr 	PrintStringXA
.b0ad		60		rts				rts
.b0ae						_CLCMsg:
>b0ae		43 6f 6d 70 6c 65 74 65				.text 	"Complete.",13,0
>b0b6		2e 0d 00
.b0b9						CLCloseError:
.b0b9		48		pha				pha
.b0ba		ad df 07	lda $07df			lda 	BasicFileStream
.b0bd		20 19 85	jsr $8519			jsr 	KNLCloseFile
.b0c0		68		pla				pla
.b0c1						CLErrorHandler:
.b0c1		c9 28		cmp #$28			cmp 	#KERR_NOTFOUND
.b0c3		f0 05		beq $b0ca			beq 	_CLEHNotFound
.b0c5		a9 1a		lda #$1a		lda	#26
.b0c7		4c 4d 95	jmp $954d		jmp	ErrorHandler
.b0ca						_CLEHNotFound:
.b0ca		a9 19		lda #$19		lda	#25
.b0cc		4c 4d 95	jmp $954d		jmp	ErrorHandler
.b0cf						LoadReadLine:
.b0cf		a2 00		ldx #$00			ldx 	#0 							; look for first character non space/ctl
.b0d1		20 eb b0	jsr $b0eb			jsr 	LoadReadCharacter
.b0d4		f0 14		beq $b0ea			beq 	_LRLExit 					; eof ?
.b0d6		c9 21		cmp #$21			cmp 	#' '+1 						; space control tab skip
.b0d8		90 f5		bcc $b0cf			bcc 	LoadReadLine
.b0da						_LRLLoop:
.b0da		9d 46 05	sta $0546,x			sta 	lineBuffer,x 				; write into line buffer
.b0dd		9e 47 05	stz $0547,x			stz 	lineBuffer+1,x 				; make ASCIIZ
.b0e0		e8		inx				inx
.b0e1		20 eb b0	jsr $b0eb			jsr 	LoadReadCharacter 			; next line
.b0e4		c9 20		cmp #$20			cmp 	#32 						; until < space ctrl/eof.
.b0e6		b0 f2		bcs $b0da			bcs 	_LRLLoop
.b0e8		a9 01		lda #$01			lda 	#1 							; return code 1, okay.
.b0ea						_LRLExit:
.b0ea		60		rts				rts
.b0eb						LoadReadCharacter:
.b0eb		da		phx				phx
.b0ec		5a		phy				phy
.b0ed		ad de 07	lda $07de			lda 	LoadEOFFlag 				; already done EOF.
.b0f0		d0 0c		bne $b0fe			bne 	_LRCIsEOF
.b0f2		20 1b b1	jsr $b11b			jsr 	LoadReadByte 				; read a byte
.b0f5		90 09		bcc $b100			bcc		_LRCExit 					; read okay.
.b0f7		c9 30		cmp #$30			cmp 	#KERR_EOF 					; if error not EOF it's an actual error.
.b0f9		d0 be		bne $b0b9			bne 	CLCloseError
.b0fb		ce de 07	dec $07de			dec 	LoadEOFFlag
.b0fe						_LRCIsEOF:
.b0fe		a9 00		lda #$00			lda 	#0
.b100						_LRCExit:
.b100		c9 09		cmp #$09			cmp 	#9 							; convert tab to space
.b102		d0 02		bne $b106			bne 	_LRCNotTab
.b104		a9 20		lda #$20			lda 	#' '
.b106						_LRCNotTab:
.b106		c9 0a		cmp #$0a			cmp 	#$0A
.b108		d0 02		bne $b10c			bne 	_LRCNotLF
.b10a		a9 0d		lda #$0d			lda 	#$0D
.b10c						_LRCNotLF:
.b10c		7a		ply				ply
.b10d		fa		plx				plx
.b10e		c9 00		cmp #$00			cmp 	#0 							; set Z flag if EOF.
.b110		60		rts				rts
.b111						LoadReadByteInit:
.b111		8d e0 07	sta $07e0			sta     LoadFileStream 				; save stream
.b114		9c e1 07	stz $07e1			stz     LoadNextCharacter 			; reset buffer
.b117		9c e2 07	stz $07e2			stz     LoadEndCharacter
.b11a		60		rts				rts
.b11b						LoadReadByte:
.b11b		da		phx				phx
.b11c		ae e1 07	ldx $07e1			ldx     LoadNextCharacter 					; all data consumed ?
.b11f		ec e2 07	cpx $07e2			cpx     LoadEndCharacter
.b122		d0 12		bne $b136			bne     _KNLRBGetNextByte
.b124		ad e0 07	lda $07e0			lda     LoadFileStream
.b127		a2 40		ldx #$40			ldx     #KNLReadBufferLen 			; set bytes to read.
.b129		20 a4 84	jsr $84a4			jsr     KNLReadBlock 				; read next chunk from the stream
.b12c		b0 0f		bcs $b13d			bcs     _KNLRBError 				; error has occurred on read.
.b12e		8d e2 07	sta $07e2			sta     LoadEndCharacter 						; # read is the number available
.b131		a2 00		ldx #$00			ldx     #0 							; reset the read pointer.
.b133		8e e1 07	stx $07e1			stx     LoadNextCharacter
.b136						_KNLRBGetNextByte:
.b136		bd bd 06	lda $06bd,x			lda     KNLReadBuffer,x 			; get the next data item
.b139		ee e1 07	inc $07e1			inc     LoadNextCharacter 					; and advance the index
.b13c		18		clc				clc 								; succeeded
.b13d						_KNLRBError:
.b13d		fa		plx				plx
.b13e		60		rts				rts
.07de						LoadEOFFlag:
>07de								.fill 	1
.07df						BasicFileStream:
>07df								.fill 	1
.07e0						LoadFileStream:
>07e0								.byte   ?
.07e1						LoadNextCharacter:
>07e1								.byte   ?
.07e2						LoadEndCharacter:
>07e2								.byte   ?

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/save.asm

.b13f						Command_Save:
.b13f		20 0e a4	jsr $a40e			jsr 	EvaluateString 				; file name to load
.b142		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.b144		a5 36		lda $36				lda 	zTemp0
.b146		20 45 84	jsr $8445			jsr 	KNLOpenFileWrite 			; open file for writing
.b149		b0 35		bcs $b180			bcs 	CSErrorHandler 				; error, so fail.
.b14b		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.b14e		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.b150		85 30		sta $30				sta 	codePtr
.b152		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.b154		85 31		sta $31				sta 	codePtr+1
.b156						_CSLoop:
.b156		b2 30		lda ($30)			lda 	(codePtr)
.b158		f0 17		beq $b171			beq 	_CSExit
.b15a		20 a4 b1	jsr $b1a4			jsr 	CSGetCleanLine
.b15d		84 37		sty $37				sty 	zTemp0+1 					; save write address of data
.b15f		85 36		sta $36				sta 	zTemp0
.b161		20 83 b1	jsr $b183			jsr 	CLWriteByteBlock 			; write the block out.
.b164		18		clc				clc
.b165		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.b167		65 30		adc $30				adc 	codePtr
.b169		85 30		sta $30				sta 	codePtr
.b16b		90 02		bcc $b16f			bcc 	_CREExit
.b16d		e6 31		inc $31				inc 	codePtr+1 					; carry
.b16f						_CREExit:
.b16f		80 e5		bra $b156			bra 	_CSLoop
.b171						_CSExit:
.b171		ad df 07	lda $07df			lda 	BasicFileStream 			; close file
.b174		20 19 85	jsr $8519			jsr 	KNLCloseFile
.b177		20 a6 b0	jsr $b0a6			jsr 	CLComplete 					; display complete message.
.b17a		9c 75 06	stz $0675			stz		programChanged				; mark program not changed since save
.b17d		4c 12 89	jmp $8912			jmp 	WarmStart 					; and warm start
.b180						CSErrorHandler:
.b180		4c c1 b0	jmp $b0c1			jmp 	CLErrorHandler
.b183						CLWriteByteBlock:
.b183		e0 00		cpx #$00			cpx 	#0 							; written the lot ?
.b185		f0 1c		beq $b1a3			beq 	_CLWBBExit					; if so, exit
.b187		ad df 07	lda $07df			lda 	BasicFileStream 			; stream to write, count in X
.b18a		20 df 84	jsr $84df			jsr 	KNLWriteBlock 				; call one write attempt
.b18d		b0 f1		bcs $b180			bcs 	CSErrorHandler 				; error occurred
.b18f		85 38		sta $38				sta 	zTemp1 						; save bytes written.
.b191		8a		txa				txa 								; subtract bytes written from X, total count.
.b192		38		sec				sec
.b193		e5 38		sbc $38				sbc 	zTemp1
.b195		aa		tax				tax
.b196		18		clc				clc 								; advance zTemp0 pointer by bytes written.
.b197		a5 36		lda $36				lda 	zTemp0
.b199		65 38		adc $38				adc 	zTemp1
.b19b		85 36		sta $36				sta 	zTemp0
.b19d		90 e4		bcc $b183			bcc 	CLWriteByteBlock
.b19f		e6 37		inc $37				inc 	zTemp0+1
.b1a1		80 e0		bra $b183			bra 	CLWriteByteBlock 			; and retry write out.
.b1a3						_CLWBBExit:
.b1a3		60		rts				rts
.b1a4						CSGetCleanLine:
.b1a4		a9 00		lda #$00			lda 	#0 							; no indent.
.b1a6		20 89 80	jsr $8089			jsr 	TKListConvertLine 			; convert line into token Buffer
.b1a9		a2 00		ldx #$00			ldx 	#0 							; copy stripping controls.
.b1ab		a0 00		ldy #$00			ldy 	#0
.b1ad						_CSClean:
.b1ad		b9 49 04	lda $0449,y			lda 	tokenBuffer,y
.b1b0		f0 09		beq $b1bb			beq 	_CSDoneClean
.b1b2		30 04		bmi $b1b8			bmi 	_CSIgnoreCharacter
.b1b4		9d 46 05	sta $0546,x			sta 	lineBuffer,x
.b1b7		e8		inx				inx
.b1b8						_CSIgnoreCharacter:
.b1b8		c8		iny				iny
.b1b9		80 f2		bra $b1ad			bra 	_CSClean
.b1bb						_CSDoneClean:
.b1bb		a9 0d		lda #$0d			lda 	#13 						; add CR, length now in X and ASCIIZ.
.b1bd		9d 46 05	sta $0546,x			sta 	lineBuffer,x
.b1c0		e8		inx				inx
.b1c1		9e 46 05	stz $0546,x			stz 	lineBuffer,x
.b1c4		a0 05		ldy #$05			ldy 	#(lineBuffer >> 8) 			; line address in YA
.b1c6		a9 46		lda #$46			lda 	#(lineBuffer & $FF)
.b1c8		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/try.asm

.b1c9						Command_Try:
.b1c9		b1 30		lda ($30),y			lda 	(codePtr),y
.b1cb		c9 81		cmp #$81			cmp 	#KWC_SHIFT1					; can only try in SHIFT_1
.b1cd		d0 0c		bne $b1db			bne 	_TrySyntax
.b1cf		c8		iny				iny 								; get second
.b1d0		b1 30		lda ($30),y			lda 	(codePtr),y
.b1d2		c8		iny				iny 								; and consume it.
.b1d3		c9 86		cmp #$86			cmp 	#KWD1_BLOAD
.b1d5		f0 09		beq $b1e0			beq 	_TryBLoad
.b1d7		c9 87		cmp #$87			cmp	 	#KWD1_BSAVE
.b1d9		f0 0a		beq $b1e5			beq 	_TryBSave
.b1db						_TrySyntax:
.b1db		a9 02		lda #$02		lda	#2
.b1dd		4c 4d 95	jmp $954d		jmp	ErrorHandler
.b1e0						_TryBLoad:
.b1e0		20 6d ae	jsr $ae6d			jsr 	BLOADHandler
.b1e3		80 03		bra $b1e8			bra 	_TryExit
.b1e5						_TryBSave:
.b1e5		20 19 af	jsr $af19			jsr 	BSaveHandler
.b1e8						_TryExit:
.b1e8		48		pha				pha 								; save result
.b1e9		b1 30		lda ($30),y			lda 	(codePtr),y
.b1eb		c8		iny				iny
.b1ec		c9 dd		cmp #$dd			cmp 	#KWD_TO
.b1ee		d0 eb		bne $b1db			bne 	_TrySyntax
.b1f0		a2 00		ldx #$00			ldx 	#0 							; get an integer reference.
.b1f2		20 aa 9e	jsr $9eaa			jsr 	EvaluateTerm
.b1f5		b5 50		lda $50,x			lda 	NSStatus,x
.b1f7		c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.b1f9		d0 e0		bne $b1db			bne		_TrySyntax
.b1fb		68		pla				pla 								; error code.
.b1fc		a2 01		ldx #$01			ldx	 	#1 							; address in 0, data in 1
.b1fe		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte
.b201		ca		dex				dex
.b202		20 7f 8d	jsr $8d7f			jsr 	AssignVariable 				; do the assign and exit
.b205		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/verify.asm

.e779						m
.b206						Command_VERIFY:
.b206		20 0e a4	jsr $a40e			jsr 	EvaluateString 				; file name to verify
.b209		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.b20b		a5 36		lda $36				lda 	zTemp0
.b20d		20 4a 84	jsr $844a			jsr 	KNLOpenFileRead 			; open file for reading
.b210		b0 51		bcs $b263			bcs 	_CVErrorHandler 			; error, so fail.
.b212		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.b215		20 11 b1	jsr $b111			jsr     LoadReadByteInit            ; Init reader with the stream
.b218		9c de 07	stz $07de			stz 	LoadEOFFlag 				; clear EOF Flag.
.b21b		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.b21d		85 30		sta $30				sta 	codePtr
.b21f		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.b221		85 31		sta $31				sta 	codePtr+1
.b223						_CVLoop:
.b223		20 cf b0	jsr $b0cf			jsr 	LoadReadLine 				; get next line.
.b226		f0 27		beq $b24f			beq 	_CVExit 					; end, exit.
.b228		20 93 80	jsr $8093			jsr 	TKTokeniseLine 				; tokenise the line.
.b22b		ad 47 04	lda $0447			lda 	tokenLineNumber 			; line number = 0
.b22e		0d 48 04	ora $0448			ora 	tokenLineNumber+1
.b231		f0 f0		beq $b223			beq 	_CVLoop 					; not legal code, blank line or maybe a comment.
.b233		a0 00		ldy #$00			ldy 	#0 							; start compare
.b235						_CVCompareLoop:
.b235		b1 30		lda ($30),y			lda 	(codePtr),y
.b237		d9 46 04	cmp $0446,y			cmp 	tokenOffset,y 				; compare against actual code.
.b23a		d0 1f		bne $b25b			bne 	_CVCompareError
.b23c		c8		iny				iny
.b23d		cc 46 04	cpy $0446			cpy 	tokenOffset 				; until done whole line of code
.b240		d0 f3		bne $b235			bne 	_CVCompareLoop
.b242		18		clc				clc
.b243		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.b245		65 30		adc $30				adc 	codePtr
.b247		85 30		sta $30				sta 	codePtr
.b249		90 02		bcc $b24d			bcc 	_CREExit
.b24b		e6 31		inc $31				inc 	codePtr+1 					; carry
.b24d						_CREExit:
.b24d		80 d4		bra $b223			bra 	_CVLoop
.b24f						_CVExit:
.b24f		ad df 07	lda $07df			lda 	BasicFileStream
.b252		20 19 85	jsr $8519			jsr 	KNLCloseFile
.b255		20 a6 b0	jsr $b0a6			jsr 	CLComplete
.b258		4c 12 89	jmp $8912			jmp		WarmStart
.b25b						_CVCompareError:
.b25b		20 8c 88	jsr $888c			jsr		ResetTokenBuffer
.b25e		a9 1b		lda #$1b		lda	#27
.b260		4c 4d 95	jmp $954d		jmp	ErrorHandler
.b263						_CVErrorHandler:
.b263		4c c1 b0	jmp $b0c1			jmp 	CLErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/joy.asm

.b266						UnaryJoyX:
.b266		18		clc				clc
.b267		80 01		bra $b26a			bra 	JoyMain
.b269						UnaryJoyY:
.b269		38		sec				sec
.b26a						JoyMain:
.b26a		fa		plx				plx 								; get pos
.b26b		08		php				php 								; save carry (set for Y)
.b26c		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; ignore the parameter
.b26f		20 34 95	jsr $9534			jsr 	CheckRightBracket
.b272		20 1f 85	jsr $851f			jsr 	KNLReadController 			; read the controller.
.b275		28		plp				plp
.b276		b0 02		bcs $b27a			bcs 	_JMNoShift 					; if X then shift bits 3,2 -> 1,0
.b278		4a		lsr a				lsr 	a
.b279		4a		lsr a				lsr 	a
.b27a						_JMNoShift:
.b27a		4a		lsr a				lsr 	a 							; if bit 0 set then left/up e.g. -1
.b27b		b0 07		bcs $b284			bcs 	JMIsLeft
.b27d		4a		lsr a				lsr 	a 							; if bit 1 set then right/down e.g. +1
.b27e		b0 07		bcs $b287			bcs 	JMIsRight
.b280		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero 					; zero result
.b283		60		rts				rts
.b284						JMIsLeft:
.b284		4c c0 95	jmp $95c0			jmp 	ReturnTrue
.b287						JMIsRight:
.b287		a9 01		lda #$01			lda 	#1
.b289		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte
.b28c		60		rts				rts
.b28d						UnaryJoyB:
.b28d		fa		plx				plx 								; get pos
.b28e		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; ignore the parameter
.b291		20 34 95	jsr $9534			jsr 	CheckRightBracket
.b294		20 1f 85	jsr $851f			jsr 	KNLReadController 			; read the controller.
.b297		29 10		and #$10			and 	#$10
.b299		d0 e9		bne $b284			bne 	JMIsLeft
.b29b		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero
.b29e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/memcopy.asm

.b29f						MCCommand:
.b29f		a5 01		lda $01				lda 	1 							; save current I/O ; switch to I/O 0
.b2a1		48		pha				pha
.b2a2		64 01		stz $01				stz 	1
.b2a4		9c 00 df	stz $df00			stz 	$DF00 						; zero control byte.
.b2a7		a9 81		lda #$81			lda 	#$81 						; standard start byte (DMA Enabled, Start set)
.b2a9		8d e3 07	sta $07e3			sta 	DMAControlByte
.b2ac		20 5a b3	jsr $b35a			jsr 	MCPosition 					; start position
.b2af		a2 04		ldx #$04			ldx 	#4 							; write to source AND $DF04 destination address $DF08
.b2b1		20 2b b3	jsr $b32b			jsr 	MCCopyAddress
.b2b4		a2 08		ldx #$08			ldx 	#8
.b2b6		20 2b b3	jsr $b32b			jsr 	MCCopyAddress
.b2b9		b1 30		lda ($30),y			lda 	(codePtr),y
.b2bb		c8		iny				iny
.b2bc		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; , <size>
.b2be		f0 09		beq $b2c9			beq 	_MCSize1D
.b2c0		c9 d6		cmp #$d6			cmp 	#KWD_RECT 					; RECT <x>,<y>
.b2c2		f0 11		beq $b2d5			beq 	_MCRect2D
.b2c4						_MCSyntax:
.b2c4		a9 02		lda #$02		lda	#2
.b2c6		4c 4d 95	jmp $954d		jmp	ErrorHandler
.b2c9						_MCSize1D:
.b2c9		a2 00		ldx #$00			ldx 	#0 							; get size
.b2cb		20 23 a4	jsr $a423			jsr 	EvaluateInteger
.b2ce		a2 0c		ldx #$0c			ldx 	#$C 						; copy to size $DF0C-E
.b2d0		20 2b b3	jsr $b32b			jsr 	MCCopyAddress
.b2d3		80 24		bra $b2f9			bra 	_MCDestination
.b2d5						_MCRect2D:
.b2d5		a2 0c		ldx #$0c			ldx 	#$C 						; width to $DF0C,D
.b2d7		20 48 b3	jsr $b348			jsr 	MCEvalCopyData16
.b2da		20 3c 95	jsr $953c			jsr 	CheckComma
.b2dd		a2 0e		ldx #$0e			ldx 	#$E 						; height to $DF0E,F
.b2df		20 48 b3	jsr $b348			jsr 	MCEvalCopyData16
.b2e2		a9 ba		lda #$ba			lda 	#KWD_BY 					; BY keyword.
.b2e4		20 44 95	jsr $9544			jsr 	CheckNextA
.b2e7		a2 10		ldx #$10			ldx 	#$10 						; store source and destination stride
.b2e9		20 48 b3	jsr $b348			jsr 	MCEvalCopyData16
.b2ec		a2 12		ldx #$12			ldx 	#$12
.b2ee		20 4f b3	jsr $b34f			jsr 	MCCopyData16
.b2f1		ad e3 07	lda $07e3			lda 	DMAControlByte 				; set bit 4 of DMA control indicating 2D.
.b2f4		09 02		ora #$02			ora 	#$02
.b2f6		8d e3 07	sta $07e3			sta 	DMAControlByte
.b2f9						_MCDestination:
.b2f9		b1 30		lda ($30),y			lda 	(codePtr),y
.b2fb		c8		iny				iny
.b2fc		c9 d1		cmp #$d1			cmp 	#KWD_POKE 					; is it POKE n
.b2fe		f0 0e		beq $b30e			beq 	_MCDestPoke
.b300		c9 dd		cmp #$dd			cmp 	#KWD_TO 					; is it TO n
.b302		d0 c0		bne $b2c4			bne 	_MCSyntax
.b304		20 5a b3	jsr $b35a			jsr 	MCPosition 					; get target address
.b307		a2 08		ldx #$08			ldx 	#8							; copy to target address at $DF08-A
.b309		20 2b b3	jsr $b32b			jsr 	MCCopyAddress
.b30c		80 0e		bra $b31c			bra 	_MCDoDMA 					; and we can go.
.b30e						_MCDestPoke:
.b30e		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; POKE what
.b311		8d 01 df	sta $df01			sta 	$DF01 						; set the FILL register
.b314		ad e3 07	lda $07e3			lda 	DMAControlByte 				; set bit 2 of control byte indicating FILL.
.b317		09 04		ora #$04			ora 	#$04
.b319		8d e3 07	sta $07e3			sta 	DMAControlByte
.b31c						_MCDoDMA:
.b31c		ad e3 07	lda $07e3			lda 	DMAControlByte 				; set the DMA Control byte to go !
.b31f		8d 00 df	sta $df00			sta 	$DF00
.b322						_MCWaitBUSD:
.b322		ad 01 df	lda $df01			lda 	$DF01
.b325		30 fb		bmi $b322			bmi 	_MCWaitBUSD
.b327		68		pla				pla 								; restore I/O.
.b328		85 01		sta $01				sta 	1
.b32a		60		rts				rts
.b32b						MCCopyAddress:
.b32b		a5 80		lda $80				lda 	NSMantissa2 				; check valid vlaue
.b32d		29 f8		and #$f8			and 	#$F8
.b32f		05 90		ora $90				ora 	NSMantissa3
.b331		d0 10		bne $b343			bne 	_MCRange
.b333		a5 60		lda $60				lda 	NSMantissa0
.b335		9d 00 df	sta $df00,x			sta 	$DF00,x
.b338		a5 70		lda $70				lda 	NSMantissa1
.b33a		9d 01 df	sta $df01,x			sta 	$DF01,x
.b33d		a5 80		lda $80				lda 	NSMantissa2
.b33f		9d 02 df	sta $df02,x			sta 	$DF02,x
.b342		60		rts				rts
.b343						_MCRange:
.b343		a9 04		lda #$04		lda	#4
.b345		4c 4d 95	jmp $954d		jmp	ErrorHandler
.b348						MCEvalCopyData16:
.b348		da		phx				phx
.b349		a2 00		ldx #$00			ldx 	#0
.b34b		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger
.b34e		fa		plx				plx
.b34f						MCCopyData16:
.b34f		a5 60		lda $60				lda 	NSMantissa0
.b351		9d 00 df	sta $df00,x			sta 	$DF00,x
.b354		a5 70		lda $70				lda 	NSMantissa1
.b356		9d 01 df	sta $df01,x			sta 	$DF01,x
.b359		60		rts				rts
.b35a						MCPosition:
.b35a		a2 00		ldx #$00			ldx 	#0 							; get start address.
.b35c		b1 30		lda ($30),y			lda 	(codePtr),y
.b35e		c9 b9		cmp #$b9			cmp 	#KWD_AT
.b360		f0 04		beq $b366			beq 	_MCPAt
.b362		20 23 a4	jsr $a423			jsr 	EvaluateInteger
.b365		60		rts				rts
.b366						_MCPAt:
.b366		c8		iny				iny
.b367		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; X position
.b36a		48		pha				pha
.b36b		20 3c 95	jsr $953c			jsr 	CheckComma
.b36e		e8		inx				inx
.b36f		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; Y position
.b372		ca		dex				dex
.b373		85 70		sta $70				sta 	NSMantissa1 				; put Y x 64 in Mantissa.0
.b375		64 60		stz $60				stz 	NSMantissa0
.b377		64 80		stz $80				stz 	NSMantissa2
.b379		64 90		stz $90				stz 	NSMantissa3
.b37b		46 70		lsr $70				lsr 	NSMantissa1
.b37d		66 60		ror $60				ror 	NSMantissa0
.b37f		46 70		lsr $70				lsr 	NSMantissa1
.b381		66 60		ror $60				ror 	NSMantissa0
.b383		68		pla				pla
.b384		18		clc				clc
.b385		65 60		adc $60				adc 	NSMantissa0 				; add X, Y * 256 and the
.b387		85 60		sta $60				sta 	NSMantissa0
.b389		a5 70		lda $70				lda 	NSMantissa1
.b38b		65 61		adc $61				adc 	NSMantissa0+1
.b38d		85 70		sta $70				sta 	NSMantissa1
.b38f		90 02		bcc $b393			bcc 	_MCPNoCarry
.b391		e6 80		inc $80				inc 	NSMantissa2
.b393						_MCPNoCarry:
.b393		ad 03 09	lda $0903			lda 	gxBasePage
.b396		85 81		sta $81				sta 	NSMantissa2+1
.b398		64 61		stz $61				stz 	NSMantissa0+1
.b39a		64 71		stz $71				stz 	NSMantissa1+1
.b39c		64 91		stz $91				stz 	NSMantissa3+1
.b39e		a2 01		ldx #$01			ldx 	#1
.b3a0		20 cf a4	jsr $a4cf			jsr 	NSMShiftRight
.b3a3		20 cf a4	jsr $a4cf			jsr 	NSMShiftRight
.b3a6		20 cf a4	jsr $a4cf			jsr 	NSMShiftRight
.b3a9		a2 00		ldx #$00			ldx 	#0
.b3ab		20 4d 98	jsr $984d			jsr 	AddTopTwoStack
.b3ae		60		rts				rts
.07e3						DMAControlByte:
>07e3								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/mouse.asm

.b3af						MouseStatus:
.b3af		a9 ff		lda #$ff	        lda     #255
.b3b1		80 02		bra $b3b5	        bra     MouseCommand
.b3b3						MouseDeltaStatus:
.b3b3		a9 00		lda #$00	        lda     #0
.b3b5						MouseCommand:
.b3b5		8d 82 06	sta $0682	        sta     CMDMouseFlag
.b3b8		a2 00		ldx #$00	        ldx     #0
.b3ba						_MouseCommandLoop:
.b3ba		da		phx		        phx                                 ; save slot.
.b3bb		20 55 9a	jsr $9a55	        jsr     EvaluateExpressionAt0       ; evaluate a reference.
.b3be		a5 50		lda $50		        lda     NSStatus                    ; check it's a reference.
.b3c0		c9 20		cmp #$20	        cmp     #NSBIsReference
.b3c2		d0 60		bne $b424	        bne     _MouseNotRef
.b3c4		b1 30		lda ($30),y			lda 	(codePtr),y
.b3c6		c9 2c		cmp #$2c	        cmp     #KWD_COMMA
.b3c8		d0 01		bne $b3cb	        bne     _MouseNoSkipComma
.b3ca		c8		iny		        iny
.b3cb						_MouseNoSkipComma:
.b3cb		fa		plx		        plx                                 ; restore X
.b3cc		5a		phy		        phy                                 ; save Y
.b3cd		a5 60		lda $60		        lda     NSMantissa0                 ; copy address to zTemp0
.b3cf		85 36		sta $36		        sta     zTemp0
.b3d1		a5 70		lda $70		        lda     NSMantissa1
.b3d3		85 37		sta $37		        sta     zTemp0+1
.b3d5		a0 04		ldy #$04	        ldy     #4                          ; set exponent, m3, m2 , m1 , m0
.b3d7		a9 00		lda #$00	        lda     #0
.b3d9		91 36		sta ($36),y	        sta     (zTemp0),y                  ; exponent
.b3db		88		dey		        dey
.b3dc		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m3
.b3de		88		dey		        dey
.b3df		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m2
.b3e1		88		dey		        dey
.b3e2		2c 82 06	bit $0682	        bit     CMDMouseFlag                ; mouse or mdelta command
.b3e5		30 12		bmi $b3f9	        bmi     _MouseMouseCommand
.b3e7						_MouseMDeltaCommand:
.b3e7		bd a5 06	lda $06a5,x	        lda     MouseDeltaX,x
.b3ea		92 36		sta ($36)	        sta     (zTemp0)                    ; m0
.b3ec		bd a6 06	lda $06a6,x	        lda     MouseDeltaX+1,x
.b3ef		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m1
.b3f1		9e a5 06	stz $06a5,x	        stz     MouseDeltaX,x               ; clear entry in current table
.b3f4		9e a6 06	stz $06a6,x	        stz     MouseDeltaX+1,x
.b3f7		80 0a		bra $b403	        bra     _MouseProcessData
.b3f9						_MouseMouseCommand:
.b3f9		bd b1 06	lda $06b1,x	        lda     MousePosX,x
.b3fc		92 36		sta ($36)	        sta     (zTemp0)                    ; m0
.b3fe		bd b2 06	lda $06b2,x	        lda     MousePosX+1,x
.b401		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m1
.b403						_MouseProcessData:
.b403		b1 36		lda ($36),y	        lda     (zTemp0),y
.b405		10 15		bpl $b41c	        bpl     _MouseDataPos               ; signed 16 bit value, so fix up if -ve.
.b407		38		sec		        sec                                 ; negate the mantissa 2 bytes
.b408		a9 00		lda #$00	        lda     #0
.b40a		f2 36		sbc ($36)	        sbc     (zTemp0)
.b40c		92 36		sta ($36)	        sta     (zTemp0)
.b40e		a9 00		lda #$00	        lda     #0
.b410		f1 36		sbc ($36),y	        sbc     (zTemp0),y
.b412		91 36		sta ($36),y	        sta     (zTemp0),y
.b414		a0 03		ldy #$03	        ldy     #3
.b416		b1 36		lda ($36),y	        lda     (zTemp0),y                  ; set upper bit of mantissa
.b418		09 80		ora #$80	        ora     #$80
.b41a		91 36		sta ($36),y	        sta     (zTemp0),y
.b41c						_MouseDataPos:
.b41c		7a		ply		        ply                                 ; restore Y.
.b41d		e8		inx		        inx                                 ; next entry
.b41e		e8		inx		        inx
.b41f		e0 0c		cpx #$0c	        cpx     #6*2                        ; done 6 reads to variables.
.b421		d0 97		bne $b3ba	        bne     _MouseCommandLoop
.b423		60		rts		        rts
.b424						_MouseNotRef:
.b424		a9 07		lda #$07		lda	#7
.b426		4c 4d 95	jmp $954d		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/setdatetime.asm

.b429						CommandSetDate:
.b429		a9 03		lda #$03			lda 	#3
.b42b		80 02		bra $b42f			bra 	CSDTMain
.b42d						CommandSetTime:
.b42d		a9 00		lda #$00			lda 	#0
.b42f						CSDTMain:
.b42f		48		pha				pha 								; save table offsets 0 or 3
.b430		a2 00		ldx #$00			ldx 	#0 							; input 3 values.
.b432		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.b435		20 3c 95	jsr $953c			jsr 	CheckComma
.b438		e8		inx				inx
.b439		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.b43c		20 3c 95	jsr $953c			jsr 	CheckComma
.b43f		e8		inx				inx
.b440		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger
.b443		68		pla				pla 								; table offset in Y, saving Y
.b444		5a		phy				phy
.b445		a8		tay				tay
.b446		a2 00		ldx #$00			ldx 	#0 							; first number
.b448		a5 01		lda $01				lda 	1 							; save I/O page, switch to zero
.b44a		48		pha				pha
.b44b		64 01		stz $01				stz 	1
.b44d						_CSDTCopy:
.b44d		b5 60		lda $60,x			lda 	NSMantissa0,x 				; get first number
.b44f		d9 91 b4	cmp $b491,y			cmp 	RTCWMinValues,y 			; check range
.b452		90 1b		bcc $b46f			bcc 	_CSDTRange
.b454		d9 97 b4	cmp $b497,y			cmp 	RTCWMaxValues,y
.b457		b0 16		bcs $b46f			bcs 	_CSDTRange
.b459		20 74 b4	jsr $b474			jsr 	CSDTDecimalToBCD
.b45c		da		phx				phx 								; save X
.b45d		be 8b b4	ldx $b48b,y			ldx 	RTCWOffset,y 				; offset in RTC in X
.b460		9d 90 d6	sta $d690,x			sta 	$D690,x 					; write to RTC
.b463		fa		plx				plx 								; restore X
.b464		e8		inx				inx 								; next number
.b465		c8		iny				iny 								; next table entries
.b466		e0 03		cpx #$03			cpx 	#3 							; until done all 3.
.b468		d0 e3		bne $b44d			bne 	_CSDTCopy
.b46a		68		pla				pla 								; restore I/O space
.b46b		85 01		sta $01				sta 	1
.b46d		7a		ply				ply 								; restore code pos and exit.
.b46e		60		rts				rts
.b46f						_CSDTRange:
.b46f		a9 04		lda #$04		lda	#4
.b471		4c 4d 95	jmp $954d		jmp	ErrorHandler
.b474						CSDTDecimalToBCD:
.b474		da		phx				phx 								; 10 count in X
.b475		a2 00		ldx #$00			ldx 	#0
.b477						_CSDTDBLoop:
.b477		c9 0a		cmp #$0a			cmp 	#10 						; < 10 evaluate result.
.b479		90 05		bcc $b480			bcc 	_CSDTDBExit
.b47b		e9 0a		sbc #$0a			sbc 	#10 						; 10 from value
.b47d		e8		inx				inx 								; one more 10s.
.b47e		80 f7		bra $b477			bra 	_CSDTDBLoop
.b480						_CSDTDBExit:
.b480		85 36		sta $36				sta 	zTemp0 						; units
.b482		8a		txa				txa 								; 10s x 16
.b483		0a		asl a				asl 	a
.b484		0a		asl a				asl 	a
.b485		0a		asl a				asl 	a
.b486		0a		asl a				asl 	a
.b487		05 36		ora $36				ora 	zTemp0 						; BCD result and exit
.b489		fa		plx				plx
.b48a		60		rts				rts
.b48b						RTCWOffset:
>b48b		04 02 00 06 09 0a				.byte 	4,2,0,6,9,10
.b491						RTCWMinValues:
>b491		00 00 00 01 01 00				.byte 	0,0,0,1,1,0
.b497						RTCWMaxValues:
>b497		18 3c 3c 20 0d 64				.byte 	24,60,60,32,13,100

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/timer.asm

.b49d						UnaryTimer:
.b49d		fa		plx				plx
.b49e		20 34 95	jsr $9534			jsr 	CheckRightBracket
.b4a1						TimerToStackX:
.b4a1		20 b6 a4	jsr $a4b6			jsr 	NSMSetZero 					; zero result
.b4a4		64 01		stz $01				stz 	1 							; access I/O
.b4a6		ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.b4a9		95 60		sta $60,x			sta 	NSMantissa0,x
.b4ab		ad 5a d6	lda $d65a			lda 	$D65A
.b4ae		95 70		sta $70,x			sta 	NSMantissa1,x
.b4b0		ad 5b d6	lda $d65b			lda 	$D65B
.b4b3		95 80		sta $80,x			sta 	NSMantissa2,x
.b4b5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/getdatetime.asm

.b4b6						UnaryGetTime:
.b4b6		a9 00		lda #$00			lda 	#0
.b4b8		80 02		bra $b4bc			bra 	UGDTMain
.b4ba						UnaryGetDate:
.b4ba		a9 03		lda #$03			lda 	#3
.b4bc						UGDTMain:
.b4bc		fa		plx				plx 								; get stack position back
.b4bd		48		pha				pha 								; save table offset
.b4be		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger			; ignored parameter
.b4c1		20 34 95	jsr $9534			jsr 	CheckRightBracket 			; closing )
.b4c4		68		pla				pla 								; table offset in A
.b4c5		5a		phy				phy 								; saving Y
.b4c6		a8		tay				tay 								; table offset in Y
.b4c7		a9 08		lda #$08			lda 	#8							; allocate space for 8 chars DD:MM:YY
.b4c9		20 bd b7	jsr $b7bd			jsr 	StringTempAllocate
.b4cc		a5 01		lda $01				lda 	1 							; save I/O table and switch to I/O page 0
.b4ce		48		pha				pha
.b4cf		64 01		stz $01				stz 	1
.b4d1		20 e4 b4	jsr $b4e4			jsr 	UGDTDigit 					; do XX:YY:ZZ
.b4d4		20 df b4	jsr $b4df			jsr 	UGDTColonDigit
.b4d7		20 df b4	jsr $b4df			jsr 	UGDTColonDigit
.b4da		68		pla				pla 								; restore I/O select
.b4db		85 01		sta $01				sta 	1
.b4dd		7a		ply				ply  								; restore code position
.b4de		60		rts				rts
.b4df						UGDTColonDigit:
.b4df		a9 3a		lda #$3a			lda 	#':'
.b4e1		20 f6 b7	jsr $b7f6			jsr 	StringTempWrite
.b4e4						UGDTDigit:
.b4e4		da		phx				phx 								; save X
.b4e5		b9 04 b5	lda $b504,y			lda 	RTCROffset,y 				; get offset in RTC register
.b4e8		aa		tax				tax
.b4e9		bd 90 d6	lda $d690,x			lda 	$D690,x 					; read RTC register
.b4ec		39 0a b5	and $b50a,y			and 	RTCRMask,y 					; and with Mask.
.b4ef		fa		plx				plx
.b4f0		48		pha				pha 								; output in BCD
.b4f1		4a		lsr a				lsr 	a
.b4f2		4a		lsr a				lsr 	a
.b4f3		4a		lsr a				lsr 	a
.b4f4		4a		lsr a				lsr 	a
.b4f5		09 30		ora #$30			ora 	#48
.b4f7		20 f6 b7	jsr $b7f6			jsr 	StringTempWrite
.b4fa		68		pla				pla
.b4fb		29 0f		and #$0f			and 	#15
.b4fd		09 30		ora #$30			ora 	#48
.b4ff		20 f6 b7	jsr $b7f6			jsr 	StringTempWrite
.b502		c8		iny				iny
.b503		60		rts				rts
.b504						RTCROffset:
>b504		04 02 00 06 09 0a				.byte 	4,2,0,6,9,10
.b50a						RTCRMask:
>b50a		3f 7f 7f 3f 1f 7f				.byte 	$3F,$7F,$7F,$3F,$1F,$7F

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/getinkey.asm

.b510						AscGet:
.b510		fa		plx				plx 								; restore stack pos
.b511						AscGet2:
.b511		20 34 95	jsr $9534			jsr 	CheckRightBracket
.b514		20 f5 81	jsr $81f5			jsr 	KNLGetSingleCharacter
.b517		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte
.b51a		60		rts				rts
.b51b						_AGBreak:
.b51b		a9 01		lda #$01		lda	#1
.b51d		4c 4d 95	jmp $954d		jmp	ErrorHandler
.b520						AscInkey:
.b520		fa		plx				plx 								; restore stack pos
.b521						AscInkey2:
.b521		20 34 95	jsr $9534			jsr 	CheckRightBracket
.b524		20 d3 81	jsr $81d3			jsr 	KNLGetKeyPressed
.b527		20 b8 a4	jsr $a4b8			jsr 	NSMSetByte
.b52a		60		rts				rts
.b52b						ChrGet:
.b52b		fa		plx				plx
.b52c		20 11 b5	jsr $b511			jsr 	AscGet2
.b52f		4c 36 b5	jmp $b536			jmp 	GetInkeyToString
.b532						ChrInkey:
.b532		fa		plx				plx
.b533		20 21 b5	jsr $b521			jsr 	AscInkey2
.b536						GetInkeyToString:
.b536		c9 00		cmp #$00			cmp 	#0 							; if zero, return ""
.b538		f0 0b		beq $b545			beq 	_GKISNull
.b53a		48		pha				pha
.b53b		a9 01		lda #$01			lda 	#1 							; allocate space for one char
.b53d		20 bd b7	jsr $b7bd			jsr 	StringTempAllocate
.b540		68		pla				pla 								; write number to it
.b541		20 f6 b7	jsr $b7f6			jsr 	StringTempWrite
.b544		60		rts				rts
.b545						_GKISNull:
.b545		a9 00		lda #$00			lda 	#0
.b547		20 bd b7	jsr $b7bd			jsr 	StringTempAllocate
.b54a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/keydown.asm

.b54b						KeyDown:
.b54b		20 58 81	jsr $8158			jsr 	ProcessEvents 				; process outstanding events.
.b54e		fa		plx				plx 								; restore stack pos
.b54f		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; key to check.
.b552		48		pha				pha 								; check right bracket.
.b553		20 34 95	jsr $9534			jsr 	CheckRightBracket
.b556		68		pla				pla
.b557		20 2d 84	jsr $842d			jsr 	KeyboardConvertXA 			; get offset and mask.
.b55a		3d 83 06	and $0683,x			and 	KeyStatus,x 				; is it zero ?
.b55d		f0 03		beq $b562			beq 	_KeyUp
.b55f		4c c0 95	jmp $95c0			jmp 	ReturnTrue
.b562		4c cb 95	jmp $95cb	_KeyUp:	jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/rnd.asm

.b565						Unary_Random:
.b565		fa		plx				plx
.b566		20 b6 b5	jsr $b5b6			jsr 	URCopyToMantissa  			; put random # in mantissa
.b569		b1 30		lda ($30),y			lda 	(codePtr),y
.b56b		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.b56d		f0 08		beq $b577			beq 	_URNoModulus 				; then we return a random 30 bit number.
.b56f		e8		inx				inx
.b570		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.b573		ca		dex				dex
.b574		20 12 97	jsr $9712			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.b577						_URNoModulus:
.b577		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.b579		74 a0		stz $a0,x			stz 	NSExponent,x
.b57b		20 34 95	jsr $9534			jsr 	CheckRightBracket
.b57e		60		rts				rts
.b57f						Unary_Rnd:
.b57f		fa		plx				plx
.b580		20 04 a4	jsr $a404			jsr 	EvaluateNumber 				; number to use.
.b583		20 34 95	jsr $9534			jsr 	CheckRightBracket 			; closing bracket
.b586		b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.b588		10 20		bpl $b5aa			bpl 	_URDontSeed
.b58a		a5 01		lda $01				lda 	1 							; switch to page 0
.b58c		48		pha				pha
.b58d		64 01		stz $01				stz 	1
.b58f		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.b591		49 17		eor #$17			eor 	#$17
.b593		8d a4 d6	sta $d6a4			sta 	$D6A4
.b596		b5 70		lda $70,x			lda 	NSMantissa1,x
.b598		49 a5		eor #$a5			eor 	#$A5
.b59a		8d a5 d6	sta $d6a5			sta 	$D6A5
.b59d		a9 03		lda #$03			lda 	#3 							; set bit 1 high/low to set seed.
.b59f		8d a6 d6	sta $d6a6			sta 	$D6A6
.b5a2		a9 01		lda #$01			lda 	#1
.b5a4		8d a6 d6	sta $d6a6			sta 	$D6A6
.b5a7		68		pla				pla
.b5a8		85 01		sta $01				sta 	1
.b5aa						_URDontSeed:
.b5aa		20 b6 b5	jsr $b5b6			jsr 	URCopyToMantissa 			; copy into mantissa
.b5ad		a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.b5af		95 a0		sta $a0,x			sta 	NSExponent,x
.b5b1		a9 08		lda #$08			lda 	#NSTFloat
.b5b3		95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.b5b5		60		rts				rts
.b5b6						URCopyToMantissa:
.b5b6		a5 01		lda $01				lda 	1 							; switch to I/O page 1
.b5b8		48		pha				pha
.b5b9		64 01		stz $01				stz 	1
.b5bb		a9 01		lda #$01			lda 	#1
.b5bd		8d a6 d6	sta $d6a6			sta 	$D6A6 						; enable LFSR
.b5c0		ad a4 d6	lda $d6a4			lda 	$D6A4
.b5c3		95 60		sta $60,x			sta 	NSMantissa0,x
.b5c5		ad a5 d6	lda $d6a5			lda 	$D6A5
.b5c8		95 70		sta $70,x			sta 	NSMantissa1,x
.b5ca		ad a4 d6	lda $d6a4			lda 	$D6A4
.b5cd		95 80		sta $80,x			sta 	NSMantissa2,x
.b5cf		ad a5 d6	lda $d6a5			lda 	$D6A5
.b5d2		29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.b5d4		95 90		sta $90,x			sta 	NSMantissa3,x
.b5d6		68		pla				pla
.b5d7		85 01		sta $01				sta 	1
.b5d9		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/effects.asm

.b5da						PingCommand:
.b5da		5a		phy				phy 								; save pos
.b5db		a9 01		lda #$01			lda 	#1 						; push channel.
.b5dd		48		pha				pha
.b5de		a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.b5e0		a2 06		ldx #$06			ldx 	#6 						; length
.b5e2		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b5e4		80 24		bra $b60a			bra 	SoundEffectCommand
.b5e6						ZapCommand:
.b5e6		5a		phy				phy 								; save pos
.b5e7		a9 01		lda #$01			lda 	#1 						; push channel.
.b5e9		48		pha				pha
.b5ea		a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.b5ec		a2 0a		ldx #$0a			ldx 	#10 						; length
.b5ee		a0 0a		ldy #$0a			ldy 	#10 						; slide LSB
.b5f0		80 18		bra $b60a			bra 	SoundEffectCommand
.b5f2						ShootCommand:
.b5f2		5a		phy				phy 								; save pos
.b5f3		a9 03		lda #$03			lda 	#3 						; push channel.
.b5f5		48		pha				pha
.b5f6		a9 20		lda #$20			lda 	#32 						; pitch LSB
.b5f8		a2 04		ldx #$04			ldx 	#4 						; length
.b5fa		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b5fc		80 0c		bra $b60a			bra 	SoundEffectCommand
.b5fe						Explode:
.b5fe		5a		phy				phy 								; save pos
.b5ff		a9 03		lda #$03			lda 	#3 						; push channel.
.b601		48		pha				pha
.b602		a9 50		lda #$50			lda 	#80 						; pitch LSB
.b604		a2 0a		ldx #$0a			ldx 	#10 						; length
.b606		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b608		80 00		bra $b60a			bra 	SoundEffectCommand
.b60a						SoundEffectCommand:
.b60a		8d e4 07	sta $07e4			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.b60d		9c e5 07	stz $07e5			stz 	SoundCommandBlock+1
.b610		a9 0f		lda #$0f			lda 	#15
.b612		8d e6 07	sta $07e6			sta 	SoundCommandBlock+2
.b615		8e e7 07	stx $07e7			stx 	SoundCommandBlock+3
.b618		8c e8 07	sty $07e8			sty 	SoundCommandBlock+4
.b61b		9c e9 07	stz $07e9			stz 	SoundCommandBlock+5
.b61e		68		pla				pla
.b61f		09 10		ora #$10			ora 	#$10  						; execute command $11
.b621		a2 e4		ldx #$e4			ldx 	#(SoundCommandBlock & $FF)
.b623		a0 07		ldy #$07			ldy 	#(SoundCommandBlock >> 8)
.b625		20 6b 80	jsr $806b			jsr 	SNDCommand
.b628		7a		ply				ply
.b629		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/playing.asm

.b62a						UnaryPlaying:
.b62a		fa		plx				plx
.b62b		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; get channel #
.b62e		48		pha				pha
.b62f		20 34 95	jsr $9534			jsr		CheckRightBracket
.b632		68		pla				pla
.b633		c9 04		cmp #$04			cmp 	#4
.b635		b0 0c		bcs $b643			bcs 	_UPNotPlaying
.b637		09 20		ora #$20			ora 	#$20 						; query playing ?
.b639		20 6b 80	jsr $806b			jsr 	SNDCommand
.b63c		c9 00		cmp #$00			cmp 	#0
.b63e		f0 03		beq $b643			beq 	_UPNotPlaying
.b640		4c c0 95	jmp $95c0			jmp 	ReturnTrue
.b643						_UPNotPlaying:
.b643		4c cb 95	jmp $95cb			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/sound.asm

.b646						SoundCommand:
.b646		b1 30		lda ($30),y			lda 	(codePtr),y
.b648		c9 cc		cmp #$cc			cmp 	#KWD_OFF 					; SOUND OFF ?
.b64a		d0 09		bne $b655			bne 	_SNDMain
.b64c		c8		iny				iny 								; skip OFF
.b64d		a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.b64f		5a		phy				phy
.b650		20 6b 80	jsr $806b			jsr 	SNDCommand
.b653		7a		ply				ply
.b654		60		rts				rts
.b655						_SNDMain:
.b655		a2 00		ldx #$00			ldx 	#0
.b657		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; channel
.b65a		c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.b65c		b0 4b		bcs $b6a9			bcs 	_SndError
.b65e		e8		inx				inx 								; do the rest in slot 1.
.b65f		20 3c 95	jsr $953c			jsr 	CheckComma
.b662		20 36 a4	jsr $a436			jsr 	Evaluate16BitInteger 		; Pitch
.b665		b5 70		lda $70,x			lda 	NSMantissa1,x 				; must be 10 bit
.b667		c9 10		cmp #$10			cmp 	#16
.b669		b0 3e		bcs $b6a9			bcs 	_SndError
.b66b		8d e5 07	sta $07e5			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.b66e		b5 60		lda $60,x			lda 	NSMantissa0,x
.b670		8d e4 07	sta $07e4			sta 	SoundCommandBlock
.b673		20 3c 95	jsr $953c			jsr 	CheckComma
.b676		20 51 a4	jsr $a451			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.b679		8d e7 07	sta $07e7			sta 	SoundCommandBlock+3
.b67c		a9 0f		lda #$0f			lda 	#15
.b67e		8d e6 07	sta $07e6			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.b681		9c e8 07	stz $07e8			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.b684		9c e9 07	stz $07e9			stz 	SoundCommandBlock+5
.b687		b1 30		lda ($30),y			lda 	(codePtr),y
.b689		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.b68b		d0 0e		bne $b69b			bne 	_SNDPlay
.b68d		c8		iny				iny
.b68e		20 40 a4	jsr $a440			jsr 	Evaluate16BitIntegerSigned 	; Slide
.b691		b5 60		lda $60,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.b693		8d e8 07	sta $07e8			sta 	SoundCommandBlock+4
.b696		b5 70		lda $70,x			lda 	NSMantissa1,x
.b698		8d e9 07	sta $07e9			sta 	SoundCommandBlock+5
.b69b						_SNDPlay:
.b69b		5a		phy				phy
.b69c		a5 60		lda $60				lda 	NSMantissa0 				; channel.
.b69e		09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.b6a0		a2 e4		ldx #$e4			ldx 	#(SoundCommandBlock & $FF)
.b6a2		a0 07		ldy #$07			ldy 	#(SoundCommandBlock >> 8)
.b6a4		20 6b 80	jsr $806b			jsr 	SNDCommand
.b6a7		7a		ply				ply
.b6a8		60		rts				rts
.b6a9						_SndError:
.b6a9		4c 33 a6	jmp $a633			jmp 	RangeError
.07e4						SoundCommandBlock:
>07e4								.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.b6ac						StackPushByte:
.b6ac		48		pha				pha 								; save byte on stack
.b6ad		a5 34		lda $34				lda 	basicStack 					; decrement basic stack pointer
.b6af		d0 08		bne $b6b9			bne 	_SPBNoBorrow
.b6b1		c6 35		dec $35				dec 	basicStack+1 				; borrow
.b6b3		a5 35		lda $35				lda 	basicStack+1 				; check range.
.b6b5		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.b6b7		90 06		bcc $b6bf			bcc 	_SPBMemory
.b6b9						_SPBNoBorrow:
.b6b9		c6 34		dec $34				dec 	basicStack
.b6bb		68		pla				pla 								; get back and write
.b6bc		92 34		sta ($34)			sta 	(basicStack)
.b6be		60		rts				rts
.b6bf						_SPBMemory:
.b6bf		a9 12		lda #$12		lda	#18
.b6c1		4c 4d 95	jmp $954d		jmp	ErrorHandler
.b6c4						StackPopByte:
.b6c4		b2 34		lda ($34)			lda 	(basicStack) 				; bump the stack pointer.
.b6c6		e6 34		inc $34				inc 	basicStack
.b6c8		d0 02		bne $b6cc			bne 	_SPBNoCarry
.b6ca		e6 35		inc $35				inc 	basicStack+1
.b6cc						_SPBNoCarry:
.b6cc		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.b6cd						StackOpen:
.b6cd		48		pha				pha 								; save frame byte
.b6ce		29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.b6d0		0a		asl a				asl 	a 							; claim twice this for storage
.b6d1		49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.b6d3		38		sec				sec 								; so basically subtracting from
.b6d4		65 34		adc $34				adc 	basicStack 	 				; basicStack
.b6d6		85 34		sta $34				sta 	basicStack
.b6d8		b0 09		bcs $b6e3			bcs 	_SONoBorrow
>b6da		db						.byte 	$DB 						; causes a break in the emulator
.b6db		c6 35		dec $35				dec 	basicStack+1
.b6dd		a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.b6df		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.b6e1		90 04		bcc $b6e7			bcc 	_SOMemory
.b6e3						_SONoBorrow:
.b6e3		68		pla				pla 								; get marker back and write at TOS
.b6e4		92 34		sta ($34)			sta 	(basicStack)
.b6e6		60		rts				rts
.b6e7						_SOMemory:
.b6e7		a9 12		lda #$12		lda	#18
.b6e9		4c 4d 95	jmp $954d		jmp	ErrorHandler
.b6ec						StackClose:
.b6ec		b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.b6ee		29 0f		and #$0f			and 	#$0F 						; bytes to add back
.b6f0		0a		asl a				asl 	a 							; claim twice this.
.b6f1		65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.b6f3		85 34		sta $34				sta 	basicStack
.b6f5		90 02		bcc $b6f9			bcc 	_SCExit
.b6f7		e6 35		inc $35				inc 	basicStack+1
.b6f9						_SCExit:
.b6f9		60		rts				rts
.b6fa						StackCheckFrame:
.b6fa		48		pha				pha
.b6fb						_StackRemoveLocals:
.b6fb		b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.b6fd		c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.b6ff		b0 05		bcs $b706			bcs 	_SCNoLocal
.b701		20 1f 8f	jsr $8f1f			jsr 	LocalPopValue 				; restore the local value
.b704		80 f5		bra $b6fb			bra 	_StackRemoveLocals 			; gr round again
.b706						_SCNoLocal:
.b706		68		pla				pla 								; get the frame check.
.b707		52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.b709		29 f0		and #$f0			and 	#$F0 						; check type bits
.b70b		d0 01		bne $b70e			bne 	_SCFError 					; different, we have structures mixed up
.b70d		60		rts				rts
.b70e						_SCFError:
.b70e		8a		txa				txa 								; report error X
.b70f		4c 4d 95	jmp $954d			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.b712						STKSaveCodePosition:
.b712		5a		phy				phy
.b713		98		tya				tya 								; save Y
.b714		a0 05		ldy #$05			ldy 	#5
.b716		91 34		sta ($34),y			sta 	(basicStack),y
.b718		88		dey				dey 								; save Code Pointer
.b719						_STKSaveLoop:
.b719		b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.b71c		91 34		sta ($34),y			sta 	(basicStack),y
.b71e		88		dey				dey
.b71f		d0 f8		bne $b719			bne 	_STKSaveLoop
.b721		7a		ply				ply
.b722		60		rts				rts
.b723						STKLoadCodePosition:
.b723		a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.b725						_STKLoadLoop:
.b725		b1 34		lda ($34),y			lda 	(basicStack),y
.b727		99 2f 00	sta $002f,y			sta 	safePtr-1,y
.b72a		c8		iny				iny
.b72b		c0 05		cpy #$05			cpy 	#5
.b72d		d0 f6		bne $b725			bne 	_STKLoadLoop
.b72f		b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.b731		a8		tay				tay
.b732		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.b733						StackReset:
.b733		a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.b735		85 34		sta $34				sta 	0+basicStack
.b737		a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.b739		85 35		sta $35				sta 	1+basicStack
.b73b		a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.b73d		92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.b73f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.b740						StringConcrete:
.b740		5a		phy				phy 								; save position on stack
.b741		20 96 a0	jsr $a096			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.b744		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.b746		85 38		sta $38				sta 	zTemp1
.b748		b5 70		lda $70,x			lda 	NSMantissa1,x
.b74a		85 39		sta $39				sta 	zTemp1+1
.b74c		a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.b74e						_SALength:
.b74e		c8		iny				iny
.b74f		b1 38		lda ($38),y			lda 	(zTemp1),y
.b751		d0 fb		bne $b74e			bne 	_SALength
.b753		c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.b755		b0 3d		bcs $b794			bcs 	_SALengthError
.b757		98		tya				tya 				 				; length of the new string
.b758		18		clc				clc
.b759		69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.b75b		90 02		bcc $b75f			bcc 	_SAHaveLength
.b75d		a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.b75f						_SAHaveLength:
.b75f		48		pha				pha 								; save length.
.b760		38		sec				sec
.b761		49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.b763		6d 2a 04	adc $042a			adc 	stringMemory
.b766		8d 2a 04	sta $042a			sta 	stringMemory
.b769		85 3a		sta $3a				sta 	zTemp2 						; update storage address
.b76b		95 60		sta $60,x			sta 	NSMantissa0,x 				; update mantissa address
.b76d		a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.b76f		6d 2b 04	adc $042b			adc 	stringMemory+1
.b772		8d 2b 04	sta $042b			sta 	stringMemory+1
.b775		85 3b		sta $3b				sta 	zTemp2+1
.b777		95 70		sta $70,x			sta 	NSMantissa1,x
.b779		68		pla				pla 								; save length-3 (chars allowed) in first byte
.b77a		38		sec				sec
.b77b		e9 03		sbc #$03			sbc 	#3
.b77d		92 3a		sta ($3a)			sta 	(zTemp2)
.b77f		a9 00		lda #$00			lda 	#0 							; clear the status byte.
.b781		a0 01		ldy #$01			ldy 	#1
.b783		91 3a		sta ($3a),y			sta 	(zTemp2),y
.b785						_SACopyNewString:
.b785		a0 00		ldy #$00			ldy 	#0
.b787						_SACopyNSLoop:
.b787		b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.b789		c8		iny				iny 								; write two on in string storage
.b78a		c8		iny				iny
.b78b		91 3a		sta ($3a),y			sta 	(zTemp2),y
.b78d		88		dey				dey 								; this makes it one one.
.b78e		c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.b790		d0 f5		bne $b787			bne 	_SACopyNSLoop
.b792		7a		ply				ply
.b793		60		rts				rts
.b794						_SALengthError:
.b794		a9 09		lda #$09		lda	#9
.b796		4c 4d 95	jmp $954d		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.b799						StringSystemInitialise:
.b799		a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.b79b		8d 2a 04	sta $042a			sta 	0+stringMemory
.b79e		a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.b7a0		8d 2b 04	sta $042b			sta 	1+stringMemory
.b7a3		9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.b7a6		60		rts				rts
.b7a7						StringSpaceInitialise:
.b7a7		20 96 a0	jsr $a096			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.b7aa		a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.b7ac		8d 2c 04	sta $042c			sta 	stringInitialised
.b7af		ad 2a 04	lda $042a			lda 	stringMemory 				; allocate 256 bytes for one concreted string
.b7b2		8d 2d 04	sta $042d			sta 	stringTempPointer 			; so temporary string space is allocated below that.
.b7b5		ad 2b 04	lda $042b			lda 	stringMemory+1
.b7b8		3a		dec a				dec 	a
.b7b9		8d 2e 04	sta $042e			sta 	stringTempPointer+1
.b7bc		60		rts				rts
.b7bd						StringTempAllocate:
.b7bd		c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.b7bf		b0 30		bcs $b7f1			bcs 	_STALength
.b7c1		2c 2c 04	bit $042c			bit 	stringInitialised 			; already initialised
.b7c4		30 05		bmi $b7cb			bmi 	_STAAllocate
.b7c6		48		pha				pha 								; save value to subtract.
.b7c7		20 a7 b7	jsr $b7a7			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.b7ca		68		pla				pla 								; restore it
.b7cb						_STAAllocate:
.b7cb		49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.b7cd		18		clc				clc  								; deliberate allows one more
.b7ce		6d 2d 04	adc $042d			adc 	stringTempPointer 			; subtract from temp pointer
.b7d1		8d 2d 04	sta $042d			sta 	stringTempPointer
.b7d4		95 60		sta $60,x			sta 	NSMantissa0,x 				; address in mantissa
.b7d6		85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.b7d8		ad 2e 04	lda $042e			lda 	stringTempPointer+1
.b7db		69 ff		adc #$ff			adc 	#$FF
.b7dd		8d 2e 04	sta $042e			sta 	stringTempPointer+1
.b7e0		85 3d		sta $3d				sta 	zsTemp+1
.b7e2		95 70		sta $70,x			sta 	NSMantissa1,x
.b7e4		74 80		stz $80,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.b7e6		74 90		stz $90,x			stz 	NSMantissa3,x
.b7e8		a9 10		lda #$10			lda 	#NSTString
.b7ea		95 50		sta $50,x			sta 	NSStatus,x
.b7ec		a9 00		lda #$00			lda 	#0 							; clear the target string
.b7ee		92 3c		sta ($3c)			sta 	(zsTemp)
.b7f0		60		rts				rts
.b7f1						_STALength:
.b7f1		a9 09		lda #$09		lda	#9
.b7f3		4c 4d 95	jmp $954d		jmp	ErrorHandler
.b7f6						StringTempWrite:
.b7f6		48		pha				pha
.b7f7		92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.b7f9		e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.b7fb		d0 02		bne $b7ff			bne 	_STWNoCarry
.b7fd		e6 3d		inc $3d				inc 	zsTemp+1
.b7ff						_STWNoCarry:
.b7ff		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.b801		92 3c		sta ($3c)			sta 	(zsTemp)
.b803		68		pla				pla
.b804		60		rts				rts

;******  Return to file: _basic.asm

.b805						StartModuleCode:

;******  Processing file: ../modules/.build/hardware.module.asm

=1						hardwareIntegrated=1
=0						CONBlack = 0
=1						CONGrey = 1
=2						CONDarkBlue = 2
=3						CONGreen = 3
=4						CONPurple = 4
=5						CONBrown = 5
=6						CONOrange = 6
=7						CONCyan = 7
=8						CONDarkGrey = 8
=9						CONLightGrey = 9
=10						CONLightBlue = 10
=11						CONLightGreen = 11
=12						CONPink = 12
=13						CONRed = 13
=14						CONYellow = 14
=15						CONWhite = 15
=9						CONForeground = CONLightGrey
=2						CONBackground = CONDarkBlue
=9						CLICommandLine = CONLightGrey
.c000	a000					Export_EXTPrintNoControl:
.c000	a000	48		pha				pha
.c001	a001	da		phx				phx
.c002	a002	5a		phy				phy
.c003	a003	a6 01		ldx $01				ldx 	1
.c005	a005	da		phx				phx
.c006	a006	ac eb 07	ldy $07eb			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.c009	a009	80 11		bra $a01c			bra 	PrintCharacterOnly
.c00b	a00b					Export_EXTPrintCharacter:
.c00b	a00b					PAGEDPrintCharacter:
.c00b	a00b	48		pha				pha
.c00c	a00c	da		phx				phx
.c00d	a00d	5a		phy				phy
.c00e	a00e	a6 01		ldx $01				ldx 	1
.c010	a010	da		phx				phx
.c011	a011	ac eb 07	ldy $07eb			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.c014	a014	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.c016	a016	30 48		bmi $a060			bmi 	EXPCColour
.c018	a018	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.c01a	a01a	90 4d		bcc $a069			bcc 	EXPCControl
.c01c	a01c					PrintCharacterOnly:
.c01c	a01c	a2 02		ldx #$02			ldx 	#2 							; select char memory
.c01e	a01e	86 01		stx $01				stx 	1
.c020	a020	91 40		sta ($40),y			sta 	(EXTAddress),y
.c022	a022	e6 01		inc $01				inc 	1 							; select colour memory
.c024	a024	ad ec 07	lda $07ec			lda 	EXTTextColour
.c027	a027	91 40		sta ($40),y			sta 	(EXTAddress),y
.c029	a029	c8		iny				iny 								; advance horizontal position
.c02a	a02a	8c eb 07	sty $07eb			sty 	EXTColumn
.c02d	a02d	cc ed 07	cpy $07ed			cpy 	EXTScreenWidth 				; reached RHS ?
.c030	a030	90 63		bcc $a095			bcc 	EXPCExit 					; no, then exit.
.c032	a032					EXPCCRLF:
.c032	a032	ee ea 07	inc $07ea			inc 	EXTRow  					; bump row
.c035	a035	9c eb 07	stz $07eb			stz 	EXTColumn 					; back to column 0
.c038	a038	ad ea 07	lda $07ea			lda 	EXTRow 						; check if reached the bottom ?
.c03b	a03b	cd ee 07	cmp $07ee			cmp 	EXTScreenHeight 			; if so, then scroll.
.c03e	a03e	f0 18		beq $a058			beq 	EXPCScroll
.c040	a040	18		clc				clc 								; add width to address.
.c041	a041	a5 40		lda $40				lda 	EXTAddress
.c043	a043	6d ed 07	adc $07ed			adc 	EXTScreenWidth
.c046	a046	85 40		sta $40				sta 	EXTAddress
.c048	a048	90 4b		bcc $a095			bcc 	EXPCExit
.c04a	a04a	e6 41		inc $41				inc 	EXTAddress+1
.c04c	a04c	80 47		bra $a095			bra 	EXPCExit
.c04e	a04e					EXPCLeft:
.c04e	a04e	ce eb 07	dec $07eb			dec 	EXTColumn
.c051	a051	10 42		bpl $a095			bpl 	EXPCExit
.c053	a053					EXPCBegin:
.c053	a053	9c eb 07	stz $07eb			stz 	EXTColumn
.c056	a056	80 3d		bra $a095			bra 	EXPCExit
.c058	a058					EXPCScroll:
.c058	a058	ce ea 07	dec $07ea			dec 	EXTRow 						; the height-1 th line.
.c05b	a05b	20 47 a1	jsr $a147			jsr 	EXTScreenScroll 			; scroll the screen
.c05e	a05e	80 35		bra $a095			bra 	EXPCExit
.c060	a060					EXPCColour:
.c060	a060	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.c062	a062	b0 31		bcs $a095			bcs 	EXPCExit
.c064	a064	20 27 a1	jsr $a127			jsr 	EXPCHandleColour
.c067	a067	80 2c		bra $a095			bra 	EXPCExit
.c069	a069					EXPCControl:
.c069	a069	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.c06b	a06b	b0 28		bcs $a095			bcs 	EXPCExit
.c06d	a06d	0a		asl a				asl 	a 							; double into X
.c06e	a06e	aa		tax				tax
.c06f	a06f	7c 05 a1	jmp ($a105,x)			jmp 	(EXPCActionTable,x) 		; and execute code.
.c072	a072					EXPCUp:
.c072	a072	ad ea 07	lda $07ea			lda 	EXTRow 						; already at top ?
.c075	a075	f0 1e		beq $a095			beq 	EXPCExit
.c077	a077	ce ea 07	dec $07ea			dec 	EXTRow 						; up one in position/address
.c07a	a07a	38		sec				sec
.c07b	a07b	a5 40		lda $40				lda 	EXTAddress
.c07d	a07d	ed ed 07	sbc $07ed			sbc 	EXTScreenWidth
.c080	a080	85 40		sta $40				sta 	EXTAddress
.c082	a082	b0 11		bcs $a095			bcs 	EXPCExit
.c084	a084	c6 41		dec $41				dec 	EXTAddress+1
.c086	a086	80 0d		bra $a095			bra 	EXPCExit
.c088	a088					EXPCRight:
.c088	a088	c8		iny				iny
.c089	a089	8c eb 07	sty $07eb			sty 	EXTColumn
.c08c	a08c	cc ed 07	cpy $07ed			cpy 	EXTScreenWidth
.c08f	a08f	d0 04		bne $a095			bne 	EXPCExit
.c091	a091	88		dey				dey
.c092	a092					EXPCSetColumnY:
.c092	a092	8c eb 07	sty $07eb			sty 	EXTColumn
.c095	a095					EXPCExit:
.c095	a095	20 bc a1	jsr $a1bc			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.c098	a098	68		pla				pla
.c099	a099	85 01		sta $01				sta 	1
.c09b	a09b	7a		ply				ply
.c09c	a09c	fa		plx				plx
.c09d	a09d	68		pla				pla
.c09e	a09e	60		rts				rts
.c09f	a09f					EXPCClearScreen:
.c09f	a09f	20 79 a1	jsr $a179			jsr		EXTClearScreenCode
.c0a2	a0a2	80 f1		bra $a095			bra 	EXPCExit
.c0a4	a0a4					EXPCDown:
.c0a4	a0a4	ad ee 07	lda $07ee			lda 	EXTScreenHeight 			; at the bottom
.c0a7	a0a7	3a		dec a				dec 	a
.c0a8	a0a8	cd ea 07	cmp $07ea			cmp 	EXTRow
.c0ab	a0ab	f0 e8		beq $a095			beq 	EXPCExit
.c0ad	a0ad	ee ea 07	inc $07ea			inc 	EXTRow 						; down one in position/address
.c0b0	a0b0	18		clc				clc
.c0b1	a0b1	a5 40		lda $40				lda 	EXTAddress
.c0b3	a0b3	6d ed 07	adc $07ed			adc 	EXTScreenWidth
.c0b6	a0b6	85 40		sta $40				sta 	EXTAddress
.c0b8	a0b8	90 db		bcc $a095			bcc 	EXPCExit
.c0ba	a0ba	e6 41		inc $41				inc 	EXTAddress+1
.c0bc	a0bc	80 d7		bra $a095			bra 	EXPCExit
.c0be	a0be					EXPCTab:
.c0be	a0be	ad eb 07	lda $07eb			lda 	EXTColumn 					; next tab stop
.c0c1	a0c1	29 f8		and #$f8			and 	#$F8
.c0c3	a0c3	18		clc				clc
.c0c4	a0c4	69 08		adc #$08			adc 	#8
.c0c6	a0c6	8d eb 07	sta $07eb			sta 	EXTColumn
.c0c9	a0c9	cd ed 07	cmp $07ed			cmp 	EXTScreenWidth 				; too far, new line.
.c0cc	a0cc	90 c7		bcc $a095			bcc 	EXPCExit
.c0ce	a0ce	4c 32 a0	jmp $a032			jmp 	EXPCCRLF
.c0d1	a0d1					EXPCBackSpace:
.c0d1	a0d1	88		dey				dey
.c0d2	a0d2	30 c1		bmi $a095			bmi 	EXPCExit
.c0d4	a0d4	ce eb 07	dec $07eb			dec 	EXTColumn
.c0d7	a0d7	a9 02		lda #$02			lda 	#2
.c0d9	a0d9	85 01		sta $01				sta 	1
.c0db	a0db	a9 20		lda #$20			lda 	#32
.c0dd	a0dd	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0df	a0df	80 b4		bra $a095			bra 	EXPCExit
.c0e1	a0e1					EXPCEnd:
.c0e1	a0e1	a9 02		lda #$02			lda 	#2 							; access text screen
.c0e3	a0e3	85 01		sta $01				sta 	1
.c0e5	a0e5	ac ed 07	ldy $07ed			ldy 	EXTScreenWidth 				; point to last character
.c0e8	a0e8	88		dey				dey
.c0e9	a0e9					EXPCEndSearch:
.c0e9	a0e9	88		dey				dey 								; if past start, move to col 0.
.c0ea	a0ea	30 06		bmi $a0f2			bmi 	EXPCFound
.c0ec	a0ec	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.c0ee	a0ee	c9 20		cmp #$20			cmp 	#' '
.c0f0	a0f0	f0 f7		beq $a0e9			beq 	EXPCEndSearch
.c0f2	a0f2					EXPCFound:
.c0f2	a0f2	c8		iny				iny 								; move to following cell.
.c0f3	a0f3	80 9d		bra $a092			bra 	EXPCSetColumnY
.c0f5	a0f5					EXPCClearEOL:
.c0f5	a0f5	a9 02		lda #$02			lda 	#2 							; access character RAM
.c0f7	a0f7	85 01		sta $01				sta 	1
.c0f9	a0f9	a9 20		lda #$20			lda 	#' ' 						; write space
.c0fb	a0fb	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0fd	a0fd	c8		iny				iny
.c0fe	a0fe	cc ed 07	cpy $07ed			cpy 	EXTScreenWidth 				; until RHS of screen.
.c101	a101	90 f2		bcc $a0f5			bcc 	EXPCClearEOL
.c103	a103	80 90		bra $a095			bra 	EXPCExit
.c105	a105					EXPCActionTable:
>c105	a105	95 a0						.word 	EXPCExit 					; 00
>c107	a107	53 a0						.word 	EXPCBegin 					; 01 A Start of Line
>c109	a109	4e a0						.word 	EXPCLeft 					; 02 B Left
>c10b	a10b	95 a0						.word 	EXPCExit 					; 03 <Break>
>c10d	a10d	95 a0						.word 	EXPCExit 					; 04
>c10f	a10f	e1 a0						.word 	EXPCEnd 					; 05 E End of Line
>c111	a111	88 a0						.word 	EXPCRight 					; 06 F Right
>c113	a113	95 a0						.word 	EXPCExit 					; 07
>c115	a115	d1 a0						.word 	EXPCBackSpace 				; 08 H Backspace
>c117	a117	be a0						.word 	EXPCTab 					; 09 I Tab
>c119	a119	95 a0						.word 	EXPCExit 					; 0A
>c11b	a11b	f5 a0						.word 	EXPCClearEOL 				; 0B K Clear to EOL
>c11d	a11d	9f a0						.word 	EXPCClearScreen			; 0C L CLS
>c11f	a11f	32 a0						.word 	EXPCCRLF 					; 0D M CR/LF
>c121	a121	a4 a0						.word 	EXPCDown 					; 0E N Down
>c123	a123	95 a0						.word 	EXPCExit 					; 0F
>c125	a125	72 a0						.word 	EXPCUp 					; 10 P Up
.c127	a127					EXPCHandleColour:
.c127	a127	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.c129	a129	b0 16		bcs $a141			bcs 	EXPCBackground
.c12b	a12b	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.c12c	a12c	0a		asl a				asl 	a
.c12d	a12d	0a		asl a				asl 	a
.c12e	a12e	0a		asl a				asl 	a
.c12f	a12f	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.c131	a131					EXPCUpdate:
.c131	a131	48		pha				pha 								; save new colour
.c132	a132	8a		txa				txa 								; get mask
.c133	a133	2d ec 07	and $07ec			and 	EXTTextColour 				; mask out old.
.c136	a136	8d ec 07	sta $07ec			sta 	EXTTextColour
.c139	a139	68		pla				pla 								; or in new colour
.c13a	a13a	0d ec 07	ora $07ec			ora 	EXTTextColour
.c13d	a13d	8d ec 07	sta $07ec			sta 	EXTTextColour
.c140	a140	60		rts				rts
.c141	a141					EXPCBackground:
.c141	a141	29 0f		and #$0f			and 	#$0F 						; get the colour
.c143	a143	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.c145	a145	80 ea		bra $a131			bra 	EXPCUpdate
.c147	a147					EXTScreenScroll:
.c147	a147	a9 02		lda #$02			lda 	#2 							; select text page
.c149	a149	85 01		sta $01				sta 	1
.c14b	a14b	a9 20		lda #$20			lda		#32 						; fill with space
.c14d	a14d	20 e6 a2	jsr $a2e6			jsr 	EXTScrollFill
.c150	a150	e6 01		inc $01				inc 	1 							; select colour page
.c152	a152	ad ec 07	lda $07ec			lda 	EXTTextColour
.c155	a155	20 e6 a2	jsr $a2e6			jsr 	EXTScrollFill
.c158	a158	60		rts				rts
.c159	a159					PAGEDPrintHex:
.c159	a159	48		pha				pha
.c15a	a15a	a9 20		lda #$20			lda 	#' '
.c15c	a15c	20 0b a0	jsr $a00b			jsr 	PAGEDPrintCharacter
.c15f	a15f	68		pla				pla
.c160	a160	48		pha				pha
.c161	a161	4a		lsr a				lsr 	a
.c162	a162	4a		lsr a				lsr 	a
.c163	a163	4a		lsr a				lsr 	a
.c164	a164	4a		lsr a				lsr 	a
.c165	a165	20 69 a1	jsr $a169			jsr 	_PPHNibble
.c168	a168	68		pla				pla
.c169	a169					_PPHNibble:
.c169	a169	48		pha				pha
.c16a	a16a	29 0f		and #$0f			and 	#15
.c16c	a16c	c9 0a		cmp #$0a			cmp 	#10
.c16e	a16e	90 02		bcc $a172			bcc 	_PPHOut
.c170	a170	69 06		adc #$06			adc 	#6
.c172	a172	69 30		adc #$30	_PPHOut:adc 	#48
.c174	a174	20 0b a0	jsr $a00b			jsr		PAGEDPrintCharacter
.c177	a177	68		pla				pla
.c178	a178	60		rts				rts
.c179	a179					EXTClearScreenCode:
.c179	a179	a9 02		lda #$02			lda 	#2 							; select text page
.c17b	a17b	85 01		sta $01				sta 	1
.c17d	a17d	a9 20		lda #$20			lda		#32 						; fill with space
.c17f	a17f	20 8c a1	jsr $a18c			jsr 	_EXTCSFill
.c182	a182	e6 01		inc $01				inc 	1 							; select color page
.c184	a184	ad ec 07	lda $07ec			lda 	EXTTextColour
.c187	a187	20 8c a1	jsr $a18c			jsr 	_EXTCSFill
.c18a	a18a	80 22		bra $a1ae			bra 	EXTHomeCursor				; home cursor
.c18c	a18c					_EXTCSFill:
.c18c	a18c	aa		tax				tax
.c18d	a18d	a9 00		lda #$00			lda 	#EXTMemory & $FF
.c18f	a18f	85 40		sta $40				sta 	EXTAddress
.c191	a191	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.c193	a193	85 41		sta $41				sta 	EXTAddress+1
.c195	a195					_EXTCSFill1:
.c195	a195	a0 00		ldy #$00			ldy 	#0
.c197	a197	8a		txa				txa
.c198	a198					_EXTCSFill2:
.c198	a198	91 40		sta ($40),y			sta 	(EXTAddress),y
.c19a	a19a	c8		iny				iny
.c19b	a19b	d0 fb		bne $a198			bne 	_EXTCSFill2
.c19d	a19d	e6 41		inc $41				inc 	EXTAddress+1
.c19f	a19f	a5 41		lda $41				lda 	EXTAddress+1
.c1a1	a1a1	c9 d2		cmp #$d2			cmp 	#$D2
.c1a3	a1a3	d0 f0		bne $a195			bne 	_EXTCSFill1
.c1a5	a1a5	8a		txa				txa
.c1a6	a1a6					_EXTCSFill3:
.c1a6	a1a6	91 40		sta ($40),y			sta 	(EXTAddress),y
.c1a8	a1a8	c8		iny				iny
.c1a9	a1a9	c0 c0		cpy #$c0			cpy 	#$C0
.c1ab	a1ab	d0 f9		bne $a1a6			bne 	_EXTCSFill3
.c1ad	a1ad	60		rts				rts
.c1ae	a1ae					EXTHomeCursor:
.c1ae	a1ae	9c ea 07	stz $07ea			stz 	EXTRow 						; reset row & column
.c1b1	a1b1	9c eb 07	stz $07eb			stz 	EXTColumn
.c1b4	a1b4	a9 00		lda #$00			lda 	#<EXTMemory					; set address in I/O memory
.c1b6	a1b6	85 40		sta $40				sta 	EXTAddress
.c1b8	a1b8	a9 c0		lda #$c0			lda 	#>EXTMemory
.c1ba	a1ba	85 41		sta $41				sta 	EXTAddress+1
.c1bc	a1bc					EXTSetHardwareCursor:
.c1bc	a1bc	64 01		stz $01		        stz 	1 							; I/O Page zero
.c1be	a1be	ad eb 07	lda $07eb	        lda 	EXTColumn
.c1c1	a1c1	8d 14 d0	sta $d014	        sta 	$D014 						; set cursor position
.c1c4	a1c4	9c 15 d0	stz $d015	        stz 	$D015
.c1c7	a1c7	ad ea 07	lda $07ea	        lda 	EXTRow
.c1ca	a1ca	8d 16 d0	sta $d016	        sta 	$D016
.c1cd	a1cd	9c 17 d0	stz $d017	        stz 	$D017
.c1d0	a1d0	60		rts		        rts
.c1d1	a1d1					Export_EXTSetCurrentLine:
.c1d1	a1d1	ad ea 07	lda $07ea			lda     EXTRow						; `A` holds the current row
.c1d4	a1d4	0a		asl a				asl 	a							; multiply row index by 2 to get byte index
.c1d5	a1d5	a8		tay				tay									; `Y` holds the byte index of the row offset
.c1d6	a1d6	18		clc				clc
.c1d7	a1d7	a9 00		lda #$00			lda 	#<EXTMemory					; `A` = low byte of screen memory
.c1d9	a1d9	79 f0 07	adc $07f0,y			adc 	EXTScreenRowOffsets,y		; add the row offset
.c1dc	a1dc	85 40		sta $40				sta 	EXTAddress					; store low byte of the line address
.c1de	a1de	a9 c0		lda #$c0			lda 	#>EXTMemory					; `A` = high byte of screen memory
.c1e0	a1e0	79 f1 07	adc $07f1,y			adc 	EXTScreenRowOffsets+1,y		; add the row offset
.c1e3	a1e3	85 41		sta $41				sta 	EXTAddress+1				; store high byte of the line address
.c1e5	a1e5	60		rts		        rts
=$c000						EXTMemory 		= $C000
=$02						EXTTextPage 	= $02
=$03						EXTColourPage 	= $03
>07ea						EXTRow				.fill 	1
>07eb						EXTColumn			.fill 	1
>07ec						EXTTextColour		.fill 	1
>07ed						EXTScreenWidth		.fill 	1
>07ee						EXTScreenHeight		.fill 	1
>07ef								.align 2
>07f0						EXTScreenRowOffsets	.fill 	128 * 2
>0040						EXTAddress			.fill 	2
.c1e6	a1e6					Export_EXTInitialise:
.c1e6	a1e6	64 01		stz $01				stz 	1 							; Access I/O page 0
.c1e8	a1e8	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.c1eb	a1eb	9c 08 d0	stz $d008			stz 	$D008
.c1ee	a1ee	9c 09 d0	stz $d009			stz 	$D009
.c1f1	a1f1	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.c1f3	a1f3	8d 58 d6	sta $d658			sta 	$D658
.c1f6	a1f6	a9 52		lda #$52			lda 	#$52
.c1f8	a1f8	8d ec 07	sta $07ec			sta 	EXTTextColour
.c1fb	a1fb	a9 50		lda #$50			lda 	#80 						; number of columns
.c1fd	a1fd	8d ed 07	sta $07ed			sta 	EXTScreenWidth
.c200	a200	a9 3c		lda #$3c			lda 	#60							; number of rows
.c202	a202	8d ee 07	sta $07ee			sta 	EXTScreenHeight
.c205	a205	ad ee 07	lda $07ee			lda		EXTScreenHeight				; get screen height
.c208	a208	85 36		sta $36				sta		zTemp0 						; `zTemp0` = row counter
.c20a	a20a	10 05		bpl $a211			bpl		loop_start					; screen height is less then 128, continue
.c20c	a20c	a9 1f		lda #$1f		lda	#31
.c20e	a20e	4c 4d 95	jmp $954d		jmp	ErrorHandler
.c211	a211						loop_start:
.c211	a211	64 38		stz $38				stz		zTemp1						; zTemp1 holds the current offset
.c213	a213	64 39		stz $39				stz		zTemp1+1					;
.c215	a215	a0 00		ldy #$00			ldy		#0			  				; `Y` = offset byte index
.c217	a217						next_row:
.c217	a217	a5 38		lda $38				lda		zTemp1						; get low byte of offset
.c219	a219	99 f0 07	sta $07f0,y			sta		EXTScreenRowOffsets,y		; store low byte
.c21c	a21c	c8		iny				iny
.c21d	a21d	a5 39		lda $39				lda		zTemp1+1					; get high byte of offset
.c21f	a21f	99 f0 07	sta $07f0,y			sta		EXTScreenRowOffsets,y		; store high byte
.c222	a222	c8		iny				iny
.c223	a223	18		clc				clc
.c224	a224	a5 38		lda $38				lda		zTemp1						; `A` holds the low byte of offset
.c226	a226	6d ed 07	adc $07ed			adc		EXTScreenWidth				; add screen width
.c229	a229	85 38		sta $38				sta		zTemp1						; store low byte of new offset
.c22b	a22b	90 02		bcc $a22f			bcc		no_carry					; if no carry, we are done
.c22d	a22d	e6 39		inc $39				inc		zTemp1+1					; increment high byte of offset if carry occurred
.c22f	a22f						no_carry:
.c22f	a22f	c6 36		dec $36				dec		zTemp0						; decrement row counter
.c231	a231	d0 e4		bne $a217			bne		next_row					; if not zero, precompute the next row's offset
.c233	a233	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.c235	a235	8d 10 d0	sta $d010			sta 	$D010
.c238	a238	a9 d6		lda #$d6			lda 	#214 						; cursor character
.c23a	a23a	8d 12 d0	sta $d012			sta 	$D012
.c23d	a23d	20 79 a1	jsr $a179			jsr 	EXTClearScreenCode 			; clear the screen and home cursor
.c240	a240					_EXMoveDown:
.c240	a240	a9 0d		lda #$0d			lda 	#13
.c242	a242	20 0b a0	jsr $a00b			jsr 	PAGEDPrintCharacter
.c245	a245	ad ea 07	lda $07ea			lda 	EXTRow
.c248	a248	c9 0a		cmp #$0a			cmp 	#Header_Height-4
.c24a	a24a	d0 f4		bne $a240			bne 	_EXMoveDown
.c24c	a24c	20 52 a2	jsr $a252			jsr 	EXTShowHeader
.c24f	a24f	64 01		stz $01				stz 	1
.c251	a251	60		rts				rts
.c252	a252					EXTShowHeader:
.c252	a252	a5 01		lda $01				lda 	1
.c254	a254	48		pha				pha
.c255	a255	a5 0b		lda $0b				lda 	8+3
.c257	a257	48		pha				pha
.c258	a258	a5 0c		lda $0c				lda 	8+4
.c25a	a25a	18		clc				clc
.c25b	a25b	69 03		adc #$03			adc 	#3
.c25d	a25d	85 0b		sta $0b				sta 	8+3
.c25f	a25f	a2 92		ldx #$92			ldx 	#(Header_jchars & $FF)
.c261	a261	a0 61		ldy #$61			ldy 	#(Header_jchars >> 8)-$40
.c263	a263	64 01		stz $01				stz 	1
.c265	a265	ad a7 d6	lda $d6a7			lda 	$D6A7
.c268	a268	29 10		and #$10			and 	#$10
.c26a	a26a	f0 04		beq $a270			beq 	_EXTSHNotK1
.c26c	a26c	a2 21		ldx #$21			ldx 	#(Header_kchars & $FF)
.c26e	a26e	a0 65		ldy #$65			ldy 	#(Header_kchars >> 8)-$40
.c270	a270					_EXTSHNotK1:
.c270	a270	a9 02		lda #$02			lda 	#2
.c272	a272	20 a0 a2	jsr $a2a0			jsr 	_ESHCopyBlock
.c275	a275	a2 00		ldx #$00			ldx 	#(Header_jattrs & $FF)
.c277	a277	a0 60		ldy #$60			ldy 	#(Header_jattrs >> 8)-$40
.c279	a279	64 01		stz $01				stz 	1
.c27b	a27b	ad a7 d6	lda $d6a7			lda 	$D6A7
.c27e	a27e	29 10		and #$10			and 	#$10
.c280	a280	f0 04		beq $a286			beq 	_EXTSHNotK2
.c282	a282	a2 c2		ldx #$c2			ldx 	#(Header_kattrs & $FF)
.c284	a284	a0 63		ldy #$63			ldy 	#(Header_kattrs >> 8)-$40
.c286	a286					_EXTSHNotK2:
.c286	a286	a9 03		lda #$03			lda 	#3
.c288	a288	20 a0 a2	jsr $a2a0			jsr 	_ESHCopyBlock
.c28b	a28b	64 01		stz $01				stz 	1
.c28d	a28d	a2 3f		ldx #$3f			ldx 	#16*4-1
.c28f	a28f					_EXTCopyLUT:
.c28f	a28f	bd 23 67	lda $6723,x			lda 	Header_Palette-$4000,x
.c292	a292	9d 00 d8	sta $d800,x			sta 	$D800,x
.c295	a295	9d 40 d8	sta $d840,x			sta 	$D840,x
.c298	a298	ca		dex				dex
.c299	a299	10 f4		bpl $a28f			bpl 	_EXTCopyLUT
.c29b	a29b	68		pla				pla
.c29c	a29c	85 0b		sta $0b				sta 	8+3
.c29e	a29e	68		pla				pla
.c29f	a29f	60		rts				rts
.c2a0	a2a0					_ESHCopyBlock:
.c2a0	a2a0	85 01		sta $01				sta 	1
.c2a2	a2a2	86 36		stx $36				stx 	zTemp0 						; zTemp0 is RLE packed data
.c2a4	a2a4	84 37		sty $37				sty 	zTemp0+1
.c2a6	a2a6	a9 00		lda #$00			lda 	#(($C000) & $FF)
.c2a8	a2a8	85 38		sta $38				sta 	0+zTemp1
.c2aa	a2aa	a9 c0		lda #$c0			lda 	#(($C000) >> 8)
.c2ac	a2ac	85 39		sta $39				sta 	1+zTemp1
.c2ae	a2ae					_ESHCopyLoop:
.c2ae	a2ae	b2 36		lda ($36)			lda 	(zTemp0) 					; get next character
.c2b0	a2b0	c9 ff		cmp #$ff			cmp 	#Header_RLE 				; packed ?
.c2b2	a2b2	f0 1b		beq $a2cf			beq 	_ESHUnpack
.c2b4	a2b4	92 38		sta ($38)			sta 	(zTemp1) 					; copy it out.
.c2b6	a2b6	a9 01		lda #$01			lda 	#1 							; source add 1
.c2b8	a2b8	a0 01		ldy #$01			ldy 	#1 							; dest add 1
.c2ba	a2ba					_ESHNext:
.c2ba	a2ba	18		clc				clc 								; zTemp0 + A
.c2bb	a2bb	65 36		adc $36				adc 	zTemp0
.c2bd	a2bd	85 36		sta $36				sta 	zTemp0
.c2bf	a2bf	90 02		bcc $a2c3			bcc 	_ESHNoCarry
.c2c1	a2c1	e6 37		inc $37				inc 	zTemp0+1
.c2c3	a2c3					_ESHNoCarry:
.c2c3	a2c3	98		tya				tya 								; zTemp1 + Y
.c2c4	a2c4	18		clc				clc
.c2c5	a2c5	65 38		adc $38				adc 	zTemp1
.c2c7	a2c7	85 38		sta $38				sta 	zTemp1
.c2c9	a2c9	90 e3		bcc $a2ae			bcc 	_ESHCopyLoop
.c2cb	a2cb	e6 39		inc $39				inc 	zTemp1+1
.c2cd	a2cd	80 df		bra $a2ae			bra 	_ESHCopyLoop
.c2cf	a2cf					_ESHUnpack:
.c2cf	a2cf	a0 02		ldy #$02			ldy 	#2 							; get count into X
.c2d1	a2d1	b1 36		lda ($36),y			lda 	(zTemp0),y
.c2d3	a2d3	aa		tax				tax
.c2d4	a2d4	88		dey				dey 								; byte into A
.c2d5	a2d5	b1 36		lda ($36),y			lda 	(zTemp0),y
.c2d7	a2d7	f0 0c		beq $a2e5			beq 	_ESHExit 					; exit if zero.
.c2d9	a2d9	a0 00		ldy #$00			ldy 	#0 							; copy start position
.c2db	a2db					_ESHCopyOut:
.c2db	a2db	91 38		sta ($38),y			sta 	(zTemp1),y
.c2dd	a2dd	c8		iny				iny
.c2de	a2de	ca		dex				dex
.c2df	a2df	d0 fa		bne $a2db			bne 	_ESHCopyOut
.c2e1	a2e1	a9 03		lda #$03			lda 	#3 							; Y is bytes on screen, 3 bytes from source
.c2e3	a2e3	80 d5		bra $a2ba			bra 	_ESHNext
.c2e5	a2e5					_ESHExit:
.c2e5	a2e5	60		rts				rts
.c2e6	a2e6					EXTScrollFill:
.c2e6	a2e6	aa		tax				tax									; save value to fill with
.c2e7	a2e7	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.c2e9	a2e9	48		pha				pha
.c2ea	a2ea	a5 37		lda $37				lda 	zTemp0+1
.c2ec	a2ec	48		pha				pha
.c2ed	a2ed	a5 38		lda $38				lda 	zTemp1
.c2ef	a2ef	48		pha				pha
.c2f0	a2f0	a5 39		lda $39				lda 	zTemp1+1
.c2f2	a2f2	48		pha				pha
.c2f3	a2f3	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.c2f5	a2f5	85 37		sta $37				sta 	zTemp0+1
.c2f7	a2f7	85 39		sta $39				sta 	zTemp1+1
.c2f9	a2f9	64 36		stz $36				stz 	zTemp0
.c2fb	a2fb	ad ed 07	lda $07ed			lda 	EXTScreenWidth
.c2fe	a2fe	85 38		sta $38				sta 	zTemp1
.c300	a300	a0 00		ldy #$00			ldy 	#0
.c302	a302					_EXSFCopy1:
.c302	a302	b1 38		lda ($38),y			lda 	(zTemp1),y
.c304	a304	91 36		sta ($36),y			sta 	(zTemp0),y
.c306	a306	c8		iny				iny
.c307	a307	d0 f9		bne $a302			bne 	_EXSFCopy1
.c309	a309	e6 37		inc $37				inc 	zTemp0+1 					; next page
.c30b	a30b	e6 39		inc $39				inc 	zTemp1+1
.c30d	a30d	a5 39		lda $39				lda 	zTemp1+1
.c30f	a30f	c9 d3		cmp #$d3			cmp 	#$D3
.c311	a311	d0 ef		bne $a302			bne 	_EXSFCopy1
.c313	a313	ac ed 07	ldy $07ed			ldy 	EXTScreenWidth 				; blank the bottom line.
.c316	a316	8a		txa				txa
.c317	a317					_EXSFFill1:
.c317	a317	88		dey				dey
.c318	a318	91 40		sta ($40),y			sta 	(EXTAddress),y
.c31a	a31a	c0 00		cpy #$00			cpy 	#0
.c31c	a31c	10 f9		bpl $a317			bpl 	_EXSFFill1
.c31e	a31e	68		pla				pla
.c31f	a31f	85 39		sta $39				sta 	zTemp1+1
.c321	a321	68		pla				pla
.c322	a322	85 38		sta $38				sta 	zTemp1
.c324	a324	68		pla				pla
.c325	a325	85 37		sta $37				sta 	zTemp0+1
.c327	a327	68		pla				pla
.c328	a328	85 36		sta $36				sta 	zTemp0
.c32a	a32a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/.build/graphics.module.asm

=1						graphicsIntegrated=1
=0						GCMD_Initialise = 0*2
=2						GCMD_BitmapCtl = 1*2
=4						GCMD_SpriteCtl = 2*2
=6						GCMD_Clear = 3*2
=8						GCMD_Colour = 4*2
=10						GCMD_DrawFont = 5*2
=12						GCMD_DrawSprite = 6*2
=14						GCMD_SpriteUse = 7*2
=16						GCMD_SpriteImage = 8*2
=18						GCMD_SpriteCollide = 9*2
=20						GCMD_TileCtl = 10*2
=22						GCMD_TileSize = 11*2
=24						GCMD_TileScrollX = 12*2
=26						GCMD_TileScrollY = 13*2
=28						GCMD_TilePos = 14*2
=30						GCMD_TileWrite = 15*2
=32						GCMD_TileRead = 16*2
=64						GCMD_Move = 32*2
=66						GCMD_Line = 33*2
=68						GCMD_FrameRect = 34*2
=70						GCMD_FillRect = 35*2
=72						GCMD_FrameCircle = 36*2
=74						GCMD_FillCircle = 37*2
=80						GCMD_Plot = 40*2
=82						GCMD_SpriteMove = 41*2
=42						GRFirstFreeCode = 42
.c32b	a32b					GRVectorTable:
>c32b	a32b	7d a5					.word	GXInitialise             ; $00 Initialise
>c32d	a32d	a4 a5					.word	GXControlBitmap          ; $01 BitmapCtl
>c32f	a32f	ec a5					.word	GXControlSprite          ; $02 SpriteCtl
>c331	a331	2d a5					.word	GXClearBitmap            ; $03 Clear
>c333	a333	1d a8					.word	GXSetColourMode          ; $04 Colour
>c335	a335	3c aa					.word	GXFontHandler            ; $05 DrawFont
>c337	a337	84 aa					.word	GXSpriteHandler          ; $06 DrawSprite
>c339	a339	f5 aa					.word	GXSelect                 ; $07 SpriteUse
>c33b	a33b	1e ab					.word	GXSelectImage            ; $08 SpriteImage
>c33d	a33d	43 ad					.word	GXCollide                ; $09 SpriteCollide
>c33f	a33f	2d a6					.word	GXControlTilemap         ; $0a TileCtl
>c341	a341	b5 a6					.word	GXControlTileSize        ; $0b TileSize
>c343	a343	e5 a9					.word	GXControlTileScrollX     ; $0c TileScrollX
>c345	a345	f6 a9					.word	GXControlTileScrollY     ; $0d TileScrollY
>c347	a347	24 ac					.word	GXSelectTile             ; $0e TilePos
>c349	a349	86 ac					.word	GXSTWriteTile            ; $0f TileWrite
>c34b	a34b	89 ac					.word	GXSTReadTile             ; $10 TileRead
>c34d	a34d	de a3					.word	GRUndefined              ; $11
>c34f	a34f	de a3					.word	GRUndefined              ; $12
>c351	a351	de a3					.word	GRUndefined              ; $13
>c353	a353	de a3					.word	GRUndefined              ; $14
>c355	a355	de a3					.word	GRUndefined              ; $15
>c357	a357	de a3					.word	GRUndefined              ; $16
>c359	a359	de a3					.word	GRUndefined              ; $17
>c35b	a35b	de a3					.word	GRUndefined              ; $18
>c35d	a35d	de a3					.word	GRUndefined              ; $19
>c35f	a35f	de a3					.word	GRUndefined              ; $1a
>c361	a361	de a3					.word	GRUndefined              ; $1b
>c363	a363	de a3					.word	GRUndefined              ; $1c
>c365	a365	de a3					.word	GRUndefined              ; $1d
>c367	a367	de a3					.word	GRUndefined              ; $1e
>c369	a369	de a3					.word	GRUndefined              ; $1f
>c36b	a36b	dc a3					.word	GXMove                   ; $20 Move
>c36d	a36d	eb a6					.word	GXLine                   ; $21 Line
>c36f	a36f	66 a8					.word	GXFrameRectangle         ; $22 FrameRect
>c371	a371	63 a8					.word	GXFillRectangle          ; $23 FillRect
>c373	a373	e4 a3					.word	GXFrameCircle            ; $24 FrameCircle
>c375	a375	e0 a3					.word	GXFillCircle             ; $25 FillCircle
>c377	a377	de a3					.word	GRUndefined              ; $26
>c379	a379	de a3					.word	GRUndefined              ; $27
>c37b	a37b	4b a8					.word	GXPlotPoint              ; $28 Plot
>c37d	a37d	b4 ab					.word	GXMoveSprite             ; $29 SpriteMove
=3						GXMappingPage = 3
=24576						GXMappingAddress = ($2000 * GXMappingPage)
=11						GXEditSlot = 8 + GXMappingPage
=$36						gxzTemp0 = zTemp0
=$38						gxzTemp1 = zTemp1
=$3a						gxzTemp2 = zTemp2
=$3c						gxzScreen = zsTemp
=$643						gxPixelBuffer = numberBuffer
.08f0						gxCurrentX:
>08f0								.fill 	2
.08f2						gxCurrentY:
>08f2								.fill 	2
.08f4						gxLastX:
>08f4								.fill 	2
.08f6						gxLastY:
>08f6								.fill 	2
.08f8						gxX0:
>08f8								.fill 	2
.08fa						gxY0:
>08fa								.fill 	2
.08fc						gxX1:
>08fc								.fill 	2
.08fe						gxY1:
>08fe								.fill 	2
.0900						gxSpritesOn:
>0900								.fill 	1
.0901						gxBitmapsOn:
>0901								.fill 	1
.0902						gxTilesOn:
>0902								.fill 	1
.0903						gxBasePage:
>0903								.fill 	1
.0904						gxSpritePage:
>0904								.fill 	1
.0905						gxTileImagePage:
>0905								.fill 	1
.0906						gxTileMapPage:
>0906								.fill 	1
.0907						gxTileMapWidth:
>0907								.fill 	1
.0908						gxTileMapHeight:
>0908								.fill 	1
.0909						gxHeight:
>0909								.fill 	1
.090a						gxMode:
>090a								.fill 	1
.090b						gxColour:
>090b								.fill 	1
.090c						gxEORValue:
>090c								.fill 	1
.090d						gxANDValue:
>090d								.fill 	1
.090e						gxOriginalLUTValue:
>090e								.fill 	1
.090f						gxOffset:
>090f								.fill 	1
.0910						GSCurrentSpriteID:
>0910								.fill 	1
.0911						GSCurrentSpriteAddr:
>0911								.fill 	2
.0913						gxSpriteOffsetBase:
>0913								.fill 	2
.0915						gxSpriteLow:
>0915								.fill 	64
.0955						gxSpriteHigh:
>0955								.fill 	64
.0995						gxTileAccessPage:
>0995								.fill 	1
.0996						gxTileAccessAddress:
>0996								.fill 	2
.c37f	a37f					Export_GXGraphicDraw:
.c37f	a37f	c9 40		cmp #$40			cmp 	#GCMD_Move					; low value instructions don't use coordinates
.c381	a381	b0 06		bcs $a389			bcs 	_GDCoordinate 				; (see graphics.txt)
.c383	a383	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.c385	a385	84 37		sty $37				sty 	gxzTemp0+1
.c387	a387	80 4b		bra $a3d4			bra 	_GDExecuteA 				; and execute
.c389	a389					_GDCoordinate:
.c389	a389	48		pha				pha 								; save AXY
.c38a	a38a	da		phx				phx
.c38b	a38b	5a		phy				phy
.c38c	a38c	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.c38e	a38e					_GDCopy1:
.c38e	a38e	bd f0 08	lda $08f0,x			lda 	gxCurrentX,x
.c391	a391	9d f4 08	sta $08f4,x			sta 	gxLastX,x
.c394	a394	ca		dex				dex
.c395	a395	10 f7		bpl $a38e			bpl 	_GDCopy1
.c397	a397	68		pla				pla
.c398	a398	8d f2 08	sta $08f2			sta 	gxCurrentY
.c39b	a39b	9c f3 08	stz $08f3			stz 	gxCurrentY+1
.c39e	a39e	68		pla				pla
.c39f	a39f	8d f0 08	sta $08f0			sta 	gxCurrentX
.c3a2	a3a2	68		pla				pla 								; get A (command+X.1) back
.c3a3	a3a3	48		pha				pha
.c3a4	a3a4	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.c3a6	a3a6	8d f1 08	sta $08f1			sta 	gxCurrentX+1
.c3a9	a3a9	68		pla				pla 								; get command back
.c3aa	a3aa	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.c3ac	a3ac	48		pha				pha 								; push back.
.c3ad	a3ad	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.c3af	a3af	f0 17		beq $a3c8			beq 	_GDCopyToWorkArea
.c3b1	a3b1	ad f1 08	lda $08f1			lda 	gxCurrentX+1 				; X < 256 X okay
.c3b4	a3b4	f0 07		beq $a3bd			beq 	_GDCheckY
.c3b6	a3b6	ad f0 08	lda $08f0			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.c3b9	a3b9	c9 40		cmp #$40			cmp 	#64
.c3bb	a3bb	b0 08		bcs $a3c5			bcs 	_GDError1
.c3bd	a3bd					_GDCheckY:
.c3bd	a3bd	ad f2 08	lda $08f2			lda 	gxCurrentY 					; check Y < Height.
.c3c0	a3c0	cd 09 09	cmp $0909			cmp 	gxHeight
.c3c3	a3c3	90 03		bcc $a3c8			bcc 	_GDCopyToWorkArea
.c3c5	a3c5					_GDError1:
.c3c5	a3c5	68		pla				pla
.c3c6	a3c6					_GDError2:
.c3c6	a3c6	38		sec				sec
.c3c7	a3c7	60		rts				rts
.c3c8	a3c8					_GDCopyToWorkArea:
.c3c8	a3c8	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.c3ca	a3ca					_GDCopy2:
.c3ca	a3ca	bd f0 08	lda $08f0,x			lda 	gxCurrentX,x
.c3cd	a3cd	9d f8 08	sta $08f8,x			sta 	gxX0,x
.c3d0	a3d0	ca		dex				dex
.c3d1	a3d1	10 f7		bpl $a3ca			bpl 	_GDCopy2
.c3d3	a3d3	68		pla				pla 								; get command
.c3d4	a3d4					_GDExecuteA:
.c3d4	a3d4	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad command ?
.c3d6	a3d6	b0 ee		bcs $a3c6			bcs 	_GDError2
.c3d8	a3d8	aa		tax				tax 								; go execute the command.
.c3d9	a3d9	7c 2b a3	jmp ($a32b,x)			jmp 	(GRVectorTable,x)
.c3dc	a3dc					GXMove:
.c3dc	a3dc	18		clc				clc
.c3dd	a3dd	60		rts				rts
.c3de	a3de					GRUndefined:
.c3de	a3de	38		sec				sec
.c3df	a3df	60		rts				rts
.c3e0	a3e0					GXFillCircle:
.c3e0	a3e0	a9 ff		lda #$ff			lda 	#255 						; A determines fill or not
.c3e2	a3e2	80 02		bra $a3e6			bra 	GXCircle
.c3e4	a3e4					GXFrameCircle:
.c3e4	a3e4	a9 00		lda #$00			lda 	#0
.c3e6	a3e6					GXCircle:
.c3e6	a3e6	8d 9b 09	sta $099b			sta 	gxIsFillMode				; save Fill flag
.c3e9	a3e9	ad 01 09	lda $0901			lda 	gxBitmapsOn
.c3ec	a3ec	f0 26		beq $a414			beq 	_GXCFail
.c3ee	a3ee	20 31 ae	jsr $ae31			jsr 	GXSortXY 					; topleft/bottomright
.c3f1	a3f1	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; start drawing
.c3f4	a3f4	20 e6 a4	jsr $a4e6			jsr 	GXCircleSetup 				; set up for drawing
.c3f7	a3f7	9c 9c 09	stz $099c			stz 	gxYChanged
.c3fa	a3fa					_GXCircleDraw:
.c3fa	a3fa	ad 99 09	lda $0999			lda 	gxxCentre					; while x <= y
.c3fd	a3fd	cd 9a 09	cmp $099a			cmp 	gxYCentre
.c400	a400	90 0a		bcc $a40c			bcc 	_GXCircleContinue
.c402	a402	d0 03		bne $a407			bne 	_GXNoLast  					; fix up if x < y
.c404	a404	20 19 a4	jsr $a419			jsr 	GXPlot1
.c407	a407					_GXNoLast:
.c407	a407	20 ca ac	jsr $acca			jsr 	GXCloseBitmap 				; close the bitmap
.c40a	a40a	18		clc				clc
.c40b	a40b	60		rts				rts
.c40c	a40c					_GXCircleContinue:
.c40c	a40c	20 16 a4	jsr $a416			jsr 	GXPlot2 					; draw it
.c40f	a40f	20 93 a4	jsr $a493			jsr 	GXCircleMove 				; adjust the coordinates
.c412	a412	80 e6		bra $a3fa			bra 	_GXCircleDraw
.c414	a414					_GXCFail:
.c414	a414	38		sec				sec
.c415	a415	60		rts				rts
.c416	a416					GXPlot2:
.c416	a416	20 19 a4	jsr $a419			jsr 	GXPlot1 						; plot and swap, fall through does twice
.c419	a419					GXPlot1:
.c419	a419	ad 9a 09	lda $099a			lda 	gxYCentre 						; if y = 0, don't do it twice (xor)
.c41c	a41c	f0 03		beq $a421			beq 	_GXPlot1Only
.c41e	a41e	20 3d a4	jsr $a43d			jsr 	GXPlot0 						; plot and negate
.c421	a421					_GXPlot1Only:
.c421	a421	20 3d a4	jsr $a43d			jsr 	GXPlot0 						; twice, undoing negation
.c424	a424	ad 99 09	lda $0999			lda 	gxxCentre 						; swap X and Y
.c427	a427	ae 9a 09	ldx $099a			ldx	 	gxYCentre
.c42a	a42a	8d 9a 09	sta $099a			sta 	gxYCentre
.c42d	a42d	8e 99 09	stx $0999			stx 	gxxCentre
.c430	a430	ad 9c 09	lda $099c			lda 	gxYChanged 						; toggle Y Changed flag
.c433	a433	a9 ff		lda #$ff			lda 	#$FF
.c435	a435	8d 9c 09	sta $099c			sta 	gxYChanged
.c438	a438	60		rts				rts
.c439	a439	20 3d a4	jsr $a43d			jsr 	GXPlot0 						; do once
.c43c	a43c	60		rts				rts
.c43d	a43d	ad 9b 09	lda $099b	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.c440	a440	f0 05		beq $a447			beq 	_GXPlot0Always
.c442	a442	ad 9c 09	lda $099c			lda 	gxYChanged						; fill mode, only draw if changed.
.c445	a445	f0 2d		beq $a474			beq 	GXPlot0Exit
.c447	a447					_GXPlot0Always:
.c447	a447	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.c449	a449	ad 9a 09	lda $099a			lda 	gxYCentre
.c44c	a44c	20 75 a4	jsr $a475			jsr 	GXSubCopy
.c44f	a44f	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.c451	a451	ad 99 09	lda $0999			lda 	gxxCentre
.c454	a454	20 75 a4	jsr $a475			jsr 	GXSubCopy
.c457	a457	48		pha				pha 									; save last offset X
.c458	a458	20 d2 ac	jsr $acd2			jsr 	gxPositionCalc 					; calculate position/offset.
.c45b	a45b	68		pla				pla
.c45c	a45c	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.c45d	a45d	85 36		sta $36				sta 	gxzTemp0
.c45f	a45f	64 37		stz $37				stz 	gxzTemp0+1
.c461	a461	26 37		rol $37				rol 	gxzTemp0+1
.c463	a463	ad 9b 09	lda $099b			lda 	gxIsFillMode
.c466	a466	69 80		adc #$80			adc 	#128
.c468	a468	20 b6 a8	jsr $a8b6			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.c46b	a46b	38		sec				sec 									; GY = -GY
.c46c	a46c	a9 00		lda #$00			lda 	#0
.c46e	a46e	ed 9a 09	sbc $099a			sbc 	gxYCentre
.c471	a471	8d 9a 09	sta $099a			sta 	gxYCentre
.c474	a474					GXPlot0Exit:
.c474	a474	60		rts				rts
.c475	a475					GXSubCopy:
.c475	a475	85 36		sta $36				sta 	gxzTemp0
.c477	a477	64 37		stz $37				stz 	gxzTemp0+1
.c479	a479	29 80		and #$80			and 	#$80
.c47b	a47b	f0 02		beq $a47f			beq 	_GXNoSx
.c47d	a47d	c6 37		dec $37				dec 	gxzTemp0+1
.c47f	a47f					_GXNoSx:
.c47f	a47f	38		sec				sec
.c480	a480	bd fc 08	lda $08fc,x			lda 	gxX1,x
.c483	a483	e5 36		sbc $36				sbc 	gxzTemp0
.c485	a485	9d f8 08	sta $08f8,x			sta 	gxX0,x
.c488	a488	bd fd 08	lda $08fd,x			lda 	gxX1+1,x
.c48b	a48b	e5 37		sbc $37				sbc 	gxzTemp0+1
.c48d	a48d	9d f9 08	sta $08f9,x			sta 	gxX0+1,x
.c490	a490	a5 36		lda $36				lda 	gxzTemp0 						; return A
.c492	a492	60		rts				rts
.c493	a493					GXCircleMove:
.c493	a493	9c 9c 09	stz $099c			stz 	gxYChanged 					; clear Y changed flag
.c496	a496	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.c498	a498	10 0d		bpl $a4a7			bpl 	_GXEMPositive
.c49a	a49a	ee 99 09	inc $0999			inc 	gxxCentre 					; X++
.c49d	a49d	ad 99 09	lda $0999			lda 	gxxCentre
.c4a0	a4a0	20 c6 a4	jsr $a4c6			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c4a3	a4a3	a9 06		lda #$06			lda 	#6  						; and add 6
.c4a5	a4a5	80 15		bra $a4bc			bra 	_GXEMAddD
.c4a7	a4a7					_GXEMPositive:
.c4a7	a4a7	ee 99 09	inc $0999			inc 	gxxCentre					; X++
.c4aa	a4aa	ce 9a 09	dec $099a			dec 	gxYCentre 					; Y--
.c4ad	a4ad	38		sec				sec 								; calculate X-Y
.c4ae	a4ae	ad 99 09	lda $0999			lda 	gxxCentre
.c4b1	a4b1	ed 9a 09	sbc $099a			sbc 	gxYCentre
.c4b4	a4b4	20 c6 a4	jsr $a4c6			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c4b7	a4b7	a9 0a		lda #$0a			lda 	#10  						; and add 10
.c4b9	a4b9	ce 9c 09	dec $099c			dec 	gxYChanged
.c4bc	a4bc					_GXEMAddD:
.c4bc	a4bc	18		clc				clc
.c4bd	a4bd	65 38		adc $38				adc 	gxzTemp1
.c4bf	a4bf	85 38		sta $38				sta 	gxzTemp1
.c4c1	a4c1	90 02		bcc $a4c5			bcc 	_GXEMNoCarry
.c4c3	a4c3	e6 39		inc $39				inc 	gxzTemp1+1
.c4c5	a4c5					_GXEMNoCarry:
.c4c5	a4c5	60		rts				rts
.c4c6	a4c6					_GXAdd4TimesToD:
.c4c6	a4c6	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.c4c8	a4c8	29 80		and #$80			and 	#$80
.c4ca	a4ca	f0 02		beq $a4ce			beq 	_GXA4Unsigned
.c4cc	a4cc	a9 ff		lda #$ff			lda 	#$FF
.c4ce	a4ce					_GXA4Unsigned:
.c4ce	a4ce	85 37		sta $37				sta 	gxzTemp0+1
.c4d0	a4d0	06 36		asl $36				asl 	gxzTemp0  					; x 4
.c4d2	a4d2	26 37		rol $37				rol 	gxzTemp0+1
.c4d4	a4d4	06 36		asl $36				asl 	gxzTemp0
.c4d6	a4d6	26 37		rol $37				rol 	gxzTemp0+1
.c4d8	a4d8	18		clc				clc 								; add
.c4d9	a4d9	a5 36		lda $36				lda		gxzTemp0
.c4db	a4db	65 38		adc $38				adc 	gxzTemp1
.c4dd	a4dd	85 38		sta $38				sta 	gxzTemp1
.c4df	a4df	a5 37		lda $37				lda		gxzTemp0+1
.c4e1	a4e1	65 39		adc $39				adc 	gxzTemp1+1
.c4e3	a4e3	85 39		sta $39				sta 	gxzTemp1+1
.c4e5	a4e5	60		rts				rts
.c4e6	a4e6					GXCircleSetup:
.c4e6	a4e6	38		sec				sec
.c4e7	a4e7	ad fe 08	lda $08fe			lda 	gxY1
.c4ea	a4ea	ed fa 08	sbc $08fa			sbc 	gxY0
.c4ed	a4ed	4a		lsr a				lsr 	a
.c4ee	a4ee	8d 98 09	sta $0998			sta 	gxRadius
.c4f1	a4f1	a2 00		ldx #$00			ldx 	#0
.c4f3	a4f3	20 15 a5	jsr $a515			jsr 	_GXCalculateCentre
.c4f6	a4f6	a2 02		ldx #$02			ldx 	#2
.c4f8	a4f8	20 15 a5	jsr $a515			jsr 	_GXCalculateCentre
.c4fb	a4fb	9c 99 09	stz $0999			stz 	gxxCentre
.c4fe	a4fe	ad 98 09	lda $0998			lda 	gxRadius
.c501	a501	8d 9a 09	sta $099a			sta 	gxYCentre
.c504	a504	0a		asl a				asl 	a 							; R x 2
.c505	a505	85 36		sta $36				sta 	gxzTemp0
.c507	a507	38		sec				sec
.c508	a508	a9 03		lda #$03			lda 	#3
.c50a	a50a	e5 36		sbc $36				sbc 	gxzTemp0
.c50c	a50c	85 38		sta $38				sta 	gxzTemp1
.c50e	a50e	a9 00		lda #$00			lda 	#0
.c510	a510	e9 00		sbc #$00			sbc 	#0
.c512	a512	85 39		sta $39				sta 	gxzTemp1+1
.c514	a514	60		rts				rts
.c515	a515					_GXCalculateCentre:
.c515	a515	38		sec				sec
.c516	a516	bd fc 08	lda $08fc,x			lda 	gxX1,x
.c519	a519	7d f8 08	adc $08f8,x			adc 	gxX0,x
.c51c	a51c	9d fc 08	sta $08fc,x			sta 	gxX1,x
.c51f	a51f	bd fd 08	lda $08fd,x			lda 	gxX1+1,x
.c522	a522	7d f9 08	adc $08f9,x			adc 	gxX0+1,x
.c525	a525	4a		lsr a				lsr 	a
.c526	a526	9d fd 08	sta $08fd,x			sta 	gxX1+1,x
.c529	a529	7e fc 08	ror $08fc,x			ror 	gxX1,x
.c52c	a52c	60		rts				rts
.0998						gxRadius:
>0998								.fill 	1
.0999						gxxCentre:
>0999								.fill 	1
.099a						gxYCentre:
>099a								.fill 	1
.099b						gxIsFillMode:
>099b								.fill 	1
.099c						gxYChanged:
>099c								.fill  	1
=64000						ScreenSize200 = 320 * 200
=76800						ScreenSize240 = 320 * 240
.c52d	a52d					GXClearBitmap:
.c52d	a52d	ad 01 09	lda $0901			lda 	gxBitmapsOn 				; check BMP turned on.
.c530	a530	f0 26		beq $a558			beq 	_GXCBFail
.c532	a532	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; start access
.c535	a535	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear as 2 graphic heights.
.c537	a537	ad 09 09	lda $0909			lda 	gxHeight
.c53a	a53a	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.c53c	a53c	f0 02		beq $a540			beq 	_GXCalcLastPage
.c53e	a53e	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.c540	a540					_GXCalcLastPage:
.c540	a540	98		tya				tya 								; add to base page
.c541	a541	18		clc				clc
.c542	a542	6d 03 09	adc $0903			adc 	gxBasePage
.c545	a545	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.c547	a547					_GXClearAll:
.c547	a547	20 5a a5	jsr $a55a			jsr 	_GXClearBlock 				; clear 8k block
.c54a	a54a	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.c54c	a54c	a5 0b		lda $0b				lda 	GXEditSlot
.c54e	a54e	cd 03 09	cmp $0903			cmp 	gxBasePage 					; until before base page
.c551	a551	b0 f4		bcs $a547			bcs 	_GXClearAll
.c553	a553	20 ca ac	jsr $acca			jsr 	GXCloseBitmap	 			; stop access
.c556	a556	18		clc				clc
.c557	a557	60		rts				rts
.c558	a558					_GXCBFail:
.c558	a558	38		sec				sec
.c559	a559	60		rts				rts
.c55a	a55a					_GXClearBlock:
.c55a	a55a	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.c55c	a55c	85 38		sta $38				sta 	0+gxzTemp1
.c55e	a55e	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.c560	a560	85 39		sta $39				sta 	1+gxzTemp1
.c562	a562					_GXCB0:
.c562	a562	a5 36		lda $36				lda 	gxzTemp0 					; clear colour
.c564	a564	a0 00		ldy #$00			ldy 	#0
.c566	a566					_GXCB1:
.c566	a566	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c568	a568	c8		iny				iny
.c569	a569	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c56b	a56b	c8		iny				iny
.c56c	a56c	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c56e	a56e	c8		iny				iny
.c56f	a56f	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c571	a571	c8		iny				iny
.c572	a572	d0 f2		bne $a566			bne 	_GXCB1
.c574	a574	e6 39		inc $39				inc 	gxzTemp1+1
.c576	a576	a5 39		lda $39				lda 	gxzTemp1+1
.c578	a578	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.c57a	a57a	d0 e6		bne $a562			bne 	_GXCB0
.c57c	a57c	60		rts				rts
.c57d	a57d					GXInitialise:
.c57d	a57d	64 01		stz $01				stz 	1 							; access I/O
.c57f	a57f	a9 01		lda #$01			lda 	#1 							; reset bitmap address
.c581	a581	8d 00 d0	sta $d000			sta 	$D000
.c584	a584	18		clc				clc
.c585	a585	9c 00 09	stz $0900			stz 	gxSpritesOn					; sprites/bitmaps/tiles off.
.c588	a588	9c 01 09	stz $0901			stz 	gxBitmapsOn
.c58b	a58b	9c 02 09	stz $0902			stz 	gxTilesOn
.c58e	a58e	a2 0f		ldx #$0f			ldx 	#15 						; erase work area
.c590	a590					_GXIClear:
.c590	a590	9e f0 08	stz $08f0,x			stz 	gxCurrentX,x
.c593	a593	ca		dex				dex
.c594	a594	10 fa		bpl $a590			bpl 	_GXIClear
.c596	a596	20 dd a6	jsr $a6dd			jsr 	GXClearSpriteStore 			; clear sprite backup space.
.c599	a599	a9 40		lda #$40			lda 	#$40                   		; Layer 0 = Bitmap 0, Layer 1 = Tile map 0
.c59b	a59b	8d 02 d0	sta $d002			sta 	$D002
.c59e	a59e	a9 15		lda #$15			lda 	#$15                   		; Layer 2 = Tile Map 1
.c5a0	a5a0	8d 03 d0	sta $d003			sta 	$D003
.c5a3	a5a3	60		rts				rts
.c5a4	a5a4					GXControlBitmap:
.c5a4	a5a4	64 01		stz $01				stz 	1
.c5a6	a5a6	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c5a8	a5a8	29 01		and #$01			and 	#1 							; get bitmap flag (is enabled)
.c5aa	a5aa	8d 01 09	sta $0901			sta 	gxBitmapsOn
.c5ad	a5ad	4a		lsr a				lsr 	a 							; bit 0 into carry.
.c5ae	a5ae	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c5b1	a5b1	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c5b3	a5b3	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.c5b5	a5b5	90 02		bcc $a5b9			bcc 	_CBNotOn
.c5b7	a5b7	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.c5b9	a5b9					_CBNotOn:
.c5b9	a5b9	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c5bc	a5bc	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.c5be	a5be	29 07		and #$07			and 	#7
.c5c0	a5c0	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.c5c3	a5c3	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page requested
.c5c5	a5c5	d0 02		bne $a5c9			bne 	_CBNotDefault
.c5c7	a5c7	a9 08		lda #$08			lda 	#8  						; if zero, use default 8 e.g. bitmap at $10000
.c5c9	a5c9					_CBNotDefault:
.c5c9	a5c9	8d 03 09	sta $0903			sta 	gxBasePage 					; save as bitmap base page.
.c5cc	a5cc	20 cf a6	jsr $a6cf			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c5cf	a5cf	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.c5d1	a5d1	8d 03 d1	sta $d103			sta 	$D103
.c5d4	a5d4	a5 36		lda $36				lda 	gxzTemp0
.c5d6	a5d6	8d 02 d1	sta $d102			sta 	$D102
.c5d9	a5d9	9c 01 d1	stz $d101			stz 	$D101
.c5dc	a5dc	a2 f0		ldx #$f0			ldx 	#240 						; height is 240 or 200 ?
.c5de	a5de	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.c5e1	a5e1	29 01		and #$01			and 	#1
.c5e3	a5e3	f0 02		beq $a5e7			beq 	_CBHaveHeight
.c5e5	a5e5	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.c5e7	a5e7					_CBHaveHeight
.c5e7	a5e7	8e 09 09	stx $0909			stx 	gxHeight
.c5ea	a5ea	18		clc				clc
.c5eb	a5eb	60		rts				rts
.c5ec	a5ec					GXControlSprite:
.c5ec	a5ec	64 01		stz $01				stz 	1
.c5ee	a5ee	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c5f0	a5f0	29 01		and #$01			and 	#1 							; set sprites flag
.c5f2	a5f2	8d 00 09	sta $0900			sta 	gxSpritesOn
.c5f5	a5f5	4a		lsr a				lsr 	a 							; bit 0 into carry
.c5f6	a5f6	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c5f9	a5f9	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c5fb	a5fb	29 df		and #$df			and 	#$DF 						; clear sprite bit
.c5fd	a5fd	90 02		bcc $a601			bcc 	_CSNotOn
.c5ff	a5ff	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.c601	a601					_CSNotOn:
.c601	a601	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c604	a604	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.c606	a606	d0 02		bne $a60a			bne 	_CSNotDefault
.c608	a608	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.c60a	a60a					_CSNotDefault:
.c60a	a60a	8d 04 09	sta $0904			sta 	gxSpritePage
.c60d	a60d	20 cf a6	jsr $a6cf			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c610	a610	a5 36		lda $36				lda 	gxzTemp0 					; save this so we know where the sprites are.
.c612	a612	8d 13 09	sta $0913			sta 	gxSpriteOffsetBase
.c615	a615	a5 37		lda $37				lda 	gxzTemp0+1
.c617	a617	8d 14 09	sta $0914			sta 	gxSpriteOffsetBase+1
.c61a	a61a	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.c61c	a61c					_CSClear:
.c61c	a61c	9e 00 d9	stz $d900,x			stz 	$D900,x
.c61f	a61f	9e 00 da	stz $da00,x			stz 	$DA00,x
.c622	a622	ca		dex				dex
.c623	a623	d0 f7		bne $a61c			bne 	_CSClear
.c625	a625	9c 12 09	stz $0912			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.c628	a628	20 dd a6	jsr $a6dd			jsr 	GXClearSpriteStore
.c62b	a62b	18		clc				clc
.c62c	a62c	60		rts				rts
.c62d	a62d					GXControlTilemap:
.c62d	a62d	64 01		stz $01				stz 	1 							; access I/O
.c62f	a62f	a5 36		lda $36				lda 	gxzTemp0 					; get the Map Page/Enable
.c631	a631	30 0d		bmi $a640			bmi 	_GXCTOn
.c633	a633	ad 00 d0	lda $d000			lda 	$D000 						; turn off bitmap enable bit in MCR
.c636	a636	29 ef		and #$ef			and 	#$EF 						; clear bit 4
.c638	a638	8d 00 d0	sta $d000			sta 	$D000
.c63b	a63b	9c 02 09	stz $0902			stz 	gxTilesOn 					; clear tiles on flag.
.c63e	a63e	18		clc				clc
.c63f	a63f	60		rts				rts
.c640	a640					_GXCTOn:
.c640	a640	8d 02 09	sta $0902			sta 	gxTilesOn 					; set tiles on flag.
.c643	a643	ad 00 d0	lda $d000			lda 	$D000	 					; turn tilemap on
.c646	a646	09 17		ora #$17			ora 	#$17
.c648	a648	8d 00 d0	sta $d000			sta 	$D000
.c64b	a64b	9c 0c d2	stz $d20c			stz 	$D20C 						; turn off tilemap#1 and tilemap#2
.c64e	a64e	9c 18 d2	stz $d218			stz 	$D218
.c651	a651	a9 40		lda #$40			lda 	#64 						; default size of 64x32
.c653	a653	8d 07 09	sta $0907			sta 	gxTileMapWidth
.c656	a656	a9 20		lda #$20			lda		#32
.c658	a658	8d 08 09	sta $0908			sta 	gxTileMapHeight
.c65b	a65b	ad 02 09	lda $0902			lda 	gxTilesOn 					; set the tile map page
.c65e	a65e	29 7f		and #$7f			and 	#$7F
.c660	a660	d0 02		bne $a664			bne	 	_GXCTNotMapDefault 			; check for default
.c662	a662	a9 12		lda #$12			lda 	#TILEMAP_ADDRESS >> 13
.c664	a664					_GXCTNotMapDefault:
.c664	a664	8d 06 09	sta $0906			sta 	gxTileMapPage
.c667	a667	a5 37		lda $37				lda 	gxzTemp0+1 					; set the tile image page
.c669	a669	d0 02		bne $a66d			bne 	_GXCTNotImgDefault 			; check for default
.c66b	a66b	a9 13		lda #$13			lda 	#TILEIMAGES_ADDRESS >> 13
.c66d	a66d					_GXCTNotImgDefault:
.c66d	a66d	8d 05 09	sta $0905			sta 	gxTileImagePage
.c670	a670	a9 11		lda #$11			lda 	#$11 						; set tilemap#0 on and 8x8
.c672	a672	8d 00 d2	sta $d200			sta 	$D200
.c675	a675	ad 06 09	lda $0906			lda 	gxTileMapPage 				; put tile map address in.
.c678	a678	20 cf a6	jsr $a6cf			jsr		GXCalculateBaseAddress
.c67b	a67b	9c 01 d2	stz $d201			stz 	$D201
.c67e	a67e	a5 36		lda $36				lda 	gxzTemp0
.c680	a680	8d 02 d2	sta $d202			sta 	$D202
.c683	a683	a5 37		lda $37				lda 	gxzTemp0+1
.c685	a685	8d 03 d2	sta $d203			sta 	$D203
.c688	a688	ad 07 09	lda $0907			lda 	gxTileMapWidth	 			; set tilemap size.
.c68b	a68b	8d 04 d2	sta $d204			sta 	$D204
.c68e	a68e	ad 08 09	lda $0908			lda 	gxTileMapHeight
.c691	a691	8d 06 d2	sta $d206			sta 	$D206
.c694	a694	9c 08 d2	stz $d208			stz 	$D208 						; clear scrolling register
.c697	a697	9c 09 d2	stz $d209			stz 	$D209
.c69a	a69a	9c 0a d2	stz $d20a			stz 	$D20A
.c69d	a69d	9c 0b d2	stz $d20b			stz 	$D20B
.c6a0	a6a0	ad 05 09	lda $0905			lda 	gxTileImagePage 			; set the tile image address
.c6a3	a6a3	20 cf a6	jsr $a6cf			jsr 	GXCalculateBaseAddress
.c6a6	a6a6	9c 80 d2	stz $d280			stz 	$D280
.c6a9	a6a9	a5 36		lda $36				lda 	gxzTemp0
.c6ab	a6ab	8d 81 d2	sta $d281			sta 	$D281
.c6ae	a6ae	a5 37		lda $37				lda 	gxzTemp0+1
.c6b0	a6b0	8d 82 d2	sta $d282			sta 	$D282
.c6b3	a6b3	18		clc				clc
.c6b4	a6b4	60		rts				rts
.c6b5	a6b5					GXControlTileSize:
.c6b5	a6b5	ad 02 09	lda $0902			lda 	gxTilesOn 					; check on
.c6b8	a6b8	38		sec				sec
.c6b9	a6b9	f0 13		beq $a6ce			beq 	_GXCTSExit
.c6bb	a6bb	64 01		stz $01				stz 	1 							; access I/O 0
.c6bd	a6bd	a5 36		lda $36				lda 	gxzTemp0 					; save parameter to registes
.c6bf	a6bf	8d 07 09	sta $0907			sta 	gxTileMapWidth
.c6c2	a6c2	8d 04 d2	sta $d204			sta 	$D204
.c6c5	a6c5	a5 37		lda $37				lda 	gxzTemp0+1
.c6c7	a6c7	8d 08 09	sta $0908			sta 	gxTileMapHeight
.c6ca	a6ca	8d 06 d2	sta $d206			sta 	$D206
.c6cd	a6cd	18		clc				clc
.c6ce	a6ce					_GXCTSExit:
.c6ce	a6ce	60		rts				rts
.c6cf	a6cf					GXCalculateBaseAddress:
.c6cf	a6cf	85 36		sta $36				sta 	gxzTemp0
.c6d1	a6d1	64 37		stz $37				stz 	gxzTemp0+1
.c6d3	a6d3	a9 05		lda #$05			lda 	#5
.c6d5	a6d5					_GXShift:
.c6d5	a6d5	06 36		asl $36				asl 	gxzTemp0
.c6d7	a6d7	26 37		rol $37				rol 	gxzTemp0+1
.c6d9	a6d9	3a		dec a				dec		a
.c6da	a6da	d0 f9		bne $a6d5			bne 	_GXShift
.c6dc	a6dc	60		rts				rts
.c6dd	a6dd					GXClearSpriteStore:
.c6dd	a6dd	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.c6df	a6df					_GXCSSLoop:
.c6df	a6df	9e 55 09	stz $0955,x			stz 	gxSpriteHigh,x
.c6e2	a6e2	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.c6e4	a6e4	9d 15 09	sta $0915,x			sta 	gxSpriteLow,x
.c6e7	a6e7	ca		dex				dex
.c6e8	a6e8	10 f5		bpl $a6df			bpl 	_GXCSSLoop
.c6ea	a6ea	60		rts				rts
.c6eb	a6eb					GXLine:
.c6eb	a6eb	ad 01 09	lda $0901			lda 	gxBitmapsOn					; check bitmap on.
.c6ee	a6ee	f0 28		beq $a718			beq 	_GXLFail
.c6f0	a6f0	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; access it.
.c6f3	a6f3	20 4f ae	jsr $ae4f			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.c6f6	a6f6	20 be a7	jsr $a7be			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.c6f9	a6f9	20 d2 ac	jsr $acd2			jsr 	gxPositionCalc 				; calculate position/offset.
.c6fc	a6fc					_GXDrawLoop:
.c6fc	a6fc	ac 0f 09	ldy $090f			ldy 	gxOffset 					; draw the pixel
.c6ff	a6ff	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c701	a701	2d 0d 09	and $090d			and 	gxANDValue
.c704	a704	4d 0c 09	eor $090c			eor 	gxEORValue
.c707	a707	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c709	a709	20 1a a7	jsr $a71a			jsr 	GXLineIsComplete 			; is the line complete ?
.c70c	a70c	f0 05		beq $a713			beq 	_GXLExit
.c70e	a70e	20 35 a7	jsr $a735			jsr 	GXLineAdvance 				; code as per advance method
.c711	a711	80 e9		bra $a6fc			bra 	_GXDrawLoop
.c713	a713					_GXLExit:
.c713	a713	20 ca ac	jsr $acca			jsr 	GXCloseBitmap 				; restore and return success.
.c716	a716	18		clc				clc
.c717	a717	60		rts				rts
.c718	a718					_GXLFail:
.c718	a718	38		sec				sec
.c719	a719	60		rts				rts
.c71a	a71a					GXLineIsComplete:
.c71a	a71a	ad 9f 09	lda $099f			lda 	gxIsDiffYLarger 			; is dy larger
.c71d	a71d	d0 0f		bne $a72e			bne 	_GXLICCompareY 				; if so compare Y1 versus Y0
.c71f	a71f	ad f8 08	lda $08f8			lda 	gxX0 						; compare X, LSB and MSB
.c722	a722	4d fc 08	eor $08fc			eor 	gxX1
.c725	a725	d0 06		bne $a72d			bne 	_GXLICExit
.c727	a727	ad f9 08	lda $08f9			lda 	gxX0+1
.c72a	a72a	4d fd 08	eor $08fd			eor 	gxX1+1
.c72d	a72d					_GXLICExit:
.c72d	a72d	60		rts				rts
.c72e	a72e					_GXLICCompareY:
.c72e	a72e	ad fe 08	lda $08fe			lda 	gxY1
.c731	a731	4d fa 08	eor $08fa			eor 	gxY0
.c734	a734	60		rts				rts
.c735	a735					GXLineAdvance:
.c735	a735	18		clc				clc 								; add adjust to position
.c736	a736	ad a1 09	lda $09a1			lda 	gxPosition
.c739	a739	6d a2 09	adc $09a2			adc 	gxAdjust
.c73c	a73c	8d a1 09	sta $09a1			sta 	gxPosition
.c73f	a73f	9c a4 09	stz $09a4			stz 	gxAddSelect 				; clear add select flag
.c742	a742	b0 05		bcs $a749			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.c744	a744	cd a3 09	cmp $09a3			cmp 	gxTotal 					; if exceeded total
.c747	a747	90 0a		bcc $a753			bcc 	_GXLANoExtra
.c749	a749					_GXLAOverflow:
.c749	a749	ce a4 09	dec $09a4			dec 	gxAddSelect 				; set addselect to $FF
.c74c	a74c	38		sec				sec 								; subtract total and write back
.c74d	a74d	ed a3 09	sbc $09a3			sbc 	gxTotal
.c750	a750	8d a1 09	sta $09a1			sta 	gxPosition
.c753	a753					_GXLANoExtra:
.c753	a753	ad 9f 09	lda $099f			lda 	gxIsDiffYLarger
.c756	a756	f0 0d		beq $a765			beq 	_GXDXLarger
.c758	a758	20 b7 a7	jsr $a7b7			jsr 	GXIncrementY
.c75b	a75b	ad a4 09	lda $09a4			lda 	gxAddSelect
.c75e	a75e	f0 10		beq $a770			beq 	_GXLAExit
.c760	a760	20 71 a7	jsr $a771			jsr 	gxAdjustX
.c763	a763	80 0b		bra $a770			bra 	_GXLAExit
.c765	a765					_GXDXLarger:
.c765	a765	20 71 a7	jsr $a771			jsr 	gxAdjustX
.c768	a768	ad a4 09	lda $09a4			lda 	gxAddSelect
.c76b	a76b	f0 03		beq $a770			beq 	_GXLAExit
.c76d	a76d	20 b7 a7	jsr $a7b7			jsr 	GXIncrementY
.c770	a770					_GXLAExit:
.c770	a770	60		rts				rts
.c771	a771					gxAdjustX:
.c771	a771	ad a0 09	lda $09a0			lda 	gxDXNegative
.c774	a774	10 25		bpl $a79b			bpl 	_GXAXRight
.c776	a776	ad f8 08	lda $08f8			lda 	gxX0
.c779	a779	d0 03		bne $a77e			bne 	_GXAXNoBorrow
.c77b	a77b	ce f9 08	dec $08f9			dec 	gxX0+1
.c77e	a77e					_GXAXNoBorrow:
.c77e	a77e	ce f8 08	dec $08f8			dec 	gxX0
.c781	a781	ce 0f 09	dec $090f			dec 	gxOffset 					; pixel left
.c784	a784	ad 0f 09	lda $090f			lda 	gxOffset
.c787	a787	c9 ff		cmp #$ff			cmp 	#$FF
.c789	a789	d0 0f		bne $a79a			bne 	_GXAYExit 					; underflow
.c78b	a78b	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.c78d	a78d	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.c78f	a78f	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.c791	a791	b0 07		bcs $a79a			bcs 	_GXAYExit
.c793	a793	18		clc				clc
.c794	a794	69 20		adc #$20			adc 	#$20 						; fix up
.c796	a796	85 3d		sta $3d				sta 	gxzScreen+1
.c798	a798	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.c79a	a79a					_GXAYExit:
.c79a	a79a	60		rts				rts
.c79b	a79b					_GXAXRight:
.c79b	a79b	ee f8 08	inc $08f8			inc 	gxX0
.c79e	a79e	d0 03		bne $a7a3			bne 	_GXAXNoCarry
.c7a0	a7a0	ee f9 08	inc $08f9			inc 	gxX0+1
.c7a3	a7a3					_GXAXNoCarry:
.c7a3	a7a3	ee 0f 09	inc $090f			inc 	gxOffset 					; pixel right
.c7a6	a7a6	d0 0e		bne $a7b6			bne 	_GXAXExit 					; if not overflowed, exit.
.c7a8	a7a8	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.c7aa	a7aa	a5 3d		lda $3d				lda 	gxzScreen+1
.c7ac	a7ac	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.c7ae	a7ae	90 06		bcc $a7b6			bcc 	_GXAXExit
.c7b0	a7b0	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c7b2	a7b2	85 3d		sta $3d				sta 	gxzScreen+1
.c7b4	a7b4	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.c7b6	a7b6					_GXAXExit:
.c7b6	a7b6	60		rts				rts
.c7b7	a7b7					GXIncrementY:
.c7b7	a7b7	ee fa 08	inc $08fa			inc 	gxY0
.c7ba	a7ba	20 28 ad	jsr $ad28			jsr 	GXMovePositionDown
.c7bd	a7bd	60		rts				rts
.c7be	a7be					GXLineSetup:
.c7be	a7be	ad fe 08	lda $08fe			lda 	gxY1
.c7c1	a7c1	38		sec				sec
.c7c2	a7c2	ed fa 08	sbc $08fa			sbc 	gxY0
.c7c5	a7c5	4a		lsr a				lsr 	a
.c7c6	a7c6	8d 9e 09	sta $099e			sta 	gxDiffY
.c7c9	a7c9	9c a0 09	stz $09a0			stz 	gxDXNegative 				; clear -ve flag
.c7cc	a7cc	38		sec				sec
.c7cd	a7cd	ad fc 08	lda $08fc			lda 	gxX1
.c7d0	a7d0	ed f8 08	sbc $08f8			sbc 	gxX0
.c7d3	a7d3	8d 9d 09	sta $099d			sta 	gxDiffX
.c7d6	a7d6	ad fd 08	lda $08fd			lda 	gxX1+1 						; calculate MSB
.c7d9	a7d9	ed f9 08	sbc $08f9			sbc 	gxX0+1
.c7dc	a7dc	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.c7dd	a7dd	6e 9d 09	ror $099d			ror 	gxDiffX
.c7e0	a7e0	0a		asl a				asl 	a
.c7e1	a7e1	10 0c		bpl $a7ef			bpl 	_GDXNotNegative
.c7e3	a7e3	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.c7e5	a7e5	38		sec				sec
.c7e6	a7e6	ed 9d 09	sbc $099d			sbc 	gxDiffX
.c7e9	a7e9	8d 9d 09	sta $099d			sta 	gxDiffX
.c7ec	a7ec	ce a0 09	dec $09a0			dec 	gxDXNegative 				; -ve flag = $FF.
.c7ef	a7ef					_GDXNotNegative:
.c7ef	a7ef	9c 9f 09	stz $099f			stz 	gxIsDiffYLarger 			; clear larger flag
.c7f2	a7f2	ad 9e 09	lda $099e			lda 	gxDiffY 					; set adjust and total.
.c7f5	a7f5	8d a2 09	sta $09a2			sta 	gxAdjust
.c7f8	a7f8	ad 9d 09	lda $099d			lda 	gxDiffX
.c7fb	a7fb	8d a3 09	sta $09a3			sta 	gxTotal
.c7fe	a7fe	ad 9e 09	lda $099e			lda 	gxDiffY 					; if dy > dx
.c801	a801	cd 9d 09	cmp $099d			cmp 	gxDiffX
.c804	a804	90 0f		bcc $a815			bcc 	_GDXNotLarger
.c806	a806	ce 9f 09	dec $099f			dec 	gxIsDiffYLarger 			; set the dy larger flag
.c809	a809	ad 9d 09	lda $099d			lda 	gxDiffX 					; set adjust and total other way round
.c80c	a80c	8d a2 09	sta $09a2			sta 	gxAdjust
.c80f	a80f	ad 9e 09	lda $099e			lda 	gxDiffY
.c812	a812	8d a3 09	sta $09a3			sta 	gxTotal
.c815	a815					_GDXNotLarger:
.c815	a815	ad a3 09	lda $09a3			lda 	gxTotal
.c818	a818	4a		lsr a				lsr 	a
.c819	a819	8d a1 09	sta $09a1			sta 	gxPosition
.c81c	a81c	60		rts				rts
.099d						gxDiffX:
>099d								.fill 	1
.099e						gxDiffY:
>099e								.fill 	1
.099f						gxIsDiffYLarger:
>099f								.fill 	1
.09a0						gxDXNegative:
>09a0								.fill 	1
.09a1						gxPosition:
>09a1								.fill 	1
.09a2						gxAdjust:
>09a2								.fill 	1
.09a3						gxTotal:
>09a3								.fill 	1
.09a4						gxAddSelect:
>09a4								.fill 	1
.c81d	a81d					GXSetColourMode:
.c81d	a81d	a6 36		ldx $36				ldx 	gxzTemp0
.c81f	a81f	8e 0b 09	stx $090b			stx 	gxColour 								; set colour
.c822	a822	a5 37		lda $37				lda 	gxzTemp0+1 								;
.c824	a824	8d 0a 09	sta $090a			sta 	gxMode 									; set mode
.c827	a827	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.c829	a829	9c 0d 09	stz $090d			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.c82c	a82c	ae 0b 09	ldx $090b			ldx 	gxColour
.c82f	a82f	8e 0c 09	stx $090c			stx 	gxEORValue
.c832	a832	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.c834	a834	90 03		bcc $a839			bcc 	_GXSDCNotAndColour
.c836	a836	8e 0d 09	stx $090d			stx 	gxANDValue
.c839	a839					_GXSDCNotAndColour:
.c839	a839	d0 03		bne $a83e			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.c83b	a83b	9c 0c 09	stz $090c			stz 	gxEORValue
.c83e	a83e					_GXSDCNotAnd:
.c83e	a83e	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.c83f	a83f	90 08		bcc $a849			bcc 	_GXSDCNoFlip
.c841	a841	ad 0d 09	lda $090d			lda	 	gxANDValue
.c844	a844	49 ff		eor #$ff			eor 	#$FF
.c846	a846	8d 0d 09	sta $090d			sta 	gxANDValue
.c849	a849					_GXSDCNoFlip:
.c849	a849	18		clc				clc
.c84a	a84a	60		rts				rts
.c84b	a84b					GXPlotPoint:
.c84b	a84b	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; start drawing
.c84e	a84e	20 d2 ac	jsr $acd2			jsr 	gxPositionCalc 				; setup gxzScreen, gxOffset and the position.
.c851	a851	ac 0f 09	ldy $090f			ldy 	gxOffset
.c854	a854	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 				; set pixel on the right
.c856	a856	2d 0d 09	and $090d			and 	gxANDValue
.c859	a859	4d 0c 09	eor $090c			eor 	gxEORValue
.c85c	a85c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c85e	a85e	20 ca ac	jsr $acca			jsr 	GXCloseBitmap 				; stop drawing and exit
.c861	a861	18		clc				clc
.c862	a862	60		rts				rts
.c863	a863					GXFillRectangle:
.c863	a863	38		sec				sec 								; pass carry in for fill/frame
.c864	a864	80 01		bra $a867			bra 	GXRectangle
.c866	a866					GXFrameRectangle:
.c866	a866	18		clc				clc
.c867	a867					GXRectangle:
.c867	a867	ad 01 09	lda $0901			lda 	gxBitmapsOn 				; exit if off.
.c86a	a86a	f0 35		beq $a8a1			beq 	_GXRFail
.c86c	a86c	08		php				php 								; save Fill flag (CS)
.c86d	a86d	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; start drawing
.c870	a870	20 31 ae	jsr $ae31			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.c873	a873	20 d2 ac	jsr $acd2			jsr 	gxPositionCalc 				; setup gxzScreen, gxOffset and the position.
.c876	a876	38		sec				sec 								; sec = Draw line
.c877	a877	20 a3 a8	jsr $a8a3			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.c87a	a87a	ad fa 08	lda $08fa			lda 	gxY0 						; reached end of rectangle ?
.c87d	a87d	cd fe 08	cmp $08fe			cmp 	gxY1 						; e.g. 1 pixel high.
.c880	a880	f0 19		beq $a89b			beq 	_GXRectangleExit
.c882	a882					_GXRectLoop:
.c882	a882	20 28 ad	jsr $ad28			jsr 	GXMovePositionDown 			; down one.
.c885	a885	ee fa 08	inc $08fa			inc 	gxY0 						; change Y pos
.c888	a888	ad fa 08	lda $08fa			lda 	gxY0 						; reached last line
.c88b	a88b	cd fe 08	cmp $08fe			cmp 	gxY1
.c88e	a88e	f0 07		beq $a897			beq 	_GXLastLine
.c890	a890	28		plp				plp 								; get flag back for solid/edged
.c891	a891	08		php				php
.c892	a892	20 a3 a8	jsr $a8a3			jsr 	GXDrawLineX1X0 				; draw horizontal line
.c895	a895	80 eb		bra $a882			bra 	_GXRectLoop
.c897	a897					_GXLastLine:
.c897	a897	38		sec				sec
.c898	a898	20 a3 a8	jsr $a8a3			jsr 	GXDrawLineX1X0
.c89b	a89b					_GXRectangleExit:
.c89b	a89b	68		pla				pla 								; throw fill flag.
.c89c	a89c	20 ca ac	jsr $acca			jsr 	GXCloseBitmap 				; stop drawing and exit
.c89f	a89f	18		clc				clc
.c8a0	a8a0	60		rts				rts
.c8a1	a8a1					_GXRFail:
.c8a1	a8a1	38		sec				sec
.c8a2	a8a2	60		rts				rts
.c8a3	a8a3					GXDrawLineX1X0:
.c8a3	a8a3	08		php				php 								; save solid/either-end
.c8a4	a8a4	38		sec				sec 								; calculate x1-x0
.c8a5	a8a5	ad fc 08	lda $08fc			lda		gxX1
.c8a8	a8a8	ed f8 08	sbc $08f8			sbc 	gxX0
.c8ab	a8ab	85 36		sta $36				sta 	gxzTemp0
.c8ad	a8ad	ad fd 08	lda $08fd			lda 	gxX1+1
.c8b0	a8b0	ed f9 08	sbc $08f9			sbc 	gxX0+1
.c8b3	a8b3	85 37		sta $37				sta 	gxzTemp0+1
.c8b5	a8b5	28		plp				plp
.c8b6	a8b6					GXDrawLineTemp0:
.c8b6	a8b6	a5 3c		lda $3c				lda 	gxzScreen 					; push gxzScreen, gxOffset and GXEditSlot on stack
.c8b8	a8b8	48		pha				pha
.c8b9	a8b9	a5 3d		lda $3d				lda 	gxzScreen+1
.c8bb	a8bb	48		pha				pha
.c8bc	a8bc	ad 0f 09	lda $090f			lda 	gxOffset
.c8bf	a8bf	48		pha				pha
.c8c0	a8c0	a5 0b		lda $0b				lda 	GXEditSlot
.c8c2	a8c2	48		pha				pha
.c8c3	a8c3	ac 0f 09	ldy $090f			ldy 	gxOffset 					; Y offset
.c8c6	a8c6	90 1e		bcc $a8e6			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.c8c8	a8c8					_GXDLTLine:
.c8c8	a8c8	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 				; set pixel
.c8ca	a8ca	2d 0d 09	and $090d			and 	gxANDValue
.c8cd	a8cd	4d 0c 09	eor $090c			eor 	gxEORValue
.c8d0	a8d0	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c8d2	a8d2	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.c8d4	a8d4	d0 04		bne $a8da			bne 	_GXDLTNoBorrow
.c8d6	a8d6	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.c8d8	a8d8	30 2e		bmi $a908			bmi 	_GXDLTExit
.c8da	a8da					_GXDLTNoBorrow:
.c8da	a8da	c6 36		dec $36				dec 	gxzTemp0
.c8dc	a8dc	c8		iny				iny 								; next slot.
.c8dd	a8dd	d0 e9		bne $a8c8			bne 	_GXDLTLine
.c8df	a8df	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.c8e1	a8e1	20 16 a9	jsr $a916			jsr 	GXDLTCheckWrap				; check for new page.
.c8e4	a8e4	80 e2		bra $a8c8			bra 	_GXDLTLine
.c8e6	a8e6					_GXDLTEndPoints:
.c8e6	a8e6	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 				; set pixel
.c8e8	a8e8	2d 0d 09	and $090d			and 	gxANDValue
.c8eb	a8eb	4d 0c 09	eor $090c			eor 	gxEORValue
.c8ee	a8ee	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c8f0	a8f0	98		tya				tya 								; advance to right side
.c8f1	a8f1	18		clc				clc
.c8f2	a8f2	65 36		adc $36				adc 	gxzTemp0
.c8f4	a8f4	a8		tay				tay
.c8f5	a8f5	a5 3d		lda $3d				lda 	gxzScreen+1
.c8f7	a8f7	65 37		adc $37				adc 	gxzTemp0+1
.c8f9	a8f9	85 3d		sta $3d				sta 	gxzScreen+1
.c8fb	a8fb	20 16 a9	jsr $a916			jsr 	GXDLTCheckWrap 				; fix up.
.c8fe	a8fe	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 				; set pixel on the right
.c900	a900	2d 0d 09	and $090d			and 	gxANDValue
.c903	a903	4d 0c 09	eor $090c			eor 	gxEORValue
.c906	a906	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c908	a908					_GXDLTExit:
.c908	a908	68		pla				pla
.c909	a909	85 0b		sta $0b				sta 	GXEditSlot
.c90b	a90b	68		pla				pla
.c90c	a90c	8d 0f 09	sta $090f			sta 	gxOffset
.c90f	a90f	68		pla				pla
.c910	a910	85 3d		sta $3d				sta 	gxzScreen+1
.c912	a912	68		pla				pla
.c913	a913	85 3c		sta $3c				sta 	gxzScreen
.c915	a915	60		rts				rts
.c916	a916					GXDLTCheckWrap:
.c916	a916	a5 3d		lda $3d				lda 	gxzScreen+1 				; check end of page
.c918	a918	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.c91a	a91a	90 06		bcc $a922			bcc 	_GXDLTCWExit
.c91c	a91c	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c91e	a91e	85 3d		sta $3d				sta 	gxzScreen+1
.c920	a920	e6 0b		inc $0b				inc 	GXEditSlot 					; next bitmap vram page.
.c922	a922					_GXDLTCWExit:
.c922	a922	60		rts				rts
.c923	a923					GXDrawGraphicElement:
.c923	a923	8d a5 09	sta $09a5			sta 	gxSize 						; save size
.c926	a926	3a		dec a				dec 	a
.c927	a927	8d a6 09	sta $09a6			sta 	gxMask 						; and mask
.c92a	a92a	ad 01 09	lda $0901			lda 	gxBitmapsOn 				; check BMP on
.c92d	a92d	f0 67		beq $a996			beq 	_GXSLFail
.c92f	a92f	ad fa 08	lda $08fa			lda 	gxY0 						; push Y on stack
.c932	a932	48		pha				pha
.c933	a933	8c a8 09	sty $09a8			sty 	gxAcquireVector+1 			; and acquisition vector
.c936	a936	8e a7 09	stx $09a7			stx 	gxAcquireVector
.c939	a939	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; open the bitmap.
.c93c	a93c	ad aa 09	lda $09aa			lda 	gxUseMode 					; scale bits
.c93f	a93f	4a		lsr a				lsr 	a
.c940	a940	4a		lsr a				lsr 	a
.c941	a941	4a		lsr a				lsr 	a
.c942	a942	29 07		and #$07			and		#7
.c944	a944	1a		inc a				inc 	a
.c945	a945	8d a9 09	sta $09a9			sta 	gxScale
.c948	a948	64 38		stz $38				stz 	gxzTemp1					; start first line
.c94a	a94a					_GXGELoop:
.c94a	a94a	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.c94c	a94c	2c aa 09	bit $09aa			bit 	gxUseMode 					; check for flip.
.c94f	a94f	10 06		bpl $a957			bpl		_GXNoVFlip
.c951	a951	ad a6 09	lda $09a6			lda 	gxMask
.c954	a954	38		sec				sec
.c955	a955	e5 38		sbc $38				sbc 	gxzTemp1
.c957	a957					_GXNoVFlip:
.c957	a957	aa		tax				tax 								; get the Xth line.
.c958	a958	20 98 a9	jsr $a998			jsr 	_GXCallAcquire 				; get that data.
.c95b	a95b	ad a9 09	lda $09a9			lda 	gxScale 					; do scale identical copies of that line.
.c95e	a95e	85 39		sta $39				sta 	gxzTemp1+1
.c960	a960					_GXGELoop2:
.c960	a960	ad fa 08	lda $08fa			lda 	gxY0 						; off screen
.c963	a963	cd 09 09	cmp $0909			cmp 	gxHeight
.c966	a966	b0 10		bcs $a978			bcs 	_GXDGEExit
.c968	a968	20 9b a9	jsr $a99b			jsr 	GXRenderOneLine 			; render line
.c96b	a96b	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.c96d	a96d	d0 f1		bne $a960			bne 	_GXGELoop2
.c96f	a96f	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.c971	a971	a5 38		lda $38				lda 	gxzTemp1
.c973	a973	cd a5 09	cmp $09a5			cmp 	gxSize
.c976	a976	d0 d2		bne $a94a			bne 	_GXGELoop
.c978	a978					_GXDGEExit:
.c978	a978	68		pla				pla 								; restore Y for next time
.c979	a979	8d fa 08	sta $08fa			sta 	gxY0
.c97c	a97c	ae a9 09	ldx $09a9			ldx 	gxScale 					; get scale (1-8)
.c97f	a97f					_GXShiftLeft:
.c97f	a97f	18		clc				clc
.c980	a980	ad a5 09	lda $09a5			lda 	gxSize
.c983	a983	6d f8 08	adc $08f8			adc 	gxX0
.c986	a986	8d f8 08	sta $08f8			sta 	gxX0
.c989	a989	90 03		bcc $a98e			bcc 	_GXSLNoCarry
.c98b	a98b	ee f9 08	inc $08f9			inc 	gxX0+1
.c98e	a98e					_GXSLNoCarry:
.c98e	a98e	ca		dex				dex
.c98f	a98f	d0 ee		bne $a97f			bne 	_GXShiftLeft
.c991	a991	20 ca ac	jsr $acca			jsr 	GXCloseBitmap
.c994	a994	18		clc				clc
.c995	a995	60		rts				rts
.c996	a996					_GXSLFail:
.c996	a996	38		sec				sec
.c997	a997	60		rts				rts
.c998	a998					_GXCallAcquire:
.c998	a998	6c a7 09	jmp ($09a7)			jmp 	(gxAcquireVector)
.c99b	a99b					GXRenderOneLine:
.c99b	a99b	20 d2 ac	jsr $acd2			jsr 	gxPositionCalc 				; calculate position/offset.
.c99e	a99e	ac 0f 09	ldy $090f			ldy 	gxOffset 					; Y contains position.
.c9a1	a9a1	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.c9a3	a9a3					_GXROLLoop1:
.c9a3	a9a3	ad a9 09	lda $09a9			lda 	gxScale 					; set to do 'scale' times
.c9a6	a9a6	85 3b		sta $3b				sta 	gxzTemp2+1
.c9a8	a9a8					_GXROLLoop2:
.c9a8	a9a8	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.c9aa	a9aa	2c 0a 09	bit $090a			bit 	gxMode 						; check H Flip
.c9ad	a9ad	50 06		bvc $a9b5			bvc 	_GXNoHFlip
.c9af	a9af	ad a6 09	lda $09a6			lda 	gxMask
.c9b2	a9b2	38		sec				sec
.c9b3	a9b3	e5 3a		sbc $3a				sbc 	gxzTemp2
.c9b5	a9b5					_GXNoHFlip:
.c9b5	a9b5	aa		tax				tax 								; read from the pixel buffer
.c9b6	a9b6	bd 43 06	lda $0643,x			lda 	gxPixelBuffer,x
.c9b9	a9b9	d0 07		bne $a9c2			bne 	_GXDraw 					; draw if non zero
.c9bb	a9bb	ad aa 09	lda $09aa			lda 	gxUseMode 					; check to see if solid background
.c9be	a9be	29 04		and #$04			and 	#4
.c9c0	a9c0	f0 0a		beq $a9cc			beq 	_GXZeroPixel
.c9c2	a9c2					_GXDraw:
.c9c2	a9c2	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c9c4	a9c4	2d 0d 09	and $090d			and 	gxANDValue
.c9c7	a9c7	5d 43 06	eor $0643,x			eor 	gxPixelBuffer,x
.c9ca	a9ca	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c9cc	a9cc					_GXZeroPixel:
.c9cc	a9cc	c8		iny				iny 								; advance pointer
.c9cd	a9cd	d0 05		bne $a9d4			bne 	_GXNoShift
.c9cf	a9cf	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.c9d1	a9d1	20 16 a9	jsr $a916			jsr 	GXDLTCheckWrap				; check for new page.
.c9d4	a9d4					_GXNoShift:
.c9d4	a9d4	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.c9d6	a9d6	d0 d0		bne $a9a8			bne 	_GXROLLoop2
.c9d8	a9d8	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.c9da	a9da	a5 3a		lda $3a				lda 	gxzTemp2
.c9dc	a9dc	cd a5 09	cmp $09a5			cmp 	gxSize
.c9df	a9df	d0 c2		bne $a9a3			bne 	_GXROLLoop1
.c9e1	a9e1	ee fa 08	inc $08fa			inc 	gxY0
.c9e4	a9e4	60		rts				rts
.09a5						gxSize:
>09a5								.fill 	1
.09a6						gxMask:
>09a6								.fill 	1
.09a7						gxAcquireVector:
>09a7								.fill 	2
.09a9						gxScale:
>09a9								.fill 	1
.09aa						gxUseMode:
>09aa								.fill 	1
.c9e5	a9e5					GXControlTileScrollX:
.c9e5	a9e5	ad 07 09	lda $0907			lda 	gxTileMapWidth 				; comparator value (max X tile)
.c9e8	a9e8	20 07 aa	jsr $aa07			jsr 	GXScrollProcessor 			; scroll processing.
.c9eb	a9eb	b0 08		bcs $a9f5			bcs 	_GXCTSExit
.c9ed	a9ed	64 01		stz $01				stz 	1 							; write it out.
.c9ef	a9ef	8e 08 d2	stx $d208			stx 	$D208
.c9f2	a9f2	8c 09 d2	sty $d209			sty 	$D209
.c9f5	a9f5					_GXCTSExit:
.c9f5	a9f5	60		rts				rts
.c9f6	a9f6					GXControlTileScrollY:
.c9f6	a9f6	ad 08 09	lda $0908			lda 	gxTileMapHeight 			; comparator value (max X tile)
.c9f9	a9f9	20 07 aa	jsr $aa07			jsr 	GXScrollProcessor 			; scroll processing.
.c9fc	a9fc	b0 08		bcs $aa06			bcs 	_GXCTSExit
.c9fe	a9fe	64 01		stz $01				stz 	1 							; write it out.
.ca00	aa00	8e 0a d2	stx $d20a			stx 	$D20A
.ca03	aa03	8c 0b d2	sty $d20b			sty 	$D20B
.ca06	aa06					_GXCTSExit:
.ca06	aa06	60		rts				rts
.ca07	aa07					GXScrollProcessor:
.ca07	aa07	85 38		sta $38				sta 	gxzTemp1 					; save max tile value.
.ca09	aa09	ad 02 09	lda $0902			lda 	gxTilesOn 					; check tile map is on.
.ca0c	aa0c	38		sec				sec
.ca0d	aa0d	f0 2c		beq $aa3b			beq 	_GXSPExit
.ca0f	aa0f	64 39		stz $39				stz 	gxzTemp1+1 					; convert tile size to a pixel scroll.
.ca11	aa11	a2 03		ldx #$03			ldx 	#3
.ca13	aa13					_GXCalcMaxPixelScroll:
.ca13	aa13	06 38		asl $38				asl 	gxzTemp1
.ca15	aa15	26 39		rol $39				rol 	gxzTemp1+1
.ca17	aa17	ca		dex				dex
.ca18	aa18	d0 f9		bne $aa13			bne 	_GXCalcMaxPixelScroll
.ca1a	aa1a	a5 36		lda $36				lda 	gxzTemp0 					; check scroll in range.
.ca1c	aa1c	c5 38		cmp $38				cmp 	gxzTemp1
.ca1e	aa1e	a5 37		lda $37				lda 	gxzTemp0+1
.ca20	aa20	e5 39		sbc $39				sbc 	gxzTemp1+1
.ca22	aa22	b0 17		bcs $aa3b			bcs		_GXSPExit
.ca24	aa24	a5 36		lda $36				lda 	gxzTemp0 	 				; save fine scroll.
.ca26	aa26	29 07		and #$07			and		#7
.ca28	aa28	85 38		sta $38				sta 	gxzTemp1
.ca2a	aa2a	06 36		asl $36				asl 	gxzTemp0 					; shift left one, as whole tiles are 8 pixels.
.ca2c	aa2c	26 37		rol $37				rol 	gxzTemp0+1
.ca2e	aa2e	a5 37		lda $37				lda 	gxzTemp0+1 					; MSB is the upper byte.
.ca30	aa30	29 0f		and #$0f			and 	#$0F
.ca32	aa32	a8		tay				tay
.ca33	aa33	a5 36		lda $36				lda 	gxzTemp0 					; get coarse scroll
.ca35	aa35	29 f0		and #$f0			and 	#$F0
.ca37	aa37	05 38		ora $38				ora 	gxzTemp1 					; OR in fine scroll.
.ca39	aa39	aa		tax				tax 								; return in X
.ca3a	aa3a	18		clc				clc
.ca3b	aa3b					_GXSPExit:
.ca3b	aa3b	60		rts				rts
.ca3c	aa3c					GXFontHandler:
.ca3c	aa3c	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.ca3e	aa3e	4d 0a 09	eor $090a			eor 	gxMode
.ca41	aa41	8d aa 09	sta $09aa			sta 	gxUseMode
.ca44	aa44	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.ca46	aa46	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.ca48	aa48	26 37		rol $37				rol	 	gxzTemp0+1
.ca4a	aa4a	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.ca4c	aa4c	26 37		rol $37				rol	 	gxzTemp0+1
.ca4e	aa4e	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.ca50	aa50	26 37		rol $37				rol	 	gxzTemp0+1
.ca52	aa52	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.ca54	aa54	09 c0		ora #$c0			ora 	#$C0
.ca56	aa56	85 37		sta $37				sta 	gxzTemp0+1
.ca58	aa58	a9 08		lda #$08			lda 	#8 							; size 8x8
.ca5a	aa5a	a2 62		ldx #$62			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.ca5c	aa5c	a0 aa		ldy #$aa			ldy 	#GXGetGraphicDataFont >> 8
.ca5e	aa5e	20 23 a9	jsr $a923			jsr 	GXDrawGraphicElement
.ca61	aa61	60		rts				rts
.ca62	aa62					GXGetGraphicDataFont:
.ca62	aa62	8a		txa				txa 								; X->Y
.ca63	aa63	a8		tay				tay
.ca64	aa64	a6 01		ldx $01				ldx 	1 							; preserve old value
.ca66	aa66	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.ca68	aa68	85 01		sta $01				sta 	1
.ca6a	aa6a	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.ca6c	aa6c	86 01		stx $01				stx 	1 							; put old value back.
.ca6e	aa6e	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.ca70	aa70					_GXExpand:
.ca70	aa70	9e 43 06	stz $0643,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.ca73	aa73	0a		asl a				asl 	a 							; shift bit 7 into C
.ca74	aa74	90 08		bcc $aa7e			bcc 	_GXNoPixel
.ca76	aa76	48		pha				pha 								; if set, set pixel buffer to current colour.
.ca77	aa77	ad 0b 09	lda $090b			lda 	gxColour
.ca7a	aa7a	9d 43 06	sta $0643,x			sta 	gxPixelBuffer,x
.ca7d	aa7d	68		pla				pla
.ca7e	aa7e					_GXNoPixel:
.ca7e	aa7e	e8		inx				inx 								; do the whole byte.
.ca7f	aa7f	e0 08		cpx #$08			cpx 	#8
.ca81	aa81	d0 ed		bne $aa70			bne 	_GXExpand
.ca83	aa83	60		rts				rts
.ca84	aa84					GXSpriteHandler:
.ca84	aa84	ad 00 09	lda $0900			lda 	gxSpritesOn 				; sprites on ?
.ca87	aa87	f0 23		beq $aaac			beq 	_GXSHExit
.ca89	aa89	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.ca8b	aa8b	4d 0a 09	eor $090a			eor 	gxMode
.ca8e	aa8e	8d aa 09	sta $09aa			sta 	gxUseMode
.ca91	aa91	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.ca93	aa93	da		phx				phx
.ca94	aa94	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap 				; can access sprite information
.ca97	aa97	68		pla				pla
.ca98	aa98	20 a3 ad	jsr $ada3			jsr 	GXFindSprite 				; get the sprite address
.ca9b	aa9b	08		php				php
.ca9c	aa9c	20 ca ac	jsr $acca			jsr 	GXCloseBitmap
.ca9f	aa9f	28		plp				plp
.caa0	aaa0	b0 0a		bcs $aaac			bcs		_GXSHExit 					; exit if find failed.
.caa2	aaa2	ad ab 09	lda $09ab			lda 	gxSizePixels 				; return size
.caa5	aaa5	a2 ad		ldx #$ad			ldx 	#GXSpriteAcquire & $FF
.caa7	aaa7	a0 aa		ldy #$aa			ldy 	#GXSpriteAcquire >> 8
.caa9	aaa9	20 23 a9	jsr $a923			jsr 	GXDrawGraphicElement
.caac	aaac					_GXSHExit:
.caac	aaac	60		rts				rts
.caad	aaad					GXSpriteAcquire:
.caad	aaad	ad 04 09	lda $0904			lda 	gxSpritePage				; point to base page
.cab0	aab0	85 0b		sta $0b				sta 	GXEditSlot
.cab2	aab2	86 36		stx $36				stx 	gxzTemp0 					; row number x 1,2,3,4
.cab4	aab4	a9 00		lda #$00			lda 	#0
.cab6	aab6	ae ac 09	ldx $09ac			ldx 	gxSizeBits
.cab9	aab9					_GXTimesRowNumber:
.cab9	aab9	18		clc				clc
.caba	aaba	65 36		adc $36				adc 	gxzTemp0
.cabc	aabc	ca		dex				dex
.cabd	aabd	10 fa		bpl $aab9			bpl 	_GXTimesRowNumber
.cabf	aabf	64 37		stz $37				stz 	gxzTemp0+1
.cac1	aac1	0a		asl a				asl 	a 							; row x 2,4,6,8
.cac2	aac2	26 37		rol $37				rol 	gxzTemp0+1
.cac4	aac4	0a		asl a				asl 	a 							; row x 4,8,12,16
.cac5	aac5	26 37		rol $37				rol 	gxzTemp0+1
.cac7	aac7	0a		asl a				asl 	a 							; row x 8,16,24,32
.cac8	aac8	26 37		rol $37				rol 	gxzTemp0+1
.caca	aaca	85 36		sta $36				sta 	gxzTemp0
.cacc	aacc	18		clc				clc 								; add base address.
.cacd	aacd	a5 36		lda $36				lda 	gxzTemp0
.cacf	aacf	6d ae 09	adc $09ae			adc 	gxSpriteOffset
.cad2	aad2	85 36		sta $36				sta 	gxzTemp0
.cad4	aad4	a5 37		lda $37				lda 	gxzTemp0+1
.cad6	aad6	6d af 09	adc $09af			adc 	gxSpriteOffset+1
.cad9	aad9					_GXSAFindPage:
.cad9	aad9	c9 20		cmp #$20			cmp 	#$20 						; on this page
.cadb	aadb	90 06		bcc $aae3			bcc 	_GXSAFoundPage
.cadd	aadd	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.cadf	aadf	e6 0b		inc $0b				inc 	GXEditSlot
.cae1	aae1	80 f6		bra $aad9			bra 	_GXSAFindPage
.cae3	aae3					_GXSAFoundPage:
.cae3	aae3	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.cae5	aae5	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.cae7	aae7	a0 00		ldy #$00			ldy 	#0
.cae9	aae9					_GXSACopyLoop:
.cae9	aae9	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.caeb	aaeb	99 43 06	sta $0643,y			sta 	gxPixelBuffer,y
.caee	aaee	c8		iny				iny
.caef	aaef	cc ab 09	cpy $09ab			cpy 	gxSizePixels
.caf2	aaf2	d0 f5		bne $aae9			bne 	_GXSACopyLoop
.caf4	aaf4	60		rts				rts
.caf5	aaf5					GXSelect:
.caf5	aaf5	ad 00 09	lda $0900			lda 	gxSpritesOn
.caf8	aaf8	f0 22		beq $ab1c			beq 	_GXSFail
.cafa	aafa	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.cafc	aafc	c9 40		cmp #$40			cmp 	#64
.cafe	aafe	b0 1c		bcs $ab1c			bcs 	_GXSFail
.cb00	ab00	8d 10 09	sta $0910			sta 	GSCurrentSpriteID
.cb03	ab03	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.cb05	ab05	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.cb07	ab07	06 36		asl $36				asl 	gxzTemp0
.cb09	ab09	06 36		asl $36				asl 	gxzTemp0
.cb0b	ab0b	06 36		asl $36				asl 	gxzTemp0
.cb0d	ab0d	2a		rol a				rol 	a
.cb0e	ab0e	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.cb10	ab10	8d 12 09	sta $0912			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.cb13	ab13	85 37		sta $37				sta 	gxzTemp0+1
.cb15	ab15	a5 36		lda $36				lda 	gxzTemp0
.cb17	ab17	8d 11 09	sta $0911			sta 	GSCurrentSpriteAddr
.cb1a	ab1a	18		clc				clc
.cb1b	ab1b	60		rts				rts
.cb1c	ab1c					_GXSFail:
.cb1c	ab1c	38		sec				sec
.cb1d	ab1d	60		rts				rts
.cb1e	ab1e					GXSelectImage:
.cb1e	ab1e	ad 00 09	lda $0900			lda 	gxSpritesOn
.cb21	ab21	f0 74		beq $ab97			beq 	_GXSIFail
.cb23	ab23	ad 12 09	lda $0912			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.cb26	ab26	f0 6f		beq $ab97			beq 	_GXSIFail 					; (checking the MSB)
.cb28	ab28	64 01		stz $01				stz 	1
.cb2a	ab2a	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.cb2c	ab2c	d0 6b		bne $ab99			bne 	_GXSIHide
.cb2e	ab2e	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.cb30	ab30	48		pha				pha
.cb31	ab31	20 c2 ac	jsr $acc2			jsr 	GXOpenBitmap
.cb34	ab34	68		pla				pla
.cb35	ab35	20 a3 ad	jsr $ada3			jsr 	GXFindSprite
.cb38	ab38	b0 5a		bcs $ab94			bcs 	_GXSICloseFail 				; no image
.cb3a	ab3a	a0 01		ldy #$01			ldy 	#1
.cb3c	ab3c	ad 11 09	lda $0911			lda 	GSCurrentSpriteAddr
.cb3f	ab3f	85 36		sta $36				sta 	gxzTemp0
.cb41	ab41	ad 12 09	lda $0912			lda 	GSCurrentSpriteAddr+1
.cb44	ab44	85 37		sta $37				sta 	gxzTemp0+1
.cb46	ab46	ad ae 09	lda $09ae			lda 	gxSpriteOffset
.cb49	ab49	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.cb4b	ab4b	18		clc				clc
.cb4c	ab4c	ad af 09	lda $09af			lda 	gxSpriteOffset+1
.cb4f	ab4f	6d 13 09	adc $0913			adc 	gxSpriteOffsetBase
.cb52	ab52	c8		iny				iny
.cb53	ab53	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.cb55	ab55	ad 14 09	lda $0914			lda 	gxSpriteOffsetBase+1
.cb58	ab58	69 00		adc #$00			adc 	#0
.cb5a	ab5a	c8		iny				iny
.cb5b	ab5b	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.cb5d	ab5d	ad ac 09	lda $09ac			lda 	gxSizeBits 					; get raw size
.cb60	ab60	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.cb62	ab62	2a		rol a				rol 	a 							; x 2
.cb63	ab63	0a		asl a				asl 	a 							; x 4
.cb64	ab64	0a		asl a				asl 	a 							; x 8
.cb65	ab65	0a		asl a				asl 	a 							; x 16
.cb66	ab66	0d ad 09	ora $09ad			ora 	gxSpriteLUT 				; Or with LUT
.cb69	ab69	0a		asl a				asl 	a 							; 1 shift
.cb6a	ab6a	09 01		ora #$01			ora 	#1 							; enable sprite.
.cb6c	ab6c	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.cb6e	ab6e	20 ca ac	jsr $acca			jsr 	GXCloseBitmap
.cb71	ab71	ae 10 09	ldx $0910			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.cb74	ab74	bd 55 09	lda $0955,x			lda 	gxSpriteHigh,x 				; clear upper two bits of size
.cb77	ab77	29 3f		and #$3f			and 	#$3F
.cb79	ab79	9d 55 09	sta $0955,x			sta 	gxSpriteHigh,x
.cb7c	ab7c	ad ac 09	lda $09ac			lda 	gxSizeBits 					; get bit size
.cb7f	ab7f	6a		ror a				ror 	a 							; shift into bits 6/7
.cb80	ab80	6a		ror a				ror 	a
.cb81	ab81	6a		ror a				ror 	a
.cb82	ab82	29 c0		and #$c0			and 	#$C0
.cb84	ab84	1d 55 09	ora $0955,x			ora 	gxSpriteHigh,x 				; put in  upper 2 bits of sprite data
.cb87	ab87	9d 55 09	sta $0955,x			sta 	gxSpriteHigh,x
.cb8a	ab8a	bd 15 09	lda $0915,x			lda 	gxSpriteLow,x 				; clear hidden flag.
.cb8d	ab8d	29 7f		and #$7f			and 	#$7F
.cb8f	ab8f	9d 15 09	sta $0915,x			sta 	gxSpriteLow,x
.cb92	ab92	18		clc				clc
.cb93	ab93	60		rts				rts
.cb94	ab94					_GXSICloseFail:
.cb94	ab94	20 ca ac	jsr $acca			jsr 	GXCloseBitmap
.cb97	ab97					_GXSIFail:
.cb97	ab97	38		sec				sec
.cb98	ab98	60		rts				rts
.cb99	ab99					_GXSIHide:
.cb99	ab99	ad 11 09	lda $0911			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.cb9c	ab9c	85 36		sta $36				sta 	gxzTemp0
.cb9e	ab9e	ad 12 09	lda $0912			lda 	GSCurrentSpriteAddr+1
.cba1	aba1	85 37		sta $37				sta 	gxzTemp0+1
.cba3	aba3	a9 00		lda #$00			lda 	#0
.cba5	aba5	92 36		sta ($36)			sta 	(gxzTemp0)
.cba7	aba7	ae 10 09	ldx $0910			ldx 	GSCurrentSpriteID 			; get sprite ID
.cbaa	abaa	bd 15 09	lda $0915,x			lda 	gxSpriteLow,x 				; set the hidden bit.
.cbad	abad	09 80		ora #$80			ora 	#$80
.cbaf	abaf	9d 15 09	sta $0915,x			sta 	gxSpriteLow,x
.cbb2	abb2	18		clc				clc
.cbb3	abb3	60		rts				rts
.cbb4	abb4					GXMoveSprite:
.cbb4	abb4	ad 00 09	lda $0900			lda 	gxSpritesOn
.cbb7	abb7	f0 65		beq $ac1e			beq 	_GXSIFail
.cbb9	abb9	ad 12 09	lda $0912			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.cbbc	abbc	f0 60		beq $ac1e			beq 	_GXSIFail
.cbbe	abbe	85 37		sta $37				sta 	gxzTemp0+1
.cbc0	abc0	a0 04		ldy #$04			ldy 	#4
.cbc2	abc2	ad 11 09	lda $0911			lda 	GSCurrentSpriteAddr
.cbc5	abc5	85 36		sta $36				sta 	gxzTemp0
.cbc7	abc7	ae 10 09	ldx $0910			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.cbca	abca	bd 55 09	lda $0955,x			lda 	gxSpriteHigh,x
.cbcd	abcd	2a		rol a				rol 	a	 						; into bits 0,1.
.cbce	abce	2a		rol a				rol 	a
.cbcf	abcf	2a		rol a				rol 	a
.cbd0	abd0	29 03		and #$03			and 	#3
.cbd2	abd2	aa		tax				tax
.cbd3	abd3	bd 20 ac	lda $ac20,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.cbd6	abd6	48		pha				pha
.cbd7	abd7	18		clc				clc
.cbd8	abd8	6d f8 08	adc $08f8			adc 	gxX0						; copy position.
.cbdb	abdb	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cbdd	abdd	c8		iny				iny
.cbde	abde	ad f9 08	lda $08f9			lda 	gxX0+1
.cbe1	abe1	69 00		adc #$00			adc 	#0
.cbe3	abe3	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cbe5	abe5	c8		iny				iny
.cbe6	abe6	68		pla				pla
.cbe7	abe7	18		clc				clc
.cbe8	abe8	6d fa 08	adc $08fa			adc 	gxY0
.cbeb	abeb	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cbed	abed	a9 00		lda #$00			lda 	#0
.cbef	abef	69 00		adc #$00			adc 	#0
.cbf1	abf1	c8		iny				iny
.cbf2	abf2	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cbf4	abf4	4e f9 08	lsr $08f9			lsr 	gxX0+1 						; divide X by 4
.cbf7	abf7	6e f8 08	ror $08f8			ror 	gxX0
.cbfa	abfa	4e f8 08	lsr $08f8			lsr 	gxX0
.cbfd	abfd	4e fa 08	lsr $08fa			lsr 	gxY0 						; divide Y by 4
.cc00	ac00	4e fa 08	lsr $08fa			lsr 	gxY0
.cc03	ac03	ae 10 09	ldx $0910			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.cc06	ac06	bd 15 09	lda $0915,x			lda 	gxSpriteLow,x
.cc09	ac09	29 80		and #$80			and 	#$80
.cc0b	ac0b	0d f8 08	ora $08f8			ora 	gxX0
.cc0e	ac0e	9d 15 09	sta $0915,x			sta 	gxSpriteLow,x
.cc11	ac11	bd 55 09	lda $0955,x			lda 	gxSpriteHigh,x
.cc14	ac14	29 c0		and #$c0			and 	#$C0
.cc16	ac16	0d fa 08	ora $08fa			ora 	gxY0
.cc19	ac19	9d 55 09	sta $0955,x			sta 	gxSpriteHigh,x
.cc1c	ac1c	18		clc				clc
.cc1d	ac1d	60		rts				rts
.cc1e	ac1e					_GXSIFail:
.cc1e	ac1e	38		sec				sec
.cc1f	ac1f	60		rts				rts
.cc20	ac20					_GXMSOffset:
>cc20	ac20	1c						.byte 	32-8/2
>cc21	ac21	18						.byte 	32-16/2
>cc22	ac22	14						.byte 	32-24/2
>cc23	ac23	10						.byte 	32-32/2
.cc24	ac24					GXSelectTile:
.cc24	ac24	ad 02 09	lda $0902			lda 	gxTilesOn 					; check tilemap in use
.cc27	ac27	f0 4b		beq $ac74			beq 	_GXSFail
.cc29	ac29	a5 36		lda $36				lda 	gxzTemp0 					; check X and Y in range
.cc2b	ac2b	cd 07 09	cmp $0907			cmp 	gxTileMapWidth
.cc2e	ac2e	b0 44		bcs $ac74			bcs 	_GXSFail
.cc30	ac30	a5 37		lda $37				lda 	gxzTemp0+1
.cc32	ac32	cd 08 09	cmp $0908			cmp 	gxTileMapHeight
.cc35	ac35	b0 3d		bcs $ac74			bcs 	_GXSFail
.cc37	ac37	ad 06 09	lda $0906			lda 	gxTileMapPage 				; page to access = tile access page.
.cc3a	ac3a	8d 95 09	sta $0995			sta 	gxTileAccessPage
.cc3d	ac3d	ae 07 09	ldx $0907			ldx 	gxTileMapWidth 				; YX is the additive, e.g. shifted left. gxzTemp0+1 is shifted right.
.cc40	ac40	a0 00		ldy #$00			ldy 	#0
.cc42	ac42	a5 36		lda $36				lda 	gxzTemp0 					; initial result is X
.cc44	ac44	8d 96 09	sta $0996			sta 	gxTileAccessAddress
.cc47	ac47	9c 97 09	stz $0997			stz  	gxTileAccessAddress+1
.cc4a	ac4a					_GXSTMultiply:
.cc4a	ac4a	46 37		lsr $37				lsr 	gxzTemp0+1 					; shift Y right
.cc4c	ac4c	90 0f		bcc $ac5d			bcc 	_GXSTNoAdd 					; add if CS
.cc4e	ac4e	18		clc				clc 								; add YX to result
.cc4f	ac4f	8a		txa				txa
.cc50	ac50	6d 96 09	adc $0996			adc 	gxTileAccessAddress
.cc53	ac53	8d 96 09	sta $0996			sta 	gxTileAccessAddress
.cc56	ac56	98		tya				tya
.cc57	ac57	6d 97 09	adc $0997			adc 	gxTileAccessAddress+1
.cc5a	ac5a	8d 97 09	sta $0997			sta 	gxTileAccessAddress+1
.cc5d	ac5d					_GXSTNoAdd:
.cc5d	ac5d	8a		txa				txa 								; shift YX left
.cc5e	ac5e	0a		asl a				asl 	a
.cc5f	ac5f	aa		tax				tax
.cc60	ac60	98		tya				tya
.cc61	ac61	2a		rol a				rol 	a
.cc62	ac62	a8		tay				tay
.cc63	ac63	a5 37		lda $37				lda 	gxzTemp0+1 					; multiply complete
.cc65	ac65	d0 e3		bne $ac4a			bne 	_GXSTMultiply
.cc67	ac67	0e 96 09	asl $0996			asl 	gxTileAccessAddress 		; double it, as it is a word array.
.cc6a	ac6a	2e 97 09	rol $0997			rol 	gxTileAccessAddress+1
.cc6d	ac6d					_GXSTFixAddressLoop:
.cc6d	ac6d	20 76 ac	jsr $ac76			jsr 	GXSTFixAddress
.cc70	ac70	b0 fb		bcs $ac6d			bcs 	_GXSTFixAddressLoop
.cc72	ac72	18		clc				clc
.cc73	ac73	60		rts				rts
.cc74	ac74					_GXSFail:
.cc74	ac74	38		sec				sec
.cc75	ac75	60		rts				rts
.cc76	ac76					GXSTFixAddress:
.cc76	ac76	48		pha				pha
.cc77	ac77	ad 97 09	lda $0997			lda 	gxTileAccessAddress+1 		; in legal page range e.g. $0000-$1FFF
.cc7a	ac7a	c9 20		cmp #$20			cmp 	#$20
.cc7c	ac7c	90 06		bcc $ac84			bcc 	_GXSTFAExit
.cc7e	ac7e	e9 20		sbc #$20			sbc 	#$20 						; adjust address
.cc80	ac80	ee 95 09	inc $0995			inc 	gxTileAccessPage 			; adjust page up.
.cc83	ac83	38		sec				sec
.cc84	ac84					_GXSTFAExit:
.cc84	ac84	68		pla				pla
.cc85	ac85	60		rts				rts
.cc86	ac86					GXSTWriteTile:
.cc86	ac86	38		sec				sec 								; CS = update flag
.cc87	ac87	80 01		bra $ac8a			bra 	GXSTTileAccess
.cc89	ac89					GXSTReadTile:
.cc89	ac89	18		clc				clc
.cc8a	ac8a					GXSTTileAccess:
.cc8a	ac8a	a5 0b		lda $0b				lda 	GXEditSlot 					; save oroginal page
.cc8c	ac8c	48		pha				pha
.cc8d	ac8d	08		php				php 								; save update flag
.cc8e	ac8e	ad 95 09	lda $0995			lda 	gxTileAccessPage 			; access the tile page.
.cc91	ac91	85 0b		sta $0b				sta 	GXEditSlot
.cc93	ac93	a6 36		ldx $36				ldx 	gxzTemp0 					; X = New value
.cc95	ac95	ad 96 09	lda $0996			lda 	gxTileAccessAddress 		; set gxzTemp0 to point there
.cc98	ac98	85 36		sta $36				sta 	gxzTemp0
.cc9a	ac9a	ad 97 09	lda $0997			lda 	gxTileAccessAddress+1
.cc9d	ac9d	09 60		ora #$60			ora 	#(GXMappingAddress >> 8)
.cc9f	ac9f	85 37		sta $37				sta 	gxzTemp0+1
.cca1	aca1	28		plp				plp 								; get flag
.cca2	aca2	90 09		bcc $acad			bcc 	_GXSNoUpdate 				; updating the tile map ?
.cca4	aca4	8a		txa				txa 								; new value
.cca5	aca5	92 36		sta ($36)			sta 	(gxzTemp0) 					; write it out, as a word.
.cca7	aca7	a0 01		ldy #$01			ldy 	#1
.cca9	aca9	a9 00		lda #$00			lda 	#0
.ccab	acab	91 36		sta ($36),y			sta 	(gxzTemp0),y
.ccad	acad					_GXSNoUpdate:
.ccad	acad	b2 36		lda ($36)			lda 	(gxzTemp0) 					; read the value
.ccaf	acaf	fa		plx				plx 								; restore old page
.ccb0	acb0	86 0b		stx $0b				stx 	GXEditSlot
.ccb2	acb2	ee 96 09	inc $0996			inc 	gxTileAccessAddress 		; advance tile ptr by 2 - will always be even.
.ccb5	acb5	ee 96 09	inc $0996			inc 	gxTileAccessAddress
.ccb8	acb8	d0 03		bne $acbd			bne 	_GXSNoCarry
.ccba	acba	ee 97 09	inc $0997			inc 	gxTileAccessAddress+1
.ccbd	acbd					_GXSNoCarry:
.ccbd	acbd	20 76 ac	jsr $ac76			jsr 	GXSTFixAddress 				; fix address if required.
.ccc0	acc0	18		clc				clc 								; return with ok flag.
.ccc1	acc1	60		rts				rts
.ccc2	acc2					GXOpenBitmap:
.ccc2	acc2	78		sei				sei 								; no interrupts here
.ccc3	acc3	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.ccc5	acc5	8d 0e 09	sta $090e			sta 	gxOriginalLUTValue
.ccc8	acc8	58		cli				cli
.ccc9	acc9	60		rts				rts
.ccca	acca					GXCloseBitmap:
.ccca	acca	78		sei				sei
.cccb	accb	ad 0e 09	lda $090e			lda 	gxOriginalLUTValue 			; restore LUT slot value
.ccce	acce	85 0b		sta $0b				sta 	GXEditSlot
.ccd0	acd0	58		cli				cli
.ccd1	acd1	60		rts				rts
.ccd2	acd2					gxPositionCalc:
.ccd2	acd2	a5 36		lda $36				lda 	gxzTemp0 						; save temp memory slot
.ccd4	acd4	48		pha				pha
.ccd5	acd5	ad fa 08	lda $08fa			lda 	gxY0 							; gxzScreen = Y0
.ccd8	acd8	85 3c		sta $3c				sta 	gxzScreen
.ccda	acda	64 3d		stz $3d				stz 	gxzScreen+1
.ccdc	acdc	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.ccde	acde	26 3d		rol $3d				rol 	gxzScreen+1
.cce0	ace0	06 3c		asl $3c				asl 	gxzScreen
.cce2	ace2	26 3d		rol $3d				rol 	gxzScreen+1
.cce4	ace4	18		clc				clc 									; gxzScreen = Y0 * 5, as it's still in A
.cce5	ace5	65 3c		adc $3c				adc 	gxzScreen
.cce7	ace7	85 3c		sta $3c				sta 	gxzScreen
.cce9	ace9	90 02		bcc $aced			bcc 	_GXPCNoCarry
.cceb	aceb	e6 3d		inc $3d				inc 	gxzScreen+1
.cced	aced					_GXPCNoCarry:
.cced	aced	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10
.ccef	acef	26 3d		rol $3d				rol 	gxzScreen+1
.ccf1	acf1	a5 3d		lda $3d				lda	 	gxzScreen+1
.ccf3	acf3	85 36		sta $36				sta 	gxzTemp0 						; the page offset.
.ccf5	acf5	64 3d		stz $3d				stz 	gxzScreen+1
.ccf7	acf7	a9 05		lda #$05			lda 	#5 								; now multiply by 32, this puts this in the range 0..8191
.ccf9	acf9					_GXPCMultiply32:
.ccf9	acf9	06 3c		asl $3c				asl 	gxzScreen
.ccfb	acfb	26 3d		rol $3d				rol 	gxzScreen+1
.ccfd	acfd	3a		dec a				dec 	a
.ccfe	acfe	d0 f9		bne $acf9			bne 	_GXPCMultiply32
.cd00	ad00	18		clc				clc
.cd01	ad01	ad f8 08	lda $08f8			lda 	gxX0 						; add X to this value, put the result in gxOffset, gxzScreen has to be on a page boundary
.cd04	ad04	65 3c		adc $3c				adc 	gxzScreen
.cd06	ad06	8d 0f 09	sta $090f			sta 	gxOffset
.cd09	ad09	ad f9 08	lda $08f9			lda 	gxX0+1
.cd0c	ad0c	65 3d		adc $3d				adc 	gxzScreen+1
.cd0e	ad0e	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.cd10	ad10	90 04		bcc $ad16			bcc 	_GXPCNoOverflow
.cd12	ad12	29 1f		and #$1f			and 	#$1F 						; fix it up
.cd14	ad14	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.cd16	ad16					_GXPCNoOverflow:
.cd16	ad16	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.cd18	ad18	85 3d		sta $3d				sta 	gxzScreen+1
.cd1a	ad1a	64 3c		stz $3c				stz 	gxzScreen
.cd1c	ad1c	18		clc				clc
.cd1d	ad1d	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.cd1f	ad1f	6d 03 09	adc $0903			adc 	gxBasePage 					; by adding the base page
.cd22	ad22	85 0b		sta $0b				sta 	GXEditSlot 					; and map it into memory.
.cd24	ad24	68		pla				pla
.cd25	ad25	85 36		sta $36				sta 	gxzTemp0
.cd27	ad27	60		rts				rts
.cd28	ad28					GXMovePositionDown:
.cd28	ad28	18		clc				clc 								; add 320 to offset/temp+1
.cd29	ad29	ad 0f 09	lda $090f			lda 	gxOffset
.cd2c	ad2c	69 40		adc #$40			adc 	#64
.cd2e	ad2e	8d 0f 09	sta $090f			sta 	gxOffset
.cd31	ad31	a5 3d		lda $3d				lda 	gxzScreen+1
.cd33	ad33	69 01		adc #$01			adc 	#1
.cd35	ad35	85 3d		sta $3d				sta 	gxzScreen+1
.cd37	ad37	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.cd39	ad39	90 07		bcc $ad42			bcc 	_GXMPDExit
.cd3b	ad3b	38		sec				sec  								; next page, adjust address
.cd3c	ad3c	e9 20		sbc #$20			sbc 	#$20
.cd3e	ad3e	85 3d		sta $3d				sta 	gxzScreen+1
.cd40	ad40	e6 0b		inc $0b				inc 	GXEditSlot 					; bump page
.cd42	ad42					_GXMPDExit:
.cd42	ad42	60		rts				rts
.cd43	ad43					GXCollide:
.cd43	ad43	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.cd45	ad45	aa		tax				tax
.cd46	ad46	05 37		ora $37				ora 	gxzTemp0+1
.cd48	ad48	29 c0		and #$c0			and 	#$C0
.cd4a	ad4a	38		sec				sec
.cd4b	ad4b	d0 53		bne $ada0			bne 	_GXCollideFail 				; if either >= 64, fail.
.cd4d	ad4d	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.cd4f	ad4f	b9 15 09	lda $0915,y			lda 	gxSpriteLow,y 				; check if either hidden bit is set
.cd52	ad52	1d 15 09	ora $0915,x			ora 	gxSpriteLow,x
.cd55	ad55	30 48		bmi $ad9f			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.cd57	ad57	18		clc				clc 								; need to calculate sum of sizes.
.cd58	ad58	b9 55 09	lda $0955,y			lda 	gxSpriteHigh,y
.cd5b	ad5b	7d 55 09	adc $0955,x			adc 	gxSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.cd5e	ad5e	29 c0		and #$c0			and 	#$C0 					 	; mask off
.cd60	ad60	6a		ror a				ror 	a 							; 5/6/7
.cd61	ad61	4a		lsr a				lsr 	a 							; 4/5/6
.cd62	ad62	4a		lsr a				lsr 	a 							; 3/4/5
.cd63	ad63	4a		lsr a				lsr 	a 							; 2/3/4
.cd64	ad64	18		clc				clc
.cd65	ad65	69 08		adc #$08			adc 	#$08
.cd67	ad67	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.cd68	ad68	4a		lsr a				lsr 	a
.cd69	ad69	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.cd6b	ad6b	b9 55 09	lda $0955,y			lda 	gxSpriteHigh,y 				; calculate y1-y0
.cd6e	ad6e	29 3f		and #$3f			and 	#$3F
.cd70	ad70	85 39		sta $39				sta 	gxzTemp1+1
.cd72	ad72	38		sec				sec
.cd73	ad73	bd 55 09	lda $0955,x			lda 	gxSpriteHigh,x
.cd76	ad76	29 3f		and #$3f			and 	#$3F
.cd78	ad78	e5 39		sbc $39				sbc 	gxzTemp1+1
.cd7a	ad7a	b0 03		bcs $ad7f			bcs 	_GXCAbs1 					; calculate |y1-y0|
.cd7c	ad7c	49 ff		eor #$ff			eor 	#$FF
.cd7e	ad7e	1a		inc a				inc 	a
.cd7f	ad7f					_GXCAbs1:
.cd7f	ad7f	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cd81	ad81	b0 1c		bcs $ad9f			bcs 	_GXOkayFail
.cd83	ad83	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.cd85	ad85	38		sec				sec 								; calculate |x1-x0|
.cd86	ad86	b9 15 09	lda $0915,y			lda 	gxSpriteLow,y
.cd89	ad89	fd 15 09	sbc $0915,x			sbc 	gxSpriteLow,x
.cd8c	ad8c	b0 03		bcs $ad91			bcs 	_GXCAbs2
.cd8e	ad8e	49 ff		eor #$ff			eor 	#$FF
.cd90	ad90	1a		inc a				inc 	a
.cd91	ad91					_GXCAbs2:
.cd91	ad91	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cd93	ad93	b0 0a		bcs $ad9f			bcs 	_GXOkayFail
.cd95	ad95	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.cd97	ad97	90 02		bcc $ad9b			bcc 	_GXCHaveLowest
.cd99	ad99	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.cd9b	ad9b					_GXCHaveLowest:
.cd9b	ad9b	0a		asl a				asl 	a 							; scale to allow for >> 2
.cd9c	ad9c	0a		asl a				asl 	a
.cd9d	ad9d	18		clc				clc
.cd9e	ad9e	60		rts				rts
.cd9f	ad9f					_GXOkayFail:
.cd9f	ad9f	18		clc				clc
.cda0	ada0					_GXCollideFail:
.cda0	ada0	a9 ff		lda #$ff			lda 	#$FF
.cda2	ada2	60		rts				rts
.cda3	ada3					GXFindSprite:
.cda3	ada3	aa		tax				tax  								; sprite index in X
.cda4	ada4	9c ae 09	stz $09ae			stz 	gxSpriteOffset 				; sprite offset is the offset in the sprite list.
.cda7	ada7	9c af 09	stz $09af			stz 	gxSpriteOffset+1
.cdaa	adaa	64 38		stz $38				stz 	gxzTemp1 					; zTemp1 is the address in memory, given the current selected page.
.cdac	adac	a9 60		lda #$60			lda 	#GXMappingAddress >> 8
.cdae	adae	85 39		sta $39				sta 	gxzTemp1+1
.cdb0	adb0	ad 04 09	lda $0904			lda 	gxSpritePage 				; and point to the sprite page.
.cdb3	adb3	85 0b		sta $0b				sta 	GXEditSlot
.cdb5	adb5	b2 38		lda ($38)			lda 	(gxzTemp1) 					; get the first sprite record header, identifying the format.
.cdb7	adb7	c9 11		cmp #$11			cmp 	#$11						; should be $11
.cdb9	adb9	d0 6c		bne $ae27			bne 	_GXFSFail 					; if not, fail
.cdbb	adbb	20 0d ae	jsr $ae0d			jsr 	_GXFSIncrement 				; increment pointers.
.cdbe	adbe					_GXFindLoop:
.cdbe	adbe	b2 38		lda ($38)			lda 	(gxzTemp1) 					; reached the end, if so then failed.
.cdc0	adc0	c9 80		cmp #$80			cmp 	#$80
.cdc2	adc2	f0 63		beq $ae27			beq 	_GXFSFail
.cdc4	adc4	e0 00		cpx #$00			cpx 	#0 							; if zero, then found.
.cdc6	adc6	f0 2c		beq $adf4			beq 	_GXFSFound
.cdc8	adc8	ca		dex				dex 								; decrement count.
.cdc9	adc9	0a		asl a				asl 	a 							; index into table
.cdca	adca	a8		tay				tay 								; so we can look it up.
.cdcb	adcb	18		clc				clc 								; add LSB
.cdcc	adcc	ad ae 09	lda $09ae			lda 	gxSpriteOffset
.cdcf	adcf	79 29 ae	adc $ae29,y			adc 	_GXFSSizeTable,y
.cdd2	add2	8d ae 09	sta $09ae			sta 	gxSpriteOffset 				; these two should move in lock step.
.cdd5	add5	85 38		sta $38				sta 	gxzTemp1
.cdd7	add7	90 05		bcc $adde			bcc 	_GXNextNoCarry 				; adjust for carry as we add the MSB seperately.
.cdd9	add9	ee af 09	inc $09af			inc 	gxSpriteOffset+1
.cddc	addc	e6 39		inc $39				inc 	gxzTemp1+1
.cdde	adde					_GXNextNoCarry:
.cdde	adde	18		clc				clc
.cddf	addf	a5 39		lda $39				lda 	gxzTemp1+1 					; add MSB
.cde1	ade1	79 2a ae	adc $ae2a,y			adc 	_GXFSSizeTable+1,y
.cde4	ade4	85 39		sta $39				sta 	gxzTemp1+1
.cde6	ade6	ad af 09	lda $09af			lda 	gxSpriteOffset+1
.cde9	ade9	79 2a ae	adc $ae2a,y			adc 	_GXFSSizeTable+1,y
.cdec	adec	8d af 09	sta $09af			sta 	gxSpriteOffset+1
.cdef	adef	20 19 ae	jsr $ae19			jsr 	_GXFSNormalise 				; and normalise the page address.
.cdf2	adf2	80 ca		bra $adbe			bra 	_GXFindLoop 				; and go round again.
.cdf4	adf4					_GXFSFound:
.cdf4	adf4	b2 38		lda ($38)			lda 	(gxzTemp1)					; get the bit size (e.g. 0-3)
.cdf6	adf6	8d ac 09	sta $09ac			sta 	gxSizeBits
.cdf9	adf9	1a		inc a				inc 	a 							; 1,2,3,4 - calculating pixel size
.cdfa	adfa	0a		asl a				asl 	a 							; 2,4,6,8
.cdfb	adfb	0a		asl a				asl 	a 							; 4,8,12,16
.cdfc	adfc	0a		asl a				asl 	a 							; 8,16,24,32
.cdfd	adfd	8d ab 09	sta $09ab			sta 	gxSizePixels
.ce00	ae00	20 0d ae	jsr $ae0d			jsr 	_GXFSIncrement 				; and to the LUT
.ce03	ae03	b2 38		lda ($38)			lda 	(gxzTemp1) 					; copy that out.
.ce05	ae05	8d ad 09	sta $09ad			sta 	gxSpriteLUT
.ce08	ae08	20 0d ae	jsr $ae0d			jsr 	_GXFSIncrement 				; and it now points to the first graphic data byte
.ce0b	ae0b	18		clc				clc
.ce0c	ae0c	60		rts				rts
.ce0d	ae0d					_GXFSIncrement:
.ce0d	ae0d	ee ae 09	inc $09ae			inc 	gxSpriteOffset 				; these two should move in sync
.ce10	ae10	e6 38		inc $38				inc 	gxzTemp1
.ce12	ae12	d0 05		bne $ae19			bne 	_GXFSNormalise
.ce14	ae14	ee af 09	inc $09af			inc 	gxSpriteOffset+1
.ce17	ae17	e6 39		inc $39				inc 	gxzTemp1+1
.ce19	ae19					_GXFSNormalise:
.ce19	ae19	a5 39		lda $39				lda 	gxzTemp1+1 					; are we out of range.
.ce1b	ae1b	c9 80		cmp #$80			cmp 	#(GXMappingAddress >> 8)+$20
.ce1d	ae1d	90 07		bcc $ae26			bcc 	_GXFSOkay
.ce1f	ae1f	e6 0b		inc $0b				inc 	GXEditSlot 					; next 8k page
.ce21	ae21	38		sec				sec 								; adjust page address back
.ce22	ae22	e9 20		sbc #$20			sbc 	#$20
.ce24	ae24	85 39		sta $39				sta 	gxzTemp1+1
.ce26	ae26					_GXFSOkay:
.ce26	ae26	60		rts				rts
.ce27	ae27					_GXFSFail:
.ce27	ae27	38		sec				sec
.ce28	ae28	60		rts				rts
.ce29	ae29					_GXFSSizeTable:
>ce29	ae29	42 00 02 01 42 02 02 04				.word 	8*8+2,16*16+2,24*24+2,32*32+2
.09ab						gxSizePixels:
>09ab								.fill 	1
.09ac						gxSizeBits:
>09ac								.fill 	1
.09ad						gxSpriteLUT:
>09ad								.fill 	1
.09ae						gxSpriteOffset:
>09ae								.fill 	2
.ce31	ae31					GXSortXY:
.ce31	ae31	20 4f ae	jsr $ae4f			jsr 	GXSortY 					; will be sorted on Y now
.ce34	ae34	ad f8 08	lda $08f8			lda 	gxX0 						; compare X0 v X1
.ce37	ae37	cd fc 08	cmp $08fc			cmp 	gxX1
.ce3a	ae3a	ad f9 08	lda $08f9			lda 	gxX0+1
.ce3d	ae3d	ed fd 08	sbc $08fd			sbc 	gxX1+1
.ce40	ae40	90 0c		bcc $ae4e			bcc 	_GXSXYExit 					; X0 < X1 exit
.ce42	ae42	a2 00		ldx #$00			ldx 	#0 							; swap them over
.ce44	ae44	a0 04		ldy #$04			ldy 	#4
.ce46	ae46	20 63 ae	jsr $ae63			jsr 	GXSwapXY
.ce49	ae49	e8		inx				inx
.ce4a	ae4a	c8		iny				iny
.ce4b	ae4b	20 63 ae	jsr $ae63			jsr 	GXSwapXY
.ce4e	ae4e					_GXSXYExit:
.ce4e	ae4e	60		rts				rts
.ce4f	ae4f					GXSortY:
.ce4f	ae4f	ad fa 08	lda $08fa			lda 	gxY0 						; if Y0 >= Y1
.ce52	ae52	cd fe 08	cmp $08fe			cmp 	gxY1
.ce55	ae55	90 0b		bcc $ae62			bcc 	_GXSYSorted
.ce57	ae57	a2 03		ldx #$03			ldx 	#3 							; swap 3-0 - for lines we want to sort but keep lines together
.ce59	ae59	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.ce5b	ae5b					_GXSwap1:
.ce5b	ae5b	20 63 ae	jsr $ae63			jsr 	GXSwapXY
.ce5e	ae5e	88		dey				dey
.ce5f	ae5f	ca		dex				dex
.ce60	ae60	10 f9		bpl $ae5b			bpl 	_GXSwap1
.ce62	ae62					_GXSYSorted:
.ce62	ae62	60		rts				rts
.ce63	ae63					GXSwapXY:
.ce63	ae63	bd f8 08	lda $08f8,x			lda 	gxX0,x
.ce66	ae66	48		pha				pha
.ce67	ae67	b9 f8 08	lda $08f8,y			lda 	gxX0,y
.ce6a	ae6a	9d f8 08	sta $08f8,x			sta 	gxX0,x
.ce6d	ae6d	68		pla				pla
.ce6e	ae6e	99 f8 08	sta $08f8,y			sta 	gxX0,y
.ce71	ae71	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/.build/tokeniser.module.asm

=1						tokeniserIntegrated=1
.ce72	ae72					KeywordSet0:
>ce72	ae72	00 65					.text	0,$65,""               ; $80 !0:EOF
>ce74	ae74	00 58					.text	0,$58,""               ; $81 !1:SH1
>ce76	ae76	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ce78	ae78	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>ce7e	ae7e	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>ce86	ae86	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>ce8c	ae8c	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>ce93	ae93	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>ce9b	ae9b	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>cea2	aea2	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>cea9	aea9	05 2c 47 45 54 24 28			.text	5,$2c,"GET$("          ; $8a GET$(
>ceb0	aeb0	04 08 47 45 54 28			.text	4,$08,"GET("           ; $8b GET(
>ceb6	aeb6	09 4a 47 45 54 44 41 54			.text	9,$4a,"GETDATE$("      ; $8c GETDATE$(
>cebe	aebe	45 24 28
>cec1	aec1	09 5b 47 45 54 54 49 4d			.text	9,$5b,"GETTIME$("      ; $8d GETTIME$(
>cec9	aec9	45 24 28
>cecc	aecc	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8e HIT(
>ced2	aed2	07 cc 49 4e 4b 45 59 24			.text	7,$cc,"INKEY$("        ; $8f INKEY$(
>ceda	aeda	28
>cedb	aedb	06 a8 49 4e 4b 45 59 28			.text	6,$a8,"INKEY("         ; $90 INKEY(
>cee3	aee3	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $91 INT(
>cee9	aee9	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $92 ISVAL(
>cef1	aef1	0a e0 49 54 45 4d 43 4f			.text	10,$e0,"ITEMCOUNT("     ; $93 ITEMCOUNT(
>cef9	aef9	55 4e 54 28
>cefd	aefd	09 5b 49 54 45 4d 47 45			.text	9,$5b,"ITEMGET$("      ; $94 ITEMGET$(
>cf05	af05	54 24 28
>cf08	af08	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $95 JOYB(
>cf0f	af0f	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $96 JOYX(
>cf16	af16	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $97 JOYY(
>cf1d	af1d	08 49 4b 45 59 44 4f 57			.text	8,$49,"KEYDOWN("       ; $98 KEYDOWN(
>cf25	af25	4e 28
>cf27	af27	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $99 LEFT$(
>cf2f	af2f	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $9a LEN(
>cf35	af35	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $9b MAX(
>cf3b	af3b	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $9c MID$(
>cf42	af42	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $9d MIN(
>cf48	af48	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $9e NOT(
>cf4e	af4e	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $9f PEEK(
>cf55	af55	06 91 50 45 45 4b 44 28			.text	6,$91,"PEEKD("         ; $a0 PEEKD(
>cf5d	af5d	06 99 50 45 45 4b 4c 28			.text	6,$99,"PEEKL("         ; $a1 PEEKL(
>cf65	af65	06 a4 50 45 45 4b 57 28			.text	6,$a4,"PEEKW("         ; $a2 PEEKW(
>cf6d	af6d	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $a3 PLAYING(
>cf75	af75	47 28
>cf77	af77	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $a4 RANDOM(
>cf7f	af7f	28
>cf80	af80	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $a5 RIGHT$(
>cf88	af88	28
>cf89	af89	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $a6 RND(
>cf8f	af8f	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $a7 SGN(
>cf95	af95	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $a8 SPC(
>cf9b	af9b	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $a9 STR$(
>cfa2	afa2	05 56 54 49 4c 45 28			.text	5,$56,"TILE("          ; $aa TILE(
>cfa9	afa9	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $ab TIMER(
>cfb1	afb1	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $ac TRUE
>cfb7	afb7	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $ad VAL(
>cfbd	afbd	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $ae FOR
>cfc2	afc2	02 8f 49 46				.text	2,$8f,"IF"             ; $af IF
>cfc6	afc6	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $b0 PROC
>cfcc	afcc	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $b1 REPEAT
>cfd4	afd4	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $b2 WHILE
>cfdb	afdb	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $b3 ENDIF
>cfe2	afe2	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $b4 ENDPROC
>cfea	afea	43
>cfeb	afeb	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $b5 NEXT
>cff1	aff1	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $b6 THEN
>cff7	aff7	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $b7 UNTIL
>cffe	affe	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $b8 WEND
>d004	b004	02 95 41 54				.text	2,$95,"AT"             ; $b9 AT
>d008	b008	02 9b 42 59				.text	2,$9b,"BY"             ; $ba BY
>d00c	b00c	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $bb CALL
>d012	b012	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $bc CIRCLE
>d01a	b01a	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $bd CLEAR
>d021	b021	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $be COLOR
>d028	b028	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $bf COLOUR
>d030	b030	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $c0 DATA
>d036	b036	03 da 44 49 4d				.text	3,$da,"DIM"            ; $c1 DIM
>d03b	b03b	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $c2 DOWNTO
>d043	b043	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $c3 ELSE
>d049	b049	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $c4 FROM
>d04f	b04f	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $c5 GFX
>d054	b054	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $c6 HERE
>d05a	b05a	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $c7 IMAGE
>d061	b061	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c8 LET
>d066	b066	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c9 LINE
>d06c	b06c	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $ca LOCAL
>d073	b073	07 1a 4d 45 4d 43 4f 50			.text	7,$1a,"MEMCOPY"        ; $cb MEMCOPY
>d07b	b07b	59
>d07c	b07c	03 db 4f 46 46				.text	3,$db,"OFF"            ; $cc OFF
>d081	b081	02 9d 4f 4e				.text	2,$9d,"ON"             ; $cd ON
>d085	b085	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $ce OUTLINE
>d08d	b08d	45
>d08e	b08e	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $cf PALETTE
>d096	b096	45
>d097	b097	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $d0 PLOT
>d09d	b09d	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $d1 POKE
>d0a3	b0a3	05 73 50 4f 4b 45 44			.text	5,$73,"POKED"          ; $d2 POKED
>d0aa	b0aa	05 7b 50 4f 4b 45 4c			.text	5,$7b,"POKEL"          ; $d3 POKEL
>d0b1	b0b1	05 86 50 4f 4b 45 57			.text	5,$86,"POKEW"          ; $d4 POKEW
>d0b8	b0b8	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $d5 READ
>d0be	b0be	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $d6 RECT
>d0c4	b0c4	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $d7 REM
>d0c9	b0c9	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $d8 SOLID
>d0d0	b0d0	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $d9 SOUND
>d0d7	b0d7	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $da SPRITE
>d0df	b0df	04 3c 53 54 45 50			.text	4,$3c,"STEP"           ; $db STEP
>d0e5	b0e5	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $dc TEXT
>d0eb	b0eb	02 a3 54 4f				.text	2,$a3,"TO"             ; $dd TO
>d0ef	b0ef	ff					.text	$FF
.d0f0	b0f0					KeywordSet1:
>d0f0	b0f0	00 65					.text	0,$65,""               ; $80 !0:EOF
>d0f2	b0f2	00 58					.text	0,$58,""               ; $81 !1:SH1
>d0f4	b0f4	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>d0f6	b0f6	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>d0fe	b0fe	4c 45
>d100	b100	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>d108	b108	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>d110	b110	05 62 42 4c 4f 41 44			.text	5,$62,"BLOAD"          ; $86 BLOAD
>d117	b117	05 71 42 53 41 56 45			.text	5,$71,"BSAVE"          ; $87 BSAVE
>d11e	b11e	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $88 CLS
>d123	b123	06 d0 43 50 52 49 4e 54			.text	6,$d0,"CPRINT"         ; $89 CPRINT
>d12b	b12b	06 de 43 55 52 53 4f 52			.text	6,$de,"CURSOR"         ; $8a CURSOR
>d133	b133	03 df 44 49 52				.text	3,$df,"DIR"            ; $8b DIR
>d138	b138	05 7a 44 52 49 56 45			.text	5,$7a,"DRIVE"          ; $8c DRIVE
>d13f	b13f	03 d7 45 4e 44				.text	3,$d7,"END"            ; $8d END
>d144	b144	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $8e EXPLODE
>d14c	b14c	45
>d14d	b14d	02 96 47 4f				.text	2,$96,"GO"             ; $8f GO
>d151	b151	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $90 GOSUB
>d158	b158	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $91 GOTO
>d15e	b15e	05 70 48 49 4d 45 4d			.text	5,$70,"HIMEM"          ; $92 HIMEM
>d165	b165	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $93 INPUT
>d16c	b16c	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $94 LIST
>d172	b172	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $95 LOAD
>d178	b178	06 b7 4d 44 45 4c 54 41			.text	6,$b7,"MDELTA"         ; $96 MDELTA
>d180	b180	05 89 4d 4f 55 53 45			.text	5,$89,"MOUSE"          ; $97 MOUSE
>d187	b187	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $98 NEW
>d18c	b18c	06 d9 4f 50 54 49 4f 4e			.text	6,$d9,"OPTION"         ; $99 OPTION
>d194	b194	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $9a PING
>d19a	b19a	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $9b PRINT
>d1a1	b1a1	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $9c RESTORE
>d1a9	b1a9	45
>d1aa	b1aa	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $9d RETURN
>d1b2	b1b2	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $9e RUN
>d1b7	b1b7	04 2f 53 41 56 45			.text	4,$2f,"SAVE"           ; $9f SAVE
>d1bd	b1bd	07 0a 53 45 54 44 41 54			.text	7,$0a,"SETDATE"        ; $a0 SETDATE
>d1c5	b1c5	45
>d1c6	b1c6	07 1b 53 45 54 54 49 4d			.text	7,$1b,"SETTIME"        ; $a1 SETTIME
>d1ce	b1ce	45
>d1cf	b1cf	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $a2 SHOOT
>d1d6	b1d6	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $a3 SPRITES
>d1de	b1de	53
>d1df	b1df	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $a4 STOP
>d1e5	b1e5	04 2e 54 49 4c 45			.text	4,$2e,"TILE"           ; $a5 TILE
>d1eb	b1eb	05 81 54 49 4c 45 53			.text	5,$81,"TILES"          ; $a6 TILES
>d1f2	b1f2	03 ff 54 52 59				.text	3,$ff,"TRY"            ; $a7 TRY
>d1f7	b1f7	06 d5 56 45 52 49 46 59			.text	6,$d5,"VERIFY"         ; $a8 VERIFY
>d1ff	b1ff	03 ee 58 47 4f				.text	3,$ee,"XGO"            ; $a9 XGO
>d204	b204	05 78 58 4c 4f 41 44			.text	5,$78,"XLOAD"          ; $aa XLOAD
>d20b	b20b	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $ab ZAP
>d210	b210	ff					.text	$FF
.d211	b211					KeywordSet2:
>d211	b211	00 65					.text	0,$65,""               ; $80 !0:EOF
>d213	b213	00 58					.text	0,$58,""               ; $81 !1:SH1
>d215	b215	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>d217	b217	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>d21c	b21c	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>d221	b221	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>d226	b226	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>d22b	b22b	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>d230	b230	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>d235	b235	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>d23a	b23a	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>d23f	b23f	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>d244	b244	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>d249	b249	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>d24e	b24e	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>d253	b253	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>d258	b258	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>d25d	b25d	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>d262	b262	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>d267	b267	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>d26c	b26c	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>d271	b271	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>d276	b276	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>d27b	b27b	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>d280	b280	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>d285	b285	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>d28a	b28a	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>d28f	b28f	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>d294	b294	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>d299	b299	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>d29e	b29e	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>d2a3	b2a3	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>d2a8	b2a8	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>d2ad	b2ad	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>d2b2	b2b2	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>d2b7	b2b7	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>d2bc	b2bc	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>d2c1	b2c1	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>d2c6	b2c6	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>d2cb	b2cb	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>d2d0	b2d0	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>d2d5	b2d5	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>d2da	b2da	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>d2df	b2df	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>d2e4	b2e4	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>d2e9	b2e9	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>d2ee	b2ee	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>d2f3	b2f3	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>d2f8	b2f8	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>d2fd	b2fd	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>d302	b302	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>d307	b307	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>d30c	b30c	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>d311	b311	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>d316	b316	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>d31b	b31b	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>d320	b320	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>d325	b325	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>d32a	b32a	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>d32f	b32f	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>d334	b334	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>d339	b339	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>d33e	b33e	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>d343	b343	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>d348	b348	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>d34d	b34d	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>d352	b352	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>d357	b357	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>d35c	b35c	ff					.text	$FF
.d35d	b35d					Export_TKInitialise:
.d35d	b35d	a2 07		ldx #$07			ldx 	#7
.d35f	b35f					_ETKISetDefault:
.d35f	b35f	bd b4 b5	lda $b5b4,x			lda 	CLIDefault,x
.d362	b362	9d 00 04	sta $0400,x			sta 	CLIFComment,x
.d365	b365	ca		dex				dex
.d366	b366	10 f7		bpl $b35f			bpl 	_ETKISetDefault
.d368	b368	60		rts				rts
.d369	b369					Export_TKListConvertLine:
.d369	b369	48		pha				pha 								; save indent on the stack
.d36a	b36a	9c 39 04	stz $0439			stz 	tbOffset
.d36d	b36d	9c 49 04	stz $0449			stz 	tokenBuffer
.d370	b370	9c 45 04	stz $0445			stz 	currentListColour
.d373	b373	ad 02 04	lda $0402			lda 	CLILineNumber
.d376	b376	20 fe b4	jsr $b4fe			jsr 	LCLWriteColour
.d379	b379	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.d37b	b37b	b1 30		lda ($30),y			lda 	(codePtr),y
.d37d	b37d	aa		tax				tax
.d37e	b37e	88		dey				dey
.d37f	b37f	b1 30		lda ($30),y			lda 	(codePtr),y
.d381	b381	20 73 b5	jsr $b573			jsr 	LCLWriteNumberXA
.d384	b384	68		pla				pla 								; adjustment to indent
.d385	b385	48		pha				pha 								; save on stack
.d386	b386	10 0c		bpl $b394			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.d388	b388	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.d389	b389	6d 42 04	adc $0442			adc 	listIndent
.d38c	b38c	8d 42 04	sta $0442			sta 	listIndent
.d38f	b38f	10 03		bpl $b394			bpl 	_LCNoAdjust
.d391	b391	9c 42 04	stz $0442			stz 	listIndent
.d394	b394					_LCNoAdjust:
.d394	b394	18		clc				clc		 							; work out actual indent.
.d395	b395	ad 42 04	lda $0442			lda 	listIndent
.d398	b398	0a		asl a				asl 	a
.d399	b399	69 07		adc #$07			adc 	#7
.d39b	b39b	85 36		sta $36				sta 	zTemp0
.d39d	b39d					_LCPadOut:
.d39d	b39d	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.d39f	b39f	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d3a2	b3a2	ad 39 04	lda $0439			lda 	tbOffset
.d3a5	b3a5	c5 36		cmp $36				cmp 	zTemp0
.d3a7	b3a7	d0 f4		bne $b39d			bne 	_LCPadOut
.d3a9	b3a9	a0 03		ldy #$03			ldy 	#3 							; start position.
.d3ab	b3ab					_LCMainLoop:
.d3ab	b3ab	ad 06 04	lda $0406			lda 	CLIPunctuation
.d3ae	b3ae	20 fe b4	jsr $b4fe			jsr 	LCLWriteColour
.d3b1	b3b1	b1 30		lda ($30),y			lda 	(codePtr),y
.d3b3	b3b3	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.d3b5	b3b5	f0 17		beq $b3ce			beq 	_LCExit
.d3b7	b3b7	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.d3b9	b3b9	90 1e		bcc $b3d9			bcc 	_LCDoubles
.d3bb	b3bb	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.d3bd	b3bd	90 2a		bcc $b3e9			bcc 	_LCShiftPunc
.d3bf	b3bf	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.d3c1	b3c1	90 35		bcc $b3f8			bcc 	_LCPunctuation
.d3c3	b3c3	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.d3c5	b3c5	90 52		bcc $b419			bcc 	_LCIdentifiers
.d3c7	b3c7	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.d3c9	b3c9	90 75		bcc $b440			bcc 	_LCTokens
.d3cb	b3cb	4c a1 b4	jmp $b4a1			jmp 	_LCData 					; 254-5 are data objects
.d3ce	b3ce					_LCExit:
.d3ce	b3ce	68		pla				pla 								; get old indent adjust
.d3cf	b3cf	30 07		bmi $b3d8			bmi 	_LCExit2
.d3d1	b3d1	18		clc				clc 								; add to indent if +ve
.d3d2	b3d2	6d 42 04	adc $0442			adc 	listIndent
.d3d5	b3d5	8d 42 04	sta $0442			sta 	listIndent
.d3d8	b3d8					_LCExit2:
.d3d8	b3d8	60		rts				rts
.d3d9	b3d9					_LCDoubles:
.d3d9	b3d9	48		pha				pha
.d3da	b3da	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.d3db	b3db	29 02		and #$02			and 	#2
.d3dd	b3dd	09 3c		ora #$3c			ora 	#60 						; make < >
.d3df	b3df	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d3e2	b3e2	68		pla				pla 								; restore, do lower bit
.d3e3	b3e3	29 03		and #$03			and 	#3
.d3e5	b3e5	09 3c		ora #$3c			ora 	#60
.d3e7	b3e7	80 0f		bra $b3f8			bra		_LCPunctuation 				; print, increment, loop
.d3e9	b3e9					_LCShiftPunc:
.d3e9	b3e9	aa		tax				tax 								; save in X
.d3ea	b3ea	29 07		and #$07			and 	#7 							; lower 3 bits
.d3ec	b3ec	f0 02		beq $b3f0			beq 	_LCNoAdd
.d3ee	b3ee	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.d3f0	b3f0					_LCNoAdd:
.d3f0	b3f0	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.d3f2	b3f2	90 02		bcc $b3f6			bcc 	_LCNoAdd2
.d3f4	b3f4	09 20		ora #$20			ora 	#32 						; adds $20
.d3f6	b3f6					_LCNoAdd2:
.d3f6	b3f6	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.d3f8	b3f8					_LCPunctuation:
.d3f8	b3f8	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.d3fa	b3fa	d0 03		bne $b3ff			bne 	_LCPContinue
.d3fc	b3fc	20 21 b5	jsr $b521			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.d3ff	b3ff					_LCPContinue:
.d3ff	b3ff	c9 2e		cmp #$2e			cmp 	#'.'
.d401	b401	f0 08		beq $b40b			beq 	_LCPIsConstant
.d403	b403	c9 30		cmp #$30			cmp 	#'0'
.d405	b405	90 0c		bcc $b413			bcc 	_LCPNotConstant
.d407	b407	c9 3a		cmp #$3a			cmp 	#'9'+1
.d409	b409	b0 08		bcs $b413			bcs 	_LCPNotConstant
.d40b	b40b					_LCPIsConstant:
.d40b	b40b	48		pha				pha
.d40c	b40c	ad 04 04	lda $0404			lda 	CLIConstant
.d40f	b40f	20 fe b4	jsr $b4fe			jsr 	LCLWriteColour
.d412	b412	68		pla				pla
.d413	b413					_LCPNotConstant:
.d413	b413	c8		iny				iny 								; consume character
.d414	b414	20 0b b5	jsr $b50b			jsr 	LCLWrite 					; write it out.
.d417	b417	80 92		bra $b3ab			bra 	_LCMainLoop 				; go round again.
.d419	b419					_LCIdentifiers:
.d419	b419	18		clc				clc 								; convert to physical address
.d41a	b41a	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.d41c	b41c	85 37		sta $37				sta 	zTemp0+1
.d41e	b41e	c8		iny				iny
.d41f	b41f	b1 30		lda ($30),y			lda 	(codePtr),y
.d421	b421	85 36		sta $36				sta 	zTemp0
.d423	b423	c8		iny				iny
.d424	b424	5a		phy				phy 								; save position
.d425	b425	ad 05 04	lda $0405			lda 	CLIIdentifier
.d428	b428	20 fe b4	jsr $b4fe			jsr 	LCLWriteColour
.d42b	b42b	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.d42d	b42d					_LCOutIdentifier:
.d42d	b42d	c8		iny				iny
.d42e	b42e	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.d430	b430	29 7f		and #$7f			and 	#$7F
.d432	b432	20 5d b5	jsr $b55d			jsr 	LCLLowerCase
.d435	b435	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d438	b438	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.d43a	b43a	10 f1		bpl $b42d			bpl 	_LCOutIdentifier
.d43c	b43c	7a		ply				ply 								; restore position
.d43d	b43d	4c ab b3	jmp $b3ab			jmp 	_LCMainLoop
.d440	b440					_LCTokens:
.d440	b440	aa		tax				tax 								; token in X
.d441	b441	a9 11		lda #$11			lda 	#((KeywordSet2) & $FF)
.d443	b443	85 36		sta $36				sta 	0+zTemp0
.d445	b445	a9 b2		lda #$b2			lda 	#((KeywordSet2) >> 8)
.d447	b447	85 37		sta $37				sta 	1+zTemp0
.d449	b449	e0 82		cpx #$82			cpx 	#$82
.d44b	b44b	f0 16		beq $b463			beq 	_LCUseShift
.d44d	b44d	a9 f0		lda #$f0			lda 	#((KeywordSet1) & $FF)
.d44f	b44f	85 36		sta $36				sta 	0+zTemp0
.d451	b451	a9 b0		lda #$b0			lda 	#((KeywordSet1) >> 8)
.d453	b453	85 37		sta $37				sta 	1+zTemp0
.d455	b455	e0 81		cpx #$81			cpx 	#$81
.d457	b457	f0 0a		beq $b463			beq 	_LCUseShift
.d459	b459	a9 72		lda #$72			lda 	#((KeywordSet0) & $FF)
.d45b	b45b	85 36		sta $36				sta 	0+zTemp0
.d45d	b45d	a9 ae		lda #$ae			lda 	#((KeywordSet0) >> 8)
.d45f	b45f	85 37		sta $37				sta 	1+zTemp0
.d461	b461	80 01		bra $b464			bra 	_LCNoShift
.d463	b463					_LCUseShift:
.d463	b463	c8		iny				iny
.d464	b464					_LCNoShift:
.d464	b464	20 35 b5	jsr $b535			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.d467	b467	b1 30		lda ($30),y			lda 	(codePtr),y
.d469	b469	aa		tax				tax 								; into X
.d46a	b46a					_LCFindText:
.d46a	b46a	ca		dex				dex
.d46b	b46b	10 0e		bpl $b47b			bpl 	_LCFoundText 				; found text.
.d46d	b46d	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.d46f	b46f	1a		inc a				inc 	a 							; one extra for size
.d470	b470	38		sec				sec 								; one extra for checksum
.d471	b471	65 36		adc $36				adc 	zTemp0 						; go to next token
.d473	b473	85 36		sta $36				sta 	zTemp0
.d475	b475	90 f3		bcc $b46a			bcc 	_LCFindText
.d477	b477	e6 37		inc $37				inc 	zTemp0+1
.d479	b479	80 ef		bra $b46a			bra 	_LCFindText
.d47b	b47b					_LCFoundText:
.d47b	b47b	5a		phy				phy 								; save List position
.d47c	b47c	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.d47e	b47e	aa		tax				tax
.d47f	b47f	ad 03 04	lda $0403			lda 	CLIToken
.d482	b482	20 fe b4	jsr $b4fe			jsr 	LCLWriteColour
.d485	b485	a0 02		ldy #$02			ldy 	#2
.d487	b487					_LCCopyToken:
.d487	b487	b1 36		lda ($36),y			lda 	(zTemp0),y
.d489	b489	20 5d b5	jsr $b55d			jsr 	LCLLowerCase
.d48c	b48c	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d48f	b48f	c8		iny				iny
.d490	b490	ca		dex				dex
.d491	b491	d0 f4		bne $b487			bne 	_LCCopyToken
.d493	b493	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.d495	b495	f0 05		beq $b49c			beq 	_LCNoSpace
.d497	b497	a9 20		lda #$20			lda 	#' '
.d499	b499	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d49c	b49c					_LCNoSpace:
.d49c	b49c	7a		ply				ply 								; restore position.
.d49d	b49d	c8		iny				iny 								; consume token
.d49e	b49e	4c ab b3	jmp $b3ab			jmp 	_LCMainLoop 				; and go around again.
.d4a1	b4a1					_LCData:
.d4a1	b4a1	48		pha				pha 								; save type $FE/$FF
.d4a2	b4a2	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.d4a4	b4a4	c9 fe		cmp #$fe			cmp 	#$FE
.d4a6	b4a6	f0 29		beq $b4d1			beq 	_LCHaveOpener
.d4a8	b4a8	a2 22		ldx #$22			ldx 	#'"'
.d4aa	b4aa	ad 07 04	lda $0407			lda 	CLIData
.d4ad	b4ad	20 fe b4	jsr $b4fe			jsr 	LCLWriteColour
.d4b0	b4b0	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.d4b2	b4b2	d0 1d		bne $b4d1			bne 	_LCHaveOpener
.d4b4	b4b4	88		dey				dey 								; what precedes it ?
.d4b5	b4b5	b1 30		lda ($30),y			lda 	(codePtr),y
.d4b7	b4b7	c8		iny				iny
.d4b8	b4b8	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.d4ba	b4ba	d0 15		bne $b4d1			bne 	_LCHaveOpener
.d4bc	b4bc	a9 09		lda #$09			lda 	#9 							; tab
.d4be	b4be	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d4c1	b4c1	ad 01 04	lda $0401			lda 	CLIBComment
.d4c4	b4c4	30 0b		bmi $b4d1			bmi 	_LCHaveOpener
.d4c6	b4c6	09 90		ora #$90			ora 	#$90
.d4c8	b4c8	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d4cb	b4cb	ad 00 04	lda $0400			lda 	CLIFComment
.d4ce	b4ce	20 fe b4	jsr $b4fe			jsr 	LCLWriteColour
.d4d1	b4d1					_LCHaveOpener:
.d4d1	b4d1	8a		txa				txa 								; output prefix (# or ")
.d4d2	b4d2	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d4d5	b4d5	c8		iny				iny 								; get count
.d4d6	b4d6	b1 30		lda ($30),y			lda 	(codePtr),y
.d4d8	b4d8	aa		tax				tax
.d4d9	b4d9	c8		iny				iny 								; point at first character
.d4da	b4da					_LCOutData:
.d4da	b4da	b1 30		lda ($30),y			lda 	(codePtr),y
.d4dc	b4dc	c9 00		cmp #$00			cmp 	#0
.d4de	b4de	f0 03		beq $b4e3			beq 	_LCNoPrint
.d4e0	b4e0	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d4e3	b4e3					_LCNoPrint:
.d4e3	b4e3	c8		iny				iny
.d4e4	b4e4	ca		dex				dex
.d4e5	b4e5	d0 f3		bne $b4da			bne 	_LCOutData
.d4e7	b4e7	68		pla				pla 								; closing " required ?
.d4e8	b4e8	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.d4ea	b4ea	d0 0f		bne $b4fb			bne 	_LCNoQuote
.d4ec	b4ec	a9 22		lda #$22			lda 	#'"'
.d4ee	b4ee	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d4f1	b4f1	ad ec 07	lda $07ec			lda 	EXTTextColour
.d4f4	b4f4	29 0f		and #$0f			and 	#$0F
.d4f6	b4f6	09 90		ora #$90			ora 	#$90
.d4f8	b4f8	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d4fb	b4fb					_LCNoQuote:
.d4fb	b4fb	4c ab b3	jmp $b3ab			jmp 	_LCMainLoop
.d4fe	b4fe					LCLWriteColour:
.d4fe	b4fe	29 0f		and #$0f			and 	#$0F
.d500	b500	09 80		ora #$80			ora 	#$80
.d502	b502	cd 45 04	cmp $0445			cmp 	currentListColour 			; has the colour changed
.d505	b505	8d 45 04	sta $0445			sta 	currentListColour 			; (update it anyway)
.d508	b508	d0 01		bne $b50b			bne 	LCLWrite 					; if different, output it
.d50a	b50a	60		rts				rts
.d50b	b50b					LCLWrite:
.d50b	b50b	da		phx				phx
.d50c	b50c	ae 39 04	ldx $0439			ldx 	tbOffset 					; write out make ASCIIZ
.d50f	b50f	9d 49 04	sta $0449,x			sta 	tokenBuffer,x
.d512	b512	9e 4a 04	stz $044a,x			stz 	tokenBuffer+1,x
.d515	b515	ee 39 04	inc $0439			inc 	tbOffset 					; bump the position
.d518	b518	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.d51a	b51a	30 03		bmi $b51f			bmi 	_LCLNoColour
.d51c	b51c	8d 43 04	sta $0443			sta 	lcLastCharacter
.d51f	b51f					_LCLNoColour:
.d51f	b51f	fa		plx				plx
.d520	b520	60		rts				rts
.d521	b521					LCLDeleteLastSpace:
.d521	b521	48		pha				pha
.d522	b522	da		phx				phx
.d523	b523	ae 39 04	ldx $0439			ldx 	tbOffset
.d526	b526	f0 0a		beq $b532			beq 	_LCDLSExit
.d528	b528	bd 48 04	lda $0448,x			lda 	tokenBuffer-1,x
.d52b	b52b	c9 20		cmp #$20			cmp 	#' '
.d52d	b52d	d0 03		bne $b532			bne 	_LCDLSExit
.d52f	b52f	ce 39 04	dec $0439			dec 	tbOffset
.d532	b532					_LCDLSExit:
.d532	b532	fa		plx				plx
.d533	b533	68		pla				pla
.d534	b534	60		rts				rts
.d535	b535					LCLCheckSpaceRequired:
.d535	b535	ad 43 04	lda $0443			lda 	lcLastCharacter 			; check last character
.d538	b538	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.d53a	b53a	f0 1b		beq $b557			beq 	_LCCSRSpace
.d53c	b53c	c9 29		cmp #$29			cmp 	#')'
.d53e	b53e	f0 17		beq $b557			beq 	_LCCSRSpace
.d540	b540	c9 23		cmp #$23			cmp 	#'#'
.d542	b542	f0 13		beq $b557			beq 	_LCCSRSpace
.d544	b544	20 5d b5	jsr $b55d			jsr 	LCLLowerCase 				; saves a little effort
.d547	b547	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.d549	b549	90 11		bcc $b55c			bcc 	_LCCSRExit
.d54b	b54b	c9 3a		cmp #$3a			cmp 	#"9"+1
.d54d	b54d	90 08		bcc $b557			bcc 	_LCCSRSpace
.d54f	b54f	c9 61		cmp #$61			cmp 	#"a"
.d551	b551	90 09		bcc $b55c			bcc 	_LCCSRExit
.d553	b553	c9 7b		cmp #$7b			cmp 	#"z"+1
.d555	b555	b0 05		bcs $b55c			bcs 	_LCCSRExit
.d557	b557					_LCCSRSpace:
.d557	b557	a9 20		lda #$20			lda 	#' '
.d559	b559	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d55c	b55c					_LCCSRExit:
.d55c	b55c	60		rts				rts
.d55d	b55d					LCLLowerCase:
.d55d	b55d	c9 41		cmp #$41			cmp 	#"A"
.d55f	b55f	90 06		bcc $b567			bcc 	_LCLLCOut
.d561	b561	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d563	b563	b0 02		bcs $b567			bcs 	_LCLLCOut
.d565	b565	69 20		adc #$20			adc 	#$20
.d567	b567					_LCLLCOut:
.d567	b567	60		rts				rts
.d568	b568					LCLUpperCase:
.d568	b568	c9 61		cmp #$61			cmp 	#"a"
.d56a	b56a	90 06		bcc $b572			bcc 	_LCLUCOut
.d56c	b56c	c9 7b		cmp #$7b			cmp 	#"z"+1
.d56e	b56e	b0 02		bcs $b572			bcs 	_LCLUCOut
.d570	b570	e9 1f		sbc #$1f			sbc 	#$1F
.d572	b572					_LCLUCOut:
.d572	b572	60		rts				rts
.d573	b573					LCLWriteNumberXA:
.d573	b573	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.d575	b575					_LCLWNLoop1:
.d575	b575	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.d577	b577					_LCLWNLoop2:
.d577	b577	48		pha				pha 								; save initial LSB
.d578	b578	38		sec				sec
.d579	b579	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.d57b	b57b	f9 ac b5	sbc $b5ac,y			sbc 	_LCLWNTable,y
.d57e	b57e	48		pha				pha
.d57f	b57f	8a		txa				txa
.d580	b580	f9 ad b5	sbc $b5ad,y			sbc 	_LCLWNTable+1,y
.d583	b583	90 07		bcc $b58c			bcc 	_LCLWNUnderflow
.d585	b585	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.d587	b587	aa		tax				tax 								; update X
.d588	b588	68		pla				pla 								; restore A
.d589	b589	7a		ply				ply 								; throw original
.d58a	b58a	80 eb		bra $b577			bra 	_LCLWNLoop2 				; try again.
.d58c	b58c					_LCLWNUnderflow:
.d58c	b58c	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.d58e	b58e	d0 06		bne $b596			bne 	_LCLWNOut
.d590	b590	ad 39 04	lda $0439			lda 	tbOffset 					; suppress leading zeroes
.d593	b593	3a		dec a				dec 	a
.d594	b594	f0 04		beq $b59a			beq 	_LCLWNNext
.d596	b596					_LCLWNOut:
.d596	b596	98		tya				tya
.d597	b597	20 a6 b5	jsr $b5a6			jsr 	_LCLWNOutDigit
.d59a	b59a					_LCLWNNext:
.d59a	b59a	7a		ply				ply 							 	; restore original value.
.d59b	b59b	68		pla				pla
.d59c	b59c	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.d59e	b59e	c8		iny				iny
.d59f	b59f	c8		iny				iny
.d5a0	b5a0	84 37		sty $37				sty 	zTemp0+1
.d5a2	b5a2	c0 08		cpy #$08			cpy 	#8 							; done all 4
.d5a4	b5a4	d0 cf		bne $b575			bne 	_LCLWNLoop1
.d5a6	b5a6					_LCLWNOutDigit:
.d5a6	b5a6	09 30		ora #$30			ora 	#'0'
.d5a8	b5a8	20 0b b5	jsr $b50b			jsr 	LCLWrite
.d5ab	b5ab	60		rts				rts
.d5ac	b5ac					_LCLWNTable:
>d5ac	b5ac	10 27						.word 	10000
>d5ae	b5ae	e8 03						.word 	1000
>d5b0	b5b0	64 00						.word 	100
>d5b2	b5b2	0a 00						.word 	10
.d5b4	b5b4					CLIDefault:
>d5b4	b5b4	05 0e 0d 06 07 0e 0c 0f				.byte	CONBrown, CONYellow, CONRed, CONOrange, CONCyan, CONYellow, CONPink, CONWhite
=1024						CLIFComment = ControlStorage + 0
=1025						CLIBComment = ControlStorage + 1
=1026						CLILineNumber = ControlStorage + 2
=1027						CLIToken = ControlStorage + 3
=1028						CLIConstant = ControlStorage + 4
=1029						CLIIdentifier = ControlStorage + 5
=1030						CLIPunctuation = ControlStorage + 6
=1031						CLIData = ControlStorage + 7
.d5bc	b5bc					TOKSearchTable:
.d5bc	b5bc	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.d5be	b5be	85 36		sta $36				sta 	zTemp0
.d5c0	b5c0	a0 00		ldy #$00			ldy 	#0
.d5c2	b5c2	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.d5c4	b5c4	85 38		sta $38				sta 	zTemp1
.d5c6	b5c6					_TSTLoop:
.d5c6	b5c6	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.d5c8	b5c8	30 49		bmi $b613			bmi 	_TSTFail 					; -ve = end of table, so fail.
.d5ca	b5ca	f0 2e		beq $b5fa			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.d5cc	b5cc	c8		iny				iny 								; get the hash
.d5cd	b5cd	b1 36		lda ($36),y			lda 	(zTemp0),y
.d5cf	b5cf	88		dey				dey
.d5d0	b5d0	cd 23 04	cmp $0423			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.d5d3	b5d3	d0 25		bne $b5fa			bne 	_TSTNext
.d5d5	b5d5	ad 22 04	lda $0422			lda 	identTypeEnd 				; get length of identifier from end-start
.d5d8	b5d8	38		sec				sec
.d5d9	b5d9	ed 20 04	sbc $0420			sbc 	identStart
.d5dc	b5dc	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.d5de	b5de	d0 1a		bne $b5fa			bne 	_TSTNext
.d5e0	b5e0	5a		phy				phy 								; save Y , we might fail to match.
.d5e1	b5e1	c8		iny				iny 								; point to text
.d5e2	b5e2	c8		iny				iny
.d5e3	b5e3	ae 20 04	ldx $0420			ldx 	identStart 					; offset in line buffer in X
.d5e6	b5e6					_TSTCompareName:
.d5e6	b5e6	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; compare text.
.d5e9	b5e9	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.d5eb	b5eb	d0 0c		bne $b5f9			bne 	_TSTNextPullY 				; fail, pullY and do next
.d5ed	b5ed	e8		inx				inx
.d5ee	b5ee	c8		iny				iny
.d5ef	b5ef	ec 22 04	cpx $0422			cpx 	identTypeEnd 				; complete match.
.d5f2	b5f2	d0 f2		bne $b5e6			bne 	_TSTCompareName
.d5f4	b5f4	7a		ply				ply 								; throw Y
.d5f5	b5f5	a5 38		lda $38				lda 	zTemp1 						; get token #
.d5f7	b5f7	38		sec				sec 								; return with CS = passed.
.d5f8	b5f8	60		rts				rts
.d5f9	b5f9					_TSTNextPullY:
.d5f9	b5f9	7a		ply				ply 								; restore current, fall through.
.d5fa	b5fa					_TSTNext:
.d5fa	b5fa	e6 38		inc $38				inc 	zTemp1 						; token counter
.d5fc	b5fc	98		tya				tya
.d5fd	b5fd	18		clc				clc
.d5fe	b5fe	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.d600	b600	1a		inc a				inc 	a 							; +1
.d601	b601	1a		inc a				inc 	a 							; +2
.d602	b602	a8		tay				tay
.d603	b603	10 c1		bpl $b5c6			bpl 	_TSTLoop 					; if Y < $80 loop back
.d605	b605	98		tya				tya 								; add Y to zTemp0 and reset Y
.d606	b606	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.d608	b608	18		clc				clc  								; but have tables > 255 bytes
.d609	b609	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.d60b	b60b	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.d60d	b60d	90 b7		bcc $b5c6			bcc 	_TSTLoop
.d60f	b60f	e6 37		inc $37				inc 	zTemp0+1
.d611	b611	80 b3		bra $b5c6			bra 	_TSTLoop
.d613	b613					_TSTFail:
.d613	b613	18		clc				clc
.d614	b614	60		rts				rts
.d615	b615					Export_TKTokeniseLine:
.d615	b615	20 e2 b7	jsr $b7e2			jsr 	LCLFixLineBufferCase 		; fix line case
.d618	b618	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.d61a	b61a	8d 46 04	sta $0446			sta 	tokenOffset 				; (3 bytes for line number & offset)
.d61d	b61d	9c 47 04	stz $0447			stz 	tokenLineNumber
.d620	b620	9c 48 04	stz $0448			stz 	tokenLineNumber+1
.d623	b623	a2 ff		ldx #$ff			ldx 	#$FF
.d625	b625					_TKFindFirst:
.d625	b625	e8		inx				inx
.d626	b626	bd 46 05	lda $0546,x			lda 	lineBuffer,x
.d629	b629	f0 62		beq $b68d			beq 	_TKExit
.d62b	b62b	c9 20		cmp #$20			cmp 	#' '
.d62d	b62d	90 f6		bcc $b625			bcc 	_TKFindFirst
.d62f	b62f	c9 30		cmp #$30			cmp 	#'0'
.d631	b631	90 07		bcc $b63a			bcc 	_TKNoLineNumber
.d633	b633	c9 3a		cmp #$3a			cmp 	#'9'+1
.d635	b635	b0 03		bcs $b63a			bcs 	_TKNoLineNumber
.d637	b637	20 0c b8	jsr $b80c			jsr 	TOKExtractLineNumber
.d63a	b63a					_TKNoLineNumber:
.d63a	b63a					_TKTokeniseLoop:
.d63a	b63a	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.d63d	b63d	f0 4e		beq $b68d			beq 	_TKExit
.d63f	b63f	e8		inx				inx
.d640	b640	c9 20		cmp #$20			cmp 	#' '
.d642	b642	f0 f6		beq $b63a			beq 	_TKTokeniseLoop 			; keep looping if space found.
.d644	b644	ca		dex				dex 								; undo last get, A contains character, X is position.
.d645	b645	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.d647	b647	f0 68		beq $b6b1			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.d649	b649	c9 41		cmp #$41			cmp 	#'A'
.d64b	b64b	90 04		bcc $b651			bcc 	_TKTokenisePunctuation
.d64d	b64d	c9 5b		cmp #$5b			cmp 	#'Z'+1
.d64f	b64f	90 60		bcc $b6b1			bcc 	_TKTokeniseIdentifier
.d651	b651					_TKTokenisePunctuation:
.d651	b651	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.d653	b653	f0 2e		beq $b683			beq 	_TKString
.d655	b655	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.d657	b657	f0 2f		beq $b688			beq 	_TKHexConstant
.d659	b659	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.d65b	b65b	f0 36		beq $b693			beq 	_TKCheckDouble
.d65d	b65d	c9 3e		cmp #$3e			cmp 	#'>'
.d65f	b65f	f0 32		beq $b693			beq 	_TKCheckDouble
.d661	b661					_TKStandardPunctuation:
.d661	b661	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; get the punctuation token back.
.d664	b664	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.d666	b666	90 0e		bcc $b676			bcc 	_TKNoShift
.d668	b668	48		pha				pha 								; save. we are about to convert this punctuation token from
.d669	b669	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.d66b	b66b	85 36		sta $36				sta 	zTemp0
.d66d	b66d	68		pla				pla
.d66e	b66e	29 20		and #$20			and 	#32 						; bit 5
.d670	b670	4a		lsr a				lsr 	a 							; shift into bit 3
.d671	b671	4a		lsr a				lsr 	a
.d672	b672	05 36		ora $36				ora 	zTemp0
.d674	b674	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.d676	b676					_TKNoShift:
.d676	b676	20 51 b8	jsr $b851			jsr 	TOKWriteByte 				; write the punctuation character
.d679	b679	e8		inx				inx 								; consume the character
.d67a	b67a	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; quote found ?
.d67c	b67c	d0 bc		bne $b63a			bne 	_TKTokeniseLoop 			; and loop round again.
.d67e	b67e	20 44 b7	jsr $b744			jsr 	TOKCheckComment 			; comment checl
.d681	b681	80 b7		bra $b63a			bra 	_TKTokeniseLoop
.d683	b683					_TKString:
.d683	b683	20 71 b7	jsr $b771			jsr 	TOKTokenString
.d686	b686	80 b2		bra $b63a			bra 	_TKTokeniseLoop
.d688	b688					_TKHexConstant:
.d688	b688	20 ac b7	jsr $b7ac			jsr 	TOKHexConstant
.d68b	b68b	80 ad		bra $b63a			bra 	_TKTokeniseLoop
.d68d	b68d	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.d68f	b68f	20 51 b8	jsr $b851			jsr 	TOKWriteByte
.d692	b692	60		rts				rts
.d693	b693					_TKCheckDouble:
.d693	b693	bd 47 05	lda $0547,x			lda 	lineBuffer+1,x 				; get next character
.d696	b696	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.d698	b698	90 c7		bcc $b661			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.d69a	b69a	c9 3f		cmp #$3f			cmp 	#'>'+1
.d69c	b69c	b0 c3		bcs $b661			bcs 	_TKStandardPunctuation
.d69e	b69e	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.d6a1	b6a1	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.d6a3	b6a3	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.d6a4	b6a4	7d 47 05	adc $0547,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.d6a7	b6a7	38		sec				sec
.d6a8	b6a8	e9 3c		sbc #$3c			sbc 	#'<'
.d6aa	b6aa	20 51 b8	jsr $b851			jsr 	TOKWriteByte 				; this is in the range 0-7
.d6ad	b6ad	e8		inx				inx 								; consume both
.d6ae	b6ae	e8		inx				inx
.d6af	b6af	80 89		bra $b63a			bra 	_TKTokeniseLoop
.d6b1	b6b1					_TKTokeniseIdentifier:
.d6b1	b6b1	8e 20 04	stx $0420			stx 	identStart 					; save start
.d6b4	b6b4	9c 24 04	stz $0424			stz 	identTypeByte 				; zero the type byte
.d6b7	b6b7					_TKCheckLoop:
.d6b7	b6b7	e8		inx				inx 								; look at next, we know first is identifier already.
.d6b8	b6b8	bd 46 05	lda $0546,x			lda  	lineBuffer,x
.d6bb	b6bb	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.d6bd	b6bd	f0 f8		beq $b6b7			beq 	_TKCheckLoop
.d6bf	b6bf	c9 30		cmp #$30			cmp	 	#"0"
.d6c1	b6c1	90 0c		bcc $b6cf			bcc 	_TKEndIdentifier
.d6c3	b6c3	c9 3a		cmp #$3a			cmp 	#"9"+1
.d6c5	b6c5	90 f0		bcc $b6b7			bcc 	_TKCheckLoop
.d6c7	b6c7	c9 41		cmp #$41			cmp	 	#"A"
.d6c9	b6c9	90 04		bcc $b6cf			bcc 	_TKEndIdentifier
.d6cb	b6cb	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d6cd	b6cd	90 e8		bcc $b6b7			bcc 	_TKCheckLoop
.d6cf	b6cf					_TKEndIdentifier:
.d6cf	b6cf	8e 21 04	stx $0421			stx 	identTypeStart 				; save start of type text (if any !)
.d6d2	b6d2	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.d6d4	b6d4	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.d6d6	b6d6	f0 06		beq $b6de			beq 	_TKHasTypeCharacter
.d6d8	b6d8	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.d6da	b6da	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.d6dc	b6dc	d0 07		bne $b6e5			bne 	_TKNoTypeCharacter
.d6de	b6de					_TKHasTypeCharacter:
.d6de	b6de	8c 24 04	sty $0424			sty 	identTypeByte 				; has # or $, save the type
.d6e1	b6e1	e8		inx				inx 								; consume the type character
.d6e2	b6e2	bd 46 05	lda $0546,x			lda 	lineBuffer,x
.d6e5	b6e5					_TKNoTypeCharacter:
.d6e5	b6e5	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.d6e7	b6e7	d0 09		bne $b6f2			bne 	_TKNoArray
.d6e9	b6e9	e8		inx				inx 								; skip the (
.d6ea	b6ea	ad 24 04	lda $0424			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.d6ed	b6ed	09 04		ora #$04			ora 	#$04
.d6ef	b6ef	8d 24 04	sta $0424			sta 	identTypeByte
.d6f2	b6f2					_TKNoArray:
.d6f2	b6f2	8e 22 04	stx $0422			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.d6f5	b6f5	20 cd b7	jsr $b7cd			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.d6f8	b6f8	a0 ae		ldy #$ae			ldy 	#(KeywordSet0) >> 8
.d6fa	b6fa	a9 72		lda #$72			lda 	#(KeywordSet0) & $FF
.d6fc	b6fc	20 bc b5	jsr $b5bc			jsr 	TOKSearchTable
.d6ff	b6ff	a2 00		ldx #$00			ldx 	#0
.d701	b701	b0 1f		bcs $b722			bcs 	_TKFoundToken
.d703	b703	a0 b0		ldy #$b0			ldy 	#(KeywordSet1) >> 8
.d705	b705	a9 f0		lda #$f0			lda 	#(KeywordSet1) & $FF
.d707	b707	20 bc b5	jsr $b5bc			jsr 	TOKSearchTable
.d70a	b70a	a2 81		ldx #$81			ldx 	#$81
.d70c	b70c	b0 14		bcs $b722			bcs 	_TKFoundToken
.d70e	b70e	a0 b2		ldy #$b2			ldy 	#(KeywordSet2) >> 8
.d710	b710	a9 11		lda #$11			lda 	#(KeywordSet2) & $FF
.d712	b712	20 bc b5	jsr $b5bc			jsr 	TOKSearchTable
.d715	b715	a2 82		ldx #$82			ldx 	#$82
.d717	b717	b0 09		bcs $b722			bcs 	_TKFoundToken
.d719	b719	20 5d b8	jsr $b85d			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.d71c	b71c	ae 22 04	ldx $0422			ldx 	identTypeEnd 				; X points to following byte
.d71f	b71f	4c 3a b6	jmp $b63a			jmp 	_TKTokeniseLoop 			; and go round again.
.d722	b722					_TKFoundToken:
.d722	b722	48		pha				pha 								; save token
.d723	b723	8a		txa				txa 								; shift in X, is there one ?
.d724	b724	f0 03		beq $b729			beq 	_TKNoTShift
.d726	b726	20 51 b8	jsr $b851			jsr 	TOKWriteByte 				; if so, write it out
.d729	b729					_TKNoTShift:
.d729	b729	68		pla				pla 								; restore and write token
.d72a	b72a	20 51 b8	jsr $b851			jsr 	TOKWriteByte
.d72d	b72d	e0 00		cpx #$00			cpx 	#0 							; check for REM and '
.d72f	b72f	d0 0d		bne $b73e			bne 	_TKNotRem 			 		; not shifted ?
.d731	b731	c9 d7		cmp #$d7			cmp 	#KWD_REM
.d733	b733	d0 09		bne $b73e			bne 	_TKNotRem
.d735	b735	ae 22 04	ldx $0422			ldx 	identTypeEnd 				; check if comment follows.
.d738	b738	20 44 b7	jsr $b744			jsr 	TOKCheckComment
.d73b	b73b	4c 3a b6	jmp $b63a			jmp 	_TKTokeniseLoop
.d73e	b73e					_TKNotRem:
.d73e	b73e	ae 22 04	ldx $0422			ldx 	identTypeEnd 				; X points to following byte
.d741	b741	4c 3a b6	jmp $b63a			jmp 	_TKTokeniseLoop 			; and go round again.
.d744	b744					TOKCheckComment:
.d744	b744	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; skip over space
.d747	b747	e8		inx				inx
.d748	b748	c9 20		cmp #$20			cmp 	#' '
.d74a	b74a	f0 f8		beq $b744			beq 	TOKCheckComment
.d74c	b74c	ca		dex				dex 								; first non space character
.d74d	b74d	c9 22		cmp #$22			cmp 	#'"'						; quote mark
.d74f	b74f	f0 1f		beq $b770			beq 	_TOKCCExit 					; then we are okay
.d751	b751	c9 00		cmp #$00			cmp 	#0 							; EOL
.d753	b753	f0 1b		beq $b770			beq 	_TOKCCExit 					; then we are okay
.d755	b755	da		phx				phx
.d756	b756					_TOKCCLowerCase:
.d756	b756	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; about making it lower case it all, but I thought
.d759	b759	c9 41		cmp #$41			cmp 	#"A"		 				; that was a bit risky. So it's converted to L/C here.
.d75b	b75b	90 09		bcc $b766			bcc 	_TOKKCNotUC
.d75d	b75d	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d75f	b75f	b0 05		bcs $b766			bcs 	_TOKKCNotUC
.d761	b761	49 20		eor #$20			eor 	#$20
.d763	b763	9d 46 05	sta $0546,x			sta 	lineBuffer,x
.d766	b766					_TOKKCNotUC:
.d766	b766	e8		inx				inx
.d767	b767	c9 00		cmp #$00			cmp 	#0
.d769	b769	d0 eb		bne $b756			bne 	_TOKCCLowerCase
.d76b	b76b	fa		plx				plx
.d76c	b76c	ca		dex				dex 								; tokenise string expects initial skip.
.d76d	b76d	20 71 b7	jsr $b771			jsr 	TOKTokenString 				; tokenise rest of line as a string.
.d770	b770					_TOKCCExit:
.d770	b770	60		rts				rts
.d771	b771					TOKTokenString:
.d771	b771	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.d773	b773	20 51 b8	jsr $b851			jsr 	TOKWriteByte
.d776	b776	e8		inx				inx									; start of quoted string.
.d777	b777	da		phx				phx 								; push start of string on top
.d778	b778	ca		dex				dex 								; because we pre-increment
.d779	b779					_TSFindEnd:
.d779	b779	e8		inx				inx
.d77a	b77a	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; next character
.d77d	b77d	f0 04		beq $b783			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.d77f	b77f	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.d781	b781	d0 f6		bne $b779			bne 	_TSFindEnd
.d783	b783					_TSEndOfString:
.d783	b783	7a		ply				ply  								; so now Y is first character, X is character after end.
.d784	b784	48		pha				pha 								; save terminating character
.d785	b785	20 8d b7	jsr $b78d			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.d788	b788	68		pla				pla 								; terminating character
.d789	b789	f0 01		beq $b78c			beq 	_TSNotQuote					; if it wasn't EOS skip it
.d78b	b78b	e8		inx				inx
.d78c	b78c					_TSNotQuote:
.d78c	b78c	60		rts				rts
.d78d	b78d					TOKWriteBlockXY:
.d78d	b78d	86 36		stx $36				stx 	zTemp0 						; save end character
.d78f	b78f	98		tya				tya 								; use 2's complement to work out the byte size
.d790	b790	49 ff		eor #$ff			eor 	#$FF
.d792	b792	38		sec				sec
.d793	b793	65 36		adc $36				adc 	zTemp0
.d795	b795	1a		inc a				inc 	a 							; one extra for NULL
.d796	b796	20 51 b8	jsr $b851			jsr 	TOKWriteByte
.d799	b799					_TOBlockLoop:
.d799	b799	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.d79b	b79b	f0 09		beq $b7a6			beq 	_TOBlockExit
.d79d	b79d	b9 46 05	lda $0546,y			lda 	lineBuffer,y 				; write byte out.
.d7a0	b7a0	20 51 b8	jsr $b851			jsr 	TOKWriteByte
.d7a3	b7a3	c8		iny				iny
.d7a4	b7a4	80 f3		bra $b799			bra 	_TOBlockLoop
.d7a6	b7a6					_TOBlockExit:
.d7a6	b7a6	a9 00		lda #$00			lda 	#0 							; add NULL.
.d7a8	b7a8	20 51 b8	jsr $b851			jsr 	TOKWriteByte
.d7ab	b7ab	60		rts				rts
.d7ac	b7ac					TOKHexConstant:
.d7ac	b7ac	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.d7ae	b7ae	20 51 b8	jsr $b851			jsr 	TOKWriteByte
.d7b1	b7b1	e8		inx				inx									; start of quoted string.
.d7b2	b7b2	da		phx				phx 								; push start of constant on top
.d7b3	b7b3	ca		dex				dex
.d7b4	b7b4					_THFindLoop:
.d7b4	b7b4	e8		inx				inx 	 							; this is stored in a block, so find out how long
.d7b5	b7b5	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; the hex constant is.
.d7b8	b7b8	c9 30		cmp #$30			cmp 	#"0"
.d7ba	b7ba	90 0c		bcc $b7c8			bcc 	_THFoundEnd
.d7bc	b7bc	c9 3a		cmp #$3a			cmp 	#"9"+1
.d7be	b7be	90 f4		bcc $b7b4			bcc 	_THFindLoop
.d7c0	b7c0	c9 41		cmp #$41			cmp 	#"A"
.d7c2	b7c2	90 04		bcc $b7c8			bcc 	_THFoundEnd
.d7c4	b7c4	c9 47		cmp #$47			cmp 	#"F"+1
.d7c6	b7c6	90 ec		bcc $b7b4			bcc 	_THFindLoop
.d7c8	b7c8					_THFoundEnd:
.d7c8	b7c8	7a		ply				ply 								; restore start
.d7c9	b7c9	20 8d b7	jsr $b78d			jsr 	TOKWriteBlockXY 			; output the block
.d7cc	b7cc	60		rts				rts
.d7cd	b7cd					TOKCalculateHash:
.d7cd	b7cd	da		phx				phx
.d7ce	b7ce	ae 20 04	ldx $0420			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.d7d1	b7d1	a9 00		lda #$00			lda 	#0
.d7d3	b7d3					_TCHLoop:
.d7d3	b7d3	18		clc				clc
.d7d4	b7d4	7d 46 05	adc $0546,x			adc 	lineBuffer,x
.d7d7	b7d7	e8		inx				inx
.d7d8	b7d8	ec 22 04	cpx $0422			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.d7db	b7db	d0 f6		bne $b7d3			bne 	_TCHLoop
.d7dd	b7dd	8d 23 04	sta $0423			sta 	identHash 					; save the hash
.d7e0	b7e0	fa		plx				plx
.d7e1	b7e1	60		rts				rts
.d7e2	b7e2					LCLFixLineBufferCase:
.d7e2	b7e2	a2 00		ldx #$00			ldx 	#0
.d7e4	b7e4					_FLBCLoop:
.d7e4	b7e4	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; get next character
.d7e7	b7e7	f0 22		beq $b80b			beq 	_FLBCExit 					; end of string.
.d7e9	b7e9	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.d7eb	b7eb	f0 11		beq $b7fe			beq 	_FLBCInQuotes
.d7ed	b7ed	e8		inx				inx
.d7ee	b7ee	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.d7f0	b7f0	90 f2		bcc $b7e4			bcc 	_FLBCLoop
.d7f2	b7f2	c9 7b		cmp #$7b			cmp 	#'z'+1
.d7f4	b7f4	b0 ee		bcs $b7e4			bcs 	_FLBCLoop
.d7f6	b7f6	38		sec				sec 								; make U/C
.d7f7	b7f7	e9 20		sbc #$20			sbc 	#32
.d7f9	b7f9	9d 45 05	sta $0545,x			sta	 	lineBuffer-1,x 				; write back
.d7fc	b7fc	80 e6		bra $b7e4			bra 	_FLBCLoop
.d7fe	b7fe					_FLBCInQuotes:
.d7fe	b7fe	e8		inx				inx 								; advance
.d7ff	b7ff	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; get next
.d802	b802	f0 07		beq $b80b			beq 	_FLBCExit 					; exit on EOS
.d804	b804	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.d806	b806	d0 f6		bne $b7fe			bne 	_FLBCInQuotes
.d808	b808	e8		inx				inx 								; skip over it
.d809	b809	80 d9		bra $b7e4			bra 	_FLBCLoop
.d80b	b80b					_FLBCExit:
.d80b	b80b	60		rts				rts
.d80c	b80c					TOKExtractLineNumber:
.d80c	b80c	ad 48 04	lda $0448			lda 	tokenLineNumber+1 			; push current value on stack
.d80f	b80f	48		pha				pha
.d810	b810	ad 47 04	lda $0447			lda 	tokenLineNumber
.d813	b813	48		pha				pha
.d814	b814	20 4a b8	jsr $b84a			jsr 	_LCLNTimes2 				; line # x 2
.d817	b817	20 4a b8	jsr $b84a			jsr 	_LCLNTimes2 				; line # x 4
.d81a	b81a	18		clc				clc 								; add stacked value
.d81b	b81b	68		pla				pla
.d81c	b81c	6d 47 04	adc $0447			adc 	tokenLineNumber
.d81f	b81f	8d 47 04	sta $0447			sta 	tokenLineNumber
.d822	b822	68		pla				pla
.d823	b823	6d 48 04	adc $0448			adc 	tokenLineNumber+1
.d826	b826	8d 48 04	sta $0448			sta 	tokenLineNumber+1 			; line # x 5
.d829	b829	20 4a b8	jsr $b84a			jsr 	_LCLNTimes2 				; line # x 10
.d82c	b82c	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; get and consume character
.d82f	b82f	e8		inx				inx
.d830	b830	29 0f		and #$0f			and 	#15 						; add to line #
.d832	b832	18		clc				clc
.d833	b833	6d 47 04	adc $0447			adc 	tokenLineNumber
.d836	b836	8d 47 04	sta $0447			sta 	tokenLineNumber
.d839	b839	90 03		bcc $b83e			bcc 	_TLENNoCarry
.d83b	b83b	ee 48 04	inc $0448			inc 	tokenLineNumber+1
.d83e	b83e					_TLENNoCarry:
.d83e	b83e	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; more digits ?
.d841	b841	c9 30		cmp #$30			cmp 	#'0'
.d843	b843	90 04		bcc $b849			bcc 	_TLENExit
.d845	b845	c9 3a		cmp #$3a			cmp 	#'9'+1
.d847	b847	90 c3		bcc $b80c			bcc 	TOKExtractLineNumber
.d849	b849					_TLENExit:
.d849	b849	60		rts				rts
.d84a	b84a					_LCLNTimes2:
.d84a	b84a	0e 47 04	asl $0447			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.d84d	b84d	2e 48 04	rol $0448			rol 	tokenLineNumber+1
.d850	b850	60		rts				rts
.d851	b851					TOKWriteByte:
.d851	b851	da		phx				phx
.d852	b852	ae 46 04	ldx $0446			ldx 	tokenOffset 				; next slot to write to
.d855	b855	9d 46 04	sta $0446,x			sta 	tokenOffset,x 				; write byte out
.d858	b858	ee 46 04	inc $0446			inc 	tokenOffset 				; advance slot.
.d85b	b85b	fa		plx				plx
.d85c	b85c	60		rts				rts
.d85d	b85d					TOKCheckCreateVariableRecord:
.d85d	b85d	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.d85f	b85f	85 36		sta $36				sta 	0+zTemp0
.d861	b861	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.d863	b863	85 37		sta $37				sta 	1+zTemp0
.d865	b865					_CCVSearch:
.d865	b865	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.d867	b867	f0 2c		beq $b895			beq 	_CCVFail
.d869	b869	a0 01		ldy #$01			ldy 	#1 							; read the hash
.d86b	b86b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.d86d	b86d	cd 23 04	cmp $0423			cmp 	identHash 	  				; if not, try the next.
.d870	b870	d0 16		bne $b888			bne 	_CCVNext
.d872	b872	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.d874	b874	ae 20 04	ldx $0420			ldx 	identStart
.d877	b877					_CCVCompare:
.d877	b877	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.d87a	b87a	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.d87c	b87c	e8		inx				inx 								; advance pointers
.d87d	b87d	c8		iny				iny
.d87e	b87e	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.d87f	b87f	d0 07		bne $b888			bne 	_CCVNext  					; didn't match go to next.
.d881	b881	90 f4		bcc $b877			bcc 	_CCVCompare 				; not finished yet.
.d883	b883	ec 22 04	cpx $0422			cpx 	identTypeEnd 				; matched whole thing ?
.d886	b886	f0 41		beq $b8c9			beq 	_CCVFound 					; yes, we were successful
.d888	b888					_CCVNext:
.d888	b888	18		clc				clc 								; go to next record.
.d889	b889	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.d88b	b88b	65 36		adc $36				adc 	zTemp0
.d88d	b88d	85 36		sta $36				sta 	zTemp0
.d88f	b88f	90 d4		bcc $b865			bcc 	_CCVSearch
.d891	b891	e6 37		inc $37				inc 	zTemp0+1
.d893	b893	80 d0		bra $b865			bra 	_CCVSearch
.d895	b895					_CCVFail:
.d895	b895	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.d897	b897	ad 23 04	lda $0423			lda 	identHash
.d89a	b89a	91 36		sta ($36),y			sta 	(zTemp0),y
.d89c	b89c	c8		iny				iny 								; offset 2 is the type byte
.d89d	b89d	ad 24 04	lda $0424			lda 	identTypeByte
.d8a0	b8a0	91 36		sta ($36),y			sta 	(zTemp0),y
.d8a2	b8a2	c8		iny				iny
.d8a3	b8a3					_CCVData:
.d8a3	b8a3	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.d8a5	b8a5	91 36		sta ($36),y			sta 	(zTemp0),y
.d8a7	b8a7	c8		iny				iny
.d8a8	b8a8	c0 08		cpy #$08			cpy 	#8
.d8aa	b8aa	90 f7		bcc $b8a3			bcc 	_CCVData
.d8ac	b8ac	ae 20 04	ldx $0420			ldx 	identStart 					; copy name into 8 on.
.d8af	b8af					_CCVCopyName:
.d8af	b8af	bd 46 05	lda $0546,x			lda 	lineBuffer,x
.d8b2	b8b2	91 36		sta ($36),y			sta 	(zTemp0),y
.d8b4	b8b4	e8		inx				inx
.d8b5	b8b5	c8		iny				iny
.d8b6	b8b6	ec 22 04	cpx $0422			cpx 	identTypeEnd
.d8b9	b8b9	d0 f4		bne $b8af			bne 	_CCVCopyName
.d8bb	b8bb	98		tya				tya 								; patch offset
.d8bc	b8bc	92 36		sta ($36)			sta 	(zTemp0)
.d8be	b8be	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.d8c0	b8c0	91 36		sta ($36),y			sta 	(zTemp0),y
.d8c2	b8c2	88		dey				dey
.d8c3	b8c3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.d8c5	b8c5	09 80		ora #$80			ora 	#$80
.d8c7	b8c7	91 36		sta ($36),y			sta 	(zTemp0),y
.d8c9	b8c9					_CCVFound:
.d8c9	b8c9	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.d8cb	b8cb	38		sec				sec
.d8cc	b8cc	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.d8ce	b8ce	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.d8d0	b8d0	20 51 b8	jsr $b851			jsr 	TOKWriteByte
.d8d3	b8d3	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.d8d5	b8d5	20 51 b8	jsr $b851			jsr 	TOKWriteByte
.d8d8	b8d8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/.build/sound.module.asm

=1						soundIntegrated=1
.d8d9	b8d9					SNDCheckChannel:
.d8d9	b8d9	aa		tax				tax
.d8da	b8da	bd be 0a	lda $0abe,x			lda 	SNDTimeLeft,x 				; currently playing a note
.d8dd	b8dd	d0 38		bne $b917			bne 	_SNDCCExit
.d8df	b8df	da		phx				phx 								; save current channel
.d8e0	b8e0	8a		txa				txa 								; put in A
.d8e1	b8e1	20 5d b9	jsr $b95d			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.d8e4	b8e4	68		pla				pla 								; channel # in A
.d8e5	b8e5	90 30		bcc $b917			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.d8e7	b8e7	a8		tay				tay 								; Y is the channel #
.d8e8	b8e8	bd b3 09	lda $09b3,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.d8eb	b8eb	99 b2 0a	sta $0ab2,y			sta 	SNDPitchLow,y
.d8ee	b8ee	bd b4 09	lda $09b4,x			lda 	SNDQueue+2,x
.d8f1	b8f1	99 b6 0a	sta $0ab6,y			sta 	SNDPitchHigh,y
.d8f4	b8f4	bd b5 09	lda $09b5,x			lda 	SNDQueue+3,x
.d8f7	b8f7	99 ba 0a	sta $0aba,y			sta 	SNDVolume,y
.d8fa	b8fa	bd b6 09	lda $09b6,x			lda 	SNDQueue+4,x
.d8fd	b8fd	99 be 0a	sta $0abe,y			sta 	SNDTimeLeft,y
.d900	b900	bd b7 09	lda $09b7,x			lda 	SNDQueue+5,x
.d903	b903	99 c2 0a	sta $0ac2,y			sta 	SNDAdjustLow,y
.d906	b906	bd b8 09	lda $09b8,x			lda 	SNDQueue+6,x
.d909	b909	99 c6 0a	sta $0ac6,y			sta 	SNDAdjustHigh,y
.d90c	b90c	5a		phy				phy 								; save channel #
.d90d	b90d	20 77 b9	jsr $b977			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.d910	b910	ce b1 09	dec $09b1			dec 	SNDLength 					; reduce the queue length.
.d913	b913	68		pla				pla
.d914	b914	20 18 b9	jsr $b918			jsr 	SNDUpdateNote 				; update channel A
.d917	b917					_SNDCCExit:
.d917	b917	60		rts				rts
.d918	b918					SNDUpdateNote:
.d918	b918	aa		tax				tax 								; so we can access records
.d919	b919	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.d91a	b91a	0a		asl a				asl 	a
.d91b	b91b	0a		asl a				asl 	a
.d91c	b91c	0a		asl a				asl 	a
.d91d	b91d	0a		asl a				asl 	a
.d91e	b91e	8d b0 09	sta $09b0			sta 	SNDChannelBits
.d921	b921	bd be 0a	lda $0abe,x			lda 	SNDTimeLeft,x 				; are we silent
.d924	b924	f0 2e		beq $b954			beq 	_SNDUNIsSilent
.d926	b926	ad b0 09	lda $09b0			lda 	SNDChannelBits 				; push channel bits on stack
.d929	b929	48		pha				pha
.d92a	b92a	bd b2 0a	lda $0ab2,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.d92d	b92d	29 0f		and #$0f			and 	#$0F
.d92f	b92f	0d b0 09	ora $09b0			ora 	SNDChannelBits 				; set channel bits
.d932	b932	09 80		ora #$80			ora 	#$80 						; write to pitch register
.d934	b934	20 c1 b9	jsr $b9c1			jsr 	SNDWritePorts
.d937	b937	bd b6 0a	lda $0ab6,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.d93a	b93a	8d b0 09	sta $09b0			sta 	SNDChannelBits
.d93d	b93d	bd b2 0a	lda $0ab2,x			lda 	SNDPitchLow,x
.d940	b940	4e b0 09	lsr $09b0			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.d943	b943	6a		ror a				ror 	a
.d944	b944	4e b0 09	lsr $09b0			lsr 	SNDChannelBits
.d947	b947	6a		ror a				ror 	a
.d948	b948	4a		lsr a				lsr 	a 							; put in bits 0-5
.d949	b949	4a		lsr a				lsr 	a
.d94a	b94a	20 c1 b9	jsr $b9c1			jsr 	SNDWritePorts 				; write as rest of pitch register
.d94d	b94d	68		pla				pla
.d94e	b94e	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.d950	b950	20 c1 b9	jsr $b9c1			jsr 	SNDWritePorts
.d953	b953	60		rts				rts
.d954	b954					_SNDUNIsSilent:
.d954	b954	ad b0 09	lda $09b0			lda 	SNDChannelBits 				; channel bits
.d957	b957	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.d959	b959	20 c1 b9	jsr $b9c1			jsr 	SNDWritePorts 				; write to the ports
.d95c	b95c	60		rts				rts
.d95d	b95d					SNDFindNextNoteForA:
.d95d	b95d	ac b1 09	ldy $09b1			ldy 	SNDLength 					; queue size into Y
.d960	b960	f0 13		beq $b975			beq 	_SNDFNNFail 				; queue empty.
.d962	b962	a2 00		ldx #$00			ldx 	#0
.d964	b964					_SNDFNNSearch:
.d964	b964	dd b2 09	cmp $09b2,x			cmp 	SNDQueue,x 					; does it match the channel
.d967	b967	38		sec				sec
.d968	b968	f0 0c		beq $b976			beq 	_SNDFNNExit 				; if so exit with CS.
.d96a	b96a	e8		inx				inx 								; next queue slot.
.d96b	b96b	e8		inx				inx
.d96c	b96c	e8		inx				inx
.d96d	b96d	e8		inx				inx
.d96e	b96e	e8		inx				inx
.d96f	b96f	e8		inx				inx
.d970	b970	e8		inx				inx
.d971	b971	e8		inx				inx
.d972	b972	88		dey				dey 								; done the whole queue
.d973	b973	d0 ef		bne $b964			bne 	_SNDFNNSearch 				; no, go back.
.d975	b975					_SNDFNNFail:
.d975	b975	18		clc				clc
.d976	b976					_SNDFNNExit:
.d976	b976	60		rts				rts
.d977	b977					SNDDeleteXFromQueue:
.d977	b977	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.d979	b979	f0 09		beq $b984			beq 	_SNDDXExit
.d97b	b97b	bd ba 09	lda $09ba,x			lda 	SNDQueue+8,x
.d97e	b97e	9d b2 09	sta $09b2,x			sta 	SNDQueue,x
.d981	b981	e8		inx				inx
.d982	b982	80 f3		bra $b977			bra 	SNDDeleteXFromQueue
.d984	b984					_SNDDXExit:
.d984	b984	60		rts				rts
.09b0						SNDChannelBits:
>09b0								.fill 	1
.d985	b985					SNDQueueRequest:
.d985	b985	86 36		stx $36				stx 	zTemp0						; save queue address
.d987	b987	84 37		sty $37				sty 	zTemp0+1
.d989	b989	ae b1 09	ldx $09b1			ldx 	SNDLength 					; queue is full, can't take any more.
.d98c	b98c	e0 20		cpx #$20			cpx 	#SNDQueueSize
.d98e	b98e	f0 21		beq $b9b1			beq 	_SNDQRExit
.d990	b990	29 03		and #$03			and 	#3	 						; channel # and push on stack
.d992	b992	48		pha				pha
.d993	b993	8a		txa				txa  								; get offset in queue buffer/
.d994	b994	0a		asl a				asl 	a
.d995	b995	0a		asl a				asl 	a
.d996	b996	0a		asl a				asl 	a
.d997	b997	aa		tax				tax
.d998	b998	68		pla				pla 								; get back and push again
.d999	b999	48		pha				pha
.d99a	b99a	9d b2 09	sta $09b2,x			sta 	SNDQueue+0,x 				; save the channel #
.d99d	b99d	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.d99f	b99f					_SNDQCopy:
.d99f	b99f	b1 36		lda ($36),y			lda 	(zTemp0),y
.d9a1	b9a1	e8		inx				inx
.d9a2	b9a2	c8		iny				iny
.d9a3	b9a3	9d b2 09	sta $09b2,x			sta 	SNDQueue,x
.d9a6	b9a6	c0 06		cpy #$06			cpy 	#6
.d9a8	b9a8	d0 f5		bne $b99f			bne 	_SNDQCopy
.d9aa	b9aa	ee b1 09	inc $09b1			inc 	SNDLength 					; bump queue length.
.d9ad	b9ad	68		pla				pla 								; get channel # back
.d9ae	b9ae	20 d9 b8	jsr $b8d9			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.d9b1	b9b1					_SNDQRExit:
.d9b1	b9b1	60		rts				rts
.d9b2	b9b2					SNDSilenceChannel:
.d9b2	b9b2	aa		tax				tax 								; zero time left.
.d9b3	b9b3	9e be 0a	stz $0abe,x			stz 	SNDTimeLeft,x
.d9b6	b9b6	0a		asl a				asl 	a 							; shift into position
.d9b7	b9b7	0a		asl a				asl 	a
.d9b8	b9b8	0a		asl a				asl 	a
.d9b9	b9b9	0a		asl a				asl 	a
.d9ba	b9ba	0a		asl a				asl 	a
.d9bb	b9bb	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.d9bd	b9bd	20 c1 b9	jsr $b9c1			jsr 	SNDWritePorts
.d9c0	b9c0	60		rts				rts
.d9c1	b9c1					SNDWritePorts:
.d9c1	b9c1	da		phx				phx 								; save X
.d9c2	b9c2	a6 01		ldx $01				ldx 	1 							; save I/O status
.d9c4	b9c4	64 01		stz $01				stz 	1 							; access I/O page 0
.d9c6	b9c6	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.d9c9	b9c9	8d 10 d6	sta $d610			sta 	$D610
.d9cc	b9cc	86 01		stx $01				stx 	1 							; restore I/O
.d9ce	b9ce	fa		plx				plx 								; restore X
.d9cf	b9cf	60		rts				rts
.d9d0	b9d0					Export_SNDCommand:
.d9d0	b9d0	da		phx				phx 								; save XY
.d9d1	b9d1	5a		phy				phy
.d9d2	b9d2	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.d9d4	b9d4	f0 1d		beq $b9f3			beq 	_SNDInitialise
.d9d6	b9d6	90 28		bcc $ba00			bcc 	_SNDExit
.d9d8	b9d8	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.d9da	b9da	f0 17		beq $b9f3			beq 	_SNDSilence
.d9dc	b9dc	b0 22		bcs $ba00			bcs 	_SNDExit
.d9de	b9de	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.d9e0	b9e0	b0 09		bcs $b9eb			bcs 	_SNDQueryPlay
.d9e2	b9e2	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.d9e4	b9e4	b0 1a		bcs $ba00			bcs 	_SNDExit
.d9e6	b9e6	20 85 b9	jsr $b985			jsr 	SNDQueueRequest
.d9e9	b9e9	80 15		bra $ba00			bra 	_SNDExit
.d9eb	b9eb					_SNDQueryPlay:
.d9eb	b9eb	29 03		and #$03			and 	#3 							; get channel #
.d9ed	b9ed	aa		tax				tax
.d9ee	b9ee	bd be 0a	lda $0abe,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.d9f1	b9f1	80 0d		bra $ba00			bra 	_SNDExit
.d9f3	b9f3					_SNDInitialise:
.d9f3	b9f3					_SNDSilence:
.d9f3	b9f3	9c b1 09	stz $09b1			stz 	SNDLength 					; empty the queue.
.d9f6	b9f6	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.d9f8	b9f8					_SNDSilenceLoop:
.d9f8	b9f8	48		pha				pha
.d9f9	b9f9	20 b2 b9	jsr $b9b2			jsr 	SNDSilenceChannel
.d9fc	b9fc	68		pla				pla
.d9fd	b9fd	3a		dec a				dec 	a
.d9fe	b9fe	10 f8		bpl $b9f8			bpl 	_SNDSilenceLoop
.da00	ba00					_SNDExit:
.da00	ba00	7a		ply				ply
.da01	ba01	fa		plx				plx
.da02	ba02	60		rts				rts
=32						SNDQueueSize = 32 							; number of queue entries
.09b1						SNDLength:
>09b1								.fill 	1
.09b2						SNDQueue:
>09b2								.fill 	SNDQueueSize * 8
.0ab2						SNDPitchLow:
>0ab2								.fill 	4
.0ab6						SNDPitchHigh:
>0ab6								.fill 	4
.0aba						SNDVolume:
>0aba								.fill 	4
.0abe						SNDTimeLeft:
>0abe								.fill 	4
.0ac2						SNDAdjustLow:
>0ac2								.fill 	4
.0ac6						SNDAdjustHigh:
>0ac6								.fill 	4
.da03	ba03					Export_SNDUpdate:
.da03	ba03					PagedSNDUpdate:
.da03	ba03	ad be 0a	lda $0abe			lda 	SNDTimeLeft+0 				; look at time remaining
.da06	ba06	f0 05		beq $ba0d			beq 	_SNDUNot0 					; not playing
.da08	ba08	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.da0a	ba0a	20 2c ba	jsr $ba2c			jsr 	SNDUpdateChannel 			; update it.
.da0d	ba0d					_SNDUNot0:
.da0d	ba0d	ad bf 0a	lda $0abf			lda 	SNDTimeLeft+1
.da10	ba10	f0 05		beq $ba17			beq 	_SNDUNot1
.da12	ba12	a2 01		ldx #$01			ldx 	#1
.da14	ba14	20 2c ba	jsr $ba2c			jsr 	SNDUpdateChannel
.da17	ba17					_SNDUNot1:
.da17	ba17	ad c0 0a	lda $0ac0			lda 	SNDTimeLeft+2
.da1a	ba1a	f0 05		beq $ba21			beq 	_SNDUNot2
.da1c	ba1c	a2 02		ldx #$02			ldx 	#2
.da1e	ba1e	20 2c ba	jsr $ba2c			jsr 	SNDUpdateChannel
.da21	ba21					_SNDUNot2:
.da21	ba21	ad c1 0a	lda $0ac1			lda 	SNDTimeLeft+3
.da24	ba24	f0 05		beq $ba2b			beq 	_SNDUNot3
.da26	ba26	a2 03		ldx #$03			ldx 	#3
.da28	ba28	20 2c ba	jsr $ba2c			jsr 	SNDUpdateChannel
.da2b	ba2b					_SNDUNot3:
.da2b	ba2b	60		rts				rts
.da2c	ba2c					SNDUpdateChannel:
.da2c	ba2c	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.da2e	ba2e	f0 2c		beq $ba5c			beq 	_SNDUCExit
.da30	ba30	3a		dec a				dec 	a 							; decrement and update timer
.da31	ba31	9d be 0a	sta $0abe,x			sta 	SNDTimeLeft,x
.da34	ba34	f0 1d		beq $ba53			beq 	_SNDUCUpdate 				; if zero, silence channel
.da36	ba36	bd c2 0a	lda $0ac2,x			lda 	SNDAdjustLow,x 				; adjust ?
.da39	ba39	1d c6 0a	ora $0ac6,x			ora 	SNDAdjustHigh,x
.da3c	ba3c	f0 1e		beq $ba5c			beq 	_SNDUCExit 					; if zero carry on at current tone.
.da3e	ba3e	18		clc				clc 								; add adjust, forcing into a 10 bit range
.da3f	ba3f	bd b2 0a	lda $0ab2,x			lda 	SNDPitchLow,x
.da42	ba42	7d c2 0a	adc $0ac2,x			adc 	SNDAdjustLow,x
.da45	ba45	9d b2 0a	sta $0ab2,x			sta 	SNDPitchLow,x
.da48	ba48	bd b6 0a	lda $0ab6,x			lda 	SNDPitchHigh,x
.da4b	ba4b	7d c6 0a	adc $0ac6,x			adc 	SNDAdjustHigh,x
.da4e	ba4e	29 03		and #$03			and 	#3
.da50	ba50	9d b6 0a	sta $0ab6,x			sta 	SNDPitchHigh,x
.da53	ba53					_SNDUCUpdate:
.da53	ba53	8a		txa				txa 								; which channel.
.da54	ba54	48		pha				pha
.da55	ba55	20 18 b9	jsr $b918			jsr 	SNDUpdateNote 				; update the current note
.da58	ba58	68		pla				pla
.da59	ba59	20 d9 b8	jsr $b8d9			jsr 	SNDCheckChannel 			; more to do ?
.da5c	ba5c					_SNDUCExit:
.da5c	ba5c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/.build/kernel.module.asm

=1						kernelIntegrated=1

;******  Return to file: _basic.asm


;******  Processing file: ../modules/hardware/header/.build/headerdata.dat

=14						Header_Height = 14
=255						Header_RLE = 255
.e000	a000					Header_jattrs:
>e000	a000	ff f2 58 f2 ff d8 07 d8			.byte	255,242,88,242,255,216,7,216,255,242,2,242,255,216,6,216,255,242,2,242,255,216,8,216,255,242,2,242,255,216,6,216,255,242,9,242,210,210,242,242,255,210,7,210,255,242,17,242,104,104,255,242,7,242,104,104,255,242,4,242,104,104,242,242,104,104,255,242,8,242,104,104,255,242,4,242,104,104,255,242,8,242,210,210,242,242,210,210,255,242,4,242,210,210,255,242,16,242,232,232,255,242,14,242,232,232,242,242,232,232,255,242,8,242,232,232,255,242,15,242,210,210,242,242,210,210,255,242,4,242,210,210,255,242,16,242,255,56,5,56,255,242,4,242,255,56,6,56,255,242,2,242,255,56,7,56,255,242,2,242,255,56,7,56,255,242,9,242,210,210,242,242,255,210,7,210,255,242,17,242,120,120,255,242,7,242,120,120,255,242,15,242,120,120,242,242,120,120,255,242,4,242,120,120,242,242,210,210,255,242,4,242,210,210,242,242,210,210,255,242,2,242,210,210,255,242,18,242,168,168,255,242,7,242,168,168,255,242,8,242,168,168,255,242,4,242,168,168,242,242,168,168,255,242,4,242,168,168,242,242,210,210,255,242,4,242,210,210,242,242,210,210,255,242,3,242,210,210,255,242,17,242,72,72,255,242,7,242,255,72,8,72,255,242,2,242,255,72,6,72,255,242,3,242,255,72,6,72,255,242,3,242,255,210,4,210,209,210,255,242,2,242,210,210,255,242,4,242,210,210,255,242,87,242,255,114,80,114,255,226,27,226,114,255,146,3,146,145,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,3,146,145,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,3,146,145,255,114,18,114,255,194,24,194,255,114,80,114,255,0
>e008	a008	ff f2 02 f2 ff d8 06 d8 ff f2 02 f2 ff d8 08 d8
>e018	a018	ff f2 02 f2 ff d8 06 d8 ff f2 09 f2 d2 d2 f2 f2
>e028	a028	ff d2 07 d2 ff f2 11 f2 68 68 ff f2 07 f2 68 68
>e038	a038	ff f2 04 f2 68 68 f2 f2 68 68 ff f2 08 f2 68 68
>e048	a048	ff f2 04 f2 68 68 ff f2 08 f2 d2 d2 f2 f2 d2 d2
>e058	a058	ff f2 04 f2 d2 d2 ff f2 10 f2 e8 e8 ff f2 0e f2
>e068	a068	e8 e8 f2 f2 e8 e8 ff f2 08 f2 e8 e8 ff f2 0f f2
>e078	a078	d2 d2 f2 f2 d2 d2 ff f2 04 f2 d2 d2 ff f2 10 f2
>e088	a088	ff 38 05 38 ff f2 04 f2 ff 38 06 38 ff f2 02 f2
>e098	a098	ff 38 07 38 ff f2 02 f2 ff 38 07 38 ff f2 09 f2
>e0a8	a0a8	d2 d2 f2 f2 ff d2 07 d2 ff f2 11 f2 78 78 ff f2
>e0b8	a0b8	07 f2 78 78 ff f2 0f f2 78 78 f2 f2 78 78 ff f2
>e0c8	a0c8	04 f2 78 78 f2 f2 d2 d2 ff f2 04 f2 d2 d2 f2 f2
>e0d8	a0d8	d2 d2 ff f2 02 f2 d2 d2 ff f2 12 f2 a8 a8 ff f2
>e0e8	a0e8	07 f2 a8 a8 ff f2 08 f2 a8 a8 ff f2 04 f2 a8 a8
>e0f8	a0f8	f2 f2 a8 a8 ff f2 04 f2 a8 a8 f2 f2 d2 d2 ff f2
>e108	a108	04 f2 d2 d2 f2 f2 d2 d2 ff f2 03 f2 d2 d2 ff f2
>e118	a118	11 f2 48 48 ff f2 07 f2 ff 48 08 48 ff f2 02 f2
>e128	a128	ff 48 06 48 ff f2 03 f2 ff 48 06 48 ff f2 03 f2
>e138	a138	ff d2 04 d2 d1 d2 ff f2 02 f2 d2 d2 ff f2 04 f2
>e148	a148	d2 d2 ff f2 57 f2 ff 72 50 72 ff e2 1b e2 72 ff
>e158	a158	92 03 92 91 ff 72 12 72 ff c2 18 c2 72 72 ff e2
>e168	a168	1b e2 72 ff 92 03 92 91 ff 72 12 72 ff c2 18 c2
>e178	a178	72 72 ff e2 1b e2 72 ff 92 03 92 91 ff 72 12 72
>e188	a188	ff c2 18 c2 ff 72 50 72 ff 00
.e192	a192					Header_jchars:
>e192	a192	ff 20 58 20 ff 08 07 08			.byte	255,32,88,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,9,32,252,252,32,32,255,252,7,252,255,32,17,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,255,32,8,32,252,252,32,32,252,252,255,32,4,32,252,252,255,32,16,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,15,32,252,252,32,32,252,252,255,32,4,32,252,252,255,32,16,32,255,8,5,8,255,32,4,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,7,8,255,32,9,32,252,252,32,32,255,252,7,252,255,32,17,32,8,8,255,32,7,32,8,8,255,32,15,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,252,252,255,32,4,32,252,252,32,32,252,252,255,32,2,32,252,252,255,32,18,32,8,8,255,32,7,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,252,252,255,32,4,32,252,252,32,32,252,252,255,32,3,32,252,252,255,32,17,32,8,8,255,32,7,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,3,32,255,8,6,8,255,32,3,32,255,252,6,252,255,32,2,32,252,252,255,32,4,32,252,252,255,32,87,32,160,255,150,27,150,155,255,150,22,150,155,255,150,24,150,161,130,72,97,114,100,119,97,114,101,255,32,19,32,130,215,50,48,50,51,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,45,106,114,255,32,2,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,215,50,48,50,51,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,215,50,48,50,51,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,162,255,150,27,150,157,255,150,22,150,157,255,150,24,150,163,255,0
>e19a	a19a	ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08 08 08
>e1aa	a1aa	ff 20 02 20 ff 08 06 08 ff 20 09 20 fc fc 20 20
>e1ba	a1ba	ff fc 07 fc ff 20 11 20 08 08 ff 20 07 20 08 08
>e1ca	a1ca	ff 20 04 20 08 08 20 20 08 08 ff 20 08 20 08 08
>e1da	a1da	ff 20 04 20 08 08 ff 20 08 20 fc fc 20 20 fc fc
>e1ea	a1ea	ff 20 04 20 fc fc ff 20 10 20 08 08 ff 20 0e 20
>e1fa	a1fa	08 08 20 20 08 08 ff 20 08 20 08 08 ff 20 0f 20
>e20a	a20a	fc fc 20 20 fc fc ff 20 04 20 fc fc ff 20 10 20
>e21a	a21a	ff 08 05 08 ff 20 04 20 ff 08 06 08 ff 20 02 20
>e22a	a22a	ff 08 07 08 ff 20 02 20 ff 08 07 08 ff 20 09 20
>e23a	a23a	fc fc 20 20 ff fc 07 fc ff 20 11 20 08 08 ff 20
>e24a	a24a	07 20 08 08 ff 20 0f 20 08 08 20 20 08 08 ff 20
>e25a	a25a	04 20 08 08 20 20 fc fc ff 20 04 20 fc fc 20 20
>e26a	a26a	fc fc ff 20 02 20 fc fc ff 20 12 20 08 08 ff 20
>e27a	a27a	07 20 08 08 ff 20 08 20 08 08 ff 20 04 20 08 08
>e28a	a28a	20 20 08 08 ff 20 04 20 08 08 20 20 fc fc ff 20
>e29a	a29a	04 20 fc fc 20 20 fc fc ff 20 03 20 fc fc ff 20
>e2aa	a2aa	11 20 08 08 ff 20 07 20 ff 08 08 08 ff 20 02 20
>e2ba	a2ba	ff 08 06 08 ff 20 03 20 ff 08 06 08 ff 20 03 20
>e2ca	a2ca	ff fc 06 fc ff 20 02 20 fc fc ff 20 04 20 fc fc
>e2da	a2da	ff 20 57 20 a0 ff 96 1b 96 9b ff 96 16 96 9b ff
>e2ea	a2ea	96 18 96 a1 82 48 61 72 64 77 61 72 65 ff 20 13
>e2fa	a2fa	20 82 d7 32 30 32 33 20 53 74 65 66 61 6e 79 20
>e30a	a30a	41 6c 6c 61 69 72 65 20 20 82 63 32 35 36 66 6f
>e31a	a31a	65 6e 69 78 2e 63 6f 6d 2f 66 32 35 36 2d 6a 72
>e32a	a32a	ff 20 02 20 82 82 4d 69 63 72 6f 4b 65 72 6e 65
>e33a	a33a	6c ff 20 10 20 82 d7 32 30 32 33 20 4a 65 73 73
>e34a	a34a	69 65 20 4f 62 65 72 72 65 75 74 65 72 82 47 61
>e35a	a35a	64 67 65 74 40 48 61 63 6b 77 72 65 6e 63 68 4c
>e36a	a36a	61 62 73 2e 63 6f 6d 82 82 53 75 70 65 72 42 41
>e37a	a37a	53 49 43 ff 20 11 20 82 d7 32 30 32 33 20 50 61
>e38a	a38a	75 6c 20 52 6f 62 73 6f 6e ff 20 05 20 82 50 61
>e39a	a39a	75 6c 40 52 6f 62 73 6f 6e 73 2e 6f 72 67 2e 75
>e3aa	a3aa	6b ff 20 05 20 82 a2 ff 96 1b 96 9d ff 96 16 96
>e3ba	a3ba	9d ff 96 18 96 a3 ff 00
.e3c2	a3c2					Header_kattrs:
>e3c2	a3c2	ff f2 5e f2 ff d8 07 d8			.byte	255,242,94,242,255,216,7,216,255,242,2,242,255,216,6,216,255,242,2,242,255,216,8,216,255,242,2,242,255,216,6,216,255,242,2,242,210,210,255,242,3,242,210,210,255,242,28,242,104,104,255,242,7,242,104,104,255,242,4,242,104,104,242,242,104,104,255,242,8,242,104,104,255,242,4,242,104,104,242,242,210,210,255,242,2,242,210,210,255,242,29,242,232,232,255,242,14,242,232,232,242,242,232,232,255,242,8,242,232,232,255,242,8,242,210,210,242,242,210,210,255,242,30,242,255,56,5,56,255,242,4,242,255,56,6,56,255,242,2,242,255,56,7,56,255,242,2,242,255,56,7,56,255,242,2,242,255,210,4,210,255,242,31,242,120,120,255,242,7,242,120,120,255,242,15,242,113,113,242,242,113,113,255,242,4,242,113,113,242,242,210,210,242,242,210,210,255,242,30,242,168,168,255,242,7,242,168,168,255,242,8,242,168,168,255,242,4,242,168,168,242,242,168,168,255,242,4,242,168,168,242,242,210,210,255,242,2,242,210,210,255,242,29,242,72,72,255,242,7,242,255,72,8,72,255,242,2,242,255,72,6,72,255,242,3,242,255,72,6,72,255,242,2,242,210,210,255,242,3,242,210,210,255,242,93,242,255,114,80,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,255,114,80,114,255,0
>e3ca	a3ca	ff f2 02 f2 ff d8 06 d8 ff f2 02 f2 ff d8 08 d8
>e3da	a3da	ff f2 02 f2 ff d8 06 d8 ff f2 02 f2 d2 d2 ff f2
>e3ea	a3ea	03 f2 d2 d2 ff f2 1c f2 68 68 ff f2 07 f2 68 68
>e3fa	a3fa	ff f2 04 f2 68 68 f2 f2 68 68 ff f2 08 f2 68 68
>e40a	a40a	ff f2 04 f2 68 68 f2 f2 d2 d2 ff f2 02 f2 d2 d2
>e41a	a41a	ff f2 1d f2 e8 e8 ff f2 0e f2 e8 e8 f2 f2 e8 e8
>e42a	a42a	ff f2 08 f2 e8 e8 ff f2 08 f2 d2 d2 f2 f2 d2 d2
>e43a	a43a	ff f2 1e f2 ff 38 05 38 ff f2 04 f2 ff 38 06 38
>e44a	a44a	ff f2 02 f2 ff 38 07 38 ff f2 02 f2 ff 38 07 38
>e45a	a45a	ff f2 02 f2 ff d2 04 d2 ff f2 1f f2 78 78 ff f2
>e46a	a46a	07 f2 78 78 ff f2 0f f2 71 71 f2 f2 71 71 ff f2
>e47a	a47a	04 f2 71 71 f2 f2 d2 d2 f2 f2 d2 d2 ff f2 1e f2
>e48a	a48a	a8 a8 ff f2 07 f2 a8 a8 ff f2 08 f2 a8 a8 ff f2
>e49a	a49a	04 f2 a8 a8 f2 f2 a8 a8 ff f2 04 f2 a8 a8 f2 f2
>e4aa	a4aa	d2 d2 ff f2 02 f2 d2 d2 ff f2 1d f2 48 48 ff f2
>e4ba	a4ba	07 f2 ff 48 08 48 ff f2 02 f2 ff 48 06 48 ff f2
>e4ca	a4ca	03 f2 ff 48 06 48 ff f2 02 f2 d2 d2 ff f2 03 f2
>e4da	a4da	d2 d2 ff f2 5d f2 ff 72 50 72 ff e2 1b e2 72 ff
>e4ea	a4ea	92 04 92 ff 72 12 72 ff c2 18 c2 72 72 ff e2 1b
>e4fa	a4fa	e2 72 ff 92 04 92 ff 72 12 72 ff c2 18 c2 72 72
>e50a	a50a	ff e2 1b e2 72 ff 92 04 92 ff 72 12 72 ff c2 18
>e51a	a51a	c2 ff 72 50 72 ff 00
.e521	a521					Header_kchars:
>e521	a521	ff 20 5e 20 ff 08 07 08			.byte	255,32,94,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,2,32,180,180,255,32,3,32,180,180,255,32,28,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,180,180,255,32,2,32,180,180,255,32,29,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,8,32,180,180,32,32,180,180,255,32,30,32,255,8,5,8,255,32,4,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,7,8,255,32,2,32,255,180,4,180,255,32,31,32,8,8,255,32,7,32,8,8,255,32,15,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,180,180,32,32,180,180,255,32,30,32,8,8,255,32,7,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,180,180,255,32,2,32,180,180,255,32,29,32,8,8,255,32,7,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,3,32,255,8,6,8,255,32,2,32,180,180,255,32,3,32,180,180,255,32,93,32,188,255,150,27,150,155,255,150,22,150,155,255,150,24,150,189,130,72,97,114,100,119,97,114,101,255,32,19,32,130,215,50,48,50,51,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,45,106,114,255,32,2,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,215,50,48,50,51,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,215,50,48,50,51,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,190,255,150,27,150,157,255,150,22,150,157,255,150,24,150,191,255,0
>e529	a529	ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08 08 08
>e539	a539	ff 20 02 20 ff 08 06 08 ff 20 02 20 b4 b4 ff 20
>e549	a549	03 20 b4 b4 ff 20 1c 20 08 08 ff 20 07 20 08 08
>e559	a559	ff 20 04 20 08 08 20 20 08 08 ff 20 08 20 08 08
>e569	a569	ff 20 04 20 08 08 20 20 b4 b4 ff 20 02 20 b4 b4
>e579	a579	ff 20 1d 20 08 08 ff 20 0e 20 08 08 20 20 08 08
>e589	a589	ff 20 08 20 08 08 ff 20 08 20 b4 b4 20 20 b4 b4
>e599	a599	ff 20 1e 20 ff 08 05 08 ff 20 04 20 ff 08 06 08
>e5a9	a5a9	ff 20 02 20 ff 08 07 08 ff 20 02 20 ff 08 07 08
>e5b9	a5b9	ff 20 02 20 ff b4 04 b4 ff 20 1f 20 08 08 ff 20
>e5c9	a5c9	07 20 08 08 ff 20 0f 20 08 08 20 20 08 08 ff 20
>e5d9	a5d9	04 20 08 08 20 20 b4 b4 20 20 b4 b4 ff 20 1e 20
>e5e9	a5e9	08 08 ff 20 07 20 08 08 ff 20 08 20 08 08 ff 20
>e5f9	a5f9	04 20 08 08 20 20 08 08 ff 20 04 20 08 08 20 20
>e609	a609	b4 b4 ff 20 02 20 b4 b4 ff 20 1d 20 08 08 ff 20
>e619	a619	07 20 ff 08 08 08 ff 20 02 20 ff 08 06 08 ff 20
>e629	a629	03 20 ff 08 06 08 ff 20 02 20 b4 b4 ff 20 03 20
>e639	a639	b4 b4 ff 20 5d 20 bc ff 96 1b 96 9b ff 96 16 96
>e649	a649	9b ff 96 18 96 bd 82 48 61 72 64 77 61 72 65 ff
>e659	a659	20 13 20 82 d7 32 30 32 33 20 53 74 65 66 61 6e
>e669	a669	79 20 41 6c 6c 61 69 72 65 20 20 82 63 32 35 36
>e679	a679	66 6f 65 6e 69 78 2e 63 6f 6d 2f 66 32 35 36 2d
>e689	a689	6a 72 ff 20 02 20 82 82 4d 69 63 72 6f 4b 65 72
>e699	a699	6e 65 6c ff 20 10 20 82 d7 32 30 32 33 20 4a 65
>e6a9	a6a9	73 73 69 65 20 4f 62 65 72 72 65 75 74 65 72 82
>e6b9	a6b9	47 61 64 67 65 74 40 48 61 63 6b 77 72 65 6e 63
>e6c9	a6c9	68 4c 61 62 73 2e 63 6f 6d 82 82 53 75 70 65 72
>e6d9	a6d9	42 41 53 49 43 ff 20 11 20 82 d7 32 30 32 33 20
>e6e9	a6e9	50 61 75 6c 20 52 6f 62 73 6f 6e ff 20 05 20 82
>e6f9	a6f9	50 61 75 6c 40 52 6f 62 73 6f 6e 73 2e 6f 72 67
>e709	a709	2e 75 6b ff 20 05 20 82 be ff 96 1b 96 9d ff 96
>e719	a719	16 96 9d ff 96 18 96 bf ff 00
.e723	a723					Header_Palette:
>e723	a723	00 00 00 00				.dword $000000
>e727	a727	66 66 66 00				.dword $666666
>e72b	a72b	aa 00 00 00				.dword $0000aa
>e72f	a72f	00 aa 00 00				.dword $00aa00
>e733	a733	ea 41 c0 00				.dword $c041ea
>e737	a737	00 48 87 00				.dword $874800
>e73b	a73b	00 9c ff 00				.dword $ff9c00
>e73f	a73f	ff db 57 00				.dword $57dbff
>e743	a743	28 3f 3f 00				.dword $3f3f28
>e747	a747	8a aa aa 00				.dword $aaaa8a
>e74b	a74b	ff 55 55 00				.dword $5555ff
>e74f	a74f	55 ff 55 00				.dword $55ff55
>e753	a753	ed 8d ff 00				.dword $ff8ded
>e757	a757	00 00 ff 00				.dword $ff0000
>e75b	a75b	55 ff ff 00				.dword $ffff55
>e75f	a75f	ff ff ff 00				.dword $ffffff
>e763	a763	ff ff ff 00				.dword $ffffff
>e767	a767	ff ff ff 00				.dword $ffffff

;******  Return to file: _basic.asm


;******  End of listing
