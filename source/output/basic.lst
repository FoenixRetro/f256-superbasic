
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Mon Dec  5 17:06:44 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$28000					 SOURCE_ADDRESS=$28000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	253
.0627					numberBuffer:
>0627							.fill 	34
.0649					decimalBuffer:
>0649							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_DEEKLPAREN                       = $87; $87 DEEK(
=$88					KWD_EVENTLPAREN                      = $88; $88 EVENT(
=$89					KWD_FALSE                            = $89; $89 FALSE
=$8a					KWD_FRACLPAREN                       = $8a; $8a FRAC(
=$8b					KWD_HITLPAREN                        = $8b; $8b HIT(
=$8c					KWD_INTLPAREN                        = $8c; $8c INT(
=$8d					KWD_ISVALLPAREN                      = $8d; $8d ISVAL(
=$8e					KWD_JOYBLPAREN                       = $8e; $8e JOYB(
=$8f					KWD_JOYXLPAREN                       = $8f; $8f JOYX(
=$90					KWD_JOYYLPAREN                       = $90; $90 JOYY(
=$91					KWD_LEFTDOLLARLPAREN                 = $91; $91 LEFT$(
=$92					KWD_LENLPAREN                        = $92; $92 LEN(
=$93					KWD_MAXLPAREN                        = $93; $93 MAX(
=$94					KWD_MIDDOLLARLPAREN                  = $94; $94 MID$(
=$95					KWD_MINLPAREN                        = $95; $95 MIN(
=$96					KWD_NOTLPAREN                        = $96; $96 NOT(
=$97					KWD_PEEKLPAREN                       = $97; $97 PEEK(
=$98					KWD_PLAYINGLPAREN                    = $98; $98 PLAYING(
=$99					KWD_RANDOMLPAREN                     = $99; $99 RANDOM(
=$9a					KWD_RIGHTDOLLARLPAREN                = $9a; $9a RIGHT$(
=$9b					KWD_RNDLPAREN                        = $9b; $9b RND(
=$9c					KWD_SGNLPAREN                        = $9c; $9c SGN(
=$9d					KWD_SPCLPAREN                        = $9d; $9d SPC(
=$9e					KWD_STRDOLLARLPAREN                  = $9e; $9e STR$(
=$9f					KWD_TIMERLPAREN                      = $9f; $9f TIMER(
=$a0					KWD_TRUE                             = $a0; $a0 TRUE
=$a1					KWD_VALLPAREN                        = $a1; $a1 VAL(
=$a2					KWD_FOR                              = $a2; $a2 FOR
=$a3					KWD_IF                               = $a3; $a3 IF
=$a4					KWD_PROC                             = $a4; $a4 PROC
=$a5					KWD_REPEAT                           = $a5; $a5 REPEAT
=$a6					KWD_WHILE                            = $a6; $a6 WHILE
=$a7					KWD_ENDIF                            = $a7; $a7 ENDIF
=$a8					KWD_ENDPROC                          = $a8; $a8 ENDPROC
=$a9					KWD_NEXT                             = $a9; $a9 NEXT
=$aa					KWD_THEN                             = $aa; $aa THEN
=$ab					KWD_UNTIL                            = $ab; $ab UNTIL
=$ac					KWD_WEND                             = $ac; $ac WEND
=$ad					KWD_BY                               = $ad; $ad BY
=$ae					KWD_CALL                             = $ae; $ae CALL
=$af					KWD_CIRCLE                           = $af; $af CIRCLE
=$b0					KWD_CLEAR                            = $b0; $b0 CLEAR
=$b1					KWD_CLS                              = $b1; $b1 CLS
=$b2					KWD_COLOR                            = $b2; $b2 COLOR
=$b3					KWD_COLOUR                           = $b3; $b3 COLOUR
=$b4					KWD_DATA                             = $b4; $b4 DATA
=$b5					KWD_DIM                              = $b5; $b5 DIM
=$b6					KWD_DOKE                             = $b6; $b6 DOKE
=$b7					KWD_DOWNTO                           = $b7; $b7 DOWNTO
=$b8					KWD_ELSE                             = $b8; $b8 ELSE
=$b9					KWD_FROM                             = $b9; $b9 FROM
=$ba					KWD_GFX                              = $ba; $ba GFX
=$bb					KWD_GOSUB                            = $bb; $bb GOSUB
=$bc					KWD_GOTO                             = $bc; $bc GOTO
=$bd					KWD_HERE                             = $bd; $bd HERE
=$be					KWD_IMAGE                            = $be; $be IMAGE
=$bf					KWD_INPUT                            = $bf; $bf INPUT
=$c0					KWD_LET                              = $c0; $c0 LET
=$c1					KWD_LINE                             = $c1; $c1 LINE
=$c2					KWD_LOCAL                            = $c2; $c2 LOCAL
=$c3					KWD_OFF                              = $c3; $c3 OFF
=$c4					KWD_ON                               = $c4; $c4 ON
=$c5					KWD_OUTLINE                          = $c5; $c5 OUTLINE
=$c6					KWD_PALETTE                          = $c6; $c6 PALETTE
=$c7					KWD_PLOT                             = $c7; $c7 PLOT
=$c8					KWD_POKE                             = $c8; $c8 POKE
=$c9					KWD_PRINT                            = $c9; $c9 PRINT
=$ca					KWD_READ                             = $ca; $ca READ
=$cb					KWD_RECT                             = $cb; $cb RECT
=$cc					KWD_REM                              = $cc; $cc REM
=$cd					KWD_RETURN                           = $cd; $cd RETURN
=$ce					KWD_SOLID                            = $ce; $ce SOLID
=$cf					KWD_SOUND                            = $cf; $cf SOUND
=$d0					KWD_SPRITE                           = $d0; $d0 SPRITE
=$d1					KWD_TEXT                             = $d1; $d1 TEXT
=$d2					KWD_TO                               = $d2; $d2 TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a2					KWC_FIRST_STRUCTURE = $a2
=$a7					KWC_FIRST_STRUCTURE_DEC = $a7
=$ac					KWC_LAST_STRUCTURE = $ac
=$83					KWC_FIRST_UNARY = $83
=$a1					KWC_LAST_UNARY = $a1

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c e4 a7	jmp $a7e4		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c 7d aa	jmp $aa7d		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c b3 aa	jmp $aab3		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c d9 aa	jmp $aad9		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c dc aa	jmp $aadc		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c 93 a9	jmp $a993		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c 77 ab	jmp $ab77		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 5c be	jmp $be5c		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c 8f be	jmp $be8f		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 52 b8	jmp $b852		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c e6 ba	jmp $bae6		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; added to stop initial break bug.
.802a	a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.802c	09 80		ora #$80			ora 	#$80
.802e	85 00		sta $00				sta 	0
.8030	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.8033	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.8035	aa		tax				tax
.8036	a8		tay				tay
.8037	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.803a	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.803c	20 18 80	jsr $8018			jsr 	SNDCommand
.803f	a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.8041	a9 4f		lda #$4f			lda 	#Prompt & $FF
.8043	20 50 8f	jsr $8f50			jsr 	PrintStringXA
.8046	20 2c 8a	jsr $8a2c			jsr 	NewProgram 					; erase current program
.8049	4c d5 83	jmp $83d5			jmp 	WarmStart					; make same size.
.804c	4c d5 83	jmp $83d5			jmp 	WarmStart
>804f	36 35 30 32 20 53 75 70		Prompt:	.text 	"6502 SuperBASIC"
>8057	65 72 42 41 53 49 43

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>805e	52 65 6c 65 61 73 65 20			.text "Release Alpha 12 (05-Dec-22). "
>8066	41 6c 70 68 61 20 31 32 20 28 30 35 2d 44 65 63
>8076	2d 32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>807c	0d						.byte  	13
>807d	43 6f 70 79 72 69 67 68				.text 	"Copyright 2022 Paul Robson",13
>8085	74 20 32 30 32 32 20 50 61 75 6c 20 52 6f 62 73
>8095	6f 6e 0d
>8098	50 61 75 6c 40 52 6f 62				.text  	"Paul@Robsons.org.uk",13
>80a0	73 6f 6e 73 2e 6f 72 67 2e 75 6b 0d
>80ac	0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.80af					AssembleGroup1:
.80af	a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.80b1	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.80b4	80 02		bra $80b8			bra 	AsmGroup12
.80b6					AssembleGroup2:
.80b6	a9 00		lda #$00			lda 	#$00 						; flag for group 2
.80b8					AsmGroup12:
.80b8	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.80bb	68		pla				pla 								; pop the return address to access the information following.
.80bc	fa		plx				plx
.80bd	20 44 81	jsr $8144			jsr 	AccessParameters 			; get opcode and save as base
.80c0	8d 24 04	sta $0424			sta 	BaseOpcode
.80c3	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.80c6	d0 08		bne $80d0			bne 	_AG12HaveMask
.80c8	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.80ca	20 4c 81	jsr $814c			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.80cd	8d 25 04	sta $0425			sta 	ModeMask
.80d0					_AG12HaveMask:
.80d0	20 80 82	jsr $8280			jsr 	TypeAndCalculateOperand 	; get zero page type
.80d3	da		phx				phx 								; save found address mode
.80d4	20 b0 81	jsr $81b0			jsr 	AssembleModeX
.80d7	fa		plx				plx  								; restore address mode
.80d8	b0 0b		bcs $80e5			bcs 	_AG12Exit
.80da	20 e6 80	jsr $80e6			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.80dd	20 b0 81	jsr $81b0			jsr 	AssembleModeX
.80e0	b0 03		bcs $80e5			bcs 	_AG12Exit
.80e2	4c 97 9f	jmp $9f97			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80e5					_AG12Exit:
.80e5	60		rts				rts
.80e6					PromoteToAbsolute:
.80e6	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80e8	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80ea	f0 19		beq $8105			beq 	_PTADo
.80ec	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80ee	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80f0	f0 13		beq $8105			beq 	_PTADo
.80f2	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80f4	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80f6	f0 0d		beq $8105			beq 	_PTADo
.80f8	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80fa	e0 d1		cpx #$d1			cpx 	#AM_IND
.80fc	f0 07		beq $8105			beq 	_PTADo
.80fe	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8100	e0 c0		cpx #$c0			cpx 	#AM_INDX
.8102	f0 01		beq $8105			beq 	_PTADo
.8104	60		rts				rts
.8105					_PTADo:
.8105	aa		tax				tax
.8106	60		rts				rts
.8107					AssembleGroup3:
.8107	68		pla				pla 								; get parameters, which is just the opcode.
.8108	fa		plx				plx
.8109	20 44 81	jsr $8144			jsr 	AccessParameters 			; get and output opcode
.810c	20 5c 81	jsr $815c			jsr 	AssemblerWriteByte
.810f	20 e4 82	jsr $82e4			jsr 	CalculateOperand 			; get a 16 bit operand
.8112	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.8114	38		sec				sec
.8115	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.8118	48		pha				pha 								; LSB in A
.8119	a5 60		lda $60				lda 	NSMantissa1
.811b	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.811e	aa		tax				tax 								; MSB in X
.811f	68		pla				pla
.8120	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.8121	69 7f		adc #$7f			adc 	#$7F
.8123	90 01		bcc $8126			bcc 	_AG3NoCarry
.8125	e8		inx				inx
.8126					_AG3NoCarry:
.8126	38		sec				sec 								; fix back and write out anyways.
.8127	e9 80		sbc #$80			sbc 	#$80
.8129	20 5c 81	jsr $815c			jsr 	AssemblerWriteByte
.812c	e0 00		cpx #$00			cpx 	#0 							; was it in range
.812e	f0 0a		beq $813a			beq 	_AG3Exit
.8130	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.8133	29 01		and #$01			and 	#1
.8135	f0 03		beq $813a			beq 	_AG3Exit
.8137	4c 9c 9f	jmp $9f9c			jmp 	RangeError 					; no, branch is out of range
.813a					_AG3Exit:
.813a	60		rts				rts
.813b					AssembleGroup4:
.813b	68		pla				pla 								; pop address
.813c	fa		plx				plx
.813d	20 44 81	jsr $8144			jsr 	AccessParameters 			; access and get first
.8140	20 5c 81	jsr $815c			jsr 	AssemblerWriteByte 			; output it.
.8143	60		rts				rts
.8144					AccessParameters:
.8144	8d 21 04	sta $0421			sta 	ParamStart
.8147	8e 22 04	stx $0422			stx 	ParamStart+1
.814a	a9 01		lda #$01			lda 	#1
.814c					GetParameter:
.814c	5a		phy				phy
.814d	a8		tay				tay
.814e	ad 21 04	lda $0421			lda 	ParamStart
.8151	85 36		sta $36				sta 	zTemp0
.8153	ad 22 04	lda $0422			lda 	ParamStart+1
.8156	85 37		sta $37				sta 	zTemp0+1
.8158	b1 36		lda ($36),y			lda 	(zTemp0),y
.815a	7a		ply				ply
.815b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.815c					AssemblerWriteByte:
.815c	48		pha			pha
.815d	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8160	29 02		and #$02		and 	#2
.8162	f0 1b		beq $817f		beq 	_AWBNoPrint
.8164	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.8167	20 9a 81	jsr $819a		jsr 	PrintHex
.816a	ad 1e 04	lda $041e		lda		AssemblerAddress
.816d	20 9a 81	jsr $819a		jsr 	PrintHex
.8170	a9 20		lda #$20		lda 	#' '
.8172	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8175	68		pla			pla 									; print byte
.8176	48		pha			pha
.8177	20 9a 81	jsr $819a		jsr 	PrintHex
.817a	a9 0d		lda #$0d		lda 	#13
.817c	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.817f					_AWBNoPrint:
.817f	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8182	85 36		sta $36			sta 	zTemp0
.8184	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.8187	f0 0e		beq $8197		beq 	_AWBRange
.8189	85 37		sta $37			sta 	zTemp0+1
.818b	68		pla			pla 									; write byte out
.818c	92 36		sta ($36)		sta 	(zTemp0)
.818e	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8191	d0 03		bne $8196		bne 	_AWBNoCarry
.8193	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.8196					_AWBNoCarry:
.8196	60		rts			rts
.8197					_AWBRange:
.8197	4c 9c 9f	jmp $9f9c		jmp 	RangeError
.819a					PrintHex:
.819a	48		pha				pha
.819b	4a		lsr a				lsr 	a
.819c	4a		lsr a				lsr 	a
.819d	4a		lsr a				lsr 	a
.819e	4a		lsr a				lsr 	a
.819f	20 a3 81	jsr $81a3			jsr 	_PrintNibble
.81a2	68		pla				pla
.81a3					_PrintNibble:
.81a3	29 0f		and #$0f			and 	#15
.81a5	c9 0a		cmp #$0a			cmp 	#10
.81a7	90 02		bcc $81ab			bcc 	_NoShift
.81a9	69 06		adc #$06			adc 	#6
.81ab					_NoShift:
.81ab	69 30		adc #$30			adc 	#48
.81ad	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.81b0					AssembleModeX:
.81b0	5a		phy				phy
.81b1	ad 23 04	lda $0423			lda 	IsGroup1
.81b4	f0 17		beq $81cd			beq 	_AMXGroup2
.81b6	8a		txa				txa 							; is it in group # 1
.81b7	29 40		and #$40			and 	#AM_ISG1
.81b9	f0 4d		beq $8208			beq 	_AMXFail 				; no, give up.
.81bb	8a		txa				txa 							; get back.
.81bc	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.81be	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.81c0	d0 22		bne $81e4			bne 	_AMXHaveInfo
.81c2	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.81c5	c9 81		cmp #$81			cmp 	#$81
.81c7	f0 3f		beq $8208			beq 	_AMXFail
.81c9	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.81cb	80 17		bra $81e4			bra 	_AMXHaveInfo 			; odd design decision there.
.81cd					_AMXGroup2:
.81cd	8a		txa				txa 							; is it in group 2 ?
.81ce	29 20		and #$20			and 	#AM_ISG2
.81d0	f0 36		beq $8208			beq 	_AMXFail 				; no, give up.
.81d2	8a		txa				txa 							; get the offset into Y
.81d3	29 1f		and #$1f			and 	#$1F
.81d5	4a		lsr a				lsr 	a 						; make it 0-7.
.81d6	4a		lsr a				lsr  	a
.81d7	a8		tay				tay
.81d8	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.81db					_AMXCheckOkay:
.81db	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.81dc	88		dey				dey
.81dd	10 fc		bpl $81db			bpl 	_AMXCheckOkay
.81df	90 27		bcc $8208			bcc 	_AMXFail 				; not allowed.
.81e1	8a		txa				txa  							; get mask back
.81e2	29 1f		and #$1f			and 	#$1F
.81e4					_AMXHaveInfo:
.81e4	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81e6	10 04		bpl $81ec			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81e8	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81ea	d0 1c		bne $8208			bne 	_AMXFail
.81ec					_AMXAnySize:
.81ec	18		clc				clc 							; add offset to the base opcode
.81ed	6d 24 04	adc $0424			adc 	BaseOpcode
.81f0					_AMXOutputCode:
.81f0	20 5c 81	jsr $815c			jsr 	AssemblerWriteByte 		; write the opcode out.
.81f3	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.81f5	f0 0e		beq $8205			beq 	_AMXExit
.81f7	a5 58		lda $58				lda 	NSMantissa0 			; write LSB operand
.81f9	20 5c 81	jsr $815c			jsr 	AssemblerWriteByte
.81fc	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81fe	30 05		bmi $8205			bmi 	_AMXExit
.8200	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.8202	20 5c 81	jsr $815c			jsr 	AssemblerWriteByte
.8205					_AMXExit:
.8205	7a		ply				ply
.8206	38		sec				sec
.8207	60		rts				rts
.8208					_AMXFail:
.8208	a0 00		ldy #$00			ldy 	#0
.820a					_AMXCheckOddities:
.820a	8a		txa				txa
.820b	d9 32 82	cmp $8232,y			cmp 	ExtraOpcode+2,y 		; match address mode
.820e	d0 15		bne $8225			bne 	_AMXCONext
.8210	b9 30 82	lda $8230,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.8213	cd 24 04	cmp $0424			cmp 	BaseOpcode
.8216	d0 0d		bne $8225			bne 	_AMXCONext
.8218	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.821a	10 04		bpl $8220			bpl 	_AMXCONotZero
.821c	a5 60		lda $60				lda 	NSMantissa1
.821e	d0 05		bne $8225			bne 	_AMXCONext
.8220					_AMXCONotZero:
.8220	b9 31 82	lda $8231,y			lda 	ExtraOpcode+1,y 		; get new opcode
.8223	80 cb		bra $81f0			bra 	_AMXOutputCode 			; and assemble it
.8225					_AMXCONext:
.8225	c8		iny				iny
.8226	c8		iny				iny
.8227	c8		iny				iny
.8228	b9 30 82	lda $8230,y			lda 	ExtraOpcode+0,y 		; end of table
.822b	d0 dd		bne $820a			bne 	_AMXCheckOddities
.822d					_AMXCOFail:
.822d	7a		ply				ply
.822e	18		clc				clc
.822f	60		rts				rts
.8230					ExtraOpcode:
>8230	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>8233	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>8236	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>8239	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>823c	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>823f	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8242	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8245	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>8248	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>824b	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>824e	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.824f					LabelHere:
.824f	c8		iny				iny 								; skip .
.8250	a2 00		ldx #$00			ldx 	#0 							; get a term
.8252	20 45 98	jsr $9845			jsr 	EvaluateTerm
.8255	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.8257	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.8259	d0 22		bne $827d			bne 	_ALType 					; otherwise typing error
.825b	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.825d	85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.825f	b5 60		lda $60,x			lda 	NSMantissa1,x
.8261	85 37		sta $37				sta 	zTemp0+1
.8263	5a		phy				phy 								; copy address in (64k)
.8264	a0 01		ldy #$01			ldy 	#1
.8266	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.8269	92 36		sta ($36)			sta 	(zTemp0)
.826b	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.826e	91 36		sta ($36),y			sta 	(zTemp0),y
.8270	c8		iny				iny
.8271	a9 00		lda #$00			lda 	#0 							; zero the rest.
.8273	91 36		sta ($36),y			sta 	(zTemp0),y
.8275	c8		iny				iny
.8276	91 36		sta ($36),y			sta 	(zTemp0),y
.8278	c8		iny				iny
.8279	91 36		sta ($36),y			sta 	(zTemp0),y
.827b	7a		ply				ply
.827c	60		rts				rts
.827d					_ALType:
.827d	4c a1 9f	jmp $9fa1			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8280					TypeAndCalculateOperand:
.8280	b1 30		lda ($30),y			lda 	(codePtr),y
.8282	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8284	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8286	f0 5b		beq $82e3			beq 	_TACOExit
.8288	c9 80		cmp #$80			cmp 	#KWC_EOL
.828a	f0 57		beq $82e3			beq 	_TACOExit
.828c	c8		iny				iny
.828d	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.828f	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8291	f0 51		beq $82e4			beq 	CalculateOperand
.8293	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8295	f0 1f		beq $82b6			beq 	_TACOIndirect
.8297	88		dey				dey 								; undo get of first character
.8298	20 e4 82	jsr $82e4			jsr 	CalculateOperand 			; get operand
.829b	b1 30		lda ($30),y			lda 	(codePtr),y
.829d	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.829f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.82a1	d0 40		bne $82e3			bne 	_TACOExit
.82a3	c8		iny				iny
.82a4	20 ee 82	jsr $82ee			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.82a7	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.82a9	c9 58		cmp #$58			cmp 	#'X'
.82ab	f0 36		beq $82e3			beq 	_TACOExit
.82ad	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.82af	c9 59		cmp #$59			cmp 	#'Y'
.82b1	f0 30		beq $82e3			beq 	_TACOExit
.82b3					_TACOSyntax:
.82b3	4c 97 9f	jmp $9f97			jmp 	SyntaxError
.82b6					_TACOIndirect:
.82b6	20 e4 82	jsr $82e4			jsr 	CalculateOperand 			; get the operand
.82b9	b1 30		lda ($30),y			lda 	(codePtr),y
.82bb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.82bd	f0 17		beq $82d6			beq 	_TACOIndX
.82bf	20 de 8e	jsr $8ede			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.82c2	b1 30		lda ($30),y			lda 	(codePtr),y
.82c4	a2 d1		ldx #$d1			ldx 	#AM_IND
.82c6	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.82c8	d0 19		bne $82e3			bne 	_TACOExit
.82ca	c8		iny				iny
.82cb	20 ee 82	jsr $82ee			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82ce	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.82d0	d0 e1		bne $82b3			bne 	_TACOSyntax
.82d2	a2 d0		ldx #$d0			ldx 	#AM_INDY
.82d4	80 0d		bra $82e3			bra 	_TACOExit
.82d6					_TACOIndX:
.82d6	c8		iny				iny
.82d7	20 ee 82	jsr $82ee			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82da	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82dc	d0 d5		bne $82b3			bne 	_TACOSyntax
.82de	20 de 8e	jsr $8ede			jsr 	CheckRightBracket			; check )
.82e1	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82e3					_TACOExit:
.82e3	60		rts				rts
.82e4					CalculateOperand:
.82e4	48		pha				pha
.82e5	da		phx				phx
.82e6	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82e8	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger
.82eb	fa		plx				plx
.82ec	68		pla				pla
.82ed	60		rts				rts
.82ee					TACOCheckXY:
.82ee	b1 30		lda ($30),y			lda 	(codePtr),y
.82f0	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82f2	c9 40		cmp #$40			cmp 	#$40
.82f4	d0 21		bne $8317			bne 	_TCXYFail
.82f6	b1 30		lda ($30),y			lda 	(codePtr),y
.82f8	18		clc				clc
.82f9	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82fb	85 37		sta $37				sta 	zTemp0+1
.82fd	c8		iny				iny
.82fe	b1 30		lda ($30),y			lda 	(codePtr),y
.8300	c8		iny				iny
.8301	85 36		sta $36				sta 	zTemp0
.8303	5a		phy				phy 								; save position
.8304	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.8306	b1 36		lda ($36),y			lda 	(zTemp0),y
.8308	d0 0c		bne $8316			bne 	_TCXYPopFail
.830a	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.830c	b1 36		lda ($36),y			lda 	(zTemp0),y
.830e	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.8310	f0 08		beq $831a			beq 	_TCXYFound
.8312	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.8314	f0 04		beq $831a			beq 	_TCXYFound
.8316					_TCXYPopFail:
.8316	7a		ply				ply
.8317					_TCXYFail:
.8317	a9 00		lda #$00			lda 	#0
.8319	60		rts				rts
.831a					_TCXYFound:
.831a	7a		ply				ply 								; restore position
.831b	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.831d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.831e					BackloadProgram:
.831e	20 2c 8a	jsr $8a2c			jsr 	NewProgram 					; does the actual NEW.
.8321	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.8323	a9 6d		lda #$6d			lda 	#_BLLoad & $FF
.8325	20 50 8f	jsr $8f50			jsr 	PrintStringXA
.8328	a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; start page
.832a	8d 59 06	sta $0659			sta 	BackLoadPage
.832d	a9 00		lda #$00			lda 	#(($6000) & $FF)
.832f	8d 5a 06	sta $065a			sta 	0+BackLoadPointer
.8332	a9 60		lda #$60			lda 	#(($6000) >> 8)
.8334	8d 5b 06	sta $065b			sta 	1+BackLoadPointer
.8337	a9 ff		lda #$ff			lda 	#$FF
.8339	8d fa ff	sta $fffa			sta 	$FFFA
.833c					_BPLoop:
.833c	a2 ff		ldx #$ff			ldx 	#$FF
.833e	20 82 83	jsr $8382			jsr 	BLReadByte 					; read a byte
.8341	c9 00		cmp #$00			cmp 	#0
.8343	f0 21		beq $8366			beq 	_BPExit 					; if 0 exit
.8345	30 1f		bmi $8366			bmi 	_BPExit 					; if -ve exit
.8347					_BPCopy:
.8347	e8		inx				inx  								; copy byte into the lineBuffer
.8348	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.834b	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.834e	20 82 83	jsr $8382			jsr 	BLReadByte 					; read next byte
.8351	30 0a		bmi $835d			bmi 	_BPEndLine 					; -ve = EOL
.8353	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8355	d0 02		bne $8359			bne 	_BPNotTab
.8357	a9 20		lda #$20			lda 	#' '
.8359					_BPNotTab:
.8359	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.835b	b0 ea		bcs $8347			bcs 	_BPCopy 					; until a control character, should be 13 received.
.835d					_BPEndLine:
.835d	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.8360	38		sec				sec 								; append not insert
.8361	20 e2 a4	jsr $a4e2			jsr 	MemoryInsertLine 			; append to current program
.8364	80 d6		bra $833c			bra 	_BPLoop
.8366					_BPExit:
.8366	9c fa ff	stz $fffa			stz 	$FFFA
.8369	20 6b 84	jsr $846b			jsr 	ClearCommand 				; clear variables etc.
.836c	60		rts				rts
.836d					_BLLoad:
>836d	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8375	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.8382					BLReadByte:
.8382	da		phx				phx
.8383	a6 0b		ldx $0b				ldx 	8+3 						; save current mapping for $6000 in X
.8385	ad 59 06	lda $0659			lda 	BackLoadPage	 			; set current page
.8388	85 0b		sta $0b				sta 	8+3
.838a	ad 5a 06	lda $065a			lda 	BackLoadPointer 			; copy pointer to zTemp0
.838d	85 36		sta $36				sta 	zTemp0
.838f	ad 5b 06	lda $065b			lda 	BackLoadPointer+1
.8392	85 37		sta $37				sta 	zTemp0+1
.8394	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8396	ee 5a 06	inc $065a			inc 	BackLoadPointer 			; bump pointer
.8399	d0 0f		bne $83aa			bne 	_BLNoCarry
.839b	ee 5b 06	inc $065b			inc 	BackLoadPointer+1
.839e	10 0a		bpl $83aa			bpl 	_BLNoCarry 					; need a new page
.83a0	48		pha				pha
.83a1	a9 60		lda #$60			lda 	#$60 						; reset pointer
.83a3	8d 5b 06	sta $065b			sta 	BackLoadPointer+1
.83a6	ee 59 06	inc $0659			inc 	BackLoadPage 				; next page from source.
.83a9	68		pla				pla
.83aa					_BLNoCarry:
.83aa	86 0b		stx $0b				stx 	8+3 						; restore mapping, then X.
.83ac	fa		plx				plx
.83ad	c9 00		cmp #$00			cmp 	#0
.83af	60		rts				rts
.0659					BackLoadPage:
>0659							.fill  	1
.065a					BackLoadPointer:
>065a							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.83b0					EditProgramCode:
.83b0	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; try to find the line.
.83b3	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.83b6	20 86 a5	jsr $a586			jsr 	MemorySearch
.83b9	90 05		bcc $83c0			bcc 	_EPCNoDelete 				; reached the end : don't delete
.83bb	d0 03		bne $83c0			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.83bd	20 ab a4	jsr $a4ab			jsr 	MemoryDeleteLine 			; delete the line
.83c0					_EPCNoDelete:
.83c0	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty - we just want to delete a line.
.83c3	c9 80		cmp #$80			cmp 	#KWC_EOL
.83c5	f0 0d		beq $83d4			beq 	_EPCNoInsert
.83c7	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.83ca	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.83cd	20 86 a5	jsr $a586			jsr 	MemorySearch
.83d0	18		clc				clc 								; insert at this point.
.83d1	20 e2 a4	jsr $a4e2			jsr 	MemoryInsertLine 			; insert the line
.83d4					_EPCNoInsert:
.83d4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.83d5					WarmStart:
.83d5	a2 ff		ldx #$ff			ldx 	#$FF
.83d7	9a		txs				txs
.83d8	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.83da	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.83dd	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.83e0	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.83e3	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number <> 0
.83e6	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.83e9	d0 17		bne $8402			bne 	_WSEditCode 				; if so,edit code.
.83eb	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero the "offset", meaning it only runs one line.
.83ee	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.83f0	85 30		sta $30				sta 	codePtr
.83f2	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.83f4	85 31		sta $31				sta 	codePtr+1
.83f6	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.83f9	c9 80		cmp #$80			cmp 	#KWC_EOL
.83fb	f0 d8		beq $83d5			beq 	WarmStart
.83fd	20 7f 8b	jsr $8b7f			jsr 	RUNCodePointerLine 			; execute that line.
.8400	80 d3		bra $83d5			bra 	WarmStart
.8402					_WSEditCode:
.8402	20 b0 83	jsr $83b0			jsr 	EditProgramCode 			; edit the program code
.8405	20 6b 84	jsr $846b			jsr 	ClearCommand 				; clear all variables etc.
.8408	80 cb		bra $83d5			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.840a					AssembleCommand:
.840a	a2 00		ldx #$00			ldx 	#0
.840c	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger 		; start address
.840f	a5 58		lda $58				lda 	NSMantissa0
.8411	8d 1e 04	sta $041e			sta 	AssemblerAddress
.8414	a5 60		lda $60				lda 	NSMantissa1
.8416	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.8419	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.841c	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; options 0-3
.841f	a5 58		lda $58				lda 	NSMantissa0
.8421	8d 20 04	sta $0420			sta 	AssemblerControl
.8424	60		rts				rts
.8425	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.8426					AssertCommand:
.8426	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8428	20 86 9d	jsr $9d86			jsr 	EvaluateInteger 			; the assert test
.842b	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; exit if result is non zero.
.842e	d0 05		bne $8435			bne 	_ACExit
.8430	a9 0a		lda #$0a		lda	#10
.8432	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.8435					_ACExit:
.8435	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.8436					CallCommand:
.8436	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.8438	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger
.843b					_CCClear
.843b	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.843c	20 19 9e	jsr $9e19			jsr 	NSMSetZero 					; these are optional sequentially.
.843f	e0 04		cpx #$04			cpx 	#4
.8441	d0 f8		bne $843b			bne 	_CCClear
.8443	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.8445					_CCCParam:
.8445	b1 30		lda ($30),y			lda 	(codePtr),y
.8447	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8449	d0 09		bne $8454			bne 	_CCCRun6502
.844b	c8		iny				iny 								; skip comma
.844c	e8		inx				inx	 								; next level
.844d	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; get A/X/Y
.8450	e0 03		cpx #$03			cpx 	#3
.8452	90 f1		bcc $8445			bcc 	_CCCParam 					; done all 3 ?
.8454					_CCCRun6502:
.8454	5a		phy				phy 								; save position
.8455	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.8457	85 37		sta $37				sta 	zTemp0+1
.8459	a5 58		lda $58				lda 	NSMantissa0
.845b	85 36		sta $36				sta 	zTemp0
.845d	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.845f	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.8461	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.8463	20 68 84	jsr $8468			jsr 	_CCCZTemp0 					; call zTemp0
.8466	7a		ply				ply 								; restore position and exit
.8467	60		rts				rts
.8468					_CCCZTemp0:
.8468	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.846b					ClearCommand:
.846b	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.846d	85 36		sta $36				sta 	0+zTemp0
.846f	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.8471	85 37		sta $37				sta 	1+zTemp0
.8473					_ClearZeroLoop:
.8473	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.8475	f0 24		beq $849b			beq 	_ClearZeroEnd
.8477	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.8479	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.847b					_ClearOneVariable:
.847b	91 36		sta ($36),y			sta 	(zTemp0),y
.847d	c8		iny				iny
.847e	c0 08		cpy #$08			cpy 	#8
.8480	d0 f9		bne $847b			bne 	_ClearOneVariable
.8482	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8484	b1 36		lda ($36),y			lda 	(zTemp0),y
.8486	c9 18		cmp #$18			cmp 	#NSTProcedure
.8488	d0 04		bne $848e			bne 	_ClearNotProcedure
.848a	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.848c	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.848e					_ClearNotProcedure:
.848e	18		clc				clc 								; go to the next variable
.848f	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8491	65 36		adc $36				adc 	zTemp0
.8493	85 36		sta $36				sta 	zTemp0
.8495	90 dc		bcc $8473			bcc 	_ClearZeroLoop
.8497	e6 37		inc $37				inc 	zTemp0+1
.8499	80 d8		bra $8473			bra 	_ClearZeroLoop
.849b					_ClearZeroEnd:
.849b	18		clc				clc
.849c	a5 36		lda $36				lda 	zTemp0
.849e	69 01		adc #$01			adc 	#1
.84a0	8d 0c 04	sta $040c			sta 	lowMemPtr
.84a3	a5 37		lda $37				lda 	zTemp0+1
.84a5	69 00		adc #$00			adc 	#0
.84a7	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.84aa	20 12 a7	jsr $a712			jsr 	StackReset
.84ad	20 78 a7	jsr $a778			jsr 	StringSystemInitialise
.84b0	20 e7 8d	jsr $8de7			jsr 	ProcedureScan
.84b3	20 2e 8b	jsr $8b2e			jsr 	Command_Restore
.84b6	9c 1e 04	stz $041e			stz 	AssemblerAddress
.84b9	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.84bc	9c 20 04	stz $0420			stz 	AssemblerControl
.84bf	20 2c 9a	jsr $9a2c			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.84c2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.84c3					ClearScreen:
.84c3	5a		phy				phy
.84c4	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.84c6	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.84c9	7a		ply				ply
.84ca	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.84cb					Command_Data:
.84cb	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.84cd	a2 80		ldx #$80			ldx 	#KWC_EOL
.84cf	20 39 8e	jsr $8e39			jsr 	ScanForward
.84d2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.84d3					DimCommand:
.84d3	b1 30		lda ($30),y			lda 	(codePtr),y
.84d5	29 c0		and #$c0			and 	#$C0
.84d7	c9 40		cmp #$40			cmp 	#$40
.84d9	d0 7a		bne $8555			bne 	_DCSyntax 				; n o, error.
.84db	b1 30		lda ($30),y			lda 	(codePtr),y
.84dd	18		clc				clc
.84de	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.84e0	85 3f		sta $3f				sta 	zaTemp+1
.84e2	c8		iny				iny
.84e3	b1 30		lda ($30),y			lda 	(codePtr),y
.84e5	c8		iny				iny
.84e6	85 3e		sta $3e				sta 	zaTemp
.84e8	5a		phy				phy
.84e9	a0 02		ldy #$02			ldy 	#2 						; read type byte
.84eb	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ed	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.84ef	c9 18		cmp #$18			cmp 	#NSTProcedure
.84f1	f0 62		beq $8555			beq 	_DCSyntax
.84f3	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.84f5	29 04		and #$04			and 	#NSBIsArray
.84f7	f0 64		beq $855d			beq 	_DCType
.84f9	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.84fb	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84fd	d0 59		bne $8558			bne 	_DCRedefine
.84ff	7a		ply				ply
.8500	20 60 85	jsr $8560			jsr 	_DCGetSize 				; get array size, check it.
.8503	5a		phy				phy
.8504	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8506	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.8508	7a		ply				ply 							; is there a second (e.g. ,x)
.8509	b1 30		lda ($30),y			lda 	(codePtr),y
.850b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.850d	d0 0a		bne $8519			bne 	_DCOneDimension
.850f	c8		iny				iny 							; skip comma
.8510	20 60 85	jsr $8560			jsr 	_DCGetSize 				; get 2nd array size
.8513	5a		phy				phy
.8514	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8516	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8518	7a		ply				ply
.8519					_DCOneDimension:
.8519	5a		phy				phy 							; save position
.851a	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.851c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.851e	aa		tax				tax
.851f	c8		iny				iny
.8520	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8522	e8		inx				inx 							; bump them.
.8523	1a		inc a				inc 	a
.8524	20 c4 9d	jsr $9dc4			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.8527	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.8529	29 e0		and #$e0			and 	#$E0
.852b	d0 23		bne $8550			bne 	_DCSize
.852d	a0 02		ldy #$02			ldy 	#2 						; get base type
.852f	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8531	20 6e 85	jsr $856e			jsr 	ScaleByBaseType 		; scale by base type
.8534	a5 36		lda $36				lda 	zTemp0
.8536	a6 37		ldx $37				ldx 	zTemp0+1
.8538	20 ee 99	jsr $99ee			jsr 	AllocateXABytes 		; allocate memory
.853b	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.853d	91 3e		sta ($3e),y			sta 	(zaTemp),y
.853f	c8		iny				iny
.8540	8a		txa				txa
.8541	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8543	7a		ply				ply 							; get position back
.8544	20 de 8e	jsr $8ede			jsr 	CheckRightBracket 		; check )
.8547	b1 30		lda ($30),y			lda 	(codePtr),y
.8549	c8		iny				iny 							; consume in case
.854a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.854c	f0 85		beq $84d3			beq 	DimCommand
.854e	88		dey				dey 							; undo consume
.854f	60		rts				rts
.8550					_DCSize:
.8550	a9 16		lda #$16		lda	#22
.8552	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.8555					_DCSyntax:
.8555	4c 97 9f	jmp $9f97			jmp 	SyntaxError
.8558					_DCRedefine:
.8558	a9 15		lda #$15		lda	#21
.855a	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.855d					_DCType:
.855d	4c a1 9f	jmp $9fa1			jmp 	TypeError
.8560					_DCGetSize:
.8560	a2 00		ldx #$00			ldx 	#0 						; get first index.
.8562	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 	; get array dimension
.8565	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8567	f0 e7		beq $8550			beq 	_DCSize
.8569	c9 fe		cmp #$fe			cmp 	#254
.856b	f0 e3		beq $8550			beq 	_DCSize
.856d	60		rts				rts
.856e					ScaleByBaseType:
.856e	29 10		and #$10			and 	#NSBIsString 			; is it string
.8570	d0 19		bne $858b			bne 	_SBBTString
.8572	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8574	48		pha				pha
.8575	a5 36		lda $36				lda 	zTemp0
.8577	48		pha				pha
.8578	06 36		asl $36				asl 	zTemp0 					; x 2
.857a	26 37		rol $37				rol 	zTemp0+1
.857c	06 36		asl $36				asl 	zTemp0 					; x 4
.857e	26 37		rol $37				rol 	zTemp0+1
.8580	68		pla				pla 							; add stacked value = x 5
.8581	65 36		adc $36				adc 	zTemp0
.8583	85 36		sta $36				sta 	zTemp0
.8585	68		pla				pla
.8586	65 37		adc $37				adc 	zTemp0+1
.8588	85 37		sta $37				sta 	zTemp0+1
.858a	60		rts				rts
.858b					_SBBTString:
.858b	06 36		asl $36				asl 	zTemp0
.858d	26 37		rol $37				rol 	zTemp0+1
.858f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dokepoke.asm

.8590					PokeCommand:
.8590	18		clc				clc
.8591	80 01		bra $8594			bra 	DPCommand
.8593					DokeCommand:
.8593	38		sec				sec
.8594					DPCommand:
.8594	08		php				php									; save on stack, CS = Doke, CC = Poke
.8595	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8597	20 99 9d	jsr $9d99			jsr		Evaluate16BitInteger 		; address
.859a	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.859d	e8		inx				inx
.859e	20 99 9d	jsr $9d99			jsr		Evaluate16BitInteger 		; data
.85a1	a5 58		lda $58				lda 	NSMantissa0 				; copy address
.85a3	85 36		sta $36				sta 	zTemp0
.85a5	a5 60		lda $60				lda 	NSMantissa1
.85a7	85 37		sta $37				sta 	zTemp0+1
.85a9	a5 59		lda $59				lda 	NSMantissa0+1 				; low byte
.85ab	92 36		sta ($36)			sta 	(zTemp0)
.85ad	28		plp				plp 								; done if POKE
.85ae	90 08		bcc $85b8			bcc 	_DPExit
.85b0	5a		phy				phy 								; write high byte out.
.85b1	a0 01		ldy #$01			ldy 	#1
.85b3	a5 61		lda $61				lda 	NSMantissa1+1
.85b5	91 36		sta ($36),y			sta 	(zTemp0),y
.85b7	7a		ply				ply
.85b8					_DPExit:
.85b8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.85b9					EndCommand:
.85b9	4c d5 83	jmp $83d5			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.85bc					ForCommand:
.85bc	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.85be	20 ac a6	jsr $a6ac			jsr 	StackOpen
.85c1	a2 00		ldx #$00			ldx 	#0
.85c3	20 45 98	jsr $9845			jsr 	EvaluateTerm
.85c6	b5 50		lda $50,x			lda 	NSStatus,x
.85c8	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.85ca	d0 47		bne $8613			bne		_FCError
.85cc	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.85ce	20 ee 8e	jsr $8eee			jsr 	CheckNextA
.85d1	e8		inx				inx
.85d2	20 86 9d	jsr $9d86			jsr 	EvaluateInteger 			; <from> in +1
.85d5	b1 30		lda ($30),y			lda 	(codePtr),y
.85d7	c8		iny				iny 								; consume it
.85d8	48		pha				pha 								; save on stack for later
.85d9	c9 b7		cmp #$b7			cmp 	#KWD_DOWNTO
.85db	f0 04		beq $85e1			beq 	_FCNoSyntax
.85dd	c9 d2		cmp #$d2			cmp 	#KWD_TO
.85df	d0 35		bne $8616			bne 	_FCSyntaxError
.85e1					_FCNoSyntax:
.85e1	e8		inx				inx
.85e2	20 86 9d	jsr $9d86			jsr 	EvaluateInteger
.85e5	20 f1 a6	jsr $a6f1			jsr 	STKSaveCodePosition 		; save loop back position
.85e8	68		pla				pla 								; restore DOWNTO or TO
.85e9	5a		phy				phy 								; save Y on the stack
.85ea	49 b7		eor #$b7			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.85ec	f0 02		beq $85f0			beq 	_FCNotDownTo
.85ee	a9 02		lda #$02			lda 	#2
.85f0					_FCNotDownTo:
.85f0	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.85f1	a0 10		ldy #$10			ldy 	#16
.85f3	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.85f5	a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.85f7	a5 58		lda $58				lda 	NSMantissa0
.85f9	91 34		sta ($34),y			sta 	(basicStack),y
.85fb	a5 60		lda $60				lda 	NSMantissa1
.85fd	c8		iny				iny
.85fe	91 34		sta ($34),y			sta 	(basicStack),y
.8600	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8602	a2 01		ldx #$01			ldx 	#1
.8604	20 19 86	jsr $8619			jsr 	FCIntegerToStack
.8607	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8609	a2 02		ldx #$02			ldx 	#2
.860b	20 19 86	jsr $8619			jsr 	FCIntegerToStack
.860e	20 34 86	jsr $8634			jsr 	CopyIndexToReference
.8611	7a		ply				ply 								; restore position
.8612	60		rts				rts
.8613					_FCError:
.8613	4c a1 9f	jmp $9fa1			jmp 	TypeError
.8616					_FCSyntaxError:
.8616	4c 97 9f	jmp $9f97			jmp 	SyntaxError
.8619					FCIntegerToStack:
.8619	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.861b	10 03		bpl $8620			bpl	 	_FCNotNegative
.861d	20 e2 9d	jsr $9de2			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8620					_FCNotNegative:
.8620	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8622	91 34		sta ($34),y			sta 	(basicStack),y
.8624	c8		iny				iny
.8625	b5 60		lda $60,x			lda 	NSMantissa1,x
.8627	91 34		sta ($34),y			sta 	(basicStack),y
.8629	c8		iny				iny
.862a	b5 68		lda $68,x			lda 	NSMantissa2,x
.862c	91 34		sta ($34),y			sta 	(basicStack),y
.862e	c8		iny				iny
.862f	b5 70		lda $70,x			lda 	NSMantissa3,x
.8631	91 34		sta ($34),y			sta 	(basicStack),y
.8633	60		rts				rts
.8634					CopyIndexToReference:
.8634	5a		phy				phy
.8635	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8637	38		sec				sec 								; (because we copy from offset 8)
.8638	b1 34		lda ($34),y			lda 	(basicStack),y
.863a	e9 08		sbc #$08			sbc 	#8
.863c	85 36		sta $36				sta 	zTemp0
.863e	c8		iny				iny
.863f	b1 34		lda ($34),y			lda 	(basicStack),y
.8641	e9 00		sbc #$00			sbc 	#0
.8643	85 37		sta $37				sta 	zTemp0+1
.8645	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.8647	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.8649	b1 34		lda ($34),y			lda 	(basicStack),y
.864b	0a		asl a				asl 	a 							; into carry
.864c	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.864e	90 14		bcc $8664			bcc 	_CITRNormal
.8650	38		sec				sec
.8651					_CITRNegative:
.8651	a9 00		lda #$00			lda 	#0
.8653	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8655	91 36		sta ($36),y			sta 	(zTemp0),y
.8657	c8		iny				iny
.8658	ca		dex				dex
.8659	d0 f6		bne $8651			bne 	_CITRNegative
.865b	88		dey				dey 								; look at MSB of mantissa
.865c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.865e	09 80		ora #$80			ora 	#$80
.8660	91 36		sta ($36),y			sta 	(zTemp0),y
.8662	7a		ply				ply
.8663	60		rts				rts
.8664					_CITRNormal:
.8664	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.8666	91 36		sta ($36),y			sta 	(zTemp0),y
.8668	c8		iny				iny
.8669	ca		dex				dex
.866a	d0 f8		bne $8664			bne 	_CITRNormal
.866c	7a		ply				ply 								; and exit.
.866d	60		rts				rts
.866e					NextCommand:
.866e	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8670	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.8672	20 d9 a6	jsr $a6d9			jsr 	StackCheckFrame
.8675	5a		phy				phy
.8676	a0 10		ldy #$10			ldy 	#16 						; get the step count
.8678	b1 34		lda ($34),y			lda 	(basicStack),y
.867a	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.867c	30 02		bmi $8680			bmi 	_NCStepNeg
.867e	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8680					_NCStepNeg:
.8680	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8682	a2 04		ldx #$04			ldx 	#4 							; count to bump
.8684	18		clc				clc
.8685					_NCBump:
.8685	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8687	91 34		sta ($34),y			sta 	(basicStack),y
.8689	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.868b	c8		iny				iny 								; next byte
.868c	ca		dex				dex 								; do four times
.868d	d0 f6		bne $8685			bne 	_NCBump
.868f	20 34 86	jsr $8634			jsr		CopyIndexToReference		; copy it to the reference variable.
.8692	a0 10		ldy #$10			ldy 	#16 						; get step count again
.8694	b1 34		lda ($34),y			lda 	(basicStack),y
.8696	0a		asl a				asl 	a 							; sign bit to carry
.8697	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8699	85 38		sta $38				sta 	zTemp1
.869b	90 02		bcc $869f			bcc 	_NCCompRev 					; use if step is +ve
.869d	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.869f					_NCCompRev:
.869f	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.86a1	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.86a3	85 39		sta $39				sta 	zTemp1+1
.86a5	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.86a7	38		sec				sec
.86a8					_NCCompare:
.86a8	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.86aa	b1 34		lda ($34),y			lda 	(basicStack),y
.86ac	a4 39		ldy $39				ldy 	zTemp1+1
.86ae	f1 34		sbc ($34),y			sbc 	(basicStack),y
.86b0	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.86b2	e6 39		inc $39				inc 	zTemp1+1
.86b4	ca		dex				dex 								; do it 4 times.
.86b5	d0 f1		bne $86a8			bne 	_NCCompare
.86b7	50 02		bvc $86bb			bvc 	_NCNoOverflow 				; convert to signed comparison
.86b9	49 80		eor #$80			eor 	#$80
.86bb					_NCNoOverflow:
.86bb	7a		ply				ply 								; restore Y position
.86bc	0a		asl a				asl 	a 							; is bit 7 set.
.86bd	90 04		bcc $86c3			bcc 	_NCLoopback 				; if no , >= so loop back
.86bf	20 cb a6	jsr $a6cb			jsr 	StackClose 					; exit the loop
.86c2	60		rts				rts
.86c3					_NCLoopBack:
.86c3	20 02 a7	jsr $a702			jsr 	STKLoadCodePosition 		; loop back
.86c6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.86c7					Command_GOSUB:
.86c7	a2 00		ldx #$00			ldx 	#0
.86c9	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.86cc	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.86ce	20 ac a6	jsr $a6ac			jsr 	StackOpen 					; create frame
.86d1	20 f1 a6	jsr $a6f1			jsr 	STKSaveCodePosition 		; save current position
.86d4	4c ea 86	jmp $86ea			jmp 	GotoStackX
.86d7					Command_RETURN:
.86d7	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.86d9	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.86db	20 d9 a6	jsr $a6d9			jsr 	StackCheckFrame
.86de	20 02 a7	jsr $a702			jsr 	STKLoadCodePosition 		; restore code position
.86e1	20 cb a6	jsr $a6cb			jsr 	StackClose
.86e4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.86e5					GotoCommand:
.86e5	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.86e7	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger
.86ea					GotoStackX:
.86ea	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.86ec	48		pha				pha 								; it is slightly inefficient, just in cases.
.86ed	b5 58		lda $58,x			lda 	NSMantissa0,x
.86ef	fa		plx				plx
.86f0	20 86 a5	jsr $a586			jsr 	MemorySearch 				; transfer to line number AX.
.86f3	90 05		bcc $86fa			bcc 	_GotoError 					; not found, off end.
.86f5	d0 03		bne $86fa			bne 	_GotoError 					; not found exactly
.86f7	4c 78 8b	jmp $8b78			jmp 	RunNewLine 					; and go straight to new line code.
.86fa					_GotoError:
.86fa	a9 0d		lda #$0d		lda	#13
.86fc	4c f7 8e	jmp $8ef7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.86ff					IfCommand:
.86ff	a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.8701	20 67 9d	jsr $9d67			jsr 	EvaluateNumber
.8704	b1 30		lda ($30),y			lda 	(codePtr),y
.8706	c9 aa		cmp #$aa			cmp 	#KWD_THEN  					; could be THEN <stuff>
.8708	d0 0a		bne $8714			bne 	_IFStructured 				; we still support it.
.870a	c8		iny				iny 								; consume THEN
.870b	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; is it zero
.870e	f0 01		beq $8711			beq 	_IfFail 					; if fail, go to next line
.8710	60		rts				rts 								; if THEN just continue
.8711					_IfFail:
.8711	4c 60 8b	jmp $8b60			jmp 	EOLCommand
.8714					_IfStructured:
.8714	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; is it zero
.8717	d0 07		bne $8720			bne 	_IfExit 					; if not, then continue normally.
.8719	a9 b8		lda #$b8			lda 	#KWD_ELSE 					; look for else/endif
.871b	a2 a7		ldx #$a7			ldx 	#KWD_ENDIF
.871d	20 39 8e	jsr $8e39			jsr 	ScanForward 				; and run from there
.8720					_IfExit:
.8720	60		rts				rts
.8721					ElseCode:
.8721	a9 a7		lda #$a7			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8723	aa		tax				tax 								; so just go to the structure exit
.8724	20 39 8e	jsr $8e39			jsr 	ScanForward
.8727	60		rts				rts
.8728					EndIf:
.8728	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8729					Command_Input:
.8729	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.872b	8d 28 04	sta $0428			sta 	IsInputFlag
.872e	80 03		bra $8733			bra 	Command_IP_Main
.8730					Command_Print:
.8730	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.8733					Command_IP_Main:
.8733	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.8734					_CPLoop:
.8734	08		php				php 								; save last action flag
.8735	b1 30		lda ($30),y			lda 	(codePtr),y
.8737	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8739	f0 54		beq $878f			beq 	_CPExit
.873b	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.873d	f0 50		beq $878f			beq 	_CPExit
.873f	68		pla				pla 								; throw last action flag
.8740	b1 30		lda ($30),y			lda 	(codePtr),y
.8742	c8		iny				iny
.8743	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.8745	f0 45		beq $878c			beq 	_CPContinueWithSameLine
.8747	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8749	f0 3c		beq $8787			beq 	_CPTab
.874b	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.874d	f0 34		beq $8783			beq 	_CPNewLine
.874f	88		dey				dey 								; undo the get.
.8750	20 f9 93	jsr $93f9			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.8753	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.8755	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.8757	f0 0d		beq $8766			beq 	_CPIsValue 					; no, display it.
.8759	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.875c	f0 05		beq $8763			beq 	_CPIsPrint 					; otherwise display.
.875e	20 98 87	jsr $8798			jsr 	CIInputValue 				; input a value to the reference
.8761	80 20		bra $8783			bra 	_CPNewLine
.8763					_CPIsPrint:
.8763	20 be 96	jsr $96be			jsr 	Dereference 				; dereference if required.
.8766					_CPIsValue:
.8766	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.8768	29 10		and #$10			and 	#NSBIsString
.876a	f0 09		beq $8775			beq 	_CPNumber
.876c	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.876e	a5 58		lda $58				lda 	NSMantissa0
.8770	20 fb 87	jsr $87fb			jsr 	CPPrintStringXA
.8773	80 be		bra $8733			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8775					_CPNumber:
.8775	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8777	20 4e 9c	jsr $9c4e			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.877a	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.877c	a9 49		lda #$49			lda 	#DecimalBuffer & $FF
.877e	20 fb 87	jsr $87fb			jsr 	CPPrintStringXA 			; print it.
.8781	80 b0		bra $8733			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8783					_CPNewLine:
.8783	a9 0d		lda #$0d			lda 	#13
.8785	80 02		bra $8789			bra 	_CPPrintChar
.8787					_CPTab:
.8787	a9 09		lda #$09			lda 	#9 							; print TAB
.8789					_CPPrintChar:
.8789	20 0e 88	jsr $880e			jsr 	CPPrintVector
.878c					_CPContinueWithSameLine:
.878c	38		sec				sec 								; loop round with carry set, which
.878d	80 a5		bra $8734			bra 	_CPLoop 					; will inhibit final CR
.878f					_CPExit:
.878f	28		plp				plp 								; get last action flag
.8790	b0 05		bcs $8797			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8792	a9 0d		lda #$0d			lda 	#13 						; print new line
.8794	20 0e 88	jsr $880e			jsr 	CPPrintVector
.8797					_CPExit2:
.8797	60		rts				rts
.8798					CIInputValue:
.8798	a2 00		ldx #$00			ldx 	#0 							; input a line.
.879a					_CIInputLine:
.879a	20 11 88	jsr $8811			jsr 	CPInputVector 				; get key
.879d	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.879f	f0 1f		beq $87c0			beq 	_CIHaveValue
.87a1	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.87a3	f0 11		beq $87b6			beq 	_CIBackspace
.87a5	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.87a7	90 f1		bcc $879a			bcc 	_CIInputLine
.87a9	e0 50		cpx #$50			cpx 	#80 						; max length
.87ab	b0 ed		bcs $879a			bcs 	_CIInputLine
.87ad	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.87b0	e8		inx				inx
.87b1	20 0e 88	jsr $880e			jsr 	CPPrintVector 				; echo it.
.87b4	80 e4		bra $879a			bra 	_CIInputLine
.87b6					_CIBackSpace:
.87b6	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.87b8	f0 e0		beq $879a			beq 	_CIInputLine
.87ba	20 0e 88	jsr $880e			jsr 	CPPrintVector 				; echo it.
.87bd	ca		dex				dex
.87be	80 da		bra $879a			bra 	_CIInputLine
.87c0					_CIHaveValue:
.87c0	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.87c3	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.87c5	29 10		and #$10			and 	#NSBIsString
.87c7	f0 17		beq $87e0			beq 	_CIAssignNumber 			; assign a number
.87c9	a2 01		ldx #$01			ldx 	#1
.87cb	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.87cd	95 58		sta $58,x			sta 	NSMantissa0,x
.87cf	a9 05		lda #$05			lda 	#lineBuffer >> 8
.87d1	95 60		sta $60,x			sta 	NSMantissa1,x
.87d3	74 68		stz $68,x			stz 	NSMantissa2,x
.87d5	74 70		stz $70,x			stz 	NSMantissa3,x
.87d7	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.87d9	95 50		sta $50,x			sta  	NSStatus,x
.87db	ca		dex				dex 								; X = 0
.87dc	20 4d 88	jsr $884d			jsr 	AssignVariable
.87df	60		rts				rts
.87e0					_CIAssignNumber:
.87e0	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.87e2	85 36		sta $36				sta 	zTemp0
.87e4	a9 05		lda #$05			lda 	#lineBuffer >> 8
.87e6	85 37		sta $37				sta 	zTemp0+1
.87e8	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.87ea	20 d0 9b	jsr $9bd0			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.87ed	90 07		bcc $87f6			bcc 	_CIIsOkay
.87ef	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.87f1	20 0e 88	jsr $880e			jsr 	CPPrintVector
.87f4	80 a2		bra $8798			bra 	CIInputValue
.87f6					_CIIsOkay:
.87f6	ca		dex				dex 								; X = 0
.87f7	20 4d 88	jsr $884d			jsr 	AssignVariable
.87fa	60		rts				rts
.87fb					CPPrintStringXA:
.87fb	5a		phy				phy
.87fc	86 37		stx $37				stx 	zTemp0+1
.87fe	85 36		sta $36				sta 	zTemp0
.8800	a0 00		ldy #$00			ldy 	#0
.8802					_PSXALoop:
.8802	b1 36		lda ($36),y			lda 	(zTemp0),y
.8804	f0 06		beq $880c			beq 	_PSXAExit
.8806	20 0e 88	jsr $880e			jsr 	CPPrintVector
.8809	c8		iny				iny
.880a	80 f6		bra $8802			bra 	_PSXALoop
.880c					_PSXAExit:
.880c	7a		ply				ply
.880d	60		rts				rts
.880e					CPPrintVector:
.880e	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.8811					CPInputVector:
.8811	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8814					LetCommand:
.8814	a2 00		ldx #$00			ldx 	#0
.8816	b1 30		lda ($30),y			lda 	(codePtr),y
.8818	c9 10		cmp #$10			cmp 	#KWD_AT
.881a	d0 14		bne $8830			bne 	_LCStandard
.881c	c8		iny				iny 								; skip equal
.881d	20 45 98	jsr $9845			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.8820	20 be 96	jsr $96be			jsr 	Dereference 				; dereference it to a value
.8823	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.8825	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8827	95 50		sta $50,x			sta 	NSStatus,x
.8829	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.882b	d0 0f		bne $883c			bne 	_LCMain
.882d	4c a1 9f	jmp $9fa1			jmp 	TypeError 					; was a reference before.
.8830					_LCStandard:
.8830	ad e3 93	lda $93e3			lda 	PrecedenceLevel+"*"			; precedence > this
.8833	20 fd 93	jsr $93fd			jsr 	EvaluateExpressionAtPrecedence
.8836	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.8838	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.883a	f0 0e		beq $884a			beq 	_LetGoProc 					; it's a procedure call.
.883c					_LCMain:
.883c	a9 3d		lda #$3d			lda 	#"=" 						; check =
.883e	20 ee 8e	jsr $8eee			jsr 	CheckNextA
.8841	e8		inx				inx 								; RHS
.8842	20 5e 9d	jsr $9d5e			jsr 	EvaluateValue
.8845	ca		dex				dex
.8846	20 4d 88	jsr $884d			jsr 	AssignVariable
.8849	60		rts				rts
.884a					_LetGoProc:
.884a	4c 36 8a	jmp $8a36			jmp 	CallProcedure
.884d					AssignVariable:
.884d	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.884f	48		pha				pha 								; save a copy
.8850	55 51		eor $51,x			eor 	NSStatus+1,x
.8852	29 10		and #$10			and 	#NSBIsString
.8854	d0 0b		bne $8861			bne 	_ASError
.8856	68		pla				pla 								; get back
.8857	29 10		and #$10			and 	#NSBIsString 				; check type
.8859	d0 03		bne $885e			bne 	_ASString
.885b	4c fc 95	jmp $95fc			jmp 	AssignNumber
.885e					_ASString:
.885e	4c 5a 96	jmp $965a			jmp 	AssignString
.8861					_ASError:
.8861	4c a1 9f	jmp $9fa1			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.8864					Command_List:
.8864	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.8867	b1 30		lda ($30),y			lda 	(codePtr),y
.8869	29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.886b	c9 40		cmp #$40			cmp 	#$40  						; of code.
.886d	f0 6e		beq $88dd			beq 	_CLListProcedure
.886f	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.8871	64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.8873	a9 ff		lda #$ff			lda 	#$FF
.8875	85 5f		sta $5f				sta 	NSMantissa0+7
.8877	85 67		sta $67				sta 	NSMantissa1+7
.8879	b1 30		lda ($30),y			lda 	(codePtr),y
.887b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.887d	f0 1a		beq $8899			beq 	_CLSecond
.887f	20 5a 89	jsr $895a			jsr 	CLIsDigit 					; if not digit, list all
.8882	b0 20		bcs $88a4			bcs 	_CLStart
.8884	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8886	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger
.8889	b1 30		lda ($30),y			lda 	(codePtr),y
.888b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.888d	f0 0a		beq $8899			beq 	_CLSecond 					; if so go get it
.888f	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.8891	85 5f		sta $5f				sta 	NSMantissa0+7
.8893	a5 64		lda $64				lda 	NSMantissa1+4
.8895	85 67		sta $67				sta 	NSMantissa1+7
.8897	80 0b		bra $88a4			bra 	_CLStart
.8899					_CLSecond:
.8899	c8		iny				iny 								; consume comma
.889a	20 5a 89	jsr $895a			jsr 	CLIsDigit 					; digit found
.889d	b0 05		bcs $88a4			bcs 	_CLStart 					; if not, continue listing
.889f	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.88a1	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger
.88a4					_CLStart
.88a4	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88a6	85 30		sta $30				sta 	codePtr
.88a8	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88aa	85 31		sta $31				sta 	codePtr+1
.88ac					_CLLoop:
.88ac	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check here, as we want the option of breaking out of long lists.
.88af	f0 27		beq $88d8			beq 	_CLBreak
.88b1	b2 30		lda ($30)			lda 	(codePtr)
.88b3	f0 20		beq $88d5			beq 	_CLExit
.88b5	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.88b7	20 49 89	jsr $8949			jsr 	CLCompareLineNo
.88ba	90 0c		bcc $88c8			bcc 	_CLNext
.88bc	a2 07		ldx #$07			ldx 	#7
.88be	20 49 89	jsr $8949			jsr 	CLCompareLineNo
.88c1	f0 02		beq $88c5			beq 	_CLDoThisOne
.88c3	b0 03		bcs $88c8			bcs 	_CLNext
.88c5					_CLDoThisOne:
.88c5	20 36 89	jsr $8936			jsr 	CLListOneLine 				; routine to list the current line.
.88c8					_CLNext:
.88c8	18		clc				clc
.88c9	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88cb	65 30		adc $30				adc 	codePtr
.88cd	85 30		sta $30				sta 	codePtr
.88cf	90 02		bcc $88d3			bcc 	_CREExit
.88d1	e6 31		inc $31				inc 	codePtr+1 					; carry
.88d3					_CREExit:
.88d3	80 d7		bra $88ac			bra 	_CLLoop
.88d5					_CLExit:
.88d5	4c d5 83	jmp $83d5			jmp 	WarmStart
.88d8					_CLBreak:
.88d8	a9 01		lda #$01		lda	#1
.88da	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.88dd					_CLListProcedure:
.88dd	b1 30		lda ($30),y			lda 	(codePtr),y
.88df	85 38		sta $38				sta 	zTemp1
.88e1	c8		iny				iny
.88e2	b1 30		lda ($30),y			lda 	(codePtr),y
.88e4	85 39		sta $39				sta 	zTemp1+1
.88e6	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88e8	85 30		sta $30				sta 	codePtr
.88ea	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88ec	85 31		sta $31				sta 	codePtr+1
.88ee					_CLLPSearch:
.88ee	b2 30		lda ($30)			lda 	(codePtr)
.88f0	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.88f2	f0 e1		beq $88d5			beq 	_CLExit
.88f4	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.88f6	b1 30		lda ($30),y			lda 	(codePtr),y
.88f8	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.88fa	d0 0e		bne $890a			bne 	_CLLPNext
.88fc	c8		iny				iny 								; check if PROC this.
.88fd	b1 30		lda ($30),y			lda 	(codePtr),y
.88ff	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8901	d0 07		bne $890a			bne 	_CLLPNext
.8903	c8		iny				iny
.8904	b1 30		lda ($30),y			lda 	(codePtr),y
.8906	c5 39		cmp $39				cmp 	zTemp1+1
.8908	f0 0d		beq $8917			beq 	_CLLPFound
.890a					_CLLPNext:
.890a	18		clc				clc
.890b	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.890d	65 30		adc $30				adc 	codePtr
.890f	85 30		sta $30				sta 	codePtr
.8911	90 02		bcc $8915			bcc 	_CREExit
.8913	e6 31		inc $31				inc 	codePtr+1 					; carry
.8915					_CREExit:
.8915	80 d7		bra $88ee			bra 	_CLLPSearch
.8917					_CLLPFound:
.8917	b2 30		lda ($30)			lda 	(codePtr)
.8919	f0 ba		beq $88d5			beq 	_CLExit
.891b	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.891d	b1 30		lda ($30),y			lda 	(codePtr),y
.891f	48		pha				pha
.8920	20 36 89	jsr $8936			jsr 	CLListOneLine 				; list line and go forward
.8923	18		clc				clc
.8924	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8926	65 30		adc $30				adc 	codePtr
.8928	85 30		sta $30				sta 	codePtr
.892a	90 02		bcc $892e			bcc 	_CREExit
.892c	e6 31		inc $31				inc 	codePtr+1 					; carry
.892e					_CREExit:
.892e	68		pla				pla 								; reached ENDPROC ?
.892f	c9 a8		cmp #$a8			cmp 	#KWD_ENDPROC
.8931	d0 e4		bne $8917			bne 	_CLLPFound
.8933	4c d5 83	jmp $83d5			jmp 	WarmStart
.8936					CLListOneLine:
.8936	20 9c 8e	jsr $8e9c			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8939	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.893c	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.893e	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8940	20 50 8f	jsr $8f50			jsr 	PrintStringXA
.8943	a9 0d		lda #$0d			lda 	#13 						; new line
.8945	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8948	60		rts				rts
.8949					CLCompareLineNo:
.8949	38		sec				sec
.894a	a0 01		ldy #$01			ldy 	#1
.894c	b1 30		lda ($30),y			lda 	(codePtr),y
.894e	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8950	85 36		sta $36				sta 	zTemp0
.8952	c8		iny				iny
.8953	b1 30		lda ($30),y			lda 	(codePtr),y
.8955	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.8957	05 36		ora $36				ora 	zTemp0
.8959	60		rts				rts
.895a					CLIsDigit:
.895a	b1 30		lda ($30),y			lda 	(codePtr),y
.895c	c9 30		cmp #$30			cmp 	#"0"
.895e	90 03		bcc $8963			bcc	 	_CLIDExitFalse
.8960	c9 3a		cmp #$3a			cmp 	#"9"+1
.8962	60		rts				rts
.8963					_CLIDExitFalse:
.8963	38		sec				sec
.8964	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8965					Command_LOCAL:
.8965	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8967	20 73 89	jsr $8973			jsr 	LocaliseNextTerm 			; convert term to a local.
.896a	b1 30		lda ($30),y			lda 	(codePtr),y
.896c	c8		iny				iny
.896d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.896f	f0 f4		beq $8965			beq 	Command_LOCAL 				; if so, localise another variable.
.8971	88		dey				dey 								; unpick pre-get
.8972	60		rts				rts
.8973					LocaliseNextTerm:
.8973	20 45 98	jsr $9845			jsr 	EvaluateTerm 				; evaluate the term
.8976	b5 50		lda $50,x			lda 	NSStatus,x
.8978	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.897a	f0 5c		beq $89d8			beq		_LNTError
.897c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.897e	85 36		sta $36				sta 	zTemp0
.8980	b5 60		lda $60,x			lda 	NSMantissa1,x
.8982	85 37		sta $37				sta  	zTemp0+1
.8984	b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.8986	29 10		and #$10			and 	#NSBIsString
.8988	d0 1e		bne $89a8			bne 	_LNTPushString
.898a	5a		phy				phy
.898b	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.898d					_LNTPushNumLoop:
.898d	b1 36		lda ($36),y			lda		(zTemp0),y
.898f	20 8b a6	jsr $a68b			jsr 	StackPushByte
.8992	c8		iny				iny
.8993	c0 05		cpy #$05			cpy 	#5
.8995	d0 f6		bne $898d			bne 	_LNTPushNumLoop
.8997	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.8999	20 8b a6	jsr $a68b			jsr 	StackPushByte
.899c	a5 37		lda $37				lda 	zTemp0+1
.899e	20 8b a6	jsr $a68b			jsr 	StackPushByte
.89a1	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.89a3	20 8b a6	jsr $a68b			jsr 	StackPushByte
.89a6	7a		ply				ply
.89a7	60		rts				rts
.89a8					_LNTPushString:
.89a8	5a		phy				phy
.89a9	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.89ab	85 38		sta $38				sta 	zTemp1
.89ad	a0 01		ldy #$01			ldy 	#1
.89af	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b1	85 39		sta $39				sta 	zTemp1+1
.89b3	a0 00		ldy #$00			ldy 	#0 							; output string
.89b5	c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.89b7	f0 0a		beq $89c3			beq 	_LNTStringOut
.89b9					_LNTPushStrLoop:
.89b9	b1 38		lda ($38),y			lda 	(zTemp1),y
.89bb	f0 06		beq $89c3			beq 	_LNTStringOut
.89bd	20 8b a6	jsr $a68b			jsr 	StackPushByte
.89c0	c8		iny				iny
.89c1	80 f6		bra $89b9			bra 	_LNTPushStrLoop
.89c3					_LNTStringOut:
.89c3	98		tya				tya									; output length (chars written).
.89c4	20 8b a6	jsr $a68b			jsr 	StackPushByte
.89c7	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.89c9	20 8b a6	jsr $a68b			jsr 	StackPushByte
.89cc	b5 60		lda $60,x			lda 	NSMantissa1,x
.89ce	20 8b a6	jsr $a68b			jsr 	StackPushByte
.89d1	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.89d3	20 8b a6	jsr $a68b			jsr 	StackPushByte
.89d6	7a		ply				ply
.89d7	60		rts				rts
.89d8					_LNTError:
.89d8	4c 97 9f	jmp $9f97			jmp 	SyntaxError
.89db					LocalPopValue:
.89db	20 a3 a6	jsr $a6a3			jsr 	StackPopByte
.89de	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.89e0	d0 17		bne $89f9			bne 	_LPVString
.89e2	20 a3 a6	jsr $a6a3			jsr 	StackPopByte 				; address
.89e5	85 37		sta $37				sta 	zTemp0+1
.89e7	20 a3 a6	jsr $a6a3			jsr 	StackPopByte
.89ea	85 36		sta $36				sta 	zTemp0
.89ec	5a		phy				phy
.89ed	a0 04		ldy #$04			ldy 	#4 							; copy back
.89ef					_LPVNumberCopy:
.89ef	20 a3 a6	jsr $a6a3			jsr 	StackPopByte
.89f2	91 36		sta ($36),y			sta 	(zTemp0),y
.89f4	88		dey				dey
.89f5	10 f8		bpl $89ef			bpl 	_LPVNumberCopy
.89f7	7a		ply				ply 								; and complete
.89f8	60		rts				rts
.89f9					_LPVString:
.89f9	20 a3 a6	jsr $a6a3			jsr 	StackPopByte 				; address of record copied to zTemp0
.89fc	85 37		sta $37				sta 	zTemp0+1
.89fe	20 a3 a6	jsr $a6a3			jsr 	StackPopByte
.8a01	85 36		sta $36				sta 	zTemp0
.8a03	5a		phy				phy
.8a04	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.8a06	85 38		sta $38				sta 	zTemp1
.8a08	a0 01		ldy #$01			ldy 	#1
.8a0a	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a0c	85 39		sta $39				sta 	zTemp1+1
.8a0e	20 a3 a6	jsr $a6a3			jsr 	StackPopByte 				; # chars to get => y
.8a11	a8		tay				tay
.8a12	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8a14	f0 0e		beq $8a24			beq 	_LPVStringCopied
.8a16	a9 00		lda #$00			lda 	#0 							; NULL on end
.8a18	91 38		sta ($38),y			sta 	(zTemp1),y
.8a1a					_LPVStringCopy:
.8a1a	88		dey				dey
.8a1b	30 07		bmi $8a24			bmi 	_LPVStringCopied
.8a1d	20 a3 a6	jsr $a6a3			jsr 	StackPopByte
.8a20	91 38		sta ($38),y			sta 	(zTemp1),y
.8a22	80 f6		bra $8a1a			bra 	_LPVStringCopy
.8a24					_LPVStringCopied:
.8a24	fa		plx				plx
.8a25	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8a26					NewCommand:
.8a26	20 2c 8a	jsr $8a2c			jsr 	NewProgram 					; does the actual NEW.
.8a29	4c d5 83	jmp $83d5			jmp 	WarmStart 					; and warm starts straight away.
.8a2c					NewProgram:
.8a2c	20 68 a5	jsr $a568			jsr 	MemoryNew
.8a2f	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8a32	20 6b 84	jsr $846b			jsr 	ClearCommand 				; clear everything.
.8a35	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8a36					CallProcedure:
.8a36	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8a38	b1 30		lda ($30),y			lda 	(codePtr),y
.8a3a	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8a3c	f0 0c		beq $8a4a			beq 	_CPEndParam
.8a3e					_CPParamLoop:
.8a3e	20 5e 9d	jsr $9d5e			jsr 	EvaluateValue 				; get parameter onto stack
.8a41	e8		inx				inx 								; bump next stack
.8a42	b1 30		lda ($30),y			lda 	(codePtr),y
.8a44	c8		iny				iny
.8a45	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8a47	f0 f5		beq $8a3e			beq 	_CPParamLoop
.8a49	88		dey				dey 								; unpick.
.8a4a					_CPEndParam:
.8a4a	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8a4d	c8		iny				iny									; skip right bracket
.8a4e	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8a50	20 ac a6	jsr $a6ac			jsr 	StackOpen
.8a53	20 f1 a6	jsr $a6f1			jsr 	STKSaveCodePosition 		; save loop position
.8a56	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8a58	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8a5a	a5 60		lda $60				lda 	NSMantissa1
.8a5c	85 37		sta $37				sta 	zTemp0+1
.8a5e	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8a60	b2 36		lda ($36)			lda 	(zTemp0)
.8a62	85 30		sta $30				sta 	safePtr
.8a64	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a66	85 31		sta $31				sta 	safePtr+1
.8a68	c8		iny				iny
.8a69	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a6b	85 32		sta $32				sta 	safePtr+2
.8a6d	c8		iny				iny
.8a6e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a70	85 33		sta $33				sta 	safePtr+3
.8a72	c8		iny				iny 								; get Y offset -> Y
.8a73	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a75	a8		tay				tay
.8a76	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8a78	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check zero parameters at the start
.8a7b	f0 13		beq $8a90			beq 	_ParamExit 					; if so, exit.
.8a7d					_ParamExtract:
.8a7d	ca		dex				dex 								; put a local term on the level before
.8a7e	20 73 89	jsr $8973			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8a81	20 4d 88	jsr $884d			jsr 	AssignVariable 				; assign stacked value to the variable.
.8a84	e8		inx				inx 								; advance to next parameter to do.
.8a85	e8		inx				inx
.8a86	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8a89	f0 05		beq $8a90			beq 	_ParamExit
.8a8b	20 e6 8e	jsr $8ee6			jsr 	CheckComma 					; comma seperating parameters
.8a8e	80 ed		bra $8a7d			bra 	_ParamExtract
.8a90					_ParamExit:
.8a90	20 de 8e	jsr $8ede			jsr 	CheckRightBracket 			; check )
.8a93	60		rts				rts 								; and continue from here
.8a94					Command_ENDPROC:
.8a94	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8a96	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8a98	20 d9 a6	jsr $a6d9			jsr 	StackCheckFrame
.8a9b	20 02 a7	jsr $a702			jsr 	STKLoadCodePosition 		; restore code position
.8a9e	20 cb a6	jsr $a6cb			jsr 	StackClose
.8aa1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8aa2					Command_Read:
.8aa2	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8aa4	20 45 98	jsr $9845			jsr 	EvaluateTerm
.8aa7	b5 50		lda $50,x			lda 	NSStatus,x
.8aa9	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8aab	f0 4f		beq $8afc			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.8aad	20 45 8b	jsr $8b45			jsr 	SwapDataCodePtrs 			; swap code and data
.8ab0	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8ab3	d0 25		bne $8ada			bne 	_CRContinueData  			; forward for the next one.
.8ab5	b2 30		lda ($30)			lda 	(codePtr)
.8ab7	f0 1c		beq $8ad5			beq 	_CRNoData
.8ab9					_CRKeepSearching:
.8ab9	a9 b4		lda #$b4			lda 	#KWD_DATA 					; scan for instruction
.8abb	a2 80		ldx #$80			ldx 	#KWC_EOL
.8abd	20 39 8e	jsr $8e39			jsr 	ScanForward
.8ac0	c9 b4		cmp #$b4			cmp 	#KWD_DATA 					; found data ?
.8ac2	f0 16		beq $8ada			beq 	_CRHaveData 				; found it
.8ac4	18		clc				clc
.8ac5	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8ac7	65 30		adc $30				adc 	codePtr
.8ac9	85 30		sta $30				sta 	codePtr
.8acb	90 02		bcc $8acf			bcc 	_CREExit
.8acd	e6 31		inc $31				inc 	codePtr+1 					; carry
.8acf					_CREExit:
.8acf	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8ad1	b2 30		lda ($30)			lda 	(codePtr)
.8ad3	d0 e4		bne $8ab9			bne 	_CRKeepSearching
.8ad5					_CRNoData:
.8ad5	a9 0b		lda #$0b		lda	#11
.8ad7	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.8ada					_CRHaveData:
.8ada					_CRContinueData:
.8ada	a2 01		ldx #$01			ldx 	#1
.8adc	20 5e 9d	jsr $9d5e			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8adf	ca		dex				dex
.8ae0	20 4d 88	jsr $884d			jsr		AssignVariable 				; do the assignment
.8ae3	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data flag
.8ae6	b1 30		lda ($30),y			lda 	(codePtr),y
.8ae8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.8aea	d0 04		bne $8af0			bne 	_CRSwapBack
.8aec	c8		iny				iny 								; consume comma
.8aed	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8af0					_CRSwapBack:
.8af0	20 45 8b	jsr $8b45			jsr 	SwapDataCodePtrs			; swap them back.
.8af3	b1 30		lda ($30),y			lda 	(codePtr),y
.8af5	c8		iny				iny
.8af6	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8af8	f0 a8		beq $8aa2			beq 	Command_Read 				; if so go round again.
.8afa	88		dey				dey 								; unpick get.
.8afb	60		rts				rts
.8afc					_CRSyntax:
.8afc	4c 97 9f	jmp $9f97			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8aff					RemCommand:
.8aff	b1 30		lda ($30),y			lda 	(codePtr),y
.8b01	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8b03	d0 06		bne $8b0b			bne 	_RMExit
.8b05	c8		iny				iny 								; point to offset
.8b06	98		tya				tya 								; A = offset position
.8b07	38		sec				sec 								; add size +1 hence SEC
.8b08	71 30		adc ($30),y			adc 	(codePtr),y
.8b0a	a8		tay				tay 								; make current position.
.8b0b					_RMExit:
.8b0b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8b0c					Command_REPEAT:
.8b0c	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8b0e	20 ac a6	jsr $a6ac			jsr 	StackOpen
.8b11	20 f1 a6	jsr $a6f1			jsr 	STKSaveCodePosition 		; save loop position
.8b14	60		rts				rts
.8b15					Command_UNTIL:
.8b15	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8b17	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8b19	20 d9 a6	jsr $a6d9			jsr 	StackCheckFrame
.8b1c	a2 00		ldx #$00			ldx 	#0
.8b1e	20 67 9d	jsr $9d67			jsr 	EvaluateNumber 				; work out the number
.8b21	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; check if zero
.8b24	f0 04		beq $8b2a			beq 	_CULoopBack 				; if so keep looping
.8b26	20 cb a6	jsr $a6cb			jsr 	StackClose		 			; return
.8b29	60		rts				rts
.8b2a					_CULoopBack:
.8b2a	20 02 a7	jsr $a702			jsr 	STKLoadCodePosition 		; loop back
.8b2d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8b2e					Command_Restore:
.8b2e	20 45 8b	jsr $8b45			jsr 	SwapDataCodePtrs 			; swap code and data
.8b31	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b33	85 30		sta $30				sta 	codePtr
.8b35	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b37	85 31		sta $31				sta 	codePtr+1
.8b39	20 45 8b	jsr $8b45			jsr 	SwapDataCodePtrs 			; put them back
.8b3c	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8b3e	8d 1b 04	sta $041b			sta 	dataPointer+4   			; (read checks not EOF)
.8b41	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8b44	60		rts				rts
.8b45					SwapDataCodePtrs:
.8b45	da		phx				phx
.8b46	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8b48					_SDCPLoop:
.8b48	b5 30		lda $30,x			lda 	safePtr,x
.8b4a	48		pha				pha
.8b4b	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8b4e	95 30		sta $30,x			sta 	safePtr,x
.8b50	68		pla				pla
.8b51	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8b54	ca		dex				dex
.8b55	10 f1		bpl $8b48			bpl 	_SDCPLoop
.8b57	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8b5a	8c 1b 04	sty $041b			sty 	dataPointer+4
.8b5d	a8		tay				tay
.8b5e	fa		plx				plx
.8b5f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8b60					EOLCommand:
.8b60	18		clc				clc
.8b61	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8b63	65 30		adc $30				adc 	codePtr
.8b65	85 30		sta $30				sta 	codePtr
.8b67	90 02		bcc $8b6b			bcc 	_CREExit
.8b69	e6 31		inc $31				inc 	codePtr+1 					; carry
.8b6b					_CREExit:
.8b6b	80 0b		bra $8b78			bra 	RunNewLine
.8b6d					CommandRUN:
.8b6d	20 6b 84	jsr $846b			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8b70	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b72	85 30		sta $30				sta 	codePtr
.8b74	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b76	85 31		sta $31				sta 	codePtr+1
.8b78					RUNNewLine:
.8b78	b2 30		lda ($30)			lda 	(codePtr)
.8b7a	f0 7b		beq $8bf7			beq 	CRNoProgram         		; no then END.
.8b7c	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8b7e	9a		txs				txs
.8b7f					RUNCodePointerLine:
.8b7f	a0 02		ldy #$02			ldy 	#2 							; start of program
.8b81					_CRIncMainLoop:
.8b81	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8b84	d0 22		bne $8ba8			bne 	_CRNoBreakCheck
.8b86	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8b89	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8b8c	f0 64		beq $8bf2			beq 	_CRBreak
.8b8e	a5 01		lda $01				lda 	1 							; save I/O 0
.8b90	48		pha				pha
.8b91	64 01		stz $01				stz 	1 							; access I/O Page 0
.8b93	38		sec				sec 								; calculate timer - LastTick
.8b94	ad 59 d6	lda $d659			lda 	$D659
.8b97	aa		tax				tax 								; saving timer in X
.8b98	ed 5c 06	sbc $065c			sbc 	LastTick
.8b9b	c9 03		cmp #$03			cmp 	#3
.8b9d	90 06		bcc $8ba5			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8b9f	8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.8ba2	20 44 9e	jsr $9e44			jsr 	TickHandler 							; go do the code.
.8ba5					_NoFireTick:
.8ba5	68		pla				pla 								; restore I/O 0
.8ba6	85 01		sta $01				sta 	1
.8ba8					_CRNoBreakCheck:
.8ba8	c8		iny				iny									; next token
.8ba9					_CRMainLoop:
.8ba9	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8bac	b1 30		lda ($30),y			lda 	(codePtr),y
.8bae	10 10		bpl $8bc0			bpl 	_CRNotKeyword				; not a token.
.8bb0	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8bb2	b0 04		bcs $8bb8			bcs 	_CRIsKeyword
.8bb4	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8bb6	b0 34		bcs $8bec			bcs		_CRSyntaxError
.8bb8					_CRIsKeyword:
.8bb8	c8		iny				iny 								; consume command
.8bb9	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8bba	aa		tax				tax 								; put in X for vector jump
.8bbb	20 ef 8b	jsr $8bef			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8bbe	80 e9		bra $8ba9			bra 	_CRMainLoop 				; and loop round
.8bc0					_CRNotKeyword:
.8bc0	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8bc2	f0 bd		beq $8b81			beq 	_CRIncMainLoop
.8bc4	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8bc6	90 05		bcc $8bcd			bcc 	_CRNotVariable
.8bc8					_CRGoLet:
.8bc8	20 14 88	jsr $8814			jsr 	LetCommand
.8bcb	80 dc		bra $8ba9			bra 	_CRMainLoop
.8bcd					_CRNotVariable:
.8bcd	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8bcf	f0 f7		beq $8bc8			beq 	_CRGoLet
.8bd1	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8bd3	f0 f3		beq $8bc8			beq 	_CRGoLet
.8bd5	c9 21		cmp #$21			cmp 	#KWD_PLING
.8bd7	f0 ef		beq $8bc8			beq 	_CRGoLet
.8bd9	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8bdb	f0 09		beq $8be6			beq 	_CRGoRem
.8bdd	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8bdf	d0 0b		bne $8bec			bne 	_CRSyntaxError
.8be1	20 4f 82	jsr $824f			jsr 	LabelHere
.8be4	80 c3		bra $8ba9			bra 	_CRMainLoop
.8be6					_CRGoRem:
.8be6	c8		iny				iny
.8be7	20 ff 8a	jsr $8aff			jsr 	RemCommand
.8bea	80 bd		bra $8ba9			bra 	_CRMainLoop
.8bec					_CRSyntaxError:
.8bec	4c 97 9f	jmp $9f97			jmp 	SyntaxError
.8bef					_CRCallVector0:
.8bef	7c 8e 8c	jmp ($8c8e,x)			jmp 	(VectorSet0,x)
.8bf2					_CRBreak:
.8bf2	a9 01		lda #$01		lda	#1
.8bf4	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.8bf7					CRNoProgram:
.8bf7	4c b9 85	jmp $85b9			jmp 	EndCommand
.8bfa					Shift1Command:
.8bfa	b1 30		lda ($30),y			lda 	(codePtr),y
.8bfc	c8		iny				iny
.8bfd	0a		asl a				asl 	a
.8bfe	aa		tax				tax
.8bff	7c 34 8d	jmp ($8d34,x)			jmp 	(VectorSet1,x)
.8c02					Shift2Command:
.8c02	b1 30		lda ($30),y			lda 	(codePtr),y
.8c04	c8		iny				iny
.8c05	0a		asl a				asl 	a
.8c06	aa		tax				tax
.8c07	7c 5a 8d	jmp ($8d5a,x)			jmp 	(VectorSet2,x)
.8c0a					Unused1:
.8c0a					Unused2:
.8c0a					Unused3:
.8c0a					Unused4:
.8c0a	4c 97 9f	jmp $9f97			jmp 	SyntaxError
>8c0d							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8c0e					VectorSetPunc:
>8c0e	af 91					.word	ShiftLeft                        ; $00 <<
>8c10	9a 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8c12	90 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8c14	97 9f					.word	SyntaxError                      ; $03 !!3
>8c16	97 9f					.word	SyntaxError                      ; $04 ><
>8c18	a4 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8c1a	b2 91					.word	ShiftRight                       ; $06 >>
>8c1c	97 9f					.word	SyntaxError                      ; $07 !!7
>8c1e	97 9f					.word	SyntaxError                      ; $08 !!8
>8c20	97 9f					.word	SyntaxError                      ; $09 !!9
>8c22	97 9f					.word	SyntaxError                      ; $0a !!10
>8c24	97 9f					.word	SyntaxError                      ; $0b !!11
>8c26	97 9f					.word	SyntaxError                      ; $0c !!12
>8c28	97 9f					.word	SyntaxError                      ; $0d !!13
>8c2a	97 9f					.word	SyntaxError                      ; $0e !!14
>8c2c	97 9f					.word	SyntaxError                      ; $0f !!15
>8c2e	97 9f					.word	SyntaxError                      ; $10 @
>8c30	97 9f					.word	SyntaxError                      ; $11 !!17
>8c32	97 9f					.word	SyntaxError                      ; $12 !!18
>8c34	97 9f					.word	SyntaxError                      ; $13 [
>8c36	5b 90					.word	IntegerDivide                    ; $14 \
>8c38	97 9f					.word	SyntaxError                      ; $15 ]
>8c3a	ed 92					.word	EorInteger                       ; $16 ^
>8c3c	97 9f					.word	SyntaxError                      ; $17 _
>8c3e	97 9f					.word	SyntaxError                      ; $18 `
>8c40	97 9f					.word	SyntaxError                      ; $19 !!25
>8c42	97 9f					.word	SyntaxError                      ; $1a !!26
>8c44	97 9f					.word	SyntaxError                      ; $1b {
>8c46	b8 92					.word	OraInteger                       ; $1c |
>8c48	97 9f					.word	SyntaxError                      ; $1d }
>8c4a	97 9f					.word	SyntaxError                      ; $1e ~
>8c4c	97 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8c4e	97 9f					.word	SyntaxError                      ; $20
>8c50	22 93					.word	WordIndirect                     ; $21 !
>8c52	97 9f					.word	SyntaxError                      ; $22 "
>8c54	97 9f					.word	SyntaxError                      ; $23 #
>8c56	97 9f					.word	SyntaxError                      ; $24 $
>8c58	9c 90					.word	IntegerModulus                   ; $25 %
>8c5a	83 92					.word	AndInteger                       ; $26 &
>8c5c	97 9f					.word	SyntaxError                      ; $27 '
>8c5e	97 9f					.word	SyntaxError                      ; $28 (
>8c60	97 9f					.word	SyntaxError                      ; $29 )
>8c62	0a 91					.word	MulInteger                       ; $2a *
>8c64	25 92					.word	AddInteger                       ; $2b +
>8c66	97 9f					.word	SyntaxError                      ; $2c ,
>8c68	5e 92					.word	SubInteger                       ; $2d -
>8c6a	97 9f					.word	SyntaxError                      ; $2e .
>8c6c	dc 94					.word	FDivideCommand                   ; $2f /
>8c6e	97 9f					.word	SyntaxError                      ; $30 0
>8c70	97 9f					.word	SyntaxError                      ; $31 1
>8c72	97 9f					.word	SyntaxError                      ; $32 2
>8c74	97 9f					.word	SyntaxError                      ; $33 3
>8c76	97 9f					.word	SyntaxError                      ; $34 4
>8c78	97 9f					.word	SyntaxError                      ; $35 5
>8c7a	97 9f					.word	SyntaxError                      ; $36 6
>8c7c	97 9f					.word	SyntaxError                      ; $37 7
>8c7e	97 9f					.word	SyntaxError                      ; $38 8
>8c80	97 9f					.word	SyntaxError                      ; $39 9
>8c82	97 9f					.word	SyntaxError                      ; $3a :
>8c84	97 9f					.word	SyntaxError                      ; $3b ;
>8c86	7c 8f					.word	BinaryCompareLess                ; $3c <
>8c88	72 8f					.word	BinaryCompareEqual               ; $3d =
>8c8a	86 8f					.word	BinaryCompareGreater             ; $3e >
>8c8c	44 93					.word	ByteIndirect                     ; $3f ?
.8c8e					VectorSet0:
>8c8e	60 8b					.word	EOLCommand                       ; $80 !0:EOF
>8c90	fa 8b					.word	Shift1Command                    ; $81 !1:SH1
>8c92	02 8c					.word	Shift2Command                    ; $82 !2:SH2
>8c94	c1 99					.word	AbsUnary                         ; $83 ABS(
>8c96	cf 99					.word	AllocUnary                       ; $84 ALLOC(
>8c98	3f 9a					.word	AscUnary                         ; $85 ASC(
>8c9a	ff 9b					.word	ChrUnary                         ; $86 CHR$(
>8c9c	4f 9a					.word	DeekUnary                        ; $87 DEEK(
>8c9e	e8 a3					.word	UnaryEvent                       ; $88 EVENT(
>8ca0	6e 8f					.word	UnaryFalse                       ; $89 FALSE
>8ca2	61 9a					.word	FracUnary                        ; $8a FRAC(
>8ca4	84 a3					.word	UnaryHit                         ; $8b HIT(
>8ca6	76 9a					.word	IntUnary                         ; $8c INT(
>8ca8	be 9b					.word	IsValUnary                       ; $8d ISVAL(
>8caa	6c a4					.word	UnaryJoyB                        ; $8e JOYB(
>8cac	45 a4					.word	UnaryJoyX                        ; $8f JOYX(
>8cae	48 a4					.word	UnaryJoyY                        ; $90 JOYY(
>8cb0	d2 9c					.word	Unary_Left                       ; $91 LEFT$(
>8cb2	87 9a					.word	LenUnary                         ; $92 LEN(
>8cb4	a5 9a					.word	Unary_Max                        ; $93 MAX(
>8cb6	f4 9c					.word	Unary_Mid                        ; $94 MID$(
>8cb8	a1 9a					.word	Unary_Min                        ; $95 MIN(
>8cba	f0 9a					.word	Unary_Not                        ; $96 NOT(
>8cbc	4c 9a					.word	PeekUnary                        ; $97 PEEK(
>8cbe	09 a6					.word	UnaryPlaying                     ; $98 PLAYING(
>8cc0	03 9b					.word	Unary_Random                     ; $99 RANDOM(
>8cc2	df 9c					.word	Unary_Right                      ; $9a RIGHT$(
>8cc4	20 9b					.word	Unary_Rnd                        ; $9b RND(
>8cc6	96 9b					.word	SgnUnary                         ; $9c SGN(
>8cc8	11 9c					.word	SpcUnary                         ; $9d SPC(
>8cca	2c 9c					.word	Unary_Str                        ; $9e STR$(
>8ccc	92 a4					.word	UnaryTimer                       ; $9f TIMER(
>8cce	63 8f					.word	UnaryTrue                        ; $a0 TRUE
>8cd0	b4 9b					.word	ValUnary                         ; $a1 VAL(
>8cd2	bc 85					.word	ForCommand                       ; $a2 FOR
>8cd4	ff 86					.word	IfCommand                        ; $a3 IF
>8cd6	0a 8c					.word	Unused1                          ; $a4 PROC
>8cd8	0c 8b					.word	Command_REPEAT                   ; $a5 REPEAT
>8cda	af 8e					.word	Command_WHILE                    ; $a6 WHILE
>8cdc	28 87					.word	EndIf                            ; $a7 ENDIF
>8cde	94 8a					.word	Command_ENDPROC                  ; $a8 ENDPROC
>8ce0	6e 86					.word	NextCommand                      ; $a9 NEXT
>8ce2	0a 8c					.word	Unused4                          ; $aa THEN
>8ce4	15 8b					.word	Command_UNTIL                    ; $ab UNTIL
>8ce6	d0 8e					.word	Command_WEND                     ; $ac WEND
>8ce8	97 9f					.word	SyntaxError                      ; $ad BY
>8cea	36 84					.word	CallCommand                      ; $ae CALL
>8cec	38 a1					.word	CircleCommand                    ; $af CIRCLE
>8cee	6b 84					.word	ClearCommand                     ; $b0 CLEAR
>8cf0	c3 84					.word	ClearScreen                      ; $b1 CLS
>8cf2	97 9f					.word	SyntaxError                      ; $b2 COLOR
>8cf4	97 9f					.word	SyntaxError                      ; $b3 COLOUR
>8cf6	cb 84					.word	Command_Data                     ; $b4 DATA
>8cf8	d3 84					.word	DimCommand                       ; $b5 DIM
>8cfa	93 85					.word	DokeCommand                      ; $b6 DOKE
>8cfc	0a 8c					.word	Unused3                          ; $b7 DOWNTO
>8cfe	21 87					.word	ElseCode                         ; $b8 ELSE
>8d00	97 9f					.word	SyntaxError                      ; $b9 FROM
>8d02	57 a3					.word	GfxCommand                       ; $ba GFX
>8d04	c7 86					.word	Command_GOSUB                    ; $bb GOSUB
>8d06	e5 86					.word	GotoCommand                      ; $bc GOTO
>8d08	97 9f					.word	SyntaxError                      ; $bd HERE
>8d0a	61 a1					.word	ImageCommand                     ; $be IMAGE
>8d0c	29 87					.word	Command_Input                    ; $bf INPUT
>8d0e	14 88					.word	LetCommand                       ; $c0 LET
>8d10	b3 a1					.word	LineCommand                      ; $c1 LINE
>8d12	65 89					.word	Command_LOCAL                    ; $c2 LOCAL
>8d14	97 9f					.word	SyntaxError                      ; $c3 OFF
>8d16	97 9f					.word	SyntaxError                      ; $c4 ON
>8d18	97 9f					.word	SyntaxError                      ; $c5 OUTLINE
>8d1a	a8 a3					.word	PaletteCommand                   ; $c6 PALETTE
>8d1c	ac a1					.word	PlotCommand                      ; $c7 PLOT
>8d1e	90 85					.word	PokeCommand                      ; $c8 POKE
>8d20	30 87					.word	Command_Print                    ; $c9 PRINT
>8d22	a2 8a					.word	Command_Read                     ; $ca READ
>8d24	34 a1					.word	RectangleCommand                 ; $cb RECT
>8d26	ff 8a					.word	RemCommand                       ; $cc REM
>8d28	d7 86					.word	Command_RETURN                   ; $cd RETURN
>8d2a	97 9f					.word	SyntaxError                      ; $ce SOLID
>8d2c	25 a6					.word	SoundCommand                     ; $cf SOUND
>8d2e	43 a1					.word	SpriteCommand                    ; $d0 SPRITE
>8d30	7d a1					.word	TextCommand                      ; $d1 TEXT
>8d32	0a 8c					.word	Unused2                          ; $d2 TO
.8d34					VectorSet1:
>8d34	97 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d36	97 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d38	97 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d3a	0a 84					.word	AssembleCommand                  ; $83 ASSEMBLE
>8d3c	26 84					.word	AssertCommand                    ; $84 ASSERT
>8d3e	f7 a2					.word	BitmapCtrl                       ; $85 BITMAP
>8d40	b9 85					.word	EndCommand                       ; $86 END
>8d42	dd a5					.word	Explode                          ; $87 EXPLODE
>8d44	89 a4					.word	GoCommand                        ; $88 GO
>8d46	64 88					.word	Command_List                     ; $89 LIST
>8d48	80 a4					.word	LoadCommand                      ; $8a LOAD
>8d4a	26 8a					.word	NewCommand                       ; $8b NEW
>8d4c	b9 a5					.word	PingCommand                      ; $8c PING
>8d4e	2e 8b					.word	Command_Restore                  ; $8d RESTORE
>8d50	6d 8b					.word	CommandRUN                       ; $8e RUN
>8d52	d1 a5					.word	ShootCommand                     ; $8f SHOOT
>8d54	3c a3					.word	SpritesCtrl                      ; $90 SPRITES
>8d56	e2 8d					.word	StopCommand                      ; $91 STOP
>8d58	c5 a5					.word	ZapCommand                       ; $92 ZAP
.8d5a					VectorSet2:
>8d5a	97 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d5c	97 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d5e	97 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d60	56 9e					.word	Assemble_adc                     ; $83 ADC
>8d62	4e 9e					.word	Assemble_and                     ; $84 AND
>8d64	6a 9e					.word	Assemble_asl                     ; $85 ASL
>8d66	d4 9e					.word	Assemble_bcc                     ; $86 BCC
>8d68	d8 9e					.word	Assemble_bcs                     ; $87 BCS
>8d6a	e0 9e					.word	Assemble_beq                     ; $88 BEQ
>8d6c	97 9e					.word	Assemble_bit                     ; $89 BIT
>8d6e	c8 9e					.word	Assemble_bmi                     ; $8a BMI
>8d70	dc 9e					.word	Assemble_bne                     ; $8b BNE
>8d72	c4 9e					.word	Assemble_bpl                     ; $8c BPL
>8d74	e4 9e					.word	Assemble_bra                     ; $8d BRA
>8d76	e8 9e					.word	Assemble_brk                     ; $8e BRK
>8d78	cc 9e					.word	Assemble_bvc                     ; $8f BVC
>8d7a	d0 9e					.word	Assemble_bvs                     ; $90 BVS
>8d7c	f0 9e					.word	Assemble_clc                     ; $91 CLC
>8d7e	44 9f					.word	Assemble_cld                     ; $92 CLD
>8d80	04 9f					.word	Assemble_cli                     ; $93 CLI
>8d82	34 9f					.word	Assemble_clv                     ; $94 CLV
>8d84	62 9e					.word	Assemble_cmp                     ; $95 CMP
>8d86	ab 9e					.word	Assemble_cpx                     ; $96 CPX
>8d88	a6 9e					.word	Assemble_cpy                     ; $97 CPY
>8d8a	88 9e					.word	Assemble_dec                     ; $98 DEC
>8d8c	40 9f					.word	Assemble_dex                     ; $99 DEX
>8d8e	1c 9f					.word	Assemble_dey                     ; $9a DEY
>8d90	52 9e					.word	Assemble_eor                     ; $9b EOR
>8d92	8d 9e					.word	Assemble_inc                     ; $9c INC
>8d94	50 9f					.word	Assemble_inx                     ; $9d INX
>8d96	3c 9f					.word	Assemble_iny                     ; $9e INY
>8d98	bf 9e					.word	Assemble_jmp                     ; $9f JMP
>8d9a	ba 9e					.word	Assemble_jsr                     ; $a0 JSR
>8d9c	5e 9e					.word	Assemble_lda                     ; $a1 LDA
>8d9e	83 9e					.word	Assemble_ldx                     ; $a2 LDX
>8da0	a1 9e					.word	Assemble_ldy                     ; $a3 LDY
>8da2	74 9e					.word	Assemble_lsr                     ; $a4 LSR
>8da4	54 9f					.word	Assemble_nop                     ; $a5 NOP
>8da6	4a 9e					.word	Assemble_ora                     ; $a6 ORA
>8da8	00 9f					.word	Assemble_pha                     ; $a7 PHA
>8daa	ec 9e					.word	Assemble_php                     ; $a8 PHP
>8dac	48 9f					.word	Assemble_phx                     ; $a9 PHX
>8dae	08 9f					.word	Assemble_phy                     ; $aa PHY
>8db0	10 9f					.word	Assemble_pla                     ; $ab PLA
>8db2	f4 9e					.word	Assemble_plp                     ; $ac PLP
>8db4	5c 9f					.word	Assemble_plx                     ; $ad PLX
>8db6	18 9f					.word	Assemble_ply                     ; $ae PLY
>8db8	6f 9e					.word	Assemble_rol                     ; $af ROL
>8dba	79 9e					.word	Assemble_ror                     ; $b0 ROR
>8dbc	fc 9e					.word	Assemble_rti                     ; $b1 RTI
>8dbe	0c 9f					.word	Assemble_rts                     ; $b2 RTS
>8dc0	66 9e					.word	Assemble_sbc                     ; $b3 SBC
>8dc2	f8 9e					.word	Assemble_sec                     ; $b4 SEC
>8dc4	58 9f					.word	Assemble_sed                     ; $b5 SED
>8dc6	14 9f					.word	Assemble_sei                     ; $b6 SEI
>8dc8	5a 9e					.word	Assemble_sta                     ; $b7 STA
>8dca	4c 9f					.word	Assemble_stp                     ; $b8 STP
>8dcc	7e 9e					.word	Assemble_stx                     ; $b9 STX
>8dce	9c 9e					.word	Assemble_sty                     ; $ba STY
>8dd0	92 9e					.word	Assemble_stz                     ; $bb STZ
>8dd2	30 9f					.word	Assemble_tax                     ; $bc TAX
>8dd4	2c 9f					.word	Assemble_tay                     ; $bd TAY
>8dd6	b5 9e					.word	Assemble_trb                     ; $be TRB
>8dd8	b0 9e					.word	Assemble_tsb                     ; $bf TSB
>8dda	38 9f					.word	Assemble_tsx                     ; $c0 TSX
>8ddc	20 9f					.word	Assemble_txa                     ; $c1 TXA
>8dde	28 9f					.word	Assemble_txs                     ; $c2 TXS
>8de0	24 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8de2					StopCommand:
.8de2	a9 08		lda #$08		lda	#8
.8de4	4c f7 8e	jmp $8ef7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8de7					ProcedureScan:
.8de7	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8de9	85 30		sta $30				sta 	codePtr
.8deb	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8ded	85 31		sta $31				sta 	codePtr+1
.8def					_PSLoop:
.8def	b2 30		lda ($30)			lda 	(codePtr)
.8df1	f0 42		beq $8e35			beq 	_PSExit
.8df3	a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.8df5	b1 30		lda ($30),y			lda 	(codePtr),y
.8df7	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8df9	d0 2d		bne $8e28			bne 	_PSNext
.8dfb	c8		iny				iny 								; get the address of the record to zTemp0 and
.8dfc	b1 30		lda ($30),y			lda 	(codePtr),y
.8dfe	29 c0		and #$c0			and 	#$C0
.8e00	c9 40		cmp #$40			cmp 	#$40
.8e02	d0 32		bne $8e36			bne 	_PSSyntax
.8e04	b1 30		lda ($30),y			lda 	(codePtr),y
.8e06	18		clc				clc
.8e07	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8e09	85 37		sta $37				sta 	zTemp0+1
.8e0b	c8		iny				iny 								; LSB
.8e0c	b1 30		lda ($30),y			lda 	(codePtr),y
.8e0e	85 36		sta $36				sta 	zTemp0
.8e10	c8		iny				iny 								; character after variable call.
.8e11	98		tya				tya 								; save Y offset at +7 (exponent slot)
.8e12	a0 07		ldy #$07			ldy 	#7
.8e14	91 36		sta ($36),y			sta 	(zTemp0),y
.8e16	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8e18	a0 02		ldy #$02			ldy 	#2
.8e1a	91 36		sta ($36),y			sta 	(zTemp0),y
.8e1c	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.8e1e					_PSCopy:
.8e1e	b5 30		lda $30,x			lda 	safePtr,x
.8e20	c8		iny				iny
.8e21	91 36		sta ($36),y			sta 	(zTemp0),y
.8e23	e8		inx				inx
.8e24	e0 04		cpx #$04			cpx 	#4
.8e26	d0 f6		bne $8e1e			bne 	_PSCopy
.8e28					_PSNext:
.8e28	18		clc				clc
.8e29	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e2b	65 30		adc $30				adc 	codePtr
.8e2d	85 30		sta $30				sta 	codePtr
.8e2f	90 02		bcc $8e33			bcc 	_CREExit
.8e31	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e33					_CREExit:
.8e33	80 ba		bra $8def			bra 	_PSLoop
.8e35					_PSExit:
.8e35	60		rts				rts
.8e36					_PSSyntax:
.8e36	4c 97 9f	jmp $9f97			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8e39					ScanForward:
.8e39	64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.8e3b	86 37		stx $37				stx 	zTemp0+1
.8e3d	85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.8e3f					_ScanLoop:
.8e3f	b1 30		lda ($30),y			lda 	(codePtr),y
.8e41	c8		iny				iny
.8e42	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8e44	d0 0e		bne $8e54			bne 	_ScanGoNext
.8e46	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8e48	f0 04		beq $8e4e			beq 	_ScanMatch
.8e4a	c5 37		cmp $37				cmp 	zTemp0+1
.8e4c	d0 06		bne $8e54			bne 	_ScanGoNext
.8e4e					_ScanMatch:
.8e4e	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8e50	d0 01		bne $8e53			bne 	_ScanNotEndEOL
.8e52	88		dey				dey
.8e53					_ScanNotEndEOL:
.8e53	60		rts				rts
.8e54					_ScanGoNext:
.8e54	20 59 8e	jsr $8e59			jsr  	ScanForwardOne 				; allows for shifts and so on.
.8e57	80 e6		bra $8e3f			bra 	_ScanLoop
.8e59					ScanForwardOne:
.8e59	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.8e5b	90 3e		bcc $8e9b			bcc 	_SFWExit
.8e5d	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.8e5f	90 18		bcc $8e79			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.8e61	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.8e63	b0 2f		bcs $8e94			bcs 	_ScanSkipData
.8e65	c9 a2		cmp #$a2			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8e67	90 32		bcc $8e9b			bcc 	_SFWExit 					; if not, ordinary keywords.
.8e69	c9 ad		cmp #$ad			cmp 	#KWC_LAST_STRUCTURE+1
.8e6b	b0 2e		bcs $8e9b			bcs 	_SFWExit
.8e6d	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8e6f	c9 a7		cmp #$a7			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8e71	b0 28		bcs $8e9b			bcs 	_SFWExit
.8e73	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8e75	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8e77	80 22		bra $8e9b			bra 	_SFWExit
.8e79					_ScanSkipOne:
.8e79	c8		iny				iny 								; consume the extra one.
.8e7a	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8e7c	d0 1d		bne $8e9b			bne 	_SFWExit
.8e7e	18		clc				clc
.8e7f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e81	65 30		adc $30				adc 	codePtr
.8e83	85 30		sta $30				sta 	codePtr
.8e85	90 02		bcc $8e89			bcc 	_CREExit
.8e87	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e89					_CREExit:
.8e89	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8e8b	b2 30		lda ($30)			lda 	(codePtr)
.8e8d	d0 0c		bne $8e9b			bne 	_SFWExit 					; if not zero, more to scan
.8e8f	a9 13		lda #$13		lda	#19
.8e91	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.8e94					_ScanSkipData:
.8e94	88		dey				dey 								; point at data token
.8e95	c8		iny				iny 								; point to offset
.8e96	98		tya				tya 								; A = offset position
.8e97	38		sec				sec 								; add size +1 hence SEC
.8e98	71 30		adc ($30),y			adc 	(codePtr),y
.8e9a	a8		tay				tay 								; make current position.
.8e9b					_SFWExit:
.8e9b	60		rts				rts
.8e9c					ScanGetCurrentLineStep:
.8e9c	64 38		stz $38				stz 	zTemp1
.8e9e	a0 03		ldy #$03			ldy 	#3
.8ea0					_SGCLSLoop:
.8ea0	b1 30		lda ($30),y			lda 	(codePtr),y
.8ea2	c8		iny				iny
.8ea3	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8ea5	f0 05		beq $8eac			beq 	_SGCLSExit
.8ea7	20 59 8e	jsr $8e59			jsr 	ScanForwardOne
.8eaa	80 f4		bra $8ea0			bra 	_SGCLSLoop
.8eac					_SGCLSExit:
.8eac	a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.8eae	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8eaf					Command_WHILE:
.8eaf	5a		phy				phy 								; save position of the test
.8eb0	a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.8eb2	20 67 9d	jsr $9d67			jsr 	EvaluateNumber
.8eb5	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; check if zero
.8eb8	f0 0e		beq $8ec8			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.8eba	98		tya				tya 								; position *after* test.
.8ebb	7a		ply				ply 								; restore position before test, at WHILE
.8ebc	88		dey				dey 								; so we execute the WHILE command again.
.8ebd	48		pha				pha 								; push after test on the stack
.8ebe	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8ec0	20 ac a6	jsr $a6ac			jsr 	StackOpen
.8ec3	20 f1 a6	jsr $a6f1			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.8ec6	7a		ply				ply 								; restore the position *after* the test
.8ec7	60		rts				rts
.8ec8					_WHExitLoop:
.8ec8	68		pla				pla 								; throw post loop position
.8ec9	a9 ac		lda #$ac			lda 	#KWD_WEND 					; scan forward past WEND
.8ecb	aa		tax				tax
.8ecc	20 39 8e	jsr $8e39			jsr 	ScanForward
.8ecf	60		rts				rts
.8ed0					Command_WEND:
.8ed0	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.8ed2	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.8ed4	20 d9 a6	jsr $a6d9			jsr 	StackCheckFrame
.8ed7	20 02 a7	jsr $a702			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.8eda	20 cb a6	jsr $a6cb			jsr 	StackClose		 			; erase the frame
.8edd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8ede					CheckRightBracket:
.8ede	b1 30		lda ($30),y			lda 	(codePtr),y
.8ee0	c8		iny				iny
.8ee1	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8ee3	d0 0f		bne $8ef4			bne 	CNAFail
.8ee5	60		rts				rts
.8ee6					CheckComma:
.8ee6	b1 30		lda ($30),y			lda 	(codePtr),y
.8ee8	c8		iny				iny
.8ee9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8eeb	d0 07		bne $8ef4			bne 	CNAFail
.8eed	60		rts				rts
.8eee					CheckNextA:
.8eee	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8ef0	d0 02		bne $8ef4			bne 	CNAFail
.8ef2	c8		iny				iny 								; skip character
.8ef3	60		rts				rts 								; and exit
.8ef4					CNAFail:
.8ef4	4c 97 9f	jmp $9f97			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8ef7					ErrorHandler:
.8ef7	a8		tay				tay 								; find the error text
.8ef8	f0 49		beq $8f43			beq 	_EHEnd
.8efa	a2 00		ldx #$00			ldx 	#0
.8efc	a9 b0		lda #$b0			lda 	#((ErrorText) & $FF)
.8efe	85 36		sta $36				sta 	0+zTemp0
.8f00	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8f02	85 37		sta $37				sta 	1+zTemp0
.8f04					_EHFind:
.8f04	88		dey				dey 								; keep looking through text
.8f05	f0 0e		beq $8f15			beq 	_EHFound
.8f07					_EHFindZero:
.8f07	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8f09	e6 36		inc $36				inc 	zTemp0
.8f0b	d0 02		bne $8f0f			bne 	_EHFNoCarry
.8f0d	e6 37		inc $37				inc 	zTemp0+1
.8f0f					_EHFNoCarry:
.8f0f	c9 00		cmp #$00			cmp 	#0
.8f11	d0 f4		bne $8f07			bne 	_EHFindZero
.8f13	80 ef		bra $8f04			bra 	_EHFind
.8f15					_EHFound:
.8f15	a5 36		lda $36				lda 	zTemp0 						; print message
.8f17	a6 37		ldx $37				ldx 	zTemp0+1
.8f19	20 50 8f	jsr $8f50			jsr 	PrintStringXA
.8f1c	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8f1e	b1 30		lda ($30),y			lda 	(codePtr),y
.8f20	d0 05		bne $8f27			bne 	_EHAtMsg
.8f22	c8		iny				iny
.8f23	b1 30		lda ($30),y			lda 	(codePtr),y
.8f25	f0 17		beq $8f3e			beq 	_EHCREnd
.8f27					_EHAtMsg:
.8f27	a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8f29	a9 46		lda #$46			lda 	#_AtMsg & $FF
.8f2b	20 50 8f	jsr $8f50			jsr 	PrintStringXA
.8f2e	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f30	b1 30		lda ($30),y			lda 	(codePtr),y
.8f32	48		pha				pha
.8f33	c8		iny				iny
.8f34	b1 30		lda ($30),y			lda 	(codePtr),y
.8f36	aa		tax				tax
.8f37	68		pla				pla
.8f38	20 66 93	jsr $9366			jsr 	ConvertInt16 				; convert XA to string
.8f3b	20 50 8f	jsr $8f50			jsr 	PrintStringXA 				; and print it.
.8f3e					_EHCREnd:
.8f3e	a9 0d		lda #$0d			lda 	#13 						; new line
.8f40	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f43					_EHEnd:
.8f43	4c d5 83	jmp $83d5			jmp 	WarmStart
>8f46	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8f4e	20 00
.8f50					PrintStringXA:
.8f50	5a		phy				phy
.8f51	86 37		stx $37				stx 	zTemp0+1
.8f53	85 36		sta $36				sta 	zTemp0
.8f55	a0 00		ldy #$00			ldy 	#0
.8f57					_PSXALoop:
.8f57	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f59	f0 06		beq $8f61			beq 	_PSXAExit
.8f5b	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f5e	c8		iny				iny
.8f5f	80 f6		bra $8f57			bra 	_PSXALoop
.8f61					_PSXAExit:
.8f61	7a		ply				ply
.8f62	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f63					UnaryTrue:
.8f63	fa		plx				plx
.8f64					ReturnTrue:
.8f64	a9 01		lda #$01			lda 	#1  						; set to 1
.8f66	20 1b 9e	jsr $9e1b			jsr 	NSMSetByte
.8f69	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f6b	95 50		sta $50,x			sta 	NSStatus,x
.8f6d	60		rts				rts
.8f6e					UnaryFalse:
.8f6e	fa		plx				plx
.8f6f					ReturnFalse:
.8f6f	4c 19 9e	jmp $9e19			jmp 	NSMSetZero 					; set it all to zero
.8f72					BinaryCompareEqual:
.8f72	fa		plx				plx
.8f73	20 ae 8f	jsr $8fae			jsr 	CompareBaseCode
.8f76	c9 00		cmp #$00			cmp 	#0
.8f78	f0 ea		beq $8f64			beq 	ReturnTrue
.8f7a	80 f3		bra $8f6f			bra 	ReturnFalse
.8f7c					BinaryCompareLess:
.8f7c	fa		plx				plx
.8f7d	20 ae 8f	jsr $8fae			jsr 	CompareBaseCode
.8f80	c9 ff		cmp #$ff			cmp 	#$FF
.8f82	f0 e0		beq $8f64			beq 	ReturnTrue
.8f84	80 e9		bra $8f6f			bra 	ReturnFalse
.8f86					BinaryCompareGreater:
.8f86	fa		plx				plx
.8f87	20 ae 8f	jsr $8fae			jsr 	CompareBaseCode
.8f8a	c9 01		cmp #$01			cmp 	#1
.8f8c	f0 d6		beq $8f64			beq 	ReturnTrue
.8f8e	80 df		bra $8f6f			bra 	ReturnFalse
.8f90					BinaryCompareNotEqual:
.8f90	fa		plx				plx
.8f91	20 ae 8f	jsr $8fae			jsr 	CompareBaseCode
.8f94	c9 00		cmp #$00			cmp 	#0
.8f96	d0 cc		bne $8f64			bne 	ReturnTrue
.8f98	80 d5		bra $8f6f			bra 	ReturnFalse
.8f9a					BinaryCompareLessEqual:
.8f9a	fa		plx				plx
.8f9b	20 ae 8f	jsr $8fae			jsr 	CompareBaseCode
.8f9e	c9 01		cmp #$01			cmp 	#1
.8fa0	d0 c2		bne $8f64			bne 	ReturnTrue
.8fa2	80 cb		bra $8f6f			bra 	ReturnFalse
.8fa4					BinaryCompareGreaterEqual:
.8fa4	fa		plx				plx
.8fa5	20 ae 8f	jsr $8fae			jsr 	CompareBaseCode
.8fa8	c9 ff		cmp #$ff			cmp 	#$FF
.8faa	d0 b8		bne $8f64			bne 	ReturnTrue
.8fac	80 c1		bra $8f6f			bra 	ReturnFalse
.8fae					CompareBaseCode:
.8fae	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; make both values if references.
.8fb1	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8fb3	15 51		ora $51,x			ora 	NSStatus+1,x
.8fb5	29 10		and #$10			and 	#NSTString
.8fb7	d0 37		bne $8ff0			bne 	_CBCString 					; if so do string code, which will check if both.
.8fb9	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8fbb	15 79		ora $79,x			ora 	NSExponent+1,x
.8fbd	d0 34		bne $8ff3			bne 	_CBCFloat
.8fbf	b5 50		lda $50,x			lda 	NSStatus,x
.8fc1	15 51		ora $51,x			ora 	NSStatus+1,x
.8fc3	29 08		and #$08			and 	#NSTFloat
.8fc5	d0 2c		bne $8ff3			bne 	_CBCFloat
.8fc7	20 f6 8f	jsr $8ff6			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8fca	e8		inx				inx
.8fcb	20 f6 8f	jsr $8ff6			jsr 	CompareFixMinusZero
.8fce	ca		dex				dex
.8fcf	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8fd1	55 51		eor $51,x			eor 	NSStatus+1,x
.8fd3	10 0a		bpl $8fdf			bpl 	_CDCSameSign
.8fd5	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8fd7	30 14		bmi $8fed			bmi 	_CBCLess 					; return $FF
.8fd9					_CBCGreater:
.8fd9	a9 01		lda #$01			lda 	#1
.8fdb	60		rts				rts
.8fdc					_CBCEqual:
.8fdc	a9 00		lda #$00			lda 	#0
.8fde	60		rts				rts
.8fdf					_CDCSameSign:
.8fdf	20 0b 92	jsr $920b			jsr 	SubTopTwoStack 				; unsigned subtract
.8fe2	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; or the mantissa together
.8fe5	f0 f5		beq $8fdc			beq 	_CBCEqual 					; -0 == 0
.8fe7	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8fe9	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8feb	10 ec		bpl $8fd9			bpl 	_CBCGreater
.8fed					_CBCLess:
.8fed	a9 ff		lda #$ff			lda 	#$FF
.8fef	60		rts				rts
.8ff0					_CBCString:
.8ff0	4c 7c 91	jmp $917c			jmp 	CompareStrings
.8ff3					_CBCFloat:
.8ff3	4c c6 94	jmp $94c6			jmp 	CompareFloat
.8ff6					CompareFixMinusZero:
.8ff6	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero
.8ff9	d0 02		bne $8ffd			bne 	_CFXMZNotZero
.8ffb	74 50		stz $50,x			stz 	NSStatus,x
.8ffd					_CFXMZNotZero:
.8ffd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8ffe					StringConcat:
.8ffe	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9000	35 51		and $51,x			and 	NSStatus+1,x
.9002	29 18		and #$18			and 	#NSBTypeMask
.9004	c9 10		cmp #$10			cmp 	#NSTString
.9006	d0 50		bne $9058			bne		_SCType
.9008	64 38		stz $38				stz 	zTemp1 						; counting total length
.900a	e8		inx				inx
.900b	20 29 90	jsr $9029			jsr 	_SCSetupZ0 					; setup for second
.900e	20 32 90	jsr $9032			jsr 	_SCLengthZ0 				; length for second
.9011	ca		dex				dex
.9012	20 29 90	jsr $9029			jsr 	_SCSetupZ0 					; setup for first
.9015	20 32 90	jsr $9032			jsr 	_SCLengthZ0 				; length for first
.9018	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.901a	20 9c a7	jsr $a79c			jsr 	StringTempAllocate
.901d	20 49 90	jsr $9049			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9020	e8		inx				inx
.9021	20 29 90	jsr $9029			jsr 	_SCSetupZ0 					; copy second out
.9024	20 49 90	jsr $9049			jsr 	_SCCopy
.9027	ca		dex				dex
.9028	60		rts				rts
.9029					_SCSetupZ0:
.9029	b5 58		lda $58,x			lda 	NSMantissa0,x
.902b	85 36		sta $36				sta 	zTemp0
.902d	b5 60		lda $60,x			lda 	NSMantissa1,x
.902f	85 37		sta $37				sta 	zTemp0+1
.9031	60		rts				rts
.9032					_SCLengthZ0:
.9032	5a		phy				phy
.9033	a0 00		ldy #$00			ldy 	#0
.9035					_SCLenLoop:
.9035	b1 36		lda ($36),y			lda 	(zTemp0),y
.9037	f0 0e		beq $9047			beq 	_SCLExit
.9039	c8		iny				iny
.903a	e6 38		inc $38				inc 	zTemp1
.903c	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.903e	c9 fd		cmp #$fd			cmp 	#253
.9040	d0 f3		bne $9035			bne		_SCLenLoop
.9042	a9 09		lda #$09		lda	#9
.9044	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.9047					_SCLExit:
.9047	7a		ply				ply
.9048	60		rts				rts
.9049					_SCCopy:
.9049	5a		phy				phy
.904a	a0 00		ldy #$00			ldy 	#0
.904c					_SCCopyLoop:
.904c	b1 36		lda ($36),y			lda 	(zTemp0),y
.904e	f0 06		beq $9056			beq 	_SCCExit
.9050	20 d5 a7	jsr $a7d5			jsr 	StringTempWrite
.9053	c8		iny				iny
.9054	80 f6		bra $904c			bra 	_SCCopyLoop
.9056					_SCCExit:
.9056	7a		ply				ply
.9057	60		rts				rts
.9058					_SCType:
.9058	4c a1 9f	jmp $9fa1			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.905b					IntegerDivide:
.905b	fa		plx				plx
.905c	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.905e	15 51		ora $51,x			ora 	NSStatus+1,x
.9060	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9061	0a		asl a				asl 	a
.9062	10 05		bpl $9069			bpl 	_NotRef
.9064	48		pha				pha
.9065	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9068	68		pla				pla
.9069					_NotRef:
.9069	0a		asl a				asl 	a
.906a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.906c	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.906e	15 79		ora $79,x			ora 	NSExponent+1,x
.9070	f0 03		beq $9075			beq 	_IntegerCode 				; if clear, then we have two integers
.9072	4c a1 9f	jmp $9fa1			jmp 	TypeError 					; anything else, type mismatch.
.9075					_IntegerCode:
.9075	20 8f 90	jsr $908f			jsr 	CheckDivideZero 			; do div zero check
.9078	20 c1 90	jsr $90c1			jsr 	Int32Divide 				; do the division
.907b	20 72 91	jsr $9172			jsr 	CalculateSign 				; calculate result sign
.907e					NSMCopyPlusTwoToZero:
.907e	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9080	95 58		sta $58,x			sta 	NSMantissa0,x
.9082	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.9084	95 60		sta $60,x			sta 	NSMantissa1,x
.9086	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.9088	95 68		sta $68,x			sta 	NSMantissa2,x
.908a	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.908c	95 70		sta $70,x			sta 	NSMantissa3,x
.908e	60		rts				rts
.908f					CheckDivideZero:
.908f	e8		inx				inx
.9090	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero
.9093	f0 02		beq $9097			beq 	_CDVError
.9095	ca		dex				dex
.9096	60		rts				rts
.9097					_CDVError:
.9097	a9 03		lda #$03		lda	#3
.9099	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.909c					IntegerModulus:
.909c	fa		plx				plx
.909d	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.909f	15 51		ora $51,x			ora 	NSStatus+1,x
.90a1	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90a2	0a		asl a				asl 	a
.90a3	10 05		bpl $90aa			bpl 	_NotRef
.90a5	48		pha				pha
.90a6	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90a9	68		pla				pla
.90aa					_NotRef:
.90aa	0a		asl a				asl 	a
.90ab	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90ad	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90af	15 79		ora $79,x			ora 	NSExponent+1,x
.90b1	f0 03		beq $90b6			beq 	_IntegerCode 				; if clear, then we have two integers
.90b3	4c a1 9f	jmp $9fa1			jmp 	TypeError 					; anything else, type mismatch.
.90b6					_IntegerCode:
.90b6					IntegerModulusNoCheck:
.90b6	20 8f 90	jsr $908f			jsr 	CheckDivideZero 			; do div zero check
.90b9	20 c1 90	jsr $90c1			jsr 	Int32Divide 				; do the division
.90bc	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.90be	56 50		lsr $50,x			lsr 	NSStatus,x
.90c0	60		rts				rts
.90c1					Int32Divide:
.90c1	48		pha				pha 								; save AXY
.90c2	5a		phy				phy
.90c3	20 fc 9d	jsr $9dfc			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90c6	20 15 9e	jsr $9e15			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.90c9	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.90cb					_I32DivideLoop:
.90cb	e8		inx				inx
.90cc	e8		inx				inx
.90cd	20 28 9e	jsr $9e28			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.90d0	ca		dex				dex
.90d1	ca		dex				dex
.90d2	20 29 9e	jsr $9e29			jsr 	NSMRotateLeft
.90d5	20 00 91	jsr $9100			jsr 	DivideCheckSubtract 		; check if subtract possible
.90d8	90 02		bcc $90dc			bcc 	_I32DivideNoCarryIn
.90da	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.90dc					_I32DivideNoCarryIn:
.90dc	88		dey				dey 								; loop round till division completed.
.90dd	d0 ec		bne $90cb			bne 	_I32DivideLoop
.90df	7a		ply				ply 								; restore AXY and exit
.90e0	68		pla				pla
.90e1	60		rts				rts
.90e2					Int32ShiftDivide:
.90e2	48		pha				pha 								; save AY
.90e3	5a		phy				phy
.90e4	e8		inx				inx 								; clear S[X+2]
.90e5	e8		inx				inx
.90e6	20 19 9e	jsr $9e19			jsr 	NSMSetZero
.90e9	ca		dex				dex
.90ea	ca		dex				dex
.90eb	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.90ed					_I32SDLoop:
.90ed	20 00 91	jsr $9100			jsr 	DivideCheckSubtract 		; check if subtract possible
.90f0	e8		inx				inx
.90f1	e8		inx				inx
.90f2	20 29 9e	jsr $9e29			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.90f5	ca		dex				dex
.90f6	ca		dex				dex
.90f7	20 29 9e	jsr $9e29			jsr 	NSMRotateLeft
.90fa	88		dey				dey 	 							; do 31 times
.90fb	d0 f0		bne $90ed			bne 	_I32SDLoop
.90fd	7a		ply				ply 								; restore AY and exit
.90fe	68		pla				pla
.90ff	60		rts				rts
.9100					DivideCheckSubtract:
.9100	20 0b 92	jsr $920b			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9103	b0 04		bcs $9109			bcs 	_DCSExit 					; if carry set, then could do, exit
.9105	20 f1 91	jsr $91f1			jsr 	AddTopTwoStack 				; add it back in
.9108	18		clc				clc 								; and return False
.9109					_DCSExit:
.9109	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.910a					MulInteger:
.910a	fa		plx				plx
.910b	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.910d	15 51		ora $51,x			ora 	NSStatus+1,x
.910f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9110	0a		asl a				asl 	a
.9111	10 05		bpl $9118			bpl 	_NotRef
.9113	48		pha				pha
.9114	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9117	68		pla				pla
.9118					_NotRef:
.9118	0a		asl a				asl 	a 							; put MSB of type into A:7
.9119	30 09		bmi $9124			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.911b	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.911d	15 79		ora $79,x			ora 	NSExponent+1,x
.911f	f0 06		beq $9127			beq 	_IntegerCode 				; if clear, then we have two integers
.9121	4c 88 95	jmp $9588			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9124					_StringData:
.9124	4c ab 9f	jmp $9fab			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9127					_IntegerCode:
.9127	20 34 91	jsr $9134			jsr 	MultiplyShort
.912a	c9 00		cmp #$00			cmp 	#0
.912c	f0 05		beq $9133			beq 	_MIExit
.912e	a9 04		lda #$04		lda	#4
.9130	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.9133					_MIExit:
.9133	60		rts				rts
.9134					MultiplyShort:
.9134	5a		phy				phy 								; save Y
.9135	20 fc 9d	jsr $9dfc			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9138	20 15 9e	jsr $9e15			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.913b	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.913d					_I32MLoop:
.913d	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.913f	15 62		ora $62,x			ora 	NSMantissa1+2,x
.9141	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.9143	15 72		ora $72,x			ora 	NSMantissa3+2,x
.9145	f0 25		beq $916c			beq 	_I32MExit 					; exit if zero
.9147	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9149	29 01		and #$01			and 	#1
.914b	f0 0d		beq $915a			beq 	_I32MNoAdd
.914d	20 f1 91	jsr $91f1			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9150	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9152	10 06		bpl $915a			bpl 	_I32MNoAdd
.9154					_I32ShiftRight:
.9154	20 32 9e	jsr $9e32			jsr 	NSMShiftRight 				; shift S[X] right
.9157	c8		iny				iny 								; increment shift count
.9158	80 09		bra $9163			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.915a					_I32MNoAdd:
.915a	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.915c	70 f6		bvs $9154			bvs 	_I32ShiftRight 				; instead.
.915e	e8		inx				inx
.915f	20 28 9e	jsr $9e28			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9162	ca		dex				dex
.9163					_I32MShiftUpper:
.9163	e8		inx				inx 								; shift S[X+2] right
.9164	e8		inx				inx
.9165	20 32 9e	jsr $9e32			jsr 	NSMShiftRight
.9168	ca		dex				dex
.9169	ca		dex				dex
.916a	80 d1		bra $913d			bra 	_I32MLoop 					; try again.
.916c					_I32MExit:
.916c	20 72 91	jsr $9172			jsr 	CalculateSign
.916f	98		tya				tya 								; shift in A
.9170	7a		ply				ply 								; restore Y and exit
.9171	60		rts				rts
.9172					CalculateSign:
.9172	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9174	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.9176	55 51		eor $51,x			eor 	NSStatus+1,x
.9178	0a		asl a				asl 	a 							; shift bit 7 into carry
.9179	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.917b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.917c					CompareStrings:
.917c	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.917e	35 51		and $51,x			and 	NSStatus+1,x
.9180	29 10		and #$10			and 	#NSBIsString
.9182	f0 28		beq $91ac			beq 	_CSTypeError
.9184	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9186	85 36		sta $36				sta 	zTemp0
.9188	b5 60		lda $60,x			lda 	NSMantissa1,x
.918a	85 37		sta $37				sta 	zTemp0+1
.918c	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.918e	85 38		sta $38				sta 	zTemp1
.9190	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9192	85 39		sta $39				sta 	zTemp1+1
.9194	5a		phy				phy 								; save Y so we can access strings
.9195	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.9197					_CSLoop:
.9197	c8		iny				iny
.9198	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.919a	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.919c	d0 06		bne $91a4			bne 	_CSDifferent
.919e	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.91a0	d0 f5		bne $9197			bne 	_CSLoop 					; still comparing
.91a2					_CSExit:
.91a2	7a		ply				ply 								; reached end, return zero in A from EOS
.91a3	60		rts				rts
.91a4					_CSDifferent:
.91a4	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.91a6	90 fa		bcc $91a2			bcc		_CSExit
.91a8	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.91aa	80 f6		bra $91a2			bra 	_CSExit
.91ac					_CSTypeError:
.91ac	4c a1 9f	jmp $9fa1			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.91af					ShiftLeft:
.91af	38		sec				sec 								; common code, carry determines which way.
.91b0	80 01		bra $91b3			bra 	ShiftMain
.91b2					ShiftRight:
.91b2	18		clc				clc
.91b3					ShiftMain:
.91b3	fa		plx				plx 								; restore X
.91b4	08		php				php 								; save direction
.91b5	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91b7	15 51		ora $51,x			ora 	NSStatus+1,x
.91b9	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91ba	0a		asl a				asl 	a
.91bb	10 05		bpl $91c2			bpl 	_NotRef
.91bd	48		pha				pha
.91be	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91c1	68		pla				pla
.91c2					_NotRef:
.91c2	0a		asl a				asl 	a
.91c3	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91c5	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91c7	15 79		ora $79,x			ora 	NSExponent+1,x
.91c9	f0 03		beq $91ce			beq 	_IntegerCode 				; if clear, then we have two integers
.91cb	4c a1 9f	jmp $9fa1			jmp 	TypeError 					; anything else, type mismatch.
.91ce					_IntegerCode:
.91ce	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.91d0	29 e0		and #$e0			and 	#$E0
.91d2	15 61		ora $61,x			ora 	NSMantissa1+1,x
.91d4	15 69		ora $69,x			ora 	NSMantissa2+1,x
.91d6	15 71		ora $71,x			ora 	NSMantissa3+1,x
.91d8	d0 12		bne $91ec			bne 	_SMExit0 					; if >= 32 it will always return zero.
.91da					_SMLoop:
.91da	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.91dc	30 11		bmi $91ef			bmi 	_SMExit 					; exit if done.
.91de	28		plp				plp 								; restore direction setting
.91df	08		php				php
.91e0	90 05		bcc $91e7			bcc 	_SMRight
.91e2	20 28 9e	jsr $9e28			jsr 	NSMShiftLeft 				; shift left if CS
.91e5	80 f3		bra $91da			bra 	_SMLoop
.91e7					_SMRight:
.91e7	20 32 9e	jsr $9e32			jsr 	NSMShiftRight 				; shift right if CC
.91ea	80 ee		bra $91da			bra 	_SMLoop
.91ec					_SMExit0:
.91ec	20 19 9e	jsr $9e19			jsr 	NSMSetZero 					; return zero.
.91ef					_SMExit:
.91ef	28		plp				plp 								; throw direction
.91f0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.91f1					AddTopTwoStack:
.91f1	18		clc				clc
.91f2	b5 58		lda $58,x			lda		NSMantissa0,x
.91f4	75 59		adc $59,x			adc 		NSMantissa0+1,x
.91f6	95 58		sta $58,x			sta 	NSMantissa0,x
.91f8	b5 60		lda $60,x			lda		NSMantissa1,x
.91fa	75 61		adc $61,x			adc 		NSMantissa1+1,x
.91fc	95 60		sta $60,x			sta 	NSMantissa1,x
.91fe	b5 68		lda $68,x			lda		NSMantissa2,x
.9200	75 69		adc $69,x			adc 		NSMantissa2+1,x
.9202	95 68		sta $68,x			sta 	NSMantissa2,x
.9204	b5 70		lda $70,x			lda		NSMantissa3,x
.9206	75 71		adc $71,x			adc 		NSMantissa3+1,x
.9208	95 70		sta $70,x			sta 	NSMantissa3,x
.920a	60		rts				rts
.920b					SubTopTwoStack:
.920b	38		sec				sec
.920c	b5 58		lda $58,x			lda		NSMantissa0,x
.920e	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9210	95 58		sta $58,x			sta 	NSMantissa0,x
.9212	b5 60		lda $60,x			lda		NSMantissa1,x
.9214	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.9216	95 60		sta $60,x			sta 	NSMantissa1,x
.9218	b5 68		lda $68,x			lda		NSMantissa2,x
.921a	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.921c	95 68		sta $68,x			sta 	NSMantissa2,x
.921e	b5 70		lda $70,x			lda		NSMantissa3,x
.9220	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.9222	95 70		sta $70,x			sta 	NSMantissa3,x
.9224	60		rts				rts
.9225					AddInteger:
.9225	fa		plx				plx
.9226	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9228	15 51		ora $51,x			ora 	NSStatus+1,x
.922a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.922b	0a		asl a				asl 	a
.922c	10 05		bpl $9233			bpl 	_NotRef
.922e	48		pha				pha
.922f	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9232	68		pla				pla
.9233					_NotRef:
.9233	0a		asl a				asl 	a 							; put MSB of type into A:7
.9234	30 09		bmi $923f			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9236	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9238	15 79		ora $79,x			ora 	NSExponent+1,x
.923a	f0 06		beq $9242			beq 	_IntegerCode 				; if clear, then we have two integers
.923c	4c 38 94	jmp $9438			jmp 	FloatingPointAdd 							; otherwise at least one float.
.923f					_StringData:
.923f	4c fe 8f	jmp $8ffe			jmp 	StringConcat							; at least one string - don't know both are strings.
.9242					_IntegerCode:
.9242					AddCode:
.9242	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9244	55 51		eor $51,x			eor 	NSStatus+1,x
.9246	10 a9		bpl $91f1			bpl 	AddTopTwoStack
.9248	20 0b 92	jsr $920b			jsr 	SubTopTwoStack 				; do a physical subtraction
.924b	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.924d	10 07		bpl $9256			bpl 	_AddExit
.924f	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9251	95 50		sta $50,x			sta 	NSStatus,x
.9253	20 e2 9d	jsr $9de2			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9256					_AddExit:
.9256	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; check for -0
.9259	d0 02		bne $925d			bne 	_AddNonZero
.925b	74 50		stz $50,x			stz 	NSStatus,x
.925d					_AddNonZero:
.925d	60		rts				rts
.925e					SubInteger:
.925e	fa		plx				plx
.925f	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9261	15 51		ora $51,x			ora 	NSStatus+1,x
.9263	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9264	0a		asl a				asl 	a
.9265	10 05		bpl $926c			bpl 	_NotRef
.9267	48		pha				pha
.9268	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.926b	68		pla				pla
.926c					_NotRef:
.926c	0a		asl a				asl 	a 							; put MSB of type into A:7
.926d	30 09		bmi $9278			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.926f	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9271	15 79		ora $79,x			ora 	NSExponent+1,x
.9273	f0 06		beq $927b			beq 	_IntegerCode 				; if clear, then we have two integers
.9275	4c 3d 94	jmp $943d			jmp 	FloatingPointSub 							; otherwise at least one float.
.9278					_StringData:
.9278	4c ab 9f	jmp $9fab			jmp 	NotDoneError							; at least one string - don't know both are strings.
.927b					_IntegerCode:
.927b	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.927d	49 80		eor #$80			eor 	#$80
.927f	95 51		sta $51,x			sta 	NSStatus+1,x
.9281	80 bf		bra $9242			bra 	AddCode 					; and do the same code as add.
.9283					AndInteger:
.9283	fa		plx				plx
.9284	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9286	15 51		ora $51,x			ora 	NSStatus+1,x
.9288	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9289	0a		asl a				asl 	a
.928a	10 05		bpl $9291			bpl 	_NotRef
.928c	48		pha				pha
.928d	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9290	68		pla				pla
.9291					_NotRef:
.9291	0a		asl a				asl 	a
.9292	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9294	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9296	15 79		ora $79,x			ora 	NSExponent+1,x
.9298	f0 03		beq $929d			beq 	_IntegerCode 				; if clear, then we have two integers
.929a	4c a1 9f	jmp $9fa1			jmp 	TypeError 					; anything else, type mismatch.
.929d					_IntegerCode:
.929d	b5 58		lda $58,x			lda		NSMantissa0,x
.929f	35 59		and $59,x			and 		NSMantissa0+1,x
.92a1	95 58		sta $58,x			sta 	NSMantissa0,x
.92a3	b5 60		lda $60,x			lda		NSMantissa1,x
.92a5	35 61		and $61,x			and 		NSMantissa1+1,x
.92a7	95 60		sta $60,x			sta 	NSMantissa1,x
.92a9	b5 68		lda $68,x			lda		NSMantissa2,x
.92ab	35 69		and $69,x			and 		NSMantissa2+1,x
.92ad	95 68		sta $68,x			sta 	NSMantissa2,x
.92af	b5 70		lda $70,x			lda		NSMantissa3,x
.92b1	35 71		and $71,x			and 		NSMantissa3+1,x
.92b3	95 70		sta $70,x			sta 	NSMantissa3,x
.92b5	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92b7	60		rts				rts
.92b8					OraInteger:
.92b8	fa		plx				plx
.92b9	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92bb	15 51		ora $51,x			ora 	NSStatus+1,x
.92bd	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92be	0a		asl a				asl 	a
.92bf	10 05		bpl $92c6			bpl 	_NotRef
.92c1	48		pha				pha
.92c2	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92c5	68		pla				pla
.92c6					_NotRef:
.92c6	0a		asl a				asl 	a
.92c7	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92c9	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92cb	15 79		ora $79,x			ora 	NSExponent+1,x
.92cd	f0 03		beq $92d2			beq 	_IntegerCode 				; if clear, then we have two integers
.92cf	4c a1 9f	jmp $9fa1			jmp 	TypeError 					; anything else, type mismatch.
.92d2					_IntegerCode:
.92d2	b5 58		lda $58,x			lda		NSMantissa0,x
.92d4	15 59		ora $59,x			ora 		NSMantissa0+1,x
.92d6	95 58		sta $58,x			sta 	NSMantissa0,x
.92d8	b5 60		lda $60,x			lda		NSMantissa1,x
.92da	15 61		ora $61,x			ora 		NSMantissa1+1,x
.92dc	95 60		sta $60,x			sta 	NSMantissa1,x
.92de	b5 68		lda $68,x			lda		NSMantissa2,x
.92e0	15 69		ora $69,x			ora 		NSMantissa2+1,x
.92e2	95 68		sta $68,x			sta 	NSMantissa2,x
.92e4	b5 70		lda $70,x			lda		NSMantissa3,x
.92e6	15 71		ora $71,x			ora 		NSMantissa3+1,x
.92e8	95 70		sta $70,x			sta 	NSMantissa3,x
.92ea	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92ec	60		rts				rts
.92ed					EorInteger:
.92ed	fa		plx				plx
.92ee	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92f0	15 51		ora $51,x			ora 	NSStatus+1,x
.92f2	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92f3	0a		asl a				asl 	a
.92f4	10 05		bpl $92fb			bpl 	_NotRef
.92f6	48		pha				pha
.92f7	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92fa	68		pla				pla
.92fb					_NotRef:
.92fb	0a		asl a				asl 	a
.92fc	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92fe	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9300	15 79		ora $79,x			ora 	NSExponent+1,x
.9302	f0 03		beq $9307			beq 	_IntegerCode 				; if clear, then we have two integers
.9304	4c a1 9f	jmp $9fa1			jmp 	TypeError 					; anything else, type mismatch.
.9307					_IntegerCode:
.9307	b5 58		lda $58,x			lda		NSMantissa0,x
.9309	55 59		eor $59,x			eor 		NSMantissa0+1,x
.930b	95 58		sta $58,x			sta 	NSMantissa0,x
.930d	b5 60		lda $60,x			lda		NSMantissa1,x
.930f	55 61		eor $61,x			eor 		NSMantissa1+1,x
.9311	95 60		sta $60,x			sta 	NSMantissa1,x
.9313	b5 68		lda $68,x			lda		NSMantissa2,x
.9315	55 69		eor $69,x			eor 		NSMantissa2+1,x
.9317	95 68		sta $68,x			sta 	NSMantissa2,x
.9319	b5 70		lda $70,x			lda		NSMantissa3,x
.931b	55 71		eor $71,x			eor 		NSMantissa3+1,x
.931d	95 70		sta $70,x			sta 	NSMantissa3,x
.931f	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9321	60		rts				rts
.9322					WordIndirect:
.9322	fa		plx				plx
.9323	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9325	15 51		ora $51,x			ora 	NSStatus+1,x
.9327	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9328	0a		asl a				asl 	a
.9329	10 05		bpl $9330			bpl 	_NotRef
.932b	48		pha				pha
.932c	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.932f	68		pla				pla
.9330					_NotRef:
.9330	0a		asl a				asl 	a
.9331	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9333	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9335	15 79		ora $79,x			ora 	NSExponent+1,x
.9337	f0 03		beq $933c			beq 	_IntegerCode 				; if clear, then we have two integers
.9339	4c a1 9f	jmp $9fa1			jmp 	TypeError 					; anything else, type mismatch.
.933c					_IntegerCode:
.933c	20 42 92	jsr $9242			jsr 	AddCode 					; add the two values
.933f	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9341	95 50		sta $50,x			sta 	NSStatus,x
.9343	60		rts				rts
.9344					ByteIndirect:
.9344	fa		plx				plx
.9345	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9347	15 51		ora $51,x			ora 	NSStatus+1,x
.9349	0a		asl a				asl 	a 							; shift reference bit into sign bit
.934a	0a		asl a				asl 	a
.934b	10 05		bpl $9352			bpl 	_NotRef
.934d	48		pha				pha
.934e	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9351	68		pla				pla
.9352					_NotRef:
.9352	0a		asl a				asl 	a
.9353	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9355	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9357	15 79		ora $79,x			ora 	NSExponent+1,x
.9359	f0 03		beq $935e			beq 	_IntegerCode 				; if clear, then we have two integers
.935b	4c a1 9f	jmp $9fa1			jmp 	TypeError 					; anything else, type mismatch.
.935e					_IntegerCode:
.935e	20 42 92	jsr $9242			jsr 	AddCode 					; add the two values
.9361	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9363	95 50		sta $50,x			sta 	NSStatus,x
.9365	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9366					ConvertInt16:
.9366	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.9368	86 60		stx $60				stx 	NSMantissa1
.936a	64 68		stz $68				stz 	NSMantissa2
.936c	64 70		stz $70				stz 	NSMantissa3
.936e	64 50		stz $50				stz 	NSStatus 					; positive integer
.9370	a2 00		ldx #$00			ldx 	#0 							; stack level
.9372	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.9374	80 00		bra $9376			bra 	ConvertInt32
.9376					ConvertInt32:
.9376	5a		phy				phy
.9377	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9379	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.937b	10 08		bpl $9385			bpl 	_CI32NotNeg
.937d	48		pha				pha
.937e	a9 2d		lda #$2d			lda 	#'-'
.9380	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.9383	c8		iny				iny
.9384	68		pla				pla
.9385					_CI32NotNeg:
.9385	20 93 93	jsr $9393			jsr 	_CI32DivideConvert 			; recursive conversion
.9388	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.938a	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.938d	7a		ply				ply
.938e	a2 06		ldx #$06			ldx 	#NumberBuffer >> 8 			; return address in XA
.9390	a9 27		lda #$27			lda 	#NumberBuffer & $FF
.9392	60		rts				rts
.9393					_CI32DivideConvert:
.9393	e8		inx				inx 								; write to next slot up
.9394	20 1b 9e	jsr $9e1b			jsr 	NSMSetByte 		 			; write the base out.
.9397	ca		dex				dex
.9398	20 c1 90	jsr $90c1			jsr 	Int32Divide 				; divide
.939b	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.939d	48		pha				pha
.939e	20 7e 90	jsr $907e			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.93a1	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; is it zero ?
.93a4	f0 05		beq $93ab			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.93a6	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.93a8	20 93 93	jsr $9393			jsr 	_CI32DivideConvert 			; and recusrively call.
.93ab					_CI32NoRecurse:
.93ab	68		pla				pla 								; remainder
.93ac	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.93ae	90 02		bcc $93b2			bcc 	_CI32NotHex
.93b0	69 26		adc #$26			adc 	#6+32
.93b2					_CI32NotHex:
.93b2	69 30		adc #$30			adc 	#48
.93b4	99 27 06	sta $0627,y			sta 	NumberBuffer,y 				; write out and exit
.93b7	c8		iny				iny
.93b8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.93b9					PrecedenceLevel:
>93b9	04					.byte	 4	; $00 <<
>93ba	02					.byte	 2	; $01 <=
>93bb	02					.byte	 2	; $02 <>
>93bc	00					.byte	 0	; $03 !!3
>93bd	00					.byte	 0	; $04 ><
>93be	02					.byte	 2	; $05 >=
>93bf	04					.byte	 4	; $06 >>
>93c0	00					.byte	 0	; $07 !!7
>93c1	00					.byte	 0	; $08 !!8
>93c2	00					.byte	 0	; $09 !!9
>93c3	00					.byte	 0	; $0a !!10
>93c4	00					.byte	 0	; $0b !!11
>93c5	00					.byte	 0	; $0c !!12
>93c6	00					.byte	 0	; $0d !!13
>93c7	00					.byte	 0	; $0e !!14
>93c8	00					.byte	 0	; $0f !!15
>93c9	00					.byte	 0	; $10 @
>93ca	00					.byte	 0	; $11 !!17
>93cb	00					.byte	 0	; $12 !!18
>93cc	00					.byte	 0	; $13 [
>93cd	04					.byte	 4	; $14 \
>93ce	00					.byte	 0	; $15 ]
>93cf	01					.byte	 1	; $16 ^
>93d0	00					.byte	 0	; $17 _
>93d1	00					.byte	 0	; $18 `
>93d2	00					.byte	 0	; $19 !!25
>93d3	00					.byte	 0	; $1a !!26
>93d4	00					.byte	 0	; $1b {
>93d5	01					.byte	 1	; $1c |
>93d6	00					.byte	 0	; $1d }
>93d7	00					.byte	 0	; $1e ~
>93d8	00					.byte	 0	; $1f [7m<7F>[m
>93d9	00					.byte	 0	; $20
>93da	05					.byte	 5	; $21 !
>93db	00					.byte	 0	; $22 "
>93dc	00					.byte	 0	; $23 #
>93dd	05					.byte	 5	; $24 $
>93de	04					.byte	 4	; $25 %
>93df	01					.byte	 1	; $26 &
>93e0	00					.byte	 0	; $27 '
>93e1	00					.byte	 0	; $28 (
>93e2	00					.byte	 0	; $29 )
>93e3	04					.byte	 4	; $2a *
>93e4	03					.byte	 3	; $2b +
>93e5	00					.byte	 0	; $2c ,
>93e6	03					.byte	 3	; $2d -
>93e7	00					.byte	 0	; $2e .
>93e8	04					.byte	 4	; $2f /
>93e9	00					.byte	 0	; $30 0
>93ea	00					.byte	 0	; $31 1
>93eb	00					.byte	 0	; $32 2
>93ec	00					.byte	 0	; $33 3
>93ed	00					.byte	 0	; $34 4
>93ee	00					.byte	 0	; $35 5
>93ef	00					.byte	 0	; $36 6
>93f0	00					.byte	 0	; $37 7
>93f1	00					.byte	 0	; $38 8
>93f2	00					.byte	 0	; $39 9
>93f3	00					.byte	 0	; $3a :
>93f4	00					.byte	 0	; $3b ;
>93f5	02					.byte	 2	; $3c <
>93f6	02					.byte	 2	; $3d =
>93f7	02					.byte	 2	; $3e >
>93f8	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93f9					EvaluateExpressionAt0:
.93f9	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93fb					EvaluateExpression:
.93fb	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93fd					EvaluateExpressionAtPrecedence:
.93fd	48		pha				pha 								; save precedence level
.93fe	20 45 98	jsr $9845			jsr 	EvaluateTerm 				; evaluate term into level X.
.9401	68		pla				pla 								; restore precedence level.
.9402					_EXPRLoop:
.9402	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9404	b1 30		lda ($30),y			lda 	(codePtr),y
.9406	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9408	b0 25		bcs $942f			bcs 	_EXPRExit
.940a	da		phx				phx 								; read the operator precedence
.940b	aa		tax				tax
.940c	bd b9 93	lda $93b9,x			lda 	PrecedenceLevel,x
.940f	fa		plx				plx
.9410	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9412	f0 1b		beq $942f			beq 	_EXPRExit
.9414	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9416	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9418	c5 37		cmp $37				cmp 	zTemp0+1
.941a	b0 13		bcs $942f			bcs		_EXPRExit 					; if current >= operator exit
.941c	48		pha				pha 								; save current precedence.
.941d	b1 30		lda ($30),y			lda 	(codePtr),y
.941f	c8		iny				iny
.9420	48		pha				pha
.9421	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9423	e8		inx				inx 								; work out the right hand side.
.9424	20 fd 93	jsr $93fd			jsr 	EvaluateExpressionAtPrecedence
.9427	ca		dex				dex
.9428	68		pla				pla 								; get operator, call the code.
.9429	20 32 94	jsr $9432			jsr 	_EXPRCaller
.942c	68		pla				pla 								; restore precedence level
.942d	80 d3		bra $9402			bra 	_EXPRLoop 					; and go round.
.942f					_EXPRExit:
.942f	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9431	60		rts				rts
.9432					_EXPRCaller:
.9432	da		phx				phx 								; save on stack, first thing is to restore it
.9433	0a		asl a				asl 	a 							; double so can use vectors into X
.9434	aa		tax				tax
.9435	7c 0e 8c	jmp ($8c0e,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9438					FloatingPointAdd:
.9438	20 ae 95	jsr $95ae			jsr 	FloatPrepare 				; prepare for floats
.943b	80 09		bra $9446			bra 	FloatAdd
.943d					FloatingPointSub:
.943d	20 ae 95	jsr $95ae			jsr 	FloatPrepare 				; prepare for floats
.9440					FloatSubtract:
.9440	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9442	49 80		eor #$80			eor 	#$80
.9444	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9446					FloatAdd:
.9446	48		pha				pha
.9447	5a		phy				phy
.9448	20 bd 95	jsr $95bd			jsr 	NSNormalise 				; normalise S[X]
.944b	f0 51		beq $949e			beq 	_FAReturn1
.944d	e8		inx				inx 								; normalise S[X+1]
.944e	20 bd 95	jsr $95bd			jsr 	NSNormalise
.9451	ca		dex				dex
.9452	c9 00		cmp #$00			cmp 	#0
.9454	f0 60		beq $94b6			beq 	_FAExit 					; if so, just return A
.9456	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.9458	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.945a	f0 18		beq $9474			beq 	_FAExponentsEqual
.945c	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.945e	a8		tay				tay
.945f	38		sec				sec 								; do a signed comparison of the exponents.
.9460	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9462	50 02		bvc $9466			bvc 	_FANoSignedChange
.9464	49 80		eor #$80			eor 	#$80
.9466					_FANoSignedChange:
.9466	29 80		and #$80			and 	#$80
.9468	10 02		bpl $946c			bpl 	_FAHaveMax
.946a	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.946c					_FAHaveMax:
.946c	20 b9 94	jsr $94b9			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.946f	e8		inx				inx
.9470	20 b9 94	jsr $94b9			jsr 	_FAShiftToExponent
.9473	ca		dex				dex
.9474					_FAExponentsEqual:
.9474	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9476	55 51		eor $51,x			eor 	NSStatus+1,x
.9478	30 0e		bmi $9488			bmi 	_FADifferentSigns
.947a	20 f1 91	jsr $91f1			jsr 	AddTopTwoStack 				; do the add of the mantissae
.947d	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.947f	10 35		bpl $94b6			bpl 	_FAExit 					; if no, we are done.
.9481	20 32 9e	jsr $9e32			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9484	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.9486	80 2e		bra $94b6			bra 	_FAExit
.9488					_FADifferentSigns:
.9488	20 0b 92	jsr $920b			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.948b	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.948d	10 06		bpl $9495			bpl 	_FACheckZero 				; if no, check for -0
.948f	20 db 9d	jsr $9ddb			jsr 	NSMNegate 					; netate result
.9492	20 e2 9d	jsr $9de2			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9495					_FACheckZero:
.9495	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero	 				; check for -0
.9498	d0 1c		bne $94b6			bne 	_FAExit
.949a	74 50		stz $50,x			stz 	NSStatus,x
.949c	80 18		bra $94b6			bra 	_FAExit
.949e					_FAReturn1:
.949e	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.94a0	95 58		sta $58,x			sta 	NSMantissa0,x
.94a2	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.94a4	95 60		sta $60,x			sta 	NSMantissa1,x
.94a6	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.94a8	95 68		sta $68,x			sta 	NSMantissa2,x
.94aa	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.94ac	95 70		sta $70,x			sta 	NSMantissa3,x
.94ae	b5 79		lda $79,x			lda 	NSExponent+1,x
.94b0	95 78		sta $78,x			sta 	NSExponent,x
.94b2	b5 51		lda $51,x			lda 	NSStatus+1,x
.94b4	95 50		sta $50,x			sta 	NSStatus,x
.94b6					_FAExit:
.94b6	7a		ply				ply
.94b7	68		pla				pla
.94b8	60		rts				rts
.94b9					_FAShiftToExponent:
.94b9					_FAShiftToExponent2:
.94b9	98		tya				tya 								; compare Y to exponent
.94ba	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.94bc	f0 07		beq $94c5			beq 	_FASEExit 					; exit if so.
.94be	20 32 9e	jsr $9e32			jsr 	NSMShiftRight	 			; shift the mantissa right
.94c1	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.94c3	80 f4		bra $94b9			bra 	_FAShiftToExponent2
.94c5					_FASEExit:
.94c5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94c6					CompareFloat:
.94c6	20 40 94	jsr $9440			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94c9	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94cb	29 f8		and #$f8			and 	#$F8
.94cd	15 68		ora $68,x			ora 	NSMantissa2,x
.94cf	15 70		ora $70,x			ora 	NSMantissa3,x
.94d1	f0 08		beq $94db			beq 	_FCExit 					; zero, so approximately identical
.94d3	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94d5	34 50		bit $50,x			bit 	NSStatus,x
.94d7	10 02		bpl $94db			bpl 	_FCExit
.94d9					_FCNegative:
.94d9	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94db					_FCExit:
.94db	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94dc					FDivideCommand:
.94dc	fa		plx				plx	 								; restore stack position
.94dd	20 ae 95	jsr $95ae			jsr 	FloatPrepare 				; prepare for floats
.94e0					FloatDivide:
.94e0	48		pha				pha
.94e1	e8		inx				inx
.94e2	20 bd 95	jsr $95bd			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94e5	ca		dex				dex
.94e6	c9 00		cmp #$00			cmp 	#0
.94e8	f0 1d		beq $9507			beq 	_FDZero
.94ea	20 bd 95	jsr $95bd			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94ed	f0 16		beq $9505			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94ef	20 e2 90	jsr $90e2			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94f2	20 7e 90	jsr $907e			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94f5	20 bd 95	jsr $95bd			jsr		NSNormalise 				; renormalise
.94f8	20 72 91	jsr $9172			jsr 	CalculateSign 				; calculate result sign
.94fb	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.94fd	38		sec				sec
.94fe	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9500	38		sec				sec
.9501	e9 1e		sbc #$1e			sbc 	#30
.9503	95 78		sta $78,x			sta 	NSExponent,x
.9505					_FDExit:
.9505	68		pla				pla
.9506	60		rts				rts
.9507					_FDZero:
.9507	a9 03		lda #$03		lda	#3
.9509	4c f7 8e	jmp $8ef7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.950c					FloatFractionalPart:
.950c	5a		phy				phy
.950d	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.950f	29 7f		and #$7f			and 	#$7F
.9511	95 50		sta $50,x			sta 	NSStatus,x
.9513	20 bd 95	jsr $95bd			jsr 	NSNormalise
.9516	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9518	38		sec				sec
.9519	e9 e0		sbc #$e0			sbc 	#$E0
.951b	90 29		bcc $9546			bcc 	_FFPExit 					; already fractional
.951d	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.951f	b0 22		bcs $9543			bcs 	_FFPZero
.9521	a8		tay				tay 								; put count to do in Y
.9522	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.9524	20 48 95	jsr $9548			jsr 	_FFPPartial
.9527	95 70		sta $70,x			sta 	NSMantissa3,x
.9529	b5 68		lda $68,x			lda 	NSMantissa2,x
.952b	20 48 95	jsr $9548			jsr 	_FFPPartial
.952e	95 68		sta $68,x			sta 	NSMantissa2,x
.9530	b5 60		lda $60,x			lda 	NSMantissa1,x
.9532	20 48 95	jsr $9548			jsr 	_FFPPartial
.9535	95 60		sta $60,x			sta 	NSMantissa1,x
.9537	b5 58		lda $58,x			lda 	NSMantissa0,x
.9539	20 48 95	jsr $9548			jsr 	_FFPPartial
.953c	95 58		sta $58,x			sta 	NSMantissa0,x
.953e	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; zeroed check.
.9541	d0 03		bne $9546			bne 	_FFPExit
.9543					_FFPZero:
.9543	20 19 9e	jsr $9e19			jsr 	NSMSetZero
.9546					_FFPExit:
.9546	7a		ply				ply
.9547	60		rts				rts
.9548					_FFPPartial:
.9548	c0 00		cpy #$00			cpy 	#0 							; no more to do
.954a	f0 17		beq $9563			beq 	_FFFPPExit
.954c	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.954e	b0 0c		bcs $955c			bcs 	_FFFPPWholeByte
.9550	5a		phy				phy
.9551					_FFFPPLeft:
.9551	0a		asl a				asl 	a
.9552	88		dey				dey
.9553	d0 fc		bne $9551			bne 	_FFFPPLeft
.9555	7a		ply				ply
.9556					_FFFPPRight:
.9556	4a		lsr a				lsr 	a
.9557	88		dey				dey
.9558	d0 fc		bne $9556			bne 	_FFFPPRight
.955a	80 07		bra $9563			bra 	_FFFPPExit
.955c					_FFFPPWholeByte:
.955c	98		tya				tya 								; subtract 8 from count
.955d	38		sec				sec
.955e	e9 08		sbc #$08			sbc 	#8
.9560	a8		tay				tay
.9561	a9 00		lda #$00			lda 	#0 							; and clear all
.9563					_FFFPPExit:
.9563	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9564					FloatIntegerPart:
.9564	48		pha				pha
.9565	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.9567	f0 1d		beq $9586			beq 	_FIPExit 					; if so do nothing
.9569	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; is it zero ?
.956c	f0 15		beq $9583			beq 	_FIPZero 					; if so return zero.
.956e	20 bd 95	jsr $95bd			jsr 	NSNormalise 				; normalise
.9571	f0 10		beq $9583			beq 	_FIPZero 					; normalised to zero, exit zero
.9573					_FIPShift:
.9573	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9575	10 07		bpl $957e			bpl 	_FIPCheckZero
.9577	20 32 9e	jsr $9e32			jsr 	NSMShiftRight 				; shift mantissa right
.957a	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.957c	80 f5		bra $9573			bra 	_FIPShift
.957e					_FIPCheckZero:
.957e	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; avoid -0 problem
.9581	d0 03		bne $9586			bne 	_FIPExit 					; set to zero if mantissa zero.
.9583					_FIPZero:
.9583	20 19 9e	jsr $9e19			jsr 	NSMSetZero
.9586					_FIPExit:
.9586	68		pla				pla
.9587	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9588					FloatingPointMultiply:
.9588	20 ae 95	jsr $95ae			jsr 	FloatPrepare 				; prepare for floats
.958b					FloatMultiply:
.958b	48		pha				pha
.958c	20 bd 95	jsr $95bd			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.958f	f0 18		beq $95a9			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.9591	e8		inx				inx
.9592	20 bd 95	jsr $95bd			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9595	ca		dex				dex
.9596	c9 00		cmp #$00			cmp 	#0
.9598	f0 0c		beq $95a6			beq 	_FDSetZero
.959a	20 34 91	jsr $9134			jsr 	MultiplyShort 				; calculate the result.
.959d	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.959f	18		clc				clc
.95a0	75 79		adc $79,x			adc 	NSExponent+1,x
.95a2	95 78		sta $78,x			sta 	NSExponent,x
.95a4	80 03		bra $95a9			bra 	_FDExit
.95a6					_FDSetZero:
.95a6	20 19 9e	jsr $9e19			jsr 	NSMSetZero 					; return 0
.95a9					_FDExit:
.95a9	20 bd 95	jsr $95bd			jsr 	NSNormalise 				; normalise the result
.95ac	68		pla				pla
.95ad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95ae					FloatPrepare:
.95ae	20 b9 96	jsr $96b9			jsr 	DereferenceTopTwo 			; dereference the top two values
.95b1	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.95b3	15 51		ora $51,x			ora 	NSStatus+1,x
.95b5	29 10		and #$10			and 	#NSBIsString
.95b7	d0 01		bne $95ba			bne 	_FDType
.95b9	60		rts				rts
.95ba					_FDType:
.95ba	4c a1 9f	jmp $9fa1			jmp 	TypeError
.95bd					NSNormalise:
.95bd	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.95bf	29 80		and #$80			and 	#$80
.95c1	09 08		ora #$08			ora 	#NSTFloat
.95c3	95 50		sta $50,x			sta 	NSStatus,x
.95c5	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; if zero exit
.95c8	d0 07		bne $95d1			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95ca	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.95cc	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.95ce	a9 00		lda #$00			lda 	#0 							; set Z flag
.95d0	60		rts				rts
.95d1					_NSNormaliseOptimise:
.95d1	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95d3	d0 19		bne $95ee			bne 	_NSNormaliseLoop
.95d5	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.95d7	30 15		bmi $95ee			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95d9	95 70		sta $70,x			sta 	NSMantissa3,x
.95db	b5 60		lda $60,x			lda 	NSMantissa1,x
.95dd	95 68		sta $68,x			sta 	NSMantissa2,x
.95df	b5 58		lda $58,x			lda 	NSMantissa0,x
.95e1	95 60		sta $60,x			sta 	NSMantissa1,x
.95e3	74 58		stz $58,x			stz 	NSMantissa0,x
.95e5	b5 78		lda $78,x			lda 	NSExponent,x
.95e7	38		sec				sec
.95e8	e9 08		sbc #$08			sbc 	#8
.95ea	95 78		sta $78,x			sta 	NSExponent,x
.95ec	80 e3		bra $95d1			bra 	_NSNormaliseOptimise
.95ee					_NSNormaliseLoop:
.95ee	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95f0	70 07		bvs $95f9			bvs 	_NSNExit 					; exit if so with Z flag clear
.95f2	20 28 9e	jsr $9e28			jsr 	NSMShiftLeft 				; shift mantissa left
.95f5	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.95f7	80 f5		bra $95ee			bra 	_NSNormaliseLoop
.95f9					_NSNExit:
.95f9	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95fb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.95fc					AssignNumber:
.95fc	5a		phy				phy
.95fd	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.95ff	85 36		sta $36				sta 	zTemp0
.9601	b5 60		lda $60,x			lda 	NSMantissa1,x
.9603	85 37		sta $37				sta 	zTemp0+1
.9605	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9607	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9609	95 50		sta $50,x			sta 	NSStatus,x
.960b	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.960d	c9 08		cmp #$08			cmp 	#NSTFloat
.960f	f0 24		beq $9635			beq 	_ANFloat
.9611	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.9613	f0 03		beq $9618			beq		_ANNotFloat
.9615	4c 9c 9f	jmp $9f9c			jmp 	RangeError					; if it is, report an error.
.9618					_ANNotFloat:
.9618	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.961a	29 03		and #$03			and 	#3
.961c	d0 05		bne $9623			bne 	_ANByteWord
.961e	20 40 96	jsr $9640			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9621	80 1b		bra $963e			bra 	_ANExit
.9623					_ANByteWord:
.9623	48		pha				pha 								; save count
.9624	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.9626	92 36		sta ($36)			sta 	(zTemp0)
.9628	68		pla				pla
.9629	c9 01		cmp #$01			cmp	 	#1
.962b	f0 11		beq $963e			beq 	_ANExit
.962d	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.962f	a0 01		ldy #$01			ldy 	#1
.9631	91 36		sta ($36),y			sta 	(zTemp0),y
.9633	80 09		bra $963e			bra 	_ANExit
.9635					_ANFloat:
.9635	20 40 96	jsr $9640			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9638	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.963a	a0 04		ldy #$04			ldy 	#4
.963c	91 36		sta ($36),y			sta 	(zTemp0),y
.963e					_ANExit:
.963e	7a		ply				ply
.963f	60		rts				rts
.9640					_ANCopy4PackSign:
.9640	a0 03		ldy #$03			ldy 	#3
.9642	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.9644	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9646	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9648	91 36		sta ($36),y			sta 	(zTemp0),y
.964a	88		dey				dey
.964b	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.964d	91 36		sta ($36),y			sta 	(zTemp0),y
.964f	88		dey				dey
.9650	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9652	91 36		sta ($36),y			sta 	(zTemp0),y
.9654	88		dey				dey
.9655	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9657	91 36		sta ($36),y			sta 	(zTemp0),y
.9659	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.965a					AssignString:
.965a	5a		phy				phy
.965b	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.965d	85 38		sta $38				sta 	zTemp1
.965f	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9661	85 39		sta $39				sta 	zTemp1+1
.9663	b5 58		lda $58,x			lda 	NSMantissa0,x
.9665	85 36		sta $36				sta 	zTemp0
.9667	b5 60		lda $60,x			lda 	NSMantissa1,x
.9669	85 37		sta $37				sta 	zTemp0+1
.966b	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.966d	b1 36		lda ($36),y			lda 	(zTemp0),y
.966f	f0 23		beq $9694			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9671	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9672	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9674	e9 02		sbc #$02			sbc 	#2
.9676	85 3c		sta $3c				sta 	zsTemp
.9678	a0 01		ldy #$01			ldy 	#1
.967a	b1 36		lda ($36),y			lda 	(zTemp0),y
.967c	e9 00		sbc #$00			sbc 	#0
.967e	85 3d		sta $3d				sta 	zsTemp+1
.9680	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9682					_ASGetLength:
.9682	c8		iny				iny
.9683	b1 38		lda ($38),y			lda 	(zTemp1),y
.9685	d0 fb		bne $9682			bne 	_ASGetLength
.9687	98		tya				tya 								; is this length <= current length
.9688	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.968a	90 1e		bcc $96aa			bcc 	_ASCopyString
.968c	f0 1c		beq $96aa			beq 	_ASCopyString
.968e	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9690	a0 01		ldy #$01			ldy 	#1
.9692	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9694					_ASNewStringRequired:
.9694	e8		inx				inx 								; concrete the new string.
.9695	20 1f a7	jsr $a71f			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9698	ca		dex				dex
.9699	18		clc				clc
.969a	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.969c	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.969e	92 36		sta ($36)			sta 	(zTemp0)
.96a0	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96a2	69 00		adc #$00			adc 	#0
.96a4	a0 01		ldy #$01			ldy 	#1
.96a6	91 36		sta ($36),y			sta 	(zTemp0),y
.96a8	80 0d		bra $96b7			bra 	_ASExit
.96aa					_ASCopyString:
.96aa	a0 00		ldy #$00			ldy 	#0
.96ac					_ASCopyLoop:
.96ac	b1 38		lda ($38),y			lda 	(zTemp1),y
.96ae	c8		iny				iny
.96af	c8		iny				iny
.96b0	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96b2	88		dey				dey
.96b3	c9 00		cmp #$00			cmp 	#0
.96b5	d0 f5		bne $96ac			bne 	_ASCopyLoop
.96b7					_ASExit:
.96b7	7a		ply				ply
.96b8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96b9					DereferenceTopTwo:
.96b9	e8		inx				inx
.96ba	20 be 96	jsr $96be			jsr 	Dereference 				; deref x+1
.96bd	ca		dex				dex  								; falls through to deref x
.96be					Dereference:
.96be	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.96c0	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.96c2	f0 48		beq $970c			beq 	_DRFExit 					; not a reference, so exit.
.96c4	5a		phy				phy
.96c5	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96c7	85 36		sta $36				sta 	zTemp0
.96c9	b5 60		lda $60,x			lda 	NSMantissa1,x
.96cb	85 37		sta $37				sta 	zTemp0+1
.96cd	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.96cf	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96d1	95 58		sta $58,x			sta 	NSMantissa0,x
.96d3	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.96d5	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96d7	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96d9	f0 0e		beq $96e9			beq 	_DRFDereferenceTwo
.96db	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96dd	f0 2f		beq $970e			beq 	_DRFFull
.96df	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96e1	29 03		and #$03			and 	#3
.96e3	f0 29		beq $970e			beq 	_DRFFull 					; the whole word
.96e5	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96e7	f0 06		beq $96ef			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96e9					_DRFDereferenceTwo:
.96e9	a0 01		ldy #$01			ldy 	#1
.96eb	b1 36		lda ($36),y			lda 	(zTemp0),y
.96ed	95 60		sta $60,x			sta 	NSMantissa1,x
.96ef					_DRFClear23:
.96ef	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.96f1	74 70		stz $70,x			stz 	NSMantissa3,x
.96f3	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.96f5	29 18		and #$18			and 	#NSBTypeMask
.96f7	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.96f9	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.96fb	d0 0e		bne $970b			bne 	_DRFNotString
.96fd	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.96ff	15 60		ora $60,x			ora 	NSMantissa1,x
.9701	d0 08		bne $970b			bne 	_DRFNotString
.9703	a9 0d		lda #$0d			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9705	95 58		sta $58,x			sta 	NSMantissa0,X
.9707	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9709	95 60		sta $60,x			sta 	NSMantissa1,X
.970b					_DRFNotString
.970b	7a		ply				ply 								; restore Y and exit
.970c					_DRFExit:
.970c	60		rts				rts
.970d					_DRFNullString:
>970d	00						.byte 	0
.970e					_DRFFull:
.970e	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9710	b1 36		lda ($36),y			lda 	(zTemp0),y
.9712	95 60		sta $60,x			sta 	NSMantissa1,x
.9714	c8		iny				iny
.9715	b1 36		lda ($36),y			lda 	(zTemp0),y
.9717	95 68		sta $68,x			sta 	NSMantissa2,x
.9719	c8		iny				iny
.971a	b1 36		lda ($36),y			lda 	(zTemp0),y
.971c	95 70		sta $70,x			sta 	NSMantissa3,x
.971e	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.9720	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.9722	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9724	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.9726	f0 05		beq $972d			beq 	_DRFNoExponent
.9728	c8		iny				iny 								; if not, read the exponent as well.
.9729	b1 36		lda ($36),y			lda 	(zTemp0),y
.972b	95 78		sta $78,x			sta 	NSExponent,x
.972d					_DRFNoExponent:
.972d	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.972f	10 0a		bpl $973b			bpl 	_DRFExit2 					; if not, then exit.
.9731	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9733	95 70		sta $70,x			sta 	NSMantissa3,x
.9735	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9737	09 80		ora #$80			ora 	#NSBIsNegative
.9739	95 50		sta $50,x			sta 	NSStatus,x
.973b					_DRFExit2:
.973b	7a		ply				ply
.973c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.973d					EncodeNumberStart:
.973d	38		sec				sec
.973e	80 01		bra $9741			bra 	EncodeNumberContinue+1
.9740					EncodeNumberContinue:
.9740	18		clc				clc
.9741					EncodeNumber:
.9741	08		php				php 								; save reset flag.
.9742	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9744	f0 12		beq $9758			beq 	_ENIsOkay
.9746	c9 30		cmp #$30			cmp 	#"0"
.9748	90 04		bcc $974e			bcc 	_ENBadNumber
.974a	c9 3a		cmp #$3a			cmp 	#"9"+1
.974c	90 0a		bcc $9758			bcc 	_ENIsOkay
.974e					_ENBadNumber:
.974e	28		plp				plp 								; throw saved reset
.974f	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.9752	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9754	f0 7b		beq $97d1			beq 	_ENConstructFinal
.9756					_ENFail:
.9756	18		clc				clc 								; not allowed
.9757	60		rts				rts
.9758					_ENIsOkay:
.9758	28		plp				plp 								; are we restarting
.9759	90 15		bcc $9770			bcc 	_ENNoRestart
.975b					_ENStartEncode:
.975b	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.975d	f0 0c		beq $976b			beq 	_ENFirstDP
.975f	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.9761	20 1b 9e	jsr $9e1b			jsr 	NSMSetByte 					; in single byte mode.
.9764	a9 01		lda #$01			lda 	#ESTA_Low
.9766					_ENExitChange:
.9766	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.9769	38		sec				sec
.976a	60		rts				rts
.976b					_ENFirstDP:
.976b	20 19 9e	jsr $9e19			jsr 	NSMSetZero 					; clear integer part
.976e	80 3c		bra $97ac			bra 	_ESTASwitchFloat			; go straight to float and exi
.9770					_ENNoRestart:
.9770	48		pha				pha 								; save digit or DP on stack.
.9771	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.9774	c9 01		cmp #$01			cmp 	#ESTA_Low
.9776	f0 09		beq $9781			beq  	_ESTALowState
.9778	c9 02		cmp #$02			cmp 	#ESTA_High
.977a	f0 26		beq $97a2			beq 	_ESTAHighState
.977c	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.977e	f0 38		beq $97b8			beq 	_ESTADecimalState
>9780	db						.byte 	$DB 						; causes a break in the emulator
.9781					_ESTALowState:
.9781	68		pla				pla 								; get value back
.9782	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9784	f0 26		beq $97ac			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9786	29 0f		and #$0f			and 	#15 						; make digit
.9788	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.978b	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.978d	0a		asl a				asl 	a
.978e	0a		asl a				asl 	a
.978f	75 58		adc $58,x			adc 	NSMantissa0,x
.9791	0a		asl a				asl 	a
.9792	6d 06 04	adc $0406			adc 	DigitTemp
.9795	95 58		sta $58,x			sta 	NSMantissa0,x
.9797	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.9799	90 05		bcc $97a0			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.979b	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.979d	8d 05 04	sta $0405			sta 	EncodeState
.97a0					_ESTANoSwitch:
.97a0	38		sec				sec
.97a1	60		rts				rts
.97a2					_ESTAHighState:
.97a2	68		pla				pla 								; get value back
.97a3	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97a5	f0 05		beq $97ac			beq 	_ESTASwitchFloat
.97a7	20 05 98	jsr $9805			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97aa	38		sec				sec
.97ab	60		rts				rts
.97ac					_ESTASwitchFloat:
.97ac	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.97af	e8		inx				inx 								; zero the decimal additive.
.97b0	20 19 9e	jsr $9e19			jsr 	NSMSetZero
.97b3	ca		dex				dex
.97b4	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97b6	80 ae		bra $9766			bra 	_ENExitChange
.97b8					_ESTADecimalState:
.97b8	68		pla				pla 								; digit.
.97b9	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97bb	f0 99		beq $9756			beq 	_ENFail
.97bd	e8		inx				inx 								; put digit into fractional part of X+1
.97be	20 05 98	jsr $9805			jsr 	ESTAShiftDigitIntoMantissa
.97c1	ca		dex				dex
.97c2	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.97c5	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.97c8	c9 0b		cmp #$0b			cmp 	#11
.97ca	f0 02		beq $97ce			beq 	_ESTADSFail
.97cc	38		sec				sec
.97cd	60		rts				rts
.97ce					_ESTADSFail:
.97ce	4c 9c 9f	jmp $9f9c			jmp 	RangeError
.97d1					_ENConstructFinal:
.97d1	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.97d4	f0 2d		beq $9803			beq 	_ENCFExit 					; no decimals
.97d6	5a		phy				phy
.97d7	0a		asl a				asl 	a 							; x 4 and CLC
.97d8	0a		asl a				asl 	a
.97d9	6d 07 04	adc $0407			adc 	DecimalCount
.97dc	a8		tay				tay
.97dd	b9 5b 9f	lda $9f5b,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.97e0	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.97e2	b9 5c 9f	lda $9f5c,y			lda 	DecimalScalarTable-5+1,y
.97e5	95 62		sta $62,x			sta 	NSMantissa1+2,x
.97e7	b9 5d 9f	lda $9f5d,y			lda 	DecimalScalarTable-5+2,y
.97ea	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.97ec	b9 5e 9f	lda $9f5e,y			lda 	DecimalScalarTable-5+3,y
.97ef	95 72		sta $72,x			sta 	NSMantissa3+2,x
.97f1	b9 5f 9f	lda $9f5f,y			lda 	DecimalScalarTable-5+4,y
.97f4	95 7a		sta $7a,x			sta 	NSExponent+2,x
.97f6	a9 08		lda #$08			lda 	#NSTFloat
.97f8	95 52		sta $52,x			sta 	NSStatus+2,x
.97fa	7a		ply				ply
.97fb	e8		inx				inx 								; multiply decimal const by decimal scalar
.97fc	20 8b 95	jsr $958b			jsr 	FloatMultiply
.97ff	ca		dex				dex
.9800	20 46 94	jsr $9446			jsr 	FloatAdd 					; add to integer part.
.9803					_ENCFExit:
.9803	18		clc				clc 								; reject the digit.
.9804	60		rts				rts
.9805					ESTAShiftDigitIntoMantissa:
.9805	29 0f		and #$0f			and 	#15 						; save digit
.9807	48		pha				pha
.9808	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.980a	48		pha				pha
.980b	b5 68		lda $68,x			lda 	NSMantissa2,x
.980d	48		pha				pha
.980e	b5 60		lda $60,x			lda 	NSMantissa1,x
.9810	48		pha				pha
.9811	b5 58		lda $58,x			lda 	NSMantissa0,x
.9813	48		pha				pha
.9814	20 28 9e	jsr $9e28			jsr 	NSMShiftLeft 				; x 2
.9817	20 28 9e	jsr $9e28			jsr 	NSMShiftLeft 				; x 4
.981a	18		clc				clc 								; pop mantissa and add
.981b	68		pla				pla
.981c	75 58		adc $58,x			adc 	NSMantissa0,x
.981e	95 58		sta $58,x			sta 	NSMantissa0,x
.9820	68		pla				pla
.9821	75 60		adc $60,x			adc 	NSMantissa1,x
.9823	95 60		sta $60,x			sta 	NSMantissa1,x
.9825	68		pla				pla
.9826	75 68		adc $68,x			adc 	NSMantissa2,x
.9828	95 68		sta $68,x			sta 	NSMantissa2,x
.982a	68		pla				pla
.982b	75 70		adc $70,x			adc 	NSMantissa3,x
.982d	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.982f	20 28 9e	jsr $9e28			jsr 	NSMShiftLeft 				; x 10
.9832	68		pla				pla 								; add digit
.9833	18		clc				clc
.9834	75 58		adc $58,x			adc 	NSMantissa0,x
.9836	95 58		sta $58,x			sta 	NSMantissa0,x
.9838	90 0a		bcc $9844			bcc 	_ESTASDExit
.983a	f6 60		inc $60,x			inc 	NSMantissa1,x
.983c	d0 06		bne $9844			bne 	_ESTASDExit
.983e	f6 68		inc $68,x			inc 	NSMantissa2,x
.9840	d0 02		bne $9844			bne 	_ESTASDExit
.9842	f6 70		inc $70,x			inc 	NSMantissa3,x
.9844					_ESTASDExit:
.9844	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9845					EvaluateTerm:
.9845	b1 30		lda ($30),y			lda 	(codePtr),y
.9847	30 18		bmi $9861			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9849	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.984b	b0 6c		bcs $98b9			bcs 	_ETVariable
.984d	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.984f	90 6b		bcc $98bc			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9851	c9 3a		cmp #$3a			cmp 	#'9'+1
.9853	b0 67		bcs $98bc			bcs 	_ETPuncUnary
.9855	20 3d 97	jsr $973d			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9858					_ETNumber:
.9858	c8		iny				iny 								; keep encoding until we have the numbers
.9859	b1 30		lda ($30),y			lda 	(codePtr),y
.985b	20 40 97	jsr $9740			jsr 	EncodeNumberContinue
.985e	b0 f8		bcs $9858			bcs 	_ETNumber 					; go back if accepted.
.9860	60		rts				rts
.9861					_ETCheckUnary:
.9861	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9863	f0 3f		beq $98a4			beq 	_ETString
.9865	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9867	f0 12		beq $987b			beq 	_ETHexConstant
.9869	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.986b	90 0b		bcc $9878			bcc 	_ETSyntaxError
.986d	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1
.986f	b0 07		bcs $9878			bcs 	_ETSyntaxError
.9871	da		phx				phx 								; push X on the stack
.9872	0a		asl a				asl 	a 							; put vector x 2 into X
.9873	aa		tax				tax
.9874	c8		iny				iny 								; consume unary function token
.9875	7c 8e 8c	jmp ($8c8e,x)			jmp 	(VectorSet0,x) 				; and do it.
.9878					_ETSyntaxError:
.9878	4c 97 9f	jmp $9f97			jmp 	SyntaxError
.987b					_ETHexConstant:
.987b	c8		iny				iny 								; skip #
.987c	c8		iny				iny 								; skip count
.987d	20 19 9e	jsr $9e19			jsr 	NSMSetZero 					; clear result
.9880					_ETHLoop:
.9880	b1 30		lda ($30),y			lda 	(codePtr),y
.9882	c8		iny				iny 								; and consume
.9883	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9885	f0 1c		beq $98a3			beq 	_ETHExit
.9887	48		pha				pha 								; save on stack.
.9888	20 28 9e	jsr $9e28			jsr 	NSMShiftLeft 				; x 2
.988b	20 28 9e	jsr $9e28			jsr 	NSMShiftLeft 				; x 4
.988e	20 28 9e	jsr $9e28			jsr 	NSMShiftLeft 				; x 8
.9891	20 28 9e	jsr $9e28			jsr 	NSMShiftLeft 				; x 16
.9894	68		pla				pla 								; ASCII
.9895	c9 41		cmp #$41			cmp 	#'A'
.9897	90 02		bcc $989b			bcc 	_ETHNotChar
.9899	e9 07		sbc #$07			sbc 	#7
.989b					_ETHNotChar:
.989b	29 0f		and #$0f			and 	#15 						; digit now
.989d	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.989f	95 58		sta $58,x			sta 	NSMantissa0,x
.98a1	80 dd		bra $9880			bra 	_ETHLoop 					; go round.
.98a3					_ETHExit:
.98a3	60		rts				rts
.98a4					_ETString:
.98a4	c8		iny				iny 								; look at length
.98a5	b1 30		lda ($30),y			lda 	(codePtr),y
.98a7	48		pha				pha
.98a8	c8		iny				iny 								; first character
.98a9	20 75 a5	jsr $a575			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98ac	68		pla				pla 								; restore count and save
.98ad	85 36		sta $36				sta 	zTemp0
.98af	98		tya				tya 								; add length to Y to skip it.
.98b0	18		clc				clc
.98b1	65 36		adc $36				adc 	zTemp0
.98b3	a8		tay				tay
.98b4	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98b6	95 50		sta $50,x			sta 	NSStatus,x
.98b8	60		rts				rts
.98b9					_ETVariable:
.98b9	4c 0e 99	jmp $990e			jmp 	VariableHandler
.98bc					_ETPuncUnary:
.98bc	c8		iny				iny 								; consume the unary character
.98bd	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98bf	f0 2b		beq $98ec			beq 	_ETUnaryNegate
.98c1	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98c3	f0 36		beq $98fb			beq 	_ETDereference
.98c5	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.98c7	f0 3e		beq $9907			beq 	_ETParenthesis
.98c9	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.98cb	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.98cd	f0 06		beq $98d5			beq 	_ETIndirection
.98cf	e6 36		inc $36				inc 	zTemp0
.98d1	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.98d3	d0 a3		bne $9878			bne 	_ETSyntaxError
.98d5					_ETIndirection:
.98d5	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.98d7	1a		inc a				inc 	a
.98d8	48		pha				pha
.98d9	20 45 98	jsr $9845			jsr 	EvaluateTerm				; evaluate the term
.98dc	20 be 96	jsr $96be			jsr 	Dereference 				; dereference it.
.98df	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.98e1	d0 06		bne $98e9			bne 	_ETTypeMismatch
.98e3	68		pla				pla 								; indirection 1-2
.98e4	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.98e6	95 50		sta $50,x			sta 	NSStatus,x
.98e8	60		rts				rts
.98e9					_ETTypeMismatch:
.98e9	4c a1 9f	jmp $9fa1			jmp 	TypeError
.98ec					_ETUnaryNegate:
.98ec	20 45 98	jsr $9845			jsr 	EvaluateTerm				; evaluate the term
.98ef	20 be 96	jsr $96be			jsr 	Dereference 				; dereference it.
.98f2	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.98f4	29 10		and #$10			and 	#NSTString
.98f6	d0 f1		bne $98e9			bne 	_ETTypeMismatch
.98f8	4c db 9d	jmp $9ddb			jmp 	NSMNegate  					; just toggles the sign bit.
.98fb					_ETDereference:
.98fb	20 45 98	jsr $9845			jsr 	EvaluateTerm				; evaluate the term
.98fe	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9900	29 20		and #$20			and 	#NSBIsReference
.9902	f0 e5		beq $98e9			beq 	_ETTypeMismatch
.9904	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9906	60		rts				rts
.9907					_ETParenthesis:
.9907	20 fb 93	jsr $93fb			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.990a	20 de 8e	jsr $8ede			jsr 	CheckRightBracket 			; check for )
.990d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.990e					VariableHandler:
.990e	b1 30		lda ($30),y			lda 	(codePtr),y
.9910	18		clc				clc
.9911	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9913	85 37		sta $37				sta 	zTemp0+1
.9915	c8		iny				iny
.9916	b1 30		lda ($30),y			lda 	(codePtr),y
.9918	85 36		sta $36				sta 	zTemp0
.991a	c8		iny				iny
.991b	18		clc				clc									; copy variable address+3 to mantissa
.991c	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.991e	95 58		sta $58,x			sta 	NSMantissa0,x
.9920	a5 37		lda $37				lda 	zTemp0+1
.9922	69 00		adc #$00			adc 	#0
.9924	95 60		sta $60,x			sta 	NSMantissa1,x
.9926	74 68		stz $68,x			stz 	NSMantissa2,x
.9928	74 70		stz $70,x			stz 	NSMantissa3,x
.992a	74 78		stz $78,x			stz 	NSExponent,x
.992c	5a		phy				phy
.992d	a0 02		ldy #$02			ldy 	#2 							; read type
.992f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9931	7a		ply				ply
.9932	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9934	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9936	95 50		sta $50,x			sta 	NSStatus,x
.9938	29 04		and #$04			and 	#NSBIsArray
.993a	d0 01		bne $993d			bne 	_VHArray
.993c	60		rts				rts
.993d					_VHArray:
.993d	e8		inx				inx
.993e	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9941	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9943	95 51		sta $51,x			sta 	NSStatus+1,x
.9945	b1 30		lda ($30),y			lda 	(codePtr),y
.9947	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9949	d0 06		bne $9951			bne 	_VHNoSecondIndex
.994b	c8		iny				iny 								; skip the comma
.994c	e8		inx				inx
.994d	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9950	ca		dex				dex
.9951					_VHNoSecondIndex:
.9951	ca		dex				dex 								; set X back.
.9952	20 de 8e	jsr $8ede			jsr 	CheckRightBracket 			; and check the right bracket.
.9955	5a		phy				phy 								; save position
.9956	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9958	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.995a	f0 60		beq $99bc			beq 	_VHBadIndex
.995c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.995e	85 3e		sta $3e				sta 	zaTemp
.9960	b5 60		lda $60,x			lda 	NSMantissa1,x
.9962	85 3f		sta $3f				sta 	zaTemp+1
.9964	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9966	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9968	f0 02		beq $996c			beq 	_VHHas2Mask
.996a	a9 ff		lda #$ff			lda 	#$FF
.996c					_VHHas2Mask:
.996c	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.996e	f0 4c		beq $99bc			beq 	_VHBadIndex
.9970	0a		asl a				asl 	a 							; carry will be set if a second index
.9971	90 08		bcc $997b			bcc 	_VHCheckFirstIndex
.9973	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9975	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9977	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.9979	90 41		bcc $99bc			bcc 	_VHBadIndex
.997b					_VHCheckFirstIndex:
.997b	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.997d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.997f	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.9981	90 39		bcc $99bc			bcc 	_VHBadIndex
.9983	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9985	64 37		stz $37				stz 	zTemp0+1
.9987	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9989	30 0e		bmi $9999			bmi 	_VHNoMultiply
.998b	da		phx				phx
.998c	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.998e	48		pha				pha
.998f	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9991	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9993	1a		inc a				inc 	a 							; add 1 for zero base
.9994	fa		plx				plx
.9995	20 c4 9d	jsr $9dc4			jsr 	Multiply8x8 				; calculate -> Z0
.9998	fa		plx				plx
.9999					_VHNoMultiply:
.9999	18		clc				clc
.999a	a5 36		lda $36				lda 	zTemp0
.999c	75 59		adc $59,x			adc 	NSMantissa0+1,x
.999e	85 36		sta $36				sta 	zTemp0
.99a0	a5 37		lda $37				lda 	zTemp0+1
.99a2	69 00		adc #$00			adc 	#0
.99a4	85 37		sta $37				sta 	zTemp0+1
.99a6	b5 50		lda $50,x			lda 	NSStatus,x
.99a8	20 6e 85	jsr $856e			jsr 	ScaleByBaseType
.99ab	18		clc				clc
.99ac	b2 3e		lda ($3e)			lda 	(zaTemp)
.99ae	65 36		adc $36				adc 	zTemp0
.99b0	95 58		sta $58,x			sta 	NSMantissa0,x
.99b2	a0 01		ldy #$01			ldy 	#1
.99b4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99b6	65 37		adc $37				adc 	zTemp0+1
.99b8	95 60		sta $60,x			sta 	NSMantissa1,x
.99ba	7a		ply				ply 								; restore position
.99bb	60		rts				rts
.99bc					_VHBadIndex:
.99bc	a9 17		lda #$17		lda	#23
.99be	4c f7 8e	jmp $8ef7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.99c1					AbsUnary:
.99c1	fa		plx				plx 								; restore stack pos
.99c2	20 67 9d	jsr $9d67			jsr 	EvaluateNumber 				; get a float or int
.99c5	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.99c8	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.99ca	29 7f		and #$7f			and 	#$7F
.99cc	95 50		sta $50,x			sta 	NSStatus,x
.99ce	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.99cf					AllocUnary:
.99cf	fa		plx				plx 								; restore stack pos
.99d0	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger		; get bytes required.
.99d3	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.99d6	da		phx				phx 								; save X/Y
.99d7	5a		phy				phy
.99d8	8a		txa				txa 								; copy X into Y
.99d9	a8		tay				tay
.99da	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.99dd	aa		tax				tax
.99de	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.99e1	20 ee 99	jsr $99ee			jsr 	AllocateXABytes 			; allocate memory
.99e4	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.99e7	8a		txa				txa 	 							; typing is 16 bit integer.
.99e8	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.99eb	7a		ply				ply
.99ec	fa		plx				plx
.99ed	60		rts				rts
.99ee					AllocateXABytes:
.99ee	5a		phy				phy
.99ef	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99f2	84 36		sty $36				sty 	zTemp0
.99f4	5a		phy				phy
.99f5	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.99f8	84 37		sty $37				sty 	zTemp0+1
.99fa	5a		phy				phy
.99fb	18		clc				clc 								; add to low memory pointer
.99fc	6d 0c 04	adc $040c			adc 	lowMemPtr
.99ff	8d 0c 04	sta $040c			sta 	lowMemPtr
.9a02	8a		txa				txa
.9a03	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9a06	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9a09	b0 2f		bcs $9a3a			bcs 	CISSMemory
.9a0b	20 2c 9a	jsr $9a2c			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a0e					_ClearMemory:
.9a0e	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.9a11	c5 36		cmp $36				cmp 	zTemp0
.9a13	d0 07		bne $9a1c			bne 	_CMClearNext
.9a15	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9a18	c5 37		cmp $37				cmp 	zTemp0+1
.9a1a	f0 0c		beq $9a28			beq 	_CMExit
.9a1c					_CMClearNext:
.9a1c	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a1e	92 36		sta ($36)			sta 	(zTemp0)
.9a20	e6 36		inc $36				inc 	zTemp0
.9a22	d0 ea		bne $9a0e			bne 	_ClearMemory
.9a24	e6 37		inc $37				inc		zTemp0+1
.9a26	80 e6		bra $9a0e			bra 	_ClearMemory
.9a28					_CMExit:
.9a28	fa		plx				plx
.9a29	68		pla				pla
.9a2a	7a		ply				ply
.9a2b	60		rts				rts
.9a2c					CheckIdentifierStringSpace:
.9a2c	48		pha				pha
.9a2d	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a30	18		clc				clc
.9a31	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a33	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a36	b0 02		bcs $9a3a			bcs 	CISSMemory
.9a38	68		pla				pla
.9a39	60		rts				rts
.9a3a					CISSMemory:
.9a3a	a9 06		lda #$06		lda	#6
.9a3c	4c f7 8e	jmp $8ef7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a3f					AscUnary:
.9a3f	fa		plx				plx 								; restore stack pos
.9a40	20 71 9d	jsr $9d71			jsr 	EvaluateString 				; get a string
.9a43	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a45	20 1b 9e	jsr $9e1b			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a48	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.9a4b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/deekpeek.asm

.9a4c					PeekUnary:
.9a4c	18		clc				clc
.9a4d	80 01		bra $9a50			bra 	DPUnary
.9a4f					DeekUnary:
.9a4f	38		sec				sec
.9a50					DPUnary:
.9a50	fa		plx				plx 								; restore position.
.9a51	08		php				php									; save on stack, CS = Deek, CC = Peek
.9a52	20 99 9d	jsr $9d99			jsr		Evaluate16BitInteger 		; address as constant.
.9a55	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.9a58	28		plp				plp 								; function back.
.9a59	a9 21		lda #$21			lda 	#NSBIsReference+NSTInteger+1 ; 1 byte read
.9a5b	90 01		bcc $9a5e			bcc 	_DPUpdate
.9a5d	1a		inc a				inc 	a 							; 2 byte read
.9a5e					_DPUpdate:
.9a5e	95 50		sta $50,x			sta 	NSStatus,x 					; set to 1/2 byte reference.
.9a60	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a61					FracUnary:
.9a61	fa		plx				plx 								; restore stack pos
.9a62	20 67 9d	jsr $9d67			jsr 	EvaluateNumber 				; get a float or int
.9a65	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.9a68	b5 50		lda $50,x			lda 	NSStatus,x
.9a6a	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a6c	f0 04		beq $9a72			beq 	_IUZero
.9a6e	20 0c 95	jsr $950c			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9a71	60		rts				rts
.9a72					_IUZero:
.9a72	20 19 9e	jsr $9e19			jsr 	NSMSetZero
.9a75	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a76					IntUnary:
.9a76	fa		plx				plx 								; restore stack pos
.9a77	20 67 9d	jsr $9d67			jsr 	EvaluateNumber 				; get a float or int
.9a7a	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.9a7d	b5 50		lda $50,x			lda 	NSStatus,x
.9a7f	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a81	f0 03		beq $9a86			beq 	_IUExit
.9a83	20 64 95	jsr $9564			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9a86					_IUExit:
.9a86	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a87					LenUnary:
.9a87	fa		plx				plx 								; restore stack pos
.9a88	20 71 9d	jsr $9d71			jsr 	EvaluateString 				; get a string
.9a8b	5a		phy				phy
.9a8c	a0 00		ldy #$00			ldy 	#0 							; find length
.9a8e					_LenFind:
.9a8e	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a90	f0 06		beq $9a98			beq 	_LenExit
.9a92	c8		iny				iny
.9a93	d0 f9		bne $9a8e			bne 	_LenFind
.9a95	4c 9c 9f	jmp $9f9c			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9a98					_LenExit:
.9a98	98		tya				tya		 							; return length
.9a99	20 1b 9e	jsr $9e1b			jsr 	NSMSetByte
.9a9c	7a		ply				ply
.9a9d	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.9aa0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9aa1					Unary_Min:
.9aa1	a9 01		lda #$01			lda 	#1
.9aa3	80 02		bra $9aa7			bra 	UnaryMinMaxMain
.9aa5					Unary_Max:
.9aa5	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9aa7					UnaryMinMaxMain:
.9aa7	fa		plx				plx 								; get index on number stack
.9aa8	48		pha				pha 								; save comparator
.9aa9	20 5e 9d	jsr $9d5e			jsr 	EvaluateValue 				; get the first value.
.9aac					_UMMMLoop:
.9aac	b1 30		lda ($30),y			lda 	(codePtr),y
.9aae	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9ab0	f0 22		beq $9ad4			beq 	_UMMMDone
.9ab2	20 e6 8e	jsr $8ee6			jsr 	CheckComma 					; must be a comma
.9ab5	e8		inx				inx
.9ab6	20 5e 9d	jsr $9d5e			jsr 	EvaluateValue
.9ab9	ca		dex				dex
.9aba	20 fc 9d	jsr $9dfc			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9abd	e8		inx				inx
.9abe	20 fc 9d	jsr $9dfc			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9ac1	e8		inx				inx
.9ac2	20 ae 8f	jsr $8fae			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9ac5	ca		dex				dex
.9ac6	ca		dex				dex
.9ac7	85 36		sta $36				sta 	zTemp0 						; save required result
.9ac9	68		pla				pla 								; get and save comparator
.9aca	48		pha				pha
.9acb	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9acd	d0 dd		bne $9aac			bne 	_UMMMLoop
.9acf	20 d7 9a	jsr $9ad7			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9ad2	80 d8		bra $9aac			bra 	_UMMMLoop
.9ad4					_UMMMDone:
.9ad4	68		pla				pla 								; throw the comparator
.9ad5	c8		iny				iny 								; skip )
.9ad6	60		rts				rts
.9ad7					ExpCopyAboveDown:
.9ad7	b5 51		lda $51,x			lda 	NSStatus+1,x
.9ad9	95 50		sta $50,x			sta 	NSStatus,x
.9adb	b5 79		lda $79,x			lda 	NSExponent+1,x
.9add	95 78		sta $78,x			sta 	NSExponent,x
.9adf	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9ae1	95 58		sta $58,x			sta 	NSMantissa0,x
.9ae3	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9ae5	95 60		sta $60,x			sta 	NSMantissa1,x
.9ae7	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9ae9	95 68		sta $68,x			sta 	NSMantissa2,x
.9aeb	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9aed	95 70		sta $70,x			sta 	NSMantissa3,x
.9aef	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9af0					Unary_Not:
.9af0	fa		plx				plx
.9af1	20 86 9d	jsr $9d86			jsr 	EvaluateInteger 			; get integer
.9af4	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.9af7	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; zero mantissa ?
.9afa	f0 04		beq $9b00			beq 	_NotZero
.9afc	20 19 9e	jsr $9e19			jsr 	NSMSetZero
.9aff	60		rts				rts
.9b00					_NotZero:
.9b00	4c 64 8f	jmp $8f64			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b03					Unary_Random:
.9b03	fa		plx				plx
.9b04	20 75 9b	jsr $9b75			jsr 	Random32Bit 				; get a random number
.9b07	20 5e 9b	jsr $9b5e			jsr 	URCopyToMantissa  			; put in mantissa
.9b0a	b1 30		lda ($30),y			lda 	(codePtr),y
.9b0c	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b0e	f0 08		beq $9b18			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9b10	e8		inx				inx
.9b11	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b14	ca		dex				dex
.9b15	20 b6 90	jsr $90b6			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9b18					_URNoModulus:
.9b18	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9b1a	74 78		stz $78,x			stz 	NSExponent,x
.9b1c	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.9b1f	60		rts				rts
.9b20					Unary_Rnd:
.9b20	fa		plx				plx
.9b21	20 67 9d	jsr $9d67			jsr 	EvaluateNumber 				; number to use.
.9b24	20 de 8e	jsr $8ede			jsr 	CheckRightBracket 			; closing bracket
.9b27	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b2a	f0 26		beq $9b52			beq 	_URCopySeed
.9b2c	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b2e	10 1f		bpl $9b4f			bpl 	_URDontSeed
.9b30	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b32	49 17		eor #$17			eor 	#$17
.9b34	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b37	b5 60		lda $60,x			lda 	NSMantissa1,x
.9b39	49 a5		eor #$a5			eor 	#$A5
.9b3b	8d 09 04	sta $0409			sta 	RandomSeed+1
.9b3e	b5 68		lda $68,x			lda 	NSMantissa2,x
.9b40	49 c2		eor #$c2			eor 	#$C2
.9b42	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9b45	b5 70		lda $70,x			lda 	NSMantissa3,x
.9b47	49 9d		eor #$9d			eor 	#$9D
.9b49	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9b4c	20 75 9b	jsr $9b75			jsr 	Random32Bit
.9b4f					_URDontSeed:
.9b4f	20 75 9b	jsr $9b75			jsr 	Random32Bit 				; generate a number
.9b52					_URCopySeed:
.9b52	20 5e 9b	jsr $9b5e			jsr 	URCopyToMantissa 			; copy into mantissa
.9b55	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b57	95 78		sta $78,x			sta 	NSExponent,x
.9b59	a9 08		lda #$08			lda 	#NSTFloat
.9b5b	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9b5d	60		rts				rts
.9b5e					URCopyToMantissa:
.9b5e	ad 08 04	lda $0408			lda 	RandomSeed+0
.9b61	95 58		sta $58,x			sta 	NSMantissa0,x
.9b63	ad 09 04	lda $0409			lda 	RandomSeed+1
.9b66	95 60		sta $60,x			sta 	NSMantissa1,x
.9b68	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b6b	95 68		sta $68,x			sta 	NSMantissa2,x
.9b6d	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b70	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b72	95 70		sta $70,x			sta 	NSMantissa3,x
.9b74	60		rts				rts
.9b75					Random32Bit:
.9b75	5a		phy				phy
.9b76	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b78	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9b7b	d0 03		bne $9b80			bne 	_Random1
.9b7d	a8		tay				tay 								; if so do it 256 times
.9b7e	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b80					_Random1:
.9b80	0a		asl a				asl 	a 							; LSFR RNG
.9b81	2e 09 04	rol $0409			rol 	RandomSeed+1
.9b84	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9b87	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9b8a	90 02		bcc $9b8e			bcc 	_Random2
.9b8c	49 c5		eor #$c5			eor 	#$C5
.9b8e					_Random2:
.9b8e	88		dey				dey
.9b8f	d0 ef		bne $9b80			bne 	_Random1
.9b91	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b94	7a		ply				ply
.9b95	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b96					SgnUnary:
.9b96	fa		plx				plx 								; restore stack pos
.9b97	20 67 9d	jsr $9d67			jsr 	EvaluateNumber 				; get a float or int
.9b9a	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.9b9d	20 3b 9e	jsr $9e3b			jsr 	NSMIsZero 					; if zero
.9ba0	f0 0e		beq $9bb0			beq 	_SGZero  					; return Int Zero
.9ba2	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9ba4	48		pha				pha
.9ba5	a9 01		lda #$01			lda 	#1 							; set to 1
.9ba7	20 1b 9e	jsr $9e1b			jsr 	NSMSetByte
.9baa	68		pla				pla
.9bab	29 80		and #$80			and		#$80 						; copy the sign byte out
.9bad	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9baf	60		rts				rts
.9bb0	20 19 9e	jsr $9e19	_SGZero:jsr 	NSMSetZero
.9bb3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9bb4					ValUnary:
.9bb4	fa		plx				plx 								; restore stack pos
.9bb5	20 ca 9b	jsr $9bca			jsr 	ValMainCode 				; do the main val() code
.9bb8	b0 01		bcs $9bbb			bcs 	_VUError 					; couldn't convert
.9bba	60		rts				rts
.9bbb					_VUError:
.9bbb	4c a1 9f	jmp $9fa1			jmp 	TypeError
.9bbe					IsValUnary:
.9bbe	fa		plx				plx 								; restore stack pos
.9bbf	20 ca 9b	jsr $9bca			jsr 	ValMainCode 				; do the main val() code
.9bc2	b0 03		bcs $9bc7			bcs 	_VUBad
.9bc4	4c 64 8f	jmp $8f64			jmp 	ReturnTrue
.9bc7					_VUBad:
.9bc7	4c 6f 8f	jmp $8f6f			jmp 	ReturnFalse
.9bca					ValMainCode:
.9bca	20 71 9d	jsr $9d71			jsr 	EvaluateString 				; get a string
.9bcd	20 de 8e	jsr $8ede			jsr 	CheckRightBracket 			; check right bracket present
.9bd0					ValEvaluateZTemp0:
.9bd0	5a		phy				phy
.9bd1	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9bd3	f0 17		beq $9bec			beq 	_VMCFail2
.9bd5	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9bd7	48		pha				pha 								; save first character
.9bd8	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9bda	d0 01		bne $9bdd			bne 	_VMCStart
.9bdc	c8		iny				iny 								; skip over -
.9bdd					_VMCStart:
.9bdd	38		sec				sec 								; initialise first time round.
.9bde					_VMCNext:
.9bde	c8		iny				iny 								; pre-increment
.9bdf	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9be1	f0 0c		beq $9bef			beq 	_VMCSuccess 				; successful.
.9be3	20 41 97	jsr $9741			jsr 	EncodeNumber 				; send it to the number-builder
.9be6	90 03		bcc $9beb			bcc 	_VMCFail 					; if failed, give up.
.9be8	18		clc				clc 								; next time round, countinue
.9be9	80 f3		bra $9bde			bra 	_VMCNext
.9beb					_VMCFail:
.9beb	68		pla				pla
.9bec					_VMCFail2:
.9bec	7a		ply				ply
.9bed	38		sec				sec
.9bee	60		rts				rts
.9bef					_VMCSuccess:
.9bef	a9 00		lda #$00			lda 	#0 							; construct final
.9bf1	20 41 97	jsr $9741			jsr 	EncodeNumber 				; by sending a duff value.
.9bf4	68		pla				pla 								; if it was -ve
.9bf5	c9 2d		cmp #$2d			cmp 	#"-"
.9bf7	d0 03		bne $9bfc			bne 	_VMCNotNegative
.9bf9	20 db 9d	jsr $9ddb			jsr		NSMNegate 					; negate it.
.9bfc					_VMCNotNegative:
.9bfc	7a		ply				ply
.9bfd	18		clc				clc
.9bfe	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9bff					ChrUnary:
.9bff	fa		plx				plx 								; restore stack pos
.9c00	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9c03	48		pha				pha
.9c04	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.9c07	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c09	20 9c a7	jsr $a79c			jsr 	StringTempAllocate
.9c0c	68		pla				pla 								; write number to it
.9c0d	20 d5 a7	jsr $a7d5			jsr 	StringTempWrite
.9c10	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c11					SpcUnary:
.9c11	fa		plx				plx 								; restore stack pos
.9c12	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger			; get value
.9c15	5a		phy				phy
.9c16	48		pha				pha 								; save count
.9c17	20 9c a7	jsr $a79c			jsr 	StringTempAllocate
.9c1a	7a		ply				ply 								; to do count in Y
.9c1b					_SpcLoop:
.9c1b	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9c1d	f0 08		beq $9c27			beq 	_SpcExit
.9c1f	a9 20		lda #$20			lda 	#32
.9c21	20 d5 a7	jsr $a7d5			jsr 	StringTempWrite
.9c24	88		dey				dey
.9c25	80 f4		bra $9c1b			bra 	_SPCLoop
.9c27					_SpcExit:
.9c27	7a		ply				ply
.9c28	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.9c2b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c2c					Unary_Str:
.9c2c	fa		plx				plx
.9c2d	20 67 9d	jsr $9d67			jsr 	EvaluateNumber  			; get number
.9c30	20 de 8e	jsr $8ede			jsr 	CheckRightBracket 			; closing bracket
.9c33	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c35	20 4e 9c	jsr $9c4e			jsr 	ConvertNumberToString 		; do the conversion.
.9c38	a9 21		lda #$21			lda		#33 						; create buffer
.9c3a	20 9c a7	jsr $a79c			jsr 	StringTempAllocate 			; allocate memory
.9c3d	da		phx				phx  								; copy the converted string into the buffer.
.9c3e	a2 00		ldx #$00			ldx 	#0
.9c40					_USCopy:
.9c40	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c43	20 d5 a7	jsr $a7d5			jsr 	StringTempWrite
.9c46	e8		inx				inx
.9c47	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c4a	d0 f4		bne $9c40			bne 	_USCopy
.9c4c	fa		plx				plx
.9c4d	60		rts				rts
.9c4e					ConvertNumberToString:
.9c4e	5a		phy				phy 								; save code position
.9c4f	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9c52	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9c55	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9c57	10 09		bpl $9c62			bpl 	_CNTSNotNegative
.9c59	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c5b	95 50		sta $50,x			sta 	NSStatus,x
.9c5d	a9 2d		lda #$2d			lda 	#"-"
.9c5f	20 c3 9c	jsr $9cc3			jsr 	WriteDecimalBuffer
.9c62					_CNTSNotNegative:
.9c62	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9c64	f0 12		beq $9c78			beq 	_CNTSNotFloat
.9c66	e8		inx				inx 								; round up so we don't get too many 6.999999
.9c67	a9 01		lda #$01			lda 	#1
.9c69	20 1b 9e	jsr $9e1b			jsr 	NSMSetByte
.9c6c	ca		dex				dex
.9c6d	b5 78		lda $78,x			lda		NSExponent,x
.9c6f	95 79		sta $79,x			sta 	NSExponent+1,x
.9c71	a9 08		lda #$08			lda 	#NSTFloat
.9c73	95 51		sta $51,x			sta 	NSStatus+1,x
.9c75	20 46 94	jsr $9446			jsr 	FloatAdd
.9c78					_CNTSNotFloat:
.9c78	20 a5 9c	jsr $9ca5			jsr 	MakePlusTwoString 			; do the integer part.
.9c7b	20 0c 95	jsr $950c			jsr 	FloatFractionalPart 		; get the fractional part
.9c7e	20 bd 95	jsr $95bd			jsr 	NSNormalise					; normalise , exit if zero
.9c81	f0 20		beq $9ca3			beq 	_CNTSExit
.9c83	a9 2e		lda #$2e			lda 	#"."
.9c85	20 c3 9c	jsr $9cc3			jsr 	WriteDecimalBuffer 			; write decimal place
.9c88					_CNTSDecimal:
.9c88	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9c8b	30 16		bmi $9ca3			bmi 	_CNTSExit
.9c8d	e8		inx				inx 								; x 10.0
.9c8e	a9 0a		lda #$0a			lda 	#10
.9c90	20 1b 9e	jsr $9e1b			jsr 	NSMSetByte
.9c93	a9 08		lda #$08			lda 	#NSTFloat
.9c95	95 50		sta $50,x			sta 	NSStatus,x
.9c97	ca		dex				dex
.9c98	20 8b 95	jsr $958b			jsr 	FloatMultiply
.9c9b	20 a5 9c	jsr $9ca5			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9c9e	20 0c 95	jsr $950c			jsr 	FloatFractionalPart 		; get the fractional part
.9ca1	80 e5		bra $9c88			bra 	_CNTSDecimal 				; keep going.
.9ca3					_CNTSExit:
.9ca3	7a		ply				ply
.9ca4	60		rts				rts
.9ca5					MakePlusTwoString:
.9ca5	da		phx				phx
.9ca6	20 fc 9d	jsr $9dfc			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9ca9	e8		inx				inx 								; access it
.9caa	e8		inx				inx
.9cab	20 64 95	jsr $9564			jsr 	FloatIntegerPart 			; make it an integer
.9cae	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9cb0	20 76 93	jsr $9376			jsr 	ConvertInt32
.9cb3	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9cb5					_MPTSCopy:
.9cb5	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cb8	20 c3 9c	jsr $9cc3			jsr 	WriteDecimalBuffer
.9cbb	e8		inx				inx
.9cbc	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cbf	d0 f4		bne $9cb5			bne 	_MPTSCopy
.9cc1	fa		plx				plx
.9cc2	60		rts				rts
.9cc3					WriteDecimalBuffer:
.9cc3	da		phx				phx
.9cc4	ae 15 04	ldx $0415			ldx 	dbOffset
.9cc7	9d 49 06	sta $0649,x			sta 	DecimalBuffer,x
.9cca	9e 4a 06	stz $064a,x			stz 	DecimalBuffer+1,x
.9ccd	ee 15 04	inc $0415			inc 	dbOffset
.9cd0	fa		plx				plx
.9cd1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9cd2					Unary_Left:
.9cd2	fa		plx				plx
.9cd3	18		clc				clc 								; only one parameter
.9cd4	20 37 9d	jsr $9d37			jsr 	SubstringInitial 			; set up.
.9cd7	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9cd9	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9cdb	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9cdd	80 25		bra $9d04			bra 	SubstringMain
.9cdf					Unary_Right:
.9cdf	fa		plx				plx
.9ce0	18		clc				clc 								; only one parameter
.9ce1	20 37 9d	jsr $9d37			jsr 	SubstringInitial 			; set up.
.9ce4	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9ce6	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9ce8	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9cea	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cec	b0 02		bcs $9cf0			bcs 	_URNotUnderflow
.9cee	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cf0					_URNotUnderFlow:
.9cf0	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cf2	80 10		bra $9d04			bra 	SubStringMain
.9cf4					Unary_Mid:
.9cf4	fa		plx				plx
.9cf5	38		sec				sec 								; two parameters
.9cf6	20 37 9d	jsr $9d37			jsr 	SubstringInitial 			; set up.
.9cf9	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9cfb	f0 04		beq $9d01			beq 	_UMError
.9cfd	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9cff	80 03		bra $9d04			bra 	SubStringMain
.9d01					_UMError:
.9d01	4c a6 9f	jmp $9fa6			jmp 	ArgumentError
.9d04					SubStringMain:
.9d04	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d06	d5 78		cmp $78,x			cmp 	NSExponent,x
.9d08	b0 27		bcs $9d31			bcs 	_SSMNull 					; if so, return an empty string.
.9d0a	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d0c	f0 23		beq $9d31			beq 	_SSMNull 					; return empty string.
.9d0e	18		clc				clc 								; add the offset +1 to the address and
.9d0f	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9d11	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9d13	85 36		sta $36				sta 	zTemp0
.9d15	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9d17	69 00		adc #$00			adc 	#0
.9d19	85 37		sta $37				sta 	zTemp0+1
.9d1b					_SSMNoCarry:
.9d1b	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d1d	20 9c a7	jsr $a79c			jsr 	StringTempAllocate 			; allocate that many characters
.9d20	5a		phy				phy 								; save Y
.9d21	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d23					_SSMCopy:
.9d23	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d25	f0 08		beq $9d2f			beq 	_SSMEString 				; no more to copy
.9d27	20 d5 a7	jsr $a7d5			jsr 	StringTempWrite 			; and write it out.
.9d2a	c8		iny				iny
.9d2b	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9d2d	d0 f4		bne $9d23			bne 	_SSMCopy
.9d2f					_SSMEString:
.9d2f	7a		ply				ply
.9d30					_SSMExit:
.9d30	60		rts				rts
.9d31					_SSMNull:
.9d31	a9 00		lda #$00			lda 	#0
.9d33	20 9c a7	jsr $a79c			jsr 	StringTempAllocate
.9d36	60		rts				rts
.9d37					SubstringInitial:
.9d37	da		phx				phx 								; save initial stack position
.9d38	08		php				php 								; save carry on stack indicating 2 parameters
.9d39	20 71 9d	jsr $9d71			jsr 	EvaluateString 				; get a string
.9d3c	5a		phy				phy 								; calculate length to exponent.
.9d3d	a0 ff		ldy #$ff			ldy 	#$FF
.9d3f					_SIFindLength:
.9d3f	c8		iny				iny
.9d40	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d42	d0 fb		bne $9d3f			bne 	_SIFindLength
.9d44	98		tya				tya
.9d45	95 78		sta $78,x			sta 	NSExponent,x
.9d47	7a		ply				ply
.9d48	e8		inx				inx
.9d49	20 e6 8e	jsr $8ee6			jsr 	CheckComma 					; comma next
.9d4c	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; get next parameter
.9d4f	28		plp				plp 								; is it the last parameter ?
.9d50	90 07		bcc $9d59			bcc 	_SSIExit 					; if so, exit.
.9d52	e8		inx				inx
.9d53	20 e6 8e	jsr $8ee6			jsr 	CheckComma 					; comma next
.9d56	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; get last parameter
.9d59					_SSIExit:
.9d59	fa		plx				plx
.9d5a	20 de 8e	jsr $8ede			jsr 	CheckRightBracket 			; check closing bracket
.9d5d	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d5e					EvaluateValue:
.9d5e	48		pha				pha
.9d5f	20 fb 93	jsr $93fb			jsr		EvaluateExpression 			; expression
.9d62	20 be 96	jsr $96be			jsr 	Dereference					; derefernce it
.9d65	68		pla				pla
.9d66	60		rts				rts
.9d67					EvaluateNumber:
.9d67	20 5e 9d	jsr $9d5e			jsr 	EvaluateValue 				; get a value
.9d6a	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d6c	29 10		and #$10			and 	#NSBIsString
.9d6e	d0 13		bne $9d83			bne 	HelperTypeError
.9d70	60		rts				rts
.9d71					EvaluateString:
.9d71	20 5e 9d	jsr $9d5e			jsr 	EvaluateValue 				; get a value
.9d74	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d76	29 10		and #$10			and 	#NSBIsString
.9d78	f0 09		beq $9d83			beq 	HelperTypeError
.9d7a					CopyAddressToTemp0:
.9d7a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d7c	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9d7e	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d80	85 37		sta $37				sta 	zTemp0+1
.9d82	60		rts				rts
.9d83					HelperTypeError:
.9d83	4c a1 9f	jmp $9fa1			jmp 	TypeError
.9d86					EvaluateInteger:
.9d86	20 67 9d	jsr $9d67			jsr 	EvaluateNumber
.9d89	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9d8b	d0 09		bne $9d96			bne 	HelperValueError 			; if not, it's a float.
.9d8d	60		rts				rts
.9d8e					EvaluateUnsignedInteger:
.9d8e	20 86 9d	jsr $9d86			jsr 	EvaluateInteger 			; check integer is +ve
.9d91	b5 50		lda $50,x			lda 	NSStatus,x
.9d93	30 01		bmi $9d96			bmi 	HelperValueError
.9d95	60		rts				rts
.9d96					HelperValueError:
.9d96	4c a6 9f	jmp $9fa6			jmp 	ArgumentError
.9d99					Evaluate16BitInteger:
.9d99	20 8e 9d	jsr $9d8e			jsr	 	EvaluateUnsignedInteger		; get integer
.9d9c	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d9e	15 68		ora $68,x			ora 	NSMantissa2,x
.9da0	d0 f4		bne $9d96			bne 	HelperValueError
.9da2	60		rts				rts
.9da3					Evaluate16BitIntegerSigned:
.9da3	20 86 9d	jsr $9d86			jsr	 	EvaluateInteger				; get integer
.9da6	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9da8	15 68		ora $68,x			ora 	NSMantissa2,x
.9daa	d0 ea		bne $9d96			bne 	HelperValueError
.9dac	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9dae	10 03		bpl $9db3			bpl 	_EISNotSigned
.9db0	20 e2 9d	jsr $9de2			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9db3					_EISNotSigned:
.9db3	60		rts				rts
.9db4					Evaluate8BitInteger:
.9db4	20 8e 9d	jsr $9d8e			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9db7	d0 dd		bne $9d96			bne 	HelperValueError
.9db9	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9dbb	15 68		ora $68,x			ora 	NSMantissa2,x
.9dbd	15 60		ora $60,x			ora 	NSMantissa1,x
.9dbf	d0 d5		bne $9d96			bne 	HelperValueError
.9dc1	b5 58		lda $58,x			lda 	NSMantissa0,x
.9dc3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dc4					Multiply8x8:
.9dc4	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dc5	85 36		sta $36			  	sta 	zTemp0
.9dc7	86 37		stx $37				stx 	zTemp0+1
.9dc9	a9 00		lda #$00			lda 	#0
.9dcb	a2 08		ldx #$08			ldx 	#8
.9dcd					_M88Loop:
.9dcd	90 03		bcc $9dd2			bcc 	_M88NoAdd
.9dcf	18		clc				clc
.9dd0	65 37		adc $37				adc 	zTemp0+1
.9dd2					_M88NoAdd:
.9dd2	6a		ror a				ror 	a
.9dd3	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dd5	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9dd6	d0 f5		bne $9dcd			bne 	_M88Loop
.9dd8	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9dda	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9ddb					NSMNegate:
.9ddb	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9ddd	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9ddf	95 50		sta $50,x			sta 	NSStatus,x
.9de1	60		rts				rts
.9de2					NSMNegateMantissa:
.9de2	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9de3	a9 00		lda #$00			lda 	#0
.9de5	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9de7	95 58		sta $58,x			sta 	NSMantissa0,x
.9de9	a9 00		lda #$00			lda 	#0
.9deb	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9ded	95 60		sta $60,x			sta 	NSMantissa1,x
.9def	a9 00		lda #$00			lda 	#0
.9df1	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9df3	95 68		sta $68,x			sta 	NSMantissa2,x
.9df5	a9 00		lda #$00			lda 	#0
.9df7	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9df9	95 70		sta $70,x			sta 	NSMantissa3,x
.9dfb	60		rts				rts
.9dfc					NSMShiftUpTwo:
.9dfc	b5 58		lda $58,x			lda 	NSMantissa0,x
.9dfe	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9e00	b5 60		lda $60,x			lda 	NSMantissa1,x
.9e02	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9e04	b5 68		lda $68,x			lda 	NSMantissa2,x
.9e06	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9e08	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e0a	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9e0c	b5 78		lda $78,x			lda 	NSExponent,x
.9e0e	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9e10	b5 50		lda $50,x			lda 	NSStatus,x
.9e12	95 52		sta $52,x			sta 	NSStatus+2,x
.9e14	60		rts				rts
.9e15					NSMSetZeroMantissaOnly:
.9e15	a9 00		lda #$00			lda 	#0
.9e17	80 06		bra $9e1f			bra 	NSMSetMantissa
.9e19					NSMSetZero:
.9e19	a9 00		lda #$00			lda 	#0
.9e1b					NSMSetByte:
.9e1b	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e1d	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9e1f					NSMSetMantissa:
.9e1f	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9e21	74 60		stz $60,x			stz 	NSMantissa1,x
.9e23	74 68		stz $68,x			stz 	NSMantissa2,x
.9e25	74 70		stz $70,x			stz 	NSMantissa3,x
.9e27	60		rts				rts
.9e28					NSMShiftLeft:
.9e28	18		clc				clc
.9e29					NSMRotateLeft:
.9e29	36 58		rol $58,x			rol 	NSMantissa0,x
.9e2b	36 60		rol $60,x			rol		NSMantissa1,x
.9e2d	36 68		rol $68,x			rol		NSMantissa2,x
.9e2f	36 70		rol $70,x			rol		NSMantissa3,x
.9e31	60		rts				rts
.9e32					NSMShiftRight:
.9e32	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9e34	76 68		ror $68,x			ror		NSMantissa2,x
.9e36	76 60		ror $60,x			ror		NSMantissa1,x
.9e38	76 58		ror $58,x			ror		NSMantissa0,x
.9e3a	60		rts				rts
.9e3b					NSMIsZero:
.9e3b	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e3d	15 68		ora $68,x			ora		NSMantissa2,x
.9e3f	15 60		ora $60,x			ora		NSMantissa1,x
.9e41	15 58		ora $58,x			ora		NSMantissa0,x
.9e43	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9e44					TickHandler:
.9e44	5a		phy				phy 								; need to preserve Y
.9e45	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9e48	7a		ply				ply
.9e49	60		rts				rts
.065c					LastTick:
>065c							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e4a					Assemble_ora:
.9e4a	20 af 80	jsr $80af		jsr	AssembleGroup1
>9e4d	01					.byte $01
.9e4e					Assemble_and:
.9e4e	20 af 80	jsr $80af		jsr	AssembleGroup1
>9e51	21					.byte $21
.9e52					Assemble_eor:
.9e52	20 af 80	jsr $80af		jsr	AssembleGroup1
>9e55	41					.byte $41
.9e56					Assemble_adc:
.9e56	20 af 80	jsr $80af		jsr	AssembleGroup1
>9e59	61					.byte $61
.9e5a					Assemble_sta:
.9e5a	20 af 80	jsr $80af		jsr	AssembleGroup1
>9e5d	81					.byte $81
.9e5e					Assemble_lda:
.9e5e	20 af 80	jsr $80af		jsr	AssembleGroup1
>9e61	a1					.byte $a1
.9e62					Assemble_cmp:
.9e62	20 af 80	jsr $80af		jsr	AssembleGroup1
>9e65	c1					.byte $c1
.9e66					Assemble_sbc:
.9e66	20 af 80	jsr $80af		jsr	AssembleGroup1
>9e69	e1					.byte $e1
.9e6a					Assemble_asl:
.9e6a	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9e6d	02					.byte $02
>9e6e	75					.byte $75
.9e6f					Assemble_rol:
.9e6f	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9e72	22					.byte $22
>9e73	75					.byte $75
.9e74					Assemble_lsr:
.9e74	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9e77	42					.byte $42
>9e78	75					.byte $75
.9e79					Assemble_ror:
.9e79	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9e7c	62					.byte $62
>9e7d	75					.byte $75
.9e7e					Assemble_stx:
.9e7e	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9e81	82					.byte $82
>9e82	50					.byte $50
.9e83					Assemble_ldx:
.9e83	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9e86	a2					.byte $a2
>9e87	d0					.byte $d0
.9e88					Assemble_dec:
.9e88	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9e8b	c2					.byte $c2
>9e8c	55					.byte $55
.9e8d					Assemble_inc:
.9e8d	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9e90	e2					.byte $e2
>9e91	55					.byte $55
.9e92					Assemble_stz:
.9e92	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9e95	60					.byte $60
>9e96	44					.byte $44
.9e97					Assemble_bit:
.9e97	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9e9a	20					.byte $20
>9e9b	55					.byte $55
.9e9c					Assemble_sty:
.9e9c	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9e9f	80					.byte $80
>9ea0	54					.byte $54
.9ea1					Assemble_ldy:
.9ea1	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9ea4	a0					.byte $a0
>9ea5	d5					.byte $d5
.9ea6					Assemble_cpy:
.9ea6	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9ea9	c0					.byte $c0
>9eaa	d4					.byte $d4
.9eab					Assemble_cpx:
.9eab	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9eae	e0					.byte $e0
>9eaf	d0					.byte $d0
.9eb0					Assemble_tsb:
.9eb0	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9eb3	00					.byte $00
>9eb4	50					.byte $50
.9eb5					Assemble_trb:
.9eb5	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9eb8	10					.byte $10
>9eb9	50					.byte $50
.9eba					Assemble_jsr:
.9eba	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9ebd	14					.byte $14
>9ebe	10					.byte $10
.9ebf					Assemble_jmp:
.9ebf	20 b6 80	jsr $80b6		jsr	AssembleGroup2
>9ec2	40					.byte $40
>9ec3	10					.byte $10
.9ec4					Assemble_bpl:
.9ec4	20 07 81	jsr $8107		jsr	AssembleGroup3
>9ec7	10					.byte $10
.9ec8					Assemble_bmi:
.9ec8	20 07 81	jsr $8107		jsr	AssembleGroup3
>9ecb	30					.byte $30
.9ecc					Assemble_bvc:
.9ecc	20 07 81	jsr $8107		jsr	AssembleGroup3
>9ecf	50					.byte $50
.9ed0					Assemble_bvs:
.9ed0	20 07 81	jsr $8107		jsr	AssembleGroup3
>9ed3	70					.byte $70
.9ed4					Assemble_bcc:
.9ed4	20 07 81	jsr $8107		jsr	AssembleGroup3
>9ed7	90					.byte $90
.9ed8					Assemble_bcs:
.9ed8	20 07 81	jsr $8107		jsr	AssembleGroup3
>9edb	b0					.byte $b0
.9edc					Assemble_bne:
.9edc	20 07 81	jsr $8107		jsr	AssembleGroup3
>9edf	d0					.byte $d0
.9ee0					Assemble_beq:
.9ee0	20 07 81	jsr $8107		jsr	AssembleGroup3
>9ee3	f0					.byte $f0
.9ee4					Assemble_bra:
.9ee4	20 07 81	jsr $8107		jsr	AssembleGroup3
>9ee7	80					.byte $80
.9ee8					Assemble_brk:
.9ee8	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9eeb	00					.byte $00
.9eec					Assemble_php:
.9eec	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9eef	08					.byte $08
.9ef0					Assemble_clc:
.9ef0	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9ef3	18					.byte $18
.9ef4					Assemble_plp:
.9ef4	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9ef7	28					.byte $28
.9ef8					Assemble_sec:
.9ef8	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9efb	38					.byte $38
.9efc					Assemble_rti:
.9efc	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9eff	40					.byte $40
.9f00					Assemble_pha:
.9f00	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f03	48					.byte $48
.9f04					Assemble_cli:
.9f04	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f07	58					.byte $58
.9f08					Assemble_phy:
.9f08	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f0b	5a					.byte $5a
.9f0c					Assemble_rts:
.9f0c	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f0f	60					.byte $60
.9f10					Assemble_pla:
.9f10	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f13	68					.byte $68
.9f14					Assemble_sei:
.9f14	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f17	78					.byte $78
.9f18					Assemble_ply:
.9f18	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f1b	7a					.byte $7a
.9f1c					Assemble_dey:
.9f1c	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f1f	88					.byte $88
.9f20					Assemble_txa:
.9f20	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f23	8a					.byte $8a
.9f24					Assemble_tya:
.9f24	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f27	98					.byte $98
.9f28					Assemble_txs:
.9f28	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f2b	9a					.byte $9a
.9f2c					Assemble_tay:
.9f2c	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f2f	a8					.byte $a8
.9f30					Assemble_tax:
.9f30	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f33	aa					.byte $aa
.9f34					Assemble_clv:
.9f34	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f37	b8					.byte $b8
.9f38					Assemble_tsx:
.9f38	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f3b	ba					.byte $ba
.9f3c					Assemble_iny:
.9f3c	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f3f	c8					.byte $c8
.9f40					Assemble_dex:
.9f40	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f43	ca					.byte $ca
.9f44					Assemble_cld:
.9f44	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f47	d8					.byte $d8
.9f48					Assemble_phx:
.9f48	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f4b	da					.byte $da
.9f4c					Assemble_stp:
.9f4c	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f4f	db					.byte $db
.9f50					Assemble_inx:
.9f50	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f53	e8					.byte $e8
.9f54					Assemble_nop:
.9f54	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f57	ea					.byte $ea
.9f58					Assemble_sed:
.9f58	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f5b	f8					.byte $f8
.9f5c					Assemble_plx:
.9f5c	20 3b 81	jsr $813b		jsr	AssembleGroup4
>9f5f	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f60					DecimalScalarTable:
>9f60	66 66 66 66				.dword $66666666 ; 0.1
>9f64	de					.byte $de
>9f65	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f69	db					.byte $db
>9f6a	4c 37 89 41				.dword $4189374c ; 0.001
>9f6e	d8					.byte $d8
>9f6f	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f73	d4					.byte $d4
>9f74	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f78	d1					.byte $d1
>9f79	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f7d	ce					.byte $ce
>9f7e	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f82	ca					.byte $ca
>9f83	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9f87	c7					.byte $c7
>9f88	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f8c	c4					.byte $c4
>9f8d	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f91	c0					.byte $c0
>9f92	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9f96	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9f97					SyntaxError:
.9f97	a9 02		lda #$02		lda	#2
.9f99	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.9f9c					RangeError:
.9f9c	a9 04		lda #$04		lda	#4
.9f9e	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.9fa1					TypeError:
.9fa1	a9 05		lda #$05		lda	#5
.9fa3	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.9fa6					ArgumentError:
.9fa6	a9 07		lda #$07		lda	#7
.9fa8	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.9fab					NotDoneError:
.9fab	a9 0c		lda #$0c		lda	#12
.9fad	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.9fb0					ErrorText:
>9fb0	42 72 65 61 6b 00			.text	"Break",0
>9fb6	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fbe	72 72 6f 72 00
>9fc3	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fcb	20 62 79 20 7a 65 72 6f 00
>9fd4	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9fdc	61 6e 67 65 00
>9fe1	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9fe9	6d 61 74 63 68 00
>9fef	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9ff7	65 6d 6f 72 79 00
>9ffd	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a005	61 72 67 75 6d 65 6e 74 00
>a00e	53 74 6f 70 00				.text	"Stop",0
>a013	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a01b	6f 6f 20 6c 6f 6e 67 00
>a023	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a02b	6e 20 66 61 69 6c 65 64 00
>a034	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a03c	61 74 61 00
>a040	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a048	65 6e 74 65 64 00
>a04e	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a056	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a062	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a06a	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a077	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a07f	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a08c	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a094	68 6f 75 74 20 57 68 69 6c 65 00
>a09f	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0a7	68 6f 75 74 20 46 6f 72 00
>a0b0	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0b8	61 63 6b 20 66 75 6c 6c 00
>a0c1	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0c9	75 63 74 75 72 65 00
>a0d0	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0d8	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a0e5	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a0ed	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a0fb	41 72 72 61 79 20 73 69			.text	"Array size",0
>a103	7a 65 00
>a106	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a10e	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a116	52 65 6c 65 61 73 65 20			.text "Release Alpha 12 (05-Dec-22). "
>a11e	41 6c 70 68 61 20 31 32 20 28 30 35 2d 44 65 63
>a12e	2d 32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a134					RectangleCommand:
.a134	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a136	80 02		bra $a13a			bra 	ShapeDrawCmd
.a138					CircleCommand:
.a138	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a13a					ShapeDrawCmd:
.a13a	20 c4 a1	jsr $a1c4			jsr 	RunGraphicsCommand
.a13d					ShapeDraw:
.a13d	0d 5e 06	ora $065e			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a140	4c b8 a1	jmp $a1b8			jmp 	ExecuteGraphicCommand	 	; and complete
.a143					SpriteCommand:
.a143	a2 00		ldx #$00			ldx 	#0
.a145	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; get image number.
.a148	5a		phy				phy
.a149	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a14b	a6 58		ldx $58				ldx 	NSMantissa0
.a14d	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a14f	b0 0d		bcs $a15e			bcs 	_SCRange
.a151	a0 ff		ldy #$ff			ldy 	#255
.a153	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a156	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a158	7a		ply				ply
.a159	20 c4 a1	jsr $a1c4			jsr 	RunGraphicsCommand
.a15c	80 5a		bra $a1b8			bra 	ExecuteGraphicCommand
.a15e					_SCRange:
.a15e	4c 9c 9f	jmp $9f9c			jmp 	RangeError
.a161					ImageCommand:
.a161	a2 00		ldx #$00			ldx 	#0
.a163	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; get image number.
.a166	20 c4 a1	jsr $a1c4			jsr 	RunGraphicsCommand
.a169					ImageRunDraw:
.a169	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a16b	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a16e	ad 64 06	lda $0664			lda 	gxDrawScale
.a171	0a		asl a				asl 	a
.a172	0a		asl a				asl 	a
.a173	0a		asl a				asl 	a
.a174	a8		tay				tay
.a175	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a177	a6 58		ldx $58				ldx 	NSMantissa0
.a179	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a17c	60		rts				rts
.a17d					TextCommand:
.a17d	a2 00		ldx #$00			ldx 	#0
.a17f	20 71 9d	jsr $9d71			jsr 	EvaluateString 				; get text
.a182	20 c4 a1	jsr $a1c4			jsr 	RunGraphicsCommand
.a185					TextRunDraw:
.a185	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a187	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a18a	a0 00		ldy #$00			ldy 	#0
.a18c					_IRDLoop:
.a18c	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a18e	85 37		sta $37				sta 	zTemp0+1
.a190	a5 58		lda $58				lda 	NSMantissa0
.a192	85 36		sta $36				sta 	zTemp0
.a194	b1 36		lda ($36),y			lda 	(zTemp0),y
.a196	f0 13		beq $a1ab			beq 	_IRDExit
.a198	5a		phy				phy									; save string pos
.a199	48		pha				pha 								; save char
.a19a	ad 64 06	lda $0664			lda 	gxDrawScale 				; get scale
.a19d	0a		asl a				asl 	a
.a19e	0a		asl a				asl 	a
.a19f	0a		asl a				asl 	a
.a1a0	a8		tay				tay
.a1a1	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1a3	fa		plx				plx 								; char to draw
.a1a4	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1a7	7a		ply				ply 								; restore string pos
.a1a8	c8		iny				iny
.a1a9	90 e1		bcc $a18c			bcc 	_IRDLoop 					; go back if no error.
.a1ab					_IRDExit:
.a1ab	60		rts				rts
.a1ac					PlotCommand:
.a1ac	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1ae	20 c4 a1	jsr $a1c4			jsr 	RunGraphicsCommand
.a1b1	80 05		bra $a1b8			bra 	ExecuteGraphicCommand
.a1b3					LineCommand:
.a1b3	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1b5	20 c4 a1	jsr $a1c4			jsr 	RunGraphicsCommand
.a1b8					ExecuteGraphicCommand:
.a1b8	0d 5d 06	ora $065d			ora 	gxCommandID 				; make a full command
.a1bb	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a1be	b0 01		bcs $a1c1			bcs 	_EGCError
.a1c0	60		rts				rts
.a1c1					_EGCError:
.a1c1	4c 97 9f	jmp $9f97			jmp 	SyntaxError
.a1c4					RunGraphicsCommand:
.a1c4	8d 5d 06	sta $065d			sta 	gxCommandID					; save TODO graphics command.
.a1c7	68		pla				pla 								; pop handler address
.a1c8	fa		plx				plx
.a1c9	1a		inc a				inc 	a
.a1ca	d0 01		bne $a1cd			bne 	_RGINoCarry
.a1cc	e8		inx				inx
.a1cd					_RGINoCarry:
.a1cd	8d 62 06	sta $0662			sta 	GXHandler
.a1d0	8e 63 06	stx $0663			stx 	GXHandler+1
.a1d3					_RGICommandLoop:
.a1d3	b1 30		lda ($30),y			lda 	(codePtr),y
.a1d5	c8		iny				iny
.a1d6	c9 d2		cmp #$d2			cmp 	#KWD_TO						; is it TO x,y
.a1d8	f0 53		beq $a22d			beq 	_RGI_To
.a1da	c9 bd		cmp #$bd			cmp 	#KWD_HERE 					; do it here.
.a1dc	f0 55		beq $a233			beq 	_RGI_Here
.a1de	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a1e0	f0 3d		beq $a21f			beq 	_RGI_Exit
.a1e2	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a1e4	f0 39		beq $a21f			beq 	_RGI_Exit
.a1e6	c9 c5		cmp #$c5			cmp 	#KWD_OUTLINE 				; solid or outline
.a1e8	f0 3e		beq $a228			beq 	_RGI_Frame
.a1ea	c9 ce		cmp #$ce			cmp 	#KWD_SOLID
.a1ec	f0 33		beq $a221			beq 	_RGI_Solid
.a1ee	c9 ad		cmp #$ad			cmp 	#KWD_BY 					; by offset
.a1f0	f0 4b		beq $a23d			beq 	_RGI_By
.a1f2	c9 b9		cmp #$b9			cmp 	#KWD_FROM 					; from
.a1f4	f0 17		beq $a20d			beq 	_RGI_Move2
.a1f6	c9 b5		cmp #$b5			cmp 	#KWD_DIM 					; dim (set scale)
.a1f8	f0 62		beq $a25c			beq 	_RGI_Dim
.a1fa	c9 b3		cmp #$b3			cmp 	#KWD_COLOUR 				; colour or Color
.a1fc	f0 74		beq $a272			beq 	_RGI_Colour
.a1fe	c9 b2		cmp #$b2			cmp 	#KWD_COLOR
.a200	f0 70		beq $a272			beq 	_RGI_Colour
.a202	ae 5d 06	ldx $065d			ldx 	gxCommandID
.a205	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a207	d0 03		bne $a20c			bne 	_RGI_Move 					; move
.a209	4c 9a a2	jmp $a29a			jmp		_RGI_SpriteInstructions
.a20c					_RGI_Move:
.a20c	88		dey				dey 								; unpick get.
.a20d					_RGI_Move2:
.a20d	20 c0 a2	jsr $a2c0			jsr 	GCGetCoordinatePair 		; move to here
.a210	20 e7 a2	jsr $a2e7			jsr 	GCCopyPairToStore 			; save
.a213	5a		phy				phy
.a214	20 dd a2	jsr $a2dd			jsr 	GCLoadAXY 					; load in
.a217	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a219	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a21c	7a		ply				ply
.a21d	80 b4		bra $a1d3			bra 	_RGICommandLoop 			; and go round
.a21f					_RGI_Exit:
.a21f	88		dey				dey 								; unpick : / EOL
.a220	60		rts				rts
.a221					_RGI_Solid:
.a221	a9 02		lda #$02			lda 	#2
.a223	8d 5e 06	sta $065e			sta 	gxFillSolid
.a226	80 ab		bra $a1d3			bra 	_RGICommandLoop
.a228					_RGI_Frame:
.a228	9c 5e 06	stz $065e			stz 	gxFillSolid
.a22b	80 a6		bra $a1d3			bra 	_RGICommandLoop
.a22d					_RGI_To:
.a22d	20 c0 a2	jsr $a2c0			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a230	20 e7 a2	jsr $a2e7			jsr 	GCCopyPairToStore
.a233					_RGI_Here:
.a233	5a		phy				phy
.a234	20 dd a2	jsr $a2dd			jsr 	GCLoadAXY 					; load it into AXY
.a237	20 97 a2	jsr $a297			jsr 	_RGICallHandler 			; go do whatever it is.
.a23a	7a		ply				ply
.a23b	80 96		bra $a1d3			bra 	_RGICommandLoop 			; and go round
.a23d					_RGI_By:
.a23d	20 cd a2	jsr $a2cd			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a240	18		clc				clc
.a241	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a243	6d 5f 06	adc $065f			adc 	gxxPos
.a246	8d 5f 06	sta $065f			sta 	gxXPos
.a249	a5 61		lda $61				lda 	NSMantissa1+1
.a24b	6d 60 06	adc $0660			adc 	gxxPos+1
.a24e	8d 60 06	sta $0660			sta 	gxXPos+1
.a251	a5 5a		lda $5a				lda 	NSMantissa0+2
.a253	18		clc				clc
.a254	6d 61 06	adc $0661			adc 	gxYPos
.a257	8d 61 06	sta $0661			sta 	gxYPos
.a25a	80 d7		bra $a233			bra 	_RGI_Here
.a25c					_RGI_Dim:
.a25c	a2 01		ldx #$01			ldx	 	#1
.a25e	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger
.a261	a5 59		lda $59				lda 	NSMantissa0+1
.a263	c9 00		cmp #$00			cmp 	#0
.a265	f0 2d		beq $a294			beq 	_RGIRange
.a267	c9 09		cmp #$09			cmp 	#8+1
.a269	b0 29		bcs $a294			bcs		_RGIRange
.a26b	3a		dec a				dec 	a
.a26c	8d 64 06	sta $0664			sta 	gxDrawScale
.a26f	4c d3 a1	jmp $a1d3			jmp 	_RGICommandLoop
.a272					_RGI_Colour:
.a272	a2 01		ldx #$01			ldx 	#1 							; colour
.a274	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger
.a277	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a279	20 19 9e	jsr $9e19			jsr 	NSMSetZero
.a27c	b1 30		lda ($30),y			lda 	(codePtr),y
.a27e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a280	d0 04		bne $a286			bne 	_RGICDefaultMode
.a282	c8		iny				iny
.a283	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger
.a286					_RGICDefaultMode:
.a286	5a		phy				phy
.a287	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a289	a6 59		ldx $59				ldx 	NSMantissa0+1
.a28b	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a28d	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a290	7a		ply				ply
.a291	4c d3 a1	jmp $a1d3			jmp 	_RGICommandLoop 			; and go round
.a294					_RGIRange:
.a294	4c 9c 9f	jmp $9f9c			jmp 	RangeError
.a297					_RGICallHandler:
.a297	6c 62 06	jmp ($0662)			jmp 	(GXHandler)
.a29a					_RGI_SpriteInstructions:
.a29a	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a29c	f0 07		beq $a2a5			beq 	_RGISpriteOff
.a29e	c9 be		cmp #$be			cmp 	#KWD_IMAGE
.a2a0	f0 13		beq $a2b5			beq 	_RGISetImage
.a2a2	4c 0c a2	jmp $a20c			jmp 	_RGI_Move
.a2a5					_RGISpriteOff:
.a2a5	5a		phy				phy
.a2a6	a0 01		ldy #$01			ldy 	#1
.a2a8	a2 00		ldx #$00			ldx 	#0
.a2aa					_RGIDoCommandLoop:
.a2aa	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2ac	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2af	7a		ply				ply
.a2b0	b0 e2		bcs $a294			bcs 	_RGIRange
.a2b2	4c d3 a1	jmp $a1d3			jmp 	_RGICommandLoop
.a2b5					_RGISetImage:
.a2b5	a2 01		ldx #$01			ldx 	#1
.a2b7	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger
.a2ba	5a		phy				phy
.a2bb	aa		tax				tax
.a2bc	a0 00		ldy #$00			ldy 	#0
.a2be	80 ea		bra $a2aa			bra 	_RGIDoCommandLoop
.a2c0					GCGetCoordinatePair:
.a2c0	a2 01		ldx #$01			ldx 	#1
.a2c2	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger
.a2c5	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.a2c8	e8		inx				inx
.a2c9	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger
.a2cc	60		rts				rts
.a2cd					GCSignedCoordinatePair:
.a2cd	a2 01		ldx #$01			ldx 	#1
.a2cf	20 a3 9d	jsr $9da3			jsr 	Evaluate16BitIntegerSigned
.a2d2	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.a2d5	e8		inx				inx
.a2d6	20 a3 9d	jsr $9da3			jsr 	Evaluate16BitIntegerSigned
.a2d9	60		rts				rts
.a2da					_GCCPRange:
.a2da	4c 9c 9f	jmp $9f9c			jmp 	RangeError
.a2dd					GCLoadAXY:
.a2dd	ad 60 06	lda $0660			lda 	gxXPos+1
.a2e0	ae 5f 06	ldx $065f			ldx 	gxXPos
.a2e3	ac 61 06	ldy $0661			ldy 	gxYPos
.a2e6	60		rts				rts
.a2e7					GCCopyPairToStore:
.a2e7	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a2e9	8d 5f 06	sta $065f			sta 	gxXPos
.a2ec	a5 61		lda $61				lda 	NSMantissa1+1
.a2ee	8d 60 06	sta $0660			sta 	gxXPos+1
.a2f1	a5 5a		lda $5a				lda 	NSMantissa0+2
.a2f3	8d 61 06	sta $0661			sta 	gxYPos
.a2f6	60		rts				rts
.065d					gxCommandID:
>065d							.fill 	1
.065e					gxFillSolid:
>065e							.fill 	1
.065f					gxXPos:
>065f							.fill 	2
.0661					gxYPos:
>0661							.fill 	1
.0662					gxHandler:
>0662							.fill 	2
.0664					gxDrawScale:
>0664							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a2f7					BitmapCtrl:
.a2f7	b1 30		lda ($30),y			lda 	(codePtr),y
.a2f9	c8		iny				iny
.a2fa	a2 01		ldx #$01			ldx 	#1
.a2fc	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a2fe	f0 11		beq $a311			beq 	BitmapSwitch
.a300	ca		dex				dex
.a301	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a303	f0 0c		beq $a311			beq 	BitmapSwitch
.a305	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; get the colour
.a308	5a		phy				phy
.a309	aa		tax				tax
.a30a	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a30c	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a30f	7a		ply				ply
.a310	60		rts				rts
.a311					BitmapSwitch:
.a311	5a		phy				phy
.a312	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a314	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a316	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a319	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a31b	a0 00		ldy #$00			ldy 	#0
.a31d	a2 ff		ldx #$ff			ldx 	#$FF
.a31f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a322	9c 5e 06	stz $065e			stz 	gxFillSolid
.a325	9c 5f 06	stz $065f			stz 	gxXPos
.a328	9c 60 06	stz $0660			stz 	gxXPos+1
.a32b	9c 61 06	stz $0661			stz 	gxYPos
.a32e	9c 64 06	stz $0664			stz 	gxDrawScale
.a331	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a333	a2 00		ldx #$00			ldx 	#0
.a335	a0 00		ldy #$00			ldy 	#0
.a337	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a33a	7a		ply				ply
.a33b	60		rts				rts
.a33c					SpritesCtrl:
.a33c	b1 30		lda ($30),y			lda 	(codePtr),y
.a33e	c8		iny				iny
.a33f	a2 01		ldx #$01			ldx 	#1
.a341	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a343	f0 08		beq $a34d			beq 	SpriteSwitch
.a345	ca		dex				dex
.a346	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a348	f0 03		beq $a34d			beq 	SpriteSwitch
.a34a	4c 97 9f	jmp $9f97			jmp 	SyntaxError
.a34d					SpriteSwitch:
.a34d	5a		phy				phy
.a34e	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a350	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a352	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a355	7a		ply				ply
.a356	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a357					GfxCommand:
.a357	a2 00		ldx #$00			ldx 	#0
.a359	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; command
.a35c	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.a35f	e8		inx				inx
.a360	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger 		; X
.a363	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.a366	e8		inx				inx
.a367	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; Y
.a36a	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a36c	4a		lsr a				lsr 	a
.a36d	d0 12		bne $a381			bne 	_GfxError
.a36f	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a371	b0 0e		bcs $a381			bcs 	_GfxError 					; bit 7 should have been zero
.a373	5a		phy				phy 								; save pos
.a374	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a376	a6 59		ldx $59				ldx 	NSMantissa0+1
.a378	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a37a	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a37d	b0 02		bcs $a381			bcs 	_GfxError
.a37f	7a		ply				ply 								; restore pos and exit.
.a380	60		rts				rts
.a381					_GfxError:
.a381	4c 9c 9f	jmp $9f9c			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a384					UnaryHit:
.a384	fa		plx				plx
.a385	a9 36		lda #$36			lda 	#zTemp0
.a387	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a38a	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.a38d	e8		inx				inx
.a38e	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a391	20 de 8e	jsr $8ede			jsr		CheckRightBracket
.a394	ca		dex				dex 								; fix back up again.
.a395	da		phx				phx 								; save X/Y
.a396	5a		phy				phy
.a397	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a399	b5 58		lda $58,x			lda 	NSMantissa0,x
.a39b	aa		tax				tax
.a39c	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a39e	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a3a1	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3a2	7a		ply				ply 								; restore XY
.a3a3	fa		plx				plx
.a3a4	20 1b 9e	jsr $9e1b			jsr 	NSMSetByte 					; return the hit result
.a3a7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3a8					PaletteCommand:
.a3a8	a2 00		ldx #$00			ldx 	#0
.a3aa	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; colour
.a3ad	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.a3b0	e8		inx				inx
.a3b1	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger 		; r
.a3b4	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.a3b7	e8		inx				inx
.a3b8	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; g
.a3bb	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.a3be	e8		inx				inx
.a3bf	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; b
.a3c2	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a3c4	85 36		sta $36				sta 	zTemp0
.a3c6	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a3c8	85 37		sta $37				sta 	zTemp0+1
.a3ca	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a3cc	26 37		rol $37				rol	 	zTemp0+1
.a3ce	06 36		asl $36				asl 	zTemp0
.a3d0	26 37		rol $37				rol	 	zTemp0+1
.a3d2	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a3d4	85 01		sta $01				sta 	1
.a3d6	5a		phy				phy
.a3d7	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a3d9	92 36		sta ($36)			sta 	(zTemp0)
.a3db	a0 01		ldy #$01			ldy 	#1
.a3dd	a5 5a		lda $5a				lda 	NSMantissa0+2
.a3df	91 36		sta ($36),y			sta 	(zTemp0),y
.a3e1	a5 59		lda $59				lda 	NSMantissa0+1
.a3e3	c8		iny				iny
.a3e4	91 36		sta ($36),y			sta 	(zTemp0),y
.a3e6	7a		ply				ply
.a3e7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a3e8					UnaryEvent:
.a3e8	fa		plx				plx
.a3e9	20 96 a4	jsr $a496			jsr 	TimerToStackX 				; timer in +0
.a3ec	e8		inx				inx  								; put reference into +1
.a3ed	20 45 98	jsr $9845			jsr 	EvaluateTerm
.a3f0	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a3f2	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a3f4	d0 4c		bne $a442			bne 	_UEType
.a3f6	e8		inx				inx 								; put the step in +2
.a3f7	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.a3fa	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger
.a3fd	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.a400	ca		dex				dex
.a401	ca		dex				dex
.a402	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a404	85 36		sta $36				sta 	zTemp0
.a406	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a408	85 37		sta $37				sta 	zTemp0+1
.a40a	5a		phy				phy
.a40b	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a40d	b1 36		lda ($36),y			lda 	(zTemp0),y
.a40f	30 2d		bmi $a43e			bmi 	_UEFalse 					; exit if signed.
.a411	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a413	b5 58		lda $58,x			lda 	NSMantissa0,x
.a415	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a417	c8		iny				iny
.a418	b5 60		lda $60,x			lda 	NSMantissa1,x
.a41a	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a41c	c8		iny				iny
.a41d	b5 68		lda $68,x			lda 	NSMantissa2,x
.a41f	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a421	90 1b		bcc $a43e			bcc 	_UEFalse 					; no, return FALSE.
.a423	18		clc				clc
.a424	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a426	b5 58		lda $58,x			lda 	NSMantissa0,x
.a428	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a42a	91 36		sta ($36),y			sta 	(zTemp0),y
.a42c	c8		iny				iny
.a42d	b5 60		lda $60,x			lda 	NSMantissa1,x
.a42f	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a431	91 36		sta ($36),y			sta 	(zTemp0),y
.a433	c8		iny				iny
.a434	b5 68		lda $68,x			lda 	NSMantissa2,x
.a436	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a438	91 36		sta ($36),y			sta 	(zTemp0),y
.a43a	7a		ply				ply
.a43b	4c 64 8f	jmp $8f64			jmp 	ReturnTrue
.a43e					_UEFalse:
.a43e	7a		ply				ply 								; restore Y
.a43f	4c 6f 8f	jmp $8f6f			jmp 	ReturnFalse 				; and return False
.a442					_UEType:
.a442	4c a1 9f	jmp $9fa1			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a445					UnaryJoyX:
.a445	18		clc				clc
.a446	80 01		bra $a449			bra 	JoyMain
.a448					UnaryJoyY:
.a448	38		sec				sec
.a449					JoyMain:
.a449	fa		plx				plx 								; get pos
.a44a	08		php				php 								; save carry (set for Y)
.a44b	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a44e	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.a451	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a454	28		plp				plp
.a455	90 02		bcc $a459			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a457	4a		lsr a				lsr 	a
.a458	4a		lsr a				lsr 	a
.a459					_JMNoShift:
.a459	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a45a	b0 0a		bcs $a466			bcs 	_JMIsRight
.a45c	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a45d	b0 04		bcs $a463			bcs 	_JMIsLeft
.a45f	20 19 9e	jsr $9e19			jsr 	NSMSetZero 					; zero result
.a462	60		rts				rts
.a463					_JMIsLeft:
.a463	4c 64 8f	jmp $8f64			jmp 	ReturnTrue
.a466					_JMIsRight:
.a466	a9 01		lda #$01			lda 	#1
.a468	20 1b 9e	jsr $9e1b			jsr 	NSMSetByte
.a46b	60		rts				rts
.a46c					UnaryJoyB:
.a46c	fa		plx				plx 								; get pos
.a46d	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a470	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.a473	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a476	4a		lsr a				lsr 	a
.a477	4a		lsr a				lsr 	a
.a478	4a		lsr a				lsr 	a
.a479	4a		lsr a				lsr 	a
.a47a	29 01		and #$01			and 	#1
.a47c	20 1b 9e	jsr $9e1b			jsr 	NSMSetByte
.a47f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a480					LoadCommand:
.a480	20 2c 8a	jsr $8a2c			jsr 	NewProgram
.a483	20 1e 83	jsr $831e			jsr 	BackLoadProgram
.a486	4c d5 83	jmp $83d5			jmp 	WarmStart
.a489					GoCommand:
.a489	20 2c 8a	jsr $8a2c			jsr 	NewProgram
.a48c	20 1e 83	jsr $831e			jsr 	BackLoadProgram
.a48f	4c 6d 8b	jmp $8b6d			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a492					UnaryTimer:
.a492	fa		plx				plx
.a493	20 de 8e	jsr $8ede			jsr 	CheckRightBracket
.a496					TimerToStackX:
.a496	20 19 9e	jsr $9e19			jsr 	NSMSetZero 					; zero result
.a499	64 01		stz $01				stz 	1 							; access I/O
.a49b	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a49e	95 58		sta $58,x			sta 	NSMantissa0,x
.a4a0	ad 5a d6	lda $d65a			lda 	$D65A
.a4a3	95 60		sta $60,x			sta 	NSMantissa1,x
.a4a5	ad 5b d6	lda $d65b			lda 	$D65B
.a4a8	95 68		sta $68,x			sta 	NSMantissa2,x
.a4aa	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4ab					MemoryDeleteLine:
.a4ab	20 ca a4	jsr $a4ca			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4ae	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4b0	a8		tay				tay
.a4b1					_MDDLLoop:
.a4b1	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4b3	92 30		sta ($30)			sta 	(codePtr)
.a4b5	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4b7	c5 3a		cmp $3a				cmp 	zTemp2
.a4b9	d0 07		bne $a4c2			bne 	_MDLDLNext
.a4bb	a5 31		lda $31				lda 	codePtr+1
.a4bd	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4bf	d0 01		bne $a4c2			bne 	_MDLDLNext
.a4c1					_MDDLExit:
.a4c1	60		rts				rts
.a4c2					_MDLDLNext:
.a4c2	e6 30		inc $30				inc 	codePtr						; next byte
.a4c4	d0 eb		bne $a4b1			bne 	_MDDLLoop
.a4c6	e6 31		inc $31				inc 	codePtr+1
.a4c8	80 e7		bra $a4b1			bra 	_MDDLLoop
.a4ca					IMemoryFindEnd:
.a4ca	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4cc	85 3a		sta $3a				sta 	0+zTemp2
.a4ce	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4d0	85 3b		sta $3b				sta 	1+zTemp2
.a4d2					_MDLFELoop:
.a4d2	b2 3a		lda ($3a)			lda 	(zTemp2)
.a4d4	f0 0b		beq $a4e1			beq 	_MDLFEExit
.a4d6	18		clc				clc
.a4d7	65 3a		adc $3a				adc 	zTemp2
.a4d9	85 3a		sta $3a				sta 	zTemp2
.a4db	90 f5		bcc $a4d2			bcc 	_MDLFELoop
.a4dd	e6 3b		inc $3b				inc 	zTemp2+1
.a4df	80 f1		bra $a4d2			bra 	_MDLFELoop
.a4e1					_MDLFEExit:
.a4e1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a4e2					MemoryInsertLine:
.a4e2	08		php				php
.a4e3	20 ca a4	jsr $a4ca			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4e6	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a4e8	1a		inc a				inc 	a
.a4e9	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a4eb	b0 36		bcs $a523			bcs 	_MDLIError
.a4ed	28		plp				plp
.a4ee	90 08		bcc $a4f8			bcc 	_MDLIFound
.a4f0	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a4f2	85 30		sta $30				sta 	codePtr
.a4f4	a5 3b		lda $3b				lda 	zTemp2+1
.a4f6	85 31		sta $31				sta 	codePtr+1
.a4f8					_MDLIFound:
.a4f8	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a4fb	a8		tay				tay
.a4fc					_MDLIInsert:
.a4fc	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a4fe	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a500	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a502	c5 3a		cmp $3a				cmp 	zTemp2
.a504	d0 06		bne $a50c			bne 	_MDLINext
.a506	a5 31		lda $31				lda 	codePtr+1
.a508	c5 3b		cmp $3b				cmp 	zTemp2+1
.a50a	f0 0a		beq $a516			beq 	_MDLIHaveSpace
.a50c					_MDLINext:
.a50c	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a50e	d0 02		bne $a512			bne 	_MDLINoBorrow
.a510	c6 3b		dec $3b				dec 	zTemp2+1
.a512					_MDLINoBorrow:
.a512	c6 3a		dec $3a				dec 	zTemp2
.a514	80 e6		bra $a4fc			bra 	_MDLIInsert
.a516					_MDLIHaveSpace:
.a516	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a519	88		dey				dey 								; from offset-1 to 0
.a51a					_MDLICopy:
.a51a	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a51d	91 30		sta ($30),y			sta 	(codePtr),y
.a51f	88		dey				dey
.a520	10 f8		bpl $a51a			bpl 	_MDLICopy
.a522	60		rts				rts
.a523					_MDLIError:
.a523	a9 06		lda #$06		lda	#6
.a525	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.a528					MDLAppendLine:
.a528	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a52a	85 36		sta $36				sta 	zTemp0
.a52c	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a52e	85 38		sta $38				sta 	0+zTemp1
.a530	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a532	85 39		sta $39				sta 	1+zTemp1
.a534	b2 38		lda ($38)			lda 	(zTemp1)
.a536	d0 0a		bne $a542			bne 	_MDLANoInitialise
.a538	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a53a	8d 65 06	sta $0665			sta 	0+AppendPointer
.a53d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a53f	8d 66 06	sta $0666			sta 	1+AppendPointer
.a542					_MDLANoInitialise:
.a542	18		clc				clc
.a543	ad 65 06	lda $0665			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a546	85 38		sta $38				sta 	zTemp1
.a548	72 36		adc ($36)			adc 	(zTemp0)
.a54a	8d 65 06	sta $0665			sta 	AppendPointer
.a54d	ad 66 06	lda $0666			lda 	AppendPointer+1
.a550	85 39		sta $39				sta 	zTemp1+1
.a552	69 00		adc #$00			adc 	#0
.a554	8d 66 06	sta $0666			sta 	AppendPointer+1
.a557	a0 00		ldy #$00			ldy 	#0
.a559					_MDLACopy:
.a559	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a55b	91 38		sta ($38),y			sta 	(zTemp1),y
.a55d	c8		iny				iny
.a55e	98		tya				tya
.a55f	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a561	d0 f6		bne $a559			bne 	_MDLACopy
.a563	a9 00		lda #$00			lda 	#0 							; end of program.
.a565	91 38		sta ($38),y			sta 	(zTemp1),y
.a567	60		rts				rts
.0665					AppendPointer:
>0665							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a568					MemoryNew:
.a568	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a56a	85 30		sta $30				sta 	codePtr
.a56c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a56e	85 31		sta $31				sta 	codePtr+1
.a570	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a572	92 30		sta ($30)			sta 	(codePtr)
.a574	60		rts				rts
.a575					MemoryInline:
.a575	98		tya				tya 								; put address into stack,x
.a576	18		clc				clc  								; get the offset, add codePtr
.a577	65 30		adc $30				adc 	codePtr
.a579	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a57b	a5 31		lda $31				lda 	codePtr+1
.a57d	69 00		adc #$00			adc 	#0
.a57f	95 60		sta $60,x			sta 	NSMantissa1,x
.a581	74 68		stz $68,x			stz 	NSMantissa2,x
.a583	74 70		stz $70,x			stz 	NSMantissa3,x
.a585	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a586					MemorySearch:
.a586	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a588	86 37		stx $37				stx 	zTemp0+1
.a58a	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a58c	85 30		sta $30				sta 	codePtr
.a58e	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a590	85 31		sta $31				sta 	codePtr+1
.a592					_MTAXLoop:
.a592	b2 30		lda ($30)			lda 	(codePtr)
.a594	18		clc				clc
.a595	f0 21		beq $a5b8			beq 	_MTAXExit 					; reached end, exit with CC.
.a597	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a599	b1 30		lda ($30),y			lda 	(codePtr),y
.a59b	38		sec				sec
.a59c	e5 36		sbc $36				sbc 	zTemp0
.a59e	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5a0	c8		iny				iny 								; do the MSB
.a5a1	b1 30		lda ($30),y			lda 	(codePtr),y
.a5a3	e5 37		sbc $37				sbc 	zTemp0+1
.a5a5	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a5a7	f0 0f		beq $a5b8			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a5a9	b0 0d		bcs $a5b8			bcs 	_MTAXExit 					; current < required exit
.a5ab	18		clc				clc
.a5ac	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a5ae	65 30		adc $30				adc 	codePtr
.a5b0	85 30		sta $30				sta 	codePtr
.a5b2	90 02		bcc $a5b6			bcc 	_CREExit
.a5b4	e6 31		inc $31				inc 	codePtr+1 					; carry
.a5b6					_CREExit:
.a5b6	80 da		bra $a592			bra 	_MTAXLoop
.a5b8					_MTAXExit:
.a5b8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/effects.asm

.a5b9					PingCommand:
.a5b9	5a		phy				phy 								; save pos
.a5ba	a9 01		lda #$01			lda 	#1 						; push channel.
.a5bc	48		pha				pha
.a5bd	a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.a5bf	a2 03		ldx #$03			ldx 	#3 						; length
.a5c1	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5c3	80 24		bra $a5e9			bra 	SoundEffectCommand
.a5c5					ZapCommand:
.a5c5	5a		phy				phy 								; save pos
.a5c6	a9 01		lda #$01			lda 	#1 						; push channel.
.a5c8	48		pha				pha
.a5c9	a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.a5cb	a2 05		ldx #$05			ldx 	#5 						; length
.a5cd	a0 14		ldy #$14			ldy 	#20 						; slide LSB
.a5cf	80 18		bra $a5e9			bra 	SoundEffectCommand
.a5d1					ShootCommand:
.a5d1	5a		phy				phy 								; save pos
.a5d2	a9 03		lda #$03			lda 	#3 						; push channel.
.a5d4	48		pha				pha
.a5d5	a9 20		lda #$20			lda 	#32 						; pitch LSB
.a5d7	a2 02		ldx #$02			ldx 	#2 						; length
.a5d9	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5db	80 0c		bra $a5e9			bra 	SoundEffectCommand
.a5dd					Explode:
.a5dd	5a		phy				phy 								; save pos
.a5de	a9 03		lda #$03			lda 	#3 						; push channel.
.a5e0	48		pha				pha
.a5e1	a9 50		lda #$50			lda 	#80 						; pitch LSB
.a5e3	a2 05		ldx #$05			ldx 	#5 						; length
.a5e5	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5e7	80 00		bra $a5e9			bra 	SoundEffectCommand
.a5e9					SoundEffectCommand:
.a5e9	8d 67 06	sta $0667			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.a5ec	9c 68 06	stz $0668			stz 	SoundCommandBlock+1
.a5ef	a9 0f		lda #$0f			lda 	#15
.a5f1	8d 69 06	sta $0669			sta 	SoundCommandBlock+2
.a5f4	8e 6a 06	stx $066a			stx 	SoundCommandBlock+3
.a5f7	8c 6b 06	sty $066b			sty 	SoundCommandBlock+4
.a5fa	9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a5fd	68		pla				pla
.a5fe	09 10		ora #$10			ora 	#$10  						; execute command $11
.a600	a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a602	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a604	20 18 80	jsr $8018			jsr 	SNDCommand
.a607	7a		ply				ply
.a608	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a609					UnaryPlaying:
.a609	fa		plx				plx
.a60a	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; get channel #
.a60d	48		pha				pha
.a60e	20 de 8e	jsr $8ede			jsr		CheckRightBracket
.a611	68		pla				pla
.a612	c9 04		cmp #$04			cmp 	#4
.a614	b0 0c		bcs $a622			bcs 	_UPNotPlaying
.a616	09 20		ora #$20			ora 	#$20 						; query playing ?
.a618	20 18 80	jsr $8018			jsr 	SNDCommand
.a61b	c9 00		cmp #$00			cmp 	#0
.a61d	f0 03		beq $a622			beq 	_UPNotPlaying
.a61f	4c 64 8f	jmp $8f64			jmp 	ReturnTrue
.a622					_UPNotPlaying:
.a622	4c 6f 8f	jmp $8f6f			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a625					SoundCommand:
.a625	b1 30		lda ($30),y			lda 	(codePtr),y
.a627	c9 c3		cmp #$c3			cmp 	#KWD_OFF 					; SOUND OFF ?
.a629	d0 09		bne $a634			bne 	_SNDMain
.a62b	c8		iny				iny 								; skip OFF
.a62c	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a62e	5a		phy				phy
.a62f	20 18 80	jsr $8018			jsr 	SNDCommand
.a632	7a		ply				ply
.a633	60		rts				rts
.a634					_SNDMain:
.a634	a2 00		ldx #$00			ldx 	#0
.a636	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; channel
.a639	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a63b	b0 4b		bcs $a688			bcs 	_SndError
.a63d	e8		inx				inx 								; do the rest in slot 1.
.a63e	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.a641	20 99 9d	jsr $9d99			jsr 	Evaluate16BitInteger 		; Pitch
.a644	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a646	c9 10		cmp #$10			cmp 	#16
.a648	b0 3e		bcs $a688			bcs 	_SndError
.a64a	8d 68 06	sta $0668			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a64d	b5 58		lda $58,x			lda 	NSMantissa0,x
.a64f	8d 67 06	sta $0667			sta 	SoundCommandBlock
.a652	20 e6 8e	jsr $8ee6			jsr 	CheckComma
.a655	20 b4 9d	jsr $9db4			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a658	8d 6a 06	sta $066a			sta 	SoundCommandBlock+3
.a65b	a9 0f		lda #$0f			lda 	#15
.a65d	8d 69 06	sta $0669			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a660	9c 6b 06	stz $066b			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a663	9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a666	b1 30		lda ($30),y			lda 	(codePtr),y
.a668	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a66a	d0 0e		bne $a67a			bne 	_SNDPlay
.a66c	c8		iny				iny
.a66d	20 a3 9d	jsr $9da3			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a670	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a672	8d 6b 06	sta $066b			sta 	SoundCommandBlock+4
.a675	b5 60		lda $60,x			lda 	NSMantissa1,x
.a677	8d 6c 06	sta $066c			sta 	SoundCommandBlock+5
.a67a					_SNDPlay:
.a67a	5a		phy				phy
.a67b	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a67d	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a67f	a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a681	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a683	20 18 80	jsr $8018			jsr 	SNDCommand
.a686	7a		ply				ply
.a687	60		rts				rts
.a688					_SndError:
.a688	4c 9c 9f	jmp $9f9c			jmp 	RangeError
.0667					SoundCommandBlock:
>0667							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a68b					StackPushByte:
.a68b	48		pha				pha 								; save byte on stack
.a68c	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a68e	d0 08		bne $a698			bne 	_SPBNoBorrow
.a690	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a692	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a694	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a696	90 06		bcc $a69e			bcc 	_SPBMemory
.a698					_SPBNoBorrow:
.a698	c6 34		dec $34				dec 	BasicStack
.a69a	68		pla				pla 								; get back and write
.a69b	92 34		sta ($34)			sta 	(BasicStack)
.a69d	60		rts				rts
.a69e					_SPBMemory:
.a69e	a9 12		lda #$12		lda	#18
.a6a0	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.a6a3					StackPopByte:
.a6a3	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a6a5	e6 34		inc $34				inc 	BasicStack
.a6a7	d0 02		bne $a6ab			bne 	_SPBNoCarry
.a6a9	e6 35		inc $35				inc 	BasicStack+1
.a6ab					_SPBNoCarry:
.a6ab	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a6ac					StackOpen:
.a6ac	48		pha				pha 								; save frame byte
.a6ad	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a6af	0a		asl a				asl 	a 							; claim twice this for storage
.a6b0	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a6b2	38		sec				sec 								; so basically subtracting from
.a6b3	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a6b5	85 34		sta $34				sta 	basicStack
.a6b7	b0 09		bcs $a6c2			bcs 	_SONoBorrow
>a6b9	db						.byte 	$DB 						; causes a break in the emulator
.a6ba	c6 35		dec $35				dec 	basicStack+1
.a6bc	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a6be	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6c0	90 04		bcc $a6c6			bcc 	_SOMemory
.a6c2					_SONoBorrow:
.a6c2	68		pla				pla 								; get marker back and write at TOS
.a6c3	92 34		sta ($34)			sta 	(basicStack)
.a6c5	60		rts				rts
.a6c6					_SOMemory:
.a6c6	a9 12		lda #$12		lda	#18
.a6c8	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.a6cb					StackClose:
.a6cb	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6cd	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6cf	0a		asl a				asl 	a 							; claim twice this.
.a6d0	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6d2	85 34		sta $34				sta 	basicStack
.a6d4	90 02		bcc $a6d8			bcc 	_SCExit
.a6d6	e6 35		inc $35				inc 	basicStack+1
.a6d8					_SCExit:
.a6d8	60		rts				rts
.a6d9					StackCheckFrame:
.a6d9	48		pha				pha
.a6da					_StackRemoveLocals:
.a6da	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6dc	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a6de	b0 05		bcs $a6e5			bcs 	_SCNoLocal
.a6e0	20 db 89	jsr $89db			jsr 	LocalPopValue 				; restore the local value
.a6e3	80 f5		bra $a6da			bra 	_StackRemoveLocals 			; gr round again
.a6e5					_SCNoLocal:
.a6e5	68		pla				pla 								; get the frame check.
.a6e6	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6e8	29 f0		and #$f0			and 	#$F0 						; check type bits
.a6ea	d0 01		bne $a6ed			bne 	_SCFError 					; different, we have structures mixed up
.a6ec	60		rts				rts
.a6ed					_SCFError:
.a6ed	8a		txa				txa 								; report error X
.a6ee	4c f7 8e	jmp $8ef7			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a6f1					STKSaveCodePosition:
.a6f1	5a		phy				phy
.a6f2	98		tya				tya 								; save Y
.a6f3	a0 05		ldy #$05			ldy 	#5
.a6f5	91 34		sta ($34),y			sta 	(basicStack),y
.a6f7	88		dey				dey 								; save Code Pointer
.a6f8					_STKSaveLoop:
.a6f8	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a6fb	91 34		sta ($34),y			sta 	(basicStack),y
.a6fd	88		dey				dey
.a6fe	d0 f8		bne $a6f8			bne 	_STKSaveLoop
.a700	7a		ply				ply
.a701	60		rts				rts
.a702					STKLoadCodePosition:
.a702	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a704					_STKLoadLoop:
.a704	b1 34		lda ($34),y			lda 	(basicStack),y
.a706	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a709	c8		iny				iny
.a70a	c0 05		cpy #$05			cpy 	#5
.a70c	d0 f6		bne $a704			bne 	_STKLoadLoop
.a70e	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a710	a8		tay				tay
.a711	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a712					StackReset:
.a712	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a714	85 34		sta $34				sta 	0+basicStack
.a716	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a718	85 35		sta $35				sta 	1+basicStack
.a71a	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a71c	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a71e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a71f					StringConcrete:
.a71f	5a		phy				phy 								; save position on stack
.a720	20 2c 9a	jsr $9a2c			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a723	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a725	85 38		sta $38				sta 	zTemp1
.a727	b5 60		lda $60,x			lda 	NSMantissa1,x
.a729	85 39		sta $39				sta 	zTemp1+1
.a72b	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a72d					_SALength:
.a72d	c8		iny				iny
.a72e	b1 38		lda ($38),y			lda 	(zTemp1),y
.a730	d0 fb		bne $a72d			bne 	_SALength
.a732	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a734	b0 3d		bcs $a773			bcs 	_SALengthError
.a736	98		tya				tya 				 				; length of the new string
.a737	18		clc				clc
.a738	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a73a	90 02		bcc $a73e			bcc 	_SAHaveLength
.a73c	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a73e					_SAHaveLength:
.a73e	48		pha				pha 								; save length.
.a73f	38		sec				sec
.a740	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a742	6d 0e 04	adc $040e			adc 	StringMemory
.a745	8d 0e 04	sta $040e			sta 	StringMemory
.a748	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a74a	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a74c	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a74e	6d 0f 04	adc $040f			adc 	StringMemory+1
.a751	8d 0f 04	sta $040f			sta 	StringMemory+1
.a754	85 3b		sta $3b				sta 	zTemp2+1
.a756	95 60		sta $60,x			sta 	NSMantissa1,x
.a758	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a759	38		sec				sec
.a75a	e9 03		sbc #$03			sbc 	#3
.a75c	92 3a		sta ($3a)			sta 	(zTemp2)
.a75e	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a760	a0 01		ldy #$01			ldy 	#1
.a762	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a764					_SACopyNewString:
.a764	a0 00		ldy #$00			ldy 	#0
.a766					_SACopyNSLoop:
.a766	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a768	c8		iny				iny 								; write two on in string storage
.a769	c8		iny				iny
.a76a	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a76c	88		dey				dey 								; this makes it one one.
.a76d	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a76f	d0 f5		bne $a766			bne 	_SACopyNSLoop
.a771	7a		ply				ply
.a772	60		rts				rts
.a773					_SALengthError:
.a773	a9 09		lda #$09		lda	#9
.a775	4c f7 8e	jmp $8ef7		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a778					StringSystemInitialise:
.a778	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a77a	8d 0e 04	sta $040e			sta 	0+StringMemory
.a77d	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a77f	8d 0f 04	sta $040f			sta 	1+StringMemory
.a782	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a785	60		rts				rts
.a786					StringSpaceInitialise:
.a786	20 2c 9a	jsr $9a2c			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a789	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a78b	8d 10 04	sta $0410			sta 	StringInitialised
.a78e	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a791	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a794	ad 0f 04	lda $040f			lda 	StringMemory+1
.a797	3a		dec a				dec 	a
.a798	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a79b	60		rts				rts
.a79c					StringTempAllocate:
.a79c	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a79e	b0 30		bcs $a7d0			bcs 	_STALength
.a7a0	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a7a3	30 05		bmi $a7aa			bmi 	_STAAllocate
.a7a5	48		pha				pha 								; save value to subtract.
.a7a6	20 86 a7	jsr $a786			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a7a9	68		pla				pla 								; restore it
.a7aa					_STAAllocate:
.a7aa	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a7ac	18		clc				clc  								; deliberate allows one more
.a7ad	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a7b0	8d 11 04	sta $0411			sta 	StringTempPointer
.a7b3	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a7b5	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a7b7	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a7ba	69 ff		adc #$ff			adc 	#$FF
.a7bc	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7bf	85 3d		sta $3d				sta 	zsTemp+1
.a7c1	95 60		sta $60,x			sta 	NSMantissa1,x
.a7c3	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a7c5	74 70		stz $70,x			stz 	NSMantissa3,x
.a7c7	a9 10		lda #$10			lda 	#NSTString
.a7c9	95 50		sta $50,x			sta 	NSStatus,x
.a7cb	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7cd	92 3c		sta ($3c)			sta 	(zsTemp)
.a7cf	60		rts				rts
.a7d0					_STALength:
.a7d0	a9 09		lda #$09		lda	#9
.a7d2	4c f7 8e	jmp $8ef7		jmp	ErrorHandler
.a7d5					StringTempWrite:
.a7d5	48		pha				pha
.a7d6	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a7d8	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a7da	d0 02		bne $a7de			bne 	_STWNoCarry
.a7dc	e6 3d		inc $3d				inc 	zsTemp+1
.a7de					_STWNoCarry:
.a7de	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a7e0	92 3c		sta ($3c)			sta 	(zsTemp)
.a7e2	68		pla				pla
.a7e3	60		rts				rts

;******  Return to file: _basic.asm

.a7e4					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7e4					Export_EXTPrintCharacter:
.a7e4					PAGEDPrintCharacter:
.a7e4	48		pha				pha
.a7e5	da		phx				phx
.a7e6	5a		phy				phy
.a7e7	a6 01		ldx $01				ldx 	1
.a7e9	da		phx				phx
.a7ea	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a7ed	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a7ef	30 48		bmi $a839			bmi 	_EXPCColour
.a7f1	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a7f3	90 4d		bcc $a842			bcc 	_EXPCControl
.a7f5	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a7f7	86 01		stx $01				stx 	1
.a7f9	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7fb	e6 01		inc $01				inc 	1 							; select colour memory
.a7fd	ad 6f 06	lda $066f			lda 	EXTTextColour
.a800	91 40		sta ($40),y			sta 	(EXTAddress),y
.a802	c8		iny				iny 								; advance horizontal position
.a803	8c 6e 06	sty $066e			sty 	EXTColumn
.a806	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; reached RHS ?
.a809	90 63		bcc $a86e			bcc 	_EXPCExit 					; no, then exit.
.a80b					_EXPCCRLF:
.a80b	ee 6d 06	inc $066d			inc 	EXTRow  					; bump row
.a80e	9c 6e 06	stz $066e			stz 	EXTColumn 					; back to column 0
.a811	ad 6d 06	lda $066d			lda 	EXTRow 						; check if reached the bottom ?
.a814	cd 71 06	cmp $0671			cmp 	EXTScreenHeight 			; if so, then scroll.
.a817	f0 18		beq $a831			beq 	_EXPCScroll
.a819	18		clc				clc 								; add width to address.
.a81a	a5 40		lda $40				lda 	EXTAddress
.a81c	6d 70 06	adc $0670			adc 	EXTScreenWidth
.a81f	85 40		sta $40				sta 	EXTAddress
.a821	90 4b		bcc $a86e			bcc 	_EXPCExit
.a823	e6 41		inc $41				inc 	EXTAddress+1
.a825	80 47		bra $a86e			bra 	_EXPCExit
.a827					_EXPCLeft:
.a827	ce 6e 06	dec $066e			dec 	EXTColumn
.a82a	10 42		bpl $a86e			bpl 	_EXPCExit
.a82c					_EXPCBegin:
.a82c	9c 6e 06	stz $066e			stz 	EXTColumn
.a82f	80 3d		bra $a86e			bra 	_EXPCExit
.a831					_EXPCScroll:
.a831	ce 6d 06	dec $066d			dec 	EXTRow 						; the height-1 th line.
.a834	20 1f a9	jsr $a91f			jsr 	EXTScreenScroll 			; scroll the screen
.a837	80 35		bra $a86e			bra 	_EXPCExit
.a839					_EXPCColour:
.a839	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a83b	b0 31		bcs $a86e			bcs 	_EXPCExit
.a83d	20 ff a8	jsr $a8ff			jsr 	_EXPCHandleColour
.a840	80 2c		bra $a86e			bra 	_EXPCExit
.a842					_EXPCControl:
.a842	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a844	b0 28		bcs $a86e			bcs 	_EXPCExit
.a846	0a		asl a				asl 	a 							; double into X
.a847	aa		tax				tax
.a848	7c dd a8	jmp ($a8dd,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a84b					_EXPCUp:
.a84b	ad 6d 06	lda $066d			lda 	EXTRow 						; already at top ?
.a84e	f0 1e		beq $a86e			beq 	_EXPCExit
.a850	ce 6d 06	dec $066d			dec 	EXTRow 						; up one in position/address
.a853	38		sec				sec
.a854	a5 40		lda $40				lda 	EXTAddress
.a856	ed 70 06	sbc $0670			sbc 	EXTScreenWidth
.a859	85 40		sta $40				sta 	EXTAddress
.a85b	b0 11		bcs $a86e			bcs 	_EXPCExit
.a85d	c6 41		dec $41				dec 	EXTAddress+1
.a85f	80 0d		bra $a86e			bra 	_EXPCExit
.a861					_EXPCRight:
.a861	c8		iny				iny
.a862	8c 6e 06	sty $066e			sty 	EXTColumn
.a865	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.a868	d0 04		bne $a86e			bne 	_EXPCExit
.a86a	88		dey				dey
.a86b					_EXPCSetColumnY:
.a86b	8c 6e 06	sty $066e			sty 	EXTColumn
.a86e					_EXPCExit:
.a86e	20 74 a9	jsr $a974			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a871	68		pla				pla
.a872	85 01		sta $01				sta 	1
.a874	7a		ply				ply
.a875	fa		plx				plx
.a876	68		pla				pla
.a877	60		rts				rts
.a878					_EXPCClearScreen:
.a878	20 31 a9	jsr $a931			jsr		EXTClearScreenCode
.a87b	80 f1		bra $a86e			bra 	_EXPCExit
.a87d					_EXPCDown:
.a87d	ad 71 06	lda $0671			lda 	EXTScreenHeight 			; at the bottom
.a880	3a		dec a				dec 	a
.a881	cd 6d 06	cmp $066d			cmp 	EXTRow
.a884	f0 e8		beq $a86e			beq 	_EXPCExit
.a886	ee 6d 06	inc $066d			inc 	EXTRow 						; down one in position/address
.a889	18		clc				clc
.a88a	a5 40		lda $40				lda 	EXTAddress
.a88c	6d 70 06	adc $0670			adc 	EXTScreenWidth
.a88f	85 40		sta $40				sta 	EXTAddress
.a891	90 db		bcc $a86e			bcc 	_EXPCExit
.a893	e6 41		inc $41				inc 	EXTAddress+1
.a895	80 d7		bra $a86e			bra 	_EXPCExit
.a897					_EXPCTab:
.a897	ad 6e 06	lda $066e			lda 	EXTColumn 					; next tab stop
.a89a	29 f8		and #$f8			and 	#$F8
.a89c	18		clc				clc
.a89d	69 08		adc #$08			adc 	#8
.a89f	8d 6e 06	sta $066e			sta 	EXTColumn
.a8a2	cd 70 06	cmp $0670			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a8a5	90 c7		bcc $a86e			bcc 	_EXPCExit
.a8a7	80 10		bra $a8b9			bra 	_EXPCEnd
.a8a9					_EXPCBackSpace:
.a8a9	88		dey				dey
.a8aa	30 c2		bmi $a86e			bmi 	_EXPCExit
.a8ac	ce 6e 06	dec $066e			dec 	EXTColumn
.a8af	a9 02		lda #$02			lda 	#2
.a8b1	85 01		sta $01				sta 	1
.a8b3	a9 20		lda #$20			lda 	#32
.a8b5	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8b7	80 b5		bra $a86e			bra 	_EXPCExit
.a8b9					_EXPCEnd:
.a8b9	a9 02		lda #$02			lda 	#2 							; access text screen
.a8bb	85 01		sta $01				sta 	1
.a8bd	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; point to last character
.a8c0	88		dey				dey
.a8c1					_EXPCEndSearch:
.a8c1	88		dey				dey 								; if past start, move to col 0.
.a8c2	30 06		bmi $a8ca			bmi 	_EXPCFound
.a8c4	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a8c6	c9 20		cmp #$20			cmp 	#' '
.a8c8	f0 f7		beq $a8c1			beq 	_EXPCEndSearch
.a8ca					_EXPCFound:
.a8ca	c8		iny				iny 								; move to following cell.
.a8cb	80 9e		bra $a86b			bra 	_EXPCSetColumnY
.a8cd					_EXPCClearEOL:
.a8cd	a9 02		lda #$02			lda 	#2 							; access character RAM
.a8cf	85 01		sta $01				sta 	1
.a8d1	a9 20		lda #$20			lda 	#' ' 						; write space
.a8d3	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8d5	c8		iny				iny
.a8d6	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; until RHS of screen.
.a8d9	90 f2		bcc $a8cd			bcc 	_EXPCClearEOL
.a8db	80 91		bra $a86e			bra 	_EXPCExit
.a8dd					_EXPCActionTable:
>a8dd	6e a8						.word 	_EXPCExit 					; 00
>a8df	2c a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8e1	27 a8						.word 	_EXPCLeft 					; 02 B Left
>a8e3	6e a8						.word 	_EXPCExit 					; 03 <Break>
>a8e5	6e a8						.word 	_EXPCExit 					; 04
>a8e7	b9 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a8e9	61 a8						.word 	_EXPCRight 					; 06 F Right
>a8eb	6e a8						.word 	_EXPCExit 					; 07
>a8ed	a9 a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a8ef	97 a8						.word 	_EXPCTab 					; 09 I Tab
>a8f1	6e a8						.word 	_EXPCExit 					; 0A
>a8f3	cd a8						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a8f5	78 a8						.word 	_EXPCClearScreen			; 0C L CLS
>a8f7	0b a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a8f9	7d a8						.word 	_EXPCDown 					; 0E N Down
>a8fb	6e a8						.word 	_EXPCExit 					; 0F
>a8fd	4b a8						.word 	_EXPCUp 					; 10 P Up
.a8ff					_EXPCHandleColour
.a8ff	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a901	b0 16		bcs $a919			bcs 	_EXPCBackground
.a903	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a904	0a		asl a				asl 	a
.a905	0a		asl a				asl 	a
.a906	0a		asl a				asl 	a
.a907	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a909					_EXPCUpdate:
.a909	48		pha				pha 								; save new colour
.a90a	8a		txa				txa 								; get mask
.a90b	2d 6f 06	and $066f			and 	EXTTextColour 				; mask out old.
.a90e	8d 6f 06	sta $066f			sta 	EXTTextColour
.a911	68		pla				pla 								; or in new colour
.a912	0d 6f 06	ora $066f			ora 	EXTTextColour
.a915	8d 6f 06	sta $066f			sta 	EXTTextColour
.a918	60		rts				rts
.a919					_EXPCBackground:
.a919	29 0f		and #$0f			and 	#$0F 						; get the colour
.a91b	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a91d	80 ea		bra $a909			bra 	_EXPCUpdate
.a91f					EXTScreenScroll:
.a91f	a9 02		lda #$02			lda 	#2 							; select text page
.a921	85 01		sta $01				sta 	1
.a923	a9 20		lda #$20			lda		#32 						; fill with space
.a925	20 38 aa	jsr $aa38			jsr 	EXTScrollFill
.a928	e6 01		inc $01				inc 	1 							; select colour page
.a92a	ad 6f 06	lda $066f			lda 	EXTTextColour
.a92d	20 38 aa	jsr $aa38			jsr 	EXTScrollFill
.a930	60		rts				rts
.a931					EXTClearScreenCode:
.a931	a9 02		lda #$02			lda 	#2 							; select text page
.a933	85 01		sta $01				sta 	1
.a935	a9 20		lda #$20			lda		#32 						; fill with space
.a937	20 44 a9	jsr $a944			jsr 	_EXTCSFill
.a93a	e6 01		inc $01				inc 	1 							; select colour page
.a93c	ad 6f 06	lda $066f			lda 	EXTTextColour
.a93f	20 44 a9	jsr $a944			jsr 	_EXTCSFill
.a942	80 22		bra $a966			bra 	EXTHomeCursor
.a944					_EXTCSFill:
.a944	aa		tax				tax
.a945	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a947	85 40		sta $40				sta 	EXTAddress
.a949	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a94b	85 41		sta $41				sta 	EXTAddress+1
.a94d					_EXTCSFill1:
.a94d	a0 00		ldy #$00			ldy 	#0
.a94f	8a		txa				txa
.a950					_EXTCSFill2:
.a950	91 40		sta ($40),y			sta 	(EXTAddress),y
.a952	c8		iny				iny
.a953	d0 fb		bne $a950			bne 	_EXTCSFill2
.a955	e6 41		inc $41				inc 	EXTAddress+1
.a957	a5 41		lda $41				lda 	EXTAddress+1
.a959	c9 d2		cmp #$d2			cmp 	#$D2
.a95b	d0 f0		bne $a94d			bne 	_EXTCSFill1
.a95d	8a		txa				txa
.a95e					_EXTCSFill3:
.a95e	91 40		sta ($40),y			sta 	(EXTAddress),y
.a960	c8		iny				iny
.a961	c0 c0		cpy #$c0			cpy 	#$C0
.a963	d0 f9		bne $a95e			bne 	_EXTCSFill3
.a965	60		rts				rts
.a966					EXTHomeCursor:
.a966	9c 6d 06	stz $066d			stz 	EXTRow 						; reset row & column
.a969	9c 6e 06	stz $066e			stz 	EXTColumn
.a96c	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a96e	85 40		sta $40				sta 	EXTAddress
.a970	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a972	85 41		sta $41				sta 	EXTAddress+1
.a974					EXTSetHardwareCursor:
.a974	64 01		stz $01				stz 	1 							; I/O Page zero
.a976	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a978	8d 10 d0	sta $d010			sta 	$D010
.a97b	a9 b1		lda #$b1			lda 	#$B1
.a97d	8d 12 d0	sta $d012			sta 	$D012
.a980	ad 6e 06	lda $066e			lda 	EXTColumn
.a983	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a986	9c 15 d0	stz $d015			stz 	$D015
.a989	ad 6d 06	lda $066d			lda 	EXTRow
.a98c	8d 16 d0	sta $d016			sta 	$D016
.a98f	9c 17 d0	stz $d017			stz 	$D017
.a992	60		rts				rts
.a993					Export_EXTInputLine:
.a993	48		pha				pha
.a994	da		phx				phx
.a995	5a		phy				phy
.a996	a5 01		lda $01				lda 	1 							; save I/O page
.a998	48		pha				pha
.a999					_EILLoop:
.a999	20 b3 aa	jsr $aab3			jsr 	PagedInputSingleCharacter
.a99c	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a99e	f0 44		beq $a9e4			beq 	_EILExit
.a9a0	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a9a2	f0 2a		beq $a9ce			beq 	_EILDelete
.a9a4	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a9a6	f0 1c		beq $a9c4			beq 	_EILBackspace
.a9a8	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a9aa	90 12		bcc $a9be			bcc 	_EILPrintLoop
.a9ac	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a9ae	b0 0e		bcs $a9be			bcs 	_EILPrintLoop
.a9b0	48		pha				pha 								; save character
.a9b1	a9 02		lda #$02			lda 	#2  						; insert a space
.a9b3	85 01		sta $01				sta 	1
.a9b5	20 26 aa	jsr $aa26			jsr 	EXTILInsert 				; insert in text screen
.a9b8	e6 01		inc $01				inc 	1
.a9ba	20 26 aa	jsr $aa26			jsr 	EXTILInsert 				; insert in colour screen
.a9bd	68		pla				pla 								; get character back.
.a9be					_EILPrintLoop:
.a9be	20 e4 a7	jsr $a7e4			jsr 	PagedPrintCharacter
.a9c1	80 d6		bra $a999			bra 	_EILLoop
.a9c3	60		rts				rts
.a9c4					_EILBackspace:
.a9c4	ad 6e 06	lda $066e			lda 	EXTColumn					; can we backspace ?
.a9c7	f0 d0		beq $a999			beq 	_EILLoop
.a9c9	a9 02		lda #$02			lda 	#2 							; move cursor left
.a9cb	20 e4 a7	jsr $a7e4			jsr 	PagedPrintCharacter
.a9ce					_EILDelete
.a9ce	a9 02		lda #$02			lda 	#2 							; text block
.a9d0	85 01		sta $01				sta 	1
.a9d2	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a9d4	20 11 aa	jsr $aa11			jsr 	EXTILDelete
.a9d7	e6 01		inc $01				inc 	1 							; colour block
.a9d9	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; get attribute of last character
.a9dc	88		dey				dey
.a9dd	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9df	20 11 aa	jsr $aa11			jsr 	EXTILDelete 				; backspace attribute
.a9e2	80 b5		bra $a999			bra 	_EILLoop 					; and go round.
.a9e4					_EILExit:
.a9e4	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a9e6	85 01		sta $01				sta 	1
.a9e8	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a9ea					_EILScrapeLine:
.a9ea	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9ec	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a9ef	c8		iny				iny
.a9f0	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.a9f3	d0 f5		bne $a9ea			bne 	_EILScrapeLine
.a9f5					_EILTrimSpaces:
.a9f5	88		dey				dey
.a9f6	f0 08		beq $aa00			beq 	_EILEndTrim
.a9f8	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.a9fb	c9 20		cmp #$20			cmp 	#' '
.a9fd	f0 f6		beq $a9f5			beq 	_EILTrimSpaces
.a9ff	c8		iny				iny 								; trim after non space character.
.aa00					_EILEndTrim:
.aa00	a9 00		lda #$00			lda 	#0 							; trim here.
.aa02	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa05	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa07	20 e4 a7	jsr $a7e4			jsr 	PagedPrintCharacter
.aa0a	68		pla				pla 								; reset I/O page
.aa0b	85 01		sta $01				sta 	1
.aa0d	7a		ply				ply
.aa0e	fa		plx				plx
.aa0f	68		pla				pla
.aa10	60		rts				rts
.aa11					EXTILDelete:
.aa11	48		pha				pha 								; save the new character
.aa12	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; start copying from here.
.aa15					_EXTDLoop:
.aa15	c8		iny				iny 								; copy one byte down.
.aa16	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa18	88		dey				dey
.aa19	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa1b	c8		iny				iny 								; do till end of line.
.aa1c	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.aa1f	90 f4		bcc $aa15			bcc 	_EXTDLoop
.aa21	88		dey				dey 	 							; write in last slot.
.aa22	68		pla				pla
.aa23	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa25	60		rts				rts
.aa26					EXTILInsert:
.aa26	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; end position
.aa29					_EXTILoop:
.aa29	88		dey				dey 								; back one
.aa2a	cc 6e 06	cpy $066e			cpy 	EXTColumn 					; exit if reached insert point.
.aa2d	f0 08		beq $aa37			beq 	_EXTIExit
.aa2f	88		dey				dey 								; copy one byte up.
.aa30	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa32	c8		iny				iny
.aa33	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa35	80 f2		bra $aa29			bra 	_EXTILoop
.aa37					_EXTIExit:
.aa37	60		rts				rts
.aa38					EXTScrollFill:
.aa38	aa		tax				tax									; save value to fill with
.aa39	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa3b	48		pha				pha
.aa3c	a5 37		lda $37				lda 	zTemp0+1
.aa3e	48		pha				pha
.aa3f	a5 38		lda $38				lda 	zTemp1
.aa41	48		pha				pha
.aa42	a5 39		lda $39				lda 	zTemp1+1
.aa44	48		pha				pha
.aa45	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa47	85 37		sta $37				sta 	zTemp0+1
.aa49	85 39		sta $39				sta 	zTemp1+1
.aa4b	64 36		stz $36				stz 	zTemp0
.aa4d	ad 70 06	lda $0670			lda 	EXTScreenWidth
.aa50	85 38		sta $38				sta 	zTemp1
.aa52	a0 00		ldy #$00			ldy 	#0
.aa54					_EXSFCopy1:
.aa54	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa56	91 36		sta ($36),y			sta 	(zTemp0),y
.aa58	c8		iny				iny
.aa59	d0 f9		bne $aa54			bne 	_EXSFCopy1
.aa5b	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa5d	e6 39		inc $39				inc 	zTemp1+1
.aa5f	a5 39		lda $39				lda 	zTemp1+1
.aa61	c9 d3		cmp #$d3			cmp 	#$D3
.aa63	d0 ef		bne $aa54			bne 	_EXSFCopy1
.aa65	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa68	8a		txa				txa
.aa69					_EXSFFill1:
.aa69	88		dey				dey
.aa6a	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa6c	c0 00		cpy #$00			cpy 	#0
.aa6e	10 f9		bpl $aa69			bpl 	_EXSFFill1
.aa70	68		pla				pla
.aa71	85 39		sta $39				sta 	zTemp1+1
.aa73	68		pla				pla
.aa74	85 38		sta $38				sta 	zTemp1
.aa76	68		pla				pla
.aa77	85 37		sta $37				sta 	zTemp0+1
.aa79	68		pla				pla
.aa7a	85 36		sta $36				sta 	zTemp0
.aa7c	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.066d					EXTRow:
>066d							.fill 	1
.066e					EXTColumn:
>066e							.fill 	1
.066f					EXTTextColour:
>066f							.fill 	1
.0670					EXTScreenWidth:
>0670							.fill 	1
.0671					EXTScreenHeight:
>0671							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa7d					Export_EXTInitialise:
.aa7d	64 01		stz $01				stz 	1 							; Access I/O page 0
.aa7f	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa82	9c 08 d0	stz $d008			stz 	$D008
.aa85	9c 09 d0	stz $d009			stz 	$D009
.aa88	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aa8a	8d 58 d6	sta $d658			sta 	$D658
.aa8d	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.aa8f	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.aa91	ad 00 c0	lda $c000			lda 	$C000
.aa94	8d 6f 06	sta $066f			sta 	EXTTextColour
.aa97	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aa99	8d 70 06	sta $0670			sta 	EXTScreenWidth
.aa9c	a9 3c		lda #$3c			lda 	#60
.aa9e	8d 71 06	sta $0671			sta 	EXTScreenHeight
.aaa1	20 66 a9	jsr $a966			jsr 	EXTHomeCursor 				; home cursor
.aaa4					_EXMoveDown:
.aaa4	a9 0d		lda #$0d			lda 	#13
.aaa6	20 e4 a7	jsr $a7e4			jsr 	PAGEDPrintCharacter
.aaa9	ad 6d 06	lda $066d			lda 	EXTRow
.aaac	c9 08		cmp #$08			cmp 	#8
.aaae	d0 f4		bne $aaa4			bne 	_EXMoveDown
.aab0	64 01		stz $01				stz 	1
.aab2	60		rts				rts
.aab3					Export_EXTInputSingleCharacter:
.aab3					PagedInputSingleCharacter:
.aab3	da		phx				phx
.aab4	5a		phy				phy
.aab5					_EISCWait:
.aab5	a5 01		lda $01				lda 	1 							; save I/O 0
.aab7	48		pha				pha
.aab8	64 01		stz $01				stz 	1 							; access I/O Page 0
.aaba	38		sec				sec 								; calculate timer - LastTick
.aabb	ad 59 d6	lda $d659			lda 	$D659
.aabe	aa		tax				tax 								; saving timer in X
.aabf	ed 5c 06	sbc $065c			sbc 	LastTick
.aac2	c9 03		cmp #$03			cmp 	#3
.aac4	90 06		bcc $aacc			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aac6	8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.aac9	20 8f be	jsr $be8f			jsr 	PagedSNDUpdate 							; go do the code.
.aacc					_NoFireTick:
.aacc	68		pla				pla 								; restore I/O 0
.aacd	85 01		sta $01				sta 	1
.aacf	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.aad2	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.aad4	f0 df		beq $aab5			beq 	_EISCWait
.aad6	7a		ply				ply
.aad7	fa		plx				plx
.aad8	60		rts				rts
.aad9					Export_EXTBreakCheck:
.aad9	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aadc					Export_EXTReadController:
.aadc	da		phx				phx
.aadd	a2 00		ldx #$00			ldx 	#0
.aadf	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aae1	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aae4	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aae6	f0 04		beq $aaec			beq 	_NoSet1
.aae8	8a		txa				txa
.aae9	09 01		ora #$01			ora 	#1
.aaeb	aa		tax				tax
.aaec					_NoSet1:
.aaec	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aaee	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaf1	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aaf3	f0 04		beq $aaf9			beq 	_NoSet1
.aaf5	8a		txa				txa
.aaf6	09 02		ora #$02			ora 	#2
.aaf8	aa		tax				tax
.aaf9					_NoSet1:
.aaf9	a9 06		lda #$06			lda 	#(($32) >> 3)
.aafb	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aafe	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab00	f0 04		beq $ab06			beq 	_NoSet1
.ab02	8a		txa				txa
.ab03	09 04		ora #$04			ora 	#4
.ab05	aa		tax				tax
.ab06					_NoSet1:
.ab06	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab08	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab0b	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab0d	f0 04		beq $ab13			beq 	_NoSet1
.ab0f	8a		txa				txa
.ab10	09 08		ora #$08			ora 	#8
.ab12	aa		tax				tax
.ab13					_NoSet1:
.ab13	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab15	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab18	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab1a	f0 04		beq $ab20			beq 	_NoSet1
.ab1c	8a		txa				txa
.ab1d	09 10		ora #$10			ora 	#16
.ab1f	aa		tax				tax
.ab20					_NoSet1:
.ab20	8a		txa				txa
.ab21	fa		plx				plx
.ab22	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ab23					GRVectorTable:
>ab23	72 ad					.word	GXInitialise             ; $00 Initialise
>ab25	8c ad					.word	GXControlBitmap          ; $01 BitmapCtl
>ab27	d4 ad					.word	GXControlSprite          ; $02 SpriteCtl
>ab29	24 ad					.word	GXClearBitmap            ; $03 Clear
>ab2b	63 af					.word	GXSetColourMode          ; $04 Colour
>ab2d	2b b1					.word	GXFontHandler            ; $05 DrawFont
>ab2f	73 b1					.word	GXSpriteHandler          ; $06 DrawSprite
>ab31	e4 b1					.word	GXSelect                 ; $07 SpriteUse
>ab33	0d b2					.word	GXSelectImage            ; $08 SpriteImage
>ab35	94 b3					.word	GXCollide                ; $09 SpriteCollide
>ab37	d6 ab					.word	GRUndefined              ; $0a
>ab39	d6 ab					.word	GRUndefined              ; $0b
>ab3b	d6 ab					.word	GRUndefined              ; $0c
>ab3d	d6 ab					.word	GRUndefined              ; $0d
>ab3f	d6 ab					.word	GRUndefined              ; $0e
>ab41	d6 ab					.word	GRUndefined              ; $0f
>ab43	d6 ab					.word	GRUndefined              ; $10
>ab45	d6 ab					.word	GRUndefined              ; $11
>ab47	d6 ab					.word	GRUndefined              ; $12
>ab49	d6 ab					.word	GRUndefined              ; $13
>ab4b	d6 ab					.word	GRUndefined              ; $14
>ab4d	d6 ab					.word	GRUndefined              ; $15
>ab4f	d6 ab					.word	GRUndefined              ; $16
>ab51	d6 ab					.word	GRUndefined              ; $17
>ab53	d6 ab					.word	GRUndefined              ; $18
>ab55	d6 ab					.word	GRUndefined              ; $19
>ab57	d6 ab					.word	GRUndefined              ; $1a
>ab59	d6 ab					.word	GRUndefined              ; $1b
>ab5b	d6 ab					.word	GRUndefined              ; $1c
>ab5d	d6 ab					.word	GRUndefined              ; $1d
>ab5f	d6 ab					.word	GRUndefined              ; $1e
>ab61	d6 ab					.word	GRUndefined              ; $1f
>ab63	d4 ab					.word	GXMove                   ; $20 Move
>ab65	31 ae					.word	GXLine                   ; $21 Line
>ab67	ac af					.word	GXFrameRectangle         ; $22 FrameRect
>ab69	a9 af					.word	GXFillRectangle          ; $23 FillRect
>ab6b	db ab					.word	GXFrameCircle            ; $24 FrameCircle
>ab6d	d7 ab					.word	GXFillCircle             ; $25 FillCircle
>ab6f	d6 ab					.word	GRUndefined              ; $26
>ab71	d6 ab					.word	GRUndefined              ; $27
>ab73	91 af					.word	GXPlotPoint              ; $28 Plot
>ab75	a3 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$627					gxPixelBuffer = numberBuffer
.0672					gxCurrentX:
>0672							.fill 	2
.0674					gxCurrentY:
>0674							.fill 	2
.0676					gxLastX:
>0676							.fill 	2
.0678					gxLastY:
>0678							.fill 	2
.067a					gxX0:
>067a							.fill 	2
.067c					gxY0:
>067c							.fill 	2
.067e					gxX1:
>067e							.fill 	2
.0680					gxY1:
>0680							.fill 	2
.0682					gxSpritesOn:
>0682							.fill 	1
.0683					gxBitmapsOn:
>0683							.fill 	1
.0684					gxBasePage:
>0684							.fill 	1
.0685					gxSpritePage:
>0685							.fill 	1
.0686					gxHeight:
>0686							.fill 	1
.0687					gxMode:
>0687							.fill 	1
.0688					gxColour:
>0688							.fill 	1
.0689					gxEORValue:
>0689							.fill 	1
.068a					gxANDValue:
>068a							.fill 	1
.068b					gxOriginalLUTValue:
>068b							.fill 	1
.068c					gsOffset:
>068c							.fill 	1
.068d					GSCurrentSpriteID:
>068d							.fill 	1
.068e					GSCurrentSpriteAddr:
>068e							.fill 	2
.0690					GXSpriteOffsetBase:
>0690							.fill 	2
.0692					GXSpriteLow:
>0692							.fill 	64
.06d2					GXSpriteHigh:
>06d2							.fill 	64
.ab77					Export_GXGraphicDraw:
.ab77	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab79	b0 06		bcs $ab81			bcs 	_GDCoordinate
.ab7b	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab7d	84 37		sty $37				sty 	gxzTemp0+1
.ab7f	80 4b		bra $abcc			bra 	_GDExecuteA 				; and execute
.ab81					_GDCoordinate:
.ab81	48		pha				pha 								; save AXY
.ab82	da		phx				phx
.ab83	5a		phy				phy
.ab84	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab86					_GDCopy1:
.ab86	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.ab89	9d 76 06	sta $0676,x			sta 	gxLastX,x
.ab8c	ca		dex				dex
.ab8d	10 f7		bpl $ab86			bpl 	_GDCopy1
.ab8f	68		pla				pla 								; update Y
.ab90	8d 74 06	sta $0674			sta 	gxCurrentY
.ab93	9c 75 06	stz $0675			stz 	gxCurrentY+1
.ab96	68		pla				pla
.ab97	8d 72 06	sta $0672			sta 	gxCurrentX
.ab9a	68		pla				pla 								; get A (command+X.1) back
.ab9b	48		pha				pha
.ab9c	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.ab9e	8d 73 06	sta $0673			sta 	gxCurrentX+1
.aba1	68		pla				pla 								; get command back
.aba2	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aba4	48		pha				pha 								; push back.
.aba5	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aba7	f0 17		beq $abc0			beq 	_GDCopyToWorkArea
.aba9	ad 73 06	lda $0673			lda 	gxCurrentX+1 				; X < 256 X okay
.abac	f0 07		beq $abb5			beq 	_GDCheckY
.abae	ad 72 06	lda $0672			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abb1	c9 40		cmp #$40			cmp 	#64
.abb3	b0 08		bcs $abbd			bcs 	_GDError1
.abb5					_GDCheckY:
.abb5	ad 74 06	lda $0674			lda 	gxCurrentY 					; check Y < Height.
.abb8	cd 86 06	cmp $0686			cmp 	gxHeight
.abbb	90 03		bcc $abc0			bcc 	_GDCopyToWorkArea
.abbd					_GDError1:
.abbd	68		pla				pla
.abbe					_GDError2:
.abbe	38		sec				sec
.abbf	60		rts				rts
.abc0					_GDCopyToWorkArea:
.abc0	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abc2					_GDCopy2:
.abc2	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.abc5	9d 7a 06	sta $067a,x			sta 	gxX0,x
.abc8	ca		dex				dex
.abc9	10 f7		bpl $abc2			bpl 	_GDCopy2
.abcb	68		pla				pla 								; get command
.abcc					_GDExecuteA:
.abcc	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abce	b0 ee		bcs $abbe			bcs 	_GDError2
.abd0	aa		tax				tax
.abd1	7c 23 ab	jmp ($ab23,x)			jmp 	(GRVectorTable,x)
.abd4					GXMove:
.abd4	18		clc				clc
.abd5	60		rts				rts
.abd6					GRUndefined:
>abd6	db						.byte 	$DB 						; causes a break in the emulator
.abd7					GXFillCircle:
.abd7	a9 ff		lda #$ff			lda 	#255
.abd9	80 02		bra $abdd			bra 	GXCircle
.abdb					GXFrameCircle:
.abdb	a9 00		lda #$00			lda 	#0
.abdd					GXCircle:
.abdd	8d 15 07	sta $0715			sta 	gxIsFillMode					; save Fill flag
.abe0	ad 83 06	lda $0683			lda 	gxBitmapsOn
.abe3	f0 26		beq $ac0b			beq 	_GXCFail
.abe5	20 3b b4	jsr $b43b			jsr 	GXSortXY 					; topleft/bottomright
.abe8	20 13 b3	jsr $b313			jsr 	GXOpenBitmap 				; start drawing
.abeb	20 dd ac	jsr $acdd			jsr 	GXCircleSetup 				; set up for drawing
.abee	9c 16 07	stz $0716			stz 	gxYChanged
.abf1					_GXCircleDraw:
.abf1	ad 13 07	lda $0713			lda 	gXCentre					; while x <= y
.abf4	cd 14 07	cmp $0714			cmp 	gYCentre
.abf7	90 0a		bcc $ac03			bcc 	_GXCircleContinue
.abf9	d0 03		bne $abfe			bne 	_GXNoLast
.abfb	20 10 ac	jsr $ac10			jsr 	GXPlot1
.abfe					_GXNoLast:
.abfe	20 1b b3	jsr $b31b			jsr 	GXCloseBitmap 				; close the bitmap
.ac01	18		clc				clc
.ac02	60		rts				rts
.ac03					_GXCircleContinue:
.ac03	20 0d ac	jsr $ac0d			jsr 	GXPlot2 					; draw it
.ac06	20 8a ac	jsr $ac8a			jsr 	GXCircleMove 				; adjust the coordinates
.ac09	80 e6		bra $abf1			bra 	_GXCircleDraw
.ac0b					_GXCFail:
.ac0b	38		sec				sec
.ac0c	60		rts				rts
.ac0d					GXPlot2:
.ac0d	20 10 ac	jsr $ac10			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac10					GXPlot1:
.ac10	ad 14 07	lda $0714			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac13	f0 03		beq $ac18			beq 	_GXPlot1Only
.ac15	20 34 ac	jsr $ac34			jsr 	GXPlot0 						; plot and negate
.ac18					_GXPlot1Only:
.ac18	20 34 ac	jsr $ac34			jsr 	GXPlot0 						; twice, undoing negation
.ac1b	ad 13 07	lda $0713			lda 	gXCentre 						; swap X and Y
.ac1e	ae 14 07	ldx $0714			ldx	 	gYCentre
.ac21	8d 14 07	sta $0714			sta 	gYCentre
.ac24	8e 13 07	stx $0713			stx 	gXCentre
.ac27	ad 16 07	lda $0716			lda 	gxYChanged 						; toggle Y Changed flag
.ac2a	a9 ff		lda #$ff			lda 	#$FF
.ac2c	8d 16 07	sta $0716			sta 	gxYChanged
.ac2f	60		rts				rts
.ac30	20 34 ac	jsr $ac34			jsr 	GXPlot0 						; do once
.ac33	60		rts				rts
.ac34	ad 15 07	lda $0715	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac37	f0 05		beq $ac3e			beq 	_GXPlot0Always
.ac39	ad 16 07	lda $0716			lda 	gxYChanged						; fill mode, only draw if changed.
.ac3c	f0 2d		beq $ac6b			beq 	GXPlot0Exit
.ac3e					_GXPlot0Always:
.ac3e	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac40	ad 14 07	lda $0714			lda 	gYCentre
.ac43	20 6c ac	jsr $ac6c			jsr 	GXSubCopy
.ac46	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac48	ad 13 07	lda $0713			lda 	gXCentre
.ac4b	20 6c ac	jsr $ac6c			jsr 	GXSubCopy
.ac4e	48		pha				pha 									; save last offset X
.ac4f	20 23 b3	jsr $b323			jsr 	GXPositionCalc 					; calculate position/offset.
.ac52	68		pla				pla
.ac53	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac54	85 36		sta $36				sta 	gxzTemp0
.ac56	64 37		stz $37				stz 	gxzTemp0+1
.ac58	26 37		rol $37				rol 	gxzTemp0+1
.ac5a	ad 15 07	lda $0715			lda 	gxIsFillMode
.ac5d	69 80		adc #$80			adc 	#128
.ac5f	20 fc af	jsr $affc			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac62	38		sec				sec 									; GY = -GY
.ac63	a9 00		lda #$00			lda 	#0
.ac65	ed 14 07	sbc $0714			sbc 	gYCentre
.ac68	8d 14 07	sta $0714			sta 	gYCentre
.ac6b					GXPlot0Exit:
.ac6b	60		rts				rts
.ac6c					GXSubCopy:
.ac6c	85 36		sta $36				sta 	gxzTemp0
.ac6e	64 37		stz $37				stz 	gxzTemp0+1
.ac70	29 80		and #$80			and 	#$80
.ac72	f0 02		beq $ac76			beq 	_GXNoSx
.ac74	c6 37		dec $37				dec 	gxzTemp0+1
.ac76					_GXNoSx:
.ac76	38		sec				sec
.ac77	bd 7e 06	lda $067e,x			lda 	gXX1,x
.ac7a	e5 36		sbc $36				sbc 	gxzTemp0
.ac7c	9d 7a 06	sta $067a,x			sta 	gXX0,x
.ac7f	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.ac82	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac84	9d 7b 06	sta $067b,x			sta 	gXX0+1,x
.ac87	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ac89	60		rts				rts
.ac8a					GXCircleMove:
.ac8a	9c 16 07	stz $0716			stz 	gxYChanged 					; clear Y changed flag
.ac8d	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.ac8f	10 0d		bpl $ac9e			bpl 	_GXEMPositive
.ac91	ee 13 07	inc $0713			inc 	gXCentre 					; X++
.ac94	ad 13 07	lda $0713			lda 	gXCentre
.ac97	20 bd ac	jsr $acbd			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.ac9a	a9 06		lda #$06			lda 	#6  						; and add 6
.ac9c	80 15		bra $acb3			bra 	_GXEMAddD
.ac9e					_GXEMPositive:
.ac9e	ee 13 07	inc $0713			inc 	gXCentre					; X++
.aca1	ce 14 07	dec $0714			dec 	gyCentre 					; Y--
.aca4	38		sec				sec 								; calculate X-Y
.aca5	ad 13 07	lda $0713			lda 	gXCentre
.aca8	ed 14 07	sbc $0714			sbc 	gYCentre
.acab	20 bd ac	jsr $acbd			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acae	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acb0	ce 16 07	dec $0716			dec 	gxYChanged
.acb3					_GXEMAddD:
.acb3	18		clc				clc
.acb4	65 38		adc $38				adc 	gxzTemp1
.acb6	85 38		sta $38				sta 	gxzTemp1
.acb8	90 02		bcc $acbc			bcc 	_GXEMNoCarry
.acba	e6 39		inc $39				inc 	gxzTemp1+1
.acbc					_GXEMNoCarry:
.acbc	60		rts				rts
.acbd					_GXAdd4TimesToD:
.acbd	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acbf	29 80		and #$80			and 	#$80
.acc1	f0 02		beq $acc5			beq 	_GXA4Unsigned
.acc3	a9 ff		lda #$ff			lda 	#$FF
.acc5					_GXA4Unsigned:
.acc5	85 37		sta $37				sta 	gxzTemp0+1
.acc7	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acc9	26 37		rol $37				rol 	gxzTemp0+1
.accb	06 36		asl $36				asl 	gxzTemp0
.accd	26 37		rol $37				rol 	gxzTemp0+1
.accf	18		clc				clc 								; add
.acd0	a5 36		lda $36				lda		gxzTemp0
.acd2	65 38		adc $38				adc 	gxzTemp1
.acd4	85 38		sta $38				sta 	gxzTemp1
.acd6	a5 37		lda $37				lda		gxzTemp0+1
.acd8	65 39		adc $39				adc 	gxzTemp1+1
.acda	85 39		sta $39				sta 	gxzTemp1+1
.acdc	60		rts				rts
.acdd					GXCircleSetup:
.acdd	38		sec				sec
.acde	ad 80 06	lda $0680			lda 	gxY1
.ace1	ed 7c 06	sbc $067c			sbc 	gxY0
.ace4	4a		lsr a				lsr 	a
.ace5	8d 12 07	sta $0712			sta 	gxRadius
.ace8	a2 00		ldx #$00			ldx 	#0
.acea	20 0c ad	jsr $ad0c			jsr 	_GXCalculateCentre
.aced	a2 02		ldx #$02			ldx 	#2
.acef	20 0c ad	jsr $ad0c			jsr 	_GXCalculateCentre
.acf2	9c 13 07	stz $0713			stz 	gXCentre
.acf5	ad 12 07	lda $0712			lda 	gxRadius
.acf8	8d 14 07	sta $0714			sta 	gYCentre
.acfb	0a		asl a				asl 	a 							; R x 2
.acfc	85 36		sta $36				sta 	gxzTemp0
.acfe	38		sec				sec
.acff	a9 03		lda #$03			lda 	#3
.ad01	e5 36		sbc $36				sbc 	gxzTemp0
.ad03	85 38		sta $38				sta 	gxzTemp1
.ad05	a9 00		lda #$00			lda 	#0
.ad07	e9 00		sbc #$00			sbc 	#0
.ad09	85 39		sta $39				sta 	gxzTemp1+1
.ad0b	60		rts				rts
.ad0c					_GXCalculateCentre:
.ad0c	38		sec				sec
.ad0d	bd 7e 06	lda $067e,x			lda 	gxX1,x
.ad10	7d 7a 06	adc $067a,x			adc 	gXX0,x
.ad13	9d 7e 06	sta $067e,x			sta 	gXX1,x
.ad16	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.ad19	7d 7b 06	adc $067b,x			adc 	gXX0+1,x
.ad1c	4a		lsr a				lsr 	a
.ad1d	9d 7f 06	sta $067f,x			sta 	gXX1+1,x
.ad20	7e 7e 06	ror $067e,x			ror 	gXX1,x
.ad23	60		rts				rts
.0712					gxRadius:
>0712							.fill 	1
.0713					gXCentre:
>0713							.fill 	1
.0714					gYCentre:
>0714							.fill 	1
.0715					gxIsFillMode:
>0715							.fill 	1
.0716					gxYChanged:
>0716							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad24					GXClearBitmap:
.ad24	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP running.
.ad27	f0 24		beq $ad4d			beq 	_GXCBFail
.ad29	20 13 b3	jsr $b313			jsr 	GXOpenBitmap 				; start access
.ad2c	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad2e	ad 86 06	lda $0686			lda 	gxHeight
.ad31	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad33	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad35					_GXCalcLastPage:
.ad35	98		tya				tya 								; add to base page
.ad36	18		clc				clc
.ad37	6d 84 06	adc $0684			adc 	gxBasePage
.ad3a	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad3c					_GXClearAll:
.ad3c	20 4f ad	jsr $ad4f			jsr 	_GXClearBlock 				; clear 8k block
.ad3f	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad41	a5 0b		lda $0b				lda 	GXEditSlot
.ad43	cd 84 06	cmp $0684			cmp 	gxBasePage 					; until before base page
.ad46	b0 f4		bcs $ad3c			bcs 	_GXClearAll
.ad48	20 1b b3	jsr $b31b			jsr 	GXCloseBitmap	 			; stop access
.ad4b	18		clc				clc
.ad4c	60		rts				rts
.ad4d					_GXCBFail:
.ad4d	38		sec				sec
.ad4e	60		rts				rts
.ad4f					_GXClearBlock:
.ad4f	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad51	85 38		sta $38				sta 	0+gxzTemp1
.ad53	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad55	85 39		sta $39				sta 	1+gxzTemp1
.ad57					_GXCB0:
.ad57	a5 36		lda $36				lda 	gxzTemp0
.ad59	a0 00		ldy #$00			ldy 	#0
.ad5b					_GXCB1:
.ad5b	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad5d	c8		iny				iny
.ad5e	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad60	c8		iny				iny
.ad61	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad63	c8		iny				iny
.ad64	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad66	c8		iny				iny
.ad67	d0 f2		bne $ad5b			bne 	_GXCB1
.ad69	e6 39		inc $39				inc 	gxzTemp1+1
.ad6b	a5 39		lda $39				lda 	gxzTemp1+1
.ad6d	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad6f	d0 e6		bne $ad57			bne 	_GXCB0
.ad71	60		rts				rts
.ad72					GXInitialise:
.ad72	64 01		stz $01				stz 	1
.ad74	a9 01		lda #$01			lda 	#1
.ad76	8d 00 d0	sta $d000			sta 	$D000
.ad79	18		clc				clc
.ad7a	9c 82 06	stz $0682			stz 	GXSpritesOn
.ad7d	9c 83 06	stz $0683			stz 	GXBitmapsOn
.ad80	a2 0f		ldx #$0f			ldx 	#15
.ad82					_GXIClear:
.ad82	9e 72 06	stz $0672,x			stz 	gxCurrentX,x
.ad85	ca		dex				dex
.ad86	10 fa		bpl $ad82			bpl 	_GXIClear
.ad88	20 23 ae	jsr $ae23			jsr 	GXClearSpriteStore
.ad8b	60		rts				rts
.ad8c					GXControlBitmap:
.ad8c	64 01		stz $01				stz 	1
.ad8e	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad90	29 01		and #$01			and 	#1 							; set bitmap flag
.ad92	8d 83 06	sta $0683			sta 	gxBitmapsOn
.ad95	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad96	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad99	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad9b	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ad9d	90 02		bcc $ada1			bcc 	_CBNotOn
.ad9f	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.ada1					_CBNotOn:
.ada1	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ada4	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ada6	29 07		and #$07			and 	#7
.ada8	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adab	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adad	d0 02		bne $adb1			bne 	_CBNotDefault
.adaf	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adb1					_CBNotDefault:
.adb1	8d 84 06	sta $0684			sta 	gxBasePage
.adb4	20 15 ae	jsr $ae15			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adb7	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.adb9	8d 03 d1	sta $d103			sta 	$D103
.adbc	a5 36		lda $36				lda 	gxzTemp0
.adbe	8d 02 d1	sta $d102			sta 	$D102
.adc1	9c 01 d1	stz $d101			stz 	$D101
.adc4	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.adc6	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.adc9	29 01		and #$01			and 	#1
.adcb	f0 02		beq $adcf			beq 	_CBHaveHeight
.adcd	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.adcf					_CBHaveHeight
.adcf	8e 86 06	stx $0686			stx 	gxHeight
.add2	18		clc				clc
.add3	60		rts				rts
.add4					GXControlSprite:
.add4	64 01		stz $01				stz 	1
.add6	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.add8	29 01		and #$01			and 	#1 							; set sprites flag
.adda	8d 82 06	sta $0682			sta 	gxSpritesOn
.addd	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adde	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ade1	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ade3	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ade5	90 02		bcc $ade9			bcc 	_CSNotOn
.ade7	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ade9					_CSNotOn:
.ade9	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adec	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adee	d0 02		bne $adf2			bne 	_CSNotDefault
.adf0	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.adf2					_CSNotDefault:
.adf2	8d 85 06	sta $0685			sta 	gxSpritePage
.adf5	20 15 ae	jsr $ae15			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adf8	a5 36		lda $36				lda 	zTemp0
.adfa	8d 90 06	sta $0690			sta 	GXSpriteOffsetBase
.adfd	a5 37		lda $37				lda 	zTemp0+1
.adff	8d 91 06	sta $0691			sta 	GXSpriteOffsetBase+1
.ae02	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae04					_CSClear:
.ae04	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae07	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae0a	ca		dex				dex
.ae0b	d0 f7		bne $ae04			bne 	_CSClear
.ae0d	9c 8f 06	stz $068f			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae10	20 23 ae	jsr $ae23			jsr 	GXClearSpriteStore
.ae13	18		clc				clc
.ae14	60		rts				rts
.ae15					GXCalculateBaseAddress:
.ae15	85 36		sta $36				sta 	gxzTemp0
.ae17	64 37		stz $37				stz 	gxzTemp0+1
.ae19	a9 05		lda #$05			lda 	#5
.ae1b					_GXShift:
.ae1b	06 36		asl $36				asl 	gxzTemp0
.ae1d	26 37		rol $37				rol 	gxzTemp0+1
.ae1f	3a		dec a				dec		a
.ae20	d0 f9		bne $ae1b			bne 	_GXShift
.ae22	60		rts				rts
.ae23					GXClearSpriteStore:
.ae23	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae25					_GXCSSLoop:
.ae25	9e d2 06	stz $06d2,x			stz 	GXSpriteHigh,x
.ae28	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae2a	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.ae2d	ca		dex				dex
.ae2e	10 f5		bpl $ae25			bpl 	_GXCSSLoop
.ae30	60		rts				rts
.ae31					GXLine:
.ae31	ad 83 06	lda $0683			lda 	GXBitmapsOn
.ae34	f0 28		beq $ae5e			beq 	_GXLFail
.ae36	20 13 b3	jsr $b313			jsr 	GXOpenBitmap
.ae39	20 59 b4	jsr $b459			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae3c	20 04 af	jsr $af04			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae3f	20 23 b3	jsr $b323			jsr 	GXPositionCalc 				; calculate position/offset.
.ae42					_GXDrawLoop:
.ae42	ac 8c 06	ldy $068c			ldy 	gsOffset 					; draw the pixel
.ae45	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae47	2d 8a 06	and $068a			and 	gxANDValue
.ae4a	4d 89 06	eor $0689			eor 	gxEORValue
.ae4d	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae4f	20 60 ae	jsr $ae60			jsr 	GXLineIsComplete 			; is the line complete ?
.ae52	f0 05		beq $ae59			beq 	_GXLExit
.ae54	20 7b ae	jsr $ae7b			jsr 	GXLineAdvance 				; code as per advance method
.ae57	80 e9		bra $ae42			bra 	_GXDrawLoop
.ae59					_GXLExit:
.ae59	20 1b b3	jsr $b31b			jsr 	GXCloseBitmap
.ae5c	18		clc				clc
.ae5d	60		rts				rts
.ae5e					_GXLFail:
.ae5e	38		sec				sec
.ae5f	60		rts				rts
.ae60					GXLineIsComplete:
.ae60	ad 19 07	lda $0719			lda 	GXIsDiffYLarger 			; is dy larger
.ae63	d0 0f		bne $ae74			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae65	ad 7a 06	lda $067a			lda 	GXX0 						; compare X, LSB and MSB
.ae68	4d 7e 06	eor $067e			eor 	GXX1
.ae6b	d0 06		bne $ae73			bne 	_GXLICExit
.ae6d	ad 7b 06	lda $067b			lda 	GXX0+1
.ae70	4d 7f 06	eor $067f			eor 	GXX1+1
.ae73					_GXLICExit:
.ae73	60		rts				rts
.ae74					_GXLICCompareY:
.ae74	ad 80 06	lda $0680			lda 	GXY1
.ae77	4d 7c 06	eor $067c			eor 	GXY0
.ae7a	60		rts				rts
.ae7b					GXLineAdvance:
.ae7b	18		clc				clc 								; add adjust to position
.ae7c	ad 1b 07	lda $071b			lda 	GXPosition
.ae7f	6d 1c 07	adc $071c			adc 	GXAdjust
.ae82	8d 1b 07	sta $071b			sta 	GXPosition
.ae85	9c 1e 07	stz $071e			stz 	GXAddSelect 				; clear add select flag
.ae88	b0 05		bcs $ae8f			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ae8a	cd 1d 07	cmp $071d			cmp 	GXTotal 					; if exceeded total
.ae8d	90 0a		bcc $ae99			bcc 	_GXLANoExtra
.ae8f					_GXLAOverflow:
.ae8f	ce 1e 07	dec $071e			dec 	GXAddSelect 				; set addselect to $FF
.ae92	38		sec				sec 								; subtract total and write back
.ae93	ed 1d 07	sbc $071d			sbc 	GXTotal
.ae96	8d 1b 07	sta $071b			sta 	GXPosition
.ae99					_GXLANoExtra:
.ae99	ad 19 07	lda $0719			lda 	GXIsDiffYLarger
.ae9c	f0 0d		beq $aeab			beq 	_GXDXLarger
.ae9e	20 fd ae	jsr $aefd			jsr 	GXIncrementY
.aea1	ad 1e 07	lda $071e			lda 	GXAddSelect
.aea4	f0 10		beq $aeb6			beq 	_GXLAExit
.aea6	20 b7 ae	jsr $aeb7			jsr 	GXAdjustX
.aea9	80 0b		bra $aeb6			bra 	_GXLAExit
.aeab					_GXDXLarger:
.aeab	20 b7 ae	jsr $aeb7			jsr 	GXAdjustX
.aeae	ad 1e 07	lda $071e			lda 	GXAddSelect
.aeb1	f0 03		beq $aeb6			beq 	_GXLAExit
.aeb3	20 fd ae	jsr $aefd			jsr 	GXIncrementY
.aeb6					_GXLAExit:
.aeb6	60		rts				rts
.aeb7					GXAdjustX:
.aeb7	ad 1a 07	lda $071a			lda 	GXDXNegative
.aeba	10 25		bpl $aee1			bpl 	_GXAXRight
.aebc	ad 7a 06	lda $067a			lda 	GXX0
.aebf	d0 03		bne $aec4			bne 	_GXAXNoBorrow
.aec1	ce 7b 06	dec $067b			dec 	GXX0+1
.aec4					_GXAXNoBorrow:
.aec4	ce 7a 06	dec $067a			dec 	GXX0
.aec7	ce 8c 06	dec $068c			dec 	gsOffset 					; pixel left
.aeca	ad 8c 06	lda $068c			lda 	gsOffset
.aecd	c9 ff		cmp #$ff			cmp 	#$FF
.aecf	d0 0f		bne $aee0			bne 	_GXAYExit 					; underflow
.aed1	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aed3	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aed5	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aed7	b0 07		bcs $aee0			bcs 	_GXAYExit
.aed9	18		clc				clc
.aeda	69 20		adc #$20			adc 	#$20 						; fix up
.aedc	85 3d		sta $3d				sta 	gxzScreen+1
.aede	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aee0					_GXAYExit:
.aee0	60		rts				rts
.aee1					_GXAXRight:
.aee1	ee 7a 06	inc $067a			inc 	GXX0
.aee4	d0 03		bne $aee9			bne 	_GXAXNoCarry
.aee6	ee 7b 06	inc $067b			inc 	GXX0+1
.aee9					_GXAXNoCarry:
.aee9	ee 8c 06	inc $068c			inc 	gsOffset 					; pixel right
.aeec	d0 0e		bne $aefc			bne 	_GXAXExit 					; if not overflowed, exit.
.aeee	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.aef0	a5 3d		lda $3d				lda 	gxzScreen+1
.aef2	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.aef4	90 06		bcc $aefc			bcc 	_GXAXExit
.aef6	e9 20		sbc #$20			sbc 	#$20 						; fix up
.aef8	85 3d		sta $3d				sta 	gxzScreen+1
.aefa	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.aefc					_GXAXExit:
.aefc	60		rts				rts
.aefd					GXIncrementY:
.aefd	ee 7c 06	inc $067c			inc 	GXY0
.af00	20 79 b3	jsr $b379			jsr 	GXMovePositionDown
.af03	60		rts				rts
.af04					GXLineSetup:
.af04	ad 80 06	lda $0680			lda 	GXY1
.af07	38		sec				sec
.af08	ed 7c 06	sbc $067c			sbc 	GXY0
.af0b	4a		lsr a				lsr 	a
.af0c	8d 18 07	sta $0718			sta 	GXDiffY
.af0f	9c 1a 07	stz $071a			stz 	GXDXNegative 				; clear -ve flag
.af12	38		sec				sec
.af13	ad 7e 06	lda $067e			lda 	GXX1
.af16	ed 7a 06	sbc $067a			sbc 	GXX0
.af19	8d 17 07	sta $0717			sta 	GXDiffX
.af1c	ad 7f 06	lda $067f			lda 	GXX1+1 						; calculate MSB
.af1f	ed 7b 06	sbc $067b			sbc 	GXX0+1
.af22	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af23	6e 17 07	ror $0717			ror 	GXDiffX
.af26	0a		asl a				asl 	a
.af27	10 0c		bpl $af35			bpl 	_GDXNotNegative
.af29	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af2b	38		sec				sec
.af2c	ed 17 07	sbc $0717			sbc 	GXDiffX
.af2f	8d 17 07	sta $0717			sta 	GXDiffX
.af32	ce 1a 07	dec $071a			dec 	GXDXNegative 				; -ve flag = $FF.
.af35					_GDXNotNegative:
.af35	9c 19 07	stz $0719			stz 	GXIsDiffYLarger 			; clear larger flag
.af38	ad 18 07	lda $0718			lda 	GXDiffY 					; set adjust and total.
.af3b	8d 1c 07	sta $071c			sta 	GXAdjust
.af3e	ad 17 07	lda $0717			lda 	GXDiffX
.af41	8d 1d 07	sta $071d			sta 	GXTotal
.af44	ad 18 07	lda $0718			lda 	GXDiffY 					; if dy > dx
.af47	cd 17 07	cmp $0717			cmp 	GXDiffX
.af4a	90 0f		bcc $af5b			bcc 	_GDXNotLarger
.af4c	ce 19 07	dec $0719			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af4f	ad 17 07	lda $0717			lda 	GXDiffX 					; set adjust and total other way round
.af52	8d 1c 07	sta $071c			sta 	GXAdjust
.af55	ad 18 07	lda $0718			lda 	GXDiffY
.af58	8d 1d 07	sta $071d			sta 	GXTotal
.af5b					_GDXNotLarger:
.af5b	ad 1d 07	lda $071d			lda 	GXTotal
.af5e	4a		lsr a				lsr 	a
.af5f	8d 1b 07	sta $071b			sta 	GXPosition
.af62	60		rts				rts
.0717					GXDiffX:
>0717							.fill 	1
.0718					GXDiffY:
>0718							.fill 	1
.0719					GXIsDiffYLarger:
>0719							.fill 	1
.071a					GXDXNegative:
>071a							.fill 	1
.071b					GXPosition:
>071b							.fill 	1
.071c					GXAdjust:
>071c							.fill 	1
.071d					GXTotal:
>071d							.fill 	1
.071e					GXAddSelect:
>071e							.fill 	1
.af63					GXSetColourMode:
.af63	a6 36		ldx $36				ldx 	gxzTemp0
.af65	8e 88 06	stx $0688			stx 	gxColour 								; set colour
.af68	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af6a	8d 87 06	sta $0687			sta 	gxMode 									; set mode
.af6d	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af6f	9c 8a 06	stz $068a			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af72	ae 88 06	ldx $0688			ldx 	gxColour
.af75	8e 89 06	stx $0689			stx 	gxEORValue
.af78	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af7a	90 03		bcc $af7f			bcc 	_GXSDCNotAndColour
.af7c	8e 8a 06	stx $068a			stx 	gxANDValue
.af7f					_GXSDCNotAndColour:
.af7f	d0 03		bne $af84			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af81	9c 89 06	stz $0689			stz 	gxEORValue
.af84					_GXSDCNotAnd:
.af84	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af85	90 08		bcc $af8f			bcc 	_GXSDCNoFlip
.af87	ad 8a 06	lda $068a			lda	 	gxANDValue
.af8a	49 ff		eor #$ff			eor 	#$FF
.af8c	8d 8a 06	sta $068a			sta 	gxANDValue
.af8f					_GXSDCNoFlip:
.af8f	18		clc				clc
.af90	60		rts				rts
.af91					GXPlotPoint:
.af91	20 13 b3	jsr $b313			jsr 	GXOpenBitmap 				; start drawing
.af94	20 23 b3	jsr $b323			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.af97	ac 8c 06	ldy $068c			ldy 	gsOffset
.af9a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af9c	2d 8a 06	and $068a			and 	gxANDValue
.af9f	4d 89 06	eor $0689			eor 	gxEORValue
.afa2	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afa4	20 1b b3	jsr $b31b			jsr 	GXCloseBitmap 				; stop drawing and exit
.afa7	18		clc				clc
.afa8	60		rts				rts
.afa9					GXFillRectangle:
.afa9	38		sec				sec
.afaa	80 01		bra $afad			bra 	GXRectangle
.afac					GXFrameRectangle:
.afac	18		clc				clc
.afad					GXRectangle:
.afad	ad 83 06	lda $0683			lda 	gxBitmapsOn
.afb0	f0 35		beq $afe7			beq 	_GXRFail
.afb2	08		php				php 								; save Fill flag (CS)
.afb3	20 13 b3	jsr $b313			jsr 	GXOpenBitmap 				; start drawing
.afb6	20 3b b4	jsr $b43b			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afb9	20 23 b3	jsr $b323			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afbc	38		sec				sec 								; sec = Draw line
.afbd	20 e9 af	jsr $afe9			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afc0	ad 7c 06	lda $067c			lda 	gxY0 						; reached end of rectangle ?
.afc3	cd 80 06	cmp $0680			cmp 	gxY1
.afc6	f0 19		beq $afe1			beq 	_GXRectangleExit
.afc8					_GXRectLoop:
.afc8	20 79 b3	jsr $b379			jsr 	GXMovePositionDown 			; down one.
.afcb	ee 7c 06	inc $067c			inc 	gxY0 						; change Y pos
.afce	ad 7c 06	lda $067c			lda 	gxY0 						; reached last line
.afd1	cd 80 06	cmp $0680			cmp 	gXY1
.afd4	f0 07		beq $afdd			beq 	_GXLastLine
.afd6	28		plp				plp 								; get flag back
.afd7	08		php				php
.afd8	20 e9 af	jsr $afe9			jsr 	GXDrawLineX1X0 				; draw horizontal line
.afdb	80 eb		bra $afc8			bra 	_GXRectLoop
.afdd					_GXLastLine:
.afdd	38		sec				sec
.afde	20 e9 af	jsr $afe9			jsr 	GXDrawLineX1X0
.afe1					_GXRectangleExit:
.afe1	68		pla				pla 								; throw fill flag.
.afe2	20 1b b3	jsr $b31b			jsr 	GXCloseBitmap 				; stop drawing and exit
.afe5	18		clc				clc
.afe6	60		rts				rts
.afe7					_GXRFail:
.afe7	38		sec				sec
.afe8	60		rts				rts
.afe9					GXDrawLineX1X0:
.afe9	08		php				php 								; save solid/either-end
.afea	38		sec				sec
.afeb	ad 7e 06	lda $067e			lda		gXX1
.afee	ed 7a 06	sbc $067a			sbc 	gXX0
.aff1	85 36		sta $36				sta 	gxzTemp0
.aff3	ad 7f 06	lda $067f			lda 	gXX1+1
.aff6	ed 7b 06	sbc $067b			sbc 	gXX0+1
.aff9	85 37		sta $37				sta 	gxzTemp0+1
.affb	28		plp				plp
.affc					GXDrawLineTemp0:
.affc	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.affe	48		pha				pha
.afff	a5 3d		lda $3d				lda 	gxzScreen+1
.b001	48		pha				pha
.b002	ad 8c 06	lda $068c			lda 	gsOffset
.b005	48		pha				pha
.b006	a5 0b		lda $0b				lda 	GXEditSlot
.b008	48		pha				pha
.b009	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y offset
.b00c	90 1e		bcc $b02c			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b00e					_GXDLTLine:
.b00e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b010	2d 8a 06	and $068a			and 	gxANDValue
.b013	4d 89 06	eor $0689			eor 	gxEORValue
.b016	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b018	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b01a	d0 04		bne $b020			bne 	_GXDLTNoBorrow
.b01c	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b01e	30 2e		bmi $b04e			bmi 	_GXDLTExit
.b020					_GXDLTNoBorrow:
.b020	c6 36		dec $36				dec 	gxzTemp0
.b022	c8		iny				iny 								; next slot.
.b023	d0 e9		bne $b00e			bne 	_GXDLTLine
.b025	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b027	20 5c b0	jsr $b05c			jsr 	GXDLTCheckWrap				; check for new page.
.b02a	80 e2		bra $b00e			bra 	_GXDLTLine
.b02c					_GXDLTEndPoints:
.b02c	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b02e	2d 8a 06	and $068a			and 	gxANDValue
.b031	4d 89 06	eor $0689			eor 	gxEORValue
.b034	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b036	98		tya				tya 								; advance to right side
.b037	18		clc				clc
.b038	65 36		adc $36				adc 	gxzTemp0
.b03a	a8		tay				tay
.b03b	a5 3d		lda $3d				lda 	gxzScreen+1
.b03d	65 37		adc $37				adc 	gxzTemp0+1
.b03f	85 3d		sta $3d				sta 	gxzScreen+1
.b041	20 5c b0	jsr $b05c			jsr 	GXDLTCheckWrap 			; fix up.
.b044	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b046	2d 8a 06	and $068a			and 	gxANDValue
.b049	4d 89 06	eor $0689			eor 	gxEORValue
.b04c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b04e					_GXDLTExit:
.b04e	68		pla				pla
.b04f	85 0b		sta $0b				sta 	GXEditSlot
.b051	68		pla				pla
.b052	8d 8c 06	sta $068c			sta 	gsOffset
.b055	68		pla				pla
.b056	85 3d		sta $3d				sta 	gxzScreen+1
.b058	68		pla				pla
.b059	85 3c		sta $3c				sta 	gxzScreen
.b05b	60		rts				rts
.b05c					GXDLTCheckWrap:
.b05c	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b05e	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b060	90 06		bcc $b068			bcc 	_GXDLTCWExit
.b062	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b064	85 3d		sta $3d				sta 	gxzScreen+1
.b066	e6 0b		inc $0b				inc 	GXEditSlot
.b068					_GXDLTCWExit:
.b068	60		rts				rts
.b069					GXDrawGraphicElement:
.b069	8d 1f 07	sta $071f			sta 	gxSize 						; save size
.b06c	3a		dec a				dec 	a
.b06d	8d 20 07	sta $0720			sta 	gxMask 						; and mask
.b070	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP on
.b073	f0 67		beq $b0dc			beq 	_GXSLFail
.b075	ad 7c 06	lda $067c			lda 	gxY0 						; push Y on stack
.b078	48		pha				pha
.b079	8c 22 07	sty $0722			sty 	gxAcquireVector+1 			; and acquisition vector
.b07c	8e 21 07	stx $0721			stx 	gxAcquireVector
.b07f	20 13 b3	jsr $b313			jsr 	gxOpenBitmap 				; open the bitmap.
.b082	ad 24 07	lda $0724			lda 	gxUseMode 					; scale bits
.b085	4a		lsr a				lsr 	a
.b086	4a		lsr a				lsr 	a
.b087	4a		lsr a				lsr 	a
.b088	29 07		and #$07			and		#7
.b08a	1a		inc a				inc 	a
.b08b	8d 23 07	sta $0723			sta 	gxScale
.b08e	64 38		stz $38				stz 	gxzTemp1					; start first line
.b090					_GXGELoop:
.b090	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b092	2c 24 07	bit $0724			bit 	gxUseMode 					; check for flip.
.b095	10 06		bpl $b09d			bpl		_GXNoVFlip
.b097	ad 20 07	lda $0720			lda 	gxMask
.b09a	38		sec				sec
.b09b	e5 38		sbc $38				sbc 	gxzTemp1
.b09d					_GXNoVFlip:
.b09d	aa		tax				tax 								; get the Xth line.
.b09e	20 de b0	jsr $b0de			jsr 	_GXCallAcquire 				; get that data.
.b0a1	ad 23 07	lda $0723			lda 	gxScale 					; do scale identical copies of that line.
.b0a4	85 39		sta $39				sta 	gxzTemp1+1
.b0a6					_GXGELoop2:
.b0a6	ad 7c 06	lda $067c			lda 	gxY0 						; off screen
.b0a9	cd 86 06	cmp $0686			cmp 	gxHeight
.b0ac	b0 10		bcs $b0be			bcs 	_GXDGEExit
.b0ae	20 e1 b0	jsr $b0e1			jsr 	GXRenderOneLine 			; render line
.b0b1	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0b3	d0 f1		bne $b0a6			bne 	_GXGELoop2
.b0b5	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0b7	a5 38		lda $38				lda 	gxzTemp1
.b0b9	cd 1f 07	cmp $071f			cmp 	gxSize
.b0bc	d0 d2		bne $b090			bne 	_GXGELoop
.b0be					_GXDGEExit:
.b0be	68		pla				pla 								; restore Y for next time
.b0bf	8d 7c 06	sta $067c			sta 	gxY0
.b0c2	ae 23 07	ldx $0723			ldx 	gxScale 					; get scale (1-8)
.b0c5					_GXShiftLeft:
.b0c5	18		clc				clc
.b0c6	ad 1f 07	lda $071f			lda 	gxSize
.b0c9	6d 7a 06	adc $067a			adc 	gxX0
.b0cc	8d 7a 06	sta $067a			sta 	gxX0
.b0cf	90 03		bcc $b0d4			bcc 	_GXSLNoCarry
.b0d1	ee 7b 06	inc $067b			inc 	gxX0+1
.b0d4					_GXSLNoCarry:
.b0d4	ca		dex				dex
.b0d5	d0 ee		bne $b0c5			bne 	_GXShiftLeft
.b0d7	20 1b b3	jsr $b31b			jsr 	GXCloseBitmap
.b0da	18		clc				clc
.b0db	60		rts				rts
.b0dc					_GXSLFail:
.b0dc	38		sec				sec
.b0dd	60		rts				rts
.b0de					_GXCallAcquire:
.b0de	6c 21 07	jmp ($0721)			jmp 	(gxAcquireVector)
.b0e1					GXRenderOneLine:
.b0e1	20 23 b3	jsr $b323			jsr 	GXPositionCalc 				; calculate position/offset.
.b0e4	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y contains position.
.b0e7	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b0e9					_GXROLLoop1:
.b0e9	ad 23 07	lda $0723			lda 	gxScale 					; set to do 'scale' times
.b0ec	85 3b		sta $3b				sta 	gxzTemp2+1
.b0ee					_GXROLLoop2:
.b0ee	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b0f0	2c 87 06	bit $0687			bit 	gxMode 						; check H Flip
.b0f3	50 06		bvc $b0fb			bvc 	_GXNoHFlip
.b0f5	ad 20 07	lda $0720			lda 	gxMask
.b0f8	38		sec				sec
.b0f9	e5 3a		sbc $3a				sbc 	gxzTemp2
.b0fb					_GXNoHFlip:
.b0fb	aa		tax				tax 								; read from the pixel buffer
.b0fc	bd 27 06	lda $0627,x			lda 	gxPixelBuffer,x
.b0ff	d0 07		bne $b108			bne 	_GXDraw 					; draw if non zero
.b101	ad 24 07	lda $0724			lda 	gxUseMode 					; check to see if solid background
.b104	29 04		and #$04			and 	#4
.b106	f0 0a		beq $b112			beq 	_GXZeroPixel
.b108					_GXDraw:
.b108	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b10a	2d 8a 06	and $068a			and 	gxANDValue
.b10d	5d 27 06	eor $0627,x			eor 	gxPixelBuffer,x
.b110	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b112					_GXZeroPixel:
.b112	c8		iny				iny 								; advance pointer
.b113	d0 05		bne $b11a			bne 	_GXNoShift
.b115	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b117	20 5c b0	jsr $b05c			jsr 	GXDLTCheckWrap				; check for new page.
.b11a					_GXNoShift:
.b11a	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b11c	d0 d0		bne $b0ee			bne 	_GXROLLoop2
.b11e	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b120	a5 3a		lda $3a				lda 	gxzTemp2
.b122	cd 1f 07	cmp $071f			cmp 	gxSize
.b125	d0 c2		bne $b0e9			bne 	_GXROLLoop1
.b127	ee 7c 06	inc $067c			inc 	gxY0
.b12a	60		rts				rts
.071f					gxSize:
>071f							.fill 	1
.0720					gxMask:
>0720							.fill 	1
.0721					gxAcquireVector:
>0721							.fill 	2
.0723					gxScale:
>0723							.fill 	1
.0724					gxUseMode:
>0724							.fill 	1
.b12b					GXFontHandler:
.b12b	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b12d	4d 87 06	eor $0687			eor 	gxMode
.b130	8d 24 07	sta $0724			sta 	gxUseMode
.b133	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b135	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b137	26 37		rol $37				rol	 	gxzTemp0+1
.b139	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b13b	26 37		rol $37				rol	 	gxzTemp0+1
.b13d	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b13f	26 37		rol $37				rol	 	gxzTemp0+1
.b141	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b143	09 c0		ora #$c0			ora 	#$C0
.b145	85 37		sta $37				sta 	gxzTemp0+1
.b147	a9 08		lda #$08			lda 	#8 							; size 8x8
.b149	a2 51		ldx #$51			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b14b	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b14d	20 69 b0	jsr $b069			jsr 	GXDrawGraphicElement
.b150	60		rts				rts
.b151					GXGetGraphicDataFont:
.b151	8a		txa				txa 								; X->Y
.b152	a8		tay				tay
.b153	a6 01		ldx $01				ldx 	1 							; preserve old value
.b155	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b157	85 01		sta $01				sta 	1
.b159	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b15b	86 01		stx $01				stx 	1 							; put old value back.
.b15d	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b15f					_GXExpand:
.b15f	9e 27 06	stz $0627,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b162	0a		asl a				asl 	a 							; shift bit 7 into C
.b163	90 08		bcc $b16d			bcc 	_GXNoPixel
.b165	48		pha				pha 								; if set, set pixel buffer to current colour.
.b166	ad 88 06	lda $0688			lda 	gxColour
.b169	9d 27 06	sta $0627,x			sta 	gxPixelBuffer,x
.b16c	68		pla				pla
.b16d					_GXNoPixel:
.b16d	e8		inx				inx 								; do the whole byte.
.b16e	e0 08		cpx #$08			cpx 	#8
.b170	d0 ed		bne $b15f			bne 	_GXExpand
.b172	60		rts				rts
.b173					GXSpriteHandler:
.b173	ad 82 06	lda $0682			lda 	gxSpritesOn 				; sprites on ?
.b176	f0 23		beq $b19b			beq 	_GXSHExit
.b178	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b17a	4d 87 06	eor $0687			eor 	gxMode
.b17d	8d 24 07	sta $0724			sta 	gxUseMode
.b180	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b182	da		phx				phx
.b183	20 13 b3	jsr $b313			jsr 	GXOpenBitmap 				; can access sprite information
.b186	68		pla				pla
.b187	20 f4 b3	jsr $b3f4			jsr 	GXFindSprite 				; get the sprite address
.b18a	08		php				php
.b18b	20 1b b3	jsr $b31b			jsr 	GXCloseBitmap
.b18e	28		plp				plp
.b18f	b0 0a		bcs $b19b			bcs		_GXSHExit 					; exit if find failed.
.b191	ad 25 07	lda $0725			lda 	GXSizePixels 				; return size
.b194	a2 9c		ldx #$9c			ldx 	#GXSpriteAcquire & $FF
.b196	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b198	20 69 b0	jsr $b069			jsr 	GXDrawGraphicElement
.b19b					_GXSHExit:
.b19b	60		rts				rts
.b19c					GXSpriteAcquire:
.b19c	ad 85 06	lda $0685			lda 	GXSpritePage				; point to base page
.b19f	85 0b		sta $0b				sta 	GXEditSlot
.b1a1	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1a3	a9 00		lda #$00			lda 	#0
.b1a5	ae 26 07	ldx $0726			ldx 	GXSizeBits
.b1a8					_GXTimesRowNumber:
.b1a8	18		clc				clc
.b1a9	65 36		adc $36				adc 	zTemp0
.b1ab	ca		dex				dex
.b1ac	10 fa		bpl $b1a8			bpl 	_GXTimesRowNumber
.b1ae	64 37		stz $37				stz 	gxzTemp0+1
.b1b0	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1b1	26 37		rol $37				rol 	gxzTemp0+1
.b1b3	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1b4	26 37		rol $37				rol 	gxzTemp0+1
.b1b6	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1b7	26 37		rol $37				rol 	gxzTemp0+1
.b1b9	85 36		sta $36				sta 	gxzTemp0
.b1bb	18		clc				clc 								; add base address.
.b1bc	a5 36		lda $36				lda 	gxzTemp0
.b1be	6d 28 07	adc $0728			adc 	GXSpriteOffset
.b1c1	85 36		sta $36				sta 	gxzTemp0
.b1c3	a5 37		lda $37				lda 	gxzTemp0+1
.b1c5	6d 29 07	adc $0729			adc 	GXSpriteOffset+1
.b1c8					_GXSAFindPage:
.b1c8	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1ca	90 06		bcc $b1d2			bcc 	_GXSAFoundPage
.b1cc	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1ce	e6 0b		inc $0b				inc 	GXEditSlot
.b1d0	80 f6		bra $b1c8			bra 	_GXSAFindPage
.b1d2					_GXSAFoundPage:
.b1d2	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1d4	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1d6	a0 00		ldy #$00			ldy 	#0
.b1d8					_GXSACopyLoop:
.b1d8	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1da	99 27 06	sta $0627,y			sta 	gxPixelBuffer,y
.b1dd	c8		iny				iny
.b1de	cc 25 07	cpy $0725			cpy 	GXSizePixels
.b1e1	d0 f5		bne $b1d8			bne 	_GXSACopyLoop
.b1e3	60		rts				rts
.b1e4					GXSelect:
.b1e4	ad 82 06	lda $0682			lda 	gxSpritesOn
.b1e7	f0 22		beq $b20b			beq 	_GXSFail
.b1e9	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b1eb	c9 40		cmp #$40			cmp 	#64
.b1ed	b0 1c		bcs $b20b			bcs 	_GXSFail
.b1ef	8d 8d 06	sta $068d			sta 	GSCurrentSpriteID
.b1f2	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b1f4	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b1f6	06 36		asl $36				asl 	gxzTemp0
.b1f8	06 36		asl $36				asl 	gxzTemp0
.b1fa	06 36		asl $36				asl 	gxzTemp0
.b1fc	2a		rol a				rol 	a
.b1fd	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b1ff	8d 8f 06	sta $068f			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b202	85 37		sta $37				sta 	gxzTemp0+1
.b204	a5 36		lda $36				lda 	gxzTemp0
.b206	8d 8e 06	sta $068e			sta 	GSCurrentSpriteAddr
.b209	18		clc				clc
.b20a	60		rts				rts
.b20b					_GXSFail:
.b20b	38		sec				sec
.b20c	60		rts				rts
.b20d					GXSelectImage:
.b20d	ad 82 06	lda $0682			lda 	gxSpritesOn
.b210	f0 74		beq $b286			beq 	_GXSIFail
.b212	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b215	f0 6f		beq $b286			beq 	_GXSIFail 					; (checking the MSB)
.b217	64 01		stz $01				stz 	1
.b219	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b21b	d0 6b		bne $b288			bne 	_GXSIHide
.b21d	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b21f	48		pha				pha
.b220	20 13 b3	jsr $b313			jsr 	GXOpenBitmap
.b223	68		pla				pla
.b224	20 f4 b3	jsr $b3f4			jsr 	GXFindSprite
.b227	b0 5a		bcs $b283			bcs 	_GXSICloseFail 				; no image
.b229	a0 01		ldy #$01			ldy 	#1
.b22b	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.b22e	85 36		sta $36				sta 	gxzTemp0
.b230	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.b233	85 37		sta $37				sta 	gxzTemp0+1
.b235	ad 28 07	lda $0728			lda 	GXSpriteOffset
.b238	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b23a	18		clc				clc
.b23b	ad 29 07	lda $0729			lda 	GXSpriteOffset+1
.b23e	6d 90 06	adc $0690			adc 	GXSpriteOffsetBase
.b241	c8		iny				iny
.b242	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b244	ad 91 06	lda $0691			lda 	GXSpriteOffsetBase+1
.b247	69 00		adc #$00			adc 	#0
.b249	c8		iny				iny
.b24a	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b24c	ad 26 07	lda $0726			lda 	GXSizeBits 					; get raw size
.b24f	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b251	2a		rol a				rol 	a 							; x 2
.b252	0a		asl a				asl 	a 							; x 4
.b253	0a		asl a				asl 	a 							; x 8
.b254	0a		asl a				asl 	a 							; x 16
.b255	0d 27 07	ora $0727			ora 	GXSpriteLUT 				; Or with LUT
.b258	0a		asl a				asl 	a 							; 1 shift
.b259	09 01		ora #$01			ora 	#1 							; enable sprite.
.b25b	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b25d	20 1b b3	jsr $b31b			jsr 	GXCloseBitmap
.b260	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b263	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b266	29 3f		and #$3f			and 	#$3F
.b268	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b26b	ad 26 07	lda $0726			lda 	GXSizeBits 					; get bit size
.b26e	6a		ror a				ror 	a 							; shift into bits 6/7
.b26f	6a		ror a				ror 	a
.b270	6a		ror a				ror 	a
.b271	29 c0		and #$c0			and 	#$C0
.b273	1d d2 06	ora $06d2,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b276	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b279	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b27c	29 7f		and #$7f			and 	#$7F
.b27e	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b281	18		clc				clc
.b282	60		rts				rts
.b283					_GXSICloseFail:
.b283	20 1b b3	jsr $b31b			jsr 	GXCloseBitmap
.b286					_GXSIFail:
.b286	38		sec				sec
.b287	60		rts				rts
.b288					_GXSIHide:
.b288	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b28b	85 36		sta $36				sta 	gxzTemp0
.b28d	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.b290	85 37		sta $37				sta 	gxzTemp0+1
.b292	a9 00		lda #$00			lda 	#0
.b294	92 36		sta ($36)			sta 	(gxzTemp0)
.b296	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get sprite ID
.b299	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b29c	09 80		ora #$80			ora 	#$80
.b29e	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b2a1	18		clc				clc
.b2a2	60		rts				rts
.b2a3					GXMoveSprite:
.b2a3	ad 82 06	lda $0682			lda 	gxSpritesOn
.b2a6	f0 65		beq $b30d			beq 	_GXSIFail
.b2a8	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2ab	f0 60		beq $b30d			beq 	_GXSIFail
.b2ad	85 37		sta $37				sta 	gxzTemp0+1
.b2af	a0 04		ldy #$04			ldy 	#4
.b2b1	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.b2b4	85 36		sta $36				sta 	gxzTemp0
.b2b6	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2b9	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b2bc	2a		rol a				rol 	a	 						; into bits 0,1.
.b2bd	2a		rol a				rol 	a
.b2be	2a		rol a				rol 	a
.b2bf	29 03		and #$03			and 	#3
.b2c1	aa		tax				tax
.b2c2	bd 0f b3	lda $b30f,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2c5	48		pha				pha
.b2c6	18		clc				clc
.b2c7	6d 7a 06	adc $067a			adc 	gxX0						; copy position.
.b2ca	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2cc	c8		iny				iny
.b2cd	ad 7b 06	lda $067b			lda 	gxX0+1
.b2d0	69 00		adc #$00			adc 	#0
.b2d2	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2d4	c8		iny				iny
.b2d5	68		pla				pla
.b2d6	18		clc				clc
.b2d7	6d 7c 06	adc $067c			adc 	gxY0
.b2da	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2dc	a9 00		lda #$00			lda 	#0
.b2de	69 00		adc #$00			adc 	#0
.b2e0	c8		iny				iny
.b2e1	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e3	4e 7b 06	lsr $067b			lsr 	gxX0+1 						; divide X by 4
.b2e6	6e 7a 06	ror $067a			ror 	gxX0
.b2e9	4e 7a 06	lsr $067a			lsr 	gxX0
.b2ec	4e 7c 06	lsr $067c			lsr 	gxY0 						; divide Y by 4
.b2ef	4e 7c 06	lsr $067c			lsr 	gxY0
.b2f2	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b2f5	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x
.b2f8	29 80		and #$80			and 	#$80
.b2fa	0d 7a 06	ora $067a			ora 	gxX0
.b2fd	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b300	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b303	29 c0		and #$c0			and 	#$C0
.b305	0d 7c 06	ora $067c			ora 	gxY0
.b308	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b30b	18		clc				clc
.b30c	60		rts				rts
.b30d					_GXSIFail:
.b30d	38		sec				sec
.b30e	60		rts				rts
.b30f					_GXMSOffset:
>b30f	1c						.byte 	32-8/2
>b310	18						.byte 	32-16/2
>b311	14						.byte 	32-24/2
>b312	10						.byte 	32-32/2
.b313					GXOpenBitmap:
.b313	78		sei				sei 								; no interrupts here
.b314	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b316	8d 8b 06	sta $068b			sta 	gxOriginalLUTValue
.b319	58		cli				cli
.b31a	60		rts				rts
.b31b					GXCloseBitmap:
.b31b	78		sei				sei
.b31c	ad 8b 06	lda $068b			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b31f	85 0b		sta $0b				sta 	GXEditSlot
.b321	58		cli				cli
.b322	60		rts				rts
.b323					GXPositionCalc:
.b323	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b325	48		pha				pha
.b326	ad 7c 06	lda $067c			lda 	GXY0 						; gxzScreen = Y0
.b329	85 3c		sta $3c				sta 	gxzScreen
.b32b	64 3d		stz $3d				stz 	gxzScreen+1
.b32d	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b32f	26 3d		rol $3d				rol 	gxzScreen+1
.b331	06 3c		asl $3c				asl 	gxzScreen
.b333	26 3d		rol $3d				rol 	gxzScreen+1
.b335	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b336	65 3c		adc $3c				adc 	gxzScreen
.b338	85 3c		sta $3c				sta 	gxzScreen
.b33a	90 02		bcc $b33e			bcc 	_GXPCNoCarry
.b33c	e6 3d		inc $3d				inc 	gxzScreen+1
.b33e					_GXPCNoCarry:
.b33e	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b340	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b342	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b344	85 36		sta $36				sta 	gxzTemp0
.b346	64 3d		stz $3d				stz 	gxzScreen+1
.b348	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b34a					_GXPCMultiply32:
.b34a	06 3c		asl $3c				asl 	gxzScreen
.b34c	26 3d		rol $3d				rol 	gxzScreen+1
.b34e	3a		dec a				dec 	a
.b34f	d0 f9		bne $b34a			bne 	_GXPCMultiply32
.b351	18		clc				clc
.b352	ad 7a 06	lda $067a			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b355	65 3c		adc $3c				adc 	gxzScreen
.b357	8d 8c 06	sta $068c			sta 	gsOffset
.b35a	ad 7b 06	lda $067b			lda 	GXX0+1
.b35d	65 3d		adc $3d				adc 	gxzScreen+1
.b35f	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b361	90 04		bcc $b367			bcc 	_GXPCNoOverflow
.b363	29 1f		and #$1f			and 	#$1F 						; fix it up
.b365	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b367					_GXPCNoOverflow:
.b367	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b369	85 3d		sta $3d				sta 	gxzScreen+1
.b36b	64 3c		stz $3c				stz 	gxzScreen
.b36d	18		clc				clc
.b36e	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b370	6d 84 06	adc $0684			adc 	gxBasePage 					; by adding the base page
.b373	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b375	68		pla				pla
.b376	85 36		sta $36				sta 	gxzTemp0
.b378	60		rts				rts
.b379					GXMovePositionDown:
.b379	18		clc				clc 								; add 320 to offset/temp+1
.b37a	ad 8c 06	lda $068c			lda 	gsOffset
.b37d	69 40		adc #$40			adc 	#64
.b37f	8d 8c 06	sta $068c			sta 	gsOffset
.b382	a5 3d		lda $3d				lda 	gxzScreen+1
.b384	69 01		adc #$01			adc 	#1
.b386	85 3d		sta $3d				sta 	gxzScreen+1
.b388	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b38a	90 07		bcc $b393			bcc 	_GXMPDExit
.b38c	38		sec				sec  								; next page
.b38d	e9 20		sbc #$20			sbc 	#$20
.b38f	85 3d		sta $3d				sta 	gxzScreen+1
.b391	e6 0b		inc $0b				inc 	GXEditSlot
.b393					_GXMPDExit:
.b393	60		rts				rts
.b394					GXCollide:
.b394	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b396	aa		tax				tax
.b397	05 37		ora $37				ora 	gxzTemp0+1
.b399	29 c0		and #$c0			and 	#$C0
.b39b	38		sec				sec
.b39c	d0 53		bne $b3f1			bne 	_GXCollideFail 				; if either >= 64, fail.
.b39e	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3a0	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3a3	1d 92 06	ora $0692,x			ora 	GXSpriteLow,x
.b3a6	30 48		bmi $b3f0			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3a8	18		clc				clc 								; need to calculate sum of sizes.
.b3a9	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y
.b3ac	7d d2 06	adc $06d2,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3af	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3b1	6a		ror a				ror 	a 							; 5/6/7
.b3b2	4a		lsr a				lsr 	a 							; 4/5/6
.b3b3	4a		lsr a				lsr 	a 							; 3/4/5
.b3b4	4a		lsr a				lsr 	a 							; 2/3/4
.b3b5	18		clc				clc
.b3b6	69 08		adc #$08			adc 	#$08
.b3b8	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3b9	4a		lsr a				lsr 	a
.b3ba	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3bc	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3bf	29 3f		and #$3f			and 	#$3F
.b3c1	85 39		sta $39				sta 	gxzTemp1+1
.b3c3	38		sec				sec
.b3c4	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b3c7	29 3f		and #$3f			and 	#$3F
.b3c9	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3cb	b0 03		bcs $b3d0			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3cd	49 ff		eor #$ff			eor 	#$FF
.b3cf	1a		inc a				inc 	a
.b3d0					_GXCAbs1:
.b3d0	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3d2	b0 1c		bcs $b3f0			bcs 	_GXOkayFail
.b3d4	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3d6	38		sec				sec 								; calculate |x1-x0|
.b3d7	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y
.b3da	fd 92 06	sbc $0692,x			sbc 	GXSpriteLow,x
.b3dd	b0 03		bcs $b3e2			bcs 	_GXCAbs2
.b3df	49 ff		eor #$ff			eor 	#$FF
.b3e1	1a		inc a				inc 	a
.b3e2					_GXCAbs2:
.b3e2	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3e4	b0 0a		bcs $b3f0			bcs 	_GXOkayFail
.b3e6	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b3e8	90 02		bcc $b3ec			bcc 	_GXCHaveLowest
.b3ea	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b3ec					_GXCHaveLowest:
.b3ec	0a		asl a				asl 	a 							; scale to allow for >> 2
.b3ed	0a		asl a				asl 	a
.b3ee	18		clc				clc
.b3ef	60		rts				rts
.b3f0					_GXOkayFail:
.b3f0	18		clc				clc
.b3f1					_GXCollideFail:
.b3f1	a9 ff		lda #$ff			lda 	#$FF
.b3f3	60		rts				rts
.b3f4					GXFindSprite:
.b3f4	aa		tax				tax
.b3f5	ad 85 06	lda $0685			lda 	GXSpritePage 				; access the base page of the sprite
.b3f8	85 0b		sta $0b				sta 	GXEditSlot
.b3fa	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b3fd	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b400	f0 33		beq $b435			beq 	_GXFSFail
.b402	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b405	8d 29 07	sta $0729			sta 	GXSpriteOffset+1
.b408	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b40b	48		pha				pha 								; save twice
.b40c	48		pha				pha
.b40d	29 03		and #$03			and 	#3 							; get sprite size
.b40f	8d 26 07	sta $0726			sta 	GXSizeBits 					; save raw (0-3)
.b412	aa		tax				tax
.b413	bd 37 b4	lda $b437,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b416	8d 25 07	sta $0725			sta 	GXSizePixels 					; save (8/16/24/32)
.b419	68		pla				pla 								; get LUT
.b41a	4a		lsr a				lsr		a
.b41b	4a		lsr a				lsr		a
.b41c	29 03		and #$03			and 	#3
.b41e	8d 27 07	sta $0727			sta 	GXSpriteLUT
.b421	68		pla				pla 								; address, neeeds to be x 4
.b422	29 f0		and #$f0			and 	#$F0
.b424	8d 28 07	sta $0728			sta 	GXSpriteOffset
.b427	0e 28 07	asl $0728			asl 	GXSpriteOffset
.b42a	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.b42d	0e 28 07	asl $0728			asl 	GXSpriteOffset
.b430	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.b433	18		clc				clc
.b434	60		rts				rts
.b435					_GXFSFail:
.b435	38		sec				sec
.b436	60		rts				rts
.b437					_GXFXSSTTable:
>b437	08 10 18 20					.byte 	8,16,24,32
.0725					GXSizePixels:
>0725							.fill 	1
.0726					GXSizeBits:
>0726							.fill 	1
.0727					GXSpriteLUT:
>0727							.fill 	1
.0728					GXSpriteOffset:
>0728							.fill 	2
.b43b					GXSortXY:
.b43b	20 59 b4	jsr $b459			jsr 	GXSortY 					; will be sorted on Y now
.b43e	ad 7a 06	lda $067a			lda 	gxX0 						; compare X0 v X1
.b441	cd 7e 06	cmp $067e			cmp 	gxX1
.b444	ad 7b 06	lda $067b			lda 	gXX0+1
.b447	ed 7f 06	sbc $067f			sbc 	gXX1+1
.b44a	90 0c		bcc $b458			bcc 	_GXSXYExit 					; X0 < X1 exit
.b44c	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b44e	a0 04		ldy #$04			ldy 	#4
.b450	20 6d b4	jsr $b46d			jsr 	GXSwapXY
.b453	e8		inx				inx
.b454	c8		iny				iny
.b455	20 6d b4	jsr $b46d			jsr 	GXSwapXY
.b458					_GXSXYExit:
.b458	60		rts				rts
.b459					GXSortY:
.b459	ad 7c 06	lda $067c			lda 	gxY0 						; if Y0 >= Y1
.b45c	cd 80 06	cmp $0680			cmp 	gxY1
.b45f	90 0b		bcc $b46c			bcc 	_GXSYSorted
.b461	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b463	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b465					_GXSwap1:
.b465	20 6d b4	jsr $b46d			jsr 	GXSwapXY
.b468	88		dey				dey
.b469	ca		dex				dex
.b46a	10 f9		bpl $b465			bpl 	_GXSwap1
.b46c					_GXSYSorted:
.b46c	60		rts				rts
.b46d					GXSwapXY:
.b46d	bd 7a 06	lda $067a,x			lda 	gxX0,x
.b470	48		pha				pha
.b471	b9 7a 06	lda $067a,y			lda 	gxX0,y
.b474	9d 7a 06	sta $067a,x			sta 	gxX0,x
.b477	68		pla				pla
.b478	99 7a 06	sta $067a,y			sta 	gxX0,y
.b47b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b47c					KeywordSet0:
>b47c	00 65					.text	0,$65,""               ; $80 !0:EOF
>b47e	00 58					.text	0,$58,""               ; $81 !1:SH1
>b480	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b482	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b488	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b490	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b496	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b49d	05 41 44 45 45 4b 28			.text	5,$41,"DEEK("          ; $87 DEEK(
>b4a4	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $88 EVENT(
>b4ac	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $89 FALSE
>b4b3	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $8a FRAC(
>b4ba	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8b HIT(
>b4c0	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8c INT(
>b4c6	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8d ISVAL(
>b4ce	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8e JOYB(
>b4d5	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8f JOYX(
>b4dc	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $90 JOYY(
>b4e3	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $91 LEFT$(
>b4eb	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $92 LEN(
>b4f1	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $93 MAX(
>b4f7	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $94 MID$(
>b4fe	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $95 MIN(
>b504	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $96 NOT(
>b50a	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $97 PEEK(
>b511	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $98 PLAYING(
>b519	47 28
>b51b	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $99 RANDOM(
>b523	28
>b524	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $9a RIGHT$(
>b52c	28
>b52d	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $9b RND(
>b533	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9c SGN(
>b539	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9d SPC(
>b53f	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9e STR$(
>b546	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9f TIMER(
>b54e	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $a0 TRUE
>b554	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $a1 VAL(
>b55a	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a2 FOR
>b55f	02 8f 49 46				.text	2,$8f,"IF"             ; $a3 IF
>b563	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a4 PROC
>b569	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a5 REPEAT
>b571	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a6 WHILE
>b578	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a7 ENDIF
>b57f	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a8 ENDPROC
>b587	43
>b588	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a9 NEXT
>b58e	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $aa THEN
>b594	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $ab UNTIL
>b59b	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ac WEND
>b5a1	02 9b 42 59				.text	2,$9b,"BY"             ; $ad BY
>b5a5	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ae CALL
>b5ab	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $af CIRCLE
>b5b3	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $b0 CLEAR
>b5ba	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $b1 CLS
>b5bf	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b2 COLOR
>b5c6	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b3 COLOUR
>b5ce	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b4 DATA
>b5d4	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b5 DIM
>b5d9	04 23 44 4f 4b 45			.text	4,$23,"DOKE"           ; $b6 DOKE
>b5df	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b7 DOWNTO
>b5e7	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b8 ELSE
>b5ed	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b9 FROM
>b5f3	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $ba GFX
>b5f8	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $bb GOSUB
>b5ff	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $bc GOTO
>b605	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $bd HERE
>b60b	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $be IMAGE
>b612	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bf INPUT
>b619	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c0 LET
>b61e	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c1 LINE
>b624	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c2 LOCAL
>b62b	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c3 OFF
>b630	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c4 ON
>b634	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c5 OUTLINE
>b63c	45
>b63d	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c6 PALETTE
>b645	45
>b646	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c7 PLOT
>b64c	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $c8 POKE
>b652	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c9 PRINT
>b659	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $ca READ
>b65f	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $cb RECT
>b665	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $cc REM
>b66a	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $cd RETURN
>b672	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ce SOLID
>b679	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cf SOUND
>b680	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d0 SPRITE
>b688	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $d1 TEXT
>b68e	02 a3 54 4f				.text	2,$a3,"TO"             ; $d2 TO
>b692	ff					.text	$FF
.b693					KeywordSet1:
>b693	00 65					.text	0,$65,""               ; $80 !0:EOF
>b695	00 58					.text	0,$58,""               ; $81 !1:SH1
>b697	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b699	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b6a1	4c 45
>b6a3	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b6ab	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b6b3	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b6b8	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $87 EXPLODE
>b6c0	45
>b6c1	02 96 47 4f				.text	2,$96,"GO"             ; $88 GO
>b6c5	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $89 LIST
>b6cb	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $8a LOAD
>b6d1	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8b NEW
>b6d6	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $8c PING
>b6dc	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8d RESTORE
>b6e4	45
>b6e5	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8e RUN
>b6ea	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $8f SHOOT
>b6f1	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $90 SPRITES
>b6f9	53
>b6fa	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $91 STOP
>b700	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $92 ZAP
>b705	ff					.text	$FF
.b706					KeywordSet2:
>b706	00 65					.text	0,$65,""               ; $80 !0:EOF
>b708	00 58					.text	0,$58,""               ; $81 !1:SH1
>b70a	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b70c	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b711	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b716	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b71b	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b720	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b725	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b72a	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b72f	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b734	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b739	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b73e	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b743	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b748	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b74d	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b752	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b757	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b75c	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b761	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b766	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b76b	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b770	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b775	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b77a	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b77f	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b784	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b789	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b78e	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b793	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b798	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b79d	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b7a2	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b7a7	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b7ac	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b7b1	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b7b6	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b7bb	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b7c0	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b7c5	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b7ca	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b7cf	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b7d4	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b7d9	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b7de	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b7e3	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b7e8	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b7ed	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b7f2	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b7f7	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b7fc	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b801	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b806	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b80b	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b810	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b815	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b81a	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b81f	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b824	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b829	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b82e	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b833	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b838	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b83d	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b842	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b847	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b84c	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b851	ff					.text	$FF
.b852					Export_TKListConvertLine:
.b852	48		pha				pha 								; save indent on the stack
.b853	9c 1d 04	stz $041d			stz 	tbOffset
.b856	9c 2d 04	stz $042d			stz 	tokenBuffer
.b859	9c 29 04	stz $0429			stz 	currentListColour
.b85c	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b85e	20 db b9	jsr $b9db			jsr 	LCLWriteColour
.b861	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b863	b1 30		lda ($30),y			lda 	(codePtr),y
.b865	aa		tax				tax
.b866	88		dey				dey
.b867	b1 30		lda ($30),y			lda 	(codePtr),y
.b869	20 4c ba	jsr $ba4c			jsr 	LCLWriteNumberXA
.b86c	68		pla				pla 								; adjustment to indent
.b86d	48		pha				pha 								; save on stack
.b86e	10 0c		bpl $b87c			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b870	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b871	6d 26 04	adc $0426			adc 	listIndent
.b874	8d 26 04	sta $0426			sta 	listIndent
.b877	10 03		bpl $b87c			bpl 	_LCNoAdjust
.b879	9c 26 04	stz $0426			stz 	listIndent
.b87c					_LCNoAdjust:
.b87c	18		clc				clc		 							; work out actual indent.
.b87d	ad 26 04	lda $0426			lda 	listIndent
.b880	0a		asl a				asl 	a
.b881	69 07		adc #$07			adc 	#7
.b883	85 36		sta $36				sta 	zTemp0
.b885					_LCPadOut:
.b885	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b887	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.b88a	ad 1d 04	lda $041d			lda 	tbOffset
.b88d	c5 36		cmp $36				cmp 	zTemp0
.b88f	d0 f4		bne $b885			bne 	_LCPadOut
.b891	a0 03		ldy #$03			ldy 	#3 							; start position.
.b893					_LCMainLoop:
.b893	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b895	20 db b9	jsr $b9db			jsr 	LCLWriteColour
.b898	b1 30		lda ($30),y			lda 	(codePtr),y
.b89a	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b89c	f0 17		beq $b8b5			beq 	_LCExit
.b89e	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b8a0	90 1e		bcc $b8c0			bcc 	_LCDoubles
.b8a2	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b8a4	90 2a		bcc $b8d0			bcc 	_LCShiftPunc
.b8a6	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b8a8	90 35		bcc $b8df			bcc 	_LCPunctuation
.b8aa	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b8ac	90 51		bcc $b8ff			bcc 	_LCIdentifiers
.b8ae	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b8b0	90 73		bcc $b925			bcc 	_LCTokens
.b8b2	4c 85 b9	jmp $b985			jmp 	_LCData 					; 254-5 are data objects
.b8b5					_LCExit:
.b8b5	68		pla				pla 								; get old indent adjust
.b8b6	30 07		bmi $b8bf			bmi 	_LCExit2
.b8b8	18		clc				clc 								; add to indent if +ve
.b8b9	6d 26 04	adc $0426			adc 	listIndent
.b8bc	8d 26 04	sta $0426			sta 	listIndent
.b8bf					_LCExit2:
.b8bf	60		rts				rts
.b8c0					_LCDoubles:
.b8c0	48		pha				pha
.b8c1	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b8c2	29 02		and #$02			and 	#2
.b8c4	09 3c		ora #$3c			ora 	#60 						; make < >
.b8c6	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.b8c9	68		pla				pla 								; restore, do lower bit
.b8ca	29 03		and #$03			and 	#3
.b8cc	09 3c		ora #$3c			ora 	#60
.b8ce	80 0f		bra $b8df			bra		_LCPunctuation 				; print, increment, loop
.b8d0					_LCShiftPunc:
.b8d0	aa		tax				tax 								; save in X
.b8d1	29 07		and #$07			and 	#7 							; lower 3 bits
.b8d3	f0 02		beq $b8d7			beq 	_LCNoAdd
.b8d5	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b8d7					_LCNoAdd:
.b8d7	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b8d9	90 02		bcc $b8dd			bcc 	_LCNoAdd2
.b8db	09 20		ora #$20			ora 	#32 						; adds $20
.b8dd					_LCNoAdd2:
.b8dd	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b8df					_LCPunctuation:
.b8df	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b8e1	d0 03		bne $b8e6			bne 	_LCPContinue
.b8e3	20 fa b9	jsr $b9fa			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b8e6					_LCPContinue:
.b8e6	c9 2e		cmp #$2e			cmp 	#'.'
.b8e8	f0 08		beq $b8f2			beq 	_LCPIsConstant
.b8ea	c9 30		cmp #$30			cmp 	#'0'
.b8ec	90 0b		bcc $b8f9			bcc 	_LCPNotConstant
.b8ee	c9 3a		cmp #$3a			cmp 	#'9'+1
.b8f0	b0 07		bcs $b8f9			bcs 	_LCPNotConstant
.b8f2					_LCPIsConstant:
.b8f2	48		pha				pha
.b8f3	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b8f5	20 db b9	jsr $b9db			jsr 	LCLWriteColour
.b8f8	68		pla				pla
.b8f9					_LCPNotConstant:
.b8f9	c8		iny				iny 								; consume character
.b8fa	20 e4 b9	jsr $b9e4			jsr 	LCLWrite 					; write it out.
.b8fd	80 94		bra $b893			bra 	_LCMainLoop 				; go round again.
.b8ff					_LCIdentifiers:
.b8ff	18		clc				clc 								; convert to physical address
.b900	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b902	85 37		sta $37				sta 	zTemp0+1
.b904	c8		iny				iny
.b905	b1 30		lda ($30),y			lda 	(codePtr),y
.b907	85 36		sta $36				sta 	zTemp0
.b909	c8		iny				iny
.b90a	5a		phy				phy 								; save position
.b90b	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b90d	20 db b9	jsr $b9db			jsr 	LCLWriteColour
.b910	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b912					_LCOutIdentifier:
.b912	c8		iny				iny
.b913	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b915	29 7f		and #$7f			and 	#$7F
.b917	20 36 ba	jsr $ba36			jsr 	LCLLowerCase
.b91a	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.b91d	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b91f	10 f1		bpl $b912			bpl 	_LCOutIdentifier
.b921	7a		ply				ply 								; restore position
.b922	4c 93 b8	jmp $b893			jmp 	_LCMainLoop
.b925					_LCTokens:
.b925	aa		tax				tax 								; token in X
.b926	a9 06		lda #$06			lda 	#((KeywordSet2) & $FF)
.b928	85 36		sta $36				sta 	0+zTemp0
.b92a	a9 b7		lda #$b7			lda 	#((KeywordSet2) >> 8)
.b92c	85 37		sta $37				sta 	1+zTemp0
.b92e	e0 82		cpx #$82			cpx 	#$82
.b930	f0 16		beq $b948			beq 	_LCUseShift
.b932	a9 93		lda #$93			lda 	#((KeywordSet1) & $FF)
.b934	85 36		sta $36				sta 	0+zTemp0
.b936	a9 b6		lda #$b6			lda 	#((KeywordSet1) >> 8)
.b938	85 37		sta $37				sta 	1+zTemp0
.b93a	e0 81		cpx #$81			cpx 	#$81
.b93c	f0 0a		beq $b948			beq 	_LCUseShift
.b93e	a9 7c		lda #$7c			lda 	#((KeywordSet0) & $FF)
.b940	85 36		sta $36				sta 	0+zTemp0
.b942	a9 b4		lda #$b4			lda 	#((KeywordSet0) >> 8)
.b944	85 37		sta $37				sta 	1+zTemp0
.b946	80 01		bra $b949			bra 	_LCNoShift
.b948					_LCUseShift:
.b948	c8		iny				iny
.b949					_LCNoShift:
.b949	20 0e ba	jsr $ba0e			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b94c	b1 30		lda ($30),y			lda 	(codePtr),y
.b94e	aa		tax				tax 								; into X
.b94f					_LCFindText:
.b94f	ca		dex				dex
.b950	10 0e		bpl $b960			bpl 	_LCFoundText 				; found text.
.b952	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b954	1a		inc a				inc 	a 							; one extra for size
.b955	38		sec				sec 								; one extra for checksum
.b956	65 36		adc $36				adc 	zTemp0 						; go to next token
.b958	85 36		sta $36				sta 	zTemp0
.b95a	90 f3		bcc $b94f			bcc 	_LCFindText
.b95c	e6 37		inc $37				inc 	zTemp0+1
.b95e	80 ef		bra $b94f			bra 	_LCFindText
.b960					_LCFoundText:
.b960	5a		phy				phy 								; save List position
.b961	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b963	aa		tax				tax
.b964	a9 83		lda #$83			lda 	#CLIToken+$80
.b966	20 db b9	jsr $b9db			jsr 	LCLWriteColour
.b969	a0 02		ldy #$02			ldy 	#2
.b96b					_LCCopyToken:
.b96b	b1 36		lda ($36),y			lda 	(zTemp0),y
.b96d	20 36 ba	jsr $ba36			jsr 	LCLLowerCase
.b970	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.b973	c8		iny				iny
.b974	ca		dex				dex
.b975	d0 f4		bne $b96b			bne 	_LCCopyToken
.b977	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b979	f0 05		beq $b980			beq 	_LCNoSpace
.b97b	a9 20		lda #$20			lda 	#' '
.b97d	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.b980					_LCNoSpace:
.b980	7a		ply				ply 								; restore position.
.b981	c8		iny				iny 								; consume token
.b982	4c 93 b8	jmp $b893			jmp 	_LCMainLoop 				; and go around again.
.b985					_LCData:
.b985	48		pha				pha 								; save type $FE/$FF
.b986	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b988	c9 fe		cmp #$fe			cmp 	#$FE
.b98a	f0 22		beq $b9ae			beq 	_LCHaveOpener
.b98c	a2 22		ldx #$22			ldx 	#'"'
.b98e	a9 81		lda #$81			lda 	#CLIData+$80
.b990	20 db b9	jsr $b9db			jsr 	LCLWriteColour
.b993	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b995	d0 17		bne $b9ae			bne 	_LCHaveOpener
.b997	88		dey				dey 								; what precedes it ?
.b998	b1 30		lda ($30),y			lda 	(codePtr),y
.b99a	c8		iny				iny
.b99b	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b99d	d0 0f		bne $b9ae			bne 	_LCHaveOpener
.b99f	a9 09		lda #$09			lda 	#9 							; tab
.b9a1	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.b9a4	a9 97		lda #$97			lda 	#$90+CLIBComment
.b9a6	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.b9a9	a9 80		lda #$80			lda 	#CLIFComment+$80
.b9ab	20 db b9	jsr $b9db			jsr 	LCLWriteColour
.b9ae					_LCHaveOpener:
.b9ae	8a		txa				txa 								; output prefix (# or ")
.b9af	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.b9b2	c8		iny				iny 								; get count
.b9b3	b1 30		lda ($30),y			lda 	(codePtr),y
.b9b5	aa		tax				tax
.b9b6	c8		iny				iny 								; point at first character
.b9b7					_LCOutData:
.b9b7	b1 30		lda ($30),y			lda 	(codePtr),y
.b9b9	c9 00		cmp #$00			cmp 	#0
.b9bb	f0 03		beq $b9c0			beq 	_LCNoPrint
.b9bd	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.b9c0					_LCNoPrint:
.b9c0	c8		iny				iny
.b9c1	ca		dex				dex
.b9c2	d0 f3		bne $b9b7			bne 	_LCOutData
.b9c4	68		pla				pla 								; closing " required ?
.b9c5	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b9c7	d0 0f		bne $b9d8			bne 	_LCNoQuote
.b9c9	a9 22		lda #$22			lda 	#'"'
.b9cb	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.b9ce	ad 6f 06	lda $066f			lda 	EXTTextColour
.b9d1	29 0f		and #$0f			and 	#$0F
.b9d3	09 90		ora #$90			ora 	#$90
.b9d5	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.b9d8					_LCNoQuote:
.b9d8	4c 93 b8	jmp $b893			jmp 	_LCMainLoop
.b9db					LCLWriteColour:
.b9db	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b9de	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b9e1	d0 01		bne $b9e4			bne 	LCLWrite 					; if different, output it
.b9e3	60		rts				rts
.b9e4					LCLWrite:
.b9e4	da		phx				phx
.b9e5	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b9e8	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b9eb	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.b9ee	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.b9f1	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b9f3	30 03		bmi $b9f8			bmi 	_LCLNoColour
.b9f5	8d 27 04	sta $0427			sta 	LCLastCharacter
.b9f8					_LCLNoColour:
.b9f8	fa		plx				plx
.b9f9	60		rts				rts
.b9fa					LCLDeleteLastSpace:
.b9fa	48		pha				pha
.b9fb	da		phx				phx
.b9fc	ae 1d 04	ldx $041d			ldx 	tbOffset
.b9ff	f0 0a		beq $ba0b			beq 	_LCDLSExit
.ba01	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.ba04	c9 20		cmp #$20			cmp 	#' '
.ba06	d0 03		bne $ba0b			bne 	_LCDLSExit
.ba08	ce 1d 04	dec $041d			dec 	tbOffset
.ba0b					_LCDLSExit:
.ba0b	fa		plx				plx
.ba0c	68		pla				pla
.ba0d	60		rts				rts
.ba0e					LCLCheckSpaceRequired:
.ba0e	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.ba11	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.ba13	f0 1b		beq $ba30			beq 	_LCCSRSpace
.ba15	c9 29		cmp #$29			cmp 	#')'
.ba17	f0 17		beq $ba30			beq 	_LCCSRSpace
.ba19	c9 23		cmp #$23			cmp 	#'#'
.ba1b	f0 13		beq $ba30			beq 	_LCCSRSpace
.ba1d	20 36 ba	jsr $ba36			jsr 	LCLLowerCase 				; saves a little effort
.ba20	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.ba22	90 11		bcc $ba35			bcc 	_LCCSRExit
.ba24	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba26	90 08		bcc $ba30			bcc 	_LCCSRSpace
.ba28	c9 61		cmp #$61			cmp 	#"a"
.ba2a	90 09		bcc $ba35			bcc 	_LCCSRExit
.ba2c	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba2e	b0 05		bcs $ba35			bcs 	_LCCSRExit
.ba30					_LCCSRSpace:
.ba30	a9 20		lda #$20			lda 	#' '
.ba32	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.ba35					_LCCSRExit:
.ba35	60		rts				rts
.ba36					LCLLowerCase:
.ba36	c9 41		cmp #$41			cmp 	#"A"
.ba38	90 06		bcc $ba40			bcc 	_LCLLCOut
.ba3a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba3c	b0 02		bcs $ba40			bcs 	_LCLLCOut
.ba3e	69 20		adc #$20			adc 	#$20
.ba40					_LCLLCOut:
.ba40	60		rts				rts
.ba41					LCLUpperCase:
.ba41	c9 61		cmp #$61			cmp 	#"a"
.ba43	90 06		bcc $ba4b			bcc 	_LCLUCOut
.ba45	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba47	b0 02		bcs $ba4b			bcs 	_LCLUCOut
.ba49	e9 1f		sbc #$1f			sbc 	#$1F
.ba4b					_LCLUCOut:
.ba4b	60		rts				rts
.ba4c					LCLWriteNumberXA:
.ba4c	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.ba4e					_LCLWNLoop1:
.ba4e	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.ba50					_LCLWNLoop2:
.ba50	48		pha				pha 								; save initial LSB
.ba51	38		sec				sec
.ba52	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.ba54	f9 85 ba	sbc $ba85,y			sbc 	_LCLWNTable,y
.ba57	48		pha				pha
.ba58	8a		txa				txa
.ba59	f9 86 ba	sbc $ba86,y			sbc 	_LCLWNTable+1,y
.ba5c	90 07		bcc $ba65			bcc 	_LCLWNUnderflow
.ba5e	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.ba60	aa		tax				tax 								; update X
.ba61	68		pla				pla 								; restore A
.ba62	7a		ply				ply 								; throw original
.ba63	80 eb		bra $ba50			bra 	_LCLWNLoop2 				; try again.
.ba65					_LCLWNUnderflow:
.ba65	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.ba67	d0 06		bne $ba6f			bne 	_LCLWNOut
.ba69	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.ba6c	3a		dec a				dec 	a
.ba6d	f0 04		beq $ba73			beq 	_LCLWNNext
.ba6f					_LCLWNOut:
.ba6f	98		tya				tya
.ba70	20 7f ba	jsr $ba7f			jsr 	_LCLWNOutDigit
.ba73					_LCLWNNext:
.ba73	7a		ply				ply 							 	; restore original value.
.ba74	68		pla				pla
.ba75	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.ba77	c8		iny				iny
.ba78	c8		iny				iny
.ba79	84 37		sty $37				sty 	zTemp0+1
.ba7b	c0 08		cpy #$08			cpy 	#8 							; done all 4
.ba7d	d0 cf		bne $ba4e			bne 	_LCLWNLoop1
.ba7f					_LCLWNOutDigit:
.ba7f	09 30		ora #$30			ora 	#'0'
.ba81	20 e4 b9	jsr $b9e4			jsr 	LCLWrite
.ba84	60		rts				rts
.ba85					_LCLWNTable:
>ba85	10 27						.word 	10000
>ba87	e8 03						.word 	1000
>ba89	64 00						.word 	100
>ba8b	0a 00						.word 	10
.ba8d					TOKSearchTable:
.ba8d	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.ba8f	85 36		sta $36				sta 	zTemp0
.ba91	a0 00		ldy #$00			ldy 	#0
.ba93	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.ba95	85 38		sta $38				sta 	zTemp1
.ba97					_TSTLoop:
.ba97	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.ba99	30 49		bmi $bae4			bmi 	_TSTFail 					; -ve = end of table, so fail.
.ba9b	f0 2e		beq $bacb			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.ba9d	c8		iny				iny 								; get the hash
.ba9e	b1 36		lda ($36),y			lda 	(zTemp0),y
.baa0	88		dey				dey
.baa1	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.baa4	d0 25		bne $bacb			bne 	_TSTNext
.baa6	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.baa9	38		sec				sec
.baaa	ed 00 04	sbc $0400			sbc 	identStart
.baad	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.baaf	d0 1a		bne $bacb			bne 	_TSTNext
.bab1	5a		phy				phy 								; save Y , we might fail to match.
.bab2	c8		iny				iny 								; point to text
.bab3	c8		iny				iny
.bab4	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.bab7					_TSTCompareName:
.bab7	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.baba	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.babc	d0 0c		bne $baca			bne 	_TSTNextPullY 				; fail, pullY and do next
.babe	e8		inx				inx
.babf	c8		iny				iny
.bac0	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.bac3	d0 f2		bne $bab7			bne 	_TSTCompareName
.bac5	7a		ply				ply 								; throw Y
.bac6	a5 38		lda $38				lda 	zTemp1 						; get token #
.bac8	38		sec				sec 								; return with CS = passed.
.bac9	60		rts				rts
.baca					_TSTNextPullY:
.baca	7a		ply				ply 								; restore current, fall through.
.bacb					_TSTNext:
.bacb	e6 38		inc $38				inc 	zTemp1 						; token counter
.bacd	98		tya				tya
.bace	18		clc				clc
.bacf	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.bad1	1a		inc a				inc 	a 							; +1
.bad2	1a		inc a				inc 	a 							; +2
.bad3	a8		tay				tay
.bad4	10 c1		bpl $ba97			bpl 	_TSTLoop 					; if Y < $80 loop back
.bad6	98		tya				tya 								; add Y to zTemp0 and reset Y
.bad7	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.bad9	18		clc				clc  								; but have tables > 255 bytes
.bada	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.badc	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.bade	90 b7		bcc $ba97			bcc 	_TSTLoop
.bae0	e6 37		inc $37				inc 	zTemp0+1
.bae2	80 b3		bra $ba97			bra 	_TSTLoop
.bae4					_TSTFail:
.bae4	18		clc				clc
.bae5	60		rts				rts
.bae6					Export_TKTokeniseLine:
.bae6	20 6e bc	jsr $bc6e			jsr 	LCLFixLineBufferCase 		; fix line case
.bae9	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.baeb	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.baee	9c 2b 04	stz $042b			stz 	tokenLineNumber
.baf1	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.baf4	a2 ff		ldx #$ff			ldx 	#$FF
.baf6					_TKFindFirst:
.baf6	e8		inx				inx
.baf7	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bafa	f0 79		beq $bb75			beq 	_TKExit
.bafc	c9 20		cmp #$20			cmp 	#' '
.bafe	90 f6		bcc $baf6			bcc 	_TKFindFirst
.bb00	c9 30		cmp #$30			cmp 	#'0'
.bb02	90 07		bcc $bb0b			bcc 	_TKNoLineNumber
.bb04	c9 3a		cmp #$3a			cmp 	#'9'+1
.bb06	b0 03		bcs $bb0b			bcs 	_TKNoLineNumber
.bb08	20 98 bc	jsr $bc98			jsr 	TOKExtractLineNumber
.bb0b					_TKNoLineNumber:
.bb0b					_TKTokeniseLoop:
.bb0b	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.bb0e	f0 65		beq $bb75			beq 	_TKExit
.bb10	e8		inx				inx
.bb11	c9 20		cmp #$20			cmp 	#' '
.bb13	f0 f6		beq $bb0b			beq 	_TKTokeniseLoop 			; keep looping if space found.
.bb15	ca		dex				dex 								; undo last get, A contains character, X is position.
.bb16	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.bb18	f0 61		beq $bb7b			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.bb1a	c9 41		cmp #$41			cmp 	#'A'
.bb1c	90 04		bcc $bb22			bcc 	_TKTokenisePunctuation
.bb1e	c9 5b		cmp #$5b			cmp 	#'Z'+1
.bb20	90 59		bcc $bb7b			bcc 	_TKTokeniseIdentifier
.bb22					_TKTokenisePunctuation:
.bb22	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.bb24	f0 27		beq $bb4d			beq 	_TKString
.bb26	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.bb28	f0 28		beq $bb52			beq 	_TKHexConstant
.bb2a	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.bb2c	f0 29		beq $bb57			beq 	_TKCheckDouble
.bb2e	c9 3e		cmp #$3e			cmp 	#'>'
.bb30	f0 25		beq $bb57			beq 	_TKCheckDouble
.bb32					_TKStandardPunctuation:
.bb32	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.bb35	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.bb37	90 0e		bcc $bb47			bcc 	_TKNoShift
.bb39	48		pha				pha 								; save. we are about to convert this punctuation token from
.bb3a	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.bb3c	85 36		sta $36				sta 	zTemp0
.bb3e	68		pla				pla
.bb3f	29 20		and #$20			and 	#32 						; bit 5
.bb41	4a		lsr a				lsr 	a 							; shift into bit 3
.bb42	4a		lsr a				lsr 	a
.bb43	05 36		ora $36				ora 	zTemp0
.bb45	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.bb47					_TKNoShift:
.bb47	20 dd bc	jsr $bcdd			jsr 	TOKWriteByte 				; write the punctuation character
.bb4a	e8		inx				inx 								; consume the character
.bb4b	80 be		bra $bb0b			bra 	_TKTokeniseLoop 			; and loop round again.
.bb4d					_TKString:
.bb4d	20 fd bb	jsr $bbfd			jsr 	TOKTokenString
.bb50	80 b9		bra $bb0b			bra 	_TKTokeniseLoop
.bb52					_TKHexConstant:
.bb52	20 38 bc	jsr $bc38			jsr 	TOKHexConstant
.bb55	80 b4		bra $bb0b			bra 	_TKTokeniseLoop
.bb57					_TKCheckDouble:
.bb57	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.bb5a	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.bb5c	90 d4		bcc $bb32			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.bb5e	c9 3f		cmp #$3f			cmp 	#'>'+1
.bb60	b0 d0		bcs $bb32			bcs 	_TKStandardPunctuation
.bb62	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.bb65	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.bb67	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.bb68	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.bb6b	38		sec				sec
.bb6c	e9 3c		sbc #$3c			sbc 	#'<'
.bb6e	20 dd bc	jsr $bcdd			jsr 	TOKWriteByte 				; this is in the range 0-7
.bb71	e8		inx				inx 								; consume both
.bb72	e8		inx				inx
.bb73	80 96		bra $bb0b			bra 	_TKTokeniseLoop
.bb75	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.bb77	20 dd bc	jsr $bcdd			jsr 	TOKWriteByte
.bb7a	60		rts				rts
.bb7b					_TKTokeniseIdentifier:
.bb7b	8e 00 04	stx $0400			stx 	identStart 					; save start
.bb7e	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.bb81					_TKCheckLoop:
.bb81	e8		inx				inx 								; look at next, we know first is identifier already.
.bb82	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.bb85	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.bb87	f0 f8		beq $bb81			beq 	_TKCheckLoop
.bb89	c9 30		cmp #$30			cmp	 	#"0"
.bb8b	90 0c		bcc $bb99			bcc 	_TKEndIdentifier
.bb8d	c9 3a		cmp #$3a			cmp 	#"9"+1
.bb8f	90 f0		bcc $bb81			bcc 	_TKCheckLoop
.bb91	c9 41		cmp #$41			cmp	 	#"A"
.bb93	90 04		bcc $bb99			bcc 	_TKEndIdentifier
.bb95	c9 5b		cmp #$5b			cmp 	#"Z"+1
.bb97	90 e8		bcc $bb81			bcc 	_TKCheckLoop
.bb99					_TKEndIdentifier:
.bb99	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.bb9c	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.bb9e	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.bba0	f0 06		beq $bba8			beq 	_TKHasTypeCharacter
.bba2	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.bba4	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.bba6	d0 07		bne $bbaf			bne 	_TKNoTypeCharacter
.bba8					_TKHasTypeCharacter:
.bba8	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.bbab	e8		inx				inx 								; consume the type character
.bbac	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bbaf					_TKNoTypeCharacter:
.bbaf	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.bbb1	d0 09		bne $bbbc			bne 	_TKNoArray
.bbb3	e8		inx				inx 								; skip the (
.bbb4	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.bbb7	09 04		ora #$04			ora 	#$04
.bbb9	8d 04 04	sta $0404			sta 	identTypeByte
.bbbc					_TKNoArray:
.bbbc	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.bbbf	20 59 bc	jsr $bc59			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.bbc2	a0 b4		ldy #$b4			ldy 	#(KeywordSet0) >> 8
.bbc4	a9 7c		lda #$7c			lda 	#(KeywordSet0) & $FF
.bbc6	20 8d ba	jsr $ba8d			jsr 	TOKSearchTable
.bbc9	a2 00		ldx #$00			ldx 	#0
.bbcb	b0 1f		bcs $bbec			bcs 	_TKFoundToken
.bbcd	a0 b6		ldy #$b6			ldy 	#(KeywordSet1) >> 8
.bbcf	a9 93		lda #$93			lda 	#(KeywordSet1) & $FF
.bbd1	20 8d ba	jsr $ba8d			jsr 	TOKSearchTable
.bbd4	a2 81		ldx #$81			ldx 	#$81
.bbd6	b0 14		bcs $bbec			bcs 	_TKFoundToken
.bbd8	a0 b7		ldy #$b7			ldy 	#(KeywordSet2) >> 8
.bbda	a9 06		lda #$06			lda 	#(KeywordSet2) & $FF
.bbdc	20 8d ba	jsr $ba8d			jsr 	TOKSearchTable
.bbdf	a2 82		ldx #$82			ldx 	#$82
.bbe1	b0 09		bcs $bbec			bcs 	_TKFoundToken
.bbe3	20 e9 bc	jsr $bce9			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bbe6	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bbe9	4c 0b bb	jmp $bb0b			jmp 	_TKTokeniseLoop 			; and go round again.
.bbec					_TKFoundToken:
.bbec	48		pha				pha 								; save token
.bbed	8a		txa				txa 								; shift in X, is there one ?
.bbee	f0 03		beq $bbf3			beq 	_TKNoTShift
.bbf0	20 dd bc	jsr $bcdd			jsr 	TOKWriteByte 				; if so, write it out
.bbf3					_TKNoTShift:
.bbf3	68		pla				pla 								; restore and write token
.bbf4	20 dd bc	jsr $bcdd			jsr 	TOKWriteByte
.bbf7	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bbfa	4c 0b bb	jmp $bb0b			jmp 	_TKTokeniseLoop 			; and go round again.
.bbfd					TOKTokenString:
.bbfd	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bbff	20 dd bc	jsr $bcdd			jsr 	TOKWriteByte
.bc02	e8		inx				inx									; start of quoted string.
.bc03	da		phx				phx 								; push start of string on top
.bc04	ca		dex				dex 								; because we pre-increment
.bc05					_TSFindEnd:
.bc05	e8		inx				inx
.bc06	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bc09	f0 04		beq $bc0f			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bc0b	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bc0d	d0 f6		bne $bc05			bne 	_TSFindEnd
.bc0f					_TSEndOfString:
.bc0f	7a		ply				ply  								; so now Y is first character, X is character after end.
.bc10	48		pha				pha 								; save terminating character
.bc11	20 19 bc	jsr $bc19			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bc14	68		pla				pla 								; terminating character
.bc15	f0 01		beq $bc18			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bc17	e8		inx				inx
.bc18					_TSNotQuote:
.bc18	60		rts				rts
.bc19					TOKWriteBlockXY:
.bc19	86 36		stx $36				stx 	zTemp0 						; save end character
.bc1b	98		tya				tya 								; use 2's complement to work out the byte size
.bc1c	49 ff		eor #$ff			eor 	#$FF
.bc1e	38		sec				sec
.bc1f	65 36		adc $36				adc 	zTemp0
.bc21	1a		inc a				inc 	a 							; one extra for NULL
.bc22	20 dd bc	jsr $bcdd			jsr 	TOKWriteByte
.bc25					_TOBlockLoop:
.bc25	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bc27	f0 09		beq $bc32			beq 	_TOBlockExit
.bc29	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bc2c	20 dd bc	jsr $bcdd			jsr 	TOKWriteByte
.bc2f	c8		iny				iny
.bc30	80 f3		bra $bc25			bra 	_TOBlockLoop
.bc32					_TOBlockExit:
.bc32	a9 00		lda #$00			lda 	#0 							; add NULL.
.bc34	20 dd bc	jsr $bcdd			jsr 	TOKWriteByte
.bc37	60		rts				rts
.bc38					TOKHexConstant:
.bc38	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bc3a	20 dd bc	jsr $bcdd			jsr 	TOKWriteByte
.bc3d	e8		inx				inx									; start of quoted string.
.bc3e	da		phx				phx 								; push start of constant on top
.bc3f	ca		dex				dex
.bc40					_THFindLoop:
.bc40	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bc41	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bc44	c9 30		cmp #$30			cmp 	#"0"
.bc46	90 0c		bcc $bc54			bcc 	_THFoundEnd
.bc48	c9 3a		cmp #$3a			cmp 	#"9"+1
.bc4a	90 f4		bcc $bc40			bcc 	_THFindLoop
.bc4c	c9 41		cmp #$41			cmp 	#"A"
.bc4e	90 04		bcc $bc54			bcc 	_THFoundEnd
.bc50	c9 47		cmp #$47			cmp 	#"F"+1
.bc52	90 ec		bcc $bc40			bcc 	_THFindLoop
.bc54					_THFoundEnd:
.bc54	7a		ply				ply 								; restore start
.bc55	20 19 bc	jsr $bc19			jsr 	TOKWriteBlockXY 			; output the block
.bc58	60		rts				rts
.bc59					TOKCalculateHash:
.bc59	da		phx				phx
.bc5a	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bc5d	a9 00		lda #$00			lda 	#0
.bc5f					_TCHLoop:
.bc5f	18		clc				clc
.bc60	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bc63	e8		inx				inx
.bc64	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bc67	d0 f6		bne $bc5f			bne 	_TCHLoop
.bc69	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bc6c	fa		plx				plx
.bc6d	60		rts				rts
.bc6e					LCLFixLineBufferCase:
.bc6e	a2 00		ldx #$00			ldx 	#0
.bc70					_FLBCLoop:
.bc70	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bc73	f0 22		beq $bc97			beq 	_FLBCExit 					; end of string.
.bc75	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bc77	f0 11		beq $bc8a			beq 	_FLBCInQuotes
.bc79	e8		inx				inx
.bc7a	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bc7c	90 f2		bcc $bc70			bcc 	_FLBCLoop
.bc7e	c9 7b		cmp #$7b			cmp 	#'z'+1
.bc80	b0 ee		bcs $bc70			bcs 	_FLBCLoop
.bc82	38		sec				sec 								; make U/C
.bc83	e9 20		sbc #$20			sbc 	#32
.bc85	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bc88	80 e6		bra $bc70			bra 	_FLBCLoop
.bc8a					_FLBCInQuotes:
.bc8a	e8		inx				inx 								; advance
.bc8b	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bc8e	f0 07		beq $bc97			beq 	_FLBCExit 					; exit on EOS
.bc90	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bc92	d0 f6		bne $bc8a			bne 	_FLBCInQuotes
.bc94	e8		inx				inx 								; skip over it
.bc95	80 d9		bra $bc70			bra 	_FLBCLoop
.bc97					_FLBCExit:
.bc97	60		rts				rts
.bc98					TOKExtractLineNumber:
.bc98	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bc9b	48		pha				pha
.bc9c	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bc9f	48		pha				pha
.bca0	20 d6 bc	jsr $bcd6			jsr 	_LCLNTimes2 				; line # x 2
.bca3	20 d6 bc	jsr $bcd6			jsr 	_LCLNTimes2 				; line # x 4
.bca6	18		clc				clc 								; add stacked value
.bca7	68		pla				pla
.bca8	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcab	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcae	68		pla				pla
.bcaf	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bcb2	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bcb5	20 d6 bc	jsr $bcd6			jsr 	_LCLNTimes2 				; line # x 10
.bcb8	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bcbb	e8		inx				inx
.bcbc	29 0f		and #$0f			and 	#15 						; add to line #
.bcbe	18		clc				clc
.bcbf	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcc2	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcc5	90 03		bcc $bcca			bcc 	_TLENNoCarry
.bcc7	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bcca					_TLENNoCarry:
.bcca	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bccd	c9 30		cmp #$30			cmp 	#'0'
.bccf	90 04		bcc $bcd5			bcc 	_TLENExit
.bcd1	c9 3a		cmp #$3a			cmp 	#'9'+1
.bcd3	90 c3		bcc $bc98			bcc 	TOKExtractLineNumber
.bcd5					_TLENExit:
.bcd5	60		rts				rts
.bcd6					_LCLNTimes2:
.bcd6	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bcd9	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bcdc	60		rts				rts
.bcdd					TOKWriteByte:
.bcdd	da		phx				phx
.bcde	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bce1	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bce4	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bce7	fa		plx				plx
.bce8	60		rts				rts
.bce9					TOKCheckCreateVariableRecord:
.bce9	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bceb	85 36		sta $36				sta 	0+zTemp0
.bced	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bcef	85 37		sta $37				sta 	1+zTemp0
.bcf1					_CCVSearch:
.bcf1	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bcf3	f0 2c		beq $bd21			beq 	_CCVFail
.bcf5	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bcf7	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bcf9	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bcfc	d0 16		bne $bd14			bne 	_CCVNext
.bcfe	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bd00	ae 00 04	ldx $0400			ldx 	identStart
.bd03					_CCVCompare:
.bd03	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bd06	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bd08	e8		inx				inx 								; advance pointers
.bd09	c8		iny				iny
.bd0a	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bd0b	d0 07		bne $bd14			bne 	_CCVNext  					; didn't match go to next.
.bd0d	90 f4		bcc $bd03			bcc 	_CCVCompare 				; not finished yet.
.bd0f	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bd12	f0 41		beq $bd55			beq 	_CCVFound 					; yes, we were successful
.bd14					_CCVNext:
.bd14	18		clc				clc 								; go to next record.
.bd15	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bd17	65 36		adc $36				adc 	zTemp0
.bd19	85 36		sta $36				sta 	zTemp0
.bd1b	90 d4		bcc $bcf1			bcc 	_CCVSearch
.bd1d	e6 37		inc $37				inc 	zTemp0+1
.bd1f	80 d0		bra $bcf1			bra 	_CCVSearch
.bd21					_CCVFail:
.bd21	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bd23	ad 03 04	lda $0403			lda 	identHash
.bd26	91 36		sta ($36),y			sta 	(zTemp0),y
.bd28	c8		iny				iny 								; offset 2 is the type byte
.bd29	ad 04 04	lda $0404			lda 	identTypeByte
.bd2c	91 36		sta ($36),y			sta 	(zTemp0),y
.bd2e	c8		iny				iny
.bd2f					_CCVData:
.bd2f	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bd31	91 36		sta ($36),y			sta 	(zTemp0),y
.bd33	c8		iny				iny
.bd34	c0 08		cpy #$08			cpy 	#8
.bd36	90 f7		bcc $bd2f			bcc 	_CCVData
.bd38	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bd3b					_CCVCopyName:
.bd3b	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bd3e	91 36		sta ($36),y			sta 	(zTemp0),y
.bd40	e8		inx				inx
.bd41	c8		iny				iny
.bd42	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bd45	d0 f4		bne $bd3b			bne 	_CCVCopyName
.bd47	98		tya				tya 								; patch offset
.bd48	92 36		sta ($36)			sta 	(zTemp0)
.bd4a	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bd4c	91 36		sta ($36),y			sta 	(zTemp0),y
.bd4e	88		dey				dey
.bd4f	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bd51	09 80		ora #$80			ora 	#$80
.bd53	91 36		sta ($36),y			sta 	(zTemp0),y
.bd55					_CCVFound:
.bd55	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bd57	38		sec				sec
.bd58	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bd5a	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bd5c	20 dd bc	jsr $bcdd			jsr 	TOKWriteByte
.bd5f	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bd61	20 dd bc	jsr $bcdd			jsr 	TOKWriteByte
.bd64	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bd65					SNDCheckChannel:
.bd65	aa		tax				tax
.bd66	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bd69	d0 38		bne $bda3			bne 	_SNDCCExit
.bd6b	da		phx				phx 								; save current channel
.bd6c	8a		txa				txa 								; put in A
.bd6d	20 e9 bd	jsr $bde9			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bd70	68		pla				pla 								; channel # in A
.bd71	90 30		bcc $bda3			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bd73	a8		tay				tay 								; Y is the channel #
.bd74	bd 2d 07	lda $072d,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bd77	99 2c 08	sta $082c,y			sta 	SNDPitchLow,y
.bd7a	bd 2e 07	lda $072e,x			lda 	SNDQueue+2,x
.bd7d	99 30 08	sta $0830,y			sta 	SNDPitchHigh,y
.bd80	bd 2f 07	lda $072f,x			lda 	SNDQueue+3,x
.bd83	99 34 08	sta $0834,y			sta 	SNDVolume,y
.bd86	bd 30 07	lda $0730,x			lda 	SNDQueue+4,x
.bd89	99 38 08	sta $0838,y			sta 	SNDTimeLeft,y
.bd8c	bd 31 07	lda $0731,x			lda 	SNDQueue+5,x
.bd8f	99 3c 08	sta $083c,y			sta 	SNDAdjustLow,y
.bd92	bd 32 07	lda $0732,x			lda 	SNDQueue+6,x
.bd95	99 40 08	sta $0840,y			sta 	SNDAdjustHigh,y
.bd98	5a		phy				phy 								; save channel #
.bd99	20 03 be	jsr $be03			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bd9c	ce 2b 07	dec $072b			dec 	SNDLength 					; reduce the queue length.
.bd9f	68		pla				pla
.bda0	20 a4 bd	jsr $bda4			jsr 	SNDUpdateNote 				; update channel A
.bda3					_SNDCCExit:
.bda3	60		rts				rts
.bda4					SNDUpdateNote:
.bda4	aa		tax				tax 								; so we can access records
.bda5	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bda6	0a		asl a				asl 	a
.bda7	0a		asl a				asl 	a
.bda8	0a		asl a				asl 	a
.bda9	0a		asl a				asl 	a
.bdaa	8d 2a 07	sta $072a			sta 	SNDChannelBits
.bdad	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; are we silent
.bdb0	f0 2e		beq $bde0			beq 	_SNDUNIsSilent
.bdb2	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; push channel bits on stack
.bdb5	48		pha				pha
.bdb6	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bdb9	29 0f		and #$0f			and 	#$0F
.bdbb	0d 2a 07	ora $072a			ora 	SNDChannelBits 				; set channel bits
.bdbe	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bdc0	20 4d be	jsr $be4d			jsr 	SNDWritePorts
.bdc3	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bdc6	8d 2a 07	sta $072a			sta 	SNDChannelBits
.bdc9	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.bdcc	4e 2a 07	lsr $072a			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bdcf	6a		ror a				ror 	a
.bdd0	4e 2a 07	lsr $072a			lsr 	SNDChannelBits
.bdd3	6a		ror a				ror 	a
.bdd4	4a		lsr a				lsr 	a 							; put in bits 0-5
.bdd5	4a		lsr a				lsr 	a
.bdd6	20 4d be	jsr $be4d			jsr 	SNDWritePorts 				; write as rest of pitch register
.bdd9	68		pla				pla
.bdda	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.bddc	20 4d be	jsr $be4d			jsr 	SNDWritePorts
.bddf	60		rts				rts
.bde0					_SNDUNIsSilent:
.bde0	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; channel bits
.bde3	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.bde5	20 4d be	jsr $be4d			jsr 	SNDWritePorts 				; write to the ports
.bde8	60		rts				rts
.bde9					SNDFindNextNoteForA:
.bde9	ac 2b 07	ldy $072b			ldy 	SNDLength 					; queue size into Y
.bdec	f0 13		beq $be01			beq 	_SNDFNNFail 				; queue empty.
.bdee	a2 00		ldx #$00			ldx 	#0
.bdf0					_SNDFNNSearch:
.bdf0	dd 2c 07	cmp $072c,x			cmp 	SNDQueue,x 					; does it match the channel
.bdf3	38		sec				sec
.bdf4	f0 0c		beq $be02			beq 	_SNDFNNExit 				; if so exit with CS.
.bdf6	e8		inx				inx 								; next queue slot.
.bdf7	e8		inx				inx
.bdf8	e8		inx				inx
.bdf9	e8		inx				inx
.bdfa	e8		inx				inx
.bdfb	e8		inx				inx
.bdfc	e8		inx				inx
.bdfd	e8		inx				inx
.bdfe	88		dey				dey 								; done the whole queue
.bdff	d0 ef		bne $bdf0			bne 	_SNDFNNSearch 				; no, go back.
.be01					_SNDFNNFail:
.be01	18		clc				clc
.be02					_SNDFNNexit:
.be02	60		rts				rts
.be03					SNDDeleteXFromQueue:
.be03	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.be05	f0 09		beq $be10			beq 	_SNDDXExit
.be07	bd 34 07	lda $0734,x			lda 	SNDQueue+8,x
.be0a	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.be0d	e8		inx				inx
.be0e	80 f3		bra $be03			bra 	SNDDeleteXFromQueue
.be10					_SNDDXExit:
.be10	60		rts				rts
.072a					SNDChannelBits:
>072a							.fill 	1
.be11					SNDQueueRequest:
.be11	86 36		stx $36				stx 	zTemp0						; save queue address
.be13	84 37		sty $37				sty 	zTemp0+1
.be15	ae 2b 07	ldx $072b			ldx 	SNDLength 					; queue is full, can't take any more.
.be18	e0 20		cpx #$20			cpx 	#SNDQueueSize
.be1a	f0 21		beq $be3d			beq 	_SNDQRExit
.be1c	29 03		and #$03			and 	#3	 						; channel # and push on stack
.be1e	48		pha				pha
.be1f	8a		txa				txa  								; get offset in queue buffer/
.be20	0a		asl a				asl 	a
.be21	0a		asl a				asl 	a
.be22	0a		asl a				asl 	a
.be23	aa		tax				tax
.be24	68		pla				pla 								; get back and push again
.be25	48		pha				pha
.be26	9d 2c 07	sta $072c,x			sta 	SNDQueue+0,x 				; save the channel #
.be29	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.be2b					_SNDQCopy:
.be2b	b1 36		lda ($36),y			lda 	(zTemp0),y
.be2d	e8		inx				inx
.be2e	c8		iny				iny
.be2f	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.be32	c0 06		cpy #$06			cpy 	#6
.be34	d0 f5		bne $be2b			bne 	_SNDQCopy
.be36	ee 2b 07	inc $072b			inc 	SNDLength 					; bump queue length.
.be39	68		pla				pla 								; get channel # back
.be3a	20 65 bd	jsr $bd65			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.be3d					_SNDQRExit:
.be3d	60		rts				rts
.be3e					SNDSilenceChannel:
.be3e	aa		tax				tax 								; zero time left.
.be3f	9e 38 08	stz $0838,x			stz 	SNDTimeLeft,x
.be42	0a		asl a				asl 	a 							; shift into position
.be43	0a		asl a				asl 	a
.be44	0a		asl a				asl 	a
.be45	0a		asl a				asl 	a
.be46	0a		asl a				asl 	a
.be47	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.be49	20 4d be	jsr $be4d			jsr 	SNDWritePorts
.be4c	60		rts				rts
.be4d					SNDWritePorts:
.be4d	da		phx				phx 								; save X
.be4e	a6 01		ldx $01				ldx 	1 							; save I/O status
.be50	64 01		stz $01				stz 	1 							; access I/O page 0
.be52	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.be55	8d 10 d6	sta $d610			sta 	$D610
.be58	86 01		stx $01				stx 	1 							; restore I/O
.be5a	fa		plx				plx 								; restore X
.be5b	60		rts				rts
.be5c					Export_SNDCommand:
.be5c	da		phx				phx 								; save XY
.be5d	5a		phy				phy
.be5e	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.be60	f0 1d		beq $be7f			beq 	_SNDInitialise
.be62	90 28		bcc $be8c			bcc 	_SNDExit
.be64	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.be66	f0 17		beq $be7f			beq 	_SNDSilence
.be68	b0 22		bcs $be8c			bcs 	_SNDExit
.be6a	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.be6c	b0 09		bcs $be77			bcs 	_SNDQueryPlay
.be6e	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.be70	b0 1a		bcs $be8c			bcs 	_SNDExit
.be72	20 11 be	jsr $be11			jsr 	SNDQueueRequest
.be75	80 15		bra $be8c			bra 	_SNDExit
.be77					_SNDQueryPlay:
.be77	29 03		and #$03			and 	#3 							; get channel #
.be79	aa		tax				tax
.be7a	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.be7d	80 0d		bra $be8c			bra 	_SNDExit
.be7f					_SNDInitialise:
.be7f					_SNDSilence:
.be7f	9c 2b 07	stz $072b			stz 	SNDLength 					; empty the queue.
.be82	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.be84					_SNDSilenceLoop:
.be84	48		pha				pha
.be85	20 3e be	jsr $be3e			jsr 	SNDSilenceChannel
.be88	68		pla				pla
.be89	3a		dec a				dec 	a
.be8a	10 f8		bpl $be84			bpl 	_SNDSilenceLoop
.be8c					_SNDExit:
.be8c	7a		ply				ply
.be8d	fa		plx				plx
.be8e	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.072b					SNDLength:
>072b							.fill 	1
.072c					SNDQueue:
>072c							.fill 	SNDQueueSize * 8
.082c					SNDPitchLow:
>082c							.fill 	4
.0830					SNDPitchHigh:
>0830							.fill 	4
.0834					SNDVolume:
>0834							.fill 	4
.0838					SNDTimeLeft:
>0838							.fill 	4
.083c					SNDAdjustLow:
>083c							.fill 	4
.0840					SNDAdjustHigh:
>0840							.fill 	4
.be8f					Export_SNDUpdate:
.be8f					PagedSNDUpdate:
.be8f	ad 38 08	lda $0838			lda 	SNDTimeLeft+0 				; look at time remaining
.be92	f0 05		beq $be99			beq 	_SNDUNot0 					; not playing
.be94	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.be96	20 b8 be	jsr $beb8			jsr 	SNDUpdateChannel 			; update it.
.be99					_SNDUNot0:
.be99	ad 39 08	lda $0839			lda 	SNDTimeLeft+1
.be9c	f0 05		beq $bea3			beq 	_SNDUNot1
.be9e	a2 01		ldx #$01			ldx 	#1
.bea0	20 b8 be	jsr $beb8			jsr 	SNDUpdateChannel
.bea3					_SNDUNot1:
.bea3	ad 3a 08	lda $083a			lda 	SNDTimeLeft+2
.bea6	f0 05		beq $bead			beq 	_SNDUNot2
.bea8	a2 02		ldx #$02			ldx 	#2
.beaa	20 b8 be	jsr $beb8			jsr 	SNDUpdateChannel
.bead					_SNDUNot2:
.bead	ad 3b 08	lda $083b			lda 	SNDTimeLeft+3
.beb0	f0 05		beq $beb7			beq 	_SNDUNot3
.beb2	a2 03		ldx #$03			ldx 	#3
.beb4	20 b8 be	jsr $beb8			jsr 	SNDUpdateChannel
.beb7					_SNDUNot3:
.beb7	60		rts				rts
.beb8					SNDUpdateChannel:
.beb8	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.beba	f0 2c		beq $bee8			beq 	_SNDUCExit
.bebc	3a		dec a				dec 	a 							; decrement and update timer
.bebd	9d 38 08	sta $0838,x			sta 	SNDTimeLeft,x
.bec0	f0 1d		beq $bedf			beq 	_SNDUCUpdate 				; if zero, silence channel
.bec2	bd 3c 08	lda $083c,x			lda 	SNDAdjustLow,x 				; adjust ?
.bec5	1d 40 08	ora $0840,x			ora 	SNDAdjustHigh,x
.bec8	f0 1e		beq $bee8			beq 	_SNDUCExit 					; if zero carry on at current tone.
.beca	18		clc				clc 								; add adjust, forcing into a 10 bit range
.becb	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.bece	7d 3c 08	adc $083c,x			adc 	SNDAdjustLow,x
.bed1	9d 2c 08	sta $082c,x			sta 	SNDPitchLow,x
.bed4	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x
.bed7	7d 40 08	adc $0840,x			adc 	SNDAdjustHigh,x
.beda	29 03		and #$03			and 	#3
.bedc	9d 30 08	sta $0830,x			sta 	SNDPitchHigh,x
.bedf					_SNDUCUpdate:
.bedf	8a		txa				txa 								; which channel.
.bee0	48		pha				pha
.bee1	20 a4 bd	jsr $bda4			jsr 	SNDUpdateNote 				; update the current note
.bee4	68		pla				pla
.bee5	20 65 bd	jsr $bd65			jsr 	SNDCheckChannel 			; more to do ?
.bee8					_SNDUCExit:
.bee8	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
