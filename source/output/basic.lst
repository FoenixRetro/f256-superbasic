
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$84000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Sun Dec 11 13:04:20 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$84000					 BASIC_ADDRESS=$84000
=$28000					 SOURCE_ADDRESS=$28000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	253
.0627					numberBuffer:
>0627							.fill 	34
.0649					decimalBuffer:
>0649							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23
=24					ERRID_ARRAYDEC = 24

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_DEEKLPAREN                       = $87; $87 DEEK(
=$88					KWD_EVENTLPAREN                      = $88; $88 EVENT(
=$89					KWD_FALSE                            = $89; $89 FALSE
=$8a					KWD_FRACLPAREN                       = $8a; $8a FRAC(
=$8b					KWD_HITLPAREN                        = $8b; $8b HIT(
=$8c					KWD_INTLPAREN                        = $8c; $8c INT(
=$8d					KWD_ISVALLPAREN                      = $8d; $8d ISVAL(
=$8e					KWD_JOYBLPAREN                       = $8e; $8e JOYB(
=$8f					KWD_JOYXLPAREN                       = $8f; $8f JOYX(
=$90					KWD_JOYYLPAREN                       = $90; $90 JOYY(
=$91					KWD_LEFTDOLLARLPAREN                 = $91; $91 LEFT$(
=$92					KWD_LENLPAREN                        = $92; $92 LEN(
=$93					KWD_MAXLPAREN                        = $93; $93 MAX(
=$94					KWD_MIDDOLLARLPAREN                  = $94; $94 MID$(
=$95					KWD_MINLPAREN                        = $95; $95 MIN(
=$96					KWD_NOTLPAREN                        = $96; $96 NOT(
=$97					KWD_PEEKLPAREN                       = $97; $97 PEEK(
=$98					KWD_PLAYINGLPAREN                    = $98; $98 PLAYING(
=$99					KWD_RANDOMLPAREN                     = $99; $99 RANDOM(
=$9a					KWD_RIGHTDOLLARLPAREN                = $9a; $9a RIGHT$(
=$9b					KWD_RNDLPAREN                        = $9b; $9b RND(
=$9c					KWD_SGNLPAREN                        = $9c; $9c SGN(
=$9d					KWD_SPCLPAREN                        = $9d; $9d SPC(
=$9e					KWD_STRDOLLARLPAREN                  = $9e; $9e STR$(
=$9f					KWD_TIMERLPAREN                      = $9f; $9f TIMER(
=$a0					KWD_TRUE                             = $a0; $a0 TRUE
=$a1					KWD_VALLPAREN                        = $a1; $a1 VAL(
=$a2					KWD_FOR                              = $a2; $a2 FOR
=$a3					KWD_IF                               = $a3; $a3 IF
=$a4					KWD_PROC                             = $a4; $a4 PROC
=$a5					KWD_REPEAT                           = $a5; $a5 REPEAT
=$a6					KWD_WHILE                            = $a6; $a6 WHILE
=$a7					KWD_ENDIF                            = $a7; $a7 ENDIF
=$a8					KWD_ENDPROC                          = $a8; $a8 ENDPROC
=$a9					KWD_NEXT                             = $a9; $a9 NEXT
=$aa					KWD_THEN                             = $aa; $aa THEN
=$ab					KWD_UNTIL                            = $ab; $ab UNTIL
=$ac					KWD_WEND                             = $ac; $ac WEND
=$ad					KWD_BY                               = $ad; $ad BY
=$ae					KWD_CALL                             = $ae; $ae CALL
=$af					KWD_CIRCLE                           = $af; $af CIRCLE
=$b0					KWD_CLEAR                            = $b0; $b0 CLEAR
=$b1					KWD_CLS                              = $b1; $b1 CLS
=$b2					KWD_COLOR                            = $b2; $b2 COLOR
=$b3					KWD_COLOUR                           = $b3; $b3 COLOUR
=$b4					KWD_DATA                             = $b4; $b4 DATA
=$b5					KWD_DIM                              = $b5; $b5 DIM
=$b6					KWD_DOKE                             = $b6; $b6 DOKE
=$b7					KWD_DOWNTO                           = $b7; $b7 DOWNTO
=$b8					KWD_ELSE                             = $b8; $b8 ELSE
=$b9					KWD_FROM                             = $b9; $b9 FROM
=$ba					KWD_GFX                              = $ba; $ba GFX
=$bb					KWD_GOSUB                            = $bb; $bb GOSUB
=$bc					KWD_GOTO                             = $bc; $bc GOTO
=$bd					KWD_HERE                             = $bd; $bd HERE
=$be					KWD_IMAGE                            = $be; $be IMAGE
=$bf					KWD_INPUT                            = $bf; $bf INPUT
=$c0					KWD_LET                              = $c0; $c0 LET
=$c1					KWD_LINE                             = $c1; $c1 LINE
=$c2					KWD_LOCAL                            = $c2; $c2 LOCAL
=$c3					KWD_OFF                              = $c3; $c3 OFF
=$c4					KWD_ON                               = $c4; $c4 ON
=$c5					KWD_OUTLINE                          = $c5; $c5 OUTLINE
=$c6					KWD_PALETTE                          = $c6; $c6 PALETTE
=$c7					KWD_PLOT                             = $c7; $c7 PLOT
=$c8					KWD_POKE                             = $c8; $c8 POKE
=$c9					KWD_PRINT                            = $c9; $c9 PRINT
=$ca					KWD_READ                             = $ca; $ca READ
=$cb					KWD_RECT                             = $cb; $cb RECT
=$cc					KWD_REM                              = $cc; $cc REM
=$cd					KWD_RETURN                           = $cd; $cd RETURN
=$ce					KWD_SOLID                            = $ce; $ce SOLID
=$cf					KWD_SOUND                            = $cf; $cf SOUND
=$d0					KWD_SPRITE                           = $d0; $d0 SPRITE
=$d1					KWD_TEXT                             = $d1; $d1 TEXT
=$d2					KWD_TO                               = $d2; $d2 TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a2					KWC_FIRST_STRUCTURE = $a2
=$a7					KWC_FIRST_STRUCTURE_DEC = $a7
=$ac					KWC_LAST_STRUCTURE = $ac
=$83					KWC_FIRST_UNARY = $83
=$a1					KWC_LAST_UNARY = $a1

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c fc a7	jmp $a7fc		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c 95 aa	jmp $aa95		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c cb aa	jmp $aacb		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c f1 aa	jmp $aaf1		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c f4 aa	jmp $aaf4		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c ab a9	jmp $a9ab		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c 8f ab	jmp $ab8f		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 74 be	jmp $be74		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c a7 be	jmp $bea7		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 6a b8	jmp $b86a		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c fe ba	jmp $bafe		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.8029	09 80		ora #$80			ora 	#$80
.802b	85 00		sta $00				sta 	0
.802d	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.8030	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.8032	aa		tax				tax
.8033	a8		tay				tay
.8034	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.8037	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8039	20 18 80	jsr $8018			jsr 	SNDCommand
.803c	a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.803e	a9 4c		lda #$4c			lda 	#Prompt & $FF
.8040	20 54 8f	jsr $8f54			jsr 	PrintStringXA
.8043	20 31 8a	jsr $8a31			jsr 	NewProgram 					; erase current program
.8046	4c da 83	jmp $83da			jmp 	WarmStart					; make same size.
.8049	4c da 83	jmp $83da			jmp 	WarmStart
>804c	36 35 30 32 20 53 75 70		Prompt:	.text 	"6502 SuperBASIC ("
>8054	65 72 42 41 53 49 43 20 28
>805d	31 36						.text 	"16"
>805f	6b 29 0d					.text 	"k)",13
>8062	43 6f 70 79 72 69 67 68				.text 	"Copyright 2022 Paul Robson",13
>806a	74 20 32 30 32 32 20 50 61 75 6c 20 52 6f 62 73
>807a	6f 6e 0d
>807d	50 61 75 6c 40 52 6f 62				.text  	"Paul@Robsons.org.uk",13
>8085	73 6f 6e 73 2e 6f 72 67 2e 75 6b 0d
>8091	46 32 35 36 20					.text "F256 "

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8096	41 6c 70 68 61 20 31 33			.text "Alpha 13 built 08-Dec-22. "
>809e	20 62 75 69 6c 74 20 30 38 2d 44 65 63 2d 32 32
>80ae	2e 20

;******  Return to file: ./common/aa.system/00start.asm

>80b0	0d						.byte  	13
>80b1	0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.80b4					AssembleGroup1:
.80b4	a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.80b6	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.80b9	80 02		bra $80bd			bra 	AsmGroup12
.80bb					AssembleGroup2:
.80bb	a9 00		lda #$00			lda 	#$00 						; flag for group 2
.80bd					AsmGroup12:
.80bd	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.80c0	68		pla				pla 								; pop the return address to access the information following.
.80c1	fa		plx				plx
.80c2	20 49 81	jsr $8149			jsr 	AccessParameters 			; get opcode and save as base
.80c5	8d 24 04	sta $0424			sta 	BaseOpcode
.80c8	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.80cb	d0 08		bne $80d5			bne 	_AG12HaveMask
.80cd	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.80cf	20 51 81	jsr $8151			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.80d2	8d 25 04	sta $0425			sta 	ModeMask
.80d5					_AG12HaveMask:
.80d5	20 85 82	jsr $8285			jsr 	TypeAndCalculateOperand 	; get zero page type
.80d8	da		phx				phx 								; save found address mode
.80d9	20 b5 81	jsr $81b5			jsr 	AssembleModeX
.80dc	fa		plx				plx  								; restore address mode
.80dd	b0 0b		bcs $80ea			bcs 	_AG12Exit
.80df	20 eb 80	jsr $80eb			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.80e2	20 b5 81	jsr $81b5			jsr 	AssembleModeX
.80e5	b0 03		bcs $80ea			bcs 	_AG12Exit
.80e7	4c a0 9f	jmp $9fa0			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80ea					_AG12Exit:
.80ea	60		rts				rts
.80eb					PromoteToAbsolute:
.80eb	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80ed	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80ef	f0 19		beq $810a			beq 	_PTADo
.80f1	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80f3	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80f5	f0 13		beq $810a			beq 	_PTADo
.80f7	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80f9	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80fb	f0 0d		beq $810a			beq 	_PTADo
.80fd	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80ff	e0 d1		cpx #$d1			cpx 	#AM_IND
.8101	f0 07		beq $810a			beq 	_PTADo
.8103	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8105	e0 c0		cpx #$c0			cpx 	#AM_INDX
.8107	f0 01		beq $810a			beq 	_PTADo
.8109	60		rts				rts
.810a					_PTADo:
.810a	aa		tax				tax
.810b	60		rts				rts
.810c					AssembleGroup3:
.810c	68		pla				pla 								; get parameters, which is just the opcode.
.810d	fa		plx				plx
.810e	20 49 81	jsr $8149			jsr 	AccessParameters 			; get and output opcode
.8111	20 61 81	jsr $8161			jsr 	AssemblerWriteByte
.8114	20 e9 82	jsr $82e9			jsr 	CalculateOperand 			; get a 16 bit operand
.8117	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.8119	38		sec				sec
.811a	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.811d	48		pha				pha 								; LSB in A
.811e	a5 60		lda $60				lda 	NSMantissa1
.8120	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.8123	aa		tax				tax 								; MSB in X
.8124	68		pla				pla
.8125	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.8126	69 7f		adc #$7f			adc 	#$7F
.8128	90 01		bcc $812b			bcc 	_AG3NoCarry
.812a	e8		inx				inx
.812b					_AG3NoCarry:
.812b	38		sec				sec 								; fix back and write out anyways.
.812c	e9 80		sbc #$80			sbc 	#$80
.812e	20 61 81	jsr $8161			jsr 	AssemblerWriteByte
.8131	e0 00		cpx #$00			cpx 	#0 							; was it in range
.8133	f0 0a		beq $813f			beq 	_AG3Exit
.8135	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.8138	29 01		and #$01			and 	#1
.813a	f0 03		beq $813f			beq 	_AG3Exit
.813c	4c a5 9f	jmp $9fa5			jmp 	RangeError 					; no, branch is out of range
.813f					_AG3Exit:
.813f	60		rts				rts
.8140					AssembleGroup4:
.8140	68		pla				pla 								; pop address
.8141	fa		plx				plx
.8142	20 49 81	jsr $8149			jsr 	AccessParameters 			; access and get first
.8145	20 61 81	jsr $8161			jsr 	AssemblerWriteByte 			; output it.
.8148	60		rts				rts
.8149					AccessParameters:
.8149	8d 21 04	sta $0421			sta 	ParamStart
.814c	8e 22 04	stx $0422			stx 	ParamStart+1
.814f	a9 01		lda #$01			lda 	#1
.8151					GetParameter:
.8151	5a		phy				phy
.8152	a8		tay				tay
.8153	ad 21 04	lda $0421			lda 	ParamStart
.8156	85 36		sta $36				sta 	zTemp0
.8158	ad 22 04	lda $0422			lda 	ParamStart+1
.815b	85 37		sta $37				sta 	zTemp0+1
.815d	b1 36		lda ($36),y			lda 	(zTemp0),y
.815f	7a		ply				ply
.8160	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.8161					AssemblerWriteByte:
.8161	48		pha			pha
.8162	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8165	29 02		and #$02		and 	#2
.8167	f0 1b		beq $8184		beq 	_AWBNoPrint
.8169	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.816c	20 9f 81	jsr $819f		jsr 	PrintHex
.816f	ad 1e 04	lda $041e		lda		AssemblerAddress
.8172	20 9f 81	jsr $819f		jsr 	PrintHex
.8175	a9 20		lda #$20		lda 	#' '
.8177	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.817a	68		pla			pla 									; print byte
.817b	48		pha			pha
.817c	20 9f 81	jsr $819f		jsr 	PrintHex
.817f	a9 0d		lda #$0d		lda 	#13
.8181	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8184					_AWBNoPrint:
.8184	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8187	85 36		sta $36			sta 	zTemp0
.8189	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.818c	f0 0e		beq $819c		beq 	_AWBRange
.818e	85 37		sta $37			sta 	zTemp0+1
.8190	68		pla			pla 									; write byte out
.8191	92 36		sta ($36)		sta 	(zTemp0)
.8193	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8196	d0 03		bne $819b		bne 	_AWBNoCarry
.8198	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.819b					_AWBNoCarry:
.819b	60		rts			rts
.819c					_AWBRange:
.819c	4c a5 9f	jmp $9fa5		jmp 	RangeError
.819f					PrintHex:
.819f	48		pha				pha
.81a0	4a		lsr a				lsr 	a
.81a1	4a		lsr a				lsr 	a
.81a2	4a		lsr a				lsr 	a
.81a3	4a		lsr a				lsr 	a
.81a4	20 a8 81	jsr $81a8			jsr 	_PrintNibble
.81a7	68		pla				pla
.81a8					_PrintNibble:
.81a8	29 0f		and #$0f			and 	#15
.81aa	c9 0a		cmp #$0a			cmp 	#10
.81ac	90 02		bcc $81b0			bcc 	_NoShift
.81ae	69 06		adc #$06			adc 	#6
.81b0					_NoShift:
.81b0	69 30		adc #$30			adc 	#48
.81b2	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.81b5					AssembleModeX:
.81b5	5a		phy				phy
.81b6	ad 23 04	lda $0423			lda 	IsGroup1
.81b9	f0 17		beq $81d2			beq 	_AMXGroup2
.81bb	8a		txa				txa 							; is it in group # 1
.81bc	29 40		and #$40			and 	#AM_ISG1
.81be	f0 4d		beq $820d			beq 	_AMXFail 				; no, give up.
.81c0	8a		txa				txa 							; get back.
.81c1	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.81c3	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.81c5	d0 22		bne $81e9			bne 	_AMXHaveInfo
.81c7	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.81ca	c9 81		cmp #$81			cmp 	#$81
.81cc	f0 3f		beq $820d			beq 	_AMXFail
.81ce	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.81d0	80 17		bra $81e9			bra 	_AMXHaveInfo 			; odd design decision there.
.81d2					_AMXGroup2:
.81d2	8a		txa				txa 							; is it in group 2 ?
.81d3	29 20		and #$20			and 	#AM_ISG2
.81d5	f0 36		beq $820d			beq 	_AMXFail 				; no, give up.
.81d7	8a		txa				txa 							; get the offset into Y
.81d8	29 1f		and #$1f			and 	#$1F
.81da	4a		lsr a				lsr 	a 						; make it 0-7.
.81db	4a		lsr a				lsr  	a
.81dc	a8		tay				tay
.81dd	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.81e0					_AMXCheckOkay:
.81e0	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.81e1	88		dey				dey
.81e2	10 fc		bpl $81e0			bpl 	_AMXCheckOkay
.81e4	90 27		bcc $820d			bcc 	_AMXFail 				; not allowed.
.81e6	8a		txa				txa  							; get mask back
.81e7	29 1f		and #$1f			and 	#$1F
.81e9					_AMXHaveInfo:
.81e9	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81eb	10 04		bpl $81f1			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81ed	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81ef	d0 1c		bne $820d			bne 	_AMXFail
.81f1					_AMXAnySize:
.81f1	18		clc				clc 							; add offset to the base opcode
.81f2	6d 24 04	adc $0424			adc 	BaseOpcode
.81f5					_AMXOutputCode:
.81f5	20 61 81	jsr $8161			jsr 	AssemblerWriteByte 		; write the opcode out.
.81f8	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.81fa	f0 0e		beq $820a			beq 	_AMXExit
.81fc	a5 58		lda $58				lda 	NSMantissa0 			; write LSB operand
.81fe	20 61 81	jsr $8161			jsr 	AssemblerWriteByte
.8201	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.8203	30 05		bmi $820a			bmi 	_AMXExit
.8205	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.8207	20 61 81	jsr $8161			jsr 	AssemblerWriteByte
.820a					_AMXExit:
.820a	7a		ply				ply
.820b	38		sec				sec
.820c	60		rts				rts
.820d					_AMXFail:
.820d	a0 00		ldy #$00			ldy 	#0
.820f					_AMXCheckOddities:
.820f	8a		txa				txa
.8210	d9 37 82	cmp $8237,y			cmp 	ExtraOpcode+2,y 		; match address mode
.8213	d0 15		bne $822a			bne 	_AMXCONext
.8215	b9 35 82	lda $8235,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.8218	cd 24 04	cmp $0424			cmp 	BaseOpcode
.821b	d0 0d		bne $822a			bne 	_AMXCONext
.821d	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.821f	10 04		bpl $8225			bpl 	_AMXCONotZero
.8221	a5 60		lda $60				lda 	NSMantissa1
.8223	d0 05		bne $822a			bne 	_AMXCONext
.8225					_AMXCONotZero:
.8225	b9 36 82	lda $8236,y			lda 	ExtraOpcode+1,y 		; get new opcode
.8228	80 cb		bra $81f5			bra 	_AMXOutputCode 			; and assemble it
.822a					_AMXCONext:
.822a	c8		iny				iny
.822b	c8		iny				iny
.822c	c8		iny				iny
.822d	b9 35 82	lda $8235,y			lda 	ExtraOpcode+0,y 		; end of table
.8230	d0 dd		bne $820f			bne 	_AMXCheckOddities
.8232					_AMXCOFail:
.8232	7a		ply				ply
.8233	18		clc				clc
.8234	60		rts				rts
.8235					ExtraOpcode:
>8235	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>8238	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>823b	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>823e	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>8241	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8244	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8247	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>824a	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>824d	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>8250	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8253	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8254					LabelHere:
.8254	c8		iny				iny 								; skip .
.8255	a2 00		ldx #$00			ldx 	#0 							; get a term
.8257	20 49 98	jsr $9849			jsr 	EvaluateTerm
.825a	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.825c	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.825e	d0 22		bne $8282			bne 	_ALType 					; otherwise typing error
.8260	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8262	85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.8264	b5 60		lda $60,x			lda 	NSMantissa1,x
.8266	85 37		sta $37				sta 	zTemp0+1
.8268	5a		phy				phy 								; copy address in (64k)
.8269	a0 01		ldy #$01			ldy 	#1
.826b	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.826e	92 36		sta ($36)			sta 	(zTemp0)
.8270	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.8273	91 36		sta ($36),y			sta 	(zTemp0),y
.8275	c8		iny				iny
.8276	a9 00		lda #$00			lda 	#0 							; zero the rest.
.8278	91 36		sta ($36),y			sta 	(zTemp0),y
.827a	c8		iny				iny
.827b	91 36		sta ($36),y			sta 	(zTemp0),y
.827d	c8		iny				iny
.827e	91 36		sta ($36),y			sta 	(zTemp0),y
.8280	7a		ply				ply
.8281	60		rts				rts
.8282					_ALType:
.8282	4c aa 9f	jmp $9faa			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8285					TypeAndCalculateOperand:
.8285	b1 30		lda ($30),y			lda 	(codePtr),y
.8287	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8289	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.828b	f0 5b		beq $82e8			beq 	_TACOExit
.828d	c9 80		cmp #$80			cmp 	#KWC_EOL
.828f	f0 57		beq $82e8			beq 	_TACOExit
.8291	c8		iny				iny
.8292	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8294	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8296	f0 51		beq $82e9			beq 	CalculateOperand
.8298	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.829a	f0 1f		beq $82bb			beq 	_TACOIndirect
.829c	88		dey				dey 								; undo get of first character
.829d	20 e9 82	jsr $82e9			jsr 	CalculateOperand 			; get operand
.82a0	b1 30		lda ($30),y			lda 	(codePtr),y
.82a2	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.82a4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.82a6	d0 40		bne $82e8			bne 	_TACOExit
.82a8	c8		iny				iny
.82a9	20 f3 82	jsr $82f3			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.82ac	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.82ae	c9 58		cmp #$58			cmp 	#'X'
.82b0	f0 36		beq $82e8			beq 	_TACOExit
.82b2	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.82b4	c9 59		cmp #$59			cmp 	#'Y'
.82b6	f0 30		beq $82e8			beq 	_TACOExit
.82b8					_TACOSyntax:
.82b8	4c a0 9f	jmp $9fa0			jmp 	SyntaxError
.82bb					_TACOIndirect:
.82bb	20 e9 82	jsr $82e9			jsr 	CalculateOperand 			; get the operand
.82be	b1 30		lda ($30),y			lda 	(codePtr),y
.82c0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.82c2	f0 17		beq $82db			beq 	_TACOIndX
.82c4	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.82c7	b1 30		lda ($30),y			lda 	(codePtr),y
.82c9	a2 d1		ldx #$d1			ldx 	#AM_IND
.82cb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.82cd	d0 19		bne $82e8			bne 	_TACOExit
.82cf	c8		iny				iny
.82d0	20 f3 82	jsr $82f3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82d3	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.82d5	d0 e1		bne $82b8			bne 	_TACOSyntax
.82d7	a2 d0		ldx #$d0			ldx 	#AM_INDY
.82d9	80 0d		bra $82e8			bra 	_TACOExit
.82db					_TACOIndX:
.82db	c8		iny				iny
.82dc	20 f3 82	jsr $82f3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82df	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82e1	d0 d5		bne $82b8			bne 	_TACOSyntax
.82e3	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket			; check )
.82e6	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82e8					_TACOExit:
.82e8	60		rts				rts
.82e9					CalculateOperand:
.82e9	48		pha				pha
.82ea	da		phx				phx
.82eb	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ed	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger
.82f0	fa		plx				plx
.82f1	68		pla				pla
.82f2	60		rts				rts
.82f3					TACOCheckXY:
.82f3	b1 30		lda ($30),y			lda 	(codePtr),y
.82f5	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82f7	c9 40		cmp #$40			cmp 	#$40
.82f9	d0 21		bne $831c			bne 	_TCXYFail
.82fb	b1 30		lda ($30),y			lda 	(codePtr),y
.82fd	18		clc				clc
.82fe	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8300	85 37		sta $37				sta 	zTemp0+1
.8302	c8		iny				iny
.8303	b1 30		lda ($30),y			lda 	(codePtr),y
.8305	c8		iny				iny
.8306	85 36		sta $36				sta 	zTemp0
.8308	5a		phy				phy 								; save position
.8309	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.830b	b1 36		lda ($36),y			lda 	(zTemp0),y
.830d	d0 0c		bne $831b			bne 	_TCXYPopFail
.830f	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.8311	b1 36		lda ($36),y			lda 	(zTemp0),y
.8313	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.8315	f0 08		beq $831f			beq 	_TCXYFound
.8317	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.8319	f0 04		beq $831f			beq 	_TCXYFound
.831b					_TCXYPopFail:
.831b	7a		ply				ply
.831c					_TCXYFail:
.831c	a9 00		lda #$00			lda 	#0
.831e	60		rts				rts
.831f					_TCXYFound:
.831f	7a		ply				ply 								; restore position
.8320	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.8322	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.8323					BackloadProgram:
.8323	20 31 8a	jsr $8a31			jsr 	NewProgram 					; does the actual NEW.
.8326	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.8328	a9 72		lda #$72			lda 	#_BLLoad & $FF
.832a	20 54 8f	jsr $8f54			jsr 	PrintStringXA
.832d	a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; start page
.832f	8d 59 06	sta $0659			sta 	BackLoadPage
.8332	a9 00		lda #$00			lda 	#(($6000) & $FF)
.8334	8d 5a 06	sta $065a			sta 	0+BackLoadPointer
.8337	a9 60		lda #$60			lda 	#(($6000) >> 8)
.8339	8d 5b 06	sta $065b			sta 	1+BackLoadPointer
.833c	a9 ff		lda #$ff			lda 	#$FF
.833e	8d fa ff	sta $fffa			sta 	$FFFA
.8341					_BPLoop:
.8341	a2 ff		ldx #$ff			ldx 	#$FF
.8343	20 87 83	jsr $8387			jsr 	BLReadByte 					; read a byte
.8346	c9 00		cmp #$00			cmp 	#0
.8348	f0 21		beq $836b			beq 	_BPExit 					; if 0 exit
.834a	30 1f		bmi $836b			bmi 	_BPExit 					; if -ve exit
.834c					_BPCopy:
.834c	e8		inx				inx  								; copy byte into the lineBuffer
.834d	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.8350	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.8353	20 87 83	jsr $8387			jsr 	BLReadByte 					; read next byte
.8356	30 0a		bmi $8362			bmi 	_BPEndLine 					; -ve = EOL
.8358	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.835a	d0 02		bne $835e			bne 	_BPNotTab
.835c	a9 20		lda #$20			lda 	#' '
.835e					_BPNotTab:
.835e	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8360	b0 ea		bcs $834c			bcs 	_BPCopy 					; until a control character, should be 13 received.
.8362					_BPEndLine:
.8362	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.8365	38		sec				sec 								; append not insert
.8366	20 fa a4	jsr $a4fa			jsr 	MemoryInsertLine 			; append to current program
.8369	80 d6		bra $8341			bra 	_BPLoop
.836b					_BPExit:
.836b	9c fa ff	stz $fffa			stz 	$FFFA
.836e	20 70 84	jsr $8470			jsr 	ClearCommand 				; clear variables etc.
.8371	60		rts				rts
.8372					_BLLoad:
>8372	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>837a	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.8387					BLReadByte:
.8387	da		phx				phx
.8388	a6 0b		ldx $0b				ldx 	8+3 						; save current mapping for $6000 in X
.838a	ad 59 06	lda $0659			lda 	BackLoadPage	 			; set current page
.838d	85 0b		sta $0b				sta 	8+3
.838f	ad 5a 06	lda $065a			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8392	85 36		sta $36				sta 	zTemp0
.8394	ad 5b 06	lda $065b			lda 	BackLoadPointer+1
.8397	85 37		sta $37				sta 	zTemp0+1
.8399	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.839b	ee 5a 06	inc $065a			inc 	BackLoadPointer 			; bump pointer
.839e	d0 0f		bne $83af			bne 	_BLNoCarry
.83a0	ee 5b 06	inc $065b			inc 	BackLoadPointer+1
.83a3	10 0a		bpl $83af			bpl 	_BLNoCarry 					; need a new page
.83a5	48		pha				pha
.83a6	a9 60		lda #$60			lda 	#$60 						; reset pointer
.83a8	8d 5b 06	sta $065b			sta 	BackLoadPointer+1
.83ab	ee 59 06	inc $0659			inc 	BackLoadPage 				; next page from source.
.83ae	68		pla				pla
.83af					_BLNoCarry:
.83af	86 0b		stx $0b				stx 	8+3 						; restore mapping, then X.
.83b1	fa		plx				plx
.83b2	c9 00		cmp #$00			cmp 	#0
.83b4	60		rts				rts
.0659					BackLoadPage:
>0659							.fill  	1
.065a					BackLoadPointer:
>065a							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.83b5					EditProgramCode:
.83b5	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; try to find the line.
.83b8	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.83bb	20 9e a5	jsr $a59e			jsr 	MemorySearch
.83be	90 05		bcc $83c5			bcc 	_EPCNoDelete 				; reached the end : don't delete
.83c0	d0 03		bne $83c5			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.83c2	20 c3 a4	jsr $a4c3			jsr 	MemoryDeleteLine 			; delete the line
.83c5					_EPCNoDelete:
.83c5	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty - we just want to delete a line.
.83c8	c9 80		cmp #$80			cmp 	#KWC_EOL
.83ca	f0 0d		beq $83d9			beq 	_EPCNoInsert
.83cc	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.83cf	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.83d2	20 9e a5	jsr $a59e			jsr 	MemorySearch
.83d5	18		clc				clc 								; insert at this point.
.83d6	20 fa a4	jsr $a4fa			jsr 	MemoryInsertLine 			; insert the line
.83d9					_EPCNoInsert:
.83d9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.83da					WarmStart:
.83da	a2 ff		ldx #$ff			ldx 	#$FF
.83dc	9a		txs				txs
.83dd	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.83df	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.83e2	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.83e5	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.83e8	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number <> 0
.83eb	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.83ee	d0 17		bne $8407			bne 	_WSEditCode 				; if so,edit code.
.83f0	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero the "offset", meaning it only runs one line.
.83f3	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.83f5	85 30		sta $30				sta 	codePtr
.83f7	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.83f9	85 31		sta $31				sta 	codePtr+1
.83fb	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.83fe	c9 80		cmp #$80			cmp 	#KWC_EOL
.8400	f0 d8		beq $83da			beq 	WarmStart
.8402	20 84 8b	jsr $8b84			jsr 	RUNCodePointerLine 			; execute that line.
.8405	80 d3		bra $83da			bra 	WarmStart
.8407					_WSEditCode:
.8407	20 b5 83	jsr $83b5			jsr 	EditProgramCode 			; edit the program code
.840a	20 70 84	jsr $8470			jsr 	ClearCommand 				; clear all variables etc.
.840d	80 cb		bra $83da			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.840f					AssembleCommand:
.840f	a2 00		ldx #$00			ldx 	#0
.8411	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger 		; start address
.8414	a5 58		lda $58				lda 	NSMantissa0
.8416	8d 1e 04	sta $041e			sta 	AssemblerAddress
.8419	a5 60		lda $60				lda 	NSMantissa1
.841b	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.841e	20 ea 8e	jsr $8eea			jsr 	CheckComma
.8421	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; options 0-3
.8424	a5 58		lda $58				lda 	NSMantissa0
.8426	8d 20 04	sta $0420			sta 	AssemblerControl
.8429	60		rts				rts
.842a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.842b					AssertCommand:
.842b	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.842d	20 8f 9d	jsr $9d8f			jsr 	EvaluateInteger 			; the assert test
.8430	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; exit if result is non zero.
.8433	d0 05		bne $843a			bne 	_ACExit
.8435	a9 0a		lda #$0a		lda	#10
.8437	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.843a					_ACExit:
.843a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.843b					CallCommand:
.843b	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.843d	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger
.8440					_CCClear
.8440	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.8441	20 22 9e	jsr $9e22			jsr 	NSMSetZero 					; these are optional sequentially.
.8444	e0 04		cpx #$04			cpx 	#4
.8446	d0 f8		bne $8440			bne 	_CCClear
.8448	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.844a					_CCCParam:
.844a	b1 30		lda ($30),y			lda 	(codePtr),y
.844c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.844e	d0 09		bne $8459			bne 	_CCCRun6502
.8450	c8		iny				iny 								; skip comma
.8451	e8		inx				inx	 								; next level
.8452	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; get A/X/Y
.8455	e0 03		cpx #$03			cpx 	#3
.8457	90 f1		bcc $844a			bcc 	_CCCParam 					; done all 3 ?
.8459					_CCCRun6502:
.8459	5a		phy				phy 								; save position
.845a	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.845c	85 37		sta $37				sta 	zTemp0+1
.845e	a5 58		lda $58				lda 	NSMantissa0
.8460	85 36		sta $36				sta 	zTemp0
.8462	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.8464	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.8466	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.8468	20 6d 84	jsr $846d			jsr 	_CCCZTemp0 					; call zTemp0
.846b	7a		ply				ply 								; restore position and exit
.846c	60		rts				rts
.846d					_CCCZTemp0:
.846d	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.8470					ClearCommand:
.8470	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8472	85 36		sta $36				sta 	0+zTemp0
.8474	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.8476	85 37		sta $37				sta 	1+zTemp0
.8478					_ClearZeroLoop:
.8478	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.847a	f0 24		beq $84a0			beq 	_ClearZeroEnd
.847c	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.847e	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8480					_ClearOneVariable:
.8480	91 36		sta ($36),y			sta 	(zTemp0),y
.8482	c8		iny				iny
.8483	c0 08		cpy #$08			cpy 	#8
.8485	d0 f9		bne $8480			bne 	_ClearOneVariable
.8487	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8489	b1 36		lda ($36),y			lda 	(zTemp0),y
.848b	c9 18		cmp #$18			cmp 	#NSTProcedure
.848d	d0 04		bne $8493			bne 	_ClearNotProcedure
.848f	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8491	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8493					_ClearNotProcedure:
.8493	18		clc				clc 								; go to the next variable
.8494	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8496	65 36		adc $36				adc 	zTemp0
.8498	85 36		sta $36				sta 	zTemp0
.849a	90 dc		bcc $8478			bcc 	_ClearZeroLoop
.849c	e6 37		inc $37				inc 	zTemp0+1
.849e	80 d8		bra $8478			bra 	_ClearZeroLoop
.84a0					_ClearZeroEnd:
.84a0	18		clc				clc
.84a1	a5 36		lda $36				lda 	zTemp0
.84a3	69 01		adc #$01			adc 	#1
.84a5	8d 0c 04	sta $040c			sta 	lowMemPtr
.84a8	a5 37		lda $37				lda 	zTemp0+1
.84aa	69 00		adc #$00			adc 	#0
.84ac	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.84af	20 2a a7	jsr $a72a			jsr 	StackReset
.84b2	20 90 a7	jsr $a790			jsr 	StringSystemInitialise
.84b5	20 eb 8d	jsr $8deb			jsr 	ProcedureScan
.84b8	20 33 8b	jsr $8b33			jsr 	Command_Restore
.84bb	9c 1e 04	stz $041e			stz 	AssemblerAddress
.84be	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.84c1	9c 20 04	stz $0420			stz 	AssemblerControl
.84c4	20 35 9a	jsr $9a35			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.84c7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.84c8					ClearScreen:
.84c8	5a		phy				phy
.84c9	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.84cb	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.84ce	7a		ply				ply
.84cf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.84d0					Command_Data:
.84d0	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.84d2	a2 80		ldx #$80			ldx 	#KWC_EOL
.84d4	20 3d 8e	jsr $8e3d			jsr 	ScanForward
.84d7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.84d8					DimCommand:
.84d8	b1 30		lda ($30),y			lda 	(codePtr),y
.84da	29 c0		and #$c0			and 	#$C0
.84dc	c9 40		cmp #$40			cmp 	#$40
.84de	d0 7a		bne $855a			bne 	_DCSyntax 				; n o, error.
.84e0	b1 30		lda ($30),y			lda 	(codePtr),y
.84e2	18		clc				clc
.84e3	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.84e5	85 3f		sta $3f				sta 	zaTemp+1
.84e7	c8		iny				iny
.84e8	b1 30		lda ($30),y			lda 	(codePtr),y
.84ea	c8		iny				iny
.84eb	85 3e		sta $3e				sta 	zaTemp
.84ed	5a		phy				phy
.84ee	a0 02		ldy #$02			ldy 	#2 						; read type byte
.84f0	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84f2	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.84f4	c9 18		cmp #$18			cmp 	#NSTProcedure
.84f6	f0 62		beq $855a			beq 	_DCSyntax
.84f8	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.84fa	29 04		and #$04			and 	#NSBIsArray
.84fc	f0 64		beq $8562			beq 	_DCType
.84fe	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8500	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8502	d0 59		bne $855d			bne 	_DCRedefine
.8504	7a		ply				ply
.8505	20 65 85	jsr $8565			jsr 	_DCGetSize 				; get array size, check it.
.8508	5a		phy				phy
.8509	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.850b	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.850d	7a		ply				ply 							; is there a second (e.g. ,x)
.850e	b1 30		lda ($30),y			lda 	(codePtr),y
.8510	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8512	d0 0a		bne $851e			bne 	_DCOneDimension
.8514	c8		iny				iny 							; skip comma
.8515	20 65 85	jsr $8565			jsr 	_DCGetSize 				; get 2nd array size
.8518	5a		phy				phy
.8519	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.851b	91 3e		sta ($3e),y			sta 	(zaTemp),y
.851d	7a		ply				ply
.851e					_DCOneDimension:
.851e	5a		phy				phy 							; save position
.851f	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.8521	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8523	aa		tax				tax
.8524	c8		iny				iny
.8525	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8527	e8		inx				inx 							; bump them.
.8528	1a		inc a				inc 	a
.8529	20 cd 9d	jsr $9dcd			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.852c	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.852e	29 e0		and #$e0			and 	#$E0
.8530	d0 23		bne $8555			bne 	_DCSize
.8532	a0 02		ldy #$02			ldy 	#2 						; get base type
.8534	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8536	20 73 85	jsr $8573			jsr 	ScaleByBaseType 		; scale by base type
.8539	a5 36		lda $36				lda 	zTemp0
.853b	a6 37		ldx $37				ldx 	zTemp0+1
.853d	20 f7 99	jsr $99f7			jsr 	AllocateXABytes 		; allocate memory
.8540	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.8542	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8544	c8		iny				iny
.8545	8a		txa				txa
.8546	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8548	7a		ply				ply 							; get position back
.8549	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket 		; check )
.854c	b1 30		lda ($30),y			lda 	(codePtr),y
.854e	c8		iny				iny 							; consume in case
.854f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.8551	f0 85		beq $84d8			beq 	DimCommand
.8553	88		dey				dey 							; undo consume
.8554	60		rts				rts
.8555					_DCSize:
.8555	a9 16		lda #$16		lda	#22
.8557	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.855a					_DCSyntax:
.855a	4c a0 9f	jmp $9fa0			jmp 	SyntaxError
.855d					_DCRedefine:
.855d	a9 15		lda #$15		lda	#21
.855f	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.8562					_DCType:
.8562	4c aa 9f	jmp $9faa			jmp 	TypeError
.8565					_DCGetSize:
.8565	a2 00		ldx #$00			ldx 	#0 						; get first index.
.8567	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 	; get array dimension
.856a	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.856c	f0 e7		beq $8555			beq 	_DCSize
.856e	c9 fe		cmp #$fe			cmp 	#254
.8570	f0 e3		beq $8555			beq 	_DCSize
.8572	60		rts				rts
.8573					ScaleByBaseType:
.8573	29 10		and #$10			and 	#NSBIsString 			; is it string
.8575	d0 19		bne $8590			bne 	_SBBTString
.8577	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8579	48		pha				pha
.857a	a5 36		lda $36				lda 	zTemp0
.857c	48		pha				pha
.857d	06 36		asl $36				asl 	zTemp0 					; x 2
.857f	26 37		rol $37				rol 	zTemp0+1
.8581	06 36		asl $36				asl 	zTemp0 					; x 4
.8583	26 37		rol $37				rol 	zTemp0+1
.8585	68		pla				pla 							; add stacked value = x 5
.8586	65 36		adc $36				adc 	zTemp0
.8588	85 36		sta $36				sta 	zTemp0
.858a	68		pla				pla
.858b	65 37		adc $37				adc 	zTemp0+1
.858d	85 37		sta $37				sta 	zTemp0+1
.858f	60		rts				rts
.8590					_SBBTString:
.8590	06 36		asl $36				asl 	zTemp0
.8592	26 37		rol $37				rol 	zTemp0+1
.8594	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dokepoke.asm

.8595					PokeCommand:
.8595	18		clc				clc
.8596	80 01		bra $8599			bra 	DPCommand
.8598					DokeCommand:
.8598	38		sec				sec
.8599					DPCommand:
.8599	08		php				php									; save on stack, CS = Doke, CC = Poke
.859a	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.859c	20 a2 9d	jsr $9da2			jsr		Evaluate16BitInteger 		; address
.859f	20 ea 8e	jsr $8eea			jsr 	CheckComma
.85a2	e8		inx				inx
.85a3	20 a2 9d	jsr $9da2			jsr		Evaluate16BitInteger 		; data
.85a6	a5 58		lda $58				lda 	NSMantissa0 				; copy address
.85a8	85 36		sta $36				sta 	zTemp0
.85aa	a5 60		lda $60				lda 	NSMantissa1
.85ac	85 37		sta $37				sta 	zTemp0+1
.85ae	a5 59		lda $59				lda 	NSMantissa0+1 				; low byte
.85b0	92 36		sta ($36)			sta 	(zTemp0)
.85b2	28		plp				plp 								; done if POKE
.85b3	90 08		bcc $85bd			bcc 	_DPExit
.85b5	5a		phy				phy 								; write high byte out.
.85b6	a0 01		ldy #$01			ldy 	#1
.85b8	a5 61		lda $61				lda 	NSMantissa1+1
.85ba	91 36		sta ($36),y			sta 	(zTemp0),y
.85bc	7a		ply				ply
.85bd					_DPExit:
.85bd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.85be					EndCommand:
.85be	4c da 83	jmp $83da			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.85c1					ForCommand:
.85c1	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.85c3	20 c4 a6	jsr $a6c4			jsr 	StackOpen
.85c6	a2 00		ldx #$00			ldx 	#0
.85c8	20 49 98	jsr $9849			jsr 	EvaluateTerm
.85cb	b5 50		lda $50,x			lda 	NSStatus,x
.85cd	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.85cf	d0 47		bne $8618			bne		_FCError
.85d1	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.85d3	20 f2 8e	jsr $8ef2			jsr 	CheckNextA
.85d6	e8		inx				inx
.85d7	20 8f 9d	jsr $9d8f			jsr 	EvaluateInteger 			; <from> in +1
.85da	b1 30		lda ($30),y			lda 	(codePtr),y
.85dc	c8		iny				iny 								; consume it
.85dd	48		pha				pha 								; save on stack for later
.85de	c9 b7		cmp #$b7			cmp 	#KWD_DOWNTO
.85e0	f0 04		beq $85e6			beq 	_FCNoSyntax
.85e2	c9 d2		cmp #$d2			cmp 	#KWD_TO
.85e4	d0 35		bne $861b			bne 	_FCSyntaxError
.85e6					_FCNoSyntax:
.85e6	e8		inx				inx
.85e7	20 8f 9d	jsr $9d8f			jsr 	EvaluateInteger
.85ea	20 09 a7	jsr $a709			jsr 	STKSaveCodePosition 		; save loop back position
.85ed	68		pla				pla 								; restore DOWNTO or TO
.85ee	5a		phy				phy 								; save Y on the stack
.85ef	49 b7		eor #$b7			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.85f1	f0 02		beq $85f5			beq 	_FCNotDownTo
.85f3	a9 02		lda #$02			lda 	#2
.85f5					_FCNotDownTo:
.85f5	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.85f6	a0 10		ldy #$10			ldy 	#16
.85f8	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.85fa	a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.85fc	a5 58		lda $58				lda 	NSMantissa0
.85fe	91 34		sta ($34),y			sta 	(basicStack),y
.8600	a5 60		lda $60				lda 	NSMantissa1
.8602	c8		iny				iny
.8603	91 34		sta ($34),y			sta 	(basicStack),y
.8605	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8607	a2 01		ldx #$01			ldx 	#1
.8609	20 1e 86	jsr $861e			jsr 	FCIntegerToStack
.860c	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.860e	a2 02		ldx #$02			ldx 	#2
.8610	20 1e 86	jsr $861e			jsr 	FCIntegerToStack
.8613	20 39 86	jsr $8639			jsr 	CopyIndexToReference
.8616	7a		ply				ply 								; restore position
.8617	60		rts				rts
.8618					_FCError:
.8618	4c aa 9f	jmp $9faa			jmp 	TypeError
.861b					_FCSyntaxError:
.861b	4c a0 9f	jmp $9fa0			jmp 	SyntaxError
.861e					FCIntegerToStack:
.861e	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8620	10 03		bpl $8625			bpl	 	_FCNotNegative
.8622	20 eb 9d	jsr $9deb			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8625					_FCNotNegative:
.8625	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8627	91 34		sta ($34),y			sta 	(basicStack),y
.8629	c8		iny				iny
.862a	b5 60		lda $60,x			lda 	NSMantissa1,x
.862c	91 34		sta ($34),y			sta 	(basicStack),y
.862e	c8		iny				iny
.862f	b5 68		lda $68,x			lda 	NSMantissa2,x
.8631	91 34		sta ($34),y			sta 	(basicStack),y
.8633	c8		iny				iny
.8634	b5 70		lda $70,x			lda 	NSMantissa3,x
.8636	91 34		sta ($34),y			sta 	(basicStack),y
.8638	60		rts				rts
.8639					CopyIndexToReference:
.8639	5a		phy				phy
.863a	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.863c	38		sec				sec 								; (because we copy from offset 8)
.863d	b1 34		lda ($34),y			lda 	(basicStack),y
.863f	e9 08		sbc #$08			sbc 	#8
.8641	85 36		sta $36				sta 	zTemp0
.8643	c8		iny				iny
.8644	b1 34		lda ($34),y			lda 	(basicStack),y
.8646	e9 00		sbc #$00			sbc 	#0
.8648	85 37		sta $37				sta 	zTemp0+1
.864a	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.864c	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.864e	b1 34		lda ($34),y			lda 	(basicStack),y
.8650	0a		asl a				asl 	a 							; into carry
.8651	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8653	90 14		bcc $8669			bcc 	_CITRNormal
.8655	38		sec				sec
.8656					_CITRNegative:
.8656	a9 00		lda #$00			lda 	#0
.8658	f1 34		sbc ($34),y			sbc 	(basicStack),y
.865a	91 36		sta ($36),y			sta 	(zTemp0),y
.865c	c8		iny				iny
.865d	ca		dex				dex
.865e	d0 f6		bne $8656			bne 	_CITRNegative
.8660	88		dey				dey 								; look at MSB of mantissa
.8661	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.8663	09 80		ora #$80			ora 	#$80
.8665	91 36		sta ($36),y			sta 	(zTemp0),y
.8667	7a		ply				ply
.8668	60		rts				rts
.8669					_CITRNormal:
.8669	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.866b	91 36		sta ($36),y			sta 	(zTemp0),y
.866d	c8		iny				iny
.866e	ca		dex				dex
.866f	d0 f8		bne $8669			bne 	_CITRNormal
.8671	7a		ply				ply 								; and exit.
.8672	60		rts				rts
.8673					NextCommand:
.8673	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8675	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.8677	20 f1 a6	jsr $a6f1			jsr 	StackCheckFrame
.867a	5a		phy				phy
.867b	a0 10		ldy #$10			ldy 	#16 						; get the step count
.867d	b1 34		lda ($34),y			lda 	(basicStack),y
.867f	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.8681	30 02		bmi $8685			bmi 	_NCStepNeg
.8683	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8685					_NCStepNeg:
.8685	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8687	a2 04		ldx #$04			ldx 	#4 							; count to bump
.8689	18		clc				clc
.868a					_NCBump:
.868a	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.868c	91 34		sta ($34),y			sta 	(basicStack),y
.868e	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8690	c8		iny				iny 								; next byte
.8691	ca		dex				dex 								; do four times
.8692	d0 f6		bne $868a			bne 	_NCBump
.8694	20 39 86	jsr $8639			jsr		CopyIndexToReference		; copy it to the reference variable.
.8697	a0 10		ldy #$10			ldy 	#16 						; get step count again
.8699	b1 34		lda ($34),y			lda 	(basicStack),y
.869b	0a		asl a				asl 	a 							; sign bit to carry
.869c	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.869e	85 38		sta $38				sta 	zTemp1
.86a0	90 02		bcc $86a4			bcc 	_NCCompRev 					; use if step is +ve
.86a2	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.86a4					_NCCompRev:
.86a4	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.86a6	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.86a8	85 39		sta $39				sta 	zTemp1+1
.86aa	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.86ac	38		sec				sec
.86ad					_NCCompare:
.86ad	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.86af	b1 34		lda ($34),y			lda 	(basicStack),y
.86b1	a4 39		ldy $39				ldy 	zTemp1+1
.86b3	f1 34		sbc ($34),y			sbc 	(basicStack),y
.86b5	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.86b7	e6 39		inc $39				inc 	zTemp1+1
.86b9	ca		dex				dex 								; do it 4 times.
.86ba	d0 f1		bne $86ad			bne 	_NCCompare
.86bc	50 02		bvc $86c0			bvc 	_NCNoOverflow 				; convert to signed comparison
.86be	49 80		eor #$80			eor 	#$80
.86c0					_NCNoOverflow:
.86c0	7a		ply				ply 								; restore Y position
.86c1	0a		asl a				asl 	a 							; is bit 7 set.
.86c2	90 04		bcc $86c8			bcc 	_NCLoopback 				; if no , >= so loop back
.86c4	20 e3 a6	jsr $a6e3			jsr 	StackClose 					; exit the loop
.86c7	60		rts				rts
.86c8					_NCLoopBack:
.86c8	20 1a a7	jsr $a71a			jsr 	STKLoadCodePosition 		; loop back
.86cb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.86cc					Command_GOSUB:
.86cc	a2 00		ldx #$00			ldx 	#0
.86ce	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.86d1	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.86d3	20 c4 a6	jsr $a6c4			jsr 	StackOpen 					; create frame
.86d6	20 09 a7	jsr $a709			jsr 	STKSaveCodePosition 		; save current position
.86d9	4c ef 86	jmp $86ef			jmp 	GotoStackX
.86dc					Command_RETURN:
.86dc	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.86de	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.86e0	20 f1 a6	jsr $a6f1			jsr 	StackCheckFrame
.86e3	20 1a a7	jsr $a71a			jsr 	STKLoadCodePosition 		; restore code position
.86e6	20 e3 a6	jsr $a6e3			jsr 	StackClose
.86e9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.86ea					GotoCommand:
.86ea	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.86ec	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger
.86ef					GotoStackX:
.86ef	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.86f1	48		pha				pha 								; it is slightly inefficient, just in cases.
.86f2	b5 58		lda $58,x			lda 	NSMantissa0,x
.86f4	fa		plx				plx
.86f5	20 9e a5	jsr $a59e			jsr 	MemorySearch 				; transfer to line number AX.
.86f8	90 05		bcc $86ff			bcc 	_GotoError 					; not found, off end.
.86fa	d0 03		bne $86ff			bne 	_GotoError 					; not found exactly
.86fc	4c 7d 8b	jmp $8b7d			jmp 	RunNewLine 					; and go straight to new line code.
.86ff					_GotoError:
.86ff	a9 0d		lda #$0d		lda	#13
.8701	4c fb 8e	jmp $8efb		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8704					IfCommand:
.8704	a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.8706	20 70 9d	jsr $9d70			jsr 	EvaluateNumber
.8709	b1 30		lda ($30),y			lda 	(codePtr),y
.870b	c9 aa		cmp #$aa			cmp 	#KWD_THEN  					; could be THEN <stuff>
.870d	d0 0a		bne $8719			bne 	_IFStructured 				; we still support it.
.870f	c8		iny				iny 								; consume THEN
.8710	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; is it zero
.8713	f0 01		beq $8716			beq 	_IfFail 					; if fail, go to next line
.8715	60		rts				rts 								; if THEN just continue
.8716					_IfFail:
.8716	4c 65 8b	jmp $8b65			jmp 	EOLCommand
.8719					_IfStructured:
.8719	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; is it zero
.871c	d0 07		bne $8725			bne 	_IfExit 					; if not, then continue normally.
.871e	a9 b8		lda #$b8			lda 	#KWD_ELSE 					; look for else/endif
.8720	a2 a7		ldx #$a7			ldx 	#KWD_ENDIF
.8722	20 3d 8e	jsr $8e3d			jsr 	ScanForward 				; and run from there
.8725					_IfExit:
.8725	60		rts				rts
.8726					ElseCode:
.8726	a9 a7		lda #$a7			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8728	aa		tax				tax 								; so just go to the structure exit
.8729	20 3d 8e	jsr $8e3d			jsr 	ScanForward
.872c	60		rts				rts
.872d					EndIf:
.872d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.872e					Command_Input:
.872e	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.8730	8d 28 04	sta $0428			sta 	IsInputFlag
.8733	80 03		bra $8738			bra 	Command_IP_Main
.8735					Command_Print:
.8735	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.8738					Command_IP_Main:
.8738	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.8739					_CPLoop:
.8739	08		php				php 								; save last action flag
.873a	b1 30		lda ($30),y			lda 	(codePtr),y
.873c	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.873e	f0 54		beq $8794			beq 	_CPExit
.8740	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8742	f0 50		beq $8794			beq 	_CPExit
.8744	68		pla				pla 								; throw last action flag
.8745	b1 30		lda ($30),y			lda 	(codePtr),y
.8747	c8		iny				iny
.8748	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.874a	f0 45		beq $8791			beq 	_CPContinueWithSameLine
.874c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.874e	f0 3c		beq $878c			beq 	_CPTab
.8750	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8752	f0 34		beq $8788			beq 	_CPNewLine
.8754	88		dey				dey 								; undo the get.
.8755	20 fd 93	jsr $93fd			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.8758	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.875a	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.875c	f0 0d		beq $876b			beq 	_CPIsValue 					; no, display it.
.875e	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.8761	f0 05		beq $8768			beq 	_CPIsPrint 					; otherwise display.
.8763	20 9d 87	jsr $879d			jsr 	CIInputValue 				; input a value to the reference
.8766	80 20		bra $8788			bra 	_CPNewLine
.8768					_CPIsPrint:
.8768	20 c2 96	jsr $96c2			jsr 	Dereference 				; dereference if required.
.876b					_CPIsValue:
.876b	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.876d	29 10		and #$10			and 	#NSBIsString
.876f	f0 09		beq $877a			beq 	_CPNumber
.8771	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.8773	a5 58		lda $58				lda 	NSMantissa0
.8775	20 00 88	jsr $8800			jsr 	CPPrintStringXA
.8778	80 be		bra $8738			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.877a					_CPNumber:
.877a	a9 05		lda #$05			lda 	#5 							; maximum decimals
.877c	20 57 9c	jsr $9c57			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.877f	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8781	a9 49		lda #$49			lda 	#DecimalBuffer & $FF
.8783	20 00 88	jsr $8800			jsr 	CPPrintStringXA 			; print it.
.8786	80 b0		bra $8738			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8788					_CPNewLine:
.8788	a9 0d		lda #$0d			lda 	#13
.878a	80 02		bra $878e			bra 	_CPPrintChar
.878c					_CPTab:
.878c	a9 09		lda #$09			lda 	#9 							; print TAB
.878e					_CPPrintChar:
.878e	20 13 88	jsr $8813			jsr 	CPPrintVector
.8791					_CPContinueWithSameLine:
.8791	38		sec				sec 								; loop round with carry set, which
.8792	80 a5		bra $8739			bra 	_CPLoop 					; will inhibit final CR
.8794					_CPExit:
.8794	28		plp				plp 								; get last action flag
.8795	b0 05		bcs $879c			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8797	a9 0d		lda #$0d			lda 	#13 						; print new line
.8799	20 13 88	jsr $8813			jsr 	CPPrintVector
.879c					_CPExit2:
.879c	60		rts				rts
.879d					CIInputValue:
.879d	a2 00		ldx #$00			ldx 	#0 							; input a line.
.879f					_CIInputLine:
.879f	20 16 88	jsr $8816			jsr 	CPInputVector 				; get key
.87a2	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.87a4	f0 1f		beq $87c5			beq 	_CIHaveValue
.87a6	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.87a8	f0 11		beq $87bb			beq 	_CIBackspace
.87aa	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.87ac	90 f1		bcc $879f			bcc 	_CIInputLine
.87ae	e0 50		cpx #$50			cpx 	#80 						; max length
.87b0	b0 ed		bcs $879f			bcs 	_CIInputLine
.87b2	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.87b5	e8		inx				inx
.87b6	20 13 88	jsr $8813			jsr 	CPPrintVector 				; echo it.
.87b9	80 e4		bra $879f			bra 	_CIInputLine
.87bb					_CIBackSpace:
.87bb	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.87bd	f0 e0		beq $879f			beq 	_CIInputLine
.87bf	20 13 88	jsr $8813			jsr 	CPPrintVector 				; echo it.
.87c2	ca		dex				dex
.87c3	80 da		bra $879f			bra 	_CIInputLine
.87c5					_CIHaveValue:
.87c5	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.87c8	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.87ca	29 10		and #$10			and 	#NSBIsString
.87cc	f0 17		beq $87e5			beq 	_CIAssignNumber 			; assign a number
.87ce	a2 01		ldx #$01			ldx 	#1
.87d0	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.87d2	95 58		sta $58,x			sta 	NSMantissa0,x
.87d4	a9 05		lda #$05			lda 	#lineBuffer >> 8
.87d6	95 60		sta $60,x			sta 	NSMantissa1,x
.87d8	74 68		stz $68,x			stz 	NSMantissa2,x
.87da	74 70		stz $70,x			stz 	NSMantissa3,x
.87dc	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.87de	95 50		sta $50,x			sta  	NSStatus,x
.87e0	ca		dex				dex 								; X = 0
.87e1	20 52 88	jsr $8852			jsr 	AssignVariable
.87e4	60		rts				rts
.87e5					_CIAssignNumber:
.87e5	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.87e7	85 36		sta $36				sta 	zTemp0
.87e9	a9 05		lda #$05			lda 	#lineBuffer >> 8
.87eb	85 37		sta $37				sta 	zTemp0+1
.87ed	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.87ef	20 d9 9b	jsr $9bd9			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.87f2	90 07		bcc $87fb			bcc 	_CIIsOkay
.87f4	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.87f6	20 13 88	jsr $8813			jsr 	CPPrintVector
.87f9	80 a2		bra $879d			bra 	CIInputValue
.87fb					_CIIsOkay:
.87fb	ca		dex				dex 								; X = 0
.87fc	20 52 88	jsr $8852			jsr 	AssignVariable
.87ff	60		rts				rts
.8800					CPPrintStringXA:
.8800	5a		phy				phy
.8801	86 37		stx $37				stx 	zTemp0+1
.8803	85 36		sta $36				sta 	zTemp0
.8805	a0 00		ldy #$00			ldy 	#0
.8807					_PSXALoop:
.8807	b1 36		lda ($36),y			lda 	(zTemp0),y
.8809	f0 06		beq $8811			beq 	_PSXAExit
.880b	20 13 88	jsr $8813			jsr 	CPPrintVector
.880e	c8		iny				iny
.880f	80 f6		bra $8807			bra 	_PSXALoop
.8811					_PSXAExit:
.8811	7a		ply				ply
.8812	60		rts				rts
.8813					CPPrintVector:
.8813	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.8816					CPInputVector:
.8816	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8819					LetCommand:
.8819	a2 00		ldx #$00			ldx 	#0
.881b	b1 30		lda ($30),y			lda 	(codePtr),y
.881d	c9 10		cmp #$10			cmp 	#KWD_AT
.881f	d0 14		bne $8835			bne 	_LCStandard
.8821	c8		iny				iny 								; skip equal
.8822	20 49 98	jsr $9849			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.8825	20 c2 96	jsr $96c2			jsr 	Dereference 				; dereference it to a value
.8828	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.882a	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.882c	95 50		sta $50,x			sta 	NSStatus,x
.882e	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8830	d0 0f		bne $8841			bne 	_LCMain
.8832	4c aa 9f	jmp $9faa			jmp 	TypeError 					; was a reference before.
.8835					_LCStandard:
.8835	ad e7 93	lda $93e7			lda 	PrecedenceLevel+"*"			; precedence > this
.8838	20 01 94	jsr $9401			jsr 	EvaluateExpressionAtPrecedence
.883b	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.883d	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.883f	f0 0e		beq $884f			beq 	_LetGoProc 					; it's a procedure call.
.8841					_LCMain:
.8841	a9 3d		lda #$3d			lda 	#"=" 						; check =
.8843	20 f2 8e	jsr $8ef2			jsr 	CheckNextA
.8846	e8		inx				inx 								; RHS
.8847	20 67 9d	jsr $9d67			jsr 	EvaluateValue
.884a	ca		dex				dex
.884b	20 52 88	jsr $8852			jsr 	AssignVariable
.884e	60		rts				rts
.884f					_LetGoProc:
.884f	4c 3b 8a	jmp $8a3b			jmp 	CallProcedure
.8852					AssignVariable:
.8852	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8854	48		pha				pha 								; save a copy
.8855	55 51		eor $51,x			eor 	NSStatus+1,x
.8857	29 10		and #$10			and 	#NSBIsString
.8859	d0 0b		bne $8866			bne 	_ASError
.885b	68		pla				pla 								; get back
.885c	29 10		and #$10			and 	#NSBIsString 				; check type
.885e	d0 03		bne $8863			bne 	_ASString
.8860	4c 00 96	jmp $9600			jmp 	AssignNumber
.8863					_ASString:
.8863	4c 5e 96	jmp $965e			jmp 	AssignString
.8866					_ASError:
.8866	4c aa 9f	jmp $9faa			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.8869					Command_List:
.8869	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.886c	b1 30		lda ($30),y			lda 	(codePtr),y
.886e	29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.8870	c9 40		cmp #$40			cmp 	#$40  						; of code.
.8872	f0 6e		beq $88e2			beq 	_CLListProcedure
.8874	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.8876	64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.8878	a9 ff		lda #$ff			lda 	#$FF
.887a	85 5f		sta $5f				sta 	NSMantissa0+7
.887c	85 67		sta $67				sta 	NSMantissa1+7
.887e	b1 30		lda ($30),y			lda 	(codePtr),y
.8880	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8882	f0 1a		beq $889e			beq 	_CLSecond
.8884	20 5f 89	jsr $895f			jsr 	CLIsDigit 					; if not digit, list all
.8887	b0 20		bcs $88a9			bcs 	_CLStart
.8889	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.888b	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger
.888e	b1 30		lda ($30),y			lda 	(codePtr),y
.8890	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8892	f0 0a		beq $889e			beq 	_CLSecond 					; if so go get it
.8894	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.8896	85 5f		sta $5f				sta 	NSMantissa0+7
.8898	a5 64		lda $64				lda 	NSMantissa1+4
.889a	85 67		sta $67				sta 	NSMantissa1+7
.889c	80 0b		bra $88a9			bra 	_CLStart
.889e					_CLSecond:
.889e	c8		iny				iny 								; consume comma
.889f	20 5f 89	jsr $895f			jsr 	CLIsDigit 					; digit found
.88a2	b0 05		bcs $88a9			bcs 	_CLStart 					; if not, continue listing
.88a4	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.88a6	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger
.88a9					_CLStart
.88a9	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88ab	85 30		sta $30				sta 	codePtr
.88ad	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88af	85 31		sta $31				sta 	codePtr+1
.88b1					_CLLoop:
.88b1	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check here, as we want the option of breaking out of long lists.
.88b4	f0 27		beq $88dd			beq 	_CLBreak
.88b6	b2 30		lda ($30)			lda 	(codePtr)
.88b8	f0 20		beq $88da			beq 	_CLExit
.88ba	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.88bc	20 4e 89	jsr $894e			jsr 	CLCompareLineNo
.88bf	90 0c		bcc $88cd			bcc 	_CLNext
.88c1	a2 07		ldx #$07			ldx 	#7
.88c3	20 4e 89	jsr $894e			jsr 	CLCompareLineNo
.88c6	f0 02		beq $88ca			beq 	_CLDoThisOne
.88c8	b0 03		bcs $88cd			bcs 	_CLNext
.88ca					_CLDoThisOne:
.88ca	20 3b 89	jsr $893b			jsr 	CLListOneLine 				; routine to list the current line.
.88cd					_CLNext:
.88cd	18		clc				clc
.88ce	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88d0	65 30		adc $30				adc 	codePtr
.88d2	85 30		sta $30				sta 	codePtr
.88d4	90 02		bcc $88d8			bcc 	_CREExit
.88d6	e6 31		inc $31				inc 	codePtr+1 					; carry
.88d8					_CREExit:
.88d8	80 d7		bra $88b1			bra 	_CLLoop
.88da					_CLExit:
.88da	4c da 83	jmp $83da			jmp 	WarmStart
.88dd					_CLBreak:
.88dd	a9 01		lda #$01		lda	#1
.88df	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.88e2					_CLListProcedure:
.88e2	b1 30		lda ($30),y			lda 	(codePtr),y
.88e4	85 38		sta $38				sta 	zTemp1
.88e6	c8		iny				iny
.88e7	b1 30		lda ($30),y			lda 	(codePtr),y
.88e9	85 39		sta $39				sta 	zTemp1+1
.88eb	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88ed	85 30		sta $30				sta 	codePtr
.88ef	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88f1	85 31		sta $31				sta 	codePtr+1
.88f3					_CLLPSearch:
.88f3	b2 30		lda ($30)			lda 	(codePtr)
.88f5	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.88f7	f0 e1		beq $88da			beq 	_CLExit
.88f9	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.88fb	b1 30		lda ($30),y			lda 	(codePtr),y
.88fd	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.88ff	d0 0e		bne $890f			bne 	_CLLPNext
.8901	c8		iny				iny 								; check if PROC this.
.8902	b1 30		lda ($30),y			lda 	(codePtr),y
.8904	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8906	d0 07		bne $890f			bne 	_CLLPNext
.8908	c8		iny				iny
.8909	b1 30		lda ($30),y			lda 	(codePtr),y
.890b	c5 39		cmp $39				cmp 	zTemp1+1
.890d	f0 0d		beq $891c			beq 	_CLLPFound
.890f					_CLLPNext:
.890f	18		clc				clc
.8910	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8912	65 30		adc $30				adc 	codePtr
.8914	85 30		sta $30				sta 	codePtr
.8916	90 02		bcc $891a			bcc 	_CREExit
.8918	e6 31		inc $31				inc 	codePtr+1 					; carry
.891a					_CREExit:
.891a	80 d7		bra $88f3			bra 	_CLLPSearch
.891c					_CLLPFound:
.891c	b2 30		lda ($30)			lda 	(codePtr)
.891e	f0 ba		beq $88da			beq 	_CLExit
.8920	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.8922	b1 30		lda ($30),y			lda 	(codePtr),y
.8924	48		pha				pha
.8925	20 3b 89	jsr $893b			jsr 	CLListOneLine 				; list line and go forward
.8928	18		clc				clc
.8929	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.892b	65 30		adc $30				adc 	codePtr
.892d	85 30		sta $30				sta 	codePtr
.892f	90 02		bcc $8933			bcc 	_CREExit
.8931	e6 31		inc $31				inc 	codePtr+1 					; carry
.8933					_CREExit:
.8933	68		pla				pla 								; reached ENDPROC ?
.8934	c9 a8		cmp #$a8			cmp 	#KWD_ENDPROC
.8936	d0 e4		bne $891c			bne 	_CLLPFound
.8938	4c da 83	jmp $83da			jmp 	WarmStart
.893b					CLListOneLine:
.893b	20 a0 8e	jsr $8ea0			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.893e	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.8941	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8943	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8945	20 54 8f	jsr $8f54			jsr 	PrintStringXA
.8948	a9 0d		lda #$0d			lda 	#13 						; new line
.894a	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.894d	60		rts				rts
.894e					CLCompareLineNo:
.894e	38		sec				sec
.894f	a0 01		ldy #$01			ldy 	#1
.8951	b1 30		lda ($30),y			lda 	(codePtr),y
.8953	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8955	85 36		sta $36				sta 	zTemp0
.8957	c8		iny				iny
.8958	b1 30		lda ($30),y			lda 	(codePtr),y
.895a	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.895c	05 36		ora $36				ora 	zTemp0
.895e	60		rts				rts
.895f					CLIsDigit:
.895f	b1 30		lda ($30),y			lda 	(codePtr),y
.8961	c9 30		cmp #$30			cmp 	#"0"
.8963	90 03		bcc $8968			bcc	 	_CLIDExitFalse
.8965	c9 3a		cmp #$3a			cmp 	#"9"+1
.8967	60		rts				rts
.8968					_CLIDExitFalse:
.8968	38		sec				sec
.8969	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.896a					Command_LOCAL:
.896a	a2 00		ldx #$00			ldx 	#0 							; at level 0
.896c	20 78 89	jsr $8978			jsr 	LocaliseNextTerm 			; convert term to a local.
.896f	b1 30		lda ($30),y			lda 	(codePtr),y
.8971	c8		iny				iny
.8972	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8974	f0 f4		beq $896a			beq 	Command_LOCAL 				; if so, localise another variable.
.8976	88		dey				dey 								; unpick pre-get
.8977	60		rts				rts
.8978					LocaliseNextTerm:
.8978	20 49 98	jsr $9849			jsr 	EvaluateTerm 				; evaluate the term
.897b	b5 50		lda $50,x			lda 	NSStatus,x
.897d	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.897f	f0 5c		beq $89dd			beq		_LNTError
.8981	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8983	85 36		sta $36				sta 	zTemp0
.8985	b5 60		lda $60,x			lda 	NSMantissa1,x
.8987	85 37		sta $37				sta  	zTemp0+1
.8989	b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.898b	29 10		and #$10			and 	#NSBIsString
.898d	d0 1e		bne $89ad			bne 	_LNTPushString
.898f	5a		phy				phy
.8990	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.8992					_LNTPushNumLoop:
.8992	b1 36		lda ($36),y			lda		(zTemp0),y
.8994	20 a3 a6	jsr $a6a3			jsr 	StackPushByte
.8997	c8		iny				iny
.8998	c0 05		cpy #$05			cpy 	#5
.899a	d0 f6		bne $8992			bne 	_LNTPushNumLoop
.899c	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.899e	20 a3 a6	jsr $a6a3			jsr 	StackPushByte
.89a1	a5 37		lda $37				lda 	zTemp0+1
.89a3	20 a3 a6	jsr $a6a3			jsr 	StackPushByte
.89a6	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.89a8	20 a3 a6	jsr $a6a3			jsr 	StackPushByte
.89ab	7a		ply				ply
.89ac	60		rts				rts
.89ad					_LNTPushString:
.89ad	5a		phy				phy
.89ae	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.89b0	85 38		sta $38				sta 	zTemp1
.89b2	a0 01		ldy #$01			ldy 	#1
.89b4	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b6	85 39		sta $39				sta 	zTemp1+1
.89b8	a0 00		ldy #$00			ldy 	#0 							; output string
.89ba	c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.89bc	f0 0a		beq $89c8			beq 	_LNTStringOut
.89be					_LNTPushStrLoop:
.89be	b1 38		lda ($38),y			lda 	(zTemp1),y
.89c0	f0 06		beq $89c8			beq 	_LNTStringOut
.89c2	20 a3 a6	jsr $a6a3			jsr 	StackPushByte
.89c5	c8		iny				iny
.89c6	80 f6		bra $89be			bra 	_LNTPushStrLoop
.89c8					_LNTStringOut:
.89c8	98		tya				tya									; output length (chars written).
.89c9	20 a3 a6	jsr $a6a3			jsr 	StackPushByte
.89cc	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.89ce	20 a3 a6	jsr $a6a3			jsr 	StackPushByte
.89d1	b5 60		lda $60,x			lda 	NSMantissa1,x
.89d3	20 a3 a6	jsr $a6a3			jsr 	StackPushByte
.89d6	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.89d8	20 a3 a6	jsr $a6a3			jsr 	StackPushByte
.89db	7a		ply				ply
.89dc	60		rts				rts
.89dd					_LNTError:
.89dd	4c a0 9f	jmp $9fa0			jmp 	SyntaxError
.89e0					LocalPopValue:
.89e0	20 bb a6	jsr $a6bb			jsr 	StackPopByte
.89e3	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.89e5	d0 17		bne $89fe			bne 	_LPVString
.89e7	20 bb a6	jsr $a6bb			jsr 	StackPopByte 				; address
.89ea	85 37		sta $37				sta 	zTemp0+1
.89ec	20 bb a6	jsr $a6bb			jsr 	StackPopByte
.89ef	85 36		sta $36				sta 	zTemp0
.89f1	5a		phy				phy
.89f2	a0 04		ldy #$04			ldy 	#4 							; copy back
.89f4					_LPVNumberCopy:
.89f4	20 bb a6	jsr $a6bb			jsr 	StackPopByte
.89f7	91 36		sta ($36),y			sta 	(zTemp0),y
.89f9	88		dey				dey
.89fa	10 f8		bpl $89f4			bpl 	_LPVNumberCopy
.89fc	7a		ply				ply 								; and complete
.89fd	60		rts				rts
.89fe					_LPVString:
.89fe	20 bb a6	jsr $a6bb			jsr 	StackPopByte 				; address of record copied to zTemp0
.8a01	85 37		sta $37				sta 	zTemp0+1
.8a03	20 bb a6	jsr $a6bb			jsr 	StackPopByte
.8a06	85 36		sta $36				sta 	zTemp0
.8a08	5a		phy				phy
.8a09	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.8a0b	85 38		sta $38				sta 	zTemp1
.8a0d	a0 01		ldy #$01			ldy 	#1
.8a0f	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a11	85 39		sta $39				sta 	zTemp1+1
.8a13	20 bb a6	jsr $a6bb			jsr 	StackPopByte 				; # chars to get => y
.8a16	a8		tay				tay
.8a17	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8a19	f0 0e		beq $8a29			beq 	_LPVStringCopied
.8a1b	a9 00		lda #$00			lda 	#0 							; NULL on end
.8a1d	91 38		sta ($38),y			sta 	(zTemp1),y
.8a1f					_LPVStringCopy:
.8a1f	88		dey				dey
.8a20	30 07		bmi $8a29			bmi 	_LPVStringCopied
.8a22	20 bb a6	jsr $a6bb			jsr 	StackPopByte
.8a25	91 38		sta ($38),y			sta 	(zTemp1),y
.8a27	80 f6		bra $8a1f			bra 	_LPVStringCopy
.8a29					_LPVStringCopied:
.8a29	fa		plx				plx
.8a2a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8a2b					NewCommand:
.8a2b	20 31 8a	jsr $8a31			jsr 	NewProgram 					; does the actual NEW.
.8a2e	4c da 83	jmp $83da			jmp 	WarmStart 					; and warm starts straight away.
.8a31					NewProgram:
.8a31	20 80 a5	jsr $a580			jsr 	MemoryNew
.8a34	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8a37	20 70 84	jsr $8470			jsr 	ClearCommand 				; clear everything.
.8a3a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8a3b					CallProcedure:
.8a3b	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8a3d	b1 30		lda ($30),y			lda 	(codePtr),y
.8a3f	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8a41	f0 0c		beq $8a4f			beq 	_CPEndParam
.8a43					_CPParamLoop:
.8a43	20 67 9d	jsr $9d67			jsr 	EvaluateValue 				; get parameter onto stack
.8a46	e8		inx				inx 								; bump next stack
.8a47	b1 30		lda ($30),y			lda 	(codePtr),y
.8a49	c8		iny				iny
.8a4a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8a4c	f0 f5		beq $8a43			beq 	_CPParamLoop
.8a4e	88		dey				dey 								; unpick.
.8a4f					_CPEndParam:
.8a4f	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8a52	c8		iny				iny									; skip right bracket
.8a53	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8a55	20 c4 a6	jsr $a6c4			jsr 	StackOpen
.8a58	20 09 a7	jsr $a709			jsr 	STKSaveCodePosition 		; save loop position
.8a5b	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8a5d	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8a5f	a5 60		lda $60				lda 	NSMantissa1
.8a61	85 37		sta $37				sta 	zTemp0+1
.8a63	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8a65	b2 36		lda ($36)			lda 	(zTemp0)
.8a67	85 30		sta $30				sta 	safePtr
.8a69	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a6b	85 31		sta $31				sta 	safePtr+1
.8a6d	c8		iny				iny
.8a6e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a70	85 32		sta $32				sta 	safePtr+2
.8a72	c8		iny				iny
.8a73	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a75	85 33		sta $33				sta 	safePtr+3
.8a77	c8		iny				iny 								; get Y offset -> Y
.8a78	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a7a	a8		tay				tay
.8a7b	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8a7d	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check zero parameters at the start
.8a80	f0 13		beq $8a95			beq 	_ParamExit 					; if so, exit.
.8a82					_ParamExtract:
.8a82	ca		dex				dex 								; put a local term on the level before
.8a83	20 78 89	jsr $8978			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8a86	20 52 88	jsr $8852			jsr 	AssignVariable 				; assign stacked value to the variable.
.8a89	e8		inx				inx 								; advance to next parameter to do.
.8a8a	e8		inx				inx
.8a8b	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8a8e	f0 05		beq $8a95			beq 	_ParamExit
.8a90	20 ea 8e	jsr $8eea			jsr 	CheckComma 					; comma seperating parameters
.8a93	80 ed		bra $8a82			bra 	_ParamExtract
.8a95					_ParamExit:
.8a95	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket 			; check )
.8a98	60		rts				rts 								; and continue from here
.8a99					Command_ENDPROC:
.8a99	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8a9b	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8a9d	20 f1 a6	jsr $a6f1			jsr 	StackCheckFrame
.8aa0	20 1a a7	jsr $a71a			jsr 	STKLoadCodePosition 		; restore code position
.8aa3	20 e3 a6	jsr $a6e3			jsr 	StackClose
.8aa6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8aa7					Command_Read:
.8aa7	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8aa9	20 49 98	jsr $9849			jsr 	EvaluateTerm
.8aac	b5 50		lda $50,x			lda 	NSStatus,x
.8aae	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8ab0	f0 4f		beq $8b01			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.8ab2	20 4a 8b	jsr $8b4a			jsr 	SwapDataCodePtrs 			; swap code and data
.8ab5	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8ab8	d0 25		bne $8adf			bne 	_CRContinueData  			; forward for the next one.
.8aba	b2 30		lda ($30)			lda 	(codePtr)
.8abc	f0 1c		beq $8ada			beq 	_CRNoData
.8abe					_CRKeepSearching:
.8abe	a9 b4		lda #$b4			lda 	#KWD_DATA 					; scan for instruction
.8ac0	a2 80		ldx #$80			ldx 	#KWC_EOL
.8ac2	20 3d 8e	jsr $8e3d			jsr 	ScanForward
.8ac5	c9 b4		cmp #$b4			cmp 	#KWD_DATA 					; found data ?
.8ac7	f0 16		beq $8adf			beq 	_CRHaveData 				; found it
.8ac9	18		clc				clc
.8aca	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8acc	65 30		adc $30				adc 	codePtr
.8ace	85 30		sta $30				sta 	codePtr
.8ad0	90 02		bcc $8ad4			bcc 	_CREExit
.8ad2	e6 31		inc $31				inc 	codePtr+1 					; carry
.8ad4					_CREExit:
.8ad4	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8ad6	b2 30		lda ($30)			lda 	(codePtr)
.8ad8	d0 e4		bne $8abe			bne 	_CRKeepSearching
.8ada					_CRNoData:
.8ada	a9 0b		lda #$0b		lda	#11
.8adc	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.8adf					_CRHaveData:
.8adf					_CRContinueData:
.8adf	a2 01		ldx #$01			ldx 	#1
.8ae1	20 67 9d	jsr $9d67			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8ae4	ca		dex				dex
.8ae5	20 52 88	jsr $8852			jsr		AssignVariable 				; do the assignment
.8ae8	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data flag
.8aeb	b1 30		lda ($30),y			lda 	(codePtr),y
.8aed	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.8aef	d0 04		bne $8af5			bne 	_CRSwapBack
.8af1	c8		iny				iny 								; consume comma
.8af2	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8af5					_CRSwapBack:
.8af5	20 4a 8b	jsr $8b4a			jsr 	SwapDataCodePtrs			; swap them back.
.8af8	b1 30		lda ($30),y			lda 	(codePtr),y
.8afa	c8		iny				iny
.8afb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8afd	f0 a8		beq $8aa7			beq 	Command_Read 				; if so go round again.
.8aff	88		dey				dey 								; unpick get.
.8b00	60		rts				rts
.8b01					_CRSyntax:
.8b01	4c a0 9f	jmp $9fa0			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8b04					RemCommand:
.8b04	b1 30		lda ($30),y			lda 	(codePtr),y
.8b06	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8b08	d0 06		bne $8b10			bne 	_RMExit
.8b0a	c8		iny				iny 								; point to offset
.8b0b	98		tya				tya 								; A = offset position
.8b0c	38		sec				sec 								; add size +1 hence SEC
.8b0d	71 30		adc ($30),y			adc 	(codePtr),y
.8b0f	a8		tay				tay 								; make current position.
.8b10					_RMExit:
.8b10	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8b11					Command_REPEAT:
.8b11	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8b13	20 c4 a6	jsr $a6c4			jsr 	StackOpen
.8b16	20 09 a7	jsr $a709			jsr 	STKSaveCodePosition 		; save loop position
.8b19	60		rts				rts
.8b1a					Command_UNTIL:
.8b1a	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8b1c	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8b1e	20 f1 a6	jsr $a6f1			jsr 	StackCheckFrame
.8b21	a2 00		ldx #$00			ldx 	#0
.8b23	20 70 9d	jsr $9d70			jsr 	EvaluateNumber 				; work out the number
.8b26	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; check if zero
.8b29	f0 04		beq $8b2f			beq 	_CULoopBack 				; if so keep looping
.8b2b	20 e3 a6	jsr $a6e3			jsr 	StackClose		 			; return
.8b2e	60		rts				rts
.8b2f					_CULoopBack:
.8b2f	20 1a a7	jsr $a71a			jsr 	STKLoadCodePosition 		; loop back
.8b32	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8b33					Command_Restore:
.8b33	20 4a 8b	jsr $8b4a			jsr 	SwapDataCodePtrs 			; swap code and data
.8b36	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b38	85 30		sta $30				sta 	codePtr
.8b3a	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b3c	85 31		sta $31				sta 	codePtr+1
.8b3e	20 4a 8b	jsr $8b4a			jsr 	SwapDataCodePtrs 			; put them back
.8b41	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8b43	8d 1b 04	sta $041b			sta 	dataPointer+4   			; (read checks not EOF)
.8b46	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8b49	60		rts				rts
.8b4a					SwapDataCodePtrs:
.8b4a	da		phx				phx
.8b4b	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8b4d					_SDCPLoop:
.8b4d	b5 30		lda $30,x			lda 	safePtr,x
.8b4f	48		pha				pha
.8b50	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8b53	95 30		sta $30,x			sta 	safePtr,x
.8b55	68		pla				pla
.8b56	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8b59	ca		dex				dex
.8b5a	10 f1		bpl $8b4d			bpl 	_SDCPLoop
.8b5c	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8b5f	8c 1b 04	sty $041b			sty 	dataPointer+4
.8b62	a8		tay				tay
.8b63	fa		plx				plx
.8b64	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8b65					EOLCommand:
.8b65	18		clc				clc
.8b66	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8b68	65 30		adc $30				adc 	codePtr
.8b6a	85 30		sta $30				sta 	codePtr
.8b6c	90 02		bcc $8b70			bcc 	_CREExit
.8b6e	e6 31		inc $31				inc 	codePtr+1 					; carry
.8b70					_CREExit:
.8b70	80 0b		bra $8b7d			bra 	RunNewLine
.8b72					CommandRUN:
.8b72	20 70 84	jsr $8470			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8b75	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b77	85 30		sta $30				sta 	codePtr
.8b79	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b7b	85 31		sta $31				sta 	codePtr+1
.8b7d					RUNNewLine:
.8b7d	b2 30		lda ($30)			lda 	(codePtr)
.8b7f	f0 7b		beq $8bfc			beq 	CRNoProgram         		; no then END.
.8b81	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8b83	9a		txs				txs
.8b84					RUNCodePointerLine:
.8b84	a0 02		ldy #$02			ldy 	#2 							; start of program
.8b86					_CRIncMainLoop:
.8b86	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8b89	d0 22		bne $8bad			bne 	_CRNoBreakCheck
.8b8b	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8b8e	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8b91	f0 64		beq $8bf7			beq 	_CRBreak
.8b93	a5 01		lda $01				lda 	1 							; save I/O 0
.8b95	48		pha				pha
.8b96	64 01		stz $01				stz 	1 							; access I/O Page 0
.8b98	38		sec				sec 								; calculate timer - LastTick
.8b99	ad 59 d6	lda $d659			lda 	$D659
.8b9c	aa		tax				tax 								; saving timer in X
.8b9d	ed 5c 06	sbc $065c			sbc 	LastTick
.8ba0	c9 03		cmp #$03			cmp 	#3
.8ba2	90 06		bcc $8baa			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8ba4	8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.8ba7	20 4d 9e	jsr $9e4d			jsr 	TickHandler 							; go do the code.
.8baa					_NoFireTick:
.8baa	68		pla				pla 								; restore I/O 0
.8bab	85 01		sta $01				sta 	1
.8bad					_CRNoBreakCheck:
.8bad	c8		iny				iny									; next token
.8bae					_CRMainLoop:
.8bae	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8bb1	b1 30		lda ($30),y			lda 	(codePtr),y
.8bb3	10 10		bpl $8bc5			bpl 	_CRNotKeyword				; not a token.
.8bb5	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8bb7	b0 04		bcs $8bbd			bcs 	_CRIsKeyword
.8bb9	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8bbb	b0 34		bcs $8bf1			bcs		_CRSyntaxError
.8bbd					_CRIsKeyword:
.8bbd	c8		iny				iny 								; consume command
.8bbe	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8bbf	aa		tax				tax 								; put in X for vector jump
.8bc0	20 f4 8b	jsr $8bf4			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8bc3	80 e9		bra $8bae			bra 	_CRMainLoop 				; and loop round
.8bc5					_CRNotKeyword:
.8bc5	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8bc7	f0 bd		beq $8b86			beq 	_CRIncMainLoop
.8bc9	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8bcb	90 05		bcc $8bd2			bcc 	_CRNotVariable
.8bcd					_CRGoLet:
.8bcd	20 19 88	jsr $8819			jsr 	LetCommand
.8bd0	80 dc		bra $8bae			bra 	_CRMainLoop
.8bd2					_CRNotVariable:
.8bd2	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8bd4	f0 f7		beq $8bcd			beq 	_CRGoLet
.8bd6	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8bd8	f0 f3		beq $8bcd			beq 	_CRGoLet
.8bda	c9 21		cmp #$21			cmp 	#KWD_PLING
.8bdc	f0 ef		beq $8bcd			beq 	_CRGoLet
.8bde	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8be0	f0 09		beq $8beb			beq 	_CRGoRem
.8be2	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8be4	d0 0b		bne $8bf1			bne 	_CRSyntaxError
.8be6	20 54 82	jsr $8254			jsr 	LabelHere
.8be9	80 c3		bra $8bae			bra 	_CRMainLoop
.8beb					_CRGoRem:
.8beb	c8		iny				iny
.8bec	20 04 8b	jsr $8b04			jsr 	RemCommand
.8bef	80 bd		bra $8bae			bra 	_CRMainLoop
.8bf1					_CRSyntaxError:
.8bf1	4c a0 9f	jmp $9fa0			jmp 	SyntaxError
.8bf4					_CRCallVector0:
.8bf4	7c 92 8c	jmp ($8c92,x)			jmp 	(VectorSet0,x)
.8bf7					_CRBreak:
.8bf7	a9 01		lda #$01		lda	#1
.8bf9	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.8bfc					CRNoProgram:
.8bfc	4c be 85	jmp $85be			jmp 	EndCommand
.8bff					Shift1Command:
.8bff	b1 30		lda ($30),y			lda 	(codePtr),y
.8c01	c8		iny				iny
.8c02	0a		asl a				asl 	a
.8c03	aa		tax				tax
.8c04	7c 38 8d	jmp ($8d38,x)			jmp 	(VectorSet1,x)
.8c07					Shift2Command:
.8c07	b1 30		lda ($30),y			lda 	(codePtr),y
.8c09	c8		iny				iny
.8c0a	0a		asl a				asl 	a
.8c0b	aa		tax				tax
.8c0c	7c 5e 8d	jmp ($8d5e,x)			jmp 	(VectorSet2,x)
.8c0f					Unused1:
.8c0f					Unused2:
.8c0f					Unused3:
.8c0f					Unused4:
.8c0f	4c a0 9f	jmp $9fa0			jmp 	SyntaxError
>8c12							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8c12					VectorSetPunc:
>8c12	b3 91					.word	ShiftLeft                        ; $00 <<
>8c14	9e 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8c16	94 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8c18	a0 9f					.word	SyntaxError                      ; $03 !!3
>8c1a	a0 9f					.word	SyntaxError                      ; $04 ><
>8c1c	a8 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8c1e	b6 91					.word	ShiftRight                       ; $06 >>
>8c20	a0 9f					.word	SyntaxError                      ; $07 !!7
>8c22	a0 9f					.word	SyntaxError                      ; $08 !!8
>8c24	a0 9f					.word	SyntaxError                      ; $09 !!9
>8c26	a0 9f					.word	SyntaxError                      ; $0a !!10
>8c28	a0 9f					.word	SyntaxError                      ; $0b !!11
>8c2a	a0 9f					.word	SyntaxError                      ; $0c !!12
>8c2c	a0 9f					.word	SyntaxError                      ; $0d !!13
>8c2e	a0 9f					.word	SyntaxError                      ; $0e !!14
>8c30	a0 9f					.word	SyntaxError                      ; $0f !!15
>8c32	a0 9f					.word	SyntaxError                      ; $10 @
>8c34	a0 9f					.word	SyntaxError                      ; $11 !!17
>8c36	a0 9f					.word	SyntaxError                      ; $12 !!18
>8c38	a0 9f					.word	SyntaxError                      ; $13 [
>8c3a	5f 90					.word	IntegerDivide                    ; $14 \
>8c3c	a0 9f					.word	SyntaxError                      ; $15 ]
>8c3e	f1 92					.word	EorInteger                       ; $16 ^
>8c40	a0 9f					.word	SyntaxError                      ; $17 _
>8c42	a0 9f					.word	SyntaxError                      ; $18 `
>8c44	a0 9f					.word	SyntaxError                      ; $19 !!25
>8c46	a0 9f					.word	SyntaxError                      ; $1a !!26
>8c48	a0 9f					.word	SyntaxError                      ; $1b {
>8c4a	bc 92					.word	OraInteger                       ; $1c |
>8c4c	a0 9f					.word	SyntaxError                      ; $1d }
>8c4e	a0 9f					.word	SyntaxError                      ; $1e ~
>8c50	a0 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8c52	a0 9f					.word	SyntaxError                      ; $20
>8c54	26 93					.word	WordIndirect                     ; $21 !
>8c56	a0 9f					.word	SyntaxError                      ; $22 "
>8c58	a0 9f					.word	SyntaxError                      ; $23 #
>8c5a	a0 9f					.word	SyntaxError                      ; $24 $
>8c5c	a0 90					.word	IntegerModulus                   ; $25 %
>8c5e	87 92					.word	AndInteger                       ; $26 &
>8c60	a0 9f					.word	SyntaxError                      ; $27 '
>8c62	a0 9f					.word	SyntaxError                      ; $28 (
>8c64	a0 9f					.word	SyntaxError                      ; $29 )
>8c66	0e 91					.word	MulInteger                       ; $2a *
>8c68	29 92					.word	AddInteger                       ; $2b +
>8c6a	a0 9f					.word	SyntaxError                      ; $2c ,
>8c6c	62 92					.word	SubInteger                       ; $2d -
>8c6e	a0 9f					.word	SyntaxError                      ; $2e .
>8c70	e0 94					.word	FDivideCommand                   ; $2f /
>8c72	a0 9f					.word	SyntaxError                      ; $30 0
>8c74	a0 9f					.word	SyntaxError                      ; $31 1
>8c76	a0 9f					.word	SyntaxError                      ; $32 2
>8c78	a0 9f					.word	SyntaxError                      ; $33 3
>8c7a	a0 9f					.word	SyntaxError                      ; $34 4
>8c7c	a0 9f					.word	SyntaxError                      ; $35 5
>8c7e	a0 9f					.word	SyntaxError                      ; $36 6
>8c80	a0 9f					.word	SyntaxError                      ; $37 7
>8c82	a0 9f					.word	SyntaxError                      ; $38 8
>8c84	a0 9f					.word	SyntaxError                      ; $39 9
>8c86	a0 9f					.word	SyntaxError                      ; $3a :
>8c88	a0 9f					.word	SyntaxError                      ; $3b ;
>8c8a	80 8f					.word	BinaryCompareLess                ; $3c <
>8c8c	76 8f					.word	BinaryCompareEqual               ; $3d =
>8c8e	8a 8f					.word	BinaryCompareGreater             ; $3e >
>8c90	48 93					.word	ByteIndirect                     ; $3f ?
.8c92					VectorSet0:
>8c92	65 8b					.word	EOLCommand                       ; $80 !0:EOF
>8c94	ff 8b					.word	Shift1Command                    ; $81 !1:SH1
>8c96	07 8c					.word	Shift2Command                    ; $82 !2:SH2
>8c98	ca 99					.word	AbsUnary                         ; $83 ABS(
>8c9a	d8 99					.word	AllocUnary                       ; $84 ALLOC(
>8c9c	48 9a					.word	AscUnary                         ; $85 ASC(
>8c9e	08 9c					.word	ChrUnary                         ; $86 CHR$(
>8ca0	58 9a					.word	DeekUnary                        ; $87 DEEK(
>8ca2	00 a4					.word	UnaryEvent                       ; $88 EVENT(
>8ca4	72 8f					.word	UnaryFalse                       ; $89 FALSE
>8ca6	6a 9a					.word	FracUnary                        ; $8a FRAC(
>8ca8	9c a3					.word	UnaryHit                         ; $8b HIT(
>8caa	7f 9a					.word	IntUnary                         ; $8c INT(
>8cac	c7 9b					.word	IsValUnary                       ; $8d ISVAL(
>8cae	84 a4					.word	UnaryJoyB                        ; $8e JOYB(
>8cb0	5d a4					.word	UnaryJoyX                        ; $8f JOYX(
>8cb2	60 a4					.word	UnaryJoyY                        ; $90 JOYY(
>8cb4	db 9c					.word	Unary_Left                       ; $91 LEFT$(
>8cb6	90 9a					.word	LenUnary                         ; $92 LEN(
>8cb8	ae 9a					.word	Unary_Max                        ; $93 MAX(
>8cba	fd 9c					.word	Unary_Mid                        ; $94 MID$(
>8cbc	aa 9a					.word	Unary_Min                        ; $95 MIN(
>8cbe	f9 9a					.word	Unary_Not                        ; $96 NOT(
>8cc0	55 9a					.word	PeekUnary                        ; $97 PEEK(
>8cc2	21 a6					.word	UnaryPlaying                     ; $98 PLAYING(
>8cc4	0c 9b					.word	Unary_Random                     ; $99 RANDOM(
>8cc6	e8 9c					.word	Unary_Right                      ; $9a RIGHT$(
>8cc8	29 9b					.word	Unary_Rnd                        ; $9b RND(
>8cca	9f 9b					.word	SgnUnary                         ; $9c SGN(
>8ccc	1a 9c					.word	SpcUnary                         ; $9d SPC(
>8cce	35 9c					.word	Unary_Str                        ; $9e STR$(
>8cd0	aa a4					.word	UnaryTimer                       ; $9f TIMER(
>8cd2	67 8f					.word	UnaryTrue                        ; $a0 TRUE
>8cd4	bd 9b					.word	ValUnary                         ; $a1 VAL(
>8cd6	c1 85					.word	ForCommand                       ; $a2 FOR
>8cd8	04 87					.word	IfCommand                        ; $a3 IF
>8cda	0f 8c					.word	Unused1                          ; $a4 PROC
>8cdc	11 8b					.word	Command_REPEAT                   ; $a5 REPEAT
>8cde	b3 8e					.word	Command_WHILE                    ; $a6 WHILE
>8ce0	2d 87					.word	EndIf                            ; $a7 ENDIF
>8ce2	99 8a					.word	Command_ENDPROC                  ; $a8 ENDPROC
>8ce4	73 86					.word	NextCommand                      ; $a9 NEXT
>8ce6	0f 8c					.word	Unused4                          ; $aa THEN
>8ce8	1a 8b					.word	Command_UNTIL                    ; $ab UNTIL
>8cea	d4 8e					.word	Command_WEND                     ; $ac WEND
>8cec	a0 9f					.word	SyntaxError                      ; $ad BY
>8cee	3b 84					.word	CallCommand                      ; $ae CALL
>8cf0	50 a1					.word	CircleCommand                    ; $af CIRCLE
>8cf2	70 84					.word	ClearCommand                     ; $b0 CLEAR
>8cf4	c8 84					.word	ClearScreen                      ; $b1 CLS
>8cf6	a0 9f					.word	SyntaxError                      ; $b2 COLOR
>8cf8	a0 9f					.word	SyntaxError                      ; $b3 COLOUR
>8cfa	d0 84					.word	Command_Data                     ; $b4 DATA
>8cfc	d8 84					.word	DimCommand                       ; $b5 DIM
>8cfe	98 85					.word	DokeCommand                      ; $b6 DOKE
>8d00	0f 8c					.word	Unused3                          ; $b7 DOWNTO
>8d02	26 87					.word	ElseCode                         ; $b8 ELSE
>8d04	a0 9f					.word	SyntaxError                      ; $b9 FROM
>8d06	6f a3					.word	GfxCommand                       ; $ba GFX
>8d08	cc 86					.word	Command_GOSUB                    ; $bb GOSUB
>8d0a	ea 86					.word	GotoCommand                      ; $bc GOTO
>8d0c	a0 9f					.word	SyntaxError                      ; $bd HERE
>8d0e	79 a1					.word	ImageCommand                     ; $be IMAGE
>8d10	2e 87					.word	Command_Input                    ; $bf INPUT
>8d12	19 88					.word	LetCommand                       ; $c0 LET
>8d14	cb a1					.word	LineCommand                      ; $c1 LINE
>8d16	6a 89					.word	Command_LOCAL                    ; $c2 LOCAL
>8d18	a0 9f					.word	SyntaxError                      ; $c3 OFF
>8d1a	a0 9f					.word	SyntaxError                      ; $c4 ON
>8d1c	a0 9f					.word	SyntaxError                      ; $c5 OUTLINE
>8d1e	c0 a3					.word	PaletteCommand                   ; $c6 PALETTE
>8d20	c4 a1					.word	PlotCommand                      ; $c7 PLOT
>8d22	95 85					.word	PokeCommand                      ; $c8 POKE
>8d24	35 87					.word	Command_Print                    ; $c9 PRINT
>8d26	a7 8a					.word	Command_Read                     ; $ca READ
>8d28	4c a1					.word	RectangleCommand                 ; $cb RECT
>8d2a	04 8b					.word	RemCommand                       ; $cc REM
>8d2c	dc 86					.word	Command_RETURN                   ; $cd RETURN
>8d2e	a0 9f					.word	SyntaxError                      ; $ce SOLID
>8d30	3d a6					.word	SoundCommand                     ; $cf SOUND
>8d32	5b a1					.word	SpriteCommand                    ; $d0 SPRITE
>8d34	95 a1					.word	TextCommand                      ; $d1 TEXT
>8d36	0f 8c					.word	Unused2                          ; $d2 TO
.8d38					VectorSet1:
>8d38	a0 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d3a	a0 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d3c	a0 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d3e	0f 84					.word	AssembleCommand                  ; $83 ASSEMBLE
>8d40	2b 84					.word	AssertCommand                    ; $84 ASSERT
>8d42	0f a3					.word	BitmapCtrl                       ; $85 BITMAP
>8d44	be 85					.word	EndCommand                       ; $86 END
>8d46	f5 a5					.word	Explode                          ; $87 EXPLODE
>8d48	a1 a4					.word	GoCommand                        ; $88 GO
>8d4a	69 88					.word	Command_List                     ; $89 LIST
>8d4c	98 a4					.word	LoadCommand                      ; $8a LOAD
>8d4e	2b 8a					.word	NewCommand                       ; $8b NEW
>8d50	d1 a5					.word	PingCommand                      ; $8c PING
>8d52	33 8b					.word	Command_Restore                  ; $8d RESTORE
>8d54	72 8b					.word	CommandRUN                       ; $8e RUN
>8d56	e9 a5					.word	ShootCommand                     ; $8f SHOOT
>8d58	54 a3					.word	SpritesCtrl                      ; $90 SPRITES
>8d5a	e6 8d					.word	StopCommand                      ; $91 STOP
>8d5c	dd a5					.word	ZapCommand                       ; $92 ZAP
.8d5e					VectorSet2:
>8d5e	a0 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d60	a0 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d62	a0 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d64	5f 9e					.word	Assemble_adc                     ; $83 ADC
>8d66	57 9e					.word	Assemble_and                     ; $84 AND
>8d68	73 9e					.word	Assemble_asl                     ; $85 ASL
>8d6a	dd 9e					.word	Assemble_bcc                     ; $86 BCC
>8d6c	e1 9e					.word	Assemble_bcs                     ; $87 BCS
>8d6e	e9 9e					.word	Assemble_beq                     ; $88 BEQ
>8d70	a0 9e					.word	Assemble_bit                     ; $89 BIT
>8d72	d1 9e					.word	Assemble_bmi                     ; $8a BMI
>8d74	e5 9e					.word	Assemble_bne                     ; $8b BNE
>8d76	cd 9e					.word	Assemble_bpl                     ; $8c BPL
>8d78	ed 9e					.word	Assemble_bra                     ; $8d BRA
>8d7a	f1 9e					.word	Assemble_brk                     ; $8e BRK
>8d7c	d5 9e					.word	Assemble_bvc                     ; $8f BVC
>8d7e	d9 9e					.word	Assemble_bvs                     ; $90 BVS
>8d80	f9 9e					.word	Assemble_clc                     ; $91 CLC
>8d82	4d 9f					.word	Assemble_cld                     ; $92 CLD
>8d84	0d 9f					.word	Assemble_cli                     ; $93 CLI
>8d86	3d 9f					.word	Assemble_clv                     ; $94 CLV
>8d88	6b 9e					.word	Assemble_cmp                     ; $95 CMP
>8d8a	b4 9e					.word	Assemble_cpx                     ; $96 CPX
>8d8c	af 9e					.word	Assemble_cpy                     ; $97 CPY
>8d8e	91 9e					.word	Assemble_dec                     ; $98 DEC
>8d90	49 9f					.word	Assemble_dex                     ; $99 DEX
>8d92	25 9f					.word	Assemble_dey                     ; $9a DEY
>8d94	5b 9e					.word	Assemble_eor                     ; $9b EOR
>8d96	96 9e					.word	Assemble_inc                     ; $9c INC
>8d98	59 9f					.word	Assemble_inx                     ; $9d INX
>8d9a	45 9f					.word	Assemble_iny                     ; $9e INY
>8d9c	c8 9e					.word	Assemble_jmp                     ; $9f JMP
>8d9e	c3 9e					.word	Assemble_jsr                     ; $a0 JSR
>8da0	67 9e					.word	Assemble_lda                     ; $a1 LDA
>8da2	8c 9e					.word	Assemble_ldx                     ; $a2 LDX
>8da4	aa 9e					.word	Assemble_ldy                     ; $a3 LDY
>8da6	7d 9e					.word	Assemble_lsr                     ; $a4 LSR
>8da8	5d 9f					.word	Assemble_nop                     ; $a5 NOP
>8daa	53 9e					.word	Assemble_ora                     ; $a6 ORA
>8dac	09 9f					.word	Assemble_pha                     ; $a7 PHA
>8dae	f5 9e					.word	Assemble_php                     ; $a8 PHP
>8db0	51 9f					.word	Assemble_phx                     ; $a9 PHX
>8db2	11 9f					.word	Assemble_phy                     ; $aa PHY
>8db4	19 9f					.word	Assemble_pla                     ; $ab PLA
>8db6	fd 9e					.word	Assemble_plp                     ; $ac PLP
>8db8	65 9f					.word	Assemble_plx                     ; $ad PLX
>8dba	21 9f					.word	Assemble_ply                     ; $ae PLY
>8dbc	78 9e					.word	Assemble_rol                     ; $af ROL
>8dbe	82 9e					.word	Assemble_ror                     ; $b0 ROR
>8dc0	05 9f					.word	Assemble_rti                     ; $b1 RTI
>8dc2	15 9f					.word	Assemble_rts                     ; $b2 RTS
>8dc4	6f 9e					.word	Assemble_sbc                     ; $b3 SBC
>8dc6	01 9f					.word	Assemble_sec                     ; $b4 SEC
>8dc8	61 9f					.word	Assemble_sed                     ; $b5 SED
>8dca	1d 9f					.word	Assemble_sei                     ; $b6 SEI
>8dcc	63 9e					.word	Assemble_sta                     ; $b7 STA
>8dce	55 9f					.word	Assemble_stp                     ; $b8 STP
>8dd0	87 9e					.word	Assemble_stx                     ; $b9 STX
>8dd2	a5 9e					.word	Assemble_sty                     ; $ba STY
>8dd4	9b 9e					.word	Assemble_stz                     ; $bb STZ
>8dd6	39 9f					.word	Assemble_tax                     ; $bc TAX
>8dd8	35 9f					.word	Assemble_tay                     ; $bd TAY
>8dda	be 9e					.word	Assemble_trb                     ; $be TRB
>8ddc	b9 9e					.word	Assemble_tsb                     ; $bf TSB
>8dde	41 9f					.word	Assemble_tsx                     ; $c0 TSX
>8de0	29 9f					.word	Assemble_txa                     ; $c1 TXA
>8de2	31 9f					.word	Assemble_txs                     ; $c2 TXS
>8de4	2d 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8de6					StopCommand:
.8de6	a9 08		lda #$08		lda	#8
.8de8	4c fb 8e	jmp $8efb		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8deb					ProcedureScan:
.8deb	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ded	85 30		sta $30				sta 	codePtr
.8def	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8df1	85 31		sta $31				sta 	codePtr+1
.8df3					_PSLoop:
.8df3	b2 30		lda ($30)			lda 	(codePtr)
.8df5	f0 42		beq $8e39			beq 	_PSExit
.8df7	a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.8df9	b1 30		lda ($30),y			lda 	(codePtr),y
.8dfb	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8dfd	d0 2d		bne $8e2c			bne 	_PSNext
.8dff	c8		iny				iny 								; get the address of the record to zTemp0 and
.8e00	b1 30		lda ($30),y			lda 	(codePtr),y
.8e02	29 c0		and #$c0			and 	#$C0
.8e04	c9 40		cmp #$40			cmp 	#$40
.8e06	d0 32		bne $8e3a			bne 	_PSSyntax
.8e08	b1 30		lda ($30),y			lda 	(codePtr),y
.8e0a	18		clc				clc
.8e0b	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8e0d	85 37		sta $37				sta 	zTemp0+1
.8e0f	c8		iny				iny 								; LSB
.8e10	b1 30		lda ($30),y			lda 	(codePtr),y
.8e12	85 36		sta $36				sta 	zTemp0
.8e14	c8		iny				iny 								; character after variable call.
.8e15	98		tya				tya 								; save Y offset at +7 (exponent slot)
.8e16	a0 07		ldy #$07			ldy 	#7
.8e18	91 36		sta ($36),y			sta 	(zTemp0),y
.8e1a	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8e1c	a0 02		ldy #$02			ldy 	#2
.8e1e	91 36		sta ($36),y			sta 	(zTemp0),y
.8e20	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.8e22					_PSCopy:
.8e22	b5 30		lda $30,x			lda 	safePtr,x
.8e24	c8		iny				iny
.8e25	91 36		sta ($36),y			sta 	(zTemp0),y
.8e27	e8		inx				inx
.8e28	e0 04		cpx #$04			cpx 	#4
.8e2a	d0 f6		bne $8e22			bne 	_PSCopy
.8e2c					_PSNext:
.8e2c	18		clc				clc
.8e2d	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e2f	65 30		adc $30				adc 	codePtr
.8e31	85 30		sta $30				sta 	codePtr
.8e33	90 02		bcc $8e37			bcc 	_CREExit
.8e35	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e37					_CREExit:
.8e37	80 ba		bra $8df3			bra 	_PSLoop
.8e39					_PSExit:
.8e39	60		rts				rts
.8e3a					_PSSyntax:
.8e3a	4c a0 9f	jmp $9fa0			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8e3d					ScanForward:
.8e3d	64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.8e3f	86 37		stx $37				stx 	zTemp0+1
.8e41	85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.8e43					_ScanLoop:
.8e43	b1 30		lda ($30),y			lda 	(codePtr),y
.8e45	c8		iny				iny
.8e46	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8e48	d0 0e		bne $8e58			bne 	_ScanGoNext
.8e4a	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8e4c	f0 04		beq $8e52			beq 	_ScanMatch
.8e4e	c5 37		cmp $37				cmp 	zTemp0+1
.8e50	d0 06		bne $8e58			bne 	_ScanGoNext
.8e52					_ScanMatch:
.8e52	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8e54	d0 01		bne $8e57			bne 	_ScanNotEndEOL
.8e56	88		dey				dey
.8e57					_ScanNotEndEOL:
.8e57	60		rts				rts
.8e58					_ScanGoNext:
.8e58	20 5d 8e	jsr $8e5d			jsr  	ScanForwardOne 				; allows for shifts and so on.
.8e5b	80 e6		bra $8e43			bra 	_ScanLoop
.8e5d					ScanForwardOne:
.8e5d	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.8e5f	90 3e		bcc $8e9f			bcc 	_SFWExit
.8e61	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.8e63	90 18		bcc $8e7d			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.8e65	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.8e67	b0 2f		bcs $8e98			bcs 	_ScanSkipData
.8e69	c9 a2		cmp #$a2			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8e6b	90 32		bcc $8e9f			bcc 	_SFWExit 					; if not, ordinary keywords.
.8e6d	c9 ad		cmp #$ad			cmp 	#KWC_LAST_STRUCTURE+1
.8e6f	b0 2e		bcs $8e9f			bcs 	_SFWExit
.8e71	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8e73	c9 a7		cmp #$a7			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8e75	b0 28		bcs $8e9f			bcs 	_SFWExit
.8e77	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8e79	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8e7b	80 22		bra $8e9f			bra 	_SFWExit
.8e7d					_ScanSkipOne:
.8e7d	c8		iny				iny 								; consume the extra one.
.8e7e	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8e80	d0 1d		bne $8e9f			bne 	_SFWExit
.8e82	18		clc				clc
.8e83	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e85	65 30		adc $30				adc 	codePtr
.8e87	85 30		sta $30				sta 	codePtr
.8e89	90 02		bcc $8e8d			bcc 	_CREExit
.8e8b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e8d					_CREExit:
.8e8d	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8e8f	b2 30		lda ($30)			lda 	(codePtr)
.8e91	d0 0c		bne $8e9f			bne 	_SFWExit 					; if not zero, more to scan
.8e93	a9 13		lda #$13		lda	#19
.8e95	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.8e98					_ScanSkipData:
.8e98	88		dey				dey 								; point at data token
.8e99	c8		iny				iny 								; point to offset
.8e9a	98		tya				tya 								; A = offset position
.8e9b	38		sec				sec 								; add size +1 hence SEC
.8e9c	71 30		adc ($30),y			adc 	(codePtr),y
.8e9e	a8		tay				tay 								; make current position.
.8e9f					_SFWExit:
.8e9f	60		rts				rts
.8ea0					ScanGetCurrentLineStep:
.8ea0	64 38		stz $38				stz 	zTemp1
.8ea2	a0 03		ldy #$03			ldy 	#3
.8ea4					_SGCLSLoop:
.8ea4	b1 30		lda ($30),y			lda 	(codePtr),y
.8ea6	c8		iny				iny
.8ea7	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8ea9	f0 05		beq $8eb0			beq 	_SGCLSExit
.8eab	20 5d 8e	jsr $8e5d			jsr 	ScanForwardOne
.8eae	80 f4		bra $8ea4			bra 	_SGCLSLoop
.8eb0					_SGCLSExit:
.8eb0	a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.8eb2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8eb3					Command_WHILE:
.8eb3	5a		phy				phy 								; save position of the test
.8eb4	a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.8eb6	20 70 9d	jsr $9d70			jsr 	EvaluateNumber
.8eb9	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; check if zero
.8ebc	f0 0e		beq $8ecc			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.8ebe	98		tya				tya 								; position *after* test.
.8ebf	7a		ply				ply 								; restore position before test, at WHILE
.8ec0	88		dey				dey 								; so we execute the WHILE command again.
.8ec1	48		pha				pha 								; push after test on the stack
.8ec2	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8ec4	20 c4 a6	jsr $a6c4			jsr 	StackOpen
.8ec7	20 09 a7	jsr $a709			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.8eca	7a		ply				ply 								; restore the position *after* the test
.8ecb	60		rts				rts
.8ecc					_WHExitLoop:
.8ecc	68		pla				pla 								; throw post loop position
.8ecd	a9 ac		lda #$ac			lda 	#KWD_WEND 					; scan forward past WEND
.8ecf	aa		tax				tax
.8ed0	20 3d 8e	jsr $8e3d			jsr 	ScanForward
.8ed3	60		rts				rts
.8ed4					Command_WEND:
.8ed4	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.8ed6	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.8ed8	20 f1 a6	jsr $a6f1			jsr 	StackCheckFrame
.8edb	20 1a a7	jsr $a71a			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.8ede	20 e3 a6	jsr $a6e3			jsr 	StackClose		 			; erase the frame
.8ee1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8ee2					CheckRightBracket:
.8ee2	b1 30		lda ($30),y			lda 	(codePtr),y
.8ee4	c8		iny				iny
.8ee5	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8ee7	d0 0f		bne $8ef8			bne 	CNAFail
.8ee9	60		rts				rts
.8eea					CheckComma:
.8eea	b1 30		lda ($30),y			lda 	(codePtr),y
.8eec	c8		iny				iny
.8eed	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8eef	d0 07		bne $8ef8			bne 	CNAFail
.8ef1	60		rts				rts
.8ef2					CheckNextA:
.8ef2	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8ef4	d0 02		bne $8ef8			bne 	CNAFail
.8ef6	c8		iny				iny 								; skip character
.8ef7	60		rts				rts 								; and exit
.8ef8					CNAFail:
.8ef8	4c a0 9f	jmp $9fa0			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8efb					ErrorHandler:
.8efb	a8		tay				tay 								; find the error text
.8efc	f0 49		beq $8f47			beq 	_EHEnd
.8efe	a2 00		ldx #$00			ldx 	#0
.8f00	a9 b9		lda #$b9			lda 	#((ErrorText) & $FF)
.8f02	85 36		sta $36				sta 	0+zTemp0
.8f04	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8f06	85 37		sta $37				sta 	1+zTemp0
.8f08					_EHFind:
.8f08	88		dey				dey 								; keep looking through text
.8f09	f0 0e		beq $8f19			beq 	_EHFound
.8f0b					_EHFindZero:
.8f0b	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8f0d	e6 36		inc $36				inc 	zTemp0
.8f0f	d0 02		bne $8f13			bne 	_EHFNoCarry
.8f11	e6 37		inc $37				inc 	zTemp0+1
.8f13					_EHFNoCarry:
.8f13	c9 00		cmp #$00			cmp 	#0
.8f15	d0 f4		bne $8f0b			bne 	_EHFindZero
.8f17	80 ef		bra $8f08			bra 	_EHFind
.8f19					_EHFound:
.8f19	a5 36		lda $36				lda 	zTemp0 						; print message
.8f1b	a6 37		ldx $37				ldx 	zTemp0+1
.8f1d	20 54 8f	jsr $8f54			jsr 	PrintStringXA
.8f20	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8f22	b1 30		lda ($30),y			lda 	(codePtr),y
.8f24	d0 05		bne $8f2b			bne 	_EHAtMsg
.8f26	c8		iny				iny
.8f27	b1 30		lda ($30),y			lda 	(codePtr),y
.8f29	f0 17		beq $8f42			beq 	_EHCREnd
.8f2b					_EHAtMsg:
.8f2b	a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8f2d	a9 4a		lda #$4a			lda 	#_AtMsg & $FF
.8f2f	20 54 8f	jsr $8f54			jsr 	PrintStringXA
.8f32	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f34	b1 30		lda ($30),y			lda 	(codePtr),y
.8f36	48		pha				pha
.8f37	c8		iny				iny
.8f38	b1 30		lda ($30),y			lda 	(codePtr),y
.8f3a	aa		tax				tax
.8f3b	68		pla				pla
.8f3c	20 6a 93	jsr $936a			jsr 	ConvertInt16 				; convert XA to string
.8f3f	20 54 8f	jsr $8f54			jsr 	PrintStringXA 				; and print it.
.8f42					_EHCREnd:
.8f42	a9 0d		lda #$0d			lda 	#13 						; new line
.8f44	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f47					_EHEnd:
.8f47	4c da 83	jmp $83da			jmp 	WarmStart
>8f4a	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8f52	20 00
.8f54					PrintStringXA:
.8f54	5a		phy				phy
.8f55	86 37		stx $37				stx 	zTemp0+1
.8f57	85 36		sta $36				sta 	zTemp0
.8f59	a0 00		ldy #$00			ldy 	#0
.8f5b					_PSXALoop:
.8f5b	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f5d	f0 06		beq $8f65			beq 	_PSXAExit
.8f5f	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f62	c8		iny				iny
.8f63	80 f6		bra $8f5b			bra 	_PSXALoop
.8f65					_PSXAExit:
.8f65	7a		ply				ply
.8f66	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f67					UnaryTrue:
.8f67	fa		plx				plx
.8f68					ReturnTrue:
.8f68	a9 01		lda #$01			lda 	#1  						; set to 1
.8f6a	20 24 9e	jsr $9e24			jsr 	NSMSetByte
.8f6d	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f6f	95 50		sta $50,x			sta 	NSStatus,x
.8f71	60		rts				rts
.8f72					UnaryFalse:
.8f72	fa		plx				plx
.8f73					ReturnFalse:
.8f73	4c 22 9e	jmp $9e22			jmp 	NSMSetZero 					; set it all to zero
.8f76					BinaryCompareEqual:
.8f76	fa		plx				plx
.8f77	20 b2 8f	jsr $8fb2			jsr 	CompareBaseCode
.8f7a	c9 00		cmp #$00			cmp 	#0
.8f7c	f0 ea		beq $8f68			beq 	ReturnTrue
.8f7e	80 f3		bra $8f73			bra 	ReturnFalse
.8f80					BinaryCompareLess:
.8f80	fa		plx				plx
.8f81	20 b2 8f	jsr $8fb2			jsr 	CompareBaseCode
.8f84	c9 ff		cmp #$ff			cmp 	#$FF
.8f86	f0 e0		beq $8f68			beq 	ReturnTrue
.8f88	80 e9		bra $8f73			bra 	ReturnFalse
.8f8a					BinaryCompareGreater:
.8f8a	fa		plx				plx
.8f8b	20 b2 8f	jsr $8fb2			jsr 	CompareBaseCode
.8f8e	c9 01		cmp #$01			cmp 	#1
.8f90	f0 d6		beq $8f68			beq 	ReturnTrue
.8f92	80 df		bra $8f73			bra 	ReturnFalse
.8f94					BinaryCompareNotEqual:
.8f94	fa		plx				plx
.8f95	20 b2 8f	jsr $8fb2			jsr 	CompareBaseCode
.8f98	c9 00		cmp #$00			cmp 	#0
.8f9a	d0 cc		bne $8f68			bne 	ReturnTrue
.8f9c	80 d5		bra $8f73			bra 	ReturnFalse
.8f9e					BinaryCompareLessEqual:
.8f9e	fa		plx				plx
.8f9f	20 b2 8f	jsr $8fb2			jsr 	CompareBaseCode
.8fa2	c9 01		cmp #$01			cmp 	#1
.8fa4	d0 c2		bne $8f68			bne 	ReturnTrue
.8fa6	80 cb		bra $8f73			bra 	ReturnFalse
.8fa8					BinaryCompareGreaterEqual:
.8fa8	fa		plx				plx
.8fa9	20 b2 8f	jsr $8fb2			jsr 	CompareBaseCode
.8fac	c9 ff		cmp #$ff			cmp 	#$FF
.8fae	d0 b8		bne $8f68			bne 	ReturnTrue
.8fb0	80 c1		bra $8f73			bra 	ReturnFalse
.8fb2					CompareBaseCode:
.8fb2	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; make both values if references.
.8fb5	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8fb7	15 51		ora $51,x			ora 	NSStatus+1,x
.8fb9	29 10		and #$10			and 	#NSTString
.8fbb	d0 37		bne $8ff4			bne 	_CBCString 					; if so do string code, which will check if both.
.8fbd	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8fbf	15 79		ora $79,x			ora 	NSExponent+1,x
.8fc1	d0 34		bne $8ff7			bne 	_CBCFloat
.8fc3	b5 50		lda $50,x			lda 	NSStatus,x
.8fc5	15 51		ora $51,x			ora 	NSStatus+1,x
.8fc7	29 08		and #$08			and 	#NSTFloat
.8fc9	d0 2c		bne $8ff7			bne 	_CBCFloat
.8fcb	20 fa 8f	jsr $8ffa			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8fce	e8		inx				inx
.8fcf	20 fa 8f	jsr $8ffa			jsr 	CompareFixMinusZero
.8fd2	ca		dex				dex
.8fd3	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8fd5	55 51		eor $51,x			eor 	NSStatus+1,x
.8fd7	10 0a		bpl $8fe3			bpl 	_CDCSameSign
.8fd9	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8fdb	30 14		bmi $8ff1			bmi 	_CBCLess 					; return $FF
.8fdd					_CBCGreater:
.8fdd	a9 01		lda #$01			lda 	#1
.8fdf	60		rts				rts
.8fe0					_CBCEqual:
.8fe0	a9 00		lda #$00			lda 	#0
.8fe2	60		rts				rts
.8fe3					_CDCSameSign:
.8fe3	20 0f 92	jsr $920f			jsr 	SubTopTwoStack 				; unsigned subtract
.8fe6	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; or the mantissa together
.8fe9	f0 f5		beq $8fe0			beq 	_CBCEqual 					; -0 == 0
.8feb	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8fed	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8fef	10 ec		bpl $8fdd			bpl 	_CBCGreater
.8ff1					_CBCLess:
.8ff1	a9 ff		lda #$ff			lda 	#$FF
.8ff3	60		rts				rts
.8ff4					_CBCString:
.8ff4	4c 80 91	jmp $9180			jmp 	CompareStrings
.8ff7					_CBCFloat:
.8ff7	4c ca 94	jmp $94ca			jmp 	CompareFloat
.8ffa					CompareFixMinusZero:
.8ffa	20 44 9e	jsr $9e44			jsr 	NSMIsZero
.8ffd	d0 02		bne $9001			bne 	_CFXMZNotZero
.8fff	74 50		stz $50,x			stz 	NSStatus,x
.9001					_CFXMZNotZero:
.9001	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9002					StringConcat:
.9002	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9004	35 51		and $51,x			and 	NSStatus+1,x
.9006	29 18		and #$18			and 	#NSBTypeMask
.9008	c9 10		cmp #$10			cmp 	#NSTString
.900a	d0 50		bne $905c			bne		_SCType
.900c	64 38		stz $38				stz 	zTemp1 						; counting total length
.900e	e8		inx				inx
.900f	20 2d 90	jsr $902d			jsr 	_SCSetupZ0 					; setup for second
.9012	20 36 90	jsr $9036			jsr 	_SCLengthZ0 				; length for second
.9015	ca		dex				dex
.9016	20 2d 90	jsr $902d			jsr 	_SCSetupZ0 					; setup for first
.9019	20 36 90	jsr $9036			jsr 	_SCLengthZ0 				; length for first
.901c	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.901e	20 b4 a7	jsr $a7b4			jsr 	StringTempAllocate
.9021	20 4d 90	jsr $904d			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9024	e8		inx				inx
.9025	20 2d 90	jsr $902d			jsr 	_SCSetupZ0 					; copy second out
.9028	20 4d 90	jsr $904d			jsr 	_SCCopy
.902b	ca		dex				dex
.902c	60		rts				rts
.902d					_SCSetupZ0:
.902d	b5 58		lda $58,x			lda 	NSMantissa0,x
.902f	85 36		sta $36				sta 	zTemp0
.9031	b5 60		lda $60,x			lda 	NSMantissa1,x
.9033	85 37		sta $37				sta 	zTemp0+1
.9035	60		rts				rts
.9036					_SCLengthZ0:
.9036	5a		phy				phy
.9037	a0 00		ldy #$00			ldy 	#0
.9039					_SCLenLoop:
.9039	b1 36		lda ($36),y			lda 	(zTemp0),y
.903b	f0 0e		beq $904b			beq 	_SCLExit
.903d	c8		iny				iny
.903e	e6 38		inc $38				inc 	zTemp1
.9040	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9042	c9 fd		cmp #$fd			cmp 	#253
.9044	d0 f3		bne $9039			bne		_SCLenLoop
.9046	a9 09		lda #$09		lda	#9
.9048	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.904b					_SCLExit:
.904b	7a		ply				ply
.904c	60		rts				rts
.904d					_SCCopy:
.904d	5a		phy				phy
.904e	a0 00		ldy #$00			ldy 	#0
.9050					_SCCopyLoop:
.9050	b1 36		lda ($36),y			lda 	(zTemp0),y
.9052	f0 06		beq $905a			beq 	_SCCExit
.9054	20 ed a7	jsr $a7ed			jsr 	StringTempWrite
.9057	c8		iny				iny
.9058	80 f6		bra $9050			bra 	_SCCopyLoop
.905a					_SCCExit:
.905a	7a		ply				ply
.905b	60		rts				rts
.905c					_SCType:
.905c	4c aa 9f	jmp $9faa			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.905f					IntegerDivide:
.905f	fa		plx				plx
.9060	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9062	15 51		ora $51,x			ora 	NSStatus+1,x
.9064	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9065	0a		asl a				asl 	a
.9066	10 05		bpl $906d			bpl 	_NotRef
.9068	48		pha				pha
.9069	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.906c	68		pla				pla
.906d					_NotRef:
.906d	0a		asl a				asl 	a
.906e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9070	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9072	15 79		ora $79,x			ora 	NSExponent+1,x
.9074	f0 03		beq $9079			beq 	_IntegerCode 				; if clear, then we have two integers
.9076	4c aa 9f	jmp $9faa			jmp 	TypeError 					; anything else, type mismatch.
.9079					_IntegerCode:
.9079	20 93 90	jsr $9093			jsr 	CheckDivideZero 			; do div zero check
.907c	20 c5 90	jsr $90c5			jsr 	Int32Divide 				; do the division
.907f	20 76 91	jsr $9176			jsr 	CalculateSign 				; calculate result sign
.9082					NSMCopyPlusTwoToZero:
.9082	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9084	95 58		sta $58,x			sta 	NSMantissa0,x
.9086	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.9088	95 60		sta $60,x			sta 	NSMantissa1,x
.908a	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.908c	95 68		sta $68,x			sta 	NSMantissa2,x
.908e	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.9090	95 70		sta $70,x			sta 	NSMantissa3,x
.9092	60		rts				rts
.9093					CheckDivideZero:
.9093	e8		inx				inx
.9094	20 44 9e	jsr $9e44			jsr 	NSMIsZero
.9097	f0 02		beq $909b			beq 	_CDVError
.9099	ca		dex				dex
.909a	60		rts				rts
.909b					_CDVError:
.909b	a9 03		lda #$03		lda	#3
.909d	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.90a0					IntegerModulus:
.90a0	fa		plx				plx
.90a1	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90a3	15 51		ora $51,x			ora 	NSStatus+1,x
.90a5	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90a6	0a		asl a				asl 	a
.90a7	10 05		bpl $90ae			bpl 	_NotRef
.90a9	48		pha				pha
.90aa	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90ad	68		pla				pla
.90ae					_NotRef:
.90ae	0a		asl a				asl 	a
.90af	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90b1	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90b3	15 79		ora $79,x			ora 	NSExponent+1,x
.90b5	f0 03		beq $90ba			beq 	_IntegerCode 				; if clear, then we have two integers
.90b7	4c aa 9f	jmp $9faa			jmp 	TypeError 					; anything else, type mismatch.
.90ba					_IntegerCode:
.90ba					IntegerModulusNoCheck:
.90ba	20 93 90	jsr $9093			jsr 	CheckDivideZero 			; do div zero check
.90bd	20 c5 90	jsr $90c5			jsr 	Int32Divide 				; do the division
.90c0	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.90c2	56 50		lsr $50,x			lsr 	NSStatus,x
.90c4	60		rts				rts
.90c5					Int32Divide:
.90c5	48		pha				pha 								; save AXY
.90c6	5a		phy				phy
.90c7	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90ca	20 1e 9e	jsr $9e1e			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.90cd	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.90cf					_I32DivideLoop:
.90cf	e8		inx				inx
.90d0	e8		inx				inx
.90d1	20 31 9e	jsr $9e31			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.90d4	ca		dex				dex
.90d5	ca		dex				dex
.90d6	20 32 9e	jsr $9e32			jsr 	NSMRotateLeft
.90d9	20 04 91	jsr $9104			jsr 	DivideCheckSubtract 		; check if subtract possible
.90dc	90 02		bcc $90e0			bcc 	_I32DivideNoCarryIn
.90de	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.90e0					_I32DivideNoCarryIn:
.90e0	88		dey				dey 								; loop round till division completed.
.90e1	d0 ec		bne $90cf			bne 	_I32DivideLoop
.90e3	7a		ply				ply 								; restore AXY and exit
.90e4	68		pla				pla
.90e5	60		rts				rts
.90e6					Int32ShiftDivide:
.90e6	48		pha				pha 								; save AY
.90e7	5a		phy				phy
.90e8	e8		inx				inx 								; clear S[X+2]
.90e9	e8		inx				inx
.90ea	20 22 9e	jsr $9e22			jsr 	NSMSetZero
.90ed	ca		dex				dex
.90ee	ca		dex				dex
.90ef	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.90f1					_I32SDLoop:
.90f1	20 04 91	jsr $9104			jsr 	DivideCheckSubtract 		; check if subtract possible
.90f4	e8		inx				inx
.90f5	e8		inx				inx
.90f6	20 32 9e	jsr $9e32			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.90f9	ca		dex				dex
.90fa	ca		dex				dex
.90fb	20 32 9e	jsr $9e32			jsr 	NSMRotateLeft
.90fe	88		dey				dey 	 							; do 31 times
.90ff	d0 f0		bne $90f1			bne 	_I32SDLoop
.9101	7a		ply				ply 								; restore AY and exit
.9102	68		pla				pla
.9103	60		rts				rts
.9104					DivideCheckSubtract:
.9104	20 0f 92	jsr $920f			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9107	b0 04		bcs $910d			bcs 	_DCSExit 					; if carry set, then could do, exit
.9109	20 f5 91	jsr $91f5			jsr 	AddTopTwoStack 				; add it back in
.910c	18		clc				clc 								; and return False
.910d					_DCSExit:
.910d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.910e					MulInteger:
.910e	fa		plx				plx
.910f	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9111	15 51		ora $51,x			ora 	NSStatus+1,x
.9113	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9114	0a		asl a				asl 	a
.9115	10 05		bpl $911c			bpl 	_NotRef
.9117	48		pha				pha
.9118	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.911b	68		pla				pla
.911c					_NotRef:
.911c	0a		asl a				asl 	a 							; put MSB of type into A:7
.911d	30 09		bmi $9128			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.911f	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9121	15 79		ora $79,x			ora 	NSExponent+1,x
.9123	f0 06		beq $912b			beq 	_IntegerCode 				; if clear, then we have two integers
.9125	4c 8c 95	jmp $958c			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9128					_StringData:
.9128	4c b4 9f	jmp $9fb4			jmp 	NotDoneError							; at least one string - don't know both are strings.
.912b					_IntegerCode:
.912b	20 38 91	jsr $9138			jsr 	MultiplyShort
.912e	c9 00		cmp #$00			cmp 	#0
.9130	f0 05		beq $9137			beq 	_MIExit
.9132	a9 04		lda #$04		lda	#4
.9134	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.9137					_MIExit:
.9137	60		rts				rts
.9138					MultiplyShort:
.9138	5a		phy				phy 								; save Y
.9139	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.913c	20 1e 9e	jsr $9e1e			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.913f	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9141					_I32MLoop:
.9141	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9143	15 62		ora $62,x			ora 	NSMantissa1+2,x
.9145	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.9147	15 72		ora $72,x			ora 	NSMantissa3+2,x
.9149	f0 25		beq $9170			beq 	_I32MExit 					; exit if zero
.914b	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.914d	29 01		and #$01			and 	#1
.914f	f0 0d		beq $915e			beq 	_I32MNoAdd
.9151	20 f5 91	jsr $91f5			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9154	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9156	10 06		bpl $915e			bpl 	_I32MNoAdd
.9158					_I32ShiftRight:
.9158	20 3b 9e	jsr $9e3b			jsr 	NSMShiftRight 				; shift S[X] right
.915b	c8		iny				iny 								; increment shift count
.915c	80 09		bra $9167			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.915e					_I32MNoAdd:
.915e	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9160	70 f6		bvs $9158			bvs 	_I32ShiftRight 				; instead.
.9162	e8		inx				inx
.9163	20 31 9e	jsr $9e31			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9166	ca		dex				dex
.9167					_I32MShiftUpper:
.9167	e8		inx				inx 								; shift S[X+2] right
.9168	e8		inx				inx
.9169	20 3b 9e	jsr $9e3b			jsr 	NSMShiftRight
.916c	ca		dex				dex
.916d	ca		dex				dex
.916e	80 d1		bra $9141			bra 	_I32MLoop 					; try again.
.9170					_I32MExit:
.9170	20 76 91	jsr $9176			jsr 	CalculateSign
.9173	98		tya				tya 								; shift in A
.9174	7a		ply				ply 								; restore Y and exit
.9175	60		rts				rts
.9176					CalculateSign:
.9176	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9178	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.917a	55 51		eor $51,x			eor 	NSStatus+1,x
.917c	0a		asl a				asl 	a 							; shift bit 7 into carry
.917d	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.917f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9180					CompareStrings:
.9180	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.9182	35 51		and $51,x			and 	NSStatus+1,x
.9184	29 10		and #$10			and 	#NSBIsString
.9186	f0 28		beq $91b0			beq 	_CSTypeError
.9188	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.918a	85 36		sta $36				sta 	zTemp0
.918c	b5 60		lda $60,x			lda 	NSMantissa1,x
.918e	85 37		sta $37				sta 	zTemp0+1
.9190	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9192	85 38		sta $38				sta 	zTemp1
.9194	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9196	85 39		sta $39				sta 	zTemp1+1
.9198	5a		phy				phy 								; save Y so we can access strings
.9199	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.919b					_CSLoop:
.919b	c8		iny				iny
.919c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.919e	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.91a0	d0 06		bne $91a8			bne 	_CSDifferent
.91a2	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.91a4	d0 f5		bne $919b			bne 	_CSLoop 					; still comparing
.91a6					_CSExit:
.91a6	7a		ply				ply 								; reached end, return zero in A from EOS
.91a7	60		rts				rts
.91a8					_CSDifferent:
.91a8	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.91aa	90 fa		bcc $91a6			bcc		_CSExit
.91ac	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.91ae	80 f6		bra $91a6			bra 	_CSExit
.91b0					_CSTypeError:
.91b0	4c aa 9f	jmp $9faa			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.91b3					ShiftLeft:
.91b3	38		sec				sec 								; common code, carry determines which way.
.91b4	80 01		bra $91b7			bra 	ShiftMain
.91b6					ShiftRight:
.91b6	18		clc				clc
.91b7					ShiftMain:
.91b7	fa		plx				plx 								; restore X
.91b8	08		php				php 								; save direction
.91b9	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91bb	15 51		ora $51,x			ora 	NSStatus+1,x
.91bd	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91be	0a		asl a				asl 	a
.91bf	10 05		bpl $91c6			bpl 	_NotRef
.91c1	48		pha				pha
.91c2	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91c5	68		pla				pla
.91c6					_NotRef:
.91c6	0a		asl a				asl 	a
.91c7	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91c9	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91cb	15 79		ora $79,x			ora 	NSExponent+1,x
.91cd	f0 03		beq $91d2			beq 	_IntegerCode 				; if clear, then we have two integers
.91cf	4c aa 9f	jmp $9faa			jmp 	TypeError 					; anything else, type mismatch.
.91d2					_IntegerCode:
.91d2	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.91d4	29 e0		and #$e0			and 	#$E0
.91d6	15 61		ora $61,x			ora 	NSMantissa1+1,x
.91d8	15 69		ora $69,x			ora 	NSMantissa2+1,x
.91da	15 71		ora $71,x			ora 	NSMantissa3+1,x
.91dc	d0 12		bne $91f0			bne 	_SMExit0 					; if >= 32 it will always return zero.
.91de					_SMLoop:
.91de	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.91e0	30 11		bmi $91f3			bmi 	_SMExit 					; exit if done.
.91e2	28		plp				plp 								; restore direction setting
.91e3	08		php				php
.91e4	90 05		bcc $91eb			bcc 	_SMRight
.91e6	20 31 9e	jsr $9e31			jsr 	NSMShiftLeft 				; shift left if CS
.91e9	80 f3		bra $91de			bra 	_SMLoop
.91eb					_SMRight:
.91eb	20 3b 9e	jsr $9e3b			jsr 	NSMShiftRight 				; shift right if CC
.91ee	80 ee		bra $91de			bra 	_SMLoop
.91f0					_SMExit0:
.91f0	20 22 9e	jsr $9e22			jsr 	NSMSetZero 					; return zero.
.91f3					_SMExit:
.91f3	28		plp				plp 								; throw direction
.91f4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.91f5					AddTopTwoStack:
.91f5	18		clc				clc
.91f6	b5 58		lda $58,x			lda		NSMantissa0,x
.91f8	75 59		adc $59,x			adc 		NSMantissa0+1,x
.91fa	95 58		sta $58,x			sta 	NSMantissa0,x
.91fc	b5 60		lda $60,x			lda		NSMantissa1,x
.91fe	75 61		adc $61,x			adc 		NSMantissa1+1,x
.9200	95 60		sta $60,x			sta 	NSMantissa1,x
.9202	b5 68		lda $68,x			lda		NSMantissa2,x
.9204	75 69		adc $69,x			adc 		NSMantissa2+1,x
.9206	95 68		sta $68,x			sta 	NSMantissa2,x
.9208	b5 70		lda $70,x			lda		NSMantissa3,x
.920a	75 71		adc $71,x			adc 		NSMantissa3+1,x
.920c	95 70		sta $70,x			sta 	NSMantissa3,x
.920e	60		rts				rts
.920f					SubTopTwoStack:
.920f	38		sec				sec
.9210	b5 58		lda $58,x			lda		NSMantissa0,x
.9212	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9214	95 58		sta $58,x			sta 	NSMantissa0,x
.9216	b5 60		lda $60,x			lda		NSMantissa1,x
.9218	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.921a	95 60		sta $60,x			sta 	NSMantissa1,x
.921c	b5 68		lda $68,x			lda		NSMantissa2,x
.921e	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.9220	95 68		sta $68,x			sta 	NSMantissa2,x
.9222	b5 70		lda $70,x			lda		NSMantissa3,x
.9224	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.9226	95 70		sta $70,x			sta 	NSMantissa3,x
.9228	60		rts				rts
.9229					AddInteger:
.9229	fa		plx				plx
.922a	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.922c	15 51		ora $51,x			ora 	NSStatus+1,x
.922e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.922f	0a		asl a				asl 	a
.9230	10 05		bpl $9237			bpl 	_NotRef
.9232	48		pha				pha
.9233	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9236	68		pla				pla
.9237					_NotRef:
.9237	0a		asl a				asl 	a 							; put MSB of type into A:7
.9238	30 09		bmi $9243			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.923a	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.923c	15 79		ora $79,x			ora 	NSExponent+1,x
.923e	f0 06		beq $9246			beq 	_IntegerCode 				; if clear, then we have two integers
.9240	4c 3c 94	jmp $943c			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9243					_StringData:
.9243	4c 02 90	jmp $9002			jmp 	StringConcat							; at least one string - don't know both are strings.
.9246					_IntegerCode:
.9246					AddCode:
.9246	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9248	55 51		eor $51,x			eor 	NSStatus+1,x
.924a	10 a9		bpl $91f5			bpl 	AddTopTwoStack
.924c	20 0f 92	jsr $920f			jsr 	SubTopTwoStack 				; do a physical subtraction
.924f	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9251	10 07		bpl $925a			bpl 	_AddExit
.9253	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9255	95 50		sta $50,x			sta 	NSStatus,x
.9257	20 eb 9d	jsr $9deb			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.925a					_AddExit:
.925a	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; check for -0
.925d	d0 02		bne $9261			bne 	_AddNonZero
.925f	74 50		stz $50,x			stz 	NSStatus,x
.9261					_AddNonZero:
.9261	60		rts				rts
.9262					SubInteger:
.9262	fa		plx				plx
.9263	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9265	15 51		ora $51,x			ora 	NSStatus+1,x
.9267	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9268	0a		asl a				asl 	a
.9269	10 05		bpl $9270			bpl 	_NotRef
.926b	48		pha				pha
.926c	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.926f	68		pla				pla
.9270					_NotRef:
.9270	0a		asl a				asl 	a 							; put MSB of type into A:7
.9271	30 09		bmi $927c			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9273	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9275	15 79		ora $79,x			ora 	NSExponent+1,x
.9277	f0 06		beq $927f			beq 	_IntegerCode 				; if clear, then we have two integers
.9279	4c 41 94	jmp $9441			jmp 	FloatingPointSub 							; otherwise at least one float.
.927c					_StringData:
.927c	4c b4 9f	jmp $9fb4			jmp 	NotDoneError							; at least one string - don't know both are strings.
.927f					_IntegerCode:
.927f	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.9281	49 80		eor #$80			eor 	#$80
.9283	95 51		sta $51,x			sta 	NSStatus+1,x
.9285	80 bf		bra $9246			bra 	AddCode 					; and do the same code as add.
.9287					AndInteger:
.9287	fa		plx				plx
.9288	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.928a	15 51		ora $51,x			ora 	NSStatus+1,x
.928c	0a		asl a				asl 	a 							; shift reference bit into sign bit
.928d	0a		asl a				asl 	a
.928e	10 05		bpl $9295			bpl 	_NotRef
.9290	48		pha				pha
.9291	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9294	68		pla				pla
.9295					_NotRef:
.9295	0a		asl a				asl 	a
.9296	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9298	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.929a	15 79		ora $79,x			ora 	NSExponent+1,x
.929c	f0 03		beq $92a1			beq 	_IntegerCode 				; if clear, then we have two integers
.929e	4c aa 9f	jmp $9faa			jmp 	TypeError 					; anything else, type mismatch.
.92a1					_IntegerCode:
.92a1	b5 58		lda $58,x			lda		NSMantissa0,x
.92a3	35 59		and $59,x			and 		NSMantissa0+1,x
.92a5	95 58		sta $58,x			sta 	NSMantissa0,x
.92a7	b5 60		lda $60,x			lda		NSMantissa1,x
.92a9	35 61		and $61,x			and 		NSMantissa1+1,x
.92ab	95 60		sta $60,x			sta 	NSMantissa1,x
.92ad	b5 68		lda $68,x			lda		NSMantissa2,x
.92af	35 69		and $69,x			and 		NSMantissa2+1,x
.92b1	95 68		sta $68,x			sta 	NSMantissa2,x
.92b3	b5 70		lda $70,x			lda		NSMantissa3,x
.92b5	35 71		and $71,x			and 		NSMantissa3+1,x
.92b7	95 70		sta $70,x			sta 	NSMantissa3,x
.92b9	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92bb	60		rts				rts
.92bc					OraInteger:
.92bc	fa		plx				plx
.92bd	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92bf	15 51		ora $51,x			ora 	NSStatus+1,x
.92c1	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92c2	0a		asl a				asl 	a
.92c3	10 05		bpl $92ca			bpl 	_NotRef
.92c5	48		pha				pha
.92c6	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92c9	68		pla				pla
.92ca					_NotRef:
.92ca	0a		asl a				asl 	a
.92cb	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92cd	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92cf	15 79		ora $79,x			ora 	NSExponent+1,x
.92d1	f0 03		beq $92d6			beq 	_IntegerCode 				; if clear, then we have two integers
.92d3	4c aa 9f	jmp $9faa			jmp 	TypeError 					; anything else, type mismatch.
.92d6					_IntegerCode:
.92d6	b5 58		lda $58,x			lda		NSMantissa0,x
.92d8	15 59		ora $59,x			ora 		NSMantissa0+1,x
.92da	95 58		sta $58,x			sta 	NSMantissa0,x
.92dc	b5 60		lda $60,x			lda		NSMantissa1,x
.92de	15 61		ora $61,x			ora 		NSMantissa1+1,x
.92e0	95 60		sta $60,x			sta 	NSMantissa1,x
.92e2	b5 68		lda $68,x			lda		NSMantissa2,x
.92e4	15 69		ora $69,x			ora 		NSMantissa2+1,x
.92e6	95 68		sta $68,x			sta 	NSMantissa2,x
.92e8	b5 70		lda $70,x			lda		NSMantissa3,x
.92ea	15 71		ora $71,x			ora 		NSMantissa3+1,x
.92ec	95 70		sta $70,x			sta 	NSMantissa3,x
.92ee	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92f0	60		rts				rts
.92f1					EorInteger:
.92f1	fa		plx				plx
.92f2	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92f4	15 51		ora $51,x			ora 	NSStatus+1,x
.92f6	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92f7	0a		asl a				asl 	a
.92f8	10 05		bpl $92ff			bpl 	_NotRef
.92fa	48		pha				pha
.92fb	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92fe	68		pla				pla
.92ff					_NotRef:
.92ff	0a		asl a				asl 	a
.9300	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9302	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9304	15 79		ora $79,x			ora 	NSExponent+1,x
.9306	f0 03		beq $930b			beq 	_IntegerCode 				; if clear, then we have two integers
.9308	4c aa 9f	jmp $9faa			jmp 	TypeError 					; anything else, type mismatch.
.930b					_IntegerCode:
.930b	b5 58		lda $58,x			lda		NSMantissa0,x
.930d	55 59		eor $59,x			eor 		NSMantissa0+1,x
.930f	95 58		sta $58,x			sta 	NSMantissa0,x
.9311	b5 60		lda $60,x			lda		NSMantissa1,x
.9313	55 61		eor $61,x			eor 		NSMantissa1+1,x
.9315	95 60		sta $60,x			sta 	NSMantissa1,x
.9317	b5 68		lda $68,x			lda		NSMantissa2,x
.9319	55 69		eor $69,x			eor 		NSMantissa2+1,x
.931b	95 68		sta $68,x			sta 	NSMantissa2,x
.931d	b5 70		lda $70,x			lda		NSMantissa3,x
.931f	55 71		eor $71,x			eor 		NSMantissa3+1,x
.9321	95 70		sta $70,x			sta 	NSMantissa3,x
.9323	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9325	60		rts				rts
.9326					WordIndirect:
.9326	fa		plx				plx
.9327	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9329	15 51		ora $51,x			ora 	NSStatus+1,x
.932b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.932c	0a		asl a				asl 	a
.932d	10 05		bpl $9334			bpl 	_NotRef
.932f	48		pha				pha
.9330	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9333	68		pla				pla
.9334					_NotRef:
.9334	0a		asl a				asl 	a
.9335	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9337	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9339	15 79		ora $79,x			ora 	NSExponent+1,x
.933b	f0 03		beq $9340			beq 	_IntegerCode 				; if clear, then we have two integers
.933d	4c aa 9f	jmp $9faa			jmp 	TypeError 					; anything else, type mismatch.
.9340					_IntegerCode:
.9340	20 46 92	jsr $9246			jsr 	AddCode 					; add the two values
.9343	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9345	95 50		sta $50,x			sta 	NSStatus,x
.9347	60		rts				rts
.9348					ByteIndirect:
.9348	fa		plx				plx
.9349	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.934b	15 51		ora $51,x			ora 	NSStatus+1,x
.934d	0a		asl a				asl 	a 							; shift reference bit into sign bit
.934e	0a		asl a				asl 	a
.934f	10 05		bpl $9356			bpl 	_NotRef
.9351	48		pha				pha
.9352	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9355	68		pla				pla
.9356					_NotRef:
.9356	0a		asl a				asl 	a
.9357	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9359	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.935b	15 79		ora $79,x			ora 	NSExponent+1,x
.935d	f0 03		beq $9362			beq 	_IntegerCode 				; if clear, then we have two integers
.935f	4c aa 9f	jmp $9faa			jmp 	TypeError 					; anything else, type mismatch.
.9362					_IntegerCode:
.9362	20 46 92	jsr $9246			jsr 	AddCode 					; add the two values
.9365	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9367	95 50		sta $50,x			sta 	NSStatus,x
.9369	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.936a					ConvertInt16:
.936a	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.936c	86 60		stx $60				stx 	NSMantissa1
.936e	64 68		stz $68				stz 	NSMantissa2
.9370	64 70		stz $70				stz 	NSMantissa3
.9372	64 50		stz $50				stz 	NSStatus 					; positive integer
.9374	a2 00		ldx #$00			ldx 	#0 							; stack level
.9376	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.9378	80 00		bra $937a			bra 	ConvertInt32
.937a					ConvertInt32:
.937a	5a		phy				phy
.937b	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.937d	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.937f	10 08		bpl $9389			bpl 	_CI32NotNeg
.9381	48		pha				pha
.9382	a9 2d		lda #$2d			lda 	#'-'
.9384	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.9387	c8		iny				iny
.9388	68		pla				pla
.9389					_CI32NotNeg:
.9389	20 97 93	jsr $9397			jsr 	_CI32DivideConvert 			; recursive conversion
.938c	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.938e	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.9391	7a		ply				ply
.9392	a2 06		ldx #$06			ldx 	#NumberBuffer >> 8 			; return address in XA
.9394	a9 27		lda #$27			lda 	#NumberBuffer & $FF
.9396	60		rts				rts
.9397					_CI32DivideConvert:
.9397	e8		inx				inx 								; write to next slot up
.9398	20 24 9e	jsr $9e24			jsr 	NSMSetByte 		 			; write the base out.
.939b	ca		dex				dex
.939c	20 c5 90	jsr $90c5			jsr 	Int32Divide 				; divide
.939f	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.93a1	48		pha				pha
.93a2	20 82 90	jsr $9082			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.93a5	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; is it zero ?
.93a8	f0 05		beq $93af			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.93aa	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.93ac	20 97 93	jsr $9397			jsr 	_CI32DivideConvert 			; and recusrively call.
.93af					_CI32NoRecurse:
.93af	68		pla				pla 								; remainder
.93b0	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.93b2	90 02		bcc $93b6			bcc 	_CI32NotHex
.93b4	69 26		adc #$26			adc 	#6+32
.93b6					_CI32NotHex:
.93b6	69 30		adc #$30			adc 	#48
.93b8	99 27 06	sta $0627,y			sta 	NumberBuffer,y 				; write out and exit
.93bb	c8		iny				iny
.93bc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.93bd					PrecedenceLevel:
>93bd	04					.byte	 4	; $00 <<
>93be	02					.byte	 2	; $01 <=
>93bf	02					.byte	 2	; $02 <>
>93c0	00					.byte	 0	; $03 !!3
>93c1	00					.byte	 0	; $04 ><
>93c2	02					.byte	 2	; $05 >=
>93c3	04					.byte	 4	; $06 >>
>93c4	00					.byte	 0	; $07 !!7
>93c5	00					.byte	 0	; $08 !!8
>93c6	00					.byte	 0	; $09 !!9
>93c7	00					.byte	 0	; $0a !!10
>93c8	00					.byte	 0	; $0b !!11
>93c9	00					.byte	 0	; $0c !!12
>93ca	00					.byte	 0	; $0d !!13
>93cb	00					.byte	 0	; $0e !!14
>93cc	00					.byte	 0	; $0f !!15
>93cd	00					.byte	 0	; $10 @
>93ce	00					.byte	 0	; $11 !!17
>93cf	00					.byte	 0	; $12 !!18
>93d0	00					.byte	 0	; $13 [
>93d1	04					.byte	 4	; $14 \
>93d2	00					.byte	 0	; $15 ]
>93d3	01					.byte	 1	; $16 ^
>93d4	00					.byte	 0	; $17 _
>93d5	00					.byte	 0	; $18 `
>93d6	00					.byte	 0	; $19 !!25
>93d7	00					.byte	 0	; $1a !!26
>93d8	00					.byte	 0	; $1b {
>93d9	01					.byte	 1	; $1c |
>93da	00					.byte	 0	; $1d }
>93db	00					.byte	 0	; $1e ~
>93dc	00					.byte	 0	; $1f [7m<7F>[m
>93dd	00					.byte	 0	; $20
>93de	05					.byte	 5	; $21 !
>93df	00					.byte	 0	; $22 "
>93e0	00					.byte	 0	; $23 #
>93e1	05					.byte	 5	; $24 $
>93e2	04					.byte	 4	; $25 %
>93e3	01					.byte	 1	; $26 &
>93e4	00					.byte	 0	; $27 '
>93e5	00					.byte	 0	; $28 (
>93e6	00					.byte	 0	; $29 )
>93e7	04					.byte	 4	; $2a *
>93e8	03					.byte	 3	; $2b +
>93e9	00					.byte	 0	; $2c ,
>93ea	03					.byte	 3	; $2d -
>93eb	00					.byte	 0	; $2e .
>93ec	04					.byte	 4	; $2f /
>93ed	00					.byte	 0	; $30 0
>93ee	00					.byte	 0	; $31 1
>93ef	00					.byte	 0	; $32 2
>93f0	00					.byte	 0	; $33 3
>93f1	00					.byte	 0	; $34 4
>93f2	00					.byte	 0	; $35 5
>93f3	00					.byte	 0	; $36 6
>93f4	00					.byte	 0	; $37 7
>93f5	00					.byte	 0	; $38 8
>93f6	00					.byte	 0	; $39 9
>93f7	00					.byte	 0	; $3a :
>93f8	00					.byte	 0	; $3b ;
>93f9	02					.byte	 2	; $3c <
>93fa	02					.byte	 2	; $3d =
>93fb	02					.byte	 2	; $3e >
>93fc	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93fd					EvaluateExpressionAt0:
.93fd	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93ff					EvaluateExpression:
.93ff	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9401					EvaluateExpressionAtPrecedence:
.9401	48		pha				pha 								; save precedence level
.9402	20 49 98	jsr $9849			jsr 	EvaluateTerm 				; evaluate term into level X.
.9405	68		pla				pla 								; restore precedence level.
.9406					_EXPRLoop:
.9406	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9408	b1 30		lda ($30),y			lda 	(codePtr),y
.940a	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.940c	b0 25		bcs $9433			bcs 	_EXPRExit
.940e	da		phx				phx 								; read the operator precedence
.940f	aa		tax				tax
.9410	bd bd 93	lda $93bd,x			lda 	PrecedenceLevel,x
.9413	fa		plx				plx
.9414	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9416	f0 1b		beq $9433			beq 	_EXPRExit
.9418	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.941a	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.941c	c5 37		cmp $37				cmp 	zTemp0+1
.941e	b0 13		bcs $9433			bcs		_EXPRExit 					; if current >= operator exit
.9420	48		pha				pha 								; save current precedence.
.9421	b1 30		lda ($30),y			lda 	(codePtr),y
.9423	c8		iny				iny
.9424	48		pha				pha
.9425	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9427	e8		inx				inx 								; work out the right hand side.
.9428	20 01 94	jsr $9401			jsr 	EvaluateExpressionAtPrecedence
.942b	ca		dex				dex
.942c	68		pla				pla 								; get operator, call the code.
.942d	20 36 94	jsr $9436			jsr 	_EXPRCaller
.9430	68		pla				pla 								; restore precedence level
.9431	80 d3		bra $9406			bra 	_EXPRLoop 					; and go round.
.9433					_EXPRExit:
.9433	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9435	60		rts				rts
.9436					_EXPRCaller:
.9436	da		phx				phx 								; save on stack, first thing is to restore it
.9437	0a		asl a				asl 	a 							; double so can use vectors into X
.9438	aa		tax				tax
.9439	7c 12 8c	jmp ($8c12,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.943c					FloatingPointAdd:
.943c	20 b2 95	jsr $95b2			jsr 	FloatPrepare 				; prepare for floats
.943f	80 09		bra $944a			bra 	FloatAdd
.9441					FloatingPointSub:
.9441	20 b2 95	jsr $95b2			jsr 	FloatPrepare 				; prepare for floats
.9444					FloatSubtract:
.9444	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9446	49 80		eor #$80			eor 	#$80
.9448	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.944a					FloatAdd:
.944a	48		pha				pha
.944b	5a		phy				phy
.944c	20 c1 95	jsr $95c1			jsr 	NSNormalise 				; normalise S[X]
.944f	f0 51		beq $94a2			beq 	_FAReturn1
.9451	e8		inx				inx 								; normalise S[X+1]
.9452	20 c1 95	jsr $95c1			jsr 	NSNormalise
.9455	ca		dex				dex
.9456	c9 00		cmp #$00			cmp 	#0
.9458	f0 60		beq $94ba			beq 	_FAExit 					; if so, just return A
.945a	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.945c	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.945e	f0 18		beq $9478			beq 	_FAExponentsEqual
.9460	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.9462	a8		tay				tay
.9463	38		sec				sec 								; do a signed comparison of the exponents.
.9464	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9466	50 02		bvc $946a			bvc 	_FANoSignedChange
.9468	49 80		eor #$80			eor 	#$80
.946a					_FANoSignedChange:
.946a	29 80		and #$80			and 	#$80
.946c	10 02		bpl $9470			bpl 	_FAHaveMax
.946e	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.9470					_FAHaveMax:
.9470	20 bd 94	jsr $94bd			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9473	e8		inx				inx
.9474	20 bd 94	jsr $94bd			jsr 	_FAShiftToExponent
.9477	ca		dex				dex
.9478					_FAExponentsEqual:
.9478	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.947a	55 51		eor $51,x			eor 	NSStatus+1,x
.947c	30 0e		bmi $948c			bmi 	_FADifferentSigns
.947e	20 f5 91	jsr $91f5			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9481	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9483	10 35		bpl $94ba			bpl 	_FAExit 					; if no, we are done.
.9485	20 3b 9e	jsr $9e3b			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9488	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.948a	80 2e		bra $94ba			bra 	_FAExit
.948c					_FADifferentSigns:
.948c	20 0f 92	jsr $920f			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.948f	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.9491	10 06		bpl $9499			bpl 	_FACheckZero 				; if no, check for -0
.9493	20 e4 9d	jsr $9de4			jsr 	NSMNegate 					; netate result
.9496	20 eb 9d	jsr $9deb			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9499					_FACheckZero:
.9499	20 44 9e	jsr $9e44			jsr 	NSMIsZero	 				; check for -0
.949c	d0 1c		bne $94ba			bne 	_FAExit
.949e	74 50		stz $50,x			stz 	NSStatus,x
.94a0	80 18		bra $94ba			bra 	_FAExit
.94a2					_FAReturn1:
.94a2	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.94a4	95 58		sta $58,x			sta 	NSMantissa0,x
.94a6	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.94a8	95 60		sta $60,x			sta 	NSMantissa1,x
.94aa	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.94ac	95 68		sta $68,x			sta 	NSMantissa2,x
.94ae	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.94b0	95 70		sta $70,x			sta 	NSMantissa3,x
.94b2	b5 79		lda $79,x			lda 	NSExponent+1,x
.94b4	95 78		sta $78,x			sta 	NSExponent,x
.94b6	b5 51		lda $51,x			lda 	NSStatus+1,x
.94b8	95 50		sta $50,x			sta 	NSStatus,x
.94ba					_FAExit:
.94ba	7a		ply				ply
.94bb	68		pla				pla
.94bc	60		rts				rts
.94bd					_FAShiftToExponent:
.94bd					_FAShiftToExponent2:
.94bd	98		tya				tya 								; compare Y to exponent
.94be	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.94c0	f0 07		beq $94c9			beq 	_FASEExit 					; exit if so.
.94c2	20 3b 9e	jsr $9e3b			jsr 	NSMShiftRight	 			; shift the mantissa right
.94c5	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.94c7	80 f4		bra $94bd			bra 	_FAShiftToExponent2
.94c9					_FASEExit:
.94c9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94ca					CompareFloat:
.94ca	20 44 94	jsr $9444			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94cd	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94cf	29 f8		and #$f8			and 	#$F8
.94d1	15 68		ora $68,x			ora 	NSMantissa2,x
.94d3	15 70		ora $70,x			ora 	NSMantissa3,x
.94d5	f0 08		beq $94df			beq 	_FCExit 					; zero, so approximately identical
.94d7	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94d9	34 50		bit $50,x			bit 	NSStatus,x
.94db	10 02		bpl $94df			bpl 	_FCExit
.94dd					_FCNegative:
.94dd	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94df					_FCExit:
.94df	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94e0					FDivideCommand:
.94e0	fa		plx				plx	 								; restore stack position
.94e1	20 b2 95	jsr $95b2			jsr 	FloatPrepare 				; prepare for floats
.94e4					FloatDivide:
.94e4	48		pha				pha
.94e5	e8		inx				inx
.94e6	20 c1 95	jsr $95c1			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94e9	ca		dex				dex
.94ea	c9 00		cmp #$00			cmp 	#0
.94ec	f0 1d		beq $950b			beq 	_FDZero
.94ee	20 c1 95	jsr $95c1			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94f1	f0 16		beq $9509			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94f3	20 e6 90	jsr $90e6			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94f6	20 82 90	jsr $9082			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94f9	20 c1 95	jsr $95c1			jsr		NSNormalise 				; renormalise
.94fc	20 76 91	jsr $9176			jsr 	CalculateSign 				; calculate result sign
.94ff	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.9501	38		sec				sec
.9502	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9504	38		sec				sec
.9505	e9 1e		sbc #$1e			sbc 	#30
.9507	95 78		sta $78,x			sta 	NSExponent,x
.9509					_FDExit:
.9509	68		pla				pla
.950a	60		rts				rts
.950b					_FDZero:
.950b	a9 03		lda #$03		lda	#3
.950d	4c fb 8e	jmp $8efb		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9510					FloatFractionalPart:
.9510	5a		phy				phy
.9511	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9513	29 7f		and #$7f			and 	#$7F
.9515	95 50		sta $50,x			sta 	NSStatus,x
.9517	20 c1 95	jsr $95c1			jsr 	NSNormalise
.951a	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.951c	38		sec				sec
.951d	e9 e0		sbc #$e0			sbc 	#$E0
.951f	90 29		bcc $954a			bcc 	_FFPExit 					; already fractional
.9521	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9523	b0 22		bcs $9547			bcs 	_FFPZero
.9525	a8		tay				tay 								; put count to do in Y
.9526	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.9528	20 4c 95	jsr $954c			jsr 	_FFPPartial
.952b	95 70		sta $70,x			sta 	NSMantissa3,x
.952d	b5 68		lda $68,x			lda 	NSMantissa2,x
.952f	20 4c 95	jsr $954c			jsr 	_FFPPartial
.9532	95 68		sta $68,x			sta 	NSMantissa2,x
.9534	b5 60		lda $60,x			lda 	NSMantissa1,x
.9536	20 4c 95	jsr $954c			jsr 	_FFPPartial
.9539	95 60		sta $60,x			sta 	NSMantissa1,x
.953b	b5 58		lda $58,x			lda 	NSMantissa0,x
.953d	20 4c 95	jsr $954c			jsr 	_FFPPartial
.9540	95 58		sta $58,x			sta 	NSMantissa0,x
.9542	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; zeroed check.
.9545	d0 03		bne $954a			bne 	_FFPExit
.9547					_FFPZero:
.9547	20 22 9e	jsr $9e22			jsr 	NSMSetZero
.954a					_FFPExit:
.954a	7a		ply				ply
.954b	60		rts				rts
.954c					_FFPPartial:
.954c	c0 00		cpy #$00			cpy 	#0 							; no more to do
.954e	f0 17		beq $9567			beq 	_FFFPPExit
.9550	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9552	b0 0c		bcs $9560			bcs 	_FFFPPWholeByte
.9554	5a		phy				phy
.9555					_FFFPPLeft:
.9555	0a		asl a				asl 	a
.9556	88		dey				dey
.9557	d0 fc		bne $9555			bne 	_FFFPPLeft
.9559	7a		ply				ply
.955a					_FFFPPRight:
.955a	4a		lsr a				lsr 	a
.955b	88		dey				dey
.955c	d0 fc		bne $955a			bne 	_FFFPPRight
.955e	80 07		bra $9567			bra 	_FFFPPExit
.9560					_FFFPPWholeByte:
.9560	98		tya				tya 								; subtract 8 from count
.9561	38		sec				sec
.9562	e9 08		sbc #$08			sbc 	#8
.9564	a8		tay				tay
.9565	a9 00		lda #$00			lda 	#0 							; and clear all
.9567					_FFFPPExit:
.9567	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9568					FloatIntegerPart:
.9568	48		pha				pha
.9569	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.956b	f0 1d		beq $958a			beq 	_FIPExit 					; if so do nothing
.956d	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; is it zero ?
.9570	f0 15		beq $9587			beq 	_FIPZero 					; if so return zero.
.9572	20 c1 95	jsr $95c1			jsr 	NSNormalise 				; normalise
.9575	f0 10		beq $9587			beq 	_FIPZero 					; normalised to zero, exit zero
.9577					_FIPShift:
.9577	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9579	10 07		bpl $9582			bpl 	_FIPCheckZero
.957b	20 3b 9e	jsr $9e3b			jsr 	NSMShiftRight 				; shift mantissa right
.957e	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.9580	80 f5		bra $9577			bra 	_FIPShift
.9582					_FIPCheckZero:
.9582	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; avoid -0 problem
.9585	d0 03		bne $958a			bne 	_FIPExit 					; set to zero if mantissa zero.
.9587					_FIPZero:
.9587	20 22 9e	jsr $9e22			jsr 	NSMSetZero
.958a					_FIPExit:
.958a	68		pla				pla
.958b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.958c					FloatingPointMultiply:
.958c	20 b2 95	jsr $95b2			jsr 	FloatPrepare 				; prepare for floats
.958f					FloatMultiply:
.958f	48		pha				pha
.9590	20 c1 95	jsr $95c1			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9593	f0 18		beq $95ad			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.9595	e8		inx				inx
.9596	20 c1 95	jsr $95c1			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9599	ca		dex				dex
.959a	c9 00		cmp #$00			cmp 	#0
.959c	f0 0c		beq $95aa			beq 	_FDSetZero
.959e	20 38 91	jsr $9138			jsr 	MultiplyShort 				; calculate the result.
.95a1	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.95a3	18		clc				clc
.95a4	75 79		adc $79,x			adc 	NSExponent+1,x
.95a6	95 78		sta $78,x			sta 	NSExponent,x
.95a8	80 03		bra $95ad			bra 	_FDExit
.95aa					_FDSetZero:
.95aa	20 22 9e	jsr $9e22			jsr 	NSMSetZero 					; return 0
.95ad					_FDExit:
.95ad	20 c1 95	jsr $95c1			jsr 	NSNormalise 				; normalise the result
.95b0	68		pla				pla
.95b1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95b2					FloatPrepare:
.95b2	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; dereference the top two values
.95b5	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.95b7	15 51		ora $51,x			ora 	NSStatus+1,x
.95b9	29 10		and #$10			and 	#NSBIsString
.95bb	d0 01		bne $95be			bne 	_FDType
.95bd	60		rts				rts
.95be					_FDType:
.95be	4c aa 9f	jmp $9faa			jmp 	TypeError
.95c1					NSNormalise:
.95c1	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.95c3	29 80		and #$80			and 	#$80
.95c5	09 08		ora #$08			ora 	#NSTFloat
.95c7	95 50		sta $50,x			sta 	NSStatus,x
.95c9	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; if zero exit
.95cc	d0 07		bne $95d5			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95ce	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.95d0	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.95d2	a9 00		lda #$00			lda 	#0 							; set Z flag
.95d4	60		rts				rts
.95d5					_NSNormaliseOptimise:
.95d5	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95d7	d0 19		bne $95f2			bne 	_NSNormaliseLoop
.95d9	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.95db	30 15		bmi $95f2			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95dd	95 70		sta $70,x			sta 	NSMantissa3,x
.95df	b5 60		lda $60,x			lda 	NSMantissa1,x
.95e1	95 68		sta $68,x			sta 	NSMantissa2,x
.95e3	b5 58		lda $58,x			lda 	NSMantissa0,x
.95e5	95 60		sta $60,x			sta 	NSMantissa1,x
.95e7	74 58		stz $58,x			stz 	NSMantissa0,x
.95e9	b5 78		lda $78,x			lda 	NSExponent,x
.95eb	38		sec				sec
.95ec	e9 08		sbc #$08			sbc 	#8
.95ee	95 78		sta $78,x			sta 	NSExponent,x
.95f0	80 e3		bra $95d5			bra 	_NSNormaliseOptimise
.95f2					_NSNormaliseLoop:
.95f2	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95f4	70 07		bvs $95fd			bvs 	_NSNExit 					; exit if so with Z flag clear
.95f6	20 31 9e	jsr $9e31			jsr 	NSMShiftLeft 				; shift mantissa left
.95f9	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.95fb	80 f5		bra $95f2			bra 	_NSNormaliseLoop
.95fd					_NSNExit:
.95fd	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95ff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9600					AssignNumber:
.9600	5a		phy				phy
.9601	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9603	85 36		sta $36				sta 	zTemp0
.9605	b5 60		lda $60,x			lda 	NSMantissa1,x
.9607	85 37		sta $37				sta 	zTemp0+1
.9609	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.960b	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.960d	95 50		sta $50,x			sta 	NSStatus,x
.960f	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9611	c9 08		cmp #$08			cmp 	#NSTFloat
.9613	f0 24		beq $9639			beq 	_ANFloat
.9615	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.9617	f0 03		beq $961c			beq		_ANNotFloat
.9619	4c a5 9f	jmp $9fa5			jmp 	RangeError					; if it is, report an error.
.961c					_ANNotFloat:
.961c	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.961e	29 03		and #$03			and 	#3
.9620	d0 05		bne $9627			bne 	_ANByteWord
.9622	20 44 96	jsr $9644			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9625	80 1b		bra $9642			bra 	_ANExit
.9627					_ANByteWord:
.9627	48		pha				pha 								; save count
.9628	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.962a	92 36		sta ($36)			sta 	(zTemp0)
.962c	68		pla				pla
.962d	c9 01		cmp #$01			cmp	 	#1
.962f	f0 11		beq $9642			beq 	_ANExit
.9631	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.9633	a0 01		ldy #$01			ldy 	#1
.9635	91 36		sta ($36),y			sta 	(zTemp0),y
.9637	80 09		bra $9642			bra 	_ANExit
.9639					_ANFloat:
.9639	20 44 96	jsr $9644			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.963c	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.963e	a0 04		ldy #$04			ldy 	#4
.9640	91 36		sta ($36),y			sta 	(zTemp0),y
.9642					_ANExit:
.9642	7a		ply				ply
.9643	60		rts				rts
.9644					_ANCopy4PackSign:
.9644	a0 03		ldy #$03			ldy 	#3
.9646	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.9648	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.964a	15 71		ora $71,x			ora 	NSMantissa3+1,x
.964c	91 36		sta ($36),y			sta 	(zTemp0),y
.964e	88		dey				dey
.964f	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9651	91 36		sta ($36),y			sta 	(zTemp0),y
.9653	88		dey				dey
.9654	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9656	91 36		sta ($36),y			sta 	(zTemp0),y
.9658	88		dey				dey
.9659	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.965b	91 36		sta ($36),y			sta 	(zTemp0),y
.965d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.965e					AssignString:
.965e	5a		phy				phy
.965f	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9661	85 38		sta $38				sta 	zTemp1
.9663	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9665	85 39		sta $39				sta 	zTemp1+1
.9667	b5 58		lda $58,x			lda 	NSMantissa0,x
.9669	85 36		sta $36				sta 	zTemp0
.966b	b5 60		lda $60,x			lda 	NSMantissa1,x
.966d	85 37		sta $37				sta 	zTemp0+1
.966f	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9671	b1 36		lda ($36),y			lda 	(zTemp0),y
.9673	f0 23		beq $9698			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9675	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9676	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9678	e9 02		sbc #$02			sbc 	#2
.967a	85 3c		sta $3c				sta 	zsTemp
.967c	a0 01		ldy #$01			ldy 	#1
.967e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9680	e9 00		sbc #$00			sbc 	#0
.9682	85 3d		sta $3d				sta 	zsTemp+1
.9684	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9686					_ASGetLength:
.9686	c8		iny				iny
.9687	b1 38		lda ($38),y			lda 	(zTemp1),y
.9689	d0 fb		bne $9686			bne 	_ASGetLength
.968b	98		tya				tya 								; is this length <= current length
.968c	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.968e	90 1e		bcc $96ae			bcc 	_ASCopyString
.9690	f0 1c		beq $96ae			beq 	_ASCopyString
.9692	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9694	a0 01		ldy #$01			ldy 	#1
.9696	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9698					_ASNewStringRequired:
.9698	e8		inx				inx 								; concrete the new string.
.9699	20 37 a7	jsr $a737			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.969c	ca		dex				dex
.969d	18		clc				clc
.969e	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96a0	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96a2	92 36		sta ($36)			sta 	(zTemp0)
.96a4	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96a6	69 00		adc #$00			adc 	#0
.96a8	a0 01		ldy #$01			ldy 	#1
.96aa	91 36		sta ($36),y			sta 	(zTemp0),y
.96ac	80 0d		bra $96bb			bra 	_ASExit
.96ae					_ASCopyString:
.96ae	a0 00		ldy #$00			ldy 	#0
.96b0					_ASCopyLoop:
.96b0	b1 38		lda ($38),y			lda 	(zTemp1),y
.96b2	c8		iny				iny
.96b3	c8		iny				iny
.96b4	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96b6	88		dey				dey
.96b7	c9 00		cmp #$00			cmp 	#0
.96b9	d0 f5		bne $96b0			bne 	_ASCopyLoop
.96bb					_ASExit:
.96bb	7a		ply				ply
.96bc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96bd					DereferenceTopTwo:
.96bd	e8		inx				inx
.96be	20 c2 96	jsr $96c2			jsr 	Dereference 				; deref x+1
.96c1	ca		dex				dex  								; falls through to deref x
.96c2					Dereference:
.96c2	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.96c4	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.96c6	f0 48		beq $9710			beq 	_DRFExit 					; not a reference, so exit.
.96c8	5a		phy				phy
.96c9	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96cb	85 36		sta $36				sta 	zTemp0
.96cd	b5 60		lda $60,x			lda 	NSMantissa1,x
.96cf	85 37		sta $37				sta 	zTemp0+1
.96d1	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.96d3	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96d5	95 58		sta $58,x			sta 	NSMantissa0,x
.96d7	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.96d9	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96db	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96dd	f0 0e		beq $96ed			beq 	_DRFDereferenceTwo
.96df	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96e1	f0 2f		beq $9712			beq 	_DRFFull
.96e3	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96e5	29 03		and #$03			and 	#3
.96e7	f0 29		beq $9712			beq 	_DRFFull 					; the whole word
.96e9	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96eb	f0 06		beq $96f3			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96ed					_DRFDereferenceTwo:
.96ed	a0 01		ldy #$01			ldy 	#1
.96ef	b1 36		lda ($36),y			lda 	(zTemp0),y
.96f1	95 60		sta $60,x			sta 	NSMantissa1,x
.96f3					_DRFClear23:
.96f3	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.96f5	74 70		stz $70,x			stz 	NSMantissa3,x
.96f7	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.96f9	29 18		and #$18			and 	#NSBTypeMask
.96fb	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.96fd	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.96ff	d0 0e		bne $970f			bne 	_DRFNotString
.9701	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9703	15 60		ora $60,x			ora 	NSMantissa1,x
.9705	d0 08		bne $970f			bne 	_DRFNotString
.9707	a9 11		lda #$11			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9709	95 58		sta $58,x			sta 	NSMantissa0,X
.970b	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.970d	95 60		sta $60,x			sta 	NSMantissa1,X
.970f					_DRFNotString
.970f	7a		ply				ply 								; restore Y and exit
.9710					_DRFExit:
.9710	60		rts				rts
.9711					_DRFNullString:
>9711	00						.byte 	0
.9712					_DRFFull:
.9712	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9714	b1 36		lda ($36),y			lda 	(zTemp0),y
.9716	95 60		sta $60,x			sta 	NSMantissa1,x
.9718	c8		iny				iny
.9719	b1 36		lda ($36),y			lda 	(zTemp0),y
.971b	95 68		sta $68,x			sta 	NSMantissa2,x
.971d	c8		iny				iny
.971e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9720	95 70		sta $70,x			sta 	NSMantissa3,x
.9722	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.9724	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.9726	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9728	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.972a	f0 05		beq $9731			beq 	_DRFNoExponent
.972c	c8		iny				iny 								; if not, read the exponent as well.
.972d	b1 36		lda ($36),y			lda 	(zTemp0),y
.972f	95 78		sta $78,x			sta 	NSExponent,x
.9731					_DRFNoExponent:
.9731	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9733	10 0a		bpl $973f			bpl 	_DRFExit2 					; if not, then exit.
.9735	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9737	95 70		sta $70,x			sta 	NSMantissa3,x
.9739	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.973b	09 80		ora #$80			ora 	#NSBIsNegative
.973d	95 50		sta $50,x			sta 	NSStatus,x
.973f					_DRFExit2:
.973f	7a		ply				ply
.9740	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9741					EncodeNumberStart:
.9741	38		sec				sec
.9742	80 01		bra $9745			bra 	EncodeNumberContinue+1
.9744					EncodeNumberContinue:
.9744	18		clc				clc
.9745					EncodeNumber:
.9745	08		php				php 								; save reset flag.
.9746	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9748	f0 12		beq $975c			beq 	_ENIsOkay
.974a	c9 30		cmp #$30			cmp 	#"0"
.974c	90 04		bcc $9752			bcc 	_ENBadNumber
.974e	c9 3a		cmp #$3a			cmp 	#"9"+1
.9750	90 0a		bcc $975c			bcc 	_ENIsOkay
.9752					_ENBadNumber:
.9752	28		plp				plp 								; throw saved reset
.9753	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.9756	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9758	f0 7b		beq $97d5			beq 	_ENConstructFinal
.975a					_ENFail:
.975a	18		clc				clc 								; not allowed
.975b	60		rts				rts
.975c					_ENIsOkay:
.975c	28		plp				plp 								; are we restarting
.975d	90 15		bcc $9774			bcc 	_ENNoRestart
.975f					_ENStartEncode:
.975f	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.9761	f0 0c		beq $976f			beq 	_ENFirstDP
.9763	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.9765	20 24 9e	jsr $9e24			jsr 	NSMSetByte 					; in single byte mode.
.9768	a9 01		lda #$01			lda 	#ESTA_Low
.976a					_ENExitChange:
.976a	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.976d	38		sec				sec
.976e	60		rts				rts
.976f					_ENFirstDP:
.976f	20 22 9e	jsr $9e22			jsr 	NSMSetZero 					; clear integer part
.9772	80 3c		bra $97b0			bra 	_ESTASwitchFloat			; go straight to float and exi
.9774					_ENNoRestart:
.9774	48		pha				pha 								; save digit or DP on stack.
.9775	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.9778	c9 01		cmp #$01			cmp 	#ESTA_Low
.977a	f0 09		beq $9785			beq  	_ESTALowState
.977c	c9 02		cmp #$02			cmp 	#ESTA_High
.977e	f0 26		beq $97a6			beq 	_ESTAHighState
.9780	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9782	f0 38		beq $97bc			beq 	_ESTADecimalState
>9784	db						.byte 	$DB 						; causes a break in the emulator
.9785					_ESTALowState:
.9785	68		pla				pla 								; get value back
.9786	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9788	f0 26		beq $97b0			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.978a	29 0f		and #$0f			and 	#15 						; make digit
.978c	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.978f	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9791	0a		asl a				asl 	a
.9792	0a		asl a				asl 	a
.9793	75 58		adc $58,x			adc 	NSMantissa0,x
.9795	0a		asl a				asl 	a
.9796	6d 06 04	adc $0406			adc 	DigitTemp
.9799	95 58		sta $58,x			sta 	NSMantissa0,x
.979b	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.979d	90 05		bcc $97a4			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.979f	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97a1	8d 05 04	sta $0405			sta 	EncodeState
.97a4					_ESTANoSwitch:
.97a4	38		sec				sec
.97a5	60		rts				rts
.97a6					_ESTAHighState:
.97a6	68		pla				pla 								; get value back
.97a7	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97a9	f0 05		beq $97b0			beq 	_ESTASwitchFloat
.97ab	20 09 98	jsr $9809			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97ae	38		sec				sec
.97af	60		rts				rts
.97b0					_ESTASwitchFloat:
.97b0	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.97b3	e8		inx				inx 								; zero the decimal additive.
.97b4	20 22 9e	jsr $9e22			jsr 	NSMSetZero
.97b7	ca		dex				dex
.97b8	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97ba	80 ae		bra $976a			bra 	_ENExitChange
.97bc					_ESTADecimalState:
.97bc	68		pla				pla 								; digit.
.97bd	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97bf	f0 99		beq $975a			beq 	_ENFail
.97c1	e8		inx				inx 								; put digit into fractional part of X+1
.97c2	20 09 98	jsr $9809			jsr 	ESTAShiftDigitIntoMantissa
.97c5	ca		dex				dex
.97c6	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.97c9	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.97cc	c9 0b		cmp #$0b			cmp 	#11
.97ce	f0 02		beq $97d2			beq 	_ESTADSFail
.97d0	38		sec				sec
.97d1	60		rts				rts
.97d2					_ESTADSFail:
.97d2	4c a5 9f	jmp $9fa5			jmp 	RangeError
.97d5					_ENConstructFinal:
.97d5	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.97d8	f0 2d		beq $9807			beq 	_ENCFExit 					; no decimals
.97da	5a		phy				phy
.97db	0a		asl a				asl 	a 							; x 4 and CLC
.97dc	0a		asl a				asl 	a
.97dd	6d 07 04	adc $0407			adc 	DecimalCount
.97e0	a8		tay				tay
.97e1	b9 64 9f	lda $9f64,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.97e4	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.97e6	b9 65 9f	lda $9f65,y			lda 	DecimalScalarTable-5+1,y
.97e9	95 62		sta $62,x			sta 	NSMantissa1+2,x
.97eb	b9 66 9f	lda $9f66,y			lda 	DecimalScalarTable-5+2,y
.97ee	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.97f0	b9 67 9f	lda $9f67,y			lda 	DecimalScalarTable-5+3,y
.97f3	95 72		sta $72,x			sta 	NSMantissa3+2,x
.97f5	b9 68 9f	lda $9f68,y			lda 	DecimalScalarTable-5+4,y
.97f8	95 7a		sta $7a,x			sta 	NSExponent+2,x
.97fa	a9 08		lda #$08			lda 	#NSTFloat
.97fc	95 52		sta $52,x			sta 	NSStatus+2,x
.97fe	7a		ply				ply
.97ff	e8		inx				inx 								; multiply decimal const by decimal scalar
.9800	20 8f 95	jsr $958f			jsr 	FloatMultiply
.9803	ca		dex				dex
.9804	20 4a 94	jsr $944a			jsr 	FloatAdd 					; add to integer part.
.9807					_ENCFExit:
.9807	18		clc				clc 								; reject the digit.
.9808	60		rts				rts
.9809					ESTAShiftDigitIntoMantissa:
.9809	29 0f		and #$0f			and 	#15 						; save digit
.980b	48		pha				pha
.980c	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.980e	48		pha				pha
.980f	b5 68		lda $68,x			lda 	NSMantissa2,x
.9811	48		pha				pha
.9812	b5 60		lda $60,x			lda 	NSMantissa1,x
.9814	48		pha				pha
.9815	b5 58		lda $58,x			lda 	NSMantissa0,x
.9817	48		pha				pha
.9818	20 31 9e	jsr $9e31			jsr 	NSMShiftLeft 				; x 2
.981b	20 31 9e	jsr $9e31			jsr 	NSMShiftLeft 				; x 4
.981e	18		clc				clc 								; pop mantissa and add
.981f	68		pla				pla
.9820	75 58		adc $58,x			adc 	NSMantissa0,x
.9822	95 58		sta $58,x			sta 	NSMantissa0,x
.9824	68		pla				pla
.9825	75 60		adc $60,x			adc 	NSMantissa1,x
.9827	95 60		sta $60,x			sta 	NSMantissa1,x
.9829	68		pla				pla
.982a	75 68		adc $68,x			adc 	NSMantissa2,x
.982c	95 68		sta $68,x			sta 	NSMantissa2,x
.982e	68		pla				pla
.982f	75 70		adc $70,x			adc 	NSMantissa3,x
.9831	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.9833	20 31 9e	jsr $9e31			jsr 	NSMShiftLeft 				; x 10
.9836	68		pla				pla 								; add digit
.9837	18		clc				clc
.9838	75 58		adc $58,x			adc 	NSMantissa0,x
.983a	95 58		sta $58,x			sta 	NSMantissa0,x
.983c	90 0a		bcc $9848			bcc 	_ESTASDExit
.983e	f6 60		inc $60,x			inc 	NSMantissa1,x
.9840	d0 06		bne $9848			bne 	_ESTASDExit
.9842	f6 68		inc $68,x			inc 	NSMantissa2,x
.9844	d0 02		bne $9848			bne 	_ESTASDExit
.9846	f6 70		inc $70,x			inc 	NSMantissa3,x
.9848					_ESTASDExit:
.9848	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9849					EvaluateTerm:
.9849	b1 30		lda ($30),y			lda 	(codePtr),y
.984b	30 18		bmi $9865			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.984d	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.984f	b0 6c		bcs $98bd			bcs 	_ETVariable
.9851	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9853	90 6b		bcc $98c0			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9855	c9 3a		cmp #$3a			cmp 	#'9'+1
.9857	b0 67		bcs $98c0			bcs 	_ETPuncUnary
.9859	20 41 97	jsr $9741			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.985c					_ETNumber:
.985c	c8		iny				iny 								; keep encoding until we have the numbers
.985d	b1 30		lda ($30),y			lda 	(codePtr),y
.985f	20 44 97	jsr $9744			jsr 	EncodeNumberContinue
.9862	b0 f8		bcs $985c			bcs 	_ETNumber 					; go back if accepted.
.9864	60		rts				rts
.9865					_ETCheckUnary:
.9865	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9867	f0 3f		beq $98a8			beq 	_ETString
.9869	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.986b	f0 12		beq $987f			beq 	_ETHexConstant
.986d	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.986f	90 0b		bcc $987c			bcc 	_ETSyntaxError
.9871	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1
.9873	b0 07		bcs $987c			bcs 	_ETSyntaxError
.9875	da		phx				phx 								; push X on the stack
.9876	0a		asl a				asl 	a 							; put vector x 2 into X
.9877	aa		tax				tax
.9878	c8		iny				iny 								; consume unary function token
.9879	7c 92 8c	jmp ($8c92,x)			jmp 	(VectorSet0,x) 				; and do it.
.987c					_ETSyntaxError:
.987c	4c a0 9f	jmp $9fa0			jmp 	SyntaxError
.987f					_ETHexConstant:
.987f	c8		iny				iny 								; skip #
.9880	c8		iny				iny 								; skip count
.9881	20 22 9e	jsr $9e22			jsr 	NSMSetZero 					; clear result
.9884					_ETHLoop:
.9884	b1 30		lda ($30),y			lda 	(codePtr),y
.9886	c8		iny				iny 								; and consume
.9887	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9889	f0 1c		beq $98a7			beq 	_ETHExit
.988b	48		pha				pha 								; save on stack.
.988c	20 31 9e	jsr $9e31			jsr 	NSMShiftLeft 				; x 2
.988f	20 31 9e	jsr $9e31			jsr 	NSMShiftLeft 				; x 4
.9892	20 31 9e	jsr $9e31			jsr 	NSMShiftLeft 				; x 8
.9895	20 31 9e	jsr $9e31			jsr 	NSMShiftLeft 				; x 16
.9898	68		pla				pla 								; ASCII
.9899	c9 41		cmp #$41			cmp 	#'A'
.989b	90 02		bcc $989f			bcc 	_ETHNotChar
.989d	e9 07		sbc #$07			sbc 	#7
.989f					_ETHNotChar:
.989f	29 0f		and #$0f			and 	#15 						; digit now
.98a1	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98a3	95 58		sta $58,x			sta 	NSMantissa0,x
.98a5	80 dd		bra $9884			bra 	_ETHLoop 					; go round.
.98a7					_ETHExit:
.98a7	60		rts				rts
.98a8					_ETString:
.98a8	c8		iny				iny 								; look at length
.98a9	b1 30		lda ($30),y			lda 	(codePtr),y
.98ab	48		pha				pha
.98ac	c8		iny				iny 								; first character
.98ad	20 8d a5	jsr $a58d			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98b0	68		pla				pla 								; restore count and save
.98b1	85 36		sta $36				sta 	zTemp0
.98b3	98		tya				tya 								; add length to Y to skip it.
.98b4	18		clc				clc
.98b5	65 36		adc $36				adc 	zTemp0
.98b7	a8		tay				tay
.98b8	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98ba	95 50		sta $50,x			sta 	NSStatus,x
.98bc	60		rts				rts
.98bd					_ETVariable:
.98bd	4c 12 99	jmp $9912			jmp 	VariableHandler
.98c0					_ETPuncUnary:
.98c0	c8		iny				iny 								; consume the unary character
.98c1	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98c3	f0 2b		beq $98f0			beq 	_ETUnaryNegate
.98c5	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98c7	f0 36		beq $98ff			beq 	_ETDereference
.98c9	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.98cb	f0 3e		beq $990b			beq 	_ETParenthesis
.98cd	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.98cf	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.98d1	f0 06		beq $98d9			beq 	_ETIndirection
.98d3	e6 36		inc $36				inc 	zTemp0
.98d5	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.98d7	d0 a3		bne $987c			bne 	_ETSyntaxError
.98d9					_ETIndirection:
.98d9	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.98db	1a		inc a				inc 	a
.98dc	48		pha				pha
.98dd	20 49 98	jsr $9849			jsr 	EvaluateTerm				; evaluate the term
.98e0	20 c2 96	jsr $96c2			jsr 	Dereference 				; dereference it.
.98e3	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.98e5	d0 06		bne $98ed			bne 	_ETTypeMismatch
.98e7	68		pla				pla 								; indirection 1-2
.98e8	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.98ea	95 50		sta $50,x			sta 	NSStatus,x
.98ec	60		rts				rts
.98ed					_ETTypeMismatch:
.98ed	4c aa 9f	jmp $9faa			jmp 	TypeError
.98f0					_ETUnaryNegate:
.98f0	20 49 98	jsr $9849			jsr 	EvaluateTerm				; evaluate the term
.98f3	20 c2 96	jsr $96c2			jsr 	Dereference 				; dereference it.
.98f6	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.98f8	29 10		and #$10			and 	#NSTString
.98fa	d0 f1		bne $98ed			bne 	_ETTypeMismatch
.98fc	4c e4 9d	jmp $9de4			jmp 	NSMNegate  					; just toggles the sign bit.
.98ff					_ETDereference:
.98ff	20 49 98	jsr $9849			jsr 	EvaluateTerm				; evaluate the term
.9902	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9904	29 20		and #$20			and 	#NSBIsReference
.9906	f0 e5		beq $98ed			beq 	_ETTypeMismatch
.9908	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.990a	60		rts				rts
.990b					_ETParenthesis:
.990b	20 ff 93	jsr $93ff			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.990e	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket 			; check for )
.9911	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9912					VariableHandler:
.9912	b1 30		lda ($30),y			lda 	(codePtr),y
.9914	18		clc				clc
.9915	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9917	85 37		sta $37				sta 	zTemp0+1
.9919	c8		iny				iny
.991a	b1 30		lda ($30),y			lda 	(codePtr),y
.991c	85 36		sta $36				sta 	zTemp0
.991e	c8		iny				iny
.991f	18		clc				clc									; copy variable address+3 to mantissa
.9920	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.9922	95 58		sta $58,x			sta 	NSMantissa0,x
.9924	a5 37		lda $37				lda 	zTemp0+1
.9926	69 00		adc #$00			adc 	#0
.9928	95 60		sta $60,x			sta 	NSMantissa1,x
.992a	74 68		stz $68,x			stz 	NSMantissa2,x
.992c	74 70		stz $70,x			stz 	NSMantissa3,x
.992e	74 78		stz $78,x			stz 	NSExponent,x
.9930	5a		phy				phy
.9931	a0 02		ldy #$02			ldy 	#2 							; read type
.9933	b1 36		lda ($36),y			lda 	(zTemp0),y
.9935	7a		ply				ply
.9936	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9938	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.993a	95 50		sta $50,x			sta 	NSStatus,x
.993c	29 04		and #$04			and 	#NSBIsArray
.993e	d0 01		bne $9941			bne 	_VHArray
.9940	60		rts				rts
.9941					_VHArray:
.9941	e8		inx				inx
.9942	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9945	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9947	95 51		sta $51,x			sta 	NSStatus+1,x
.9949	b1 30		lda ($30),y			lda 	(codePtr),y
.994b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.994d	d0 06		bne $9955			bne 	_VHNoSecondIndex
.994f	c8		iny				iny 								; skip the comma
.9950	e8		inx				inx
.9951	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9954	ca		dex				dex
.9955					_VHNoSecondIndex:
.9955	ca		dex				dex 								; set X back.
.9956	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket 			; and check the right bracket.
.9959	5a		phy				phy 								; save position
.995a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp (moved 6/12/22)
.995c	85 3e		sta $3e				sta 	zaTemp
.995e	b5 60		lda $60,x			lda 	NSMantissa1,x
.9960	85 3f		sta $3f				sta 	zaTemp+1
.9962	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9964	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9966	f0 5d		beq $99c5			beq 	_VHBadArray
.9968	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.996a	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.996c	f0 02		beq $9970			beq 	_VHHas2Mask
.996e	a9 ff		lda #$ff			lda 	#$FF
.9970					_VHHas2Mask:
.9970	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9972	f0 4c		beq $99c0			beq 	_VHBadIndex
.9974	0a		asl a				asl 	a 							; carry will be set if a second index
.9975	90 08		bcc $997f			bcc 	_VHCheckFirstIndex
.9977	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9979	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.997b	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.997d	90 41		bcc $99c0			bcc 	_VHBadIndex
.997f					_VHCheckFirstIndex:
.997f	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9981	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9983	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.9985	90 39		bcc $99c0			bcc 	_VHBadIndex
.9987	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9989	64 37		stz $37				stz 	zTemp0+1
.998b	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.998d	30 0e		bmi $999d			bmi 	_VHNoMultiply
.998f	da		phx				phx
.9990	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9992	48		pha				pha
.9993	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9995	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9997	1a		inc a				inc 	a 							; add 1 for zero base
.9998	fa		plx				plx
.9999	20 cd 9d	jsr $9dcd			jsr 	Multiply8x8 				; calculate -> Z0
.999c	fa		plx				plx
.999d					_VHNoMultiply:
.999d	18		clc				clc
.999e	a5 36		lda $36				lda 	zTemp0
.99a0	75 59		adc $59,x			adc 	NSMantissa0+1,x
.99a2	85 36		sta $36				sta 	zTemp0
.99a4	a5 37		lda $37				lda 	zTemp0+1
.99a6	69 00		adc #$00			adc 	#0
.99a8	85 37		sta $37				sta 	zTemp0+1
.99aa	b5 50		lda $50,x			lda 	NSStatus,x
.99ac	20 73 85	jsr $8573			jsr 	ScaleByBaseType
.99af	18		clc				clc
.99b0	b2 3e		lda ($3e)			lda 	(zaTemp)
.99b2	65 36		adc $36				adc 	zTemp0
.99b4	95 58		sta $58,x			sta 	NSMantissa0,x
.99b6	a0 01		ldy #$01			ldy 	#1
.99b8	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99ba	65 37		adc $37				adc 	zTemp0+1
.99bc	95 60		sta $60,x			sta 	NSMantissa1,x
.99be	7a		ply				ply 								; restore position
.99bf	60		rts				rts
.99c0					_VHBadIndex:
.99c0	a9 17		lda #$17		lda	#23
.99c2	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.99c5					_VHBadArray:
.99c5	a9 18		lda #$18		lda	#24
.99c7	4c fb 8e	jmp $8efb		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.99ca					AbsUnary:
.99ca	fa		plx				plx 								; restore stack pos
.99cb	20 70 9d	jsr $9d70			jsr 	EvaluateNumber 				; get a float or int
.99ce	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.99d1	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.99d3	29 7f		and #$7f			and 	#$7F
.99d5	95 50		sta $50,x			sta 	NSStatus,x
.99d7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.99d8					AllocUnary:
.99d8	fa		plx				plx 								; restore stack pos
.99d9	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger		; get bytes required.
.99dc	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.99df	da		phx				phx 								; save X/Y
.99e0	5a		phy				phy
.99e1	8a		txa				txa 								; copy X into Y
.99e2	a8		tay				tay
.99e3	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.99e6	aa		tax				tax
.99e7	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.99ea	20 f7 99	jsr $99f7			jsr 	AllocateXABytes 			; allocate memory
.99ed	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.99f0	8a		txa				txa 	 							; typing is 16 bit integer.
.99f1	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.99f4	7a		ply				ply
.99f5	fa		plx				plx
.99f6	60		rts				rts
.99f7					AllocateXABytes:
.99f7	5a		phy				phy
.99f8	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99fb	84 36		sty $36				sty 	zTemp0
.99fd	5a		phy				phy
.99fe	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.9a01	84 37		sty $37				sty 	zTemp0+1
.9a03	5a		phy				phy
.9a04	18		clc				clc 								; add to low memory pointer
.9a05	6d 0c 04	adc $040c			adc 	lowMemPtr
.9a08	8d 0c 04	sta $040c			sta 	lowMemPtr
.9a0b	8a		txa				txa
.9a0c	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9a0f	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9a12	b0 2f		bcs $9a43			bcs 	CISSMemory
.9a14	20 35 9a	jsr $9a35			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a17					_ClearMemory:
.9a17	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.9a1a	c5 36		cmp $36				cmp 	zTemp0
.9a1c	d0 07		bne $9a25			bne 	_CMClearNext
.9a1e	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9a21	c5 37		cmp $37				cmp 	zTemp0+1
.9a23	f0 0c		beq $9a31			beq 	_CMExit
.9a25					_CMClearNext:
.9a25	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a27	92 36		sta ($36)			sta 	(zTemp0)
.9a29	e6 36		inc $36				inc 	zTemp0
.9a2b	d0 ea		bne $9a17			bne 	_ClearMemory
.9a2d	e6 37		inc $37				inc		zTemp0+1
.9a2f	80 e6		bra $9a17			bra 	_ClearMemory
.9a31					_CMExit:
.9a31	fa		plx				plx
.9a32	68		pla				pla
.9a33	7a		ply				ply
.9a34	60		rts				rts
.9a35					CheckIdentifierStringSpace:
.9a35	48		pha				pha
.9a36	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a39	18		clc				clc
.9a3a	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a3c	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a3f	b0 02		bcs $9a43			bcs 	CISSMemory
.9a41	68		pla				pla
.9a42	60		rts				rts
.9a43					CISSMemory:
.9a43	a9 06		lda #$06		lda	#6
.9a45	4c fb 8e	jmp $8efb		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a48					AscUnary:
.9a48	fa		plx				plx 								; restore stack pos
.9a49	20 7a 9d	jsr $9d7a			jsr 	EvaluateString 				; get a string
.9a4c	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a4e	20 24 9e	jsr $9e24			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a51	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.9a54	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/deekpeek.asm

.9a55					PeekUnary:
.9a55	18		clc				clc
.9a56	80 01		bra $9a59			bra 	DPUnary
.9a58					DeekUnary:
.9a58	38		sec				sec
.9a59					DPUnary:
.9a59	fa		plx				plx 								; restore position.
.9a5a	08		php				php									; save on stack, CS = Deek, CC = Peek
.9a5b	20 a2 9d	jsr $9da2			jsr		Evaluate16BitInteger 		; address as constant.
.9a5e	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.9a61	28		plp				plp 								; function back.
.9a62	a9 21		lda #$21			lda 	#NSBIsReference+NSTInteger+1 ; 1 byte read
.9a64	90 01		bcc $9a67			bcc 	_DPUpdate
.9a66	1a		inc a				inc 	a 							; 2 byte read
.9a67					_DPUpdate:
.9a67	95 50		sta $50,x			sta 	NSStatus,x 					; set to 1/2 byte reference.
.9a69	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a6a					FracUnary:
.9a6a	fa		plx				plx 								; restore stack pos
.9a6b	20 70 9d	jsr $9d70			jsr 	EvaluateNumber 				; get a float or int
.9a6e	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.9a71	b5 50		lda $50,x			lda 	NSStatus,x
.9a73	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a75	f0 04		beq $9a7b			beq 	_IUZero
.9a77	20 10 95	jsr $9510			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9a7a	60		rts				rts
.9a7b					_IUZero:
.9a7b	20 22 9e	jsr $9e22			jsr 	NSMSetZero
.9a7e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a7f					IntUnary:
.9a7f	fa		plx				plx 								; restore stack pos
.9a80	20 70 9d	jsr $9d70			jsr 	EvaluateNumber 				; get a float or int
.9a83	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.9a86	b5 50		lda $50,x			lda 	NSStatus,x
.9a88	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a8a	f0 03		beq $9a8f			beq 	_IUExit
.9a8c	20 68 95	jsr $9568			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9a8f					_IUExit:
.9a8f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a90					LenUnary:
.9a90	fa		plx				plx 								; restore stack pos
.9a91	20 7a 9d	jsr $9d7a			jsr 	EvaluateString 				; get a string
.9a94	5a		phy				phy
.9a95	a0 00		ldy #$00			ldy 	#0 							; find length
.9a97					_LenFind:
.9a97	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a99	f0 06		beq $9aa1			beq 	_LenExit
.9a9b	c8		iny				iny
.9a9c	d0 f9		bne $9a97			bne 	_LenFind
.9a9e	4c a5 9f	jmp $9fa5			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9aa1					_LenExit:
.9aa1	98		tya				tya		 							; return length
.9aa2	20 24 9e	jsr $9e24			jsr 	NSMSetByte
.9aa5	7a		ply				ply
.9aa6	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.9aa9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9aaa					Unary_Min:
.9aaa	a9 01		lda #$01			lda 	#1
.9aac	80 02		bra $9ab0			bra 	UnaryMinMaxMain
.9aae					Unary_Max:
.9aae	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9ab0					UnaryMinMaxMain:
.9ab0	fa		plx				plx 								; get index on number stack
.9ab1	48		pha				pha 								; save comparator
.9ab2	20 67 9d	jsr $9d67			jsr 	EvaluateValue 				; get the first value.
.9ab5					_UMMMLoop:
.9ab5	b1 30		lda ($30),y			lda 	(codePtr),y
.9ab7	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9ab9	f0 22		beq $9add			beq 	_UMMMDone
.9abb	20 ea 8e	jsr $8eea			jsr 	CheckComma 					; must be a comma
.9abe	e8		inx				inx
.9abf	20 67 9d	jsr $9d67			jsr 	EvaluateValue
.9ac2	ca		dex				dex
.9ac3	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9ac6	e8		inx				inx
.9ac7	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9aca	e8		inx				inx
.9acb	20 b2 8f	jsr $8fb2			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9ace	ca		dex				dex
.9acf	ca		dex				dex
.9ad0	85 36		sta $36				sta 	zTemp0 						; save required result
.9ad2	68		pla				pla 								; get and save comparator
.9ad3	48		pha				pha
.9ad4	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9ad6	d0 dd		bne $9ab5			bne 	_UMMMLoop
.9ad8	20 e0 9a	jsr $9ae0			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9adb	80 d8		bra $9ab5			bra 	_UMMMLoop
.9add					_UMMMDone:
.9add	68		pla				pla 								; throw the comparator
.9ade	c8		iny				iny 								; skip )
.9adf	60		rts				rts
.9ae0					ExpCopyAboveDown:
.9ae0	b5 51		lda $51,x			lda 	NSStatus+1,x
.9ae2	95 50		sta $50,x			sta 	NSStatus,x
.9ae4	b5 79		lda $79,x			lda 	NSExponent+1,x
.9ae6	95 78		sta $78,x			sta 	NSExponent,x
.9ae8	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9aea	95 58		sta $58,x			sta 	NSMantissa0,x
.9aec	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9aee	95 60		sta $60,x			sta 	NSMantissa1,x
.9af0	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9af2	95 68		sta $68,x			sta 	NSMantissa2,x
.9af4	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9af6	95 70		sta $70,x			sta 	NSMantissa3,x
.9af8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9af9					Unary_Not:
.9af9	fa		plx				plx
.9afa	20 8f 9d	jsr $9d8f			jsr 	EvaluateInteger 			; get integer
.9afd	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.9b00	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; zero mantissa ?
.9b03	f0 04		beq $9b09			beq 	_NotZero
.9b05	20 22 9e	jsr $9e22			jsr 	NSMSetZero
.9b08	60		rts				rts
.9b09					_NotZero:
.9b09	4c 68 8f	jmp $8f68			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b0c					Unary_Random:
.9b0c	fa		plx				plx
.9b0d	20 7e 9b	jsr $9b7e			jsr 	Random32Bit 				; get a random number
.9b10	20 67 9b	jsr $9b67			jsr 	URCopyToMantissa  			; put in mantissa
.9b13	b1 30		lda ($30),y			lda 	(codePtr),y
.9b15	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b17	f0 08		beq $9b21			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9b19	e8		inx				inx
.9b1a	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b1d	ca		dex				dex
.9b1e	20 ba 90	jsr $90ba			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9b21					_URNoModulus:
.9b21	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9b23	74 78		stz $78,x			stz 	NSExponent,x
.9b25	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.9b28	60		rts				rts
.9b29					Unary_Rnd:
.9b29	fa		plx				plx
.9b2a	20 70 9d	jsr $9d70			jsr 	EvaluateNumber 				; number to use.
.9b2d	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket 			; closing bracket
.9b30	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b33	f0 26		beq $9b5b			beq 	_URCopySeed
.9b35	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b37	10 1f		bpl $9b58			bpl 	_URDontSeed
.9b39	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b3b	49 17		eor #$17			eor 	#$17
.9b3d	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b40	b5 60		lda $60,x			lda 	NSMantissa1,x
.9b42	49 a5		eor #$a5			eor 	#$A5
.9b44	8d 09 04	sta $0409			sta 	RandomSeed+1
.9b47	b5 68		lda $68,x			lda 	NSMantissa2,x
.9b49	49 c2		eor #$c2			eor 	#$C2
.9b4b	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9b4e	b5 70		lda $70,x			lda 	NSMantissa3,x
.9b50	49 9d		eor #$9d			eor 	#$9D
.9b52	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9b55	20 7e 9b	jsr $9b7e			jsr 	Random32Bit
.9b58					_URDontSeed:
.9b58	20 7e 9b	jsr $9b7e			jsr 	Random32Bit 				; generate a number
.9b5b					_URCopySeed:
.9b5b	20 67 9b	jsr $9b67			jsr 	URCopyToMantissa 			; copy into mantissa
.9b5e	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b60	95 78		sta $78,x			sta 	NSExponent,x
.9b62	a9 08		lda #$08			lda 	#NSTFloat
.9b64	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9b66	60		rts				rts
.9b67					URCopyToMantissa:
.9b67	ad 08 04	lda $0408			lda 	RandomSeed+0
.9b6a	95 58		sta $58,x			sta 	NSMantissa0,x
.9b6c	ad 09 04	lda $0409			lda 	RandomSeed+1
.9b6f	95 60		sta $60,x			sta 	NSMantissa1,x
.9b71	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b74	95 68		sta $68,x			sta 	NSMantissa2,x
.9b76	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b79	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b7b	95 70		sta $70,x			sta 	NSMantissa3,x
.9b7d	60		rts				rts
.9b7e					Random32Bit:
.9b7e	5a		phy				phy
.9b7f	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b81	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9b84	d0 03		bne $9b89			bne 	_Random1
.9b86	a8		tay				tay 								; if so do it 256 times
.9b87	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b89					_Random1:
.9b89	0a		asl a				asl 	a 							; LSFR RNG
.9b8a	2e 09 04	rol $0409			rol 	RandomSeed+1
.9b8d	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9b90	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9b93	90 02		bcc $9b97			bcc 	_Random2
.9b95	49 c5		eor #$c5			eor 	#$C5
.9b97					_Random2:
.9b97	88		dey				dey
.9b98	d0 ef		bne $9b89			bne 	_Random1
.9b9a	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b9d	7a		ply				ply
.9b9e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b9f					SgnUnary:
.9b9f	fa		plx				plx 								; restore stack pos
.9ba0	20 70 9d	jsr $9d70			jsr 	EvaluateNumber 				; get a float or int
.9ba3	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.9ba6	20 44 9e	jsr $9e44			jsr 	NSMIsZero 					; if zero
.9ba9	f0 0e		beq $9bb9			beq 	_SGZero  					; return Int Zero
.9bab	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9bad	48		pha				pha
.9bae	a9 01		lda #$01			lda 	#1 							; set to 1
.9bb0	20 24 9e	jsr $9e24			jsr 	NSMSetByte
.9bb3	68		pla				pla
.9bb4	29 80		and #$80			and		#$80 						; copy the sign byte out
.9bb6	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9bb8	60		rts				rts
.9bb9	20 22 9e	jsr $9e22	_SGZero:jsr 	NSMSetZero
.9bbc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9bbd					ValUnary:
.9bbd	fa		plx				plx 								; restore stack pos
.9bbe	20 d3 9b	jsr $9bd3			jsr 	ValMainCode 				; do the main val() code
.9bc1	b0 01		bcs $9bc4			bcs 	_VUError 					; couldn't convert
.9bc3	60		rts				rts
.9bc4					_VUError:
.9bc4	4c aa 9f	jmp $9faa			jmp 	TypeError
.9bc7					IsValUnary:
.9bc7	fa		plx				plx 								; restore stack pos
.9bc8	20 d3 9b	jsr $9bd3			jsr 	ValMainCode 				; do the main val() code
.9bcb	b0 03		bcs $9bd0			bcs 	_VUBad
.9bcd	4c 68 8f	jmp $8f68			jmp 	ReturnTrue
.9bd0					_VUBad:
.9bd0	4c 73 8f	jmp $8f73			jmp 	ReturnFalse
.9bd3					ValMainCode:
.9bd3	20 7a 9d	jsr $9d7a			jsr 	EvaluateString 				; get a string
.9bd6	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket 			; check right bracket present
.9bd9					ValEvaluateZTemp0:
.9bd9	5a		phy				phy
.9bda	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9bdc	f0 17		beq $9bf5			beq 	_VMCFail2
.9bde	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9be0	48		pha				pha 								; save first character
.9be1	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9be3	d0 01		bne $9be6			bne 	_VMCStart
.9be5	c8		iny				iny 								; skip over -
.9be6					_VMCStart:
.9be6	38		sec				sec 								; initialise first time round.
.9be7					_VMCNext:
.9be7	c8		iny				iny 								; pre-increment
.9be8	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9bea	f0 0c		beq $9bf8			beq 	_VMCSuccess 				; successful.
.9bec	20 45 97	jsr $9745			jsr 	EncodeNumber 				; send it to the number-builder
.9bef	90 03		bcc $9bf4			bcc 	_VMCFail 					; if failed, give up.
.9bf1	18		clc				clc 								; next time round, countinue
.9bf2	80 f3		bra $9be7			bra 	_VMCNext
.9bf4					_VMCFail:
.9bf4	68		pla				pla
.9bf5					_VMCFail2:
.9bf5	7a		ply				ply
.9bf6	38		sec				sec
.9bf7	60		rts				rts
.9bf8					_VMCSuccess:
.9bf8	a9 00		lda #$00			lda 	#0 							; construct final
.9bfa	20 45 97	jsr $9745			jsr 	EncodeNumber 				; by sending a duff value.
.9bfd	68		pla				pla 								; if it was -ve
.9bfe	c9 2d		cmp #$2d			cmp 	#"-"
.9c00	d0 03		bne $9c05			bne 	_VMCNotNegative
.9c02	20 e4 9d	jsr $9de4			jsr		NSMNegate 					; negate it.
.9c05					_VMCNotNegative:
.9c05	7a		ply				ply
.9c06	18		clc				clc
.9c07	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c08					ChrUnary:
.9c08	fa		plx				plx 								; restore stack pos
.9c09	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9c0c	48		pha				pha
.9c0d	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.9c10	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c12	20 b4 a7	jsr $a7b4			jsr 	StringTempAllocate
.9c15	68		pla				pla 								; write number to it
.9c16	20 ed a7	jsr $a7ed			jsr 	StringTempWrite
.9c19	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c1a					SpcUnary:
.9c1a	fa		plx				plx 								; restore stack pos
.9c1b	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger			; get value
.9c1e	5a		phy				phy
.9c1f	48		pha				pha 								; save count
.9c20	20 b4 a7	jsr $a7b4			jsr 	StringTempAllocate
.9c23	7a		ply				ply 								; to do count in Y
.9c24					_SpcLoop:
.9c24	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9c26	f0 08		beq $9c30			beq 	_SpcExit
.9c28	a9 20		lda #$20			lda 	#32
.9c2a	20 ed a7	jsr $a7ed			jsr 	StringTempWrite
.9c2d	88		dey				dey
.9c2e	80 f4		bra $9c24			bra 	_SPCLoop
.9c30					_SpcExit:
.9c30	7a		ply				ply
.9c31	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.9c34	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c35					Unary_Str:
.9c35	fa		plx				plx
.9c36	20 70 9d	jsr $9d70			jsr 	EvaluateNumber  			; get number
.9c39	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket 			; closing bracket
.9c3c	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c3e	20 57 9c	jsr $9c57			jsr 	ConvertNumberToString 		; do the conversion.
.9c41	a9 21		lda #$21			lda		#33 						; create buffer
.9c43	20 b4 a7	jsr $a7b4			jsr 	StringTempAllocate 			; allocate memory
.9c46	da		phx				phx  								; copy the converted string into the buffer.
.9c47	a2 00		ldx #$00			ldx 	#0
.9c49					_USCopy:
.9c49	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c4c	20 ed a7	jsr $a7ed			jsr 	StringTempWrite
.9c4f	e8		inx				inx
.9c50	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c53	d0 f4		bne $9c49			bne 	_USCopy
.9c55	fa		plx				plx
.9c56	60		rts				rts
.9c57					ConvertNumberToString:
.9c57	5a		phy				phy 								; save code position
.9c58	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9c5b	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9c5e	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9c60	10 09		bpl $9c6b			bpl 	_CNTSNotNegative
.9c62	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c64	95 50		sta $50,x			sta 	NSStatus,x
.9c66	a9 2d		lda #$2d			lda 	#"-"
.9c68	20 cc 9c	jsr $9ccc			jsr 	WriteDecimalBuffer
.9c6b					_CNTSNotNegative:
.9c6b	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9c6d	f0 12		beq $9c81			beq 	_CNTSNotFloat
.9c6f	e8		inx				inx 								; round up so we don't get too many 6.999999
.9c70	a9 01		lda #$01			lda 	#1
.9c72	20 24 9e	jsr $9e24			jsr 	NSMSetByte
.9c75	ca		dex				dex
.9c76	b5 78		lda $78,x			lda		NSExponent,x
.9c78	95 79		sta $79,x			sta 	NSExponent+1,x
.9c7a	a9 08		lda #$08			lda 	#NSTFloat
.9c7c	95 51		sta $51,x			sta 	NSStatus+1,x
.9c7e	20 4a 94	jsr $944a			jsr 	FloatAdd
.9c81					_CNTSNotFloat:
.9c81	20 ae 9c	jsr $9cae			jsr 	MakePlusTwoString 			; do the integer part.
.9c84	20 10 95	jsr $9510			jsr 	FloatFractionalPart 		; get the fractional part
.9c87	20 c1 95	jsr $95c1			jsr 	NSNormalise					; normalise , exit if zero
.9c8a	f0 20		beq $9cac			beq 	_CNTSExit
.9c8c	a9 2e		lda #$2e			lda 	#"."
.9c8e	20 cc 9c	jsr $9ccc			jsr 	WriteDecimalBuffer 			; write decimal place
.9c91					_CNTSDecimal:
.9c91	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9c94	30 16		bmi $9cac			bmi 	_CNTSExit
.9c96	e8		inx				inx 								; x 10.0
.9c97	a9 0a		lda #$0a			lda 	#10
.9c99	20 24 9e	jsr $9e24			jsr 	NSMSetByte
.9c9c	a9 08		lda #$08			lda 	#NSTFloat
.9c9e	95 50		sta $50,x			sta 	NSStatus,x
.9ca0	ca		dex				dex
.9ca1	20 8f 95	jsr $958f			jsr 	FloatMultiply
.9ca4	20 ae 9c	jsr $9cae			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9ca7	20 10 95	jsr $9510			jsr 	FloatFractionalPart 		; get the fractional part
.9caa	80 e5		bra $9c91			bra 	_CNTSDecimal 				; keep going.
.9cac					_CNTSExit:
.9cac	7a		ply				ply
.9cad	60		rts				rts
.9cae					MakePlusTwoString:
.9cae	da		phx				phx
.9caf	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9cb2	e8		inx				inx 								; access it
.9cb3	e8		inx				inx
.9cb4	20 68 95	jsr $9568			jsr 	FloatIntegerPart 			; make it an integer
.9cb7	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9cb9	20 7a 93	jsr $937a			jsr 	ConvertInt32
.9cbc	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9cbe					_MPTSCopy:
.9cbe	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cc1	20 cc 9c	jsr $9ccc			jsr 	WriteDecimalBuffer
.9cc4	e8		inx				inx
.9cc5	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cc8	d0 f4		bne $9cbe			bne 	_MPTSCopy
.9cca	fa		plx				plx
.9ccb	60		rts				rts
.9ccc					WriteDecimalBuffer:
.9ccc	da		phx				phx
.9ccd	ae 15 04	ldx $0415			ldx 	dbOffset
.9cd0	9d 49 06	sta $0649,x			sta 	DecimalBuffer,x
.9cd3	9e 4a 06	stz $064a,x			stz 	DecimalBuffer+1,x
.9cd6	ee 15 04	inc $0415			inc 	dbOffset
.9cd9	fa		plx				plx
.9cda	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9cdb					Unary_Left:
.9cdb	fa		plx				plx
.9cdc	18		clc				clc 								; only one parameter
.9cdd	20 40 9d	jsr $9d40			jsr 	SubstringInitial 			; set up.
.9ce0	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9ce2	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9ce4	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9ce6	80 25		bra $9d0d			bra 	SubstringMain
.9ce8					Unary_Right:
.9ce8	fa		plx				plx
.9ce9	18		clc				clc 								; only one parameter
.9cea	20 40 9d	jsr $9d40			jsr 	SubstringInitial 			; set up.
.9ced	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9cef	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9cf1	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9cf3	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cf5	b0 02		bcs $9cf9			bcs 	_URNotUnderflow
.9cf7	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cf9					_URNotUnderFlow:
.9cf9	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cfb	80 10		bra $9d0d			bra 	SubStringMain
.9cfd					Unary_Mid:
.9cfd	fa		plx				plx
.9cfe	38		sec				sec 								; two parameters
.9cff	20 40 9d	jsr $9d40			jsr 	SubstringInitial 			; set up.
.9d02	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d04	f0 04		beq $9d0a			beq 	_UMError
.9d06	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d08	80 03		bra $9d0d			bra 	SubStringMain
.9d0a					_UMError:
.9d0a	4c af 9f	jmp $9faf			jmp 	ArgumentError
.9d0d					SubStringMain:
.9d0d	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d0f	d5 78		cmp $78,x			cmp 	NSExponent,x
.9d11	b0 27		bcs $9d3a			bcs 	_SSMNull 					; if so, return an empty string.
.9d13	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d15	f0 23		beq $9d3a			beq 	_SSMNull 					; return empty string.
.9d17	18		clc				clc 								; add the offset +1 to the address and
.9d18	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9d1a	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9d1c	85 36		sta $36				sta 	zTemp0
.9d1e	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9d20	69 00		adc #$00			adc 	#0
.9d22	85 37		sta $37				sta 	zTemp0+1
.9d24					_SSMNoCarry:
.9d24	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d26	20 b4 a7	jsr $a7b4			jsr 	StringTempAllocate 			; allocate that many characters
.9d29	5a		phy				phy 								; save Y
.9d2a	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d2c					_SSMCopy:
.9d2c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d2e	f0 08		beq $9d38			beq 	_SSMEString 				; no more to copy
.9d30	20 ed a7	jsr $a7ed			jsr 	StringTempWrite 			; and write it out.
.9d33	c8		iny				iny
.9d34	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9d36	d0 f4		bne $9d2c			bne 	_SSMCopy
.9d38					_SSMEString:
.9d38	7a		ply				ply
.9d39					_SSMExit:
.9d39	60		rts				rts
.9d3a					_SSMNull:
.9d3a	a9 00		lda #$00			lda 	#0
.9d3c	20 b4 a7	jsr $a7b4			jsr 	StringTempAllocate
.9d3f	60		rts				rts
.9d40					SubstringInitial:
.9d40	da		phx				phx 								; save initial stack position
.9d41	08		php				php 								; save carry on stack indicating 2 parameters
.9d42	20 7a 9d	jsr $9d7a			jsr 	EvaluateString 				; get a string
.9d45	5a		phy				phy 								; calculate length to exponent.
.9d46	a0 ff		ldy #$ff			ldy 	#$FF
.9d48					_SIFindLength:
.9d48	c8		iny				iny
.9d49	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d4b	d0 fb		bne $9d48			bne 	_SIFindLength
.9d4d	98		tya				tya
.9d4e	95 78		sta $78,x			sta 	NSExponent,x
.9d50	7a		ply				ply
.9d51	e8		inx				inx
.9d52	20 ea 8e	jsr $8eea			jsr 	CheckComma 					; comma next
.9d55	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; get next parameter
.9d58	28		plp				plp 								; is it the last parameter ?
.9d59	90 07		bcc $9d62			bcc 	_SSIExit 					; if so, exit.
.9d5b	e8		inx				inx
.9d5c	20 ea 8e	jsr $8eea			jsr 	CheckComma 					; comma next
.9d5f	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; get last parameter
.9d62					_SSIExit:
.9d62	fa		plx				plx
.9d63	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket 			; check closing bracket
.9d66	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d67					EvaluateValue:
.9d67	48		pha				pha
.9d68	20 ff 93	jsr $93ff			jsr		EvaluateExpression 			; expression
.9d6b	20 c2 96	jsr $96c2			jsr 	Dereference					; derefernce it
.9d6e	68		pla				pla
.9d6f	60		rts				rts
.9d70					EvaluateNumber:
.9d70	20 67 9d	jsr $9d67			jsr 	EvaluateValue 				; get a value
.9d73	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d75	29 10		and #$10			and 	#NSBIsString
.9d77	d0 13		bne $9d8c			bne 	HelperTypeError
.9d79	60		rts				rts
.9d7a					EvaluateString:
.9d7a	20 67 9d	jsr $9d67			jsr 	EvaluateValue 				; get a value
.9d7d	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d7f	29 10		and #$10			and 	#NSBIsString
.9d81	f0 09		beq $9d8c			beq 	HelperTypeError
.9d83					CopyAddressToTemp0:
.9d83	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d85	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9d87	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d89	85 37		sta $37				sta 	zTemp0+1
.9d8b	60		rts				rts
.9d8c					HelperTypeError:
.9d8c	4c aa 9f	jmp $9faa			jmp 	TypeError
.9d8f					EvaluateInteger:
.9d8f	20 70 9d	jsr $9d70			jsr 	EvaluateNumber
.9d92	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9d94	d0 09		bne $9d9f			bne 	HelperValueError 			; if not, it's a float.
.9d96	60		rts				rts
.9d97					EvaluateUnsignedInteger:
.9d97	20 8f 9d	jsr $9d8f			jsr 	EvaluateInteger 			; check integer is +ve
.9d9a	b5 50		lda $50,x			lda 	NSStatus,x
.9d9c	30 01		bmi $9d9f			bmi 	HelperValueError
.9d9e	60		rts				rts
.9d9f					HelperValueError:
.9d9f	4c af 9f	jmp $9faf			jmp 	ArgumentError
.9da2					Evaluate16BitInteger:
.9da2	20 97 9d	jsr $9d97			jsr	 	EvaluateUnsignedInteger		; get integer
.9da5	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9da7	15 68		ora $68,x			ora 	NSMantissa2,x
.9da9	d0 f4		bne $9d9f			bne 	HelperValueError
.9dab	60		rts				rts
.9dac					Evaluate16BitIntegerSigned:
.9dac	20 8f 9d	jsr $9d8f			jsr	 	EvaluateInteger				; get integer
.9daf	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9db1	15 68		ora $68,x			ora 	NSMantissa2,x
.9db3	d0 ea		bne $9d9f			bne 	HelperValueError
.9db5	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9db7	10 03		bpl $9dbc			bpl 	_EISNotSigned
.9db9	20 eb 9d	jsr $9deb			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9dbc					_EISNotSigned:
.9dbc	60		rts				rts
.9dbd					Evaluate8BitInteger:
.9dbd	20 97 9d	jsr $9d97			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9dc0	d0 dd		bne $9d9f			bne 	HelperValueError
.9dc2	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9dc4	15 68		ora $68,x			ora 	NSMantissa2,x
.9dc6	15 60		ora $60,x			ora 	NSMantissa1,x
.9dc8	d0 d5		bne $9d9f			bne 	HelperValueError
.9dca	b5 58		lda $58,x			lda 	NSMantissa0,x
.9dcc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dcd					Multiply8x8:
.9dcd	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dce	85 36		sta $36			  	sta 	zTemp0
.9dd0	86 37		stx $37				stx 	zTemp0+1
.9dd2	a9 00		lda #$00			lda 	#0
.9dd4	a2 08		ldx #$08			ldx 	#8
.9dd6					_M88Loop:
.9dd6	90 03		bcc $9ddb			bcc 	_M88NoAdd
.9dd8	18		clc				clc
.9dd9	65 37		adc $37				adc 	zTemp0+1
.9ddb					_M88NoAdd:
.9ddb	6a		ror a				ror 	a
.9ddc	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dde	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9ddf	d0 f5		bne $9dd6			bne 	_M88Loop
.9de1	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9de3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9de4					NSMNegate:
.9de4	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9de6	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9de8	95 50		sta $50,x			sta 	NSStatus,x
.9dea	60		rts				rts
.9deb					NSMNegateMantissa:
.9deb	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9dec	a9 00		lda #$00			lda 	#0
.9dee	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9df0	95 58		sta $58,x			sta 	NSMantissa0,x
.9df2	a9 00		lda #$00			lda 	#0
.9df4	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9df6	95 60		sta $60,x			sta 	NSMantissa1,x
.9df8	a9 00		lda #$00			lda 	#0
.9dfa	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9dfc	95 68		sta $68,x			sta 	NSMantissa2,x
.9dfe	a9 00		lda #$00			lda 	#0
.9e00	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9e02	95 70		sta $70,x			sta 	NSMantissa3,x
.9e04	60		rts				rts
.9e05					NSMShiftUpTwo:
.9e05	b5 58		lda $58,x			lda 	NSMantissa0,x
.9e07	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9e09	b5 60		lda $60,x			lda 	NSMantissa1,x
.9e0b	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9e0d	b5 68		lda $68,x			lda 	NSMantissa2,x
.9e0f	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9e11	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e13	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9e15	b5 78		lda $78,x			lda 	NSExponent,x
.9e17	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9e19	b5 50		lda $50,x			lda 	NSStatus,x
.9e1b	95 52		sta $52,x			sta 	NSStatus+2,x
.9e1d	60		rts				rts
.9e1e					NSMSetZeroMantissaOnly:
.9e1e	a9 00		lda #$00			lda 	#0
.9e20	80 06		bra $9e28			bra 	NSMSetMantissa
.9e22					NSMSetZero:
.9e22	a9 00		lda #$00			lda 	#0
.9e24					NSMSetByte:
.9e24	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e26	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9e28					NSMSetMantissa:
.9e28	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9e2a	74 60		stz $60,x			stz 	NSMantissa1,x
.9e2c	74 68		stz $68,x			stz 	NSMantissa2,x
.9e2e	74 70		stz $70,x			stz 	NSMantissa3,x
.9e30	60		rts				rts
.9e31					NSMShiftLeft:
.9e31	18		clc				clc
.9e32					NSMRotateLeft:
.9e32	36 58		rol $58,x			rol 	NSMantissa0,x
.9e34	36 60		rol $60,x			rol		NSMantissa1,x
.9e36	36 68		rol $68,x			rol		NSMantissa2,x
.9e38	36 70		rol $70,x			rol		NSMantissa3,x
.9e3a	60		rts				rts
.9e3b					NSMShiftRight:
.9e3b	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9e3d	76 68		ror $68,x			ror		NSMantissa2,x
.9e3f	76 60		ror $60,x			ror		NSMantissa1,x
.9e41	76 58		ror $58,x			ror		NSMantissa0,x
.9e43	60		rts				rts
.9e44					NSMIsZero:
.9e44	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e46	15 68		ora $68,x			ora		NSMantissa2,x
.9e48	15 60		ora $60,x			ora		NSMantissa1,x
.9e4a	15 58		ora $58,x			ora		NSMantissa0,x
.9e4c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9e4d					TickHandler:
.9e4d	5a		phy				phy 								; need to preserve Y
.9e4e	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9e51	7a		ply				ply
.9e52	60		rts				rts
.065c					LastTick:
>065c							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e53					Assemble_ora:
.9e53	20 b4 80	jsr $80b4		jsr	AssembleGroup1
>9e56	01					.byte $01
.9e57					Assemble_and:
.9e57	20 b4 80	jsr $80b4		jsr	AssembleGroup1
>9e5a	21					.byte $21
.9e5b					Assemble_eor:
.9e5b	20 b4 80	jsr $80b4		jsr	AssembleGroup1
>9e5e	41					.byte $41
.9e5f					Assemble_adc:
.9e5f	20 b4 80	jsr $80b4		jsr	AssembleGroup1
>9e62	61					.byte $61
.9e63					Assemble_sta:
.9e63	20 b4 80	jsr $80b4		jsr	AssembleGroup1
>9e66	81					.byte $81
.9e67					Assemble_lda:
.9e67	20 b4 80	jsr $80b4		jsr	AssembleGroup1
>9e6a	a1					.byte $a1
.9e6b					Assemble_cmp:
.9e6b	20 b4 80	jsr $80b4		jsr	AssembleGroup1
>9e6e	c1					.byte $c1
.9e6f					Assemble_sbc:
.9e6f	20 b4 80	jsr $80b4		jsr	AssembleGroup1
>9e72	e1					.byte $e1
.9e73					Assemble_asl:
.9e73	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9e76	02					.byte $02
>9e77	75					.byte $75
.9e78					Assemble_rol:
.9e78	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9e7b	22					.byte $22
>9e7c	75					.byte $75
.9e7d					Assemble_lsr:
.9e7d	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9e80	42					.byte $42
>9e81	75					.byte $75
.9e82					Assemble_ror:
.9e82	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9e85	62					.byte $62
>9e86	75					.byte $75
.9e87					Assemble_stx:
.9e87	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9e8a	82					.byte $82
>9e8b	50					.byte $50
.9e8c					Assemble_ldx:
.9e8c	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9e8f	a2					.byte $a2
>9e90	d0					.byte $d0
.9e91					Assemble_dec:
.9e91	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9e94	c2					.byte $c2
>9e95	55					.byte $55
.9e96					Assemble_inc:
.9e96	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9e99	e2					.byte $e2
>9e9a	55					.byte $55
.9e9b					Assemble_stz:
.9e9b	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9e9e	60					.byte $60
>9e9f	44					.byte $44
.9ea0					Assemble_bit:
.9ea0	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9ea3	20					.byte $20
>9ea4	55					.byte $55
.9ea5					Assemble_sty:
.9ea5	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9ea8	80					.byte $80
>9ea9	54					.byte $54
.9eaa					Assemble_ldy:
.9eaa	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9ead	a0					.byte $a0
>9eae	d5					.byte $d5
.9eaf					Assemble_cpy:
.9eaf	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9eb2	c0					.byte $c0
>9eb3	d4					.byte $d4
.9eb4					Assemble_cpx:
.9eb4	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9eb7	e0					.byte $e0
>9eb8	d0					.byte $d0
.9eb9					Assemble_tsb:
.9eb9	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9ebc	00					.byte $00
>9ebd	50					.byte $50
.9ebe					Assemble_trb:
.9ebe	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9ec1	10					.byte $10
>9ec2	50					.byte $50
.9ec3					Assemble_jsr:
.9ec3	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9ec6	14					.byte $14
>9ec7	10					.byte $10
.9ec8					Assemble_jmp:
.9ec8	20 bb 80	jsr $80bb		jsr	AssembleGroup2
>9ecb	40					.byte $40
>9ecc	10					.byte $10
.9ecd					Assemble_bpl:
.9ecd	20 0c 81	jsr $810c		jsr	AssembleGroup3
>9ed0	10					.byte $10
.9ed1					Assemble_bmi:
.9ed1	20 0c 81	jsr $810c		jsr	AssembleGroup3
>9ed4	30					.byte $30
.9ed5					Assemble_bvc:
.9ed5	20 0c 81	jsr $810c		jsr	AssembleGroup3
>9ed8	50					.byte $50
.9ed9					Assemble_bvs:
.9ed9	20 0c 81	jsr $810c		jsr	AssembleGroup3
>9edc	70					.byte $70
.9edd					Assemble_bcc:
.9edd	20 0c 81	jsr $810c		jsr	AssembleGroup3
>9ee0	90					.byte $90
.9ee1					Assemble_bcs:
.9ee1	20 0c 81	jsr $810c		jsr	AssembleGroup3
>9ee4	b0					.byte $b0
.9ee5					Assemble_bne:
.9ee5	20 0c 81	jsr $810c		jsr	AssembleGroup3
>9ee8	d0					.byte $d0
.9ee9					Assemble_beq:
.9ee9	20 0c 81	jsr $810c		jsr	AssembleGroup3
>9eec	f0					.byte $f0
.9eed					Assemble_bra:
.9eed	20 0c 81	jsr $810c		jsr	AssembleGroup3
>9ef0	80					.byte $80
.9ef1					Assemble_brk:
.9ef1	20 40 81	jsr $8140		jsr	AssembleGroup4
>9ef4	00					.byte $00
.9ef5					Assemble_php:
.9ef5	20 40 81	jsr $8140		jsr	AssembleGroup4
>9ef8	08					.byte $08
.9ef9					Assemble_clc:
.9ef9	20 40 81	jsr $8140		jsr	AssembleGroup4
>9efc	18					.byte $18
.9efd					Assemble_plp:
.9efd	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f00	28					.byte $28
.9f01					Assemble_sec:
.9f01	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f04	38					.byte $38
.9f05					Assemble_rti:
.9f05	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f08	40					.byte $40
.9f09					Assemble_pha:
.9f09	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f0c	48					.byte $48
.9f0d					Assemble_cli:
.9f0d	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f10	58					.byte $58
.9f11					Assemble_phy:
.9f11	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f14	5a					.byte $5a
.9f15					Assemble_rts:
.9f15	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f18	60					.byte $60
.9f19					Assemble_pla:
.9f19	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f1c	68					.byte $68
.9f1d					Assemble_sei:
.9f1d	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f20	78					.byte $78
.9f21					Assemble_ply:
.9f21	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f24	7a					.byte $7a
.9f25					Assemble_dey:
.9f25	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f28	88					.byte $88
.9f29					Assemble_txa:
.9f29	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f2c	8a					.byte $8a
.9f2d					Assemble_tya:
.9f2d	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f30	98					.byte $98
.9f31					Assemble_txs:
.9f31	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f34	9a					.byte $9a
.9f35					Assemble_tay:
.9f35	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f38	a8					.byte $a8
.9f39					Assemble_tax:
.9f39	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f3c	aa					.byte $aa
.9f3d					Assemble_clv:
.9f3d	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f40	b8					.byte $b8
.9f41					Assemble_tsx:
.9f41	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f44	ba					.byte $ba
.9f45					Assemble_iny:
.9f45	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f48	c8					.byte $c8
.9f49					Assemble_dex:
.9f49	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f4c	ca					.byte $ca
.9f4d					Assemble_cld:
.9f4d	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f50	d8					.byte $d8
.9f51					Assemble_phx:
.9f51	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f54	da					.byte $da
.9f55					Assemble_stp:
.9f55	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f58	db					.byte $db
.9f59					Assemble_inx:
.9f59	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f5c	e8					.byte $e8
.9f5d					Assemble_nop:
.9f5d	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f60	ea					.byte $ea
.9f61					Assemble_sed:
.9f61	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f64	f8					.byte $f8
.9f65					Assemble_plx:
.9f65	20 40 81	jsr $8140		jsr	AssembleGroup4
>9f68	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f69					DecimalScalarTable:
>9f69	66 66 66 66				.dword $66666666 ; 0.1
>9f6d	de					.byte $de
>9f6e	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f72	db					.byte $db
>9f73	4c 37 89 41				.dword $4189374c ; 0.001
>9f77	d8					.byte $d8
>9f78	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f7c	d4					.byte $d4
>9f7d	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f81	d1					.byte $d1
>9f82	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f86	ce					.byte $ce
>9f87	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f8b	ca					.byte $ca
>9f8c	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9f90	c7					.byte $c7
>9f91	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f95	c4					.byte $c4
>9f96	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f9a	c0					.byte $c0
>9f9b	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9f9f	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fa0					SyntaxError:
.9fa0	a9 02		lda #$02		lda	#2
.9fa2	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.9fa5					RangeError:
.9fa5	a9 04		lda #$04		lda	#4
.9fa7	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.9faa					TypeError:
.9faa	a9 05		lda #$05		lda	#5
.9fac	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.9faf					ArgumentError:
.9faf	a9 07		lda #$07		lda	#7
.9fb1	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.9fb4					NotDoneError:
.9fb4	a9 0c		lda #$0c		lda	#12
.9fb6	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.9fb9					ErrorText:
>9fb9	42 72 65 61 6b 00			.text	"Break",0
>9fbf	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fc7	72 72 6f 72 00
>9fcc	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fd4	20 62 79 20 7a 65 72 6f 00
>9fdd	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9fe5	61 6e 67 65 00
>9fea	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9ff2	6d 61 74 63 68 00
>9ff8	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a000	65 6d 6f 72 79 00
>a006	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a00e	61 72 67 75 6d 65 6e 74 00
>a017	53 74 6f 70 00				.text	"Stop",0
>a01c	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a024	6f 6f 20 6c 6f 6e 67 00
>a02c	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a034	6e 20 66 61 69 6c 65 64 00
>a03d	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a045	61 74 61 00
>a049	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a051	65 6e 74 65 64 00
>a057	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a05f	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a06b	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a073	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a080	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a088	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a095	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a09d	68 6f 75 74 20 57 68 69 6c 65 00
>a0a8	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0b0	68 6f 75 74 20 46 6f 72 00
>a0b9	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0c1	61 63 6b 20 66 75 6c 6c 00
>a0ca	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0d2	75 63 74 75 72 65 00
>a0d9	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0e1	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a0ee	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a0f6	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a104	41 72 72 61 79 20 73 69			.text	"Array size",0
>a10c	7a 65 00
>a10f	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a117	79 20 69 6e 64 65 78 00
>a11f	41 72 72 61 79 20 6e 6f			.text	"Array not declared",0
>a127	74 20 64 65 63 6c 61 72 65 64 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a132	41 6c 70 68 61 20 31 33			.text "Alpha 13 built 08-Dec-22. "
>a13a	20 62 75 69 6c 74 20 30 38 2d 44 65 63 2d 32 32
>a14a	2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a14c					RectangleCommand:
.a14c	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a14e	80 02		bra $a152			bra 	ShapeDrawCmd
.a150					CircleCommand:
.a150	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a152					ShapeDrawCmd:
.a152	20 dc a1	jsr $a1dc			jsr 	RunGraphicsCommand
.a155					ShapeDraw:
.a155	0d 5e 06	ora $065e			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a158	4c d0 a1	jmp $a1d0			jmp 	ExecuteGraphicCommand	 	; and complete
.a15b					SpriteCommand:
.a15b	a2 00		ldx #$00			ldx 	#0
.a15d	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; get image number.
.a160	5a		phy				phy
.a161	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a163	a6 58		ldx $58				ldx 	NSMantissa0
.a165	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a167	b0 0d		bcs $a176			bcs 	_SCRange
.a169	a0 ff		ldy #$ff			ldy 	#255
.a16b	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a16e	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a170	7a		ply				ply
.a171	20 dc a1	jsr $a1dc			jsr 	RunGraphicsCommand
.a174	80 5a		bra $a1d0			bra 	ExecuteGraphicCommand
.a176					_SCRange:
.a176	4c a5 9f	jmp $9fa5			jmp 	RangeError
.a179					ImageCommand:
.a179	a2 00		ldx #$00			ldx 	#0
.a17b	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; get image number.
.a17e	20 dc a1	jsr $a1dc			jsr 	RunGraphicsCommand
.a181					ImageRunDraw:
.a181	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a183	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a186	ad 64 06	lda $0664			lda 	gxDrawScale
.a189	0a		asl a				asl 	a
.a18a	0a		asl a				asl 	a
.a18b	0a		asl a				asl 	a
.a18c	a8		tay				tay
.a18d	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a18f	a6 58		ldx $58				ldx 	NSMantissa0
.a191	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a194	60		rts				rts
.a195					TextCommand:
.a195	a2 00		ldx #$00			ldx 	#0
.a197	20 7a 9d	jsr $9d7a			jsr 	EvaluateString 				; get text
.a19a	20 dc a1	jsr $a1dc			jsr 	RunGraphicsCommand
.a19d					TextRunDraw:
.a19d	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a19f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1a2	a0 00		ldy #$00			ldy 	#0
.a1a4					_IRDLoop:
.a1a4	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a1a6	85 37		sta $37				sta 	zTemp0+1
.a1a8	a5 58		lda $58				lda 	NSMantissa0
.a1aa	85 36		sta $36				sta 	zTemp0
.a1ac	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1ae	f0 13		beq $a1c3			beq 	_IRDExit
.a1b0	5a		phy				phy									; save string pos
.a1b1	48		pha				pha 								; save char
.a1b2	ad 64 06	lda $0664			lda 	gxDrawScale 				; get scale
.a1b5	0a		asl a				asl 	a
.a1b6	0a		asl a				asl 	a
.a1b7	0a		asl a				asl 	a
.a1b8	a8		tay				tay
.a1b9	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1bb	fa		plx				plx 								; char to draw
.a1bc	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1bf	7a		ply				ply 								; restore string pos
.a1c0	c8		iny				iny
.a1c1	90 e1		bcc $a1a4			bcc 	_IRDLoop 					; go back if no error.
.a1c3					_IRDExit:
.a1c3	60		rts				rts
.a1c4					PlotCommand:
.a1c4	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1c6	20 dc a1	jsr $a1dc			jsr 	RunGraphicsCommand
.a1c9	80 05		bra $a1d0			bra 	ExecuteGraphicCommand
.a1cb					LineCommand:
.a1cb	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1cd	20 dc a1	jsr $a1dc			jsr 	RunGraphicsCommand
.a1d0					ExecuteGraphicCommand:
.a1d0	0d 5d 06	ora $065d			ora 	gxCommandID 				; make a full command
.a1d3	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a1d6	b0 01		bcs $a1d9			bcs 	_EGCError
.a1d8	60		rts				rts
.a1d9					_EGCError:
.a1d9	4c a0 9f	jmp $9fa0			jmp 	SyntaxError
.a1dc					RunGraphicsCommand:
.a1dc	8d 5d 06	sta $065d			sta 	gxCommandID					; save TODO graphics command.
.a1df	68		pla				pla 								; pop handler address
.a1e0	fa		plx				plx
.a1e1	1a		inc a				inc 	a
.a1e2	d0 01		bne $a1e5			bne 	_RGINoCarry
.a1e4	e8		inx				inx
.a1e5					_RGINoCarry:
.a1e5	8d 62 06	sta $0662			sta 	GXHandler
.a1e8	8e 63 06	stx $0663			stx 	GXHandler+1
.a1eb					_RGICommandLoop:
.a1eb	b1 30		lda ($30),y			lda 	(codePtr),y
.a1ed	c8		iny				iny
.a1ee	c9 d2		cmp #$d2			cmp 	#KWD_TO						; is it TO x,y
.a1f0	f0 53		beq $a245			beq 	_RGI_To
.a1f2	c9 bd		cmp #$bd			cmp 	#KWD_HERE 					; do it here.
.a1f4	f0 55		beq $a24b			beq 	_RGI_Here
.a1f6	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a1f8	f0 3d		beq $a237			beq 	_RGI_Exit
.a1fa	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a1fc	f0 39		beq $a237			beq 	_RGI_Exit
.a1fe	c9 c5		cmp #$c5			cmp 	#KWD_OUTLINE 				; solid or outline
.a200	f0 3e		beq $a240			beq 	_RGI_Frame
.a202	c9 ce		cmp #$ce			cmp 	#KWD_SOLID
.a204	f0 33		beq $a239			beq 	_RGI_Solid
.a206	c9 ad		cmp #$ad			cmp 	#KWD_BY 					; by offset
.a208	f0 4b		beq $a255			beq 	_RGI_By
.a20a	c9 b9		cmp #$b9			cmp 	#KWD_FROM 					; from
.a20c	f0 17		beq $a225			beq 	_RGI_Move2
.a20e	c9 b5		cmp #$b5			cmp 	#KWD_DIM 					; dim (set scale)
.a210	f0 62		beq $a274			beq 	_RGI_Dim
.a212	c9 b3		cmp #$b3			cmp 	#KWD_COLOUR 				; colour or Color
.a214	f0 74		beq $a28a			beq 	_RGI_Colour
.a216	c9 b2		cmp #$b2			cmp 	#KWD_COLOR
.a218	f0 70		beq $a28a			beq 	_RGI_Colour
.a21a	ae 5d 06	ldx $065d			ldx 	gxCommandID
.a21d	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a21f	d0 03		bne $a224			bne 	_RGI_Move 					; move
.a221	4c b2 a2	jmp $a2b2			jmp		_RGI_SpriteInstructions
.a224					_RGI_Move:
.a224	88		dey				dey 								; unpick get.
.a225					_RGI_Move2:
.a225	20 d8 a2	jsr $a2d8			jsr 	GCGetCoordinatePair 		; move to here
.a228	20 ff a2	jsr $a2ff			jsr 	GCCopyPairToStore 			; save
.a22b	5a		phy				phy
.a22c	20 f5 a2	jsr $a2f5			jsr 	GCLoadAXY 					; load in
.a22f	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a231	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a234	7a		ply				ply
.a235	80 b4		bra $a1eb			bra 	_RGICommandLoop 			; and go round
.a237					_RGI_Exit:
.a237	88		dey				dey 								; unpick : / EOL
.a238	60		rts				rts
.a239					_RGI_Solid:
.a239	a9 02		lda #$02			lda 	#2
.a23b	8d 5e 06	sta $065e			sta 	gxFillSolid
.a23e	80 ab		bra $a1eb			bra 	_RGICommandLoop
.a240					_RGI_Frame:
.a240	9c 5e 06	stz $065e			stz 	gxFillSolid
.a243	80 a6		bra $a1eb			bra 	_RGICommandLoop
.a245					_RGI_To:
.a245	20 d8 a2	jsr $a2d8			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a248	20 ff a2	jsr $a2ff			jsr 	GCCopyPairToStore
.a24b					_RGI_Here:
.a24b	5a		phy				phy
.a24c	20 f5 a2	jsr $a2f5			jsr 	GCLoadAXY 					; load it into AXY
.a24f	20 af a2	jsr $a2af			jsr 	_RGICallHandler 			; go do whatever it is.
.a252	7a		ply				ply
.a253	80 96		bra $a1eb			bra 	_RGICommandLoop 			; and go round
.a255					_RGI_By:
.a255	20 e5 a2	jsr $a2e5			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a258	18		clc				clc
.a259	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a25b	6d 5f 06	adc $065f			adc 	gxxPos
.a25e	8d 5f 06	sta $065f			sta 	gxXPos
.a261	a5 61		lda $61				lda 	NSMantissa1+1
.a263	6d 60 06	adc $0660			adc 	gxxPos+1
.a266	8d 60 06	sta $0660			sta 	gxXPos+1
.a269	a5 5a		lda $5a				lda 	NSMantissa0+2
.a26b	18		clc				clc
.a26c	6d 61 06	adc $0661			adc 	gxYPos
.a26f	8d 61 06	sta $0661			sta 	gxYPos
.a272	80 d7		bra $a24b			bra 	_RGI_Here
.a274					_RGI_Dim:
.a274	a2 01		ldx #$01			ldx	 	#1
.a276	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger
.a279	a5 59		lda $59				lda 	NSMantissa0+1
.a27b	c9 00		cmp #$00			cmp 	#0
.a27d	f0 2d		beq $a2ac			beq 	_RGIRange
.a27f	c9 09		cmp #$09			cmp 	#8+1
.a281	b0 29		bcs $a2ac			bcs		_RGIRange
.a283	3a		dec a				dec 	a
.a284	8d 64 06	sta $0664			sta 	gxDrawScale
.a287	4c eb a1	jmp $a1eb			jmp 	_RGICommandLoop
.a28a					_RGI_Colour:
.a28a	a2 01		ldx #$01			ldx 	#1 							; colour
.a28c	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger
.a28f	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a291	20 22 9e	jsr $9e22			jsr 	NSMSetZero
.a294	b1 30		lda ($30),y			lda 	(codePtr),y
.a296	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a298	d0 04		bne $a29e			bne 	_RGICDefaultMode
.a29a	c8		iny				iny
.a29b	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger
.a29e					_RGICDefaultMode:
.a29e	5a		phy				phy
.a29f	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2a1	a6 59		ldx $59				ldx 	NSMantissa0+1
.a2a3	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2a5	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2a8	7a		ply				ply
.a2a9	4c eb a1	jmp $a1eb			jmp 	_RGICommandLoop 			; and go round
.a2ac					_RGIRange:
.a2ac	4c a5 9f	jmp $9fa5			jmp 	RangeError
.a2af					_RGICallHandler:
.a2af	6c 62 06	jmp ($0662)			jmp 	(GXHandler)
.a2b2					_RGI_SpriteInstructions:
.a2b2	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a2b4	f0 07		beq $a2bd			beq 	_RGISpriteOff
.a2b6	c9 be		cmp #$be			cmp 	#KWD_IMAGE
.a2b8	f0 13		beq $a2cd			beq 	_RGISetImage
.a2ba	4c 24 a2	jmp $a224			jmp 	_RGI_Move
.a2bd					_RGISpriteOff:
.a2bd	5a		phy				phy
.a2be	a0 01		ldy #$01			ldy 	#1
.a2c0	a2 00		ldx #$00			ldx 	#0
.a2c2					_RGIDoCommandLoop:
.a2c2	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2c4	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2c7	7a		ply				ply
.a2c8	b0 e2		bcs $a2ac			bcs 	_RGIRange
.a2ca	4c eb a1	jmp $a1eb			jmp 	_RGICommandLoop
.a2cd					_RGISetImage:
.a2cd	a2 01		ldx #$01			ldx 	#1
.a2cf	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger
.a2d2	5a		phy				phy
.a2d3	aa		tax				tax
.a2d4	a0 00		ldy #$00			ldy 	#0
.a2d6	80 ea		bra $a2c2			bra 	_RGIDoCommandLoop
.a2d8					GCGetCoordinatePair:
.a2d8	a2 01		ldx #$01			ldx 	#1
.a2da	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger
.a2dd	20 ea 8e	jsr $8eea			jsr 	CheckComma
.a2e0	e8		inx				inx
.a2e1	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger
.a2e4	60		rts				rts
.a2e5					GCSignedCoordinatePair:
.a2e5	a2 01		ldx #$01			ldx 	#1
.a2e7	20 ac 9d	jsr $9dac			jsr 	Evaluate16BitIntegerSigned
.a2ea	20 ea 8e	jsr $8eea			jsr 	CheckComma
.a2ed	e8		inx				inx
.a2ee	20 ac 9d	jsr $9dac			jsr 	Evaluate16BitIntegerSigned
.a2f1	60		rts				rts
.a2f2					_GCCPRange:
.a2f2	4c a5 9f	jmp $9fa5			jmp 	RangeError
.a2f5					GCLoadAXY:
.a2f5	ad 60 06	lda $0660			lda 	gxXPos+1
.a2f8	ae 5f 06	ldx $065f			ldx 	gxXPos
.a2fb	ac 61 06	ldy $0661			ldy 	gxYPos
.a2fe	60		rts				rts
.a2ff					GCCopyPairToStore:
.a2ff	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a301	8d 5f 06	sta $065f			sta 	gxXPos
.a304	a5 61		lda $61				lda 	NSMantissa1+1
.a306	8d 60 06	sta $0660			sta 	gxXPos+1
.a309	a5 5a		lda $5a				lda 	NSMantissa0+2
.a30b	8d 61 06	sta $0661			sta 	gxYPos
.a30e	60		rts				rts
.065d					gxCommandID:
>065d							.fill 	1
.065e					gxFillSolid:
>065e							.fill 	1
.065f					gxXPos:
>065f							.fill 	2
.0661					gxYPos:
>0661							.fill 	1
.0662					gxHandler:
>0662							.fill 	2
.0664					gxDrawScale:
>0664							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a30f					BitmapCtrl:
.a30f	b1 30		lda ($30),y			lda 	(codePtr),y
.a311	c8		iny				iny
.a312	a2 01		ldx #$01			ldx 	#1
.a314	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a316	f0 11		beq $a329			beq 	BitmapSwitch
.a318	ca		dex				dex
.a319	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a31b	f0 0c		beq $a329			beq 	BitmapSwitch
.a31d	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; get the colour
.a320	5a		phy				phy
.a321	aa		tax				tax
.a322	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a324	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a327	7a		ply				ply
.a328	60		rts				rts
.a329					BitmapSwitch:
.a329	5a		phy				phy
.a32a	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a32c	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a32e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a331	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a333	a0 00		ldy #$00			ldy 	#0
.a335	a2 ff		ldx #$ff			ldx 	#$FF
.a337	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a33a	9c 5e 06	stz $065e			stz 	gxFillSolid
.a33d	9c 5f 06	stz $065f			stz 	gxXPos
.a340	9c 60 06	stz $0660			stz 	gxXPos+1
.a343	9c 61 06	stz $0661			stz 	gxYPos
.a346	9c 64 06	stz $0664			stz 	gxDrawScale
.a349	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a34b	a2 00		ldx #$00			ldx 	#0
.a34d	a0 00		ldy #$00			ldy 	#0
.a34f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a352	7a		ply				ply
.a353	60		rts				rts
.a354					SpritesCtrl:
.a354	b1 30		lda ($30),y			lda 	(codePtr),y
.a356	c8		iny				iny
.a357	a2 01		ldx #$01			ldx 	#1
.a359	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a35b	f0 08		beq $a365			beq 	SpriteSwitch
.a35d	ca		dex				dex
.a35e	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a360	f0 03		beq $a365			beq 	SpriteSwitch
.a362	4c a0 9f	jmp $9fa0			jmp 	SyntaxError
.a365					SpriteSwitch:
.a365	5a		phy				phy
.a366	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a368	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a36a	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a36d	7a		ply				ply
.a36e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a36f					GfxCommand:
.a36f	a2 00		ldx #$00			ldx 	#0
.a371	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; command
.a374	20 ea 8e	jsr $8eea			jsr 	CheckComma
.a377	e8		inx				inx
.a378	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger 		; X
.a37b	20 ea 8e	jsr $8eea			jsr 	CheckComma
.a37e	e8		inx				inx
.a37f	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; Y
.a382	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a384	4a		lsr a				lsr 	a
.a385	d0 12		bne $a399			bne 	_GfxError
.a387	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a389	b0 0e		bcs $a399			bcs 	_GfxError 					; bit 7 should have been zero
.a38b	5a		phy				phy 								; save pos
.a38c	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a38e	a6 59		ldx $59				ldx 	NSMantissa0+1
.a390	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a392	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a395	b0 02		bcs $a399			bcs 	_GfxError
.a397	7a		ply				ply 								; restore pos and exit.
.a398	60		rts				rts
.a399					_GfxError:
.a399	4c a5 9f	jmp $9fa5			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a39c					UnaryHit:
.a39c	fa		plx				plx
.a39d	a9 36		lda #$36			lda 	#zTemp0
.a39f	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3a2	20 ea 8e	jsr $8eea			jsr 	CheckComma
.a3a5	e8		inx				inx
.a3a6	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3a9	20 e2 8e	jsr $8ee2			jsr		CheckRightBracket
.a3ac	ca		dex				dex 								; fix back up again.
.a3ad	da		phx				phx 								; save X/Y
.a3ae	5a		phy				phy
.a3af	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3b1	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3b3	aa		tax				tax
.a3b4	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3b6	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a3b9	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3ba	7a		ply				ply 								; restore XY
.a3bb	fa		plx				plx
.a3bc	20 24 9e	jsr $9e24			jsr 	NSMSetByte 					; return the hit result
.a3bf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3c0					PaletteCommand:
.a3c0	a2 00		ldx #$00			ldx 	#0
.a3c2	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; colour
.a3c5	20 ea 8e	jsr $8eea			jsr 	CheckComma
.a3c8	e8		inx				inx
.a3c9	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger 		; r
.a3cc	20 ea 8e	jsr $8eea			jsr 	CheckComma
.a3cf	e8		inx				inx
.a3d0	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; g
.a3d3	20 ea 8e	jsr $8eea			jsr 	CheckComma
.a3d6	e8		inx				inx
.a3d7	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; b
.a3da	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a3dc	85 36		sta $36				sta 	zTemp0
.a3de	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a3e0	85 37		sta $37				sta 	zTemp0+1
.a3e2	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a3e4	26 37		rol $37				rol	 	zTemp0+1
.a3e6	06 36		asl $36				asl 	zTemp0
.a3e8	26 37		rol $37				rol	 	zTemp0+1
.a3ea	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a3ec	85 01		sta $01				sta 	1
.a3ee	5a		phy				phy
.a3ef	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a3f1	92 36		sta ($36)			sta 	(zTemp0)
.a3f3	a0 01		ldy #$01			ldy 	#1
.a3f5	a5 5a		lda $5a				lda 	NSMantissa0+2
.a3f7	91 36		sta ($36),y			sta 	(zTemp0),y
.a3f9	a5 59		lda $59				lda 	NSMantissa0+1
.a3fb	c8		iny				iny
.a3fc	91 36		sta ($36),y			sta 	(zTemp0),y
.a3fe	7a		ply				ply
.a3ff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a400					UnaryEvent:
.a400	fa		plx				plx
.a401	20 ae a4	jsr $a4ae			jsr 	TimerToStackX 				; timer in +0
.a404	e8		inx				inx  								; put reference into +1
.a405	20 49 98	jsr $9849			jsr 	EvaluateTerm
.a408	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a40a	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a40c	d0 4c		bne $a45a			bne 	_UEType
.a40e	e8		inx				inx 								; put the step in +2
.a40f	20 ea 8e	jsr $8eea			jsr 	CheckComma
.a412	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger
.a415	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.a418	ca		dex				dex
.a419	ca		dex				dex
.a41a	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a41c	85 36		sta $36				sta 	zTemp0
.a41e	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a420	85 37		sta $37				sta 	zTemp0+1
.a422	5a		phy				phy
.a423	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a425	b1 36		lda ($36),y			lda 	(zTemp0),y
.a427	30 2d		bmi $a456			bmi 	_UEFalse 					; exit if signed.
.a429	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a42b	b5 58		lda $58,x			lda 	NSMantissa0,x
.a42d	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a42f	c8		iny				iny
.a430	b5 60		lda $60,x			lda 	NSMantissa1,x
.a432	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a434	c8		iny				iny
.a435	b5 68		lda $68,x			lda 	NSMantissa2,x
.a437	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a439	90 1b		bcc $a456			bcc 	_UEFalse 					; no, return FALSE.
.a43b	18		clc				clc
.a43c	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a43e	b5 58		lda $58,x			lda 	NSMantissa0,x
.a440	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a442	91 36		sta ($36),y			sta 	(zTemp0),y
.a444	c8		iny				iny
.a445	b5 60		lda $60,x			lda 	NSMantissa1,x
.a447	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a449	91 36		sta ($36),y			sta 	(zTemp0),y
.a44b	c8		iny				iny
.a44c	b5 68		lda $68,x			lda 	NSMantissa2,x
.a44e	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a450	91 36		sta ($36),y			sta 	(zTemp0),y
.a452	7a		ply				ply
.a453	4c 68 8f	jmp $8f68			jmp 	ReturnTrue
.a456					_UEFalse:
.a456	7a		ply				ply 								; restore Y
.a457	4c 73 8f	jmp $8f73			jmp 	ReturnFalse 				; and return False
.a45a					_UEType:
.a45a	4c aa 9f	jmp $9faa			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a45d					UnaryJoyX:
.a45d	18		clc				clc
.a45e	80 01		bra $a461			bra 	JoyMain
.a460					UnaryJoyY:
.a460	38		sec				sec
.a461					JoyMain:
.a461	fa		plx				plx 								; get pos
.a462	08		php				php 								; save carry (set for Y)
.a463	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a466	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.a469	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a46c	28		plp				plp
.a46d	90 02		bcc $a471			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a46f	4a		lsr a				lsr 	a
.a470	4a		lsr a				lsr 	a
.a471					_JMNoShift:
.a471	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a472	b0 0a		bcs $a47e			bcs 	_JMIsRight
.a474	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a475	b0 04		bcs $a47b			bcs 	_JMIsLeft
.a477	20 22 9e	jsr $9e22			jsr 	NSMSetZero 					; zero result
.a47a	60		rts				rts
.a47b					_JMIsLeft:
.a47b	4c 68 8f	jmp $8f68			jmp 	ReturnTrue
.a47e					_JMIsRight:
.a47e	a9 01		lda #$01			lda 	#1
.a480	20 24 9e	jsr $9e24			jsr 	NSMSetByte
.a483	60		rts				rts
.a484					UnaryJoyB:
.a484	fa		plx				plx 								; get pos
.a485	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a488	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.a48b	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a48e	4a		lsr a				lsr 	a
.a48f	4a		lsr a				lsr 	a
.a490	4a		lsr a				lsr 	a
.a491	4a		lsr a				lsr 	a
.a492	29 01		and #$01			and 	#1
.a494	20 24 9e	jsr $9e24			jsr 	NSMSetByte
.a497	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a498					LoadCommand:
.a498	20 31 8a	jsr $8a31			jsr 	NewProgram
.a49b	20 23 83	jsr $8323			jsr 	BackLoadProgram
.a49e	4c da 83	jmp $83da			jmp 	WarmStart
.a4a1					GoCommand:
.a4a1	20 31 8a	jsr $8a31			jsr 	NewProgram
.a4a4	20 23 83	jsr $8323			jsr 	BackLoadProgram
.a4a7	4c 72 8b	jmp $8b72			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4aa					UnaryTimer:
.a4aa	fa		plx				plx
.a4ab	20 e2 8e	jsr $8ee2			jsr 	CheckRightBracket
.a4ae					TimerToStackX:
.a4ae	20 22 9e	jsr $9e22			jsr 	NSMSetZero 					; zero result
.a4b1	64 01		stz $01				stz 	1 							; access I/O
.a4b3	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4b6	95 58		sta $58,x			sta 	NSMantissa0,x
.a4b8	ad 5a d6	lda $d65a			lda 	$D65A
.a4bb	95 60		sta $60,x			sta 	NSMantissa1,x
.a4bd	ad 5b d6	lda $d65b			lda 	$D65B
.a4c0	95 68		sta $68,x			sta 	NSMantissa2,x
.a4c2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4c3					MemoryDeleteLine:
.a4c3	20 e2 a4	jsr $a4e2			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4c6	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4c8	a8		tay				tay
.a4c9					_MDDLLoop:
.a4c9	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4cb	92 30		sta ($30)			sta 	(codePtr)
.a4cd	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4cf	c5 3a		cmp $3a				cmp 	zTemp2
.a4d1	d0 07		bne $a4da			bne 	_MDLDLNext
.a4d3	a5 31		lda $31				lda 	codePtr+1
.a4d5	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4d7	d0 01		bne $a4da			bne 	_MDLDLNext
.a4d9					_MDDLExit:
.a4d9	60		rts				rts
.a4da					_MDLDLNext:
.a4da	e6 30		inc $30				inc 	codePtr						; next byte
.a4dc	d0 eb		bne $a4c9			bne 	_MDDLLoop
.a4de	e6 31		inc $31				inc 	codePtr+1
.a4e0	80 e7		bra $a4c9			bra 	_MDDLLoop
.a4e2					IMemoryFindEnd:
.a4e2	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4e4	85 3a		sta $3a				sta 	0+zTemp2
.a4e6	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4e8	85 3b		sta $3b				sta 	1+zTemp2
.a4ea					_MDLFELoop:
.a4ea	b2 3a		lda ($3a)			lda 	(zTemp2)
.a4ec	f0 0b		beq $a4f9			beq 	_MDLFEExit
.a4ee	18		clc				clc
.a4ef	65 3a		adc $3a				adc 	zTemp2
.a4f1	85 3a		sta $3a				sta 	zTemp2
.a4f3	90 f5		bcc $a4ea			bcc 	_MDLFELoop
.a4f5	e6 3b		inc $3b				inc 	zTemp2+1
.a4f7	80 f1		bra $a4ea			bra 	_MDLFELoop
.a4f9					_MDLFEExit:
.a4f9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a4fa					MemoryInsertLine:
.a4fa	08		php				php
.a4fb	20 e2 a4	jsr $a4e2			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4fe	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a500	1a		inc a				inc 	a
.a501	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a503	b0 36		bcs $a53b			bcs 	_MDLIError
.a505	28		plp				plp
.a506	90 08		bcc $a510			bcc 	_MDLIFound
.a508	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a50a	85 30		sta $30				sta 	codePtr
.a50c	a5 3b		lda $3b				lda 	zTemp2+1
.a50e	85 31		sta $31				sta 	codePtr+1
.a510					_MDLIFound:
.a510	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a513	a8		tay				tay
.a514					_MDLIInsert:
.a514	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a516	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a518	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a51a	c5 3a		cmp $3a				cmp 	zTemp2
.a51c	d0 06		bne $a524			bne 	_MDLINext
.a51e	a5 31		lda $31				lda 	codePtr+1
.a520	c5 3b		cmp $3b				cmp 	zTemp2+1
.a522	f0 0a		beq $a52e			beq 	_MDLIHaveSpace
.a524					_MDLINext:
.a524	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a526	d0 02		bne $a52a			bne 	_MDLINoBorrow
.a528	c6 3b		dec $3b				dec 	zTemp2+1
.a52a					_MDLINoBorrow:
.a52a	c6 3a		dec $3a				dec 	zTemp2
.a52c	80 e6		bra $a514			bra 	_MDLIInsert
.a52e					_MDLIHaveSpace:
.a52e	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a531	88		dey				dey 								; from offset-1 to 0
.a532					_MDLICopy:
.a532	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a535	91 30		sta ($30),y			sta 	(codePtr),y
.a537	88		dey				dey
.a538	10 f8		bpl $a532			bpl 	_MDLICopy
.a53a	60		rts				rts
.a53b					_MDLIError:
.a53b	a9 06		lda #$06		lda	#6
.a53d	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.a540					MDLAppendLine:
.a540	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a542	85 36		sta $36				sta 	zTemp0
.a544	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a546	85 38		sta $38				sta 	0+zTemp1
.a548	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a54a	85 39		sta $39				sta 	1+zTemp1
.a54c	b2 38		lda ($38)			lda 	(zTemp1)
.a54e	d0 0a		bne $a55a			bne 	_MDLANoInitialise
.a550	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a552	8d 65 06	sta $0665			sta 	0+AppendPointer
.a555	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a557	8d 66 06	sta $0666			sta 	1+AppendPointer
.a55a					_MDLANoInitialise:
.a55a	18		clc				clc
.a55b	ad 65 06	lda $0665			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a55e	85 38		sta $38				sta 	zTemp1
.a560	72 36		adc ($36)			adc 	(zTemp0)
.a562	8d 65 06	sta $0665			sta 	AppendPointer
.a565	ad 66 06	lda $0666			lda 	AppendPointer+1
.a568	85 39		sta $39				sta 	zTemp1+1
.a56a	69 00		adc #$00			adc 	#0
.a56c	8d 66 06	sta $0666			sta 	AppendPointer+1
.a56f	a0 00		ldy #$00			ldy 	#0
.a571					_MDLACopy:
.a571	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a573	91 38		sta ($38),y			sta 	(zTemp1),y
.a575	c8		iny				iny
.a576	98		tya				tya
.a577	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a579	d0 f6		bne $a571			bne 	_MDLACopy
.a57b	a9 00		lda #$00			lda 	#0 							; end of program.
.a57d	91 38		sta ($38),y			sta 	(zTemp1),y
.a57f	60		rts				rts
.0665					AppendPointer:
>0665							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a580					MemoryNew:
.a580	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a582	85 30		sta $30				sta 	codePtr
.a584	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a586	85 31		sta $31				sta 	codePtr+1
.a588	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a58a	92 30		sta ($30)			sta 	(codePtr)
.a58c	60		rts				rts
.a58d					MemoryInline:
.a58d	98		tya				tya 								; put address into stack,x
.a58e	18		clc				clc  								; get the offset, add codePtr
.a58f	65 30		adc $30				adc 	codePtr
.a591	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a593	a5 31		lda $31				lda 	codePtr+1
.a595	69 00		adc #$00			adc 	#0
.a597	95 60		sta $60,x			sta 	NSMantissa1,x
.a599	74 68		stz $68,x			stz 	NSMantissa2,x
.a59b	74 70		stz $70,x			stz 	NSMantissa3,x
.a59d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a59e					MemorySearch:
.a59e	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a5a0	86 37		stx $37				stx 	zTemp0+1
.a5a2	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a4	85 30		sta $30				sta 	codePtr
.a5a6	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5a8	85 31		sta $31				sta 	codePtr+1
.a5aa					_MTAXLoop:
.a5aa	b2 30		lda ($30)			lda 	(codePtr)
.a5ac	18		clc				clc
.a5ad	f0 21		beq $a5d0			beq 	_MTAXExit 					; reached end, exit with CC.
.a5af	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5b1	b1 30		lda ($30),y			lda 	(codePtr),y
.a5b3	38		sec				sec
.a5b4	e5 36		sbc $36				sbc 	zTemp0
.a5b6	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5b8	c8		iny				iny 								; do the MSB
.a5b9	b1 30		lda ($30),y			lda 	(codePtr),y
.a5bb	e5 37		sbc $37				sbc 	zTemp0+1
.a5bd	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a5bf	f0 0f		beq $a5d0			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a5c1	b0 0d		bcs $a5d0			bcs 	_MTAXExit 					; current < required exit
.a5c3	18		clc				clc
.a5c4	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a5c6	65 30		adc $30				adc 	codePtr
.a5c8	85 30		sta $30				sta 	codePtr
.a5ca	90 02		bcc $a5ce			bcc 	_CREExit
.a5cc	e6 31		inc $31				inc 	codePtr+1 					; carry
.a5ce					_CREExit:
.a5ce	80 da		bra $a5aa			bra 	_MTAXLoop
.a5d0					_MTAXExit:
.a5d0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/effects.asm

.a5d1					PingCommand:
.a5d1	5a		phy				phy 								; save pos
.a5d2	a9 01		lda #$01			lda 	#1 						; push channel.
.a5d4	48		pha				pha
.a5d5	a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.a5d7	a2 03		ldx #$03			ldx 	#3 						; length
.a5d9	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5db	80 24		bra $a601			bra 	SoundEffectCommand
.a5dd					ZapCommand:
.a5dd	5a		phy				phy 								; save pos
.a5de	a9 01		lda #$01			lda 	#1 						; push channel.
.a5e0	48		pha				pha
.a5e1	a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.a5e3	a2 05		ldx #$05			ldx 	#5 						; length
.a5e5	a0 14		ldy #$14			ldy 	#20 						; slide LSB
.a5e7	80 18		bra $a601			bra 	SoundEffectCommand
.a5e9					ShootCommand:
.a5e9	5a		phy				phy 								; save pos
.a5ea	a9 03		lda #$03			lda 	#3 						; push channel.
.a5ec	48		pha				pha
.a5ed	a9 20		lda #$20			lda 	#32 						; pitch LSB
.a5ef	a2 02		ldx #$02			ldx 	#2 						; length
.a5f1	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5f3	80 0c		bra $a601			bra 	SoundEffectCommand
.a5f5					Explode:
.a5f5	5a		phy				phy 								; save pos
.a5f6	a9 03		lda #$03			lda 	#3 						; push channel.
.a5f8	48		pha				pha
.a5f9	a9 50		lda #$50			lda 	#80 						; pitch LSB
.a5fb	a2 05		ldx #$05			ldx 	#5 						; length
.a5fd	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5ff	80 00		bra $a601			bra 	SoundEffectCommand
.a601					SoundEffectCommand:
.a601	8d 67 06	sta $0667			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.a604	9c 68 06	stz $0668			stz 	SoundCommandBlock+1
.a607	a9 0f		lda #$0f			lda 	#15
.a609	8d 69 06	sta $0669			sta 	SoundCommandBlock+2
.a60c	8e 6a 06	stx $066a			stx 	SoundCommandBlock+3
.a60f	8c 6b 06	sty $066b			sty 	SoundCommandBlock+4
.a612	9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a615	68		pla				pla
.a616	09 10		ora #$10			ora 	#$10  						; execute command $11
.a618	a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a61a	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a61c	20 18 80	jsr $8018			jsr 	SNDCommand
.a61f	7a		ply				ply
.a620	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a621					UnaryPlaying:
.a621	fa		plx				plx
.a622	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; get channel #
.a625	48		pha				pha
.a626	20 e2 8e	jsr $8ee2			jsr		CheckRightBracket
.a629	68		pla				pla
.a62a	c9 04		cmp #$04			cmp 	#4
.a62c	b0 0c		bcs $a63a			bcs 	_UPNotPlaying
.a62e	09 20		ora #$20			ora 	#$20 						; query playing ?
.a630	20 18 80	jsr $8018			jsr 	SNDCommand
.a633	c9 00		cmp #$00			cmp 	#0
.a635	f0 03		beq $a63a			beq 	_UPNotPlaying
.a637	4c 68 8f	jmp $8f68			jmp 	ReturnTrue
.a63a					_UPNotPlaying:
.a63a	4c 73 8f	jmp $8f73			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a63d					SoundCommand:
.a63d	b1 30		lda ($30),y			lda 	(codePtr),y
.a63f	c9 c3		cmp #$c3			cmp 	#KWD_OFF 					; SOUND OFF ?
.a641	d0 09		bne $a64c			bne 	_SNDMain
.a643	c8		iny				iny 								; skip OFF
.a644	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a646	5a		phy				phy
.a647	20 18 80	jsr $8018			jsr 	SNDCommand
.a64a	7a		ply				ply
.a64b	60		rts				rts
.a64c					_SNDMain:
.a64c	a2 00		ldx #$00			ldx 	#0
.a64e	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; channel
.a651	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a653	b0 4b		bcs $a6a0			bcs 	_SndError
.a655	e8		inx				inx 								; do the rest in slot 1.
.a656	20 ea 8e	jsr $8eea			jsr 	CheckComma
.a659	20 a2 9d	jsr $9da2			jsr 	Evaluate16BitInteger 		; Pitch
.a65c	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a65e	c9 10		cmp #$10			cmp 	#16
.a660	b0 3e		bcs $a6a0			bcs 	_SndError
.a662	8d 68 06	sta $0668			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a665	b5 58		lda $58,x			lda 	NSMantissa0,x
.a667	8d 67 06	sta $0667			sta 	SoundCommandBlock
.a66a	20 ea 8e	jsr $8eea			jsr 	CheckComma
.a66d	20 bd 9d	jsr $9dbd			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a670	8d 6a 06	sta $066a			sta 	SoundCommandBlock+3
.a673	a9 0f		lda #$0f			lda 	#15
.a675	8d 69 06	sta $0669			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a678	9c 6b 06	stz $066b			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a67b	9c 6c 06	stz $066c			stz 	SoundCommandBlock+5
.a67e	b1 30		lda ($30),y			lda 	(codePtr),y
.a680	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a682	d0 0e		bne $a692			bne 	_SNDPlay
.a684	c8		iny				iny
.a685	20 ac 9d	jsr $9dac			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a688	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a68a	8d 6b 06	sta $066b			sta 	SoundCommandBlock+4
.a68d	b5 60		lda $60,x			lda 	NSMantissa1,x
.a68f	8d 6c 06	sta $066c			sta 	SoundCommandBlock+5
.a692					_SNDPlay:
.a692	5a		phy				phy
.a693	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a695	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a697	a2 67		ldx #$67			ldx 	#(SoundCommandBlock & $FF)
.a699	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a69b	20 18 80	jsr $8018			jsr 	SNDCommand
.a69e	7a		ply				ply
.a69f	60		rts				rts
.a6a0					_SndError:
.a6a0	4c a5 9f	jmp $9fa5			jmp 	RangeError
.0667					SoundCommandBlock:
>0667							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a6a3					StackPushByte:
.a6a3	48		pha				pha 								; save byte on stack
.a6a4	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a6a6	d0 08		bne $a6b0			bne 	_SPBNoBorrow
.a6a8	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a6aa	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a6ac	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6ae	90 06		bcc $a6b6			bcc 	_SPBMemory
.a6b0					_SPBNoBorrow:
.a6b0	c6 34		dec $34				dec 	BasicStack
.a6b2	68		pla				pla 								; get back and write
.a6b3	92 34		sta ($34)			sta 	(BasicStack)
.a6b5	60		rts				rts
.a6b6					_SPBMemory:
.a6b6	a9 12		lda #$12		lda	#18
.a6b8	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.a6bb					StackPopByte:
.a6bb	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a6bd	e6 34		inc $34				inc 	BasicStack
.a6bf	d0 02		bne $a6c3			bne 	_SPBNoCarry
.a6c1	e6 35		inc $35				inc 	BasicStack+1
.a6c3					_SPBNoCarry:
.a6c3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a6c4					StackOpen:
.a6c4	48		pha				pha 								; save frame byte
.a6c5	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a6c7	0a		asl a				asl 	a 							; claim twice this for storage
.a6c8	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a6ca	38		sec				sec 								; so basically subtracting from
.a6cb	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a6cd	85 34		sta $34				sta 	basicStack
.a6cf	b0 09		bcs $a6da			bcs 	_SONoBorrow
>a6d1	db						.byte 	$DB 						; causes a break in the emulator
.a6d2	c6 35		dec $35				dec 	basicStack+1
.a6d4	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a6d6	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6d8	90 04		bcc $a6de			bcc 	_SOMemory
.a6da					_SONoBorrow:
.a6da	68		pla				pla 								; get marker back and write at TOS
.a6db	92 34		sta ($34)			sta 	(basicStack)
.a6dd	60		rts				rts
.a6de					_SOMemory:
.a6de	a9 12		lda #$12		lda	#18
.a6e0	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.a6e3					StackClose:
.a6e3	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6e5	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6e7	0a		asl a				asl 	a 							; claim twice this.
.a6e8	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6ea	85 34		sta $34				sta 	basicStack
.a6ec	90 02		bcc $a6f0			bcc 	_SCExit
.a6ee	e6 35		inc $35				inc 	basicStack+1
.a6f0					_SCExit:
.a6f0	60		rts				rts
.a6f1					StackCheckFrame:
.a6f1	48		pha				pha
.a6f2					_StackRemoveLocals:
.a6f2	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6f4	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a6f6	b0 05		bcs $a6fd			bcs 	_SCNoLocal
.a6f8	20 e0 89	jsr $89e0			jsr 	LocalPopValue 				; restore the local value
.a6fb	80 f5		bra $a6f2			bra 	_StackRemoveLocals 			; gr round again
.a6fd					_SCNoLocal:
.a6fd	68		pla				pla 								; get the frame check.
.a6fe	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a700	29 f0		and #$f0			and 	#$F0 						; check type bits
.a702	d0 01		bne $a705			bne 	_SCFError 					; different, we have structures mixed up
.a704	60		rts				rts
.a705					_SCFError:
.a705	8a		txa				txa 								; report error X
.a706	4c fb 8e	jmp $8efb			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a709					STKSaveCodePosition:
.a709	5a		phy				phy
.a70a	98		tya				tya 								; save Y
.a70b	a0 05		ldy #$05			ldy 	#5
.a70d	91 34		sta ($34),y			sta 	(basicStack),y
.a70f	88		dey				dey 								; save Code Pointer
.a710					_STKSaveLoop:
.a710	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a713	91 34		sta ($34),y			sta 	(basicStack),y
.a715	88		dey				dey
.a716	d0 f8		bne $a710			bne 	_STKSaveLoop
.a718	7a		ply				ply
.a719	60		rts				rts
.a71a					STKLoadCodePosition:
.a71a	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a71c					_STKLoadLoop:
.a71c	b1 34		lda ($34),y			lda 	(basicStack),y
.a71e	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a721	c8		iny				iny
.a722	c0 05		cpy #$05			cpy 	#5
.a724	d0 f6		bne $a71c			bne 	_STKLoadLoop
.a726	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a728	a8		tay				tay
.a729	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a72a					StackReset:
.a72a	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a72c	85 34		sta $34				sta 	0+basicStack
.a72e	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a730	85 35		sta $35				sta 	1+basicStack
.a732	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a734	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a736	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a737					StringConcrete:
.a737	5a		phy				phy 								; save position on stack
.a738	20 35 9a	jsr $9a35			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a73b	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a73d	85 38		sta $38				sta 	zTemp1
.a73f	b5 60		lda $60,x			lda 	NSMantissa1,x
.a741	85 39		sta $39				sta 	zTemp1+1
.a743	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a745					_SALength:
.a745	c8		iny				iny
.a746	b1 38		lda ($38),y			lda 	(zTemp1),y
.a748	d0 fb		bne $a745			bne 	_SALength
.a74a	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a74c	b0 3d		bcs $a78b			bcs 	_SALengthError
.a74e	98		tya				tya 				 				; length of the new string
.a74f	18		clc				clc
.a750	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a752	90 02		bcc $a756			bcc 	_SAHaveLength
.a754	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a756					_SAHaveLength:
.a756	48		pha				pha 								; save length.
.a757	38		sec				sec
.a758	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a75a	6d 0e 04	adc $040e			adc 	StringMemory
.a75d	8d 0e 04	sta $040e			sta 	StringMemory
.a760	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a762	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a764	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a766	6d 0f 04	adc $040f			adc 	StringMemory+1
.a769	8d 0f 04	sta $040f			sta 	StringMemory+1
.a76c	85 3b		sta $3b				sta 	zTemp2+1
.a76e	95 60		sta $60,x			sta 	NSMantissa1,x
.a770	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a771	38		sec				sec
.a772	e9 03		sbc #$03			sbc 	#3
.a774	92 3a		sta ($3a)			sta 	(zTemp2)
.a776	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a778	a0 01		ldy #$01			ldy 	#1
.a77a	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a77c					_SACopyNewString:
.a77c	a0 00		ldy #$00			ldy 	#0
.a77e					_SACopyNSLoop:
.a77e	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a780	c8		iny				iny 								; write two on in string storage
.a781	c8		iny				iny
.a782	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a784	88		dey				dey 								; this makes it one one.
.a785	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a787	d0 f5		bne $a77e			bne 	_SACopyNSLoop
.a789	7a		ply				ply
.a78a	60		rts				rts
.a78b					_SALengthError:
.a78b	a9 09		lda #$09		lda	#9
.a78d	4c fb 8e	jmp $8efb		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a790					StringSystemInitialise:
.a790	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a792	8d 0e 04	sta $040e			sta 	0+StringMemory
.a795	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a797	8d 0f 04	sta $040f			sta 	1+StringMemory
.a79a	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a79d	60		rts				rts
.a79e					StringSpaceInitialise:
.a79e	20 35 9a	jsr $9a35			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7a1	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a7a3	8d 10 04	sta $0410			sta 	StringInitialised
.a7a6	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a7a9	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a7ac	ad 0f 04	lda $040f			lda 	StringMemory+1
.a7af	3a		dec a				dec 	a
.a7b0	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7b3	60		rts				rts
.a7b4					StringTempAllocate:
.a7b4	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a7b6	b0 30		bcs $a7e8			bcs 	_STALength
.a7b8	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a7bb	30 05		bmi $a7c2			bmi 	_STAAllocate
.a7bd	48		pha				pha 								; save value to subtract.
.a7be	20 9e a7	jsr $a79e			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a7c1	68		pla				pla 								; restore it
.a7c2					_STAAllocate:
.a7c2	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a7c4	18		clc				clc  								; deliberate allows one more
.a7c5	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a7c8	8d 11 04	sta $0411			sta 	StringTempPointer
.a7cb	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a7cd	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a7cf	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a7d2	69 ff		adc #$ff			adc 	#$FF
.a7d4	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7d7	85 3d		sta $3d				sta 	zsTemp+1
.a7d9	95 60		sta $60,x			sta 	NSMantissa1,x
.a7db	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a7dd	74 70		stz $70,x			stz 	NSMantissa3,x
.a7df	a9 10		lda #$10			lda 	#NSTString
.a7e1	95 50		sta $50,x			sta 	NSStatus,x
.a7e3	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7e5	92 3c		sta ($3c)			sta 	(zsTemp)
.a7e7	60		rts				rts
.a7e8					_STALength:
.a7e8	a9 09		lda #$09		lda	#9
.a7ea	4c fb 8e	jmp $8efb		jmp	ErrorHandler
.a7ed					StringTempWrite:
.a7ed	48		pha				pha
.a7ee	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a7f0	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a7f2	d0 02		bne $a7f6			bne 	_STWNoCarry
.a7f4	e6 3d		inc $3d				inc 	zsTemp+1
.a7f6					_STWNoCarry:
.a7f6	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a7f8	92 3c		sta ($3c)			sta 	(zsTemp)
.a7fa	68		pla				pla
.a7fb	60		rts				rts

;******  Return to file: _basic.asm

.a7fc					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7fc					Export_EXTPrintCharacter:
.a7fc					PAGEDPrintCharacter:
.a7fc	48		pha				pha
.a7fd	da		phx				phx
.a7fe	5a		phy				phy
.a7ff	a6 01		ldx $01				ldx 	1
.a801	da		phx				phx
.a802	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a805	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a807	30 48		bmi $a851			bmi 	_EXPCColour
.a809	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a80b	90 4d		bcc $a85a			bcc 	_EXPCControl
.a80d	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a80f	86 01		stx $01				stx 	1
.a811	91 40		sta ($40),y			sta 	(EXTAddress),y
.a813	e6 01		inc $01				inc 	1 							; select colour memory
.a815	ad 6f 06	lda $066f			lda 	EXTTextColour
.a818	91 40		sta ($40),y			sta 	(EXTAddress),y
.a81a	c8		iny				iny 								; advance horizontal position
.a81b	8c 6e 06	sty $066e			sty 	EXTColumn
.a81e	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; reached RHS ?
.a821	90 63		bcc $a886			bcc 	_EXPCExit 					; no, then exit.
.a823					_EXPCCRLF:
.a823	ee 6d 06	inc $066d			inc 	EXTRow  					; bump row
.a826	9c 6e 06	stz $066e			stz 	EXTColumn 					; back to column 0
.a829	ad 6d 06	lda $066d			lda 	EXTRow 						; check if reached the bottom ?
.a82c	cd 71 06	cmp $0671			cmp 	EXTScreenHeight 			; if so, then scroll.
.a82f	f0 18		beq $a849			beq 	_EXPCScroll
.a831	18		clc				clc 								; add width to address.
.a832	a5 40		lda $40				lda 	EXTAddress
.a834	6d 70 06	adc $0670			adc 	EXTScreenWidth
.a837	85 40		sta $40				sta 	EXTAddress
.a839	90 4b		bcc $a886			bcc 	_EXPCExit
.a83b	e6 41		inc $41				inc 	EXTAddress+1
.a83d	80 47		bra $a886			bra 	_EXPCExit
.a83f					_EXPCLeft:
.a83f	ce 6e 06	dec $066e			dec 	EXTColumn
.a842	10 42		bpl $a886			bpl 	_EXPCExit
.a844					_EXPCBegin:
.a844	9c 6e 06	stz $066e			stz 	EXTColumn
.a847	80 3d		bra $a886			bra 	_EXPCExit
.a849					_EXPCScroll:
.a849	ce 6d 06	dec $066d			dec 	EXTRow 						; the height-1 th line.
.a84c	20 37 a9	jsr $a937			jsr 	EXTScreenScroll 			; scroll the screen
.a84f	80 35		bra $a886			bra 	_EXPCExit
.a851					_EXPCColour:
.a851	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a853	b0 31		bcs $a886			bcs 	_EXPCExit
.a855	20 17 a9	jsr $a917			jsr 	_EXPCHandleColour
.a858	80 2c		bra $a886			bra 	_EXPCExit
.a85a					_EXPCControl:
.a85a	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a85c	b0 28		bcs $a886			bcs 	_EXPCExit
.a85e	0a		asl a				asl 	a 							; double into X
.a85f	aa		tax				tax
.a860	7c f5 a8	jmp ($a8f5,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a863					_EXPCUp:
.a863	ad 6d 06	lda $066d			lda 	EXTRow 						; already at top ?
.a866	f0 1e		beq $a886			beq 	_EXPCExit
.a868	ce 6d 06	dec $066d			dec 	EXTRow 						; up one in position/address
.a86b	38		sec				sec
.a86c	a5 40		lda $40				lda 	EXTAddress
.a86e	ed 70 06	sbc $0670			sbc 	EXTScreenWidth
.a871	85 40		sta $40				sta 	EXTAddress
.a873	b0 11		bcs $a886			bcs 	_EXPCExit
.a875	c6 41		dec $41				dec 	EXTAddress+1
.a877	80 0d		bra $a886			bra 	_EXPCExit
.a879					_EXPCRight:
.a879	c8		iny				iny
.a87a	8c 6e 06	sty $066e			sty 	EXTColumn
.a87d	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.a880	d0 04		bne $a886			bne 	_EXPCExit
.a882	88		dey				dey
.a883					_EXPCSetColumnY:
.a883	8c 6e 06	sty $066e			sty 	EXTColumn
.a886					_EXPCExit:
.a886	20 8c a9	jsr $a98c			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a889	68		pla				pla
.a88a	85 01		sta $01				sta 	1
.a88c	7a		ply				ply
.a88d	fa		plx				plx
.a88e	68		pla				pla
.a88f	60		rts				rts
.a890					_EXPCClearScreen:
.a890	20 49 a9	jsr $a949			jsr		EXTClearScreenCode
.a893	80 f1		bra $a886			bra 	_EXPCExit
.a895					_EXPCDown:
.a895	ad 71 06	lda $0671			lda 	EXTScreenHeight 			; at the bottom
.a898	3a		dec a				dec 	a
.a899	cd 6d 06	cmp $066d			cmp 	EXTRow
.a89c	f0 e8		beq $a886			beq 	_EXPCExit
.a89e	ee 6d 06	inc $066d			inc 	EXTRow 						; down one in position/address
.a8a1	18		clc				clc
.a8a2	a5 40		lda $40				lda 	EXTAddress
.a8a4	6d 70 06	adc $0670			adc 	EXTScreenWidth
.a8a7	85 40		sta $40				sta 	EXTAddress
.a8a9	90 db		bcc $a886			bcc 	_EXPCExit
.a8ab	e6 41		inc $41				inc 	EXTAddress+1
.a8ad	80 d7		bra $a886			bra 	_EXPCExit
.a8af					_EXPCTab:
.a8af	ad 6e 06	lda $066e			lda 	EXTColumn 					; next tab stop
.a8b2	29 f8		and #$f8			and 	#$F8
.a8b4	18		clc				clc
.a8b5	69 08		adc #$08			adc 	#8
.a8b7	8d 6e 06	sta $066e			sta 	EXTColumn
.a8ba	cd 70 06	cmp $0670			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a8bd	90 c7		bcc $a886			bcc 	_EXPCExit
.a8bf	80 10		bra $a8d1			bra 	_EXPCEnd
.a8c1					_EXPCBackSpace:
.a8c1	88		dey				dey
.a8c2	30 c2		bmi $a886			bmi 	_EXPCExit
.a8c4	ce 6e 06	dec $066e			dec 	EXTColumn
.a8c7	a9 02		lda #$02			lda 	#2
.a8c9	85 01		sta $01				sta 	1
.a8cb	a9 20		lda #$20			lda 	#32
.a8cd	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8cf	80 b5		bra $a886			bra 	_EXPCExit
.a8d1					_EXPCEnd:
.a8d1	a9 02		lda #$02			lda 	#2 							; access text screen
.a8d3	85 01		sta $01				sta 	1
.a8d5	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; point to last character
.a8d8	88		dey				dey
.a8d9					_EXPCEndSearch:
.a8d9	88		dey				dey 								; if past start, move to col 0.
.a8da	30 06		bmi $a8e2			bmi 	_EXPCFound
.a8dc	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a8de	c9 20		cmp #$20			cmp 	#' '
.a8e0	f0 f7		beq $a8d9			beq 	_EXPCEndSearch
.a8e2					_EXPCFound:
.a8e2	c8		iny				iny 								; move to following cell.
.a8e3	80 9e		bra $a883			bra 	_EXPCSetColumnY
.a8e5					_EXPCClearEOL:
.a8e5	a9 02		lda #$02			lda 	#2 							; access character RAM
.a8e7	85 01		sta $01				sta 	1
.a8e9	a9 20		lda #$20			lda 	#' ' 						; write space
.a8eb	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8ed	c8		iny				iny
.a8ee	cc 70 06	cpy $0670			cpy 	EXTScreenWidth 				; until RHS of screen.
.a8f1	90 f2		bcc $a8e5			bcc 	_EXPCClearEOL
.a8f3	80 91		bra $a886			bra 	_EXPCExit
.a8f5					_EXPCActionTable:
>a8f5	86 a8						.word 	_EXPCExit 					; 00
>a8f7	44 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8f9	3f a8						.word 	_EXPCLeft 					; 02 B Left
>a8fb	86 a8						.word 	_EXPCExit 					; 03 <Break>
>a8fd	86 a8						.word 	_EXPCExit 					; 04
>a8ff	d1 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a901	79 a8						.word 	_EXPCRight 					; 06 F Right
>a903	86 a8						.word 	_EXPCExit 					; 07
>a905	c1 a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a907	af a8						.word 	_EXPCTab 					; 09 I Tab
>a909	86 a8						.word 	_EXPCExit 					; 0A
>a90b	e5 a8						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a90d	90 a8						.word 	_EXPCClearScreen			; 0C L CLS
>a90f	23 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a911	95 a8						.word 	_EXPCDown 					; 0E N Down
>a913	86 a8						.word 	_EXPCExit 					; 0F
>a915	63 a8						.word 	_EXPCUp 					; 10 P Up
.a917					_EXPCHandleColour
.a917	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a919	b0 16		bcs $a931			bcs 	_EXPCBackground
.a91b	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a91c	0a		asl a				asl 	a
.a91d	0a		asl a				asl 	a
.a91e	0a		asl a				asl 	a
.a91f	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a921					_EXPCUpdate:
.a921	48		pha				pha 								; save new colour
.a922	8a		txa				txa 								; get mask
.a923	2d 6f 06	and $066f			and 	EXTTextColour 				; mask out old.
.a926	8d 6f 06	sta $066f			sta 	EXTTextColour
.a929	68		pla				pla 								; or in new colour
.a92a	0d 6f 06	ora $066f			ora 	EXTTextColour
.a92d	8d 6f 06	sta $066f			sta 	EXTTextColour
.a930	60		rts				rts
.a931					_EXPCBackground:
.a931	29 0f		and #$0f			and 	#$0F 						; get the colour
.a933	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a935	80 ea		bra $a921			bra 	_EXPCUpdate
.a937					EXTScreenScroll:
.a937	a9 02		lda #$02			lda 	#2 							; select text page
.a939	85 01		sta $01				sta 	1
.a93b	a9 20		lda #$20			lda		#32 						; fill with space
.a93d	20 50 aa	jsr $aa50			jsr 	EXTScrollFill
.a940	e6 01		inc $01				inc 	1 							; select colour page
.a942	ad 6f 06	lda $066f			lda 	EXTTextColour
.a945	20 50 aa	jsr $aa50			jsr 	EXTScrollFill
.a948	60		rts				rts
.a949					EXTClearScreenCode:
.a949	a9 02		lda #$02			lda 	#2 							; select text page
.a94b	85 01		sta $01				sta 	1
.a94d	a9 20		lda #$20			lda		#32 						; fill with space
.a94f	20 5c a9	jsr $a95c			jsr 	_EXTCSFill
.a952	e6 01		inc $01				inc 	1 							; select colour page
.a954	ad 6f 06	lda $066f			lda 	EXTTextColour
.a957	20 5c a9	jsr $a95c			jsr 	_EXTCSFill
.a95a	80 22		bra $a97e			bra 	EXTHomeCursor
.a95c					_EXTCSFill:
.a95c	aa		tax				tax
.a95d	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a95f	85 40		sta $40				sta 	EXTAddress
.a961	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a963	85 41		sta $41				sta 	EXTAddress+1
.a965					_EXTCSFill1:
.a965	a0 00		ldy #$00			ldy 	#0
.a967	8a		txa				txa
.a968					_EXTCSFill2:
.a968	91 40		sta ($40),y			sta 	(EXTAddress),y
.a96a	c8		iny				iny
.a96b	d0 fb		bne $a968			bne 	_EXTCSFill2
.a96d	e6 41		inc $41				inc 	EXTAddress+1
.a96f	a5 41		lda $41				lda 	EXTAddress+1
.a971	c9 d2		cmp #$d2			cmp 	#$D2
.a973	d0 f0		bne $a965			bne 	_EXTCSFill1
.a975	8a		txa				txa
.a976					_EXTCSFill3:
.a976	91 40		sta ($40),y			sta 	(EXTAddress),y
.a978	c8		iny				iny
.a979	c0 c0		cpy #$c0			cpy 	#$C0
.a97b	d0 f9		bne $a976			bne 	_EXTCSFill3
.a97d	60		rts				rts
.a97e					EXTHomeCursor:
.a97e	9c 6d 06	stz $066d			stz 	EXTRow 						; reset row & column
.a981	9c 6e 06	stz $066e			stz 	EXTColumn
.a984	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a986	85 40		sta $40				sta 	EXTAddress
.a988	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a98a	85 41		sta $41				sta 	EXTAddress+1
.a98c					EXTSetHardwareCursor:
.a98c	64 01		stz $01				stz 	1 							; I/O Page zero
.a98e	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a990	8d 10 d0	sta $d010			sta 	$D010
.a993	a9 b1		lda #$b1			lda 	#$B1
.a995	8d 12 d0	sta $d012			sta 	$D012
.a998	ad 6e 06	lda $066e			lda 	EXTColumn
.a99b	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a99e	9c 15 d0	stz $d015			stz 	$D015
.a9a1	ad 6d 06	lda $066d			lda 	EXTRow
.a9a4	8d 16 d0	sta $d016			sta 	$D016
.a9a7	9c 17 d0	stz $d017			stz 	$D017
.a9aa	60		rts				rts
.a9ab					Export_EXTInputLine:
.a9ab	48		pha				pha
.a9ac	da		phx				phx
.a9ad	5a		phy				phy
.a9ae	a5 01		lda $01				lda 	1 							; save I/O page
.a9b0	48		pha				pha
.a9b1					_EILLoop:
.a9b1	20 cb aa	jsr $aacb			jsr 	PagedInputSingleCharacter
.a9b4	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a9b6	f0 44		beq $a9fc			beq 	_EILExit
.a9b8	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a9ba	f0 2a		beq $a9e6			beq 	_EILDelete
.a9bc	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a9be	f0 1c		beq $a9dc			beq 	_EILBackspace
.a9c0	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a9c2	90 12		bcc $a9d6			bcc 	_EILPrintLoop
.a9c4	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a9c6	b0 0e		bcs $a9d6			bcs 	_EILPrintLoop
.a9c8	48		pha				pha 								; save character
.a9c9	a9 02		lda #$02			lda 	#2  						; insert a space
.a9cb	85 01		sta $01				sta 	1
.a9cd	20 3e aa	jsr $aa3e			jsr 	EXTILInsert 				; insert in text screen
.a9d0	e6 01		inc $01				inc 	1
.a9d2	20 3e aa	jsr $aa3e			jsr 	EXTILInsert 				; insert in colour screen
.a9d5	68		pla				pla 								; get character back.
.a9d6					_EILPrintLoop:
.a9d6	20 fc a7	jsr $a7fc			jsr 	PagedPrintCharacter
.a9d9	80 d6		bra $a9b1			bra 	_EILLoop
.a9db	60		rts				rts
.a9dc					_EILBackspace:
.a9dc	ad 6e 06	lda $066e			lda 	EXTColumn					; can we backspace ?
.a9df	f0 d0		beq $a9b1			beq 	_EILLoop
.a9e1	a9 02		lda #$02			lda 	#2 							; move cursor left
.a9e3	20 fc a7	jsr $a7fc			jsr 	PagedPrintCharacter
.a9e6					_EILDelete
.a9e6	a9 02		lda #$02			lda 	#2 							; text block
.a9e8	85 01		sta $01				sta 	1
.a9ea	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a9ec	20 29 aa	jsr $aa29			jsr 	EXTILDelete
.a9ef	e6 01		inc $01				inc 	1 							; colour block
.a9f1	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; get attribute of last character
.a9f4	88		dey				dey
.a9f5	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9f7	20 29 aa	jsr $aa29			jsr 	EXTILDelete 				; backspace attribute
.a9fa	80 b5		bra $a9b1			bra 	_EILLoop 					; and go round.
.a9fc					_EILExit:
.a9fc	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a9fe	85 01		sta $01				sta 	1
.aa00	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa02					_EILScrapeLine:
.aa02	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa04	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa07	c8		iny				iny
.aa08	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.aa0b	d0 f5		bne $aa02			bne 	_EILScrapeLine
.aa0d					_EILTrimSpaces:
.aa0d	88		dey				dey
.aa0e	f0 08		beq $aa18			beq 	_EILEndTrim
.aa10	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.aa13	c9 20		cmp #$20			cmp 	#' '
.aa15	f0 f6		beq $aa0d			beq 	_EILTrimSpaces
.aa17	c8		iny				iny 								; trim after non space character.
.aa18					_EILEndTrim:
.aa18	a9 00		lda #$00			lda 	#0 							; trim here.
.aa1a	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa1d	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa1f	20 fc a7	jsr $a7fc			jsr 	PagedPrintCharacter
.aa22	68		pla				pla 								; reset I/O page
.aa23	85 01		sta $01				sta 	1
.aa25	7a		ply				ply
.aa26	fa		plx				plx
.aa27	68		pla				pla
.aa28	60		rts				rts
.aa29					EXTILDelete:
.aa29	48		pha				pha 								; save the new character
.aa2a	ac 6e 06	ldy $066e			ldy 	EXTColumn 					; start copying from here.
.aa2d					_EXTDLoop:
.aa2d	c8		iny				iny 								; copy one byte down.
.aa2e	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa30	88		dey				dey
.aa31	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa33	c8		iny				iny 								; do till end of line.
.aa34	cc 70 06	cpy $0670			cpy 	EXTScreenWidth
.aa37	90 f4		bcc $aa2d			bcc 	_EXTDLoop
.aa39	88		dey				dey 	 							; write in last slot.
.aa3a	68		pla				pla
.aa3b	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa3d	60		rts				rts
.aa3e					EXTILInsert:
.aa3e	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; end position
.aa41					_EXTILoop:
.aa41	88		dey				dey 								; back one
.aa42	cc 6e 06	cpy $066e			cpy 	EXTColumn 					; exit if reached insert point.
.aa45	f0 08		beq $aa4f			beq 	_EXTIExit
.aa47	88		dey				dey 								; copy one byte up.
.aa48	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa4a	c8		iny				iny
.aa4b	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa4d	80 f2		bra $aa41			bra 	_EXTILoop
.aa4f					_EXTIExit:
.aa4f	60		rts				rts
.aa50					EXTScrollFill:
.aa50	aa		tax				tax									; save value to fill with
.aa51	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa53	48		pha				pha
.aa54	a5 37		lda $37				lda 	zTemp0+1
.aa56	48		pha				pha
.aa57	a5 38		lda $38				lda 	zTemp1
.aa59	48		pha				pha
.aa5a	a5 39		lda $39				lda 	zTemp1+1
.aa5c	48		pha				pha
.aa5d	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa5f	85 37		sta $37				sta 	zTemp0+1
.aa61	85 39		sta $39				sta 	zTemp1+1
.aa63	64 36		stz $36				stz 	zTemp0
.aa65	ad 70 06	lda $0670			lda 	EXTScreenWidth
.aa68	85 38		sta $38				sta 	zTemp1
.aa6a	a0 00		ldy #$00			ldy 	#0
.aa6c					_EXSFCopy1:
.aa6c	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa6e	91 36		sta ($36),y			sta 	(zTemp0),y
.aa70	c8		iny				iny
.aa71	d0 f9		bne $aa6c			bne 	_EXSFCopy1
.aa73	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa75	e6 39		inc $39				inc 	zTemp1+1
.aa77	a5 39		lda $39				lda 	zTemp1+1
.aa79	c9 d3		cmp #$d3			cmp 	#$D3
.aa7b	d0 ef		bne $aa6c			bne 	_EXSFCopy1
.aa7d	ac 70 06	ldy $0670			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa80	8a		txa				txa
.aa81					_EXSFFill1:
.aa81	88		dey				dey
.aa82	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa84	c0 00		cpy #$00			cpy 	#0
.aa86	10 f9		bpl $aa81			bpl 	_EXSFFill1
.aa88	68		pla				pla
.aa89	85 39		sta $39				sta 	zTemp1+1
.aa8b	68		pla				pla
.aa8c	85 38		sta $38				sta 	zTemp1
.aa8e	68		pla				pla
.aa8f	85 37		sta $37				sta 	zTemp0+1
.aa91	68		pla				pla
.aa92	85 36		sta $36				sta 	zTemp0
.aa94	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.066d					EXTRow:
>066d							.fill 	1
.066e					EXTColumn:
>066e							.fill 	1
.066f					EXTTextColour:
>066f							.fill 	1
.0670					EXTScreenWidth:
>0670							.fill 	1
.0671					EXTScreenHeight:
>0671							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa95					Export_EXTInitialise:
.aa95	64 01		stz $01				stz 	1 							; Access I/O page 0
.aa97	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa9a	9c 08 d0	stz $d008			stz 	$D008
.aa9d	9c 09 d0	stz $d009			stz 	$D009
.aaa0	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aaa2	8d 58 d6	sta $d658			sta 	$D658
.aaa5	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.aaa7	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.aaa9	ad 00 c0	lda $c000			lda 	$C000
.aaac	8d 6f 06	sta $066f			sta 	EXTTextColour
.aaaf	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aab1	8d 70 06	sta $0670			sta 	EXTScreenWidth
.aab4	a9 3c		lda #$3c			lda 	#60
.aab6	8d 71 06	sta $0671			sta 	EXTScreenHeight
.aab9	20 7e a9	jsr $a97e			jsr 	EXTHomeCursor 				; home cursor
.aabc					_EXMoveDown:
.aabc	a9 0d		lda #$0d			lda 	#13
.aabe	20 fc a7	jsr $a7fc			jsr 	PAGEDPrintCharacter
.aac1	ad 6d 06	lda $066d			lda 	EXTRow
.aac4	c9 08		cmp #$08			cmp 	#8
.aac6	d0 f4		bne $aabc			bne 	_EXMoveDown
.aac8	64 01		stz $01				stz 	1
.aaca	60		rts				rts
.aacb					Export_EXTInputSingleCharacter:
.aacb					PagedInputSingleCharacter:
.aacb	da		phx				phx
.aacc	5a		phy				phy
.aacd					_EISCWait:
.aacd	a5 01		lda $01				lda 	1 							; save I/O 0
.aacf	48		pha				pha
.aad0	64 01		stz $01				stz 	1 							; access I/O Page 0
.aad2	38		sec				sec 								; calculate timer - LastTick
.aad3	ad 59 d6	lda $d659			lda 	$D659
.aad6	aa		tax				tax 								; saving timer in X
.aad7	ed 5c 06	sbc $065c			sbc 	LastTick
.aada	c9 03		cmp #$03			cmp 	#3
.aadc	90 06		bcc $aae4			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aade	8e 5c 06	stx $065c			stx 	LastTick 					; update last timer
.aae1	20 a7 be	jsr $bea7			jsr 	PagedSNDUpdate 							; go do the code.
.aae4					_NoFireTick:
.aae4	68		pla				pla 								; restore I/O 0
.aae5	85 01		sta $01				sta 	1
.aae7	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.aaea	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.aaec	f0 df		beq $aacd			beq 	_EISCWait
.aaee	7a		ply				ply
.aaef	fa		plx				plx
.aaf0	60		rts				rts
.aaf1					Export_EXTBreakCheck:
.aaf1	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aaf4					Export_EXTReadController:
.aaf4	da		phx				phx
.aaf5	a2 00		ldx #$00			ldx 	#0
.aaf7	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aaf9	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aafc	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aafe	f0 04		beq $ab04			beq 	_NoSet1
.ab00	8a		txa				txa
.ab01	09 01		ora #$01			ora 	#1
.ab03	aa		tax				tax
.ab04					_NoSet1:
.ab04	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab06	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab09	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab0b	f0 04		beq $ab11			beq 	_NoSet1
.ab0d	8a		txa				txa
.ab0e	09 02		ora #$02			ora 	#2
.ab10	aa		tax				tax
.ab11					_NoSet1:
.ab11	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab13	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab16	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab18	f0 04		beq $ab1e			beq 	_NoSet1
.ab1a	8a		txa				txa
.ab1b	09 04		ora #$04			ora 	#4
.ab1d	aa		tax				tax
.ab1e					_NoSet1:
.ab1e	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab20	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab23	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab25	f0 04		beq $ab2b			beq 	_NoSet1
.ab27	8a		txa				txa
.ab28	09 08		ora #$08			ora 	#8
.ab2a	aa		tax				tax
.ab2b					_NoSet1:
.ab2b	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab2d	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab30	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab32	f0 04		beq $ab38			beq 	_NoSet1
.ab34	8a		txa				txa
.ab35	09 10		ora #$10			ora 	#16
.ab37	aa		tax				tax
.ab38					_NoSet1:
.ab38	8a		txa				txa
.ab39	fa		plx				plx
.ab3a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ab3b					GRVectorTable:
>ab3b	8a ad					.word	GXInitialise             ; $00 Initialise
>ab3d	a4 ad					.word	GXControlBitmap          ; $01 BitmapCtl
>ab3f	ec ad					.word	GXControlSprite          ; $02 SpriteCtl
>ab41	3c ad					.word	GXClearBitmap            ; $03 Clear
>ab43	7b af					.word	GXSetColourMode          ; $04 Colour
>ab45	43 b1					.word	GXFontHandler            ; $05 DrawFont
>ab47	8b b1					.word	GXSpriteHandler          ; $06 DrawSprite
>ab49	fc b1					.word	GXSelect                 ; $07 SpriteUse
>ab4b	25 b2					.word	GXSelectImage            ; $08 SpriteImage
>ab4d	ac b3					.word	GXCollide                ; $09 SpriteCollide
>ab4f	ee ab					.word	GRUndefined              ; $0a
>ab51	ee ab					.word	GRUndefined              ; $0b
>ab53	ee ab					.word	GRUndefined              ; $0c
>ab55	ee ab					.word	GRUndefined              ; $0d
>ab57	ee ab					.word	GRUndefined              ; $0e
>ab59	ee ab					.word	GRUndefined              ; $0f
>ab5b	ee ab					.word	GRUndefined              ; $10
>ab5d	ee ab					.word	GRUndefined              ; $11
>ab5f	ee ab					.word	GRUndefined              ; $12
>ab61	ee ab					.word	GRUndefined              ; $13
>ab63	ee ab					.word	GRUndefined              ; $14
>ab65	ee ab					.word	GRUndefined              ; $15
>ab67	ee ab					.word	GRUndefined              ; $16
>ab69	ee ab					.word	GRUndefined              ; $17
>ab6b	ee ab					.word	GRUndefined              ; $18
>ab6d	ee ab					.word	GRUndefined              ; $19
>ab6f	ee ab					.word	GRUndefined              ; $1a
>ab71	ee ab					.word	GRUndefined              ; $1b
>ab73	ee ab					.word	GRUndefined              ; $1c
>ab75	ee ab					.word	GRUndefined              ; $1d
>ab77	ee ab					.word	GRUndefined              ; $1e
>ab79	ee ab					.word	GRUndefined              ; $1f
>ab7b	ec ab					.word	GXMove                   ; $20 Move
>ab7d	49 ae					.word	GXLine                   ; $21 Line
>ab7f	c4 af					.word	GXFrameRectangle         ; $22 FrameRect
>ab81	c1 af					.word	GXFillRectangle          ; $23 FillRect
>ab83	f3 ab					.word	GXFrameCircle            ; $24 FrameCircle
>ab85	ef ab					.word	GXFillCircle             ; $25 FillCircle
>ab87	ee ab					.word	GRUndefined              ; $26
>ab89	ee ab					.word	GRUndefined              ; $27
>ab8b	a9 af					.word	GXPlotPoint              ; $28 Plot
>ab8d	bb b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$627					gxPixelBuffer = numberBuffer
.0672					gxCurrentX:
>0672							.fill 	2
.0674					gxCurrentY:
>0674							.fill 	2
.0676					gxLastX:
>0676							.fill 	2
.0678					gxLastY:
>0678							.fill 	2
.067a					gxX0:
>067a							.fill 	2
.067c					gxY0:
>067c							.fill 	2
.067e					gxX1:
>067e							.fill 	2
.0680					gxY1:
>0680							.fill 	2
.0682					gxSpritesOn:
>0682							.fill 	1
.0683					gxBitmapsOn:
>0683							.fill 	1
.0684					gxBasePage:
>0684							.fill 	1
.0685					gxSpritePage:
>0685							.fill 	1
.0686					gxHeight:
>0686							.fill 	1
.0687					gxMode:
>0687							.fill 	1
.0688					gxColour:
>0688							.fill 	1
.0689					gxEORValue:
>0689							.fill 	1
.068a					gxANDValue:
>068a							.fill 	1
.068b					gxOriginalLUTValue:
>068b							.fill 	1
.068c					gsOffset:
>068c							.fill 	1
.068d					GSCurrentSpriteID:
>068d							.fill 	1
.068e					GSCurrentSpriteAddr:
>068e							.fill 	2
.0690					GXSpriteOffsetBase:
>0690							.fill 	2
.0692					GXSpriteLow:
>0692							.fill 	64
.06d2					GXSpriteHigh:
>06d2							.fill 	64
.ab8f					Export_GXGraphicDraw:
.ab8f	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab91	b0 06		bcs $ab99			bcs 	_GDCoordinate
.ab93	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab95	84 37		sty $37				sty 	gxzTemp0+1
.ab97	80 4b		bra $abe4			bra 	_GDExecuteA 				; and execute
.ab99					_GDCoordinate:
.ab99	48		pha				pha 								; save AXY
.ab9a	da		phx				phx
.ab9b	5a		phy				phy
.ab9c	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab9e					_GDCopy1:
.ab9e	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.aba1	9d 76 06	sta $0676,x			sta 	gxLastX,x
.aba4	ca		dex				dex
.aba5	10 f7		bpl $ab9e			bpl 	_GDCopy1
.aba7	68		pla				pla 								; update Y
.aba8	8d 74 06	sta $0674			sta 	gxCurrentY
.abab	9c 75 06	stz $0675			stz 	gxCurrentY+1
.abae	68		pla				pla
.abaf	8d 72 06	sta $0672			sta 	gxCurrentX
.abb2	68		pla				pla 								; get A (command+X.1) back
.abb3	48		pha				pha
.abb4	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.abb6	8d 73 06	sta $0673			sta 	gxCurrentX+1
.abb9	68		pla				pla 								; get command back
.abba	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abbc	48		pha				pha 								; push back.
.abbd	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abbf	f0 17		beq $abd8			beq 	_GDCopyToWorkArea
.abc1	ad 73 06	lda $0673			lda 	gxCurrentX+1 				; X < 256 X okay
.abc4	f0 07		beq $abcd			beq 	_GDCheckY
.abc6	ad 72 06	lda $0672			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abc9	c9 40		cmp #$40			cmp 	#64
.abcb	b0 08		bcs $abd5			bcs 	_GDError1
.abcd					_GDCheckY:
.abcd	ad 74 06	lda $0674			lda 	gxCurrentY 					; check Y < Height.
.abd0	cd 86 06	cmp $0686			cmp 	gxHeight
.abd3	90 03		bcc $abd8			bcc 	_GDCopyToWorkArea
.abd5					_GDError1:
.abd5	68		pla				pla
.abd6					_GDError2:
.abd6	38		sec				sec
.abd7	60		rts				rts
.abd8					_GDCopyToWorkArea:
.abd8	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abda					_GDCopy2:
.abda	bd 72 06	lda $0672,x			lda 	gxCurrentX,x
.abdd	9d 7a 06	sta $067a,x			sta 	gxX0,x
.abe0	ca		dex				dex
.abe1	10 f7		bpl $abda			bpl 	_GDCopy2
.abe3	68		pla				pla 								; get command
.abe4					_GDExecuteA:
.abe4	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abe6	b0 ee		bcs $abd6			bcs 	_GDError2
.abe8	aa		tax				tax
.abe9	7c 3b ab	jmp ($ab3b,x)			jmp 	(GRVectorTable,x)
.abec					GXMove:
.abec	18		clc				clc
.abed	60		rts				rts
.abee					GRUndefined:
>abee	db						.byte 	$DB 						; causes a break in the emulator
.abef					GXFillCircle:
.abef	a9 ff		lda #$ff			lda 	#255
.abf1	80 02		bra $abf5			bra 	GXCircle
.abf3					GXFrameCircle:
.abf3	a9 00		lda #$00			lda 	#0
.abf5					GXCircle:
.abf5	8d 15 07	sta $0715			sta 	gxIsFillMode					; save Fill flag
.abf8	ad 83 06	lda $0683			lda 	gxBitmapsOn
.abfb	f0 26		beq $ac23			beq 	_GXCFail
.abfd	20 53 b4	jsr $b453			jsr 	GXSortXY 					; topleft/bottomright
.ac00	20 2b b3	jsr $b32b			jsr 	GXOpenBitmap 				; start drawing
.ac03	20 f5 ac	jsr $acf5			jsr 	GXCircleSetup 				; set up for drawing
.ac06	9c 16 07	stz $0716			stz 	gxYChanged
.ac09					_GXCircleDraw:
.ac09	ad 13 07	lda $0713			lda 	gXCentre					; while x <= y
.ac0c	cd 14 07	cmp $0714			cmp 	gYCentre
.ac0f	90 0a		bcc $ac1b			bcc 	_GXCircleContinue
.ac11	d0 03		bne $ac16			bne 	_GXNoLast
.ac13	20 28 ac	jsr $ac28			jsr 	GXPlot1
.ac16					_GXNoLast:
.ac16	20 33 b3	jsr $b333			jsr 	GXCloseBitmap 				; close the bitmap
.ac19	18		clc				clc
.ac1a	60		rts				rts
.ac1b					_GXCircleContinue:
.ac1b	20 25 ac	jsr $ac25			jsr 	GXPlot2 					; draw it
.ac1e	20 a2 ac	jsr $aca2			jsr 	GXCircleMove 				; adjust the coordinates
.ac21	80 e6		bra $ac09			bra 	_GXCircleDraw
.ac23					_GXCFail:
.ac23	38		sec				sec
.ac24	60		rts				rts
.ac25					GXPlot2:
.ac25	20 28 ac	jsr $ac28			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac28					GXPlot1:
.ac28	ad 14 07	lda $0714			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac2b	f0 03		beq $ac30			beq 	_GXPlot1Only
.ac2d	20 4c ac	jsr $ac4c			jsr 	GXPlot0 						; plot and negate
.ac30					_GXPlot1Only:
.ac30	20 4c ac	jsr $ac4c			jsr 	GXPlot0 						; twice, undoing negation
.ac33	ad 13 07	lda $0713			lda 	gXCentre 						; swap X and Y
.ac36	ae 14 07	ldx $0714			ldx	 	gYCentre
.ac39	8d 14 07	sta $0714			sta 	gYCentre
.ac3c	8e 13 07	stx $0713			stx 	gXCentre
.ac3f	ad 16 07	lda $0716			lda 	gxYChanged 						; toggle Y Changed flag
.ac42	a9 ff		lda #$ff			lda 	#$FF
.ac44	8d 16 07	sta $0716			sta 	gxYChanged
.ac47	60		rts				rts
.ac48	20 4c ac	jsr $ac4c			jsr 	GXPlot0 						; do once
.ac4b	60		rts				rts
.ac4c	ad 15 07	lda $0715	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac4f	f0 05		beq $ac56			beq 	_GXPlot0Always
.ac51	ad 16 07	lda $0716			lda 	gxYChanged						; fill mode, only draw if changed.
.ac54	f0 2d		beq $ac83			beq 	GXPlot0Exit
.ac56					_GXPlot0Always:
.ac56	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac58	ad 14 07	lda $0714			lda 	gYCentre
.ac5b	20 84 ac	jsr $ac84			jsr 	GXSubCopy
.ac5e	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac60	ad 13 07	lda $0713			lda 	gXCentre
.ac63	20 84 ac	jsr $ac84			jsr 	GXSubCopy
.ac66	48		pha				pha 									; save last offset X
.ac67	20 3b b3	jsr $b33b			jsr 	GXPositionCalc 					; calculate position/offset.
.ac6a	68		pla				pla
.ac6b	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac6c	85 36		sta $36				sta 	gxzTemp0
.ac6e	64 37		stz $37				stz 	gxzTemp0+1
.ac70	26 37		rol $37				rol 	gxzTemp0+1
.ac72	ad 15 07	lda $0715			lda 	gxIsFillMode
.ac75	69 80		adc #$80			adc 	#128
.ac77	20 14 b0	jsr $b014			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac7a	38		sec				sec 									; GY = -GY
.ac7b	a9 00		lda #$00			lda 	#0
.ac7d	ed 14 07	sbc $0714			sbc 	gYCentre
.ac80	8d 14 07	sta $0714			sta 	gYCentre
.ac83					GXPlot0Exit:
.ac83	60		rts				rts
.ac84					GXSubCopy:
.ac84	85 36		sta $36				sta 	gxzTemp0
.ac86	64 37		stz $37				stz 	gxzTemp0+1
.ac88	29 80		and #$80			and 	#$80
.ac8a	f0 02		beq $ac8e			beq 	_GXNoSx
.ac8c	c6 37		dec $37				dec 	gxzTemp0+1
.ac8e					_GXNoSx:
.ac8e	38		sec				sec
.ac8f	bd 7e 06	lda $067e,x			lda 	gXX1,x
.ac92	e5 36		sbc $36				sbc 	gxzTemp0
.ac94	9d 7a 06	sta $067a,x			sta 	gXX0,x
.ac97	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.ac9a	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac9c	9d 7b 06	sta $067b,x			sta 	gXX0+1,x
.ac9f	a5 36		lda $36				lda 	gxzTemp0 						; return A
.aca1	60		rts				rts
.aca2					GXCircleMove:
.aca2	9c 16 07	stz $0716			stz 	gxYChanged 					; clear Y changed flag
.aca5	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.aca7	10 0d		bpl $acb6			bpl 	_GXEMPositive
.aca9	ee 13 07	inc $0713			inc 	gXCentre 					; X++
.acac	ad 13 07	lda $0713			lda 	gXCentre
.acaf	20 d5 ac	jsr $acd5			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acb2	a9 06		lda #$06			lda 	#6  						; and add 6
.acb4	80 15		bra $accb			bra 	_GXEMAddD
.acb6					_GXEMPositive:
.acb6	ee 13 07	inc $0713			inc 	gXCentre					; X++
.acb9	ce 14 07	dec $0714			dec 	gyCentre 					; Y--
.acbc	38		sec				sec 								; calculate X-Y
.acbd	ad 13 07	lda $0713			lda 	gXCentre
.acc0	ed 14 07	sbc $0714			sbc 	gYCentre
.acc3	20 d5 ac	jsr $acd5			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acc6	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acc8	ce 16 07	dec $0716			dec 	gxYChanged
.accb					_GXEMAddD:
.accb	18		clc				clc
.accc	65 38		adc $38				adc 	gxzTemp1
.acce	85 38		sta $38				sta 	gxzTemp1
.acd0	90 02		bcc $acd4			bcc 	_GXEMNoCarry
.acd2	e6 39		inc $39				inc 	gxzTemp1+1
.acd4					_GXEMNoCarry:
.acd4	60		rts				rts
.acd5					_GXAdd4TimesToD:
.acd5	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acd7	29 80		and #$80			and 	#$80
.acd9	f0 02		beq $acdd			beq 	_GXA4Unsigned
.acdb	a9 ff		lda #$ff			lda 	#$FF
.acdd					_GXA4Unsigned:
.acdd	85 37		sta $37				sta 	gxzTemp0+1
.acdf	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ace1	26 37		rol $37				rol 	gxzTemp0+1
.ace3	06 36		asl $36				asl 	gxzTemp0
.ace5	26 37		rol $37				rol 	gxzTemp0+1
.ace7	18		clc				clc 								; add
.ace8	a5 36		lda $36				lda		gxzTemp0
.acea	65 38		adc $38				adc 	gxzTemp1
.acec	85 38		sta $38				sta 	gxzTemp1
.acee	a5 37		lda $37				lda		gxzTemp0+1
.acf0	65 39		adc $39				adc 	gxzTemp1+1
.acf2	85 39		sta $39				sta 	gxzTemp1+1
.acf4	60		rts				rts
.acf5					GXCircleSetup:
.acf5	38		sec				sec
.acf6	ad 80 06	lda $0680			lda 	gxY1
.acf9	ed 7c 06	sbc $067c			sbc 	gxY0
.acfc	4a		lsr a				lsr 	a
.acfd	8d 12 07	sta $0712			sta 	gxRadius
.ad00	a2 00		ldx #$00			ldx 	#0
.ad02	20 24 ad	jsr $ad24			jsr 	_GXCalculateCentre
.ad05	a2 02		ldx #$02			ldx 	#2
.ad07	20 24 ad	jsr $ad24			jsr 	_GXCalculateCentre
.ad0a	9c 13 07	stz $0713			stz 	gXCentre
.ad0d	ad 12 07	lda $0712			lda 	gxRadius
.ad10	8d 14 07	sta $0714			sta 	gYCentre
.ad13	0a		asl a				asl 	a 							; R x 2
.ad14	85 36		sta $36				sta 	gxzTemp0
.ad16	38		sec				sec
.ad17	a9 03		lda #$03			lda 	#3
.ad19	e5 36		sbc $36				sbc 	gxzTemp0
.ad1b	85 38		sta $38				sta 	gxzTemp1
.ad1d	a9 00		lda #$00			lda 	#0
.ad1f	e9 00		sbc #$00			sbc 	#0
.ad21	85 39		sta $39				sta 	gxzTemp1+1
.ad23	60		rts				rts
.ad24					_GXCalculateCentre:
.ad24	38		sec				sec
.ad25	bd 7e 06	lda $067e,x			lda 	gxX1,x
.ad28	7d 7a 06	adc $067a,x			adc 	gXX0,x
.ad2b	9d 7e 06	sta $067e,x			sta 	gXX1,x
.ad2e	bd 7f 06	lda $067f,x			lda 	gXX1+1,x
.ad31	7d 7b 06	adc $067b,x			adc 	gXX0+1,x
.ad34	4a		lsr a				lsr 	a
.ad35	9d 7f 06	sta $067f,x			sta 	gXX1+1,x
.ad38	7e 7e 06	ror $067e,x			ror 	gXX1,x
.ad3b	60		rts				rts
.0712					gxRadius:
>0712							.fill 	1
.0713					gXCentre:
>0713							.fill 	1
.0714					gYCentre:
>0714							.fill 	1
.0715					gxIsFillMode:
>0715							.fill 	1
.0716					gxYChanged:
>0716							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad3c					GXClearBitmap:
.ad3c	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP running.
.ad3f	f0 24		beq $ad65			beq 	_GXCBFail
.ad41	20 2b b3	jsr $b32b			jsr 	GXOpenBitmap 				; start access
.ad44	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad46	ad 86 06	lda $0686			lda 	gxHeight
.ad49	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad4b	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad4d					_GXCalcLastPage:
.ad4d	98		tya				tya 								; add to base page
.ad4e	18		clc				clc
.ad4f	6d 84 06	adc $0684			adc 	gxBasePage
.ad52	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad54					_GXClearAll:
.ad54	20 67 ad	jsr $ad67			jsr 	_GXClearBlock 				; clear 8k block
.ad57	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad59	a5 0b		lda $0b				lda 	GXEditSlot
.ad5b	cd 84 06	cmp $0684			cmp 	gxBasePage 					; until before base page
.ad5e	b0 f4		bcs $ad54			bcs 	_GXClearAll
.ad60	20 33 b3	jsr $b333			jsr 	GXCloseBitmap	 			; stop access
.ad63	18		clc				clc
.ad64	60		rts				rts
.ad65					_GXCBFail:
.ad65	38		sec				sec
.ad66	60		rts				rts
.ad67					_GXClearBlock:
.ad67	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad69	85 38		sta $38				sta 	0+gxzTemp1
.ad6b	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad6d	85 39		sta $39				sta 	1+gxzTemp1
.ad6f					_GXCB0:
.ad6f	a5 36		lda $36				lda 	gxzTemp0
.ad71	a0 00		ldy #$00			ldy 	#0
.ad73					_GXCB1:
.ad73	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad75	c8		iny				iny
.ad76	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad78	c8		iny				iny
.ad79	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad7b	c8		iny				iny
.ad7c	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad7e	c8		iny				iny
.ad7f	d0 f2		bne $ad73			bne 	_GXCB1
.ad81	e6 39		inc $39				inc 	gxzTemp1+1
.ad83	a5 39		lda $39				lda 	gxzTemp1+1
.ad85	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad87	d0 e6		bne $ad6f			bne 	_GXCB0
.ad89	60		rts				rts
.ad8a					GXInitialise:
.ad8a	64 01		stz $01				stz 	1
.ad8c	a9 01		lda #$01			lda 	#1
.ad8e	8d 00 d0	sta $d000			sta 	$D000
.ad91	18		clc				clc
.ad92	9c 82 06	stz $0682			stz 	GXSpritesOn
.ad95	9c 83 06	stz $0683			stz 	GXBitmapsOn
.ad98	a2 0f		ldx #$0f			ldx 	#15
.ad9a					_GXIClear:
.ad9a	9e 72 06	stz $0672,x			stz 	gxCurrentX,x
.ad9d	ca		dex				dex
.ad9e	10 fa		bpl $ad9a			bpl 	_GXIClear
.ada0	20 3b ae	jsr $ae3b			jsr 	GXClearSpriteStore
.ada3	60		rts				rts
.ada4					GXControlBitmap:
.ada4	64 01		stz $01				stz 	1
.ada6	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ada8	29 01		and #$01			and 	#1 							; set bitmap flag
.adaa	8d 83 06	sta $0683			sta 	gxBitmapsOn
.adad	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adae	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adb1	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adb3	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.adb5	90 02		bcc $adb9			bcc 	_CBNotOn
.adb7	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.adb9					_CBNotOn:
.adb9	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adbc	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.adbe	29 07		and #$07			and 	#7
.adc0	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adc3	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adc5	d0 02		bne $adc9			bne 	_CBNotDefault
.adc7	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adc9					_CBNotDefault:
.adc9	8d 84 06	sta $0684			sta 	gxBasePage
.adcc	20 2d ae	jsr $ae2d			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adcf	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.add1	8d 03 d1	sta $d103			sta 	$D103
.add4	a5 36		lda $36				lda 	gxzTemp0
.add6	8d 02 d1	sta $d102			sta 	$D102
.add9	9c 01 d1	stz $d101			stz 	$D101
.addc	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.adde	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ade1	29 01		and #$01			and 	#1
.ade3	f0 02		beq $ade7			beq 	_CBHaveHeight
.ade5	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ade7					_CBHaveHeight
.ade7	8e 86 06	stx $0686			stx 	gxHeight
.adea	18		clc				clc
.adeb	60		rts				rts
.adec					GXControlSprite:
.adec	64 01		stz $01				stz 	1
.adee	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adf0	29 01		and #$01			and 	#1 							; set sprites flag
.adf2	8d 82 06	sta $0682			sta 	gxSpritesOn
.adf5	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adf6	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adf9	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adfb	29 df		and #$df			and 	#$DF 						; clear sprite bit
.adfd	90 02		bcc $ae01			bcc 	_CSNotOn
.adff	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ae01					_CSNotOn:
.ae01	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ae04	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ae06	d0 02		bne $ae0a			bne 	_CSNotDefault
.ae08	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ae0a					_CSNotDefault:
.ae0a	8d 85 06	sta $0685			sta 	gxSpritePage
.ae0d	20 2d ae	jsr $ae2d			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae10	a5 36		lda $36				lda 	zTemp0
.ae12	8d 90 06	sta $0690			sta 	GXSpriteOffsetBase
.ae15	a5 37		lda $37				lda 	zTemp0+1
.ae17	8d 91 06	sta $0691			sta 	GXSpriteOffsetBase+1
.ae1a	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae1c					_CSClear:
.ae1c	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae1f	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae22	ca		dex				dex
.ae23	d0 f7		bne $ae1c			bne 	_CSClear
.ae25	9c 8f 06	stz $068f			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae28	20 3b ae	jsr $ae3b			jsr 	GXClearSpriteStore
.ae2b	18		clc				clc
.ae2c	60		rts				rts
.ae2d					GXCalculateBaseAddress:
.ae2d	85 36		sta $36				sta 	gxzTemp0
.ae2f	64 37		stz $37				stz 	gxzTemp0+1
.ae31	a9 05		lda #$05			lda 	#5
.ae33					_GXShift:
.ae33	06 36		asl $36				asl 	gxzTemp0
.ae35	26 37		rol $37				rol 	gxzTemp0+1
.ae37	3a		dec a				dec		a
.ae38	d0 f9		bne $ae33			bne 	_GXShift
.ae3a	60		rts				rts
.ae3b					GXClearSpriteStore:
.ae3b	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae3d					_GXCSSLoop:
.ae3d	9e d2 06	stz $06d2,x			stz 	GXSpriteHigh,x
.ae40	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae42	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.ae45	ca		dex				dex
.ae46	10 f5		bpl $ae3d			bpl 	_GXCSSLoop
.ae48	60		rts				rts
.ae49					GXLine:
.ae49	ad 83 06	lda $0683			lda 	GXBitmapsOn
.ae4c	f0 28		beq $ae76			beq 	_GXLFail
.ae4e	20 2b b3	jsr $b32b			jsr 	GXOpenBitmap
.ae51	20 71 b4	jsr $b471			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae54	20 1c af	jsr $af1c			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae57	20 3b b3	jsr $b33b			jsr 	GXPositionCalc 				; calculate position/offset.
.ae5a					_GXDrawLoop:
.ae5a	ac 8c 06	ldy $068c			ldy 	gsOffset 					; draw the pixel
.ae5d	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae5f	2d 8a 06	and $068a			and 	gxANDValue
.ae62	4d 89 06	eor $0689			eor 	gxEORValue
.ae65	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae67	20 78 ae	jsr $ae78			jsr 	GXLineIsComplete 			; is the line complete ?
.ae6a	f0 05		beq $ae71			beq 	_GXLExit
.ae6c	20 93 ae	jsr $ae93			jsr 	GXLineAdvance 				; code as per advance method
.ae6f	80 e9		bra $ae5a			bra 	_GXDrawLoop
.ae71					_GXLExit:
.ae71	20 33 b3	jsr $b333			jsr 	GXCloseBitmap
.ae74	18		clc				clc
.ae75	60		rts				rts
.ae76					_GXLFail:
.ae76	38		sec				sec
.ae77	60		rts				rts
.ae78					GXLineIsComplete:
.ae78	ad 19 07	lda $0719			lda 	GXIsDiffYLarger 			; is dy larger
.ae7b	d0 0f		bne $ae8c			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae7d	ad 7a 06	lda $067a			lda 	GXX0 						; compare X, LSB and MSB
.ae80	4d 7e 06	eor $067e			eor 	GXX1
.ae83	d0 06		bne $ae8b			bne 	_GXLICExit
.ae85	ad 7b 06	lda $067b			lda 	GXX0+1
.ae88	4d 7f 06	eor $067f			eor 	GXX1+1
.ae8b					_GXLICExit:
.ae8b	60		rts				rts
.ae8c					_GXLICCompareY:
.ae8c	ad 80 06	lda $0680			lda 	GXY1
.ae8f	4d 7c 06	eor $067c			eor 	GXY0
.ae92	60		rts				rts
.ae93					GXLineAdvance:
.ae93	18		clc				clc 								; add adjust to position
.ae94	ad 1b 07	lda $071b			lda 	GXPosition
.ae97	6d 1c 07	adc $071c			adc 	GXAdjust
.ae9a	8d 1b 07	sta $071b			sta 	GXPosition
.ae9d	9c 1e 07	stz $071e			stz 	GXAddSelect 				; clear add select flag
.aea0	b0 05		bcs $aea7			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.aea2	cd 1d 07	cmp $071d			cmp 	GXTotal 					; if exceeded total
.aea5	90 0a		bcc $aeb1			bcc 	_GXLANoExtra
.aea7					_GXLAOverflow:
.aea7	ce 1e 07	dec $071e			dec 	GXAddSelect 				; set addselect to $FF
.aeaa	38		sec				sec 								; subtract total and write back
.aeab	ed 1d 07	sbc $071d			sbc 	GXTotal
.aeae	8d 1b 07	sta $071b			sta 	GXPosition
.aeb1					_GXLANoExtra:
.aeb1	ad 19 07	lda $0719			lda 	GXIsDiffYLarger
.aeb4	f0 0d		beq $aec3			beq 	_GXDXLarger
.aeb6	20 15 af	jsr $af15			jsr 	GXIncrementY
.aeb9	ad 1e 07	lda $071e			lda 	GXAddSelect
.aebc	f0 10		beq $aece			beq 	_GXLAExit
.aebe	20 cf ae	jsr $aecf			jsr 	GXAdjustX
.aec1	80 0b		bra $aece			bra 	_GXLAExit
.aec3					_GXDXLarger:
.aec3	20 cf ae	jsr $aecf			jsr 	GXAdjustX
.aec6	ad 1e 07	lda $071e			lda 	GXAddSelect
.aec9	f0 03		beq $aece			beq 	_GXLAExit
.aecb	20 15 af	jsr $af15			jsr 	GXIncrementY
.aece					_GXLAExit:
.aece	60		rts				rts
.aecf					GXAdjustX:
.aecf	ad 1a 07	lda $071a			lda 	GXDXNegative
.aed2	10 25		bpl $aef9			bpl 	_GXAXRight
.aed4	ad 7a 06	lda $067a			lda 	GXX0
.aed7	d0 03		bne $aedc			bne 	_GXAXNoBorrow
.aed9	ce 7b 06	dec $067b			dec 	GXX0+1
.aedc					_GXAXNoBorrow:
.aedc	ce 7a 06	dec $067a			dec 	GXX0
.aedf	ce 8c 06	dec $068c			dec 	gsOffset 					; pixel left
.aee2	ad 8c 06	lda $068c			lda 	gsOffset
.aee5	c9 ff		cmp #$ff			cmp 	#$FF
.aee7	d0 0f		bne $aef8			bne 	_GXAYExit 					; underflow
.aee9	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aeeb	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aeed	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aeef	b0 07		bcs $aef8			bcs 	_GXAYExit
.aef1	18		clc				clc
.aef2	69 20		adc #$20			adc 	#$20 						; fix up
.aef4	85 3d		sta $3d				sta 	gxzScreen+1
.aef6	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aef8					_GXAYExit:
.aef8	60		rts				rts
.aef9					_GXAXRight:
.aef9	ee 7a 06	inc $067a			inc 	GXX0
.aefc	d0 03		bne $af01			bne 	_GXAXNoCarry
.aefe	ee 7b 06	inc $067b			inc 	GXX0+1
.af01					_GXAXNoCarry:
.af01	ee 8c 06	inc $068c			inc 	gsOffset 					; pixel right
.af04	d0 0e		bne $af14			bne 	_GXAXExit 					; if not overflowed, exit.
.af06	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.af08	a5 3d		lda $3d				lda 	gxzScreen+1
.af0a	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.af0c	90 06		bcc $af14			bcc 	_GXAXExit
.af0e	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af10	85 3d		sta $3d				sta 	gxzScreen+1
.af12	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af14					_GXAXExit:
.af14	60		rts				rts
.af15					GXIncrementY:
.af15	ee 7c 06	inc $067c			inc 	GXY0
.af18	20 91 b3	jsr $b391			jsr 	GXMovePositionDown
.af1b	60		rts				rts
.af1c					GXLineSetup:
.af1c	ad 80 06	lda $0680			lda 	GXY1
.af1f	38		sec				sec
.af20	ed 7c 06	sbc $067c			sbc 	GXY0
.af23	4a		lsr a				lsr 	a
.af24	8d 18 07	sta $0718			sta 	GXDiffY
.af27	9c 1a 07	stz $071a			stz 	GXDXNegative 				; clear -ve flag
.af2a	38		sec				sec
.af2b	ad 7e 06	lda $067e			lda 	GXX1
.af2e	ed 7a 06	sbc $067a			sbc 	GXX0
.af31	8d 17 07	sta $0717			sta 	GXDiffX
.af34	ad 7f 06	lda $067f			lda 	GXX1+1 						; calculate MSB
.af37	ed 7b 06	sbc $067b			sbc 	GXX0+1
.af3a	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af3b	6e 17 07	ror $0717			ror 	GXDiffX
.af3e	0a		asl a				asl 	a
.af3f	10 0c		bpl $af4d			bpl 	_GDXNotNegative
.af41	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af43	38		sec				sec
.af44	ed 17 07	sbc $0717			sbc 	GXDiffX
.af47	8d 17 07	sta $0717			sta 	GXDiffX
.af4a	ce 1a 07	dec $071a			dec 	GXDXNegative 				; -ve flag = $FF.
.af4d					_GDXNotNegative:
.af4d	9c 19 07	stz $0719			stz 	GXIsDiffYLarger 			; clear larger flag
.af50	ad 18 07	lda $0718			lda 	GXDiffY 					; set adjust and total.
.af53	8d 1c 07	sta $071c			sta 	GXAdjust
.af56	ad 17 07	lda $0717			lda 	GXDiffX
.af59	8d 1d 07	sta $071d			sta 	GXTotal
.af5c	ad 18 07	lda $0718			lda 	GXDiffY 					; if dy > dx
.af5f	cd 17 07	cmp $0717			cmp 	GXDiffX
.af62	90 0f		bcc $af73			bcc 	_GDXNotLarger
.af64	ce 19 07	dec $0719			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af67	ad 17 07	lda $0717			lda 	GXDiffX 					; set adjust and total other way round
.af6a	8d 1c 07	sta $071c			sta 	GXAdjust
.af6d	ad 18 07	lda $0718			lda 	GXDiffY
.af70	8d 1d 07	sta $071d			sta 	GXTotal
.af73					_GDXNotLarger:
.af73	ad 1d 07	lda $071d			lda 	GXTotal
.af76	4a		lsr a				lsr 	a
.af77	8d 1b 07	sta $071b			sta 	GXPosition
.af7a	60		rts				rts
.0717					GXDiffX:
>0717							.fill 	1
.0718					GXDiffY:
>0718							.fill 	1
.0719					GXIsDiffYLarger:
>0719							.fill 	1
.071a					GXDXNegative:
>071a							.fill 	1
.071b					GXPosition:
>071b							.fill 	1
.071c					GXAdjust:
>071c							.fill 	1
.071d					GXTotal:
>071d							.fill 	1
.071e					GXAddSelect:
>071e							.fill 	1
.af7b					GXSetColourMode:
.af7b	a6 36		ldx $36				ldx 	gxzTemp0
.af7d	8e 88 06	stx $0688			stx 	gxColour 								; set colour
.af80	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af82	8d 87 06	sta $0687			sta 	gxMode 									; set mode
.af85	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af87	9c 8a 06	stz $068a			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af8a	ae 88 06	ldx $0688			ldx 	gxColour
.af8d	8e 89 06	stx $0689			stx 	gxEORValue
.af90	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af92	90 03		bcc $af97			bcc 	_GXSDCNotAndColour
.af94	8e 8a 06	stx $068a			stx 	gxANDValue
.af97					_GXSDCNotAndColour:
.af97	d0 03		bne $af9c			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af99	9c 89 06	stz $0689			stz 	gxEORValue
.af9c					_GXSDCNotAnd:
.af9c	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af9d	90 08		bcc $afa7			bcc 	_GXSDCNoFlip
.af9f	ad 8a 06	lda $068a			lda	 	gxANDValue
.afa2	49 ff		eor #$ff			eor 	#$FF
.afa4	8d 8a 06	sta $068a			sta 	gxANDValue
.afa7					_GXSDCNoFlip:
.afa7	18		clc				clc
.afa8	60		rts				rts
.afa9					GXPlotPoint:
.afa9	20 2b b3	jsr $b32b			jsr 	GXOpenBitmap 				; start drawing
.afac	20 3b b3	jsr $b33b			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afaf	ac 8c 06	ldy $068c			ldy 	gsOffset
.afb2	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afb4	2d 8a 06	and $068a			and 	gxANDValue
.afb7	4d 89 06	eor $0689			eor 	gxEORValue
.afba	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afbc	20 33 b3	jsr $b333			jsr 	GXCloseBitmap 				; stop drawing and exit
.afbf	18		clc				clc
.afc0	60		rts				rts
.afc1					GXFillRectangle:
.afc1	38		sec				sec
.afc2	80 01		bra $afc5			bra 	GXRectangle
.afc4					GXFrameRectangle:
.afc4	18		clc				clc
.afc5					GXRectangle:
.afc5	ad 83 06	lda $0683			lda 	gxBitmapsOn
.afc8	f0 35		beq $afff			beq 	_GXRFail
.afca	08		php				php 								; save Fill flag (CS)
.afcb	20 2b b3	jsr $b32b			jsr 	GXOpenBitmap 				; start drawing
.afce	20 53 b4	jsr $b453			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afd1	20 3b b3	jsr $b33b			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afd4	38		sec				sec 								; sec = Draw line
.afd5	20 01 b0	jsr $b001			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afd8	ad 7c 06	lda $067c			lda 	gxY0 						; reached end of rectangle ?
.afdb	cd 80 06	cmp $0680			cmp 	gxY1
.afde	f0 19		beq $aff9			beq 	_GXRectangleExit
.afe0					_GXRectLoop:
.afe0	20 91 b3	jsr $b391			jsr 	GXMovePositionDown 			; down one.
.afe3	ee 7c 06	inc $067c			inc 	gxY0 						; change Y pos
.afe6	ad 7c 06	lda $067c			lda 	gxY0 						; reached last line
.afe9	cd 80 06	cmp $0680			cmp 	gXY1
.afec	f0 07		beq $aff5			beq 	_GXLastLine
.afee	28		plp				plp 								; get flag back
.afef	08		php				php
.aff0	20 01 b0	jsr $b001			jsr 	GXDrawLineX1X0 				; draw horizontal line
.aff3	80 eb		bra $afe0			bra 	_GXRectLoop
.aff5					_GXLastLine:
.aff5	38		sec				sec
.aff6	20 01 b0	jsr $b001			jsr 	GXDrawLineX1X0
.aff9					_GXRectangleExit:
.aff9	68		pla				pla 								; throw fill flag.
.affa	20 33 b3	jsr $b333			jsr 	GXCloseBitmap 				; stop drawing and exit
.affd	18		clc				clc
.affe	60		rts				rts
.afff					_GXRFail:
.afff	38		sec				sec
.b000	60		rts				rts
.b001					GXDrawLineX1X0:
.b001	08		php				php 								; save solid/either-end
.b002	38		sec				sec
.b003	ad 7e 06	lda $067e			lda		gXX1
.b006	ed 7a 06	sbc $067a			sbc 	gXX0
.b009	85 36		sta $36				sta 	gxzTemp0
.b00b	ad 7f 06	lda $067f			lda 	gXX1+1
.b00e	ed 7b 06	sbc $067b			sbc 	gXX0+1
.b011	85 37		sta $37				sta 	gxzTemp0+1
.b013	28		plp				plp
.b014					GXDrawLineTemp0:
.b014	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b016	48		pha				pha
.b017	a5 3d		lda $3d				lda 	gxzScreen+1
.b019	48		pha				pha
.b01a	ad 8c 06	lda $068c			lda 	gsOffset
.b01d	48		pha				pha
.b01e	a5 0b		lda $0b				lda 	GXEditSlot
.b020	48		pha				pha
.b021	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y offset
.b024	90 1e		bcc $b044			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b026					_GXDLTLine:
.b026	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b028	2d 8a 06	and $068a			and 	gxANDValue
.b02b	4d 89 06	eor $0689			eor 	gxEORValue
.b02e	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b030	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b032	d0 04		bne $b038			bne 	_GXDLTNoBorrow
.b034	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b036	30 2e		bmi $b066			bmi 	_GXDLTExit
.b038					_GXDLTNoBorrow:
.b038	c6 36		dec $36				dec 	gxzTemp0
.b03a	c8		iny				iny 								; next slot.
.b03b	d0 e9		bne $b026			bne 	_GXDLTLine
.b03d	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b03f	20 74 b0	jsr $b074			jsr 	GXDLTCheckWrap				; check for new page.
.b042	80 e2		bra $b026			bra 	_GXDLTLine
.b044					_GXDLTEndPoints:
.b044	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b046	2d 8a 06	and $068a			and 	gxANDValue
.b049	4d 89 06	eor $0689			eor 	gxEORValue
.b04c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b04e	98		tya				tya 								; advance to right side
.b04f	18		clc				clc
.b050	65 36		adc $36				adc 	gxzTemp0
.b052	a8		tay				tay
.b053	a5 3d		lda $3d				lda 	gxzScreen+1
.b055	65 37		adc $37				adc 	gxzTemp0+1
.b057	85 3d		sta $3d				sta 	gxzScreen+1
.b059	20 74 b0	jsr $b074			jsr 	GXDLTCheckWrap 			; fix up.
.b05c	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b05e	2d 8a 06	and $068a			and 	gxANDValue
.b061	4d 89 06	eor $0689			eor 	gxEORValue
.b064	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b066					_GXDLTExit:
.b066	68		pla				pla
.b067	85 0b		sta $0b				sta 	GXEditSlot
.b069	68		pla				pla
.b06a	8d 8c 06	sta $068c			sta 	gsOffset
.b06d	68		pla				pla
.b06e	85 3d		sta $3d				sta 	gxzScreen+1
.b070	68		pla				pla
.b071	85 3c		sta $3c				sta 	gxzScreen
.b073	60		rts				rts
.b074					GXDLTCheckWrap:
.b074	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b076	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b078	90 06		bcc $b080			bcc 	_GXDLTCWExit
.b07a	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b07c	85 3d		sta $3d				sta 	gxzScreen+1
.b07e	e6 0b		inc $0b				inc 	GXEditSlot
.b080					_GXDLTCWExit:
.b080	60		rts				rts
.b081					GXDrawGraphicElement:
.b081	8d 1f 07	sta $071f			sta 	gxSize 						; save size
.b084	3a		dec a				dec 	a
.b085	8d 20 07	sta $0720			sta 	gxMask 						; and mask
.b088	ad 83 06	lda $0683			lda 	gxBitmapsOn 				; check BMP on
.b08b	f0 67		beq $b0f4			beq 	_GXSLFail
.b08d	ad 7c 06	lda $067c			lda 	gxY0 						; push Y on stack
.b090	48		pha				pha
.b091	8c 22 07	sty $0722			sty 	gxAcquireVector+1 			; and acquisition vector
.b094	8e 21 07	stx $0721			stx 	gxAcquireVector
.b097	20 2b b3	jsr $b32b			jsr 	gxOpenBitmap 				; open the bitmap.
.b09a	ad 24 07	lda $0724			lda 	gxUseMode 					; scale bits
.b09d	4a		lsr a				lsr 	a
.b09e	4a		lsr a				lsr 	a
.b09f	4a		lsr a				lsr 	a
.b0a0	29 07		and #$07			and		#7
.b0a2	1a		inc a				inc 	a
.b0a3	8d 23 07	sta $0723			sta 	gxScale
.b0a6	64 38		stz $38				stz 	gxzTemp1					; start first line
.b0a8					_GXGELoop:
.b0a8	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b0aa	2c 24 07	bit $0724			bit 	gxUseMode 					; check for flip.
.b0ad	10 06		bpl $b0b5			bpl		_GXNoVFlip
.b0af	ad 20 07	lda $0720			lda 	gxMask
.b0b2	38		sec				sec
.b0b3	e5 38		sbc $38				sbc 	gxzTemp1
.b0b5					_GXNoVFlip:
.b0b5	aa		tax				tax 								; get the Xth line.
.b0b6	20 f6 b0	jsr $b0f6			jsr 	_GXCallAcquire 				; get that data.
.b0b9	ad 23 07	lda $0723			lda 	gxScale 					; do scale identical copies of that line.
.b0bc	85 39		sta $39				sta 	gxzTemp1+1
.b0be					_GXGELoop2:
.b0be	ad 7c 06	lda $067c			lda 	gxY0 						; off screen
.b0c1	cd 86 06	cmp $0686			cmp 	gxHeight
.b0c4	b0 10		bcs $b0d6			bcs 	_GXDGEExit
.b0c6	20 f9 b0	jsr $b0f9			jsr 	GXRenderOneLine 			; render line
.b0c9	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0cb	d0 f1		bne $b0be			bne 	_GXGELoop2
.b0cd	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0cf	a5 38		lda $38				lda 	gxzTemp1
.b0d1	cd 1f 07	cmp $071f			cmp 	gxSize
.b0d4	d0 d2		bne $b0a8			bne 	_GXGELoop
.b0d6					_GXDGEExit:
.b0d6	68		pla				pla 								; restore Y for next time
.b0d7	8d 7c 06	sta $067c			sta 	gxY0
.b0da	ae 23 07	ldx $0723			ldx 	gxScale 					; get scale (1-8)
.b0dd					_GXShiftLeft:
.b0dd	18		clc				clc
.b0de	ad 1f 07	lda $071f			lda 	gxSize
.b0e1	6d 7a 06	adc $067a			adc 	gxX0
.b0e4	8d 7a 06	sta $067a			sta 	gxX0
.b0e7	90 03		bcc $b0ec			bcc 	_GXSLNoCarry
.b0e9	ee 7b 06	inc $067b			inc 	gxX0+1
.b0ec					_GXSLNoCarry:
.b0ec	ca		dex				dex
.b0ed	d0 ee		bne $b0dd			bne 	_GXShiftLeft
.b0ef	20 33 b3	jsr $b333			jsr 	GXCloseBitmap
.b0f2	18		clc				clc
.b0f3	60		rts				rts
.b0f4					_GXSLFail:
.b0f4	38		sec				sec
.b0f5	60		rts				rts
.b0f6					_GXCallAcquire:
.b0f6	6c 21 07	jmp ($0721)			jmp 	(gxAcquireVector)
.b0f9					GXRenderOneLine:
.b0f9	20 3b b3	jsr $b33b			jsr 	GXPositionCalc 				; calculate position/offset.
.b0fc	ac 8c 06	ldy $068c			ldy 	gsOffset 					; Y contains position.
.b0ff	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b101					_GXROLLoop1:
.b101	ad 23 07	lda $0723			lda 	gxScale 					; set to do 'scale' times
.b104	85 3b		sta $3b				sta 	gxzTemp2+1
.b106					_GXROLLoop2:
.b106	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b108	2c 87 06	bit $0687			bit 	gxMode 						; check H Flip
.b10b	50 06		bvc $b113			bvc 	_GXNoHFlip
.b10d	ad 20 07	lda $0720			lda 	gxMask
.b110	38		sec				sec
.b111	e5 3a		sbc $3a				sbc 	gxzTemp2
.b113					_GXNoHFlip:
.b113	aa		tax				tax 								; read from the pixel buffer
.b114	bd 27 06	lda $0627,x			lda 	gxPixelBuffer,x
.b117	d0 07		bne $b120			bne 	_GXDraw 					; draw if non zero
.b119	ad 24 07	lda $0724			lda 	gxUseMode 					; check to see if solid background
.b11c	29 04		and #$04			and 	#4
.b11e	f0 0a		beq $b12a			beq 	_GXZeroPixel
.b120					_GXDraw:
.b120	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b122	2d 8a 06	and $068a			and 	gxANDValue
.b125	5d 27 06	eor $0627,x			eor 	gxPixelBuffer,x
.b128	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b12a					_GXZeroPixel:
.b12a	c8		iny				iny 								; advance pointer
.b12b	d0 05		bne $b132			bne 	_GXNoShift
.b12d	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b12f	20 74 b0	jsr $b074			jsr 	GXDLTCheckWrap				; check for new page.
.b132					_GXNoShift:
.b132	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b134	d0 d0		bne $b106			bne 	_GXROLLoop2
.b136	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b138	a5 3a		lda $3a				lda 	gxzTemp2
.b13a	cd 1f 07	cmp $071f			cmp 	gxSize
.b13d	d0 c2		bne $b101			bne 	_GXROLLoop1
.b13f	ee 7c 06	inc $067c			inc 	gxY0
.b142	60		rts				rts
.071f					gxSize:
>071f							.fill 	1
.0720					gxMask:
>0720							.fill 	1
.0721					gxAcquireVector:
>0721							.fill 	2
.0723					gxScale:
>0723							.fill 	1
.0724					gxUseMode:
>0724							.fill 	1
.b143					GXFontHandler:
.b143	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b145	4d 87 06	eor $0687			eor 	gxMode
.b148	8d 24 07	sta $0724			sta 	gxUseMode
.b14b	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b14d	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b14f	26 37		rol $37				rol	 	gxzTemp0+1
.b151	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b153	26 37		rol $37				rol	 	gxzTemp0+1
.b155	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b157	26 37		rol $37				rol	 	gxzTemp0+1
.b159	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b15b	09 c0		ora #$c0			ora 	#$C0
.b15d	85 37		sta $37				sta 	gxzTemp0+1
.b15f	a9 08		lda #$08			lda 	#8 							; size 8x8
.b161	a2 69		ldx #$69			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b163	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b165	20 81 b0	jsr $b081			jsr 	GXDrawGraphicElement
.b168	60		rts				rts
.b169					GXGetGraphicDataFont:
.b169	8a		txa				txa 								; X->Y
.b16a	a8		tay				tay
.b16b	a6 01		ldx $01				ldx 	1 							; preserve old value
.b16d	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b16f	85 01		sta $01				sta 	1
.b171	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b173	86 01		stx $01				stx 	1 							; put old value back.
.b175	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b177					_GXExpand:
.b177	9e 27 06	stz $0627,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b17a	0a		asl a				asl 	a 							; shift bit 7 into C
.b17b	90 08		bcc $b185			bcc 	_GXNoPixel
.b17d	48		pha				pha 								; if set, set pixel buffer to current colour.
.b17e	ad 88 06	lda $0688			lda 	gxColour
.b181	9d 27 06	sta $0627,x			sta 	gxPixelBuffer,x
.b184	68		pla				pla
.b185					_GXNoPixel:
.b185	e8		inx				inx 								; do the whole byte.
.b186	e0 08		cpx #$08			cpx 	#8
.b188	d0 ed		bne $b177			bne 	_GXExpand
.b18a	60		rts				rts
.b18b					GXSpriteHandler:
.b18b	ad 82 06	lda $0682			lda 	gxSpritesOn 				; sprites on ?
.b18e	f0 23		beq $b1b3			beq 	_GXSHExit
.b190	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b192	4d 87 06	eor $0687			eor 	gxMode
.b195	8d 24 07	sta $0724			sta 	gxUseMode
.b198	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b19a	da		phx				phx
.b19b	20 2b b3	jsr $b32b			jsr 	GXOpenBitmap 				; can access sprite information
.b19e	68		pla				pla
.b19f	20 0c b4	jsr $b40c			jsr 	GXFindSprite 				; get the sprite address
.b1a2	08		php				php
.b1a3	20 33 b3	jsr $b333			jsr 	GXCloseBitmap
.b1a6	28		plp				plp
.b1a7	b0 0a		bcs $b1b3			bcs		_GXSHExit 					; exit if find failed.
.b1a9	ad 25 07	lda $0725			lda 	GXSizePixels 				; return size
.b1ac	a2 b4		ldx #$b4			ldx 	#GXSpriteAcquire & $FF
.b1ae	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b1b0	20 81 b0	jsr $b081			jsr 	GXDrawGraphicElement
.b1b3					_GXSHExit:
.b1b3	60		rts				rts
.b1b4					GXSpriteAcquire:
.b1b4	ad 85 06	lda $0685			lda 	GXSpritePage				; point to base page
.b1b7	85 0b		sta $0b				sta 	GXEditSlot
.b1b9	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1bb	a9 00		lda #$00			lda 	#0
.b1bd	ae 26 07	ldx $0726			ldx 	GXSizeBits
.b1c0					_GXTimesRowNumber:
.b1c0	18		clc				clc
.b1c1	65 36		adc $36				adc 	zTemp0
.b1c3	ca		dex				dex
.b1c4	10 fa		bpl $b1c0			bpl 	_GXTimesRowNumber
.b1c6	64 37		stz $37				stz 	gxzTemp0+1
.b1c8	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1c9	26 37		rol $37				rol 	gxzTemp0+1
.b1cb	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1cc	26 37		rol $37				rol 	gxzTemp0+1
.b1ce	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1cf	26 37		rol $37				rol 	gxzTemp0+1
.b1d1	85 36		sta $36				sta 	gxzTemp0
.b1d3	18		clc				clc 								; add base address.
.b1d4	a5 36		lda $36				lda 	gxzTemp0
.b1d6	6d 28 07	adc $0728			adc 	GXSpriteOffset
.b1d9	85 36		sta $36				sta 	gxzTemp0
.b1db	a5 37		lda $37				lda 	gxzTemp0+1
.b1dd	6d 29 07	adc $0729			adc 	GXSpriteOffset+1
.b1e0					_GXSAFindPage:
.b1e0	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1e2	90 06		bcc $b1ea			bcc 	_GXSAFoundPage
.b1e4	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1e6	e6 0b		inc $0b				inc 	GXEditSlot
.b1e8	80 f6		bra $b1e0			bra 	_GXSAFindPage
.b1ea					_GXSAFoundPage:
.b1ea	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1ec	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1ee	a0 00		ldy #$00			ldy 	#0
.b1f0					_GXSACopyLoop:
.b1f0	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1f2	99 27 06	sta $0627,y			sta 	gxPixelBuffer,y
.b1f5	c8		iny				iny
.b1f6	cc 25 07	cpy $0725			cpy 	GXSizePixels
.b1f9	d0 f5		bne $b1f0			bne 	_GXSACopyLoop
.b1fb	60		rts				rts
.b1fc					GXSelect:
.b1fc	ad 82 06	lda $0682			lda 	gxSpritesOn
.b1ff	f0 22		beq $b223			beq 	_GXSFail
.b201	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b203	c9 40		cmp #$40			cmp 	#64
.b205	b0 1c		bcs $b223			bcs 	_GXSFail
.b207	8d 8d 06	sta $068d			sta 	GSCurrentSpriteID
.b20a	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b20c	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b20e	06 36		asl $36				asl 	gxzTemp0
.b210	06 36		asl $36				asl 	gxzTemp0
.b212	06 36		asl $36				asl 	gxzTemp0
.b214	2a		rol a				rol 	a
.b215	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b217	8d 8f 06	sta $068f			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b21a	85 37		sta $37				sta 	gxzTemp0+1
.b21c	a5 36		lda $36				lda 	gxzTemp0
.b21e	8d 8e 06	sta $068e			sta 	GSCurrentSpriteAddr
.b221	18		clc				clc
.b222	60		rts				rts
.b223					_GXSFail:
.b223	38		sec				sec
.b224	60		rts				rts
.b225					GXSelectImage:
.b225	ad 82 06	lda $0682			lda 	gxSpritesOn
.b228	f0 74		beq $b29e			beq 	_GXSIFail
.b22a	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b22d	f0 6f		beq $b29e			beq 	_GXSIFail 					; (checking the MSB)
.b22f	64 01		stz $01				stz 	1
.b231	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b233	d0 6b		bne $b2a0			bne 	_GXSIHide
.b235	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b237	48		pha				pha
.b238	20 2b b3	jsr $b32b			jsr 	GXOpenBitmap
.b23b	68		pla				pla
.b23c	20 0c b4	jsr $b40c			jsr 	GXFindSprite
.b23f	b0 5a		bcs $b29b			bcs 	_GXSICloseFail 				; no image
.b241	a0 01		ldy #$01			ldy 	#1
.b243	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.b246	85 36		sta $36				sta 	gxzTemp0
.b248	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.b24b	85 37		sta $37				sta 	gxzTemp0+1
.b24d	ad 28 07	lda $0728			lda 	GXSpriteOffset
.b250	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b252	18		clc				clc
.b253	ad 29 07	lda $0729			lda 	GXSpriteOffset+1
.b256	6d 90 06	adc $0690			adc 	GXSpriteOffsetBase
.b259	c8		iny				iny
.b25a	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b25c	ad 91 06	lda $0691			lda 	GXSpriteOffsetBase+1
.b25f	69 00		adc #$00			adc 	#0
.b261	c8		iny				iny
.b262	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b264	ad 26 07	lda $0726			lda 	GXSizeBits 					; get raw size
.b267	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b269	2a		rol a				rol 	a 							; x 2
.b26a	0a		asl a				asl 	a 							; x 4
.b26b	0a		asl a				asl 	a 							; x 8
.b26c	0a		asl a				asl 	a 							; x 16
.b26d	0d 27 07	ora $0727			ora 	GXSpriteLUT 				; Or with LUT
.b270	0a		asl a				asl 	a 							; 1 shift
.b271	09 01		ora #$01			ora 	#1 							; enable sprite.
.b273	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b275	20 33 b3	jsr $b333			jsr 	GXCloseBitmap
.b278	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b27b	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b27e	29 3f		and #$3f			and 	#$3F
.b280	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b283	ad 26 07	lda $0726			lda 	GXSizeBits 					; get bit size
.b286	6a		ror a				ror 	a 							; shift into bits 6/7
.b287	6a		ror a				ror 	a
.b288	6a		ror a				ror 	a
.b289	29 c0		and #$c0			and 	#$C0
.b28b	1d d2 06	ora $06d2,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b28e	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b291	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b294	29 7f		and #$7f			and 	#$7F
.b296	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b299	18		clc				clc
.b29a	60		rts				rts
.b29b					_GXSICloseFail:
.b29b	20 33 b3	jsr $b333			jsr 	GXCloseBitmap
.b29e					_GXSIFail:
.b29e	38		sec				sec
.b29f	60		rts				rts
.b2a0					_GXSIHide:
.b2a0	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b2a3	85 36		sta $36				sta 	gxzTemp0
.b2a5	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1
.b2a8	85 37		sta $37				sta 	gxzTemp0+1
.b2aa	a9 00		lda #$00			lda 	#0
.b2ac	92 36		sta ($36)			sta 	(gxzTemp0)
.b2ae	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get sprite ID
.b2b1	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2b4	09 80		ora #$80			ora 	#$80
.b2b6	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b2b9	18		clc				clc
.b2ba	60		rts				rts
.b2bb					GXMoveSprite:
.b2bb	ad 82 06	lda $0682			lda 	gxSpritesOn
.b2be	f0 65		beq $b325			beq 	_GXSIFail
.b2c0	ad 8f 06	lda $068f			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2c3	f0 60		beq $b325			beq 	_GXSIFail
.b2c5	85 37		sta $37				sta 	gxzTemp0+1
.b2c7	a0 04		ldy #$04			ldy 	#4
.b2c9	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr
.b2cc	85 36		sta $36				sta 	gxzTemp0
.b2ce	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2d1	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b2d4	2a		rol a				rol 	a	 						; into bits 0,1.
.b2d5	2a		rol a				rol 	a
.b2d6	2a		rol a				rol 	a
.b2d7	29 03		and #$03			and 	#3
.b2d9	aa		tax				tax
.b2da	bd 27 b3	lda $b327,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2dd	48		pha				pha
.b2de	18		clc				clc
.b2df	6d 7a 06	adc $067a			adc 	gxX0						; copy position.
.b2e2	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e4	c8		iny				iny
.b2e5	ad 7b 06	lda $067b			lda 	gxX0+1
.b2e8	69 00		adc #$00			adc 	#0
.b2ea	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2ec	c8		iny				iny
.b2ed	68		pla				pla
.b2ee	18		clc				clc
.b2ef	6d 7c 06	adc $067c			adc 	gxY0
.b2f2	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f4	a9 00		lda #$00			lda 	#0
.b2f6	69 00		adc #$00			adc 	#0
.b2f8	c8		iny				iny
.b2f9	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2fb	4e 7b 06	lsr $067b			lsr 	gxX0+1 						; divide X by 4
.b2fe	6e 7a 06	ror $067a			ror 	gxX0
.b301	4e 7a 06	lsr $067a			lsr 	gxX0
.b304	4e 7c 06	lsr $067c			lsr 	gxY0 						; divide Y by 4
.b307	4e 7c 06	lsr $067c			lsr 	gxY0
.b30a	ae 8d 06	ldx $068d			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b30d	bd 92 06	lda $0692,x			lda 	GXSpriteLow,x
.b310	29 80		and #$80			and 	#$80
.b312	0d 7a 06	ora $067a			ora 	gxX0
.b315	9d 92 06	sta $0692,x			sta 	GXSpriteLow,x
.b318	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b31b	29 c0		and #$c0			and 	#$C0
.b31d	0d 7c 06	ora $067c			ora 	gxY0
.b320	9d d2 06	sta $06d2,x			sta 	GXSpriteHigh,x
.b323	18		clc				clc
.b324	60		rts				rts
.b325					_GXSIFail:
.b325	38		sec				sec
.b326	60		rts				rts
.b327					_GXMSOffset:
>b327	1c						.byte 	32-8/2
>b328	18						.byte 	32-16/2
>b329	14						.byte 	32-24/2
>b32a	10						.byte 	32-32/2
.b32b					GXOpenBitmap:
.b32b	78		sei				sei 								; no interrupts here
.b32c	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b32e	8d 8b 06	sta $068b			sta 	gxOriginalLUTValue
.b331	58		cli				cli
.b332	60		rts				rts
.b333					GXCloseBitmap:
.b333	78		sei				sei
.b334	ad 8b 06	lda $068b			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b337	85 0b		sta $0b				sta 	GXEditSlot
.b339	58		cli				cli
.b33a	60		rts				rts
.b33b					GXPositionCalc:
.b33b	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b33d	48		pha				pha
.b33e	ad 7c 06	lda $067c			lda 	GXY0 						; gxzScreen = Y0
.b341	85 3c		sta $3c				sta 	gxzScreen
.b343	64 3d		stz $3d				stz 	gxzScreen+1
.b345	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b347	26 3d		rol $3d				rol 	gxzScreen+1
.b349	06 3c		asl $3c				asl 	gxzScreen
.b34b	26 3d		rol $3d				rol 	gxzScreen+1
.b34d	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b34e	65 3c		adc $3c				adc 	gxzScreen
.b350	85 3c		sta $3c				sta 	gxzScreen
.b352	90 02		bcc $b356			bcc 	_GXPCNoCarry
.b354	e6 3d		inc $3d				inc 	gxzScreen+1
.b356					_GXPCNoCarry:
.b356	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b358	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b35a	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b35c	85 36		sta $36				sta 	gxzTemp0
.b35e	64 3d		stz $3d				stz 	gxzScreen+1
.b360	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b362					_GXPCMultiply32:
.b362	06 3c		asl $3c				asl 	gxzScreen
.b364	26 3d		rol $3d				rol 	gxzScreen+1
.b366	3a		dec a				dec 	a
.b367	d0 f9		bne $b362			bne 	_GXPCMultiply32
.b369	18		clc				clc
.b36a	ad 7a 06	lda $067a			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b36d	65 3c		adc $3c				adc 	gxzScreen
.b36f	8d 8c 06	sta $068c			sta 	gsOffset
.b372	ad 7b 06	lda $067b			lda 	GXX0+1
.b375	65 3d		adc $3d				adc 	gxzScreen+1
.b377	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b379	90 04		bcc $b37f			bcc 	_GXPCNoOverflow
.b37b	29 1f		and #$1f			and 	#$1F 						; fix it up
.b37d	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b37f					_GXPCNoOverflow:
.b37f	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b381	85 3d		sta $3d				sta 	gxzScreen+1
.b383	64 3c		stz $3c				stz 	gxzScreen
.b385	18		clc				clc
.b386	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b388	6d 84 06	adc $0684			adc 	gxBasePage 					; by adding the base page
.b38b	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b38d	68		pla				pla
.b38e	85 36		sta $36				sta 	gxzTemp0
.b390	60		rts				rts
.b391					GXMovePositionDown:
.b391	18		clc				clc 								; add 320 to offset/temp+1
.b392	ad 8c 06	lda $068c			lda 	gsOffset
.b395	69 40		adc #$40			adc 	#64
.b397	8d 8c 06	sta $068c			sta 	gsOffset
.b39a	a5 3d		lda $3d				lda 	gxzScreen+1
.b39c	69 01		adc #$01			adc 	#1
.b39e	85 3d		sta $3d				sta 	gxzScreen+1
.b3a0	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b3a2	90 07		bcc $b3ab			bcc 	_GXMPDExit
.b3a4	38		sec				sec  								; next page
.b3a5	e9 20		sbc #$20			sbc 	#$20
.b3a7	85 3d		sta $3d				sta 	gxzScreen+1
.b3a9	e6 0b		inc $0b				inc 	GXEditSlot
.b3ab					_GXMPDExit:
.b3ab	60		rts				rts
.b3ac					GXCollide:
.b3ac	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b3ae	aa		tax				tax
.b3af	05 37		ora $37				ora 	gxzTemp0+1
.b3b1	29 c0		and #$c0			and 	#$C0
.b3b3	38		sec				sec
.b3b4	d0 53		bne $b409			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3b6	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3b8	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3bb	1d 92 06	ora $0692,x			ora 	GXSpriteLow,x
.b3be	30 48		bmi $b408			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3c0	18		clc				clc 								; need to calculate sum of sizes.
.b3c1	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y
.b3c4	7d d2 06	adc $06d2,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3c7	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3c9	6a		ror a				ror 	a 							; 5/6/7
.b3ca	4a		lsr a				lsr 	a 							; 4/5/6
.b3cb	4a		lsr a				lsr 	a 							; 3/4/5
.b3cc	4a		lsr a				lsr 	a 							; 2/3/4
.b3cd	18		clc				clc
.b3ce	69 08		adc #$08			adc 	#$08
.b3d0	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3d1	4a		lsr a				lsr 	a
.b3d2	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3d4	b9 d2 06	lda $06d2,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3d7	29 3f		and #$3f			and 	#$3F
.b3d9	85 39		sta $39				sta 	gxzTemp1+1
.b3db	38		sec				sec
.b3dc	bd d2 06	lda $06d2,x			lda 	GXSpriteHigh,x
.b3df	29 3f		and #$3f			and 	#$3F
.b3e1	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3e3	b0 03		bcs $b3e8			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3e5	49 ff		eor #$ff			eor 	#$FF
.b3e7	1a		inc a				inc 	a
.b3e8					_GXCAbs1:
.b3e8	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3ea	b0 1c		bcs $b408			bcs 	_GXOkayFail
.b3ec	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3ee	38		sec				sec 								; calculate |x1-x0|
.b3ef	b9 92 06	lda $0692,y			lda 	GXSpriteLow,y
.b3f2	fd 92 06	sbc $0692,x			sbc 	GXSpriteLow,x
.b3f5	b0 03		bcs $b3fa			bcs 	_GXCAbs2
.b3f7	49 ff		eor #$ff			eor 	#$FF
.b3f9	1a		inc a				inc 	a
.b3fa					_GXCAbs2:
.b3fa	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3fc	b0 0a		bcs $b408			bcs 	_GXOkayFail
.b3fe	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b400	90 02		bcc $b404			bcc 	_GXCHaveLowest
.b402	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b404					_GXCHaveLowest:
.b404	0a		asl a				asl 	a 							; scale to allow for >> 2
.b405	0a		asl a				asl 	a
.b406	18		clc				clc
.b407	60		rts				rts
.b408					_GXOkayFail:
.b408	18		clc				clc
.b409					_GXCollideFail:
.b409	a9 ff		lda #$ff			lda 	#$FF
.b40b	60		rts				rts
.b40c					GXFindSprite:
.b40c	aa		tax				tax
.b40d	ad 85 06	lda $0685			lda 	GXSpritePage 				; access the base page of the sprite
.b410	85 0b		sta $0b				sta 	GXEditSlot
.b412	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b415	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b418	f0 33		beq $b44d			beq 	_GXFSFail
.b41a	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b41d	8d 29 07	sta $0729			sta 	GXSpriteOffset+1
.b420	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b423	48		pha				pha 								; save twice
.b424	48		pha				pha
.b425	29 03		and #$03			and 	#3 							; get sprite size
.b427	8d 26 07	sta $0726			sta 	GXSizeBits 					; save raw (0-3)
.b42a	aa		tax				tax
.b42b	bd 4f b4	lda $b44f,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b42e	8d 25 07	sta $0725			sta 	GXSizePixels 					; save (8/16/24/32)
.b431	68		pla				pla 								; get LUT
.b432	4a		lsr a				lsr		a
.b433	4a		lsr a				lsr		a
.b434	29 03		and #$03			and 	#3
.b436	8d 27 07	sta $0727			sta 	GXSpriteLUT
.b439	68		pla				pla 								; address, neeeds to be x 4
.b43a	29 f0		and #$f0			and 	#$F0
.b43c	8d 28 07	sta $0728			sta 	GXSpriteOffset
.b43f	0e 28 07	asl $0728			asl 	GXSpriteOffset
.b442	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.b445	0e 28 07	asl $0728			asl 	GXSpriteOffset
.b448	2e 29 07	rol $0729			rol 	GXSpriteOffset+1
.b44b	18		clc				clc
.b44c	60		rts				rts
.b44d					_GXFSFail:
.b44d	38		sec				sec
.b44e	60		rts				rts
.b44f					_GXFXSSTTable:
>b44f	08 10 18 20					.byte 	8,16,24,32
.0725					GXSizePixels:
>0725							.fill 	1
.0726					GXSizeBits:
>0726							.fill 	1
.0727					GXSpriteLUT:
>0727							.fill 	1
.0728					GXSpriteOffset:
>0728							.fill 	2
.b453					GXSortXY:
.b453	20 71 b4	jsr $b471			jsr 	GXSortY 					; will be sorted on Y now
.b456	ad 7a 06	lda $067a			lda 	gxX0 						; compare X0 v X1
.b459	cd 7e 06	cmp $067e			cmp 	gxX1
.b45c	ad 7b 06	lda $067b			lda 	gXX0+1
.b45f	ed 7f 06	sbc $067f			sbc 	gXX1+1
.b462	90 0c		bcc $b470			bcc 	_GXSXYExit 					; X0 < X1 exit
.b464	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b466	a0 04		ldy #$04			ldy 	#4
.b468	20 85 b4	jsr $b485			jsr 	GXSwapXY
.b46b	e8		inx				inx
.b46c	c8		iny				iny
.b46d	20 85 b4	jsr $b485			jsr 	GXSwapXY
.b470					_GXSXYExit:
.b470	60		rts				rts
.b471					GXSortY:
.b471	ad 7c 06	lda $067c			lda 	gxY0 						; if Y0 >= Y1
.b474	cd 80 06	cmp $0680			cmp 	gxY1
.b477	90 0b		bcc $b484			bcc 	_GXSYSorted
.b479	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b47b	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b47d					_GXSwap1:
.b47d	20 85 b4	jsr $b485			jsr 	GXSwapXY
.b480	88		dey				dey
.b481	ca		dex				dex
.b482	10 f9		bpl $b47d			bpl 	_GXSwap1
.b484					_GXSYSorted:
.b484	60		rts				rts
.b485					GXSwapXY:
.b485	bd 7a 06	lda $067a,x			lda 	gxX0,x
.b488	48		pha				pha
.b489	b9 7a 06	lda $067a,y			lda 	gxX0,y
.b48c	9d 7a 06	sta $067a,x			sta 	gxX0,x
.b48f	68		pla				pla
.b490	99 7a 06	sta $067a,y			sta 	gxX0,y
.b493	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b494					KeywordSet0:
>b494	00 65					.text	0,$65,""               ; $80 !0:EOF
>b496	00 58					.text	0,$58,""               ; $81 !1:SH1
>b498	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b49a	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b4a0	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b4a8	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b4ae	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b4b5	05 41 44 45 45 4b 28			.text	5,$41,"DEEK("          ; $87 DEEK(
>b4bc	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $88 EVENT(
>b4c4	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $89 FALSE
>b4cb	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $8a FRAC(
>b4d2	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8b HIT(
>b4d8	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8c INT(
>b4de	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8d ISVAL(
>b4e6	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8e JOYB(
>b4ed	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8f JOYX(
>b4f4	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $90 JOYY(
>b4fb	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $91 LEFT$(
>b503	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $92 LEN(
>b509	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $93 MAX(
>b50f	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $94 MID$(
>b516	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $95 MIN(
>b51c	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $96 NOT(
>b522	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $97 PEEK(
>b529	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $98 PLAYING(
>b531	47 28
>b533	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $99 RANDOM(
>b53b	28
>b53c	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $9a RIGHT$(
>b544	28
>b545	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $9b RND(
>b54b	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9c SGN(
>b551	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9d SPC(
>b557	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9e STR$(
>b55e	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9f TIMER(
>b566	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $a0 TRUE
>b56c	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $a1 VAL(
>b572	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a2 FOR
>b577	02 8f 49 46				.text	2,$8f,"IF"             ; $a3 IF
>b57b	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a4 PROC
>b581	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a5 REPEAT
>b589	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a6 WHILE
>b590	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a7 ENDIF
>b597	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a8 ENDPROC
>b59f	43
>b5a0	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a9 NEXT
>b5a6	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $aa THEN
>b5ac	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $ab UNTIL
>b5b3	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ac WEND
>b5b9	02 9b 42 59				.text	2,$9b,"BY"             ; $ad BY
>b5bd	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ae CALL
>b5c3	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $af CIRCLE
>b5cb	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $b0 CLEAR
>b5d2	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $b1 CLS
>b5d7	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b2 COLOR
>b5de	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b3 COLOUR
>b5e6	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b4 DATA
>b5ec	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b5 DIM
>b5f1	04 23 44 4f 4b 45			.text	4,$23,"DOKE"           ; $b6 DOKE
>b5f7	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b7 DOWNTO
>b5ff	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b8 ELSE
>b605	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b9 FROM
>b60b	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $ba GFX
>b610	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $bb GOSUB
>b617	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $bc GOTO
>b61d	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $bd HERE
>b623	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $be IMAGE
>b62a	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bf INPUT
>b631	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c0 LET
>b636	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c1 LINE
>b63c	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c2 LOCAL
>b643	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c3 OFF
>b648	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c4 ON
>b64c	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c5 OUTLINE
>b654	45
>b655	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c6 PALETTE
>b65d	45
>b65e	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c7 PLOT
>b664	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $c8 POKE
>b66a	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c9 PRINT
>b671	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $ca READ
>b677	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $cb RECT
>b67d	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $cc REM
>b682	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $cd RETURN
>b68a	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ce SOLID
>b691	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cf SOUND
>b698	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d0 SPRITE
>b6a0	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $d1 TEXT
>b6a6	02 a3 54 4f				.text	2,$a3,"TO"             ; $d2 TO
>b6aa	ff					.text	$FF
.b6ab					KeywordSet1:
>b6ab	00 65					.text	0,$65,""               ; $80 !0:EOF
>b6ad	00 58					.text	0,$58,""               ; $81 !1:SH1
>b6af	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b6b1	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b6b9	4c 45
>b6bb	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b6c3	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b6cb	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b6d0	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $87 EXPLODE
>b6d8	45
>b6d9	02 96 47 4f				.text	2,$96,"GO"             ; $88 GO
>b6dd	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $89 LIST
>b6e3	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $8a LOAD
>b6e9	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8b NEW
>b6ee	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $8c PING
>b6f4	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8d RESTORE
>b6fc	45
>b6fd	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8e RUN
>b702	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $8f SHOOT
>b709	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $90 SPRITES
>b711	53
>b712	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $91 STOP
>b718	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $92 ZAP
>b71d	ff					.text	$FF
.b71e					KeywordSet2:
>b71e	00 65					.text	0,$65,""               ; $80 !0:EOF
>b720	00 58					.text	0,$58,""               ; $81 !1:SH1
>b722	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b724	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b729	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b72e	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b733	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b738	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b73d	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b742	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b747	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b74c	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b751	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b756	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b75b	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b760	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b765	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b76a	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b76f	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b774	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b779	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b77e	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b783	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b788	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b78d	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b792	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b797	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b79c	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b7a1	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b7a6	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b7ab	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b7b0	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b7b5	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b7ba	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b7bf	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b7c4	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b7c9	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b7ce	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b7d3	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b7d8	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b7dd	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b7e2	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b7e7	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b7ec	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b7f1	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b7f6	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b7fb	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b800	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b805	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b80a	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b80f	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b814	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b819	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b81e	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b823	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b828	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b82d	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b832	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b837	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b83c	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b841	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b846	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b84b	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b850	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b855	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b85a	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b85f	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b864	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b869	ff					.text	$FF
.b86a					Export_TKListConvertLine:
.b86a	48		pha				pha 								; save indent on the stack
.b86b	9c 1d 04	stz $041d			stz 	tbOffset
.b86e	9c 2d 04	stz $042d			stz 	tokenBuffer
.b871	9c 29 04	stz $0429			stz 	currentListColour
.b874	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b876	20 f3 b9	jsr $b9f3			jsr 	LCLWriteColour
.b879	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b87b	b1 30		lda ($30),y			lda 	(codePtr),y
.b87d	aa		tax				tax
.b87e	88		dey				dey
.b87f	b1 30		lda ($30),y			lda 	(codePtr),y
.b881	20 64 ba	jsr $ba64			jsr 	LCLWriteNumberXA
.b884	68		pla				pla 								; adjustment to indent
.b885	48		pha				pha 								; save on stack
.b886	10 0c		bpl $b894			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b888	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b889	6d 26 04	adc $0426			adc 	listIndent
.b88c	8d 26 04	sta $0426			sta 	listIndent
.b88f	10 03		bpl $b894			bpl 	_LCNoAdjust
.b891	9c 26 04	stz $0426			stz 	listIndent
.b894					_LCNoAdjust:
.b894	18		clc				clc		 							; work out actual indent.
.b895	ad 26 04	lda $0426			lda 	listIndent
.b898	0a		asl a				asl 	a
.b899	69 07		adc #$07			adc 	#7
.b89b	85 36		sta $36				sta 	zTemp0
.b89d					_LCPadOut:
.b89d	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b89f	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.b8a2	ad 1d 04	lda $041d			lda 	tbOffset
.b8a5	c5 36		cmp $36				cmp 	zTemp0
.b8a7	d0 f4		bne $b89d			bne 	_LCPadOut
.b8a9	a0 03		ldy #$03			ldy 	#3 							; start position.
.b8ab					_LCMainLoop:
.b8ab	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b8ad	20 f3 b9	jsr $b9f3			jsr 	LCLWriteColour
.b8b0	b1 30		lda ($30),y			lda 	(codePtr),y
.b8b2	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b8b4	f0 17		beq $b8cd			beq 	_LCExit
.b8b6	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b8b8	90 1e		bcc $b8d8			bcc 	_LCDoubles
.b8ba	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b8bc	90 2a		bcc $b8e8			bcc 	_LCShiftPunc
.b8be	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b8c0	90 35		bcc $b8f7			bcc 	_LCPunctuation
.b8c2	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b8c4	90 51		bcc $b917			bcc 	_LCIdentifiers
.b8c6	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b8c8	90 73		bcc $b93d			bcc 	_LCTokens
.b8ca	4c 9d b9	jmp $b99d			jmp 	_LCData 					; 254-5 are data objects
.b8cd					_LCExit:
.b8cd	68		pla				pla 								; get old indent adjust
.b8ce	30 07		bmi $b8d7			bmi 	_LCExit2
.b8d0	18		clc				clc 								; add to indent if +ve
.b8d1	6d 26 04	adc $0426			adc 	listIndent
.b8d4	8d 26 04	sta $0426			sta 	listIndent
.b8d7					_LCExit2:
.b8d7	60		rts				rts
.b8d8					_LCDoubles:
.b8d8	48		pha				pha
.b8d9	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b8da	29 02		and #$02			and 	#2
.b8dc	09 3c		ora #$3c			ora 	#60 						; make < >
.b8de	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.b8e1	68		pla				pla 								; restore, do lower bit
.b8e2	29 03		and #$03			and 	#3
.b8e4	09 3c		ora #$3c			ora 	#60
.b8e6	80 0f		bra $b8f7			bra		_LCPunctuation 				; print, increment, loop
.b8e8					_LCShiftPunc:
.b8e8	aa		tax				tax 								; save in X
.b8e9	29 07		and #$07			and 	#7 							; lower 3 bits
.b8eb	f0 02		beq $b8ef			beq 	_LCNoAdd
.b8ed	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b8ef					_LCNoAdd:
.b8ef	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b8f1	90 02		bcc $b8f5			bcc 	_LCNoAdd2
.b8f3	09 20		ora #$20			ora 	#32 						; adds $20
.b8f5					_LCNoAdd2:
.b8f5	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b8f7					_LCPunctuation:
.b8f7	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b8f9	d0 03		bne $b8fe			bne 	_LCPContinue
.b8fb	20 12 ba	jsr $ba12			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b8fe					_LCPContinue:
.b8fe	c9 2e		cmp #$2e			cmp 	#'.'
.b900	f0 08		beq $b90a			beq 	_LCPIsConstant
.b902	c9 30		cmp #$30			cmp 	#'0'
.b904	90 0b		bcc $b911			bcc 	_LCPNotConstant
.b906	c9 3a		cmp #$3a			cmp 	#'9'+1
.b908	b0 07		bcs $b911			bcs 	_LCPNotConstant
.b90a					_LCPIsConstant:
.b90a	48		pha				pha
.b90b	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b90d	20 f3 b9	jsr $b9f3			jsr 	LCLWriteColour
.b910	68		pla				pla
.b911					_LCPNotConstant:
.b911	c8		iny				iny 								; consume character
.b912	20 fc b9	jsr $b9fc			jsr 	LCLWrite 					; write it out.
.b915	80 94		bra $b8ab			bra 	_LCMainLoop 				; go round again.
.b917					_LCIdentifiers:
.b917	18		clc				clc 								; convert to physical address
.b918	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b91a	85 37		sta $37				sta 	zTemp0+1
.b91c	c8		iny				iny
.b91d	b1 30		lda ($30),y			lda 	(codePtr),y
.b91f	85 36		sta $36				sta 	zTemp0
.b921	c8		iny				iny
.b922	5a		phy				phy 								; save position
.b923	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b925	20 f3 b9	jsr $b9f3			jsr 	LCLWriteColour
.b928	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b92a					_LCOutIdentifier:
.b92a	c8		iny				iny
.b92b	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b92d	29 7f		and #$7f			and 	#$7F
.b92f	20 4e ba	jsr $ba4e			jsr 	LCLLowerCase
.b932	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.b935	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b937	10 f1		bpl $b92a			bpl 	_LCOutIdentifier
.b939	7a		ply				ply 								; restore position
.b93a	4c ab b8	jmp $b8ab			jmp 	_LCMainLoop
.b93d					_LCTokens:
.b93d	aa		tax				tax 								; token in X
.b93e	a9 1e		lda #$1e			lda 	#((KeywordSet2) & $FF)
.b940	85 36		sta $36				sta 	0+zTemp0
.b942	a9 b7		lda #$b7			lda 	#((KeywordSet2) >> 8)
.b944	85 37		sta $37				sta 	1+zTemp0
.b946	e0 82		cpx #$82			cpx 	#$82
.b948	f0 16		beq $b960			beq 	_LCUseShift
.b94a	a9 ab		lda #$ab			lda 	#((KeywordSet1) & $FF)
.b94c	85 36		sta $36				sta 	0+zTemp0
.b94e	a9 b6		lda #$b6			lda 	#((KeywordSet1) >> 8)
.b950	85 37		sta $37				sta 	1+zTemp0
.b952	e0 81		cpx #$81			cpx 	#$81
.b954	f0 0a		beq $b960			beq 	_LCUseShift
.b956	a9 94		lda #$94			lda 	#((KeywordSet0) & $FF)
.b958	85 36		sta $36				sta 	0+zTemp0
.b95a	a9 b4		lda #$b4			lda 	#((KeywordSet0) >> 8)
.b95c	85 37		sta $37				sta 	1+zTemp0
.b95e	80 01		bra $b961			bra 	_LCNoShift
.b960					_LCUseShift:
.b960	c8		iny				iny
.b961					_LCNoShift:
.b961	20 26 ba	jsr $ba26			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b964	b1 30		lda ($30),y			lda 	(codePtr),y
.b966	aa		tax				tax 								; into X
.b967					_LCFindText:
.b967	ca		dex				dex
.b968	10 0e		bpl $b978			bpl 	_LCFoundText 				; found text.
.b96a	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b96c	1a		inc a				inc 	a 							; one extra for size
.b96d	38		sec				sec 								; one extra for checksum
.b96e	65 36		adc $36				adc 	zTemp0 						; go to next token
.b970	85 36		sta $36				sta 	zTemp0
.b972	90 f3		bcc $b967			bcc 	_LCFindText
.b974	e6 37		inc $37				inc 	zTemp0+1
.b976	80 ef		bra $b967			bra 	_LCFindText
.b978					_LCFoundText:
.b978	5a		phy				phy 								; save List position
.b979	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b97b	aa		tax				tax
.b97c	a9 83		lda #$83			lda 	#CLIToken+$80
.b97e	20 f3 b9	jsr $b9f3			jsr 	LCLWriteColour
.b981	a0 02		ldy #$02			ldy 	#2
.b983					_LCCopyToken:
.b983	b1 36		lda ($36),y			lda 	(zTemp0),y
.b985	20 4e ba	jsr $ba4e			jsr 	LCLLowerCase
.b988	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.b98b	c8		iny				iny
.b98c	ca		dex				dex
.b98d	d0 f4		bne $b983			bne 	_LCCopyToken
.b98f	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b991	f0 05		beq $b998			beq 	_LCNoSpace
.b993	a9 20		lda #$20			lda 	#' '
.b995	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.b998					_LCNoSpace:
.b998	7a		ply				ply 								; restore position.
.b999	c8		iny				iny 								; consume token
.b99a	4c ab b8	jmp $b8ab			jmp 	_LCMainLoop 				; and go around again.
.b99d					_LCData:
.b99d	48		pha				pha 								; save type $FE/$FF
.b99e	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b9a0	c9 fe		cmp #$fe			cmp 	#$FE
.b9a2	f0 22		beq $b9c6			beq 	_LCHaveOpener
.b9a4	a2 22		ldx #$22			ldx 	#'"'
.b9a6	a9 81		lda #$81			lda 	#CLIData+$80
.b9a8	20 f3 b9	jsr $b9f3			jsr 	LCLWriteColour
.b9ab	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b9ad	d0 17		bne $b9c6			bne 	_LCHaveOpener
.b9af	88		dey				dey 								; what precedes it ?
.b9b0	b1 30		lda ($30),y			lda 	(codePtr),y
.b9b2	c8		iny				iny
.b9b3	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b9b5	d0 0f		bne $b9c6			bne 	_LCHaveOpener
.b9b7	a9 09		lda #$09			lda 	#9 							; tab
.b9b9	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.b9bc	a9 97		lda #$97			lda 	#$90+CLIBComment
.b9be	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.b9c1	a9 80		lda #$80			lda 	#CLIFComment+$80
.b9c3	20 f3 b9	jsr $b9f3			jsr 	LCLWriteColour
.b9c6					_LCHaveOpener:
.b9c6	8a		txa				txa 								; output prefix (# or ")
.b9c7	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.b9ca	c8		iny				iny 								; get count
.b9cb	b1 30		lda ($30),y			lda 	(codePtr),y
.b9cd	aa		tax				tax
.b9ce	c8		iny				iny 								; point at first character
.b9cf					_LCOutData:
.b9cf	b1 30		lda ($30),y			lda 	(codePtr),y
.b9d1	c9 00		cmp #$00			cmp 	#0
.b9d3	f0 03		beq $b9d8			beq 	_LCNoPrint
.b9d5	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.b9d8					_LCNoPrint:
.b9d8	c8		iny				iny
.b9d9	ca		dex				dex
.b9da	d0 f3		bne $b9cf			bne 	_LCOutData
.b9dc	68		pla				pla 								; closing " required ?
.b9dd	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b9df	d0 0f		bne $b9f0			bne 	_LCNoQuote
.b9e1	a9 22		lda #$22			lda 	#'"'
.b9e3	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.b9e6	ad 6f 06	lda $066f			lda 	EXTTextColour
.b9e9	29 0f		and #$0f			and 	#$0F
.b9eb	09 90		ora #$90			ora 	#$90
.b9ed	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.b9f0					_LCNoQuote:
.b9f0	4c ab b8	jmp $b8ab			jmp 	_LCMainLoop
.b9f3					LCLWriteColour:
.b9f3	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b9f6	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b9f9	d0 01		bne $b9fc			bne 	LCLWrite 					; if different, output it
.b9fb	60		rts				rts
.b9fc					LCLWrite:
.b9fc	da		phx				phx
.b9fd	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.ba00	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.ba03	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.ba06	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.ba09	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.ba0b	30 03		bmi $ba10			bmi 	_LCLNoColour
.ba0d	8d 27 04	sta $0427			sta 	LCLastCharacter
.ba10					_LCLNoColour:
.ba10	fa		plx				plx
.ba11	60		rts				rts
.ba12					LCLDeleteLastSpace:
.ba12	48		pha				pha
.ba13	da		phx				phx
.ba14	ae 1d 04	ldx $041d			ldx 	tbOffset
.ba17	f0 0a		beq $ba23			beq 	_LCDLSExit
.ba19	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.ba1c	c9 20		cmp #$20			cmp 	#' '
.ba1e	d0 03		bne $ba23			bne 	_LCDLSExit
.ba20	ce 1d 04	dec $041d			dec 	tbOffset
.ba23					_LCDLSExit:
.ba23	fa		plx				plx
.ba24	68		pla				pla
.ba25	60		rts				rts
.ba26					LCLCheckSpaceRequired:
.ba26	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.ba29	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.ba2b	f0 1b		beq $ba48			beq 	_LCCSRSpace
.ba2d	c9 29		cmp #$29			cmp 	#')'
.ba2f	f0 17		beq $ba48			beq 	_LCCSRSpace
.ba31	c9 23		cmp #$23			cmp 	#'#'
.ba33	f0 13		beq $ba48			beq 	_LCCSRSpace
.ba35	20 4e ba	jsr $ba4e			jsr 	LCLLowerCase 				; saves a little effort
.ba38	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.ba3a	90 11		bcc $ba4d			bcc 	_LCCSRExit
.ba3c	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba3e	90 08		bcc $ba48			bcc 	_LCCSRSpace
.ba40	c9 61		cmp #$61			cmp 	#"a"
.ba42	90 09		bcc $ba4d			bcc 	_LCCSRExit
.ba44	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba46	b0 05		bcs $ba4d			bcs 	_LCCSRExit
.ba48					_LCCSRSpace:
.ba48	a9 20		lda #$20			lda 	#' '
.ba4a	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.ba4d					_LCCSRExit:
.ba4d	60		rts				rts
.ba4e					LCLLowerCase:
.ba4e	c9 41		cmp #$41			cmp 	#"A"
.ba50	90 06		bcc $ba58			bcc 	_LCLLCOut
.ba52	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba54	b0 02		bcs $ba58			bcs 	_LCLLCOut
.ba56	69 20		adc #$20			adc 	#$20
.ba58					_LCLLCOut:
.ba58	60		rts				rts
.ba59					LCLUpperCase:
.ba59	c9 61		cmp #$61			cmp 	#"a"
.ba5b	90 06		bcc $ba63			bcc 	_LCLUCOut
.ba5d	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba5f	b0 02		bcs $ba63			bcs 	_LCLUCOut
.ba61	e9 1f		sbc #$1f			sbc 	#$1F
.ba63					_LCLUCOut:
.ba63	60		rts				rts
.ba64					LCLWriteNumberXA:
.ba64	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.ba66					_LCLWNLoop1:
.ba66	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.ba68					_LCLWNLoop2:
.ba68	48		pha				pha 								; save initial LSB
.ba69	38		sec				sec
.ba6a	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.ba6c	f9 9d ba	sbc $ba9d,y			sbc 	_LCLWNTable,y
.ba6f	48		pha				pha
.ba70	8a		txa				txa
.ba71	f9 9e ba	sbc $ba9e,y			sbc 	_LCLWNTable+1,y
.ba74	90 07		bcc $ba7d			bcc 	_LCLWNUnderflow
.ba76	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.ba78	aa		tax				tax 								; update X
.ba79	68		pla				pla 								; restore A
.ba7a	7a		ply				ply 								; throw original
.ba7b	80 eb		bra $ba68			bra 	_LCLWNLoop2 				; try again.
.ba7d					_LCLWNUnderflow:
.ba7d	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.ba7f	d0 06		bne $ba87			bne 	_LCLWNOut
.ba81	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.ba84	3a		dec a				dec 	a
.ba85	f0 04		beq $ba8b			beq 	_LCLWNNext
.ba87					_LCLWNOut:
.ba87	98		tya				tya
.ba88	20 97 ba	jsr $ba97			jsr 	_LCLWNOutDigit
.ba8b					_LCLWNNext:
.ba8b	7a		ply				ply 							 	; restore original value.
.ba8c	68		pla				pla
.ba8d	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.ba8f	c8		iny				iny
.ba90	c8		iny				iny
.ba91	84 37		sty $37				sty 	zTemp0+1
.ba93	c0 08		cpy #$08			cpy 	#8 							; done all 4
.ba95	d0 cf		bne $ba66			bne 	_LCLWNLoop1
.ba97					_LCLWNOutDigit:
.ba97	09 30		ora #$30			ora 	#'0'
.ba99	20 fc b9	jsr $b9fc			jsr 	LCLWrite
.ba9c	60		rts				rts
.ba9d					_LCLWNTable:
>ba9d	10 27						.word 	10000
>ba9f	e8 03						.word 	1000
>baa1	64 00						.word 	100
>baa3	0a 00						.word 	10
.baa5					TOKSearchTable:
.baa5	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.baa7	85 36		sta $36				sta 	zTemp0
.baa9	a0 00		ldy #$00			ldy 	#0
.baab	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.baad	85 38		sta $38				sta 	zTemp1
.baaf					_TSTLoop:
.baaf	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.bab1	30 49		bmi $bafc			bmi 	_TSTFail 					; -ve = end of table, so fail.
.bab3	f0 2e		beq $bae3			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.bab5	c8		iny				iny 								; get the hash
.bab6	b1 36		lda ($36),y			lda 	(zTemp0),y
.bab8	88		dey				dey
.bab9	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.babc	d0 25		bne $bae3			bne 	_TSTNext
.babe	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.bac1	38		sec				sec
.bac2	ed 00 04	sbc $0400			sbc 	identStart
.bac5	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.bac7	d0 1a		bne $bae3			bne 	_TSTNext
.bac9	5a		phy				phy 								; save Y , we might fail to match.
.baca	c8		iny				iny 								; point to text
.bacb	c8		iny				iny
.bacc	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.bacf					_TSTCompareName:
.bacf	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.bad2	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.bad4	d0 0c		bne $bae2			bne 	_TSTNextPullY 				; fail, pullY and do next
.bad6	e8		inx				inx
.bad7	c8		iny				iny
.bad8	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.badb	d0 f2		bne $bacf			bne 	_TSTCompareName
.badd	7a		ply				ply 								; throw Y
.bade	a5 38		lda $38				lda 	zTemp1 						; get token #
.bae0	38		sec				sec 								; return with CS = passed.
.bae1	60		rts				rts
.bae2					_TSTNextPullY:
.bae2	7a		ply				ply 								; restore current, fall through.
.bae3					_TSTNext:
.bae3	e6 38		inc $38				inc 	zTemp1 						; token counter
.bae5	98		tya				tya
.bae6	18		clc				clc
.bae7	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.bae9	1a		inc a				inc 	a 							; +1
.baea	1a		inc a				inc 	a 							; +2
.baeb	a8		tay				tay
.baec	10 c1		bpl $baaf			bpl 	_TSTLoop 					; if Y < $80 loop back
.baee	98		tya				tya 								; add Y to zTemp0 and reset Y
.baef	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.baf1	18		clc				clc  								; but have tables > 255 bytes
.baf2	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.baf4	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.baf6	90 b7		bcc $baaf			bcc 	_TSTLoop
.baf8	e6 37		inc $37				inc 	zTemp0+1
.bafa	80 b3		bra $baaf			bra 	_TSTLoop
.bafc					_TSTFail:
.bafc	18		clc				clc
.bafd	60		rts				rts
.bafe					Export_TKTokeniseLine:
.bafe	20 86 bc	jsr $bc86			jsr 	LCLFixLineBufferCase 		; fix line case
.bb01	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.bb03	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.bb06	9c 2b 04	stz $042b			stz 	tokenLineNumber
.bb09	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.bb0c	a2 ff		ldx #$ff			ldx 	#$FF
.bb0e					_TKFindFirst:
.bb0e	e8		inx				inx
.bb0f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bb12	f0 79		beq $bb8d			beq 	_TKExit
.bb14	c9 20		cmp #$20			cmp 	#' '
.bb16	90 f6		bcc $bb0e			bcc 	_TKFindFirst
.bb18	c9 30		cmp #$30			cmp 	#'0'
.bb1a	90 07		bcc $bb23			bcc 	_TKNoLineNumber
.bb1c	c9 3a		cmp #$3a			cmp 	#'9'+1
.bb1e	b0 03		bcs $bb23			bcs 	_TKNoLineNumber
.bb20	20 b0 bc	jsr $bcb0			jsr 	TOKExtractLineNumber
.bb23					_TKNoLineNumber:
.bb23					_TKTokeniseLoop:
.bb23	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.bb26	f0 65		beq $bb8d			beq 	_TKExit
.bb28	e8		inx				inx
.bb29	c9 20		cmp #$20			cmp 	#' '
.bb2b	f0 f6		beq $bb23			beq 	_TKTokeniseLoop 			; keep looping if space found.
.bb2d	ca		dex				dex 								; undo last get, A contains character, X is position.
.bb2e	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.bb30	f0 61		beq $bb93			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.bb32	c9 41		cmp #$41			cmp 	#'A'
.bb34	90 04		bcc $bb3a			bcc 	_TKTokenisePunctuation
.bb36	c9 5b		cmp #$5b			cmp 	#'Z'+1
.bb38	90 59		bcc $bb93			bcc 	_TKTokeniseIdentifier
.bb3a					_TKTokenisePunctuation:
.bb3a	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.bb3c	f0 27		beq $bb65			beq 	_TKString
.bb3e	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.bb40	f0 28		beq $bb6a			beq 	_TKHexConstant
.bb42	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.bb44	f0 29		beq $bb6f			beq 	_TKCheckDouble
.bb46	c9 3e		cmp #$3e			cmp 	#'>'
.bb48	f0 25		beq $bb6f			beq 	_TKCheckDouble
.bb4a					_TKStandardPunctuation:
.bb4a	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.bb4d	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.bb4f	90 0e		bcc $bb5f			bcc 	_TKNoShift
.bb51	48		pha				pha 								; save. we are about to convert this punctuation token from
.bb52	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.bb54	85 36		sta $36				sta 	zTemp0
.bb56	68		pla				pla
.bb57	29 20		and #$20			and 	#32 						; bit 5
.bb59	4a		lsr a				lsr 	a 							; shift into bit 3
.bb5a	4a		lsr a				lsr 	a
.bb5b	05 36		ora $36				ora 	zTemp0
.bb5d	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.bb5f					_TKNoShift:
.bb5f	20 f5 bc	jsr $bcf5			jsr 	TOKWriteByte 				; write the punctuation character
.bb62	e8		inx				inx 								; consume the character
.bb63	80 be		bra $bb23			bra 	_TKTokeniseLoop 			; and loop round again.
.bb65					_TKString:
.bb65	20 15 bc	jsr $bc15			jsr 	TOKTokenString
.bb68	80 b9		bra $bb23			bra 	_TKTokeniseLoop
.bb6a					_TKHexConstant:
.bb6a	20 50 bc	jsr $bc50			jsr 	TOKHexConstant
.bb6d	80 b4		bra $bb23			bra 	_TKTokeniseLoop
.bb6f					_TKCheckDouble:
.bb6f	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.bb72	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.bb74	90 d4		bcc $bb4a			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.bb76	c9 3f		cmp #$3f			cmp 	#'>'+1
.bb78	b0 d0		bcs $bb4a			bcs 	_TKStandardPunctuation
.bb7a	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.bb7d	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.bb7f	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.bb80	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.bb83	38		sec				sec
.bb84	e9 3c		sbc #$3c			sbc 	#'<'
.bb86	20 f5 bc	jsr $bcf5			jsr 	TOKWriteByte 				; this is in the range 0-7
.bb89	e8		inx				inx 								; consume both
.bb8a	e8		inx				inx
.bb8b	80 96		bra $bb23			bra 	_TKTokeniseLoop
.bb8d	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.bb8f	20 f5 bc	jsr $bcf5			jsr 	TOKWriteByte
.bb92	60		rts				rts
.bb93					_TKTokeniseIdentifier:
.bb93	8e 00 04	stx $0400			stx 	identStart 					; save start
.bb96	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.bb99					_TKCheckLoop:
.bb99	e8		inx				inx 								; look at next, we know first is identifier already.
.bb9a	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.bb9d	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.bb9f	f0 f8		beq $bb99			beq 	_TKCheckLoop
.bba1	c9 30		cmp #$30			cmp	 	#"0"
.bba3	90 0c		bcc $bbb1			bcc 	_TKEndIdentifier
.bba5	c9 3a		cmp #$3a			cmp 	#"9"+1
.bba7	90 f0		bcc $bb99			bcc 	_TKCheckLoop
.bba9	c9 41		cmp #$41			cmp	 	#"A"
.bbab	90 04		bcc $bbb1			bcc 	_TKEndIdentifier
.bbad	c9 5b		cmp #$5b			cmp 	#"Z"+1
.bbaf	90 e8		bcc $bb99			bcc 	_TKCheckLoop
.bbb1					_TKEndIdentifier:
.bbb1	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.bbb4	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.bbb6	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.bbb8	f0 06		beq $bbc0			beq 	_TKHasTypeCharacter
.bbba	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.bbbc	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.bbbe	d0 07		bne $bbc7			bne 	_TKNoTypeCharacter
.bbc0					_TKHasTypeCharacter:
.bbc0	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.bbc3	e8		inx				inx 								; consume the type character
.bbc4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bbc7					_TKNoTypeCharacter:
.bbc7	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.bbc9	d0 09		bne $bbd4			bne 	_TKNoArray
.bbcb	e8		inx				inx 								; skip the (
.bbcc	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.bbcf	09 04		ora #$04			ora 	#$04
.bbd1	8d 04 04	sta $0404			sta 	identTypeByte
.bbd4					_TKNoArray:
.bbd4	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.bbd7	20 71 bc	jsr $bc71			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.bbda	a0 b4		ldy #$b4			ldy 	#(KeywordSet0) >> 8
.bbdc	a9 94		lda #$94			lda 	#(KeywordSet0) & $FF
.bbde	20 a5 ba	jsr $baa5			jsr 	TOKSearchTable
.bbe1	a2 00		ldx #$00			ldx 	#0
.bbe3	b0 1f		bcs $bc04			bcs 	_TKFoundToken
.bbe5	a0 b6		ldy #$b6			ldy 	#(KeywordSet1) >> 8
.bbe7	a9 ab		lda #$ab			lda 	#(KeywordSet1) & $FF
.bbe9	20 a5 ba	jsr $baa5			jsr 	TOKSearchTable
.bbec	a2 81		ldx #$81			ldx 	#$81
.bbee	b0 14		bcs $bc04			bcs 	_TKFoundToken
.bbf0	a0 b7		ldy #$b7			ldy 	#(KeywordSet2) >> 8
.bbf2	a9 1e		lda #$1e			lda 	#(KeywordSet2) & $FF
.bbf4	20 a5 ba	jsr $baa5			jsr 	TOKSearchTable
.bbf7	a2 82		ldx #$82			ldx 	#$82
.bbf9	b0 09		bcs $bc04			bcs 	_TKFoundToken
.bbfb	20 01 bd	jsr $bd01			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bbfe	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc01	4c 23 bb	jmp $bb23			jmp 	_TKTokeniseLoop 			; and go round again.
.bc04					_TKFoundToken:
.bc04	48		pha				pha 								; save token
.bc05	8a		txa				txa 								; shift in X, is there one ?
.bc06	f0 03		beq $bc0b			beq 	_TKNoTShift
.bc08	20 f5 bc	jsr $bcf5			jsr 	TOKWriteByte 				; if so, write it out
.bc0b					_TKNoTShift:
.bc0b	68		pla				pla 								; restore and write token
.bc0c	20 f5 bc	jsr $bcf5			jsr 	TOKWriteByte
.bc0f	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc12	4c 23 bb	jmp $bb23			jmp 	_TKTokeniseLoop 			; and go round again.
.bc15					TOKTokenString:
.bc15	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bc17	20 f5 bc	jsr $bcf5			jsr 	TOKWriteByte
.bc1a	e8		inx				inx									; start of quoted string.
.bc1b	da		phx				phx 								; push start of string on top
.bc1c	ca		dex				dex 								; because we pre-increment
.bc1d					_TSFindEnd:
.bc1d	e8		inx				inx
.bc1e	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bc21	f0 04		beq $bc27			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bc23	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bc25	d0 f6		bne $bc1d			bne 	_TSFindEnd
.bc27					_TSEndOfString:
.bc27	7a		ply				ply  								; so now Y is first character, X is character after end.
.bc28	48		pha				pha 								; save terminating character
.bc29	20 31 bc	jsr $bc31			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bc2c	68		pla				pla 								; terminating character
.bc2d	f0 01		beq $bc30			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bc2f	e8		inx				inx
.bc30					_TSNotQuote:
.bc30	60		rts				rts
.bc31					TOKWriteBlockXY:
.bc31	86 36		stx $36				stx 	zTemp0 						; save end character
.bc33	98		tya				tya 								; use 2's complement to work out the byte size
.bc34	49 ff		eor #$ff			eor 	#$FF
.bc36	38		sec				sec
.bc37	65 36		adc $36				adc 	zTemp0
.bc39	1a		inc a				inc 	a 							; one extra for NULL
.bc3a	20 f5 bc	jsr $bcf5			jsr 	TOKWriteByte
.bc3d					_TOBlockLoop:
.bc3d	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bc3f	f0 09		beq $bc4a			beq 	_TOBlockExit
.bc41	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bc44	20 f5 bc	jsr $bcf5			jsr 	TOKWriteByte
.bc47	c8		iny				iny
.bc48	80 f3		bra $bc3d			bra 	_TOBlockLoop
.bc4a					_TOBlockExit:
.bc4a	a9 00		lda #$00			lda 	#0 							; add NULL.
.bc4c	20 f5 bc	jsr $bcf5			jsr 	TOKWriteByte
.bc4f	60		rts				rts
.bc50					TOKHexConstant:
.bc50	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bc52	20 f5 bc	jsr $bcf5			jsr 	TOKWriteByte
.bc55	e8		inx				inx									; start of quoted string.
.bc56	da		phx				phx 								; push start of constant on top
.bc57	ca		dex				dex
.bc58					_THFindLoop:
.bc58	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bc59	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bc5c	c9 30		cmp #$30			cmp 	#"0"
.bc5e	90 0c		bcc $bc6c			bcc 	_THFoundEnd
.bc60	c9 3a		cmp #$3a			cmp 	#"9"+1
.bc62	90 f4		bcc $bc58			bcc 	_THFindLoop
.bc64	c9 41		cmp #$41			cmp 	#"A"
.bc66	90 04		bcc $bc6c			bcc 	_THFoundEnd
.bc68	c9 47		cmp #$47			cmp 	#"F"+1
.bc6a	90 ec		bcc $bc58			bcc 	_THFindLoop
.bc6c					_THFoundEnd:
.bc6c	7a		ply				ply 								; restore start
.bc6d	20 31 bc	jsr $bc31			jsr 	TOKWriteBlockXY 			; output the block
.bc70	60		rts				rts
.bc71					TOKCalculateHash:
.bc71	da		phx				phx
.bc72	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bc75	a9 00		lda #$00			lda 	#0
.bc77					_TCHLoop:
.bc77	18		clc				clc
.bc78	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bc7b	e8		inx				inx
.bc7c	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bc7f	d0 f6		bne $bc77			bne 	_TCHLoop
.bc81	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bc84	fa		plx				plx
.bc85	60		rts				rts
.bc86					LCLFixLineBufferCase:
.bc86	a2 00		ldx #$00			ldx 	#0
.bc88					_FLBCLoop:
.bc88	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bc8b	f0 22		beq $bcaf			beq 	_FLBCExit 					; end of string.
.bc8d	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bc8f	f0 11		beq $bca2			beq 	_FLBCInQuotes
.bc91	e8		inx				inx
.bc92	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bc94	90 f2		bcc $bc88			bcc 	_FLBCLoop
.bc96	c9 7b		cmp #$7b			cmp 	#'z'+1
.bc98	b0 ee		bcs $bc88			bcs 	_FLBCLoop
.bc9a	38		sec				sec 								; make U/C
.bc9b	e9 20		sbc #$20			sbc 	#32
.bc9d	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bca0	80 e6		bra $bc88			bra 	_FLBCLoop
.bca2					_FLBCInQuotes:
.bca2	e8		inx				inx 								; advance
.bca3	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bca6	f0 07		beq $bcaf			beq 	_FLBCExit 					; exit on EOS
.bca8	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bcaa	d0 f6		bne $bca2			bne 	_FLBCInQuotes
.bcac	e8		inx				inx 								; skip over it
.bcad	80 d9		bra $bc88			bra 	_FLBCLoop
.bcaf					_FLBCExit:
.bcaf	60		rts				rts
.bcb0					TOKExtractLineNumber:
.bcb0	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bcb3	48		pha				pha
.bcb4	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bcb7	48		pha				pha
.bcb8	20 ee bc	jsr $bcee			jsr 	_LCLNTimes2 				; line # x 2
.bcbb	20 ee bc	jsr $bcee			jsr 	_LCLNTimes2 				; line # x 4
.bcbe	18		clc				clc 								; add stacked value
.bcbf	68		pla				pla
.bcc0	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcc3	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcc6	68		pla				pla
.bcc7	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bcca	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bccd	20 ee bc	jsr $bcee			jsr 	_LCLNTimes2 				; line # x 10
.bcd0	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bcd3	e8		inx				inx
.bcd4	29 0f		and #$0f			and 	#15 						; add to line #
.bcd6	18		clc				clc
.bcd7	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcda	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcdd	90 03		bcc $bce2			bcc 	_TLENNoCarry
.bcdf	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bce2					_TLENNoCarry:
.bce2	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bce5	c9 30		cmp #$30			cmp 	#'0'
.bce7	90 04		bcc $bced			bcc 	_TLENExit
.bce9	c9 3a		cmp #$3a			cmp 	#'9'+1
.bceb	90 c3		bcc $bcb0			bcc 	TOKExtractLineNumber
.bced					_TLENExit:
.bced	60		rts				rts
.bcee					_LCLNTimes2:
.bcee	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bcf1	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bcf4	60		rts				rts
.bcf5					TOKWriteByte:
.bcf5	da		phx				phx
.bcf6	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bcf9	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bcfc	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bcff	fa		plx				plx
.bd00	60		rts				rts
.bd01					TOKCheckCreateVariableRecord:
.bd01	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bd03	85 36		sta $36				sta 	0+zTemp0
.bd05	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bd07	85 37		sta $37				sta 	1+zTemp0
.bd09					_CCVSearch:
.bd09	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bd0b	f0 2c		beq $bd39			beq 	_CCVFail
.bd0d	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bd0f	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bd11	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bd14	d0 16		bne $bd2c			bne 	_CCVNext
.bd16	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bd18	ae 00 04	ldx $0400			ldx 	identStart
.bd1b					_CCVCompare:
.bd1b	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bd1e	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bd20	e8		inx				inx 								; advance pointers
.bd21	c8		iny				iny
.bd22	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bd23	d0 07		bne $bd2c			bne 	_CCVNext  					; didn't match go to next.
.bd25	90 f4		bcc $bd1b			bcc 	_CCVCompare 				; not finished yet.
.bd27	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bd2a	f0 41		beq $bd6d			beq 	_CCVFound 					; yes, we were successful
.bd2c					_CCVNext:
.bd2c	18		clc				clc 								; go to next record.
.bd2d	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bd2f	65 36		adc $36				adc 	zTemp0
.bd31	85 36		sta $36				sta 	zTemp0
.bd33	90 d4		bcc $bd09			bcc 	_CCVSearch
.bd35	e6 37		inc $37				inc 	zTemp0+1
.bd37	80 d0		bra $bd09			bra 	_CCVSearch
.bd39					_CCVFail:
.bd39	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bd3b	ad 03 04	lda $0403			lda 	identHash
.bd3e	91 36		sta ($36),y			sta 	(zTemp0),y
.bd40	c8		iny				iny 								; offset 2 is the type byte
.bd41	ad 04 04	lda $0404			lda 	identTypeByte
.bd44	91 36		sta ($36),y			sta 	(zTemp0),y
.bd46	c8		iny				iny
.bd47					_CCVData:
.bd47	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bd49	91 36		sta ($36),y			sta 	(zTemp0),y
.bd4b	c8		iny				iny
.bd4c	c0 08		cpy #$08			cpy 	#8
.bd4e	90 f7		bcc $bd47			bcc 	_CCVData
.bd50	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bd53					_CCVCopyName:
.bd53	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bd56	91 36		sta ($36),y			sta 	(zTemp0),y
.bd58	e8		inx				inx
.bd59	c8		iny				iny
.bd5a	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bd5d	d0 f4		bne $bd53			bne 	_CCVCopyName
.bd5f	98		tya				tya 								; patch offset
.bd60	92 36		sta ($36)			sta 	(zTemp0)
.bd62	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bd64	91 36		sta ($36),y			sta 	(zTemp0),y
.bd66	88		dey				dey
.bd67	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bd69	09 80		ora #$80			ora 	#$80
.bd6b	91 36		sta ($36),y			sta 	(zTemp0),y
.bd6d					_CCVFound:
.bd6d	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bd6f	38		sec				sec
.bd70	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bd72	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bd74	20 f5 bc	jsr $bcf5			jsr 	TOKWriteByte
.bd77	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bd79	20 f5 bc	jsr $bcf5			jsr 	TOKWriteByte
.bd7c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bd7d					SNDCheckChannel:
.bd7d	aa		tax				tax
.bd7e	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bd81	d0 38		bne $bdbb			bne 	_SNDCCExit
.bd83	da		phx				phx 								; save current channel
.bd84	8a		txa				txa 								; put in A
.bd85	20 01 be	jsr $be01			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bd88	68		pla				pla 								; channel # in A
.bd89	90 30		bcc $bdbb			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bd8b	a8		tay				tay 								; Y is the channel #
.bd8c	bd 2d 07	lda $072d,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bd8f	99 2c 08	sta $082c,y			sta 	SNDPitchLow,y
.bd92	bd 2e 07	lda $072e,x			lda 	SNDQueue+2,x
.bd95	99 30 08	sta $0830,y			sta 	SNDPitchHigh,y
.bd98	bd 2f 07	lda $072f,x			lda 	SNDQueue+3,x
.bd9b	99 34 08	sta $0834,y			sta 	SNDVolume,y
.bd9e	bd 30 07	lda $0730,x			lda 	SNDQueue+4,x
.bda1	99 38 08	sta $0838,y			sta 	SNDTimeLeft,y
.bda4	bd 31 07	lda $0731,x			lda 	SNDQueue+5,x
.bda7	99 3c 08	sta $083c,y			sta 	SNDAdjustLow,y
.bdaa	bd 32 07	lda $0732,x			lda 	SNDQueue+6,x
.bdad	99 40 08	sta $0840,y			sta 	SNDAdjustHigh,y
.bdb0	5a		phy				phy 								; save channel #
.bdb1	20 1b be	jsr $be1b			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bdb4	ce 2b 07	dec $072b			dec 	SNDLength 					; reduce the queue length.
.bdb7	68		pla				pla
.bdb8	20 bc bd	jsr $bdbc			jsr 	SNDUpdateNote 				; update channel A
.bdbb					_SNDCCExit:
.bdbb	60		rts				rts
.bdbc					SNDUpdateNote:
.bdbc	aa		tax				tax 								; so we can access records
.bdbd	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bdbe	0a		asl a				asl 	a
.bdbf	0a		asl a				asl 	a
.bdc0	0a		asl a				asl 	a
.bdc1	0a		asl a				asl 	a
.bdc2	8d 2a 07	sta $072a			sta 	SNDChannelBits
.bdc5	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; are we silent
.bdc8	f0 2e		beq $bdf8			beq 	_SNDUNIsSilent
.bdca	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; push channel bits on stack
.bdcd	48		pha				pha
.bdce	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bdd1	29 0f		and #$0f			and 	#$0F
.bdd3	0d 2a 07	ora $072a			ora 	SNDChannelBits 				; set channel bits
.bdd6	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bdd8	20 65 be	jsr $be65			jsr 	SNDWritePorts
.bddb	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bdde	8d 2a 07	sta $072a			sta 	SNDChannelBits
.bde1	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.bde4	4e 2a 07	lsr $072a			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bde7	6a		ror a				ror 	a
.bde8	4e 2a 07	lsr $072a			lsr 	SNDChannelBits
.bdeb	6a		ror a				ror 	a
.bdec	4a		lsr a				lsr 	a 							; put in bits 0-5
.bded	4a		lsr a				lsr 	a
.bdee	20 65 be	jsr $be65			jsr 	SNDWritePorts 				; write as rest of pitch register
.bdf1	68		pla				pla
.bdf2	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.bdf4	20 65 be	jsr $be65			jsr 	SNDWritePorts
.bdf7	60		rts				rts
.bdf8					_SNDUNIsSilent:
.bdf8	ad 2a 07	lda $072a			lda 	SNDChannelBits 				; channel bits
.bdfb	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.bdfd	20 65 be	jsr $be65			jsr 	SNDWritePorts 				; write to the ports
.be00	60		rts				rts
.be01					SNDFindNextNoteForA:
.be01	ac 2b 07	ldy $072b			ldy 	SNDLength 					; queue size into Y
.be04	f0 13		beq $be19			beq 	_SNDFNNFail 				; queue empty.
.be06	a2 00		ldx #$00			ldx 	#0
.be08					_SNDFNNSearch:
.be08	dd 2c 07	cmp $072c,x			cmp 	SNDQueue,x 					; does it match the channel
.be0b	38		sec				sec
.be0c	f0 0c		beq $be1a			beq 	_SNDFNNExit 				; if so exit with CS.
.be0e	e8		inx				inx 								; next queue slot.
.be0f	e8		inx				inx
.be10	e8		inx				inx
.be11	e8		inx				inx
.be12	e8		inx				inx
.be13	e8		inx				inx
.be14	e8		inx				inx
.be15	e8		inx				inx
.be16	88		dey				dey 								; done the whole queue
.be17	d0 ef		bne $be08			bne 	_SNDFNNSearch 				; no, go back.
.be19					_SNDFNNFail:
.be19	18		clc				clc
.be1a					_SNDFNNexit:
.be1a	60		rts				rts
.be1b					SNDDeleteXFromQueue:
.be1b	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.be1d	f0 09		beq $be28			beq 	_SNDDXExit
.be1f	bd 34 07	lda $0734,x			lda 	SNDQueue+8,x
.be22	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.be25	e8		inx				inx
.be26	80 f3		bra $be1b			bra 	SNDDeleteXFromQueue
.be28					_SNDDXExit:
.be28	60		rts				rts
.072a					SNDChannelBits:
>072a							.fill 	1
.be29					SNDQueueRequest:
.be29	86 36		stx $36				stx 	zTemp0						; save queue address
.be2b	84 37		sty $37				sty 	zTemp0+1
.be2d	ae 2b 07	ldx $072b			ldx 	SNDLength 					; queue is full, can't take any more.
.be30	e0 20		cpx #$20			cpx 	#SNDQueueSize
.be32	f0 21		beq $be55			beq 	_SNDQRExit
.be34	29 03		and #$03			and 	#3	 						; channel # and push on stack
.be36	48		pha				pha
.be37	8a		txa				txa  								; get offset in queue buffer/
.be38	0a		asl a				asl 	a
.be39	0a		asl a				asl 	a
.be3a	0a		asl a				asl 	a
.be3b	aa		tax				tax
.be3c	68		pla				pla 								; get back and push again
.be3d	48		pha				pha
.be3e	9d 2c 07	sta $072c,x			sta 	SNDQueue+0,x 				; save the channel #
.be41	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.be43					_SNDQCopy:
.be43	b1 36		lda ($36),y			lda 	(zTemp0),y
.be45	e8		inx				inx
.be46	c8		iny				iny
.be47	9d 2c 07	sta $072c,x			sta 	SNDQueue,x
.be4a	c0 06		cpy #$06			cpy 	#6
.be4c	d0 f5		bne $be43			bne 	_SNDQCopy
.be4e	ee 2b 07	inc $072b			inc 	SNDLength 					; bump queue length.
.be51	68		pla				pla 								; get channel # back
.be52	20 7d bd	jsr $bd7d			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.be55					_SNDQRExit:
.be55	60		rts				rts
.be56					SNDSilenceChannel:
.be56	aa		tax				tax 								; zero time left.
.be57	9e 38 08	stz $0838,x			stz 	SNDTimeLeft,x
.be5a	0a		asl a				asl 	a 							; shift into position
.be5b	0a		asl a				asl 	a
.be5c	0a		asl a				asl 	a
.be5d	0a		asl a				asl 	a
.be5e	0a		asl a				asl 	a
.be5f	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.be61	20 65 be	jsr $be65			jsr 	SNDWritePorts
.be64	60		rts				rts
.be65					SNDWritePorts:
.be65	da		phx				phx 								; save X
.be66	a6 01		ldx $01				ldx 	1 							; save I/O status
.be68	64 01		stz $01				stz 	1 							; access I/O page 0
.be6a	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.be6d	8d 10 d6	sta $d610			sta 	$D610
.be70	86 01		stx $01				stx 	1 							; restore I/O
.be72	fa		plx				plx 								; restore X
.be73	60		rts				rts
.be74					Export_SNDCommand:
.be74	da		phx				phx 								; save XY
.be75	5a		phy				phy
.be76	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.be78	f0 1d		beq $be97			beq 	_SNDInitialise
.be7a	90 28		bcc $bea4			bcc 	_SNDExit
.be7c	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.be7e	f0 17		beq $be97			beq 	_SNDSilence
.be80	b0 22		bcs $bea4			bcs 	_SNDExit
.be82	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.be84	b0 09		bcs $be8f			bcs 	_SNDQueryPlay
.be86	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.be88	b0 1a		bcs $bea4			bcs 	_SNDExit
.be8a	20 29 be	jsr $be29			jsr 	SNDQueueRequest
.be8d	80 15		bra $bea4			bra 	_SNDExit
.be8f					_SNDQueryPlay:
.be8f	29 03		and #$03			and 	#3 							; get channel #
.be91	aa		tax				tax
.be92	bd 38 08	lda $0838,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.be95	80 0d		bra $bea4			bra 	_SNDExit
.be97					_SNDInitialise:
.be97					_SNDSilence:
.be97	9c 2b 07	stz $072b			stz 	SNDLength 					; empty the queue.
.be9a	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.be9c					_SNDSilenceLoop:
.be9c	48		pha				pha
.be9d	20 56 be	jsr $be56			jsr 	SNDSilenceChannel
.bea0	68		pla				pla
.bea1	3a		dec a				dec 	a
.bea2	10 f8		bpl $be9c			bpl 	_SNDSilenceLoop
.bea4					_SNDExit:
.bea4	7a		ply				ply
.bea5	fa		plx				plx
.bea6	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.072b					SNDLength:
>072b							.fill 	1
.072c					SNDQueue:
>072c							.fill 	SNDQueueSize * 8
.082c					SNDPitchLow:
>082c							.fill 	4
.0830					SNDPitchHigh:
>0830							.fill 	4
.0834					SNDVolume:
>0834							.fill 	4
.0838					SNDTimeLeft:
>0838							.fill 	4
.083c					SNDAdjustLow:
>083c							.fill 	4
.0840					SNDAdjustHigh:
>0840							.fill 	4
.bea7					Export_SNDUpdate:
.bea7					PagedSNDUpdate:
.bea7	ad 38 08	lda $0838			lda 	SNDTimeLeft+0 				; look at time remaining
.beaa	f0 05		beq $beb1			beq 	_SNDUNot0 					; not playing
.beac	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.beae	20 d0 be	jsr $bed0			jsr 	SNDUpdateChannel 			; update it.
.beb1					_SNDUNot0:
.beb1	ad 39 08	lda $0839			lda 	SNDTimeLeft+1
.beb4	f0 05		beq $bebb			beq 	_SNDUNot1
.beb6	a2 01		ldx #$01			ldx 	#1
.beb8	20 d0 be	jsr $bed0			jsr 	SNDUpdateChannel
.bebb					_SNDUNot1:
.bebb	ad 3a 08	lda $083a			lda 	SNDTimeLeft+2
.bebe	f0 05		beq $bec5			beq 	_SNDUNot2
.bec0	a2 02		ldx #$02			ldx 	#2
.bec2	20 d0 be	jsr $bed0			jsr 	SNDUpdateChannel
.bec5					_SNDUNot2:
.bec5	ad 3b 08	lda $083b			lda 	SNDTimeLeft+3
.bec8	f0 05		beq $becf			beq 	_SNDUNot3
.beca	a2 03		ldx #$03			ldx 	#3
.becc	20 d0 be	jsr $bed0			jsr 	SNDUpdateChannel
.becf					_SNDUNot3:
.becf	60		rts				rts
.bed0					SNDUpdateChannel:
.bed0	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.bed2	f0 2c		beq $bf00			beq 	_SNDUCExit
.bed4	3a		dec a				dec 	a 							; decrement and update timer
.bed5	9d 38 08	sta $0838,x			sta 	SNDTimeLeft,x
.bed8	f0 1d		beq $bef7			beq 	_SNDUCUpdate 				; if zero, silence channel
.beda	bd 3c 08	lda $083c,x			lda 	SNDAdjustLow,x 				; adjust ?
.bedd	1d 40 08	ora $0840,x			ora 	SNDAdjustHigh,x
.bee0	f0 1e		beq $bf00			beq 	_SNDUCExit 					; if zero carry on at current tone.
.bee2	18		clc				clc 								; add adjust, forcing into a 10 bit range
.bee3	bd 2c 08	lda $082c,x			lda 	SNDPitchLow,x
.bee6	7d 3c 08	adc $083c,x			adc 	SNDAdjustLow,x
.bee9	9d 2c 08	sta $082c,x			sta 	SNDPitchLow,x
.beec	bd 30 08	lda $0830,x			lda 	SNDPitchHigh,x
.beef	7d 40 08	adc $0840,x			adc 	SNDAdjustHigh,x
.bef2	29 03		and #$03			and 	#3
.bef4	9d 30 08	sta $0830,x			sta 	SNDPitchHigh,x
.bef7					_SNDUCUpdate:
.bef7	8a		txa				txa 								; which channel.
.bef8	48		pha				pha
.bef9	20 bc bd	jsr $bdbc			jsr 	SNDUpdateNote 				; update the current note
.befc	68		pla				pla
.befd	20 7d bd	jsr $bd7d			jsr 	SNDCheckChannel 			; more to do ?
.bf00					_SNDUCExit:
.bf00	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
