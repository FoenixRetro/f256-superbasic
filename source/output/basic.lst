
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Tue Nov 22 09:00:04 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					tokenOffset:
>04a8							.fill 	1
.04a9					tokenLineNumber:
>04a9							.fill 	2
.04ab					tokenBuffer:
>04ab							.fill 	253
.05a8					lineBuffer:
>05a8							.fill 	MaxLineSize+1
.05f9					numberBuffer:
>05f9							.fill 	34
.061b					decimalBuffer:
>061b							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_LET                              = $bc; $bc LET
=$bd					KWD_LINE                             = $bd; $bd LINE
=$be					KWD_LOCAL                            = $be; $be LOCAL
=$bf					KWD_OFF                              = $bf; $bf OFF
=$c0					KWD_ON                               = $c0; $c0 ON
=$c1					KWD_OUTLINE                          = $c1; $c1 OUTLINE
=$c2					KWD_PALETTE                          = $c2; $c2 PALETTE
=$c3					KWD_PLOT                             = $c3; $c3 PLOT
=$c4					KWD_PRINT                            = $c4; $c4 PRINT
=$c5					KWD_READ                             = $c5; $c5 READ
=$c6					KWD_RECT                             = $c6; $c6 RECT
=$c7					KWD_REM                              = $c7; $c7 REM
=$c8					KWD_RETURN                           = $c8; $c8 RETURN
=$c9					KWD_SOLID                            = $c9; $c9 SOLID
=$ca					KWD_SOUND                            = $ca; $ca SOUND
=$cb					KWD_SPRITE                           = $cb; $cb SPRITE
=$cc					KWD_TEXT                             = $cc; $cc TEXT
=$cd					KWD_TO                               = $cd; $cd TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 36 aa	jsr $aa36			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 be 8d	jsr $8dbe			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 50 b9	jsr $b950			jsr 	SNDCommand
.8019	20 4f 88	jsr $884f			jsr 	NewProgram 					; erase current program
.801c	20 e4 82	jsr $82e4			jsr 	BackloadProgram
.801f	4c 54 83	jmp $8354			jmp 	WarmStart
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 54 75			.text "Built Tuesday 22-Nov-2022. Build 3494."
>804b	65 73 64 61 79 20 32 32 2d 4e 6f 76 2d 32 30 32
>805b	32 2e 20 42 75 69 6c 64 20 33 34 39 34 2e

;******  Return to file: ./common/aa.system/00start.asm

>8069	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806c					AssembleGroup1:
.806c	a9 ff		lda #$ff			lda 	#$FF
.806e	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8071	80 02		bra $8075			bra 	AsmGroup12
.8073					AssembleGroup2:
.8073	a9 00		lda #$00			lda 	#$00
.8075					AsmGroup12:
.8075	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.8078	68		pla				pla 								; pop the return address to access the information following.
.8079	fa		plx				plx
.807a	20 03 81	jsr $8103			jsr 	AccessParameters 			; get opcode and save as base
.807d	8d a4 04	sta $04a4			sta 	BaseOpcode
.8080	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8083	d0 08		bne $808d			bne 	_AG12HaveMask
.8085	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8087	20 0b 81	jsr $810b			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.808a	8d a5 04	sta $04a5			sta 	ModeMask
.808d					_AG12HaveMask:
.808d	20 46 82	jsr $8246			jsr 	TypeAndCalculateOperand 	; get zero page type
.8090	da		phx				phx 								; save found address mode
.8091	20 6f 81	jsr $816f			jsr 	AssembleModeX
.8094	fa		plx				plx  								; restore address mode
.8095	b0 0b		bcs $80a2			bcs 	_AG12Exit
.8097	20 a3 80	jsr $80a3			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.809a	20 6f 81	jsr $816f			jsr 	AssembleModeX
.809d	b0 03		bcs $80a2			bcs 	_AG12Exit
.809f	4c b2 9f	jmp $9fb2			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a2					_AG12Exit:
.80a2	60		rts				rts
.80a3					PromoteToAbsolute:
.80a3	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a5	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a7	f0 19		beq $80c2			beq 	_PTADo
.80a9	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80ab	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80ad	f0 13		beq $80c2			beq 	_PTADo
.80af	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b1	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b3	f0 0d		beq $80c2			beq 	_PTADo
.80b5	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b7	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b9	f0 07		beq $80c2			beq 	_PTADo
.80bb	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bd	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80bf	f0 01		beq $80c2			beq 	_PTADo
.80c1	60		rts				rts
.80c2					_PTADo:
.80c2	aa		tax				tax
.80c3	60		rts				rts
.80c4					AssembleGroup3:
.80c4	68		pla				pla 								; get parameters, which is just the opcode.
.80c5	fa		plx				plx
.80c6	20 03 81	jsr $8103			jsr 	AccessParameters 			; get and output opcode
.80c9	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.80cc	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get a 16 bit operand
.80cf	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d2	38		sec				sec
.80d3	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d6	48		pha				pha 								; LSB in A
.80d7	ad 10 04	lda $0410			lda 	NSMantissa1
.80da	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80dd	aa		tax				tax 								; MSB in X
.80de	68		pla				pla
.80df	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80e0	69 7f		adc #$7f			adc 	#$7F
.80e2	90 01		bcc $80e5			bcc 	_AG3NoCarry
.80e4	e8		inx				inx
.80e5					_AG3NoCarry:
.80e5	38		sec				sec 								; fix back and write out anyways.
.80e6	e9 80		sbc #$80			sbc 	#$80
.80e8	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.80eb	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ed	f0 0a		beq $80f9			beq 	_AG3Exit
.80ef	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f2	29 01		and #$01			and 	#1
.80f4	f0 03		beq $80f9			beq 	_AG3Exit
.80f6	4c b7 9f	jmp $9fb7			jmp 	RangeError 					; no, branch is out of range
.80f9					_AG3Exit:
.80f9	60		rts				rts
.80fa					AssembleGroup4:
.80fa	68		pla				pla 								; pop address
.80fb	fa		plx				plx
.80fc	20 03 81	jsr $8103			jsr 	AccessParameters 			; access and get first
.80ff	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte 			; output it.
.8102	60		rts				rts
.8103					AccessParameters:
.8103	8d a1 04	sta $04a1			sta 	ParamStart
.8106	8e a2 04	stx $04a2			stx 	ParamStart+1
.8109	a9 01		lda #$01			lda 	#1
.810b					GetParameter:
.810b	5a		phy				phy
.810c	a8		tay				tay
.810d	ad a1 04	lda $04a1			lda 	ParamStart
.8110	85 36		sta $36				sta 	zTemp0
.8112	ad a2 04	lda $04a2			lda 	ParamStart+1
.8115	85 37		sta $37				sta 	zTemp0+1
.8117	b1 36		lda ($36),y			lda 	(zTemp0),y
.8119	7a		ply				ply
.811a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811b					AssemblerWriteByte:
.811b	48		pha			pha
.811c	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.811f	29 02		and #$02		and 	#2
.8121	f0 1b		beq $813e		beq 	_AWBNoPrint
.8123	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8126	20 59 81	jsr $8159		jsr 	PrintHex
.8129	ad 9e 04	lda $049e		lda		AssemblerAddress
.812c	20 59 81	jsr $8159		jsr 	PrintHex
.812f	a9 20		lda #$20		lda 	#' '
.8131	20 c2 a7	jsr $a7c2		jsr 	EXTPrintCharacter
.8134	68		pla			pla 									; print byte
.8135	48		pha			pha
.8136	20 59 81	jsr $8159		jsr 	PrintHex
.8139	a9 0d		lda #$0d		lda 	#13
.813b	20 c2 a7	jsr $a7c2		jsr 	EXTPrintCharacter
.813e					_AWBNoPrint:
.813e	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8141	85 36		sta $36			sta 	zTemp0
.8143	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8146	f0 0e		beq $8156		beq 	_AWBRange
.8148	85 37		sta $37			sta 	zTemp0+1
.814a	68		pla			pla 									; write byte out
.814b	92 36		sta ($36)		sta 	(zTemp0)
.814d	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.8150	d0 03		bne $8155		bne 	_AWBNoCarry
.8152	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8155					_AWBNoCarry:
.8155	60		rts			rts
.8156					_AWBRange:
.8156	4c b7 9f	jmp $9fb7		jmp 	RangeError
.8159					PrintHex:
.8159	48		pha				pha
.815a	4a		lsr a				lsr 	a
.815b	4a		lsr a				lsr 	a
.815c	4a		lsr a				lsr 	a
.815d	4a		lsr a				lsr 	a
.815e	20 62 81	jsr $8162			jsr 	_PrintNibble
.8161	68		pla				pla
.8162					_PrintNibble:
.8162	29 0f		and #$0f			and 	#15
.8164	c9 0a		cmp #$0a			cmp 	#10
.8166	90 02		bcc $816a			bcc 	_NoShift
.8168	69 06		adc #$06			adc 	#6
.816a					_NoShift:
.816a	69 30		adc #$30			adc 	#48
.816c	4c c2 a7	jmp $a7c2			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.816f					AssembleModeX:
.816f	5a		phy				phy
.8170	ad a3 04	lda $04a3			lda 	IsGroup1
.8173	f0 17		beq $818c			beq 	_AMXGroup2
.8175	8a		txa				txa 							; is it in group # 1
.8176	29 40		and #$40			and 	#AM_ISG1
.8178	f0 50		beq $81ca			beq 	_AMXFail 				; no, give up.
.817a	8a		txa				txa 							; get back.
.817b	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817d	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.817f	d0 22		bne $81a3			bne 	_AMXHaveInfo
.8181	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8184	c9 81		cmp #$81			cmp 	#$81
.8186	f0 42		beq $81ca			beq 	_AMXFail
.8188	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.818a	80 17		bra $81a3			bra 	_AMXHaveInfo 			; odd design decision there.
.818c					_AMXGroup2:
.818c	8a		txa				txa 							; is it in group 2 ?
.818d	29 20		and #$20			and 	#AM_ISG2
.818f	f0 39		beq $81ca			beq 	_AMXFail 				; no, give up.
.8191	8a		txa				txa 							; get the offset into Y
.8192	29 1f		and #$1f			and 	#$1F
.8194	4a		lsr a				lsr 	a 						; make it 0-7.
.8195	4a		lsr a				lsr  	a
.8196	a8		tay				tay
.8197	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.819a					_AMXCheckOkay:
.819a	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819b	88		dey				dey
.819c	10 fc		bpl $819a			bpl 	_AMXCheckOkay
.819e	90 2a		bcc $81ca			bcc 	_AMXFail 				; not allowed.
.81a0	8a		txa				txa  							; get mask back
.81a1	29 1f		and #$1f			and 	#$1F
.81a3					_AMXHaveInfo:
.81a3	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a5	10 05		bpl $81ac			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a7	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81aa	d0 1e		bne $81ca			bne 	_AMXFail
.81ac					_AMXAnySize:
.81ac	18		clc				clc 							; add offset to the base opcode
.81ad	6d a4 04	adc $04a4			adc 	BaseOpcode
.81b0					_AMXOutputCode:
.81b0	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b3	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b5	f0 10		beq $81c7			beq 	_AMXExit
.81b7	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81ba	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.81bd	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81bf	30 06		bmi $81c7			bmi 	_AMXExit
.81c1	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c4	20 1b 81	jsr $811b			jsr 	AssemblerWriteByte
.81c7					_AMXExit:
.81c7	7a		ply				ply
.81c8	38		sec				sec
.81c9	60		rts				rts
.81ca					_AMXFail:
.81ca	a0 00		ldy #$00			ldy 	#0
.81cc					_AMXCheckOddities:
.81cc	8a		txa				txa
.81cd	d9 f5 81	cmp $81f5,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d0	d0 16		bne $81e8			bne 	_AMXCONext
.81d2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d5	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81d8	d0 0e		bne $81e8			bne 	_AMXCONext
.81da	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81dc	10 05		bpl $81e3			bpl 	_AMXCONotZero
.81de	ad 10 04	lda $0410			lda 	NSMantissa1
.81e1	d0 05		bne $81e8			bne 	_AMXCONext
.81e3					_AMXCONotZero:
.81e3	b9 f4 81	lda $81f4,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e6	80 c8		bra $81b0			bra 	_AMXOutputCode 			; and assemble it
.81e8					_AMXCONext:
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	c8		iny				iny
.81eb	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+0,y 		; end of table
.81ee	d0 dc		bne $81cc			bne 	_AMXCheckOddities
.81f0					_AMXCOFail:
.81f0	7a		ply				ply
.81f1	18		clc				clc
.81f2	60		rts				rts
.81f3					ExtraOpcode:
>81f3	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f6	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f9	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fc	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81ff	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8202	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8205	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8208	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820b	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820e	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8211	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8212					LabelHere:
.8212	c8		iny				iny 								; skip .
.8213	a2 00		ldx #$00			ldx 	#0 							; get a term
.8215	20 ee 97	jsr $97ee			jsr 	EvaluateTerm 				; get a term
.8218	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821b	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821d	d0 24		bne $8243			bne 	_ALType
.821f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8222	85 36		sta $36				sta 	zTemp0
.8224	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8227	85 37		sta $37				sta 	zTemp0+1
.8229	5a		phy				phy 								; copy address in.
.822a	a0 01		ldy #$01			ldy 	#1
.822c	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.822f	92 36		sta ($36)			sta 	(zTemp0)
.8231	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8234	91 36		sta ($36),y			sta 	(zTemp0),y
.8236	c8		iny				iny
.8237	a9 00		lda #$00			lda 	#0
.8239	91 36		sta ($36),y			sta 	(zTemp0),y
.823b	c8		iny				iny
.823c	91 36		sta ($36),y			sta 	(zTemp0),y
.823e	c8		iny				iny
.823f	91 36		sta ($36),y			sta 	(zTemp0),y
.8241	7a		ply				ply
.8242	60		rts				rts
.8243					_ALType:
.8243	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8246					TypeAndCalculateOperand:
.8246	b1 30		lda ($30),y			lda 	(codePtr),y
.8248	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.824a	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824c	f0 5b		beq $82a9			beq 	_TACOExit
.824e	c9 80		cmp #$80			cmp 	#KWC_EOL
.8250	f0 57		beq $82a9			beq 	_TACOExit
.8252	c8		iny				iny
.8253	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8255	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8257	f0 51		beq $82aa			beq 	CalculateOperand
.8259	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825b	f0 1f		beq $827c			beq 	_TACOIndirect
.825d	88		dey				dey 								; undo get of first character
.825e	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get operand
.8261	b1 30		lda ($30),y			lda 	(codePtr),y
.8263	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8265	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8267	d0 40		bne $82a9			bne 	_TACOExit
.8269	c8		iny				iny
.826a	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826d	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826f	c9 58		cmp #$58			cmp 	#'X'
.8271	f0 36		beq $82a9			beq 	_TACOExit
.8273	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8275	c9 59		cmp #$59			cmp 	#'Y'
.8277	f0 30		beq $82a9			beq 	_TACOExit
.8279					_TACOSyntax:
.8279	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.827c					_TACOIndirect:
.827c	20 aa 82	jsr $82aa			jsr 	CalculateOperand 			; get the operand
.827f	b1 30		lda ($30),y			lda 	(codePtr),y
.8281	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8283	f0 17		beq $829c			beq 	_TACOIndX
.8285	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8288	b1 30		lda ($30),y			lda 	(codePtr),y
.828a	a2 d1		ldx #$d1			ldx 	#AM_IND
.828c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828e	d0 19		bne $82a9			bne 	_TACOExit
.8290	c8		iny				iny
.8291	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8294	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8296	d0 e1		bne $8279			bne 	_TACOSyntax
.8298	a2 d0		ldx #$d0			ldx 	#AM_INDY
.829a	80 0d		bra $82a9			bra 	_TACOExit
.829c					_TACOIndX:
.829c	c8		iny				iny
.829d	20 b4 82	jsr $82b4			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82a0	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a2	d0 d5		bne $8279			bne 	_TACOSyntax
.82a4	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket			; check )
.82a7	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a9					_TACOExit:
.82a9	60		rts				rts
.82aa					CalculateOperand:
.82aa	48		pha				pha
.82ab	da		phx				phx
.82ac	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ae	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.82b1	fa		plx				plx
.82b2	68		pla				pla
.82b3	60		rts				rts
.82b4					TACOCheckXY:
.82b4	b1 30		lda ($30),y			lda 	(codePtr),y
.82b6	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b8	c9 40		cmp #$40			cmp 	#$40
.82ba	d0 21		bne $82dd			bne 	_TCXYFail
.82bc	b1 30		lda ($30),y			lda 	(codePtr),y
.82be	18		clc				clc
.82bf	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c1	85 37		sta $37				sta 	zTemp0+1
.82c3	c8		iny				iny
.82c4	b1 30		lda ($30),y			lda 	(codePtr),y
.82c6	c8		iny				iny
.82c7	85 36		sta $36				sta 	zTemp0
.82c9	5a		phy				phy 								; save position
.82ca	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cc	b1 36		lda ($36),y			lda 	(zTemp0),y
.82ce	d0 0c		bne $82dc			bne 	_TCXYPopFail
.82d0	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d2	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d4	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d6	f0 08		beq $82e0			beq 	_TCXYFound
.82d8	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82da	f0 04		beq $82e0			beq 	_TCXYFound
.82dc					_TCXYPopFail:
.82dc	7a		ply				ply
.82dd					_TCXYFail:
.82dd	a9 00		lda #$00			lda 	#0
.82df	60		rts				rts
.82e0					_TCXYFound:
.82e0	7a		ply				ply 								; restore position
.82e1	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e4					BackloadProgram:
.82e4	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e6	8d 2b 06	sta $062b			sta 	0+BackLoadPointer
.82e9	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82eb	8d 2c 06	sta $062c			sta 	1+BackLoadPointer
.82ee					_BPLoop:
.82ee	a2 ff		ldx #$ff			ldx 	#$FF
.82f0	20 18 83	jsr $8318			jsr 	BLReadByte
.82f3	30 1f		bmi $8314			bmi 	_BPExit
.82f5					_BPCopy:
.82f5	e8		inx				inx  								; copy byte in
.82f6	9d a8 05	sta $05a8,x			sta 	lineBuffer,x
.82f9	9e a9 05	stz $05a9,x			stz 	lineBuffer+1,x
.82fc	20 18 83	jsr $8318			jsr 	BLReadByte 					; read next byte
.82ff	30 0a		bmi $830b			bmi 	_BPEndLine 					; -ve = EOL
.8301	c9 09		cmp #$09			cmp 	#9 							; handle TAB
.8303	d0 02		bne $8307			bne 	_BPNotTab
.8305	a9 20		lda #$20			lda 	#' '
.8307					_BPNotTab:
.8307	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8309	b0 ea		bcs $82f5			bcs 	_BPCopy
.830b					_BPEndLine:
.830b	20 e0 b5	jsr $b5e0			jsr 	TokeniseLine 				; tokenise the line.
.830e	38		sec				sec 								; append not insert
.830f	20 1a a5	jsr $a51a			jsr 	MemoryInsertLine 			; append to current program
.8312	80 da		bra $82ee			bra 	_BPLoop
.8314					_BPExit:
.8314	20 ed 83	jsr $83ed			jsr 	ClearCommand 				; clear variables etc.
.8317	60		rts				rts
.8318					BLReadByte:
.8318	ad 2b 06	lda $062b			lda 	BackLoadPointer
.831b	85 36		sta $36				sta 	zTemp0
.831d	ad 2c 06	lda $062c			lda 	BackLoadPointer+1
.8320	85 37		sta $37				sta 	zTemp0+1
.8322	b2 36		lda ($36)			lda 	(zTemp0)
.8324	ee 2b 06	inc $062b			inc 	BackLoadPointer
.8327	d0 03		bne $832c			bne 	_BLNoCarry
.8329	ee 2c 06	inc $062c			inc 	BackLoadPointer+1
.832c					_BLNoCarry:
.832c	c9 00		cmp #$00			cmp 	#0
.832e	60		rts				rts
.062b					BackLoadPointer:
>062b							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.832f					EditProgramCode:
.832f	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line.
.8332	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1
.8335	20 c2 a5	jsr $a5c2			jsr 	MemorySearch
.8338	90 05		bcc $833f			bcc 	_EPCNoDelete 				; reached the end don't delete
.833a	d0 03		bne $833f			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.833c	20 e3 a4	jsr $a4e3			jsr 	MemoryDeleteLine 			; delete the line
.833f					_EPCNoDelete:
.833f	ad ab 04	lda $04ab			lda 	TokenBuffer 				; buffer empty
.8342	c9 80		cmp #$80			cmp 	#KWC_EOL
.8344	f0 0d		beq $8353			beq 	_EPCNoInsert
.8346	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line - it cannot exist.
.8349	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.834c	20 c2 a5	jsr $a5c2			jsr 	MemorySearch
.834f	18		clc				clc 								; insert at this point.
.8350	20 1a a5	jsr $a51a			jsr 	MemoryInsertLine 			; insert the line
.8353					_EPCNoInsert:
.8353	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8354					WarmStart:
.8354	a2 ff		ldx #$ff			ldx 	#$FF
.8356	9a		txs				txs
.8357	20 50 a9	jsr $a950			jsr 	EXTInputLine 				; get line to lineBuffer
.835a	20 e0 b5	jsr $b5e0			jsr 	TokeniseLine 				; tokenise the line
.835d	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; line number ?
.8360	0d aa 04	ora $04aa			ora 	TokenLineNumber+1
.8363	d0 17		bne $837c			bne 	_WSEditCode 				; if so,edit code.
.8365	9c a8 04	stz $04a8			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.8368	a9 a8		lda #$a8			lda 	#((TokenOffset) & $FF)
.836a	85 30		sta $30				sta 	codePtr
.836c	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.836e	85 31		sta $31				sta 	codePtr+1
.8370	ad ab 04	lda $04ab			lda 	TokenBuffer 				; nothing to run
.8373	c9 80		cmp #$80			cmp 	#KWC_EOL
.8375	f0 dd		beq $8354			beq 	WarmStart
.8377	20 0d 8a	jsr $8a0d			jsr 	RUNCodePointerLine 			; execute that line.
.837a	80 d8		bra $8354			bra 	WarmStart
.837c					_WSEditCode:
.837c	20 2f 83	jsr $832f			jsr 	EditProgramCode
.837f	20 ed 83	jsr $83ed			jsr 	ClearCommand
.8382	80 d0		bra $8354			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8384					AssembleCommand:
.8384	a2 00		ldx #$00			ldx 	#0
.8386	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; start address
.8389	ad 08 04	lda $0408			lda 	NSMantissa0
.838c	8d 9e 04	sta $049e			sta 	AssemblerAddress
.838f	ad 10 04	lda $0410			lda 	NSMantissa1
.8392	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.8395	20 54 8d	jsr $8d54			jsr 	CheckComma
.8398	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; options
.839b	ad 08 04	lda $0408			lda 	NSMantissa0
.839e	8d a0 04	sta $04a0			sta 	AssemblerControl
.83a1	60		rts				rts
.83a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83a3					AssertCommand:
.83a3	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83a5	20 74 9d	jsr $9d74			jsr 	EvaluateInteger 			; the assert test
.83a8	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; exit if result is non zero.
.83ab	d0 05		bne $83b2			bne 	_ACExit
.83ad	a9 0a		lda #$0a		lda	#10
.83af	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.83b2					_ACExit:
.83b2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83b3					CallCommand:
.83b3	a2 00		ldx #$00			ldx 	#0
.83b5	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.83b8					_CCClear
.83b8	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83b9	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.83bc	e0 04		cpx #$04			cpx 	#4
.83be	d0 f8		bne $83b8			bne 	_CCClear
.83c0	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83c2					_CCCParam:
.83c2	b1 30		lda ($30),y			lda 	(codePtr),y
.83c4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83c6	d0 09		bne $83d1			bne 	_CCCRun6502
.83c8	c8		iny				iny 								; skip comma
.83c9	e8		inx				inx	 								; next level
.83ca	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83cd	e0 03		cpx #$03			cpx 	#3
.83cf	90 f1		bcc $83c2			bcc 	_CCCParam 					; done all 3 ?
.83d1					_CCCRun6502:
.83d1	5a		phy				phy 								; save position
.83d2	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83d5	85 37		sta $37				sta 	zTemp0+1
.83d7	ad 08 04	lda $0408			lda 	NSMantissa0
.83da	85 36		sta $36				sta 	zTemp0
.83dc	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83df	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83e2	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83e5	20 ea 83	jsr $83ea			jsr 	_CCCZTemp0 					; call zTemp0
.83e8	7a		ply				ply 								; restore position and exit
.83e9	60		rts				rts
.83ea					_CCCZTemp0:
.83ea	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83ed					ClearCommand:
.83ed	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83ef	85 36		sta $36				sta 	0+zTemp0
.83f1	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f3	85 37		sta $37				sta 	1+zTemp0
.83f5					_ClearZeroLoop:
.83f5	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables
.83f7	f0 24		beq $841d			beq 	_ClearZeroEnd
.83f9	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83fb	a9 00		lda #$00			lda 	#0
.83fd					_ClearOneVariable:
.83fd	91 36		sta ($36),y			sta 	(zTemp0),y
.83ff	c8		iny				iny
.8400	c0 08		cpy #$08			cpy 	#8
.8402	d0 f9		bne $83fd			bne 	_ClearOneVariable
.8404	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8406	b1 36		lda ($36),y			lda 	(zTemp0),y
.8408	c9 18		cmp #$18			cmp 	#NSTProcedure
.840a	d0 04		bne $8410			bne 	_ClearNotProcedure
.840c	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; set it back to an integer array
.840e	91 36		sta ($36),y			sta 	(zTemp0),y
.8410					_ClearNotProcedure:
.8410	18		clc				clc 								; go to the next variable
.8411	b2 36		lda ($36)			lda 	(zTemp0)
.8413	65 36		adc $36				adc 	zTemp0
.8415	85 36		sta $36				sta 	zTemp0
.8417	90 dc		bcc $83f5			bcc 	_ClearZeroLoop
.8419	e6 37		inc $37				inc 	zTemp0+1
.841b	80 d8		bra $83f5			bra 	_ClearZeroLoop
.841d					_ClearZeroEnd:
.841d	18		clc				clc
.841e	a5 36		lda $36				lda 	zTemp0
.8420	69 01		adc #$01			adc 	#1
.8422	8d 8c 04	sta $048c			sta 	lowMemPtr
.8425	a5 37		lda $37				lda 	zTemp0+1
.8427	69 00		adc #$00			adc 	#0
.8429	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.842c	20 e7 a6	jsr $a6e7			jsr 	StackReset
.842f	20 51 a7	jsr $a751			jsr 	StringSystemInitialise
.8432	20 55 8c	jsr $8c55			jsr 	ProcedureScan
.8435	20 bc 89	jsr $89bc			jsr 	Command_Restore
.8438	9c 9e 04	stz $049e			stz 	AssemblerAddress
.843b	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.843e	9c a0 04	stz $04a0			stz 	AssemblerControl
.8441	20 f1 99	jsr $99f1			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8444	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8445					ClearScreen:
.8445	5a		phy				phy
.8446	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8448	20 c2 a7	jsr $a7c2			jsr 	EXTPrintCharacter
.844b	7a		ply				ply
.844c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.844d					Command_Data:
.844d	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.844f	a2 80		ldx #$80			ldx 	#KWC_EOL
.8451	20 a7 8c	jsr $8ca7			jsr 	ScanForward
.8454	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8455					DimCommand:
.8455	b1 30		lda ($30),y			lda 	(codePtr),y
.8457	29 c0		and #$c0			and 	#$C0
.8459	c9 40		cmp #$40			cmp 	#$40
.845b	d0 7a		bne $84d7			bne 	_DCSyntax
.845d	b1 30		lda ($30),y			lda 	(codePtr),y
.845f	18		clc				clc
.8460	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8462	85 3f		sta $3f				sta 	zaTemp+1
.8464	c8		iny				iny
.8465	b1 30		lda ($30),y			lda 	(codePtr),y
.8467	c8		iny				iny
.8468	85 3e		sta $3e				sta 	zaTemp
.846a	5a		phy				phy
.846b	a0 02		ldy #$02			ldy 	#2 						; read type byte
.846d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.846f	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8471	c9 18		cmp #$18			cmp 	#NSTProcedure
.8473	f0 62		beq $84d7			beq 	_DCSyntax
.8475	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8477	29 04		and #$04			and 	#NSBIsArray
.8479	f0 64		beq $84df			beq 	_DCType
.847b	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.847d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.847f	d0 59		bne $84da			bne 	_DCRedefine
.8481	7a		ply				ply
.8482	20 e2 84	jsr $84e2			jsr 	_DCGetSize 				; get array size, check it.
.8485	5a		phy				phy
.8486	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8488	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.848a	7a		ply				ply 							; is there a second (e.g. ,x)
.848b	b1 30		lda ($30),y			lda 	(codePtr),y
.848d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.848f	d0 0a		bne $849b			bne 	_DCOneDimension
.8491	c8		iny				iny 							; skip comma
.8492	20 e2 84	jsr $84e2			jsr 	_DCGetSize 				; get 2nd array size
.8495	5a		phy				phy
.8496	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8498	91 3e		sta ($3e),y			sta 	(zaTemp),y
.849a	7a		ply				ply
.849b					_DCOneDimension:
.849b	5a		phy				phy 							; save position
.849c	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.849e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a0	aa		tax				tax
.84a1	c8		iny				iny
.84a2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a4	e8		inx				inx 							; bump them.
.84a5	1a		inc a				inc 	a
.84a6	20 bd 9d	jsr $9dbd			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84a9	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84ab	29 e0		and #$e0			and 	#$E0
.84ad	d0 23		bne $84d2			bne 	_DCSize
.84af	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b3	20 f0 84	jsr $84f0			jsr 	ScaleByBaseType 		; scale by base type
.84b6	a5 36		lda $36				lda 	zTemp0
.84b8	a6 37		ldx $37				ldx 	zTemp0+1
.84ba	20 b3 99	jsr $99b3			jsr 	AllocateXABytes 		; allocate memory
.84bd	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84bf	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c1	c8		iny				iny
.84c2	8a		txa				txa
.84c3	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c5	7a		ply				ply 							; get position back
.84c6	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 		; check )
.84c9	b1 30		lda ($30),y			lda 	(codePtr),y
.84cb	c8		iny				iny 							; consume in case
.84cc	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84ce	f0 85		beq $8455			beq 	DimCommand
.84d0	88		dey				dey 							; undo consume
.84d1	60		rts				rts
.84d2					_DCSize:
.84d2	a9 16		lda #$16		lda	#22
.84d4	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.84d7					_DCSyntax:
.84d7	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.84da					_DCRedefine:
.84da	a9 15		lda #$15		lda	#21
.84dc	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.84df					_DCType:
.84df	4c bc 9f	jmp $9fbc			jmp 	TypeError
.84e2					_DCGetSize:
.84e2	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84e4	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 	; get array dimension
.84e7	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84e9	f0 e7		beq $84d2			beq 	_DCSize
.84eb	c9 fe		cmp #$fe			cmp 	#254
.84ed	f0 e3		beq $84d2			beq 	_DCSize
.84ef	60		rts				rts
.84f0					ScaleByBaseType:
.84f0	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f2	d0 19		bne $850d			bne 	_SBBTString
.84f4	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84f6	48		pha				pha
.84f7	a5 36		lda $36				lda 	zTemp0
.84f9	48		pha				pha
.84fa	06 36		asl $36				asl 	zTemp0 					; x 2
.84fc	26 37		rol $37				rol 	zTemp0+1
.84fe	06 36		asl $36				asl 	zTemp0 					; x 4
.8500	26 37		rol $37				rol 	zTemp0+1
.8502	68		pla				pla 							; add stacked value = x 5
.8503	65 36		adc $36				adc 	zTemp0
.8505	85 36		sta $36				sta 	zTemp0
.8507	68		pla				pla
.8508	65 37		adc $37				adc 	zTemp0+1
.850a	85 37		sta $37				sta 	zTemp0+1
.850c	60		rts				rts
.850d					_SBBTString:
.850d	06 36		asl $36				asl 	zTemp0
.850f	26 37		rol $37				rol 	zTemp0+1
.8511	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8512					EndCommand:
.8512	4c 54 83	jmp $8354			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8515					ForCommand:
.8515	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.8517	20 82 a6	jsr $a682			jsr 	StackOpen
.851a	a2 00		ldx #$00			ldx 	#0
.851c	20 ee 97	jsr $97ee			jsr 	EvaluateTerm
.851f	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8522	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8524	d0 49		bne $856f			bne		_FCError
.8526	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8528	20 5c 8d	jsr $8d5c			jsr 	CheckNextA
.852b	e8		inx				inx
.852c	20 74 9d	jsr $9d74			jsr 	EvaluateInteger 			; <from> in +1
.852f	b1 30		lda ($30),y			lda 	(codePtr),y
.8531	c8		iny				iny 								; consume it
.8532	48		pha				pha 								; save on stack for later
.8533	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8535	f0 04		beq $853b			beq 	_FCNoSyntax
.8537	c9 cd		cmp #$cd			cmp 	#KWD_TO
.8539	d0 37		bne $8572			bne 	_FCSyntaxError
.853b					_FCNoSyntax:
.853b	e8		inx				inx
.853c	20 74 9d	jsr $9d74			jsr 	EvaluateInteger
.853f	20 c6 a6	jsr $a6c6			jsr 	STKSaveCodePosition 		; save loop back position
.8542	68		pla				pla 								; restore DOWNTO or TO
.8543	5a		phy				phy 								; save Y on the stack
.8544	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8546	f0 02		beq $854a			beq 	_FCNotDownTo
.8548	a9 02		lda #$02			lda 	#2
.854a					_FCNotDownTo:
.854a	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.854b	a0 10		ldy #$10			ldy 	#16
.854d	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.854f	a0 06		ldy #$06			ldy 	#6
.8551	ad 08 04	lda $0408			lda 	NSMantissa0
.8554	91 34		sta ($34),y			sta 	(basicStack),y
.8556	ad 10 04	lda $0410			lda 	NSMantissa1
.8559	c8		iny				iny
.855a	91 34		sta ($34),y			sta 	(basicStack),y
.855c	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.855e	a2 01		ldx #$01			ldx 	#1
.8560	20 75 85	jsr $8575			jsr 	FCIntegerToStack
.8563	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8565	a2 02		ldx #$02			ldx 	#2
.8567	20 75 85	jsr $8575			jsr 	FCIntegerToStack
.856a	20 95 85	jsr $8595			jsr 	CopyIndexToReference
.856d	7a		ply				ply 								; restore position
.856e	60		rts				rts
.856f					_FCError:
.856f	4c bc 9f	jmp $9fbc			jmp 	TypeError
.8572					_FCSyntaxError:
.8572	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.8575					FCIntegerToStack:
.8575	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.8578	10 03		bpl $857d			bpl	 	_FCNotNegative
.857a	20 dd 9d	jsr $9ddd			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.857d					_FCNotNegative:
.857d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8580	91 34		sta ($34),y			sta 	(basicStack),y
.8582	c8		iny				iny
.8583	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8586	91 34		sta ($34),y			sta 	(basicStack),y
.8588	c8		iny				iny
.8589	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.858c	91 34		sta ($34),y			sta 	(basicStack),y
.858e	c8		iny				iny
.858f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.8592	91 34		sta ($34),y			sta 	(basicStack),y
.8594	60		rts				rts
.8595					CopyIndexToReference:
.8595	5a		phy				phy
.8596	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8598	38		sec				sec 								; (because we copy from offset 8)
.8599	b1 34		lda ($34),y			lda 	(basicStack),y
.859b	e9 08		sbc #$08			sbc 	#8
.859d	85 36		sta $36				sta 	zTemp0
.859f	c8		iny				iny
.85a0	b1 34		lda ($34),y			lda 	(basicStack),y
.85a2	e9 00		sbc #$00			sbc 	#0
.85a4	85 37		sta $37				sta 	zTemp0+1
.85a6	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85a8	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85aa	b1 34		lda ($34),y			lda 	(basicStack),y
.85ac	0a		asl a				asl 	a 							; into carry
.85ad	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85af	90 14		bcc $85c5			bcc 	_CITRNormal
.85b1	38		sec				sec
.85b2					_CITRNegative:
.85b2	a9 00		lda #$00			lda 	#0
.85b4	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85b6	91 36		sta ($36),y			sta 	(zTemp0),y
.85b8	c8		iny				iny
.85b9	ca		dex				dex
.85ba	d0 f6		bne $85b2			bne 	_CITRNegative
.85bc	88		dey				dey 								; look at MSB of mantissa
.85bd	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85bf	09 80		ora #$80			ora 	#$80
.85c1	91 36		sta ($36),y			sta 	(zTemp0),y
.85c3	7a		ply				ply
.85c4	60		rts				rts
.85c5					_CITRNormal:
.85c5	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85c7	91 36		sta ($36),y			sta 	(zTemp0),y
.85c9	c8		iny				iny
.85ca	ca		dex				dex
.85cb	d0 f8		bne $85c5			bne 	_CITRNormal
.85cd	7a		ply				ply 								; and exit.
.85ce	60		rts				rts
.85cf					NextCommand:
.85cf	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85d1	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d3	20 ae a6	jsr $a6ae			jsr 	StackCheckFrame
.85d6	5a		phy				phy
.85d7	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85d9	b1 34		lda ($34),y			lda 	(basicStack),y
.85db	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85dd	30 02		bmi $85e1			bmi 	_NCStepNeg
.85df	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85e1					_NCStepNeg:
.85e1	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e3	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85e5	18		clc				clc
.85e6					_NCBump:
.85e6	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85e8	91 34		sta ($34),y			sta 	(basicStack),y
.85ea	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85ec	c8		iny				iny 								; next byte
.85ed	ca		dex				dex 								; do four times
.85ee	d0 f6		bne $85e6			bne 	_NCBump
.85f0	20 95 85	jsr $8595			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f3	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85f5	b1 34		lda ($34),y			lda 	(basicStack),y
.85f7	0a		asl a				asl 	a 							; sign bit to carry
.85f8	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85fa	85 38		sta $38				sta 	zTemp1
.85fc	90 02		bcc $8600			bcc 	_NCCompRev 					; use if step is +ve
.85fe	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8600					_NCCompRev:
.8600	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8602	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8604	85 39		sta $39				sta 	zTemp1+1
.8606	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8608	38		sec				sec
.8609					_NCCompare:
.8609	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.860b	b1 34		lda ($34),y			lda 	(basicStack),y
.860d	a4 39		ldy $39				ldy 	zTemp1+1
.860f	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8611	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8613	e6 39		inc $39				inc 	zTemp1+1
.8615	ca		dex				dex 								; do it 4 times.
.8616	d0 f1		bne $8609			bne 	_NCCompare
.8618	50 02		bvc $861c			bvc 	_NCNoOverflow 				; convert to signed comparison
.861a	49 80		eor #$80			eor 	#$80
.861c					_NCNoOverflow:
.861c	7a		ply				ply 								; restore Y position
.861d	0a		asl a				asl 	a 							; is bit 7 set.
.861e	90 04		bcc $8624			bcc 	_NCLoopback 				; if no , >= so loop back
.8620	20 a0 a6	jsr $a6a0			jsr 	StackClose 					; exit the loop
.8623	60		rts				rts
.8624					_NCLoopBack:
.8624	20 d7 a6	jsr $a6d7			jsr 	STKLoadCodePosition 		; loop back
.8627	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8628					Command_GOSUB:
.8628	a2 00		ldx #$00			ldx 	#0
.862a	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.862d	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.862f	20 82 a6	jsr $a682			jsr 	StackOpen 					; create frame
.8632	20 c6 a6	jsr $a6c6			jsr 	STKSaveCodePosition 		; save current position
.8635	4c 4b 86	jmp $864b			jmp 	GotoStackX
.8638					Command_RETURN:
.8638	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.863a	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.863c	20 ae a6	jsr $a6ae			jsr 	StackCheckFrame
.863f	20 d7 a6	jsr $a6d7			jsr 	STKLoadCodePosition 		; restore code position
.8642	20 a0 a6	jsr $a6a0			jsr 	StackClose
.8645	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8646					GotoCommand:
.8646	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8648	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.864b					GotoStackX:
.864b	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.864e	48		pha				pha 								; it is slightly inefficient, just in cases.
.864f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8652	fa		plx				plx
.8653	20 c2 a5	jsr $a5c2			jsr 	MemorySearch 				; transfer to line number AX.
.8656	90 05		bcc $865d			bcc 	_GotoError 					; not found, off end.
.8658	d0 03		bne $865d			bne 	_GotoError 					; not found exactly
.865a	4c 06 8a	jmp $8a06			jmp 	RunNewLine 					; and go straight to new line code.
.865d					_GotoError:
.865d	a9 0d		lda #$0d		lda	#13
.865f	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8662					IfCommand:
.8662	a2 00		ldx #$00			ldx 	#0 							; If what.
.8664	20 51 9d	jsr $9d51			jsr 	EvaluateNumber
.8667	b1 30		lda ($30),y			lda 	(codePtr),y
.8669	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.866b	d0 0a		bne $8677			bne 	_IFStructured
.866d	c8		iny				iny 								; consume THEN
.866e	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; is it zero
.8671	f0 01		beq $8674			beq 	_IfFail 					; if fail, go to next line
.8673	60		rts				rts 								; if THEN just continue
.8674					_IfFail:
.8674	4c ee 89	jmp $89ee			jmp 	EOLCommand
.8677					_IfStructured:
.8677	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; is it zero
.867a	d0 07		bne $8683			bne 	_IfExit 					; if not, then continue normally.
.867c	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.867e	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8680	20 a7 8c	jsr $8ca7			jsr 	ScanForward 				; and run from there/
.8683					_IfExit:
.8683	60		rts				rts
.8684					ElseCode:
.8684	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8686	aa		tax				tax 								; so just go to the structure exit
.8687	20 a7 8c	jsr $8ca7			jsr 	ScanForward
.868a	60		rts				rts
.868b					EndIf:
.868b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.868c					LetCommand:
.868c	a2 00		ldx #$00			ldx 	#0
.868e	b1 30		lda ($30),y			lda 	(codePtr),y
.8690	c9 10		cmp #$10			cmp 	#KWD_AT
.8692	d0 16		bne $86aa			bne 	_LCStandard
.8694	c8		iny				iny 								; skip equal
.8695	20 ee 97	jsr $97ee			jsr 	EvaluateTerm 				; get a number
.8698	20 32 96	jsr $9632			jsr 	Dereference 				; dereference it
.869b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.869e	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.86a0	9d 00 04	sta $0400,x			sta 	NSStatus,x
.86a3	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.86a5	d0 10		bne $86b7			bne 	_LCMain
.86a7	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; was a reference before.
.86aa					_LCStandard:
.86aa	ad fc 92	lda $92fc			lda 	PrecedenceLevel+"*"			; precedence > this
.86ad	20 16 93	jsr $9316			jsr 	EvaluateExpressionAtPrecedence
.86b0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.86b3	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.86b5	f0 0e		beq $86c5			beq 	_LetGoProc 					; it's a procedure call.
.86b7					_LCMain:
.86b7	a9 3d		lda #$3d			lda 	#"=" 						; check =
.86b9	20 5c 8d	jsr $8d5c			jsr 	CheckNextA
.86bc	e8		inx				inx 								; RHS
.86bd	20 48 9d	jsr $9d48			jsr 	EvaluateValue
.86c0	ca		dex				dex
.86c1	20 c8 86	jsr $86c8			jsr 	AssignVariable
.86c4	60		rts				rts
.86c5					_LetGoProc:
.86c5	4c c6 88	jmp $88c6			jmp 	CallProcedure
.86c8					AssignVariable:
.86c8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.86cb	48		pha				pha 								; save a copy
.86cc	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.86cf	29 10		and #$10			and 	#NSBIsString
.86d1	d0 0b		bne $86de			bne 	_ASError
.86d3	68		pla				pla 								; get back
.86d4	29 10		and #$10			and 	#NSBIsString 				; check type
.86d6	d0 03		bne $86db			bne 	_ASString
.86d8	4c 5a 95	jmp $955a			jmp 	AssignNumber
.86db					_ASString:
.86db	4c c8 95	jmp $95c8			jmp 	AssignString
.86de					_ASError:
.86de	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.86e1					Command_List:
.86e1	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.86e4	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.86e7	9c 14 04	stz $0414			stz 	NSMantissa1+4
.86ea	a9 ff		lda #$ff			lda 	#$FF
.86ec	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.86ef	8d 17 04	sta $0417			sta 	NSMantissa1+7
.86f2	b1 30		lda ($30),y			lda 	(codePtr),y
.86f4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.86f6	f0 1e		beq $8716			beq 	_CLSecond
.86f8	20 77 87	jsr $8777			jsr 	CLIsDigit 					; if not digit, list all
.86fb	b0 24		bcs $8721			bcs 	_CLStart
.86fd	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.86ff	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.8702	b1 30		lda ($30),y			lda 	(codePtr),y
.8704	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8706	f0 0e		beq $8716			beq 	_CLSecond 					; if so go get it
.8708	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.870b	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.870e	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8711	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8714	80 0b		bra $8721			bra 	_CLStart
.8716					_CLSecond:
.8716	c8		iny				iny 								; consume comma
.8717	20 77 87	jsr $8777			jsr 	CLIsDigit 					; digit found
.871a	b0 05		bcs $8721			bcs 	_CLStart 					; if not, continue listing
.871c	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.871e	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.8721					_CLStart
.8721	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8723	85 30		sta $30				sta 	codePtr
.8725	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8727	85 31		sta $31				sta 	codePtr+1
.8729					_CLLoop:
.8729	20 78 aa	jsr $aa78			jsr 	EXTBreakCheck 				; break check
.872c	f0 33		beq $8761			beq 	_CLExit
.872e	b2 30		lda ($30)			lda 	(codePtr)
.8730	f0 2f		beq $8761			beq 	_CLExit
.8732	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8734	20 64 87	jsr $8764			jsr 	CLCompareLineNo
.8737	90 1b		bcc $8754			bcc 	_CLNext
.8739	a2 07		ldx #$07			ldx 	#7
.873b	20 64 87	jsr $8764			jsr 	CLCompareLineNo
.873e	f0 02		beq $8742			beq 	_CLDoThisOne
.8740	b0 12		bcs $8754			bcs 	_CLNext
.8742					_CLDoThisOne:
.8742	20 0a 8d	jsr $8d0a			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8745	20 c2 b3	jsr $b3c2			jsr 	ListConvertLine 			; convert line into token Buffer
.8748	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.874a	a9 ab		lda #$ab			lda 	#(tokenBuffer & $FF)
.874c	20 be 8d	jsr $8dbe			jsr 	PrintStringXA
.874f	a9 0d		lda #$0d			lda 	#13 						; new line
.8751	20 c2 a7	jsr $a7c2			jsr 	EXTPrintCharacter
.8754					_CLNext:
.8754	18		clc				clc
.8755	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8757	65 30		adc $30				adc 	codePtr
.8759	85 30		sta $30				sta 	codePtr
.875b	90 02		bcc $875f			bcc 	_CREExit
.875d	e6 31		inc $31				inc 	codePtr+1
.875f					_CREExit:
.875f	80 c8		bra $8729			bra 	_CLLoop
.8761					_CLExit:
.8761	4c 54 83	jmp $8354			jmp 	WarmStart
.8764					CLCompareLineNo:
.8764	38		sec				sec
.8765	a0 01		ldy #$01			ldy 	#1
.8767	b1 30		lda ($30),y			lda 	(codePtr),y
.8769	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.876c	85 36		sta $36				sta 	zTemp0
.876e	c8		iny				iny
.876f	b1 30		lda ($30),y			lda 	(codePtr),y
.8771	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8774	05 36		ora $36				ora 	zTemp0
.8776	60		rts				rts
.8777					CLIsDigit:
.8777	b1 30		lda ($30),y			lda 	(codePtr),y
.8779	c9 30		cmp #$30			cmp 	#"0"
.877b	90 03		bcc $8780			bcc	 	_CLIDExitFalse
.877d	c9 3a		cmp #$3a			cmp 	#"9"+1
.877f	60		rts				rts
.8780					_CLIDExitFalse:
.8780	38		sec				sec
.8781	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8782					Command_LOCAL:
.8782	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8784	20 90 87	jsr $8790			jsr 	LocaliseNextTerm 			; convert term to a local.
.8787	b1 30		lda ($30),y			lda 	(codePtr),y
.8789	c8		iny				iny
.878a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.878c	f0 f4		beq $8782			beq 	Command_LOCAL
.878e	88		dey				dey 								; unpick pre-get
.878f	60		rts				rts
.8790					LocaliseNextTerm:
.8790	20 ee 97	jsr $97ee			jsr 	EvaluateTerm 				; evaluate the term
.8793	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8796	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.8798	f0 61		beq $87fb			beq		_LNTError
.879a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.879d	85 36		sta $36				sta 	zTemp0
.879f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87a2	85 37		sta $37				sta  	zTemp0+1
.87a4	bd 00 04	lda $0400,x			lda 	NSStatus,x
.87a7	29 10		and #$10			and 	#NSBIsString
.87a9	d0 1e		bne $87c9			bne 	_LNTPushString
.87ab	5a		phy				phy
.87ac	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.87ae					_LNTPushNumLoop:
.87ae	b1 36		lda ($36),y			lda		(zTemp0),y
.87b0	20 60 a6	jsr $a660			jsr 	StackPushByte
.87b3	c8		iny				iny
.87b4	c0 05		cpy #$05			cpy 	#5
.87b6	d0 f6		bne $87ae			bne 	_LNTPushNumLoop
.87b8	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.87ba	20 60 a6	jsr $a660			jsr 	StackPushByte
.87bd	a5 37		lda $37				lda 	zTemp0+1
.87bf	20 60 a6	jsr $a660			jsr 	StackPushByte
.87c2	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.87c4	20 60 a6	jsr $a660			jsr 	StackPushByte
.87c7	7a		ply				ply
.87c8	60		rts				rts
.87c9					_LNTPushString:
.87c9	5a		phy				phy
.87ca	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.87cc	85 38		sta $38				sta 	zTemp1
.87ce	a0 01		ldy #$01			ldy 	#1
.87d0	b1 36		lda ($36),y			lda 	(zTemp0),y
.87d2	85 39		sta $39				sta 	zTemp1+1
.87d4	a0 00		ldy #$00			ldy 	#0 							; output string
.87d6	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.87d8	f0 0a		beq $87e4			beq 	_LNTStringOut
.87da					_LNTPushStrLoop:
.87da	b1 38		lda ($38),y			lda 	(zTemp1),y
.87dc	f0 06		beq $87e4			beq 	_LNTStringOut
.87de	20 60 a6	jsr $a660			jsr 	StackPushByte
.87e1	c8		iny				iny
.87e2	80 f6		bra $87da			bra 	_LNTPushStrLoop
.87e4					_LNTStringOut:
.87e4	98		tya				tya									; output length
.87e5	20 60 a6	jsr $a660			jsr 	StackPushByte
.87e8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.87eb	20 60 a6	jsr $a660			jsr 	StackPushByte
.87ee	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87f1	20 60 a6	jsr $a660			jsr 	StackPushByte
.87f4	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.87f6	20 60 a6	jsr $a660			jsr 	StackPushByte
.87f9	7a		ply				ply
.87fa	60		rts				rts
.87fb					_LNTError:
.87fb	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.87fe					LocalPopValue:
.87fe	20 79 a6	jsr $a679			jsr 	StackPopByte
.8801	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8803	d0 17		bne $881c			bne 	_LPVString
.8805	20 79 a6	jsr $a679			jsr 	StackPopByte 				; address
.8808	85 37		sta $37				sta 	zTemp0+1
.880a	20 79 a6	jsr $a679			jsr 	StackPopByte
.880d	85 36		sta $36				sta 	zTemp0
.880f	5a		phy				phy
.8810	a0 04		ldy #$04			ldy 	#4 							; copy back
.8812					_LPVNumberCopy:
.8812	20 79 a6	jsr $a679			jsr 	StackPopByte
.8815	91 36		sta ($36),y			sta 	(zTemp0),y
.8817	88		dey				dey
.8818	10 f8		bpl $8812			bpl 	_LPVNumberCopy
.881a	7a		ply				ply 								; and complete
.881b	60		rts				rts
.881c					_LPVString:
.881c	20 79 a6	jsr $a679			jsr 	StackPopByte 				; address of record => zTemp0
.881f	85 37		sta $37				sta 	zTemp0+1
.8821	20 79 a6	jsr $a679			jsr 	StackPopByte
.8824	85 36		sta $36				sta 	zTemp0
.8826	5a		phy				phy
.8827	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8829	85 38		sta $38				sta 	zTemp1
.882b	a0 01		ldy #$01			ldy 	#1
.882d	b1 36		lda ($36),y			lda 	(zTemp0),y
.882f	85 39		sta $39				sta 	zTemp1+1
.8831	20 79 a6	jsr $a679			jsr 	StackPopByte 				; # to get => y
.8834	a8		tay				tay
.8835	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8837	f0 0e		beq $8847			beq 	_LPVStringCopied
.8839	a9 00		lda #$00			lda 	#0 							; NULL on end
.883b	91 38		sta ($38),y			sta 	(zTemp1),y
.883d					_LPVStringCopy:
.883d	88		dey				dey
.883e	30 07		bmi $8847			bmi 	_LPVStringCopied
.8840	20 79 a6	jsr $a679			jsr 	StackPopByte
.8843	91 38		sta ($38),y			sta 	(zTemp1),y
.8845	80 f6		bra $883d			bra 	_LPVStringCopy
.8847					_LPVStringCopied:
.8847	fa		plx				plx
.8848	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8849					NewCommand:
.8849	20 4f 88	jsr $884f			jsr 	NewProgram
.884c	4c 54 83	jmp $8354			jmp 	WarmStart
.884f					NewProgram:
.884f	20 a0 a5	jsr $a5a0			jsr 	MemoryNew
.8852	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8855	20 ed 83	jsr $83ed			jsr 	ClearCommand 				; clear everything.
.8858	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/print.asm

.8859					Command_Print:
.8859	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.885a					_CPLoop:
.885a	08		php				php 								; save last action flag
.885b	b1 30		lda ($30),y			lda 	(codePtr),y
.885d	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.885f	f0 46		beq $88a7			beq 	_CPExit
.8861	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8863	f0 42		beq $88a7			beq 	_CPExit
.8865	68		pla				pla 								; throw last action flag
.8866	b1 30		lda ($30),y			lda 	(codePtr),y
.8868	c8		iny				iny
.8869	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.886b	f0 37		beq $88a4			beq 	_CPContinueWithSameLine
.886d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.886f	f0 2e		beq $889f			beq 	_CPTab
.8871	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8873	f0 26		beq $889b			beq 	_CPNewLine
.8875	88		dey				dey 								; undo the get.
.8876	a2 00		ldx #$00			ldx 	#0
.8878	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get a value into slot 0
.887b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.887e	29 10		and #$10			and 	#NSBIsString
.8880	f0 0b		beq $888d			beq 	_CPNumber
.8882	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.8885	ad 08 04	lda $0408			lda 	NSMantissa0
.8888	20 b0 88	jsr $88b0			jsr 	CPPrintStringXA
.888b	80 cc		bra $8859			bra 	Command_Print 				; loop round clearing carry so NL if end
.888d					_CPNumber:
.888d	a9 05		lda #$05			lda 	#5 							; maximum decimals
.888f	20 1e 9c	jsr $9c1e			jsr 	ConvertNumberToString 		; convert to string
.8892	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8894	a9 1b		lda #$1b			lda 	#DecimalBuffer & $FF
.8896	20 b0 88	jsr $88b0			jsr 	CPPrintStringXA
.8899	80 be		bra $8859			bra 	Command_Print 				; loop round clearing carry so NL if end
.889b					_CPNewLine:
.889b	a9 0d		lda #$0d			lda 	#13
.889d	80 02		bra $88a1			bra 	_CPPrintChar
.889f					_CPTab:
.889f	a9 09		lda #$09			lda 	#9 							; print TAB
.88a1					_CPPrintChar:
.88a1	20 c3 88	jsr $88c3			jsr 	CPPrintVector
.88a4					_CPContinueWithSameLine:
.88a4	38		sec				sec 								; loop round with carry set, which
.88a5	80 b3		bra $885a			bra 	_CPLoop 					; will inhibit final CR
.88a7					_CPExit:
.88a7	28		plp				plp 								; get last action flag
.88a8	b0 05		bcs $88af			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.88aa	a9 0d		lda #$0d			lda 	#13 						; print new line
.88ac	20 c3 88	jsr $88c3			jsr 	CPPrintVector
.88af					_CPExit2:
.88af	60		rts				rts
.88b0					CPPrintStringXA:
.88b0	5a		phy				phy
.88b1	86 37		stx $37				stx 	zTemp0+1
.88b3	85 36		sta $36				sta 	zTemp0
.88b5	a0 00		ldy #$00			ldy 	#0
.88b7					_PSXALoop:
.88b7	b1 36		lda ($36),y			lda 	(zTemp0),y
.88b9	f0 06		beq $88c1			beq 	_PSXAExit
.88bb	20 c3 88	jsr $88c3			jsr 	CPPrintVector
.88be	c8		iny				iny
.88bf	80 f6		bra $88b7			bra 	_PSXALoop
.88c1					_PSXAExit:
.88c1	7a		ply				ply
.88c2	60		rts				rts
.88c3					CPPrintVector:
.88c3	4c c2 a7	jmp $a7c2			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.88c6					CallProcedure:
.88c6	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.88c8	b1 30		lda ($30),y			lda 	(codePtr),y
.88ca	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.88cc	f0 0c		beq $88da			beq 	_CPEndParam
.88ce					_CPParamLoop:
.88ce	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get parameter onto stack
.88d1	e8		inx				inx 								; bump next stack
.88d2	b1 30		lda ($30),y			lda 	(codePtr),y
.88d4	c8		iny				iny
.88d5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.88d7	f0 f5		beq $88ce			beq 	_CPParamLoop
.88d9	88		dey				dey 								; unpick.
.88da					_CPEndParam:
.88da	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.88dd	c8		iny				iny									; skip right bracket
.88de	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.88e0	20 82 a6	jsr $a682			jsr 	StackOpen
.88e3	20 c6 a6	jsr $a6c6			jsr 	STKSaveCodePosition 		; save loop position
.88e6	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.88e9	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.88eb	ad 10 04	lda $0410			lda 	NSMantissa1
.88ee	85 37		sta $37				sta 	zTemp0+1
.88f0	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.88f2	b2 36		lda ($36)			lda 	(zTemp0)
.88f4	85 30		sta $30				sta 	safePtr
.88f6	b1 36		lda ($36),y			lda 	(zTemp0),y
.88f8	85 31		sta $31				sta 	safePtr+1
.88fa	c8		iny				iny
.88fb	b1 36		lda ($36),y			lda 	(zTemp0),y
.88fd	85 32		sta $32				sta 	safePtr+2
.88ff	c8		iny				iny
.8900	b1 36		lda ($36),y			lda 	(zTemp0),y
.8902	85 33		sta $33				sta 	safePtr+3
.8904	c8		iny				iny 								; get Y offset -> Y
.8905	b1 36		lda ($36),y			lda 	(zTemp0),y
.8907	a8		tay				tay
.8908	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.890a	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.890d	f0 13		beq $8922			beq 	_ParamExit 					; if so, exit.
.890f					_ParamExtract:
.890f	ca		dex				dex 								; put a local term on the level before
.8910	20 90 87	jsr $8790			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8913	20 c8 86	jsr $86c8			jsr 	AssignVariable 				; assign stacked value to the variable.
.8916	e8		inx				inx 								; advance to next parameter to do.
.8917	e8		inx				inx
.8918	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.891b	f0 05		beq $8922			beq 	_ParamExit
.891d	20 54 8d	jsr $8d54			jsr 	CheckComma 					; comma seperating parameters
.8920	80 ed		bra $890f			bra 	_ParamExtract
.8922					_ParamExit:
.8922	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; check )
.8925	60		rts				rts 								; and continue from here
.8926					Command_ENDPROC:
.8926	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8928	a2 14		ldx #$14			ldx 	#ERRID_PROC
.892a	20 ae a6	jsr $a6ae			jsr 	StackCheckFrame
.892d	20 d7 a6	jsr $a6d7			jsr 	STKLoadCodePosition 		; restore code position
.8930	20 a0 a6	jsr $a6a0			jsr 	StackClose
.8933	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8934					Command_Read:
.8934	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8936	20 ee 97	jsr $97ee			jsr 	EvaluateTerm
.8939	bd 00 04	lda $0400,x			lda 	NSStatus,x
.893c	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.893e	f0 4a		beq $898a			beq 	_CRSyntax 					; check reference (bit 0)
.8940	20 d3 89	jsr $89d3			jsr 	SwapDataCodePtrs 			; swap code and data
.8943	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8946	d0 20		bne $8968			bne 	_CRContinueData
.8948					_CRKeepSearching:
.8948	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.894a	aa		tax				tax
.894b	20 a7 8c	jsr $8ca7			jsr 	ScanForward
.894e	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8950	f0 16		beq $8968			beq 	_CRHaveData 				; found it
.8952	18		clc				clc
.8953	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8955	65 30		adc $30				adc 	codePtr
.8957	85 30		sta $30				sta 	codePtr
.8959	90 02		bcc $895d			bcc 	_CREExit
.895b	e6 31		inc $31				inc 	codePtr+1
.895d					_CREExit:
.895d	a0 03		ldy #$03			ldy 	#3 							; start of line.
.895f	b2 30		lda ($30)			lda 	(codePtr)
.8961	d0 e5		bne $8948			bne 	_CRKeepSearching
.8963	a9 0b		lda #$0b		lda	#11
.8965	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8968					_CRHaveData:
.8968					_CRContinueData:
.8968	a2 01		ldx #$01			ldx 	#1
.896a	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; evaluate value into slot # 1
.896d	ca		dex				dex
.896e	20 c8 86	jsr $86c8			jsr		AssignVariable 				; do the assignment
.8971	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.8974	b1 30		lda ($30),y			lda 	(codePtr),y
.8976	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8978	d0 04		bne $897e			bne 	_CRSwapBack
.897a	c8		iny				iny 								; consume comma
.897b	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.897e					_CRSwapBack:
.897e	20 d3 89	jsr $89d3			jsr 	SwapDataCodePtrs			; swap them back.
.8981	b1 30		lda ($30),y			lda 	(codePtr),y
.8983	c8		iny				iny
.8984	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8986	f0 ac		beq $8934			beq 	Command_Read 				; if so go round again.
.8988	88		dey				dey 								; unpick get.
.8989	60		rts				rts
.898a					_CRSyntax:
.898a	4c b2 9f	jmp $9fb2			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.898d					RemCommand:
.898d	b1 30		lda ($30),y			lda 	(codePtr),y
.898f	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8991	d0 06		bne $8999			bne 	_RMExit
.8993	c8		iny				iny
.8994	98		tya				tya
.8995	38		sec				sec
.8996	71 30		adc ($30),y			adc 	(codePtr),y
.8998	a8		tay				tay
.8999					_RMExit:
.8999	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.899a					Command_REPEAT:
.899a	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.899c	20 82 a6	jsr $a682			jsr 	StackOpen
.899f	20 c6 a6	jsr $a6c6			jsr 	STKSaveCodePosition 		; save loop position
.89a2	60		rts				rts
.89a3					Command_UNTIL:
.89a3	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.89a5	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.89a7	20 ae a6	jsr $a6ae			jsr 	StackCheckFrame
.89aa	a2 00		ldx #$00			ldx 	#0
.89ac	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; work out the number
.89af	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; check if zero
.89b2	f0 04		beq $89b8			beq 	_CULoopBack 				; if so keep looping
.89b4	20 a0 a6	jsr $a6a0			jsr 	StackClose		 			; return
.89b7	60		rts				rts
.89b8					_CULoopBack:
.89b8	20 d7 a6	jsr $a6d7			jsr 	STKLoadCodePosition 		; loop back
.89bb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.89bc					Command_Restore:
.89bc	20 d3 89	jsr $89d3			jsr 	SwapDataCodePtrs 			; swap code and data
.89bf	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.89c1	85 30		sta $30				sta 	codePtr
.89c3	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.89c5	85 31		sta $31				sta 	codePtr+1
.89c7	20 d3 89	jsr $89d3			jsr 	SwapDataCodePtrs 			; put them back
.89ca	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.89cc	8d 9b 04	sta $049b			sta 	dataPointer+4
.89cf	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.89d2	60		rts				rts
.89d3					SwapDataCodePtrs:
.89d3	da		phx				phx
.89d4	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.89d6					_SDCPLoop:
.89d6	b5 30		lda $30,x			lda 	safePtr,x
.89d8	48		pha				pha
.89d9	bd 97 04	lda $0497,x			lda 	dataPointer,x
.89dc	95 30		sta $30,x			sta 	safePtr,x
.89de	68		pla				pla
.89df	9d 97 04	sta $0497,x			sta 	dataPointer,x
.89e2	ca		dex				dex
.89e3	10 f1		bpl $89d6			bpl 	_SDCPLoop
.89e5	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.89e8	8c 9b 04	sty $049b			sty 	dataPointer+4
.89eb	a8		tay				tay
.89ec	fa		plx				plx
.89ed	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.89ee					EOLCommand:
.89ee	18		clc				clc
.89ef	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.89f1	65 30		adc $30				adc 	codePtr
.89f3	85 30		sta $30				sta 	codePtr
.89f5	90 02		bcc $89f9			bcc 	_CREExit
.89f7	e6 31		inc $31				inc 	codePtr+1
.89f9					_CREExit:
.89f9	80 0b		bra $8a06			bra 	RunNewLine
.89fb					CommandRUN:
.89fb	20 ed 83	jsr $83ed			jsr 	ClearCommand 				; clear variable/stacks/etc.
.89fe	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a00	85 30		sta $30				sta 	codePtr
.8a02	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a04	85 31		sta $31				sta 	codePtr+1
.8a06					RUNNewLine:
.8a06	b2 30		lda ($30)			lda 	(codePtr)
.8a08	f0 72		beq $8a7c			beq 	CRNoProgram         		; no then END.
.8a0a	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a0c	9a		txs				txs
.8a0d					RUNCodePointerLine:
.8a0d	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a0f					_CRIncMainLoop:
.8a0f	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8a12	d0 19		bne $8a2d			bne 	_CRNoBreakCheck
.8a14	20 78 aa	jsr $aa78			jsr 	EXTBreakCheck 				; break check
.8a17	f0 5e		beq $8a77			beq 	_CRBreak
.8a19	64 01		stz $01				stz 	1 							; access I/O Page 0
.8a1b	38		sec				sec 								; calculate timer - LastTick
.8a1c	ad 59 d6	lda $d659			lda 	$D659
.8a1f	aa		tax				tax 								; saving timer in X
.8a20	ed 2d 06	sbc $062d			sbc 	LastTick
.8a23	c9 03		cmp #$03			cmp 	#3
.8a25	90 06		bcc $8a2d			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8a27	8e 2d 06	stx $062d			stx 	LastTick 					; update last timer
.8a2a	20 d8 b9	jsr $b9d8			jsr 	TickHandler 				; go do the code.
.8a2d					_NoFireTick:
.8a2d					_CRNoBreakCheck:
.8a2d	c8		iny				iny
.8a2e					_CRMainLoop:
.8a2e	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8a31	b1 30		lda ($30),y			lda 	(codePtr),y
.8a33	10 10		bpl $8a45			bpl 	_CRNotKeyword
.8a35	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8a37	b0 04		bcs $8a3d			bcs 	_CRIsKeyword
.8a39	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8a3b	b0 34		bcs $8a71			bcs		_CRSyntaxError
.8a3d					_CRIsKeyword:
.8a3d	c8		iny				iny 								; consume command
.8a3e	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8a3f	aa		tax				tax 								; put in X for vector jump
.8a40	20 74 8a	jsr $8a74			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8a43	80 e9		bra $8a2e			bra 	_CRMainLoop 				; and loop round
.8a45					_CRNotKeyword:
.8a45	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8a47	f0 c6		beq $8a0f			beq 	_CRIncMainLoop
.8a49	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8a4b	90 05		bcc $8a52			bcc 	_CRNotVariable
.8a4d					_CRGoLet:
.8a4d	20 8c 86	jsr $868c			jsr 	LetCommand
.8a50	80 dc		bra $8a2e			bra 	_CRMainLoop
.8a52					_CRNotVariable:
.8a52	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8a54	f0 f7		beq $8a4d			beq 	_CRGoLet
.8a56	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8a58	f0 f3		beq $8a4d			beq 	_CRGoLet
.8a5a	c9 21		cmp #$21			cmp 	#KWD_PLING
.8a5c	f0 ef		beq $8a4d			beq 	_CRGoLet
.8a5e	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8a60	f0 09		beq $8a6b			beq 	_CRGoRem
.8a62	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8a64	d0 0b		bne $8a71			bne 	_CRSyntaxError
.8a66	20 12 82	jsr $8212			jsr 	LabelHere
.8a69	80 c3		bra $8a2e			bra 	_CRMainLoop
.8a6b					_CRGoRem:
.8a6b	c8		iny				iny
.8a6c	20 8d 89	jsr $898d			jsr 	RemCommand
.8a6f	80 bd		bra $8a2e			bra 	_CRMainLoop
.8a71					_CRSyntaxError:
.8a71	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.8a74					_CRCallVector0:
.8a74	7c 12 8b	jmp ($8b12,x)			jmp 	(VectorSet0,x)
.8a77					_CRBreak:
.8a77	a9 01		lda #$01		lda	#1
.8a79	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8a7c					CRNoProgram:
.8a7c	4c 12 85	jmp $8512			jmp 	EndCommand
.8a7f					Shift1Command:
.8a7f	b1 30		lda ($30),y			lda 	(codePtr),y
.8a81	c8		iny				iny
.8a82	0a		asl a				asl 	a
.8a83	aa		tax				tax
.8a84	7c ae 8b	jmp ($8bae,x)			jmp 	(VectorSet1,x)
.8a87					Shift2Command:
.8a87	b1 30		lda ($30),y			lda 	(codePtr),y
.8a89	c8		iny				iny
.8a8a	0a		asl a				asl 	a
.8a8b	aa		tax				tax
.8a8c	7c c8 8b	jmp ($8bc8,x)			jmp 	(VectorSet2,x)
.8a8f					Unused1:
.8a8f					Unused2:
.8a8f					Unused3:
.8a8f					Unused4:
.8a8f	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
>8a92							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8a92					VectorSetPunc:
>8a92	52 90					.word	ShiftLeft                        ; $00 <<
>8a94	09 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8a96	ff 8d					.word	BinaryCompareNotEqual            ; $02 <>
>8a98	b2 9f					.word	SyntaxError                      ; $03 !!3
>8a9a	b2 9f					.word	SyntaxError                      ; $04 ><
>8a9c	13 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8a9e	55 90					.word	ShiftRight                       ; $06 >>
>8aa0	b2 9f					.word	SyntaxError                      ; $07 !!7
>8aa2	b2 9f					.word	SyntaxError                      ; $08 !!8
>8aa4	b2 9f					.word	SyntaxError                      ; $09 !!9
>8aa6	b2 9f					.word	SyntaxError                      ; $0a !!10
>8aa8	b2 9f					.word	SyntaxError                      ; $0b !!11
>8aaa	b2 9f					.word	SyntaxError                      ; $0c !!12
>8aac	b2 9f					.word	SyntaxError                      ; $0d !!13
>8aae	b2 9f					.word	SyntaxError                      ; $0e !!14
>8ab0	b2 9f					.word	SyntaxError                      ; $0f !!15
>8ab2	b2 9f					.word	SyntaxError                      ; $10 @
>8ab4	b2 9f					.word	SyntaxError                      ; $11 !!17
>8ab6	b2 9f					.word	SyntaxError                      ; $12 !!18
>8ab8	b2 9f					.word	SyntaxError                      ; $13 [
>8aba	d6 8e					.word	IntegerDivide                    ; $14 \
>8abc	b2 9f					.word	SyntaxError                      ; $15 ]
>8abe	e3 91					.word	EorInteger                       ; $16 ^
>8ac0	b2 9f					.word	SyntaxError                      ; $17 _
>8ac2	b2 9f					.word	SyntaxError                      ; $18 `
>8ac4	b2 9f					.word	SyntaxError                      ; $19 !!25
>8ac6	b2 9f					.word	SyntaxError                      ; $1a !!26
>8ac8	b2 9f					.word	SyntaxError                      ; $1b {
>8aca	9d 91					.word	OraInteger                       ; $1c |
>8acc	b2 9f					.word	SyntaxError                      ; $1d }
>8ace	b2 9f					.word	SyntaxError                      ; $1e ~
>8ad0	b2 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8ad2	b2 9f					.word	SyntaxError                      ; $20
>8ad4	29 92					.word	WordIndirect                     ; $21 !
>8ad6	b2 9f					.word	SyntaxError                      ; $22 "
>8ad8	b2 9f					.word	SyntaxError                      ; $23 #
>8ada	b2 9f					.word	SyntaxError                      ; $24 $
>8adc	23 8f					.word	IntegerModulus                   ; $25 %
>8ade	57 91					.word	AndInteger                       ; $26 &
>8ae0	b2 9f					.word	SyntaxError                      ; $27 '
>8ae2	b2 9f					.word	SyntaxError                      ; $28 (
>8ae4	b2 9f					.word	SyntaxError                      ; $29 )
>8ae6	98 8f					.word	MulInteger                       ; $2a *
>8ae8	e9 90					.word	AddInteger                       ; $2b +
>8aea	b2 9f					.word	SyntaxError                      ; $2c ,
>8aec	2c 91					.word	SubInteger                       ; $2d -
>8aee	b2 9f					.word	SyntaxError                      ; $2e .
>8af0	14 94					.word	FDivideCommand                   ; $2f /
>8af2	b2 9f					.word	SyntaxError                      ; $30 0
>8af4	b2 9f					.word	SyntaxError                      ; $31 1
>8af6	b2 9f					.word	SyntaxError                      ; $32 2
>8af8	b2 9f					.word	SyntaxError                      ; $33 3
>8afa	b2 9f					.word	SyntaxError                      ; $34 4
>8afc	b2 9f					.word	SyntaxError                      ; $35 5
>8afe	b2 9f					.word	SyntaxError                      ; $36 6
>8b00	b2 9f					.word	SyntaxError                      ; $37 7
>8b02	b2 9f					.word	SyntaxError                      ; $38 8
>8b04	b2 9f					.word	SyntaxError                      ; $39 9
>8b06	b2 9f					.word	SyntaxError                      ; $3a :
>8b08	b2 9f					.word	SyntaxError                      ; $3b ;
>8b0a	eb 8d					.word	BinaryCompareLess                ; $3c <
>8b0c	e1 8d					.word	BinaryCompareEqual               ; $3d =
>8b0e	f5 8d					.word	BinaryCompareGreater             ; $3e >
>8b10	50 92					.word	ByteIndirect                     ; $3f ?
.8b12					VectorSet0:
>8b12	ee 89					.word	EOLCommand                       ; $80 !0:EOF
>8b14	7f 8a					.word	Shift1Command                    ; $81 !1:SH1
>8b16	87 8a					.word	Shift2Command                    ; $82 !2:SH2
>8b18	84 99					.word	AbsUnary                         ; $83 ABS(
>8b1a	94 99					.word	AllocUnary                       ; $84 ALLOC(
>8b1c	04 9a					.word	AscUnary                         ; $85 ASC(
>8b1e	cf 9b					.word	ChrUnary                         ; $86 CHR$(
>8b20	23 a4					.word	UnaryEvent                       ; $87 EVENT(
>8b22	dd 8d					.word	UnaryFalse                       ; $88 FALSE
>8b24	11 9a					.word	FracUnary                        ; $89 FRAC(
>8b26	b9 a3					.word	UnaryHit                         ; $8a HIT(
>8b28	27 9a					.word	IntUnary                         ; $8b INT(
>8b2a	8e 9b					.word	IsValUnary                       ; $8c ISVAL(
>8b2c	b3 a4					.word	UnaryJoyB                        ; $8d JOYB(
>8b2e	8c a4					.word	UnaryJoyX                        ; $8e JOYX(
>8b30	8f a4					.word	UnaryJoyY                        ; $8f JOYY(
>8b32	a9 9c					.word	Unary_Left                       ; $90 LEFT$(
>8b34	39 9a					.word	LenUnary                         ; $91 LEN(
>8b36	57 9a					.word	Unary_Max                        ; $92 MAX(
>8b38	d3 9c					.word	Unary_Mid                        ; $93 MID$(
>8b3a	53 9a					.word	Unary_Min                        ; $94 MIN(
>8b3c	ae 9a					.word	Unary_Not                        ; $95 NOT(
>8b3e	b2 9f					.word	SyntaxError                      ; $96 PLAYING(
>8b40	c4 9a					.word	Unary_Random                     ; $97 RANDOM(
>8b42	b9 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8b44	e3 9a					.word	Unary_Rnd                        ; $99 RND(
>8b46	64 9b					.word	SgnUnary                         ; $9a SGN(
>8b48	e1 9b					.word	SpcUnary                         ; $9b SPC(
>8b4a	fc 9b					.word	Unary_Str                        ; $9c STR$(
>8b4c	c7 a4					.word	UnaryTimer                       ; $9d TIMER(
>8b4e	d1 8d					.word	UnaryTrue                        ; $9e TRUE
>8b50	84 9b					.word	ValUnary                         ; $9f VAL(
>8b52	15 85					.word	ForCommand                       ; $a0 FOR
>8b54	62 86					.word	IfCommand                        ; $a1 IF
>8b56	8f 8a					.word	Unused1                          ; $a2 PROC
>8b58	9a 89					.word	Command_REPEAT                   ; $a3 REPEAT
>8b5a	1d 8d					.word	Command_WHILE                    ; $a4 WHILE
>8b5c	8b 86					.word	EndIf                            ; $a5 ENDIF
>8b5e	26 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8b60	cf 85					.word	NextCommand                      ; $a7 NEXT
>8b62	8f 8a					.word	Unused4                          ; $a8 THEN
>8b64	a3 89					.word	Command_UNTIL                    ; $a9 UNTIL
>8b66	3e 8d					.word	Command_WEND                     ; $aa WEND
>8b68	b2 9f					.word	SyntaxError                      ; $ab BY
>8b6a	b3 83					.word	CallCommand                      ; $ac CALL
>8b6c	5b a1					.word	CircleCommand                    ; $ad CIRCLE
>8b6e	ed 83					.word	ClearCommand                     ; $ae CLEAR
>8b70	45 84					.word	ClearScreen                      ; $af CLS
>8b72	b2 9f					.word	SyntaxError                      ; $b0 COLOR
>8b74	b2 9f					.word	SyntaxError                      ; $b1 COLOUR
>8b76	4d 84					.word	Command_Data                     ; $b2 DATA
>8b78	55 84					.word	DimCommand                       ; $b3 DIM
>8b7a	8f 8a					.word	Unused3                          ; $b4 DOWNTO
>8b7c	84 86					.word	ElseCode                         ; $b5 ELSE
>8b7e	b2 9f					.word	SyntaxError                      ; $b6 FROM
>8b80	87 a3					.word	GfxCommand                       ; $b7 GFX
>8b82	28 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8b84	46 86					.word	GotoCommand                      ; $b9 GOTO
>8b86	b2 9f					.word	SyntaxError                      ; $ba HERE
>8b88	85 a1					.word	ImageCommand                     ; $bb IMAGE
>8b8a	8c 86					.word	LetCommand                       ; $bc LET
>8b8c	da a1					.word	LineCommand                      ; $bd LINE
>8b8e	82 87					.word	Command_LOCAL                    ; $be LOCAL
>8b90	b2 9f					.word	SyntaxError                      ; $bf OFF
>8b92	b2 9f					.word	SyntaxError                      ; $c0 ON
>8b94	b2 9f					.word	SyntaxError                      ; $c1 OUTLINE
>8b96	df a3					.word	PaletteCommand                   ; $c2 PALETTE
>8b98	d3 a1					.word	PlotCommand                      ; $c3 PLOT
>8b9a	59 88					.word	Command_Print                    ; $c4 PRINT
>8b9c	34 89					.word	Command_Read                     ; $c5 READ
>8b9e	57 a1					.word	RectangleCommand                 ; $c6 RECT
>8ba0	8d 89					.word	RemCommand                       ; $c7 REM
>8ba2	38 86					.word	Command_RETURN                   ; $c8 RETURN
>8ba4	b2 9f					.word	SyntaxError                      ; $c9 SOLID
>8ba6	f5 a5					.word	SoundCommand                     ; $ca SOUND
>8ba8	66 a1					.word	SpriteCommand                    ; $cb SPRITE
>8baa	a2 a1					.word	TextCommand                      ; $cc TEXT
>8bac	8f 8a					.word	Unused2                          ; $cd TO
.8bae					VectorSet1:
>8bae	b2 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bb0	b2 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bb2	b2 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bb4	84 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8bb6	a3 83					.word	AssertCommand                    ; $84 ASSERT
>8bb8	27 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8bba	12 85					.word	EndCommand                       ; $86 END
>8bbc	e1 86					.word	Command_List                     ; $87 LIST
>8bbe	49 88					.word	NewCommand                       ; $88 NEW
>8bc0	bc 89					.word	Command_Restore                  ; $89 RESTORE
>8bc2	fb 89					.word	CommandRUN                       ; $8a RUN
>8bc4	6c a3					.word	SpritesCtrl                      ; $8b SPRITES
>8bc6	50 8c					.word	StopCommand                      ; $8c STOP
.8bc8					VectorSet2:
>8bc8	b2 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bca	b2 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bcc	b2 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bce	71 9e					.word	Assemble_adc                     ; $83 ADC
>8bd0	69 9e					.word	Assemble_and                     ; $84 AND
>8bd2	85 9e					.word	Assemble_asl                     ; $85 ASL
>8bd4	ef 9e					.word	Assemble_bcc                     ; $86 BCC
>8bd6	f3 9e					.word	Assemble_bcs                     ; $87 BCS
>8bd8	fb 9e					.word	Assemble_beq                     ; $88 BEQ
>8bda	b2 9e					.word	Assemble_bit                     ; $89 BIT
>8bdc	e3 9e					.word	Assemble_bmi                     ; $8a BMI
>8bde	f7 9e					.word	Assemble_bne                     ; $8b BNE
>8be0	df 9e					.word	Assemble_bpl                     ; $8c BPL
>8be2	ff 9e					.word	Assemble_bra                     ; $8d BRA
>8be4	03 9f					.word	Assemble_brk                     ; $8e BRK
>8be6	e7 9e					.word	Assemble_bvc                     ; $8f BVC
>8be8	eb 9e					.word	Assemble_bvs                     ; $90 BVS
>8bea	0b 9f					.word	Assemble_clc                     ; $91 CLC
>8bec	5f 9f					.word	Assemble_cld                     ; $92 CLD
>8bee	1f 9f					.word	Assemble_cli                     ; $93 CLI
>8bf0	4f 9f					.word	Assemble_clv                     ; $94 CLV
>8bf2	7d 9e					.word	Assemble_cmp                     ; $95 CMP
>8bf4	c6 9e					.word	Assemble_cpx                     ; $96 CPX
>8bf6	c1 9e					.word	Assemble_cpy                     ; $97 CPY
>8bf8	a3 9e					.word	Assemble_dec                     ; $98 DEC
>8bfa	5b 9f					.word	Assemble_dex                     ; $99 DEX
>8bfc	37 9f					.word	Assemble_dey                     ; $9a DEY
>8bfe	6d 9e					.word	Assemble_eor                     ; $9b EOR
>8c00	a8 9e					.word	Assemble_inc                     ; $9c INC
>8c02	6b 9f					.word	Assemble_inx                     ; $9d INX
>8c04	57 9f					.word	Assemble_iny                     ; $9e INY
>8c06	da 9e					.word	Assemble_jmp                     ; $9f JMP
>8c08	d5 9e					.word	Assemble_jsr                     ; $a0 JSR
>8c0a	79 9e					.word	Assemble_lda                     ; $a1 LDA
>8c0c	9e 9e					.word	Assemble_ldx                     ; $a2 LDX
>8c0e	bc 9e					.word	Assemble_ldy                     ; $a3 LDY
>8c10	8f 9e					.word	Assemble_lsr                     ; $a4 LSR
>8c12	6f 9f					.word	Assemble_nop                     ; $a5 NOP
>8c14	65 9e					.word	Assemble_ora                     ; $a6 ORA
>8c16	1b 9f					.word	Assemble_pha                     ; $a7 PHA
>8c18	07 9f					.word	Assemble_php                     ; $a8 PHP
>8c1a	63 9f					.word	Assemble_phx                     ; $a9 PHX
>8c1c	23 9f					.word	Assemble_phy                     ; $aa PHY
>8c1e	2b 9f					.word	Assemble_pla                     ; $ab PLA
>8c20	0f 9f					.word	Assemble_plp                     ; $ac PLP
>8c22	77 9f					.word	Assemble_plx                     ; $ad PLX
>8c24	33 9f					.word	Assemble_ply                     ; $ae PLY
>8c26	8a 9e					.word	Assemble_rol                     ; $af ROL
>8c28	94 9e					.word	Assemble_ror                     ; $b0 ROR
>8c2a	17 9f					.word	Assemble_rti                     ; $b1 RTI
>8c2c	27 9f					.word	Assemble_rts                     ; $b2 RTS
>8c2e	81 9e					.word	Assemble_sbc                     ; $b3 SBC
>8c30	13 9f					.word	Assemble_sec                     ; $b4 SEC
>8c32	73 9f					.word	Assemble_sed                     ; $b5 SED
>8c34	2f 9f					.word	Assemble_sei                     ; $b6 SEI
>8c36	75 9e					.word	Assemble_sta                     ; $b7 STA
>8c38	67 9f					.word	Assemble_stp                     ; $b8 STP
>8c3a	99 9e					.word	Assemble_stx                     ; $b9 STX
>8c3c	b7 9e					.word	Assemble_sty                     ; $ba STY
>8c3e	ad 9e					.word	Assemble_stz                     ; $bb STZ
>8c40	4b 9f					.word	Assemble_tax                     ; $bc TAX
>8c42	47 9f					.word	Assemble_tay                     ; $bd TAY
>8c44	d0 9e					.word	Assemble_trb                     ; $be TRB
>8c46	cb 9e					.word	Assemble_tsb                     ; $bf TSB
>8c48	53 9f					.word	Assemble_tsx                     ; $c0 TSX
>8c4a	3b 9f					.word	Assemble_txa                     ; $c1 TXA
>8c4c	43 9f					.word	Assemble_txs                     ; $c2 TXS
>8c4e	3f 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8c50					StopCommand:
.8c50	a9 08		lda #$08		lda	#8
.8c52	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8c55					ProcedureScan:
.8c55	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8c57	85 30		sta $30				sta 	codePtr
.8c59	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8c5b	85 31		sta $31				sta 	codePtr+1
.8c5d					_PSLoop:
.8c5d	b2 30		lda ($30)			lda 	(codePtr)
.8c5f	f0 42		beq $8ca3			beq 	_PSExit
.8c61	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8c63	b1 30		lda ($30),y			lda 	(codePtr),y
.8c65	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8c67	d0 2d		bne $8c96			bne 	_PSNext
.8c69	c8		iny				iny 								; get the address of the record to zTemp0 and
.8c6a	b1 30		lda ($30),y			lda 	(codePtr),y
.8c6c	29 c0		and #$c0			and 	#$C0
.8c6e	c9 40		cmp #$40			cmp 	#$40
.8c70	d0 32		bne $8ca4			bne 	_PSSyntax
.8c72	b1 30		lda ($30),y			lda 	(codePtr),y
.8c74	18		clc				clc
.8c75	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8c77	85 37		sta $37				sta 	zTemp0+1
.8c79	c8		iny				iny 								; LSB
.8c7a	b1 30		lda ($30),y			lda 	(codePtr),y
.8c7c	85 36		sta $36				sta 	zTemp0
.8c7e	c8		iny				iny 								; character after variable call.
.8c7f	98		tya				tya 								; save Y offset at +7
.8c80	a0 07		ldy #$07			ldy 	#7
.8c82	91 36		sta ($36),y			sta 	(zTemp0),y
.8c84	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8c86	a0 02		ldy #$02			ldy 	#2
.8c88	91 36		sta ($36),y			sta 	(zTemp0),y
.8c8a	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8c8c					_PSCopy:
.8c8c	b5 30		lda $30,x			lda 	safePtr,x
.8c8e	c8		iny				iny
.8c8f	91 36		sta ($36),y			sta 	(zTemp0),y
.8c91	e8		inx				inx
.8c92	e0 04		cpx #$04			cpx 	#4
.8c94	d0 f6		bne $8c8c			bne 	_PSCopy
.8c96					_PSNext:
.8c96	18		clc				clc
.8c97	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8c99	65 30		adc $30				adc 	codePtr
.8c9b	85 30		sta $30				sta 	codePtr
.8c9d	90 02		bcc $8ca1			bcc 	_CREExit
.8c9f	e6 31		inc $31				inc 	codePtr+1
.8ca1					_CREExit:
.8ca1	80 ba		bra $8c5d			bra 	_PSLoop
.8ca3					_PSExit:
.8ca3	60		rts				rts
.8ca4					_PSSyntax:
.8ca4	4c b2 9f	jmp $9fb2			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8ca7					ScanForward:
.8ca7	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8ca9	86 37		stx $37				stx 	zTemp0+1
.8cab	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8cad					_ScanLoop:
.8cad	b1 30		lda ($30),y			lda 	(codePtr),y
.8caf	c8		iny				iny
.8cb0	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8cb2	d0 0e		bne $8cc2			bne 	_ScanGoNext
.8cb4	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8cb6	f0 04		beq $8cbc			beq 	_ScanMatch
.8cb8	c5 37		cmp $37				cmp 	zTemp0+1
.8cba	d0 06		bne $8cc2			bne 	_ScanGoNext
.8cbc					_ScanMatch:
.8cbc	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8cbe	d0 01		bne $8cc1			bne 	_ScanNotEndEOL
.8cc0	88		dey				dey
.8cc1					_ScanNotEndEOL:
.8cc1	60		rts				rts
.8cc2					_ScanGoNext:
.8cc2	20 c7 8c	jsr $8cc7			jsr  	ScanForwardOne
.8cc5	80 e6		bra $8cad			bra 	_ScanLoop
.8cc7					ScanForwardOne:
.8cc7	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8cc9	90 3e		bcc $8d09			bcc 	_SFWExit
.8ccb	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8ccd	90 18		bcc $8ce7			bcc 	_ScanSkipOne
.8ccf	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8cd1	b0 2f		bcs $8d02			bcs 	_ScanSkipData
.8cd3	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8cd5	90 32		bcc $8d09			bcc 	_SFWExit 					; if not, ordinary keywords.
.8cd7	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8cd9	b0 2e		bcs $8d09			bcs 	_SFWExit
.8cdb	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8cdd	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8cdf	b0 28		bcs $8d09			bcs 	_SFWExit
.8ce1	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8ce3	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8ce5	80 22		bra $8d09			bra 	_SFWExit
.8ce7					_ScanSkipOne:
.8ce7	c8		iny				iny 								; consume the extra one.
.8ce8	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8cea	d0 1d		bne $8d09			bne 	_SFWExit
.8cec	18		clc				clc
.8ced	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8cef	65 30		adc $30				adc 	codePtr
.8cf1	85 30		sta $30				sta 	codePtr
.8cf3	90 02		bcc $8cf7			bcc 	_CREExit
.8cf5	e6 31		inc $31				inc 	codePtr+1
.8cf7					_CREExit:
.8cf7	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8cf9	b2 30		lda ($30)			lda 	(codePtr)
.8cfb	d0 0c		bne $8d09			bne 	_SFWExit 					; if not zero, more to scan
.8cfd	a9 13		lda #$13		lda	#19
.8cff	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8d02					_ScanSkipData:
.8d02	88		dey				dey 								; point at data token
.8d03	c8		iny				iny
.8d04	98		tya				tya
.8d05	38		sec				sec
.8d06	71 30		adc ($30),y			adc 	(codePtr),y
.8d08	a8		tay				tay
.8d09					_SFWExit:
.8d09	60		rts				rts
.8d0a					ScanGetCurrentLineStep:
.8d0a	64 38		stz $38				stz 	zTemp1
.8d0c	a0 03		ldy #$03			ldy 	#3
.8d0e					_SGCLSLoop:
.8d0e	b1 30		lda ($30),y			lda 	(codePtr),y
.8d10	c8		iny				iny
.8d11	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d13	f0 05		beq $8d1a			beq 	_SGCLSExit
.8d15	20 c7 8c	jsr $8cc7			jsr 	ScanForwardOne
.8d18	80 f4		bra $8d0e			bra 	_SGCLSLoop
.8d1a					_SGCLSExit:
.8d1a	a5 38		lda $38				lda 	zTemp1
.8d1c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8d1d					Command_WHILE:
.8d1d	5a		phy				phy 								; save position of the test
.8d1e	a2 00		ldx #$00			ldx 	#0
.8d20	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; work out the number
.8d23	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; check if zero
.8d26	f0 0e		beq $8d36			beq 	_WHExitLoop 				; if so exit the loop
.8d28	98		tya				tya 								; position *after* test.
.8d29	7a		ply				ply 								; restore position before test, at WHILE
.8d2a	88		dey				dey
.8d2b	48		pha				pha 								; push after test on the stack
.8d2c	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8d2e	20 82 a6	jsr $a682			jsr 	StackOpen
.8d31	20 c6 a6	jsr $a6c6			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8d34	7a		ply				ply 								; restore the position *after* the test
.8d35	60		rts				rts
.8d36					_WHExitLoop:
.8d36	68		pla				pla 								; throw post loop position
.8d37	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8d39	aa		tax				tax
.8d3a	20 a7 8c	jsr $8ca7			jsr 	ScanForward
.8d3d	60		rts				rts
.8d3e					Command_WEND:
.8d3e	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8d40	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8d42	20 ae a6	jsr $a6ae			jsr 	StackCheckFrame
.8d45	20 d7 a6	jsr $a6d7			jsr 	STKLoadCodePosition 		; loop back
.8d48	20 a0 a6	jsr $a6a0			jsr 	StackClose		 			; erase the frame
.8d4b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8d4c					CheckRightBracket:
.8d4c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d4e	c8		iny				iny
.8d4f	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8d51	d0 0f		bne $8d62			bne 	CNAFail
.8d53	60		rts				rts
.8d54					CheckComma:
.8d54	b1 30		lda ($30),y			lda 	(codePtr),y
.8d56	c8		iny				iny
.8d57	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8d59	d0 07		bne $8d62			bne 	CNAFail
.8d5b	60		rts				rts
.8d5c					CheckNextA:
.8d5c	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8d5e	d0 02		bne $8d62			bne 	CNAFail
.8d60	c8		iny				iny 								; skip character
.8d61	60		rts				rts 								; and exit
.8d62					CNAFail:
.8d62	4c b2 9f	jmp $9fb2			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8d65					ErrorHandler:
.8d65	a8		tay				tay 								; find the error text
.8d66	f0 49		beq $8db1			beq 	_EHEnd
.8d68	a2 00		ldx #$00			ldx 	#0
.8d6a	a9 cb		lda #$cb			lda 	#((ErrorText) & $FF)
.8d6c	85 36		sta $36				sta 	0+zTemp0
.8d6e	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8d70	85 37		sta $37				sta 	1+zTemp0
.8d72					_EHFind:
.8d72	88		dey				dey 								; found the error text ?
.8d73	f0 0e		beq $8d83			beq 	_EHFound
.8d75					_EHFindZero:
.8d75	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8d77	e6 36		inc $36				inc 	zTemp0
.8d79	d0 02		bne $8d7d			bne 	_EHFNoCarry
.8d7b	e6 37		inc $37				inc 	zTemp0+1
.8d7d					_EHFNoCarry:
.8d7d	c9 00		cmp #$00			cmp 	#0
.8d7f	d0 f4		bne $8d75			bne 	_EHFindZero
.8d81	80 ef		bra $8d72			bra 	_EHFind
.8d83					_EHFound:
.8d83	a5 36		lda $36				lda 	zTemp0 						; print message
.8d85	a6 37		ldx $37				ldx 	zTemp0+1
.8d87	20 be 8d	jsr $8dbe			jsr 	PrintStringXA
.8d8a	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8d8c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d8e	d0 05		bne $8d95			bne 	_EHAtMsg
.8d90	c8		iny				iny
.8d91	b1 30		lda ($30),y			lda 	(codePtr),y
.8d93	f0 17		beq $8dac			beq 	_EHCREnd
.8d95					_EHAtMsg:
.8d95	a2 8d		ldx #$8d			ldx 	#_AtMsg >> 8 				; print " at "
.8d97	a9 b4		lda #$b4			lda 	#_AtMsg & $FF
.8d99	20 be 8d	jsr $8dbe			jsr 	PrintStringXA
.8d9c	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8d9e	b1 30		lda ($30),y			lda 	(codePtr),y
.8da0	48		pha				pha
.8da1	c8		iny				iny
.8da2	b1 30		lda ($30),y			lda 	(codePtr),y
.8da4	aa		tax				tax
.8da5	68		pla				pla
.8da6	20 77 92	jsr $9277			jsr 	LCLConvertInt16 				; convert XA to string
.8da9	20 be 8d	jsr $8dbe			jsr 	PrintStringXA 				; and print it.
.8dac					_EHCREnd:
.8dac	a9 0d		lda #$0d			lda 	#13 						; new line
.8dae	20 c2 a7	jsr $a7c2			jsr 	EXTPrintCharacter
.8db1					_EHEnd:
.8db1	4c 54 83	jmp $8354			jmp 	WarmStart
>8db4	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8dbc	20 00
.8dbe					PrintStringXA:
.8dbe	5a		phy				phy
.8dbf	86 37		stx $37				stx 	zTemp0+1
.8dc1	85 36		sta $36				sta 	zTemp0
.8dc3	a0 00		ldy #$00			ldy 	#0
.8dc5					_PSXALoop:
.8dc5	b1 36		lda ($36),y			lda 	(zTemp0),y
.8dc7	f0 06		beq $8dcf			beq 	_PSXAExit
.8dc9	20 c2 a7	jsr $a7c2			jsr 	EXTPrintCharacter
.8dcc	c8		iny				iny
.8dcd	80 f6		bra $8dc5			bra 	_PSXALoop
.8dcf					_PSXAExit:
.8dcf	7a		ply				ply
.8dd0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8dd1					UnaryTrue:
.8dd1	fa		plx				plx
.8dd2					ReturnTrue:
.8dd2	a9 01		lda #$01			lda 	#1  						; set to 1
.8dd4	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.8dd7	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8dd9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8ddc	60		rts				rts
.8ddd					UnaryFalse:
.8ddd	fa		plx				plx
.8dde					ReturnFalse:
.8dde	4c 28 9e	jmp $9e28			jmp 	NSMSetZero 					; set it all to zero
.8de1					BinaryCompareEqual:
.8de1	fa		plx				plx
.8de2	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8de5	c9 00		cmp #$00			cmp 	#0
.8de7	f0 e9		beq $8dd2			beq 	ReturnTrue
.8de9	80 f3		bra $8dde			bra 	ReturnFalse
.8deb					BinaryCompareLess:
.8deb	fa		plx				plx
.8dec	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8def	c9 ff		cmp #$ff			cmp 	#$FF
.8df1	f0 df		beq $8dd2			beq 	ReturnTrue
.8df3	80 e9		bra $8dde			bra 	ReturnFalse
.8df5					BinaryCompareGreater:
.8df5	fa		plx				plx
.8df6	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8df9	c9 01		cmp #$01			cmp 	#1
.8dfb	f0 d5		beq $8dd2			beq 	ReturnTrue
.8dfd	80 df		bra $8dde			bra 	ReturnFalse
.8dff					BinaryCompareNotEqual:
.8dff	fa		plx				plx
.8e00	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8e03	c9 00		cmp #$00			cmp 	#0
.8e05	d0 cb		bne $8dd2			bne 	ReturnTrue
.8e07	80 d5		bra $8dde			bra 	ReturnFalse
.8e09					BinaryCompareLessEqual:
.8e09	fa		plx				plx
.8e0a	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8e0d	c9 01		cmp #$01			cmp 	#1
.8e0f	d0 c1		bne $8dd2			bne 	ReturnTrue
.8e11	80 cb		bra $8dde			bra 	ReturnFalse
.8e13					BinaryCompareGreaterEqual:
.8e13	fa		plx				plx
.8e14	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode
.8e17	c9 ff		cmp #$ff			cmp 	#$FF
.8e19	d0 b7		bne $8dd2			bne 	ReturnTrue
.8e1b	80 c1		bra $8dde			bra 	ReturnFalse
.8e1d					CompareBaseCode:
.8e1d	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; make both values if references.
.8e20	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8e23	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e26	29 10		and #$10			and 	#NSTString
.8e28	d0 40		bne $8e6a			bne 	_CBCString
.8e2a	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8e2d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8e30	d0 3b		bne $8e6d			bne 	_CBCFloat
.8e32	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8e35	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e38	29 08		and #$08			and 	#NSTFloat
.8e3a	d0 31		bne $8e6d			bne 	_CBCFloat
.8e3c	20 70 8e	jsr $8e70			jsr 	CompareFixMinusZero
.8e3f	e8		inx				inx
.8e40	20 70 8e	jsr $8e70			jsr 	CompareFixMinusZero
.8e43	ca		dex				dex
.8e44	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8e47	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8e4a	10 0b		bpl $8e57			bpl 	_CDCSameSign
.8e4c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8e4f	30 16		bmi $8e67			bmi 	_CBCLess 					; return $FF
.8e51					_CBCGreater:
.8e51	a9 01		lda #$01			lda 	#1
.8e53	60		rts				rts
.8e54					_CBCEqual:
.8e54	a9 00		lda #$00			lda 	#0
.8e56	60		rts				rts
.8e57					_CDCSameSign:
.8e57	20 c3 90	jsr $90c3			jsr 	SubTopTwoStack 				; unsigned subtract
.8e5a	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; or the mantissa together
.8e5d	f0 f5		beq $8e54			beq 	_CBCEqual 					; -0 == 0
.8e5f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8e62	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8e65	10 ea		bpl $8e51			bpl 	_CBCGreater
.8e67					_CBCLess:
.8e67	a9 ff		lda #$ff			lda 	#$FF
.8e69	60		rts				rts
.8e6a					_CBCString:
.8e6a	4c 19 90	jmp $9019			jmp 	CompareStrings
.8e6d					_CBCFloat:
.8e6d	4c fa 93	jmp $93fa			jmp 	CompareFloat
.8e70					CompareFixMinusZero:
.8e70	20 58 9e	jsr $9e58			jsr 	NSMIsZero
.8e73	d0 03		bne $8e78			bne 	_CFXMZNotZero
.8e75	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8e78					_CFXMZNotZero:
.8e78	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8e79					StringConcat:
.8e79	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8e7c	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8e7f	29 18		and #$18			and 	#NSBTypeMask
.8e81	c9 10		cmp #$10			cmp 	#NSTString
.8e83	d0 4e		bne $8ed3			bne		_SCType
.8e85	64 38		stz $38				stz 	zTemp1 						; counting total length
.8e87	e8		inx				inx
.8e88	20 a6 8e	jsr $8ea6			jsr 	_SCSetupZ0 					; setup for second
.8e8b	20 b1 8e	jsr $8eb1			jsr 	_SCLengthZ0 				; length for second
.8e8e	ca		dex				dex
.8e8f	20 a6 8e	jsr $8ea6			jsr 	_SCSetupZ0 					; setup for first
.8e92	20 b1 8e	jsr $8eb1			jsr 	_SCLengthZ0 				; length for first
.8e95	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8e97	20 75 a7	jsr $a775			jsr 	StringTempAllocate
.8e9a	20 c4 8e	jsr $8ec4			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8e9d	e8		inx				inx
.8e9e	20 a6 8e	jsr $8ea6			jsr 	_SCSetupZ0 					; copy second out
.8ea1	20 c4 8e	jsr $8ec4			jsr 	_SCCopy
.8ea4	ca		dex				dex
.8ea5	60		rts				rts
.8ea6					_SCSetupZ0:
.8ea6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8ea9	85 36		sta $36				sta 	zTemp0
.8eab	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8eae	85 37		sta $37				sta 	zTemp0+1
.8eb0	60		rts				rts
.8eb1					_SCLengthZ0:
.8eb1	5a		phy				phy
.8eb2	a0 00		ldy #$00			ldy 	#0
.8eb4					_SCLenLoop:
.8eb4	b1 36		lda ($36),y			lda 	(zTemp0),y
.8eb6	f0 0a		beq $8ec2			beq 	_SCLExit
.8eb8	c8		iny				iny
.8eb9	e6 38		inc $38				inc 	zTemp1
.8ebb	10 f7		bpl $8eb4			bpl		_SCLenLoop
.8ebd	a9 09		lda #$09		lda	#9
.8ebf	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8ec2					_SCLExit:
.8ec2	7a		ply				ply
.8ec3	60		rts				rts
.8ec4					_SCCopy:
.8ec4	5a		phy				phy
.8ec5	a0 00		ldy #$00			ldy 	#0
.8ec7					_SCCopyLoop:
.8ec7	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ec9	f0 06		beq $8ed1			beq 	_SCCExit
.8ecb	20 b3 a7	jsr $a7b3			jsr 	StringTempWrite
.8ece	c8		iny				iny
.8ecf	80 f6		bra $8ec7			bra 	_SCCopyLoop
.8ed1					_SCCExit:
.8ed1	7a		ply				ply
.8ed2	60		rts				rts
.8ed3					_SCType:
.8ed3	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8ed6					IntegerDivide:
.8ed6	fa		plx				plx
.8ed7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8eda	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8edd	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8ede	0a		asl a				asl 	a
.8edf	10 05		bpl $8ee6			bpl 	_NotRef
.8ee1	48		pha				pha
.8ee2	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8ee5	68		pla				pla
.8ee6					_NotRef:
.8ee6	0a		asl a				asl 	a
.8ee7	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8ee9	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8eec	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8eef	f0 03		beq $8ef4			beq 	_IntegerCode 				; if clear, then we have two integers
.8ef1	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.8ef4					_IntegerCode:
.8ef4	20 16 8f	jsr $8f16			jsr 	CheckDivideZero 			; do div zero check
.8ef7	20 4e 8f	jsr $8f4e			jsr 	Int32Divide 				; do the division
.8efa	20 0b 90	jsr $900b			jsr 	CalculateSign 				; calculate result sign
.8efd					NSMCopyPlusTwoToZero:
.8efd	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f00	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8f03	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8f06	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8f09	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8f0c	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8f0f	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8f12	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8f15	60		rts				rts
.8f16					CheckDivideZero:
.8f16	e8		inx				inx
.8f17	20 58 9e	jsr $9e58			jsr 	NSMIsZero
.8f1a	f0 02		beq $8f1e			beq 	_CDVError
.8f1c	ca		dex				dex
.8f1d	60		rts				rts
.8f1e					_CDVError:
.8f1e	a9 03		lda #$03		lda	#3
.8f20	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8f23					IntegerModulus:
.8f23	fa		plx				plx
.8f24	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f27	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f2a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f2b	0a		asl a				asl 	a
.8f2c	10 05		bpl $8f33			bpl 	_NotRef
.8f2e	48		pha				pha
.8f2f	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f32	68		pla				pla
.8f33					_NotRef:
.8f33	0a		asl a				asl 	a
.8f34	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f36	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f39	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f3c	f0 03		beq $8f41			beq 	_IntegerCode 				; if clear, then we have two integers
.8f3e	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.8f41					_IntegerCode:
.8f41					IntegerModulusNoCheck:
.8f41	20 16 8f	jsr $8f16			jsr 	CheckDivideZero 			; do div zero check
.8f44	20 4e 8f	jsr $8f4e			jsr 	Int32Divide 				; do the division
.8f47	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8f4a	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8f4d	60		rts				rts
.8f4e					Int32Divide:
.8f4e	48		pha				pha 								; save AXY
.8f4f	5a		phy				phy
.8f50	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8f53	20 24 9e	jsr $9e24			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8f56	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8f58					_I32DivideLoop:
.8f58	e8		inx				inx
.8f59	e8		inx				inx
.8f5a	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8f5d	ca		dex				dex
.8f5e	ca		dex				dex
.8f5f	20 3e 9e	jsr $9e3e			jsr 	NSMRotateLeft
.8f62	20 8e 8f	jsr $8f8e			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f65	90 03		bcc $8f6a			bcc 	_I32DivideNoCarryIn
.8f67	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8f6a					_I32DivideNoCarryIn:
.8f6a	88		dey				dey 								; loop round till division completed.
.8f6b	d0 eb		bne $8f58			bne 	_I32DivideLoop
.8f6d	7a		ply				ply 								; restore AXY and exit
.8f6e	68		pla				pla
.8f6f	60		rts				rts
.8f70					Int32ShiftDivide:
.8f70	48		pha				pha 								; save AY
.8f71	5a		phy				phy
.8f72	e8		inx				inx 								; clear S[X+2]
.8f73	e8		inx				inx
.8f74	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.8f77	ca		dex				dex
.8f78	ca		dex				dex
.8f79	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.8f7b					_I32SDLoop:
.8f7b	20 8e 8f	jsr $8f8e			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f7e	e8		inx				inx
.8f7f	e8		inx				inx
.8f80	20 3e 9e	jsr $9e3e			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.8f83	ca		dex				dex
.8f84	ca		dex				dex
.8f85	20 3e 9e	jsr $9e3e			jsr 	NSMRotateLeft
.8f88	88		dey				dey 	 							; do 31 times
.8f89	d0 f0		bne $8f7b			bne 	_I32SDLoop
.8f8b	7a		ply				ply 								; restore AY and exit
.8f8c	68		pla				pla
.8f8d	60		rts				rts
.8f8e					DivideCheckSubtract:
.8f8e	20 c3 90	jsr $90c3			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.8f91	b0 04		bcs $8f97			bcs 	_DCSExit 					; if carry set, then could do, exit
.8f93	20 9d 90	jsr $909d			jsr 	AddTopTwoStack 				; add it back in
.8f96	18		clc				clc 								; and return False
.8f97					_DCSExit:
.8f97	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.8f98					MulInteger:
.8f98	fa		plx				plx
.8f99	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f9c	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f9f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fa0	0a		asl a				asl 	a
.8fa1	10 05		bpl $8fa8			bpl 	_NotRef
.8fa3	48		pha				pha
.8fa4	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fa7	68		pla				pla
.8fa8					_NotRef:
.8fa8	0a		asl a				asl 	a 							; put MSB of type into A:7
.8fa9	30 0b		bmi $8fb6			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.8fab	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fae	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fb1	f0 06		beq $8fb9			beq 	_IntegerCode 				; if clear, then we have two integers
.8fb3	4c d1 94	jmp $94d1			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.8fb6					_StringData:
.8fb6	4c c6 9f	jmp $9fc6			jmp 	NotDoneError							; at least one string - don't know both are strings.
.8fb9					_IntegerCode:
.8fb9	20 c6 8f	jsr $8fc6			jsr 	MultiplyShort
.8fbc	c9 00		cmp #$00			cmp 	#0
.8fbe	f0 05		beq $8fc5			beq 	_MIExit
.8fc0	a9 04		lda #$04		lda	#4
.8fc2	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.8fc5					_MIExit:
.8fc5	60		rts				rts
.8fc6					MultiplyShort:
.8fc6	5a		phy				phy 								; save Y
.8fc7	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fca	20 24 9e	jsr $9e24			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.8fcd	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.8fcf					_I32MLoop:
.8fcf	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.8fd2	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.8fd5	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.8fd8	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.8fdb	f0 28		beq $9005			beq 	_I32MExit 					; exit if zero
.8fdd	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.8fe0	29 01		and #$01			and 	#1
.8fe2	f0 0e		beq $8ff2			beq 	_I32MNoAdd
.8fe4	20 9d 90	jsr $909d			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.8fe7	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.8fea	10 06		bpl $8ff2			bpl 	_I32MNoAdd
.8fec					_I32ShiftRight:
.8fec	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift S[X] right
.8fef	c8		iny				iny 								; increment shift count
.8ff0	80 0a		bra $8ffc			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.8ff2					_I32MNoAdd:
.8ff2	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.8ff5	70 f5		bvs $8fec			bvs 	_I32ShiftRight 				; instead.
.8ff7	e8		inx				inx
.8ff8	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.8ffb	ca		dex				dex
.8ffc					_I32MShiftUpper:
.8ffc	e8		inx				inx 								; shift S[X+2] right
.8ffd	e8		inx				inx
.8ffe	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight
.9001	ca		dex				dex
.9002	ca		dex				dex
.9003	80 ca		bra $8fcf			bra 	_I32MLoop 					; try again.
.9005					_I32MExit:
.9005	20 0b 90	jsr $900b			jsr 	CalculateSign
.9008	98		tya				tya 								; shift in A
.9009	7a		ply				ply 								; restore Y and exit
.900a	60		rts				rts
.900b					CalculateSign:
.900b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.900e	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.9011	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9014	0a		asl a				asl 	a 							; shift bit 7 into carry
.9015	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.9018	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9019					CompareStrings:
.9019	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.901c	3d 01 04	and $0401,x			and 	NSStatus+1,x
.901f	29 10		and #$10			and 	#NSBIsString
.9021	f0 2c		beq $904f			beq 	_CSTypeError
.9023	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9026	85 36		sta $36				sta 	zTemp0
.9028	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.902b	85 37		sta $37				sta 	zTemp0+1
.902d	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9030	85 38		sta $38				sta 	zTemp1
.9032	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9035	85 39		sta $39				sta 	zTemp1+1
.9037	5a		phy				phy 								; save Y so we can access strings
.9038	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.903a					_CSLoop:
.903a	c8		iny				iny
.903b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.903d	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.903f	d0 06		bne $9047			bne 	_CSDifferent
.9041	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9043	d0 f5		bne $903a			bne 	_CSLoop 					; still comparing
.9045					_CSExit:
.9045	7a		ply				ply 								; reached end, return zero in A from EOS
.9046	60		rts				rts
.9047					_CSDifferent:
.9047	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.9049	90 fa		bcc $9045			bcc		_CSExit
.904b	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.904d	80 f6		bra $9045			bra 	_CSExit
.904f					_CSTypeError:
.904f	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9052					ShiftLeft:
.9052	38		sec				sec
.9053	80 01		bra $9056			bra 	ShiftMain
.9055					ShiftRight:
.9055	18		clc				clc
.9056					ShiftMain:
.9056	fa		plx				plx 								; restore X
.9057	08		php				php 								; save direction
.9058	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.905b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.905e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.905f	0a		asl a				asl 	a
.9060	10 05		bpl $9067			bpl 	_NotRef
.9062	48		pha				pha
.9063	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9066	68		pla				pla
.9067					_NotRef:
.9067	0a		asl a				asl 	a
.9068	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.906a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.906d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9070	f0 03		beq $9075			beq 	_IntegerCode 				; if clear, then we have two integers
.9072	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.9075					_IntegerCode:
.9075	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.9078	29 e0		and #$e0			and 	#$E0
.907a	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.907d	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.9080	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9083	d0 13		bne $9098			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9085					_SMLoop:
.9085	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9088	30 11		bmi $909b			bmi 	_SMExit 					; exit if done.
.908a	28		plp				plp 								; restore direcition setting
.908b	08		php				php
.908c	90 05		bcc $9093			bcc 	_SMRight
.908e	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; shift left if CS
.9091	80 f2		bra $9085			bra 	_SMLoop
.9093					_SMRight:
.9093	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift right if CC
.9096	80 ed		bra $9085			bra 	_SMLoop
.9098					_SMExit0:
.9098	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; return zero.
.909b					_SMExit:
.909b	28		plp				plp 								; throw direction
.909c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.909d					AddTopTwoStack:
.909d	18		clc				clc
.909e	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90a1	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.90a4	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90a7	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90aa	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.90ad	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90b0	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90b3	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.90b6	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90b9	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90bc	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.90bf	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90c2	60		rts				rts
.90c3					SubTopTwoStack:
.90c3	38		sec				sec
.90c4	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90c7	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.90ca	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90cd	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90d0	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.90d3	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90d6	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90d9	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.90dc	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90df	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90e2	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.90e5	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90e8	60		rts				rts
.90e9					AddInteger:
.90e9	fa		plx				plx
.90ea	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90ed	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90f0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90f1	0a		asl a				asl 	a
.90f2	10 05		bpl $90f9			bpl 	_NotRef
.90f4	48		pha				pha
.90f5	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90f8	68		pla				pla
.90f9					_NotRef:
.90f9	0a		asl a				asl 	a 							; put MSB of type into A:7
.90fa	30 0b		bmi $9107			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.90fc	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90ff	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9102	f0 06		beq $910a			beq 	_IntegerCode 				; if clear, then we have two integers
.9104	4c 51 93	jmp $9351			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9107					_StringData:
.9107	4c 79 8e	jmp $8e79			jmp 	StringConcat							; at least one string - don't know both are strings.
.910a					_IntegerCode:
.910a					AddCode:
.910a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.910d	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9110	10 8b		bpl $909d			bpl 	AddTopTwoStack
.9112	20 c3 90	jsr $90c3			jsr 	SubTopTwoStack 				; do a physical subtraction
.9115	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9118	10 09		bpl $9123			bpl 	_AddExit
.911a	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.911d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9120	20 dd 9d	jsr $9ddd			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9123					_AddExit:
.9123	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; check for -0
.9126	d0 03		bne $912b			bne 	_AddNonZero
.9128	9e 00 04	stz $0400,x			stz 	NSStatus,x
.912b					_AddNonZero:
.912b	60		rts				rts
.912c					SubInteger:
.912c	fa		plx				plx
.912d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9130	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9133	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9134	0a		asl a				asl 	a
.9135	10 05		bpl $913c			bpl 	_NotRef
.9137	48		pha				pha
.9138	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.913b	68		pla				pla
.913c					_NotRef:
.913c	0a		asl a				asl 	a 							; put MSB of type into A:7
.913d	30 0b		bmi $914a			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.913f	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9142	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9145	f0 06		beq $914d			beq 	_IntegerCode 				; if clear, then we have two integers
.9147	4c 56 93	jmp $9356			jmp 	FloatingPointSub 							; otherwise at least one float.
.914a					_StringData:
.914a	4c c6 9f	jmp $9fc6			jmp 	NotDoneError							; at least one string - don't know both are strings.
.914d					_IntegerCode:
.914d	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.9150	49 80		eor #$80			eor 	#$80
.9152	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9155	80 b3		bra $910a			bra 	AddCode 					; and do the same code as add.
.9157					AndInteger:
.9157	fa		plx				plx
.9158	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.915b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.915e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.915f	0a		asl a				asl 	a
.9160	10 05		bpl $9167			bpl 	_NotRef
.9162	48		pha				pha
.9163	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9166	68		pla				pla
.9167					_NotRef:
.9167	0a		asl a				asl 	a
.9168	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.916a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.916d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9170	f0 03		beq $9175			beq 	_IntegerCode 				; if clear, then we have two integers
.9172	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.9175					_IntegerCode:
.9175	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9178	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.917b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.917e	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9181	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.9184	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9187	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.918a	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.918d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9190	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9193	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.9196	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9199	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.919c	60		rts				rts
.919d					OraInteger:
.919d	fa		plx				plx
.919e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91a1	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91a4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91a5	0a		asl a				asl 	a
.91a6	10 05		bpl $91ad			bpl 	_NotRef
.91a8	48		pha				pha
.91a9	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91ac	68		pla				pla
.91ad					_NotRef:
.91ad	0a		asl a				asl 	a
.91ae	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91b0	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91b3	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91b6	f0 03		beq $91bb			beq 	_IntegerCode 				; if clear, then we have two integers
.91b8	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.91bb					_IntegerCode:
.91bb	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.91be	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.91c1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.91c4	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.91c7	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.91ca	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.91cd	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.91d0	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.91d3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.91d6	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.91d9	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.91dc	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.91df	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.91e2	60		rts				rts
.91e3					EorInteger:
.91e3	fa		plx				plx
.91e4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91e7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91ea	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91eb	0a		asl a				asl 	a
.91ec	10 05		bpl $91f3			bpl 	_NotRef
.91ee	48		pha				pha
.91ef	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f2	68		pla				pla
.91f3					_NotRef:
.91f3	0a		asl a				asl 	a
.91f4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91f6	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91f9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91fc	f0 03		beq $9201			beq 	_IntegerCode 				; if clear, then we have two integers
.91fe	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.9201					_IntegerCode:
.9201	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9204	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.9207	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.920a	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.920d	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.9210	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9213	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9216	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.9219	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.921c	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.921f	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.9222	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9225	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9228	60		rts				rts
.9229					WordIndirect:
.9229	fa		plx				plx
.922a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.922d	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9230	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9231	0a		asl a				asl 	a
.9232	10 05		bpl $9239			bpl 	_NotRef
.9234	48		pha				pha
.9235	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9238	68		pla				pla
.9239					_NotRef:
.9239	0a		asl a				asl 	a
.923a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.923c	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.923f	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9242	f0 03		beq $9247			beq 	_IntegerCode 				; if clear, then we have two integers
.9244	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.9247					_IntegerCode:
.9247	20 0a 91	jsr $910a			jsr 	AddCode 					; add the two values
.924a	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.924c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.924f	60		rts				rts
.9250					ByteIndirect:
.9250	fa		plx				plx
.9251	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9254	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9257	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9258	0a		asl a				asl 	a
.9259	10 05		bpl $9260			bpl 	_NotRef
.925b	48		pha				pha
.925c	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.925f	68		pla				pla
.9260					_NotRef:
.9260	0a		asl a				asl 	a
.9261	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9263	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9266	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9269	f0 03		beq $926e			beq 	_IntegerCode 				; if clear, then we have two integers
.926b	4c bc 9f	jmp $9fbc			jmp 	TypeError 					; anything else, type mismatch.
.926e					_IntegerCode:
.926e	20 0a 91	jsr $910a			jsr 	AddCode 					; add the two values
.9271	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9273	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9276	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9277					LCLConvertInt16:
.9277	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.927a	8e 10 04	stx $0410			stx 	NSMantissa1
.927d	9c 18 04	stz $0418			stz 	NSMantissa2
.9280	9c 20 04	stz $0420			stz 	NSMantissa3
.9283	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.9286	a2 00		ldx #$00			ldx 	#0 							; stack level
.9288	a9 0a		lda #$0a			lda 	#10 						; base
.928a	80 00		bra $928c			bra 	ConvertInt32
.928c					ConvertInt32:
.928c	5a		phy				phy
.928d	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.928f	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.9292	10 08		bpl $929c			bpl 	_CI32NotNeg
.9294	48		pha				pha
.9295	a9 2d		lda #$2d			lda 	#'-'
.9297	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.929a	c8		iny				iny
.929b	68		pla				pla
.929c					_CI32NotNeg:
.929c	20 aa 92	jsr $92aa			jsr 	_CI32DivideConvert 			; recursive conversion
.929f	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.92a1	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.92a4	7a		ply				ply
.92a5	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.92a7	a9 f9		lda #$f9			lda 	#NumberBuffer & $FF
.92a9	60		rts				rts
.92aa					_CI32DivideConvert:
.92aa	e8		inx				inx 								; write to next slot up
.92ab	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.92ae	ca		dex				dex
.92af	20 4e 8f	jsr $8f4e			jsr 	Int32Divide 				; divide
.92b2	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.92b5	48		pha				pha
.92b6	20 fd 8e	jsr $8efd			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.92b9	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; is it zero ?
.92bc	f0 06		beq $92c4			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.92be	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.92c1	20 aa 92	jsr $92aa			jsr 	_CI32DivideConvert 			; and recusrively call.
.92c4					_CI32NoRecurse:
.92c4	68		pla				pla 								; remainder
.92c5	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.92c7	90 02		bcc $92cb			bcc 	_CI32NotHex
.92c9	69 26		adc #$26			adc 	#6+32
.92cb					_CI32NotHex:
.92cb	69 30		adc #$30			adc 	#48
.92cd	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y 				; write out and exit
.92d0	c8		iny				iny
.92d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.92d2					PrecedenceLevel:
>92d2	04					.byte	 4	; $00 <<
>92d3	02					.byte	 2	; $01 <=
>92d4	02					.byte	 2	; $02 <>
>92d5	00					.byte	 0	; $03 !!3
>92d6	00					.byte	 0	; $04 ><
>92d7	02					.byte	 2	; $05 >=
>92d8	04					.byte	 4	; $06 >>
>92d9	00					.byte	 0	; $07 !!7
>92da	00					.byte	 0	; $08 !!8
>92db	00					.byte	 0	; $09 !!9
>92dc	00					.byte	 0	; $0a !!10
>92dd	00					.byte	 0	; $0b !!11
>92de	00					.byte	 0	; $0c !!12
>92df	00					.byte	 0	; $0d !!13
>92e0	00					.byte	 0	; $0e !!14
>92e1	00					.byte	 0	; $0f !!15
>92e2	00					.byte	 0	; $10 @
>92e3	00					.byte	 0	; $11 !!17
>92e4	00					.byte	 0	; $12 !!18
>92e5	00					.byte	 0	; $13 [
>92e6	04					.byte	 4	; $14 \
>92e7	00					.byte	 0	; $15 ]
>92e8	01					.byte	 1	; $16 ^
>92e9	00					.byte	 0	; $17 _
>92ea	00					.byte	 0	; $18 `
>92eb	00					.byte	 0	; $19 !!25
>92ec	00					.byte	 0	; $1a !!26
>92ed	00					.byte	 0	; $1b {
>92ee	01					.byte	 1	; $1c |
>92ef	00					.byte	 0	; $1d }
>92f0	00					.byte	 0	; $1e ~
>92f1	00					.byte	 0	; $1f [7m<7F>[m
>92f2	00					.byte	 0	; $20
>92f3	05					.byte	 5	; $21 !
>92f4	00					.byte	 0	; $22 "
>92f5	00					.byte	 0	; $23 #
>92f6	05					.byte	 5	; $24 $
>92f7	04					.byte	 4	; $25 %
>92f8	01					.byte	 1	; $26 &
>92f9	00					.byte	 0	; $27 '
>92fa	00					.byte	 0	; $28 (
>92fb	00					.byte	 0	; $29 )
>92fc	04					.byte	 4	; $2a *
>92fd	03					.byte	 3	; $2b +
>92fe	00					.byte	 0	; $2c ,
>92ff	03					.byte	 3	; $2d -
>9300	00					.byte	 0	; $2e .
>9301	04					.byte	 4	; $2f /
>9302	00					.byte	 0	; $30 0
>9303	00					.byte	 0	; $31 1
>9304	00					.byte	 0	; $32 2
>9305	00					.byte	 0	; $33 3
>9306	00					.byte	 0	; $34 4
>9307	00					.byte	 0	; $35 5
>9308	00					.byte	 0	; $36 6
>9309	00					.byte	 0	; $37 7
>930a	00					.byte	 0	; $38 8
>930b	00					.byte	 0	; $39 9
>930c	00					.byte	 0	; $3a :
>930d	00					.byte	 0	; $3b ;
>930e	02					.byte	 2	; $3c <
>930f	02					.byte	 2	; $3d =
>9310	02					.byte	 2	; $3e >
>9311	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9312					EvaluateExpressionAt0:
.9312	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9314					EvaluateExpression:
.9314	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9316					EvaluateExpressionAtPrecedence:
.9316	48		pha				pha 								; save precedence level
.9317	20 ee 97	jsr $97ee			jsr 	EvaluateTerm 				; evaluate term into level X.
.931a	68		pla				pla 								; restore precedence level.
.931b					_EXPRLoop:
.931b	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.931d	b1 30		lda ($30),y			lda 	(codePtr),y
.931f	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9321	b0 25		bcs $9348			bcs 	_EXPRExit
.9323	da		phx				phx 								; read the operator precedence
.9324	aa		tax				tax
.9325	bd d2 92	lda $92d2,x			lda 	PrecedenceLevel,x
.9328	fa		plx				plx
.9329	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.932b	f0 1b		beq $9348			beq 	_EXPRExit
.932d	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.932f	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9331	c5 37		cmp $37				cmp 	zTemp0+1
.9333	b0 13		bcs $9348			bcs		_EXPRExit 					; if current >= operator exit
.9335	48		pha				pha 								; save current precedence.
.9336	b1 30		lda ($30),y			lda 	(codePtr),y
.9338	c8		iny				iny
.9339	48		pha				pha
.933a	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.933c	e8		inx				inx 								; work out the right hand side.
.933d	20 16 93	jsr $9316			jsr 	EvaluateExpressionAtPrecedence
.9340	ca		dex				dex
.9341	68		pla				pla 								; get operator, call the code.
.9342	20 4b 93	jsr $934b			jsr 	_EXPRCaller
.9345	68		pla				pla 								; restore precedence level
.9346	80 d3		bra $931b			bra 	_EXPRLoop 					; and go round.
.9348					_EXPRExit:
.9348	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.934a	60		rts				rts
.934b					_EXPRCaller:
.934b	da		phx				phx 								; save on stack, first thing is to restore it
.934c	0a		asl a				asl 	a 							; double so can use vectors into X
.934d	aa		tax				tax
.934e	7c 92 8a	jmp ($8a92,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9351					FloatingPointAdd:
.9351	20 fa 94	jsr $94fa			jsr 	FloatPrepare 				; prepare for floats
.9354	80 0b		bra $9361			bra 	FloatAdd
.9356					FloatingPointSub:
.9356	20 fa 94	jsr $94fa			jsr 	FloatPrepare 				; prepare for floats
.9359					FloatSubtract:
.9359	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.935c	49 80		eor #$80			eor 	#$80
.935e	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.9361					FloatAdd:
.9361	48		pha				pha
.9362	5a		phy				phy
.9363	20 0b 95	jsr $950b			jsr 	NSNormalise 				; normalise S[X]
.9366	f0 5c		beq $93c4			beq 	_FAReturn1
.9368	e8		inx				inx 								; normalise S[X+1]
.9369	20 0b 95	jsr $950b			jsr 	NSNormalise
.936c	ca		dex				dex
.936d	c9 00		cmp #$00			cmp 	#0
.936f	f0 77		beq $93e8			beq 	_FAExit 					; if so, just return A
.9371	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.9374	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.9377	f0 1b		beq $9394			beq 	_FAExponentsEqual
.9379	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.937c	a8		tay				tay
.937d	38		sec				sec 								; do a signed comparison of the exponents.
.937e	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9381	50 02		bvc $9385			bvc 	_FANoSignedChange
.9383	49 80		eor #$80			eor 	#$80
.9385					_FANoSignedChange:
.9385	29 80		and #$80			and 	#$80
.9387	10 03		bpl $938c			bpl 	_FAHaveMax
.9389	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.938c					_FAHaveMax:
.938c	20 eb 93	jsr $93eb			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.938f	e8		inx				inx
.9390	20 eb 93	jsr $93eb			jsr 	_FAShiftToExponent
.9393	ca		dex				dex
.9394					_FAExponentsEqual:
.9394	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.9397	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.939a	30 10		bmi $93ac			bmi 	_FADifferentSigns
.939c	20 9d 90	jsr $909d			jsr 	AddTopTwoStack 				; do the add of the mantissae
.939f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.93a2	10 44		bpl $93e8			bpl 	_FAExit 					; if no, we are done.
.93a4	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.93a7	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.93aa	80 3c		bra $93e8			bra 	_FAExit
.93ac					_FADifferentSigns:
.93ac	20 c3 90	jsr $90c3			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.93af	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.93b2	10 06		bpl $93ba			bpl 	_FACheckZero 				; if no, check for -0
.93b4	20 d4 9d	jsr $9dd4			jsr 	NSMNegate 					; netate result
.93b7	20 dd 9d	jsr $9ddd			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.93ba					_FACheckZero:
.93ba	20 58 9e	jsr $9e58			jsr 	NSMIsZero	 				; check for -0
.93bd	d0 29		bne $93e8			bne 	_FAExit
.93bf	9e 00 04	stz $0400,x			stz 	NSStatus,x
.93c2	80 24		bra $93e8			bra 	_FAExit
.93c4					_FAReturn1:
.93c4	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.93c7	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.93ca	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.93cd	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.93d0	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.93d3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.93d6	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.93d9	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.93dc	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.93df	9d 28 04	sta $0428,x			sta 	NSExponent,x
.93e2	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.93e5	9d 00 04	sta $0400,x			sta 	NSStatus,x
.93e8					_FAExit:
.93e8	7a		ply				ply
.93e9	68		pla				pla
.93ea	60		rts				rts
.93eb					_FAShiftToExponent:
.93eb					_FAShiftToExponent2:
.93eb	98		tya				tya 								; compare Y to exponent
.93ec	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.93ef	f0 08		beq $93f9			beq 	_FASEExit 					; exit if so.
.93f1	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight	 			; shift the mantissa right
.93f4	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.93f7	80 f2		bra $93eb			bra 	_FAShiftToExponent2
.93f9					_FASEExit:
.93f9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.93fa					CompareFloat:
.93fa	20 59 93	jsr $9359			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.93fd	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9400	29 f8		and #$f8			and 	#$F8
.9402	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9405	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.9408	f0 09		beq $9413			beq 	_FCExit 					; zero, so approximately identical
.940a	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.940c	3c 00 04	bit $0400,x			bit 	NSStatus,x
.940f	10 02		bpl $9413			bpl 	_FCExit
.9411					_FCNegative:
.9411	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9413					_FCExit:
.9413	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9414					FDivideCommand:
.9414	fa		plx				plx	 								; restore stack position
.9415	20 fa 94	jsr $94fa			jsr 	FloatPrepare 				; prepare for floats
.9418					FloatDivide:
.9418	48		pha				pha
.9419	e8		inx				inx
.941a	20 0b 95	jsr $950b			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.941d	ca		dex				dex
.941e	c9 00		cmp #$00			cmp 	#0
.9420	f0 20		beq $9442			beq 	_FDZero
.9422	20 0b 95	jsr $950b			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9425	f0 19		beq $9440			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9427	20 70 8f	jsr $8f70			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.942a	20 fd 8e	jsr $8efd			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.942d	20 0b 95	jsr $950b			jsr		NSNormalise 				; renormalise
.9430	20 0b 90	jsr $900b			jsr 	CalculateSign 				; calculate result sign
.9433	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.9436	38		sec				sec
.9437	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.943a	38		sec				sec
.943b	e9 1e		sbc #$1e			sbc 	#30
.943d	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9440					_FDExit:
.9440	68		pla				pla
.9441	60		rts				rts
.9442					_FDZero:
.9442	a9 03		lda #$03		lda	#3
.9444	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9447					FloatFractionalPart:
.9447	5a		phy				phy
.9448	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.944b	29 7f		and #$7f			and 	#$7F
.944d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9450	20 0b 95	jsr $950b			jsr 	NSNormalise
.9453	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9456	38		sec				sec
.9457	e9 e0		sbc #$e0			sbc 	#$E0
.9459	90 31		bcc $948c			bcc 	_FFPExit 					; already fractional
.945b	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.945d	b0 2a		bcs $9489			bcs 	_FFPZero
.945f	a8		tay				tay 								; put count to do in Y
.9460	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.9463	20 8e 94	jsr $948e			jsr 	_FFPPartial
.9466	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9469	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.946c	20 8e 94	jsr $948e			jsr 	_FFPPartial
.946f	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9472	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9475	20 8e 94	jsr $948e			jsr 	_FFPPartial
.9478	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.947b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.947e	20 8e 94	jsr $948e			jsr 	_FFPPartial
.9481	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9484	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; zeroed check.
.9487	d0 03		bne $948c			bne 	_FFPExit
.9489					_FFPZero:
.9489	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.948c					_FFPExit:
.948c	7a		ply				ply
.948d	60		rts				rts
.948e					_FFPPartial:
.948e	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9490	f0 17		beq $94a9			beq 	_FFFPPExit
.9492	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9494	b0 0c		bcs $94a2			bcs 	_FFFPPWholeByte
.9496	5a		phy				phy
.9497					_FFFPPLeft:
.9497	0a		asl a				asl 	a
.9498	88		dey				dey
.9499	d0 fc		bne $9497			bne 	_FFFPPLeft
.949b	7a		ply				ply
.949c					_FFFPPRight:
.949c	4a		lsr a				lsr 	a
.949d	88		dey				dey
.949e	d0 fc		bne $949c			bne 	_FFFPPRight
.94a0	80 07		bra $94a9			bra 	_FFFPPExit
.94a2					_FFFPPWholeByte:
.94a2	98		tya				tya 								; subtract 8 from count
.94a3	38		sec				sec
.94a4	e9 08		sbc #$08			sbc 	#8
.94a6	a8		tay				tay
.94a7	a9 00		lda #$00			lda 	#0 							; and clear all
.94a9					_FFFPPExit:
.94a9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.94aa					FloatIntegerPart:
.94aa	48		pha				pha
.94ab	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.94ae	f0 1f		beq $94cf			beq 	_FIPExit 					; if so do nothing
.94b0	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; is it zero ?
.94b3	f0 17		beq $94cc			beq 	_FIPZero 					; if so return zero.
.94b5	20 0b 95	jsr $950b			jsr 	NSNormalise 				; normalise
.94b8	f0 12		beq $94cc			beq 	_FIPZero 					; normalised to zero, exit zero
.94ba					_FIPShift:
.94ba	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.94bd	10 08		bpl $94c7			bpl 	_FIPCheckZero
.94bf	20 4b 9e	jsr $9e4b			jsr 	NSMShiftRight 				; shift mantissa right
.94c2	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.94c5	80 f3		bra $94ba			bra 	_FIPShift
.94c7					_FIPCheckZero:
.94c7	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; avoid -0 problem
.94ca	d0 03		bne $94cf			bne 	_FIPExit 					; set to zero if mantissa zero.
.94cc					_FIPZero:
.94cc	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.94cf					_FIPExit:
.94cf	68		pla				pla
.94d0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.94d1					FloatingPointMultiply:
.94d1	20 fa 94	jsr $94fa			jsr 	FloatPrepare 				; prepare for floats
.94d4					FloatMultiply:
.94d4	48		pha				pha
.94d5	20 0b 95	jsr $950b			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94d8	f0 1b		beq $94f5			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94da	e8		inx				inx
.94db	20 0b 95	jsr $950b			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94de	ca		dex				dex
.94df	c9 00		cmp #$00			cmp 	#0
.94e1	f0 0f		beq $94f2			beq 	_FDSetZero
.94e3	20 c6 8f	jsr $8fc6			jsr 	MultiplyShort 				; calculate the result.
.94e6	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.94e9	18		clc				clc
.94ea	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.94ed	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94f0	80 03		bra $94f5			bra 	_FDExit
.94f2					_FDSetZero:
.94f2	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; return 0
.94f5					_FDExit:
.94f5	20 0b 95	jsr $950b			jsr 	NSNormalise 				; normalise the result
.94f8	68		pla				pla
.94f9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.94fa					FloatPrepare:
.94fa	20 2d 96	jsr $962d			jsr 	DereferenceTopTwo 			; dereference the top two values
.94fd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.9500	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9503	29 10		and #$10			and 	#NSBIsString
.9505	d0 01		bne $9508			bne 	_FDType
.9507	60		rts				rts
.9508					_FDType:
.9508	4c bc 9f	jmp $9fbc			jmp 	TypeError
.950b					NSNormalise:
.950b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.950e	29 80		and #$80			and 	#$80
.9510	09 08		ora #$08			ora 	#NSTFloat
.9512	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9515	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; if zero exit
.9518	d0 09		bne $9523			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.951a	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.951d	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.9520	a9 00		lda #$00			lda 	#0 							; set Z flag
.9522	60		rts				rts
.9523					_NSNormaliseOptimise:
.9523	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.9526	d0 22		bne $954a			bne 	_NSNormaliseLoop
.9528	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.952b	30 1d		bmi $954a			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.952d	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9530	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9533	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9536	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9539	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.953c	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.953f	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9542	38		sec				sec
.9543	e9 08		sbc #$08			sbc 	#8
.9545	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9548	80 d9		bra $9523			bra 	_NSNormaliseOptimise
.954a					_NSNormaliseLoop:
.954a	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.954d	70 08		bvs $9557			bvs 	_NSNExit 					; exit if so with Z flag clear
.954f	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; shift mantissa left
.9552	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.9555	80 f3		bra $954a			bra 	_NSNormaliseLoop
.9557					_NSNExit:
.9557	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9559	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.955a					AssignNumber:
.955a	5a		phy				phy
.955b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.955e	85 36		sta $36				sta 	zTemp0
.9560	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9563	85 37		sta $37				sta 	zTemp0+1
.9565	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.9568	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.956a	9d 00 04	sta $0400,x			sta 	NSStatus,x
.956d	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.956f	c9 08		cmp #$08			cmp 	#NSTFloat
.9571	f0 2a		beq $959d			beq 	_ANFloat
.9573	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.9576	f0 05		beq $957d			beq		_ANNotFloat
.9578	e8		inx				inx
.9579	20 aa 94	jsr $94aa			jsr 	FloatIntegerPart 			; make it an integer
.957c	ca		dex				dex
.957d					_ANNotFloat:
.957d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.9580	29 03		and #$03			and 	#3
.9582	d0 05		bne $9589			bne 	_ANByteWord
.9584	20 a9 95	jsr $95a9			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9587	80 1e		bra $95a7			bra 	_ANExit
.9589					_ANByteWord:
.9589	48		pha				pha 								; save count
.958a	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.958d	92 36		sta ($36)			sta 	(zTemp0)
.958f	68		pla				pla
.9590	c9 01		cmp #$01			cmp	 	#1
.9592	f0 13		beq $95a7			beq 	_ANExit
.9594	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.9597	a0 01		ldy #$01			ldy 	#1
.9599	91 36		sta ($36),y			sta 	(zTemp0),y
.959b	80 0a		bra $95a7			bra 	_ANExit
.959d					_ANFloat:
.959d	20 a9 95	jsr $95a9			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.95a0	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.95a3	a0 04		ldy #$04			ldy 	#4
.95a5	91 36		sta ($36),y			sta 	(zTemp0),y
.95a7					_ANExit:
.95a7	7a		ply				ply
.95a8	60		rts				rts
.95a9					_ANCopy4PackSign:
.95a9	a0 03		ldy #$03			ldy 	#3
.95ab	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.95ae	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.95b0	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.95b3	91 36		sta ($36),y			sta 	(zTemp0),y
.95b5	88		dey				dey
.95b6	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.95b9	91 36		sta ($36),y			sta 	(zTemp0),y
.95bb	88		dey				dey
.95bc	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95bf	91 36		sta ($36),y			sta 	(zTemp0),y
.95c1	88		dey				dey
.95c2	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95c5	91 36		sta ($36),y			sta 	(zTemp0),y
.95c7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95c8					AssignString:
.95c8	5a		phy				phy
.95c9	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95cc	85 38		sta $38				sta 	zTemp1
.95ce	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95d1	85 39		sta $39				sta 	zTemp1+1
.95d3	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95d6	85 36		sta $36				sta 	zTemp0
.95d8	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95db	85 37		sta $37				sta 	zTemp0+1
.95dd	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.95df	b1 36		lda ($36),y			lda 	(zTemp0),y
.95e1	f0 23		beq $9606			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.95e3	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.95e4	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.95e6	e9 02		sbc #$02			sbc 	#2
.95e8	85 3c		sta $3c				sta 	zsTemp
.95ea	a0 01		ldy #$01			ldy 	#1
.95ec	b1 36		lda ($36),y			lda 	(zTemp0),y
.95ee	e9 00		sbc #$00			sbc 	#0
.95f0	85 3d		sta $3d				sta 	zsTemp+1
.95f2	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.95f4					_ASGetLength:
.95f4	c8		iny				iny
.95f5	b1 38		lda ($38),y			lda 	(zTemp1),y
.95f7	d0 fb		bne $95f4			bne 	_ASGetLength
.95f9	98		tya				tya 								; is this length <= current length
.95fa	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.95fc	90 20		bcc $961e			bcc 	_ASCopyString
.95fe	f0 1e		beq $961e			beq 	_ASCopyString
.9600	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9602	a0 01		ldy #$01			ldy 	#1
.9604	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9606					_ASNewStringRequired:
.9606	e8		inx				inx 								; concrete the new string.
.9607	20 f4 a6	jsr $a6f4			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.960a	ca		dex				dex
.960b	18		clc				clc
.960c	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.960f	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9611	92 36		sta ($36)			sta 	(zTemp0)
.9613	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9616	69 00		adc #$00			adc 	#0
.9618	a0 01		ldy #$01			ldy 	#1
.961a	91 36		sta ($36),y			sta 	(zTemp0),y
.961c	80 0d		bra $962b			bra 	_ASExit
.961e					_ASCopyString:
.961e	a0 00		ldy #$00			ldy 	#0
.9620					_ASCopyLoop:
.9620	b1 38		lda ($38),y			lda 	(zTemp1),y
.9622	c8		iny				iny
.9623	c8		iny				iny
.9624	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9626	88		dey				dey
.9627	c9 00		cmp #$00			cmp 	#0
.9629	d0 f5		bne $9620			bne 	_ASCopyLoop
.962b					_ASExit:
.962b	7a		ply				ply
.962c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.962d					DereferenceTopTwo:
.962d	e8		inx				inx
.962e	20 32 96	jsr $9632			jsr 	Dereference 				; deref x+1
.9631	ca		dex				dex  								; falls through to deref x
.9632					Dereference:
.9632	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.9635	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.9637	f0 57		beq $9690			beq 	_DRFExit 					; not a reference
.9639	5a		phy				phy
.963a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.963d	85 36		sta $36				sta 	zTemp0
.963f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9642	85 37		sta $37				sta 	zTemp0+1
.9644	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.9647	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.9649	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.964c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.964f	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9651	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9653	f0 0f		beq $9664			beq 	_DRFDereferenceTwo
.9655	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9657	f0 39		beq $9692			beq 	_DRFFull
.9659	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.965c	29 03		and #$03			and 	#3
.965e	f0 32		beq $9692			beq 	_DRFFull 					; the whole word
.9660	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9662	f0 07		beq $966b			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9664					_DRFDereferenceTwo:
.9664	a0 01		ldy #$01			ldy 	#1
.9666	b1 36		lda ($36),y			lda 	(zTemp0),y
.9668	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.966b					_DRFClear23:
.966b	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.966e	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9671	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.9674	29 18		and #$18			and 	#NSBTypeMask
.9676	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9679	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.967b	d0 12		bne $968f			bne 	_DRFNotString
.967d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.9680	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9683	d0 0a		bne $968f			bne 	_DRFNotString
.9685	a9 91		lda #$91			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9687	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.968a	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.968c	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.968f					_DRFNotString
.968f	7a		ply				ply 								; restore Y and exit
.9690					_DRFExit:
.9690	60		rts				rts
.9691					_DRFNullString:
>9691	00						.byte 	0
.9692					_DRFFull:
.9692	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9694	b1 36		lda ($36),y			lda 	(zTemp0),y
.9696	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9699	c8		iny				iny
.969a	b1 36		lda ($36),y			lda 	(zTemp0),y
.969c	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.969f	c8		iny				iny
.96a0	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a2	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96a5	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.96a8	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.96ab	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96ad	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.96b0	f0 06		beq $96b8			beq 	_DRFNoExponent
.96b2	c8		iny				iny 								; if not, read the exponent as well.
.96b3	b1 36		lda ($36),y			lda 	(zTemp0),y
.96b5	9d 28 04	sta $0428,x			sta 	NSExponent,x
.96b8					_DRFNoExponent:
.96b8	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96bb	10 0d		bpl $96ca			bpl 	_DRFExit2 					; if not, then exit.
.96bd	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96bf	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96c2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.96c5	09 80		ora #$80			ora 	#NSBIsNegative
.96c7	9d 00 04	sta $0400,x			sta 	NSStatus,x
.96ca					_DRFExit2:
.96ca	7a		ply				ply
.96cb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.96cc					EncodeNumberStart:
.96cc	38		sec				sec
.96cd	80 01		bra $96d0			bra 	EncodeNumberContinue+1
.96cf					EncodeNumberContinue:
.96cf	18		clc				clc
.96d0					EncodeNumber:
.96d0	08		php				php 								; save reset.
.96d1	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.96d3	f0 12		beq $96e7			beq 	_ENIsOkay
.96d5	c9 30		cmp #$30			cmp 	#"0"
.96d7	90 04		bcc $96dd			bcc 	_ENBadNumber
.96d9	c9 3a		cmp #$3a			cmp 	#"9"+1
.96db	90 0a		bcc $96e7			bcc 	_ENIsOkay
.96dd					_ENBadNumber:
.96dd	28		plp				plp 								; throw saved reset
.96de	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.96e1	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96e3	f0 7e		beq $9763			beq 	_ENConstructFinal
.96e5					_ENFail:
.96e5	18		clc				clc 								; not allowed
.96e6	60		rts				rts
.96e7					_ENIsOkay:
.96e7	28		plp				plp 								; are we restarting
.96e8	90 15		bcc $96ff			bcc 	_ENNoRestart
.96ea					_ENStartEncode:
.96ea	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.96ec	f0 0c		beq $96fa			beq 	_ENFirstDP
.96ee	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.96f0	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.96f3	a9 01		lda #$01			lda 	#ESTA_Low
.96f5					_ENExitChange:
.96f5	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.96f8	38		sec				sec
.96f9	60		rts				rts
.96fa					_ENFirstDP:
.96fa	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; clear integer part
.96fd	80 3f		bra $973e			bra 	_ESTASwitchFloat			; go straight to float and exi
.96ff					_ENNoRestart:
.96ff	48		pha				pha 								; save on stack.
.9700	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.9703	c9 01		cmp #$01			cmp 	#ESTA_Low
.9705	f0 09		beq $9710			beq  	_ESTALowState
.9707	c9 02		cmp #$02			cmp 	#ESTA_High
.9709	f0 29		beq $9734			beq 	_ESTAHighState
.970b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.970d	f0 3b		beq $974a			beq 	_ESTADecimalState
>970f	db						.byte 	$DB 						; causes a break in the emulator
.9710					_ESTALowState:
.9710	68		pla				pla 								; get value back
.9711	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9713	f0 29		beq $973e			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9715	29 0f		and #$0f			and 	#15 						; make digit
.9717	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.971a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.971d	0a		asl a				asl 	a
.971e	0a		asl a				asl 	a
.971f	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9722	0a		asl a				asl 	a
.9723	6d 86 04	adc $0486			adc 	DigitTemp
.9726	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9729	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.972b	90 05		bcc $9732			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.972d	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.972f	8d 85 04	sta $0485			sta 	EncodeState
.9732					_ESTANoSwitch:
.9732	38		sec				sec
.9733	60		rts				rts
.9734					_ESTAHighState:
.9734	68		pla				pla 								; get value back
.9735	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.9737	f0 05		beq $973e			beq 	_ESTASwitchFloat
.9739	20 9d 97	jsr $979d			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.973c	38		sec				sec
.973d	60		rts				rts
.973e					_ESTASwitchFloat:
.973e	9c 87 04	stz $0487			stz 	DecimalCount
.9741	e8		inx				inx 								; zero the decimal additive.
.9742	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.9745	ca		dex				dex
.9746	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9748	80 ab		bra $96f5			bra 	_ENExitChange
.974a					_ESTADecimalState:
.974a	68		pla				pla 								; digit.
.974b	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.974d	f0 96		beq $96e5			beq 	_ENFail
.974f	e8		inx				inx 								; put digit into fractional part of X+1
.9750	20 9d 97	jsr $979d			jsr 	ESTAShiftDigitIntoMantissa
.9753	ca		dex				dex
.9754	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.9757	ad 87 04	lda $0487			lda 	DecimalCount
.975a	c9 0b		cmp #$0b			cmp 	#11
.975c	f0 02		beq $9760			beq 	_ESTADSFail
.975e	38		sec				sec
.975f	60		rts				rts
.9760					_ESTADSFail:
.9760	4c b7 9f	jmp $9fb7			jmp 	RangeError
.9763					_ENConstructFinal:
.9763	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.9766	f0 33		beq $979b			beq 	_ENCFExit 					; no decimals
.9768	5a		phy				phy
.9769	0a		asl a				asl 	a 							; x 4 and CLC
.976a	0a		asl a				asl 	a
.976b	6d 87 04	adc $0487			adc 	DecimalCount
.976e	a8		tay				tay
.976f	b9 76 9f	lda $9f76,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9772	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9775	b9 77 9f	lda $9f77,y			lda 	DecimalScalarTable-5+1,y
.9778	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.977b	b9 78 9f	lda $9f78,y			lda 	DecimalScalarTable-5+2,y
.977e	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9781	b9 79 9f	lda $9f79,y			lda 	DecimalScalarTable-5+3,y
.9784	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9787	b9 7a 9f	lda $9f7a,y			lda 	DecimalScalarTable-5+4,y
.978a	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.978d	a9 08		lda #$08			lda 	#NSTFloat
.978f	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9792	7a		ply				ply
.9793	e8		inx				inx 								; multiply decimal const by decimal scalar
.9794	20 d4 94	jsr $94d4			jsr 	FloatMultiply
.9797	ca		dex				dex
.9798	20 61 93	jsr $9361			jsr 	FloatAdd 					; add to integer part.
.979b					_ENCFExit:
.979b	18		clc				clc 								; reject the digit.
.979c	60		rts				rts
.979d					ESTAShiftDigitIntoMantissa:
.979d	29 0f		and #$0f			and 	#15 						; save digit
.979f	48		pha				pha
.97a0	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.97a3	48		pha				pha
.97a4	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.97a7	48		pha				pha
.97a8	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.97ab	48		pha				pha
.97ac	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.97af	48		pha				pha
.97b0	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 2
.97b3	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 4
.97b6	18		clc				clc 								; pop mantissa and add
.97b7	68		pla				pla
.97b8	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97bb	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97be	68		pla				pla
.97bf	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.97c2	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.97c5	68		pla				pla
.97c6	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.97c9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.97cc	68		pla				pla
.97cd	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.97d0	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.97d3	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 10
.97d6	68		pla				pla 								; add digit
.97d7	18		clc				clc
.97d8	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97db	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97de	90 0d		bcc $97ed			bcc 	_ESTASDExit
.97e0	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.97e3	d0 08		bne $97ed			bne 	_ESTASDExit
.97e5	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.97e8	d0 03		bne $97ed			bne 	_ESTASDExit
.97ea	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.97ed					_ESTASDExit:
.97ed	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.97ee					EvaluateTerm:
.97ee	b1 30		lda ($30),y			lda 	(codePtr),y
.97f0	30 18		bmi $980a			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.97f2	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.97f4	b0 6f		bcs $9865			bcs 	_ETVariable
.97f6	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.97f8	90 6e		bcc $9868			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.97fa	c9 3a		cmp #$3a			cmp 	#'9'+1
.97fc	b0 6a		bcs $9868			bcs 	_ETPuncUnary
.97fe	20 cc 96	jsr $96cc			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9801					_ETNumber:
.9801	c8		iny				iny 								; keep encoding until we have the numbers
.9802	b1 30		lda ($30),y			lda 	(codePtr),y
.9804	20 cf 96	jsr $96cf			jsr 	EncodeNumberContinue
.9807	b0 f8		bcs $9801			bcs 	_ETNumber 					; go back if accepted.
.9809	60		rts				rts
.980a					_ETCheckUnary:
.980a	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.980c	f0 41		beq $984f			beq 	_ETString
.980e	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9810	f0 12		beq $9824			beq 	_ETHexConstant
.9812	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9814	90 0b		bcc $9821			bcc 	_ETSyntaxError
.9816	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.9818	b0 07		bcs $9821			bcs 	_ETSyntaxError
.981a	da		phx				phx 								; push X on the stack
.981b	0a		asl a				asl 	a 							; put vector x 2 into X
.981c	aa		tax				tax
.981d	c8		iny				iny 								; consume unary function token
.981e	7c 12 8b	jmp ($8b12,x)			jmp 	(VectorSet0,x) 				; and do it.
.9821					_ETSyntaxError:
.9821	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.9824					_ETHexConstant:
.9824	c8		iny				iny 								; skip #
.9825	c8		iny				iny 								; skip count
.9826	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; clear result
.9829					_ETHLoop:
.9829	b1 30		lda ($30),y			lda 	(codePtr),y
.982b	c8		iny				iny 								; and consume
.982c	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.982e	f0 1e		beq $984e			beq 	_ETHExit
.9830	48		pha				pha 								; save on stack.
.9831	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 2
.9834	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 4
.9837	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 8
.983a	20 3d 9e	jsr $9e3d			jsr 	NSMShiftLeft 				; x 16
.983d	68		pla				pla 								; ASCII
.983e	c9 41		cmp #$41			cmp 	#'A'
.9840	90 02		bcc $9844			bcc 	_ETHNotChar
.9842	e9 07		sbc #$07			sbc 	#7
.9844					_ETHNotChar:
.9844	29 0f		and #$0f			and 	#15 						; digit now
.9846	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.9849	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.984c	80 db		bra $9829			bra 	_ETHLoop 					; go round.
.984e					_ETHExit:
.984e	60		rts				rts
.984f					_ETString:
.984f	c8		iny				iny 								; look at length
.9850	b1 30		lda ($30),y			lda 	(codePtr),y
.9852	48		pha				pha
.9853	c8		iny				iny 								; first character
.9854	20 ad a5	jsr $a5ad			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9857	68		pla				pla 								; restore count and save
.9858	85 36		sta $36				sta 	zTemp0
.985a	98		tya				tya 								; add length to Y to skip it.
.985b	18		clc				clc
.985c	65 36		adc $36				adc 	zTemp0
.985e	a8		tay				tay
.985f	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9861	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9864	60		rts				rts
.9865					_ETVariable:
.9865	4c bf 98	jmp $98bf			jmp 	VariableHandler
.9868					_ETPuncUnary:
.9868	c8		iny				iny 								; consume the unary character
.9869	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.986b	f0 2d		beq $989a			beq 	_ETUnaryNegate
.986d	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.986f	f0 39		beq $98aa			beq 	_ETDereference
.9871	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9873	f0 43		beq $98b8			beq 	_ETParenthesis
.9875	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9877	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9879	f0 06		beq $9881			beq 	_ETIndirection
.987b	e6 36		inc $36				inc 	zTemp0
.987d	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.987f	d0 a0		bne $9821			bne 	_ETSyntaxError
.9881					_ETIndirection:
.9881	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9883	1a		inc a				inc 	a
.9884	48		pha				pha
.9885	20 ee 97	jsr $97ee			jsr 	EvaluateTerm				; evaluate the term
.9888	20 32 96	jsr $9632			jsr 	Dereference 				; dereference it.
.988b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.988e	d0 07		bne $9897			bne 	_ETTypeMismatch
.9890	68		pla				pla 								; indirection 1-2
.9891	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9893	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9896	60		rts				rts
.9897					_ETTypeMismatch:
.9897	4c bc 9f	jmp $9fbc			jmp 	TypeError
.989a					_ETUnaryNegate:
.989a	20 ee 97	jsr $97ee			jsr 	EvaluateTerm				; evaluate the term
.989d	20 32 96	jsr $9632			jsr 	Dereference 				; dereference it.
.98a0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.98a3	29 10		and #$10			and 	#NSTString
.98a5	d0 f0		bne $9897			bne 	_ETTypeMismatch
.98a7	4c d4 9d	jmp $9dd4			jmp 	NSMNegate  					; just toggles the sign bit.
.98aa					_ETDereference:
.98aa	20 ee 97	jsr $97ee			jsr 	EvaluateTerm				; evaluate the term
.98ad	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.98b0	29 20		and #$20			and 	#NSBIsReference
.98b2	f0 e3		beq $9897			beq 	_ETTypeMismatch
.98b4	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.98b7	60		rts				rts
.98b8					_ETParenthesis:
.98b8	20 14 93	jsr $9314			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.98bb	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; check for )
.98be	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.98bf					VariableHandler:
.98bf	b1 30		lda ($30),y			lda 	(codePtr),y
.98c1	18		clc				clc
.98c2	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98c4	85 37		sta $37				sta 	zTemp0+1
.98c6	c8		iny				iny
.98c7	b1 30		lda ($30),y			lda 	(codePtr),y
.98c9	85 36		sta $36				sta 	zTemp0
.98cb	c8		iny				iny
.98cc	18		clc				clc									; copy variable address+3 to mantissa
.98cd	69 03		adc #$03			adc 	#3
.98cf	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98d2	a5 37		lda $37				lda 	zTemp0+1
.98d4	69 00		adc #$00			adc 	#0
.98d6	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.98d9	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.98dc	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.98df	9e 28 04	stz $0428,x			stz 	NSExponent,x
.98e2	5a		phy				phy
.98e3	a0 02		ldy #$02			ldy 	#2 							; read type
.98e5	b1 36		lda ($36),y			lda 	(zTemp0),y
.98e7	7a		ply				ply
.98e8	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98ea	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98ec	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98ef	29 04		and #$04			and 	#NSBIsArray
.98f1	d0 01		bne $98f4			bne 	_VHArray
.98f3	60		rts				rts
.98f4					_VHArray:
.98f4	e8		inx				inx
.98f5	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get the 1st index.
.98f8	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.98fa	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.98fd	b1 30		lda ($30),y			lda 	(codePtr),y
.98ff	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9901	d0 06		bne $9909			bne 	_VHNoSecondIndex
.9903	c8		iny				iny 								; skip the comma
.9904	e8		inx				inx
.9905	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9908	ca		dex				dex
.9909					_VHNoSecondIndex:
.9909	ca		dex				dex 								; set X back.
.990a	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; and check the right bracket.
.990d	5a		phy				phy 								; save position
.990e	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9910	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9912	f0 6b		beq $997f			beq 	_VHBadIndex
.9914	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.9917	85 3e		sta $3e				sta 	zaTemp
.9919	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.991c	85 3f		sta $3f				sta 	zaTemp+1
.991e	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9920	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9922	f0 02		beq $9926			beq 	_VHHas2Mask
.9924	a9 ff		lda #$ff			lda 	#$FF
.9926					_VHHas2Mask:
.9926	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9929	f0 54		beq $997f			beq 	_VHBadIndex
.992b	0a		asl a				asl 	a 							; carry will be set if a second index
.992c	90 09		bcc $9937			bcc 	_VHCheckFirstIndex
.992e	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9930	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9932	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.9935	90 48		bcc $997f			bcc 	_VHBadIndex
.9937					_VHCheckFirstIndex:
.9937	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9939	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.993b	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.993e	90 3f		bcc $997f			bcc 	_VHBadIndex
.9940	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9942	64 37		stz $37				stz 	zTemp0+1
.9944	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9947	30 0f		bmi $9958			bmi 	_VHNoMultiply
.9949	da		phx				phx
.994a	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.994d	48		pha				pha
.994e	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9950	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9952	1a		inc a				inc 	a 							; add 1 for zero base
.9953	fa		plx				plx
.9954	20 bd 9d	jsr $9dbd			jsr 	Multiply8x8 				; calculate -> Z0
.9957	fa		plx				plx
.9958					_VHNoMultiply:
.9958	18		clc				clc
.9959	a5 36		lda $36				lda 	zTemp0
.995b	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.995e	85 36		sta $36				sta 	zTemp0
.9960	a5 37		lda $37				lda 	zTemp0+1
.9962	69 00		adc #$00			adc 	#0
.9964	85 37		sta $37				sta 	zTemp0+1
.9966	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9969	20 f0 84	jsr $84f0			jsr 	ScaleByBaseType
.996c	18		clc				clc
.996d	b2 3e		lda ($3e)			lda 	(zaTemp)
.996f	65 36		adc $36				adc 	zTemp0
.9971	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9974	a0 01		ldy #$01			ldy 	#1
.9976	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9978	65 37		adc $37				adc 	zTemp0+1
.997a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.997d	7a		ply				ply 								; restore position
.997e	60		rts				rts
.997f					_VHBadIndex:
.997f	a9 17		lda #$17		lda	#23
.9981	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9984					AbsUnary:
.9984	fa		plx				plx 								; restore stack pos
.9985	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; get a float or int
.9988	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.998b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.998e	29 7f		and #$7f			and 	#$7F
.9990	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9993	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9994					AllocUnary:
.9994	fa		plx				plx 								; restore stack pos
.9995	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger		; get bytes required.
.9998	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.999b	da		phx				phx 								; save X/Y
.999c	5a		phy				phy
.999d	8a		txa				txa 								; copy X into Y
.999e	a8		tay				tay
.999f	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.99a2	aa		tax				tax
.99a3	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.99a6	20 b3 99	jsr $99b3			jsr 	AllocateXABytes 			; allocate memory
.99a9	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.99ac	8a		txa				txa
.99ad	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.99b0	7a		ply				ply
.99b1	fa		plx				plx
.99b2	60		rts				rts
.99b3					AllocateXABytes:
.99b3	5a		phy				phy
.99b4	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99b7	84 36		sty $36				sty 	zTemp0
.99b9	5a		phy				phy
.99ba	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.99bd	84 37		sty $37				sty 	zTemp0+1
.99bf	5a		phy				phy
.99c0	18		clc				clc 								; add to low memory pointer
.99c1	6d 8c 04	adc $048c			adc 	lowMemPtr
.99c4	8d 8c 04	sta $048c			sta 	lowMemPtr
.99c7	8a		txa				txa
.99c8	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.99cb	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.99ce	b0 2f		bcs $99ff			bcs 	CISSMemory
.99d0	20 f1 99	jsr $99f1			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.99d3					_ClearMemory:
.99d3	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.99d6	c5 36		cmp $36				cmp 	zTemp0
.99d8	d0 07		bne $99e1			bne 	_CMClearNext
.99da	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.99dd	c5 37		cmp $37				cmp 	zTemp0+1
.99df	f0 0c		beq $99ed			beq 	_CMExit
.99e1					_CMClearNext:
.99e1	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99e3	92 36		sta ($36)			sta 	(zTemp0)
.99e5	e6 36		inc $36				inc 	zTemp0
.99e7	d0 ea		bne $99d3			bne 	_ClearMemory
.99e9	e6 37		inc $37				inc		zTemp0+1
.99eb	80 e6		bra $99d3			bra 	_ClearMemory
.99ed					_CMExit:
.99ed	fa		plx				plx
.99ee	68		pla				pla
.99ef	7a		ply				ply
.99f0	60		rts				rts
.99f1					CheckIdentifierStringSpace:
.99f1	48		pha				pha
.99f2	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.99f5	18		clc				clc
.99f6	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99f8	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.99fb	b0 02		bcs $99ff			bcs 	CISSMemory
.99fd	68		pla				pla
.99fe	60		rts				rts
.99ff					CISSMemory:
.99ff	a9 06		lda #$06		lda	#6
.9a01	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a04					AscUnary:
.9a04	fa		plx				plx 								; restore stack pos
.9a05	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get a string
.9a08	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9a0a	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9a0d	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9a10	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a11					FracUnary:
.9a11	fa		plx				plx 								; restore stack pos
.9a12	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; get a float or int
.9a15	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9a18	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a1b	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a1d	f0 04		beq $9a23			beq 	_IUZero
.9a1f	20 47 94	jsr $9447			jsr 	FloatFractionalPart
.9a22	60		rts				rts
.9a23					_IUZero:
.9a23	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.9a26	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a27					IntUnary:
.9a27	fa		plx				plx 								; restore stack pos
.9a28	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; get a float or int
.9a2b	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9a2e	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a31	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a33	f0 03		beq $9a38			beq 	_IUExit
.9a35	20 aa 94	jsr $94aa			jsr 	FloatIntegerPart
.9a38					_IUExit:
.9a38	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a39					LenUnary:
.9a39	fa		plx				plx 								; restore stack pos
.9a3a	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get a string
.9a3d	5a		phy				phy
.9a3e	a0 00		ldy #$00			ldy 	#0 							; find length
.9a40					_LenFind:
.9a40	b1 36		lda ($36),y			lda 	(zTemp0),y
.9a42	f0 06		beq $9a4a			beq 	_LenExit
.9a44	c8		iny				iny
.9a45	d0 f9		bne $9a40			bne 	_LenFind
.9a47	4c b7 9f	jmp $9fb7			jmp 	RangeError 					; string > 255
.9a4a					_LenExit:
.9a4a	98		tya				tya
.9a4b	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9a4e	7a		ply				ply
.9a4f	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9a52	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a53					Unary_Min:
.9a53	a9 01		lda #$01			lda 	#1
.9a55	80 02		bra $9a59			bra 	UnaryMinMaxMain
.9a57					Unary_Max:
.9a57	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a59					UnaryMinMaxMain:
.9a59	fa		plx				plx 								; get index on number stack
.9a5a	48		pha				pha 								; save comparator
.9a5b	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get the first value.
.9a5e					_UMMMLoop:
.9a5e	b1 30		lda ($30),y			lda 	(codePtr),y
.9a60	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a62	f0 22		beq $9a86			beq 	_UMMMDone
.9a64	20 54 8d	jsr $8d54			jsr 	CheckComma 					; must be a comma
.9a67	e8		inx				inx
.9a68	20 48 9d	jsr $9d48			jsr 	EvaluateValue
.9a6b	ca		dex				dex
.9a6c	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a6f	e8		inx				inx
.9a70	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a73	e8		inx				inx
.9a74	20 1d 8e	jsr $8e1d			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a77	ca		dex				dex
.9a78	ca		dex				dex
.9a79	85 36		sta $36				sta 	zTemp0 						; save required result
.9a7b	68		pla				pla 								; get and save comparator
.9a7c	48		pha				pha
.9a7d	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a7f	d0 dd		bne $9a5e			bne 	_UMMMLoop
.9a81	20 89 9a	jsr $9a89			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a84	80 d8		bra $9a5e			bra 	_UMMMLoop
.9a86					_UMMMDone:
.9a86	68		pla				pla 								; throw the comparator
.9a87	c8		iny				iny 								; skip )
.9a88	60		rts				rts
.9a89					ExpCopyAboveDown:
.9a89	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9a8c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a8f	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9a92	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9a95	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9a98	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a9b	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9a9e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9aa1	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9aa4	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9aa7	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9aaa	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9aad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9aae					Unary_Not:
.9aae	fa		plx				plx
.9aaf	20 74 9d	jsr $9d74			jsr 	EvaluateInteger 			; get integer
.9ab2	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9ab5	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; zero mantissa ?
.9ab8	f0 04		beq $9abe			beq 	_NotZero
.9aba	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.9abd	60		rts				rts
.9abe					_NotZero:
.9abe	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.9ac1					_UNBad:
.9ac1	4c c1 9f	jmp $9fc1			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9ac4					Unary_Random:
.9ac4	fa		plx				plx
.9ac5	20 43 9b	jsr $9b43			jsr 	Random32Bit 				; get a random number
.9ac8	20 28 9b	jsr $9b28			jsr 	URCopyToMantissa  			; put in mantissa
.9acb	b1 30		lda ($30),y			lda 	(codePtr),y
.9acd	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9acf	f0 08		beq $9ad9			beq 	_URNoModulus
.9ad1	e8		inx				inx
.9ad2	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9ad5	ca		dex				dex
.9ad6	20 41 8f	jsr $8f41			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9ad9					_URNoModulus:
.9ad9	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9adc	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9adf	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9ae2	60		rts				rts
.9ae3					Unary_Rnd:
.9ae3	fa		plx				plx
.9ae4	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; number to use.
.9ae7	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; closing bracket
.9aea	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9aed	f0 2b		beq $9b1a			beq 	_URCopySeed
.9aef	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9af2	10 23		bpl $9b17			bpl 	_URDontSeed
.9af4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9af7	49 17		eor #$17			eor 	#$17
.9af9	8d 88 04	sta $0488			sta 	RandomSeed+0
.9afc	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9aff	49 a5		eor #$a5			eor 	#$A5
.9b01	8d 89 04	sta $0489			sta 	RandomSeed+1
.9b04	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9b07	49 c2		eor #$c2			eor 	#$C2
.9b09	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9b0c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9b0f	49 9d		eor #$9d			eor 	#$9D
.9b11	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9b14	20 43 9b	jsr $9b43			jsr 	Random32Bit
.9b17					_URDontSeed:
.9b17	20 43 9b	jsr $9b43			jsr 	Random32Bit 				; generate a number.
.9b1a					_URCopySeed:
.9b1a	20 28 9b	jsr $9b28			jsr 	URCopyToMantissa 			; copy into mantissa
.9b1d	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b1f	8d 28 04	sta $0428			sta 	NSExponent
.9b22	a9 08		lda #$08			lda 	#NSTFloat
.9b24	8d 00 04	sta $0400			sta 	NSStatus 					; positive.
.9b27	60		rts				rts
.9b28					URCopyToMantissa:
.9b28	ad 88 04	lda $0488			lda 	RandomSeed+0
.9b2b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b2e	ad 89 04	lda $0489			lda 	RandomSeed+1
.9b31	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b34	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9b37	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b3a	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9b3d	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b3f	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b42	60		rts				rts
.9b43					Random32Bit:
.9b43	5a		phy				phy
.9b44	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b46	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9b49	d0 03		bne $9b4e			bne 	_Random1
.9b4b	a8		tay				tay 								; if so do it 256 times
.9b4c	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b4e					_Random1:
.9b4e	0a		asl a				asl 	a 							; LSFR RNG
.9b4f	2e 89 04	rol $0489			rol 	RandomSeed+1
.9b52	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9b55	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9b58	90 02		bcc $9b5c			bcc 	_Random2
.9b5a	49 c5		eor #$c5			eor 	#$C5
.9b5c					_Random2:
.9b5c	88		dey				dey
.9b5d	d0 ef		bne $9b4e			bne 	_Random1
.9b5f	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b62	7a		ply				ply
.9b63	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b64					SgnUnary:
.9b64	fa		plx				plx 								; restore stack pos
.9b65	20 51 9d	jsr $9d51			jsr 	EvaluateNumber 				; get a float or int
.9b68	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9b6b	20 58 9e	jsr $9e58			jsr 	NSMIsZero 					; if zero
.9b6e	f0 10		beq $9b80			beq 	_SGZero  					; return Int Zero
.9b70	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9b73	48		pha				pha
.9b74	a9 01		lda #$01			lda 	#1 							; set to 1
.9b76	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9b79	68		pla				pla
.9b7a	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b7c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b7f	60		rts				rts
.9b80	20 28 9e	jsr $9e28	_SGZero:jsr 	NSMSetZero
.9b83	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b84					ValUnary:
.9b84	fa		plx				plx 								; restore stack pos
.9b85	20 9a 9b	jsr $9b9a			jsr 	ValMainCode 				; do the main val() code
.9b88	b0 01		bcs $9b8b			bcs 	_VUError 					; couldn't convert
.9b8a	60		rts				rts
.9b8b					_VUError:
.9b8b	4c bc 9f	jmp $9fbc			jmp 	TypeError
.9b8e					IsValUnary:
.9b8e	fa		plx				plx 								; restore stack pos
.9b8f	20 9a 9b	jsr $9b9a			jsr 	ValMainCode 				; do the main val() code
.9b92	b0 03		bcs $9b97			bcs 	_VUBad
.9b94	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.9b97					_VUBad:
.9b97	4c de 8d	jmp $8dde			jmp 	ReturnFalse
.9b9a					ValMainCode:
.9b9a	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get a string
.9b9d	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; check right bracket present
.9ba0	5a		phy				phy
.9ba1	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9ba3	f0 17		beq $9bbc			beq 	_VMCFail2
.9ba5	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9ba7	48		pha				pha 								; save first character
.9ba8	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9baa	d0 01		bne $9bad			bne 	_VMCStart
.9bac	c8		iny				iny 								; skip over -
.9bad					_VMCStart:
.9bad	38		sec				sec 								; initialise first time round.
.9bae					_VMCNext:
.9bae	c8		iny				iny 								; pre-increment
.9baf	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9bb1	f0 0c		beq $9bbf			beq 	_VMCSuccess 				; successful.
.9bb3	20 d0 96	jsr $96d0			jsr 	EncodeNumber 				; send it to the number-builder
.9bb6	90 03		bcc $9bbb			bcc 	_VMCFail 					; if failed, give up.
.9bb8	18		clc				clc 								; next time round, countinue
.9bb9	80 f3		bra $9bae			bra 	_VMCNext
.9bbb					_VMCFail:
.9bbb	68		pla				pla
.9bbc					_VMCFail2:
.9bbc	7a		ply				ply
.9bbd	38		sec				sec
.9bbe	60		rts				rts
.9bbf					_VMCSuccess:
.9bbf	a9 00		lda #$00			lda 	#0 							; construct final
.9bc1	20 d0 96	jsr $96d0			jsr 	EncodeNumber
.9bc4	68		pla				pla
.9bc5	c9 2d		cmp #$2d			cmp 	#"-"
.9bc7	d0 03		bne $9bcc			bne 	_VMCNotNegative
.9bc9	20 d4 9d	jsr $9dd4			jsr		NSMNegate
.9bcc					_VMCNotNegative:
.9bcc	7a		ply				ply
.9bcd	18		clc				clc
.9bce	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9bcf					ChrUnary:
.9bcf	fa		plx				plx 								; restore stack pos
.9bd0	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger			; get value
.9bd3	48		pha				pha
.9bd4	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9bd7	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9bd9	20 75 a7	jsr $a775			jsr 	StringTempAllocate
.9bdc	68		pla				pla 								; write number to it
.9bdd	20 b3 a7	jsr $a7b3			jsr 	StringTempWrite
.9be0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9be1					SpcUnary:
.9be1	fa		plx				plx 								; restore stack pos
.9be2	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger			; get value
.9be5	5a		phy				phy
.9be6	48		pha				pha 								; save count
.9be7	20 75 a7	jsr $a775			jsr 	StringTempAllocate
.9bea	7a		ply				ply 								; to do count in Y
.9beb					_SpcLoop:
.9beb	c0 00		cpy #$00			cpy 	#0
.9bed	f0 08		beq $9bf7			beq 	_SpcExit
.9bef	a9 20		lda #$20			lda 	#32
.9bf1	20 b3 a7	jsr $a7b3			jsr 	StringTempWrite
.9bf4	88		dey				dey
.9bf5	80 f4		bra $9beb			bra 	_SPCLoop
.9bf7					_SpcExit:
.9bf7	7a		ply				ply
.9bf8	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.9bfb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9bfc					Unary_Str:
.9bfc	fa		plx				plx
.9bfd	20 51 9d	jsr $9d51			jsr 	EvaluateNumber  			; get number
.9c00	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; closing bracket
.9c03	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c05	20 1e 9c	jsr $9c1e			jsr 	ConvertNumberToString 		; do the conversion.
.9c08	a9 21		lda #$21			lda		#33 						; create buffer
.9c0a	20 75 a7	jsr $a775			jsr 	StringTempAllocate 			; allocate memory
.9c0d	da		phx				phx
.9c0e	a2 00		ldx #$00			ldx 	#0
.9c10					_USCopy:
.9c10	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c13	20 b3 a7	jsr $a7b3			jsr 	StringTempWrite
.9c16	e8		inx				inx
.9c17	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c1a	d0 f4		bne $9c10			bne 	_USCopy
.9c1c	fa		plx				plx
.9c1d	60		rts				rts
.9c1e					ConvertNumberToString:
.9c1e	5a		phy				phy 								; save code position
.9c1f	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9c22	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9c25	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9c28	10 0a		bpl $9c34			bpl 	_CNTSNotNegative
.9c2a	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c2c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c2f	a9 2d		lda #$2d			lda 	#"-"
.9c31	20 9a 9c	jsr $9c9a			jsr 	WriteDecimalBuffer
.9c34					_CNTSNotNegative:
.9c34	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9c37	f0 15		beq $9c4e			beq 	_CNTSNotFloat
.9c39	e8		inx				inx 								; round up
.9c3a	a9 01		lda #$01			lda 	#1
.9c3c	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9c3f	ca		dex				dex
.9c40	bd 28 04	lda $0428,x			lda		NSExponent,x
.9c43	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9c46	a9 08		lda #$08			lda 	#NSTFloat
.9c48	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9c4b	20 61 93	jsr $9361			jsr 	FloatAdd
.9c4e					_CNTSNotFloat:
.9c4e	20 7c 9c	jsr $9c7c			jsr 	MakePlusTwoString
.9c51	20 47 94	jsr $9447			jsr 	FloatFractionalPart 		; get the fractional part
.9c54	20 0b 95	jsr $950b			jsr 	NSNormalise					; normalise , exit if zero
.9c57	f0 21		beq $9c7a			beq 	_CNTSExit
.9c59	a9 2e		lda #$2e			lda 	#"."
.9c5b	20 9a 9c	jsr $9c9a			jsr 	WriteDecimalBuffer 			; write decimal place
.9c5e					_CNTSDecimal:
.9c5e	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9c61	30 17		bmi $9c7a			bmi 	_CNTSExit
.9c63	e8		inx				inx 								; x 10.0
.9c64	a9 0a		lda #$0a			lda 	#10
.9c66	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.9c69	a9 08		lda #$08			lda 	#NSTFloat
.9c6b	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c6e	ca		dex				dex
.9c6f	20 d4 94	jsr $94d4			jsr 	FloatMultiply
.9c72	20 7c 9c	jsr $9c7c			jsr 	MakePlusTwoString
.9c75	20 47 94	jsr $9447			jsr 	FloatFractionalPart 		; get the fractional part
.9c78	80 e4		bra $9c5e			bra 	_CNTSDecimal 				; keep going.
.9c7a					_CNTSExit:
.9c7a	7a		ply				ply
.9c7b	60		rts				rts
.9c7c					MakePlusTwoString:
.9c7c	da		phx				phx
.9c7d	20 ff 9d	jsr $9dff			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c80	e8		inx				inx 								; access it
.9c81	e8		inx				inx
.9c82	20 aa 94	jsr $94aa			jsr 	FloatIntegerPart 			; make it an integer
.9c85	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c87	20 8c 92	jsr $928c			jsr 	ConvertInt32
.9c8a	a2 00		ldx #$00			ldx	 	#0
.9c8c					_MPTSCopy:
.9c8c	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c8f	20 9a 9c	jsr $9c9a			jsr 	WriteDecimalBuffer
.9c92	e8		inx				inx
.9c93	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c96	d0 f4		bne $9c8c			bne 	_MPTSCopy
.9c98	fa		plx				plx
.9c99	60		rts				rts
.9c9a					WriteDecimalBuffer:
.9c9a	da		phx				phx
.9c9b	ae 95 04	ldx $0495			ldx 	dbOffset
.9c9e	9d 1b 06	sta $061b,x			sta 	DecimalBuffer,x
.9ca1	9e 1c 06	stz $061c,x			stz 	DecimalBuffer+1,x
.9ca4	ee 95 04	inc $0495			inc 	dbOffset
.9ca7	fa		plx				plx
.9ca8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9ca9					Unary_Left:
.9ca9	fa		plx				plx
.9caa	18		clc				clc 								; only one parameter
.9cab	20 20 9d	jsr $9d20			jsr 	SubstringInitial 			; set up.
.9cae	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9cb1	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cb4	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9cb7	80 2c		bra $9ce5			bra 	SubstringMain
.9cb9					Unary_Right:
.9cb9	fa		plx				plx
.9cba	18		clc				clc 								; only one parameter
.9cbb	20 20 9d	jsr $9d20			jsr 	SubstringInitial 			; set up.
.9cbe	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9cc1	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cc4	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9cc7	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cca	b0 02		bcs $9cce			bcs 	_URNotUnderflow
.9ccc	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cce					_URNotUnderFlow:
.9cce	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cd1	80 12		bra $9ce5			bra 	SubStringMain
.9cd3					Unary_Mid:
.9cd3	fa		plx				plx
.9cd4	38		sec				sec 								; two parameters
.9cd5	20 20 9d	jsr $9d20			jsr 	SubstringInitial 			; set up.
.9cd8	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9cdb	f0 05		beq $9ce2			beq 	_UMError
.9cdd	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9ce0	80 03		bra $9ce5			bra 	SubStringMain
.9ce2					_UMError:
.9ce2	4c c1 9f	jmp $9fc1			jmp 	ArgumentError
.9ce5					SubStringMain:
.9ce5	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9ce8	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9ceb	b0 2d		bcs $9d1a			bcs 	_SSMNull 					; if so, return an empty string.
.9ced	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9cf0	f0 28		beq $9d1a			beq 	_SSMNull 					; return empty string.
.9cf2	18		clc				clc 								; add the offset +1 to the address and
.9cf3	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9cf6	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9cf9	85 36		sta $36				sta 	zTemp0
.9cfb	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9cfe	69 00		adc #$00			adc 	#0
.9d00	85 37		sta $37				sta 	zTemp0+1
.9d02					_SSMNoCarry:
.9d02	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d05	20 75 a7	jsr $a775			jsr 	StringTempAllocate 			; allocate that many characters
.9d08	5a		phy				phy 								; save Y
.9d09	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d0b					_SSMCopy:
.9d0b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d0d	f0 09		beq $9d18			beq 	_SSMEString 				; no more to copy
.9d0f	20 b3 a7	jsr $a7b3			jsr 	StringTempWrite 			; and write it out.
.9d12	c8		iny				iny
.9d13	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9d16	d0 f3		bne $9d0b			bne 	_SSMCopy
.9d18					_SSMEString:
.9d18	7a		ply				ply
.9d19					_SSMExit:
.9d19	60		rts				rts
.9d1a					_SSMNull:
.9d1a	a9 00		lda #$00			lda 	#0
.9d1c	20 75 a7	jsr $a775			jsr 	StringTempAllocate
.9d1f	60		rts				rts
.9d20					SubstringInitial:
.9d20	da		phx				phx 								; save initial stack position
.9d21	08		php				php 								; save carry on stack indicating 2 parameters
.9d22	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get a string
.9d25	5a		phy				phy 								; calculate length to exponent.
.9d26	a0 ff		ldy #$ff			ldy 	#$FF
.9d28					_SIFindLength:
.9d28	c8		iny				iny
.9d29	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d2b	d0 fb		bne $9d28			bne 	_SIFindLength
.9d2d	98		tya				tya
.9d2e	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9d31	7a		ply				ply
.9d32	e8		inx				inx
.9d33	20 54 8d	jsr $8d54			jsr 	CheckComma 					; comma next
.9d36	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get next parameter
.9d39	28		plp				plp 								; is it the last parameter ?
.9d3a	90 07		bcc $9d43			bcc 	_SSIExit 					; if so, exit.
.9d3c	e8		inx				inx
.9d3d	20 54 8d	jsr $8d54			jsr 	CheckComma 					; comma next
.9d40	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get last parameter
.9d43					_SSIExit:
.9d43	fa		plx				plx
.9d44	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket 			; check closing bracket
.9d47	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d48					EvaluateValue:
.9d48	48		pha				pha
.9d49	20 14 93	jsr $9314			jsr		EvaluateExpression 			; expression
.9d4c	20 32 96	jsr $9632			jsr 	Dereference					; derefernce it
.9d4f	68		pla				pla
.9d50	60		rts				rts
.9d51					EvaluateNumber:
.9d51	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get a value
.9d54	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d57	29 10		and #$10			and 	#NSBIsString
.9d59	d0 16		bne $9d71			bne 	HelperTypeError
.9d5b	60		rts				rts
.9d5c					EvaluateString:
.9d5c	20 48 9d	jsr $9d48			jsr 	EvaluateValue 				; get a value
.9d5f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d62	29 10		and #$10			and 	#NSBIsString
.9d64	f0 0b		beq $9d71			beq 	HelperTypeError
.9d66					CopyAddressToTemp0:
.9d66	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d69	85 36		sta $36				sta 	zTemp0
.9d6b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9d6e	85 37		sta $37				sta 	zTemp0+1
.9d70	60		rts				rts
.9d71					HelperTypeError:
.9d71	4c bc 9f	jmp $9fbc			jmp 	TypeError
.9d74					EvaluateInteger:
.9d74	20 51 9d	jsr $9d51			jsr 	EvaluateNumber
.9d77	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9d7a	d0 0a		bne $9d86			bne 	HelperValueError 			; if not, it's a float.
.9d7c	60		rts				rts
.9d7d					EvaluateUnsignedInteger:
.9d7d	20 74 9d	jsr $9d74			jsr 	EvaluateInteger 			; check integer is +ve
.9d80	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9d83	30 01		bmi $9d86			bmi 	HelperValueError
.9d85	60		rts				rts
.9d86					HelperValueError:
.9d86	4c c1 9f	jmp $9fc1			jmp 	ArgumentError
.9d89					Evaluate16BitInteger:
.9d89	20 7d 9d	jsr $9d7d			jsr	 	EvaluateUnsignedInteger		; get integer
.9d8c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d8f	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9d92	d0 f2		bne $9d86			bne 	HelperValueError
.9d94	60		rts				rts
.9d95					Evaluate16BitIntegerSigned:
.9d95	20 74 9d	jsr $9d74			jsr	 	EvaluateInteger				; get integer
.9d98	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d9b	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9d9e	d0 e6		bne $9d86			bne 	HelperValueError
.9da0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9da3	10 03		bpl $9da8			bpl 	_EISNotSigned
.9da5	20 dd 9d	jsr $9ddd			jsr 	NSMNegateMantissa
.9da8					_EISNotSigned:
.9da8	60		rts				rts
.9da9					Evaluate8BitInteger:
.9da9	20 7d 9d	jsr $9d7d			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9dac	d0 d8		bne $9d86			bne 	HelperValueError
.9dae	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9db1	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9db4	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9db7	d0 cd		bne $9d86			bne 	HelperValueError
.9db9	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9dbc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dbd					Multiply8x8:
.9dbd	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dbe	85 36		sta $36			  	sta 	zTemp0
.9dc0	86 37		stx $37				stx 	zTemp0+1
.9dc2	a9 00		lda #$00			lda 	#0
.9dc4	a2 08		ldx #$08			ldx 	#8
.9dc6					_M88Loop:
.9dc6	90 03		bcc $9dcb			bcc 	_M88NoAdd
.9dc8	18		clc				clc
.9dc9	65 37		adc $37				adc 	zTemp0+1
.9dcb					_M88NoAdd:
.9dcb	6a		ror a				ror 	a
.9dcc	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dce	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9dcf	d0 f5		bne $9dc6			bne 	_M88Loop
.9dd1	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9dd3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9dd4					NSMNegate:
.9dd4	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9dd7	49 80		eor #$80			eor 	#NSBIsNegative
.9dd9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9ddc	60		rts				rts
.9ddd					NSMNegateMantissa:
.9ddd	38		sec				sec
.9dde	a9 00		lda #$00			lda 	#0
.9de0	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9de3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9de6	a9 00		lda #$00			lda 	#0
.9de8	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9deb	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9dee	a9 00		lda #$00			lda 	#0
.9df0	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9df3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9df6	a9 00		lda #$00			lda 	#0
.9df8	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9dfb	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9dfe	60		rts				rts
.9dff					NSMShiftUpTwo:
.9dff	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e02	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9e05	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e08	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9e0b	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9e0e	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9e11	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e14	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9e17	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9e1a	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9e1d	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e20	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9e23	60		rts				rts
.9e24					NSMSetZeroMantissaOnly:
.9e24	a9 00		lda #$00			lda 	#0
.9e26	80 08		bra $9e30			bra 	NSMSetMantissa
.9e28					NSMSetZero:
.9e28	a9 00		lda #$00			lda 	#0
.9e2a					NSMSetByte:
.9e2a	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e2d	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9e30					NSMSetMantissa:
.9e30	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9e33	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9e36	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9e39	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9e3c	60		rts				rts
.9e3d					NSMShiftLeft:
.9e3d	18		clc				clc
.9e3e					NSMRotateLeft:
.9e3e	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9e41	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9e44	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9e47	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9e4a	60		rts				rts
.9e4b					NSMShiftRight:
.9e4b	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9e4e	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9e51	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9e54	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9e57	60		rts				rts
.9e58					NSMIsZero:
.9e58	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e5b	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9e5e	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9e61	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9e64	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.b9d8					TickHandler:
.b9d8	5a		phy				phy 								; need to preserve Y
.b9d9	20 7e b9	jsr $b97e			jsr 	SNDUpdate 					; update sound
.b9dc	7a		ply				ply
.b9dd	60		rts				rts
.062d					LastTick:
>062d							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e65					Assemble_ora:
.9e65	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e68	01					.byte $01
.9e69					Assemble_and:
.9e69	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e6c	21					.byte $21
.9e6d					Assemble_eor:
.9e6d	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e70	41					.byte $41
.9e71					Assemble_adc:
.9e71	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e74	61					.byte $61
.9e75					Assemble_sta:
.9e75	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e78	81					.byte $81
.9e79					Assemble_lda:
.9e79	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e7c	a1					.byte $a1
.9e7d					Assemble_cmp:
.9e7d	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e80	c1					.byte $c1
.9e81					Assemble_sbc:
.9e81	20 6c 80	jsr $806c		jsr	AssembleGroup1
>9e84	e1					.byte $e1
.9e85					Assemble_asl:
.9e85	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e88	02					.byte $02
>9e89	75					.byte $75
.9e8a					Assemble_rol:
.9e8a	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e8d	22					.byte $22
>9e8e	75					.byte $75
.9e8f					Assemble_lsr:
.9e8f	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e92	42					.byte $42
>9e93	75					.byte $75
.9e94					Assemble_ror:
.9e94	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e97	62					.byte $62
>9e98	75					.byte $75
.9e99					Assemble_stx:
.9e99	20 73 80	jsr $8073		jsr	AssembleGroup2
>9e9c	82					.byte $82
>9e9d	50					.byte $50
.9e9e					Assemble_ldx:
.9e9e	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ea1	a2					.byte $a2
>9ea2	d0					.byte $d0
.9ea3					Assemble_dec:
.9ea3	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ea6	c2					.byte $c2
>9ea7	55					.byte $55
.9ea8					Assemble_inc:
.9ea8	20 73 80	jsr $8073		jsr	AssembleGroup2
>9eab	e2					.byte $e2
>9eac	55					.byte $55
.9ead					Assemble_stz:
.9ead	20 73 80	jsr $8073		jsr	AssembleGroup2
>9eb0	60					.byte $60
>9eb1	44					.byte $44
.9eb2					Assemble_bit:
.9eb2	20 73 80	jsr $8073		jsr	AssembleGroup2
>9eb5	20					.byte $20
>9eb6	55					.byte $55
.9eb7					Assemble_sty:
.9eb7	20 73 80	jsr $8073		jsr	AssembleGroup2
>9eba	80					.byte $80
>9ebb	54					.byte $54
.9ebc					Assemble_ldy:
.9ebc	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ebf	a0					.byte $a0
>9ec0	d5					.byte $d5
.9ec1					Assemble_cpy:
.9ec1	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ec4	c0					.byte $c0
>9ec5	d4					.byte $d4
.9ec6					Assemble_cpx:
.9ec6	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ec9	e0					.byte $e0
>9eca	d0					.byte $d0
.9ecb					Assemble_tsb:
.9ecb	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ece	00					.byte $00
>9ecf	50					.byte $50
.9ed0					Assemble_trb:
.9ed0	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ed3	10					.byte $10
>9ed4	50					.byte $50
.9ed5					Assemble_jsr:
.9ed5	20 73 80	jsr $8073		jsr	AssembleGroup2
>9ed8	14					.byte $14
>9ed9	10					.byte $10
.9eda					Assemble_jmp:
.9eda	20 73 80	jsr $8073		jsr	AssembleGroup2
>9edd	40					.byte $40
>9ede	10					.byte $10
.9edf					Assemble_bpl:
.9edf	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9ee2	10					.byte $10
.9ee3					Assemble_bmi:
.9ee3	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9ee6	30					.byte $30
.9ee7					Assemble_bvc:
.9ee7	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9eea	50					.byte $50
.9eeb					Assemble_bvs:
.9eeb	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9eee	70					.byte $70
.9eef					Assemble_bcc:
.9eef	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9ef2	90					.byte $90
.9ef3					Assemble_bcs:
.9ef3	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9ef6	b0					.byte $b0
.9ef7					Assemble_bne:
.9ef7	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9efa	d0					.byte $d0
.9efb					Assemble_beq:
.9efb	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9efe	f0					.byte $f0
.9eff					Assemble_bra:
.9eff	20 c4 80	jsr $80c4		jsr	AssembleGroup3
>9f02	80					.byte $80
.9f03					Assemble_brk:
.9f03	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f06	00					.byte $00
.9f07					Assemble_php:
.9f07	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f0a	08					.byte $08
.9f0b					Assemble_clc:
.9f0b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f0e	18					.byte $18
.9f0f					Assemble_plp:
.9f0f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f12	28					.byte $28
.9f13					Assemble_sec:
.9f13	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f16	38					.byte $38
.9f17					Assemble_rti:
.9f17	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f1a	40					.byte $40
.9f1b					Assemble_pha:
.9f1b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f1e	48					.byte $48
.9f1f					Assemble_cli:
.9f1f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f22	58					.byte $58
.9f23					Assemble_phy:
.9f23	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f26	5a					.byte $5a
.9f27					Assemble_rts:
.9f27	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f2a	60					.byte $60
.9f2b					Assemble_pla:
.9f2b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f2e	68					.byte $68
.9f2f					Assemble_sei:
.9f2f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f32	78					.byte $78
.9f33					Assemble_ply:
.9f33	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f36	7a					.byte $7a
.9f37					Assemble_dey:
.9f37	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f3a	88					.byte $88
.9f3b					Assemble_txa:
.9f3b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f3e	8a					.byte $8a
.9f3f					Assemble_tya:
.9f3f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f42	98					.byte $98
.9f43					Assemble_txs:
.9f43	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f46	9a					.byte $9a
.9f47					Assemble_tay:
.9f47	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f4a	a8					.byte $a8
.9f4b					Assemble_tax:
.9f4b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f4e	aa					.byte $aa
.9f4f					Assemble_clv:
.9f4f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f52	b8					.byte $b8
.9f53					Assemble_tsx:
.9f53	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f56	ba					.byte $ba
.9f57					Assemble_iny:
.9f57	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f5a	c8					.byte $c8
.9f5b					Assemble_dex:
.9f5b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f5e	ca					.byte $ca
.9f5f					Assemble_cld:
.9f5f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f62	d8					.byte $d8
.9f63					Assemble_phx:
.9f63	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f66	da					.byte $da
.9f67					Assemble_stp:
.9f67	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f6a	db					.byte $db
.9f6b					Assemble_inx:
.9f6b	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f6e	e8					.byte $e8
.9f6f					Assemble_nop:
.9f6f	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f72	ea					.byte $ea
.9f73					Assemble_sed:
.9f73	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f76	f8					.byte $f8
.9f77					Assemble_plx:
.9f77	20 fa 80	jsr $80fa		jsr	AssembleGroup4
>9f7a	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f7b					DecimalScalarTable:
>9f7b	66 66 66 66				.dword $66666666 ; 0.1
>9f7f	de					.byte $de
>9f80	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f84	db					.byte $db
>9f85	4c 37 89 41				.dword $4189374c ; 0.001
>9f89	d8					.byte $d8
>9f8a	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f8e	d4					.byte $d4
>9f8f	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f93	d1					.byte $d1
>9f94	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f98	ce					.byte $ce
>9f99	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9f9d	ca					.byte $ca
>9f9e	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9fa2	c7					.byte $c7
>9fa3	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9fa7	c4					.byte $c4
>9fa8	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9fac	c0					.byte $c0
>9fad	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fb1	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fb2					SyntaxError:
.9fb2	a9 02		lda #$02		lda	#2
.9fb4	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fb7					RangeError:
.9fb7	a9 04		lda #$04		lda	#4
.9fb9	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fbc					TypeError:
.9fbc	a9 05		lda #$05		lda	#5
.9fbe	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fc1					ArgumentError:
.9fc1	a9 07		lda #$07		lda	#7
.9fc3	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fc6					NotDoneError:
.9fc6	a9 0c		lda #$0c		lda	#12
.9fc8	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.9fcb					ErrorText:
>9fcb	42 72 65 61 6b 00			.text	"Break",0
>9fd1	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fd9	72 72 6f 72 00
>9fde	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fe6	20 62 79 20 7a 65 72 6f 00
>9fef	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9ff7	61 6e 67 65 00
>9ffc	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a004	6d 61 74 63 68 00
>a00a	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a012	65 6d 6f 72 79 00
>a018	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a020	61 72 67 75 6d 65 6e 74 00
>a029	53 74 6f 70 00				.text	"Stop",0
>a02e	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a036	6f 6f 20 6c 6f 6e 67 00
>a03e	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a046	6e 20 66 61 69 6c 65 64 00
>a04f	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a057	61 74 61 00
>a05b	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a063	65 6e 74 65 64 00
>a069	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a071	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a07d	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a085	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a092	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a09a	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a0a7	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0af	68 6f 75 74 20 57 68 69 6c 65 00
>a0ba	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0c2	68 6f 75 74 20 46 6f 72 00
>a0cb	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0d3	61 63 6b 20 66 75 6c 6c 00
>a0dc	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0e4	75 63 74 75 72 65 00
>a0eb	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0f3	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a100	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a108	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a116	41 72 72 61 79 20 73 69			.text	"Array size",0
>a11e	7a 65 00
>a121	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a129	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a131	42 75 69 6c 74 20 54 75			.text "Built Tuesday 22-Nov-2022. Build 3494."
>a139	65 73 64 61 79 20 32 32 2d 4e 6f 76 2d 32 30 32
>a149	32 2e 20 42 75 69 6c 64 20 33 34 39 34 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a157					RectangleCommand:
.a157	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a159	80 02		bra $a15d			bra 	ShapeDrawCmd
.a15b					CircleCommand:
.a15b	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a15d					ShapeDrawCmd:
.a15d	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a160					ShapeDraw:
.a160	0d 2f 06	ora $062f			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a163	4c df a1	jmp $a1df			jmp 	ExecuteGraphicCommand	 	; and complete
.a166					SpriteCommand:
.a166	a2 00		ldx #$00			ldx 	#0
.a168	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get image number.
.a16b	5a		phy				phy
.a16c	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a16e	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a171	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a173	b0 0d		bcs $a182			bcs 	_SCRange
.a175	a0 ff		ldy #$ff			ldy 	#255
.a177	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a17a	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a17c	7a		ply				ply
.a17d	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a180	80 5d		bra $a1df			bra 	ExecuteGraphicCommand
.a182					_SCRange:
.a182	4c b7 9f	jmp $9fb7			jmp 	RangeError
.a185					ImageCommand:
.a185	a2 00		ldx #$00			ldx 	#0
.a187	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get image number.
.a18a	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a18d					ImageRunDraw:
.a18d	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a18f	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a192	ad 35 06	lda $0635			lda 	gxDrawScale
.a195	0a		asl a				asl 	a
.a196	0a		asl a				asl 	a
.a197	0a		asl a				asl 	a
.a198	a8		tay				tay
.a199	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a19b	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a19e	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a1a1	60		rts				rts
.a1a2					TextCommand:
.a1a2	a2 00		ldx #$00			ldx 	#0
.a1a4	20 5c 9d	jsr $9d5c			jsr 	EvaluateString 				; get text
.a1a7	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a1aa					TextRunDraw:
.a1aa	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1ac	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a1af	a0 00		ldy #$00			ldy 	#0
.a1b1					_IRDLoop:
.a1b1	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a1b4	85 37		sta $37				sta 	zTemp0+1
.a1b6	ad 08 04	lda $0408			lda 	NSMantissa0
.a1b9	85 36		sta $36				sta 	zTemp0
.a1bb	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1bd	f0 13		beq $a1d2			beq 	_IRDExit
.a1bf	5a		phy				phy									; save string pos
.a1c0	48		pha				pha 								; save char
.a1c1	ad 35 06	lda $0635			lda 	gxDrawScale 				; get scale
.a1c4	0a		asl a				asl 	a
.a1c5	0a		asl a				asl 	a
.a1c6	0a		asl a				asl 	a
.a1c7	a8		tay				tay
.a1c8	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1ca	fa		plx				plx 								; char to draw
.a1cb	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a1ce	7a		ply				ply 								; restore string pos
.a1cf	c8		iny				iny
.a1d0	90 df		bcc $a1b1			bcc 	_IRDLoop 					; go back if no error.
.a1d2					_IRDExit:
.a1d2	60		rts				rts
.a1d3					PlotCommand:
.a1d3	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1d5	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a1d8	80 05		bra $a1df			bra 	ExecuteGraphicCommand
.a1da					LineCommand:
.a1da	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1dc	20 eb a1	jsr $a1eb			jsr 	RunGraphicsCommand
.a1df					ExecuteGraphicCommand:
.a1df	0d 2e 06	ora $062e			ora 	gxCommandID 				; make a full command
.a1e2	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw 				; draw it and exit
.a1e5	b0 01		bcs $a1e8			bcs 	_EGCError
.a1e7	60		rts				rts
.a1e8					_EGCError:
.a1e8	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.a1eb					RunGraphicsCommand:
.a1eb	8d 2e 06	sta $062e			sta 	gxCommandID					; save TODO graphics command.
.a1ee	68		pla				pla 								; pop handler address
.a1ef	fa		plx				plx
.a1f0	1a		inc a				inc 	a
.a1f1	d0 01		bne $a1f4			bne 	_RGINoCarry
.a1f3	e8		inx				inx
.a1f4					_RGINoCarry:
.a1f4	8d 33 06	sta $0633			sta 	GXHandler
.a1f7	8e 34 06	stx $0634			stx 	GXHandler+1
.a1fa					_RGICommandLoop:
.a1fa	b1 30		lda ($30),y			lda 	(codePtr),y
.a1fc	c8		iny				iny
.a1fd	c9 cd		cmp #$cd			cmp 	#KWD_TO						; is it TO x,y
.a1ff	f0 53		beq $a254			beq 	_RGI_To
.a201	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a203	f0 55		beq $a25a			beq 	_RGI_Here
.a205	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a207	f0 3d		beq $a246			beq 	_RGI_Exit
.a209	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a20b	f0 39		beq $a246			beq 	_RGI_Exit
.a20d	c9 c1		cmp #$c1			cmp 	#KWD_OUTLINE 				; solid or outline
.a20f	f0 3e		beq $a24f			beq 	_RGI_Frame
.a211	c9 c9		cmp #$c9			cmp 	#KWD_SOLID
.a213	f0 33		beq $a248			beq 	_RGI_Solid
.a215	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a217	f0 4b		beq $a264			beq 	_RGI_By
.a219	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a21b	f0 17		beq $a234			beq 	_RGI_Move2
.a21d	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a21f	f0 65		beq $a286			beq 	_RGI_Dim
.a221	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a223	f0 78		beq $a29d			beq 	_RGI_Colour
.a225	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a227	f0 74		beq $a29d			beq 	_RGI_Colour
.a229	ae 2e 06	ldx $062e			ldx 	gxCommandID
.a22c	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a22e	d0 03		bne $a233			bne 	_RGI_Move 					; move
.a230	4c c7 a2	jmp $a2c7			jmp		_RGI_SpriteInstructions
.a233					_RGI_Move:
.a233	88		dey				dey 								; unpick get.
.a234					_RGI_Move2:
.a234	20 ed a2	jsr $a2ed			jsr 	GCGetCoordinatePair 		; move to here
.a237	20 14 a3	jsr $a314			jsr 	GCCopyPairToStore 			; save
.a23a	5a		phy				phy
.a23b	20 0a a3	jsr $a30a			jsr 	GCLoadAXY 					; load in
.a23e	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a240	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a243	7a		ply				ply
.a244	80 b4		bra $a1fa			bra 	_RGICommandLoop 			; and go round
.a246					_RGI_Exit:
.a246	88		dey				dey 								; unpick : / EOL
.a247	60		rts				rts
.a248					_RGI_Solid:
.a248	a9 02		lda #$02			lda 	#2
.a24a	8d 2f 06	sta $062f			sta 	gxFillSolid
.a24d	80 ab		bra $a1fa			bra 	_RGICommandLoop
.a24f					_RGI_Frame:
.a24f	9c 2f 06	stz $062f			stz 	gxFillSolid
.a252	80 a6		bra $a1fa			bra 	_RGICommandLoop
.a254					_RGI_To:
.a254	20 ed a2	jsr $a2ed			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a257	20 14 a3	jsr $a314			jsr 	GCCopyPairToStore
.a25a					_RGI_Here:
.a25a	5a		phy				phy
.a25b	20 0a a3	jsr $a30a			jsr 	GCLoadAXY 					; load it into AXY
.a25e	20 c4 a2	jsr $a2c4			jsr 	_RGICallHandler 			; go do whatever it is.
.a261	7a		ply				ply
.a262	80 96		bra $a1fa			bra 	_RGICommandLoop 			; and go round
.a264					_RGI_By:
.a264	20 fa a2	jsr $a2fa			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a267	18		clc				clc
.a268	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a26b	6d 30 06	adc $0630			adc 	gxxPos
.a26e	8d 30 06	sta $0630			sta 	gxXPos
.a271	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a274	6d 31 06	adc $0631			adc 	gxxPos+1
.a277	8d 31 06	sta $0631			sta 	gxXPos+1
.a27a	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a27d	18		clc				clc
.a27e	6d 32 06	adc $0632			adc 	gxYPos
.a281	8d 32 06	sta $0632			sta 	gxYPos
.a284	80 d4		bra $a25a			bra 	_RGI_Here
.a286					_RGI_Dim:
.a286	a2 01		ldx #$01			ldx	 	#1
.a288	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger
.a28b	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a28e	c9 00		cmp #$00			cmp 	#0
.a290	f0 2f		beq $a2c1			beq 	_RGIRange
.a292	c9 09		cmp #$09			cmp 	#8+1
.a294	b0 2b		bcs $a2c1			bcs		_RGIRange
.a296	3a		dec a				dec 	a
.a297	8d 35 06	sta $0635			sta 	gxDrawScale
.a29a	4c fa a1	jmp $a1fa			jmp 	_RGICommandLoop
.a29d					_RGI_Colour:
.a29d	a2 01		ldx #$01			ldx 	#1 							; colour
.a29f	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger
.a2a2	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a2a4	20 28 9e	jsr $9e28			jsr 	NSMSetZero
.a2a7	b1 30		lda ($30),y			lda 	(codePtr),y
.a2a9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a2ab	d0 04		bne $a2b1			bne 	_RGICDefaultMode
.a2ad	c8		iny				iny
.a2ae	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger
.a2b1					_RGICDefaultMode:
.a2b1	5a		phy				phy
.a2b2	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2b4	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a2b7	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a2ba	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a2bd	7a		ply				ply
.a2be	4c fa a1	jmp $a1fa			jmp 	_RGICommandLoop 			; and go round
.a2c1					_RGIRange:
.a2c1	4c b7 9f	jmp $9fb7			jmp 	RangeError
.a2c4					_RGICallHandler:
.a2c4	6c 33 06	jmp ($0633)			jmp 	(GXHandler)
.a2c7					_RGI_SpriteInstructions:
.a2c7	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a2c9	f0 07		beq $a2d2			beq 	_RGISpriteOff
.a2cb	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a2cd	f0 13		beq $a2e2			beq 	_RGISetImage
.a2cf	4c 33 a2	jmp $a233			jmp 	_RGI_Move
.a2d2					_RGISpriteOff:
.a2d2	5a		phy				phy
.a2d3	a0 01		ldy #$01			ldy 	#1
.a2d5	a2 00		ldx #$00			ldx 	#0
.a2d7					_RGIDoCommandLoop:
.a2d7	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2d9	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a2dc	7a		ply				ply
.a2dd	b0 e2		bcs $a2c1			bcs 	_RGIRange
.a2df	4c fa a1	jmp $a1fa			jmp 	_RGICommandLoop
.a2e2					_RGISetImage:
.a2e2	a2 01		ldx #$01			ldx 	#1
.a2e4	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger
.a2e7	5a		phy				phy
.a2e8	aa		tax				tax
.a2e9	a0 00		ldy #$00			ldy 	#0
.a2eb	80 ea		bra $a2d7			bra 	_RGIDoCommandLoop
.a2ed					GCGetCoordinatePair:
.a2ed	a2 01		ldx #$01			ldx 	#1
.a2ef	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.a2f2	20 54 8d	jsr $8d54			jsr 	CheckComma
.a2f5	e8		inx				inx
.a2f6	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.a2f9	60		rts				rts
.a2fa					GCSignedCoordinatePair:
.a2fa	a2 01		ldx #$01			ldx 	#1
.a2fc	20 95 9d	jsr $9d95			jsr 	Evaluate16BitIntegerSigned
.a2ff	20 54 8d	jsr $8d54			jsr 	CheckComma
.a302	e8		inx				inx
.a303	20 95 9d	jsr $9d95			jsr 	Evaluate16BitIntegerSigned
.a306	60		rts				rts
.a307					_GCCPRange:
.a307	4c b7 9f	jmp $9fb7			jmp 	RangeError
.a30a					GCLoadAXY:
.a30a	ad 31 06	lda $0631			lda 	gxXPos+1
.a30d	ae 30 06	ldx $0630			ldx 	gxXPos
.a310	ac 32 06	ldy $0632			ldy 	gxYPos
.a313	60		rts				rts
.a314					GCCopyPairToStore:
.a314	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a317	8d 30 06	sta $0630			sta 	gxXPos
.a31a	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a31d	8d 31 06	sta $0631			sta 	gxXPos+1
.a320	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a323	8d 32 06	sta $0632			sta 	gxYPos
.a326	60		rts				rts
.062e					gxCommandID:
>062e							.fill 	1
.062f					gxFillSolid:
>062f							.fill 	1
.0630					gxXPos:
>0630							.fill 	2
.0632					gxYPos:
>0632							.fill 	1
.0633					gxHandler:
>0633							.fill 	2
.0635					gxDrawScale:
>0635							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a327					BitmapCtrl:
.a327	b1 30		lda ($30),y			lda 	(codePtr),y
.a329	c8		iny				iny
.a32a	a2 01		ldx #$01			ldx 	#1
.a32c	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a32e	f0 11		beq $a341			beq 	BitmapSwitch
.a330	ca		dex				dex
.a331	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a333	f0 0c		beq $a341			beq 	BitmapSwitch
.a335	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get the colour
.a338	5a		phy				phy
.a339	aa		tax				tax
.a33a	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a33c	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a33f	7a		ply				ply
.a340	60		rts				rts
.a341					BitmapSwitch:
.a341	5a		phy				phy
.a342	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a344	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a346	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a349	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a34b	a0 00		ldy #$00			ldy 	#0
.a34d	a2 ff		ldx #$ff			ldx 	#$FF
.a34f	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a352	9c 2f 06	stz $062f			stz 	gxFillSolid
.a355	9c 30 06	stz $0630			stz 	gxXPos
.a358	9c 31 06	stz $0631			stz 	gxXPos+1
.a35b	9c 32 06	stz $0632			stz 	gxYPos
.a35e	9c 35 06	stz $0635			stz 	gxDrawScale
.a361	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a363	a2 00		ldx #$00			ldx 	#0
.a365	a0 00		ldy #$00			ldy 	#0
.a367	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a36a	7a		ply				ply
.a36b	60		rts				rts
.a36c					SpritesCtrl:
.a36c	b1 30		lda ($30),y			lda 	(codePtr),y
.a36e	c8		iny				iny
.a36f	a2 01		ldx #$01			ldx 	#1
.a371	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a373	f0 08		beq $a37d			beq 	SpriteSwitch
.a375	ca		dex				dex
.a376	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a378	f0 03		beq $a37d			beq 	SpriteSwitch
.a37a	4c b2 9f	jmp $9fb2			jmp 	SyntaxError
.a37d					SpriteSwitch:
.a37d	5a		phy				phy
.a37e	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a380	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a382	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a385	7a		ply				ply
.a386	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a387					GfxCommand:
.a387	a2 00		ldx #$00			ldx 	#0
.a389	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; command
.a38c	20 54 8d	jsr $8d54			jsr 	CheckComma
.a38f	e8		inx				inx
.a390	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; X
.a393	20 54 8d	jsr $8d54			jsr 	CheckComma
.a396	e8		inx				inx
.a397	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; Y
.a39a	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a39d	4a		lsr a				lsr 	a
.a39e	d0 16		bne $a3b6			bne 	_GfxError
.a3a0	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a3a3	b0 11		bcs $a3b6			bcs 	_GfxError 					; bit 7 should have been zero
.a3a5	5a		phy				phy 								; save pos
.a3a6	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a3a9	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a3ac	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a3af	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw
.a3b2	b0 02		bcs $a3b6			bcs 	_GfxError
.a3b4	7a		ply				ply 								; restore pos and exit.
.a3b5	60		rts				rts
.a3b6					_GfxError:
.a3b6	4c b7 9f	jmp $9fb7			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a3b9					UnaryHit:
.a3b9	fa		plx				plx
.a3ba	a9 36		lda #$36			lda 	#zTemp0
.a3bc	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3bf	20 54 8d	jsr $8d54			jsr 	CheckComma
.a3c2	e8		inx				inx
.a3c3	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3c6	20 4c 8d	jsr $8d4c			jsr		CheckRightBracket
.a3c9	ca		dex				dex 								; fix back up again.
.a3ca	da		phx				phx 								; save X/Y
.a3cb	5a		phy				phy
.a3cc	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3cf	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a3d2	aa		tax				tax
.a3d3	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3d5	20 c2 aa	jsr $aac2			jsr 	GXGraphicDraw 				; calculate result
.a3d8	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3d9	7a		ply				ply 								; restore XY
.a3da	fa		plx				plx
.a3db	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte 					; return the hit result
.a3de	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3df					PaletteCommand:
.a3df	a2 00		ldx #$00			ldx 	#0
.a3e1	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; colour
.a3e4	20 54 8d	jsr $8d54			jsr 	CheckComma
.a3e7	e8		inx				inx
.a3e8	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; r
.a3eb	20 54 8d	jsr $8d54			jsr 	CheckComma
.a3ee	e8		inx				inx
.a3ef	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; g
.a3f2	20 54 8d	jsr $8d54			jsr 	CheckComma
.a3f5	e8		inx				inx
.a3f6	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; b
.a3f9	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a3fc	85 36		sta $36				sta 	zTemp0
.a3fe	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a400	85 37		sta $37				sta 	zTemp0+1
.a402	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a404	26 37		rol $37				rol	 	zTemp0+1
.a406	06 36		asl $36				asl 	zTemp0
.a408	26 37		rol $37				rol	 	zTemp0+1
.a40a	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a40c	85 01		sta $01				sta 	1
.a40e	5a		phy				phy
.a40f	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a412	92 36		sta ($36)			sta 	(zTemp0)
.a414	a0 01		ldy #$01			ldy 	#1
.a416	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a419	91 36		sta ($36),y			sta 	(zTemp0),y
.a41b	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a41e	c8		iny				iny
.a41f	91 36		sta ($36),y			sta 	(zTemp0),y
.a421	7a		ply				ply
.a422	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a423					UnaryEvent:
.a423	fa		plx				plx
.a424	20 cb a4	jsr $a4cb			jsr 	TimerToStackX 				; timer in +0
.a427	e8		inx				inx  								; put reference into +1
.a428	20 ee 97	jsr $97ee			jsr 	EvaluateTerm
.a42b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a42e	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a430	d0 57		bne $a489			bne 	_UEType
.a432	e8		inx				inx 								; put the step in +2
.a433	20 54 8d	jsr $8d54			jsr 	CheckComma
.a436	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger
.a439	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.a43c	ca		dex				dex
.a43d	ca		dex				dex
.a43e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a441	85 36		sta $36				sta 	zTemp0
.a443	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a446	85 37		sta $37				sta 	zTemp0+1
.a448	5a		phy				phy
.a449	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a44b	b1 36		lda ($36),y			lda 	(zTemp0),y
.a44d	30 36		bmi $a485			bmi 	_UEFalse 					; exit if signed.
.a44f	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a451	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a454	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a456	c8		iny				iny
.a457	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a45a	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a45c	c8		iny				iny
.a45d	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a460	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a462	90 21		bcc $a485			bcc 	_UEFalse 					; no, return FALSE.
.a464	18		clc				clc
.a465	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a467	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a46a	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a46d	91 36		sta ($36),y			sta 	(zTemp0),y
.a46f	c8		iny				iny
.a470	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a473	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a476	91 36		sta ($36),y			sta 	(zTemp0),y
.a478	c8		iny				iny
.a479	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a47c	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a47f	91 36		sta ($36),y			sta 	(zTemp0),y
.a481	7a		ply				ply
.a482	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.a485					_UEFalse:
.a485	7a		ply				ply 								; restore Y
.a486	4c de 8d	jmp $8dde			jmp 	ReturnFalse 				; and return False
.a489					_UEType:
.a489	4c bc 9f	jmp $9fbc			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a48c					UnaryJoyX:
.a48c	18		clc				clc
.a48d	80 01		bra $a490			bra 	JoyMain
.a48f					UnaryJoyY:
.a48f	38		sec				sec
.a490					JoyMain:
.a490	fa		plx				plx 								; get pos
.a491	08		php				php 								; save carry (set for Y)
.a492	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a495	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.a498	20 7b aa	jsr $aa7b			jsr 	EXTReadController 			; read the controller.
.a49b	28		plp				plp
.a49c	90 02		bcc $a4a0			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a49e	4a		lsr a				lsr 	a
.a49f	4a		lsr a				lsr 	a
.a4a0					_JMNoShift:
.a4a0	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a4a1	b0 0a		bcs $a4ad			bcs 	_JMIsRight
.a4a3	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a4a4	b0 04		bcs $a4aa			bcs 	_JMIsLeft
.a4a6	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; zero result
.a4a9	60		rts				rts
.a4aa					_JMIsLeft:
.a4aa	4c d2 8d	jmp $8dd2			jmp 	ReturnTrue
.a4ad					_JMIsRight:
.a4ad	a9 01		lda #$01			lda 	#1
.a4af	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.a4b2	60		rts				rts
.a4b3					UnaryJoyB:
.a4b3	fa		plx				plx 								; get pos
.a4b4	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a4b7	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.a4ba	20 7b aa	jsr $aa7b			jsr 	EXTReadController 			; read the controller.
.a4bd	4a		lsr a				lsr 	a
.a4be	4a		lsr a				lsr 	a
.a4bf	4a		lsr a				lsr 	a
.a4c0	4a		lsr a				lsr 	a
.a4c1	29 01		and #$01			and 	#1
.a4c3	20 2a 9e	jsr $9e2a			jsr 	NSMSetByte
.a4c6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4c7					UnaryTimer:
.a4c7	fa		plx				plx
.a4c8	20 4c 8d	jsr $8d4c			jsr 	CheckRightBracket
.a4cb					TimerToStackX:
.a4cb	20 28 9e	jsr $9e28			jsr 	NSMSetZero 					; zero result
.a4ce	64 01		stz $01				stz 	1 							; access I/O
.a4d0	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4d3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a4d6	ad 5a d6	lda $d65a			lda 	$D65A
.a4d9	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a4dc	ad 5b d6	lda $d65b			lda 	$D65B
.a4df	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a4e2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4e3					MemoryDeleteLine:
.a4e3	20 02 a5	jsr $a502			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4e6	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4e8	a8		tay				tay
.a4e9					_MDDLLoop:
.a4e9	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4eb	92 30		sta ($30)			sta 	(codePtr)
.a4ed	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4ef	c5 3a		cmp $3a				cmp 	zTemp2
.a4f1	d0 07		bne $a4fa			bne 	_MDLDLNext
.a4f3	a5 31		lda $31				lda 	codePtr+1
.a4f5	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4f7	d0 01		bne $a4fa			bne 	_MDLDLNext
.a4f9					_MDDLExit:
.a4f9	60		rts				rts
.a4fa					_MDLDLNext:
.a4fa	e6 30		inc $30				inc 	codePtr						; next byte
.a4fc	d0 eb		bne $a4e9			bne 	_MDDLLoop
.a4fe	e6 31		inc $31				inc 	codePtr+1
.a500	80 e7		bra $a4e9			bra 	_MDDLLoop
.a502					IMemoryFindEnd:
.a502	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a504	85 3a		sta $3a				sta 	0+zTemp2
.a506	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a508	85 3b		sta $3b				sta 	1+zTemp2
.a50a					_MDLFELoop:
.a50a	b2 3a		lda ($3a)			lda 	(zTemp2)
.a50c	f0 0b		beq $a519			beq 	_MDLFEExit
.a50e	18		clc				clc
.a50f	65 3a		adc $3a				adc 	zTemp2
.a511	85 3a		sta $3a				sta 	zTemp2
.a513	90 f5		bcc $a50a			bcc 	_MDLFELoop
.a515	e6 3b		inc $3b				inc 	zTemp2+1
.a517	80 f1		bra $a50a			bra 	_MDLFELoop
.a519					_MDLFEExit:
.a519	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a51a					MemoryInsertLine:
.a51a	08		php				php
.a51b	20 02 a5	jsr $a502			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a51e	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a520	1a		inc a				inc 	a
.a521	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a523	b0 36		bcs $a55b			bcs 	_MDLIError
.a525	28		plp				plp
.a526	90 08		bcc $a530			bcc 	_MDLIFound
.a528	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a52a	85 30		sta $30				sta 	codePtr
.a52c	a5 3b		lda $3b				lda 	zTemp2+1
.a52e	85 31		sta $31				sta 	codePtr+1
.a530					_MDLIFound:
.a530	ad a8 04	lda $04a8			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a533	a8		tay				tay
.a534					_MDLIInsert:
.a534	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a536	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a538	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a53a	c5 3a		cmp $3a				cmp 	zTemp2
.a53c	d0 06		bne $a544			bne 	_MDLINext
.a53e	a5 31		lda $31				lda 	codePtr+1
.a540	c5 3b		cmp $3b				cmp 	zTemp2+1
.a542	f0 0a		beq $a54e			beq 	_MDLIHaveSpace
.a544					_MDLINext:
.a544	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a546	d0 02		bne $a54a			bne 	_MDLINoBorrow
.a548	c6 3b		dec $3b				dec 	zTemp2+1
.a54a					_MDLINoBorrow:
.a54a	c6 3a		dec $3a				dec 	zTemp2
.a54c	80 e6		bra $a534			bra 	_MDLIInsert
.a54e					_MDLIHaveSpace:
.a54e	ac a8 04	ldy $04a8			ldy 	tokenOffset 				; bytes to copy
.a551	88		dey				dey 								; from offset-1 to 0
.a552					_MDLICopy:
.a552	b9 a8 04	lda $04a8,y			lda 	tokenOffset,y
.a555	91 30		sta ($30),y			sta 	(codePtr),y
.a557	88		dey				dey
.a558	10 f8		bpl $a552			bpl 	_MDLICopy
.a55a	60		rts				rts
.a55b					_MDLIError:
.a55b	a9 06		lda #$06		lda	#6
.a55d	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.a560					MDLAppendLine:
.a560	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a562	85 36		sta $36				sta 	zTemp0
.a564	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a566	85 38		sta $38				sta 	0+zTemp1
.a568	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a56a	85 39		sta $39				sta 	1+zTemp1
.a56c	b2 38		lda ($38)			lda 	(zTemp1)
.a56e	d0 0a		bne $a57a			bne 	_MDLANoInitialise
.a570	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a572	8d 36 06	sta $0636			sta 	0+AppendPointer
.a575	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a577	8d 37 06	sta $0637			sta 	1+AppendPointer
.a57a					_MDLANoInitialise:
.a57a	18		clc				clc
.a57b	ad 36 06	lda $0636			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a57e	85 38		sta $38				sta 	zTemp1
.a580	72 36		adc ($36)			adc 	(zTemp0)
.a582	8d 36 06	sta $0636			sta 	AppendPointer
.a585	ad 37 06	lda $0637			lda 	AppendPointer+1
.a588	85 39		sta $39				sta 	zTemp1+1
.a58a	69 00		adc #$00			adc 	#0
.a58c	8d 37 06	sta $0637			sta 	AppendPointer+1
.a58f	a0 00		ldy #$00			ldy 	#0
.a591					_MDLACopy:
.a591	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a593	91 38		sta ($38),y			sta 	(zTemp1),y
.a595	c8		iny				iny
.a596	98		tya				tya
.a597	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a599	d0 f6		bne $a591			bne 	_MDLACopy
.a59b	a9 00		lda #$00			lda 	#0 							; end of program.
.a59d	91 38		sta ($38),y			sta 	(zTemp1),y
.a59f	60		rts				rts
.0636					AppendPointer:
>0636							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a5a0					MemoryNew:
.a5a0	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a2	85 30		sta $30				sta 	codePtr
.a5a4	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5a6	85 31		sta $31				sta 	codePtr+1
.a5a8	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a5aa	92 30		sta ($30)			sta 	(codePtr)
.a5ac	60		rts				rts
.a5ad					MemoryInline:
.a5ad	98		tya				tya 								; put address into stack,x
.a5ae	18		clc				clc
.a5af	65 30		adc $30				adc 	codePtr
.a5b1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a5b4	a5 31		lda $31				lda 	codePtr+1
.a5b6	69 00		adc #$00			adc 	#0
.a5b8	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a5bb	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a5be	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a5c1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a5c2					MemorySearch:
.a5c2	85 36		sta $36				sta 	zTemp0 						; save line number zTemp0
.a5c4	86 37		stx $37				stx 	zTemp0+1
.a5c6	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5c8	85 30		sta $30				sta 	codePtr
.a5ca	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5cc	85 31		sta $31				sta 	codePtr+1
.a5ce					_MTAXLoop:
.a5ce	b2 30		lda ($30)			lda 	(codePtr)
.a5d0	18		clc				clc
.a5d1	f0 21		beq $a5f4			beq 	_MTAXExit 					; reached end, exit with CC.
.a5d3	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5d5	b1 30		lda ($30),y			lda 	(codePtr),y
.a5d7	38		sec				sec
.a5d8	e5 36		sbc $36				sbc 	zTemp0
.a5da	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5dc	c8		iny				iny 								; do the MSB
.a5dd	b1 30		lda ($30),y			lda 	(codePtr),y
.a5df	e5 37		sbc $37				sbc 	zTemp0+1
.a5e1	05 38		ora $38				ora 	zTemp1
.a5e3	f0 0f		beq $a5f4			beq 	_MTAXExit	 				; found
.a5e5	b0 0d		bcs $a5f4			bcs 	_MTAXExit 					; current < required exit
.a5e7	18		clc				clc
.a5e8	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.a5ea	65 30		adc $30				adc 	codePtr
.a5ec	85 30		sta $30				sta 	codePtr
.a5ee	90 02		bcc $a5f2			bcc 	_CREExit
.a5f0	e6 31		inc $31				inc 	codePtr+1
.a5f2					_CREExit:
.a5f2	80 da		bra $a5ce			bra 	_MTAXLoop
.a5f4					_MTAXExit:
.a5f4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a5f5					SoundCommand:
.a5f5	b1 30		lda ($30),y			lda 	(codePtr),y
.a5f7	c9 bf		cmp #$bf			cmp 	#KWD_OFF 					; SOUND OFF ?
.a5f9	d0 09		bne $a604			bne 	_SNDMain
.a5fb	c8		iny				iny 								; skip OFF
.a5fc	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a5fe	5a		phy				phy
.a5ff	20 50 b9	jsr $b950			jsr 	SNDCommand
.a602	7a		ply				ply
.a603	60		rts				rts
.a604					_SNDMain:
.a604	a2 00		ldx #$00			ldx 	#0
.a606	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; channel
.a609	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a60b	b0 50		bcs $a65d			bcs 	_SndError
.a60d	e8		inx				inx 								; do the rest in slot 1.
.a60e	20 54 8d	jsr $8d54			jsr 	CheckComma
.a611	20 89 9d	jsr $9d89			jsr 	Evaluate16BitInteger 		; Pitch
.a614	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a617	c9 10		cmp #$10			cmp 	#16
.a619	b0 42		bcs $a65d			bcs 	_SndError
.a61b	8d 39 06	sta $0639			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a61e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a621	8d 38 06	sta $0638			sta 	SoundCommandBlock
.a624	20 54 8d	jsr $8d54			jsr 	CheckComma
.a627	20 a9 9d	jsr $9da9			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a62a	8d 3b 06	sta $063b			sta 	SoundCommandBlock+3
.a62d	a9 0f		lda #$0f			lda 	#15
.a62f	8d 3a 06	sta $063a			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a632	9c 3c 06	stz $063c			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a635	9c 3d 06	stz $063d			stz 	SoundCommandBlock+5
.a638	b1 30		lda ($30),y			lda 	(codePtr),y
.a63a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a63c	d0 10		bne $a64e			bne 	_SNDPlay
.a63e	c8		iny				iny
.a63f	20 95 9d	jsr $9d95			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a642	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a645	8d 3c 06	sta $063c			sta 	SoundCommandBlock+4
.a648	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a64b	8d 3d 06	sta $063d			sta 	SoundCommandBlock+5
.a64e					_SNDPlay:
.a64e	5a		phy				phy
.a64f	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a652	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a654	a2 38		ldx #$38			ldx 	#(SoundCommandBlock & $FF)
.a656	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a658	20 50 b9	jsr $b950			jsr 	SNDCommand
.a65b	7a		ply				ply
.a65c	60		rts				rts
.a65d					_SndError:
.a65d	4c b7 9f	jmp $9fb7			jmp 	RangeError
.0638					SoundCommandBlock:
>0638							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a660					StackPushByte:
.a660	48		pha				pha 								; save byte
.a661	a5 34		lda $34				lda 	BasicStack
.a663	d0 09		bne $a66e			bne 	_SPBNoBorrow
.a665	c6 35		dec $35				dec 	BasicStack+1
.a667	48		pha				pha
.a668	a5 35		lda $35				lda 	BasicStack+1
.a66a	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a66c	90 06		bcc $a674			bcc 	_SPBMemory
.a66e					_SPBNoBorrow:
.a66e	c6 34		dec $34				dec 	BasicStack
.a670	68		pla				pla 								; get back and write
.a671	92 34		sta ($34)			sta 	(BasicStack)
.a673	60		rts				rts
.a674					_SPBMemory:
.a674	a9 12		lda #$12		lda	#18
.a676	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.a679					StackPopByte:
.a679	b2 34		lda ($34)			lda 	(BasicStack)
.a67b	e6 34		inc $34				inc 	BasicStack
.a67d	d0 02		bne $a681			bne 	_SPBNoCarry
.a67f	e6 35		inc $35				inc 	BasicStack+1
.a681					_SPBNoCarry:
.a681	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a682					StackOpen:
.a682	48		pha				pha 								; save frame byte
.a683	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a685	0a		asl a				asl 	a 							; claim twice this for storage
.a686	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a688	38		sec				sec 								; so basically subtracting from
.a689	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a68b	85 34		sta $34				sta 	basicStack
.a68d	b0 08		bcs $a697			bcs 	_SONoBorrow
.a68f	c6 35		dec $35				dec 	basicStack+1
.a691	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a693	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a695	90 04		bcc $a69b			bcc 	_SOMemory
.a697					_SONoBorrow:
.a697	68		pla				pla 								; get marker back and write at TOS
.a698	92 34		sta ($34)			sta 	(basicStack)
.a69a	60		rts				rts
.a69b					_SOMemory:
.a69b	a9 12		lda #$12		lda	#18
.a69d	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.a6a0					StackClose:
.a6a0	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6a2	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6a4	0a		asl a				asl 	a 							; claim twice this.
.a6a5	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6a7	85 34		sta $34				sta 	basicStack
.a6a9	90 02		bcc $a6ad			bcc 	_SCExit
.a6ab	e6 35		inc $35				inc 	basicStack+1
.a6ad					_SCExit:
.a6ad	60		rts				rts
.a6ae					StackCheckFrame:
.a6ae	48		pha				pha
.a6af					_StackRemoveLocals:
.a6af	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6b1	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a6b3	b0 05		bcs $a6ba			bcs 	_SCNoLocal
.a6b5	20 fe 87	jsr $87fe			jsr 	LocalPopValue
.a6b8	80 f5		bra $a6af			bra 	_StackRemoveLocals
.a6ba					_SCNoLocal:
.a6ba	68		pla				pla
.a6bb	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6bd	29 f0		and #$f0			and 	#$F0 						; check type bits
.a6bf	d0 01		bne $a6c2			bne 	_SCFError 					; different, we have structures mixed up
.a6c1	60		rts				rts
.a6c2					_SCFError:
.a6c2	8a		txa				txa 								; report error X
.a6c3	4c 65 8d	jmp $8d65			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a6c6					STKSaveCodePosition:
.a6c6	5a		phy				phy
.a6c7	98		tya				tya 								; save Y
.a6c8	a0 05		ldy #$05			ldy 	#5
.a6ca	91 34		sta ($34),y			sta 	(basicStack),y
.a6cc	88		dey				dey 								; save Code Pointer
.a6cd					_STKSaveLoop:
.a6cd	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a6d0	91 34		sta ($34),y			sta 	(basicStack),y
.a6d2	88		dey				dey
.a6d3	d0 f8		bne $a6cd			bne 	_STKSaveLoop
.a6d5	7a		ply				ply
.a6d6	60		rts				rts
.a6d7					STKLoadCodePosition:
.a6d7	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a6d9					_STKLoadLoop:
.a6d9	b1 34		lda ($34),y			lda 	(basicStack),y
.a6db	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a6de	c8		iny				iny
.a6df	c0 05		cpy #$05			cpy 	#5
.a6e1	d0 f6		bne $a6d9			bne 	_STKLoadLoop
.a6e3	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a6e5	a8		tay				tay
.a6e6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a6e7					StackReset:
.a6e7	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a6e9	85 34		sta $34				sta 	0+basicStack
.a6eb	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a6ed	85 35		sta $35				sta 	1+basicStack
.a6ef	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a6f1	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a6f3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a6f4					StringConcrete:
.a6f4	5a		phy				phy 								; save position on stack
.a6f5	20 f1 99	jsr $99f1			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a6f8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a6fb	85 38		sta $38				sta 	zTemp1
.a6fd	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a700	85 39		sta $39				sta 	zTemp1+1
.a702	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a704					_SALength:
.a704	c8		iny				iny
.a705	b1 38		lda ($38),y			lda 	(zTemp1),y
.a707	d0 fb		bne $a704			bne 	_SALength
.a709	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a70b	b0 3f		bcs $a74c			bcs 	_SALengthError
.a70d	98		tya				tya 				 				; length of the new string
.a70e	18		clc				clc
.a70f	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a711	90 02		bcc $a715			bcc 	_SAHaveLength
.a713	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a715					_SAHaveLength:
.a715	48		pha				pha 								; save length.
.a716	38		sec				sec
.a717	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a719	6d 8e 04	adc $048e			adc 	StringMemory
.a71c	8d 8e 04	sta $048e			sta 	StringMemory
.a71f	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a721	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a724	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a726	6d 8f 04	adc $048f			adc 	StringMemory+1
.a729	8d 8f 04	sta $048f			sta 	StringMemory+1
.a72c	85 3b		sta $3b				sta 	zTemp2+1
.a72e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a731	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a732	38		sec				sec
.a733	e9 03		sbc #$03			sbc 	#3
.a735	92 3a		sta ($3a)			sta 	(zTemp2)
.a737	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a739	a0 01		ldy #$01			ldy 	#1
.a73b	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a73d					_SACopyNewString:
.a73d	a0 00		ldy #$00			ldy 	#0
.a73f					_SACopyNSLoop:
.a73f	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a741	c8		iny				iny 								; write two on in string storage
.a742	c8		iny				iny
.a743	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a745	88		dey				dey 								; this makes it one one.
.a746	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a748	d0 f5		bne $a73f			bne 	_SACopyNSLoop
.a74a	7a		ply				ply
.a74b	60		rts				rts
.a74c					_SALengthError:
.a74c	a9 09		lda #$09		lda	#9
.a74e	4c 65 8d	jmp $8d65		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a751					StringSystemInitialise:
.a751	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a753	8d 8e 04	sta $048e			sta 	0+StringMemory
.a756	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a758	8d 8f 04	sta $048f			sta 	1+StringMemory
.a75b	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a75e	60		rts				rts
.a75f					StringSpaceInitialise:
.a75f	20 f1 99	jsr $99f1			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a762	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a764	8d 90 04	sta $0490			sta 	StringInitialised
.a767	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a76a	8d 91 04	sta $0491			sta 	StringTempPointer
.a76d	ad 8f 04	lda $048f			lda 	StringMemory+1
.a770	3a		dec a				dec 	a
.a771	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a774	60		rts				rts
.a775					StringTempAllocate:
.a775	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a777	b0 35		bcs $a7ae			bcs 	_STALength
.a779	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a77c	30 05		bmi $a783			bmi 	_STAAllocate
.a77e	48		pha				pha 								; save value to subtract.
.a77f	20 5f a7	jsr $a75f			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a782	68		pla				pla 								; restore it
.a783					_STAAllocate:
.a783	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a785	18		clc				clc  								; deliberate allows one more
.a786	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a789	8d 91 04	sta $0491			sta 	StringTempPointer
.a78c	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a78f	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a791	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a794	69 ff		adc #$ff			adc 	#$FF
.a796	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a799	85 3d		sta $3d				sta 	zsTemp+1
.a79b	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a79e	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a7a1	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a7a4	a9 10		lda #$10			lda 	#NSTString
.a7a6	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a7a9	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7ab	92 3c		sta ($3c)			sta 	(zsTemp)
.a7ad	60		rts				rts
.a7ae					_STALength:
.a7ae	a9 09		lda #$09		lda	#9
.a7b0	4c 65 8d	jmp $8d65		jmp	ErrorHandler
.a7b3					StringTempWrite:
.a7b3	48		pha				pha
.a7b4	92 3c		sta ($3c)			sta 	(zsTemp)
.a7b6	e6 3c		inc $3c				inc 	zsTemp
.a7b8	d0 02		bne $a7bc			bne 	_STWNoCarry
.a7ba	e6 3d		inc $3d				inc 	zsTemp+1
.a7bc					_STWNoCarry:
.a7bc	a9 00		lda #$00			lda 	#0
.a7be	92 3c		sta ($3c)			sta 	(zsTemp)
.a7c0	68		pla				pla
.a7c1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7c2					EXTPrintCharacter:
.a7c2	48		pha				pha
.a7c3	da		phx				phx
.a7c4	5a		phy				phy
.a7c5	a6 01		ldx $01				ldx 	1
.a7c7	da		phx				phx
.a7c8	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a7cb	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a7cd	30 48		bmi $a817			bmi 	_EXPCColour
.a7cf	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a7d1	90 4d		bcc $a820			bcc 	_EXPCControl
.a7d3	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a7d5	86 01		stx $01				stx 	1
.a7d7	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7d9	e6 01		inc $01				inc 	1 							; select colour memory
.a7db	ad 40 06	lda $0640			lda 	EXTTextColour
.a7de	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7e0	c8		iny				iny 								; advance horizontal position
.a7e1	8c 3f 06	sty $063f			sty 	EXTColumn
.a7e4	cc 41 06	cpy $0641			cpy 	EXTScreenWidth 				; reached RHS ?
.a7e7	90 66		bcc $a84f			bcc 	_EXPCExit 					; no, then exit.
.a7e9					_EXPCCRLF:
.a7e9	ee 3e 06	inc $063e			inc 	EXTRow  					; bump row
.a7ec	9c 3f 06	stz $063f			stz 	EXTColumn 					; back to column 0
.a7ef	ad 3e 06	lda $063e			lda 	EXTRow 						; check if reached the bottom ?
.a7f2	cd 42 06	cmp $0642			cmp 	EXTScreenHeight 			; if so, then scroll.
.a7f5	f0 18		beq $a80f			beq 	_EXPCScroll
.a7f7	18		clc				clc 								; add width to address.
.a7f8	a5 40		lda $40				lda 	EXTAddress
.a7fa	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a7fd	85 40		sta $40				sta 	EXTAddress
.a7ff	90 4e		bcc $a84f			bcc 	_EXPCExit
.a801	e6 41		inc $41				inc 	EXTAddress+1
.a803	80 4a		bra $a84f			bra 	_EXPCExit
.a805					_EXPCLeft:
.a805	ce 3f 06	dec $063f			dec 	EXTColumn
.a808	10 45		bpl $a84f			bpl 	_EXPCExit
.a80a					_EXPCBegin:
.a80a	9c 3f 06	stz $063f			stz 	EXTColumn
.a80d	80 40		bra $a84f			bra 	_EXPCExit
.a80f					_EXPCScroll:
.a80f	ce 3e 06	dec $063e			dec 	EXTRow 						; the height-1 th line.
.a812	20 dc a8	jsr $a8dc			jsr 	EXTScreenScroll 			; scroll the screen
.a815	80 38		bra $a84f			bra 	_EXPCExit
.a817					_EXPCColour:
.a817	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a819	b0 34		bcs $a84f			bcs 	_EXPCExit
.a81b	20 bc a8	jsr $a8bc			jsr 	_EXPCHandleColour
.a81e	80 2f		bra $a84f			bra 	_EXPCExit
.a820					_EXPCControl:
.a820	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a822	b0 2b		bcs $a84f			bcs 	_EXPCExit
.a824	0a		asl a				asl 	a 							; double into X
.a825	aa		tax				tax
.a826	7c 9a a8	jmp ($a89a,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a829					_EXPCUp:
.a829	ad 3e 06	lda $063e			lda 	EXTRow 						; already at top ?
.a82c	f0 21		beq $a84f			beq 	_EXPCExit
.a82e	ce 3e 06	dec $063e			dec 	EXTRow 						; up one in position/address
.a831	38		sec				sec
.a832	a5 40		lda $40				lda 	EXTAddress
.a834	ed 41 06	sbc $0641			sbc 	EXTScreenWidth
.a837	85 40		sta $40				sta 	EXTAddress
.a839	b0 14		bcs $a84f			bcs 	_EXPCExit
.a83b	c6 41		dec $41				dec 	EXTAddress+1
.a83d	80 10		bra $a84f			bra 	_EXPCExit
.a83f					_EXPCRight:
.a83f	c8		iny				iny
.a840	8c 3f 06	sty $063f			sty 	EXTColumn
.a843	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a846	d0 07		bne $a84f			bne 	_EXPCExit
.a848					_EXPCEnd:
.a848	ad 41 06	lda $0641			lda 	EXTScreenWidth
.a84b	3a		dec a				dec 	a
.a84c	8d 3f 06	sta $063f			sta 	EXTColumn
.a84f					_EXPCExit:
.a84f	20 31 a9	jsr $a931			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a852	68		pla				pla
.a853	85 01		sta $01				sta 	1
.a855	7a		ply				ply
.a856	fa		plx				plx
.a857	68		pla				pla
.a858	60		rts				rts
.a859					_EXPCClearScreen:
.a859	20 ee a8	jsr $a8ee			jsr		EXTClearScreenCode
.a85c	80 f1		bra $a84f			bra 	_EXPCExit
.a85e					_EXPCDown:
.a85e	ad 42 06	lda $0642			lda 	EXTScreenHeight 			; at the bottom
.a861	3a		dec a				dec 	a
.a862	cd 3e 06	cmp $063e			cmp 	EXTRow
.a865	f0 e8		beq $a84f			beq 	_EXPCExit
.a867	ee 3e 06	inc $063e			inc 	EXTRow 						; down one in position/address
.a86a	18		clc				clc
.a86b	a5 40		lda $40				lda 	EXTAddress
.a86d	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a870	85 40		sta $40				sta 	EXTAddress
.a872	90 db		bcc $a84f			bcc 	_EXPCExit
.a874	e6 41		inc $41				inc 	EXTAddress+1
.a876	80 d7		bra $a84f			bra 	_EXPCExit
.a878					_EXPCTab:
.a878	ad 3f 06	lda $063f			lda 	EXTColumn 					; next tab stop
.a87b	29 f8		and #$f8			and 	#$F8
.a87d	18		clc				clc
.a87e	69 08		adc #$08			adc 	#8
.a880	8d 3f 06	sta $063f			sta 	EXTColumn
.a883	cd 41 06	cmp $0641			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a886	90 c7		bcc $a84f			bcc 	_EXPCExit
.a888	80 be		bra $a848			bra 	_EXPCEnd
.a88a					_EXPCBackSpace:
.a88a	88		dey				dey
.a88b	30 c2		bmi $a84f			bmi 	_EXPCExit
.a88d	ce 3f 06	dec $063f			dec 	EXTColumn
.a890	a9 02		lda #$02			lda 	#2
.a892	85 01		sta $01				sta 	1
.a894	a9 20		lda #$20			lda 	#32
.a896	91 40		sta ($40),y			sta 	(EXTAddress),y
.a898	80 b5		bra $a84f			bra 	_EXPCExit
.a89a					_EXPCActionTable:
>a89a	4f a8						.word 	_EXPCExit 					; 00
>a89c	0a a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a89e	05 a8						.word 	_EXPCLeft 					; 02 B Left
>a8a0	4f a8						.word 	_EXPCExit 					; 03 <Break>
>a8a2	4f a8						.word 	_EXPCExit 					; 04
>a8a4	48 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a8a6	3f a8						.word 	_EXPCRight 					; 06 F Right
>a8a8	4f a8						.word 	_EXPCExit 					; 07
>a8aa	8a a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a8ac	78 a8						.word 	_EXPCTab 					; 09 I Tab
>a8ae	4f a8						.word 	_EXPCExit 					; 0A
>a8b0	4f a8						.word 	_EXPCExit 					; 0B
>a8b2	59 a8						.word 	_EXPCClearScreen			; 0C L CLS
>a8b4	e9 a7						.word 	_EXPCCRLF 					; 0D M CR/LF
>a8b6	5e a8						.word 	_EXPCDown 					; 0E N Down
>a8b8	4f a8						.word 	_EXPCExit 					; 0F
>a8ba	29 a8						.word 	_EXPCUp 					; 10 P Up
.a8bc					_EXPCHandleColour
.a8bc	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a8be	b0 16		bcs $a8d6			bcs 	_EXPCBackground
.a8c0	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a8c1	0a		asl a				asl 	a
.a8c2	0a		asl a				asl 	a
.a8c3	0a		asl a				asl 	a
.a8c4	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a8c6					_EXPCUpdate:
.a8c6	48		pha				pha 								; save new colour
.a8c7	8a		txa				txa 								; get mask
.a8c8	2d 40 06	and $0640			and 	EXTTextColour 				; mask out old.
.a8cb	8d 40 06	sta $0640			sta 	EXTTextColour
.a8ce	68		pla				pla 								; or in new colour
.a8cf	0d 40 06	ora $0640			ora 	EXTTextColour
.a8d2	8d 40 06	sta $0640			sta 	EXTTextColour
.a8d5	60		rts				rts
.a8d6					_EXPCBackground:
.a8d6	29 0f		and #$0f			and 	#$0F 						; get the colour
.a8d8	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a8da	80 ea		bra $a8c6			bra 	_EXPCUpdate
.a8dc					EXTScreenScroll:
.a8dc	a9 02		lda #$02			lda 	#2 							; select text page
.a8de	85 01		sta $01				sta 	1
.a8e0	a9 20		lda #$20			lda		#32 						; fill with space
.a8e2	20 f1 a9	jsr $a9f1			jsr 	EXTScrollFill
.a8e5	e6 01		inc $01				inc 	1 							; select colour page
.a8e7	ad 40 06	lda $0640			lda 	EXTTextColour
.a8ea	20 f1 a9	jsr $a9f1			jsr 	EXTScrollFill
.a8ed	60		rts				rts
.a8ee					EXTClearScreenCode:
.a8ee	a9 02		lda #$02			lda 	#2 							; select text page
.a8f0	85 01		sta $01				sta 	1
.a8f2	a9 20		lda #$20			lda		#32 						; fill with space
.a8f4	20 01 a9	jsr $a901			jsr 	_EXTCSFill
.a8f7	e6 01		inc $01				inc 	1 							; select colour page
.a8f9	ad 40 06	lda $0640			lda 	EXTTextColour
.a8fc	20 01 a9	jsr $a901			jsr 	_EXTCSFill
.a8ff	80 22		bra $a923			bra 	EXTHomeCursor
.a901					_EXTCSFill:
.a901	aa		tax				tax
.a902	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a904	85 40		sta $40				sta 	EXTAddress
.a906	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a908	85 41		sta $41				sta 	EXTAddress+1
.a90a					_EXTCSFill1:
.a90a	a0 00		ldy #$00			ldy 	#0
.a90c	8a		txa				txa
.a90d					_EXTCSFill2:
.a90d	91 40		sta ($40),y			sta 	(EXTAddress),y
.a90f	c8		iny				iny
.a910	d0 fb		bne $a90d			bne 	_EXTCSFill2
.a912	e6 41		inc $41				inc 	EXTAddress+1
.a914	a5 41		lda $41				lda 	EXTAddress+1
.a916	c9 d2		cmp #$d2			cmp 	#$D2
.a918	d0 f0		bne $a90a			bne 	_EXTCSFill1
.a91a	8a		txa				txa
.a91b					_EXTCSFill3:
.a91b	91 40		sta ($40),y			sta 	(EXTAddress),y
.a91d	c8		iny				iny
.a91e	c0 c0		cpy #$c0			cpy 	#$C0
.a920	d0 f9		bne $a91b			bne 	_EXTCSFill3
.a922	60		rts				rts
.a923					EXTHomeCursor:
.a923	9c 3e 06	stz $063e			stz 	EXTRow 						; reset row & column
.a926	9c 3f 06	stz $063f			stz 	EXTColumn
.a929	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a92b	85 40		sta $40				sta 	EXTAddress
.a92d	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a92f	85 41		sta $41				sta 	EXTAddress+1
.a931					EXTSetHardwareCursor:
.a931	64 01		stz $01				stz 	1 							; I/O Page zero
.a933	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a935	8d 10 d0	sta $d010			sta 	$D010
.a938	a9 b1		lda #$b1			lda 	#$B1
.a93a	8d 12 d0	sta $d012			sta 	$D012
.a93d	ad 3f 06	lda $063f			lda 	EXTColumn
.a940	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a943	9c 15 d0	stz $d015			stz 	$D015
.a946	ad 3e 06	lda $063e			lda 	EXTRow
.a949	8d 16 d0	sta $d016			sta 	$D016
.a94c	9c 17 d0	stz $d017			stz 	$D017
.a94f	60		rts				rts
.a950					EXTInputLine:
.a950	48		pha				pha
.a951	da		phx				phx
.a952	5a		phy				phy
.a953	a5 01		lda $01				lda 	1 							; save I/O page
.a955	48		pha				pha
.a956					_EILLoop:
.a956	20 58 aa	jsr $aa58			jsr 	ExtInputSingleCharacter
.a959	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a95b	f0 40		beq $a99d			beq 	_EILExit
.a95d	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a95f	f0 1c		beq $a97d			beq 	_EILBackspace
.a961	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a963	90 12		bcc $a977			bcc 	_EILPrintLoop
.a965	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a967	b0 0e		bcs $a977			bcs 	_EILPrintLoop
.a969	48		pha				pha 								; save character
.a96a	a9 02		lda #$02			lda 	#2  						; insert a space
.a96c	85 01		sta $01				sta 	1
.a96e	20 df a9	jsr $a9df			jsr 	EXTILInsert 				; insert in text screen
.a971	e6 01		inc $01				inc 	1
.a973	20 df a9	jsr $a9df			jsr 	EXTILInsert 				; insert in colour screen
.a976	68		pla				pla 								; get character back.
.a977					_EILPrintLoop:
.a977	20 c2 a7	jsr $a7c2			jsr 	ExtPrintCharacter
.a97a	80 da		bra $a956			bra 	_EILLoop
.a97c	60		rts				rts
.a97d					_EILBackspace:
.a97d	ad 3f 06	lda $063f			lda 	EXTColumn					; can we backspace ?
.a980	f0 d4		beq $a956			beq 	_EILLoop
.a982	a9 02		lda #$02			lda 	#2 							; move cursor left
.a984	20 c2 a7	jsr $a7c2			jsr 	EXTPrintCharacter
.a987	a9 02		lda #$02			lda 	#2 							; text block
.a989	85 01		sta $01				sta 	1
.a98b	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a98d	20 ca a9	jsr $a9ca			jsr 	EXTILDelete
.a990	e6 01		inc $01				inc 	1 							; colour block
.a992	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; get attribute of last character
.a995	88		dey				dey
.a996	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a998	20 ca a9	jsr $a9ca			jsr 	EXTILDelete 				; backspace attribute
.a99b	80 b9		bra $a956			bra 	_EILLoop 					; and go round.
.a99d					_EILExit:
.a99d	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a99f	85 01		sta $01				sta 	1
.a9a1	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a9a3					_EILScrapeLine:
.a9a3	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9a5	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9a8	c8		iny				iny
.a9a9	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9ac	d0 f5		bne $a9a3			bne 	_EILScrapeLine
.a9ae					_EILTrimSpaces:
.a9ae	88		dey				dey
.a9af	f0 08		beq $a9b9			beq 	_EILEndTrim
.a9b1	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.a9b4	c9 20		cmp #$20			cmp 	#' '
.a9b6	f0 f6		beq $a9ae			beq 	_EILTrimSpaces
.a9b8	c8		iny				iny 								; trim after non space character.
.a9b9					_EILEndTrim:
.a9b9	a9 00		lda #$00			lda 	#0 							; trim here.
.a9bb	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9be	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a9c0	20 c2 a7	jsr $a7c2			jsr 	ExtPrintCharacter
.a9c3	68		pla				pla 								; reset I/O page
.a9c4	85 01		sta $01				sta 	1
.a9c6	7a		ply				ply
.a9c7	fa		plx				plx
.a9c8	68		pla				pla
.a9c9	60		rts				rts
.a9ca					EXTILDelete:
.a9ca	48		pha				pha 								; save the new character
.a9cb	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; start copying from here.
.a9ce					_EXTDLoop:
.a9ce	c8		iny				iny 								; copy one byte down.
.a9cf	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9d1	88		dey				dey
.a9d2	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9d4	c8		iny				iny 								; do till end of line.
.a9d5	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9d8	90 f4		bcc $a9ce			bcc 	_EXTDLoop
.a9da	88		dey				dey 	 							; write in last slot.
.a9db	68		pla				pla
.a9dc	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9de	60		rts				rts
.a9df					EXTILInsert:
.a9df	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; end position
.a9e2					_EXTILoop:
.a9e2	88		dey				dey 								; back one
.a9e3	cc 3f 06	cpy $063f			cpy 	EXTColumn 					; exit if reached insert point.
.a9e6	f0 08		beq $a9f0			beq 	_EXTIExit
.a9e8	88		dey				dey 								; copy one byte up.
.a9e9	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9eb	c8		iny				iny
.a9ec	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9ee	80 f2		bra $a9e2			bra 	_EXTILoop
.a9f0					_EXTIExit:
.a9f0	60		rts				rts
.a9f1					EXTScrollFill:
.a9f1	aa		tax				tax									; save value to fill with
.a9f2	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a9f4	48		pha				pha
.a9f5	a5 37		lda $37				lda 	zTemp0+1
.a9f7	48		pha				pha
.a9f8	a5 38		lda $38				lda 	zTemp1
.a9fa	48		pha				pha
.a9fb	a5 39		lda $39				lda 	zTemp1+1
.a9fd	48		pha				pha
.a9fe	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa00	85 37		sta $37				sta 	zTemp0+1
.aa02	85 39		sta $39				sta 	zTemp1+1
.aa04	64 36		stz $36				stz 	zTemp0
.aa06	ad 41 06	lda $0641			lda 	EXTScreenWidth
.aa09	85 38		sta $38				sta 	zTemp1
.aa0b	a0 00		ldy #$00			ldy 	#0
.aa0d					_EXSFCopy1:
.aa0d	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa0f	91 36		sta ($36),y			sta 	(zTemp0),y
.aa11	c8		iny				iny
.aa12	d0 f9		bne $aa0d			bne 	_EXSFCopy1
.aa14	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa16	e6 39		inc $39				inc 	zTemp1+1
.aa18	a5 39		lda $39				lda 	zTemp1+1
.aa1a	c9 d3		cmp #$d3			cmp 	#$D3
.aa1c	d0 ef		bne $aa0d			bne 	_EXSFCopy1
.aa1e	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa21	8a		txa				txa
.aa22					_EXSFFill1:
.aa22	88		dey				dey
.aa23	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa25	c0 00		cpy #$00			cpy 	#0
.aa27	10 f9		bpl $aa22			bpl 	_EXSFFill1
.aa29	68		pla				pla
.aa2a	85 39		sta $39				sta 	zTemp1+1
.aa2c	68		pla				pla
.aa2d	85 38		sta $38				sta 	zTemp1
.aa2f	68		pla				pla
.aa30	85 37		sta $37				sta 	zTemp0+1
.aa32	68		pla				pla
.aa33	85 36		sta $36				sta 	zTemp0
.aa35	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063e					EXTRow:
>063e							.fill 	1
.063f					EXTColumn:
>063f							.fill 	1
.0640					EXTTextColour:
>0640							.fill 	1
.0641					EXTScreenWidth:
>0641							.fill 	1
.0642					EXTScreenHeight:
>0642							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa36					EXTInitialise:
.aa36	64 01		stz $01				stz 	1 							; Access I/O
.aa38	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa3b	9c 08 d0	stz $d008			stz 	$D008
.aa3e	9c 09 d0	stz $d009			stz 	$D009
.aa41	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aa43	8d 58 d6	sta $d658			sta 	$D658
.aa46	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.aa48	8d 40 06	sta $0640			sta 	EXTTextColour
.aa4b	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aa4d	8d 41 06	sta $0641			sta 	EXTScreenWidth
.aa50	a9 3c		lda #$3c			lda 	#60
.aa52	8d 42 06	sta $0642			sta 	EXTScreenHeight
.aa55	64 01		stz $01				stz 	1
.aa57	60		rts				rts
.aa58					EXTInputSingleCharacter:
.aa58	da		phx				phx
.aa59	5a		phy				phy
.aa5a					_EISCWait:
.aa5a	64 01		stz $01				stz 	1 							; access I/O Page 0
.aa5c	38		sec				sec 								; calculate timer - LastTick
.aa5d	ad 59 d6	lda $d659			lda 	$D659
.aa60	aa		tax				tax 								; saving timer in X
.aa61	ed 2d 06	sbc $062d			sbc 	LastTick
.aa64	c9 03		cmp #$03			cmp 	#3
.aa66	90 06		bcc $aa6e			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aa68	8e 2d 06	stx $062d			stx 	LastTick 					; update last timer
.aa6b	20 d8 b9	jsr $b9d8			jsr 	TickHandler 				; go do the code.
.aa6e					_NoFireTick:
.aa6e	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.aa71	c9 00		cmp #$00			cmp 	#0
.aa73	f0 e5		beq $aa5a			beq 	_EISCWait
.aa75	7a		ply				ply
.aa76	fa		plx				plx
.aa77	60		rts				rts
.aa78					EXTBreakCheck:
.aa78	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aa7b					EXTReadController:
.aa7b	da		phx				phx
.aa7c	a2 00		ldx #$00			ldx 	#0
.aa7e	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aa80	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa83	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aa85	f0 04		beq $aa8b			beq 	_NoSet1
.aa87	8a		txa				txa
.aa88	09 01		ora #$01			ora 	#1
.aa8a	aa		tax				tax
.aa8b					_NoSet1:
.aa8b	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aa8d	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa90	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aa92	f0 04		beq $aa98			beq 	_NoSet1
.aa94	8a		txa				txa
.aa95	09 02		ora #$02			ora 	#2
.aa97	aa		tax				tax
.aa98					_NoSet1:
.aa98	a9 06		lda #$06			lda 	#(($32) >> 3)
.aa9a	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa9d	29 04		and #$04			and 	#($01 << (($32) & 7))
.aa9f	f0 04		beq $aaa5			beq 	_NoSet1
.aaa1	8a		txa				txa
.aaa2	09 04		ora #$04			ora 	#4
.aaa4	aa		tax				tax
.aaa5					_NoSet1:
.aaa5	a9 04		lda #$04			lda 	#(($25) >> 3)
.aaa7	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaaa	29 20		and #$20			and 	#($01 << (($25) & 7))
.aaac	f0 04		beq $aab2			beq 	_NoSet1
.aaae	8a		txa				txa
.aaaf	09 08		ora #$08			ora 	#8
.aab1	aa		tax				tax
.aab2					_NoSet1:
.aab2	a9 04		lda #$04			lda 	#(($26) >> 3)
.aab4	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aab7	29 40		and #$40			and 	#($01 << (($26) & 7))
.aab9	f0 04		beq $aabf			beq 	_NoSet1
.aabb	8a		txa				txa
.aabc	09 10		ora #$10			ora 	#16
.aabe	aa		tax				tax
.aabf					_NoSet1:
.aabf	8a		txa				txa
.aac0	fa		plx				plx
.aac1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.b9de					GRVectorTable:
>b9de	bd ac					.word	GXInitialise             ; $00 Initialise
>b9e0	d7 ac					.word	GXControlBitmap          ; $01 BitmapCtl
>b9e2	1f ad					.word	GXControlSprite          ; $02 SpriteCtl
>b9e4	6f ac					.word	GXClearBitmap            ; $03 Clear
>b9e6	ae ae					.word	GXSetColourMode          ; $04 Colour
>b9e8	76 b0					.word	GXFontHandler            ; $05 DrawFont
>b9ea	be b0					.word	GXSpriteHandler          ; $06 DrawSprite
>b9ec	2a b1					.word	GXSelect                 ; $07 SpriteUse
>b9ee	53 b1					.word	GXSelectImage            ; $08 SpriteImage
>b9f0	da b2					.word	GXCollide                ; $09 SpriteCollide
>b9f2	21 ab					.word	GRUndefined              ; $0a
>b9f4	21 ab					.word	GRUndefined              ; $0b
>b9f6	21 ab					.word	GRUndefined              ; $0c
>b9f8	21 ab					.word	GRUndefined              ; $0d
>b9fa	21 ab					.word	GRUndefined              ; $0e
>b9fc	21 ab					.word	GRUndefined              ; $0f
>b9fe	21 ab					.word	GRUndefined              ; $10
>ba00	21 ab					.word	GRUndefined              ; $11
>ba02	21 ab					.word	GRUndefined              ; $12
>ba04	21 ab					.word	GRUndefined              ; $13
>ba06	21 ab					.word	GRUndefined              ; $14
>ba08	21 ab					.word	GRUndefined              ; $15
>ba0a	21 ab					.word	GRUndefined              ; $16
>ba0c	21 ab					.word	GRUndefined              ; $17
>ba0e	21 ab					.word	GRUndefined              ; $18
>ba10	21 ab					.word	GRUndefined              ; $19
>ba12	21 ab					.word	GRUndefined              ; $1a
>ba14	21 ab					.word	GRUndefined              ; $1b
>ba16	21 ab					.word	GRUndefined              ; $1c
>ba18	21 ab					.word	GRUndefined              ; $1d
>ba1a	21 ab					.word	GRUndefined              ; $1e
>ba1c	21 ab					.word	GRUndefined              ; $1f
>ba1e	1f ab					.word	GXMove                   ; $20 Move
>ba20	7c ad					.word	GXLine                   ; $21 Line
>ba22	f7 ae					.word	GXFrameRectangle         ; $22 FrameRect
>ba24	f4 ae					.word	GXFillRectangle          ; $23 FillRect
>ba26	26 ab					.word	GXFrameCircle            ; $24 FrameCircle
>ba28	22 ab					.word	GXFillCircle             ; $25 FillCircle
>ba2a	21 ab					.word	GRUndefined              ; $26
>ba2c	21 ab					.word	GRUndefined              ; $27
>ba2e	dc ae					.word	GXPlotPoint              ; $28 Plot
>ba30	e9 b1					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5f9					gxPixelBuffer = numberBuffer
.0643					gxCurrentX:
>0643							.fill 	2
.0645					gxCurrentY:
>0645							.fill 	2
.0647					gxLastX:
>0647							.fill 	2
.0649					gxLastY:
>0649							.fill 	2
.064b					gxX0:
>064b							.fill 	2
.064d					gxY0:
>064d							.fill 	2
.064f					gxX1:
>064f							.fill 	2
.0651					gxY1:
>0651							.fill 	2
.0653					gxSpritesOn:
>0653							.fill 	1
.0654					gxBitmapsOn:
>0654							.fill 	1
.0655					gxBasePage:
>0655							.fill 	1
.0656					gxSpritePage:
>0656							.fill 	1
.0657					gxHeight:
>0657							.fill 	1
.0658					gxMode:
>0658							.fill 	1
.0659					gxColour:
>0659							.fill 	1
.065a					gxEORValue:
>065a							.fill 	1
.065b					gxANDValue:
>065b							.fill 	1
.065c					gxOriginalLUTValue:
>065c							.fill 	1
.065d					gsOffset:
>065d							.fill 	1
.065e					GSCurrentSpriteID:
>065e							.fill 	1
.065f					GSCurrentSpriteAddr:
>065f							.fill 	2
.0661					GXSpriteOffsetBase:
>0661							.fill 	2
.0663					GXSpriteLow:
>0663							.fill 	64
.06a3					GXSpriteHigh:
>06a3							.fill 	64
.aac2					GXGraphicDraw:
.aac2	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aac4	b0 06		bcs $aacc			bcs 	_GDCoordinate
.aac6	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aac8	84 37		sty $37				sty 	gxzTemp0+1
.aaca	80 4b		bra $ab17			bra 	_GDExecuteA 				; and execute
.aacc					_GDCoordinate:
.aacc	48		pha				pha 								; save AXY
.aacd	da		phx				phx
.aace	5a		phy				phy
.aacf	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aad1					_GDCopy1:
.aad1	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.aad4	9d 47 06	sta $0647,x			sta 	gxLastX,x
.aad7	ca		dex				dex
.aad8	10 f7		bpl $aad1			bpl 	_GDCopy1
.aada	68		pla				pla 								; update Y
.aadb	8d 45 06	sta $0645			sta 	gxCurrentY
.aade	9c 46 06	stz $0646			stz 	gxCurrentY+1
.aae1	68		pla				pla
.aae2	8d 43 06	sta $0643			sta 	gxCurrentX
.aae5	68		pla				pla 								; get A (command+X.1) back
.aae6	48		pha				pha
.aae7	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aae9	8d 44 06	sta $0644			sta 	gxCurrentX+1
.aaec	68		pla				pla 								; get command back
.aaed	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aaef	48		pha				pha 								; push back.
.aaf0	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aaf2	f0 17		beq $ab0b			beq 	_GDCopyToWorkArea
.aaf4	ad 44 06	lda $0644			lda 	gxCurrentX+1 				; X < 256 X okay
.aaf7	f0 07		beq $ab00			beq 	_GDCheckY
.aaf9	ad 43 06	lda $0643			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aafc	c9 40		cmp #$40			cmp 	#64
.aafe	b0 08		bcs $ab08			bcs 	_GDError1
.ab00					_GDCheckY:
.ab00	ad 45 06	lda $0645			lda 	gxCurrentY 					; check Y < Height.
.ab03	cd 57 06	cmp $0657			cmp 	gxHeight
.ab06	90 03		bcc $ab0b			bcc 	_GDCopyToWorkArea
.ab08					_GDError1:
.ab08	68		pla				pla
.ab09					_GDError2:
.ab09	38		sec				sec
.ab0a	60		rts				rts
.ab0b					_GDCopyToWorkArea:
.ab0b	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.ab0d					_GDCopy2:
.ab0d	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.ab10	9d 4b 06	sta $064b,x			sta 	gxX0,x
.ab13	ca		dex				dex
.ab14	10 f7		bpl $ab0d			bpl 	_GDCopy2
.ab16	68		pla				pla 								; get command
.ab17					_GDExecuteA:
.ab17	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.ab19	b0 ee		bcs $ab09			bcs 	_GDError2
.ab1b	aa		tax				tax
.ab1c	7c de b9	jmp ($b9de,x)			jmp 	(GRVectorTable,x)
.ab1f					GXMove:
.ab1f	18		clc				clc
.ab20	60		rts				rts
.ab21					GRUndefined:
>ab21	db						.byte 	$DB 						; causes a break in the emulator
.ab22					GXFillCircle:
.ab22	a9 ff		lda #$ff			lda 	#255
.ab24	80 02		bra $ab28			bra 	GXCircle
.ab26					GXFrameCircle:
.ab26	a9 00		lda #$00			lda 	#0
.ab28					GXCircle:
.ab28	8d e6 06	sta $06e6			sta 	gxIsFillMode					; save Fill flag
.ab2b	ad 54 06	lda $0654			lda 	gxBitmapsOn
.ab2e	f0 26		beq $ab56			beq 	_GXCFail
.ab30	20 81 b3	jsr $b381			jsr 	GXSortXY 					; topleft/bottomright
.ab33	20 59 b2	jsr $b259			jsr 	GXOpenBitmap 				; start drawing
.ab36	20 28 ac	jsr $ac28			jsr 	GXCircleSetup 				; set up for drawing
.ab39	9c e7 06	stz $06e7			stz 	gxYChanged
.ab3c					_GXCircleDraw:
.ab3c	ad e4 06	lda $06e4			lda 	gXCentre					; while x <= y
.ab3f	cd e5 06	cmp $06e5			cmp 	gYCentre
.ab42	90 0a		bcc $ab4e			bcc 	_GXCircleContinue
.ab44	d0 03		bne $ab49			bne 	_GXNoLast
.ab46	20 5b ab	jsr $ab5b			jsr 	GXPlot1
.ab49					_GXNoLast:
.ab49	20 61 b2	jsr $b261			jsr 	GXCloseBitmap 				; close the bitmap
.ab4c	18		clc				clc
.ab4d	60		rts				rts
.ab4e					_GXCircleContinue:
.ab4e	20 58 ab	jsr $ab58			jsr 	GXPlot2 					; draw it
.ab51	20 d5 ab	jsr $abd5			jsr 	GXCircleMove 				; adjust the coordinates
.ab54	80 e6		bra $ab3c			bra 	_GXCircleDraw
.ab56					_GXCFail:
.ab56	38		sec				sec
.ab57	60		rts				rts
.ab58					GXPlot2:
.ab58	20 5b ab	jsr $ab5b			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ab5b					GXPlot1:
.ab5b	ad e5 06	lda $06e5			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ab5e	f0 03		beq $ab63			beq 	_GXPlot1Only
.ab60	20 7f ab	jsr $ab7f			jsr 	GXPlot0 						; plot and negate
.ab63					_GXPlot1Only:
.ab63	20 7f ab	jsr $ab7f			jsr 	GXPlot0 						; twice, undoing negation
.ab66	ad e4 06	lda $06e4			lda 	gXCentre 						; swap X and Y
.ab69	ae e5 06	ldx $06e5			ldx	 	gYCentre
.ab6c	8d e5 06	sta $06e5			sta 	gYCentre
.ab6f	8e e4 06	stx $06e4			stx 	gXCentre
.ab72	ad e7 06	lda $06e7			lda 	gxYChanged 						; toggle Y Changed flag
.ab75	a9 ff		lda #$ff			lda 	#$FF
.ab77	8d e7 06	sta $06e7			sta 	gxYChanged
.ab7a	60		rts				rts
.ab7b	20 7f ab	jsr $ab7f			jsr 	GXPlot0 						; do once
.ab7e	60		rts				rts
.ab7f	ad e6 06	lda $06e6	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ab82	f0 05		beq $ab89			beq 	_GXPlot0Always
.ab84	ad e7 06	lda $06e7			lda 	gxYChanged						; fill mode, only draw if changed.
.ab87	f0 2d		beq $abb6			beq 	GXPlot0Exit
.ab89					_GXPlot0Always:
.ab89	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ab8b	ad e5 06	lda $06e5			lda 	gYCentre
.ab8e	20 b7 ab	jsr $abb7			jsr 	GXSubCopy
.ab91	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ab93	ad e4 06	lda $06e4			lda 	gXCentre
.ab96	20 b7 ab	jsr $abb7			jsr 	GXSubCopy
.ab99	48		pha				pha 									; save last offset X
.ab9a	20 69 b2	jsr $b269			jsr 	GXPositionCalc 					; calculate position/offset.
.ab9d	68		pla				pla
.ab9e	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ab9f	85 36		sta $36				sta 	gxzTemp0
.aba1	64 37		stz $37				stz 	gxzTemp0+1
.aba3	26 37		rol $37				rol 	gxzTemp0+1
.aba5	ad e6 06	lda $06e6			lda 	gxIsFillMode
.aba8	69 80		adc #$80			adc 	#128
.abaa	20 47 af	jsr $af47			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.abad	38		sec				sec 									; GY = -GY
.abae	a9 00		lda #$00			lda 	#0
.abb0	ed e5 06	sbc $06e5			sbc 	gYCentre
.abb3	8d e5 06	sta $06e5			sta 	gYCentre
.abb6					GXPlot0Exit:
.abb6	60		rts				rts
.abb7					GXSubCopy:
.abb7	85 36		sta $36				sta 	gxzTemp0
.abb9	64 37		stz $37				stz 	gxzTemp0+1
.abbb	29 80		and #$80			and 	#$80
.abbd	f0 02		beq $abc1			beq 	_GXNoSx
.abbf	c6 37		dec $37				dec 	gxzTemp0+1
.abc1					_GXNoSx:
.abc1	38		sec				sec
.abc2	bd 4f 06	lda $064f,x			lda 	gXX1,x
.abc5	e5 36		sbc $36				sbc 	gxzTemp0
.abc7	9d 4b 06	sta $064b,x			sta 	gXX0,x
.abca	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.abcd	e5 37		sbc $37				sbc 	gxzTemp0+1
.abcf	9d 4c 06	sta $064c,x			sta 	gXX0+1,x
.abd2	a5 36		lda $36				lda 	gxzTemp0 						; return A
.abd4	60		rts				rts
.abd5					GXCircleMove:
.abd5	9c e7 06	stz $06e7			stz 	gxYChanged 					; clear Y changed flag
.abd8	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.abda	10 0d		bpl $abe9			bpl 	_GXEMPositive
.abdc	ee e4 06	inc $06e4			inc 	gXCentre 					; X++
.abdf	ad e4 06	lda $06e4			lda 	gXCentre
.abe2	20 08 ac	jsr $ac08			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abe5	a9 06		lda #$06			lda 	#6  						; and add 6
.abe7	80 15		bra $abfe			bra 	_GXEMAddD
.abe9					_GXEMPositive:
.abe9	ee e4 06	inc $06e4			inc 	gXCentre					; X++
.abec	ce e5 06	dec $06e5			dec 	gyCentre 					; Y--
.abef	38		sec				sec 								; calculate X-Y
.abf0	ad e4 06	lda $06e4			lda 	gXCentre
.abf3	ed e5 06	sbc $06e5			sbc 	gYCentre
.abf6	20 08 ac	jsr $ac08			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abf9	a9 0a		lda #$0a			lda 	#10  						; and add 10
.abfb	ce e7 06	dec $06e7			dec 	gxYChanged
.abfe					_GXEMAddD:
.abfe	18		clc				clc
.abff	65 38		adc $38				adc 	gxzTemp1
.ac01	85 38		sta $38				sta 	gxzTemp1
.ac03	90 02		bcc $ac07			bcc 	_GXEMNoCarry
.ac05	e6 39		inc $39				inc 	gxzTemp1+1
.ac07					_GXEMNoCarry:
.ac07	60		rts				rts
.ac08					_GXAdd4TimesToD:
.ac08	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.ac0a	29 80		and #$80			and 	#$80
.ac0c	f0 02		beq $ac10			beq 	_GXA4Unsigned
.ac0e	a9 ff		lda #$ff			lda 	#$FF
.ac10					_GXA4Unsigned:
.ac10	85 37		sta $37				sta 	gxzTemp0+1
.ac12	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ac14	26 37		rol $37				rol 	gxzTemp0+1
.ac16	06 36		asl $36				asl 	gxzTemp0
.ac18	26 37		rol $37				rol 	gxzTemp0+1
.ac1a	18		clc				clc 								; add
.ac1b	a5 36		lda $36				lda		gxzTemp0
.ac1d	65 38		adc $38				adc 	gxzTemp1
.ac1f	85 38		sta $38				sta 	gxzTemp1
.ac21	a5 37		lda $37				lda		gxzTemp0+1
.ac23	65 39		adc $39				adc 	gxzTemp1+1
.ac25	85 39		sta $39				sta 	gxzTemp1+1
.ac27	60		rts				rts
.ac28					GXCircleSetup:
.ac28	38		sec				sec
.ac29	ad 51 06	lda $0651			lda 	gxY1
.ac2c	ed 4d 06	sbc $064d			sbc 	gxY0
.ac2f	4a		lsr a				lsr 	a
.ac30	8d e3 06	sta $06e3			sta 	gxRadius
.ac33	a2 00		ldx #$00			ldx 	#0
.ac35	20 57 ac	jsr $ac57			jsr 	_GXCalculateCentre
.ac38	a2 02		ldx #$02			ldx 	#2
.ac3a	20 57 ac	jsr $ac57			jsr 	_GXCalculateCentre
.ac3d	9c e4 06	stz $06e4			stz 	gXCentre
.ac40	ad e3 06	lda $06e3			lda 	gxRadius
.ac43	8d e5 06	sta $06e5			sta 	gYCentre
.ac46	0a		asl a				asl 	a 							; R x 2
.ac47	85 36		sta $36				sta 	gxzTemp0
.ac49	38		sec				sec
.ac4a	a9 03		lda #$03			lda 	#3
.ac4c	e5 36		sbc $36				sbc 	gxzTemp0
.ac4e	85 38		sta $38				sta 	gxzTemp1
.ac50	a9 00		lda #$00			lda 	#0
.ac52	e9 00		sbc #$00			sbc 	#0
.ac54	85 39		sta $39				sta 	gxzTemp1+1
.ac56	60		rts				rts
.ac57					_GXCalculateCentre:
.ac57	38		sec				sec
.ac58	bd 4f 06	lda $064f,x			lda 	gxX1,x
.ac5b	7d 4b 06	adc $064b,x			adc 	gXX0,x
.ac5e	9d 4f 06	sta $064f,x			sta 	gXX1,x
.ac61	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.ac64	7d 4c 06	adc $064c,x			adc 	gXX0+1,x
.ac67	4a		lsr a				lsr 	a
.ac68	9d 50 06	sta $0650,x			sta 	gXX1+1,x
.ac6b	7e 4f 06	ror $064f,x			ror 	gXX1,x
.ac6e	60		rts				rts
.06e3					gxRadius:
>06e3							.fill 	1
.06e4					gXCentre:
>06e4							.fill 	1
.06e5					gYCentre:
>06e5							.fill 	1
.06e6					gxIsFillMode:
>06e6							.fill 	1
.06e7					gxYChanged:
>06e7							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ac6f					GXClearBitmap:
.ac6f	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP running.
.ac72	f0 24		beq $ac98			beq 	_GXCBFail
.ac74	20 59 b2	jsr $b259			jsr 	GXOpenBitmap 				; start access
.ac77	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac79	ad 57 06	lda $0657			lda 	gxHeight
.ac7c	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ac7e	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ac80					_GXCalcLastPage:
.ac80	98		tya				tya 								; add to base page
.ac81	18		clc				clc
.ac82	6d 55 06	adc $0655			adc 	gxBasePage
.ac85	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ac87					_GXClearAll:
.ac87	20 9a ac	jsr $ac9a			jsr 	_GXClearBlock 				; clear 8k block
.ac8a	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ac8c	a5 0b		lda $0b				lda 	GXEditSlot
.ac8e	cd 55 06	cmp $0655			cmp 	gxBasePage 					; until before base page
.ac91	b0 f4		bcs $ac87			bcs 	_GXClearAll
.ac93	20 61 b2	jsr $b261			jsr 	GXCloseBitmap	 			; stop access
.ac96	18		clc				clc
.ac97	60		rts				rts
.ac98					_GXCBFail:
.ac98	38		sec				sec
.ac99	60		rts				rts
.ac9a					_GXClearBlock:
.ac9a	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ac9c	85 38		sta $38				sta 	0+gxzTemp1
.ac9e	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.aca0	85 39		sta $39				sta 	1+gxzTemp1
.aca2					_GXCB0:
.aca2	a5 36		lda $36				lda 	gxzTemp0
.aca4	a0 00		ldy #$00			ldy 	#0
.aca6					_GXCB1:
.aca6	91 38		sta ($38),y			sta 	(gxzTemp1),y
.aca8	c8		iny				iny
.aca9	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acab	c8		iny				iny
.acac	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acae	c8		iny				iny
.acaf	91 38		sta ($38),y			sta 	(gxzTemp1),y
.acb1	c8		iny				iny
.acb2	d0 f2		bne $aca6			bne 	_GXCB1
.acb4	e6 39		inc $39				inc 	gxzTemp1+1
.acb6	a5 39		lda $39				lda 	gxzTemp1+1
.acb8	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.acba	d0 e6		bne $aca2			bne 	_GXCB0
.acbc	60		rts				rts
.acbd					GXInitialise:
.acbd	64 01		stz $01				stz 	1
.acbf	a9 01		lda #$01			lda 	#1
.acc1	8d 00 d0	sta $d000			sta 	$D000
.acc4	18		clc				clc
.acc5	9c 53 06	stz $0653			stz 	GXSpritesOn
.acc8	9c 54 06	stz $0654			stz 	GXBitmapsOn
.accb	a2 0f		ldx #$0f			ldx 	#15
.accd					_GXIClear:
.accd	9e 43 06	stz $0643,x			stz 	gxCurrentX,x
.acd0	ca		dex				dex
.acd1	10 fa		bpl $accd			bpl 	_GXIClear
.acd3	20 6e ad	jsr $ad6e			jsr 	GXClearSpriteStore
.acd6	60		rts				rts
.acd7					GXControlBitmap:
.acd7	64 01		stz $01				stz 	1
.acd9	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acdb	29 01		and #$01			and 	#1 							; set bitmap flag
.acdd	8d 54 06	sta $0654			sta 	gxBitmapsOn
.ace0	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ace1	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ace4	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ace6	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ace8	90 02		bcc $acec			bcc 	_CBNotOn
.acea	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.acec					_CBNotOn:
.acec	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.acef	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.acf1	29 07		and #$07			and 	#7
.acf3	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.acf6	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.acf8	d0 02		bne $acfc			bne 	_CBNotDefault
.acfa	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.acfc					_CBNotDefault:
.acfc	8d 55 06	sta $0655			sta 	gxBasePage
.acff	20 60 ad	jsr $ad60			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad02	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ad04	8d 03 d1	sta $d103			sta 	$D103
.ad07	a5 36		lda $36				lda 	gxzTemp0
.ad09	8d 02 d1	sta $d102			sta 	$D102
.ad0c	9c 01 d1	stz $d101			stz 	$D101
.ad0f	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ad11	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ad14	29 01		and #$01			and 	#1
.ad16	f0 02		beq $ad1a			beq 	_CBHaveHeight
.ad18	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ad1a					_CBHaveHeight
.ad1a	8e 57 06	stx $0657			stx 	gxHeight
.ad1d	18		clc				clc
.ad1e	60		rts				rts
.ad1f					GXControlSprite:
.ad1f	64 01		stz $01				stz 	1
.ad21	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad23	29 01		and #$01			and 	#1 							; set sprites flag
.ad25	8d 53 06	sta $0653			sta 	gxSpritesOn
.ad28	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad29	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad2c	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad2e	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ad30	90 02		bcc $ad34			bcc 	_CSNotOn
.ad32	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ad34					_CSNotOn:
.ad34	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad37	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad39	d0 02		bne $ad3d			bne 	_CSNotDefault
.ad3b	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ad3d					_CSNotDefault:
.ad3d	8d 56 06	sta $0656			sta 	gxSpritePage
.ad40	20 60 ad	jsr $ad60			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad43	a5 36		lda $36				lda 	zTemp0
.ad45	8d 61 06	sta $0661			sta 	GXSpriteOffsetBase
.ad48	a5 37		lda $37				lda 	zTemp0+1
.ad4a	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase+1
.ad4d	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ad4f					_CSClear:
.ad4f	9e 00 d9	stz $d900,x			stz 	$D900,x
.ad52	9e 00 da	stz $da00,x			stz 	$DA00,x
.ad55	ca		dex				dex
.ad56	d0 f7		bne $ad4f			bne 	_CSClear
.ad58	9c 60 06	stz $0660			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ad5b	20 6e ad	jsr $ad6e			jsr 	GXClearSpriteStore
.ad5e	18		clc				clc
.ad5f	60		rts				rts
.ad60					GXCalculateBaseAddress:
.ad60	85 36		sta $36				sta 	gxzTemp0
.ad62	64 37		stz $37				stz 	gxzTemp0+1
.ad64	a9 05		lda #$05			lda 	#5
.ad66					_GXShift:
.ad66	06 36		asl $36				asl 	gxzTemp0
.ad68	26 37		rol $37				rol 	gxzTemp0+1
.ad6a	3a		dec a				dec		a
.ad6b	d0 f9		bne $ad66			bne 	_GXShift
.ad6d	60		rts				rts
.ad6e					GXClearSpriteStore:
.ad6e	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ad70					_GXCSSLoop:
.ad70	9e a3 06	stz $06a3,x			stz 	GXSpriteHigh,x
.ad73	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad75	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.ad78	ca		dex				dex
.ad79	10 f5		bpl $ad70			bpl 	_GXCSSLoop
.ad7b	60		rts				rts
.ad7c					GXLine:
.ad7c	ad 54 06	lda $0654			lda 	GXBitmapsOn
.ad7f	f0 28		beq $ada9			beq 	_GXLFail
.ad81	20 59 b2	jsr $b259			jsr 	GXOpenBitmap
.ad84	20 9f b3	jsr $b39f			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ad87	20 4f ae	jsr $ae4f			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ad8a	20 69 b2	jsr $b269			jsr 	GXPositionCalc 				; calculate position/offset.
.ad8d					_GXDrawLoop:
.ad8d	ac 5d 06	ldy $065d			ldy 	gsOffset 					; draw the pixel
.ad90	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ad92	2d 5b 06	and $065b			and 	gxANDValue
.ad95	4d 5a 06	eor $065a			eor 	gxEORValue
.ad98	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ad9a	20 ab ad	jsr $adab			jsr 	GXLineIsComplete 			; is the line complete ?
.ad9d	f0 05		beq $ada4			beq 	_GXLExit
.ad9f	20 c6 ad	jsr $adc6			jsr 	GXLineAdvance 				; code as per advance method
.ada2	80 e9		bra $ad8d			bra 	_GXDrawLoop
.ada4					_GXLExit:
.ada4	20 61 b2	jsr $b261			jsr 	GXCloseBitmap
.ada7	18		clc				clc
.ada8	60		rts				rts
.ada9					_GXLFail:
.ada9	38		sec				sec
.adaa	60		rts				rts
.adab					GXLineIsComplete:
.adab	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger 			; is dy larger
.adae	d0 0f		bne $adbf			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.adb0	ad 4b 06	lda $064b			lda 	GXX0 						; compare X, LSB and MSB
.adb3	4d 4f 06	eor $064f			eor 	GXX1
.adb6	d0 06		bne $adbe			bne 	_GXLICExit
.adb8	ad 4c 06	lda $064c			lda 	GXX0+1
.adbb	4d 50 06	eor $0650			eor 	GXX1+1
.adbe					_GXLICExit:
.adbe	60		rts				rts
.adbf					_GXLICCompareY:
.adbf	ad 51 06	lda $0651			lda 	GXY1
.adc2	4d 4d 06	eor $064d			eor 	GXY0
.adc5	60		rts				rts
.adc6					GXLineAdvance:
.adc6	18		clc				clc 								; add adjust to position
.adc7	ad ec 06	lda $06ec			lda 	GXPosition
.adca	6d ed 06	adc $06ed			adc 	GXAdjust
.adcd	8d ec 06	sta $06ec			sta 	GXPosition
.add0	9c ef 06	stz $06ef			stz 	GXAddSelect 				; clear add select flag
.add3	b0 05		bcs $adda			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.add5	cd ee 06	cmp $06ee			cmp 	GXTotal 					; if exceeded total
.add8	90 0a		bcc $ade4			bcc 	_GXLANoExtra
.adda					_GXLAOverflow:
.adda	ce ef 06	dec $06ef			dec 	GXAddSelect 				; set addselect to $FF
.addd	38		sec				sec 								; subtract total and write back
.adde	ed ee 06	sbc $06ee			sbc 	GXTotal
.ade1	8d ec 06	sta $06ec			sta 	GXPosition
.ade4					_GXLANoExtra:
.ade4	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger
.ade7	f0 0d		beq $adf6			beq 	_GXDXLarger
.ade9	20 48 ae	jsr $ae48			jsr 	GXIncrementY
.adec	ad ef 06	lda $06ef			lda 	GXAddSelect
.adef	f0 10		beq $ae01			beq 	_GXLAExit
.adf1	20 02 ae	jsr $ae02			jsr 	GXAdjustX
.adf4	80 0b		bra $ae01			bra 	_GXLAExit
.adf6					_GXDXLarger:
.adf6	20 02 ae	jsr $ae02			jsr 	GXAdjustX
.adf9	ad ef 06	lda $06ef			lda 	GXAddSelect
.adfc	f0 03		beq $ae01			beq 	_GXLAExit
.adfe	20 48 ae	jsr $ae48			jsr 	GXIncrementY
.ae01					_GXLAExit:
.ae01	60		rts				rts
.ae02					GXAdjustX:
.ae02	ad eb 06	lda $06eb			lda 	GXDXNegative
.ae05	10 25		bpl $ae2c			bpl 	_GXAXRight
.ae07	ad 4b 06	lda $064b			lda 	GXX0
.ae0a	d0 03		bne $ae0f			bne 	_GXAXNoBorrow
.ae0c	ce 4c 06	dec $064c			dec 	GXX0+1
.ae0f					_GXAXNoBorrow:
.ae0f	ce 4b 06	dec $064b			dec 	GXX0
.ae12	ce 5d 06	dec $065d			dec 	gsOffset 					; pixel left
.ae15	ad 5d 06	lda $065d			lda 	gsOffset
.ae18	c9 ff		cmp #$ff			cmp 	#$FF
.ae1a	d0 0f		bne $ae2b			bne 	_GXAYExit 					; underflow
.ae1c	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.ae1e	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.ae20	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.ae22	b0 07		bcs $ae2b			bcs 	_GXAYExit
.ae24	18		clc				clc
.ae25	69 20		adc #$20			adc 	#$20 						; fix up
.ae27	85 3d		sta $3d				sta 	gxzScreen+1
.ae29	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ae2b					_GXAYExit:
.ae2b	60		rts				rts
.ae2c					_GXAXRight:
.ae2c	ee 4b 06	inc $064b			inc 	GXX0
.ae2f	d0 03		bne $ae34			bne 	_GXAXNoCarry
.ae31	ee 4c 06	inc $064c			inc 	GXX0+1
.ae34					_GXAXNoCarry:
.ae34	ee 5d 06	inc $065d			inc 	gsOffset 					; pixel right
.ae37	d0 0e		bne $ae47			bne 	_GXAXExit 					; if not overflowed, exit.
.ae39	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ae3b	a5 3d		lda $3d				lda 	gxzScreen+1
.ae3d	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ae3f	90 06		bcc $ae47			bcc 	_GXAXExit
.ae41	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae43	85 3d		sta $3d				sta 	gxzScreen+1
.ae45	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ae47					_GXAXExit:
.ae47	60		rts				rts
.ae48					GXIncrementY:
.ae48	ee 4d 06	inc $064d			inc 	GXY0
.ae4b	20 bf b2	jsr $b2bf			jsr 	GXMovePositionDown
.ae4e	60		rts				rts
.ae4f					GXLineSetup:
.ae4f	ad 51 06	lda $0651			lda 	GXY1
.ae52	38		sec				sec
.ae53	ed 4d 06	sbc $064d			sbc 	GXY0
.ae56	4a		lsr a				lsr 	a
.ae57	8d e9 06	sta $06e9			sta 	GXDiffY
.ae5a	9c eb 06	stz $06eb			stz 	GXDXNegative 				; clear -ve flag
.ae5d	38		sec				sec
.ae5e	ad 4f 06	lda $064f			lda 	GXX1
.ae61	ed 4b 06	sbc $064b			sbc 	GXX0
.ae64	8d e8 06	sta $06e8			sta 	GXDiffX
.ae67	ad 50 06	lda $0650			lda 	GXX1+1 						; calculate MSB
.ae6a	ed 4c 06	sbc $064c			sbc 	GXX0+1
.ae6d	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ae6e	6e e8 06	ror $06e8			ror 	GXDiffX
.ae71	0a		asl a				asl 	a
.ae72	10 0c		bpl $ae80			bpl 	_GDXNotNegative
.ae74	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae76	38		sec				sec
.ae77	ed e8 06	sbc $06e8			sbc 	GXDiffX
.ae7a	8d e8 06	sta $06e8			sta 	GXDiffX
.ae7d	ce eb 06	dec $06eb			dec 	GXDXNegative 				; -ve flag = $FF.
.ae80					_GDXNotNegative:
.ae80	9c ea 06	stz $06ea			stz 	GXIsDiffYLarger 			; clear larger flag
.ae83	ad e9 06	lda $06e9			lda 	GXDiffY 					; set adjust and total.
.ae86	8d ed 06	sta $06ed			sta 	GXAdjust
.ae89	ad e8 06	lda $06e8			lda 	GXDiffX
.ae8c	8d ee 06	sta $06ee			sta 	GXTotal
.ae8f	ad e9 06	lda $06e9			lda 	GXDiffY 					; if dy > dx
.ae92	cd e8 06	cmp $06e8			cmp 	GXDiffX
.ae95	90 0f		bcc $aea6			bcc 	_GDXNotLarger
.ae97	ce ea 06	dec $06ea			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ae9a	ad e8 06	lda $06e8			lda 	GXDiffX 					; set adjust and total other way round
.ae9d	8d ed 06	sta $06ed			sta 	GXAdjust
.aea0	ad e9 06	lda $06e9			lda 	GXDiffY
.aea3	8d ee 06	sta $06ee			sta 	GXTotal
.aea6					_GDXNotLarger:
.aea6	ad ee 06	lda $06ee			lda 	GXTotal
.aea9	4a		lsr a				lsr 	a
.aeaa	8d ec 06	sta $06ec			sta 	GXPosition
.aead	60		rts				rts
.06e8					GXDiffX:
>06e8							.fill 	1
.06e9					GXDiffY:
>06e9							.fill 	1
.06ea					GXIsDiffYLarger:
>06ea							.fill 	1
.06eb					GXDXNegative:
>06eb							.fill 	1
.06ec					GXPosition:
>06ec							.fill 	1
.06ed					GXAdjust:
>06ed							.fill 	1
.06ee					GXTotal:
>06ee							.fill 	1
.06ef					GXAddSelect:
>06ef							.fill 	1
.aeae					GXSetColourMode:
.aeae	a6 36		ldx $36				ldx 	gxzTemp0
.aeb0	8e 59 06	stx $0659			stx 	gxColour 								; set colour
.aeb3	a5 37		lda $37				lda 	gxzTemp0+1 								;
.aeb5	8d 58 06	sta $0658			sta 	gxMode 									; set mode
.aeb8	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.aeba	9c 5b 06	stz $065b			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.aebd	ae 59 06	ldx $0659			ldx 	gxColour
.aec0	8e 5a 06	stx $065a			stx 	gxEORValue
.aec3	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.aec5	90 03		bcc $aeca			bcc 	_GXSDCNotAndColour
.aec7	8e 5b 06	stx $065b			stx 	gxANDValue
.aeca					_GXSDCNotAndColour:
.aeca	d0 03		bne $aecf			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.aecc	9c 5a 06	stz $065a			stz 	gxEORValue
.aecf					_GXSDCNotAnd:
.aecf	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.aed0	90 08		bcc $aeda			bcc 	_GXSDCNoFlip
.aed2	ad 5b 06	lda $065b			lda	 	gxANDValue
.aed5	49 ff		eor #$ff			eor 	#$FF
.aed7	8d 5b 06	sta $065b			sta 	gxANDValue
.aeda					_GXSDCNoFlip:
.aeda	18		clc				clc
.aedb	60		rts				rts
.aedc					GXPlotPoint:
.aedc	20 59 b2	jsr $b259			jsr 	GXOpenBitmap 				; start drawing
.aedf	20 69 b2	jsr $b269			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aee2	ac 5d 06	ldy $065d			ldy 	gsOffset
.aee5	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.aee7	2d 5b 06	and $065b			and 	gxANDValue
.aeea	4d 5a 06	eor $065a			eor 	gxEORValue
.aeed	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aeef	20 61 b2	jsr $b261			jsr 	GXCloseBitmap 				; stop drawing and exit
.aef2	18		clc				clc
.aef3	60		rts				rts
.aef4					GXFillRectangle:
.aef4	38		sec				sec
.aef5	80 01		bra $aef8			bra 	GXRectangle
.aef7					GXFrameRectangle:
.aef7	18		clc				clc
.aef8					GXRectangle:
.aef8	ad 54 06	lda $0654			lda 	gxBitmapsOn
.aefb	f0 35		beq $af32			beq 	_GXRFail
.aefd	08		php				php 								; save Fill flag (CS)
.aefe	20 59 b2	jsr $b259			jsr 	GXOpenBitmap 				; start drawing
.af01	20 81 b3	jsr $b381			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.af04	20 69 b2	jsr $b269			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.af07	38		sec				sec 								; sec = Draw line
.af08	20 34 af	jsr $af34			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.af0b	ad 4d 06	lda $064d			lda 	gxY0 						; reached end of rectangle ?
.af0e	cd 51 06	cmp $0651			cmp 	gxY1
.af11	f0 19		beq $af2c			beq 	_GXRectangleExit
.af13					_GXRectLoop:
.af13	20 bf b2	jsr $b2bf			jsr 	GXMovePositionDown 			; down one.
.af16	ee 4d 06	inc $064d			inc 	gxY0 						; change Y pos
.af19	ad 4d 06	lda $064d			lda 	gxY0 						; reached last line
.af1c	cd 51 06	cmp $0651			cmp 	gXY1
.af1f	f0 07		beq $af28			beq 	_GXLastLine
.af21	28		plp				plp 								; get flag back
.af22	08		php				php
.af23	20 34 af	jsr $af34			jsr 	GXDrawLineX1X0 				; draw horizontal line
.af26	80 eb		bra $af13			bra 	_GXRectLoop
.af28					_GXLastLine:
.af28	38		sec				sec
.af29	20 34 af	jsr $af34			jsr 	GXDrawLineX1X0
.af2c					_GXRectangleExit:
.af2c	68		pla				pla 								; throw fill flag.
.af2d	20 61 b2	jsr $b261			jsr 	GXCloseBitmap 				; stop drawing and exit
.af30	18		clc				clc
.af31	60		rts				rts
.af32					_GXRFail:
.af32	38		sec				sec
.af33	60		rts				rts
.af34					GXDrawLineX1X0:
.af34	08		php				php 								; save solid/either-end
.af35	38		sec				sec
.af36	ad 4f 06	lda $064f			lda		gXX1
.af39	ed 4b 06	sbc $064b			sbc 	gXX0
.af3c	85 36		sta $36				sta 	gxzTemp0
.af3e	ad 50 06	lda $0650			lda 	gXX1+1
.af41	ed 4c 06	sbc $064c			sbc 	gXX0+1
.af44	85 37		sta $37				sta 	gxzTemp0+1
.af46	28		plp				plp
.af47					GXDrawLineTemp0:
.af47	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.af49	48		pha				pha
.af4a	a5 3d		lda $3d				lda 	gxzScreen+1
.af4c	48		pha				pha
.af4d	ad 5d 06	lda $065d			lda 	gsOffset
.af50	48		pha				pha
.af51	a5 0b		lda $0b				lda 	GXEditSlot
.af53	48		pha				pha
.af54	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y offset
.af57	90 1e		bcc $af77			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.af59					_GXDLTLine:
.af59	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af5b	2d 5b 06	and $065b			and 	gxANDValue
.af5e	4d 5a 06	eor $065a			eor 	gxEORValue
.af61	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af63	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.af65	d0 04		bne $af6b			bne 	_GXDLTNoBorrow
.af67	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.af69	30 2e		bmi $af99			bmi 	_GXDLTExit
.af6b					_GXDLTNoBorrow:
.af6b	c6 36		dec $36				dec 	gxzTemp0
.af6d	c8		iny				iny 								; next slot.
.af6e	d0 e9		bne $af59			bne 	_GXDLTLine
.af70	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.af72	20 a7 af	jsr $afa7			jsr 	GXDLTCheckWrap				; check for new page.
.af75	80 e2		bra $af59			bra 	_GXDLTLine
.af77					_GXDLTEndPoints:
.af77	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af79	2d 5b 06	and $065b			and 	gxANDValue
.af7c	4d 5a 06	eor $065a			eor 	gxEORValue
.af7f	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af81	98		tya				tya 								; advance to right side
.af82	18		clc				clc
.af83	65 36		adc $36				adc 	gxzTemp0
.af85	a8		tay				tay
.af86	a5 3d		lda $3d				lda 	gxzScreen+1
.af88	65 37		adc $37				adc 	gxzTemp0+1
.af8a	85 3d		sta $3d				sta 	gxzScreen+1
.af8c	20 a7 af	jsr $afa7			jsr 	GXDLTCheckWrap 			; fix up.
.af8f	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af91	2d 5b 06	and $065b			and 	gxANDValue
.af94	4d 5a 06	eor $065a			eor 	gxEORValue
.af97	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af99					_GXDLTExit:
.af99	68		pla				pla
.af9a	85 0b		sta $0b				sta 	GXEditSlot
.af9c	68		pla				pla
.af9d	8d 5d 06	sta $065d			sta 	gsOffset
.afa0	68		pla				pla
.afa1	85 3d		sta $3d				sta 	gxzScreen+1
.afa3	68		pla				pla
.afa4	85 3c		sta $3c				sta 	gxzScreen
.afa6	60		rts				rts
.afa7					GXDLTCheckWrap:
.afa7	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.afa9	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.afab	90 06		bcc $afb3			bcc 	_GXDLTCWExit
.afad	e9 20		sbc #$20			sbc 	#$20 						; fix up
.afaf	85 3d		sta $3d				sta 	gxzScreen+1
.afb1	e6 0b		inc $0b				inc 	GXEditSlot
.afb3					_GXDLTCWExit:
.afb3	60		rts				rts
.afb4					GXDrawGraphicElement:
.afb4	8d f0 06	sta $06f0			sta 	gxSize 						; save size
.afb7	3a		dec a				dec 	a
.afb8	8d f1 06	sta $06f1			sta 	gxMask 						; and mask
.afbb	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP on
.afbe	f0 67		beq $b027			beq 	_GXSLFail
.afc0	ad 4d 06	lda $064d			lda 	gxY0 						; push Y on stack
.afc3	48		pha				pha
.afc4	8c f3 06	sty $06f3			sty 	gxAcquireVector+1 			; and acquisition vector
.afc7	8e f2 06	stx $06f2			stx 	gxAcquireVector
.afca	20 59 b2	jsr $b259			jsr 	gxOpenBitmap 				; open the bitmap.
.afcd	ad f5 06	lda $06f5			lda 	gxUseMode 					; scale bits
.afd0	4a		lsr a				lsr 	a
.afd1	4a		lsr a				lsr 	a
.afd2	4a		lsr a				lsr 	a
.afd3	29 07		and #$07			and		#7
.afd5	1a		inc a				inc 	a
.afd6	8d f4 06	sta $06f4			sta 	gxScale
.afd9	64 38		stz $38				stz 	gxzTemp1					; start first line
.afdb					_GXGELoop:
.afdb	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.afdd	2c f5 06	bit $06f5			bit 	gxUseMode 					; check for flip.
.afe0	10 06		bpl $afe8			bpl		_GXNoVFlip
.afe2	ad f1 06	lda $06f1			lda 	gxMask
.afe5	38		sec				sec
.afe6	e5 38		sbc $38				sbc 	gxzTemp1
.afe8					_GXNoVFlip:
.afe8	aa		tax				tax 								; get the Xth line.
.afe9	20 29 b0	jsr $b029			jsr 	_GXCallAcquire 				; get that data.
.afec	ad f4 06	lda $06f4			lda 	gxScale 					; do scale identical copies of that line.
.afef	85 39		sta $39				sta 	gxzTemp1+1
.aff1					_GXGELoop2:
.aff1	ad 4d 06	lda $064d			lda 	gxY0 						; off screen
.aff4	cd 57 06	cmp $0657			cmp 	gxHeight
.aff7	b0 10		bcs $b009			bcs 	_GXDGEExit
.aff9	20 2c b0	jsr $b02c			jsr 	GXRenderOneLine 			; render line
.affc	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.affe	d0 f1		bne $aff1			bne 	_GXGELoop2
.b000	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b002	a5 38		lda $38				lda 	gxzTemp1
.b004	cd f0 06	cmp $06f0			cmp 	gxSize
.b007	d0 d2		bne $afdb			bne 	_GXGELoop
.b009					_GXDGEExit:
.b009	68		pla				pla 								; restore Y for next time
.b00a	8d 4d 06	sta $064d			sta 	gxY0
.b00d	ae f4 06	ldx $06f4			ldx 	gxScale 					; get scale (1-8)
.b010					_GXShiftLeft:
.b010	18		clc				clc
.b011	ad f0 06	lda $06f0			lda 	gxSize
.b014	6d 4b 06	adc $064b			adc 	gxX0
.b017	8d 4b 06	sta $064b			sta 	gxX0
.b01a	90 03		bcc $b01f			bcc 	_GXSLNoCarry
.b01c	ee 4c 06	inc $064c			inc 	gxX0+1
.b01f					_GXSLNoCarry:
.b01f	ca		dex				dex
.b020	d0 ee		bne $b010			bne 	_GXShiftLeft
.b022	20 61 b2	jsr $b261			jsr 	GXCloseBitmap
.b025	18		clc				clc
.b026	60		rts				rts
.b027					_GXSLFail:
.b027	38		sec				sec
.b028	60		rts				rts
.b029					_GXCallAcquire:
.b029	6c f2 06	jmp ($06f2)			jmp 	(gxAcquireVector)
.b02c					GXRenderOneLine:
.b02c	20 69 b2	jsr $b269			jsr 	GXPositionCalc 				; calculate position/offset.
.b02f	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y contains position.
.b032	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b034					_GXROLLoop1:
.b034	ad f4 06	lda $06f4			lda 	gxScale 					; set to do 'scale' times
.b037	85 3b		sta $3b				sta 	gxzTemp2+1
.b039					_GXROLLoop2:
.b039	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b03b	2c 58 06	bit $0658			bit 	gxMode 						; check H Flip
.b03e	50 06		bvc $b046			bvc 	_GXNoHFlip
.b040	ad f1 06	lda $06f1			lda 	gxMask
.b043	38		sec				sec
.b044	e5 3a		sbc $3a				sbc 	gxzTemp2
.b046					_GXNoHFlip:
.b046	aa		tax				tax 								; read from the pixel buffer
.b047	bd f9 05	lda $05f9,x			lda 	gxPixelBuffer,x
.b04a	d0 07		bne $b053			bne 	_GXDraw 					; draw if non zero
.b04c	ad f5 06	lda $06f5			lda 	gxUseMode 					; check to see if solid background
.b04f	29 04		and #$04			and 	#4
.b051	f0 0a		beq $b05d			beq 	_GXZeroPixel
.b053					_GXDraw:
.b053	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b055	2d 5b 06	and $065b			and 	gxANDValue
.b058	5d f9 05	eor $05f9,x			eor 	gxPixelBuffer,x
.b05b	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b05d					_GXZeroPixel:
.b05d	c8		iny				iny 								; advance pointer
.b05e	d0 05		bne $b065			bne 	_GXNoShift
.b060	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b062	20 a7 af	jsr $afa7			jsr 	GXDLTCheckWrap				; check for new page.
.b065					_GXNoShift:
.b065	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b067	d0 d0		bne $b039			bne 	_GXROLLoop2
.b069	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b06b	a5 3a		lda $3a				lda 	gxzTemp2
.b06d	cd f0 06	cmp $06f0			cmp 	gxSize
.b070	d0 c2		bne $b034			bne 	_GXROLLoop1
.b072	ee 4d 06	inc $064d			inc 	gxY0
.b075	60		rts				rts
.06f0					gxSize:
>06f0							.fill 	1
.06f1					gxMask:
>06f1							.fill 	1
.06f2					gxAcquireVector:
>06f2							.fill 	2
.06f4					gxScale:
>06f4							.fill 	1
.06f5					gxUseMode:
>06f5							.fill 	1
.b076					GXFontHandler:
.b076	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b078	4d 58 06	eor $0658			eor 	gxMode
.b07b	8d f5 06	sta $06f5			sta 	gxUseMode
.b07e	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b080	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b082	26 37		rol $37				rol	 	gxzTemp0+1
.b084	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b086	26 37		rol $37				rol	 	gxzTemp0+1
.b088	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b08a	26 37		rol $37				rol	 	gxzTemp0+1
.b08c	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b08e	09 c0		ora #$c0			ora 	#$C0
.b090	85 37		sta $37				sta 	gxzTemp0+1
.b092	a9 08		lda #$08			lda 	#8 							; size 8x8
.b094	a2 9c		ldx #$9c			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b096	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b098	20 b4 af	jsr $afb4			jsr 	GXDrawGraphicElement
.b09b	60		rts				rts
.b09c					GXGetGraphicDataFont:
.b09c	8a		txa				txa 								; X->Y
.b09d	a8		tay				tay
.b09e	a6 01		ldx $01				ldx 	1 							; preserve old value
.b0a0	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b0a2	85 01		sta $01				sta 	1
.b0a4	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b0a6	86 01		stx $01				stx 	1 							; put old value back.
.b0a8	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b0aa					_GXExpand:
.b0aa	9e f9 05	stz $05f9,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b0ad	0a		asl a				asl 	a 							; shift bit 7 into C
.b0ae	90 08		bcc $b0b8			bcc 	_GXNoPixel
.b0b0	48		pha				pha 								; if set, set pixel buffer to current colour.
.b0b1	ad 59 06	lda $0659			lda 	gxColour
.b0b4	9d f9 05	sta $05f9,x			sta 	gxPixelBuffer,x
.b0b7	68		pla				pla
.b0b8					_GXNoPixel:
.b0b8	e8		inx				inx 								; do the whole byte.
.b0b9	e0 08		cpx #$08			cpx 	#8
.b0bb	d0 ed		bne $b0aa			bne 	_GXExpand
.b0bd	60		rts				rts
.b0be					GXSpriteHandler:
.b0be	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b0c0	4d 58 06	eor $0658			eor 	gxMode
.b0c3	8d f5 06	sta $06f5			sta 	gxUseMode
.b0c6	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b0c8	da		phx				phx
.b0c9	20 59 b2	jsr $b259			jsr 	GXOpenBitmap 				; can access sprite information
.b0cc	68		pla				pla
.b0cd	20 3a b3	jsr $b33a			jsr 	GXFindSprite 				; get the sprite address
.b0d0	08		php				php
.b0d1	20 61 b2	jsr $b261			jsr 	GXCloseBitmap
.b0d4	28		plp				plp
.b0d5	b0 0a		bcs $b0e1			bcs		_GXSHExit 					; exit if find failed.
.b0d7	ad f6 06	lda $06f6			lda 	GXSizePixels 				; return size
.b0da	a2 e2		ldx #$e2			ldx 	#GXSpriteAcquire & $FF
.b0dc	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b0de	20 b4 af	jsr $afb4			jsr 	GXDrawGraphicElement
.b0e1					_GXSHExit:
.b0e1	60		rts				rts
.b0e2					GXSpriteAcquire:
.b0e2	ad 56 06	lda $0656			lda 	GXSpritePage				; point to base page
.b0e5	85 0b		sta $0b				sta 	GXEditSlot
.b0e7	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b0e9	a9 00		lda #$00			lda 	#0
.b0eb	ae f7 06	ldx $06f7			ldx 	GXSizeBits
.b0ee					_GXTimesRowNumber:
.b0ee	18		clc				clc
.b0ef	65 36		adc $36				adc 	zTemp0
.b0f1	ca		dex				dex
.b0f2	10 fa		bpl $b0ee			bpl 	_GXTimesRowNumber
.b0f4	64 37		stz $37				stz 	gxzTemp0+1
.b0f6	0a		asl a				asl 	a 							; row x 2,4,6,8
.b0f7	26 37		rol $37				rol 	gxzTemp0+1
.b0f9	0a		asl a				asl 	a 							; row x 4,8,12,16
.b0fa	26 37		rol $37				rol 	gxzTemp0+1
.b0fc	0a		asl a				asl 	a 							; row x 8,16,24,32
.b0fd	26 37		rol $37				rol 	gxzTemp0+1
.b0ff	85 36		sta $36				sta 	gxzTemp0
.b101	18		clc				clc 								; add base address.
.b102	a5 36		lda $36				lda 	gxzTemp0
.b104	6d f9 06	adc $06f9			adc 	GXSpriteOffset
.b107	85 36		sta $36				sta 	gxzTemp0
.b109	a5 37		lda $37				lda 	gxzTemp0+1
.b10b	6d fa 06	adc $06fa			adc 	GXSpriteOffset+1
.b10e					_GXSAFindPage:
.b10e	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b110	90 06		bcc $b118			bcc 	_GXSAFoundPage
.b112	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b114	e6 0b		inc $0b				inc 	GXEditSlot
.b116	80 f6		bra $b10e			bra 	_GXSAFindPage
.b118					_GXSAFoundPage:
.b118	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b11a	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b11c	a0 00		ldy #$00			ldy 	#0
.b11e					_GXSACopyLoop:
.b11e	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b120	99 f9 05	sta $05f9,y			sta 	gxPixelBuffer,y
.b123	c8		iny				iny
.b124	cc f6 06	cpy $06f6			cpy 	GXSizePixels
.b127	d0 f5		bne $b11e			bne 	_GXSACopyLoop
.b129	60		rts				rts
.b12a					GXSelect:
.b12a	ad 53 06	lda $0653			lda 	gxSpritesOn
.b12d	f0 22		beq $b151			beq 	_GXSFail
.b12f	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b131	c9 40		cmp #$40			cmp 	#64
.b133	b0 1c		bcs $b151			bcs 	_GXSFail
.b135	8d 5e 06	sta $065e			sta 	GSCurrentSpriteID
.b138	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b13a	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b13c	06 36		asl $36				asl 	gxzTemp0
.b13e	06 36		asl $36				asl 	gxzTemp0
.b140	06 36		asl $36				asl 	gxzTemp0
.b142	2a		rol a				rol 	a
.b143	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b145	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b148	85 37		sta $37				sta 	gxzTemp0+1
.b14a	a5 36		lda $36				lda 	gxzTemp0
.b14c	8d 5f 06	sta $065f			sta 	GSCurrentSpriteAddr
.b14f	18		clc				clc
.b150	60		rts				rts
.b151					_GXSFail:
.b151	38		sec				sec
.b152	60		rts				rts
.b153					GXSelectImage:
.b153	ad 53 06	lda $0653			lda 	gxSpritesOn
.b156	f0 74		beq $b1cc			beq 	_GXSIFail
.b158	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b15b	f0 6f		beq $b1cc			beq 	_GXSIFail 					; (checking the MSB)
.b15d	64 01		stz $01				stz 	1
.b15f	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b161	d0 6b		bne $b1ce			bne 	_GXSIHide
.b163	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b165	48		pha				pha
.b166	20 59 b2	jsr $b259			jsr 	GXOpenBitmap
.b169	68		pla				pla
.b16a	20 3a b3	jsr $b33a			jsr 	GXFindSprite
.b16d	b0 5a		bcs $b1c9			bcs 	_GXSICloseFail 				; no image
.b16f	a0 01		ldy #$01			ldy 	#1
.b171	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b174	85 36		sta $36				sta 	gxzTemp0
.b176	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b179	85 37		sta $37				sta 	gxzTemp0+1
.b17b	ad f9 06	lda $06f9			lda 	GXSpriteOffset
.b17e	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b180	18		clc				clc
.b181	ad fa 06	lda $06fa			lda 	GXSpriteOffset+1
.b184	6d 61 06	adc $0661			adc 	GXSpriteOffsetBase
.b187	c8		iny				iny
.b188	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b18a	ad 62 06	lda $0662			lda 	GXSpriteOffsetBase+1
.b18d	69 00		adc #$00			adc 	#0
.b18f	c8		iny				iny
.b190	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b192	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get raw size
.b195	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b197	2a		rol a				rol 	a 							; x 2
.b198	0a		asl a				asl 	a 							; x 4
.b199	0a		asl a				asl 	a 							; x 8
.b19a	0a		asl a				asl 	a 							; x 16
.b19b	0d f8 06	ora $06f8			ora 	GXSpriteLUT 				; Or with LUT
.b19e	0a		asl a				asl 	a 							; 1 shift
.b19f	09 01		ora #$01			ora 	#1 							; enable sprite.
.b1a1	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b1a3	20 61 b2	jsr $b261			jsr 	GXCloseBitmap
.b1a6	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b1a9	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b1ac	29 3f		and #$3f			and 	#$3F
.b1ae	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1b1	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get bit size
.b1b4	6a		ror a				ror 	a 							; shift into bits 6/7
.b1b5	6a		ror a				ror 	a
.b1b6	6a		ror a				ror 	a
.b1b7	29 c0		and #$c0			and 	#$C0
.b1b9	1d a3 06	ora $06a3,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b1bc	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1bf	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b1c2	29 7f		and #$7f			and 	#$7F
.b1c4	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b1c7	18		clc				clc
.b1c8	60		rts				rts
.b1c9					_GXSICloseFail:
.b1c9	20 61 b2	jsr $b261			jsr 	GXCloseBitmap
.b1cc					_GXSIFail:
.b1cc	38		sec				sec
.b1cd	60		rts				rts
.b1ce					_GXSIHide:
.b1ce	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b1d1	85 36		sta $36				sta 	gxzTemp0
.b1d3	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b1d6	85 37		sta $37				sta 	gxzTemp0+1
.b1d8	a9 00		lda #$00			lda 	#0
.b1da	92 36		sta ($36)			sta 	(gxzTemp0)
.b1dc	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get sprite ID
.b1df	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b1e2	09 80		ora #$80			ora 	#$80
.b1e4	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b1e7	18		clc				clc
.b1e8	60		rts				rts
.b1e9					GXMoveSprite:
.b1e9	ad 53 06	lda $0653			lda 	gxSpritesOn
.b1ec	f0 65		beq $b253			beq 	_GXSIFail
.b1ee	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b1f1	f0 60		beq $b253			beq 	_GXSIFail
.b1f3	85 37		sta $37				sta 	gxzTemp0+1
.b1f5	a0 04		ldy #$04			ldy 	#4
.b1f7	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b1fa	85 36		sta $36				sta 	gxzTemp0
.b1fc	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b1ff	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b202	2a		rol a				rol 	a	 						; into bits 0,1.
.b203	2a		rol a				rol 	a
.b204	2a		rol a				rol 	a
.b205	29 03		and #$03			and 	#3
.b207	aa		tax				tax
.b208	bd 55 b2	lda $b255,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b20b	48		pha				pha
.b20c	18		clc				clc
.b20d	6d 4b 06	adc $064b			adc 	gxX0						; copy position.
.b210	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b212	c8		iny				iny
.b213	ad 4c 06	lda $064c			lda 	gxX0+1
.b216	69 00		adc #$00			adc 	#0
.b218	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b21a	c8		iny				iny
.b21b	68		pla				pla
.b21c	18		clc				clc
.b21d	6d 4d 06	adc $064d			adc 	gxY0
.b220	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b222	a9 00		lda #$00			lda 	#0
.b224	69 00		adc #$00			adc 	#0
.b226	c8		iny				iny
.b227	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b229	4e 4c 06	lsr $064c			lsr 	gxX0+1 						; divide X by 4
.b22c	6e 4b 06	ror $064b			ror 	gxX0
.b22f	4e 4b 06	lsr $064b			lsr 	gxX0
.b232	4e 4d 06	lsr $064d			lsr 	gxY0 						; divide Y by 4
.b235	4e 4d 06	lsr $064d			lsr 	gxY0
.b238	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b23b	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x
.b23e	29 80		and #$80			and 	#$80
.b240	0d 4b 06	ora $064b			ora 	gxX0
.b243	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b246	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b249	29 c0		and #$c0			and 	#$C0
.b24b	0d 4d 06	ora $064d			ora 	gxY0
.b24e	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b251	18		clc				clc
.b252	60		rts				rts
.b253					_GXSIFail:
.b253	38		sec				sec
.b254	60		rts				rts
.b255					_GXMSOffset:
>b255	1c						.byte 	32-8/2
>b256	18						.byte 	32-16/2
>b257	14						.byte 	32-24/2
>b258	10						.byte 	32-32/2
.b259					GXOpenBitmap:
.b259	78		sei				sei 								; no interrupts here
.b25a	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b25c	8d 5c 06	sta $065c			sta 	gxOriginalLUTValue
.b25f	58		cli				cli
.b260	60		rts				rts
.b261					GXCloseBitmap:
.b261	78		sei				sei
.b262	ad 5c 06	lda $065c			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b265	85 0b		sta $0b				sta 	GXEditSlot
.b267	58		cli				cli
.b268	60		rts				rts
.b269					GXPositionCalc:
.b269	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b26b	48		pha				pha
.b26c	ad 4d 06	lda $064d			lda 	GXY0 						; gxzScreen = Y0
.b26f	85 3c		sta $3c				sta 	gxzScreen
.b271	64 3d		stz $3d				stz 	gxzScreen+1
.b273	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b275	26 3d		rol $3d				rol 	gxzScreen+1
.b277	06 3c		asl $3c				asl 	gxzScreen
.b279	26 3d		rol $3d				rol 	gxzScreen+1
.b27b	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b27c	65 3c		adc $3c				adc 	gxzScreen
.b27e	85 3c		sta $3c				sta 	gxzScreen
.b280	90 02		bcc $b284			bcc 	_GXPCNoCarry
.b282	e6 3d		inc $3d				inc 	gxzScreen+1
.b284					_GXPCNoCarry:
.b284	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b286	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b288	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b28a	85 36		sta $36				sta 	gxzTemp0
.b28c	64 3d		stz $3d				stz 	gxzScreen+1
.b28e	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b290					_GXPCMultiply32:
.b290	06 3c		asl $3c				asl 	gxzScreen
.b292	26 3d		rol $3d				rol 	gxzScreen+1
.b294	3a		dec a				dec 	a
.b295	d0 f9		bne $b290			bne 	_GXPCMultiply32
.b297	18		clc				clc
.b298	ad 4b 06	lda $064b			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b29b	65 3c		adc $3c				adc 	gxzScreen
.b29d	8d 5d 06	sta $065d			sta 	gsOffset
.b2a0	ad 4c 06	lda $064c			lda 	GXX0+1
.b2a3	65 3d		adc $3d				adc 	gxzScreen+1
.b2a5	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b2a7	90 04		bcc $b2ad			bcc 	_GXPCNoOverflow
.b2a9	29 1f		and #$1f			and 	#$1F 						; fix it up
.b2ab	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b2ad					_GXPCNoOverflow:
.b2ad	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b2af	85 3d		sta $3d				sta 	gxzScreen+1
.b2b1	64 3c		stz $3c				stz 	gxzScreen
.b2b3	18		clc				clc
.b2b4	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b2b6	6d 55 06	adc $0655			adc 	gxBasePage 					; by adding the base page
.b2b9	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b2bb	68		pla				pla
.b2bc	85 36		sta $36				sta 	gxzTemp0
.b2be	60		rts				rts
.b2bf					GXMovePositionDown:
.b2bf	18		clc				clc 								; add 320 to offset/temp+1
.b2c0	ad 5d 06	lda $065d			lda 	gsOffset
.b2c3	69 40		adc #$40			adc 	#64
.b2c5	8d 5d 06	sta $065d			sta 	gsOffset
.b2c8	a5 3d		lda $3d				lda 	gxzScreen+1
.b2ca	69 01		adc #$01			adc 	#1
.b2cc	85 3d		sta $3d				sta 	gxzScreen+1
.b2ce	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b2d0	90 07		bcc $b2d9			bcc 	_GXMPDExit
.b2d2	38		sec				sec  								; next page
.b2d3	e9 20		sbc #$20			sbc 	#$20
.b2d5	85 3d		sta $3d				sta 	gxzScreen+1
.b2d7	e6 0b		inc $0b				inc 	GXEditSlot
.b2d9					_GXMPDExit:
.b2d9	60		rts				rts
.b2da					GXCollide:
.b2da	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b2dc	aa		tax				tax
.b2dd	05 37		ora $37				ora 	gxzTemp0+1
.b2df	29 c0		and #$c0			and 	#$C0
.b2e1	38		sec				sec
.b2e2	d0 53		bne $b337			bne 	_GXCollideFail 				; if either >= 64, fail.
.b2e4	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b2e6	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b2e9	1d 63 06	ora $0663,x			ora 	GXSpriteLow,x
.b2ec	30 48		bmi $b336			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b2ee	18		clc				clc 								; need to calculate sum of sizes.
.b2ef	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y
.b2f2	7d a3 06	adc $06a3,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b2f5	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b2f7	6a		ror a				ror 	a 							; 5/6/7
.b2f8	4a		lsr a				lsr 	a 							; 4/5/6
.b2f9	4a		lsr a				lsr 	a 							; 3/4/5
.b2fa	4a		lsr a				lsr 	a 							; 2/3/4
.b2fb	18		clc				clc
.b2fc	69 08		adc #$08			adc 	#$08
.b2fe	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b2ff	4a		lsr a				lsr 	a
.b300	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b302	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b305	29 3f		and #$3f			and 	#$3F
.b307	85 39		sta $39				sta 	gxzTemp1+1
.b309	38		sec				sec
.b30a	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b30d	29 3f		and #$3f			and 	#$3F
.b30f	e5 39		sbc $39				sbc 	gxzTemp1+1
.b311	b0 03		bcs $b316			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b313	49 ff		eor #$ff			eor 	#$FF
.b315	1a		inc a				inc 	a
.b316					_GXCAbs1:
.b316	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b318	b0 1c		bcs $b336			bcs 	_GXOkayFail
.b31a	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b31c	38		sec				sec 								; calculate |x1-x0|
.b31d	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y
.b320	fd 63 06	sbc $0663,x			sbc 	GXSpriteLow,x
.b323	b0 03		bcs $b328			bcs 	_GXCAbs2
.b325	49 ff		eor #$ff			eor 	#$FF
.b327	1a		inc a				inc 	a
.b328					_GXCAbs2:
.b328	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b32a	b0 0a		bcs $b336			bcs 	_GXOkayFail
.b32c	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b32e	90 02		bcc $b332			bcc 	_GXCHaveLowest
.b330	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b332					_GXCHaveLowest:
.b332	0a		asl a				asl 	a 							; scale to allow for >> 2
.b333	0a		asl a				asl 	a
.b334	18		clc				clc
.b335	60		rts				rts
.b336					_GXOkayFail:
.b336	18		clc				clc
.b337					_GXCollideFail:
.b337	a9 ff		lda #$ff			lda 	#$FF
.b339	60		rts				rts
.b33a					GXFindSprite:
.b33a	aa		tax				tax
.b33b	ad 56 06	lda $0656			lda 	GXSpritePage 				; access the base page of the sprite
.b33e	85 0b		sta $0b				sta 	GXEditSlot
.b340	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b343	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b346	f0 33		beq $b37b			beq 	_GXFSFail
.b348	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b34b	8d fa 06	sta $06fa			sta 	GXSpriteOffset+1
.b34e	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b351	48		pha				pha 								; save twice
.b352	48		pha				pha
.b353	29 03		and #$03			and 	#3 							; get sprite size
.b355	8d f7 06	sta $06f7			sta 	GXSizeBits 					; save raw (0-3)
.b358	aa		tax				tax
.b359	bd 7d b3	lda $b37d,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b35c	8d f6 06	sta $06f6			sta 	GXSizePixels 					; save (8/16/24/32)
.b35f	68		pla				pla 								; get LUT
.b360	4a		lsr a				lsr		a
.b361	4a		lsr a				lsr		a
.b362	29 03		and #$03			and 	#3
.b364	8d f8 06	sta $06f8			sta 	GXSpriteLUT
.b367	68		pla				pla 								; address, neeeds to be x 4
.b368	29 f0		and #$f0			and 	#$F0
.b36a	8d f9 06	sta $06f9			sta 	GXSpriteOffset
.b36d	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b370	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b373	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b376	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b379	18		clc				clc
.b37a	60		rts				rts
.b37b					_GXFSFail:
.b37b	38		sec				sec
.b37c	60		rts				rts
.b37d					_GXFXSSTTable:
>b37d	08 10 18 20					.byte 	8,16,24,32
.06f6					GXSizePixels:
>06f6							.fill 	1
.06f7					GXSizeBits:
>06f7							.fill 	1
.06f8					GXSpriteLUT:
>06f8							.fill 	1
.06f9					GXSpriteOffset:
>06f9							.fill 	2
.b381					GXSortXY:
.b381	20 9f b3	jsr $b39f			jsr 	GXSortY 					; will be sorted on Y now
.b384	ad 4b 06	lda $064b			lda 	gxX0 						; compare X0 v X1
.b387	cd 4f 06	cmp $064f			cmp 	gxX1
.b38a	ad 4c 06	lda $064c			lda 	gXX0+1
.b38d	ed 50 06	sbc $0650			sbc 	gXX1+1
.b390	90 0c		bcc $b39e			bcc 	_GXSXYExit 					; X0 < X1 exit
.b392	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b394	a0 04		ldy #$04			ldy 	#4
.b396	20 b3 b3	jsr $b3b3			jsr 	GXSwapXY
.b399	e8		inx				inx
.b39a	c8		iny				iny
.b39b	20 b3 b3	jsr $b3b3			jsr 	GXSwapXY
.b39e					_GXSXYExit:
.b39e	60		rts				rts
.b39f					GXSortY:
.b39f	ad 4d 06	lda $064d			lda 	gxY0 						; if Y0 >= Y1
.b3a2	cd 51 06	cmp $0651			cmp 	gxY1
.b3a5	90 0b		bcc $b3b2			bcc 	_GXSYSorted
.b3a7	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b3a9	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b3ab					_GXSwap1:
.b3ab	20 b3 b3	jsr $b3b3			jsr 	GXSwapXY
.b3ae	88		dey				dey
.b3af	ca		dex				dex
.b3b0	10 f9		bpl $b3ab			bpl 	_GXSwap1
.b3b2					_GXSYSorted:
.b3b2	60		rts				rts
.b3b3					GXSwapXY:
.b3b3	bd 4b 06	lda $064b,x			lda 	gxX0,x
.b3b6	48		pha				pha
.b3b7	b9 4b 06	lda $064b,y			lda 	gxX0,y
.b3ba	9d 4b 06	sta $064b,x			sta 	gxX0,x
.b3bd	68		pla				pla
.b3be	99 4b 06	sta $064b,y			sta 	gxX0,y
.b3c1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.ba32					KeywordSet0:
>ba32	00 65					.text	0,$65,""               ; $80 !0:EOF
>ba34	00 58					.text	0,$58,""               ; $81 !1:SH1
>ba36	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ba38	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>ba3e	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>ba46	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>ba4c	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>ba53	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>ba5b	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>ba62	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>ba69	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>ba6f	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>ba75	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>ba7d	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>ba84	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>ba8b	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>ba92	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>ba9a	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>baa0	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>baa6	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>baad	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bab3	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bab9	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bac1	47 28
>bac3	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>bacb	28
>bacc	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>bad4	28
>bad5	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>badb	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bae1	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>bae7	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>baee	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>baf6	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bafc	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bb02	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bb07	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bb0b	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bb11	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bb19	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bb20	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bb27	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bb2f	43
>bb30	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bb36	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bb3c	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bb43	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bb49	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bb4d	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bb53	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bb5b	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bb62	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bb67	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bb6e	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bb76	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bb7c	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bb81	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bb89	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bb8f	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bb95	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bb9a	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bba1	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bba7	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bbad	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bbb4	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bc LET
>bbb9	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $bd LINE
>bbbf	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $be LOCAL
>bbc6	03 db 4f 46 46				.text	3,$db,"OFF"            ; $bf OFF
>bbcb	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c0 ON
>bbcf	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c1 OUTLINE
>bbd7	45
>bbd8	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c2 PALETTE
>bbe0	45
>bbe1	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c3 PLOT
>bbe7	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c4 PRINT
>bbee	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c5 READ
>bbf4	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c6 RECT
>bbfa	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c7 REM
>bbff	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c8 RETURN
>bc07	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $c9 SOLID
>bc0e	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $ca SOUND
>bc15	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cb SPRITE
>bc1d	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cc TEXT
>bc23	02 a3 54 4f				.text	2,$a3,"TO"             ; $cd TO
>bc27	ff					.text	$FF
.bc28					KeywordSet1:
>bc28	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc2a	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc2c	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc2e	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bc36	4c 45
>bc38	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bc40	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bc48	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bc4d	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $87 LIST
>bc53	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $88 NEW
>bc58	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $89 RESTORE
>bc60	45
>bc61	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8a RUN
>bc66	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8b SPRITES
>bc6e	53
>bc6f	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8c STOP
>bc75	ff					.text	$FF
.bc76					KeywordSet2:
>bc76	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc78	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc7a	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc7c	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bc81	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bc86	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bc8b	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bc90	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bc95	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bc9a	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bc9f	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bca4	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bca9	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bcae	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bcb3	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bcb8	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bcbd	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bcc2	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bcc7	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bccc	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bcd1	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bcd6	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bcdb	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bce0	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bce5	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bcea	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bcef	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bcf4	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bcf9	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bcfe	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bd03	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bd08	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bd0d	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bd12	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bd17	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bd1c	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bd21	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bd26	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bd2b	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bd30	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bd35	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bd3a	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bd3f	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bd44	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bd49	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bd4e	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bd53	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bd58	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bd5d	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bd62	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bd67	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bd6c	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bd71	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bd76	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bd7b	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bd80	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bd85	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bd8a	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bd8f	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bd94	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bd99	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bd9e	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bda3	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bda8	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bdad	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bdb2	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bdb7	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bdbc	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bdc1	ff					.text	$FF
.b3c2					ListConvertLine:
.b3c2	48		pha				pha 								; save indent on the stack
.b3c3	9c 9d 04	stz $049d			stz 	tbOffset
.b3c6	9c ab 04	stz $04ab			stz 	tokenBuffer
.b3c9	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b3cb	b1 30		lda ($30),y			lda 	(codePtr),y
.b3cd	aa		tax				tax
.b3ce	88		dey				dey
.b3cf	b1 30		lda ($30),y			lda 	(codePtr),y
.b3d1	20 77 92	jsr $9277			jsr 	LCLConvertInt16
.b3d4	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b3d6	86 37		stx $37				stx 	zTemp0+1
.b3d8	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b3da	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b3dd	a0 00		ldy #$00			ldy 	#0
.b3df					_LCCopyNumber:
.b3df	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3e1	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b3e4	c8		iny				iny
.b3e5	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3e7	d0 f6		bne $b3df			bne 	_LCCopyNumber
.b3e9	68		pla				pla 								; adjustment to indent
.b3ea	48		pha				pha 								; save on stack
.b3eb	10 0c		bpl $b3f9			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b3ed	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b3ee	6d a6 04	adc $04a6			adc 	listIndent
.b3f1	8d a6 04	sta $04a6			sta 	listIndent
.b3f4	10 03		bpl $b3f9			bpl 	_LCNoAdjust
.b3f6	9c a6 04	stz $04a6			stz 	listIndent
.b3f9					_LCNoAdjust:
.b3f9	18		clc				clc		 							; work out actual indent.
.b3fa	ad a6 04	lda $04a6			lda 	listIndent
.b3fd	0a		asl a				asl 	a
.b3fe	69 06		adc #$06			adc 	#6
.b400	85 36		sta $36				sta 	zTemp0
.b402					_LCPadOut:
.b402	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b404	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b407	ad 9d 04	lda $049d			lda 	tbOffset
.b40a	c5 36		cmp $36				cmp 	zTemp0
.b40c	d0 f4		bne $b402			bne 	_LCPadOut
.b40e	a0 03		ldy #$03			ldy 	#3 							; start position.
.b410					_LCMainLoop:
.b410	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b412	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b415	b1 30		lda ($30),y			lda 	(codePtr),y
.b417	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b419	f0 17		beq $b432			beq 	_LCExit
.b41b	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b41d	90 1e		bcc $b43d			bcc 	_LCDoubles
.b41f	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b421	90 2a		bcc $b44d			bcc 	_LCShiftPunc
.b423	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b425	90 35		bcc $b45c			bcc 	_LCPunctuation
.b427	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b429	90 3e		bcc $b469			bcc 	_LCIdentifiers
.b42b	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b42d	90 5f		bcc $b48e			bcc 	_LCTokens
.b42f	4c ee b4	jmp $b4ee			jmp 	_LCData 					; 254-5 are data objects
.b432					_LCExit:
.b432	68		pla				pla 								; get old indent adjust
.b433	30 07		bmi $b43c			bmi 	_LCExit2
.b435	18		clc				clc 								; add to indent if +ve
.b436	6d a6 04	adc $04a6			adc 	listIndent
.b439	8d a6 04	sta $04a6			sta 	listIndent
.b43c					_LCExit2:
.b43c	60		rts				rts
.b43d					_LCDoubles:
.b43d	48		pha				pha
.b43e	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b43f	29 02		and #$02			and 	#2
.b441	09 3c		ora #$3c			ora 	#60 						; make < >
.b443	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b446	68		pla				pla 								; restore, do lower bit
.b447	29 03		and #$03			and 	#3
.b449	09 3c		ora #$3c			ora 	#60
.b44b	80 0f		bra $b45c			bra		_LCPunctuation 				; print, increment, loop
.b44d					_LCShiftPunc:
.b44d	aa		tax				tax 								; save in X
.b44e	29 07		and #$07			and 	#7 							; lower 3 bits
.b450	f0 02		beq $b454			beq 	_LCNoAdd
.b452	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b454					_LCNoAdd:
.b454	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b456	90 02		bcc $b45a			bcc 	_LCNoAdd2
.b458	09 20		ora #$20			ora 	#32 						; adds $20
.b45a					_LCNoAdd2:
.b45a	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b45c					_LCPunctuation:
.b45c	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b45e	d0 03		bne $b463			bne 	_LCPContinue
.b460	20 35 b5	jsr $b535			jsr 	LCLDeleteLastSpace
.b463					_LCPContinue:
.b463	c8		iny				iny 								; consume character
.b464	20 1f b5	jsr $b51f			jsr 	LCLWrite 					; write it out.
.b467	80 a7		bra $b410			bra 	_LCMainLoop 				; go round again.
.b469					_LCIdentifiers:
.b469	18		clc				clc 								; convert to physical address
.b46a	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b46c	85 37		sta $37				sta 	zTemp0+1
.b46e	c8		iny				iny
.b46f	b1 30		lda ($30),y			lda 	(codePtr),y
.b471	85 36		sta $36				sta 	zTemp0
.b473	c8		iny				iny
.b474	5a		phy				phy 								; save position
.b475	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b477	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b47a	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b47c					_LCOutIdentifier:
.b47c	c8		iny				iny
.b47d	b1 36		lda ($36),y			lda 	(zTemp0),y
.b47f	29 7f		and #$7f			and 	#$7F
.b481	20 71 b5	jsr $b571			jsr 	LCLLowerCase
.b484	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b487	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b489	10 f1		bpl $b47c			bpl 	_LCOutIdentifier
.b48b	7a		ply				ply 								; restore position
.b48c	80 82		bra $b410			bra 	_LCMainLoop
.b48e					_LCTokens:
.b48e	aa		tax				tax 								; token in X
.b48f	a9 76		lda #$76			lda 	#((KeywordSet2) & $FF)
.b491	85 36		sta $36				sta 	0+zTemp0
.b493	a9 bc		lda #$bc			lda 	#((KeywordSet2) >> 8)
.b495	85 37		sta $37				sta 	1+zTemp0
.b497	e0 82		cpx #$82			cpx 	#$82
.b499	f0 16		beq $b4b1			beq 	_LCUseShift
.b49b	a9 28		lda #$28			lda 	#((KeywordSet1) & $FF)
.b49d	85 36		sta $36				sta 	0+zTemp0
.b49f	a9 bc		lda #$bc			lda 	#((KeywordSet1) >> 8)
.b4a1	85 37		sta $37				sta 	1+zTemp0
.b4a3	e0 81		cpx #$81			cpx 	#$81
.b4a5	f0 0a		beq $b4b1			beq 	_LCUseShift
.b4a7	a9 32		lda #$32			lda 	#((KeywordSet0) & $FF)
.b4a9	85 36		sta $36				sta 	0+zTemp0
.b4ab	a9 ba		lda #$ba			lda 	#((KeywordSet0) >> 8)
.b4ad	85 37		sta $37				sta 	1+zTemp0
.b4af	80 01		bra $b4b2			bra 	_LCNoShift
.b4b1					_LCUseShift:
.b4b1	c8		iny				iny
.b4b2					_LCNoShift:
.b4b2	20 49 b5	jsr $b549			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b4b5	b1 30		lda ($30),y			lda 	(codePtr),y
.b4b7	aa		tax				tax 								; into X
.b4b8					_LCFindText:
.b4b8	ca		dex				dex
.b4b9	10 0e		bpl $b4c9			bpl 	_LCFoundText 				; found text.
.b4bb	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b4bd	1a		inc a				inc 	a 							; one extra for size
.b4be	38		sec				sec 								; one extra for checksum
.b4bf	65 36		adc $36				adc 	zTemp0 						; go to next token
.b4c1	85 36		sta $36				sta 	zTemp0
.b4c3	90 f3		bcc $b4b8			bcc 	_LCFindText
.b4c5	e6 37		inc $37				inc 	zTemp0+1
.b4c7	80 ef		bra $b4b8			bra 	_LCFindText
.b4c9					_LCFoundText:
.b4c9	5a		phy				phy 								; save List position
.b4ca	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b4cc	aa		tax				tax
.b4cd	a9 83		lda #$83			lda 	#CLIToken+$80
.b4cf	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b4d2	a0 02		ldy #$02			ldy 	#2
.b4d4					_LCCopyToken:
.b4d4	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4d6	20 71 b5	jsr $b571			jsr 	LCLLowerCase
.b4d9	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b4dc	c8		iny				iny
.b4dd	ca		dex				dex
.b4de	d0 f4		bne $b4d4			bne 	_LCCopyToken
.b4e0	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b4e2	f0 05		beq $b4e9			beq 	_LCNoSpace
.b4e4	a9 20		lda #$20			lda 	#' '
.b4e6	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b4e9					_LCNoSpace:
.b4e9	7a		ply				ply 								; restore position.
.b4ea	c8		iny				iny 								; consume token
.b4eb	4c 10 b4	jmp $b410			jmp 	_LCMainLoop 				; and go around again.
.b4ee					_LCData:
.b4ee	48		pha				pha 								; save type $FE/$FF
.b4ef	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b4f1	c9 fe		cmp #$fe			cmp 	#$FE
.b4f3	f0 07		beq $b4fc			beq 	_LCHaveOpener
.b4f5	a2 22		ldx #$22			ldx 	#'"'
.b4f7	a9 81		lda #$81			lda 	#CLIData+$80
.b4f9	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b4fc					_LCHaveOpener:
.b4fc	8a		txa				txa 								; output prefix (# or ")
.b4fd	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b500	c8		iny				iny 								; get count
.b501	b1 30		lda ($30),y			lda 	(codePtr),y
.b503	aa		tax				tax
.b504	c8		iny				iny 								; point at first character
.b505					_LCOutData:
.b505	b1 30		lda ($30),y			lda 	(codePtr),y
.b507	c9 00		cmp #$00			cmp 	#0
.b509	f0 03		beq $b50e			beq 	_LCNoPrint
.b50b	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b50e					_LCNoPrint:
.b50e	c8		iny				iny
.b50f	ca		dex				dex
.b510	d0 f3		bne $b505			bne 	_LCOutData
.b512	68		pla				pla 								; closing " required ?
.b513	c9 ff		cmp #$ff			cmp 	#$FF
.b515	d0 05		bne $b51c			bne 	_LCNoQuote
.b517	a9 22		lda #$22			lda 	#'"'
.b519	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b51c					_LCNoQuote:
.b51c	4c 10 b4	jmp $b410			jmp 	_LCMainLoop
.b51f					LCLWrite:
.b51f	da		phx				phx
.b520	ae 9d 04	ldx $049d			ldx 	tbOffset
.b523	9d ab 04	sta $04ab,x			sta 	tokenBuffer,x
.b526	9e ac 04	stz $04ac,x			stz 	tokenBuffer+1,x
.b529	ee 9d 04	inc $049d			inc 	tbOffset
.b52c	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b52e	30 03		bmi $b533			bmi 	_LCLNoColour
.b530	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b533					_LCLNoColour:
.b533	fa		plx				plx
.b534	60		rts				rts
.b535					LCLDeleteLastSpace:
.b535	48		pha				pha
.b536	da		phx				phx
.b537	ae 9d 04	ldx $049d			ldx 	tbOffset
.b53a	f0 0a		beq $b546			beq 	_LCDLSExit
.b53c	bd aa 04	lda $04aa,x			lda 	tokenBuffer-1,x
.b53f	c9 20		cmp #$20			cmp 	#' '
.b541	d0 03		bne $b546			bne 	_LCDLSExit
.b543	ce 9d 04	dec $049d			dec 	tbOffset
.b546					_LCDLSExit:
.b546	fa		plx				plx
.b547	68		pla				pla
.b548	60		rts				rts
.b549					LCLCheckSpaceRequired:
.b549	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b54c	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b54e	f0 1b		beq $b56b			beq 	_LCCSRSpace
.b550	c9 29		cmp #$29			cmp 	#')'
.b552	f0 17		beq $b56b			beq 	_LCCSRSpace
.b554	c9 23		cmp #$23			cmp 	#'#'
.b556	f0 13		beq $b56b			beq 	_LCCSRSpace
.b558	20 71 b5	jsr $b571			jsr 	LCLLowerCase 				; saves a little effort
.b55b	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b55d	90 11		bcc $b570			bcc 	_LCCSRExit
.b55f	c9 3a		cmp #$3a			cmp 	#"9"+1
.b561	90 08		bcc $b56b			bcc 	_LCCSRSpace
.b563	c9 61		cmp #$61			cmp 	#"a"
.b565	90 09		bcc $b570			bcc 	_LCCSRExit
.b567	c9 7b		cmp #$7b			cmp 	#"z"+1
.b569	b0 05		bcs $b570			bcs 	_LCCSRExit
.b56b					_LCCSRSpace:
.b56b	a9 20		lda #$20			lda 	#' '
.b56d	20 1f b5	jsr $b51f			jsr 	LCLWrite
.b570					_LCCSRExit:
.b570	60		rts				rts
.b571					LCLLowerCase:
.b571	c9 41		cmp #$41			cmp 	#"A"
.b573	90 06		bcc $b57b			bcc 	_LCLLCOut
.b575	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b577	b0 02		bcs $b57b			bcs 	_LCLLCOut
.b579	69 20		adc #$20			adc 	#$20
.b57b					_LCLLCOut:
.b57b	60		rts				rts
.b57c					LCLUpperCase:
.b57c	c9 61		cmp #$61			cmp 	#"a"
.b57e	90 06		bcc $b586			bcc 	_LCLUCOut
.b580	c9 7b		cmp #$7b			cmp 	#"z"+1
.b582	b0 02		bcs $b586			bcs 	_LCLUCOut
.b584	e9 1f		sbc #$1f			sbc 	#$1F
.b586					_LCLUCOut:
.b586	60		rts				rts
.b587					TOKSearchTable:
.b587	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token.
.b589	85 36		sta $36				sta 	zTemp0
.b58b	a0 00		ldy #$00			ldy 	#0
.b58d	a9 80		lda #$80			lda 	#$80 						; token #
.b58f	85 38		sta $38				sta 	zTemp1
.b591					_TSTLoop:
.b591	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b593	30 49		bmi $b5de			bmi 	_TSTFail 					; -ve = end of table
.b595	f0 2e		beq $b5c5			beq 	_TSTNext 					; zero, check next it's a dummy
.b597	c8		iny				iny 								; get the hash
.b598	b1 36		lda ($36),y			lda 	(zTemp0),y
.b59a	88		dey				dey
.b59b	cd 83 04	cmp $0483			cmp 	identHash 					; check they match, if not go to next
.b59e	d0 25		bne $b5c5			bne 	_TSTNext
.b5a0	ad 82 04	lda $0482			lda 	identTypeEnd 				; length of identifier
.b5a3	38		sec				sec
.b5a4	ed 80 04	sbc $0480			sbc 	identStart
.b5a7	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; no match, then return.
.b5a9	d0 1a		bne $b5c5			bne 	_TSTNext
.b5ab	5a		phy				phy 								; save Y , we might fail
.b5ac	c8		iny				iny 								; point to text
.b5ad	c8		iny				iny
.b5ae	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b5b1					_TSTCompareName:
.b5b1	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; compare text.
.b5b4	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b5b6	d0 0c		bne $b5c4			bne 	_TSTNextPullY 				; fail, pullY and do next
.b5b8	e8		inx				inx
.b5b9	c8		iny				iny
.b5ba	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b5bd	d0 f2		bne $b5b1			bne 	_TSTCompareName
.b5bf	7a		ply				ply 								; throw Y
.b5c0	a5 38		lda $38				lda 	zTemp1 						; get token #
.b5c2	38		sec				sec 								; return with CS = passed.
.b5c3	60		rts				rts
.b5c4					_TSTNextPullY:
.b5c4	7a		ply				ply 								; restore current, fall through.
.b5c5					_TSTNext:
.b5c5	e6 38		inc $38				inc 	zTemp1 						; token counter
.b5c7	98		tya				tya
.b5c8	18		clc				clc
.b5c9	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b5cb	1a		inc a				inc 	a 							; +1
.b5cc	1a		inc a				inc 	a 							; +2
.b5cd	a8		tay				tay
.b5ce	10 c1		bpl $b591			bpl 	_TSTLoop 					; if Y < $80 loop back
.b5d0	98		tya				tya 								; add Y to zTemp0 and reset Y
.b5d1	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b5d3	18		clc				clc  								; but have tables > 255 bytes
.b5d4	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b5d6	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b5d8	90 b7		bcc $b591			bcc 	_TSTLoop
.b5da	e6 37		inc $37				inc 	zTemp0+1
.b5dc	80 b3		bra $b591			bra 	_TSTLoop
.b5de					_TSTFail:
.b5de	18		clc				clc
.b5df	60		rts				rts
.b5e0					TokeniseLine:
.b5e0	20 68 b7	jsr $b768			jsr 	LCLFixLineBufferCase 		; fix line case
.b5e3	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b5e5	8d a8 04	sta $04a8			sta 	tokenOffset
.b5e8	9c a9 04	stz $04a9			stz 	tokenLineNumber
.b5eb	9c aa 04	stz $04aa			stz 	tokenLineNumber+1
.b5ee	a2 ff		ldx #$ff			ldx 	#$FF
.b5f0					_TKFindFirst:
.b5f0	e8		inx				inx
.b5f1	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b5f4	f0 79		beq $b66f			beq 	_TKExit
.b5f6	c9 20		cmp #$20			cmp 	#' '
.b5f8	90 f6		bcc $b5f0			bcc 	_TKFindFirst
.b5fa	c9 30		cmp #$30			cmp 	#'0'
.b5fc	90 07		bcc $b605			bcc 	_TKNoLineNumber
.b5fe	c9 3a		cmp #$3a			cmp 	#'9'+1
.b600	b0 03		bcs $b605			bcs 	_TKNoLineNumber
.b602	20 92 b7	jsr $b792			jsr 	TOKExtractLineNumber
.b605					_TKNoLineNumber:
.b605					_TKTokeniseLoop:
.b605	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b608	f0 65		beq $b66f			beq 	_TKExit
.b60a	e8		inx				inx
.b60b	c9 20		cmp #$20			cmp 	#' '
.b60d	f0 f6		beq $b605			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b60f	ca		dex				dex 								; undo last get, A contains character, X is position.
.b610	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b612	f0 61		beq $b675			beq 	_TKTokeniseIdentifier
.b614	c9 41		cmp #$41			cmp 	#'A'
.b616	90 04		bcc $b61c			bcc 	_TKTokenisePunctuation
.b618	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b61a	90 59		bcc $b675			bcc 	_TKTokeniseIdentifier
.b61c					_TKTokenisePunctuation:
.b61c	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b61e	f0 27		beq $b647			beq 	_TKString
.b620	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant (# only appears at end of identifiers)
.b622	f0 28		beq $b64c			beq 	_TKHexConstant
.b624	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers.
.b626	f0 29		beq $b651			beq 	_TKCheckDouble
.b628	c9 3e		cmp #$3e			cmp 	#'>'
.b62a	f0 25		beq $b651			beq 	_TKCheckDouble
.b62c					_TKStandardPunctuation:
.b62c	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get it back.
.b62f	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b631	90 0e		bcc $b641			bcc 	_TKNoShift
.b633	48		pha				pha 								; save
.b634	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b636	85 36		sta $36				sta 	zTemp0
.b638	68		pla				pla
.b639	29 20		and #$20			and 	#32 						; bit 5
.b63b	4a		lsr a				lsr 	a 							; shift into bit 3
.b63c	4a		lsr a				lsr 	a
.b63d	05 36		ora $36				ora 	zTemp0
.b63f	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b641					_TKNoShift:
.b641	20 d7 b7	jsr $b7d7			jsr 	TOKWriteByte 				; write the punctuation character
.b644	e8		inx				inx 								; consume the character
.b645	80 be		bra $b605			bra 	_TKTokeniseLoop 			; and loop round again.
.b647					_TKString:
.b647	20 f7 b6	jsr $b6f7			jsr 	TOKTokenString
.b64a	80 b9		bra $b605			bra 	_TKTokeniseLoop
.b64c					_TKHexConstant:
.b64c	20 32 b7	jsr $b732			jsr 	TOKHexConstant
.b64f	80 b4		bra $b605			bra 	_TKTokeniseLoop
.b651					_TKCheckDouble:
.b651	bd a9 05	lda $05a9,x			lda 	lineBuffer+1,x 				; get next character
.b654	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b656	90 d4		bcc $b62c			bcc 	_TKStandardPunctuation
.b658	c9 3f		cmp #$3f			cmp 	#'>'+1
.b65a	b0 d0		bcs $b62c			bcs 	_TKStandardPunctuation
.b65c	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b65f	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b661	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b662	7d a9 05	adc $05a9,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b665	38		sec				sec
.b666	e9 3c		sbc #$3c			sbc 	#'<'
.b668	20 d7 b7	jsr $b7d7			jsr 	TOKWriteByte 				; this is in the range 0-7
.b66b	e8		inx				inx 								; consume both
.b66c	e8		inx				inx
.b66d	80 96		bra $b605			bra 	_TKTokeniseLoop
.b66f	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b671	20 d7 b7	jsr $b7d7			jsr 	TOKWriteByte
.b674	60		rts				rts
.b675					_TKTokeniseIdentifier:
.b675	8e 80 04	stx $0480			stx 	identStart 					; save start
.b678	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b67b					_TKCheckLoop:
.b67b	e8		inx				inx 								; look at next, we know first is identifier.
.b67c	bd a8 05	lda $05a8,x			lda  	lineBuffer,x
.b67f	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b681	f0 f8		beq $b67b			beq 	_TKCheckLoop
.b683	c9 30		cmp #$30			cmp	 	#"0"
.b685	90 0c		bcc $b693			bcc 	_TKEndIdentifier
.b687	c9 3a		cmp #$3a			cmp 	#"9"+1
.b689	90 f0		bcc $b67b			bcc 	_TKCheckLoop
.b68b	c9 41		cmp #$41			cmp	 	#"A"
.b68d	90 04		bcc $b693			bcc 	_TKEndIdentifier
.b68f	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b691	90 e8		bcc $b67b			bcc 	_TKCheckLoop
.b693					_TKEndIdentifier:
.b693	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b696	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b698	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b69a	f0 06		beq $b6a2			beq 	_TKHasTypeCharacter
.b69c	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b69e	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b6a0	d0 07		bne $b6a9			bne 	_TKNoTypeCharacter
.b6a2					_TKHasTypeCharacter:
.b6a2	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b6a5	e8		inx				inx 								; read next
.b6a6	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b6a9					_TKNoTypeCharacter:
.b6a9	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b6ab	d0 09		bne $b6b6			bne 	_TKNoArray
.b6ad	e8		inx				inx 								; skip the (
.b6ae	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array)
.b6b1	09 04		ora #$04			ora 	#$04
.b6b3	8d 84 04	sta $0484			sta 	identTypeByte
.b6b6					_TKNoArray:
.b6b6	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b6b9	20 53 b7	jsr $b753			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b6bc	a0 ba		ldy #$ba			ldy 	#(KeywordSet0) >> 8
.b6be	a9 32		lda #$32			lda 	#(KeywordSet0) & $FF
.b6c0	20 87 b5	jsr $b587			jsr 	TOKSearchTable
.b6c3	a2 00		ldx #$00			ldx 	#0
.b6c5	b0 1f		bcs $b6e6			bcs 	_TKFoundToken
.b6c7	a0 bc		ldy #$bc			ldy 	#(KeywordSet1) >> 8
.b6c9	a9 28		lda #$28			lda 	#(KeywordSet1) & $FF
.b6cb	20 87 b5	jsr $b587			jsr 	TOKSearchTable
.b6ce	a2 81		ldx #$81			ldx 	#$81
.b6d0	b0 14		bcs $b6e6			bcs 	_TKFoundToken
.b6d2	a0 bc		ldy #$bc			ldy 	#(KeywordSet2) >> 8
.b6d4	a9 76		lda #$76			lda 	#(KeywordSet2) & $FF
.b6d6	20 87 b5	jsr $b587			jsr 	TOKSearchTable
.b6d9	a2 82		ldx #$82			ldx 	#$82
.b6db	b0 09		bcs $b6e6			bcs 	_TKFoundToken
.b6dd	20 e3 b7	jsr $b7e3			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b6e0	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6e3	4c 05 b6	jmp $b605			jmp 	_TKTokeniseLoop 			; and go round again.
.b6e6					_TKFoundToken:
.b6e6	48		pha				pha 								; save token
.b6e7	8a		txa				txa 								; shift in X, is there one ?
.b6e8	f0 03		beq $b6ed			beq 	_TKNoTShift
.b6ea	20 d7 b7	jsr $b7d7			jsr 	TOKWriteByte 				; if so, write it out
.b6ed					_TKNoTShift:
.b6ed	68		pla				pla 								; restore and write token
.b6ee	20 d7 b7	jsr $b7d7			jsr 	TOKWriteByte
.b6f1	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6f4	4c 05 b6	jmp $b605			jmp 	_TKTokeniseLoop 			; and go round again.
.b6f7					TOKTokenString:
.b6f7	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b6f9	20 d7 b7	jsr $b7d7			jsr 	TOKWriteByte
.b6fc	e8		inx				inx									; start of quoted string.
.b6fd	da		phx				phx 								; push start of string on top
.b6fe	ca		dex				dex
.b6ff					_TSFindEnd:
.b6ff	e8		inx				inx
.b700	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character
.b703	f0 04		beq $b709			beq 	_TSEndOfString
.b705	c9 22		cmp #$22			cmp 	#'"'
.b707	d0 f6		bne $b6ff			bne 	_TSFindEnd
.b709					_TSEndOfString:
.b709	7a		ply				ply  								; so now Y is first character, X is character after end.
.b70a	48		pha				pha 								; save terminating character
.b70b	20 13 b7	jsr $b713			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b70e	68		pla				pla 								; terminating character
.b70f	f0 01		beq $b712			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b711	e8		inx				inx
.b712					_TSNotQuote:
.b712	60		rts				rts
.b713					TOKWriteBlockXY:
.b713	86 36		stx $36				stx 	zTemp0 						; write end character
.b715	98		tya				tya
.b716	49 ff		eor #$ff			eor 	#$FF
.b718	38		sec				sec
.b719	65 36		adc $36				adc 	zTemp0
.b71b	1a		inc a				inc 	a 							; one extra for NULL
.b71c	20 d7 b7	jsr $b7d7			jsr 	TOKWriteByte
.b71f					_TOBlockLoop:
.b71f	c4 36		cpy $36				cpy 	zTemp0
.b721	f0 09		beq $b72c			beq 	_TOBlockExit
.b723	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.b726	20 d7 b7	jsr $b7d7			jsr 	TOKWriteByte
.b729	c8		iny				iny
.b72a	80 f3		bra $b71f			bra 	_TOBlockLoop
.b72c					_TOBlockExit:
.b72c	a9 00		lda #$00			lda 	#0
.b72e	20 d7 b7	jsr $b7d7			jsr 	TOKWriteByte
.b731	60		rts				rts
.b732					TOKHexConstant:
.b732	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b734	20 d7 b7	jsr $b7d7			jsr 	TOKWriteByte
.b737	e8		inx				inx									; start of quoted string.
.b738	da		phx				phx 								; push start of constant on top
.b739	ca		dex				dex
.b73a					_THFindLoop:
.b73a	e8		inx				inx
.b73b	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b73e	c9 30		cmp #$30			cmp 	#"0"
.b740	90 0c		bcc $b74e			bcc 	_THFoundEnd
.b742	c9 3a		cmp #$3a			cmp 	#"9"+1
.b744	90 f4		bcc $b73a			bcc 	_THFindLoop
.b746	c9 41		cmp #$41			cmp 	#"A"
.b748	90 04		bcc $b74e			bcc 	_THFoundEnd
.b74a	c9 47		cmp #$47			cmp 	#"F"+1
.b74c	90 ec		bcc $b73a			bcc 	_THFindLoop
.b74e					_THFoundEnd:
.b74e	7a		ply				ply 								; restore start
.b74f	20 13 b7	jsr $b713			jsr 	TOKWriteBlockXY 			; output the block
.b752	60		rts				rts
.b753					TOKCalculateHash:
.b753	da		phx				phx
.b754	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum
.b757	a9 00		lda #$00			lda 	#0
.b759					_TCHLoop:
.b759	18		clc				clc
.b75a	7d a8 05	adc $05a8,x			adc 	lineBuffer,x
.b75d	e8		inx				inx
.b75e	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b761	d0 f6		bne $b759			bne 	_TCHLoop
.b763	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b766	fa		plx				plx
.b767	60		rts				rts
.b768					LCLFixLineBufferCase:
.b768	a2 00		ldx #$00			ldx 	#0
.b76a					_FLBCLoop:
.b76a	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next character
.b76d	f0 22		beq $b791			beq 	_FLBCExit 					; end of string.
.b76f	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b771	f0 11		beq $b784			beq 	_FLBCInQuotes
.b773	e8		inx				inx
.b774	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b776	90 f2		bcc $b76a			bcc 	_FLBCLoop
.b778	c9 7b		cmp #$7b			cmp 	#'z'+1
.b77a	b0 ee		bcs $b76a			bcs 	_FLBCLoop
.b77c	38		sec				sec 								; make U/C
.b77d	e9 20		sbc #$20			sbc 	#32
.b77f	9d a7 05	sta $05a7,x			sta	 	lineBuffer-1,x 				; write back
.b782	80 e6		bra $b76a			bra 	_FLBCLoop
.b784					_FLBCInQuotes:
.b784	e8		inx				inx 								; advance
.b785	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next
.b788	f0 07		beq $b791			beq 	_FLBCExit 					; exit on EOS
.b78a	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b78c	d0 f6		bne $b784			bne 	_FLBCInQuotes
.b78e	e8		inx				inx 								; skip over it
.b78f	80 d9		bra $b76a			bra 	_FLBCLoop
.b791					_FLBCExit:
.b791	60		rts				rts
.b792					TOKExtractLineNumber:
.b792	ad aa 04	lda $04aa			lda 	tokenLineNumber+1 			; push current value on stack
.b795	48		pha				pha
.b796	ad a9 04	lda $04a9			lda 	tokenLineNumber
.b799	48		pha				pha
.b79a	20 d0 b7	jsr $b7d0			jsr 	_LCLNTimes2 				; line # x 4
.b79d	20 d0 b7	jsr $b7d0			jsr 	_LCLNTimes2 				; line # x 2
.b7a0	18		clc				clc 								; add stacked value
.b7a1	68		pla				pla
.b7a2	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b7a5	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b7a8	68		pla				pla
.b7a9	6d aa 04	adc $04aa			adc 	tokenLineNumber+1
.b7ac	8d aa 04	sta $04aa			sta 	tokenLineNumber+1 			; line # x 5
.b7af	20 d0 b7	jsr $b7d0			jsr 	_LCLNTimes2 				; line # x 10
.b7b2	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get and consume character
.b7b5	e8		inx				inx
.b7b6	29 0f		and #$0f			and 	#15 						; add to line #
.b7b8	18		clc				clc
.b7b9	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b7bc	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b7bf	90 03		bcc $b7c4			bcc 	_TLENNoCarry
.b7c1	ee aa 04	inc $04aa			inc 	tokenLineNumber+1
.b7c4					_TLENNoCarry:
.b7c4	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; more digits ?
.b7c7	c9 30		cmp #$30			cmp 	#'0'
.b7c9	90 04		bcc $b7cf			bcc 	_TLENExit
.b7cb	c9 3a		cmp #$3a			cmp 	#'9'+1
.b7cd	90 c3		bcc $b792			bcc 	TOKExtractLineNumber
.b7cf					_TLENExit:
.b7cf	60		rts				rts
.b7d0					_LCLNTimes2:
.b7d0	0e a9 04	asl $04a9			asl 	tokenLineNumber
.b7d3	2e aa 04	rol $04aa			rol 	tokenLineNumber+1
.b7d6	60		rts				rts
.b7d7					TOKWriteByte:
.b7d7	da		phx				phx
.b7d8	ae a8 04	ldx $04a8			ldx 	tokenOffset 				; next slot to write to
.b7db	9d a8 04	sta $04a8,x			sta 	tokenOffset,x 				; write byte out
.b7de	ee a8 04	inc $04a8			inc 	tokenOffset 				; advance slot.
.b7e1	fa		plx				plx
.b7e2	60		rts				rts
.b7e3					TOKCheckCreateVariableRecord:
.b7e3	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b7e5	85 36		sta $36				sta 	0+zTemp0
.b7e7	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b7e9	85 37		sta $37				sta 	1+zTemp0
.b7eb					_CCVSearch:
.b7eb	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b7ed	f0 2c		beq $b81b			beq 	_CCVFail
.b7ef	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b7f1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b7f3	cd 83 04	cmp $0483			cmp 	identHash
.b7f6	d0 16		bne $b80e			bne 	_CCVNext
.b7f8	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b7fa	ae 80 04	ldx $0480			ldx 	identStart
.b7fd					_CCVCompare:
.b7fd	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b800	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b802	e8		inx				inx 								; advance pointers
.b803	c8		iny				iny
.b804	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b805	d0 07		bne $b80e			bne 	_CCVNext  					; didn't match go to next.
.b807	90 f4		bcc $b7fd			bcc 	_CCVCompare 				; not finished yet.
.b809	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b80c	f0 41		beq $b84f			beq 	_CCVFound 					; yes, we were successful
.b80e					_CCVNext:
.b80e	18		clc				clc
.b80f	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b811	65 36		adc $36				adc 	zTemp0
.b813	85 36		sta $36				sta 	zTemp0
.b815	90 d4		bcc $b7eb			bcc 	_CCVSearch
.b817	e6 37		inc $37				inc 	zTemp0+1
.b819	80 d0		bra $b7eb			bra 	_CCVSearch
.b81b					_CCVFail:
.b81b	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b81d	ad 83 04	lda $0483			lda 	identHash
.b820	91 36		sta ($36),y			sta 	(zTemp0),y
.b822	c8		iny				iny 								; offset 2 is the type byte
.b823	ad 84 04	lda $0484			lda 	identTypeByte
.b826	91 36		sta ($36),y			sta 	(zTemp0),y
.b828	c8		iny				iny
.b829					_CCVData:
.b829	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b82b	91 36		sta ($36),y			sta 	(zTemp0),y
.b82d	c8		iny				iny
.b82e	c0 08		cpy #$08			cpy 	#8
.b830	90 f7		bcc $b829			bcc 	_CCVData
.b832	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b835					_CCVCopyName:
.b835	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b838	91 36		sta ($36),y			sta 	(zTemp0),y
.b83a	e8		inx				inx
.b83b	c8		iny				iny
.b83c	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b83f	d0 f4		bne $b835			bne 	_CCVCopyName
.b841	98		tya				tya 								; patch offset
.b842	92 36		sta ($36)			sta 	(zTemp0)
.b844	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b846	91 36		sta ($36),y			sta 	(zTemp0),y
.b848	88		dey				dey
.b849	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b84b	09 80		ora #$80			ora 	#$80
.b84d	91 36		sta ($36),y			sta 	(zTemp0),y
.b84f					_CCVFound:
.b84f	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b851	38		sec				sec
.b852	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b854	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b856	20 d7 b7	jsr $b7d7			jsr 	TOKWriteByte
.b859	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b85b	20 d7 b7	jsr $b7d7			jsr 	TOKWriteByte
.b85e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b85f					SNDCheckChannel:
.b85f	aa		tax				tax
.b860	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b863	d0 38		bne $b89d			bne 	_SNDCCExit
.b865	da		phx				phx 								; save current channel
.b866	8a		txa				txa 								; put in A
.b867	20 e3 b8	jsr $b8e3			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b86a	68		pla				pla 								; channel # in A
.b86b	90 30		bcc $b89d			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b86d	a8		tay				tay 								; Y is the channel #
.b86e	bd fe 06	lda $06fe,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b871	99 fd 07	sta $07fd,y			sta 	SNDPitchLow,y
.b874	bd ff 06	lda $06ff,x			lda 	SNDQueue+2,x
.b877	99 01 08	sta $0801,y			sta 	SNDPitchHigh,y
.b87a	bd 00 07	lda $0700,x			lda 	SNDQueue+3,x
.b87d	99 05 08	sta $0805,y			sta 	SNDVolume,y
.b880	bd 01 07	lda $0701,x			lda 	SNDQueue+4,x
.b883	99 09 08	sta $0809,y			sta 	SNDTimeLeft,y
.b886	bd 02 07	lda $0702,x			lda 	SNDQueue+5,x
.b889	99 0d 08	sta $080d,y			sta 	SNDAdjustLow,y
.b88c	bd 03 07	lda $0703,x			lda 	SNDQueue+6,x
.b88f	99 11 08	sta $0811,y			sta 	SNDAdjustHigh,y
.b892	5a		phy				phy 								; save channel #
.b893	20 fd b8	jsr $b8fd			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b896	ce fc 06	dec $06fc			dec 	SNDLength 					; reduce the queue length.
.b899	68		pla				pla
.b89a	20 9e b8	jsr $b89e			jsr 	SNDUpdateNote 				; update channel A
.b89d					_SNDCCExit:
.b89d	60		rts				rts
.b89e					SNDUpdateNote:
.b89e	aa		tax				tax 								; so we can access records
.b89f	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b8a0	0a		asl a				asl 	a
.b8a1	0a		asl a				asl 	a
.b8a2	0a		asl a				asl 	a
.b8a3	0a		asl a				asl 	a
.b8a4	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b8a7	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; are we silent
.b8aa	f0 2e		beq $b8da			beq 	_SNDUNIsSilent
.b8ac	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; push channel bits on stack
.b8af	48		pha				pha
.b8b0	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b8b3	29 0f		and #$0f			and 	#$0F
.b8b5	0d fb 06	ora $06fb			ora 	SNDChannelBits 				; set channel bits
.b8b8	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b8ba	20 47 b9	jsr $b947			jsr 	SNDWritePorts
.b8bd	bd 01 08	lda $0801,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b8c0	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b8c3	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x
.b8c6	4e fb 06	lsr $06fb			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b8c9	6a		ror a				ror 	a
.b8ca	4e fb 06	lsr $06fb			lsr 	SNDChannelBits
.b8cd	6a		ror a				ror 	a
.b8ce	4a		lsr a				lsr 	a 							; put in bits 0-5
.b8cf	4a		lsr a				lsr 	a
.b8d0	20 47 b9	jsr $b947			jsr 	SNDWritePorts 				; write as rest of pitch register
.b8d3	68		pla				pla
.b8d4	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b8d6	20 47 b9	jsr $b947			jsr 	SNDWritePorts
.b8d9	60		rts				rts
.b8da					_SNDUNIsSilent:
.b8da	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; channel bits
.b8dd	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b8df	20 47 b9	jsr $b947			jsr 	SNDWritePorts 				; write to the ports
.b8e2	60		rts				rts
.b8e3					SNDFindNextNoteForA:
.b8e3	ac fc 06	ldy $06fc			ldy 	SNDLength 					; queue size into Y
.b8e6	f0 13		beq $b8fb			beq 	_SNDFNNFail 				; queue empty.
.b8e8	a2 00		ldx #$00			ldx 	#0
.b8ea					_SNDFNNSearch:
.b8ea	dd fd 06	cmp $06fd,x			cmp 	SNDQueue,x 					; does it match the channel
.b8ed	38		sec				sec
.b8ee	f0 0c		beq $b8fc			beq 	_SNDFNNExit 				; if so exit with CS.
.b8f0	e8		inx				inx 								; next queue slot.
.b8f1	e8		inx				inx
.b8f2	e8		inx				inx
.b8f3	e8		inx				inx
.b8f4	e8		inx				inx
.b8f5	e8		inx				inx
.b8f6	e8		inx				inx
.b8f7	e8		inx				inx
.b8f8	88		dey				dey 								; done the whole queue
.b8f9	d0 ef		bne $b8ea			bne 	_SNDFNNSearch 				; no, go back.
.b8fb					_SNDFNNFail:
.b8fb	18		clc				clc
.b8fc					_SNDFNNexit:
.b8fc	60		rts				rts
.b8fd					SNDDeleteXFromQueue:
.b8fd	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b8ff	f0 09		beq $b90a			beq 	_SNDDXExit
.b901	bd 05 07	lda $0705,x			lda 	SNDQueue+8,x
.b904	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b907	e8		inx				inx
.b908	80 f3		bra $b8fd			bra 	SNDDeleteXFromQueue
.b90a					_SNDDXExit:
.b90a	60		rts				rts
.06fb					SNDChannelBits:
>06fb							.fill 	1
.b90b					SNDQueueRequest:
.b90b	86 36		stx $36				stx 	zTemp0						; save queue address
.b90d	84 37		sty $37				sty 	zTemp0+1
.b90f	ae fc 06	ldx $06fc			ldx 	SNDLength 					; queue is full, can't take any more.
.b912	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b914	f0 21		beq $b937			beq 	_SNDQRExit
.b916	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b918	48		pha				pha
.b919	8a		txa				txa  								; get offset in queue buffer/
.b91a	0a		asl a				asl 	a
.b91b	0a		asl a				asl 	a
.b91c	0a		asl a				asl 	a
.b91d	aa		tax				tax
.b91e	68		pla				pla 								; get back and push again
.b91f	48		pha				pha
.b920	9d fd 06	sta $06fd,x			sta 	SNDQueue+0,x 				; save the channel #
.b923	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b925					_SNDQCopy:
.b925	b1 36		lda ($36),y			lda 	(zTemp0),y
.b927	e8		inx				inx
.b928	c8		iny				iny
.b929	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b92c	c0 06		cpy #$06			cpy 	#6
.b92e	d0 f5		bne $b925			bne 	_SNDQCopy
.b930	ee fc 06	inc $06fc			inc 	SNDLength 					; bump queue length.
.b933	68		pla				pla 								; get channel # back
.b934	20 5f b8	jsr $b85f			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b937					_SNDQRExit:
.b937	60		rts				rts
.b938					SNDSilenceChannel:
.b938	aa		tax				tax 								; zero time left.
.b939	9e 09 08	stz $0809,x			stz 	SNDTimeLeft,x
.b93c	0a		asl a				asl 	a 							; shift into position
.b93d	0a		asl a				asl 	a
.b93e	0a		asl a				asl 	a
.b93f	0a		asl a				asl 	a
.b940	0a		asl a				asl 	a
.b941	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b943	20 47 b9	jsr $b947			jsr 	SNDWritePorts
.b946	60		rts				rts
.b947					SNDWritePorts:
.b947	64 01		stz $01				stz 	1
.b949	8d 00 d6	sta $d600			sta 	$D600
.b94c	8d 10 d6	sta $d610			sta 	$D610
.b94f	60		rts				rts
.b950					SNDCommand:
.b950	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b952	f0 1c		beq $b970			beq 	_SNDInitialise
.b954	90 27		bcc $b97d			bcc 	_SNDExit
.b956	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b958	f0 16		beq $b970			beq 	_SNDSilence
.b95a	b0 21		bcs $b97d			bcs 	_SNDExit
.b95c	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b95e	b0 09		bcs $b969			bcs 	_SNDQueryPlay
.b960	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b962	b0 19		bcs $b97d			bcs 	_SNDExit
.b964	20 0b b9	jsr $b90b			jsr 	SNDQueueRequest
.b967	80 14		bra $b97d			bra 	_SNDExit
.b969					_SNDQueryPlay:
.b969	29 03		and #$03			and 	#3 							; get channel #
.b96b	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b96e	80 0d		bra $b97d			bra 	_SNDExit
.b970					_SNDInitialise:
.b970					_SNDSilence:
.b970	9c fc 06	stz $06fc			stz 	SNDLength 					; empty the queue.
.b973	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b975					_SNDSilenceLoop:
.b975	48		pha				pha
.b976	20 38 b9	jsr $b938			jsr 	SNDSilenceChannel
.b979	68		pla				pla
.b97a	3a		dec a				dec 	a
.b97b	10 f8		bpl $b975			bpl 	_SNDSilenceLoop
.b97d					_SNDExit:
.b97d	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fc					SNDLength:
>06fc							.fill 	1
.06fd					SNDQueue:
>06fd							.fill 	SNDQueueSize * 8
.07fd					SNDPitchLow:
>07fd							.fill 	4
.0801					SNDPitchHigh:
>0801							.fill 	4
.0805					SNDVolume:
>0805							.fill 	4
.0809					SNDTimeLeft:
>0809							.fill 	4
.080d					SNDAdjustLow:
>080d							.fill 	4
.0811					SNDAdjustHigh:
>0811							.fill 	4
.b97e					SNDUpdate:
.b97e	ad 09 08	lda $0809			lda 	SNDTimeLeft+0 				; look at time remaining
.b981	f0 05		beq $b988			beq 	_SNDUNot0 					; not playing
.b983	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.b985	20 a7 b9	jsr $b9a7			jsr 	SNDUpdateChannel 			; update it.
.b988					_SNDUNot0:
.b988	ad 0a 08	lda $080a			lda 	SNDTimeLeft+1
.b98b	f0 05		beq $b992			beq 	_SNDUNot1
.b98d	a2 01		ldx #$01			ldx 	#1
.b98f	20 a7 b9	jsr $b9a7			jsr 	SNDUpdateChannel
.b992					_SNDUNot1:
.b992	ad 0b 08	lda $080b			lda 	SNDTimeLeft+2
.b995	f0 05		beq $b99c			beq 	_SNDUNot2
.b997	a2 02		ldx #$02			ldx 	#2
.b999	20 a7 b9	jsr $b9a7			jsr 	SNDUpdateChannel
.b99c					_SNDUNot2:
.b99c	ad 0c 08	lda $080c			lda 	SNDTimeLeft+3
.b99f	f0 05		beq $b9a6			beq 	_SNDUNot3
.b9a1	a2 03		ldx #$03			ldx 	#3
.b9a3	20 a7 b9	jsr $b9a7			jsr 	SNDUpdateChannel
.b9a6					_SNDUNot3:
.b9a6	60		rts				rts
.b9a7					SNDUpdateChannel:
.b9a7	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.b9a9	f0 2c		beq $b9d7			beq 	_SNDUCExit
.b9ab	3a		dec a				dec 	a 							; decrement and update timer
.b9ac	9d 09 08	sta $0809,x			sta 	SNDTimeLeft,x
.b9af	f0 1d		beq $b9ce			beq 	_SNDUCUpdate 				; if zero, silence channel
.b9b1	bd 0d 08	lda $080d,x			lda 	SNDAdjustLow,x 				; adjust ?
.b9b4	1d 11 08	ora $0811,x			ora 	SNDAdjustHigh,x
.b9b7	f0 1e		beq $b9d7			beq 	_SNDUCExit 					; if zero carry on at current tone.
.b9b9	18		clc				clc 								; add adjust, forcing into a 10 bit range
.b9ba	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x
.b9bd	7d 0d 08	adc $080d,x			adc 	SNDAdjustLow,x
.b9c0	9d fd 07	sta $07fd,x			sta 	SNDPitchLow,x
.b9c3	bd 01 08	lda $0801,x			lda 	SNDPitchHigh,x
.b9c6	7d 11 08	adc $0811,x			adc 	SNDAdjustHigh,x
.b9c9	29 03		and #$03			and 	#3
.b9cb	9d 01 08	sta $0801,x			sta 	SNDPitchHigh,x
.b9ce					_SNDUCUpdate:
.b9ce	8a		txa				txa 								; which channel.
.b9cf	48		pha				pha
.b9d0	20 9e b8	jsr $b89e			jsr 	SNDUpdateNote 				; update the current note
.b9d3	68		pla				pla
.b9d4	20 5f b8	jsr $b85f			jsr 	SNDCheckChannel 			; more to do ?
.b9d7					_SNDUCExit:
.b9d7	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
