
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Sun Nov 27 15:33:32 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	MaxLineSize+1
.057b					numberBuffer:
>057b							.fill 	34
.059d					decimalBuffer:
>059d							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c 07 a7	jmp $a707		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c a0 a9	jmp $a9a0		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c d6 a9	jmp $a9d6		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c f6 a9	jmp $a9f6		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c f9 a9	jmp $a9f9		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c b6 a8	jmp $a8b6		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c 94 aa	jmp $aa94		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 44 bd	jmp $bd44		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c 77 bd	jmp $bd77		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 3a b7	jmp $b73a		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c ce b9	jmp $b9ce		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.802a	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.802c	aa		tax				tax
.802d	a8		tay				tay
.802e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.8031	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8033	20 18 80	jsr $8018			jsr 	SNDCommand
.8036	20 6f 89	jsr $896f			jsr 	NewProgram 					; erase current program
.8039	4c 46 83	jmp $8346			jmp 	WarmStart					; make same size.
.803c	4c 46 83	jmp $8346			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.803f					AssembleGroup1:
.803f	a9 ff		lda #$ff			lda 	#$FF
.8041	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8044	80 02		bra $8048			bra 	AsmGroup12
.8046					AssembleGroup2:
.8046	a9 00		lda #$00			lda 	#$00
.8048					AsmGroup12:
.8048	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.804b	68		pla				pla 								; pop the return address to access the information following.
.804c	fa		plx				plx
.804d	20 d4 80	jsr $80d4			jsr 	AccessParameters 			; get opcode and save as base
.8050	8d 24 04	sta $0424			sta 	BaseOpcode
.8053	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8056	d0 08		bne $8060			bne 	_AG12HaveMask
.8058	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.805a	20 dc 80	jsr $80dc			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.805d	8d 25 04	sta $0425			sta 	ModeMask
.8060					_AG12HaveMask:
.8060	20 10 82	jsr $8210			jsr 	TypeAndCalculateOperand 	; get zero page type
.8063	da		phx				phx 								; save found address mode
.8064	20 40 81	jsr $8140			jsr 	AssembleModeX
.8067	fa		plx				plx  								; restore address mode
.8068	b0 0b		bcs $8075			bcs 	_AG12Exit
.806a	20 76 80	jsr $8076			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.806d	20 40 81	jsr $8140			jsr 	AssembleModeX
.8070	b0 03		bcs $8075			bcs 	_AG12Exit
.8072	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8075					_AG12Exit:
.8075	60		rts				rts
.8076					PromoteToAbsolute:
.8076	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.8078	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.807a	f0 19		beq $8095			beq 	_PTADo
.807c	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.807e	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.8080	f0 13		beq $8095			beq 	_PTADo
.8082	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.8084	e0 80		cpx #$80			cpx 	#AM_ZEROY
.8086	f0 0d		beq $8095			beq 	_PTADo
.8088	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.808a	e0 d1		cpx #$d1			cpx 	#AM_IND
.808c	f0 07		beq $8095			beq 	_PTADo
.808e	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8090	e0 c0		cpx #$c0			cpx 	#AM_INDX
.8092	f0 01		beq $8095			beq 	_PTADo
.8094	60		rts				rts
.8095					_PTADo:
.8095	aa		tax				tax
.8096	60		rts				rts
.8097					AssembleGroup3:
.8097	68		pla				pla 								; get parameters, which is just the opcode.
.8098	fa		plx				plx
.8099	20 d4 80	jsr $80d4			jsr 	AccessParameters 			; get and output opcode
.809c	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte
.809f	20 74 82	jsr $8274			jsr 	CalculateOperand 			; get a 16 bit operand
.80a2	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80a4	38		sec				sec
.80a5	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80a8	48		pha				pha 								; LSB in A
.80a9	a5 60		lda $60				lda 	NSMantissa1
.80ab	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80ae	aa		tax				tax 								; MSB in X
.80af	68		pla				pla
.80b0	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80b1	69 7f		adc #$7f			adc 	#$7F
.80b3	90 01		bcc $80b6			bcc 	_AG3NoCarry
.80b5	e8		inx				inx
.80b6					_AG3NoCarry:
.80b6	38		sec				sec 								; fix back and write out anyways.
.80b7	e9 80		sbc #$80			sbc 	#$80
.80b9	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte
.80bc	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80be	f0 0a		beq $80ca			beq 	_AG3Exit
.80c0	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.80c3	29 01		and #$01			and 	#1
.80c5	f0 03		beq $80ca			beq 	_AG3Exit
.80c7	4c 10 9f	jmp $9f10			jmp 	RangeError 					; no, branch is out of range
.80ca					_AG3Exit:
.80ca	60		rts				rts
.80cb					AssembleGroup4:
.80cb	68		pla				pla 								; pop address
.80cc	fa		plx				plx
.80cd	20 d4 80	jsr $80d4			jsr 	AccessParameters 			; access and get first
.80d0	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte 			; output it.
.80d3	60		rts				rts
.80d4					AccessParameters:
.80d4	8d 21 04	sta $0421			sta 	ParamStart
.80d7	8e 22 04	stx $0422			stx 	ParamStart+1
.80da	a9 01		lda #$01			lda 	#1
.80dc					GetParameter:
.80dc	5a		phy				phy
.80dd	a8		tay				tay
.80de	ad 21 04	lda $0421			lda 	ParamStart
.80e1	85 36		sta $36				sta 	zTemp0
.80e3	ad 22 04	lda $0422			lda 	ParamStart+1
.80e6	85 37		sta $37				sta 	zTemp0+1
.80e8	b1 36		lda ($36),y			lda 	(zTemp0),y
.80ea	7a		ply				ply
.80eb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.80ec					AssemblerWriteByte:
.80ec	48		pha			pha
.80ed	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.80f0	29 02		and #$02		and 	#2
.80f2	f0 1b		beq $810f		beq 	_AWBNoPrint
.80f4	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.80f7	20 2a 81	jsr $812a		jsr 	PrintHex
.80fa	ad 1e 04	lda $041e		lda		AssemblerAddress
.80fd	20 2a 81	jsr $812a		jsr 	PrintHex
.8100	a9 20		lda #$20		lda 	#' '
.8102	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8105	68		pla			pla 									; print byte
.8106	48		pha			pha
.8107	20 2a 81	jsr $812a		jsr 	PrintHex
.810a	a9 0d		lda #$0d		lda 	#13
.810c	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.810f					_AWBNoPrint:
.810f	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8112	85 36		sta $36			sta 	zTemp0
.8114	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.8117	f0 0e		beq $8127		beq 	_AWBRange
.8119	85 37		sta $37			sta 	zTemp0+1
.811b	68		pla			pla 									; write byte out
.811c	92 36		sta ($36)		sta 	(zTemp0)
.811e	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8121	d0 03		bne $8126		bne 	_AWBNoCarry
.8123	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.8126					_AWBNoCarry:
.8126	60		rts			rts
.8127					_AWBRange:
.8127	4c 10 9f	jmp $9f10		jmp 	RangeError
.812a					PrintHex:
.812a	48		pha				pha
.812b	4a		lsr a				lsr 	a
.812c	4a		lsr a				lsr 	a
.812d	4a		lsr a				lsr 	a
.812e	4a		lsr a				lsr 	a
.812f	20 33 81	jsr $8133			jsr 	_PrintNibble
.8132	68		pla				pla
.8133					_PrintNibble:
.8133	29 0f		and #$0f			and 	#15
.8135	c9 0a		cmp #$0a			cmp 	#10
.8137	90 02		bcc $813b			bcc 	_NoShift
.8139	69 06		adc #$06			adc 	#6
.813b					_NoShift:
.813b	69 30		adc #$30			adc 	#48
.813d	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8140					AssembleModeX:
.8140	5a		phy				phy
.8141	ad 23 04	lda $0423			lda 	IsGroup1
.8144	f0 17		beq $815d			beq 	_AMXGroup2
.8146	8a		txa				txa 							; is it in group # 1
.8147	29 40		and #$40			and 	#AM_ISG1
.8149	f0 4d		beq $8198			beq 	_AMXFail 				; no, give up.
.814b	8a		txa				txa 							; get back.
.814c	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.814e	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8150	d0 22		bne $8174			bne 	_AMXHaveInfo
.8152	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8155	c9 81		cmp #$81			cmp 	#$81
.8157	f0 3f		beq $8198			beq 	_AMXFail
.8159	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.815b	80 17		bra $8174			bra 	_AMXHaveInfo 			; odd design decision there.
.815d					_AMXGroup2:
.815d	8a		txa				txa 							; is it in group 2 ?
.815e	29 20		and #$20			and 	#AM_ISG2
.8160	f0 36		beq $8198			beq 	_AMXFail 				; no, give up.
.8162	8a		txa				txa 							; get the offset into Y
.8163	29 1f		and #$1f			and 	#$1F
.8165	4a		lsr a				lsr 	a 						; make it 0-7.
.8166	4a		lsr a				lsr  	a
.8167	a8		tay				tay
.8168	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.816b					_AMXCheckOkay:
.816b	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.816c	88		dey				dey
.816d	10 fc		bpl $816b			bpl 	_AMXCheckOkay
.816f	90 27		bcc $8198			bcc 	_AMXFail 				; not allowed.
.8171	8a		txa				txa  							; get mask back
.8172	29 1f		and #$1f			and 	#$1F
.8174					_AMXHaveInfo:
.8174	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.8176	10 04		bpl $817c			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.8178	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.817a	d0 1c		bne $8198			bne 	_AMXFail
.817c					_AMXAnySize:
.817c	18		clc				clc 							; add offset to the base opcode
.817d	6d 24 04	adc $0424			adc 	BaseOpcode
.8180					_AMXOutputCode:
.8180	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte 		; write the opcode out.
.8183	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.8185	f0 0e		beq $8195			beq 	_AMXExit
.8187	a5 58		lda $58				lda 	NSMantissa0 				; write LSB operand
.8189	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte
.818c	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.818e	30 05		bmi $8195			bmi 	_AMXExit
.8190	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.8192	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte
.8195					_AMXExit:
.8195	7a		ply				ply
.8196	38		sec				sec
.8197	60		rts				rts
.8198					_AMXFail:
.8198	a0 00		ldy #$00			ldy 	#0
.819a					_AMXCheckOddities:
.819a	8a		txa				txa
.819b	d9 c2 81	cmp $81c2,y			cmp 	ExtraOpcode+2,y 		; match address mode
.819e	d0 15		bne $81b5			bne 	_AMXCONext
.81a0	b9 c0 81	lda $81c0,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81a3	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81a6	d0 0d		bne $81b5			bne 	_AMXCONext
.81a8	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81aa	10 04		bpl $81b0			bpl 	_AMXCONotZero
.81ac	a5 60		lda $60				lda 	NSMantissa1
.81ae	d0 05		bne $81b5			bne 	_AMXCONext
.81b0					_AMXCONotZero:
.81b0	b9 c1 81	lda $81c1,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81b3	80 cb		bra $8180			bra 	_AMXOutputCode 			; and assemble it
.81b5					_AMXCONext:
.81b5	c8		iny				iny
.81b6	c8		iny				iny
.81b7	c8		iny				iny
.81b8	b9 c0 81	lda $81c0,y			lda 	ExtraOpcode+0,y 		; end of table
.81bb	d0 dd		bne $819a			bne 	_AMXCheckOddities
.81bd					_AMXCOFail:
.81bd	7a		ply				ply
.81be	18		clc				clc
.81bf	60		rts				rts
.81c0					ExtraOpcode:
>81c0	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>81c3	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>81c6	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81c9	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81cc	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>81cf	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>81d2	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>81d5	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>81d8	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>81db	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>81de	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.81df					LabelHere:
.81df	c8		iny				iny 								; skip .
.81e0	a2 00		ldx #$00			ldx 	#0 							; get a term
.81e2	20 ce 97	jsr $97ce			jsr 	EvaluateTerm 				; get a term
.81e5	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.81e7	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.81e9	d0 22		bne $820d			bne 	_ALType
.81eb	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.81ed	85 36		sta $36				sta 	zTemp0
.81ef	b5 60		lda $60,x			lda 	NSMantissa1,x
.81f1	85 37		sta $37				sta 	zTemp0+1
.81f3	5a		phy				phy 								; copy address in.
.81f4	a0 01		ldy #$01			ldy 	#1
.81f6	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.81f9	92 36		sta ($36)			sta 	(zTemp0)
.81fb	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.81fe	91 36		sta ($36),y			sta 	(zTemp0),y
.8200	c8		iny				iny
.8201	a9 00		lda #$00			lda 	#0
.8203	91 36		sta ($36),y			sta 	(zTemp0),y
.8205	c8		iny				iny
.8206	91 36		sta ($36),y			sta 	(zTemp0),y
.8208	c8		iny				iny
.8209	91 36		sta ($36),y			sta 	(zTemp0),y
.820b	7a		ply				ply
.820c	60		rts				rts
.820d					_ALType:
.820d	4c 15 9f	jmp $9f15			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8210					TypeAndCalculateOperand:
.8210	b1 30		lda ($30),y			lda 	(codePtr),y
.8212	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8214	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8216	f0 5b		beq $8273			beq 	_TACOExit
.8218	c9 80		cmp #$80			cmp 	#KWC_EOL
.821a	f0 57		beq $8273			beq 	_TACOExit
.821c	c8		iny				iny
.821d	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.821f	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8221	f0 51		beq $8274			beq 	CalculateOperand
.8223	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8225	f0 1f		beq $8246			beq 	_TACOIndirect
.8227	88		dey				dey 								; undo get of first character
.8228	20 74 82	jsr $8274			jsr 	CalculateOperand 			; get operand
.822b	b1 30		lda ($30),y			lda 	(codePtr),y
.822d	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.822f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8231	d0 40		bne $8273			bne 	_TACOExit
.8233	c8		iny				iny
.8234	20 7e 82	jsr $827e			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8237	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.8239	c9 58		cmp #$58			cmp 	#'X'
.823b	f0 36		beq $8273			beq 	_TACOExit
.823d	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.823f	c9 59		cmp #$59			cmp 	#'Y'
.8241	f0 30		beq $8273			beq 	_TACOExit
.8243					_TACOSyntax:
.8243	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError
.8246					_TACOIndirect:
.8246	20 74 82	jsr $8274			jsr 	CalculateOperand 			; get the operand
.8249	b1 30		lda ($30),y			lda 	(codePtr),y
.824b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.824d	f0 17		beq $8266			beq 	_TACOIndX
.824f	20 67 8e	jsr $8e67			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8252	b1 30		lda ($30),y			lda 	(codePtr),y
.8254	a2 d1		ldx #$d1			ldx 	#AM_IND
.8256	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.8258	d0 19		bne $8273			bne 	_TACOExit
.825a	c8		iny				iny
.825b	20 7e 82	jsr $827e			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.825e	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8260	d0 e1		bne $8243			bne 	_TACOSyntax
.8262	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8264	80 0d		bra $8273			bra 	_TACOExit
.8266					_TACOIndX:
.8266	c8		iny				iny
.8267	20 7e 82	jsr $827e			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.826a	c9 58		cmp #$58			cmp 	#'X' 						; check X
.826c	d0 d5		bne $8243			bne 	_TACOSyntax
.826e	20 67 8e	jsr $8e67			jsr 	CheckRightBracket			; check )
.8271	a2 c0		ldx #$c0			ldx 	#AM_INDX
.8273					_TACOExit:
.8273	60		rts				rts
.8274					CalculateOperand:
.8274	48		pha				pha
.8275	da		phx				phx
.8276	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.8278	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger
.827b	fa		plx				plx
.827c	68		pla				pla
.827d	60		rts				rts
.827e					TACOCheckXY:
.827e	b1 30		lda ($30),y			lda 	(codePtr),y
.8280	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.8282	c9 40		cmp #$40			cmp 	#$40
.8284	d0 21		bne $82a7			bne 	_TCXYFail
.8286	b1 30		lda ($30),y			lda 	(codePtr),y
.8288	18		clc				clc
.8289	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.828b	85 37		sta $37				sta 	zTemp0+1
.828d	c8		iny				iny
.828e	b1 30		lda ($30),y			lda 	(codePtr),y
.8290	c8		iny				iny
.8291	85 36		sta $36				sta 	zTemp0
.8293	5a		phy				phy 								; save position
.8294	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.8296	b1 36		lda ($36),y			lda 	(zTemp0),y
.8298	d0 0c		bne $82a6			bne 	_TCXYPopFail
.829a	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.829c	b1 36		lda ($36),y			lda 	(zTemp0),y
.829e	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82a0	f0 08		beq $82aa			beq 	_TCXYFound
.82a2	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82a4	f0 04		beq $82aa			beq 	_TCXYFound
.82a6					_TCXYPopFail:
.82a6	7a		ply				ply
.82a7					_TCXYFail:
.82a7	a9 00		lda #$00			lda 	#0
.82a9	60		rts				rts
.82aa					_TCXYFound:
.82aa	7a		ply				ply 								; restore position
.82ab	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82ad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82ae					BackloadProgram:
.82ae	a2 82		ldx #$82			ldx 	#_BLLoad >> 8
.82b0	a9 f5		lda #$f5			lda 	#_BLLoad & $FF
.82b2	20 d9 8e	jsr $8ed9			jsr 	PrintStringXA
.82b5	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82b7	8d ad 05	sta $05ad			sta 	0+BackLoadPointer
.82ba	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82bc	8d ae 05	sta $05ae			sta 	1+BackLoadPointer
.82bf	a9 ff		lda #$ff			lda 	#$FF
.82c1	8d fa ff	sta $fffa			sta 	$FFFA
.82c4					_BPLoop:
.82c4	a2 ff		ldx #$ff			ldx 	#$FF
.82c6	20 0a 83	jsr $830a			jsr 	BLReadByte 					; read a byte
.82c9	c9 00		cmp #$00			cmp 	#0
.82cb	f0 21		beq $82ee			beq 	_BPExit 					; if 0 exit
.82cd	30 1f		bmi $82ee			bmi 	_BPExit 					; if -ve exit
.82cf					_BPCopy:
.82cf	e8		inx				inx  								; copy byte into the lineBuffer
.82d0	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.82d3	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.82d6	20 0a 83	jsr $830a			jsr 	BLReadByte 					; read next byte
.82d9	30 0a		bmi $82e5			bmi 	_BPEndLine 					; -ve = EOL
.82db	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.82dd	d0 02		bne $82e1			bne 	_BPNotTab
.82df	a9 20		lda #$20			lda 	#' '
.82e1					_BPNotTab:
.82e1	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.82e3	b0 ea		bcs $82cf			bcs 	_BPCopy 					; until a control character, should be 13 received.
.82e5					_BPEndLine:
.82e5	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.82e8	38		sec				sec 								; append not insert
.82e9	20 55 a4	jsr $a455			jsr 	MemoryInsertLine 			; append to current program
.82ec	80 d6		bra $82c4			bra 	_BPLoop
.82ee					_BPExit:
.82ee	9c fa ff	stz $fffa			stz 	$FFFA
.82f1	20 dc 83	jsr $83dc			jsr 	ClearCommand 				; clear variables etc.
.82f4	60		rts				rts
.82f5					_BLLoad:
>82f5	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>82fd	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.830a					BLReadByte:
.830a	ad ad 05	lda $05ad			lda 	BackLoadPointer 			; copy pointer to zTemp0
.830d	85 36		sta $36				sta 	zTemp0
.830f	ad ae 05	lda $05ae			lda 	BackLoadPointer+1
.8312	85 37		sta $37				sta 	zTemp0+1
.8314	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8316	ee ad 05	inc $05ad			inc 	BackLoadPointer 			; bump pointer
.8319	d0 03		bne $831e			bne 	_BLNoCarry
.831b	ee ae 05	inc $05ae			inc 	BackLoadPointer+1
.831e					_BLNoCarry:
.831e	c9 00		cmp #$00			cmp 	#0
.8320	60		rts				rts
.05ad					BackLoadPointer:
>05ad							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8321					EditProgramCode:
.8321	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line.
.8324	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.8327	20 f9 a4	jsr $a4f9			jsr 	MemorySearch
.832a	90 05		bcc $8331			bcc 	_EPCNoDelete 				; reached the end don't delete
.832c	d0 03		bne $8331			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.832e	20 1e a4	jsr $a41e			jsr 	MemoryDeleteLine 			; delete the line
.8331					_EPCNoDelete:
.8331	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty
.8334	c9 80		cmp #$80			cmp 	#KWC_EOL
.8336	f0 0d		beq $8345			beq 	_EPCNoInsert
.8338	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist.
.833b	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.833e	20 f9 a4	jsr $a4f9			jsr 	MemorySearch
.8341	18		clc				clc 								; insert at this point.
.8342	20 55 a4	jsr $a455			jsr 	MemoryInsertLine 			; insert the line
.8345					_EPCNoInsert:
.8345	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8346					WarmStart:
.8346	a2 ff		ldx #$ff			ldx 	#$FF
.8348	9a		txs				txs
.8349	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour
.834b	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.834e	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.8351	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.8354	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number ?
.8357	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.835a	d0 17		bne $8373			bne 	_WSEditCode 				; if so,edit code.
.835c	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.835f	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.8361	85 30		sta $30				sta 	codePtr
.8363	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8365	85 31		sta $31				sta 	codePtr+1
.8367	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.836a	c9 80		cmp #$80			cmp 	#KWC_EOL
.836c	f0 d8		beq $8346			beq 	WarmStart
.836e	20 bd 8a	jsr $8abd			jsr 	RUNCodePointerLine 			; execute that line.
.8371	80 d3		bra $8346			bra 	WarmStart
.8373					_WSEditCode:
.8373	20 21 83	jsr $8321			jsr 	EditProgramCode
.8376	20 dc 83	jsr $83dc			jsr 	ClearCommand
.8379	80 cb		bra $8346			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.837b					AssembleCommand:
.837b	a2 00		ldx #$00			ldx 	#0
.837d	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger 		; start address
.8380	a5 58		lda $58				lda 	NSMantissa0
.8382	8d 1e 04	sta $041e			sta 	AssemblerAddress
.8385	a5 60		lda $60				lda 	NSMantissa1
.8387	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.838a	20 6f 8e	jsr $8e6f			jsr 	CheckComma
.838d	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; options
.8390	a5 58		lda $58				lda 	NSMantissa0
.8392	8d 20 04	sta $0420			sta 	AssemblerControl
.8395	60		rts				rts
.8396	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.8397					AssertCommand:
.8397	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8399	20 fa 9c	jsr $9cfa			jsr 	EvaluateInteger 			; the assert test
.839c	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; exit if result is non zero.
.839f	d0 05		bne $83a6			bne 	_ACExit
.83a1	a9 0a		lda #$0a		lda	#10
.83a3	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.83a6					_ACExit:
.83a6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83a7					CallCommand:
.83a7	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83a9	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger
.83ac					_CCClear
.83ac	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83ad	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero 					; these are optional sequentially.
.83b0	e0 04		cpx #$04			cpx 	#4
.83b2	d0 f8		bne $83ac			bne 	_CCClear
.83b4	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83b6					_CCCParam:
.83b6	b1 30		lda ($30),y			lda 	(codePtr),y
.83b8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83ba	d0 09		bne $83c5			bne 	_CCCRun6502
.83bc	c8		iny				iny 								; skip comma
.83bd	e8		inx				inx	 								; next level
.83be	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83c1	e0 03		cpx #$03			cpx 	#3
.83c3	90 f1		bcc $83b6			bcc 	_CCCParam 					; done all 3 ?
.83c5					_CCCRun6502:
.83c5	5a		phy				phy 								; save position
.83c6	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.83c8	85 37		sta $37				sta 	zTemp0+1
.83ca	a5 58		lda $58				lda 	NSMantissa0
.83cc	85 36		sta $36				sta 	zTemp0
.83ce	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.83d0	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.83d2	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.83d4	20 d9 83	jsr $83d9			jsr 	_CCCZTemp0 					; call zTemp0
.83d7	7a		ply				ply 								; restore position and exit
.83d8	60		rts				rts
.83d9					_CCCZTemp0:
.83d9	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83dc					ClearCommand:
.83dc	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83de	85 36		sta $36				sta 	0+zTemp0
.83e0	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83e2	85 37		sta $37				sta 	1+zTemp0
.83e4					_ClearZeroLoop:
.83e4	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.83e6	f0 24		beq $840c			beq 	_ClearZeroEnd
.83e8	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83ea	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.83ec					_ClearOneVariable:
.83ec	91 36		sta ($36),y			sta 	(zTemp0),y
.83ee	c8		iny				iny
.83ef	c0 08		cpy #$08			cpy 	#8
.83f1	d0 f9		bne $83ec			bne 	_ClearOneVariable
.83f3	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.83f5	b1 36		lda ($36),y			lda 	(zTemp0),y
.83f7	c9 18		cmp #$18			cmp 	#NSTProcedure
.83f9	d0 04		bne $83ff			bne 	_ClearNotProcedure
.83fb	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.83fd	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.83ff					_ClearNotProcedure:
.83ff	18		clc				clc 								; go to the next variable
.8400	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8402	65 36		adc $36				adc 	zTemp0
.8404	85 36		sta $36				sta 	zTemp0
.8406	90 dc		bcc $83e4			bcc 	_ClearZeroLoop
.8408	e6 37		inc $37				inc 	zTemp0+1
.840a	80 d8		bra $83e4			bra 	_ClearZeroLoop
.840c					_ClearZeroEnd:
.840c	18		clc				clc
.840d	a5 36		lda $36				lda 	zTemp0
.840f	69 01		adc #$01			adc 	#1
.8411	8d 0c 04	sta $040c			sta 	lowMemPtr
.8414	a5 37		lda $37				lda 	zTemp0+1
.8416	69 00		adc #$00			adc 	#0
.8418	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.841b	20 35 a6	jsr $a635			jsr 	StackReset
.841e	20 9b a6	jsr $a69b			jsr 	StringSystemInitialise
.8421	20 0d 8d	jsr $8d0d			jsr 	ProcedureScan
.8424	20 6c 8a	jsr $8a6c			jsr 	Command_Restore
.8427	9c 1e 04	stz $041e			stz 	AssemblerAddress
.842a	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.842d	9c 20 04	stz $0420			stz 	AssemblerControl
.8430	20 b5 99	jsr $99b5			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8433	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8434					ClearScreen:
.8434	5a		phy				phy
.8435	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8437	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.843a	7a		ply				ply
.843b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.843c					Command_Data:
.843c	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.843e	a2 80		ldx #$80			ldx 	#KWC_EOL
.8440	20 5f 8d	jsr $8d5f			jsr 	ScanForward
.8443	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8444					DimCommand:
.8444	b1 30		lda ($30),y			lda 	(codePtr),y
.8446	29 c0		and #$c0			and 	#$C0
.8448	c9 40		cmp #$40			cmp 	#$40
.844a	d0 7a		bne $84c6			bne 	_DCSyntax
.844c	b1 30		lda ($30),y			lda 	(codePtr),y
.844e	18		clc				clc
.844f	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8451	85 3f		sta $3f				sta 	zaTemp+1
.8453	c8		iny				iny
.8454	b1 30		lda ($30),y			lda 	(codePtr),y
.8456	c8		iny				iny
.8457	85 3e		sta $3e				sta 	zaTemp
.8459	5a		phy				phy
.845a	a0 02		ldy #$02			ldy 	#2 						; read type byte
.845c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.845e	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8460	c9 18		cmp #$18			cmp 	#NSTProcedure
.8462	f0 62		beq $84c6			beq 	_DCSyntax
.8464	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8466	29 04		and #$04			and 	#NSBIsArray
.8468	f0 64		beq $84ce			beq 	_DCType
.846a	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.846c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.846e	d0 59		bne $84c9			bne 	_DCRedefine
.8470	7a		ply				ply
.8471	20 d1 84	jsr $84d1			jsr 	_DCGetSize 				; get array size, check it.
.8474	5a		phy				phy
.8475	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8477	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.8479	7a		ply				ply 							; is there a second (e.g. ,x)
.847a	b1 30		lda ($30),y			lda 	(codePtr),y
.847c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.847e	d0 0a		bne $848a			bne 	_DCOneDimension
.8480	c8		iny				iny 							; skip comma
.8481	20 d1 84	jsr $84d1			jsr 	_DCGetSize 				; get 2nd array size
.8484	5a		phy				phy
.8485	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8487	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8489	7a		ply				ply
.848a					_DCOneDimension:
.848a	5a		phy				phy 							; save position
.848b	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.848d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.848f	aa		tax				tax
.8490	c8		iny				iny
.8491	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8493	e8		inx				inx 							; bump them.
.8494	1a		inc a				inc 	a
.8495	20 38 9d	jsr $9d38			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.8498	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.849a	29 e0		and #$e0			and 	#$E0
.849c	d0 23		bne $84c1			bne 	_DCSize
.849e	a0 02		ldy #$02			ldy 	#2 						; get base type
.84a0	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a2	20 df 84	jsr $84df			jsr 	ScaleByBaseType 		; scale by base type
.84a5	a5 36		lda $36				lda 	zTemp0
.84a7	a6 37		ldx $37				ldx 	zTemp0+1
.84a9	20 77 99	jsr $9977			jsr 	AllocateXABytes 		; allocate memory
.84ac	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84ae	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84b0	c8		iny				iny
.84b1	8a		txa				txa
.84b2	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84b4	7a		ply				ply 							; get position back
.84b5	20 67 8e	jsr $8e67			jsr 	CheckRightBracket 		; check )
.84b8	b1 30		lda ($30),y			lda 	(codePtr),y
.84ba	c8		iny				iny 							; consume in case
.84bb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84bd	f0 85		beq $8444			beq 	DimCommand
.84bf	88		dey				dey 							; undo consume
.84c0	60		rts				rts
.84c1					_DCSize:
.84c1	a9 16		lda #$16		lda	#22
.84c3	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.84c6					_DCSyntax:
.84c6	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError
.84c9					_DCRedefine:
.84c9	a9 15		lda #$15		lda	#21
.84cb	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.84ce					_DCType:
.84ce	4c 15 9f	jmp $9f15			jmp 	TypeError
.84d1					_DCGetSize:
.84d1	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84d3	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 	; get array dimension
.84d6	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84d8	f0 e7		beq $84c1			beq 	_DCSize
.84da	c9 fe		cmp #$fe			cmp 	#254
.84dc	f0 e3		beq $84c1			beq 	_DCSize
.84de	60		rts				rts
.84df					ScaleByBaseType:
.84df	29 10		and #$10			and 	#NSBIsString 			; is it string
.84e1	d0 19		bne $84fc			bne 	_SBBTString
.84e3	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84e5	48		pha				pha
.84e6	a5 36		lda $36				lda 	zTemp0
.84e8	48		pha				pha
.84e9	06 36		asl $36				asl 	zTemp0 					; x 2
.84eb	26 37		rol $37				rol 	zTemp0+1
.84ed	06 36		asl $36				asl 	zTemp0 					; x 4
.84ef	26 37		rol $37				rol 	zTemp0+1
.84f1	68		pla				pla 							; add stacked value = x 5
.84f2	65 36		adc $36				adc 	zTemp0
.84f4	85 36		sta $36				sta 	zTemp0
.84f6	68		pla				pla
.84f7	65 37		adc $37				adc 	zTemp0+1
.84f9	85 37		sta $37				sta 	zTemp0+1
.84fb	60		rts				rts
.84fc					_SBBTString:
.84fc	06 36		asl $36				asl 	zTemp0
.84fe	26 37		rol $37				rol 	zTemp0+1
.8500	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8501					EndCommand:
.8501	4c 46 83	jmp $8346			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8504					ForCommand:
.8504	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.8506	20 d0 a5	jsr $a5d0			jsr 	StackOpen
.8509	a2 00		ldx #$00			ldx 	#0
.850b	20 ce 97	jsr $97ce			jsr 	EvaluateTerm
.850e	b5 50		lda $50,x			lda 	NSStatus,x
.8510	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8512	d0 47		bne $855b			bne		_FCError
.8514	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8516	20 77 8e	jsr $8e77			jsr 	CheckNextA
.8519	e8		inx				inx
.851a	20 fa 9c	jsr $9cfa			jsr 	EvaluateInteger 			; <from> in +1
.851d	b1 30		lda ($30),y			lda 	(codePtr),y
.851f	c8		iny				iny 								; consume it
.8520	48		pha				pha 								; save on stack for later
.8521	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8523	f0 04		beq $8529			beq 	_FCNoSyntax
.8525	c9 ce		cmp #$ce			cmp 	#KWD_TO
.8527	d0 35		bne $855e			bne 	_FCSyntaxError
.8529					_FCNoSyntax:
.8529	e8		inx				inx
.852a	20 fa 9c	jsr $9cfa			jsr 	EvaluateInteger
.852d	20 14 a6	jsr $a614			jsr 	STKSaveCodePosition 		; save loop back position
.8530	68		pla				pla 								; restore DOWNTO or TO
.8531	5a		phy				phy 								; save Y on the stack
.8532	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8534	f0 02		beq $8538			beq 	_FCNotDownTo
.8536	a9 02		lda #$02			lda 	#2
.8538					_FCNotDownTo:
.8538	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8539	a0 10		ldy #$10			ldy 	#16
.853b	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.853d	a0 06		ldy #$06			ldy 	#6
.853f	a5 58		lda $58				lda 	NSMantissa0
.8541	91 34		sta ($34),y			sta 	(basicStack),y
.8543	a5 60		lda $60				lda 	NSMantissa1
.8545	c8		iny				iny
.8546	91 34		sta ($34),y			sta 	(basicStack),y
.8548	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.854a	a2 01		ldx #$01			ldx 	#1
.854c	20 61 85	jsr $8561			jsr 	FCIntegerToStack
.854f	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8551	a2 02		ldx #$02			ldx 	#2
.8553	20 61 85	jsr $8561			jsr 	FCIntegerToStack
.8556	20 7c 85	jsr $857c			jsr 	CopyIndexToReference
.8559	7a		ply				ply 								; restore position
.855a	60		rts				rts
.855b					_FCError:
.855b	4c 15 9f	jmp $9f15			jmp 	TypeError
.855e					_FCSyntaxError:
.855e	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError
.8561					FCIntegerToStack:
.8561	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8563	10 03		bpl $8568			bpl	 	_FCNotNegative
.8565	20 56 9d	jsr $9d56			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8568					_FCNotNegative:
.8568	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.856a	91 34		sta ($34),y			sta 	(basicStack),y
.856c	c8		iny				iny
.856d	b5 60		lda $60,x			lda 	NSMantissa1,x
.856f	91 34		sta ($34),y			sta 	(basicStack),y
.8571	c8		iny				iny
.8572	b5 68		lda $68,x			lda 	NSMantissa2,x
.8574	91 34		sta ($34),y			sta 	(basicStack),y
.8576	c8		iny				iny
.8577	b5 70		lda $70,x			lda 	NSMantissa3,x
.8579	91 34		sta ($34),y			sta 	(basicStack),y
.857b	60		rts				rts
.857c					CopyIndexToReference:
.857c	5a		phy				phy
.857d	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.857f	38		sec				sec 								; (because we copy from offset 8)
.8580	b1 34		lda ($34),y			lda 	(basicStack),y
.8582	e9 08		sbc #$08			sbc 	#8
.8584	85 36		sta $36				sta 	zTemp0
.8586	c8		iny				iny
.8587	b1 34		lda ($34),y			lda 	(basicStack),y
.8589	e9 00		sbc #$00			sbc 	#0
.858b	85 37		sta $37				sta 	zTemp0+1
.858d	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.858f	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.8591	b1 34		lda ($34),y			lda 	(basicStack),y
.8593	0a		asl a				asl 	a 							; into carry
.8594	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8596	90 14		bcc $85ac			bcc 	_CITRNormal
.8598	38		sec				sec
.8599					_CITRNegative:
.8599	a9 00		lda #$00			lda 	#0
.859b	f1 34		sbc ($34),y			sbc 	(basicStack),y
.859d	91 36		sta ($36),y			sta 	(zTemp0),y
.859f	c8		iny				iny
.85a0	ca		dex				dex
.85a1	d0 f6		bne $8599			bne 	_CITRNegative
.85a3	88		dey				dey 								; look at MSB of mantissa
.85a4	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85a6	09 80		ora #$80			ora 	#$80
.85a8	91 36		sta ($36),y			sta 	(zTemp0),y
.85aa	7a		ply				ply
.85ab	60		rts				rts
.85ac					_CITRNormal:
.85ac	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85ae	91 36		sta ($36),y			sta 	(zTemp0),y
.85b0	c8		iny				iny
.85b1	ca		dex				dex
.85b2	d0 f8		bne $85ac			bne 	_CITRNormal
.85b4	7a		ply				ply 								; and exit.
.85b5	60		rts				rts
.85b6					NextCommand:
.85b6	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85b8	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85ba	20 fc a5	jsr $a5fc			jsr 	StackCheckFrame
.85bd	5a		phy				phy
.85be	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85c0	b1 34		lda ($34),y			lda 	(basicStack),y
.85c2	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85c4	30 02		bmi $85c8			bmi 	_NCStepNeg
.85c6	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85c8					_NCStepNeg:
.85c8	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85ca	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85cc	18		clc				clc
.85cd					_NCBump:
.85cd	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85cf	91 34		sta ($34),y			sta 	(basicStack),y
.85d1	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85d3	c8		iny				iny 								; next byte
.85d4	ca		dex				dex 								; do four times
.85d5	d0 f6		bne $85cd			bne 	_NCBump
.85d7	20 7c 85	jsr $857c			jsr		CopyIndexToReference		; copy it to the reference variable.
.85da	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85dc	b1 34		lda ($34),y			lda 	(basicStack),y
.85de	0a		asl a				asl 	a 							; sign bit to carry
.85df	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85e1	85 38		sta $38				sta 	zTemp1
.85e3	90 02		bcc $85e7			bcc 	_NCCompRev 					; use if step is +ve
.85e5	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.85e7					_NCCompRev:
.85e7	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.85e9	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.85eb	85 39		sta $39				sta 	zTemp1+1
.85ed	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.85ef	38		sec				sec
.85f0					_NCCompare:
.85f0	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.85f2	b1 34		lda ($34),y			lda 	(basicStack),y
.85f4	a4 39		ldy $39				ldy 	zTemp1+1
.85f6	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85f8	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.85fa	e6 39		inc $39				inc 	zTemp1+1
.85fc	ca		dex				dex 								; do it 4 times.
.85fd	d0 f1		bne $85f0			bne 	_NCCompare
.85ff	50 02		bvc $8603			bvc 	_NCNoOverflow 				; convert to signed comparison
.8601	49 80		eor #$80			eor 	#$80
.8603					_NCNoOverflow:
.8603	7a		ply				ply 								; restore Y position
.8604	0a		asl a				asl 	a 							; is bit 7 set.
.8605	90 04		bcc $860b			bcc 	_NCLoopback 				; if no , >= so loop back
.8607	20 ee a5	jsr $a5ee			jsr 	StackClose 					; exit the loop
.860a	60		rts				rts
.860b					_NCLoopBack:
.860b	20 25 a6	jsr $a625			jsr 	STKLoadCodePosition 		; loop back
.860e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.860f					Command_GOSUB:
.860f	a2 00		ldx #$00			ldx 	#0
.8611	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8614	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8616	20 d0 a5	jsr $a5d0			jsr 	StackOpen 					; create frame
.8619	20 14 a6	jsr $a614			jsr 	STKSaveCodePosition 		; save current position
.861c	4c 32 86	jmp $8632			jmp 	GotoStackX
.861f					Command_RETURN:
.861f	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8621	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8623	20 fc a5	jsr $a5fc			jsr 	StackCheckFrame
.8626	20 25 a6	jsr $a625			jsr 	STKLoadCodePosition 		; restore code position
.8629	20 ee a5	jsr $a5ee			jsr 	StackClose
.862c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.862d					GotoCommand:
.862d	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.862f	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger
.8632					GotoStackX:
.8632	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8634	48		pha				pha 								; it is slightly inefficient, just in cases.
.8635	b5 58		lda $58,x			lda 	NSMantissa0,x
.8637	fa		plx				plx
.8638	20 f9 a4	jsr $a4f9			jsr 	MemorySearch 				; transfer to line number AX.
.863b	90 05		bcc $8642			bcc 	_GotoError 					; not found, off end.
.863d	d0 03		bne $8642			bne 	_GotoError 					; not found exactly
.863f	4c b6 8a	jmp $8ab6			jmp 	RunNewLine 					; and go straight to new line code.
.8642					_GotoError:
.8642	a9 0d		lda #$0d		lda	#13
.8644	4c 80 8e	jmp $8e80		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8647					IfCommand:
.8647	a2 00		ldx #$00			ldx 	#0 							; If what.
.8649	20 db 9c	jsr $9cdb			jsr 	EvaluateNumber
.864c	b1 30		lda ($30),y			lda 	(codePtr),y
.864e	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8650	d0 0a		bne $865c			bne 	_IFStructured
.8652	c8		iny				iny 								; consume THEN
.8653	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; is it zero
.8656	f0 01		beq $8659			beq 	_IfFail 					; if fail, go to next line
.8658	60		rts				rts 								; if THEN just continue
.8659					_IfFail:
.8659	4c 9e 8a	jmp $8a9e			jmp 	EOLCommand
.865c					_IfStructured:
.865c	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; is it zero
.865f	d0 07		bne $8668			bne 	_IfExit 					; if not, then continue normally.
.8661	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8663	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8665	20 5f 8d	jsr $8d5f			jsr 	ScanForward 				; and run from there/
.8668					_IfExit:
.8668	60		rts				rts
.8669					ElseCode:
.8669	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.866b	aa		tax				tax 								; so just go to the structure exit
.866c	20 5f 8d	jsr $8d5f			jsr 	ScanForward
.866f	60		rts				rts
.8670					EndIf:
.8670	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8671					Command_Input:
.8671	a9 ff		lda #$ff			lda 	#$FF
.8673	8d 28 04	sta $0428			sta 	IsInputFlag
.8676	80 03		bra $867b			bra 	Command_IP_Main
.8678					Command_Print:
.8678	9c 28 04	stz $0428			stz 	IsInputFlag
.867b					Command_IP_Main:
.867b	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.867c					_CPLoop:
.867c	08		php				php 								; save last action flag
.867d	b1 30		lda ($30),y			lda 	(codePtr),y
.867f	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8681	f0 54		beq $86d7			beq 	_CPExit
.8683	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8685	f0 50		beq $86d7			beq 	_CPExit
.8687	68		pla				pla 								; throw last action flag
.8688	b1 30		lda ($30),y			lda 	(codePtr),y
.868a	c8		iny				iny
.868b	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.868d	f0 45		beq $86d4			beq 	_CPContinueWithSameLine
.868f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8691	f0 3c		beq $86cf			beq 	_CPTab
.8693	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8695	f0 34		beq $86cb			beq 	_CPNewLine
.8697	88		dey				dey 								; undo the get.
.8698	20 82 93	jsr $9382			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.869b	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.869d	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.869f	f0 0d		beq $86ae			beq 	_CPIsValue
.86a1	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.86a4	f0 05		beq $86ab			beq 	_CPIsPrint
.86a6	20 e0 86	jsr $86e0			jsr 	CIInputValue 				; input a value to the reference
.86a9	80 20		bra $86cb			bra 	_CPNewLine
.86ab					_CPIsPrint:
.86ab	20 47 96	jsr $9647			jsr 	Dereference
.86ae					_CPIsValue:
.86ae	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.86b0	29 10		and #$10			and 	#NSBIsString
.86b2	f0 09		beq $86bd			beq 	_CPNumber
.86b4	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.86b6	a5 58		lda $58				lda 	NSMantissa0
.86b8	20 43 87	jsr $8743			jsr 	CPPrintStringXA
.86bb	80 be		bra $867b			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86bd					_CPNumber:
.86bd	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86bf	20 c2 9b	jsr $9bc2			jsr 	ConvertNumberToString 		; convert to string
.86c2	a2 05		ldx #$05			ldx 	#DecimalBuffer >> 8
.86c4	a9 9d		lda #$9d			lda 	#DecimalBuffer & $FF
.86c6	20 43 87	jsr $8743			jsr 	CPPrintStringXA
.86c9	80 b0		bra $867b			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86cb					_CPNewLine:
.86cb	a9 0d		lda #$0d			lda 	#13
.86cd	80 02		bra $86d1			bra 	_CPPrintChar
.86cf					_CPTab:
.86cf	a9 09		lda #$09			lda 	#9 							; print TAB
.86d1					_CPPrintChar:
.86d1	20 56 87	jsr $8756			jsr 	CPPrintVector
.86d4					_CPContinueWithSameLine:
.86d4	38		sec				sec 								; loop round with carry set, which
.86d5	80 a5		bra $867c			bra 	_CPLoop 					; will inhibit final CR
.86d7					_CPExit:
.86d7	28		plp				plp 								; get last action flag
.86d8	b0 05		bcs $86df			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.86da	a9 0d		lda #$0d			lda 	#13 						; print new line
.86dc	20 56 87	jsr $8756			jsr 	CPPrintVector
.86df					_CPExit2:
.86df	60		rts				rts
.86e0					CIInputValue:
.86e0	a2 00		ldx #$00			ldx 	#0 							; input a line.
.86e2					_CIInputLine:
.86e2	20 59 87	jsr $8759			jsr 	CPInputVector 				; get key
.86e5	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.86e7	f0 1f		beq $8708			beq 	_CIHaveValue
.86e9	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.86eb	f0 11		beq $86fe			beq 	_CIBackspace
.86ed	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.86ef	90 f1		bcc $86e2			bcc 	_CIInputLine
.86f1	e0 50		cpx #$50			cpx 	#80 						; max length
.86f3	b0 ed		bcs $86e2			bcs 	_CIInputLine
.86f5	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.86f8	e8		inx				inx
.86f9	20 56 87	jsr $8756			jsr 	CPPrintVector 				; echo it.
.86fc	80 e4		bra $86e2			bra 	_CIInputLine
.86fe					_CIBackSpace:
.86fe	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8700	f0 e0		beq $86e2			beq 	_CIInputLine
.8702	20 56 87	jsr $8756			jsr 	CPPrintVector 				; echo it.
.8705	ca		dex				dex
.8706	80 da		bra $86e2			bra 	_CIInputLine
.8708					_CIHaveValue:
.8708	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.870b	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.870d	29 10		and #$10			and 	#NSBIsString
.870f	f0 17		beq $8728			beq 	_CIAssignNumber 			; assign a number
.8711	a2 01		ldx #$01			ldx 	#1
.8713	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8715	95 58		sta $58,x			sta 	NSMantissa0,x
.8717	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8719	95 60		sta $60,x			sta 	NSMantissa1,x
.871b	74 68		stz $68,x			stz 	NSMantissa2,x
.871d	74 70		stz $70,x			stz 	NSMantissa3,x
.871f	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8721	95 50		sta $50,x			sta  	NSStatus,x
.8723	ca		dex				dex 								; X = 0
.8724	20 95 87	jsr $8795			jsr 	AssignVariable
.8727	60		rts				rts
.8728					_CIAssignNumber:
.8728	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.872a	85 36		sta $36				sta 	zTemp0
.872c	a9 05		lda #$05			lda 	#lineBuffer >> 8
.872e	85 37		sta $37				sta 	zTemp0+1
.8730	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8732	20 44 9b	jsr $9b44			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8735	90 07		bcc $873e			bcc 	_CIIsOkay
.8737	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8739	20 56 87	jsr $8756			jsr 	CPPrintVector
.873c	80 a2		bra $86e0			bra 	CIInputValue
.873e					_CIIsOkay:
.873e	ca		dex				dex 								; X = 0
.873f	20 95 87	jsr $8795			jsr 	AssignVariable
.8742	60		rts				rts
.8743					CPPrintStringXA:
.8743	5a		phy				phy
.8744	86 37		stx $37				stx 	zTemp0+1
.8746	85 36		sta $36				sta 	zTemp0
.8748	a0 00		ldy #$00			ldy 	#0
.874a					_PSXALoop:
.874a	b1 36		lda ($36),y			lda 	(zTemp0),y
.874c	f0 06		beq $8754			beq 	_PSXAExit
.874e	20 56 87	jsr $8756			jsr 	CPPrintVector
.8751	c8		iny				iny
.8752	80 f6		bra $874a			bra 	_PSXALoop
.8754					_PSXAExit:
.8754	7a		ply				ply
.8755	60		rts				rts
.8756					CPPrintVector:
.8756	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.8759					CPInputVector:
.8759	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.875c					LetCommand:
.875c	a2 00		ldx #$00			ldx 	#0
.875e	b1 30		lda ($30),y			lda 	(codePtr),y
.8760	c9 10		cmp #$10			cmp 	#KWD_AT
.8762	d0 14		bne $8778			bne 	_LCStandard
.8764	c8		iny				iny 								; skip equal
.8765	20 ce 97	jsr $97ce			jsr 	EvaluateTerm 				; get a number
.8768	20 47 96	jsr $9647			jsr 	Dereference 				; dereference it
.876b	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.876d	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.876f	95 50		sta $50,x			sta 	NSStatus,x
.8771	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8773	d0 0f		bne $8784			bne 	_LCMain
.8775	4c 15 9f	jmp $9f15			jmp 	TypeError 					; was a reference before.
.8778					_LCStandard:
.8778	ad 6c 93	lda $936c			lda 	PrecedenceLevel+"*"			; precedence > this
.877b	20 86 93	jsr $9386			jsr 	EvaluateExpressionAtPrecedence
.877e	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array
.8780	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.8782	f0 0e		beq $8792			beq 	_LetGoProc 					; it's a procedure call.
.8784					_LCMain:
.8784	a9 3d		lda #$3d			lda 	#"=" 						; check =
.8786	20 77 8e	jsr $8e77			jsr 	CheckNextA
.8789	e8		inx				inx 								; RHS
.878a	20 d2 9c	jsr $9cd2			jsr 	EvaluateValue
.878d	ca		dex				dex
.878e	20 95 87	jsr $8795			jsr 	AssignVariable
.8791	60		rts				rts
.8792					_LetGoProc:
.8792	4c 79 89	jmp $8979			jmp 	CallProcedure
.8795					AssignVariable:
.8795	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8797	48		pha				pha 								; save a copy
.8798	55 51		eor $51,x			eor 	NSStatus+1,x
.879a	29 10		and #$10			and 	#NSBIsString
.879c	d0 0b		bne $87a9			bne 	_ASError
.879e	68		pla				pla 								; get back
.879f	29 10		and #$10			and 	#NSBIsString 				; check type
.87a1	d0 03		bne $87a6			bne 	_ASString
.87a3	4c 85 95	jmp $9585			jmp 	AssignNumber
.87a6					_ASString:
.87a6	4c e3 95	jmp $95e3			jmp 	AssignString
.87a9					_ASError:
.87a9	4c 15 9f	jmp $9f15			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87ac					Command_List:
.87ac	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.87af	b1 30		lda ($30),y			lda 	(codePtr),y
.87b1	29 c0		and #$c0			and 	#$C0
.87b3	c9 40		cmp #$40			cmp 	#$40
.87b5	f0 69		beq $8820			beq 	_CLListProcedure
.87b7	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87b9	64 64		stz $64				stz 	NSMantissa1+4
.87bb	a9 ff		lda #$ff			lda 	#$FF
.87bd	85 5f		sta $5f				sta 	NSMantissa0+7
.87bf	85 67		sta $67				sta 	NSMantissa1+7
.87c1	b1 30		lda ($30),y			lda 	(codePtr),y
.87c3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87c5	f0 1a		beq $87e1			beq 	_CLSecond
.87c7	20 9d 88	jsr $889d			jsr 	CLIsDigit 					; if not digit, list all
.87ca	b0 20		bcs $87ec			bcs 	_CLStart
.87cc	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.87ce	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger
.87d1	b1 30		lda ($30),y			lda 	(codePtr),y
.87d3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87d5	f0 0a		beq $87e1			beq 	_CLSecond 					; if so go get it
.87d7	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.87d9	85 5f		sta $5f				sta 	NSMantissa0+7
.87db	a5 64		lda $64				lda 	NSMantissa1+4
.87dd	85 67		sta $67				sta 	NSMantissa1+7
.87df	80 0b		bra $87ec			bra 	_CLStart
.87e1					_CLSecond:
.87e1	c8		iny				iny 								; consume comma
.87e2	20 9d 88	jsr $889d			jsr 	CLIsDigit 					; digit found
.87e5	b0 05		bcs $87ec			bcs 	_CLStart 					; if not, continue listing
.87e7	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.87e9	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger
.87ec					_CLStart
.87ec	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.87ee	85 30		sta $30				sta 	codePtr
.87f0	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.87f2	85 31		sta $31				sta 	codePtr+1
.87f4					_CLLoop:
.87f4	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.87f7	f0 24		beq $881d			beq 	_CLExit
.87f9	b2 30		lda ($30)			lda 	(codePtr)
.87fb	f0 20		beq $881d			beq 	_CLExit
.87fd	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.87ff	20 8c 88	jsr $888c			jsr 	CLCompareLineNo
.8802	90 0c		bcc $8810			bcc 	_CLNext
.8804	a2 07		ldx #$07			ldx 	#7
.8806	20 8c 88	jsr $888c			jsr 	CLCompareLineNo
.8809	f0 02		beq $880d			beq 	_CLDoThisOne
.880b	b0 03		bcs $8810			bcs 	_CLNext
.880d					_CLDoThisOne:
.880d	20 79 88	jsr $8879			jsr 	CLListOneLine
.8810					_CLNext:
.8810	18		clc				clc
.8811	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8813	65 30		adc $30				adc 	codePtr
.8815	85 30		sta $30				sta 	codePtr
.8817	90 02		bcc $881b			bcc 	_CREExit
.8819	e6 31		inc $31				inc 	codePtr+1 					; carry
.881b					_CREExit:
.881b	80 d7		bra $87f4			bra 	_CLLoop
.881d					_CLExit:
.881d	4c 46 83	jmp $8346			jmp 	WarmStart
.8820					_CLListProcedure:
.8820	b1 30		lda ($30),y			lda 	(codePtr),y
.8822	85 38		sta $38				sta 	zTemp1
.8824	c8		iny				iny
.8825	b1 30		lda ($30),y			lda 	(codePtr),y
.8827	85 39		sta $39				sta 	zTemp1+1
.8829	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.882b	85 30		sta $30				sta 	codePtr
.882d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.882f	85 31		sta $31				sta 	codePtr+1
.8831					_CLLPSearch:
.8831	b2 30		lda ($30)			lda 	(codePtr)
.8833	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.8835	f0 e6		beq $881d			beq 	_CLExit
.8837	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.8839	b1 30		lda ($30),y			lda 	(codePtr),y
.883b	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.883d	d0 0e		bne $884d			bne 	_CLLPNext
.883f	c8		iny				iny 								; check if PROC this.
.8840	b1 30		lda ($30),y			lda 	(codePtr),y
.8842	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8844	d0 07		bne $884d			bne 	_CLLPNext
.8846	c8		iny				iny
.8847	b1 30		lda ($30),y			lda 	(codePtr),y
.8849	c5 39		cmp $39				cmp 	zTemp1+1
.884b	f0 0d		beq $885a			beq 	_CLLPFound
.884d					_CLLPNext:
.884d	18		clc				clc
.884e	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8850	65 30		adc $30				adc 	codePtr
.8852	85 30		sta $30				sta 	codePtr
.8854	90 02		bcc $8858			bcc 	_CREExit
.8856	e6 31		inc $31				inc 	codePtr+1 					; carry
.8858					_CREExit:
.8858	80 d7		bra $8831			bra 	_CLLPSearch
.885a					_CLLPFound:
.885a	b2 30		lda ($30)			lda 	(codePtr)
.885c	f0 bf		beq $881d			beq 	_CLExit
.885e	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.8860	b1 30		lda ($30),y			lda 	(codePtr),y
.8862	48		pha				pha
.8863	20 79 88	jsr $8879			jsr 	CLListOneLine 				; list line and go forward
.8866	18		clc				clc
.8867	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8869	65 30		adc $30				adc 	codePtr
.886b	85 30		sta $30				sta 	codePtr
.886d	90 02		bcc $8871			bcc 	_CREExit
.886f	e6 31		inc $31				inc 	codePtr+1 					; carry
.8871					_CREExit:
.8871	68		pla				pla 								; reached ENDPROC ?
.8872	c9 a6		cmp #$a6			cmp 	#KWD_ENDPROC
.8874	d0 e4		bne $885a			bne 	_CLLPFound
.8876	4c 46 83	jmp $8346			jmp 	WarmStart
.8879					CLListOneLine:
.8879	20 c2 8d	jsr $8dc2			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.887c	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.887f	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8881	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8883	20 d9 8e	jsr $8ed9			jsr 	PrintStringXA
.8886	a9 0d		lda #$0d			lda 	#13 						; new line
.8888	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.888b	60		rts				rts
.888c					CLCompareLineNo:
.888c	38		sec				sec
.888d	a0 01		ldy #$01			ldy 	#1
.888f	b1 30		lda ($30),y			lda 	(codePtr),y
.8891	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8893	85 36		sta $36				sta 	zTemp0
.8895	c8		iny				iny
.8896	b1 30		lda ($30),y			lda 	(codePtr),y
.8898	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.889a	05 36		ora $36				ora 	zTemp0
.889c	60		rts				rts
.889d					CLIsDigit:
.889d	b1 30		lda ($30),y			lda 	(codePtr),y
.889f	c9 30		cmp #$30			cmp 	#"0"
.88a1	90 03		bcc $88a6			bcc	 	_CLIDExitFalse
.88a3	c9 3a		cmp #$3a			cmp 	#"9"+1
.88a5	60		rts				rts
.88a6					_CLIDExitFalse:
.88a6	38		sec				sec
.88a7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.88a8					Command_LOCAL:
.88a8	a2 00		ldx #$00			ldx 	#0 							; at level 0
.88aa	20 b6 88	jsr $88b6			jsr 	LocaliseNextTerm 			; convert term to a local.
.88ad	b1 30		lda ($30),y			lda 	(codePtr),y
.88af	c8		iny				iny
.88b0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.88b2	f0 f4		beq $88a8			beq 	Command_LOCAL
.88b4	88		dey				dey 								; unpick pre-get
.88b5	60		rts				rts
.88b6					LocaliseNextTerm:
.88b6	20 ce 97	jsr $97ce			jsr 	EvaluateTerm 				; evaluate the term
.88b9	b5 50		lda $50,x			lda 	NSStatus,x
.88bb	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.88bd	f0 5c		beq $891b			beq		_LNTError
.88bf	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.88c1	85 36		sta $36				sta 	zTemp0
.88c3	b5 60		lda $60,x			lda 	NSMantissa1,x
.88c5	85 37		sta $37				sta  	zTemp0+1
.88c7	b5 50		lda $50,x			lda 	NSStatus,x
.88c9	29 10		and #$10			and 	#NSBIsString
.88cb	d0 1e		bne $88eb			bne 	_LNTPushString
.88cd	5a		phy				phy
.88ce	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.88d0					_LNTPushNumLoop:
.88d0	b1 36		lda ($36),y			lda		(zTemp0),y
.88d2	20 ae a5	jsr $a5ae			jsr 	StackPushByte
.88d5	c8		iny				iny
.88d6	c0 05		cpy #$05			cpy 	#5
.88d8	d0 f6		bne $88d0			bne 	_LNTPushNumLoop
.88da	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.88dc	20 ae a5	jsr $a5ae			jsr 	StackPushByte
.88df	a5 37		lda $37				lda 	zTemp0+1
.88e1	20 ae a5	jsr $a5ae			jsr 	StackPushByte
.88e4	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88e6	20 ae a5	jsr $a5ae			jsr 	StackPushByte
.88e9	7a		ply				ply
.88ea	60		rts				rts
.88eb					_LNTPushString:
.88eb	5a		phy				phy
.88ec	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88ee	85 38		sta $38				sta 	zTemp1
.88f0	a0 01		ldy #$01			ldy 	#1
.88f2	b1 36		lda ($36),y			lda 	(zTemp0),y
.88f4	85 39		sta $39				sta 	zTemp1+1
.88f6	a0 00		ldy #$00			ldy 	#0 							; output string
.88f8	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88fa	f0 0a		beq $8906			beq 	_LNTStringOut
.88fc					_LNTPushStrLoop:
.88fc	b1 38		lda ($38),y			lda 	(zTemp1),y
.88fe	f0 06		beq $8906			beq 	_LNTStringOut
.8900	20 ae a5	jsr $a5ae			jsr 	StackPushByte
.8903	c8		iny				iny
.8904	80 f6		bra $88fc			bra 	_LNTPushStrLoop
.8906					_LNTStringOut:
.8906	98		tya				tya									; output length
.8907	20 ae a5	jsr $a5ae			jsr 	StackPushByte
.890a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.890c	20 ae a5	jsr $a5ae			jsr 	StackPushByte
.890f	b5 60		lda $60,x			lda 	NSMantissa1,x
.8911	20 ae a5	jsr $a5ae			jsr 	StackPushByte
.8914	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8916	20 ae a5	jsr $a5ae			jsr 	StackPushByte
.8919	7a		ply				ply
.891a	60		rts				rts
.891b					_LNTError:
.891b	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError
.891e					LocalPopValue:
.891e	20 c7 a5	jsr $a5c7			jsr 	StackPopByte
.8921	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8923	d0 17		bne $893c			bne 	_LPVString
.8925	20 c7 a5	jsr $a5c7			jsr 	StackPopByte 				; address
.8928	85 37		sta $37				sta 	zTemp0+1
.892a	20 c7 a5	jsr $a5c7			jsr 	StackPopByte
.892d	85 36		sta $36				sta 	zTemp0
.892f	5a		phy				phy
.8930	a0 04		ldy #$04			ldy 	#4 							; copy back
.8932					_LPVNumberCopy:
.8932	20 c7 a5	jsr $a5c7			jsr 	StackPopByte
.8935	91 36		sta ($36),y			sta 	(zTemp0),y
.8937	88		dey				dey
.8938	10 f8		bpl $8932			bpl 	_LPVNumberCopy
.893a	7a		ply				ply 								; and complete
.893b	60		rts				rts
.893c					_LPVString:
.893c	20 c7 a5	jsr $a5c7			jsr 	StackPopByte 				; address of record => zTemp0
.893f	85 37		sta $37				sta 	zTemp0+1
.8941	20 c7 a5	jsr $a5c7			jsr 	StackPopByte
.8944	85 36		sta $36				sta 	zTemp0
.8946	5a		phy				phy
.8947	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8949	85 38		sta $38				sta 	zTemp1
.894b	a0 01		ldy #$01			ldy 	#1
.894d	b1 36		lda ($36),y			lda 	(zTemp0),y
.894f	85 39		sta $39				sta 	zTemp1+1
.8951	20 c7 a5	jsr $a5c7			jsr 	StackPopByte 				; # to get => y
.8954	a8		tay				tay
.8955	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8957	f0 0e		beq $8967			beq 	_LPVStringCopied
.8959	a9 00		lda #$00			lda 	#0 							; NULL on end
.895b	91 38		sta ($38),y			sta 	(zTemp1),y
.895d					_LPVStringCopy:
.895d	88		dey				dey
.895e	30 07		bmi $8967			bmi 	_LPVStringCopied
.8960	20 c7 a5	jsr $a5c7			jsr 	StackPopByte
.8963	91 38		sta ($38),y			sta 	(zTemp1),y
.8965	80 f6		bra $895d			bra 	_LPVStringCopy
.8967					_LPVStringCopied:
.8967	fa		plx				plx
.8968	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8969					NewCommand:
.8969	20 6f 89	jsr $896f			jsr 	NewProgram 					; does the actual NEW.
.896c	4c 46 83	jmp $8346			jmp 	WarmStart 					; and warm starts straight away.
.896f					NewProgram:
.896f	20 db a4	jsr $a4db			jsr 	MemoryNew
.8972	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8975	20 dc 83	jsr $83dc			jsr 	ClearCommand 				; clear everything.
.8978	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8979					CallProcedure:
.8979	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.897b	b1 30		lda ($30),y			lda 	(codePtr),y
.897d	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.897f	f0 0c		beq $898d			beq 	_CPEndParam
.8981					_CPParamLoop:
.8981	20 d2 9c	jsr $9cd2			jsr 	EvaluateValue 				; get parameter onto stack
.8984	e8		inx				inx 								; bump next stack
.8985	b1 30		lda ($30),y			lda 	(codePtr),y
.8987	c8		iny				iny
.8988	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.898a	f0 f5		beq $8981			beq 	_CPParamLoop
.898c	88		dey				dey 								; unpick.
.898d					_CPEndParam:
.898d	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8990	c8		iny				iny									; skip right bracket
.8991	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8993	20 d0 a5	jsr $a5d0			jsr 	StackOpen
.8996	20 14 a6	jsr $a614			jsr 	STKSaveCodePosition 		; save loop position
.8999	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.899b	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.899d	a5 60		lda $60				lda 	NSMantissa1
.899f	85 37		sta $37				sta 	zTemp0+1
.89a1	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.89a3	b2 36		lda ($36)			lda 	(zTemp0)
.89a5	85 30		sta $30				sta 	safePtr
.89a7	b1 36		lda ($36),y			lda 	(zTemp0),y
.89a9	85 31		sta $31				sta 	safePtr+1
.89ab	c8		iny				iny
.89ac	b1 36		lda ($36),y			lda 	(zTemp0),y
.89ae	85 32		sta $32				sta 	safePtr+2
.89b0	c8		iny				iny
.89b1	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b3	85 33		sta $33				sta 	safePtr+3
.89b5	c8		iny				iny 								; get Y offset -> Y
.89b6	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b8	a8		tay				tay
.89b9	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.89bb	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check no parameters at the start
.89be	f0 13		beq $89d3			beq 	_ParamExit 					; if so, exit.
.89c0					_ParamExtract:
.89c0	ca		dex				dex 								; put a local term on the level before
.89c1	20 b6 88	jsr $88b6			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.89c4	20 95 87	jsr $8795			jsr 	AssignVariable 				; assign stacked value to the variable.
.89c7	e8		inx				inx 								; advance to next parameter to do.
.89c8	e8		inx				inx
.89c9	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.89cc	f0 05		beq $89d3			beq 	_ParamExit
.89ce	20 6f 8e	jsr $8e6f			jsr 	CheckComma 					; comma seperating parameters
.89d1	80 ed		bra $89c0			bra 	_ParamExtract
.89d3					_ParamExit:
.89d3	20 67 8e	jsr $8e67			jsr 	CheckRightBracket 			; check )
.89d6	60		rts				rts 								; and continue from here
.89d7					Command_ENDPROC:
.89d7	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.89d9	a2 14		ldx #$14			ldx 	#ERRID_PROC
.89db	20 fc a5	jsr $a5fc			jsr 	StackCheckFrame
.89de	20 25 a6	jsr $a625			jsr 	STKLoadCodePosition 		; restore code position
.89e1	20 ee a5	jsr $a5ee			jsr 	StackClose
.89e4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89e5					Command_Read:
.89e5	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89e7	20 ce 97	jsr $97ce			jsr 	EvaluateTerm
.89ea	b5 50		lda $50,x			lda 	NSStatus,x
.89ec	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89ee	f0 4a		beq $8a3a			beq 	_CRSyntax 					; check reference (bit 0)
.89f0	20 83 8a	jsr $8a83			jsr 	SwapDataCodePtrs 			; swap code and data
.89f3	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89f6	d0 20		bne $8a18			bne 	_CRContinueData
.89f8					_CRKeepSearching:
.89f8	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89fa	aa		tax				tax
.89fb	20 5f 8d	jsr $8d5f			jsr 	ScanForward
.89fe	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8a00	f0 16		beq $8a18			beq 	_CRHaveData 				; found it
.8a02	18		clc				clc
.8a03	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a05	65 30		adc $30				adc 	codePtr
.8a07	85 30		sta $30				sta 	codePtr
.8a09	90 02		bcc $8a0d			bcc 	_CREExit
.8a0b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a0d					_CREExit:
.8a0d	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8a0f	b2 30		lda ($30)			lda 	(codePtr)
.8a11	d0 e5		bne $89f8			bne 	_CRKeepSearching
.8a13	a9 0b		lda #$0b		lda	#11
.8a15	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.8a18					_CRHaveData:
.8a18					_CRContinueData:
.8a18	a2 01		ldx #$01			ldx 	#1
.8a1a	20 d2 9c	jsr $9cd2			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a1d	ca		dex				dex
.8a1e	20 95 87	jsr $8795			jsr		AssignVariable 				; do the assignment
.8a21	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data
.8a24	b1 30		lda ($30),y			lda 	(codePtr),y
.8a26	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a28	d0 04		bne $8a2e			bne 	_CRSwapBack
.8a2a	c8		iny				iny 								; consume comma
.8a2b	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8a2e					_CRSwapBack:
.8a2e	20 83 8a	jsr $8a83			jsr 	SwapDataCodePtrs			; swap them back.
.8a31	b1 30		lda ($30),y			lda 	(codePtr),y
.8a33	c8		iny				iny
.8a34	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a36	f0 ad		beq $89e5			beq 	Command_Read 				; if so go round again.
.8a38	88		dey				dey 								; unpick get.
.8a39	60		rts				rts
.8a3a					_CRSyntax:
.8a3a	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a3d					RemCommand:
.8a3d	b1 30		lda ($30),y			lda 	(codePtr),y
.8a3f	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a41	d0 06		bne $8a49			bne 	_RMExit
.8a43	c8		iny				iny 								; point to offset
.8a44	98		tya				tya 								; A = offset position
.8a45	38		sec				sec 								; add size +1 hence SEC
.8a46	71 30		adc ($30),y			adc 	(codePtr),y
.8a48	a8		tay				tay 								; make current position.
.8a49					_RMExit:
.8a49	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a4a					Command_REPEAT:
.8a4a	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a4c	20 d0 a5	jsr $a5d0			jsr 	StackOpen
.8a4f	20 14 a6	jsr $a614			jsr 	STKSaveCodePosition 		; save loop position
.8a52	60		rts				rts
.8a53					Command_UNTIL:
.8a53	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a55	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a57	20 fc a5	jsr $a5fc			jsr 	StackCheckFrame
.8a5a	a2 00		ldx #$00			ldx 	#0
.8a5c	20 db 9c	jsr $9cdb			jsr 	EvaluateNumber 				; work out the number
.8a5f	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; check if zero
.8a62	f0 04		beq $8a68			beq 	_CULoopBack 				; if so keep looping
.8a64	20 ee a5	jsr $a5ee			jsr 	StackClose		 			; return
.8a67	60		rts				rts
.8a68					_CULoopBack:
.8a68	20 25 a6	jsr $a625			jsr 	STKLoadCodePosition 		; loop back
.8a6b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a6c					Command_Restore:
.8a6c	20 83 8a	jsr $8a83			jsr 	SwapDataCodePtrs 			; swap code and data
.8a6f	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a71	85 30		sta $30				sta 	codePtr
.8a73	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a75	85 31		sta $31				sta 	codePtr+1
.8a77	20 83 8a	jsr $8a83			jsr 	SwapDataCodePtrs 			; put them back
.8a7a	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a7c	8d 1b 04	sta $041b			sta 	dataPointer+4
.8a7f	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8a82	60		rts				rts
.8a83					SwapDataCodePtrs:
.8a83	da		phx				phx
.8a84	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a86					_SDCPLoop:
.8a86	b5 30		lda $30,x			lda 	safePtr,x
.8a88	48		pha				pha
.8a89	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8a8c	95 30		sta $30,x			sta 	safePtr,x
.8a8e	68		pla				pla
.8a8f	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8a92	ca		dex				dex
.8a93	10 f1		bpl $8a86			bpl 	_SDCPLoop
.8a95	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8a98	8c 1b 04	sty $041b			sty 	dataPointer+4
.8a9b	a8		tay				tay
.8a9c	fa		plx				plx
.8a9d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a9e					EOLCommand:
.8a9e	18		clc				clc
.8a9f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8aa1	65 30		adc $30				adc 	codePtr
.8aa3	85 30		sta $30				sta 	codePtr
.8aa5	90 02		bcc $8aa9			bcc 	_CREExit
.8aa7	e6 31		inc $31				inc 	codePtr+1 					; carry
.8aa9					_CREExit:
.8aa9	80 0b		bra $8ab6			bra 	RunNewLine
.8aab					CommandRUN:
.8aab	20 dc 83	jsr $83dc			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8aae	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ab0	85 30		sta $30				sta 	codePtr
.8ab2	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8ab4	85 31		sta $31				sta 	codePtr+1
.8ab6					RUNNewLine:
.8ab6	b2 30		lda ($30)			lda 	(codePtr)
.8ab8	f0 72		beq $8b2c			beq 	CRNoProgram         		; no then END.
.8aba	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8abc	9a		txs				txs
.8abd					RUNCodePointerLine:
.8abd	a0 02		ldy #$02			ldy 	#2 							; start of program
.8abf					_CRIncMainLoop:
.8abf	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8ac2	d0 19		bne $8add			bne 	_CRNoBreakCheck
.8ac4	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8ac7	f0 5e		beq $8b27			beq 	_CRBreak
.8ac9	64 01		stz $01				stz 	1 							; access I/O Page 0
.8acb	38		sec				sec 								; calculate timer - LastTick
.8acc	ad 59 d6	lda $d659			lda 	$D659
.8acf	aa		tax				tax 								; saving timer in X
.8ad0	ed af 05	sbc $05af			sbc 	LastTick
.8ad3	c9 03		cmp #$03			cmp 	#3
.8ad5	90 06		bcc $8add			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8ad7	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.8ada	20 b8 9d	jsr $9db8			jsr 	TickHandler 							; go do the code.
.8add					_NoFireTick:
.8add					_CRNoBreakCheck:
.8add	c8		iny				iny
.8ade					_CRMainLoop:
.8ade	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8ae1	b1 30		lda ($30),y			lda 	(codePtr),y
.8ae3	10 10		bpl $8af5			bpl 	_CRNotKeyword
.8ae5	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8ae7	b0 04		bcs $8aed			bcs 	_CRIsKeyword
.8ae9	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8aeb	b0 34		bcs $8b21			bcs		_CRSyntaxError
.8aed					_CRIsKeyword:
.8aed	c8		iny				iny 								; consume command
.8aee	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8aef	aa		tax				tax 								; put in X for vector jump
.8af0	20 24 8b	jsr $8b24			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8af3	80 e9		bra $8ade			bra 	_CRMainLoop 				; and loop round
.8af5					_CRNotKeyword:
.8af5	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8af7	f0 c6		beq $8abf			beq 	_CRIncMainLoop
.8af9	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8afb	90 05		bcc $8b02			bcc 	_CRNotVariable
.8afd					_CRGoLet:
.8afd	20 5c 87	jsr $875c			jsr 	LetCommand
.8b00	80 dc		bra $8ade			bra 	_CRMainLoop
.8b02					_CRNotVariable:
.8b02	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8b04	f0 f7		beq $8afd			beq 	_CRGoLet
.8b06	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8b08	f0 f3		beq $8afd			beq 	_CRGoLet
.8b0a	c9 21		cmp #$21			cmp 	#KWD_PLING
.8b0c	f0 ef		beq $8afd			beq 	_CRGoLet
.8b0e	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8b10	f0 09		beq $8b1b			beq 	_CRGoRem
.8b12	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8b14	d0 0b		bne $8b21			bne 	_CRSyntaxError
.8b16	20 df 81	jsr $81df			jsr 	LabelHere
.8b19	80 c3		bra $8ade			bra 	_CRMainLoop
.8b1b					_CRGoRem:
.8b1b	c8		iny				iny
.8b1c	20 3d 8a	jsr $8a3d			jsr 	RemCommand
.8b1f	80 bd		bra $8ade			bra 	_CRMainLoop
.8b21					_CRSyntaxError:
.8b21	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError
.8b24					_CRCallVector0:
.8b24	7c c2 8b	jmp ($8bc2,x)			jmp 	(VectorSet0,x)
.8b27					_CRBreak:
.8b27	a9 01		lda #$01		lda	#1
.8b29	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.8b2c					CRNoProgram:
.8b2c	4c 01 85	jmp $8501			jmp 	EndCommand
.8b2f					Shift1Command:
.8b2f	b1 30		lda ($30),y			lda 	(codePtr),y
.8b31	c8		iny				iny
.8b32	0a		asl a				asl 	a
.8b33	aa		tax				tax
.8b34	7c 60 8c	jmp ($8c60,x)			jmp 	(VectorSet1,x)
.8b37					Shift2Command:
.8b37	b1 30		lda ($30),y			lda 	(codePtr),y
.8b39	c8		iny				iny
.8b3a	0a		asl a				asl 	a
.8b3b	aa		tax				tax
.8b3c	7c 80 8c	jmp ($8c80,x)			jmp 	(VectorSet2,x)
.8b3f					Unused1:
.8b3f					Unused2:
.8b3f					Unused3:
.8b3f					Unused4:
.8b3f	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError
>8b42							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b42					VectorSetPunc:
>8b42	38 91					.word	ShiftLeft                        ; $00 <<
>8b44	23 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8b46	19 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8b48	0b 9f					.word	SyntaxError                      ; $03 !!3
>8b4a	0b 9f					.word	SyntaxError                      ; $04 ><
>8b4c	2d 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b4e	3b 91					.word	ShiftRight                       ; $06 >>
>8b50	0b 9f					.word	SyntaxError                      ; $07 !!7
>8b52	0b 9f					.word	SyntaxError                      ; $08 !!8
>8b54	0b 9f					.word	SyntaxError                      ; $09 !!9
>8b56	0b 9f					.word	SyntaxError                      ; $0a !!10
>8b58	0b 9f					.word	SyntaxError                      ; $0b !!11
>8b5a	0b 9f					.word	SyntaxError                      ; $0c !!12
>8b5c	0b 9f					.word	SyntaxError                      ; $0d !!13
>8b5e	0b 9f					.word	SyntaxError                      ; $0e !!14
>8b60	0b 9f					.word	SyntaxError                      ; $0f !!15
>8b62	0b 9f					.word	SyntaxError                      ; $10 @
>8b64	0b 9f					.word	SyntaxError                      ; $11 !!17
>8b66	0b 9f					.word	SyntaxError                      ; $12 !!18
>8b68	0b 9f					.word	SyntaxError                      ; $13 [
>8b6a	e4 8f					.word	IntegerDivide                    ; $14 \
>8b6c	0b 9f					.word	SyntaxError                      ; $15 ]
>8b6e	76 92					.word	EorInteger                       ; $16 ^
>8b70	0b 9f					.word	SyntaxError                      ; $17 _
>8b72	0b 9f					.word	SyntaxError                      ; $18 `
>8b74	0b 9f					.word	SyntaxError                      ; $19 !!25
>8b76	0b 9f					.word	SyntaxError                      ; $1a !!26
>8b78	0b 9f					.word	SyntaxError                      ; $1b {
>8b7a	41 92					.word	OraInteger                       ; $1c |
>8b7c	0b 9f					.word	SyntaxError                      ; $1d }
>8b7e	0b 9f					.word	SyntaxError                      ; $1e ~
>8b80	0b 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b82	0b 9f					.word	SyntaxError                      ; $20
>8b84	ab 92					.word	WordIndirect                     ; $21 !
>8b86	0b 9f					.word	SyntaxError                      ; $22 "
>8b88	0b 9f					.word	SyntaxError                      ; $23 #
>8b8a	0b 9f					.word	SyntaxError                      ; $24 $
>8b8c	25 90					.word	IntegerModulus                   ; $25 %
>8b8e	0c 92					.word	AndInteger                       ; $26 &
>8b90	0b 9f					.word	SyntaxError                      ; $27 '
>8b92	0b 9f					.word	SyntaxError                      ; $28 (
>8b94	0b 9f					.word	SyntaxError                      ; $29 )
>8b96	93 90					.word	MulInteger                       ; $2a *
>8b98	ae 91					.word	AddInteger                       ; $2b +
>8b9a	0b 9f					.word	SyntaxError                      ; $2c ,
>8b9c	e7 91					.word	SubInteger                       ; $2d -
>8b9e	0b 9f					.word	SyntaxError                      ; $2e .
>8ba0	65 94					.word	FDivideCommand                   ; $2f /
>8ba2	0b 9f					.word	SyntaxError                      ; $30 0
>8ba4	0b 9f					.word	SyntaxError                      ; $31 1
>8ba6	0b 9f					.word	SyntaxError                      ; $32 2
>8ba8	0b 9f					.word	SyntaxError                      ; $33 3
>8baa	0b 9f					.word	SyntaxError                      ; $34 4
>8bac	0b 9f					.word	SyntaxError                      ; $35 5
>8bae	0b 9f					.word	SyntaxError                      ; $36 6
>8bb0	0b 9f					.word	SyntaxError                      ; $37 7
>8bb2	0b 9f					.word	SyntaxError                      ; $38 8
>8bb4	0b 9f					.word	SyntaxError                      ; $39 9
>8bb6	0b 9f					.word	SyntaxError                      ; $3a :
>8bb8	0b 9f					.word	SyntaxError                      ; $3b ;
>8bba	05 8f					.word	BinaryCompareLess                ; $3c <
>8bbc	fb 8e					.word	BinaryCompareEqual               ; $3d =
>8bbe	0f 8f					.word	BinaryCompareGreater             ; $3e >
>8bc0	cd 92					.word	ByteIndirect                     ; $3f ?
.8bc2					VectorSet0:
>8bc2	9e 8a					.word	EOLCommand                       ; $80 !0:EOF
>8bc4	2f 8b					.word	Shift1Command                    ; $81 !1:SH1
>8bc6	37 8b					.word	Shift2Command                    ; $82 !2:SH2
>8bc8	4a 99					.word	AbsUnary                         ; $83 ABS(
>8bca	58 99					.word	AllocUnary                       ; $84 ALLOC(
>8bcc	c8 99					.word	AscUnary                         ; $85 ASC(
>8bce	73 9b					.word	ChrUnary                         ; $86 CHR$(
>8bd0	5b a3					.word	UnaryEvent                       ; $87 EVENT(
>8bd2	f7 8e					.word	UnaryFalse                       ; $88 FALSE
>8bd4	d5 99					.word	FracUnary                        ; $89 FRAC(
>8bd6	f7 a2					.word	UnaryHit                         ; $8a HIT(
>8bd8	ea 99					.word	IntUnary                         ; $8b INT(
>8bda	32 9b					.word	IsValUnary                       ; $8c ISVAL(
>8bdc	df a3					.word	UnaryJoyB                        ; $8d JOYB(
>8bde	b8 a3					.word	UnaryJoyX                        ; $8e JOYX(
>8be0	bb a3					.word	UnaryJoyY                        ; $8f JOYY(
>8be2	46 9c					.word	Unary_Left                       ; $90 LEFT$(
>8be4	fb 99					.word	LenUnary                         ; $91 LEN(
>8be6	19 9a					.word	Unary_Max                        ; $92 MAX(
>8be8	68 9c					.word	Unary_Mid                        ; $93 MID$(
>8bea	15 9a					.word	Unary_Min                        ; $94 MIN(
>8bec	64 9a					.word	Unary_Not                        ; $95 NOT(
>8bee	2c a5					.word	UnaryPlaying                     ; $96 PLAYING(
>8bf0	77 9a					.word	Unary_Random                     ; $97 RANDOM(
>8bf2	53 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8bf4	94 9a					.word	Unary_Rnd                        ; $99 RND(
>8bf6	0a 9b					.word	SgnUnary                         ; $9a SGN(
>8bf8	85 9b					.word	SpcUnary                         ; $9b SPC(
>8bfa	a0 9b					.word	Unary_Str                        ; $9c STR$(
>8bfc	05 a4					.word	UnaryTimer                       ; $9d TIMER(
>8bfe	ec 8e					.word	UnaryTrue                        ; $9e TRUE
>8c00	28 9b					.word	ValUnary                         ; $9f VAL(
>8c02	04 85					.word	ForCommand                       ; $a0 FOR
>8c04	47 86					.word	IfCommand                        ; $a1 IF
>8c06	3f 8b					.word	Unused1                          ; $a2 PROC
>8c08	4a 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8c0a	d5 8d					.word	Command_WHILE                    ; $a4 WHILE
>8c0c	70 86					.word	EndIf                            ; $a5 ENDIF
>8c0e	d7 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8c10	b6 85					.word	NextCommand                      ; $a7 NEXT
>8c12	3f 8b					.word	Unused4                          ; $a8 THEN
>8c14	53 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8c16	f6 8d					.word	Command_WEND                     ; $aa WEND
>8c18	0b 9f					.word	SyntaxError                      ; $ab BY
>8c1a	a7 83					.word	CallCommand                      ; $ac CALL
>8c1c	ab a0					.word	CircleCommand                    ; $ad CIRCLE
>8c1e	dc 83					.word	ClearCommand                     ; $ae CLEAR
>8c20	34 84					.word	ClearScreen                      ; $af CLS
>8c22	0b 9f					.word	SyntaxError                      ; $b0 COLOR
>8c24	0b 9f					.word	SyntaxError                      ; $b1 COLOUR
>8c26	3c 84					.word	Command_Data                     ; $b2 DATA
>8c28	44 84					.word	DimCommand                       ; $b3 DIM
>8c2a	3f 8b					.word	Unused3                          ; $b4 DOWNTO
>8c2c	69 86					.word	ElseCode                         ; $b5 ELSE
>8c2e	0b 9f					.word	SyntaxError                      ; $b6 FROM
>8c30	ca a2					.word	GfxCommand                       ; $b7 GFX
>8c32	0f 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c34	2d 86					.word	GotoCommand                      ; $b9 GOTO
>8c36	0b 9f					.word	SyntaxError                      ; $ba HERE
>8c38	d4 a0					.word	ImageCommand                     ; $bb IMAGE
>8c3a	71 86					.word	Command_Input                    ; $bc INPUT
>8c3c	5c 87					.word	LetCommand                       ; $bd LET
>8c3e	26 a1					.word	LineCommand                      ; $be LINE
>8c40	a8 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c42	0b 9f					.word	SyntaxError                      ; $c0 OFF
>8c44	0b 9f					.word	SyntaxError                      ; $c1 ON
>8c46	0b 9f					.word	SyntaxError                      ; $c2 OUTLINE
>8c48	1b a3					.word	PaletteCommand                   ; $c3 PALETTE
>8c4a	1f a1					.word	PlotCommand                      ; $c4 PLOT
>8c4c	78 86					.word	Command_Print                    ; $c5 PRINT
>8c4e	e5 89					.word	Command_Read                     ; $c6 READ
>8c50	a7 a0					.word	RectangleCommand                 ; $c7 RECT
>8c52	3d 8a					.word	RemCommand                       ; $c8 REM
>8c54	1f 86					.word	Command_RETURN                   ; $c9 RETURN
>8c56	0b 9f					.word	SyntaxError                      ; $ca SOLID
>8c58	48 a5					.word	SoundCommand                     ; $cb SOUND
>8c5a	b6 a0					.word	SpriteCommand                    ; $cc SPRITE
>8c5c	f0 a0					.word	TextCommand                      ; $cd TEXT
>8c5e	3f 8b					.word	Unused2                          ; $ce TO
.8c60					VectorSet1:
>8c60	0b 9f					.word	SyntaxError                      ; $80 !0:EOF
>8c62	0b 9f					.word	SyntaxError                      ; $81 !1:SH1
>8c64	0b 9f					.word	SyntaxError                      ; $82 !2:SH2
>8c66	7b 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c68	97 83					.word	AssertCommand                    ; $84 ASSERT
>8c6a	6a a2					.word	BitmapCtrl                       ; $85 BITMAP
>8c6c	01 85					.word	EndCommand                       ; $86 END
>8c6e	fc a3					.word	GoCommand                        ; $87 GO
>8c70	ac 87					.word	Command_List                     ; $88 LIST
>8c72	f3 a3					.word	LoadCommand                      ; $89 LOAD
>8c74	69 89					.word	NewCommand                       ; $8a NEW
>8c76	6c 8a					.word	Command_Restore                  ; $8b RESTORE
>8c78	ab 8a					.word	CommandRUN                       ; $8c RUN
>8c7a	af a2					.word	SpritesCtrl                      ; $8d SPRITES
>8c7c	08 8d					.word	StopCommand                      ; $8e STOP
>8c7e	04 8e					.word	WhoCommand                       ; $8f WHO
.8c80					VectorSet2:
>8c80	0b 9f					.word	SyntaxError                      ; $80 !0:EOF
>8c82	0b 9f					.word	SyntaxError                      ; $81 !1:SH1
>8c84	0b 9f					.word	SyntaxError                      ; $82 !2:SH2
>8c86	ca 9d					.word	Assemble_adc                     ; $83 ADC
>8c88	c2 9d					.word	Assemble_and                     ; $84 AND
>8c8a	de 9d					.word	Assemble_asl                     ; $85 ASL
>8c8c	48 9e					.word	Assemble_bcc                     ; $86 BCC
>8c8e	4c 9e					.word	Assemble_bcs                     ; $87 BCS
>8c90	54 9e					.word	Assemble_beq                     ; $88 BEQ
>8c92	0b 9e					.word	Assemble_bit                     ; $89 BIT
>8c94	3c 9e					.word	Assemble_bmi                     ; $8a BMI
>8c96	50 9e					.word	Assemble_bne                     ; $8b BNE
>8c98	38 9e					.word	Assemble_bpl                     ; $8c BPL
>8c9a	58 9e					.word	Assemble_bra                     ; $8d BRA
>8c9c	5c 9e					.word	Assemble_brk                     ; $8e BRK
>8c9e	40 9e					.word	Assemble_bvc                     ; $8f BVC
>8ca0	44 9e					.word	Assemble_bvs                     ; $90 BVS
>8ca2	64 9e					.word	Assemble_clc                     ; $91 CLC
>8ca4	b8 9e					.word	Assemble_cld                     ; $92 CLD
>8ca6	78 9e					.word	Assemble_cli                     ; $93 CLI
>8ca8	a8 9e					.word	Assemble_clv                     ; $94 CLV
>8caa	d6 9d					.word	Assemble_cmp                     ; $95 CMP
>8cac	1f 9e					.word	Assemble_cpx                     ; $96 CPX
>8cae	1a 9e					.word	Assemble_cpy                     ; $97 CPY
>8cb0	fc 9d					.word	Assemble_dec                     ; $98 DEC
>8cb2	b4 9e					.word	Assemble_dex                     ; $99 DEX
>8cb4	90 9e					.word	Assemble_dey                     ; $9a DEY
>8cb6	c6 9d					.word	Assemble_eor                     ; $9b EOR
>8cb8	01 9e					.word	Assemble_inc                     ; $9c INC
>8cba	c4 9e					.word	Assemble_inx                     ; $9d INX
>8cbc	b0 9e					.word	Assemble_iny                     ; $9e INY
>8cbe	33 9e					.word	Assemble_jmp                     ; $9f JMP
>8cc0	2e 9e					.word	Assemble_jsr                     ; $a0 JSR
>8cc2	d2 9d					.word	Assemble_lda                     ; $a1 LDA
>8cc4	f7 9d					.word	Assemble_ldx                     ; $a2 LDX
>8cc6	15 9e					.word	Assemble_ldy                     ; $a3 LDY
>8cc8	e8 9d					.word	Assemble_lsr                     ; $a4 LSR
>8cca	c8 9e					.word	Assemble_nop                     ; $a5 NOP
>8ccc	be 9d					.word	Assemble_ora                     ; $a6 ORA
>8cce	74 9e					.word	Assemble_pha                     ; $a7 PHA
>8cd0	60 9e					.word	Assemble_php                     ; $a8 PHP
>8cd2	bc 9e					.word	Assemble_phx                     ; $a9 PHX
>8cd4	7c 9e					.word	Assemble_phy                     ; $aa PHY
>8cd6	84 9e					.word	Assemble_pla                     ; $ab PLA
>8cd8	68 9e					.word	Assemble_plp                     ; $ac PLP
>8cda	d0 9e					.word	Assemble_plx                     ; $ad PLX
>8cdc	8c 9e					.word	Assemble_ply                     ; $ae PLY
>8cde	e3 9d					.word	Assemble_rol                     ; $af ROL
>8ce0	ed 9d					.word	Assemble_ror                     ; $b0 ROR
>8ce2	70 9e					.word	Assemble_rti                     ; $b1 RTI
>8ce4	80 9e					.word	Assemble_rts                     ; $b2 RTS
>8ce6	da 9d					.word	Assemble_sbc                     ; $b3 SBC
>8ce8	6c 9e					.word	Assemble_sec                     ; $b4 SEC
>8cea	cc 9e					.word	Assemble_sed                     ; $b5 SED
>8cec	88 9e					.word	Assemble_sei                     ; $b6 SEI
>8cee	ce 9d					.word	Assemble_sta                     ; $b7 STA
>8cf0	c0 9e					.word	Assemble_stp                     ; $b8 STP
>8cf2	f2 9d					.word	Assemble_stx                     ; $b9 STX
>8cf4	10 9e					.word	Assemble_sty                     ; $ba STY
>8cf6	06 9e					.word	Assemble_stz                     ; $bb STZ
>8cf8	a4 9e					.word	Assemble_tax                     ; $bc TAX
>8cfa	a0 9e					.word	Assemble_tay                     ; $bd TAY
>8cfc	29 9e					.word	Assemble_trb                     ; $be TRB
>8cfe	24 9e					.word	Assemble_tsb                     ; $bf TSB
>8d00	ac 9e					.word	Assemble_tsx                     ; $c0 TSX
>8d02	94 9e					.word	Assemble_txa                     ; $c1 TXA
>8d04	9c 9e					.word	Assemble_txs                     ; $c2 TXS
>8d06	98 9e					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8d08					StopCommand:
.8d08	a9 08		lda #$08		lda	#8
.8d0a	4c 80 8e	jmp $8e80		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8d0d					ProcedureScan:
.8d0d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8d0f	85 30		sta $30				sta 	codePtr
.8d11	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8d13	85 31		sta $31				sta 	codePtr+1
.8d15					_PSLoop:
.8d15	b2 30		lda ($30)			lda 	(codePtr)
.8d17	f0 42		beq $8d5b			beq 	_PSExit
.8d19	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8d1b	b1 30		lda ($30),y			lda 	(codePtr),y
.8d1d	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8d1f	d0 2d		bne $8d4e			bne 	_PSNext
.8d21	c8		iny				iny 								; get the address of the record to zTemp0 and
.8d22	b1 30		lda ($30),y			lda 	(codePtr),y
.8d24	29 c0		and #$c0			and 	#$C0
.8d26	c9 40		cmp #$40			cmp 	#$40
.8d28	d0 32		bne $8d5c			bne 	_PSSyntax
.8d2a	b1 30		lda ($30),y			lda 	(codePtr),y
.8d2c	18		clc				clc
.8d2d	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d2f	85 37		sta $37				sta 	zTemp0+1
.8d31	c8		iny				iny 								; LSB
.8d32	b1 30		lda ($30),y			lda 	(codePtr),y
.8d34	85 36		sta $36				sta 	zTemp0
.8d36	c8		iny				iny 								; character after variable call.
.8d37	98		tya				tya 								; save Y offset at +7
.8d38	a0 07		ldy #$07			ldy 	#7
.8d3a	91 36		sta ($36),y			sta 	(zTemp0),y
.8d3c	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d3e	a0 02		ldy #$02			ldy 	#2
.8d40	91 36		sta ($36),y			sta 	(zTemp0),y
.8d42	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d44					_PSCopy:
.8d44	b5 30		lda $30,x			lda 	safePtr,x
.8d46	c8		iny				iny
.8d47	91 36		sta ($36),y			sta 	(zTemp0),y
.8d49	e8		inx				inx
.8d4a	e0 04		cpx #$04			cpx 	#4
.8d4c	d0 f6		bne $8d44			bne 	_PSCopy
.8d4e					_PSNext:
.8d4e	18		clc				clc
.8d4f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d51	65 30		adc $30				adc 	codePtr
.8d53	85 30		sta $30				sta 	codePtr
.8d55	90 02		bcc $8d59			bcc 	_CREExit
.8d57	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d59					_CREExit:
.8d59	80 ba		bra $8d15			bra 	_PSLoop
.8d5b					_PSExit:
.8d5b	60		rts				rts
.8d5c					_PSSyntax:
.8d5c	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d5f					ScanForward:
.8d5f	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d61	86 37		stx $37				stx 	zTemp0+1
.8d63	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d65					_ScanLoop:
.8d65	b1 30		lda ($30),y			lda 	(codePtr),y
.8d67	c8		iny				iny
.8d68	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d6a	d0 0e		bne $8d7a			bne 	_ScanGoNext
.8d6c	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d6e	f0 04		beq $8d74			beq 	_ScanMatch
.8d70	c5 37		cmp $37				cmp 	zTemp0+1
.8d72	d0 06		bne $8d7a			bne 	_ScanGoNext
.8d74					_ScanMatch:
.8d74	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d76	d0 01		bne $8d79			bne 	_ScanNotEndEOL
.8d78	88		dey				dey
.8d79					_ScanNotEndEOL:
.8d79	60		rts				rts
.8d7a					_ScanGoNext:
.8d7a	20 7f 8d	jsr $8d7f			jsr  	ScanForwardOne
.8d7d	80 e6		bra $8d65			bra 	_ScanLoop
.8d7f					ScanForwardOne:
.8d7f	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d81	90 3e		bcc $8dc1			bcc 	_SFWExit
.8d83	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d85	90 18		bcc $8d9f			bcc 	_ScanSkipOne
.8d87	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d89	b0 2f		bcs $8dba			bcs 	_ScanSkipData
.8d8b	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d8d	90 32		bcc $8dc1			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d8f	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d91	b0 2e		bcs $8dc1			bcs 	_SFWExit
.8d93	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d95	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d97	b0 28		bcs $8dc1			bcs 	_SFWExit
.8d99	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d9b	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8d9d	80 22		bra $8dc1			bra 	_SFWExit
.8d9f					_ScanSkipOne:
.8d9f	c8		iny				iny 								; consume the extra one.
.8da0	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8da2	d0 1d		bne $8dc1			bne 	_SFWExit
.8da4	18		clc				clc
.8da5	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8da7	65 30		adc $30				adc 	codePtr
.8da9	85 30		sta $30				sta 	codePtr
.8dab	90 02		bcc $8daf			bcc 	_CREExit
.8dad	e6 31		inc $31				inc 	codePtr+1 					; carry
.8daf					_CREExit:
.8daf	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8db1	b2 30		lda ($30)			lda 	(codePtr)
.8db3	d0 0c		bne $8dc1			bne 	_SFWExit 					; if not zero, more to scan
.8db5	a9 13		lda #$13		lda	#19
.8db7	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.8dba					_ScanSkipData:
.8dba	88		dey				dey 								; point at data token
.8dbb	c8		iny				iny 								; point to offset
.8dbc	98		tya				tya 								; A = offset position
.8dbd	38		sec				sec 								; add size +1 hence SEC
.8dbe	71 30		adc ($30),y			adc 	(codePtr),y
.8dc0	a8		tay				tay 								; make current position.
.8dc1					_SFWExit:
.8dc1	60		rts				rts
.8dc2					ScanGetCurrentLineStep:
.8dc2	64 38		stz $38				stz 	zTemp1
.8dc4	a0 03		ldy #$03			ldy 	#3
.8dc6					_SGCLSLoop:
.8dc6	b1 30		lda ($30),y			lda 	(codePtr),y
.8dc8	c8		iny				iny
.8dc9	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8dcb	f0 05		beq $8dd2			beq 	_SGCLSExit
.8dcd	20 7f 8d	jsr $8d7f			jsr 	ScanForwardOne
.8dd0	80 f4		bra $8dc6			bra 	_SGCLSLoop
.8dd2					_SGCLSExit:
.8dd2	a5 38		lda $38				lda 	zTemp1
.8dd4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8dd5					Command_WHILE:
.8dd5	5a		phy				phy 								; save position of the test
.8dd6	a2 00		ldx #$00			ldx 	#0
.8dd8	20 db 9c	jsr $9cdb			jsr 	EvaluateNumber 				; work out the number
.8ddb	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; check if zero
.8dde	f0 0e		beq $8dee			beq 	_WHExitLoop 				; if so exit the loop
.8de0	98		tya				tya 								; position *after* test.
.8de1	7a		ply				ply 								; restore position before test, at WHILE
.8de2	88		dey				dey
.8de3	48		pha				pha 								; push after test on the stack
.8de4	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8de6	20 d0 a5	jsr $a5d0			jsr 	StackOpen
.8de9	20 14 a6	jsr $a614			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8dec	7a		ply				ply 								; restore the position *after* the test
.8ded	60		rts				rts
.8dee					_WHExitLoop:
.8dee	68		pla				pla 								; throw post loop position
.8def	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8df1	aa		tax				tax
.8df2	20 5f 8d	jsr $8d5f			jsr 	ScanForward
.8df5	60		rts				rts
.8df6					Command_WEND:
.8df6	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8df8	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8dfa	20 fc a5	jsr $a5fc			jsr 	StackCheckFrame
.8dfd	20 25 a6	jsr $a625			jsr 	STKLoadCodePosition 		; loop back
.8e00	20 ee a5	jsr $a5ee			jsr 	StackClose		 			; erase the frame
.8e03	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8e04					WhoCommand:
.8e04	a2 8e		ldx #$8e			ldx 	#(_WHOMessage >> 8)
.8e06	a9 0c		lda #$0c			lda 	#(_WHOMessage & $FF)
.8e08	20 d9 8e	jsr $8ed9			jsr 	PrintStringXA
.8e0b	60		rts				rts
.8e0c					_WHOMessage:
>8e0c	81						.byte 	$81
>8e0d	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8e15	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8e22	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8e2a	20 41 6c 6c 61 69 72 65 0d
>8e33	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8e3b	4f 62 65 72 72 65 75 74 65 72 0d
>8e46	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8e4e	62 73 6f 6e 0d
>8e53	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8e5b	65 69 6e 67 61 72 74 6e 65 72 0d
>8e66	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8e67					CheckRightBracket:
.8e67	b1 30		lda ($30),y			lda 	(codePtr),y
.8e69	c8		iny				iny
.8e6a	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8e6c	d0 0f		bne $8e7d			bne 	CNAFail
.8e6e	60		rts				rts
.8e6f					CheckComma:
.8e6f	b1 30		lda ($30),y			lda 	(codePtr),y
.8e71	c8		iny				iny
.8e72	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8e74	d0 07		bne $8e7d			bne 	CNAFail
.8e76	60		rts				rts
.8e77					CheckNextA:
.8e77	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8e79	d0 02		bne $8e7d			bne 	CNAFail
.8e7b	c8		iny				iny 								; skip character
.8e7c	60		rts				rts 								; and exit
.8e7d					CNAFail:
.8e7d	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8e80					ErrorHandler:
.8e80	a8		tay				tay 								; find the error text
.8e81	f0 49		beq $8ecc			beq 	_EHEnd
.8e83	a2 00		ldx #$00			ldx 	#0
.8e85	a9 24		lda #$24			lda 	#((ErrorText) & $FF)
.8e87	85 36		sta $36				sta 	0+zTemp0
.8e89	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8e8b	85 37		sta $37				sta 	1+zTemp0
.8e8d					_EHFind:
.8e8d	88		dey				dey 								; found the error text ?
.8e8e	f0 0e		beq $8e9e			beq 	_EHFound
.8e90					_EHFindZero:
.8e90	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e92	e6 36		inc $36				inc 	zTemp0
.8e94	d0 02		bne $8e98			bne 	_EHFNoCarry
.8e96	e6 37		inc $37				inc 	zTemp0+1
.8e98					_EHFNoCarry:
.8e98	c9 00		cmp #$00			cmp 	#0
.8e9a	d0 f4		bne $8e90			bne 	_EHFindZero
.8e9c	80 ef		bra $8e8d			bra 	_EHFind
.8e9e					_EHFound:
.8e9e	a5 36		lda $36				lda 	zTemp0 						; print message
.8ea0	a6 37		ldx $37				ldx 	zTemp0+1
.8ea2	20 d9 8e	jsr $8ed9			jsr 	PrintStringXA
.8ea5	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8ea7	b1 30		lda ($30),y			lda 	(codePtr),y
.8ea9	d0 05		bne $8eb0			bne 	_EHAtMsg
.8eab	c8		iny				iny
.8eac	b1 30		lda ($30),y			lda 	(codePtr),y
.8eae	f0 17		beq $8ec7			beq 	_EHCREnd
.8eb0					_EHAtMsg:
.8eb0	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8eb2	a9 cf		lda #$cf			lda 	#_AtMsg & $FF
.8eb4	20 d9 8e	jsr $8ed9			jsr 	PrintStringXA
.8eb7	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8eb9	b1 30		lda ($30),y			lda 	(codePtr),y
.8ebb	48		pha				pha
.8ebc	c8		iny				iny
.8ebd	b1 30		lda ($30),y			lda 	(codePtr),y
.8ebf	aa		tax				tax
.8ec0	68		pla				pla
.8ec1	20 ef 92	jsr $92ef			jsr 	ConvertInt16 				; convert XA to string
.8ec4	20 d9 8e	jsr $8ed9			jsr 	PrintStringXA 				; and print it.
.8ec7					_EHCREnd:
.8ec7	a9 0d		lda #$0d			lda 	#13 						; new line
.8ec9	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8ecc					_EHEnd:
.8ecc	4c 46 83	jmp $8346			jmp 	WarmStart
>8ecf	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8ed7	20 00
.8ed9					PrintStringXA:
.8ed9	5a		phy				phy
.8eda	86 37		stx $37				stx 	zTemp0+1
.8edc	85 36		sta $36				sta 	zTemp0
.8ede	a0 00		ldy #$00			ldy 	#0
.8ee0					_PSXALoop:
.8ee0	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ee2	f0 06		beq $8eea			beq 	_PSXAExit
.8ee4	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8ee7	c8		iny				iny
.8ee8	80 f6		bra $8ee0			bra 	_PSXALoop
.8eea					_PSXAExit:
.8eea	7a		ply				ply
.8eeb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8eec					UnaryTrue:
.8eec	fa		plx				plx
.8eed					ReturnTrue:
.8eed	a9 01		lda #$01			lda 	#1  						; set to 1
.8eef	20 8f 9d	jsr $9d8f			jsr 	NSMSetByte
.8ef2	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8ef4	95 50		sta $50,x			sta 	NSStatus,x
.8ef6	60		rts				rts
.8ef7					UnaryFalse:
.8ef7	fa		plx				plx
.8ef8					ReturnFalse:
.8ef8	4c 8d 9d	jmp $9d8d			jmp 	NSMSetZero 					; set it all to zero
.8efb					BinaryCompareEqual:
.8efb	fa		plx				plx
.8efc	20 37 8f	jsr $8f37			jsr 	CompareBaseCode
.8eff	c9 00		cmp #$00			cmp 	#0
.8f01	f0 ea		beq $8eed			beq 	ReturnTrue
.8f03	80 f3		bra $8ef8			bra 	ReturnFalse
.8f05					BinaryCompareLess:
.8f05	fa		plx				plx
.8f06	20 37 8f	jsr $8f37			jsr 	CompareBaseCode
.8f09	c9 ff		cmp #$ff			cmp 	#$FF
.8f0b	f0 e0		beq $8eed			beq 	ReturnTrue
.8f0d	80 e9		bra $8ef8			bra 	ReturnFalse
.8f0f					BinaryCompareGreater:
.8f0f	fa		plx				plx
.8f10	20 37 8f	jsr $8f37			jsr 	CompareBaseCode
.8f13	c9 01		cmp #$01			cmp 	#1
.8f15	f0 d6		beq $8eed			beq 	ReturnTrue
.8f17	80 df		bra $8ef8			bra 	ReturnFalse
.8f19					BinaryCompareNotEqual:
.8f19	fa		plx				plx
.8f1a	20 37 8f	jsr $8f37			jsr 	CompareBaseCode
.8f1d	c9 00		cmp #$00			cmp 	#0
.8f1f	d0 cc		bne $8eed			bne 	ReturnTrue
.8f21	80 d5		bra $8ef8			bra 	ReturnFalse
.8f23					BinaryCompareLessEqual:
.8f23	fa		plx				plx
.8f24	20 37 8f	jsr $8f37			jsr 	CompareBaseCode
.8f27	c9 01		cmp #$01			cmp 	#1
.8f29	d0 c2		bne $8eed			bne 	ReturnTrue
.8f2b	80 cb		bra $8ef8			bra 	ReturnFalse
.8f2d					BinaryCompareGreaterEqual:
.8f2d	fa		plx				plx
.8f2e	20 37 8f	jsr $8f37			jsr 	CompareBaseCode
.8f31	c9 ff		cmp #$ff			cmp 	#$FF
.8f33	d0 b8		bne $8eed			bne 	ReturnTrue
.8f35	80 c1		bra $8ef8			bra 	ReturnFalse
.8f37					CompareBaseCode:
.8f37	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; make both values if references.
.8f3a	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8f3c	15 51		ora $51,x			ora 	NSStatus+1,x
.8f3e	29 10		and #$10			and 	#NSTString
.8f40	d0 37		bne $8f79			bne 	_CBCString 					; if so do string code, which will check if both.
.8f42	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8f44	15 79		ora $79,x			ora 	NSExponent+1,x
.8f46	d0 34		bne $8f7c			bne 	_CBCFloat
.8f48	b5 50		lda $50,x			lda 	NSStatus,x
.8f4a	15 51		ora $51,x			ora 	NSStatus+1,x
.8f4c	29 08		and #$08			and 	#NSTFloat
.8f4e	d0 2c		bne $8f7c			bne 	_CBCFloat
.8f50	20 7f 8f	jsr $8f7f			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8f53	e8		inx				inx
.8f54	20 7f 8f	jsr $8f7f			jsr 	CompareFixMinusZero
.8f57	ca		dex				dex
.8f58	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8f5a	55 51		eor $51,x			eor 	NSStatus+1,x
.8f5c	10 0a		bpl $8f68			bpl 	_CDCSameSign
.8f5e	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8f60	30 14		bmi $8f76			bmi 	_CBCLess 					; return $FF
.8f62					_CBCGreater:
.8f62	a9 01		lda #$01			lda 	#1
.8f64	60		rts				rts
.8f65					_CBCEqual:
.8f65	a9 00		lda #$00			lda 	#0
.8f67	60		rts				rts
.8f68					_CDCSameSign:
.8f68	20 94 91	jsr $9194			jsr 	SubTopTwoStack 				; unsigned subtract
.8f6b	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; or the mantissa together
.8f6e	f0 f5		beq $8f65			beq 	_CBCEqual 					; -0 == 0
.8f70	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8f72	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8f74	10 ec		bpl $8f62			bpl 	_CBCGreater
.8f76					_CBCLess:
.8f76	a9 ff		lda #$ff			lda 	#$FF
.8f78	60		rts				rts
.8f79					_CBCString:
.8f79	4c 05 91	jmp $9105			jmp 	CompareStrings
.8f7c					_CBCFloat:
.8f7c	4c 4f 94	jmp $944f			jmp 	CompareFloat
.8f7f					CompareFixMinusZero:
.8f7f	20 af 9d	jsr $9daf			jsr 	NSMIsZero
.8f82	d0 02		bne $8f86			bne 	_CFXMZNotZero
.8f84	74 50		stz $50,x			stz 	NSStatus,x
.8f86					_CFXMZNotZero:
.8f86	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f87					StringConcat:
.8f87	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.8f89	35 51		and $51,x			and 	NSStatus+1,x
.8f8b	29 18		and #$18			and 	#NSBTypeMask
.8f8d	c9 10		cmp #$10			cmp 	#NSTString
.8f8f	d0 50		bne $8fe1			bne		_SCType
.8f91	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f93	e8		inx				inx
.8f94	20 b2 8f	jsr $8fb2			jsr 	_SCSetupZ0 					; setup for second
.8f97	20 bb 8f	jsr $8fbb			jsr 	_SCLengthZ0 				; length for second
.8f9a	ca		dex				dex
.8f9b	20 b2 8f	jsr $8fb2			jsr 	_SCSetupZ0 					; setup for first
.8f9e	20 bb 8f	jsr $8fbb			jsr 	_SCLengthZ0 				; length for first
.8fa1	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.8fa3	20 bf a6	jsr $a6bf			jsr 	StringTempAllocate
.8fa6	20 d2 8f	jsr $8fd2			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8fa9	e8		inx				inx
.8faa	20 b2 8f	jsr $8fb2			jsr 	_SCSetupZ0 					; copy second out
.8fad	20 d2 8f	jsr $8fd2			jsr 	_SCCopy
.8fb0	ca		dex				dex
.8fb1	60		rts				rts
.8fb2					_SCSetupZ0:
.8fb2	b5 58		lda $58,x			lda 	NSMantissa0,x
.8fb4	85 36		sta $36				sta 	zTemp0
.8fb6	b5 60		lda $60,x			lda 	NSMantissa1,x
.8fb8	85 37		sta $37				sta 	zTemp0+1
.8fba	60		rts				rts
.8fbb					_SCLengthZ0:
.8fbb	5a		phy				phy
.8fbc	a0 00		ldy #$00			ldy 	#0
.8fbe					_SCLenLoop:
.8fbe	b1 36		lda ($36),y			lda 	(zTemp0),y
.8fc0	f0 0e		beq $8fd0			beq 	_SCLExit
.8fc2	c8		iny				iny
.8fc3	e6 38		inc $38				inc 	zTemp1
.8fc5	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.8fc7	c9 fd		cmp #$fd			cmp 	#253
.8fc9	d0 f3		bne $8fbe			bne		_SCLenLoop
.8fcb	a9 09		lda #$09		lda	#9
.8fcd	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.8fd0					_SCLExit:
.8fd0	7a		ply				ply
.8fd1	60		rts				rts
.8fd2					_SCCopy:
.8fd2	5a		phy				phy
.8fd3	a0 00		ldy #$00			ldy 	#0
.8fd5					_SCCopyLoop:
.8fd5	b1 36		lda ($36),y			lda 	(zTemp0),y
.8fd7	f0 06		beq $8fdf			beq 	_SCCExit
.8fd9	20 f8 a6	jsr $a6f8			jsr 	StringTempWrite
.8fdc	c8		iny				iny
.8fdd	80 f6		bra $8fd5			bra 	_SCCopyLoop
.8fdf					_SCCExit:
.8fdf	7a		ply				ply
.8fe0	60		rts				rts
.8fe1					_SCType:
.8fe1	4c 15 9f	jmp $9f15			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8fe4					IntegerDivide:
.8fe4	fa		plx				plx
.8fe5	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.8fe7	15 51		ora $51,x			ora 	NSStatus+1,x
.8fe9	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fea	0a		asl a				asl 	a
.8feb	10 05		bpl $8ff2			bpl 	_NotRef
.8fed	48		pha				pha
.8fee	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8ff1	68		pla				pla
.8ff2					_NotRef:
.8ff2	0a		asl a				asl 	a
.8ff3	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8ff5	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8ff7	15 79		ora $79,x			ora 	NSExponent+1,x
.8ff9	f0 03		beq $8ffe			beq 	_IntegerCode 				; if clear, then we have two integers
.8ffb	4c 15 9f	jmp $9f15			jmp 	TypeError 					; anything else, type mismatch.
.8ffe					_IntegerCode:
.8ffe	20 18 90	jsr $9018			jsr 	CheckDivideZero 			; do div zero check
.9001	20 4a 90	jsr $904a			jsr 	Int32Divide 				; do the division
.9004	20 fb 90	jsr $90fb			jsr 	CalculateSign 				; calculate result sign
.9007					NSMCopyPlusTwoToZero:
.9007	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.9009	95 58		sta $58,x			sta 	NSMantissa0,x
.900b	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.900d	95 60		sta $60,x			sta 	NSMantissa1,x
.900f	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.9011	95 68		sta $68,x			sta 	NSMantissa2,x
.9013	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.9015	95 70		sta $70,x			sta 	NSMantissa3,x
.9017	60		rts				rts
.9018					CheckDivideZero:
.9018	e8		inx				inx
.9019	20 af 9d	jsr $9daf			jsr 	NSMIsZero
.901c	f0 02		beq $9020			beq 	_CDVError
.901e	ca		dex				dex
.901f	60		rts				rts
.9020					_CDVError:
.9020	a9 03		lda #$03		lda	#3
.9022	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.9025					IntegerModulus:
.9025	fa		plx				plx
.9026	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9028	15 51		ora $51,x			ora 	NSStatus+1,x
.902a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.902b	0a		asl a				asl 	a
.902c	10 05		bpl $9033			bpl 	_NotRef
.902e	48		pha				pha
.902f	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9032	68		pla				pla
.9033					_NotRef:
.9033	0a		asl a				asl 	a
.9034	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9036	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9038	15 79		ora $79,x			ora 	NSExponent+1,x
.903a	f0 03		beq $903f			beq 	_IntegerCode 				; if clear, then we have two integers
.903c	4c 15 9f	jmp $9f15			jmp 	TypeError 					; anything else, type mismatch.
.903f					_IntegerCode:
.903f					IntegerModulusNoCheck:
.903f	20 18 90	jsr $9018			jsr 	CheckDivideZero 			; do div zero check
.9042	20 4a 90	jsr $904a			jsr 	Int32Divide 				; do the division
.9045	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9047	56 50		lsr $50,x			lsr 	NSStatus,x
.9049	60		rts				rts
.904a					Int32Divide:
.904a	48		pha				pha 								; save AXY
.904b	5a		phy				phy
.904c	20 70 9d	jsr $9d70			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.904f	20 89 9d	jsr $9d89			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.9052	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.9054					_I32DivideLoop:
.9054	e8		inx				inx
.9055	e8		inx				inx
.9056	20 9c 9d	jsr $9d9c			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.9059	ca		dex				dex
.905a	ca		dex				dex
.905b	20 9d 9d	jsr $9d9d			jsr 	NSMRotateLeft
.905e	20 89 90	jsr $9089			jsr 	DivideCheckSubtract 		; check if subtract possible
.9061	90 02		bcc $9065			bcc 	_I32DivideNoCarryIn
.9063	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9065					_I32DivideNoCarryIn:
.9065	88		dey				dey 								; loop round till division completed.
.9066	d0 ec		bne $9054			bne 	_I32DivideLoop
.9068	7a		ply				ply 								; restore AXY and exit
.9069	68		pla				pla
.906a	60		rts				rts
.906b					Int32ShiftDivide:
.906b	48		pha				pha 								; save AY
.906c	5a		phy				phy
.906d	e8		inx				inx 								; clear S[X+2]
.906e	e8		inx				inx
.906f	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero
.9072	ca		dex				dex
.9073	ca		dex				dex
.9074	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9076					_I32SDLoop:
.9076	20 89 90	jsr $9089			jsr 	DivideCheckSubtract 		; check if subtract possible
.9079	e8		inx				inx
.907a	e8		inx				inx
.907b	20 9d 9d	jsr $9d9d			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.907e	ca		dex				dex
.907f	ca		dex				dex
.9080	20 9d 9d	jsr $9d9d			jsr 	NSMRotateLeft
.9083	88		dey				dey 	 							; do 31 times
.9084	d0 f0		bne $9076			bne 	_I32SDLoop
.9086	7a		ply				ply 								; restore AY and exit
.9087	68		pla				pla
.9088	60		rts				rts
.9089					DivideCheckSubtract:
.9089	20 94 91	jsr $9194			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.908c	b0 04		bcs $9092			bcs 	_DCSExit 					; if carry set, then could do, exit
.908e	20 7a 91	jsr $917a			jsr 	AddTopTwoStack 				; add it back in
.9091	18		clc				clc 								; and return False
.9092					_DCSExit:
.9092	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9093					MulInteger:
.9093	fa		plx				plx
.9094	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9096	15 51		ora $51,x			ora 	NSStatus+1,x
.9098	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9099	0a		asl a				asl 	a
.909a	10 05		bpl $90a1			bpl 	_NotRef
.909c	48		pha				pha
.909d	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90a0	68		pla				pla
.90a1					_NotRef:
.90a1	0a		asl a				asl 	a 							; put MSB of type into A:7
.90a2	30 09		bmi $90ad			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.90a4	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90a6	15 79		ora $79,x			ora 	NSExponent+1,x
.90a8	f0 06		beq $90b0			beq 	_IntegerCode 				; if clear, then we have two integers
.90aa	4c 11 95	jmp $9511			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.90ad					_StringData:
.90ad	4c 1f 9f	jmp $9f1f			jmp 	NotDoneError							; at least one string - don't know both are strings.
.90b0					_IntegerCode:
.90b0	20 bd 90	jsr $90bd			jsr 	MultiplyShort
.90b3	c9 00		cmp #$00			cmp 	#0
.90b5	f0 05		beq $90bc			beq 	_MIExit
.90b7	a9 04		lda #$04		lda	#4
.90b9	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.90bc					_MIExit:
.90bc	60		rts				rts
.90bd					MultiplyShort:
.90bd	5a		phy				phy 								; save Y
.90be	20 70 9d	jsr $9d70			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90c1	20 89 9d	jsr $9d89			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.90c4	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.90c6					_I32MLoop:
.90c6	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.90c8	15 62		ora $62,x			ora 	NSMantissa1+2,x
.90ca	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.90cc	15 72		ora $72,x			ora 	NSMantissa3+2,x
.90ce	f0 25		beq $90f5			beq 	_I32MExit 					; exit if zero
.90d0	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.90d2	29 01		and #$01			and 	#1
.90d4	f0 0d		beq $90e3			beq 	_I32MNoAdd
.90d6	20 7a 91	jsr $917a			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.90d9	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.90db	10 06		bpl $90e3			bpl 	_I32MNoAdd
.90dd					_I32ShiftRight:
.90dd	20 a6 9d	jsr $9da6			jsr 	NSMShiftRight 				; shift S[X] right
.90e0	c8		iny				iny 								; increment shift count
.90e1	80 09		bra $90ec			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.90e3					_I32MNoAdd:
.90e3	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.90e5	70 f6		bvs $90dd			bvs 	_I32ShiftRight 				; instead.
.90e7	e8		inx				inx
.90e8	20 9c 9d	jsr $9d9c			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.90eb	ca		dex				dex
.90ec					_I32MShiftUpper:
.90ec	e8		inx				inx 								; shift S[X+2] right
.90ed	e8		inx				inx
.90ee	20 a6 9d	jsr $9da6			jsr 	NSMShiftRight
.90f1	ca		dex				dex
.90f2	ca		dex				dex
.90f3	80 d1		bra $90c6			bra 	_I32MLoop 					; try again.
.90f5					_I32MExit:
.90f5	20 fb 90	jsr $90fb			jsr 	CalculateSign
.90f8	98		tya				tya 								; shift in A
.90f9	7a		ply				ply 								; restore Y and exit
.90fa	60		rts				rts
.90fb					CalculateSign:
.90fb	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.90fd	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.90ff	55 51		eor $51,x			eor 	NSStatus+1,x
.9101	0a		asl a				asl 	a 							; shift bit 7 into carry
.9102	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.9104	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9105					CompareStrings:
.9105	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.9107	35 51		and $51,x			and 	NSStatus+1,x
.9109	29 10		and #$10			and 	#NSBIsString
.910b	f0 28		beq $9135			beq 	_CSTypeError
.910d	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.910f	85 36		sta $36				sta 	zTemp0
.9111	b5 60		lda $60,x			lda 	NSMantissa1,x
.9113	85 37		sta $37				sta 	zTemp0+1
.9115	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9117	85 38		sta $38				sta 	zTemp1
.9119	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.911b	85 39		sta $39				sta 	zTemp1+1
.911d	5a		phy				phy 								; save Y so we can access strings
.911e	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.9120					_CSLoop:
.9120	c8		iny				iny
.9121	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.9123	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.9125	d0 06		bne $912d			bne 	_CSDifferent
.9127	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9129	d0 f5		bne $9120			bne 	_CSLoop 					; still comparing
.912b					_CSExit:
.912b	7a		ply				ply 								; reached end, return zero in A from EOS
.912c	60		rts				rts
.912d					_CSDifferent:
.912d	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.912f	90 fa		bcc $912b			bcc		_CSExit
.9131	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9133	80 f6		bra $912b			bra 	_CSExit
.9135					_CSTypeError:
.9135	4c 15 9f	jmp $9f15			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9138					ShiftLeft:
.9138	38		sec				sec 								; common code, carry determines which way.
.9139	80 01		bra $913c			bra 	ShiftMain
.913b					ShiftRight:
.913b	18		clc				clc
.913c					ShiftMain:
.913c	fa		plx				plx 								; restore X
.913d	08		php				php 								; save direction
.913e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9140	15 51		ora $51,x			ora 	NSStatus+1,x
.9142	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9143	0a		asl a				asl 	a
.9144	10 05		bpl $914b			bpl 	_NotRef
.9146	48		pha				pha
.9147	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.914a	68		pla				pla
.914b					_NotRef:
.914b	0a		asl a				asl 	a
.914c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.914e	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9150	15 79		ora $79,x			ora 	NSExponent+1,x
.9152	f0 03		beq $9157			beq 	_IntegerCode 				; if clear, then we have two integers
.9154	4c 15 9f	jmp $9f15			jmp 	TypeError 					; anything else, type mismatch.
.9157					_IntegerCode:
.9157	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.9159	29 e0		and #$e0			and 	#$E0
.915b	15 61		ora $61,x			ora 	NSMantissa1+1,x
.915d	15 69		ora $69,x			ora 	NSMantissa2+1,x
.915f	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9161	d0 12		bne $9175			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9163					_SMLoop:
.9163	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9165	30 11		bmi $9178			bmi 	_SMExit 					; exit if done.
.9167	28		plp				plp 								; restore direction setting
.9168	08		php				php
.9169	90 05		bcc $9170			bcc 	_SMRight
.916b	20 9c 9d	jsr $9d9c			jsr 	NSMShiftLeft 				; shift left if CS
.916e	80 f3		bra $9163			bra 	_SMLoop
.9170					_SMRight:
.9170	20 a6 9d	jsr $9da6			jsr 	NSMShiftRight 				; shift right if CC
.9173	80 ee		bra $9163			bra 	_SMLoop
.9175					_SMExit0:
.9175	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero 					; return zero.
.9178					_SMExit:
.9178	28		plp				plp 								; throw direction
.9179	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.917a					AddTopTwoStack:
.917a	18		clc				clc
.917b	b5 58		lda $58,x			lda		NSMantissa0,x
.917d	75 59		adc $59,x			adc 		NSMantissa0+1,x
.917f	95 58		sta $58,x			sta 	NSMantissa0,x
.9181	b5 60		lda $60,x			lda		NSMantissa1,x
.9183	75 61		adc $61,x			adc 		NSMantissa1+1,x
.9185	95 60		sta $60,x			sta 	NSMantissa1,x
.9187	b5 68		lda $68,x			lda		NSMantissa2,x
.9189	75 69		adc $69,x			adc 		NSMantissa2+1,x
.918b	95 68		sta $68,x			sta 	NSMantissa2,x
.918d	b5 70		lda $70,x			lda		NSMantissa3,x
.918f	75 71		adc $71,x			adc 		NSMantissa3+1,x
.9191	95 70		sta $70,x			sta 	NSMantissa3,x
.9193	60		rts				rts
.9194					SubTopTwoStack:
.9194	38		sec				sec
.9195	b5 58		lda $58,x			lda		NSMantissa0,x
.9197	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.9199	95 58		sta $58,x			sta 	NSMantissa0,x
.919b	b5 60		lda $60,x			lda		NSMantissa1,x
.919d	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.919f	95 60		sta $60,x			sta 	NSMantissa1,x
.91a1	b5 68		lda $68,x			lda		NSMantissa2,x
.91a3	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.91a5	95 68		sta $68,x			sta 	NSMantissa2,x
.91a7	b5 70		lda $70,x			lda		NSMantissa3,x
.91a9	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.91ab	95 70		sta $70,x			sta 	NSMantissa3,x
.91ad	60		rts				rts
.91ae					AddInteger:
.91ae	fa		plx				plx
.91af	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91b1	15 51		ora $51,x			ora 	NSStatus+1,x
.91b3	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91b4	0a		asl a				asl 	a
.91b5	10 05		bpl $91bc			bpl 	_NotRef
.91b7	48		pha				pha
.91b8	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91bb	68		pla				pla
.91bc					_NotRef:
.91bc	0a		asl a				asl 	a 							; put MSB of type into A:7
.91bd	30 09		bmi $91c8			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91bf	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91c1	15 79		ora $79,x			ora 	NSExponent+1,x
.91c3	f0 06		beq $91cb			beq 	_IntegerCode 				; if clear, then we have two integers
.91c5	4c c1 93	jmp $93c1			jmp 	FloatingPointAdd 							; otherwise at least one float.
.91c8					_StringData:
.91c8	4c 87 8f	jmp $8f87			jmp 	StringConcat							; at least one string - don't know both are strings.
.91cb					_IntegerCode:
.91cb					AddCode:
.91cb	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.91cd	55 51		eor $51,x			eor 	NSStatus+1,x
.91cf	10 a9		bpl $917a			bpl 	AddTopTwoStack
.91d1	20 94 91	jsr $9194			jsr 	SubTopTwoStack 				; do a physical subtraction
.91d4	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.91d6	10 07		bpl $91df			bpl 	_AddExit
.91d8	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.91da	95 50		sta $50,x			sta 	NSStatus,x
.91dc	20 56 9d	jsr $9d56			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.91df					_AddExit:
.91df	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; check for -0
.91e2	d0 02		bne $91e6			bne 	_AddNonZero
.91e4	74 50		stz $50,x			stz 	NSStatus,x
.91e6					_AddNonZero:
.91e6	60		rts				rts
.91e7					SubInteger:
.91e7	fa		plx				plx
.91e8	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91ea	15 51		ora $51,x			ora 	NSStatus+1,x
.91ec	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91ed	0a		asl a				asl 	a
.91ee	10 05		bpl $91f5			bpl 	_NotRef
.91f0	48		pha				pha
.91f1	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f4	68		pla				pla
.91f5					_NotRef:
.91f5	0a		asl a				asl 	a 							; put MSB of type into A:7
.91f6	30 09		bmi $9201			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91f8	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91fa	15 79		ora $79,x			ora 	NSExponent+1,x
.91fc	f0 06		beq $9204			beq 	_IntegerCode 				; if clear, then we have two integers
.91fe	4c c6 93	jmp $93c6			jmp 	FloatingPointSub 							; otherwise at least one float.
.9201					_StringData:
.9201	4c 1f 9f	jmp $9f1f			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9204					_IntegerCode:
.9204	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.9206	49 80		eor #$80			eor 	#$80
.9208	95 51		sta $51,x			sta 	NSStatus+1,x
.920a	80 bf		bra $91cb			bra 	AddCode 					; and do the same code as add.
.920c					AndInteger:
.920c	fa		plx				plx
.920d	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.920f	15 51		ora $51,x			ora 	NSStatus+1,x
.9211	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9212	0a		asl a				asl 	a
.9213	10 05		bpl $921a			bpl 	_NotRef
.9215	48		pha				pha
.9216	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9219	68		pla				pla
.921a					_NotRef:
.921a	0a		asl a				asl 	a
.921b	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.921d	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.921f	15 79		ora $79,x			ora 	NSExponent+1,x
.9221	f0 03		beq $9226			beq 	_IntegerCode 				; if clear, then we have two integers
.9223	4c 15 9f	jmp $9f15			jmp 	TypeError 					; anything else, type mismatch.
.9226					_IntegerCode:
.9226	b5 58		lda $58,x			lda		NSMantissa0,x
.9228	35 59		and $59,x			and 		NSMantissa0+1,x
.922a	95 58		sta $58,x			sta 	NSMantissa0,x
.922c	b5 60		lda $60,x			lda		NSMantissa1,x
.922e	35 61		and $61,x			and 		NSMantissa1+1,x
.9230	95 60		sta $60,x			sta 	NSMantissa1,x
.9232	b5 68		lda $68,x			lda		NSMantissa2,x
.9234	35 69		and $69,x			and 		NSMantissa2+1,x
.9236	95 68		sta $68,x			sta 	NSMantissa2,x
.9238	b5 70		lda $70,x			lda		NSMantissa3,x
.923a	35 71		and $71,x			and 		NSMantissa3+1,x
.923c	95 70		sta $70,x			sta 	NSMantissa3,x
.923e	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9240	60		rts				rts
.9241					OraInteger:
.9241	fa		plx				plx
.9242	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9244	15 51		ora $51,x			ora 	NSStatus+1,x
.9246	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9247	0a		asl a				asl 	a
.9248	10 05		bpl $924f			bpl 	_NotRef
.924a	48		pha				pha
.924b	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.924e	68		pla				pla
.924f					_NotRef:
.924f	0a		asl a				asl 	a
.9250	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9252	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9254	15 79		ora $79,x			ora 	NSExponent+1,x
.9256	f0 03		beq $925b			beq 	_IntegerCode 				; if clear, then we have two integers
.9258	4c 15 9f	jmp $9f15			jmp 	TypeError 					; anything else, type mismatch.
.925b					_IntegerCode:
.925b	b5 58		lda $58,x			lda		NSMantissa0,x
.925d	15 59		ora $59,x			ora 		NSMantissa0+1,x
.925f	95 58		sta $58,x			sta 	NSMantissa0,x
.9261	b5 60		lda $60,x			lda		NSMantissa1,x
.9263	15 61		ora $61,x			ora 		NSMantissa1+1,x
.9265	95 60		sta $60,x			sta 	NSMantissa1,x
.9267	b5 68		lda $68,x			lda		NSMantissa2,x
.9269	15 69		ora $69,x			ora 		NSMantissa2+1,x
.926b	95 68		sta $68,x			sta 	NSMantissa2,x
.926d	b5 70		lda $70,x			lda		NSMantissa3,x
.926f	15 71		ora $71,x			ora 		NSMantissa3+1,x
.9271	95 70		sta $70,x			sta 	NSMantissa3,x
.9273	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9275	60		rts				rts
.9276					EorInteger:
.9276	fa		plx				plx
.9277	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9279	15 51		ora $51,x			ora 	NSStatus+1,x
.927b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.927c	0a		asl a				asl 	a
.927d	10 05		bpl $9284			bpl 	_NotRef
.927f	48		pha				pha
.9280	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9283	68		pla				pla
.9284					_NotRef:
.9284	0a		asl a				asl 	a
.9285	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9287	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9289	15 79		ora $79,x			ora 	NSExponent+1,x
.928b	f0 03		beq $9290			beq 	_IntegerCode 				; if clear, then we have two integers
.928d	4c 15 9f	jmp $9f15			jmp 	TypeError 					; anything else, type mismatch.
.9290					_IntegerCode:
.9290	b5 58		lda $58,x			lda		NSMantissa0,x
.9292	55 59		eor $59,x			eor 		NSMantissa0+1,x
.9294	95 58		sta $58,x			sta 	NSMantissa0,x
.9296	b5 60		lda $60,x			lda		NSMantissa1,x
.9298	55 61		eor $61,x			eor 		NSMantissa1+1,x
.929a	95 60		sta $60,x			sta 	NSMantissa1,x
.929c	b5 68		lda $68,x			lda		NSMantissa2,x
.929e	55 69		eor $69,x			eor 		NSMantissa2+1,x
.92a0	95 68		sta $68,x			sta 	NSMantissa2,x
.92a2	b5 70		lda $70,x			lda		NSMantissa3,x
.92a4	55 71		eor $71,x			eor 		NSMantissa3+1,x
.92a6	95 70		sta $70,x			sta 	NSMantissa3,x
.92a8	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92aa	60		rts				rts
.92ab					WordIndirect:
.92ab	fa		plx				plx
.92ac	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92ae	15 51		ora $51,x			ora 	NSStatus+1,x
.92b0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92b1	0a		asl a				asl 	a
.92b2	10 05		bpl $92b9			bpl 	_NotRef
.92b4	48		pha				pha
.92b5	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92b8	68		pla				pla
.92b9					_NotRef:
.92b9	0a		asl a				asl 	a
.92ba	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92bc	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92be	15 79		ora $79,x			ora 	NSExponent+1,x
.92c0	f0 03		beq $92c5			beq 	_IntegerCode 				; if clear, then we have two integers
.92c2	4c 15 9f	jmp $9f15			jmp 	TypeError 					; anything else, type mismatch.
.92c5					_IntegerCode:
.92c5	20 cb 91	jsr $91cb			jsr 	AddCode 					; add the two values
.92c8	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.92ca	95 50		sta $50,x			sta 	NSStatus,x
.92cc	60		rts				rts
.92cd					ByteIndirect:
.92cd	fa		plx				plx
.92ce	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92d0	15 51		ora $51,x			ora 	NSStatus+1,x
.92d2	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92d3	0a		asl a				asl 	a
.92d4	10 05		bpl $92db			bpl 	_NotRef
.92d6	48		pha				pha
.92d7	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92da	68		pla				pla
.92db					_NotRef:
.92db	0a		asl a				asl 	a
.92dc	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92de	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92e0	15 79		ora $79,x			ora 	NSExponent+1,x
.92e2	f0 03		beq $92e7			beq 	_IntegerCode 				; if clear, then we have two integers
.92e4	4c 15 9f	jmp $9f15			jmp 	TypeError 					; anything else, type mismatch.
.92e7					_IntegerCode:
.92e7	20 cb 91	jsr $91cb			jsr 	AddCode 					; add the two values
.92ea	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.92ec	95 50		sta $50,x			sta 	NSStatus,x
.92ee	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.92ef					ConvertInt16:
.92ef	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.92f1	86 60		stx $60				stx 	NSMantissa1
.92f3	64 68		stz $68				stz 	NSMantissa2
.92f5	64 70		stz $70				stz 	NSMantissa3
.92f7	64 50		stz $50				stz 	NSStatus 					; positive integer
.92f9	a2 00		ldx #$00			ldx 	#0 							; stack level
.92fb	a9 0a		lda #$0a			lda 	#10 						; base
.92fd	80 00		bra $92ff			bra 	ConvertInt32
.92ff					ConvertInt32:
.92ff	5a		phy				phy
.9300	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9302	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.9304	10 08		bpl $930e			bpl 	_CI32NotNeg
.9306	48		pha				pha
.9307	a9 2d		lda #$2d			lda 	#'-'
.9309	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.930c	c8		iny				iny
.930d	68		pla				pla
.930e					_CI32NotNeg:
.930e	20 1c 93	jsr $931c			jsr 	_CI32DivideConvert 			; recursive conversion
.9311	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9313	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.9316	7a		ply				ply
.9317	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.9319	a9 7b		lda #$7b			lda 	#NumberBuffer & $FF
.931b	60		rts				rts
.931c					_CI32DivideConvert:
.931c	e8		inx				inx 								; write to next slot up
.931d	20 8f 9d	jsr $9d8f			jsr 	NSMSetByte
.9320	ca		dex				dex
.9321	20 4a 90	jsr $904a			jsr 	Int32Divide 				; divide
.9324	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.9326	48		pha				pha
.9327	20 07 90	jsr $9007			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.932a	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; is it zero ?
.932d	f0 05		beq $9334			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.932f	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9331	20 1c 93	jsr $931c			jsr 	_CI32DivideConvert 			; and recusrively call.
.9334					_CI32NoRecurse:
.9334	68		pla				pla 								; remainder
.9335	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.9337	90 02		bcc $933b			bcc 	_CI32NotHex
.9339	69 26		adc #$26			adc 	#6+32
.933b					_CI32NotHex:
.933b	69 30		adc #$30			adc 	#48
.933d	99 7b 05	sta $057b,y			sta 	NumberBuffer,y 				; write out and exit
.9340	c8		iny				iny
.9341	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9342					PrecedenceLevel:
>9342	04					.byte	 4	; $00 <<
>9343	02					.byte	 2	; $01 <=
>9344	02					.byte	 2	; $02 <>
>9345	00					.byte	 0	; $03 !!3
>9346	00					.byte	 0	; $04 ><
>9347	02					.byte	 2	; $05 >=
>9348	04					.byte	 4	; $06 >>
>9349	00					.byte	 0	; $07 !!7
>934a	00					.byte	 0	; $08 !!8
>934b	00					.byte	 0	; $09 !!9
>934c	00					.byte	 0	; $0a !!10
>934d	00					.byte	 0	; $0b !!11
>934e	00					.byte	 0	; $0c !!12
>934f	00					.byte	 0	; $0d !!13
>9350	00					.byte	 0	; $0e !!14
>9351	00					.byte	 0	; $0f !!15
>9352	00					.byte	 0	; $10 @
>9353	00					.byte	 0	; $11 !!17
>9354	00					.byte	 0	; $12 !!18
>9355	00					.byte	 0	; $13 [
>9356	04					.byte	 4	; $14 \
>9357	00					.byte	 0	; $15 ]
>9358	01					.byte	 1	; $16 ^
>9359	00					.byte	 0	; $17 _
>935a	00					.byte	 0	; $18 `
>935b	00					.byte	 0	; $19 !!25
>935c	00					.byte	 0	; $1a !!26
>935d	00					.byte	 0	; $1b {
>935e	01					.byte	 1	; $1c |
>935f	00					.byte	 0	; $1d }
>9360	00					.byte	 0	; $1e ~
>9361	00					.byte	 0	; $1f [7m<7F>[m
>9362	00					.byte	 0	; $20
>9363	05					.byte	 5	; $21 !
>9364	00					.byte	 0	; $22 "
>9365	00					.byte	 0	; $23 #
>9366	05					.byte	 5	; $24 $
>9367	04					.byte	 4	; $25 %
>9368	01					.byte	 1	; $26 &
>9369	00					.byte	 0	; $27 '
>936a	00					.byte	 0	; $28 (
>936b	00					.byte	 0	; $29 )
>936c	04					.byte	 4	; $2a *
>936d	03					.byte	 3	; $2b +
>936e	00					.byte	 0	; $2c ,
>936f	03					.byte	 3	; $2d -
>9370	00					.byte	 0	; $2e .
>9371	04					.byte	 4	; $2f /
>9372	00					.byte	 0	; $30 0
>9373	00					.byte	 0	; $31 1
>9374	00					.byte	 0	; $32 2
>9375	00					.byte	 0	; $33 3
>9376	00					.byte	 0	; $34 4
>9377	00					.byte	 0	; $35 5
>9378	00					.byte	 0	; $36 6
>9379	00					.byte	 0	; $37 7
>937a	00					.byte	 0	; $38 8
>937b	00					.byte	 0	; $39 9
>937c	00					.byte	 0	; $3a :
>937d	00					.byte	 0	; $3b ;
>937e	02					.byte	 2	; $3c <
>937f	02					.byte	 2	; $3d =
>9380	02					.byte	 2	; $3e >
>9381	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9382					EvaluateExpressionAt0:
.9382	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9384					EvaluateExpression:
.9384	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9386					EvaluateExpressionAtPrecedence:
.9386	48		pha				pha 								; save precedence level
.9387	20 ce 97	jsr $97ce			jsr 	EvaluateTerm 				; evaluate term into level X.
.938a	68		pla				pla 								; restore precedence level.
.938b					_EXPRLoop:
.938b	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.938d	b1 30		lda ($30),y			lda 	(codePtr),y
.938f	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9391	b0 25		bcs $93b8			bcs 	_EXPRExit
.9393	da		phx				phx 								; read the operator precedence
.9394	aa		tax				tax
.9395	bd 42 93	lda $9342,x			lda 	PrecedenceLevel,x
.9398	fa		plx				plx
.9399	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.939b	f0 1b		beq $93b8			beq 	_EXPRExit
.939d	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.939f	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93a1	c5 37		cmp $37				cmp 	zTemp0+1
.93a3	b0 13		bcs $93b8			bcs		_EXPRExit 					; if current >= operator exit
.93a5	48		pha				pha 								; save current precedence.
.93a6	b1 30		lda ($30),y			lda 	(codePtr),y
.93a8	c8		iny				iny
.93a9	48		pha				pha
.93aa	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93ac	e8		inx				inx 								; work out the right hand side.
.93ad	20 86 93	jsr $9386			jsr 	EvaluateExpressionAtPrecedence
.93b0	ca		dex				dex
.93b1	68		pla				pla 								; get operator, call the code.
.93b2	20 bb 93	jsr $93bb			jsr 	_EXPRCaller
.93b5	68		pla				pla 								; restore precedence level
.93b6	80 d3		bra $938b			bra 	_EXPRLoop 					; and go round.
.93b8					_EXPRExit:
.93b8	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93ba	60		rts				rts
.93bb					_EXPRCaller:
.93bb	da		phx				phx 								; save on stack, first thing is to restore it
.93bc	0a		asl a				asl 	a 							; double so can use vectors into X
.93bd	aa		tax				tax
.93be	7c 42 8b	jmp ($8b42,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.93c1					FloatingPointAdd:
.93c1	20 37 95	jsr $9537			jsr 	FloatPrepare 				; prepare for floats
.93c4	80 09		bra $93cf			bra 	FloatAdd
.93c6					FloatingPointSub:
.93c6	20 37 95	jsr $9537			jsr 	FloatPrepare 				; prepare for floats
.93c9					FloatSubtract:
.93c9	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.93cb	49 80		eor #$80			eor 	#$80
.93cd	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.93cf					FloatAdd:
.93cf	48		pha				pha
.93d0	5a		phy				phy
.93d1	20 46 95	jsr $9546			jsr 	NSNormalise 				; normalise S[X]
.93d4	f0 51		beq $9427			beq 	_FAReturn1
.93d6	e8		inx				inx 								; normalise S[X+1]
.93d7	20 46 95	jsr $9546			jsr 	NSNormalise
.93da	ca		dex				dex
.93db	c9 00		cmp #$00			cmp 	#0
.93dd	f0 60		beq $943f			beq 	_FAExit 					; if so, just return A
.93df	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.93e1	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.93e3	f0 18		beq $93fd			beq 	_FAExponentsEqual
.93e5	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.93e7	a8		tay				tay
.93e8	38		sec				sec 								; do a signed comparison of the exponents.
.93e9	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.93eb	50 02		bvc $93ef			bvc 	_FANoSignedChange
.93ed	49 80		eor #$80			eor 	#$80
.93ef					_FANoSignedChange:
.93ef	29 80		and #$80			and 	#$80
.93f1	10 02		bpl $93f5			bpl 	_FAHaveMax
.93f3	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.93f5					_FAHaveMax:
.93f5	20 42 94	jsr $9442			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.93f8	e8		inx				inx
.93f9	20 42 94	jsr $9442			jsr 	_FAShiftToExponent
.93fc	ca		dex				dex
.93fd					_FAExponentsEqual:
.93fd	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.93ff	55 51		eor $51,x			eor 	NSStatus+1,x
.9401	30 0e		bmi $9411			bmi 	_FADifferentSigns
.9403	20 7a 91	jsr $917a			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9406	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9408	10 35		bpl $943f			bpl 	_FAExit 					; if no, we are done.
.940a	20 a6 9d	jsr $9da6			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.940d	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.940f	80 2e		bra $943f			bra 	_FAExit
.9411					_FADifferentSigns:
.9411	20 94 91	jsr $9194			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9414	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.9416	10 06		bpl $941e			bpl 	_FACheckZero 				; if no, check for -0
.9418	20 4f 9d	jsr $9d4f			jsr 	NSMNegate 					; netate result
.941b	20 56 9d	jsr $9d56			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.941e					_FACheckZero:
.941e	20 af 9d	jsr $9daf			jsr 	NSMIsZero	 				; check for -0
.9421	d0 1c		bne $943f			bne 	_FAExit
.9423	74 50		stz $50,x			stz 	NSStatus,x
.9425	80 18		bra $943f			bra 	_FAExit
.9427					_FAReturn1:
.9427	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9429	95 58		sta $58,x			sta 	NSMantissa0,x
.942b	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.942d	95 60		sta $60,x			sta 	NSMantissa1,x
.942f	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9431	95 68		sta $68,x			sta 	NSMantissa2,x
.9433	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9435	95 70		sta $70,x			sta 	NSMantissa3,x
.9437	b5 79		lda $79,x			lda 	NSExponent+1,x
.9439	95 78		sta $78,x			sta 	NSExponent,x
.943b	b5 51		lda $51,x			lda 	NSStatus+1,x
.943d	95 50		sta $50,x			sta 	NSStatus,x
.943f					_FAExit:
.943f	7a		ply				ply
.9440	68		pla				pla
.9441	60		rts				rts
.9442					_FAShiftToExponent:
.9442					_FAShiftToExponent2:
.9442	98		tya				tya 								; compare Y to exponent
.9443	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9445	f0 07		beq $944e			beq 	_FASEExit 					; exit if so.
.9447	20 a6 9d	jsr $9da6			jsr 	NSMShiftRight	 			; shift the mantissa right
.944a	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.944c	80 f4		bra $9442			bra 	_FAShiftToExponent2
.944e					_FASEExit:
.944e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.944f					CompareFloat:
.944f	20 c9 93	jsr $93c9			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9452	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9454	29 f8		and #$f8			and 	#$F8
.9456	15 68		ora $68,x			ora 	NSMantissa2,x
.9458	15 70		ora $70,x			ora 	NSMantissa3,x
.945a	f0 08		beq $9464			beq 	_FCExit 					; zero, so approximately identical
.945c	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.945e	34 50		bit $50,x			bit 	NSStatus,x
.9460	10 02		bpl $9464			bpl 	_FCExit
.9462					_FCNegative:
.9462	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9464					_FCExit:
.9464	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9465					FDivideCommand:
.9465	fa		plx				plx	 								; restore stack position
.9466	20 37 95	jsr $9537			jsr 	FloatPrepare 				; prepare for floats
.9469					FloatDivide:
.9469	48		pha				pha
.946a	e8		inx				inx
.946b	20 46 95	jsr $9546			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.946e	ca		dex				dex
.946f	c9 00		cmp #$00			cmp 	#0
.9471	f0 1d		beq $9490			beq 	_FDZero
.9473	20 46 95	jsr $9546			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9476	f0 16		beq $948e			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9478	20 6b 90	jsr $906b			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.947b	20 07 90	jsr $9007			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.947e	20 46 95	jsr $9546			jsr		NSNormalise 				; renormalise
.9481	20 fb 90	jsr $90fb			jsr 	CalculateSign 				; calculate result sign
.9484	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.9486	38		sec				sec
.9487	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9489	38		sec				sec
.948a	e9 1e		sbc #$1e			sbc 	#30
.948c	95 78		sta $78,x			sta 	NSExponent,x
.948e					_FDExit:
.948e	68		pla				pla
.948f	60		rts				rts
.9490					_FDZero:
.9490	a9 03		lda #$03		lda	#3
.9492	4c 80 8e	jmp $8e80		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9495					FloatFractionalPart:
.9495	5a		phy				phy
.9496	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9498	29 7f		and #$7f			and 	#$7F
.949a	95 50		sta $50,x			sta 	NSStatus,x
.949c	20 46 95	jsr $9546			jsr 	NSNormalise
.949f	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.94a1	38		sec				sec
.94a2	e9 e0		sbc #$e0			sbc 	#$E0
.94a4	90 29		bcc $94cf			bcc 	_FFPExit 					; already fractional
.94a6	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.94a8	b0 22		bcs $94cc			bcs 	_FFPZero
.94aa	a8		tay				tay 								; put count to do in Y
.94ab	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.94ad	20 d1 94	jsr $94d1			jsr 	_FFPPartial
.94b0	95 70		sta $70,x			sta 	NSMantissa3,x
.94b2	b5 68		lda $68,x			lda 	NSMantissa2,x
.94b4	20 d1 94	jsr $94d1			jsr 	_FFPPartial
.94b7	95 68		sta $68,x			sta 	NSMantissa2,x
.94b9	b5 60		lda $60,x			lda 	NSMantissa1,x
.94bb	20 d1 94	jsr $94d1			jsr 	_FFPPartial
.94be	95 60		sta $60,x			sta 	NSMantissa1,x
.94c0	b5 58		lda $58,x			lda 	NSMantissa0,x
.94c2	20 d1 94	jsr $94d1			jsr 	_FFPPartial
.94c5	95 58		sta $58,x			sta 	NSMantissa0,x
.94c7	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; zeroed check.
.94ca	d0 03		bne $94cf			bne 	_FFPExit
.94cc					_FFPZero:
.94cc	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero
.94cf					_FFPExit:
.94cf	7a		ply				ply
.94d0	60		rts				rts
.94d1					_FFPPartial:
.94d1	c0 00		cpy #$00			cpy 	#0 							; no more to do
.94d3	f0 17		beq $94ec			beq 	_FFFPPExit
.94d5	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.94d7	b0 0c		bcs $94e5			bcs 	_FFFPPWholeByte
.94d9	5a		phy				phy
.94da					_FFFPPLeft:
.94da	0a		asl a				asl 	a
.94db	88		dey				dey
.94dc	d0 fc		bne $94da			bne 	_FFFPPLeft
.94de	7a		ply				ply
.94df					_FFFPPRight:
.94df	4a		lsr a				lsr 	a
.94e0	88		dey				dey
.94e1	d0 fc		bne $94df			bne 	_FFFPPRight
.94e3	80 07		bra $94ec			bra 	_FFFPPExit
.94e5					_FFFPPWholeByte:
.94e5	98		tya				tya 								; subtract 8 from count
.94e6	38		sec				sec
.94e7	e9 08		sbc #$08			sbc 	#8
.94e9	a8		tay				tay
.94ea	a9 00		lda #$00			lda 	#0 							; and clear all
.94ec					_FFFPPExit:
.94ec	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.94ed					FloatIntegerPart:
.94ed	48		pha				pha
.94ee	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.94f0	f0 1d		beq $950f			beq 	_FIPExit 					; if so do nothing
.94f2	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; is it zero ?
.94f5	f0 15		beq $950c			beq 	_FIPZero 					; if so return zero.
.94f7	20 46 95	jsr $9546			jsr 	NSNormalise 				; normalise
.94fa	f0 10		beq $950c			beq 	_FIPZero 					; normalised to zero, exit zero
.94fc					_FIPShift:
.94fc	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.94fe	10 07		bpl $9507			bpl 	_FIPCheckZero
.9500	20 a6 9d	jsr $9da6			jsr 	NSMShiftRight 				; shift mantissa right
.9503	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.9505	80 f5		bra $94fc			bra 	_FIPShift
.9507					_FIPCheckZero:
.9507	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; avoid -0 problem
.950a	d0 03		bne $950f			bne 	_FIPExit 					; set to zero if mantissa zero.
.950c					_FIPZero:
.950c	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero
.950f					_FIPExit:
.950f	68		pla				pla
.9510	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9511					FloatingPointMultiply:
.9511	20 37 95	jsr $9537			jsr 	FloatPrepare 				; prepare for floats
.9514					FloatMultiply:
.9514	48		pha				pha
.9515	20 46 95	jsr $9546			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9518	f0 18		beq $9532			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.951a	e8		inx				inx
.951b	20 46 95	jsr $9546			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.951e	ca		dex				dex
.951f	c9 00		cmp #$00			cmp 	#0
.9521	f0 0c		beq $952f			beq 	_FDSetZero
.9523	20 bd 90	jsr $90bd			jsr 	MultiplyShort 				; calculate the result.
.9526	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9528	18		clc				clc
.9529	75 79		adc $79,x			adc 	NSExponent+1,x
.952b	95 78		sta $78,x			sta 	NSExponent,x
.952d	80 03		bra $9532			bra 	_FDExit
.952f					_FDSetZero:
.952f	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero 					; return 0
.9532					_FDExit:
.9532	20 46 95	jsr $9546			jsr 	NSNormalise 				; normalise the result
.9535	68		pla				pla
.9536	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9537					FloatPrepare:
.9537	20 42 96	jsr $9642			jsr 	DereferenceTopTwo 			; dereference the top two values
.953a	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats
.953c	15 51		ora $51,x			ora 	NSStatus+1,x
.953e	29 10		and #$10			and 	#NSBIsString
.9540	d0 01		bne $9543			bne 	_FDType
.9542	60		rts				rts
.9543					_FDType:
.9543	4c 15 9f	jmp $9f15			jmp 	TypeError
.9546					NSNormalise:
.9546	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.9548	29 80		and #$80			and 	#$80
.954a	09 08		ora #$08			ora 	#NSTFloat
.954c	95 50		sta $50,x			sta 	NSStatus,x
.954e	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; if zero exit
.9551	d0 07		bne $955a			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.9553	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9555	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.9557	a9 00		lda #$00			lda 	#0 							; set Z flag
.9559	60		rts				rts
.955a					_NSNormaliseOptimise:
.955a	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.955c	d0 19		bne $9577			bne 	_NSNormaliseLoop
.955e	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.9560	30 15		bmi $9577			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9562	95 70		sta $70,x			sta 	NSMantissa3,x
.9564	b5 60		lda $60,x			lda 	NSMantissa1,x
.9566	95 68		sta $68,x			sta 	NSMantissa2,x
.9568	b5 58		lda $58,x			lda 	NSMantissa0,x
.956a	95 60		sta $60,x			sta 	NSMantissa1,x
.956c	74 58		stz $58,x			stz 	NSMantissa0,x
.956e	b5 78		lda $78,x			lda 	NSExponent,x
.9570	38		sec				sec
.9571	e9 08		sbc #$08			sbc 	#8
.9573	95 78		sta $78,x			sta 	NSExponent,x
.9575	80 e3		bra $955a			bra 	_NSNormaliseOptimise
.9577					_NSNormaliseLoop:
.9577	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9579	70 07		bvs $9582			bvs 	_NSNExit 					; exit if so with Z flag clear
.957b	20 9c 9d	jsr $9d9c			jsr 	NSMShiftLeft 				; shift mantissa left
.957e	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.9580	80 f5		bra $9577			bra 	_NSNormaliseLoop
.9582					_NSNExit:
.9582	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9584	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9585					AssignNumber:
.9585	5a		phy				phy
.9586	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9588	85 36		sta $36				sta 	zTemp0
.958a	b5 60		lda $60,x			lda 	NSMantissa1,x
.958c	85 37		sta $37				sta 	zTemp0+1
.958e	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9590	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9592	95 50		sta $50,x			sta 	NSStatus,x
.9594	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9596	c9 08		cmp #$08			cmp 	#NSTFloat
.9598	f0 24		beq $95be			beq 	_ANFloat
.959a	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.959c	f0 03		beq $95a1			beq		_ANNotFloat
.959e	4c 10 9f	jmp $9f10			jmp 	RangeError
.95a1					_ANNotFloat:
.95a1	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.95a3	29 03		and #$03			and 	#3
.95a5	d0 05		bne $95ac			bne 	_ANByteWord
.95a7	20 c9 95	jsr $95c9			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.95aa	80 1b		bra $95c7			bra 	_ANExit
.95ac					_ANByteWord:
.95ac	48		pha				pha 								; save count
.95ad	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.95af	92 36		sta ($36)			sta 	(zTemp0)
.95b1	68		pla				pla
.95b2	c9 01		cmp #$01			cmp	 	#1
.95b4	f0 11		beq $95c7			beq 	_ANExit
.95b6	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.95b8	a0 01		ldy #$01			ldy 	#1
.95ba	91 36		sta ($36),y			sta 	(zTemp0),y
.95bc	80 09		bra $95c7			bra 	_ANExit
.95be					_ANFloat:
.95be	20 c9 95	jsr $95c9			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.95c1	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.95c3	a0 04		ldy #$04			ldy 	#4
.95c5	91 36		sta ($36),y			sta 	(zTemp0),y
.95c7					_ANExit:
.95c7	7a		ply				ply
.95c8	60		rts				rts
.95c9					_ANCopy4PackSign:
.95c9	a0 03		ldy #$03			ldy 	#3
.95cb	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.95cd	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.95cf	15 71		ora $71,x			ora 	NSMantissa3+1,x
.95d1	91 36		sta ($36),y			sta 	(zTemp0),y
.95d3	88		dey				dey
.95d4	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.95d6	91 36		sta ($36),y			sta 	(zTemp0),y
.95d8	88		dey				dey
.95d9	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.95db	91 36		sta ($36),y			sta 	(zTemp0),y
.95dd	88		dey				dey
.95de	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.95e0	91 36		sta ($36),y			sta 	(zTemp0),y
.95e2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95e3					AssignString:
.95e3	5a		phy				phy
.95e4	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.95e6	85 38		sta $38				sta 	zTemp1
.95e8	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.95ea	85 39		sta $39				sta 	zTemp1+1
.95ec	b5 58		lda $58,x			lda 	NSMantissa0,x
.95ee	85 36		sta $36				sta 	zTemp0
.95f0	b5 60		lda $60,x			lda 	NSMantissa1,x
.95f2	85 37		sta $37				sta 	zTemp0+1
.95f4	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.95f6	b1 36		lda ($36),y			lda 	(zTemp0),y
.95f8	f0 23		beq $961d			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.95fa	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.95fb	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.95fd	e9 02		sbc #$02			sbc 	#2
.95ff	85 3c		sta $3c				sta 	zsTemp
.9601	a0 01		ldy #$01			ldy 	#1
.9603	b1 36		lda ($36),y			lda 	(zTemp0),y
.9605	e9 00		sbc #$00			sbc 	#0
.9607	85 3d		sta $3d				sta 	zsTemp+1
.9609	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.960b					_ASGetLength:
.960b	c8		iny				iny
.960c	b1 38		lda ($38),y			lda 	(zTemp1),y
.960e	d0 fb		bne $960b			bne 	_ASGetLength
.9610	98		tya				tya 								; is this length <= current length
.9611	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9613	90 1e		bcc $9633			bcc 	_ASCopyString
.9615	f0 1c		beq $9633			beq 	_ASCopyString
.9617	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9619	a0 01		ldy #$01			ldy 	#1
.961b	91 3c		sta ($3c),y			sta 	(zsTemp),y
.961d					_ASNewStringRequired:
.961d	e8		inx				inx 								; concrete the new string.
.961e	20 42 a6	jsr $a642			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9621	ca		dex				dex
.9622	18		clc				clc
.9623	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9625	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9627	92 36		sta ($36)			sta 	(zTemp0)
.9629	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.962b	69 00		adc #$00			adc 	#0
.962d	a0 01		ldy #$01			ldy 	#1
.962f	91 36		sta ($36),y			sta 	(zTemp0),y
.9631	80 0d		bra $9640			bra 	_ASExit
.9633					_ASCopyString:
.9633	a0 00		ldy #$00			ldy 	#0
.9635					_ASCopyLoop:
.9635	b1 38		lda ($38),y			lda 	(zTemp1),y
.9637	c8		iny				iny
.9638	c8		iny				iny
.9639	91 3c		sta ($3c),y			sta 	(zsTemp),y
.963b	88		dey				dey
.963c	c9 00		cmp #$00			cmp 	#0
.963e	d0 f5		bne $9635			bne 	_ASCopyLoop
.9640					_ASExit:
.9640	7a		ply				ply
.9641	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9642					DereferenceTopTwo:
.9642	e8		inx				inx
.9643	20 47 96	jsr $9647			jsr 	Dereference 				; deref x+1
.9646	ca		dex				dex  								; falls through to deref x
.9647					Dereference:
.9647	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.9649	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.964b	f0 48		beq $9695			beq 	_DRFExit 					; not a reference, so exit.
.964d	5a		phy				phy
.964e	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9650	85 36		sta $36				sta 	zTemp0
.9652	b5 60		lda $60,x			lda 	NSMantissa1,x
.9654	85 37		sta $37				sta 	zTemp0+1
.9656	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.9658	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.965a	95 58		sta $58,x			sta 	NSMantissa0,x
.965c	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.965e	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9660	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9662	f0 0e		beq $9672			beq 	_DRFDereferenceTwo
.9664	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9666	f0 2f		beq $9697			beq 	_DRFFull
.9668	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.966a	29 03		and #$03			and 	#3
.966c	f0 29		beq $9697			beq 	_DRFFull 					; the whole word
.966e	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9670	f0 06		beq $9678			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9672					_DRFDereferenceTwo:
.9672	a0 01		ldy #$01			ldy 	#1
.9674	b1 36		lda ($36),y			lda 	(zTemp0),y
.9676	95 60		sta $60,x			sta 	NSMantissa1,x
.9678					_DRFClear23:
.9678	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.967a	74 70		stz $70,x			stz 	NSMantissa3,x
.967c	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.967e	29 18		and #$18			and 	#NSBTypeMask
.9680	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9682	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9684	d0 0e		bne $9694			bne 	_DRFNotString
.9686	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.9688	15 60		ora $60,x			ora 	NSMantissa1,x
.968a	d0 08		bne $9694			bne 	_DRFNotString
.968c	a9 96		lda #$96			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.968e	95 58		sta $58,x			sta 	NSMantissa0,X
.9690	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.9692	95 60		sta $60,x			sta 	NSMantissa1,X
.9694					_DRFNotString
.9694	7a		ply				ply 								; restore Y and exit
.9695					_DRFExit:
.9695	60		rts				rts
.9696					_DRFNullString:
>9696	00						.byte 	0
.9697					_DRFFull:
.9697	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9699	b1 36		lda ($36),y			lda 	(zTemp0),y
.969b	95 60		sta $60,x			sta 	NSMantissa1,x
.969d	c8		iny				iny
.969e	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a0	95 68		sta $68,x			sta 	NSMantissa2,x
.96a2	c8		iny				iny
.96a3	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a5	95 70		sta $70,x			sta 	NSMantissa3,x
.96a7	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.96a9	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.96ab	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96ad	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.96af	f0 05		beq $96b6			beq 	_DRFNoExponent
.96b1	c8		iny				iny 								; if not, read the exponent as well.
.96b2	b1 36		lda ($36),y			lda 	(zTemp0),y
.96b4	95 78		sta $78,x			sta 	NSExponent,x
.96b6					_DRFNoExponent:
.96b6	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96b8	10 0a		bpl $96c4			bpl 	_DRFExit2 					; if not, then exit.
.96ba	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96bc	95 70		sta $70,x			sta 	NSMantissa3,x
.96be	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.96c0	09 80		ora #$80			ora 	#NSBIsNegative
.96c2	95 50		sta $50,x			sta 	NSStatus,x
.96c4					_DRFExit2:
.96c4	7a		ply				ply
.96c5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.96c6					EncodeNumberStart:
.96c6	38		sec				sec
.96c7	80 01		bra $96ca			bra 	EncodeNumberContinue+1
.96c9					EncodeNumberContinue:
.96c9	18		clc				clc
.96ca					EncodeNumber:
.96ca	08		php				php 								; save reset flag.
.96cb	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.96cd	f0 12		beq $96e1			beq 	_ENIsOkay
.96cf	c9 30		cmp #$30			cmp 	#"0"
.96d1	90 04		bcc $96d7			bcc 	_ENBadNumber
.96d3	c9 3a		cmp #$3a			cmp 	#"9"+1
.96d5	90 0a		bcc $96e1			bcc 	_ENIsOkay
.96d7					_ENBadNumber:
.96d7	28		plp				plp 								; throw saved reset
.96d8	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.96db	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96dd	f0 7b		beq $975a			beq 	_ENConstructFinal
.96df					_ENFail:
.96df	18		clc				clc 								; not allowed
.96e0	60		rts				rts
.96e1					_ENIsOkay:
.96e1	28		plp				plp 								; are we restarting
.96e2	90 15		bcc $96f9			bcc 	_ENNoRestart
.96e4					_ENStartEncode:
.96e4	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.96e6	f0 0c		beq $96f4			beq 	_ENFirstDP
.96e8	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.96ea	20 8f 9d	jsr $9d8f			jsr 	NSMSetByte 					; in single byte mode.
.96ed	a9 01		lda #$01			lda 	#ESTA_Low
.96ef					_ENExitChange:
.96ef	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.96f2	38		sec				sec
.96f3	60		rts				rts
.96f4					_ENFirstDP:
.96f4	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero 					; clear integer part
.96f7	80 3c		bra $9735			bra 	_ESTASwitchFloat			; go straight to float and exi
.96f9					_ENNoRestart:
.96f9	48		pha				pha 								; save digit or DP on stack.
.96fa	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.96fd	c9 01		cmp #$01			cmp 	#ESTA_Low
.96ff	f0 09		beq $970a			beq  	_ESTALowState
.9701	c9 02		cmp #$02			cmp 	#ESTA_High
.9703	f0 26		beq $972b			beq 	_ESTAHighState
.9705	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9707	f0 38		beq $9741			beq 	_ESTADecimalState
>9709	db						.byte 	$DB 						; causes a break in the emulator
.970a					_ESTALowState:
.970a	68		pla				pla 								; get value back
.970b	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.970d	f0 26		beq $9735			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.970f	29 0f		and #$0f			and 	#15 						; make digit
.9711	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.9714	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9716	0a		asl a				asl 	a
.9717	0a		asl a				asl 	a
.9718	75 58		adc $58,x			adc 	NSMantissa0,x
.971a	0a		asl a				asl 	a
.971b	6d 06 04	adc $0406			adc 	DigitTemp
.971e	95 58		sta $58,x			sta 	NSMantissa0,x
.9720	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.9722	90 05		bcc $9729			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.9724	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.9726	8d 05 04	sta $0405			sta 	EncodeState
.9729					_ESTANoSwitch:
.9729	38		sec				sec
.972a	60		rts				rts
.972b					_ESTAHighState:
.972b	68		pla				pla 								; get value back
.972c	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.972e	f0 05		beq $9735			beq 	_ESTASwitchFloat
.9730	20 8e 97	jsr $978e			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9733	38		sec				sec
.9734	60		rts				rts
.9735					_ESTASwitchFloat:
.9735	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.9738	e8		inx				inx 								; zero the decimal additive.
.9739	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero
.973c	ca		dex				dex
.973d	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.973f	80 ae		bra $96ef			bra 	_ENExitChange
.9741					_ESTADecimalState:
.9741	68		pla				pla 								; digit.
.9742	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9744	f0 99		beq $96df			beq 	_ENFail
.9746	e8		inx				inx 								; put digit into fractional part of X+1
.9747	20 8e 97	jsr $978e			jsr 	ESTAShiftDigitIntoMantissa
.974a	ca		dex				dex
.974b	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.974e	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.9751	c9 0b		cmp #$0b			cmp 	#11
.9753	f0 02		beq $9757			beq 	_ESTADSFail
.9755	38		sec				sec
.9756	60		rts				rts
.9757					_ESTADSFail:
.9757	4c 10 9f	jmp $9f10			jmp 	RangeError
.975a					_ENConstructFinal:
.975a	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.975d	f0 2d		beq $978c			beq 	_ENCFExit 					; no decimals
.975f	5a		phy				phy
.9760	0a		asl a				asl 	a 							; x 4 and CLC
.9761	0a		asl a				asl 	a
.9762	6d 07 04	adc $0407			adc 	DecimalCount
.9765	a8		tay				tay
.9766	b9 cf 9e	lda $9ecf,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9769	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.976b	b9 d0 9e	lda $9ed0,y			lda 	DecimalScalarTable-5+1,y
.976e	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9770	b9 d1 9e	lda $9ed1,y			lda 	DecimalScalarTable-5+2,y
.9773	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9775	b9 d2 9e	lda $9ed2,y			lda 	DecimalScalarTable-5+3,y
.9778	95 72		sta $72,x			sta 	NSMantissa3+2,x
.977a	b9 d3 9e	lda $9ed3,y			lda 	DecimalScalarTable-5+4,y
.977d	95 7a		sta $7a,x			sta 	NSExponent+2,x
.977f	a9 08		lda #$08			lda 	#NSTFloat
.9781	95 52		sta $52,x			sta 	NSStatus+2,x
.9783	7a		ply				ply
.9784	e8		inx				inx 								; multiply decimal const by decimal scalar
.9785	20 14 95	jsr $9514			jsr 	FloatMultiply
.9788	ca		dex				dex
.9789	20 cf 93	jsr $93cf			jsr 	FloatAdd 					; add to integer part.
.978c					_ENCFExit:
.978c	18		clc				clc 								; reject the digit.
.978d	60		rts				rts
.978e					ESTAShiftDigitIntoMantissa:
.978e	29 0f		and #$0f			and 	#15 						; save digit
.9790	48		pha				pha
.9791	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9793	48		pha				pha
.9794	b5 68		lda $68,x			lda 	NSMantissa2,x
.9796	48		pha				pha
.9797	b5 60		lda $60,x			lda 	NSMantissa1,x
.9799	48		pha				pha
.979a	b5 58		lda $58,x			lda 	NSMantissa0,x
.979c	48		pha				pha
.979d	20 9c 9d	jsr $9d9c			jsr 	NSMShiftLeft 				; x 2
.97a0	20 9c 9d	jsr $9d9c			jsr 	NSMShiftLeft 				; x 4
.97a3	18		clc				clc 								; pop mantissa and add
.97a4	68		pla				pla
.97a5	75 58		adc $58,x			adc 	NSMantissa0,x
.97a7	95 58		sta $58,x			sta 	NSMantissa0,x
.97a9	68		pla				pla
.97aa	75 60		adc $60,x			adc 	NSMantissa1,x
.97ac	95 60		sta $60,x			sta 	NSMantissa1,x
.97ae	68		pla				pla
.97af	75 68		adc $68,x			adc 	NSMantissa2,x
.97b1	95 68		sta $68,x			sta 	NSMantissa2,x
.97b3	68		pla				pla
.97b4	75 70		adc $70,x			adc 	NSMantissa3,x
.97b6	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.97b8	20 9c 9d	jsr $9d9c			jsr 	NSMShiftLeft 				; x 10
.97bb	68		pla				pla 								; add digit
.97bc	18		clc				clc
.97bd	75 58		adc $58,x			adc 	NSMantissa0,x
.97bf	95 58		sta $58,x			sta 	NSMantissa0,x
.97c1	90 0a		bcc $97cd			bcc 	_ESTASDExit
.97c3	f6 60		inc $60,x			inc 	NSMantissa1,x
.97c5	d0 06		bne $97cd			bne 	_ESTASDExit
.97c7	f6 68		inc $68,x			inc 	NSMantissa2,x
.97c9	d0 02		bne $97cd			bne 	_ESTASDExit
.97cb	f6 70		inc $70,x			inc 	NSMantissa3,x
.97cd					_ESTASDExit:
.97cd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.97ce					EvaluateTerm:
.97ce	b1 30		lda ($30),y			lda 	(codePtr),y
.97d0	30 18		bmi $97ea			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.97d2	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.97d4	b0 6c		bcs $9842			bcs 	_ETVariable
.97d6	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.97d8	90 6b		bcc $9845			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.97da	c9 3a		cmp #$3a			cmp 	#'9'+1
.97dc	b0 67		bcs $9845			bcs 	_ETPuncUnary
.97de	20 c6 96	jsr $96c6			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.97e1					_ETNumber:
.97e1	c8		iny				iny 								; keep encoding until we have the numbers
.97e2	b1 30		lda ($30),y			lda 	(codePtr),y
.97e4	20 c9 96	jsr $96c9			jsr 	EncodeNumberContinue
.97e7	b0 f8		bcs $97e1			bcs 	_ETNumber 					; go back if accepted.
.97e9	60		rts				rts
.97ea					_ETCheckUnary:
.97ea	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.97ec	f0 3f		beq $982d			beq 	_ETString
.97ee	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.97f0	f0 12		beq $9804			beq 	_ETHexConstant
.97f2	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.97f4	90 0b		bcc $9801			bcc 	_ETSyntaxError
.97f6	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.97f8	b0 07		bcs $9801			bcs 	_ETSyntaxError
.97fa	da		phx				phx 								; push X on the stack
.97fb	0a		asl a				asl 	a 							; put vector x 2 into X
.97fc	aa		tax				tax
.97fd	c8		iny				iny 								; consume unary function token
.97fe	7c c2 8b	jmp ($8bc2,x)			jmp 	(VectorSet0,x) 				; and do it.
.9801					_ETSyntaxError:
.9801	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError
.9804					_ETHexConstant:
.9804	c8		iny				iny 								; skip #
.9805	c8		iny				iny 								; skip count
.9806	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero 					; clear result
.9809					_ETHLoop:
.9809	b1 30		lda ($30),y			lda 	(codePtr),y
.980b	c8		iny				iny 								; and consume
.980c	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.980e	f0 1c		beq $982c			beq 	_ETHExit
.9810	48		pha				pha 								; save on stack.
.9811	20 9c 9d	jsr $9d9c			jsr 	NSMShiftLeft 				; x 2
.9814	20 9c 9d	jsr $9d9c			jsr 	NSMShiftLeft 				; x 4
.9817	20 9c 9d	jsr $9d9c			jsr 	NSMShiftLeft 				; x 8
.981a	20 9c 9d	jsr $9d9c			jsr 	NSMShiftLeft 				; x 16
.981d	68		pla				pla 								; ASCII
.981e	c9 41		cmp #$41			cmp 	#'A'
.9820	90 02		bcc $9824			bcc 	_ETHNotChar
.9822	e9 07		sbc #$07			sbc 	#7
.9824					_ETHNotChar:
.9824	29 0f		and #$0f			and 	#15 						; digit now
.9826	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.9828	95 58		sta $58,x			sta 	NSMantissa0,x
.982a	80 dd		bra $9809			bra 	_ETHLoop 					; go round.
.982c					_ETHExit:
.982c	60		rts				rts
.982d					_ETString:
.982d	c8		iny				iny 								; look at length
.982e	b1 30		lda ($30),y			lda 	(codePtr),y
.9830	48		pha				pha
.9831	c8		iny				iny 								; first character
.9832	20 e8 a4	jsr $a4e8			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9835	68		pla				pla 								; restore count and save
.9836	85 36		sta $36				sta 	zTemp0
.9838	98		tya				tya 								; add length to Y to skip it.
.9839	18		clc				clc
.983a	65 36		adc $36				adc 	zTemp0
.983c	a8		tay				tay
.983d	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.983f	95 50		sta $50,x			sta 	NSStatus,x
.9841	60		rts				rts
.9842					_ETVariable:
.9842	4c 97 98	jmp $9897			jmp 	VariableHandler
.9845					_ETPuncUnary:
.9845	c8		iny				iny 								; consume the unary character
.9846	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9848	f0 2b		beq $9875			beq 	_ETUnaryNegate
.984a	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.984c	f0 36		beq $9884			beq 	_ETDereference
.984e	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9850	f0 3e		beq $9890			beq 	_ETParenthesis
.9852	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9854	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9856	f0 06		beq $985e			beq 	_ETIndirection
.9858	e6 36		inc $36				inc 	zTemp0
.985a	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.985c	d0 a3		bne $9801			bne 	_ETSyntaxError
.985e					_ETIndirection:
.985e	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9860	1a		inc a				inc 	a
.9861	48		pha				pha
.9862	20 ce 97	jsr $97ce			jsr 	EvaluateTerm				; evaluate the term
.9865	20 47 96	jsr $9647			jsr 	Dereference 				; dereference it.
.9868	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.986a	d0 06		bne $9872			bne 	_ETTypeMismatch
.986c	68		pla				pla 								; indirection 1-2
.986d	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.986f	95 50		sta $50,x			sta 	NSStatus,x
.9871	60		rts				rts
.9872					_ETTypeMismatch:
.9872	4c 15 9f	jmp $9f15			jmp 	TypeError
.9875					_ETUnaryNegate:
.9875	20 ce 97	jsr $97ce			jsr 	EvaluateTerm				; evaluate the term
.9878	20 47 96	jsr $9647			jsr 	Dereference 				; dereference it.
.987b	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.987d	29 10		and #$10			and 	#NSTString
.987f	d0 f1		bne $9872			bne 	_ETTypeMismatch
.9881	4c 4f 9d	jmp $9d4f			jmp 	NSMNegate  					; just toggles the sign bit.
.9884					_ETDereference:
.9884	20 ce 97	jsr $97ce			jsr 	EvaluateTerm				; evaluate the term
.9887	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9889	29 20		and #$20			and 	#NSBIsReference
.988b	f0 e5		beq $9872			beq 	_ETTypeMismatch
.988d	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.988f	60		rts				rts
.9890					_ETParenthesis:
.9890	20 84 93	jsr $9384			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9893	20 67 8e	jsr $8e67			jsr 	CheckRightBracket 			; check for )
.9896	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9897					VariableHandler:
.9897	b1 30		lda ($30),y			lda 	(codePtr),y
.9899	18		clc				clc
.989a	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.989c	85 37		sta $37				sta 	zTemp0+1
.989e	c8		iny				iny
.989f	b1 30		lda ($30),y			lda 	(codePtr),y
.98a1	85 36		sta $36				sta 	zTemp0
.98a3	c8		iny				iny
.98a4	18		clc				clc									; copy variable address+3 to mantissa
.98a5	69 03		adc #$03			adc 	#3
.98a7	95 58		sta $58,x			sta 	NSMantissa0,x
.98a9	a5 37		lda $37				lda 	zTemp0+1
.98ab	69 00		adc #$00			adc 	#0
.98ad	95 60		sta $60,x			sta 	NSMantissa1,x
.98af	74 68		stz $68,x			stz 	NSMantissa2,x
.98b1	74 70		stz $70,x			stz 	NSMantissa3,x
.98b3	74 78		stz $78,x			stz 	NSExponent,x
.98b5	5a		phy				phy
.98b6	a0 02		ldy #$02			ldy 	#2 							; read type
.98b8	b1 36		lda ($36),y			lda 	(zTemp0),y
.98ba	7a		ply				ply
.98bb	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98bd	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98bf	95 50		sta $50,x			sta 	NSStatus,x
.98c1	29 04		and #$04			and 	#NSBIsArray
.98c3	d0 01		bne $98c6			bne 	_VHArray
.98c5	60		rts				rts
.98c6					_VHArray:
.98c6	e8		inx				inx
.98c7	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; get the 1st index.
.98ca	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.98cc	95 51		sta $51,x			sta 	NSStatus+1,x
.98ce	b1 30		lda ($30),y			lda 	(codePtr),y
.98d0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.98d2	d0 06		bne $98da			bne 	_VHNoSecondIndex
.98d4	c8		iny				iny 								; skip the comma
.98d5	e8		inx				inx
.98d6	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.98d9	ca		dex				dex
.98da					_VHNoSecondIndex:
.98da	ca		dex				dex 								; set X back.
.98db	20 67 8e	jsr $8e67			jsr 	CheckRightBracket 			; and check the right bracket.
.98de	5a		phy				phy 								; save position
.98df	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.98e1	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98e3	f0 60		beq $9945			beq 	_VHBadIndex
.98e5	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.98e7	85 3e		sta $3e				sta 	zaTemp
.98e9	b5 60		lda $60,x			lda 	NSMantissa1,x
.98eb	85 3f		sta $3f				sta 	zaTemp+1
.98ed	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.98ef	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98f1	f0 02		beq $98f5			beq 	_VHHas2Mask
.98f3	a9 ff		lda #$ff			lda 	#$FF
.98f5					_VHHas2Mask:
.98f5	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.98f7	f0 4c		beq $9945			beq 	_VHBadIndex
.98f9	0a		asl a				asl 	a 							; carry will be set if a second index
.98fa	90 08		bcc $9904			bcc 	_VHCheckFirstIndex
.98fc	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.98fe	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9900	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.9902	90 41		bcc $9945			bcc 	_VHBadIndex
.9904					_VHCheckFirstIndex:
.9904	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9906	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9908	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.990a	90 39		bcc $9945			bcc 	_VHBadIndex
.990c	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.990e	64 37		stz $37				stz 	zTemp0+1
.9910	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9912	30 0e		bmi $9922			bmi 	_VHNoMultiply
.9914	da		phx				phx
.9915	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9917	48		pha				pha
.9918	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.991a	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.991c	1a		inc a				inc 	a 							; add 1 for zero base
.991d	fa		plx				plx
.991e	20 38 9d	jsr $9d38			jsr 	Multiply8x8 				; calculate -> Z0
.9921	fa		plx				plx
.9922					_VHNoMultiply:
.9922	18		clc				clc
.9923	a5 36		lda $36				lda 	zTemp0
.9925	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9927	85 36		sta $36				sta 	zTemp0
.9929	a5 37		lda $37				lda 	zTemp0+1
.992b	69 00		adc #$00			adc 	#0
.992d	85 37		sta $37				sta 	zTemp0+1
.992f	b5 50		lda $50,x			lda 	NSStatus,x
.9931	20 df 84	jsr $84df			jsr 	ScaleByBaseType
.9934	18		clc				clc
.9935	b2 3e		lda ($3e)			lda 	(zaTemp)
.9937	65 36		adc $36				adc 	zTemp0
.9939	95 58		sta $58,x			sta 	NSMantissa0,x
.993b	a0 01		ldy #$01			ldy 	#1
.993d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.993f	65 37		adc $37				adc 	zTemp0+1
.9941	95 60		sta $60,x			sta 	NSMantissa1,x
.9943	7a		ply				ply 								; restore position
.9944	60		rts				rts
.9945					_VHBadIndex:
.9945	a9 17		lda #$17		lda	#23
.9947	4c 80 8e	jmp $8e80		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.994a					AbsUnary:
.994a	fa		plx				plx 								; restore stack pos
.994b	20 db 9c	jsr $9cdb			jsr 	EvaluateNumber 				; get a float or int
.994e	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.9951	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.9953	29 7f		and #$7f			and 	#$7F
.9955	95 50		sta $50,x			sta 	NSStatus,x
.9957	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9958					AllocUnary:
.9958	fa		plx				plx 								; restore stack pos
.9959	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger		; get bytes required.
.995c	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.995f	da		phx				phx 								; save X/Y
.9960	5a		phy				phy
.9961	8a		txa				txa 								; copy X into Y
.9962	a8		tay				tay
.9963	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size
.9966	aa		tax				tax
.9967	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.996a	20 77 99	jsr $9977			jsr 	AllocateXABytes 			; allocate memory
.996d	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.9970	8a		txa				txa
.9971	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.9974	7a		ply				ply
.9975	fa		plx				plx
.9976	60		rts				rts
.9977					AllocateXABytes:
.9977	5a		phy				phy
.9978	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.997b	84 36		sty $36				sty 	zTemp0
.997d	5a		phy				phy
.997e	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.9981	84 37		sty $37				sty 	zTemp0+1
.9983	5a		phy				phy
.9984	18		clc				clc 								; add to low memory pointer
.9985	6d 0c 04	adc $040c			adc 	lowMemPtr
.9988	8d 0c 04	sta $040c			sta 	lowMemPtr
.998b	8a		txa				txa
.998c	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.998f	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9992	b0 2f		bcs $99c3			bcs 	CISSMemory
.9994	20 b5 99	jsr $99b5			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9997					_ClearMemory:
.9997	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.999a	c5 36		cmp $36				cmp 	zTemp0
.999c	d0 07		bne $99a5			bne 	_CMClearNext
.999e	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.99a1	c5 37		cmp $37				cmp 	zTemp0+1
.99a3	f0 0c		beq $99b1			beq 	_CMExit
.99a5					_CMClearNext:
.99a5	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99a7	92 36		sta ($36)			sta 	(zTemp0)
.99a9	e6 36		inc $36				inc 	zTemp0
.99ab	d0 ea		bne $9997			bne 	_ClearMemory
.99ad	e6 37		inc $37				inc		zTemp0+1
.99af	80 e6		bra $9997			bra 	_ClearMemory
.99b1					_CMExit:
.99b1	fa		plx				plx
.99b2	68		pla				pla
.99b3	7a		ply				ply
.99b4	60		rts				rts
.99b5					CheckIdentifierStringSpace:
.99b5	48		pha				pha
.99b6	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.99b9	18		clc				clc
.99ba	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99bc	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.99bf	b0 02		bcs $99c3			bcs 	CISSMemory
.99c1	68		pla				pla
.99c2	60		rts				rts
.99c3					CISSMemory:
.99c3	a9 06		lda #$06		lda	#6
.99c5	4c 80 8e	jmp $8e80		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.99c8					AscUnary:
.99c8	fa		plx				plx 								; restore stack pos
.99c9	20 e5 9c	jsr $9ce5			jsr 	EvaluateString 				; get a string
.99cc	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.99ce	20 8f 9d	jsr $9d8f			jsr 	NSMSetByte 					; ASC("") will return zero.
.99d1	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.99d4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.99d5					FracUnary:
.99d5	fa		plx				plx 								; restore stack pos
.99d6	20 db 9c	jsr $9cdb			jsr 	EvaluateNumber 				; get a float or int
.99d9	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.99dc	b5 50		lda $50,x			lda 	NSStatus,x
.99de	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.99e0	f0 04		beq $99e6			beq 	_IUZero
.99e2	20 95 94	jsr $9495			jsr 	FloatFractionalPart
.99e5	60		rts				rts
.99e6					_IUZero:
.99e6	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero
.99e9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.99ea					IntUnary:
.99ea	fa		plx				plx 								; restore stack pos
.99eb	20 db 9c	jsr $9cdb			jsr 	EvaluateNumber 				; get a float or int
.99ee	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.99f1	b5 50		lda $50,x			lda 	NSStatus,x
.99f3	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.99f5	f0 03		beq $99fa			beq 	_IUExit
.99f7	20 ed 94	jsr $94ed			jsr 	FloatIntegerPart
.99fa					_IUExit:
.99fa	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.99fb					LenUnary:
.99fb	fa		plx				plx 								; restore stack pos
.99fc	20 e5 9c	jsr $9ce5			jsr 	EvaluateString 				; get a string
.99ff	5a		phy				phy
.9a00	a0 00		ldy #$00			ldy 	#0 							; find length
.9a02					_LenFind:
.9a02	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a04	f0 06		beq $9a0c			beq 	_LenExit
.9a06	c8		iny				iny
.9a07	d0 f9		bne $9a02			bne 	_LenFind
.9a09	4c 10 9f	jmp $9f10			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9a0c					_LenExit:
.9a0c	98		tya				tya		 							; return length
.9a0d	20 8f 9d	jsr $9d8f			jsr 	NSMSetByte
.9a10	7a		ply				ply
.9a11	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.9a14	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a15					Unary_Min:
.9a15	a9 01		lda #$01			lda 	#1
.9a17	80 02		bra $9a1b			bra 	UnaryMinMaxMain
.9a19					Unary_Max:
.9a19	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a1b					UnaryMinMaxMain:
.9a1b	fa		plx				plx 								; get index on number stack
.9a1c	48		pha				pha 								; save comparator
.9a1d	20 d2 9c	jsr $9cd2			jsr 	EvaluateValue 				; get the first value.
.9a20					_UMMMLoop:
.9a20	b1 30		lda ($30),y			lda 	(codePtr),y
.9a22	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a24	f0 22		beq $9a48			beq 	_UMMMDone
.9a26	20 6f 8e	jsr $8e6f			jsr 	CheckComma 					; must be a comma
.9a29	e8		inx				inx
.9a2a	20 d2 9c	jsr $9cd2			jsr 	EvaluateValue
.9a2d	ca		dex				dex
.9a2e	20 70 9d	jsr $9d70			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a31	e8		inx				inx
.9a32	20 70 9d	jsr $9d70			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a35	e8		inx				inx
.9a36	20 37 8f	jsr $8f37			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a39	ca		dex				dex
.9a3a	ca		dex				dex
.9a3b	85 36		sta $36				sta 	zTemp0 						; save required result
.9a3d	68		pla				pla 								; get and save comparator
.9a3e	48		pha				pha
.9a3f	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a41	d0 dd		bne $9a20			bne 	_UMMMLoop
.9a43	20 4b 9a	jsr $9a4b			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a46	80 d8		bra $9a20			bra 	_UMMMLoop
.9a48					_UMMMDone:
.9a48	68		pla				pla 								; throw the comparator
.9a49	c8		iny				iny 								; skip )
.9a4a	60		rts				rts
.9a4b					ExpCopyAboveDown:
.9a4b	b5 51		lda $51,x			lda 	NSStatus+1,x
.9a4d	95 50		sta $50,x			sta 	NSStatus,x
.9a4f	b5 79		lda $79,x			lda 	NSExponent+1,x
.9a51	95 78		sta $78,x			sta 	NSExponent,x
.9a53	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9a55	95 58		sta $58,x			sta 	NSMantissa0,x
.9a57	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9a59	95 60		sta $60,x			sta 	NSMantissa1,x
.9a5b	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9a5d	95 68		sta $68,x			sta 	NSMantissa2,x
.9a5f	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9a61	95 70		sta $70,x			sta 	NSMantissa3,x
.9a63	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9a64					Unary_Not:
.9a64	fa		plx				plx
.9a65	20 fa 9c	jsr $9cfa			jsr 	EvaluateInteger 			; get integer
.9a68	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.9a6b	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; zero mantissa ?
.9a6e	f0 04		beq $9a74			beq 	_NotZero
.9a70	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero
.9a73	60		rts				rts
.9a74					_NotZero:
.9a74	4c ed 8e	jmp $8eed			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9a77					Unary_Random:
.9a77	fa		plx				plx
.9a78	20 e9 9a	jsr $9ae9			jsr 	Random32Bit 				; get a random number
.9a7b	20 d2 9a	jsr $9ad2			jsr 	URCopyToMantissa  			; put in mantissa
.9a7e	b1 30		lda ($30),y			lda 	(codePtr),y
.9a80	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9a82	f0 08		beq $9a8c			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9a84	e8		inx				inx
.9a85	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9a88	ca		dex				dex
.9a89	20 3f 90	jsr $903f			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9a8c					_URNoModulus:
.9a8c	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9a8e	74 78		stz $78,x			stz 	NSExponent,x
.9a90	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.9a93	60		rts				rts
.9a94					Unary_Rnd:
.9a94	fa		plx				plx
.9a95	20 db 9c	jsr $9cdb			jsr 	EvaluateNumber 				; number to use.
.9a98	20 67 8e	jsr $8e67			jsr 	CheckRightBracket 			; closing bracket
.9a9b	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9a9e	f0 26		beq $9ac6			beq 	_URCopySeed
.9aa0	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9aa2	10 1f		bpl $9ac3			bpl 	_URDontSeed
.9aa4	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9aa6	49 17		eor #$17			eor 	#$17
.9aa8	8d 08 04	sta $0408			sta 	RandomSeed+0
.9aab	b5 60		lda $60,x			lda 	NSMantissa1,x
.9aad	49 a5		eor #$a5			eor 	#$A5
.9aaf	8d 09 04	sta $0409			sta 	RandomSeed+1
.9ab2	b5 68		lda $68,x			lda 	NSMantissa2,x
.9ab4	49 c2		eor #$c2			eor 	#$C2
.9ab6	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9ab9	b5 70		lda $70,x			lda 	NSMantissa3,x
.9abb	49 9d		eor #$9d			eor 	#$9D
.9abd	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9ac0	20 e9 9a	jsr $9ae9			jsr 	Random32Bit
.9ac3					_URDontSeed:
.9ac3	20 e9 9a	jsr $9ae9			jsr 	Random32Bit 				; generate a number
.9ac6					_URCopySeed:
.9ac6	20 d2 9a	jsr $9ad2			jsr 	URCopyToMantissa 			; copy into mantissa
.9ac9	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9acb	95 78		sta $78,x			sta 	NSExponent,x
.9acd	a9 08		lda #$08			lda 	#NSTFloat
.9acf	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9ad1	60		rts				rts
.9ad2					URCopyToMantissa:
.9ad2	ad 08 04	lda $0408			lda 	RandomSeed+0
.9ad5	95 58		sta $58,x			sta 	NSMantissa0,x
.9ad7	ad 09 04	lda $0409			lda 	RandomSeed+1
.9ada	95 60		sta $60,x			sta 	NSMantissa1,x
.9adc	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9adf	95 68		sta $68,x			sta 	NSMantissa2,x
.9ae1	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9ae4	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9ae6	95 70		sta $70,x			sta 	NSMantissa3,x
.9ae8	60		rts				rts
.9ae9					Random32Bit:
.9ae9	5a		phy				phy
.9aea	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9aec	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9aef	d0 03		bne $9af4			bne 	_Random1
.9af1	a8		tay				tay 								; if so do it 256 times
.9af2	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9af4					_Random1:
.9af4	0a		asl a				asl 	a 							; LSFR RNG
.9af5	2e 09 04	rol $0409			rol 	RandomSeed+1
.9af8	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9afb	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9afe	90 02		bcc $9b02			bcc 	_Random2
.9b00	49 c5		eor #$c5			eor 	#$C5
.9b02					_Random2:
.9b02	88		dey				dey
.9b03	d0 ef		bne $9af4			bne 	_Random1
.9b05	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b08	7a		ply				ply
.9b09	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b0a					SgnUnary:
.9b0a	fa		plx				plx 								; restore stack pos
.9b0b	20 db 9c	jsr $9cdb			jsr 	EvaluateNumber 				; get a float or int
.9b0e	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.9b11	20 af 9d	jsr $9daf			jsr 	NSMIsZero 					; if zero
.9b14	f0 0e		beq $9b24			beq 	_SGZero  					; return Int Zero
.9b16	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9b18	48		pha				pha
.9b19	a9 01		lda #$01			lda 	#1 							; set to 1
.9b1b	20 8f 9d	jsr $9d8f			jsr 	NSMSetByte
.9b1e	68		pla				pla
.9b1f	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b21	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9b23	60		rts				rts
.9b24	20 8d 9d	jsr $9d8d	_SGZero:jsr 	NSMSetZero
.9b27	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b28					ValUnary:
.9b28	fa		plx				plx 								; restore stack pos
.9b29	20 3e 9b	jsr $9b3e			jsr 	ValMainCode 				; do the main val() code
.9b2c	b0 01		bcs $9b2f			bcs 	_VUError 					; couldn't convert
.9b2e	60		rts				rts
.9b2f					_VUError:
.9b2f	4c 15 9f	jmp $9f15			jmp 	TypeError
.9b32					IsValUnary:
.9b32	fa		plx				plx 								; restore stack pos
.9b33	20 3e 9b	jsr $9b3e			jsr 	ValMainCode 				; do the main val() code
.9b36	b0 03		bcs $9b3b			bcs 	_VUBad
.9b38	4c ed 8e	jmp $8eed			jmp 	ReturnTrue
.9b3b					_VUBad:
.9b3b	4c f8 8e	jmp $8ef8			jmp 	ReturnFalse
.9b3e					ValMainCode:
.9b3e	20 e5 9c	jsr $9ce5			jsr 	EvaluateString 				; get a string
.9b41	20 67 8e	jsr $8e67			jsr 	CheckRightBracket 			; check right bracket present
.9b44					ValEvaluateZTemp0:
.9b44	5a		phy				phy
.9b45	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9b47	f0 17		beq $9b60			beq 	_VMCFail2
.9b49	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9b4b	48		pha				pha 								; save first character
.9b4c	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9b4e	d0 01		bne $9b51			bne 	_VMCStart
.9b50	c8		iny				iny 								; skip over -
.9b51					_VMCStart:
.9b51	38		sec				sec 								; initialise first time round.
.9b52					_VMCNext:
.9b52	c8		iny				iny 								; pre-increment
.9b53	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9b55	f0 0c		beq $9b63			beq 	_VMCSuccess 				; successful.
.9b57	20 ca 96	jsr $96ca			jsr 	EncodeNumber 				; send it to the number-builder
.9b5a	90 03		bcc $9b5f			bcc 	_VMCFail 					; if failed, give up.
.9b5c	18		clc				clc 								; next time round, countinue
.9b5d	80 f3		bra $9b52			bra 	_VMCNext
.9b5f					_VMCFail:
.9b5f	68		pla				pla
.9b60					_VMCFail2:
.9b60	7a		ply				ply
.9b61	38		sec				sec
.9b62	60		rts				rts
.9b63					_VMCSuccess:
.9b63	a9 00		lda #$00			lda 	#0 							; construct final
.9b65	20 ca 96	jsr $96ca			jsr 	EncodeNumber 				; by sending a duff value.
.9b68	68		pla				pla 								; if it was -ve
.9b69	c9 2d		cmp #$2d			cmp 	#"-"
.9b6b	d0 03		bne $9b70			bne 	_VMCNotNegative
.9b6d	20 4f 9d	jsr $9d4f			jsr		NSMNegate 					; negate it.
.9b70					_VMCNotNegative:
.9b70	7a		ply				ply
.9b71	18		clc				clc
.9b72	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9b73					ChrUnary:
.9b73	fa		plx				plx 								; restore stack pos
.9b74	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger			; get value
.9b77	48		pha				pha
.9b78	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.9b7b	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9b7d	20 bf a6	jsr $a6bf			jsr 	StringTempAllocate
.9b80	68		pla				pla 								; write number to it
.9b81	20 f8 a6	jsr $a6f8			jsr 	StringTempWrite
.9b84	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9b85					SpcUnary:
.9b85	fa		plx				plx 								; restore stack pos
.9b86	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger			; get value
.9b89	5a		phy				phy
.9b8a	48		pha				pha 								; save count
.9b8b	20 bf a6	jsr $a6bf			jsr 	StringTempAllocate
.9b8e	7a		ply				ply 								; to do count in Y
.9b8f					_SpcLoop:
.9b8f	c0 00		cpy #$00			cpy 	#0
.9b91	f0 08		beq $9b9b			beq 	_SpcExit
.9b93	a9 20		lda #$20			lda 	#32
.9b95	20 f8 a6	jsr $a6f8			jsr 	StringTempWrite
.9b98	88		dey				dey
.9b99	80 f4		bra $9b8f			bra 	_SPCLoop
.9b9b					_SpcExit:
.9b9b	7a		ply				ply
.9b9c	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.9b9f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9ba0					Unary_Str:
.9ba0	fa		plx				plx
.9ba1	20 db 9c	jsr $9cdb			jsr 	EvaluateNumber  			; get number
.9ba4	20 67 8e	jsr $8e67			jsr 	CheckRightBracket 			; closing bracket
.9ba7	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9ba9	20 c2 9b	jsr $9bc2			jsr 	ConvertNumberToString 		; do the conversion.
.9bac	a9 21		lda #$21			lda		#33 						; create buffer
.9bae	20 bf a6	jsr $a6bf			jsr 	StringTempAllocate 			; allocate memory
.9bb1	da		phx				phx
.9bb2	a2 00		ldx #$00			ldx 	#0
.9bb4					_USCopy:
.9bb4	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9bb7	20 f8 a6	jsr $a6f8			jsr 	StringTempWrite
.9bba	e8		inx				inx
.9bbb	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9bbe	d0 f4		bne $9bb4			bne 	_USCopy
.9bc0	fa		plx				plx
.9bc1	60		rts				rts
.9bc2					ConvertNumberToString:
.9bc2	5a		phy				phy 								; save code position
.9bc3	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9bc6	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9bc9	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9bcb	10 09		bpl $9bd6			bpl 	_CNTSNotNegative
.9bcd	29 7f		and #$7f			and 	#$7F 						; make +ve
.9bcf	95 50		sta $50,x			sta 	NSStatus,x
.9bd1	a9 2d		lda #$2d			lda 	#"-"
.9bd3	20 37 9c	jsr $9c37			jsr 	WriteDecimalBuffer
.9bd6					_CNTSNotNegative:
.9bd6	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9bd8	f0 12		beq $9bec			beq 	_CNTSNotFloat
.9bda	e8		inx				inx 								; round up
.9bdb	a9 01		lda #$01			lda 	#1
.9bdd	20 8f 9d	jsr $9d8f			jsr 	NSMSetByte
.9be0	ca		dex				dex
.9be1	b5 78		lda $78,x			lda		NSExponent,x
.9be3	95 79		sta $79,x			sta 	NSExponent+1,x
.9be5	a9 08		lda #$08			lda 	#NSTFloat
.9be7	95 51		sta $51,x			sta 	NSStatus+1,x
.9be9	20 cf 93	jsr $93cf			jsr 	FloatAdd
.9bec					_CNTSNotFloat:
.9bec	20 19 9c	jsr $9c19			jsr 	MakePlusTwoString
.9bef	20 95 94	jsr $9495			jsr 	FloatFractionalPart 		; get the fractional part
.9bf2	20 46 95	jsr $9546			jsr 	NSNormalise					; normalise , exit if zero
.9bf5	f0 20		beq $9c17			beq 	_CNTSExit
.9bf7	a9 2e		lda #$2e			lda 	#"."
.9bf9	20 37 9c	jsr $9c37			jsr 	WriteDecimalBuffer 			; write decimal place
.9bfc					_CNTSDecimal:
.9bfc	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9bff	30 16		bmi $9c17			bmi 	_CNTSExit
.9c01	e8		inx				inx 								; x 10.0
.9c02	a9 0a		lda #$0a			lda 	#10
.9c04	20 8f 9d	jsr $9d8f			jsr 	NSMSetByte
.9c07	a9 08		lda #$08			lda 	#NSTFloat
.9c09	95 50		sta $50,x			sta 	NSStatus,x
.9c0b	ca		dex				dex
.9c0c	20 14 95	jsr $9514			jsr 	FloatMultiply
.9c0f	20 19 9c	jsr $9c19			jsr 	MakePlusTwoString
.9c12	20 95 94	jsr $9495			jsr 	FloatFractionalPart 		; get the fractional part
.9c15	80 e5		bra $9bfc			bra 	_CNTSDecimal 				; keep going.
.9c17					_CNTSExit:
.9c17	7a		ply				ply
.9c18	60		rts				rts
.9c19					MakePlusTwoString:
.9c19	da		phx				phx
.9c1a	20 70 9d	jsr $9d70			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c1d	e8		inx				inx 								; access it
.9c1e	e8		inx				inx
.9c1f	20 ed 94	jsr $94ed			jsr 	FloatIntegerPart 			; make it an integer
.9c22	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c24	20 ff 92	jsr $92ff			jsr 	ConvertInt32
.9c27	a2 00		ldx #$00			ldx	 	#0
.9c29					_MPTSCopy:
.9c29	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9c2c	20 37 9c	jsr $9c37			jsr 	WriteDecimalBuffer
.9c2f	e8		inx				inx
.9c30	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9c33	d0 f4		bne $9c29			bne 	_MPTSCopy
.9c35	fa		plx				plx
.9c36	60		rts				rts
.9c37					WriteDecimalBuffer:
.9c37	da		phx				phx
.9c38	ae 15 04	ldx $0415			ldx 	dbOffset
.9c3b	9d 9d 05	sta $059d,x			sta 	DecimalBuffer,x
.9c3e	9e 9e 05	stz $059e,x			stz 	DecimalBuffer+1,x
.9c41	ee 15 04	inc $0415			inc 	dbOffset
.9c44	fa		plx				plx
.9c45	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9c46					Unary_Left:
.9c46	fa		plx				plx
.9c47	18		clc				clc 								; only one parameter
.9c48	20 ab 9c	jsr $9cab			jsr 	SubstringInitial 			; set up.
.9c4b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9c4d	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c4f	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9c51	80 25		bra $9c78			bra 	SubstringMain
.9c53					Unary_Right:
.9c53	fa		plx				plx
.9c54	18		clc				clc 								; only one parameter
.9c55	20 ab 9c	jsr $9cab			jsr 	SubstringInitial 			; set up.
.9c58	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9c5a	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c5c	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9c5e	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9c60	b0 02		bcs $9c64			bcs 	_URNotUnderflow
.9c62	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9c64					_URNotUnderFlow:
.9c64	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9c66	80 10		bra $9c78			bra 	SubStringMain
.9c68					Unary_Mid:
.9c68	fa		plx				plx
.9c69	38		sec				sec 								; two parameters
.9c6a	20 ab 9c	jsr $9cab			jsr 	SubstringInitial 			; set up.
.9c6d	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9c6f	f0 04		beq $9c75			beq 	_UMError
.9c71	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9c73	80 03		bra $9c78			bra 	SubStringMain
.9c75					_UMError:
.9c75	4c 1a 9f	jmp $9f1a			jmp 	ArgumentError
.9c78					SubStringMain:
.9c78	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9c7a	d5 78		cmp $78,x			cmp 	NSExponent,x
.9c7c	b0 27		bcs $9ca5			bcs 	_SSMNull 					; if so, return an empty string.
.9c7e	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9c80	f0 23		beq $9ca5			beq 	_SSMNull 					; return empty string.
.9c82	18		clc				clc 								; add the offset +1 to the address and
.9c83	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp
.9c85	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9c87	85 36		sta $36				sta 	zTemp0
.9c89	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9c8b	69 00		adc #$00			adc 	#0
.9c8d	85 37		sta $37				sta 	zTemp0+1
.9c8f					_SSMNoCarry:
.9c8f	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9c91	20 bf a6	jsr $a6bf			jsr 	StringTempAllocate 			; allocate that many characters
.9c94	5a		phy				phy 								; save Y
.9c95	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9c97					_SSMCopy:
.9c97	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9c99	f0 08		beq $9ca3			beq 	_SSMEString 				; no more to copy
.9c9b	20 f8 a6	jsr $a6f8			jsr 	StringTempWrite 			; and write it out.
.9c9e	c8		iny				iny
.9c9f	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9ca1	d0 f4		bne $9c97			bne 	_SSMCopy
.9ca3					_SSMEString:
.9ca3	7a		ply				ply
.9ca4					_SSMExit:
.9ca4	60		rts				rts
.9ca5					_SSMNull:
.9ca5	a9 00		lda #$00			lda 	#0
.9ca7	20 bf a6	jsr $a6bf			jsr 	StringTempAllocate
.9caa	60		rts				rts
.9cab					SubstringInitial:
.9cab	da		phx				phx 								; save initial stack position
.9cac	08		php				php 								; save carry on stack indicating 2 parameters
.9cad	20 e5 9c	jsr $9ce5			jsr 	EvaluateString 				; get a string
.9cb0	5a		phy				phy 								; calculate length to exponent.
.9cb1	a0 ff		ldy #$ff			ldy 	#$FF
.9cb3					_SIFindLength:
.9cb3	c8		iny				iny
.9cb4	b1 36		lda ($36),y			lda 	(zTemp0),y
.9cb6	d0 fb		bne $9cb3			bne 	_SIFindLength
.9cb8	98		tya				tya
.9cb9	95 78		sta $78,x			sta 	NSExponent,x
.9cbb	7a		ply				ply
.9cbc	e8		inx				inx
.9cbd	20 6f 8e	jsr $8e6f			jsr 	CheckComma 					; comma next
.9cc0	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; get next parameter
.9cc3	28		plp				plp 								; is it the last parameter ?
.9cc4	90 07		bcc $9ccd			bcc 	_SSIExit 					; if so, exit.
.9cc6	e8		inx				inx
.9cc7	20 6f 8e	jsr $8e6f			jsr 	CheckComma 					; comma next
.9cca	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; get last parameter
.9ccd					_SSIExit:
.9ccd	fa		plx				plx
.9cce	20 67 8e	jsr $8e67			jsr 	CheckRightBracket 			; check closing bracket
.9cd1	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9cd2					EvaluateValue:
.9cd2	48		pha				pha
.9cd3	20 84 93	jsr $9384			jsr		EvaluateExpression 			; expression
.9cd6	20 47 96	jsr $9647			jsr 	Dereference					; derefernce it
.9cd9	68		pla				pla
.9cda	60		rts				rts
.9cdb					EvaluateNumber:
.9cdb	20 d2 9c	jsr $9cd2			jsr 	EvaluateValue 				; get a value
.9cde	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9ce0	29 10		and #$10			and 	#NSBIsString
.9ce2	d0 13		bne $9cf7			bne 	HelperTypeError
.9ce4	60		rts				rts
.9ce5					EvaluateString:
.9ce5	20 d2 9c	jsr $9cd2			jsr 	EvaluateValue 				; get a value
.9ce8	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9cea	29 10		and #$10			and 	#NSBIsString
.9cec	f0 09		beq $9cf7			beq 	HelperTypeError
.9cee					CopyAddressToTemp0:
.9cee	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9cf0	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9cf2	b5 60		lda $60,x			lda 	NSMantissa1,x
.9cf4	85 37		sta $37				sta 	zTemp0+1
.9cf6	60		rts				rts
.9cf7					HelperTypeError:
.9cf7	4c 15 9f	jmp $9f15			jmp 	TypeError
.9cfa					EvaluateInteger:
.9cfa	20 db 9c	jsr $9cdb			jsr 	EvaluateNumber
.9cfd	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9cff	d0 09		bne $9d0a			bne 	HelperValueError 			; if not, it's a float.
.9d01	60		rts				rts
.9d02					EvaluateUnsignedInteger:
.9d02	20 fa 9c	jsr $9cfa			jsr 	EvaluateInteger 			; check integer is +ve
.9d05	b5 50		lda $50,x			lda 	NSStatus,x
.9d07	30 01		bmi $9d0a			bmi 	HelperValueError
.9d09	60		rts				rts
.9d0a					HelperValueError:
.9d0a	4c 1a 9f	jmp $9f1a			jmp 	ArgumentError
.9d0d						Evaluate16BitInteger:
.9d0d	20 02 9d	jsr $9d02			jsr	 	EvaluateUnsignedInteger		; get integer
.9d10	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d12	15 68		ora $68,x			ora 	NSMantissa2,x
.9d14	d0 f4		bne $9d0a			bne 	HelperValueError
.9d16	60		rts				rts
.9d17					Evaluate16BitIntegerSigned:
.9d17	20 fa 9c	jsr $9cfa			jsr	 	EvaluateInteger				; get integer
.9d1a	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d1c	15 68		ora $68,x			ora 	NSMantissa2,x
.9d1e	d0 ea		bne $9d0a			bne 	HelperValueError
.9d20	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9d22	10 03		bpl $9d27			bpl 	_EISNotSigned
.9d24	20 56 9d	jsr $9d56			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9d27					_EISNotSigned:
.9d27	60		rts				rts
.9d28					Evaluate8BitInteger:
.9d28	20 02 9d	jsr $9d02			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9d2b	d0 dd		bne $9d0a			bne 	HelperValueError
.9d2d	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9d2f	15 68		ora $68,x			ora 	NSMantissa2,x
.9d31	15 60		ora $60,x			ora 	NSMantissa1,x
.9d33	d0 d5		bne $9d0a			bne 	HelperValueError
.9d35	b5 58		lda $58,x			lda 	NSMantissa0,x
.9d37	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9d38					Multiply8x8:
.9d38	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9d39	85 36		sta $36			  	sta 	zTemp0
.9d3b	86 37		stx $37				stx 	zTemp0+1
.9d3d	a9 00		lda #$00			lda 	#0
.9d3f	a2 08		ldx #$08			ldx 	#8
.9d41					_M88Loop:
.9d41	90 03		bcc $9d46			bcc 	_M88NoAdd
.9d43	18		clc				clc
.9d44	65 37		adc $37				adc 	zTemp0+1
.9d46					_M88NoAdd:
.9d46	6a		ror a				ror 	a
.9d47	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9d49	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9d4a	d0 f5		bne $9d41			bne 	_M88Loop
.9d4c	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9d4e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9d4f					NSMNegate:
.9d4f	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9d51	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9d53	95 50		sta $50,x			sta 	NSStatus,x
.9d55	60		rts				rts
.9d56					NSMNegateMantissa:
.9d56	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9d57	a9 00		lda #$00			lda 	#0
.9d59	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9d5b	95 58		sta $58,x			sta 	NSMantissa0,x
.9d5d	a9 00		lda #$00			lda 	#0
.9d5f	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9d61	95 60		sta $60,x			sta 	NSMantissa1,x
.9d63	a9 00		lda #$00			lda 	#0
.9d65	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9d67	95 68		sta $68,x			sta 	NSMantissa2,x
.9d69	a9 00		lda #$00			lda 	#0
.9d6b	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9d6d	95 70		sta $70,x			sta 	NSMantissa3,x
.9d6f	60		rts				rts
.9d70					NSMShiftUpTwo:
.9d70	b5 58		lda $58,x			lda 	NSMantissa0,x
.9d72	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d74	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d76	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9d78	b5 68		lda $68,x			lda 	NSMantissa2,x
.9d7a	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9d7c	b5 70		lda $70,x			lda 	NSMantissa3,x
.9d7e	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9d80	b5 78		lda $78,x			lda 	NSExponent,x
.9d82	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9d84	b5 50		lda $50,x			lda 	NSStatus,x
.9d86	95 52		sta $52,x			sta 	NSStatus+2,x
.9d88	60		rts				rts
.9d89					NSMSetZeroMantissaOnly:
.9d89	a9 00		lda #$00			lda 	#0
.9d8b	80 06		bra $9d93			bra 	NSMSetMantissa
.9d8d					NSMSetZero:
.9d8d	a9 00		lda #$00			lda 	#0
.9d8f					NSMSetByte:
.9d8f	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9d91	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9d93					NSMSetMantissa:
.9d93	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9d95	74 60		stz $60,x			stz 	NSMantissa1,x
.9d97	74 68		stz $68,x			stz 	NSMantissa2,x
.9d99	74 70		stz $70,x			stz 	NSMantissa3,x
.9d9b	60		rts				rts
.9d9c					NSMShiftLeft:
.9d9c	18		clc				clc
.9d9d					NSMRotateLeft:
.9d9d	36 58		rol $58,x			rol 	NSMantissa0,x
.9d9f	36 60		rol $60,x			rol		NSMantissa1,x
.9da1	36 68		rol $68,x			rol		NSMantissa2,x
.9da3	36 70		rol $70,x			rol		NSMantissa3,x
.9da5	60		rts				rts
.9da6					NSMShiftRight:
.9da6	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9da8	76 68		ror $68,x			ror		NSMantissa2,x
.9daa	76 60		ror $60,x			ror		NSMantissa1,x
.9dac	76 58		ror $58,x			ror		NSMantissa0,x
.9dae	60		rts				rts
.9daf					NSMIsZero:
.9daf	b5 70		lda $70,x			lda 	NSMantissa3,x
.9db1	15 68		ora $68,x			ora		NSMantissa2,x
.9db3	15 60		ora $60,x			ora		NSMantissa1,x
.9db5	15 58		ora $58,x			ora		NSMantissa0,x
.9db7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9db8					TickHandler:
.9db8	5a		phy				phy 								; need to preserve Y
.9db9	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9dbc	7a		ply				ply
.9dbd	60		rts				rts
.05af					LastTick:
>05af							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9dbe					Assemble_ora:
.9dbe	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dc1	01					.byte $01
.9dc2					Assemble_and:
.9dc2	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dc5	21					.byte $21
.9dc6					Assemble_eor:
.9dc6	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dc9	41					.byte $41
.9dca					Assemble_adc:
.9dca	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dcd	61					.byte $61
.9dce					Assemble_sta:
.9dce	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dd1	81					.byte $81
.9dd2					Assemble_lda:
.9dd2	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dd5	a1					.byte $a1
.9dd6					Assemble_cmp:
.9dd6	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dd9	c1					.byte $c1
.9dda					Assemble_sbc:
.9dda	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9ddd	e1					.byte $e1
.9dde					Assemble_asl:
.9dde	20 46 80	jsr $8046		jsr	AssembleGroup2
>9de1	02					.byte $02
>9de2	75					.byte $75
.9de3					Assemble_rol:
.9de3	20 46 80	jsr $8046		jsr	AssembleGroup2
>9de6	22					.byte $22
>9de7	75					.byte $75
.9de8					Assemble_lsr:
.9de8	20 46 80	jsr $8046		jsr	AssembleGroup2
>9deb	42					.byte $42
>9dec	75					.byte $75
.9ded					Assemble_ror:
.9ded	20 46 80	jsr $8046		jsr	AssembleGroup2
>9df0	62					.byte $62
>9df1	75					.byte $75
.9df2					Assemble_stx:
.9df2	20 46 80	jsr $8046		jsr	AssembleGroup2
>9df5	82					.byte $82
>9df6	50					.byte $50
.9df7					Assemble_ldx:
.9df7	20 46 80	jsr $8046		jsr	AssembleGroup2
>9dfa	a2					.byte $a2
>9dfb	d0					.byte $d0
.9dfc					Assemble_dec:
.9dfc	20 46 80	jsr $8046		jsr	AssembleGroup2
>9dff	c2					.byte $c2
>9e00	55					.byte $55
.9e01					Assemble_inc:
.9e01	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e04	e2					.byte $e2
>9e05	55					.byte $55
.9e06					Assemble_stz:
.9e06	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e09	60					.byte $60
>9e0a	44					.byte $44
.9e0b					Assemble_bit:
.9e0b	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e0e	20					.byte $20
>9e0f	55					.byte $55
.9e10					Assemble_sty:
.9e10	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e13	80					.byte $80
>9e14	54					.byte $54
.9e15					Assemble_ldy:
.9e15	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e18	a0					.byte $a0
>9e19	d5					.byte $d5
.9e1a					Assemble_cpy:
.9e1a	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e1d	c0					.byte $c0
>9e1e	d4					.byte $d4
.9e1f					Assemble_cpx:
.9e1f	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e22	e0					.byte $e0
>9e23	d0					.byte $d0
.9e24					Assemble_tsb:
.9e24	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e27	00					.byte $00
>9e28	50					.byte $50
.9e29					Assemble_trb:
.9e29	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e2c	10					.byte $10
>9e2d	50					.byte $50
.9e2e					Assemble_jsr:
.9e2e	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e31	14					.byte $14
>9e32	10					.byte $10
.9e33					Assemble_jmp:
.9e33	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e36	40					.byte $40
>9e37	10					.byte $10
.9e38					Assemble_bpl:
.9e38	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e3b	10					.byte $10
.9e3c					Assemble_bmi:
.9e3c	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e3f	30					.byte $30
.9e40					Assemble_bvc:
.9e40	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e43	50					.byte $50
.9e44					Assemble_bvs:
.9e44	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e47	70					.byte $70
.9e48					Assemble_bcc:
.9e48	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e4b	90					.byte $90
.9e4c					Assemble_bcs:
.9e4c	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e4f	b0					.byte $b0
.9e50					Assemble_bne:
.9e50	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e53	d0					.byte $d0
.9e54					Assemble_beq:
.9e54	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e57	f0					.byte $f0
.9e58					Assemble_bra:
.9e58	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e5b	80					.byte $80
.9e5c					Assemble_brk:
.9e5c	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e5f	00					.byte $00
.9e60					Assemble_php:
.9e60	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e63	08					.byte $08
.9e64					Assemble_clc:
.9e64	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e67	18					.byte $18
.9e68					Assemble_plp:
.9e68	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e6b	28					.byte $28
.9e6c					Assemble_sec:
.9e6c	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e6f	38					.byte $38
.9e70					Assemble_rti:
.9e70	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e73	40					.byte $40
.9e74					Assemble_pha:
.9e74	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e77	48					.byte $48
.9e78					Assemble_cli:
.9e78	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e7b	58					.byte $58
.9e7c					Assemble_phy:
.9e7c	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e7f	5a					.byte $5a
.9e80					Assemble_rts:
.9e80	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e83	60					.byte $60
.9e84					Assemble_pla:
.9e84	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e87	68					.byte $68
.9e88					Assemble_sei:
.9e88	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e8b	78					.byte $78
.9e8c					Assemble_ply:
.9e8c	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e8f	7a					.byte $7a
.9e90					Assemble_dey:
.9e90	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e93	88					.byte $88
.9e94					Assemble_txa:
.9e94	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e97	8a					.byte $8a
.9e98					Assemble_tya:
.9e98	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e9b	98					.byte $98
.9e9c					Assemble_txs:
.9e9c	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e9f	9a					.byte $9a
.9ea0					Assemble_tay:
.9ea0	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ea3	a8					.byte $a8
.9ea4					Assemble_tax:
.9ea4	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ea7	aa					.byte $aa
.9ea8					Assemble_clv:
.9ea8	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9eab	b8					.byte $b8
.9eac					Assemble_tsx:
.9eac	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9eaf	ba					.byte $ba
.9eb0					Assemble_iny:
.9eb0	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9eb3	c8					.byte $c8
.9eb4					Assemble_dex:
.9eb4	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9eb7	ca					.byte $ca
.9eb8					Assemble_cld:
.9eb8	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ebb	d8					.byte $d8
.9ebc					Assemble_phx:
.9ebc	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ebf	da					.byte $da
.9ec0					Assemble_stp:
.9ec0	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ec3	db					.byte $db
.9ec4					Assemble_inx:
.9ec4	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ec7	e8					.byte $e8
.9ec8					Assemble_nop:
.9ec8	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ecb	ea					.byte $ea
.9ecc					Assemble_sed:
.9ecc	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ecf	f8					.byte $f8
.9ed0					Assemble_plx:
.9ed0	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ed3	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9ed4					DecimalScalarTable:
>9ed4	66 66 66 66				.dword $66666666 ; 0.1
>9ed8	de					.byte $de
>9ed9	1f 85 eb 51				.dword $51eb851f ; 0.01
>9edd	db					.byte $db
>9ede	4c 37 89 41				.dword $4189374c ; 0.001
>9ee2	d8					.byte $d8
>9ee3	ac 8b db 68				.dword $68db8bac ; 0.0001
>9ee7	d4					.byte $d4
>9ee8	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9eec	d1					.byte $d1
>9eed	83 de 1b 43				.dword $431bde83 ; 1e-06
>9ef1	ce					.byte $ce
>9ef2	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9ef6	ca					.byte $ca
>9ef7	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9efb	c7					.byte $c7
>9efc	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f00	c4					.byte $c4
>9f01	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f05	c0					.byte $c0
>9f06	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9f0a	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9f0b					SyntaxError:
.9f0b	a9 02		lda #$02		lda	#2
.9f0d	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.9f10					RangeError:
.9f10	a9 04		lda #$04		lda	#4
.9f12	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.9f15					TypeError:
.9f15	a9 05		lda #$05		lda	#5
.9f17	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.9f1a					ArgumentError:
.9f1a	a9 07		lda #$07		lda	#7
.9f1c	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.9f1f					NotDoneError:
.9f1f	a9 0c		lda #$0c		lda	#12
.9f21	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.9f24					ErrorText:
>9f24	42 72 65 61 6b 00			.text	"Break",0
>9f2a	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9f32	72 72 6f 72 00
>9f37	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9f3f	20 62 79 20 7a 65 72 6f 00
>9f48	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9f50	61 6e 67 65 00
>9f55	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9f5d	6d 61 74 63 68 00
>9f63	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9f6b	65 6d 6f 72 79 00
>9f71	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>9f79	61 72 67 75 6d 65 6e 74 00
>9f82	53 74 6f 70 00				.text	"Stop",0
>9f87	53 74 72 69 6e 67 20 74			.text	"String too long",0
>9f8f	6f 6f 20 6c 6f 6e 67 00
>9f97	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>9f9f	6e 20 66 61 69 6c 65 64 00
>9fa8	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>9fb0	61 74 61 00
>9fb4	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>9fbc	65 6e 74 65 64 00
>9fc2	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>9fca	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>9fd6	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>9fde	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>9feb	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>9ff3	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a000	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a008	68 6f 75 74 20 57 68 69 6c 65 00
>a013	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a01b	68 6f 75 74 20 46 6f 72 00
>a024	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a02c	61 63 6b 20 66 75 6c 6c 00
>a035	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a03d	75 63 74 75 72 65 00
>a044	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a04c	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a059	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a061	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a06f	41 72 72 61 79 20 73 69			.text	"Array size",0
>a077	7a 65 00
>a07a	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a082	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a08a	52 65 6c 65 61 73 65 20			.text "Release Alpha 7 (27-Nov-22). "
>a092	41 6c 70 68 61 20 37 20 28 32 37 2d 4e 6f 76 2d
>a0a2	32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a0a7					RectangleCommand:
.a0a7	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a0a9	80 02		bra $a0ad			bra 	ShapeDrawCmd
.a0ab					CircleCommand:
.a0ab	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a0ad					ShapeDrawCmd:
.a0ad	20 37 a1	jsr $a137			jsr 	RunGraphicsCommand
.a0b0					ShapeDraw:
.a0b0	0d b1 05	ora $05b1			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a0b3	4c 2b a1	jmp $a12b			jmp 	ExecuteGraphicCommand	 	; and complete
.a0b6					SpriteCommand:
.a0b6	a2 00		ldx #$00			ldx 	#0
.a0b8	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; get image number.
.a0bb	5a		phy				phy
.a0bc	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a0be	a6 58		ldx $58				ldx 	NSMantissa0
.a0c0	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a0c2	b0 0d		bcs $a0d1			bcs 	_SCRange
.a0c4	a0 ff		ldy #$ff			ldy 	#255
.a0c6	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a0c9	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a0cb	7a		ply				ply
.a0cc	20 37 a1	jsr $a137			jsr 	RunGraphicsCommand
.a0cf	80 5a		bra $a12b			bra 	ExecuteGraphicCommand
.a0d1					_SCRange:
.a0d1	4c 10 9f	jmp $9f10			jmp 	RangeError
.a0d4					ImageCommand:
.a0d4	a2 00		ldx #$00			ldx 	#0
.a0d6	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; get image number.
.a0d9	20 37 a1	jsr $a137			jsr 	RunGraphicsCommand
.a0dc					ImageRunDraw:
.a0dc	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a0de	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a0e1	ad b7 05	lda $05b7			lda 	gxDrawScale
.a0e4	0a		asl a				asl 	a
.a0e5	0a		asl a				asl 	a
.a0e6	0a		asl a				asl 	a
.a0e7	a8		tay				tay
.a0e8	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a0ea	a6 58		ldx $58				ldx 	NSMantissa0
.a0ec	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a0ef	60		rts				rts
.a0f0					TextCommand:
.a0f0	a2 00		ldx #$00			ldx 	#0
.a0f2	20 e5 9c	jsr $9ce5			jsr 	EvaluateString 				; get text
.a0f5	20 37 a1	jsr $a137			jsr 	RunGraphicsCommand
.a0f8					TextRunDraw:
.a0f8	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a0fa	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a0fd	a0 00		ldy #$00			ldy 	#0
.a0ff					_IRDLoop:
.a0ff	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a101	85 37		sta $37				sta 	zTemp0+1
.a103	a5 58		lda $58				lda 	NSMantissa0
.a105	85 36		sta $36				sta 	zTemp0
.a107	b1 36		lda ($36),y			lda 	(zTemp0),y
.a109	f0 13		beq $a11e			beq 	_IRDExit
.a10b	5a		phy				phy									; save string pos
.a10c	48		pha				pha 								; save char
.a10d	ad b7 05	lda $05b7			lda 	gxDrawScale 				; get scale
.a110	0a		asl a				asl 	a
.a111	0a		asl a				asl 	a
.a112	0a		asl a				asl 	a
.a113	a8		tay				tay
.a114	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a116	fa		plx				plx 								; char to draw
.a117	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a11a	7a		ply				ply 								; restore string pos
.a11b	c8		iny				iny
.a11c	90 e1		bcc $a0ff			bcc 	_IRDLoop 					; go back if no error.
.a11e					_IRDExit:
.a11e	60		rts				rts
.a11f					PlotCommand:
.a11f	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a121	20 37 a1	jsr $a137			jsr 	RunGraphicsCommand
.a124	80 05		bra $a12b			bra 	ExecuteGraphicCommand
.a126					LineCommand:
.a126	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a128	20 37 a1	jsr $a137			jsr 	RunGraphicsCommand
.a12b					ExecuteGraphicCommand:
.a12b	0d b0 05	ora $05b0			ora 	gxCommandID 				; make a full command
.a12e	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a131	b0 01		bcs $a134			bcs 	_EGCError
.a133	60		rts				rts
.a134					_EGCError:
.a134	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError
.a137					RunGraphicsCommand:
.a137	8d b0 05	sta $05b0			sta 	gxCommandID					; save TODO graphics command.
.a13a	68		pla				pla 								; pop handler address
.a13b	fa		plx				plx
.a13c	1a		inc a				inc 	a
.a13d	d0 01		bne $a140			bne 	_RGINoCarry
.a13f	e8		inx				inx
.a140					_RGINoCarry:
.a140	8d b5 05	sta $05b5			sta 	GXHandler
.a143	8e b6 05	stx $05b6			stx 	GXHandler+1
.a146					_RGICommandLoop:
.a146	b1 30		lda ($30),y			lda 	(codePtr),y
.a148	c8		iny				iny
.a149	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a14b	f0 53		beq $a1a0			beq 	_RGI_To
.a14d	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a14f	f0 55		beq $a1a6			beq 	_RGI_Here
.a151	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a153	f0 3d		beq $a192			beq 	_RGI_Exit
.a155	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a157	f0 39		beq $a192			beq 	_RGI_Exit
.a159	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a15b	f0 3e		beq $a19b			beq 	_RGI_Frame
.a15d	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a15f	f0 33		beq $a194			beq 	_RGI_Solid
.a161	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a163	f0 4b		beq $a1b0			beq 	_RGI_By
.a165	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a167	f0 17		beq $a180			beq 	_RGI_Move2
.a169	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a16b	f0 62		beq $a1cf			beq 	_RGI_Dim
.a16d	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a16f	f0 74		beq $a1e5			beq 	_RGI_Colour
.a171	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a173	f0 70		beq $a1e5			beq 	_RGI_Colour
.a175	ae b0 05	ldx $05b0			ldx 	gxCommandID
.a178	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a17a	d0 03		bne $a17f			bne 	_RGI_Move 					; move
.a17c	4c 0d a2	jmp $a20d			jmp		_RGI_SpriteInstructions
.a17f					_RGI_Move:
.a17f	88		dey				dey 								; unpick get.
.a180					_RGI_Move2:
.a180	20 33 a2	jsr $a233			jsr 	GCGetCoordinatePair 		; move to here
.a183	20 5a a2	jsr $a25a			jsr 	GCCopyPairToStore 			; save
.a186	5a		phy				phy
.a187	20 50 a2	jsr $a250			jsr 	GCLoadAXY 					; load in
.a18a	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a18c	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a18f	7a		ply				ply
.a190	80 b4		bra $a146			bra 	_RGICommandLoop 			; and go round
.a192					_RGI_Exit:
.a192	88		dey				dey 								; unpick : / EOL
.a193	60		rts				rts
.a194					_RGI_Solid:
.a194	a9 02		lda #$02			lda 	#2
.a196	8d b1 05	sta $05b1			sta 	gxFillSolid
.a199	80 ab		bra $a146			bra 	_RGICommandLoop
.a19b					_RGI_Frame:
.a19b	9c b1 05	stz $05b1			stz 	gxFillSolid
.a19e	80 a6		bra $a146			bra 	_RGICommandLoop
.a1a0					_RGI_To:
.a1a0	20 33 a2	jsr $a233			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a1a3	20 5a a2	jsr $a25a			jsr 	GCCopyPairToStore
.a1a6					_RGI_Here:
.a1a6	5a		phy				phy
.a1a7	20 50 a2	jsr $a250			jsr 	GCLoadAXY 					; load it into AXY
.a1aa	20 0a a2	jsr $a20a			jsr 	_RGICallHandler 			; go do whatever it is.
.a1ad	7a		ply				ply
.a1ae	80 96		bra $a146			bra 	_RGICommandLoop 			; and go round
.a1b0					_RGI_By:
.a1b0	20 40 a2	jsr $a240			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a1b3	18		clc				clc
.a1b4	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a1b6	6d b2 05	adc $05b2			adc 	gxxPos
.a1b9	8d b2 05	sta $05b2			sta 	gxXPos
.a1bc	a5 61		lda $61				lda 	NSMantissa1+1
.a1be	6d b3 05	adc $05b3			adc 	gxxPos+1
.a1c1	8d b3 05	sta $05b3			sta 	gxXPos+1
.a1c4	a5 5a		lda $5a				lda 	NSMantissa0+2
.a1c6	18		clc				clc
.a1c7	6d b4 05	adc $05b4			adc 	gxYPos
.a1ca	8d b4 05	sta $05b4			sta 	gxYPos
.a1cd	80 d7		bra $a1a6			bra 	_RGI_Here
.a1cf					_RGI_Dim:
.a1cf	a2 01		ldx #$01			ldx	 	#1
.a1d1	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger
.a1d4	a5 59		lda $59				lda 	NSMantissa0+1
.a1d6	c9 00		cmp #$00			cmp 	#0
.a1d8	f0 2d		beq $a207			beq 	_RGIRange
.a1da	c9 09		cmp #$09			cmp 	#8+1
.a1dc	b0 29		bcs $a207			bcs		_RGIRange
.a1de	3a		dec a				dec 	a
.a1df	8d b7 05	sta $05b7			sta 	gxDrawScale
.a1e2	4c 46 a1	jmp $a146			jmp 	_RGICommandLoop
.a1e5					_RGI_Colour:
.a1e5	a2 01		ldx #$01			ldx 	#1 							; colour
.a1e7	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger
.a1ea	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a1ec	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero
.a1ef	b1 30		lda ($30),y			lda 	(codePtr),y
.a1f1	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a1f3	d0 04		bne $a1f9			bne 	_RGICDefaultMode
.a1f5	c8		iny				iny
.a1f6	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger
.a1f9					_RGICDefaultMode:
.a1f9	5a		phy				phy
.a1fa	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a1fc	a6 59		ldx $59				ldx 	NSMantissa0+1
.a1fe	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a200	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a203	7a		ply				ply
.a204	4c 46 a1	jmp $a146			jmp 	_RGICommandLoop 			; and go round
.a207					_RGIRange:
.a207	4c 10 9f	jmp $9f10			jmp 	RangeError
.a20a					_RGICallHandler:
.a20a	6c b5 05	jmp ($05b5)			jmp 	(GXHandler)
.a20d					_RGI_SpriteInstructions:
.a20d	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a20f	f0 07		beq $a218			beq 	_RGISpriteOff
.a211	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a213	f0 13		beq $a228			beq 	_RGISetImage
.a215	4c 7f a1	jmp $a17f			jmp 	_RGI_Move
.a218					_RGISpriteOff:
.a218	5a		phy				phy
.a219	a0 01		ldy #$01			ldy 	#1
.a21b	a2 00		ldx #$00			ldx 	#0
.a21d					_RGIDoCommandLoop:
.a21d	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a21f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a222	7a		ply				ply
.a223	b0 e2		bcs $a207			bcs 	_RGIRange
.a225	4c 46 a1	jmp $a146			jmp 	_RGICommandLoop
.a228					_RGISetImage:
.a228	a2 01		ldx #$01			ldx 	#1
.a22a	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger
.a22d	5a		phy				phy
.a22e	aa		tax				tax
.a22f	a0 00		ldy #$00			ldy 	#0
.a231	80 ea		bra $a21d			bra 	_RGIDoCommandLoop
.a233					GCGetCoordinatePair:
.a233	a2 01		ldx #$01			ldx 	#1
.a235	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger
.a238	20 6f 8e	jsr $8e6f			jsr 	CheckComma
.a23b	e8		inx				inx
.a23c	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger
.a23f	60		rts				rts
.a240					GCSignedCoordinatePair:
.a240	a2 01		ldx #$01			ldx 	#1
.a242	20 17 9d	jsr $9d17			jsr 	Evaluate16BitIntegerSigned
.a245	20 6f 8e	jsr $8e6f			jsr 	CheckComma
.a248	e8		inx				inx
.a249	20 17 9d	jsr $9d17			jsr 	Evaluate16BitIntegerSigned
.a24c	60		rts				rts
.a24d					_GCCPRange:
.a24d	4c 10 9f	jmp $9f10			jmp 	RangeError
.a250					GCLoadAXY:
.a250	ad b3 05	lda $05b3			lda 	gxXPos+1
.a253	ae b2 05	ldx $05b2			ldx 	gxXPos
.a256	ac b4 05	ldy $05b4			ldy 	gxYPos
.a259	60		rts				rts
.a25a					GCCopyPairToStore:
.a25a	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a25c	8d b2 05	sta $05b2			sta 	gxXPos
.a25f	a5 61		lda $61				lda 	NSMantissa1+1
.a261	8d b3 05	sta $05b3			sta 	gxXPos+1
.a264	a5 5a		lda $5a				lda 	NSMantissa0+2
.a266	8d b4 05	sta $05b4			sta 	gxYPos
.a269	60		rts				rts
.05b0					gxCommandID:
>05b0							.fill 	1
.05b1					gxFillSolid:
>05b1							.fill 	1
.05b2					gxXPos:
>05b2							.fill 	2
.05b4					gxYPos:
>05b4							.fill 	1
.05b5					gxHandler:
>05b5							.fill 	2
.05b7					gxDrawScale:
>05b7							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a26a					BitmapCtrl:
.a26a	b1 30		lda ($30),y			lda 	(codePtr),y
.a26c	c8		iny				iny
.a26d	a2 01		ldx #$01			ldx 	#1
.a26f	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a271	f0 11		beq $a284			beq 	BitmapSwitch
.a273	ca		dex				dex
.a274	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a276	f0 0c		beq $a284			beq 	BitmapSwitch
.a278	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; get the colour
.a27b	5a		phy				phy
.a27c	aa		tax				tax
.a27d	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a27f	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a282	7a		ply				ply
.a283	60		rts				rts
.a284					BitmapSwitch:
.a284	5a		phy				phy
.a285	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a287	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a289	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a28c	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a28e	a0 00		ldy #$00			ldy 	#0
.a290	a2 ff		ldx #$ff			ldx 	#$FF
.a292	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a295	9c b1 05	stz $05b1			stz 	gxFillSolid
.a298	9c b2 05	stz $05b2			stz 	gxXPos
.a29b	9c b3 05	stz $05b3			stz 	gxXPos+1
.a29e	9c b4 05	stz $05b4			stz 	gxYPos
.a2a1	9c b7 05	stz $05b7			stz 	gxDrawScale
.a2a4	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a2a6	a2 00		ldx #$00			ldx 	#0
.a2a8	a0 00		ldy #$00			ldy 	#0
.a2aa	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2ad	7a		ply				ply
.a2ae	60		rts				rts
.a2af					SpritesCtrl:
.a2af	b1 30		lda ($30),y			lda 	(codePtr),y
.a2b1	c8		iny				iny
.a2b2	a2 01		ldx #$01			ldx 	#1
.a2b4	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a2b6	f0 08		beq $a2c0			beq 	SpriteSwitch
.a2b8	ca		dex				dex
.a2b9	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a2bb	f0 03		beq $a2c0			beq 	SpriteSwitch
.a2bd	4c 0b 9f	jmp $9f0b			jmp 	SyntaxError
.a2c0					SpriteSwitch:
.a2c0	5a		phy				phy
.a2c1	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a2c3	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a2c5	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2c8	7a		ply				ply
.a2c9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a2ca					GfxCommand:
.a2ca	a2 00		ldx #$00			ldx 	#0
.a2cc	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; command
.a2cf	20 6f 8e	jsr $8e6f			jsr 	CheckComma
.a2d2	e8		inx				inx
.a2d3	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger 		; X
.a2d6	20 6f 8e	jsr $8e6f			jsr 	CheckComma
.a2d9	e8		inx				inx
.a2da	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; Y
.a2dd	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a2df	4a		lsr a				lsr 	a
.a2e0	d0 12		bne $a2f4			bne 	_GfxError
.a2e2	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a2e4	b0 0e		bcs $a2f4			bcs 	_GfxError 					; bit 7 should have been zero
.a2e6	5a		phy				phy 								; save pos
.a2e7	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a2e9	a6 59		ldx $59				ldx 	NSMantissa0+1
.a2eb	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2ed	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2f0	b0 02		bcs $a2f4			bcs 	_GfxError
.a2f2	7a		ply				ply 								; restore pos and exit.
.a2f3	60		rts				rts
.a2f4					_GfxError:
.a2f4	4c 10 9f	jmp $9f10			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a2f7					UnaryHit:
.a2f7	fa		plx				plx
.a2f8	a9 36		lda #$36			lda 	#zTemp0
.a2fa	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a2fd	20 6f 8e	jsr $8e6f			jsr 	CheckComma
.a300	e8		inx				inx
.a301	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a304	20 67 8e	jsr $8e67			jsr		CheckRightBracket
.a307	ca		dex				dex 								; fix back up again.
.a308	da		phx				phx 								; save X/Y
.a309	5a		phy				phy
.a30a	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a30c	b5 58		lda $58,x			lda 	NSMantissa0,x
.a30e	aa		tax				tax
.a30f	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a311	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a314	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a315	7a		ply				ply 								; restore XY
.a316	fa		plx				plx
.a317	20 8f 9d	jsr $9d8f			jsr 	NSMSetByte 					; return the hit result
.a31a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a31b					PaletteCommand:
.a31b	a2 00		ldx #$00			ldx 	#0
.a31d	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; colour
.a320	20 6f 8e	jsr $8e6f			jsr 	CheckComma
.a323	e8		inx				inx
.a324	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger 		; r
.a327	20 6f 8e	jsr $8e6f			jsr 	CheckComma
.a32a	e8		inx				inx
.a32b	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; g
.a32e	20 6f 8e	jsr $8e6f			jsr 	CheckComma
.a331	e8		inx				inx
.a332	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; b
.a335	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a337	85 36		sta $36				sta 	zTemp0
.a339	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a33b	85 37		sta $37				sta 	zTemp0+1
.a33d	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a33f	26 37		rol $37				rol	 	zTemp0+1
.a341	06 36		asl $36				asl 	zTemp0
.a343	26 37		rol $37				rol	 	zTemp0+1
.a345	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a347	85 01		sta $01				sta 	1
.a349	5a		phy				phy
.a34a	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a34c	92 36		sta ($36)			sta 	(zTemp0)
.a34e	a0 01		ldy #$01			ldy 	#1
.a350	a5 5a		lda $5a				lda 	NSMantissa0+2
.a352	91 36		sta ($36),y			sta 	(zTemp0),y
.a354	a5 59		lda $59				lda 	NSMantissa0+1
.a356	c8		iny				iny
.a357	91 36		sta ($36),y			sta 	(zTemp0),y
.a359	7a		ply				ply
.a35a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a35b					UnaryEvent:
.a35b	fa		plx				plx
.a35c	20 09 a4	jsr $a409			jsr 	TimerToStackX 				; timer in +0
.a35f	e8		inx				inx  								; put reference into +1
.a360	20 ce 97	jsr $97ce			jsr 	EvaluateTerm
.a363	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a365	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a367	d0 4c		bne $a3b5			bne 	_UEType
.a369	e8		inx				inx 								; put the step in +2
.a36a	20 6f 8e	jsr $8e6f			jsr 	CheckComma
.a36d	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger
.a370	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.a373	ca		dex				dex
.a374	ca		dex				dex
.a375	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a377	85 36		sta $36				sta 	zTemp0
.a379	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a37b	85 37		sta $37				sta 	zTemp0+1
.a37d	5a		phy				phy
.a37e	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a380	b1 36		lda ($36),y			lda 	(zTemp0),y
.a382	30 2d		bmi $a3b1			bmi 	_UEFalse 					; exit if signed.
.a384	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a386	b5 58		lda $58,x			lda 	NSMantissa0,x
.a388	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a38a	c8		iny				iny
.a38b	b5 60		lda $60,x			lda 	NSMantissa1,x
.a38d	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a38f	c8		iny				iny
.a390	b5 68		lda $68,x			lda 	NSMantissa2,x
.a392	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a394	90 1b		bcc $a3b1			bcc 	_UEFalse 					; no, return FALSE.
.a396	18		clc				clc
.a397	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a399	b5 58		lda $58,x			lda 	NSMantissa0,x
.a39b	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a39d	91 36		sta ($36),y			sta 	(zTemp0),y
.a39f	c8		iny				iny
.a3a0	b5 60		lda $60,x			lda 	NSMantissa1,x
.a3a2	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a3a4	91 36		sta ($36),y			sta 	(zTemp0),y
.a3a6	c8		iny				iny
.a3a7	b5 68		lda $68,x			lda 	NSMantissa2,x
.a3a9	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a3ab	91 36		sta ($36),y			sta 	(zTemp0),y
.a3ad	7a		ply				ply
.a3ae	4c ed 8e	jmp $8eed			jmp 	ReturnTrue
.a3b1					_UEFalse:
.a3b1	7a		ply				ply 								; restore Y
.a3b2	4c f8 8e	jmp $8ef8			jmp 	ReturnFalse 				; and return False
.a3b5					_UEType:
.a3b5	4c 15 9f	jmp $9f15			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a3b8					UnaryJoyX:
.a3b8	18		clc				clc
.a3b9	80 01		bra $a3bc			bra 	JoyMain
.a3bb					UnaryJoyY:
.a3bb	38		sec				sec
.a3bc					JoyMain:
.a3bc	fa		plx				plx 								; get pos
.a3bd	08		php				php 								; save carry (set for Y)
.a3be	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a3c1	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.a3c4	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a3c7	28		plp				plp
.a3c8	90 02		bcc $a3cc			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a3ca	4a		lsr a				lsr 	a
.a3cb	4a		lsr a				lsr 	a
.a3cc					_JMNoShift:
.a3cc	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a3cd	b0 0a		bcs $a3d9			bcs 	_JMIsRight
.a3cf	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a3d0	b0 04		bcs $a3d6			bcs 	_JMIsLeft
.a3d2	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero 					; zero result
.a3d5	60		rts				rts
.a3d6					_JMIsLeft:
.a3d6	4c ed 8e	jmp $8eed			jmp 	ReturnTrue
.a3d9					_JMIsRight:
.a3d9	a9 01		lda #$01			lda 	#1
.a3db	20 8f 9d	jsr $9d8f			jsr 	NSMSetByte
.a3de	60		rts				rts
.a3df					UnaryJoyB:
.a3df	fa		plx				plx 								; get pos
.a3e0	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a3e3	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.a3e6	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a3e9	4a		lsr a				lsr 	a
.a3ea	4a		lsr a				lsr 	a
.a3eb	4a		lsr a				lsr 	a
.a3ec	4a		lsr a				lsr 	a
.a3ed	29 01		and #$01			and 	#1
.a3ef	20 8f 9d	jsr $9d8f			jsr 	NSMSetByte
.a3f2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a3f3					LoadCommand:
.a3f3	20 6f 89	jsr $896f			jsr 	NewProgram
.a3f6	20 ae 82	jsr $82ae			jsr 	BackLoadProgram
.a3f9	4c 46 83	jmp $8346			jmp 	WarmStart
.a3fc					GoCommand:
.a3fc	20 6f 89	jsr $896f			jsr 	NewProgram
.a3ff	20 ae 82	jsr $82ae			jsr 	BackLoadProgram
.a402	4c ab 8a	jmp $8aab			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a405					UnaryTimer:
.a405	fa		plx				plx
.a406	20 67 8e	jsr $8e67			jsr 	CheckRightBracket
.a409					TimerToStackX:
.a409	20 8d 9d	jsr $9d8d			jsr 	NSMSetZero 					; zero result
.a40c	64 01		stz $01				stz 	1 							; access I/O
.a40e	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a411	95 58		sta $58,x			sta 	NSMantissa0,x
.a413	ad 5a d6	lda $d65a			lda 	$D65A
.a416	95 60		sta $60,x			sta 	NSMantissa1,x
.a418	ad 5b d6	lda $d65b			lda 	$D65B
.a41b	95 68		sta $68,x			sta 	NSMantissa2,x
.a41d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a41e					MemoryDeleteLine:
.a41e	20 3d a4	jsr $a43d			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a421	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a423	a8		tay				tay
.a424					_MDDLLoop:
.a424	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a426	92 30		sta ($30)			sta 	(codePtr)
.a428	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a42a	c5 3a		cmp $3a				cmp 	zTemp2
.a42c	d0 07		bne $a435			bne 	_MDLDLNext
.a42e	a5 31		lda $31				lda 	codePtr+1
.a430	c5 3b		cmp $3b				cmp 	zTemp2+1
.a432	d0 01		bne $a435			bne 	_MDLDLNext
.a434					_MDDLExit:
.a434	60		rts				rts
.a435					_MDLDLNext:
.a435	e6 30		inc $30				inc 	codePtr						; next byte
.a437	d0 eb		bne $a424			bne 	_MDDLLoop
.a439	e6 31		inc $31				inc 	codePtr+1
.a43b	80 e7		bra $a424			bra 	_MDDLLoop
.a43d					IMemoryFindEnd:
.a43d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a43f	85 3a		sta $3a				sta 	0+zTemp2
.a441	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a443	85 3b		sta $3b				sta 	1+zTemp2
.a445					_MDLFELoop:
.a445	b2 3a		lda ($3a)			lda 	(zTemp2)
.a447	f0 0b		beq $a454			beq 	_MDLFEExit
.a449	18		clc				clc
.a44a	65 3a		adc $3a				adc 	zTemp2
.a44c	85 3a		sta $3a				sta 	zTemp2
.a44e	90 f5		bcc $a445			bcc 	_MDLFELoop
.a450	e6 3b		inc $3b				inc 	zTemp2+1
.a452	80 f1		bra $a445			bra 	_MDLFELoop
.a454					_MDLFEExit:
.a454	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a455					MemoryInsertLine:
.a455	08		php				php
.a456	20 3d a4	jsr $a43d			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a459	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a45b	1a		inc a				inc 	a
.a45c	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a45e	b0 36		bcs $a496			bcs 	_MDLIError
.a460	28		plp				plp
.a461	90 08		bcc $a46b			bcc 	_MDLIFound
.a463	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a465	85 30		sta $30				sta 	codePtr
.a467	a5 3b		lda $3b				lda 	zTemp2+1
.a469	85 31		sta $31				sta 	codePtr+1
.a46b					_MDLIFound:
.a46b	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a46e	a8		tay				tay
.a46f					_MDLIInsert:
.a46f	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a471	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a473	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a475	c5 3a		cmp $3a				cmp 	zTemp2
.a477	d0 06		bne $a47f			bne 	_MDLINext
.a479	a5 31		lda $31				lda 	codePtr+1
.a47b	c5 3b		cmp $3b				cmp 	zTemp2+1
.a47d	f0 0a		beq $a489			beq 	_MDLIHaveSpace
.a47f					_MDLINext:
.a47f	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a481	d0 02		bne $a485			bne 	_MDLINoBorrow
.a483	c6 3b		dec $3b				dec 	zTemp2+1
.a485					_MDLINoBorrow:
.a485	c6 3a		dec $3a				dec 	zTemp2
.a487	80 e6		bra $a46f			bra 	_MDLIInsert
.a489					_MDLIHaveSpace:
.a489	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a48c	88		dey				dey 								; from offset-1 to 0
.a48d					_MDLICopy:
.a48d	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a490	91 30		sta ($30),y			sta 	(codePtr),y
.a492	88		dey				dey
.a493	10 f8		bpl $a48d			bpl 	_MDLICopy
.a495	60		rts				rts
.a496					_MDLIError:
.a496	a9 06		lda #$06		lda	#6
.a498	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.a49b					MDLAppendLine:
.a49b	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a49d	85 36		sta $36				sta 	zTemp0
.a49f	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4a1	85 38		sta $38				sta 	0+zTemp1
.a4a3	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4a5	85 39		sta $39				sta 	1+zTemp1
.a4a7	b2 38		lda ($38)			lda 	(zTemp1)
.a4a9	d0 0a		bne $a4b5			bne 	_MDLANoInitialise
.a4ab	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4ad	8d b8 05	sta $05b8			sta 	0+AppendPointer
.a4b0	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4b2	8d b9 05	sta $05b9			sta 	1+AppendPointer
.a4b5					_MDLANoInitialise:
.a4b5	18		clc				clc
.a4b6	ad b8 05	lda $05b8			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a4b9	85 38		sta $38				sta 	zTemp1
.a4bb	72 36		adc ($36)			adc 	(zTemp0)
.a4bd	8d b8 05	sta $05b8			sta 	AppendPointer
.a4c0	ad b9 05	lda $05b9			lda 	AppendPointer+1
.a4c3	85 39		sta $39				sta 	zTemp1+1
.a4c5	69 00		adc #$00			adc 	#0
.a4c7	8d b9 05	sta $05b9			sta 	AppendPointer+1
.a4ca	a0 00		ldy #$00			ldy 	#0
.a4cc					_MDLACopy:
.a4cc	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a4ce	91 38		sta ($38),y			sta 	(zTemp1),y
.a4d0	c8		iny				iny
.a4d1	98		tya				tya
.a4d2	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a4d4	d0 f6		bne $a4cc			bne 	_MDLACopy
.a4d6	a9 00		lda #$00			lda 	#0 							; end of program.
.a4d8	91 38		sta ($38),y			sta 	(zTemp1),y
.a4da	60		rts				rts
.05b8					AppendPointer:
>05b8							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a4db					MemoryNew:
.a4db	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4dd	85 30		sta $30				sta 	codePtr
.a4df	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4e1	85 31		sta $31				sta 	codePtr+1
.a4e3	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a4e5	92 30		sta ($30)			sta 	(codePtr)
.a4e7	60		rts				rts
.a4e8					MemoryInline:
.a4e8	98		tya				tya 								; put address into stack,x
.a4e9	18		clc				clc  								; get the offset, add codePtr
.a4ea	65 30		adc $30				adc 	codePtr
.a4ec	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a4ee	a5 31		lda $31				lda 	codePtr+1
.a4f0	69 00		adc #$00			adc 	#0
.a4f2	95 60		sta $60,x			sta 	NSMantissa1,x
.a4f4	74 68		stz $68,x			stz 	NSMantissa2,x
.a4f6	74 70		stz $70,x			stz 	NSMantissa3,x
.a4f8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a4f9					MemorySearch:
.a4f9	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a4fb	86 37		stx $37				stx 	zTemp0+1
.a4fd	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4ff	85 30		sta $30				sta 	codePtr
.a501	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a503	85 31		sta $31				sta 	codePtr+1
.a505					_MTAXLoop:
.a505	b2 30		lda ($30)			lda 	(codePtr)
.a507	18		clc				clc
.a508	f0 21		beq $a52b			beq 	_MTAXExit 					; reached end, exit with CC.
.a50a	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a50c	b1 30		lda ($30),y			lda 	(codePtr),y
.a50e	38		sec				sec
.a50f	e5 36		sbc $36				sbc 	zTemp0
.a511	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a513	c8		iny				iny 								; do the MSB
.a514	b1 30		lda ($30),y			lda 	(codePtr),y
.a516	e5 37		sbc $37				sbc 	zTemp0+1
.a518	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a51a	f0 0f		beq $a52b			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a51c	b0 0d		bcs $a52b			bcs 	_MTAXExit 					; current < required exit
.a51e	18		clc				clc
.a51f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a521	65 30		adc $30				adc 	codePtr
.a523	85 30		sta $30				sta 	codePtr
.a525	90 02		bcc $a529			bcc 	_CREExit
.a527	e6 31		inc $31				inc 	codePtr+1 					; carry
.a529					_CREExit:
.a529	80 da		bra $a505			bra 	_MTAXLoop
.a52b					_MTAXExit:
.a52b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a52c					UnaryPlaying:
.a52c	fa		plx				plx
.a52d	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; get channel #
.a530	48		pha				pha
.a531	20 67 8e	jsr $8e67			jsr		CheckRightBracket
.a534	68		pla				pla
.a535	c9 04		cmp #$04			cmp 	#4
.a537	b0 0c		bcs $a545			bcs 	_UPNotPlaying
.a539	09 20		ora #$20			ora 	#$20 						; query playing ?
.a53b	20 18 80	jsr $8018			jsr 	SNDCommand
.a53e	c9 00		cmp #$00			cmp 	#0
.a540	f0 03		beq $a545			beq 	_UPNotPlaying
.a542	4c ed 8e	jmp $8eed			jmp 	ReturnTrue
.a545					_UPNotPlaying:
.a545	4c f8 8e	jmp $8ef8			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a548					SoundCommand:
.a548	b1 30		lda ($30),y			lda 	(codePtr),y
.a54a	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a54c	d0 09		bne $a557			bne 	_SNDMain
.a54e	c8		iny				iny 								; skip OFF
.a54f	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a551	5a		phy				phy
.a552	20 18 80	jsr $8018			jsr 	SNDCommand
.a555	7a		ply				ply
.a556	60		rts				rts
.a557					_SNDMain:
.a557	a2 00		ldx #$00			ldx 	#0
.a559	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; channel
.a55c	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a55e	b0 4b		bcs $a5ab			bcs 	_SndError
.a560	e8		inx				inx 								; do the rest in slot 1.
.a561	20 6f 8e	jsr $8e6f			jsr 	CheckComma
.a564	20 0d 9d	jsr $9d0d			jsr 	Evaluate16BitInteger 		; Pitch
.a567	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a569	c9 10		cmp #$10			cmp 	#16
.a56b	b0 3e		bcs $a5ab			bcs 	_SndError
.a56d	8d bb 05	sta $05bb			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a570	b5 58		lda $58,x			lda 	NSMantissa0,x
.a572	8d ba 05	sta $05ba			sta 	SoundCommandBlock
.a575	20 6f 8e	jsr $8e6f			jsr 	CheckComma
.a578	20 28 9d	jsr $9d28			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a57b	8d bd 05	sta $05bd			sta 	SoundCommandBlock+3
.a57e	a9 0f		lda #$0f			lda 	#15
.a580	8d bc 05	sta $05bc			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a583	9c be 05	stz $05be			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a586	9c bf 05	stz $05bf			stz 	SoundCommandBlock+5
.a589	b1 30		lda ($30),y			lda 	(codePtr),y
.a58b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a58d	d0 0e		bne $a59d			bne 	_SNDPlay
.a58f	c8		iny				iny
.a590	20 17 9d	jsr $9d17			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a593	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a595	8d be 05	sta $05be			sta 	SoundCommandBlock+4
.a598	b5 60		lda $60,x			lda 	NSMantissa1,x
.a59a	8d bf 05	sta $05bf			sta 	SoundCommandBlock+5
.a59d					_SNDPlay:
.a59d	5a		phy				phy
.a59e	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a5a0	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a5a2	a2 ba		ldx #$ba			ldx 	#(SoundCommandBlock & $FF)
.a5a4	a0 05		ldy #$05			ldy 	#(SoundCommandBlock >> 8)
.a5a6	20 18 80	jsr $8018			jsr 	SNDCommand
.a5a9	7a		ply				ply
.a5aa	60		rts				rts
.a5ab					_SndError:
.a5ab	4c 10 9f	jmp $9f10			jmp 	RangeError
.05ba					SoundCommandBlock:
>05ba							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a5ae					StackPushByte:
.a5ae	48		pha				pha 								; save byte
.a5af	a5 34		lda $34				lda 	BasicStack
.a5b1	d0 09		bne $a5bc			bne 	_SPBNoBorrow
.a5b3	c6 35		dec $35				dec 	BasicStack+1
.a5b5	48		pha				pha
.a5b6	a5 35		lda $35				lda 	BasicStack+1
.a5b8	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a5ba	90 06		bcc $a5c2			bcc 	_SPBMemory
.a5bc					_SPBNoBorrow:
.a5bc	c6 34		dec $34				dec 	BasicStack
.a5be	68		pla				pla 								; get back and write
.a5bf	92 34		sta ($34)			sta 	(BasicStack)
.a5c1	60		rts				rts
.a5c2					_SPBMemory:
.a5c2	a9 12		lda #$12		lda	#18
.a5c4	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.a5c7					StackPopByte:
.a5c7	b2 34		lda ($34)			lda 	(BasicStack)
.a5c9	e6 34		inc $34				inc 	BasicStack
.a5cb	d0 02		bne $a5cf			bne 	_SPBNoCarry
.a5cd	e6 35		inc $35				inc 	BasicStack+1
.a5cf					_SPBNoCarry:
.a5cf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a5d0					StackOpen:
.a5d0	48		pha				pha 								; save frame byte
.a5d1	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a5d3	0a		asl a				asl 	a 							; claim twice this for storage
.a5d4	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a5d6	38		sec				sec 								; so basically subtracting from
.a5d7	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a5d9	85 34		sta $34				sta 	basicStack
.a5db	b0 08		bcs $a5e5			bcs 	_SONoBorrow
.a5dd	c6 35		dec $35				dec 	basicStack+1
.a5df	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a5e1	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a5e3	90 04		bcc $a5e9			bcc 	_SOMemory
.a5e5					_SONoBorrow:
.a5e5	68		pla				pla 								; get marker back and write at TOS
.a5e6	92 34		sta ($34)			sta 	(basicStack)
.a5e8	60		rts				rts
.a5e9					_SOMemory:
.a5e9	a9 12		lda #$12		lda	#18
.a5eb	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.a5ee					StackClose:
.a5ee	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a5f0	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a5f2	0a		asl a				asl 	a 							; claim twice this.
.a5f3	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a5f5	85 34		sta $34				sta 	basicStack
.a5f7	90 02		bcc $a5fb			bcc 	_SCExit
.a5f9	e6 35		inc $35				inc 	basicStack+1
.a5fb					_SCExit:
.a5fb	60		rts				rts
.a5fc					StackCheckFrame:
.a5fc	48		pha				pha
.a5fd					_StackRemoveLocals:
.a5fd	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a5ff	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a601	b0 05		bcs $a608			bcs 	_SCNoLocal
.a603	20 1e 89	jsr $891e			jsr 	LocalPopValue
.a606	80 f5		bra $a5fd			bra 	_StackRemoveLocals
.a608					_SCNoLocal:
.a608	68		pla				pla
.a609	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a60b	29 f0		and #$f0			and 	#$F0 						; check type bits
.a60d	d0 01		bne $a610			bne 	_SCFError 					; different, we have structures mixed up
.a60f	60		rts				rts
.a610					_SCFError:
.a610	8a		txa				txa 								; report error X
.a611	4c 80 8e	jmp $8e80			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a614					STKSaveCodePosition:
.a614	5a		phy				phy
.a615	98		tya				tya 								; save Y
.a616	a0 05		ldy #$05			ldy 	#5
.a618	91 34		sta ($34),y			sta 	(basicStack),y
.a61a	88		dey				dey 								; save Code Pointer
.a61b					_STKSaveLoop:
.a61b	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a61e	91 34		sta ($34),y			sta 	(basicStack),y
.a620	88		dey				dey
.a621	d0 f8		bne $a61b			bne 	_STKSaveLoop
.a623	7a		ply				ply
.a624	60		rts				rts
.a625					STKLoadCodePosition:
.a625	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a627					_STKLoadLoop:
.a627	b1 34		lda ($34),y			lda 	(basicStack),y
.a629	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a62c	c8		iny				iny
.a62d	c0 05		cpy #$05			cpy 	#5
.a62f	d0 f6		bne $a627			bne 	_STKLoadLoop
.a631	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a633	a8		tay				tay
.a634	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a635					StackReset:
.a635	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a637	85 34		sta $34				sta 	0+basicStack
.a639	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a63b	85 35		sta $35				sta 	1+basicStack
.a63d	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a63f	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a641	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a642					StringConcrete:
.a642	5a		phy				phy 								; save position on stack
.a643	20 b5 99	jsr $99b5			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a646	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a648	85 38		sta $38				sta 	zTemp1
.a64a	b5 60		lda $60,x			lda 	NSMantissa1,x
.a64c	85 39		sta $39				sta 	zTemp1+1
.a64e	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a650					_SALength:
.a650	c8		iny				iny
.a651	b1 38		lda ($38),y			lda 	(zTemp1),y
.a653	d0 fb		bne $a650			bne 	_SALength
.a655	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a657	b0 3d		bcs $a696			bcs 	_SALengthError
.a659	98		tya				tya 				 				; length of the new string
.a65a	18		clc				clc
.a65b	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a65d	90 02		bcc $a661			bcc 	_SAHaveLength
.a65f	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a661					_SAHaveLength:
.a661	48		pha				pha 								; save length.
.a662	38		sec				sec
.a663	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a665	6d 0e 04	adc $040e			adc 	StringMemory
.a668	8d 0e 04	sta $040e			sta 	StringMemory
.a66b	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a66d	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a66f	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a671	6d 0f 04	adc $040f			adc 	StringMemory+1
.a674	8d 0f 04	sta $040f			sta 	StringMemory+1
.a677	85 3b		sta $3b				sta 	zTemp2+1
.a679	95 60		sta $60,x			sta 	NSMantissa1,x
.a67b	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a67c	38		sec				sec
.a67d	e9 03		sbc #$03			sbc 	#3
.a67f	92 3a		sta ($3a)			sta 	(zTemp2)
.a681	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a683	a0 01		ldy #$01			ldy 	#1
.a685	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a687					_SACopyNewString:
.a687	a0 00		ldy #$00			ldy 	#0
.a689					_SACopyNSLoop:
.a689	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a68b	c8		iny				iny 								; write two on in string storage
.a68c	c8		iny				iny
.a68d	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a68f	88		dey				dey 								; this makes it one one.
.a690	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a692	d0 f5		bne $a689			bne 	_SACopyNSLoop
.a694	7a		ply				ply
.a695	60		rts				rts
.a696					_SALengthError:
.a696	a9 09		lda #$09		lda	#9
.a698	4c 80 8e	jmp $8e80		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a69b					StringSystemInitialise:
.a69b	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a69d	8d 0e 04	sta $040e			sta 	0+StringMemory
.a6a0	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a6a2	8d 0f 04	sta $040f			sta 	1+StringMemory
.a6a5	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a6a8	60		rts				rts
.a6a9					StringSpaceInitialise:
.a6a9	20 b5 99	jsr $99b5			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a6ac	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a6ae	8d 10 04	sta $0410			sta 	StringInitialised
.a6b1	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a6b4	8d 11 04	sta $0411			sta 	StringTempPointer
.a6b7	ad 0f 04	lda $040f			lda 	StringMemory+1
.a6ba	3a		dec a				dec 	a
.a6bb	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a6be	60		rts				rts
.a6bf					StringTempAllocate:
.a6bf	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a6c1	b0 30		bcs $a6f3			bcs 	_STALength
.a6c3	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a6c6	30 05		bmi $a6cd			bmi 	_STAAllocate
.a6c8	48		pha				pha 								; save value to subtract.
.a6c9	20 a9 a6	jsr $a6a9			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a6cc	68		pla				pla 								; restore it
.a6cd					_STAAllocate:
.a6cd	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a6cf	18		clc				clc  								; deliberate allows one more
.a6d0	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a6d3	8d 11 04	sta $0411			sta 	StringTempPointer
.a6d6	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a6d8	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a6da	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a6dd	69 ff		adc #$ff			adc 	#$FF
.a6df	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a6e2	85 3d		sta $3d				sta 	zsTemp+1
.a6e4	95 60		sta $60,x			sta 	NSMantissa1,x
.a6e6	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data
.a6e8	74 70		stz $70,x			stz 	NSMantissa3,x
.a6ea	a9 10		lda #$10			lda 	#NSTString
.a6ec	95 50		sta $50,x			sta 	NSStatus,x
.a6ee	a9 00		lda #$00			lda 	#0 							; clear the target string
.a6f0	92 3c		sta ($3c)			sta 	(zsTemp)
.a6f2	60		rts				rts
.a6f3					_STALength:
.a6f3	a9 09		lda #$09		lda	#9
.a6f5	4c 80 8e	jmp $8e80		jmp	ErrorHandler
.a6f8					StringTempWrite:
.a6f8	48		pha				pha
.a6f9	92 3c		sta ($3c)			sta 	(zsTemp)
.a6fb	e6 3c		inc $3c				inc 	zsTemp
.a6fd	d0 02		bne $a701			bne 	_STWNoCarry
.a6ff	e6 3d		inc $3d				inc 	zsTemp+1
.a701					_STWNoCarry:
.a701	a9 00		lda #$00			lda 	#0
.a703	92 3c		sta ($3c)			sta 	(zsTemp)
.a705	68		pla				pla
.a706	60		rts				rts

;******  Return to file: _basic.asm

.a707					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a707					Export_EXTPrintCharacter:
.a707					PAGEDPrintCharacter:
.a707	48		pha				pha
.a708	da		phx				phx
.a709	5a		phy				phy
.a70a	a6 01		ldx $01				ldx 	1
.a70c	da		phx				phx
.a70d	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a710	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a712	30 48		bmi $a75c			bmi 	_EXPCColour
.a714	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a716	90 4d		bcc $a765			bcc 	_EXPCControl
.a718	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a71a	86 01		stx $01				stx 	1
.a71c	91 40		sta ($40),y			sta 	(EXTAddress),y
.a71e	e6 01		inc $01				inc 	1 							; select colour memory
.a720	ad c2 05	lda $05c2			lda 	EXTTextColour
.a723	91 40		sta ($40),y			sta 	(EXTAddress),y
.a725	c8		iny				iny 								; advance horizontal position
.a726	8c c1 05	sty $05c1			sty 	EXTColumn
.a729	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; reached RHS ?
.a72c	90 63		bcc $a791			bcc 	_EXPCExit 					; no, then exit.
.a72e					_EXPCCRLF:
.a72e	ee c0 05	inc $05c0			inc 	EXTRow  					; bump row
.a731	9c c1 05	stz $05c1			stz 	EXTColumn 					; back to column 0
.a734	ad c0 05	lda $05c0			lda 	EXTRow 						; check if reached the bottom ?
.a737	cd c4 05	cmp $05c4			cmp 	EXTScreenHeight 			; if so, then scroll.
.a73a	f0 18		beq $a754			beq 	_EXPCScroll
.a73c	18		clc				clc 								; add width to address.
.a73d	a5 40		lda $40				lda 	EXTAddress
.a73f	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a742	85 40		sta $40				sta 	EXTAddress
.a744	90 4b		bcc $a791			bcc 	_EXPCExit
.a746	e6 41		inc $41				inc 	EXTAddress+1
.a748	80 47		bra $a791			bra 	_EXPCExit
.a74a					_EXPCLeft:
.a74a	ce c1 05	dec $05c1			dec 	EXTColumn
.a74d	10 42		bpl $a791			bpl 	_EXPCExit
.a74f					_EXPCBegin:
.a74f	9c c1 05	stz $05c1			stz 	EXTColumn
.a752	80 3d		bra $a791			bra 	_EXPCExit
.a754					_EXPCScroll:
.a754	ce c0 05	dec $05c0			dec 	EXTRow 						; the height-1 th line.
.a757	20 42 a8	jsr $a842			jsr 	EXTScreenScroll 			; scroll the screen
.a75a	80 35		bra $a791			bra 	_EXPCExit
.a75c					_EXPCColour:
.a75c	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a75e	b0 31		bcs $a791			bcs 	_EXPCExit
.a760	20 22 a8	jsr $a822			jsr 	_EXPCHandleColour
.a763	80 2c		bra $a791			bra 	_EXPCExit
.a765					_EXPCControl:
.a765	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a767	b0 28		bcs $a791			bcs 	_EXPCExit
.a769	0a		asl a				asl 	a 							; double into X
.a76a	aa		tax				tax
.a76b	7c 00 a8	jmp ($a800,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a76e					_EXPCUp:
.a76e	ad c0 05	lda $05c0			lda 	EXTRow 						; already at top ?
.a771	f0 1e		beq $a791			beq 	_EXPCExit
.a773	ce c0 05	dec $05c0			dec 	EXTRow 						; up one in position/address
.a776	38		sec				sec
.a777	a5 40		lda $40				lda 	EXTAddress
.a779	ed c3 05	sbc $05c3			sbc 	EXTScreenWidth
.a77c	85 40		sta $40				sta 	EXTAddress
.a77e	b0 11		bcs $a791			bcs 	_EXPCExit
.a780	c6 41		dec $41				dec 	EXTAddress+1
.a782	80 0d		bra $a791			bra 	_EXPCExit
.a784					_EXPCRight:
.a784	c8		iny				iny
.a785	8c c1 05	sty $05c1			sty 	EXTColumn
.a788	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a78b	d0 04		bne $a791			bne 	_EXPCExit
.a78d	88		dey				dey
.a78e					_EXPCSetColumnY:
.a78e	8c c1 05	sty $05c1			sty 	EXTColumn
.a791					_EXPCExit:
.a791	20 97 a8	jsr $a897			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a794	68		pla				pla
.a795	85 01		sta $01				sta 	1
.a797	7a		ply				ply
.a798	fa		plx				plx
.a799	68		pla				pla
.a79a	60		rts				rts
.a79b					_EXPCClearScreen:
.a79b	20 54 a8	jsr $a854			jsr		EXTClearScreenCode
.a79e	80 f1		bra $a791			bra 	_EXPCExit
.a7a0					_EXPCDown:
.a7a0	ad c4 05	lda $05c4			lda 	EXTScreenHeight 			; at the bottom
.a7a3	3a		dec a				dec 	a
.a7a4	cd c0 05	cmp $05c0			cmp 	EXTRow
.a7a7	f0 e8		beq $a791			beq 	_EXPCExit
.a7a9	ee c0 05	inc $05c0			inc 	EXTRow 						; down one in position/address
.a7ac	18		clc				clc
.a7ad	a5 40		lda $40				lda 	EXTAddress
.a7af	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a7b2	85 40		sta $40				sta 	EXTAddress
.a7b4	90 db		bcc $a791			bcc 	_EXPCExit
.a7b6	e6 41		inc $41				inc 	EXTAddress+1
.a7b8	80 d7		bra $a791			bra 	_EXPCExit
.a7ba					_EXPCTab:
.a7ba	ad c1 05	lda $05c1			lda 	EXTColumn 					; next tab stop
.a7bd	29 f8		and #$f8			and 	#$F8
.a7bf	18		clc				clc
.a7c0	69 08		adc #$08			adc 	#8
.a7c2	8d c1 05	sta $05c1			sta 	EXTColumn
.a7c5	cd c3 05	cmp $05c3			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a7c8	90 c7		bcc $a791			bcc 	_EXPCExit
.a7ca	80 10		bra $a7dc			bra 	_EXPCEnd
.a7cc					_EXPCBackSpace:
.a7cc	88		dey				dey
.a7cd	30 c2		bmi $a791			bmi 	_EXPCExit
.a7cf	ce c1 05	dec $05c1			dec 	EXTColumn
.a7d2	a9 02		lda #$02			lda 	#2
.a7d4	85 01		sta $01				sta 	1
.a7d6	a9 20		lda #$20			lda 	#32
.a7d8	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7da	80 b5		bra $a791			bra 	_EXPCExit
.a7dc					_EXPCEnd:
.a7dc	a9 02		lda #$02			lda 	#2 							; access text screen
.a7de	85 01		sta $01				sta 	1
.a7e0	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; point to last character
.a7e3	88		dey				dey
.a7e4					_EXPCEndSearch:
.a7e4	88		dey				dey 								; if past start, move to col 0.
.a7e5	30 06		bmi $a7ed			bmi 	_EXPCFound
.a7e7	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a7e9	c9 20		cmp #$20			cmp 	#' '
.a7eb	f0 f7		beq $a7e4			beq 	_EXPCEndSearch
.a7ed					_EXPCFound:
.a7ed	c8		iny				iny 								; move to following cell.
.a7ee	80 9e		bra $a78e			bra 	_EXPCSetColumnY
.a7f0					_EXPCClearEOL:
.a7f0	a9 02		lda #$02			lda 	#2 							; access character RAM
.a7f2	85 01		sta $01				sta 	1
.a7f4	a9 20		lda #$20			lda 	#' ' 						; write space
.a7f6	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7f8	c8		iny				iny
.a7f9	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; until RHS of screen.
.a7fc	90 f2		bcc $a7f0			bcc 	_EXPCClearEOL
.a7fe	80 91		bra $a791			bra 	_EXPCExit
.a800					_EXPCActionTable:
>a800	91 a7						.word 	_EXPCExit 					; 00
>a802	4f a7						.word 	_EXPCBegin 					; 01 A Start of Line
>a804	4a a7						.word 	_EXPCLeft 					; 02 B Left
>a806	91 a7						.word 	_EXPCExit 					; 03 <Break>
>a808	91 a7						.word 	_EXPCExit 					; 04
>a80a	dc a7						.word 	_EXPCEnd 					; 05 E End of Line
>a80c	84 a7						.word 	_EXPCRight 					; 06 F Right
>a80e	91 a7						.word 	_EXPCExit 					; 07
>a810	cc a7						.word 	_EXPCBackspace 				; 08 H Backspace
>a812	ba a7						.word 	_EXPCTab 					; 09 I Tab
>a814	91 a7						.word 	_EXPCExit 					; 0A
>a816	f0 a7						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a818	9b a7						.word 	_EXPCClearScreen			; 0C L CLS
>a81a	2e a7						.word 	_EXPCCRLF 					; 0D M CR/LF
>a81c	a0 a7						.word 	_EXPCDown 					; 0E N Down
>a81e	91 a7						.word 	_EXPCExit 					; 0F
>a820	6e a7						.word 	_EXPCUp 					; 10 P Up
.a822					_EXPCHandleColour
.a822	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a824	b0 16		bcs $a83c			bcs 	_EXPCBackground
.a826	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a827	0a		asl a				asl 	a
.a828	0a		asl a				asl 	a
.a829	0a		asl a				asl 	a
.a82a	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a82c					_EXPCUpdate:
.a82c	48		pha				pha 								; save new colour
.a82d	8a		txa				txa 								; get mask
.a82e	2d c2 05	and $05c2			and 	EXTTextColour 				; mask out old.
.a831	8d c2 05	sta $05c2			sta 	EXTTextColour
.a834	68		pla				pla 								; or in new colour
.a835	0d c2 05	ora $05c2			ora 	EXTTextColour
.a838	8d c2 05	sta $05c2			sta 	EXTTextColour
.a83b	60		rts				rts
.a83c					_EXPCBackground:
.a83c	29 0f		and #$0f			and 	#$0F 						; get the colour
.a83e	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a840	80 ea		bra $a82c			bra 	_EXPCUpdate
.a842					EXTScreenScroll:
.a842	a9 02		lda #$02			lda 	#2 							; select text page
.a844	85 01		sta $01				sta 	1
.a846	a9 20		lda #$20			lda		#32 						; fill with space
.a848	20 5b a9	jsr $a95b			jsr 	EXTScrollFill
.a84b	e6 01		inc $01				inc 	1 							; select colour page
.a84d	ad c2 05	lda $05c2			lda 	EXTTextColour
.a850	20 5b a9	jsr $a95b			jsr 	EXTScrollFill
.a853	60		rts				rts
.a854					EXTClearScreenCode:
.a854	a9 02		lda #$02			lda 	#2 							; select text page
.a856	85 01		sta $01				sta 	1
.a858	a9 20		lda #$20			lda		#32 						; fill with space
.a85a	20 67 a8	jsr $a867			jsr 	_EXTCSFill
.a85d	e6 01		inc $01				inc 	1 							; select colour page
.a85f	ad c2 05	lda $05c2			lda 	EXTTextColour
.a862	20 67 a8	jsr $a867			jsr 	_EXTCSFill
.a865	80 22		bra $a889			bra 	EXTHomeCursor
.a867					_EXTCSFill:
.a867	aa		tax				tax
.a868	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a86a	85 40		sta $40				sta 	EXTAddress
.a86c	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a86e	85 41		sta $41				sta 	EXTAddress+1
.a870					_EXTCSFill1:
.a870	a0 00		ldy #$00			ldy 	#0
.a872	8a		txa				txa
.a873					_EXTCSFill2:
.a873	91 40		sta ($40),y			sta 	(EXTAddress),y
.a875	c8		iny				iny
.a876	d0 fb		bne $a873			bne 	_EXTCSFill2
.a878	e6 41		inc $41				inc 	EXTAddress+1
.a87a	a5 41		lda $41				lda 	EXTAddress+1
.a87c	c9 d2		cmp #$d2			cmp 	#$D2
.a87e	d0 f0		bne $a870			bne 	_EXTCSFill1
.a880	8a		txa				txa
.a881					_EXTCSFill3:
.a881	91 40		sta ($40),y			sta 	(EXTAddress),y
.a883	c8		iny				iny
.a884	c0 c0		cpy #$c0			cpy 	#$C0
.a886	d0 f9		bne $a881			bne 	_EXTCSFill3
.a888	60		rts				rts
.a889					EXTHomeCursor:
.a889	9c c0 05	stz $05c0			stz 	EXTRow 						; reset row & column
.a88c	9c c1 05	stz $05c1			stz 	EXTColumn
.a88f	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a891	85 40		sta $40				sta 	EXTAddress
.a893	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a895	85 41		sta $41				sta 	EXTAddress+1
.a897					EXTSetHardwareCursor:
.a897	64 01		stz $01				stz 	1 							; I/O Page zero
.a899	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a89b	8d 10 d0	sta $d010			sta 	$D010
.a89e	a9 b1		lda #$b1			lda 	#$B1
.a8a0	8d 12 d0	sta $d012			sta 	$D012
.a8a3	ad c1 05	lda $05c1			lda 	EXTColumn
.a8a6	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a8a9	9c 15 d0	stz $d015			stz 	$D015
.a8ac	ad c0 05	lda $05c0			lda 	EXTRow
.a8af	8d 16 d0	sta $d016			sta 	$D016
.a8b2	9c 17 d0	stz $d017			stz 	$D017
.a8b5	60		rts				rts
.a8b6					Export_EXTInputLine:
.a8b6	48		pha				pha
.a8b7	da		phx				phx
.a8b8	5a		phy				phy
.a8b9	a5 01		lda $01				lda 	1 							; save I/O page
.a8bb	48		pha				pha
.a8bc					_EILLoop:
.a8bc	20 d6 a9	jsr $a9d6			jsr 	PagedInputSingleCharacter
.a8bf	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a8c1	f0 44		beq $a907			beq 	_EILExit
.a8c3	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a8c5	f0 2a		beq $a8f1			beq 	_EILDelete
.a8c7	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a8c9	f0 1c		beq $a8e7			beq 	_EILBackspace
.a8cb	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a8cd	90 12		bcc $a8e1			bcc 	_EILPrintLoop
.a8cf	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a8d1	b0 0e		bcs $a8e1			bcs 	_EILPrintLoop
.a8d3	48		pha				pha 								; save character
.a8d4	a9 02		lda #$02			lda 	#2  						; insert a space
.a8d6	85 01		sta $01				sta 	1
.a8d8	20 49 a9	jsr $a949			jsr 	EXTILInsert 				; insert in text screen
.a8db	e6 01		inc $01				inc 	1
.a8dd	20 49 a9	jsr $a949			jsr 	EXTILInsert 				; insert in colour screen
.a8e0	68		pla				pla 								; get character back.
.a8e1					_EILPrintLoop:
.a8e1	20 07 a7	jsr $a707			jsr 	PagedPrintCharacter
.a8e4	80 d6		bra $a8bc			bra 	_EILLoop
.a8e6	60		rts				rts
.a8e7					_EILBackspace:
.a8e7	ad c1 05	lda $05c1			lda 	EXTColumn					; can we backspace ?
.a8ea	f0 d0		beq $a8bc			beq 	_EILLoop
.a8ec	a9 02		lda #$02			lda 	#2 							; move cursor left
.a8ee	20 07 a7	jsr $a707			jsr 	PagedPrintCharacter
.a8f1					_EILDelete
.a8f1	a9 02		lda #$02			lda 	#2 							; text block
.a8f3	85 01		sta $01				sta 	1
.a8f5	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a8f7	20 34 a9	jsr $a934			jsr 	EXTILDelete
.a8fa	e6 01		inc $01				inc 	1 							; colour block
.a8fc	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; get attribute of last character
.a8ff	88		dey				dey
.a900	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a902	20 34 a9	jsr $a934			jsr 	EXTILDelete 				; backspace attribute
.a905	80 b5		bra $a8bc			bra 	_EILLoop 					; and go round.
.a907					_EILExit:
.a907	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a909	85 01		sta $01				sta 	1
.a90b	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a90d					_EILScrapeLine:
.a90d	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a90f	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a912	c8		iny				iny
.a913	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a916	d0 f5		bne $a90d			bne 	_EILScrapeLine
.a918					_EILTrimSpaces:
.a918	88		dey				dey
.a919	f0 08		beq $a923			beq 	_EILEndTrim
.a91b	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.a91e	c9 20		cmp #$20			cmp 	#' '
.a920	f0 f6		beq $a918			beq 	_EILTrimSpaces
.a922	c8		iny				iny 								; trim after non space character.
.a923					_EILEndTrim:
.a923	a9 00		lda #$00			lda 	#0 							; trim here.
.a925	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a928	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a92a	20 07 a7	jsr $a707			jsr 	PagedPrintCharacter
.a92d	68		pla				pla 								; reset I/O page
.a92e	85 01		sta $01				sta 	1
.a930	7a		ply				ply
.a931	fa		plx				plx
.a932	68		pla				pla
.a933	60		rts				rts
.a934					EXTILDelete:
.a934	48		pha				pha 								; save the new character
.a935	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; start copying from here.
.a938					_EXTDLoop:
.a938	c8		iny				iny 								; copy one byte down.
.a939	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a93b	88		dey				dey
.a93c	91 40		sta ($40),y			sta 	(EXTAddress),y
.a93e	c8		iny				iny 								; do till end of line.
.a93f	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a942	90 f4		bcc $a938			bcc 	_EXTDLoop
.a944	88		dey				dey 	 							; write in last slot.
.a945	68		pla				pla
.a946	91 40		sta ($40),y			sta 	(EXTAddress),y
.a948	60		rts				rts
.a949					EXTILInsert:
.a949	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; end position
.a94c					_EXTILoop:
.a94c	88		dey				dey 								; back one
.a94d	cc c1 05	cpy $05c1			cpy 	EXTColumn 					; exit if reached insert point.
.a950	f0 08		beq $a95a			beq 	_EXTIExit
.a952	88		dey				dey 								; copy one byte up.
.a953	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a955	c8		iny				iny
.a956	91 40		sta ($40),y			sta 	(EXTAddress),y
.a958	80 f2		bra $a94c			bra 	_EXTILoop
.a95a					_EXTIExit:
.a95a	60		rts				rts
.a95b					EXTScrollFill:
.a95b	aa		tax				tax									; save value to fill with
.a95c	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a95e	48		pha				pha
.a95f	a5 37		lda $37				lda 	zTemp0+1
.a961	48		pha				pha
.a962	a5 38		lda $38				lda 	zTemp1
.a964	48		pha				pha
.a965	a5 39		lda $39				lda 	zTemp1+1
.a967	48		pha				pha
.a968	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.a96a	85 37		sta $37				sta 	zTemp0+1
.a96c	85 39		sta $39				sta 	zTemp1+1
.a96e	64 36		stz $36				stz 	zTemp0
.a970	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a973	85 38		sta $38				sta 	zTemp1
.a975	a0 00		ldy #$00			ldy 	#0
.a977					_EXSFCopy1:
.a977	b1 38		lda ($38),y			lda 	(zTemp1),y
.a979	91 36		sta ($36),y			sta 	(zTemp0),y
.a97b	c8		iny				iny
.a97c	d0 f9		bne $a977			bne 	_EXSFCopy1
.a97e	e6 37		inc $37				inc 	zTemp0+1 					; next page
.a980	e6 39		inc $39				inc 	zTemp1+1
.a982	a5 39		lda $39				lda 	zTemp1+1
.a984	c9 d3		cmp #$d3			cmp 	#$D3
.a986	d0 ef		bne $a977			bne 	_EXSFCopy1
.a988	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; blank the bottom line.
.a98b	8a		txa				txa
.a98c					_EXSFFill1:
.a98c	88		dey				dey
.a98d	91 40		sta ($40),y			sta 	(EXTAddress),y
.a98f	c0 00		cpy #$00			cpy 	#0
.a991	10 f9		bpl $a98c			bpl 	_EXSFFill1
.a993	68		pla				pla
.a994	85 39		sta $39				sta 	zTemp1+1
.a996	68		pla				pla
.a997	85 38		sta $38				sta 	zTemp1
.a999	68		pla				pla
.a99a	85 37		sta $37				sta 	zTemp0+1
.a99c	68		pla				pla
.a99d	85 36		sta $36				sta 	zTemp0
.a99f	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.05c0					EXTRow:
>05c0							.fill 	1
.05c1					EXTColumn:
>05c1							.fill 	1
.05c2					EXTTextColour:
>05c2							.fill 	1
.05c3					EXTScreenWidth:
>05c3							.fill 	1
.05c4					EXTScreenHeight:
>05c4							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.a9a0					Export_EXTInitialise:
.a9a0	64 01		stz $01				stz 	1 							; Access I/O
.a9a2	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.a9a5	9c 08 d0	stz $d008			stz 	$D008
.a9a8	9c 09 d0	stz $d009			stz 	$D009
.a9ab	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.a9ad	8d 58 d6	sta $d658			sta 	$D658
.a9b0	a9 03		lda #$03			lda 	#3 							; get current text colour
.a9b2	85 01		sta $01				sta 	1
.a9b4	ad 00 c0	lda $c000			lda 	$C000
.a9b7	8d c2 05	sta $05c2			sta 	EXTTextColour
.a9ba	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.a9bc	8d c3 05	sta $05c3			sta 	EXTScreenWidth
.a9bf	a9 3c		lda #$3c			lda 	#60
.a9c1	8d c4 05	sta $05c4			sta 	EXTScreenHeight
.a9c4	20 89 a8	jsr $a889			jsr 	EXTHomeCursor 				; home cursor
.a9c7					_EXMoveDown:
.a9c7	a9 0d		lda #$0d			lda 	#13
.a9c9	20 07 a7	jsr $a707			jsr 	PAGEDPrintCharacter
.a9cc	ad c0 05	lda $05c0			lda 	EXTRow
.a9cf	c9 06		cmp #$06			cmp 	#6
.a9d1	d0 f4		bne $a9c7			bne 	_EXMoveDown
.a9d3	64 01		stz $01				stz 	1
.a9d5	60		rts				rts
.a9d6					Export_EXTInputSingleCharacter:
.a9d6					PagedInputSingleCharacter:
.a9d6	da		phx				phx
.a9d7	5a		phy				phy
.a9d8					_EISCWait:
.a9d8	64 01		stz $01				stz 	1 							; access I/O Page 0
.a9da	38		sec				sec 								; calculate timer - LastTick
.a9db	ad 59 d6	lda $d659			lda 	$D659
.a9de	aa		tax				tax 								; saving timer in X
.a9df	ed af 05	sbc $05af			sbc 	LastTick
.a9e2	c9 03		cmp #$03			cmp 	#3
.a9e4	90 06		bcc $a9ec			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.a9e6	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.a9e9	20 77 bd	jsr $bd77			jsr 	PagedSNDUpdate 							; go do the code.
.a9ec					_NoFireTick:
.a9ec	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.a9ef	c9 00		cmp #$00			cmp 	#0
.a9f1	f0 e5		beq $a9d8			beq 	_EISCWait
.a9f3	7a		ply				ply
.a9f4	fa		plx				plx
.a9f5	60		rts				rts
.a9f6					Export_EXTBreakCheck:
.a9f6	4c e1 ff	jmp $ffe1			jmp		$FFE1
.a9f9					Export_EXTReadController:
.a9f9	da		phx				phx
.a9fa	a2 00		ldx #$00			ldx 	#0
.a9fc	a9 05		lda #$05			lda 	#(($2D) >> 3)
.a9fe	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa01	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aa03	f0 04		beq $aa09			beq 	_NoSet1
.aa05	8a		txa				txa
.aa06	09 01		ora #$01			ora 	#1
.aa08	aa		tax				tax
.aa09					_NoSet1:
.aa09	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aa0b	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa0e	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aa10	f0 04		beq $aa16			beq 	_NoSet1
.aa12	8a		txa				txa
.aa13	09 02		ora #$02			ora 	#2
.aa15	aa		tax				tax
.aa16					_NoSet1:
.aa16	a9 06		lda #$06			lda 	#(($32) >> 3)
.aa18	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa1b	29 04		and #$04			and 	#($01 << (($32) & 7))
.aa1d	f0 04		beq $aa23			beq 	_NoSet1
.aa1f	8a		txa				txa
.aa20	09 04		ora #$04			ora 	#4
.aa22	aa		tax				tax
.aa23					_NoSet1:
.aa23	a9 04		lda #$04			lda 	#(($25) >> 3)
.aa25	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa28	29 20		and #$20			and 	#($01 << (($25) & 7))
.aa2a	f0 04		beq $aa30			beq 	_NoSet1
.aa2c	8a		txa				txa
.aa2d	09 08		ora #$08			ora 	#8
.aa2f	aa		tax				tax
.aa30					_NoSet1:
.aa30	a9 04		lda #$04			lda 	#(($26) >> 3)
.aa32	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa35	29 40		and #$40			and 	#($01 << (($26) & 7))
.aa37	f0 04		beq $aa3d			beq 	_NoSet1
.aa39	8a		txa				txa
.aa3a	09 10		ora #$10			ora 	#16
.aa3c	aa		tax				tax
.aa3d					_NoSet1:
.aa3d	8a		txa				txa
.aa3e	fa		plx				plx
.aa3f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.aa40					GRVectorTable:
>aa40	8f ac					.word	GXInitialise             ; $00 Initialise
>aa42	a9 ac					.word	GXControlBitmap          ; $01 BitmapCtl
>aa44	f1 ac					.word	GXControlSprite          ; $02 SpriteCtl
>aa46	41 ac					.word	GXClearBitmap            ; $03 Clear
>aa48	80 ae					.word	GXSetColourMode          ; $04 Colour
>aa4a	48 b0					.word	GXFontHandler            ; $05 DrawFont
>aa4c	90 b0					.word	GXSpriteHandler          ; $06 DrawSprite
>aa4e	fc b0					.word	GXSelect                 ; $07 SpriteUse
>aa50	25 b1					.word	GXSelectImage            ; $08 SpriteImage
>aa52	ac b2					.word	GXCollide                ; $09 SpriteCollide
>aa54	f3 aa					.word	GRUndefined              ; $0a
>aa56	f3 aa					.word	GRUndefined              ; $0b
>aa58	f3 aa					.word	GRUndefined              ; $0c
>aa5a	f3 aa					.word	GRUndefined              ; $0d
>aa5c	f3 aa					.word	GRUndefined              ; $0e
>aa5e	f3 aa					.word	GRUndefined              ; $0f
>aa60	f3 aa					.word	GRUndefined              ; $10
>aa62	f3 aa					.word	GRUndefined              ; $11
>aa64	f3 aa					.word	GRUndefined              ; $12
>aa66	f3 aa					.word	GRUndefined              ; $13
>aa68	f3 aa					.word	GRUndefined              ; $14
>aa6a	f3 aa					.word	GRUndefined              ; $15
>aa6c	f3 aa					.word	GRUndefined              ; $16
>aa6e	f3 aa					.word	GRUndefined              ; $17
>aa70	f3 aa					.word	GRUndefined              ; $18
>aa72	f3 aa					.word	GRUndefined              ; $19
>aa74	f3 aa					.word	GRUndefined              ; $1a
>aa76	f3 aa					.word	GRUndefined              ; $1b
>aa78	f3 aa					.word	GRUndefined              ; $1c
>aa7a	f3 aa					.word	GRUndefined              ; $1d
>aa7c	f3 aa					.word	GRUndefined              ; $1e
>aa7e	f3 aa					.word	GRUndefined              ; $1f
>aa80	f1 aa					.word	GXMove                   ; $20 Move
>aa82	4e ad					.word	GXLine                   ; $21 Line
>aa84	c9 ae					.word	GXFrameRectangle         ; $22 FrameRect
>aa86	c6 ae					.word	GXFillRectangle          ; $23 FillRect
>aa88	f8 aa					.word	GXFrameCircle            ; $24 FrameCircle
>aa8a	f4 aa					.word	GXFillCircle             ; $25 FillCircle
>aa8c	f3 aa					.word	GRUndefined              ; $26
>aa8e	f3 aa					.word	GRUndefined              ; $27
>aa90	ae ae					.word	GXPlotPoint              ; $28 Plot
>aa92	bb b1					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$57b					gxPixelBuffer = numberBuffer
.05c5					gxCurrentX:
>05c5							.fill 	2
.05c7					gxCurrentY:
>05c7							.fill 	2
.05c9					gxLastX:
>05c9							.fill 	2
.05cb					gxLastY:
>05cb							.fill 	2
.05cd					gxX0:
>05cd							.fill 	2
.05cf					gxY0:
>05cf							.fill 	2
.05d1					gxX1:
>05d1							.fill 	2
.05d3					gxY1:
>05d3							.fill 	2
.05d5					gxSpritesOn:
>05d5							.fill 	1
.05d6					gxBitmapsOn:
>05d6							.fill 	1
.05d7					gxBasePage:
>05d7							.fill 	1
.05d8					gxSpritePage:
>05d8							.fill 	1
.05d9					gxHeight:
>05d9							.fill 	1
.05da					gxMode:
>05da							.fill 	1
.05db					gxColour:
>05db							.fill 	1
.05dc					gxEORValue:
>05dc							.fill 	1
.05dd					gxANDValue:
>05dd							.fill 	1
.05de					gxOriginalLUTValue:
>05de							.fill 	1
.05df					gsOffset:
>05df							.fill 	1
.05e0					GSCurrentSpriteID:
>05e0							.fill 	1
.05e1					GSCurrentSpriteAddr:
>05e1							.fill 	2
.05e3					GXSpriteOffsetBase:
>05e3							.fill 	2
.05e5					GXSpriteLow:
>05e5							.fill 	64
.0625					GXSpriteHigh:
>0625							.fill 	64
.aa94					Export_GXGraphicDraw:
.aa94	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aa96	b0 06		bcs $aa9e			bcs 	_GDCoordinate
.aa98	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aa9a	84 37		sty $37				sty 	gxzTemp0+1
.aa9c	80 4b		bra $aae9			bra 	_GDExecuteA 				; and execute
.aa9e					_GDCoordinate:
.aa9e	48		pha				pha 								; save AXY
.aa9f	da		phx				phx
.aaa0	5a		phy				phy
.aaa1	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aaa3					_GDCopy1:
.aaa3	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aaa6	9d c9 05	sta $05c9,x			sta 	gxLastX,x
.aaa9	ca		dex				dex
.aaaa	10 f7		bpl $aaa3			bpl 	_GDCopy1
.aaac	68		pla				pla 								; update Y
.aaad	8d c7 05	sta $05c7			sta 	gxCurrentY
.aab0	9c c8 05	stz $05c8			stz 	gxCurrentY+1
.aab3	68		pla				pla
.aab4	8d c5 05	sta $05c5			sta 	gxCurrentX
.aab7	68		pla				pla 								; get A (command+X.1) back
.aab8	48		pha				pha
.aab9	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aabb	8d c6 05	sta $05c6			sta 	gxCurrentX+1
.aabe	68		pla				pla 								; get command back
.aabf	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aac1	48		pha				pha 								; push back.
.aac2	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aac4	f0 17		beq $aadd			beq 	_GDCopyToWorkArea
.aac6	ad c6 05	lda $05c6			lda 	gxCurrentX+1 				; X < 256 X okay
.aac9	f0 07		beq $aad2			beq 	_GDCheckY
.aacb	ad c5 05	lda $05c5			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aace	c9 40		cmp #$40			cmp 	#64
.aad0	b0 08		bcs $aada			bcs 	_GDError1
.aad2					_GDCheckY:
.aad2	ad c7 05	lda $05c7			lda 	gxCurrentY 					; check Y < Height.
.aad5	cd d9 05	cmp $05d9			cmp 	gxHeight
.aad8	90 03		bcc $aadd			bcc 	_GDCopyToWorkArea
.aada					_GDError1:
.aada	68		pla				pla
.aadb					_GDError2:
.aadb	38		sec				sec
.aadc	60		rts				rts
.aadd					_GDCopyToWorkArea:
.aadd	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.aadf					_GDCopy2:
.aadf	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aae2	9d cd 05	sta $05cd,x			sta 	gxX0,x
.aae5	ca		dex				dex
.aae6	10 f7		bpl $aadf			bpl 	_GDCopy2
.aae8	68		pla				pla 								; get command
.aae9					_GDExecuteA:
.aae9	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.aaeb	b0 ee		bcs $aadb			bcs 	_GDError2
.aaed	aa		tax				tax
.aaee	7c 40 aa	jmp ($aa40,x)			jmp 	(GRVectorTable,x)
.aaf1					GXMove:
.aaf1	18		clc				clc
.aaf2	60		rts				rts
.aaf3					GRUndefined:
>aaf3	db						.byte 	$DB 						; causes a break in the emulator
.aaf4					GXFillCircle:
.aaf4	a9 ff		lda #$ff			lda 	#255
.aaf6	80 02		bra $aafa			bra 	GXCircle
.aaf8					GXFrameCircle:
.aaf8	a9 00		lda #$00			lda 	#0
.aafa					GXCircle:
.aafa	8d 68 06	sta $0668			sta 	gxIsFillMode					; save Fill flag
.aafd	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.ab00	f0 26		beq $ab28			beq 	_GXCFail
.ab02	20 53 b3	jsr $b353			jsr 	GXSortXY 					; topleft/bottomright
.ab05	20 2b b2	jsr $b22b			jsr 	GXOpenBitmap 				; start drawing
.ab08	20 fa ab	jsr $abfa			jsr 	GXCircleSetup 				; set up for drawing
.ab0b	9c 69 06	stz $0669			stz 	gxYChanged
.ab0e					_GXCircleDraw:
.ab0e	ad 66 06	lda $0666			lda 	gXCentre					; while x <= y
.ab11	cd 67 06	cmp $0667			cmp 	gYCentre
.ab14	90 0a		bcc $ab20			bcc 	_GXCircleContinue
.ab16	d0 03		bne $ab1b			bne 	_GXNoLast
.ab18	20 2d ab	jsr $ab2d			jsr 	GXPlot1
.ab1b					_GXNoLast:
.ab1b	20 33 b2	jsr $b233			jsr 	GXCloseBitmap 				; close the bitmap
.ab1e	18		clc				clc
.ab1f	60		rts				rts
.ab20					_GXCircleContinue:
.ab20	20 2a ab	jsr $ab2a			jsr 	GXPlot2 					; draw it
.ab23	20 a7 ab	jsr $aba7			jsr 	GXCircleMove 				; adjust the coordinates
.ab26	80 e6		bra $ab0e			bra 	_GXCircleDraw
.ab28					_GXCFail:
.ab28	38		sec				sec
.ab29	60		rts				rts
.ab2a					GXPlot2:
.ab2a	20 2d ab	jsr $ab2d			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ab2d					GXPlot1:
.ab2d	ad 67 06	lda $0667			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ab30	f0 03		beq $ab35			beq 	_GXPlot1Only
.ab32	20 51 ab	jsr $ab51			jsr 	GXPlot0 						; plot and negate
.ab35					_GXPlot1Only:
.ab35	20 51 ab	jsr $ab51			jsr 	GXPlot0 						; twice, undoing negation
.ab38	ad 66 06	lda $0666			lda 	gXCentre 						; swap X and Y
.ab3b	ae 67 06	ldx $0667			ldx	 	gYCentre
.ab3e	8d 67 06	sta $0667			sta 	gYCentre
.ab41	8e 66 06	stx $0666			stx 	gXCentre
.ab44	ad 69 06	lda $0669			lda 	gxYChanged 						; toggle Y Changed flag
.ab47	a9 ff		lda #$ff			lda 	#$FF
.ab49	8d 69 06	sta $0669			sta 	gxYChanged
.ab4c	60		rts				rts
.ab4d	20 51 ab	jsr $ab51			jsr 	GXPlot0 						; do once
.ab50	60		rts				rts
.ab51	ad 68 06	lda $0668	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ab54	f0 05		beq $ab5b			beq 	_GXPlot0Always
.ab56	ad 69 06	lda $0669			lda 	gxYChanged						; fill mode, only draw if changed.
.ab59	f0 2d		beq $ab88			beq 	GXPlot0Exit
.ab5b					_GXPlot0Always:
.ab5b	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ab5d	ad 67 06	lda $0667			lda 	gYCentre
.ab60	20 89 ab	jsr $ab89			jsr 	GXSubCopy
.ab63	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ab65	ad 66 06	lda $0666			lda 	gXCentre
.ab68	20 89 ab	jsr $ab89			jsr 	GXSubCopy
.ab6b	48		pha				pha 									; save last offset X
.ab6c	20 3b b2	jsr $b23b			jsr 	GXPositionCalc 					; calculate position/offset.
.ab6f	68		pla				pla
.ab70	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ab71	85 36		sta $36				sta 	gxzTemp0
.ab73	64 37		stz $37				stz 	gxzTemp0+1
.ab75	26 37		rol $37				rol 	gxzTemp0+1
.ab77	ad 68 06	lda $0668			lda 	gxIsFillMode
.ab7a	69 80		adc #$80			adc 	#128
.ab7c	20 19 af	jsr $af19			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ab7f	38		sec				sec 									; GY = -GY
.ab80	a9 00		lda #$00			lda 	#0
.ab82	ed 67 06	sbc $0667			sbc 	gYCentre
.ab85	8d 67 06	sta $0667			sta 	gYCentre
.ab88					GXPlot0Exit:
.ab88	60		rts				rts
.ab89					GXSubCopy:
.ab89	85 36		sta $36				sta 	gxzTemp0
.ab8b	64 37		stz $37				stz 	gxzTemp0+1
.ab8d	29 80		and #$80			and 	#$80
.ab8f	f0 02		beq $ab93			beq 	_GXNoSx
.ab91	c6 37		dec $37				dec 	gxzTemp0+1
.ab93					_GXNoSx:
.ab93	38		sec				sec
.ab94	bd d1 05	lda $05d1,x			lda 	gXX1,x
.ab97	e5 36		sbc $36				sbc 	gxzTemp0
.ab99	9d cd 05	sta $05cd,x			sta 	gXX0,x
.ab9c	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.ab9f	e5 37		sbc $37				sbc 	gxzTemp0+1
.aba1	9d ce 05	sta $05ce,x			sta 	gXX0+1,x
.aba4	a5 36		lda $36				lda 	gxzTemp0 						; return A
.aba6	60		rts				rts
.aba7					GXCircleMove:
.aba7	9c 69 06	stz $0669			stz 	gxYChanged 					; clear Y changed flag
.abaa	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.abac	10 0d		bpl $abbb			bpl 	_GXEMPositive
.abae	ee 66 06	inc $0666			inc 	gXCentre 					; X++
.abb1	ad 66 06	lda $0666			lda 	gXCentre
.abb4	20 da ab	jsr $abda			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abb7	a9 06		lda #$06			lda 	#6  						; and add 6
.abb9	80 15		bra $abd0			bra 	_GXEMAddD
.abbb					_GXEMPositive:
.abbb	ee 66 06	inc $0666			inc 	gXCentre					; X++
.abbe	ce 67 06	dec $0667			dec 	gyCentre 					; Y--
.abc1	38		sec				sec 								; calculate X-Y
.abc2	ad 66 06	lda $0666			lda 	gXCentre
.abc5	ed 67 06	sbc $0667			sbc 	gYCentre
.abc8	20 da ab	jsr $abda			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abcb	a9 0a		lda #$0a			lda 	#10  						; and add 10
.abcd	ce 69 06	dec $0669			dec 	gxYChanged
.abd0					_GXEMAddD:
.abd0	18		clc				clc
.abd1	65 38		adc $38				adc 	gxzTemp1
.abd3	85 38		sta $38				sta 	gxzTemp1
.abd5	90 02		bcc $abd9			bcc 	_GXEMNoCarry
.abd7	e6 39		inc $39				inc 	gxzTemp1+1
.abd9					_GXEMNoCarry:
.abd9	60		rts				rts
.abda					_GXAdd4TimesToD:
.abda	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.abdc	29 80		and #$80			and 	#$80
.abde	f0 02		beq $abe2			beq 	_GXA4Unsigned
.abe0	a9 ff		lda #$ff			lda 	#$FF
.abe2					_GXA4Unsigned:
.abe2	85 37		sta $37				sta 	gxzTemp0+1
.abe4	06 36		asl $36				asl 	gxzTemp0  					; x 4
.abe6	26 37		rol $37				rol 	gxzTemp0+1
.abe8	06 36		asl $36				asl 	gxzTemp0
.abea	26 37		rol $37				rol 	gxzTemp0+1
.abec	18		clc				clc 								; add
.abed	a5 36		lda $36				lda		gxzTemp0
.abef	65 38		adc $38				adc 	gxzTemp1
.abf1	85 38		sta $38				sta 	gxzTemp1
.abf3	a5 37		lda $37				lda		gxzTemp0+1
.abf5	65 39		adc $39				adc 	gxzTemp1+1
.abf7	85 39		sta $39				sta 	gxzTemp1+1
.abf9	60		rts				rts
.abfa					GXCircleSetup:
.abfa	38		sec				sec
.abfb	ad d3 05	lda $05d3			lda 	gxY1
.abfe	ed cf 05	sbc $05cf			sbc 	gxY0
.ac01	4a		lsr a				lsr 	a
.ac02	8d 65 06	sta $0665			sta 	gxRadius
.ac05	a2 00		ldx #$00			ldx 	#0
.ac07	20 29 ac	jsr $ac29			jsr 	_GXCalculateCentre
.ac0a	a2 02		ldx #$02			ldx 	#2
.ac0c	20 29 ac	jsr $ac29			jsr 	_GXCalculateCentre
.ac0f	9c 66 06	stz $0666			stz 	gXCentre
.ac12	ad 65 06	lda $0665			lda 	gxRadius
.ac15	8d 67 06	sta $0667			sta 	gYCentre
.ac18	0a		asl a				asl 	a 							; R x 2
.ac19	85 36		sta $36				sta 	gxzTemp0
.ac1b	38		sec				sec
.ac1c	a9 03		lda #$03			lda 	#3
.ac1e	e5 36		sbc $36				sbc 	gxzTemp0
.ac20	85 38		sta $38				sta 	gxzTemp1
.ac22	a9 00		lda #$00			lda 	#0
.ac24	e9 00		sbc #$00			sbc 	#0
.ac26	85 39		sta $39				sta 	gxzTemp1+1
.ac28	60		rts				rts
.ac29					_GXCalculateCentre:
.ac29	38		sec				sec
.ac2a	bd d1 05	lda $05d1,x			lda 	gxX1,x
.ac2d	7d cd 05	adc $05cd,x			adc 	gXX0,x
.ac30	9d d1 05	sta $05d1,x			sta 	gXX1,x
.ac33	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.ac36	7d ce 05	adc $05ce,x			adc 	gXX0+1,x
.ac39	4a		lsr a				lsr 	a
.ac3a	9d d2 05	sta $05d2,x			sta 	gXX1+1,x
.ac3d	7e d1 05	ror $05d1,x			ror 	gXX1,x
.ac40	60		rts				rts
.0665					gxRadius:
>0665							.fill 	1
.0666					gXCentre:
>0666							.fill 	1
.0667					gYCentre:
>0667							.fill 	1
.0668					gxIsFillMode:
>0668							.fill 	1
.0669					gxYChanged:
>0669							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ac41					GXClearBitmap:
.ac41	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP running.
.ac44	f0 24		beq $ac6a			beq 	_GXCBFail
.ac46	20 2b b2	jsr $b22b			jsr 	GXOpenBitmap 				; start access
.ac49	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac4b	ad d9 05	lda $05d9			lda 	gxHeight
.ac4e	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ac50	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ac52					_GXCalcLastPage:
.ac52	98		tya				tya 								; add to base page
.ac53	18		clc				clc
.ac54	6d d7 05	adc $05d7			adc 	gxBasePage
.ac57	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ac59					_GXClearAll:
.ac59	20 6c ac	jsr $ac6c			jsr 	_GXClearBlock 				; clear 8k block
.ac5c	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ac5e	a5 0b		lda $0b				lda 	GXEditSlot
.ac60	cd d7 05	cmp $05d7			cmp 	gxBasePage 					; until before base page
.ac63	b0 f4		bcs $ac59			bcs 	_GXClearAll
.ac65	20 33 b2	jsr $b233			jsr 	GXCloseBitmap	 			; stop access
.ac68	18		clc				clc
.ac69	60		rts				rts
.ac6a					_GXCBFail:
.ac6a	38		sec				sec
.ac6b	60		rts				rts
.ac6c					_GXClearBlock:
.ac6c	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ac6e	85 38		sta $38				sta 	0+gxzTemp1
.ac70	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ac72	85 39		sta $39				sta 	1+gxzTemp1
.ac74					_GXCB0:
.ac74	a5 36		lda $36				lda 	gxzTemp0
.ac76	a0 00		ldy #$00			ldy 	#0
.ac78					_GXCB1:
.ac78	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac7a	c8		iny				iny
.ac7b	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac7d	c8		iny				iny
.ac7e	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac80	c8		iny				iny
.ac81	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac83	c8		iny				iny
.ac84	d0 f2		bne $ac78			bne 	_GXCB1
.ac86	e6 39		inc $39				inc 	gxzTemp1+1
.ac88	a5 39		lda $39				lda 	gxzTemp1+1
.ac8a	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ac8c	d0 e6		bne $ac74			bne 	_GXCB0
.ac8e	60		rts				rts
.ac8f					GXInitialise:
.ac8f	64 01		stz $01				stz 	1
.ac91	a9 01		lda #$01			lda 	#1
.ac93	8d 00 d0	sta $d000			sta 	$D000
.ac96	18		clc				clc
.ac97	9c d5 05	stz $05d5			stz 	GXSpritesOn
.ac9a	9c d6 05	stz $05d6			stz 	GXBitmapsOn
.ac9d	a2 0f		ldx #$0f			ldx 	#15
.ac9f					_GXIClear:
.ac9f	9e c5 05	stz $05c5,x			stz 	gxCurrentX,x
.aca2	ca		dex				dex
.aca3	10 fa		bpl $ac9f			bpl 	_GXIClear
.aca5	20 40 ad	jsr $ad40			jsr 	GXClearSpriteStore
.aca8	60		rts				rts
.aca9					GXControlBitmap:
.aca9	64 01		stz $01				stz 	1
.acab	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acad	29 01		and #$01			and 	#1 							; set bitmap flag
.acaf	8d d6 05	sta $05d6			sta 	gxBitmapsOn
.acb2	4a		lsr a				lsr 	a 							; bit 0 into carry.
.acb3	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.acb6	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.acb8	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.acba	90 02		bcc $acbe			bcc 	_CBNotOn
.acbc	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.acbe					_CBNotOn:
.acbe	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.acc1	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.acc3	29 07		and #$07			and 	#7
.acc5	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.acc8	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.acca	d0 02		bne $acce			bne 	_CBNotDefault
.accc	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.acce					_CBNotDefault:
.acce	8d d7 05	sta $05d7			sta 	gxBasePage
.acd1	20 32 ad	jsr $ad32			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.acd4	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.acd6	8d 03 d1	sta $d103			sta 	$D103
.acd9	a5 36		lda $36				lda 	gxzTemp0
.acdb	8d 02 d1	sta $d102			sta 	$D102
.acde	9c 01 d1	stz $d101			stz 	$D101
.ace1	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ace3	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ace6	29 01		and #$01			and 	#1
.ace8	f0 02		beq $acec			beq 	_CBHaveHeight
.acea	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.acec					_CBHaveHeight
.acec	8e d9 05	stx $05d9			stx 	gxHeight
.acef	18		clc				clc
.acf0	60		rts				rts
.acf1					GXControlSprite:
.acf1	64 01		stz $01				stz 	1
.acf3	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acf5	29 01		and #$01			and 	#1 							; set sprites flag
.acf7	8d d5 05	sta $05d5			sta 	gxSpritesOn
.acfa	4a		lsr a				lsr 	a 							; bit 0 into carry.
.acfb	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.acfe	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad00	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ad02	90 02		bcc $ad06			bcc 	_CSNotOn
.ad04	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ad06					_CSNotOn:
.ad06	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad09	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad0b	d0 02		bne $ad0f			bne 	_CSNotDefault
.ad0d	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ad0f					_CSNotDefault:
.ad0f	8d d8 05	sta $05d8			sta 	gxSpritePage
.ad12	20 32 ad	jsr $ad32			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad15	a5 36		lda $36				lda 	zTemp0
.ad17	8d e3 05	sta $05e3			sta 	GXSpriteOffsetBase
.ad1a	a5 37		lda $37				lda 	zTemp0+1
.ad1c	8d e4 05	sta $05e4			sta 	GXSpriteOffsetBase+1
.ad1f	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ad21					_CSClear:
.ad21	9e 00 d9	stz $d900,x			stz 	$D900,x
.ad24	9e 00 da	stz $da00,x			stz 	$DA00,x
.ad27	ca		dex				dex
.ad28	d0 f7		bne $ad21			bne 	_CSClear
.ad2a	9c e2 05	stz $05e2			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ad2d	20 40 ad	jsr $ad40			jsr 	GXClearSpriteStore
.ad30	18		clc				clc
.ad31	60		rts				rts
.ad32					GXCalculateBaseAddress:
.ad32	85 36		sta $36				sta 	gxzTemp0
.ad34	64 37		stz $37				stz 	gxzTemp0+1
.ad36	a9 05		lda #$05			lda 	#5
.ad38					_GXShift:
.ad38	06 36		asl $36				asl 	gxzTemp0
.ad3a	26 37		rol $37				rol 	gxzTemp0+1
.ad3c	3a		dec a				dec		a
.ad3d	d0 f9		bne $ad38			bne 	_GXShift
.ad3f	60		rts				rts
.ad40					GXClearSpriteStore:
.ad40	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ad42					_GXCSSLoop:
.ad42	9e 25 06	stz $0625,x			stz 	GXSpriteHigh,x
.ad45	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad47	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.ad4a	ca		dex				dex
.ad4b	10 f5		bpl $ad42			bpl 	_GXCSSLoop
.ad4d	60		rts				rts
.ad4e					GXLine:
.ad4e	ad d6 05	lda $05d6			lda 	GXBitmapsOn
.ad51	f0 28		beq $ad7b			beq 	_GXLFail
.ad53	20 2b b2	jsr $b22b			jsr 	GXOpenBitmap
.ad56	20 71 b3	jsr $b371			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ad59	20 21 ae	jsr $ae21			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ad5c	20 3b b2	jsr $b23b			jsr 	GXPositionCalc 				; calculate position/offset.
.ad5f					_GXDrawLoop:
.ad5f	ac df 05	ldy $05df			ldy 	gsOffset 					; draw the pixel
.ad62	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ad64	2d dd 05	and $05dd			and 	gxANDValue
.ad67	4d dc 05	eor $05dc			eor 	gxEORValue
.ad6a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ad6c	20 7d ad	jsr $ad7d			jsr 	GXLineIsComplete 			; is the line complete ?
.ad6f	f0 05		beq $ad76			beq 	_GXLExit
.ad71	20 98 ad	jsr $ad98			jsr 	GXLineAdvance 				; code as per advance method
.ad74	80 e9		bra $ad5f			bra 	_GXDrawLoop
.ad76					_GXLExit:
.ad76	20 33 b2	jsr $b233			jsr 	GXCloseBitmap
.ad79	18		clc				clc
.ad7a	60		rts				rts
.ad7b					_GXLFail:
.ad7b	38		sec				sec
.ad7c	60		rts				rts
.ad7d					GXLineIsComplete:
.ad7d	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger 			; is dy larger
.ad80	d0 0f		bne $ad91			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ad82	ad cd 05	lda $05cd			lda 	GXX0 						; compare X, LSB and MSB
.ad85	4d d1 05	eor $05d1			eor 	GXX1
.ad88	d0 06		bne $ad90			bne 	_GXLICExit
.ad8a	ad ce 05	lda $05ce			lda 	GXX0+1
.ad8d	4d d2 05	eor $05d2			eor 	GXX1+1
.ad90					_GXLICExit:
.ad90	60		rts				rts
.ad91					_GXLICCompareY:
.ad91	ad d3 05	lda $05d3			lda 	GXY1
.ad94	4d cf 05	eor $05cf			eor 	GXY0
.ad97	60		rts				rts
.ad98					GXLineAdvance:
.ad98	18		clc				clc 								; add adjust to position
.ad99	ad 6e 06	lda $066e			lda 	GXPosition
.ad9c	6d 6f 06	adc $066f			adc 	GXAdjust
.ad9f	8d 6e 06	sta $066e			sta 	GXPosition
.ada2	9c 71 06	stz $0671			stz 	GXAddSelect 				; clear add select flag
.ada5	b0 05		bcs $adac			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ada7	cd 70 06	cmp $0670			cmp 	GXTotal 					; if exceeded total
.adaa	90 0a		bcc $adb6			bcc 	_GXLANoExtra
.adac					_GXLAOverflow:
.adac	ce 71 06	dec $0671			dec 	GXAddSelect 				; set addselect to $FF
.adaf	38		sec				sec 								; subtract total and write back
.adb0	ed 70 06	sbc $0670			sbc 	GXTotal
.adb3	8d 6e 06	sta $066e			sta 	GXPosition
.adb6					_GXLANoExtra:
.adb6	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger
.adb9	f0 0d		beq $adc8			beq 	_GXDXLarger
.adbb	20 1a ae	jsr $ae1a			jsr 	GXIncrementY
.adbe	ad 71 06	lda $0671			lda 	GXAddSelect
.adc1	f0 10		beq $add3			beq 	_GXLAExit
.adc3	20 d4 ad	jsr $add4			jsr 	GXAdjustX
.adc6	80 0b		bra $add3			bra 	_GXLAExit
.adc8					_GXDXLarger:
.adc8	20 d4 ad	jsr $add4			jsr 	GXAdjustX
.adcb	ad 71 06	lda $0671			lda 	GXAddSelect
.adce	f0 03		beq $add3			beq 	_GXLAExit
.add0	20 1a ae	jsr $ae1a			jsr 	GXIncrementY
.add3					_GXLAExit:
.add3	60		rts				rts
.add4					GXAdjustX:
.add4	ad 6d 06	lda $066d			lda 	GXDXNegative
.add7	10 25		bpl $adfe			bpl 	_GXAXRight
.add9	ad cd 05	lda $05cd			lda 	GXX0
.addc	d0 03		bne $ade1			bne 	_GXAXNoBorrow
.adde	ce ce 05	dec $05ce			dec 	GXX0+1
.ade1					_GXAXNoBorrow:
.ade1	ce cd 05	dec $05cd			dec 	GXX0
.ade4	ce df 05	dec $05df			dec 	gsOffset 					; pixel left
.ade7	ad df 05	lda $05df			lda 	gsOffset
.adea	c9 ff		cmp #$ff			cmp 	#$FF
.adec	d0 0f		bne $adfd			bne 	_GXAYExit 					; underflow
.adee	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.adf0	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.adf2	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.adf4	b0 07		bcs $adfd			bcs 	_GXAYExit
.adf6	18		clc				clc
.adf7	69 20		adc #$20			adc 	#$20 						; fix up
.adf9	85 3d		sta $3d				sta 	gxzScreen+1
.adfb	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.adfd					_GXAYExit:
.adfd	60		rts				rts
.adfe					_GXAXRight:
.adfe	ee cd 05	inc $05cd			inc 	GXX0
.ae01	d0 03		bne $ae06			bne 	_GXAXNoCarry
.ae03	ee ce 05	inc $05ce			inc 	GXX0+1
.ae06					_GXAXNoCarry:
.ae06	ee df 05	inc $05df			inc 	gsOffset 					; pixel right
.ae09	d0 0e		bne $ae19			bne 	_GXAXExit 					; if not overflowed, exit.
.ae0b	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ae0d	a5 3d		lda $3d				lda 	gxzScreen+1
.ae0f	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ae11	90 06		bcc $ae19			bcc 	_GXAXExit
.ae13	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae15	85 3d		sta $3d				sta 	gxzScreen+1
.ae17	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ae19					_GXAXExit:
.ae19	60		rts				rts
.ae1a					GXIncrementY:
.ae1a	ee cf 05	inc $05cf			inc 	GXY0
.ae1d	20 91 b2	jsr $b291			jsr 	GXMovePositionDown
.ae20	60		rts				rts
.ae21					GXLineSetup:
.ae21	ad d3 05	lda $05d3			lda 	GXY1
.ae24	38		sec				sec
.ae25	ed cf 05	sbc $05cf			sbc 	GXY0
.ae28	4a		lsr a				lsr 	a
.ae29	8d 6b 06	sta $066b			sta 	GXDiffY
.ae2c	9c 6d 06	stz $066d			stz 	GXDXNegative 				; clear -ve flag
.ae2f	38		sec				sec
.ae30	ad d1 05	lda $05d1			lda 	GXX1
.ae33	ed cd 05	sbc $05cd			sbc 	GXX0
.ae36	8d 6a 06	sta $066a			sta 	GXDiffX
.ae39	ad d2 05	lda $05d2			lda 	GXX1+1 						; calculate MSB
.ae3c	ed ce 05	sbc $05ce			sbc 	GXX0+1
.ae3f	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ae40	6e 6a 06	ror $066a			ror 	GXDiffX
.ae43	0a		asl a				asl 	a
.ae44	10 0c		bpl $ae52			bpl 	_GDXNotNegative
.ae46	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae48	38		sec				sec
.ae49	ed 6a 06	sbc $066a			sbc 	GXDiffX
.ae4c	8d 6a 06	sta $066a			sta 	GXDiffX
.ae4f	ce 6d 06	dec $066d			dec 	GXDXNegative 				; -ve flag = $FF.
.ae52					_GDXNotNegative:
.ae52	9c 6c 06	stz $066c			stz 	GXIsDiffYLarger 			; clear larger flag
.ae55	ad 6b 06	lda $066b			lda 	GXDiffY 					; set adjust and total.
.ae58	8d 6f 06	sta $066f			sta 	GXAdjust
.ae5b	ad 6a 06	lda $066a			lda 	GXDiffX
.ae5e	8d 70 06	sta $0670			sta 	GXTotal
.ae61	ad 6b 06	lda $066b			lda 	GXDiffY 					; if dy > dx
.ae64	cd 6a 06	cmp $066a			cmp 	GXDiffX
.ae67	90 0f		bcc $ae78			bcc 	_GDXNotLarger
.ae69	ce 6c 06	dec $066c			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ae6c	ad 6a 06	lda $066a			lda 	GXDiffX 					; set adjust and total other way round
.ae6f	8d 6f 06	sta $066f			sta 	GXAdjust
.ae72	ad 6b 06	lda $066b			lda 	GXDiffY
.ae75	8d 70 06	sta $0670			sta 	GXTotal
.ae78					_GDXNotLarger:
.ae78	ad 70 06	lda $0670			lda 	GXTotal
.ae7b	4a		lsr a				lsr 	a
.ae7c	8d 6e 06	sta $066e			sta 	GXPosition
.ae7f	60		rts				rts
.066a					GXDiffX:
>066a							.fill 	1
.066b					GXDiffY:
>066b							.fill 	1
.066c					GXIsDiffYLarger:
>066c							.fill 	1
.066d					GXDXNegative:
>066d							.fill 	1
.066e					GXPosition:
>066e							.fill 	1
.066f					GXAdjust:
>066f							.fill 	1
.0670					GXTotal:
>0670							.fill 	1
.0671					GXAddSelect:
>0671							.fill 	1
.ae80					GXSetColourMode:
.ae80	a6 36		ldx $36				ldx 	gxzTemp0
.ae82	8e db 05	stx $05db			stx 	gxColour 								; set colour
.ae85	a5 37		lda $37				lda 	gxzTemp0+1 								;
.ae87	8d da 05	sta $05da			sta 	gxMode 									; set mode
.ae8a	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.ae8c	9c dd 05	stz $05dd			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.ae8f	ae db 05	ldx $05db			ldx 	gxColour
.ae92	8e dc 05	stx $05dc			stx 	gxEORValue
.ae95	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.ae97	90 03		bcc $ae9c			bcc 	_GXSDCNotAndColour
.ae99	8e dd 05	stx $05dd			stx 	gxANDValue
.ae9c					_GXSDCNotAndColour:
.ae9c	d0 03		bne $aea1			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.ae9e	9c dc 05	stz $05dc			stz 	gxEORValue
.aea1					_GXSDCNotAnd:
.aea1	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.aea2	90 08		bcc $aeac			bcc 	_GXSDCNoFlip
.aea4	ad dd 05	lda $05dd			lda	 	gxANDValue
.aea7	49 ff		eor #$ff			eor 	#$FF
.aea9	8d dd 05	sta $05dd			sta 	gxANDValue
.aeac					_GXSDCNoFlip:
.aeac	18		clc				clc
.aead	60		rts				rts
.aeae					GXPlotPoint:
.aeae	20 2b b2	jsr $b22b			jsr 	GXOpenBitmap 				; start drawing
.aeb1	20 3b b2	jsr $b23b			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aeb4	ac df 05	ldy $05df			ldy 	gsOffset
.aeb7	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.aeb9	2d dd 05	and $05dd			and 	gxANDValue
.aebc	4d dc 05	eor $05dc			eor 	gxEORValue
.aebf	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aec1	20 33 b2	jsr $b233			jsr 	GXCloseBitmap 				; stop drawing and exit
.aec4	18		clc				clc
.aec5	60		rts				rts
.aec6					GXFillRectangle:
.aec6	38		sec				sec
.aec7	80 01		bra $aeca			bra 	GXRectangle
.aec9					GXFrameRectangle:
.aec9	18		clc				clc
.aeca					GXRectangle:
.aeca	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.aecd	f0 35		beq $af04			beq 	_GXRFail
.aecf	08		php				php 								; save Fill flag (CS)
.aed0	20 2b b2	jsr $b22b			jsr 	GXOpenBitmap 				; start drawing
.aed3	20 53 b3	jsr $b353			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.aed6	20 3b b2	jsr $b23b			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aed9	38		sec				sec 								; sec = Draw line
.aeda	20 06 af	jsr $af06			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.aedd	ad cf 05	lda $05cf			lda 	gxY0 						; reached end of rectangle ?
.aee0	cd d3 05	cmp $05d3			cmp 	gxY1
.aee3	f0 19		beq $aefe			beq 	_GXRectangleExit
.aee5					_GXRectLoop:
.aee5	20 91 b2	jsr $b291			jsr 	GXMovePositionDown 			; down one.
.aee8	ee cf 05	inc $05cf			inc 	gxY0 						; change Y pos
.aeeb	ad cf 05	lda $05cf			lda 	gxY0 						; reached last line
.aeee	cd d3 05	cmp $05d3			cmp 	gXY1
.aef1	f0 07		beq $aefa			beq 	_GXLastLine
.aef3	28		plp				plp 								; get flag back
.aef4	08		php				php
.aef5	20 06 af	jsr $af06			jsr 	GXDrawLineX1X0 				; draw horizontal line
.aef8	80 eb		bra $aee5			bra 	_GXRectLoop
.aefa					_GXLastLine:
.aefa	38		sec				sec
.aefb	20 06 af	jsr $af06			jsr 	GXDrawLineX1X0
.aefe					_GXRectangleExit:
.aefe	68		pla				pla 								; throw fill flag.
.aeff	20 33 b2	jsr $b233			jsr 	GXCloseBitmap 				; stop drawing and exit
.af02	18		clc				clc
.af03	60		rts				rts
.af04					_GXRFail:
.af04	38		sec				sec
.af05	60		rts				rts
.af06					GXDrawLineX1X0:
.af06	08		php				php 								; save solid/either-end
.af07	38		sec				sec
.af08	ad d1 05	lda $05d1			lda		gXX1
.af0b	ed cd 05	sbc $05cd			sbc 	gXX0
.af0e	85 36		sta $36				sta 	gxzTemp0
.af10	ad d2 05	lda $05d2			lda 	gXX1+1
.af13	ed ce 05	sbc $05ce			sbc 	gXX0+1
.af16	85 37		sta $37				sta 	gxzTemp0+1
.af18	28		plp				plp
.af19					GXDrawLineTemp0:
.af19	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.af1b	48		pha				pha
.af1c	a5 3d		lda $3d				lda 	gxzScreen+1
.af1e	48		pha				pha
.af1f	ad df 05	lda $05df			lda 	gsOffset
.af22	48		pha				pha
.af23	a5 0b		lda $0b				lda 	GXEditSlot
.af25	48		pha				pha
.af26	ac df 05	ldy $05df			ldy 	gsOffset 					; Y offset
.af29	90 1e		bcc $af49			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.af2b					_GXDLTLine:
.af2b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af2d	2d dd 05	and $05dd			and 	gxANDValue
.af30	4d dc 05	eor $05dc			eor 	gxEORValue
.af33	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af35	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.af37	d0 04		bne $af3d			bne 	_GXDLTNoBorrow
.af39	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.af3b	30 2e		bmi $af6b			bmi 	_GXDLTExit
.af3d					_GXDLTNoBorrow:
.af3d	c6 36		dec $36				dec 	gxzTemp0
.af3f	c8		iny				iny 								; next slot.
.af40	d0 e9		bne $af2b			bne 	_GXDLTLine
.af42	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.af44	20 79 af	jsr $af79			jsr 	GXDLTCheckWrap				; check for new page.
.af47	80 e2		bra $af2b			bra 	_GXDLTLine
.af49					_GXDLTEndPoints:
.af49	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af4b	2d dd 05	and $05dd			and 	gxANDValue
.af4e	4d dc 05	eor $05dc			eor 	gxEORValue
.af51	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af53	98		tya				tya 								; advance to right side
.af54	18		clc				clc
.af55	65 36		adc $36				adc 	gxzTemp0
.af57	a8		tay				tay
.af58	a5 3d		lda $3d				lda 	gxzScreen+1
.af5a	65 37		adc $37				adc 	gxzTemp0+1
.af5c	85 3d		sta $3d				sta 	gxzScreen+1
.af5e	20 79 af	jsr $af79			jsr 	GXDLTCheckWrap 			; fix up.
.af61	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af63	2d dd 05	and $05dd			and 	gxANDValue
.af66	4d dc 05	eor $05dc			eor 	gxEORValue
.af69	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af6b					_GXDLTExit:
.af6b	68		pla				pla
.af6c	85 0b		sta $0b				sta 	GXEditSlot
.af6e	68		pla				pla
.af6f	8d df 05	sta $05df			sta 	gsOffset
.af72	68		pla				pla
.af73	85 3d		sta $3d				sta 	gxzScreen+1
.af75	68		pla				pla
.af76	85 3c		sta $3c				sta 	gxzScreen
.af78	60		rts				rts
.af79					GXDLTCheckWrap:
.af79	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.af7b	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.af7d	90 06		bcc $af85			bcc 	_GXDLTCWExit
.af7f	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af81	85 3d		sta $3d				sta 	gxzScreen+1
.af83	e6 0b		inc $0b				inc 	GXEditSlot
.af85					_GXDLTCWExit:
.af85	60		rts				rts
.af86					GXDrawGraphicElement:
.af86	8d 72 06	sta $0672			sta 	gxSize 						; save size
.af89	3a		dec a				dec 	a
.af8a	8d 73 06	sta $0673			sta 	gxMask 						; and mask
.af8d	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP on
.af90	f0 67		beq $aff9			beq 	_GXSLFail
.af92	ad cf 05	lda $05cf			lda 	gxY0 						; push Y on stack
.af95	48		pha				pha
.af96	8c 75 06	sty $0675			sty 	gxAcquireVector+1 			; and acquisition vector
.af99	8e 74 06	stx $0674			stx 	gxAcquireVector
.af9c	20 2b b2	jsr $b22b			jsr 	gxOpenBitmap 				; open the bitmap.
.af9f	ad 77 06	lda $0677			lda 	gxUseMode 					; scale bits
.afa2	4a		lsr a				lsr 	a
.afa3	4a		lsr a				lsr 	a
.afa4	4a		lsr a				lsr 	a
.afa5	29 07		and #$07			and		#7
.afa7	1a		inc a				inc 	a
.afa8	8d 76 06	sta $0676			sta 	gxScale
.afab	64 38		stz $38				stz 	gxzTemp1					; start first line
.afad					_GXGELoop:
.afad	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.afaf	2c 77 06	bit $0677			bit 	gxUseMode 					; check for flip.
.afb2	10 06		bpl $afba			bpl		_GXNoVFlip
.afb4	ad 73 06	lda $0673			lda 	gxMask
.afb7	38		sec				sec
.afb8	e5 38		sbc $38				sbc 	gxzTemp1
.afba					_GXNoVFlip:
.afba	aa		tax				tax 								; get the Xth line.
.afbb	20 fb af	jsr $affb			jsr 	_GXCallAcquire 				; get that data.
.afbe	ad 76 06	lda $0676			lda 	gxScale 					; do scale identical copies of that line.
.afc1	85 39		sta $39				sta 	gxzTemp1+1
.afc3					_GXGELoop2:
.afc3	ad cf 05	lda $05cf			lda 	gxY0 						; off screen
.afc6	cd d9 05	cmp $05d9			cmp 	gxHeight
.afc9	b0 10		bcs $afdb			bcs 	_GXDGEExit
.afcb	20 fe af	jsr $affe			jsr 	GXRenderOneLine 			; render line
.afce	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.afd0	d0 f1		bne $afc3			bne 	_GXGELoop2
.afd2	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.afd4	a5 38		lda $38				lda 	gxzTemp1
.afd6	cd 72 06	cmp $0672			cmp 	gxSize
.afd9	d0 d2		bne $afad			bne 	_GXGELoop
.afdb					_GXDGEExit:
.afdb	68		pla				pla 								; restore Y for next time
.afdc	8d cf 05	sta $05cf			sta 	gxY0
.afdf	ae 76 06	ldx $0676			ldx 	gxScale 					; get scale (1-8)
.afe2					_GXShiftLeft:
.afe2	18		clc				clc
.afe3	ad 72 06	lda $0672			lda 	gxSize
.afe6	6d cd 05	adc $05cd			adc 	gxX0
.afe9	8d cd 05	sta $05cd			sta 	gxX0
.afec	90 03		bcc $aff1			bcc 	_GXSLNoCarry
.afee	ee ce 05	inc $05ce			inc 	gxX0+1
.aff1					_GXSLNoCarry:
.aff1	ca		dex				dex
.aff2	d0 ee		bne $afe2			bne 	_GXShiftLeft
.aff4	20 33 b2	jsr $b233			jsr 	GXCloseBitmap
.aff7	18		clc				clc
.aff8	60		rts				rts
.aff9					_GXSLFail:
.aff9	38		sec				sec
.affa	60		rts				rts
.affb					_GXCallAcquire:
.affb	6c 74 06	jmp ($0674)			jmp 	(gxAcquireVector)
.affe					GXRenderOneLine:
.affe	20 3b b2	jsr $b23b			jsr 	GXPositionCalc 				; calculate position/offset.
.b001	ac df 05	ldy $05df			ldy 	gsOffset 					; Y contains position.
.b004	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b006					_GXROLLoop1:
.b006	ad 76 06	lda $0676			lda 	gxScale 					; set to do 'scale' times
.b009	85 3b		sta $3b				sta 	gxzTemp2+1
.b00b					_GXROLLoop2:
.b00b	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b00d	2c da 05	bit $05da			bit 	gxMode 						; check H Flip
.b010	50 06		bvc $b018			bvc 	_GXNoHFlip
.b012	ad 73 06	lda $0673			lda 	gxMask
.b015	38		sec				sec
.b016	e5 3a		sbc $3a				sbc 	gxzTemp2
.b018					_GXNoHFlip:
.b018	aa		tax				tax 								; read from the pixel buffer
.b019	bd 7b 05	lda $057b,x			lda 	gxPixelBuffer,x
.b01c	d0 07		bne $b025			bne 	_GXDraw 					; draw if non zero
.b01e	ad 77 06	lda $0677			lda 	gxUseMode 					; check to see if solid background
.b021	29 04		and #$04			and 	#4
.b023	f0 0a		beq $b02f			beq 	_GXZeroPixel
.b025					_GXDraw:
.b025	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b027	2d dd 05	and $05dd			and 	gxANDValue
.b02a	5d 7b 05	eor $057b,x			eor 	gxPixelBuffer,x
.b02d	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b02f					_GXZeroPixel:
.b02f	c8		iny				iny 								; advance pointer
.b030	d0 05		bne $b037			bne 	_GXNoShift
.b032	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b034	20 79 af	jsr $af79			jsr 	GXDLTCheckWrap				; check for new page.
.b037					_GXNoShift:
.b037	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b039	d0 d0		bne $b00b			bne 	_GXROLLoop2
.b03b	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b03d	a5 3a		lda $3a				lda 	gxzTemp2
.b03f	cd 72 06	cmp $0672			cmp 	gxSize
.b042	d0 c2		bne $b006			bne 	_GXROLLoop1
.b044	ee cf 05	inc $05cf			inc 	gxY0
.b047	60		rts				rts
.0672					gxSize:
>0672							.fill 	1
.0673					gxMask:
>0673							.fill 	1
.0674					gxAcquireVector:
>0674							.fill 	2
.0676					gxScale:
>0676							.fill 	1
.0677					gxUseMode:
>0677							.fill 	1
.b048					GXFontHandler:
.b048	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b04a	4d da 05	eor $05da			eor 	gxMode
.b04d	8d 77 06	sta $0677			sta 	gxUseMode
.b050	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b052	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b054	26 37		rol $37				rol	 	gxzTemp0+1
.b056	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b058	26 37		rol $37				rol	 	gxzTemp0+1
.b05a	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b05c	26 37		rol $37				rol	 	gxzTemp0+1
.b05e	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b060	09 c0		ora #$c0			ora 	#$C0
.b062	85 37		sta $37				sta 	gxzTemp0+1
.b064	a9 08		lda #$08			lda 	#8 							; size 8x8
.b066	a2 6e		ldx #$6e			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b068	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b06a	20 86 af	jsr $af86			jsr 	GXDrawGraphicElement
.b06d	60		rts				rts
.b06e					GXGetGraphicDataFont:
.b06e	8a		txa				txa 								; X->Y
.b06f	a8		tay				tay
.b070	a6 01		ldx $01				ldx 	1 							; preserve old value
.b072	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b074	85 01		sta $01				sta 	1
.b076	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b078	86 01		stx $01				stx 	1 							; put old value back.
.b07a	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b07c					_GXExpand:
.b07c	9e 7b 05	stz $057b,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b07f	0a		asl a				asl 	a 							; shift bit 7 into C
.b080	90 08		bcc $b08a			bcc 	_GXNoPixel
.b082	48		pha				pha 								; if set, set pixel buffer to current colour.
.b083	ad db 05	lda $05db			lda 	gxColour
.b086	9d 7b 05	sta $057b,x			sta 	gxPixelBuffer,x
.b089	68		pla				pla
.b08a					_GXNoPixel:
.b08a	e8		inx				inx 								; do the whole byte.
.b08b	e0 08		cpx #$08			cpx 	#8
.b08d	d0 ed		bne $b07c			bne 	_GXExpand
.b08f	60		rts				rts
.b090					GXSpriteHandler:
.b090	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b092	4d da 05	eor $05da			eor 	gxMode
.b095	8d 77 06	sta $0677			sta 	gxUseMode
.b098	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b09a	da		phx				phx
.b09b	20 2b b2	jsr $b22b			jsr 	GXOpenBitmap 				; can access sprite information
.b09e	68		pla				pla
.b09f	20 0c b3	jsr $b30c			jsr 	GXFindSprite 				; get the sprite address
.b0a2	08		php				php
.b0a3	20 33 b2	jsr $b233			jsr 	GXCloseBitmap
.b0a6	28		plp				plp
.b0a7	b0 0a		bcs $b0b3			bcs		_GXSHExit 					; exit if find failed.
.b0a9	ad 78 06	lda $0678			lda 	GXSizePixels 				; return size
.b0ac	a2 b4		ldx #$b4			ldx 	#GXSpriteAcquire & $FF
.b0ae	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b0b0	20 86 af	jsr $af86			jsr 	GXDrawGraphicElement
.b0b3					_GXSHExit:
.b0b3	60		rts				rts
.b0b4					GXSpriteAcquire:
.b0b4	ad d8 05	lda $05d8			lda 	GXSpritePage				; point to base page
.b0b7	85 0b		sta $0b				sta 	GXEditSlot
.b0b9	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b0bb	a9 00		lda #$00			lda 	#0
.b0bd	ae 79 06	ldx $0679			ldx 	GXSizeBits
.b0c0					_GXTimesRowNumber:
.b0c0	18		clc				clc
.b0c1	65 36		adc $36				adc 	zTemp0
.b0c3	ca		dex				dex
.b0c4	10 fa		bpl $b0c0			bpl 	_GXTimesRowNumber
.b0c6	64 37		stz $37				stz 	gxzTemp0+1
.b0c8	0a		asl a				asl 	a 							; row x 2,4,6,8
.b0c9	26 37		rol $37				rol 	gxzTemp0+1
.b0cb	0a		asl a				asl 	a 							; row x 4,8,12,16
.b0cc	26 37		rol $37				rol 	gxzTemp0+1
.b0ce	0a		asl a				asl 	a 							; row x 8,16,24,32
.b0cf	26 37		rol $37				rol 	gxzTemp0+1
.b0d1	85 36		sta $36				sta 	gxzTemp0
.b0d3	18		clc				clc 								; add base address.
.b0d4	a5 36		lda $36				lda 	gxzTemp0
.b0d6	6d 7b 06	adc $067b			adc 	GXSpriteOffset
.b0d9	85 36		sta $36				sta 	gxzTemp0
.b0db	a5 37		lda $37				lda 	gxzTemp0+1
.b0dd	6d 7c 06	adc $067c			adc 	GXSpriteOffset+1
.b0e0					_GXSAFindPage:
.b0e0	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b0e2	90 06		bcc $b0ea			bcc 	_GXSAFoundPage
.b0e4	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b0e6	e6 0b		inc $0b				inc 	GXEditSlot
.b0e8	80 f6		bra $b0e0			bra 	_GXSAFindPage
.b0ea					_GXSAFoundPage:
.b0ea	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b0ec	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b0ee	a0 00		ldy #$00			ldy 	#0
.b0f0					_GXSACopyLoop:
.b0f0	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b0f2	99 7b 05	sta $057b,y			sta 	gxPixelBuffer,y
.b0f5	c8		iny				iny
.b0f6	cc 78 06	cpy $0678			cpy 	GXSizePixels
.b0f9	d0 f5		bne $b0f0			bne 	_GXSACopyLoop
.b0fb	60		rts				rts
.b0fc					GXSelect:
.b0fc	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b0ff	f0 22		beq $b123			beq 	_GXSFail
.b101	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b103	c9 40		cmp #$40			cmp 	#64
.b105	b0 1c		bcs $b123			bcs 	_GXSFail
.b107	8d e0 05	sta $05e0			sta 	GSCurrentSpriteID
.b10a	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b10c	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b10e	06 36		asl $36				asl 	gxzTemp0
.b110	06 36		asl $36				asl 	gxzTemp0
.b112	06 36		asl $36				asl 	gxzTemp0
.b114	2a		rol a				rol 	a
.b115	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b117	8d e2 05	sta $05e2			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b11a	85 37		sta $37				sta 	gxzTemp0+1
.b11c	a5 36		lda $36				lda 	gxzTemp0
.b11e	8d e1 05	sta $05e1			sta 	GSCurrentSpriteAddr
.b121	18		clc				clc
.b122	60		rts				rts
.b123					_GXSFail:
.b123	38		sec				sec
.b124	60		rts				rts
.b125					GXSelectImage:
.b125	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b128	f0 74		beq $b19e			beq 	_GXSIFail
.b12a	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b12d	f0 6f		beq $b19e			beq 	_GXSIFail 					; (checking the MSB)
.b12f	64 01		stz $01				stz 	1
.b131	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b133	d0 6b		bne $b1a0			bne 	_GXSIHide
.b135	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b137	48		pha				pha
.b138	20 2b b2	jsr $b22b			jsr 	GXOpenBitmap
.b13b	68		pla				pla
.b13c	20 0c b3	jsr $b30c			jsr 	GXFindSprite
.b13f	b0 5a		bcs $b19b			bcs 	_GXSICloseFail 				; no image
.b141	a0 01		ldy #$01			ldy 	#1
.b143	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b146	85 36		sta $36				sta 	gxzTemp0
.b148	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b14b	85 37		sta $37				sta 	gxzTemp0+1
.b14d	ad 7b 06	lda $067b			lda 	GXSpriteOffset
.b150	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b152	18		clc				clc
.b153	ad 7c 06	lda $067c			lda 	GXSpriteOffset+1
.b156	6d e3 05	adc $05e3			adc 	GXSpriteOffsetBase
.b159	c8		iny				iny
.b15a	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b15c	ad e4 05	lda $05e4			lda 	GXSpriteOffsetBase+1
.b15f	69 00		adc #$00			adc 	#0
.b161	c8		iny				iny
.b162	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b164	ad 79 06	lda $0679			lda 	GXSizeBits 					; get raw size
.b167	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b169	2a		rol a				rol 	a 							; x 2
.b16a	0a		asl a				asl 	a 							; x 4
.b16b	0a		asl a				asl 	a 							; x 8
.b16c	0a		asl a				asl 	a 							; x 16
.b16d	0d 7a 06	ora $067a			ora 	GXSpriteLUT 				; Or with LUT
.b170	0a		asl a				asl 	a 							; 1 shift
.b171	09 01		ora #$01			ora 	#1 							; enable sprite.
.b173	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b175	20 33 b2	jsr $b233			jsr 	GXCloseBitmap
.b178	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b17b	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b17e	29 3f		and #$3f			and 	#$3F
.b180	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b183	ad 79 06	lda $0679			lda 	GXSizeBits 					; get bit size
.b186	6a		ror a				ror 	a 							; shift into bits 6/7
.b187	6a		ror a				ror 	a
.b188	6a		ror a				ror 	a
.b189	29 c0		and #$c0			and 	#$C0
.b18b	1d 25 06	ora $0625,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b18e	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b191	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b194	29 7f		and #$7f			and 	#$7F
.b196	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b199	18		clc				clc
.b19a	60		rts				rts
.b19b					_GXSICloseFail:
.b19b	20 33 b2	jsr $b233			jsr 	GXCloseBitmap
.b19e					_GXSIFail:
.b19e	38		sec				sec
.b19f	60		rts				rts
.b1a0					_GXSIHide:
.b1a0	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b1a3	85 36		sta $36				sta 	gxzTemp0
.b1a5	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b1a8	85 37		sta $37				sta 	gxzTemp0+1
.b1aa	a9 00		lda #$00			lda 	#0
.b1ac	92 36		sta ($36)			sta 	(gxzTemp0)
.b1ae	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get sprite ID
.b1b1	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b1b4	09 80		ora #$80			ora 	#$80
.b1b6	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b1b9	18		clc				clc
.b1ba	60		rts				rts
.b1bb					GXMoveSprite:
.b1bb	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b1be	f0 65		beq $b225			beq 	_GXSIFail
.b1c0	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b1c3	f0 60		beq $b225			beq 	_GXSIFail
.b1c5	85 37		sta $37				sta 	gxzTemp0+1
.b1c7	a0 04		ldy #$04			ldy 	#4
.b1c9	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b1cc	85 36		sta $36				sta 	gxzTemp0
.b1ce	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b1d1	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b1d4	2a		rol a				rol 	a	 						; into bits 0,1.
.b1d5	2a		rol a				rol 	a
.b1d6	2a		rol a				rol 	a
.b1d7	29 03		and #$03			and 	#3
.b1d9	aa		tax				tax
.b1da	bd 27 b2	lda $b227,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b1dd	48		pha				pha
.b1de	18		clc				clc
.b1df	6d cd 05	adc $05cd			adc 	gxX0						; copy position.
.b1e2	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1e4	c8		iny				iny
.b1e5	ad ce 05	lda $05ce			lda 	gxX0+1
.b1e8	69 00		adc #$00			adc 	#0
.b1ea	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1ec	c8		iny				iny
.b1ed	68		pla				pla
.b1ee	18		clc				clc
.b1ef	6d cf 05	adc $05cf			adc 	gxY0
.b1f2	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1f4	a9 00		lda #$00			lda 	#0
.b1f6	69 00		adc #$00			adc 	#0
.b1f8	c8		iny				iny
.b1f9	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1fb	4e ce 05	lsr $05ce			lsr 	gxX0+1 						; divide X by 4
.b1fe	6e cd 05	ror $05cd			ror 	gxX0
.b201	4e cd 05	lsr $05cd			lsr 	gxX0
.b204	4e cf 05	lsr $05cf			lsr 	gxY0 						; divide Y by 4
.b207	4e cf 05	lsr $05cf			lsr 	gxY0
.b20a	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b20d	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x
.b210	29 80		and #$80			and 	#$80
.b212	0d cd 05	ora $05cd			ora 	gxX0
.b215	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b218	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b21b	29 c0		and #$c0			and 	#$C0
.b21d	0d cf 05	ora $05cf			ora 	gxY0
.b220	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b223	18		clc				clc
.b224	60		rts				rts
.b225					_GXSIFail:
.b225	38		sec				sec
.b226	60		rts				rts
.b227					_GXMSOffset:
>b227	1c						.byte 	32-8/2
>b228	18						.byte 	32-16/2
>b229	14						.byte 	32-24/2
>b22a	10						.byte 	32-32/2
.b22b					GXOpenBitmap:
.b22b	78		sei				sei 								; no interrupts here
.b22c	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b22e	8d de 05	sta $05de			sta 	gxOriginalLUTValue
.b231	58		cli				cli
.b232	60		rts				rts
.b233					GXCloseBitmap:
.b233	78		sei				sei
.b234	ad de 05	lda $05de			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b237	85 0b		sta $0b				sta 	GXEditSlot
.b239	58		cli				cli
.b23a	60		rts				rts
.b23b					GXPositionCalc:
.b23b	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b23d	48		pha				pha
.b23e	ad cf 05	lda $05cf			lda 	GXY0 						; gxzScreen = Y0
.b241	85 3c		sta $3c				sta 	gxzScreen
.b243	64 3d		stz $3d				stz 	gxzScreen+1
.b245	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b247	26 3d		rol $3d				rol 	gxzScreen+1
.b249	06 3c		asl $3c				asl 	gxzScreen
.b24b	26 3d		rol $3d				rol 	gxzScreen+1
.b24d	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b24e	65 3c		adc $3c				adc 	gxzScreen
.b250	85 3c		sta $3c				sta 	gxzScreen
.b252	90 02		bcc $b256			bcc 	_GXPCNoCarry
.b254	e6 3d		inc $3d				inc 	gxzScreen+1
.b256					_GXPCNoCarry:
.b256	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b258	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b25a	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b25c	85 36		sta $36				sta 	gxzTemp0
.b25e	64 3d		stz $3d				stz 	gxzScreen+1
.b260	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b262					_GXPCMultiply32:
.b262	06 3c		asl $3c				asl 	gxzScreen
.b264	26 3d		rol $3d				rol 	gxzScreen+1
.b266	3a		dec a				dec 	a
.b267	d0 f9		bne $b262			bne 	_GXPCMultiply32
.b269	18		clc				clc
.b26a	ad cd 05	lda $05cd			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b26d	65 3c		adc $3c				adc 	gxzScreen
.b26f	8d df 05	sta $05df			sta 	gsOffset
.b272	ad ce 05	lda $05ce			lda 	GXX0+1
.b275	65 3d		adc $3d				adc 	gxzScreen+1
.b277	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b279	90 04		bcc $b27f			bcc 	_GXPCNoOverflow
.b27b	29 1f		and #$1f			and 	#$1F 						; fix it up
.b27d	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b27f					_GXPCNoOverflow:
.b27f	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b281	85 3d		sta $3d				sta 	gxzScreen+1
.b283	64 3c		stz $3c				stz 	gxzScreen
.b285	18		clc				clc
.b286	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b288	6d d7 05	adc $05d7			adc 	gxBasePage 					; by adding the base page
.b28b	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b28d	68		pla				pla
.b28e	85 36		sta $36				sta 	gxzTemp0
.b290	60		rts				rts
.b291					GXMovePositionDown:
.b291	18		clc				clc 								; add 320 to offset/temp+1
.b292	ad df 05	lda $05df			lda 	gsOffset
.b295	69 40		adc #$40			adc 	#64
.b297	8d df 05	sta $05df			sta 	gsOffset
.b29a	a5 3d		lda $3d				lda 	gxzScreen+1
.b29c	69 01		adc #$01			adc 	#1
.b29e	85 3d		sta $3d				sta 	gxzScreen+1
.b2a0	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b2a2	90 07		bcc $b2ab			bcc 	_GXMPDExit
.b2a4	38		sec				sec  								; next page
.b2a5	e9 20		sbc #$20			sbc 	#$20
.b2a7	85 3d		sta $3d				sta 	gxzScreen+1
.b2a9	e6 0b		inc $0b				inc 	GXEditSlot
.b2ab					_GXMPDExit:
.b2ab	60		rts				rts
.b2ac					GXCollide:
.b2ac	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b2ae	aa		tax				tax
.b2af	05 37		ora $37				ora 	gxzTemp0+1
.b2b1	29 c0		and #$c0			and 	#$C0
.b2b3	38		sec				sec
.b2b4	d0 53		bne $b309			bne 	_GXCollideFail 				; if either >= 64, fail.
.b2b6	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b2b8	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b2bb	1d e5 05	ora $05e5,x			ora 	GXSpriteLow,x
.b2be	30 48		bmi $b308			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b2c0	18		clc				clc 								; need to calculate sum of sizes.
.b2c1	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y
.b2c4	7d 25 06	adc $0625,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b2c7	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b2c9	6a		ror a				ror 	a 							; 5/6/7
.b2ca	4a		lsr a				lsr 	a 							; 4/5/6
.b2cb	4a		lsr a				lsr 	a 							; 3/4/5
.b2cc	4a		lsr a				lsr 	a 							; 2/3/4
.b2cd	18		clc				clc
.b2ce	69 08		adc #$08			adc 	#$08
.b2d0	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b2d1	4a		lsr a				lsr 	a
.b2d2	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b2d4	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b2d7	29 3f		and #$3f			and 	#$3F
.b2d9	85 39		sta $39				sta 	gxzTemp1+1
.b2db	38		sec				sec
.b2dc	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b2df	29 3f		and #$3f			and 	#$3F
.b2e1	e5 39		sbc $39				sbc 	gxzTemp1+1
.b2e3	b0 03		bcs $b2e8			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b2e5	49 ff		eor #$ff			eor 	#$FF
.b2e7	1a		inc a				inc 	a
.b2e8					_GXCAbs1:
.b2e8	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b2ea	b0 1c		bcs $b308			bcs 	_GXOkayFail
.b2ec	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b2ee	38		sec				sec 								; calculate |x1-x0|
.b2ef	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y
.b2f2	fd e5 05	sbc $05e5,x			sbc 	GXSpriteLow,x
.b2f5	b0 03		bcs $b2fa			bcs 	_GXCAbs2
.b2f7	49 ff		eor #$ff			eor 	#$FF
.b2f9	1a		inc a				inc 	a
.b2fa					_GXCAbs2:
.b2fa	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b2fc	b0 0a		bcs $b308			bcs 	_GXOkayFail
.b2fe	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b300	90 02		bcc $b304			bcc 	_GXCHaveLowest
.b302	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b304					_GXCHaveLowest:
.b304	0a		asl a				asl 	a 							; scale to allow for >> 2
.b305	0a		asl a				asl 	a
.b306	18		clc				clc
.b307	60		rts				rts
.b308					_GXOkayFail:
.b308	18		clc				clc
.b309					_GXCollideFail:
.b309	a9 ff		lda #$ff			lda 	#$FF
.b30b	60		rts				rts
.b30c					GXFindSprite:
.b30c	aa		tax				tax
.b30d	ad d8 05	lda $05d8			lda 	GXSpritePage 				; access the base page of the sprite
.b310	85 0b		sta $0b				sta 	GXEditSlot
.b312	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b315	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b318	f0 33		beq $b34d			beq 	_GXFSFail
.b31a	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b31d	8d 7c 06	sta $067c			sta 	GXSpriteOffset+1
.b320	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b323	48		pha				pha 								; save twice
.b324	48		pha				pha
.b325	29 03		and #$03			and 	#3 							; get sprite size
.b327	8d 79 06	sta $0679			sta 	GXSizeBits 					; save raw (0-3)
.b32a	aa		tax				tax
.b32b	bd 4f b3	lda $b34f,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b32e	8d 78 06	sta $0678			sta 	GXSizePixels 					; save (8/16/24/32)
.b331	68		pla				pla 								; get LUT
.b332	4a		lsr a				lsr		a
.b333	4a		lsr a				lsr		a
.b334	29 03		and #$03			and 	#3
.b336	8d 7a 06	sta $067a			sta 	GXSpriteLUT
.b339	68		pla				pla 								; address, neeeds to be x 4
.b33a	29 f0		and #$f0			and 	#$F0
.b33c	8d 7b 06	sta $067b			sta 	GXSpriteOffset
.b33f	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b342	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b345	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b348	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b34b	18		clc				clc
.b34c	60		rts				rts
.b34d					_GXFSFail:
.b34d	38		sec				sec
.b34e	60		rts				rts
.b34f					_GXFXSSTTable:
>b34f	08 10 18 20					.byte 	8,16,24,32
.0678					GXSizePixels:
>0678							.fill 	1
.0679					GXSizeBits:
>0679							.fill 	1
.067a					GXSpriteLUT:
>067a							.fill 	1
.067b					GXSpriteOffset:
>067b							.fill 	2
.b353					GXSortXY:
.b353	20 71 b3	jsr $b371			jsr 	GXSortY 					; will be sorted on Y now
.b356	ad cd 05	lda $05cd			lda 	gxX0 						; compare X0 v X1
.b359	cd d1 05	cmp $05d1			cmp 	gxX1
.b35c	ad ce 05	lda $05ce			lda 	gXX0+1
.b35f	ed d2 05	sbc $05d2			sbc 	gXX1+1
.b362	90 0c		bcc $b370			bcc 	_GXSXYExit 					; X0 < X1 exit
.b364	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b366	a0 04		ldy #$04			ldy 	#4
.b368	20 85 b3	jsr $b385			jsr 	GXSwapXY
.b36b	e8		inx				inx
.b36c	c8		iny				iny
.b36d	20 85 b3	jsr $b385			jsr 	GXSwapXY
.b370					_GXSXYExit:
.b370	60		rts				rts
.b371					GXSortY:
.b371	ad cf 05	lda $05cf			lda 	gxY0 						; if Y0 >= Y1
.b374	cd d3 05	cmp $05d3			cmp 	gxY1
.b377	90 0b		bcc $b384			bcc 	_GXSYSorted
.b379	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b37b	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b37d					_GXSwap1:
.b37d	20 85 b3	jsr $b385			jsr 	GXSwapXY
.b380	88		dey				dey
.b381	ca		dex				dex
.b382	10 f9		bpl $b37d			bpl 	_GXSwap1
.b384					_GXSYSorted:
.b384	60		rts				rts
.b385					GXSwapXY:
.b385	bd cd 05	lda $05cd,x			lda 	gxX0,x
.b388	48		pha				pha
.b389	b9 cd 05	lda $05cd,y			lda 	gxX0,y
.b38c	9d cd 05	sta $05cd,x			sta 	gxX0,x
.b38f	68		pla				pla
.b390	99 cd 05	sta $05cd,y			sta 	gxX0,y
.b393	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b394					KeywordSet0:
>b394	00 65					.text	0,$65,""               ; $80 !0:EOF
>b396	00 58					.text	0,$58,""               ; $81 !1:SH1
>b398	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b39a	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b3a0	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b3a8	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b3ae	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b3b5	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>b3bd	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>b3c4	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>b3cb	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>b3d1	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>b3d7	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>b3df	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>b3e6	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>b3ed	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>b3f4	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>b3fc	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>b402	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>b408	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>b40f	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>b415	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>b41b	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>b423	47 28
>b425	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>b42d	28
>b42e	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>b436	28
>b437	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>b43d	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>b443	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>b449	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>b450	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>b458	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>b45e	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>b464	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>b469	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>b46d	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>b473	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>b47b	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>b482	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>b489	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>b491	43
>b492	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>b498	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>b49e	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>b4a5	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>b4ab	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>b4af	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>b4b5	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>b4bd	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>b4c4	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>b4c9	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>b4d0	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>b4d8	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>b4de	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>b4e3	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>b4eb	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>b4f1	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>b4f7	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>b4fc	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>b503	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>b509	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>b50f	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>b516	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>b51d	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>b522	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>b528	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>b52f	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>b534	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>b538	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>b540	45
>b541	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>b549	45
>b54a	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>b550	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>b557	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>b55d	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>b563	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>b568	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>b570	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>b577	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>b57e	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>b586	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>b58c	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>b590	ff					.text	$FF
.b591					KeywordSet1:
>b591	00 65					.text	0,$65,""               ; $80 !0:EOF
>b593	00 58					.text	0,$58,""               ; $81 !1:SH1
>b595	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b597	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b59f	4c 45
>b5a1	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b5a9	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b5b1	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b5b6	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>b5ba	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>b5c0	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>b5c6	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>b5cb	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>b5d3	45
>b5d4	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>b5d9	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>b5e1	53
>b5e2	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>b5e8	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $8f WHO
>b5ed	ff					.text	$FF
.b5ee					KeywordSet2:
>b5ee	00 65					.text	0,$65,""               ; $80 !0:EOF
>b5f0	00 58					.text	0,$58,""               ; $81 !1:SH1
>b5f2	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b5f4	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b5f9	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b5fe	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b603	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b608	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b60d	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b612	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b617	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b61c	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b621	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b626	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b62b	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b630	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b635	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b63a	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b63f	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b644	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b649	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b64e	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b653	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b658	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b65d	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b662	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b667	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b66c	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b671	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b676	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b67b	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b680	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b685	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b68a	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b68f	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b694	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b699	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b69e	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b6a3	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b6a8	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b6ad	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b6b2	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b6b7	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b6bc	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b6c1	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b6c6	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b6cb	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b6d0	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b6d5	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b6da	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b6df	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b6e4	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b6e9	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b6ee	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b6f3	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b6f8	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b6fd	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b702	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b707	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b70c	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b711	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b716	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b71b	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b720	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b725	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b72a	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b72f	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b734	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b739	ff					.text	$FF
.b73a					Export_TKListConvertLine:
.b73a	48		pha				pha 								; save indent on the stack
.b73b	9c 1d 04	stz $041d			stz 	tbOffset
.b73e	9c 2d 04	stz $042d			stz 	tokenBuffer
.b741	9c 29 04	stz $0429			stz 	currentListColour
.b744	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b746	20 c3 b8	jsr $b8c3			jsr 	LCLWriteColour
.b749	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b74b	b1 30		lda ($30),y			lda 	(codePtr),y
.b74d	aa		tax				tax
.b74e	88		dey				dey
.b74f	b1 30		lda ($30),y			lda 	(codePtr),y
.b751	20 34 b9	jsr $b934			jsr 	LCLWriteNumberXA
.b754	68		pla				pla 								; adjustment to indent
.b755	48		pha				pha 								; save on stack
.b756	10 0c		bpl $b764			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b758	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b759	6d 26 04	adc $0426			adc 	listIndent
.b75c	8d 26 04	sta $0426			sta 	listIndent
.b75f	10 03		bpl $b764			bpl 	_LCNoAdjust
.b761	9c 26 04	stz $0426			stz 	listIndent
.b764					_LCNoAdjust:
.b764	18		clc				clc		 							; work out actual indent.
.b765	ad 26 04	lda $0426			lda 	listIndent
.b768	0a		asl a				asl 	a
.b769	69 07		adc #$07			adc 	#7
.b76b	85 36		sta $36				sta 	zTemp0
.b76d					_LCPadOut:
.b76d	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b76f	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b772	ad 1d 04	lda $041d			lda 	tbOffset
.b775	c5 36		cmp $36				cmp 	zTemp0
.b777	d0 f4		bne $b76d			bne 	_LCPadOut
.b779	a0 03		ldy #$03			ldy 	#3 							; start position.
.b77b					_LCMainLoop:
.b77b	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b77d	20 c3 b8	jsr $b8c3			jsr 	LCLWriteColour
.b780	b1 30		lda ($30),y			lda 	(codePtr),y
.b782	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b784	f0 17		beq $b79d			beq 	_LCExit
.b786	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b788	90 1e		bcc $b7a8			bcc 	_LCDoubles
.b78a	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b78c	90 2a		bcc $b7b8			bcc 	_LCShiftPunc
.b78e	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b790	90 35		bcc $b7c7			bcc 	_LCPunctuation
.b792	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b794	90 51		bcc $b7e7			bcc 	_LCIdentifiers
.b796	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b798	90 73		bcc $b80d			bcc 	_LCTokens
.b79a	4c 6d b8	jmp $b86d			jmp 	_LCData 					; 254-5 are data objects
.b79d					_LCExit:
.b79d	68		pla				pla 								; get old indent adjust
.b79e	30 07		bmi $b7a7			bmi 	_LCExit2
.b7a0	18		clc				clc 								; add to indent if +ve
.b7a1	6d 26 04	adc $0426			adc 	listIndent
.b7a4	8d 26 04	sta $0426			sta 	listIndent
.b7a7					_LCExit2:
.b7a7	60		rts				rts
.b7a8					_LCDoubles:
.b7a8	48		pha				pha
.b7a9	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b7aa	29 02		and #$02			and 	#2
.b7ac	09 3c		ora #$3c			ora 	#60 						; make < >
.b7ae	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b7b1	68		pla				pla 								; restore, do lower bit
.b7b2	29 03		and #$03			and 	#3
.b7b4	09 3c		ora #$3c			ora 	#60
.b7b6	80 0f		bra $b7c7			bra		_LCPunctuation 				; print, increment, loop
.b7b8					_LCShiftPunc:
.b7b8	aa		tax				tax 								; save in X
.b7b9	29 07		and #$07			and 	#7 							; lower 3 bits
.b7bb	f0 02		beq $b7bf			beq 	_LCNoAdd
.b7bd	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b7bf					_LCNoAdd:
.b7bf	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b7c1	90 02		bcc $b7c5			bcc 	_LCNoAdd2
.b7c3	09 20		ora #$20			ora 	#32 						; adds $20
.b7c5					_LCNoAdd2:
.b7c5	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b7c7					_LCPunctuation:
.b7c7	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b7c9	d0 03		bne $b7ce			bne 	_LCPContinue
.b7cb	20 e2 b8	jsr $b8e2			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b7ce					_LCPContinue:
.b7ce	c9 2e		cmp #$2e			cmp 	#'.'
.b7d0	f0 08		beq $b7da			beq 	_LCPIsConstant
.b7d2	c9 30		cmp #$30			cmp 	#'0'
.b7d4	90 0b		bcc $b7e1			bcc 	_LCPNotConstant
.b7d6	c9 3a		cmp #$3a			cmp 	#'9'+1
.b7d8	b0 07		bcs $b7e1			bcs 	_LCPNotConstant
.b7da					_LCPIsConstant:
.b7da	48		pha				pha
.b7db	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b7dd	20 c3 b8	jsr $b8c3			jsr 	LCLWriteColour
.b7e0	68		pla				pla
.b7e1					_LCPNotConstant:
.b7e1	c8		iny				iny 								; consume character
.b7e2	20 cc b8	jsr $b8cc			jsr 	LCLWrite 					; write it out.
.b7e5	80 94		bra $b77b			bra 	_LCMainLoop 				; go round again.
.b7e7					_LCIdentifiers:
.b7e7	18		clc				clc 								; convert to physical address
.b7e8	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b7ea	85 37		sta $37				sta 	zTemp0+1
.b7ec	c8		iny				iny
.b7ed	b1 30		lda ($30),y			lda 	(codePtr),y
.b7ef	85 36		sta $36				sta 	zTemp0
.b7f1	c8		iny				iny
.b7f2	5a		phy				phy 								; save position
.b7f3	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b7f5	20 c3 b8	jsr $b8c3			jsr 	LCLWriteColour
.b7f8	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b7fa					_LCOutIdentifier:
.b7fa	c8		iny				iny
.b7fb	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b7fd	29 7f		and #$7f			and 	#$7F
.b7ff	20 1e b9	jsr $b91e			jsr 	LCLLowerCase
.b802	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b805	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b807	10 f1		bpl $b7fa			bpl 	_LCOutIdentifier
.b809	7a		ply				ply 								; restore position
.b80a	4c 7b b7	jmp $b77b			jmp 	_LCMainLoop
.b80d					_LCTokens:
.b80d	aa		tax				tax 								; token in X
.b80e	a9 ee		lda #$ee			lda 	#((KeywordSet2) & $FF)
.b810	85 36		sta $36				sta 	0+zTemp0
.b812	a9 b5		lda #$b5			lda 	#((KeywordSet2) >> 8)
.b814	85 37		sta $37				sta 	1+zTemp0
.b816	e0 82		cpx #$82			cpx 	#$82
.b818	f0 16		beq $b830			beq 	_LCUseShift
.b81a	a9 91		lda #$91			lda 	#((KeywordSet1) & $FF)
.b81c	85 36		sta $36				sta 	0+zTemp0
.b81e	a9 b5		lda #$b5			lda 	#((KeywordSet1) >> 8)
.b820	85 37		sta $37				sta 	1+zTemp0
.b822	e0 81		cpx #$81			cpx 	#$81
.b824	f0 0a		beq $b830			beq 	_LCUseShift
.b826	a9 94		lda #$94			lda 	#((KeywordSet0) & $FF)
.b828	85 36		sta $36				sta 	0+zTemp0
.b82a	a9 b3		lda #$b3			lda 	#((KeywordSet0) >> 8)
.b82c	85 37		sta $37				sta 	1+zTemp0
.b82e	80 01		bra $b831			bra 	_LCNoShift
.b830					_LCUseShift:
.b830	c8		iny				iny
.b831					_LCNoShift:
.b831	20 f6 b8	jsr $b8f6			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b834	b1 30		lda ($30),y			lda 	(codePtr),y
.b836	aa		tax				tax 								; into X
.b837					_LCFindText:
.b837	ca		dex				dex
.b838	10 0e		bpl $b848			bpl 	_LCFoundText 				; found text.
.b83a	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b83c	1a		inc a				inc 	a 							; one extra for size
.b83d	38		sec				sec 								; one extra for checksum
.b83e	65 36		adc $36				adc 	zTemp0 						; go to next token
.b840	85 36		sta $36				sta 	zTemp0
.b842	90 f3		bcc $b837			bcc 	_LCFindText
.b844	e6 37		inc $37				inc 	zTemp0+1
.b846	80 ef		bra $b837			bra 	_LCFindText
.b848					_LCFoundText:
.b848	5a		phy				phy 								; save List position
.b849	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b84b	aa		tax				tax
.b84c	a9 83		lda #$83			lda 	#CLIToken+$80
.b84e	20 c3 b8	jsr $b8c3			jsr 	LCLWriteColour
.b851	a0 02		ldy #$02			ldy 	#2
.b853					_LCCopyToken:
.b853	b1 36		lda ($36),y			lda 	(zTemp0),y
.b855	20 1e b9	jsr $b91e			jsr 	LCLLowerCase
.b858	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b85b	c8		iny				iny
.b85c	ca		dex				dex
.b85d	d0 f4		bne $b853			bne 	_LCCopyToken
.b85f	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b861	f0 05		beq $b868			beq 	_LCNoSpace
.b863	a9 20		lda #$20			lda 	#' '
.b865	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b868					_LCNoSpace:
.b868	7a		ply				ply 								; restore position.
.b869	c8		iny				iny 								; consume token
.b86a	4c 7b b7	jmp $b77b			jmp 	_LCMainLoop 				; and go around again.
.b86d					_LCData:
.b86d	48		pha				pha 								; save type $FE/$FF
.b86e	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b870	c9 fe		cmp #$fe			cmp 	#$FE
.b872	f0 22		beq $b896			beq 	_LCHaveOpener
.b874	a2 22		ldx #$22			ldx 	#'"'
.b876	a9 81		lda #$81			lda 	#CLIData+$80
.b878	20 c3 b8	jsr $b8c3			jsr 	LCLWriteColour
.b87b	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b87d	d0 17		bne $b896			bne 	_LCHaveOpener
.b87f	88		dey				dey 								; what precedes it ?
.b880	b1 30		lda ($30),y			lda 	(codePtr),y
.b882	c8		iny				iny
.b883	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b885	d0 0f		bne $b896			bne 	_LCHaveOpener
.b887	a9 09		lda #$09			lda 	#9 							; tab
.b889	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b88c	a9 97		lda #$97			lda 	#$90+CLIBComment
.b88e	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b891	a9 80		lda #$80			lda 	#CLIFComment+$80
.b893	20 c3 b8	jsr $b8c3			jsr 	LCLWriteColour
.b896					_LCHaveOpener:
.b896	8a		txa				txa 								; output prefix (# or ")
.b897	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b89a	c8		iny				iny 								; get count
.b89b	b1 30		lda ($30),y			lda 	(codePtr),y
.b89d	aa		tax				tax
.b89e	c8		iny				iny 								; point at first character
.b89f					_LCOutData:
.b89f	b1 30		lda ($30),y			lda 	(codePtr),y
.b8a1	c9 00		cmp #$00			cmp 	#0
.b8a3	f0 03		beq $b8a8			beq 	_LCNoPrint
.b8a5	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b8a8					_LCNoPrint:
.b8a8	c8		iny				iny
.b8a9	ca		dex				dex
.b8aa	d0 f3		bne $b89f			bne 	_LCOutData
.b8ac	68		pla				pla 								; closing " required ?
.b8ad	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b8af	d0 0f		bne $b8c0			bne 	_LCNoQuote
.b8b1	a9 22		lda #$22			lda 	#'"'
.b8b3	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b8b6	ad c2 05	lda $05c2			lda 	EXTTextColour
.b8b9	29 0f		and #$0f			and 	#$0F
.b8bb	09 90		ora #$90			ora 	#$90
.b8bd	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b8c0					_LCNoQuote:
.b8c0	4c 7b b7	jmp $b77b			jmp 	_LCMainLoop
.b8c3					LCLWriteColour:
.b8c3	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b8c6	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b8c9	d0 01		bne $b8cc			bne 	LCLWrite 					; if different, output it
.b8cb	60		rts				rts
.b8cc					LCLWrite:
.b8cc	da		phx				phx
.b8cd	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b8d0	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b8d3	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.b8d6	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.b8d9	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b8db	30 03		bmi $b8e0			bmi 	_LCLNoColour
.b8dd	8d 27 04	sta $0427			sta 	LCLastCharacter
.b8e0					_LCLNoColour:
.b8e0	fa		plx				plx
.b8e1	60		rts				rts
.b8e2					LCLDeleteLastSpace:
.b8e2	48		pha				pha
.b8e3	da		phx				phx
.b8e4	ae 1d 04	ldx $041d			ldx 	tbOffset
.b8e7	f0 0a		beq $b8f3			beq 	_LCDLSExit
.b8e9	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.b8ec	c9 20		cmp #$20			cmp 	#' '
.b8ee	d0 03		bne $b8f3			bne 	_LCDLSExit
.b8f0	ce 1d 04	dec $041d			dec 	tbOffset
.b8f3					_LCDLSExit:
.b8f3	fa		plx				plx
.b8f4	68		pla				pla
.b8f5	60		rts				rts
.b8f6					LCLCheckSpaceRequired:
.b8f6	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.b8f9	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b8fb	f0 1b		beq $b918			beq 	_LCCSRSpace
.b8fd	c9 29		cmp #$29			cmp 	#')'
.b8ff	f0 17		beq $b918			beq 	_LCCSRSpace
.b901	c9 23		cmp #$23			cmp 	#'#'
.b903	f0 13		beq $b918			beq 	_LCCSRSpace
.b905	20 1e b9	jsr $b91e			jsr 	LCLLowerCase 				; saves a little effort
.b908	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b90a	90 11		bcc $b91d			bcc 	_LCCSRExit
.b90c	c9 3a		cmp #$3a			cmp 	#"9"+1
.b90e	90 08		bcc $b918			bcc 	_LCCSRSpace
.b910	c9 61		cmp #$61			cmp 	#"a"
.b912	90 09		bcc $b91d			bcc 	_LCCSRExit
.b914	c9 7b		cmp #$7b			cmp 	#"z"+1
.b916	b0 05		bcs $b91d			bcs 	_LCCSRExit
.b918					_LCCSRSpace:
.b918	a9 20		lda #$20			lda 	#' '
.b91a	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b91d					_LCCSRExit:
.b91d	60		rts				rts
.b91e					LCLLowerCase:
.b91e	c9 41		cmp #$41			cmp 	#"A"
.b920	90 06		bcc $b928			bcc 	_LCLLCOut
.b922	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b924	b0 02		bcs $b928			bcs 	_LCLLCOut
.b926	69 20		adc #$20			adc 	#$20
.b928					_LCLLCOut:
.b928	60		rts				rts
.b929					LCLUpperCase:
.b929	c9 61		cmp #$61			cmp 	#"a"
.b92b	90 06		bcc $b933			bcc 	_LCLUCOut
.b92d	c9 7b		cmp #$7b			cmp 	#"z"+1
.b92f	b0 02		bcs $b933			bcs 	_LCLUCOut
.b931	e9 1f		sbc #$1f			sbc 	#$1F
.b933					_LCLUCOut:
.b933	60		rts				rts
.b934					LCLWriteNumberXA:
.b934	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.b936					_LCLWNLoop1:
.b936	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.b938					_LCLWNLoop2:
.b938	48		pha				pha 								; save initial LSB
.b939	38		sec				sec
.b93a	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.b93c	f9 6d b9	sbc $b96d,y			sbc 	_LCLWNTable,y
.b93f	48		pha				pha
.b940	8a		txa				txa
.b941	f9 6e b9	sbc $b96e,y			sbc 	_LCLWNTable+1,y
.b944	90 07		bcc $b94d			bcc 	_LCLWNUnderflow
.b946	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.b948	aa		tax				tax 								; update X
.b949	68		pla				pla 								; restore A
.b94a	7a		ply				ply 								; throw original
.b94b	80 eb		bra $b938			bra 	_LCLWNLoop2 				; try again.
.b94d					_LCLWNUnderflow:
.b94d	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.b94f	d0 06		bne $b957			bne 	_LCLWNOut
.b951	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.b954	3a		dec a				dec 	a
.b955	f0 04		beq $b95b			beq 	_LCLWNNext
.b957					_LCLWNOut:
.b957	98		tya				tya
.b958	20 67 b9	jsr $b967			jsr 	_LCLWNOutDigit
.b95b					_LCLWNNext:
.b95b	7a		ply				ply 							 	; restore original value.
.b95c	68		pla				pla
.b95d	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.b95f	c8		iny				iny
.b960	c8		iny				iny
.b961	84 37		sty $37				sty 	zTemp0+1
.b963	c0 08		cpy #$08			cpy 	#8 							; done all 4
.b965	d0 cf		bne $b936			bne 	_LCLWNLoop1
.b967					_LCLWNOutDigit:
.b967	09 30		ora #$30			ora 	#'0'
.b969	20 cc b8	jsr $b8cc			jsr 	LCLWrite
.b96c	60		rts				rts
.b96d					_LCLWNTable:
>b96d	10 27						.word 	10000
>b96f	e8 03						.word 	1000
>b971	64 00						.word 	100
>b973	0a 00						.word 	10
.b975					TOKSearchTable:
.b975	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b977	85 36		sta $36				sta 	zTemp0
.b979	a0 00		ldy #$00			ldy 	#0
.b97b	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b97d	85 38		sta $38				sta 	zTemp1
.b97f					_TSTLoop:
.b97f	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b981	30 49		bmi $b9cc			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b983	f0 2e		beq $b9b3			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b985	c8		iny				iny 								; get the hash
.b986	b1 36		lda ($36),y			lda 	(zTemp0),y
.b988	88		dey				dey
.b989	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b98c	d0 25		bne $b9b3			bne 	_TSTNext
.b98e	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.b991	38		sec				sec
.b992	ed 00 04	sbc $0400			sbc 	identStart
.b995	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b997	d0 1a		bne $b9b3			bne 	_TSTNext
.b999	5a		phy				phy 								; save Y , we might fail to match.
.b99a	c8		iny				iny 								; point to text
.b99b	c8		iny				iny
.b99c	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.b99f					_TSTCompareName:
.b99f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.b9a2	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b9a4	d0 0c		bne $b9b2			bne 	_TSTNextPullY 				; fail, pullY and do next
.b9a6	e8		inx				inx
.b9a7	c8		iny				iny
.b9a8	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.b9ab	d0 f2		bne $b99f			bne 	_TSTCompareName
.b9ad	7a		ply				ply 								; throw Y
.b9ae	a5 38		lda $38				lda 	zTemp1 						; get token #
.b9b0	38		sec				sec 								; return with CS = passed.
.b9b1	60		rts				rts
.b9b2					_TSTNextPullY:
.b9b2	7a		ply				ply 								; restore current, fall through.
.b9b3					_TSTNext:
.b9b3	e6 38		inc $38				inc 	zTemp1 						; token counter
.b9b5	98		tya				tya
.b9b6	18		clc				clc
.b9b7	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b9b9	1a		inc a				inc 	a 							; +1
.b9ba	1a		inc a				inc 	a 							; +2
.b9bb	a8		tay				tay
.b9bc	10 c1		bpl $b97f			bpl 	_TSTLoop 					; if Y < $80 loop back
.b9be	98		tya				tya 								; add Y to zTemp0 and reset Y
.b9bf	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b9c1	18		clc				clc  								; but have tables > 255 bytes
.b9c2	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b9c4	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b9c6	90 b7		bcc $b97f			bcc 	_TSTLoop
.b9c8	e6 37		inc $37				inc 	zTemp0+1
.b9ca	80 b3		bra $b97f			bra 	_TSTLoop
.b9cc					_TSTFail:
.b9cc	18		clc				clc
.b9cd	60		rts				rts
.b9ce					Export_TKTokeniseLine:
.b9ce	20 56 bb	jsr $bb56			jsr 	LCLFixLineBufferCase 		; fix line case
.b9d1	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b9d3	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b9d6	9c 2b 04	stz $042b			stz 	tokenLineNumber
.b9d9	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.b9dc	a2 ff		ldx #$ff			ldx 	#$FF
.b9de					_TKFindFirst:
.b9de	e8		inx				inx
.b9df	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b9e2	f0 79		beq $ba5d			beq 	_TKExit
.b9e4	c9 20		cmp #$20			cmp 	#' '
.b9e6	90 f6		bcc $b9de			bcc 	_TKFindFirst
.b9e8	c9 30		cmp #$30			cmp 	#'0'
.b9ea	90 07		bcc $b9f3			bcc 	_TKNoLineNumber
.b9ec	c9 3a		cmp #$3a			cmp 	#'9'+1
.b9ee	b0 03		bcs $b9f3			bcs 	_TKNoLineNumber
.b9f0	20 80 bb	jsr $bb80			jsr 	TOKExtractLineNumber
.b9f3					_TKNoLineNumber:
.b9f3					_TKTokeniseLoop:
.b9f3	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b9f6	f0 65		beq $ba5d			beq 	_TKExit
.b9f8	e8		inx				inx
.b9f9	c9 20		cmp #$20			cmp 	#' '
.b9fb	f0 f6		beq $b9f3			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b9fd	ca		dex				dex 								; undo last get, A contains character, X is position.
.b9fe	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.ba00	f0 61		beq $ba63			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.ba02	c9 41		cmp #$41			cmp 	#'A'
.ba04	90 04		bcc $ba0a			bcc 	_TKTokenisePunctuation
.ba06	c9 5b		cmp #$5b			cmp 	#'Z'+1
.ba08	90 59		bcc $ba63			bcc 	_TKTokeniseIdentifier
.ba0a					_TKTokenisePunctuation:
.ba0a	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.ba0c	f0 27		beq $ba35			beq 	_TKString
.ba0e	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.ba10	f0 28		beq $ba3a			beq 	_TKHexConstant
.ba12	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.ba14	f0 29		beq $ba3f			beq 	_TKCheckDouble
.ba16	c9 3e		cmp #$3e			cmp 	#'>'
.ba18	f0 25		beq $ba3f			beq 	_TKCheckDouble
.ba1a					_TKStandardPunctuation:
.ba1a	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.ba1d	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.ba1f	90 0e		bcc $ba2f			bcc 	_TKNoShift
.ba21	48		pha				pha 								; save. we are about to convert this punctuation token from
.ba22	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.ba24	85 36		sta $36				sta 	zTemp0
.ba26	68		pla				pla
.ba27	29 20		and #$20			and 	#32 						; bit 5
.ba29	4a		lsr a				lsr 	a 							; shift into bit 3
.ba2a	4a		lsr a				lsr 	a
.ba2b	05 36		ora $36				ora 	zTemp0
.ba2d	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.ba2f					_TKNoShift:
.ba2f	20 c5 bb	jsr $bbc5			jsr 	TOKWriteByte 				; write the punctuation character
.ba32	e8		inx				inx 								; consume the character
.ba33	80 be		bra $b9f3			bra 	_TKTokeniseLoop 			; and loop round again.
.ba35					_TKString:
.ba35	20 e5 ba	jsr $bae5			jsr 	TOKTokenString
.ba38	80 b9		bra $b9f3			bra 	_TKTokeniseLoop
.ba3a					_TKHexConstant:
.ba3a	20 20 bb	jsr $bb20			jsr 	TOKHexConstant
.ba3d	80 b4		bra $b9f3			bra 	_TKTokeniseLoop
.ba3f					_TKCheckDouble:
.ba3f	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.ba42	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.ba44	90 d4		bcc $ba1a			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.ba46	c9 3f		cmp #$3f			cmp 	#'>'+1
.ba48	b0 d0		bcs $ba1a			bcs 	_TKStandardPunctuation
.ba4a	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.ba4d	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.ba4f	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.ba50	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.ba53	38		sec				sec
.ba54	e9 3c		sbc #$3c			sbc 	#'<'
.ba56	20 c5 bb	jsr $bbc5			jsr 	TOKWriteByte 				; this is in the range 0-7
.ba59	e8		inx				inx 								; consume both
.ba5a	e8		inx				inx
.ba5b	80 96		bra $b9f3			bra 	_TKTokeniseLoop
.ba5d	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.ba5f	20 c5 bb	jsr $bbc5			jsr 	TOKWriteByte
.ba62	60		rts				rts
.ba63					_TKTokeniseIdentifier:
.ba63	8e 00 04	stx $0400			stx 	identStart 					; save start
.ba66	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.ba69					_TKCheckLoop:
.ba69	e8		inx				inx 								; look at next, we know first is identifier already.
.ba6a	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.ba6d	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.ba6f	f0 f8		beq $ba69			beq 	_TKCheckLoop
.ba71	c9 30		cmp #$30			cmp	 	#"0"
.ba73	90 0c		bcc $ba81			bcc 	_TKEndIdentifier
.ba75	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba77	90 f0		bcc $ba69			bcc 	_TKCheckLoop
.ba79	c9 41		cmp #$41			cmp	 	#"A"
.ba7b	90 04		bcc $ba81			bcc 	_TKEndIdentifier
.ba7d	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba7f	90 e8		bcc $ba69			bcc 	_TKCheckLoop
.ba81					_TKEndIdentifier:
.ba81	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.ba84	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.ba86	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.ba88	f0 06		beq $ba90			beq 	_TKHasTypeCharacter
.ba8a	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.ba8c	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.ba8e	d0 07		bne $ba97			bne 	_TKNoTypeCharacter
.ba90					_TKHasTypeCharacter:
.ba90	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.ba93	e8		inx				inx 								; consume the type character
.ba94	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.ba97					_TKNoTypeCharacter:
.ba97	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.ba99	d0 09		bne $baa4			bne 	_TKNoArray
.ba9b	e8		inx				inx 								; skip the (
.ba9c	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.ba9f	09 04		ora #$04			ora 	#$04
.baa1	8d 04 04	sta $0404			sta 	identTypeByte
.baa4					_TKNoArray:
.baa4	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.baa7	20 41 bb	jsr $bb41			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.baaa	a0 b3		ldy #$b3			ldy 	#(KeywordSet0) >> 8
.baac	a9 94		lda #$94			lda 	#(KeywordSet0) & $FF
.baae	20 75 b9	jsr $b975			jsr 	TOKSearchTable
.bab1	a2 00		ldx #$00			ldx 	#0
.bab3	b0 1f		bcs $bad4			bcs 	_TKFoundToken
.bab5	a0 b5		ldy #$b5			ldy 	#(KeywordSet1) >> 8
.bab7	a9 91		lda #$91			lda 	#(KeywordSet1) & $FF
.bab9	20 75 b9	jsr $b975			jsr 	TOKSearchTable
.babc	a2 81		ldx #$81			ldx 	#$81
.babe	b0 14		bcs $bad4			bcs 	_TKFoundToken
.bac0	a0 b5		ldy #$b5			ldy 	#(KeywordSet2) >> 8
.bac2	a9 ee		lda #$ee			lda 	#(KeywordSet2) & $FF
.bac4	20 75 b9	jsr $b975			jsr 	TOKSearchTable
.bac7	a2 82		ldx #$82			ldx 	#$82
.bac9	b0 09		bcs $bad4			bcs 	_TKFoundToken
.bacb	20 d1 bb	jsr $bbd1			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bace	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bad1	4c f3 b9	jmp $b9f3			jmp 	_TKTokeniseLoop 			; and go round again.
.bad4					_TKFoundToken:
.bad4	48		pha				pha 								; save token
.bad5	8a		txa				txa 								; shift in X, is there one ?
.bad6	f0 03		beq $badb			beq 	_TKNoTShift
.bad8	20 c5 bb	jsr $bbc5			jsr 	TOKWriteByte 				; if so, write it out
.badb					_TKNoTShift:
.badb	68		pla				pla 								; restore and write token
.badc	20 c5 bb	jsr $bbc5			jsr 	TOKWriteByte
.badf	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bae2	4c f3 b9	jmp $b9f3			jmp 	_TKTokeniseLoop 			; and go round again.
.bae5					TOKTokenString:
.bae5	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bae7	20 c5 bb	jsr $bbc5			jsr 	TOKWriteByte
.baea	e8		inx				inx									; start of quoted string.
.baeb	da		phx				phx 								; push start of string on top
.baec	ca		dex				dex 								; because we pre-increment
.baed					_TSFindEnd:
.baed	e8		inx				inx
.baee	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.baf1	f0 04		beq $baf7			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.baf3	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.baf5	d0 f6		bne $baed			bne 	_TSFindEnd
.baf7					_TSEndOfString:
.baf7	7a		ply				ply  								; so now Y is first character, X is character after end.
.baf8	48		pha				pha 								; save terminating character
.baf9	20 01 bb	jsr $bb01			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bafc	68		pla				pla 								; terminating character
.bafd	f0 01		beq $bb00			beq 	_TSNotQuote					; if it wasn't EOS skip it
.baff	e8		inx				inx
.bb00					_TSNotQuote:
.bb00	60		rts				rts
.bb01					TOKWriteBlockXY:
.bb01	86 36		stx $36				stx 	zTemp0 						; save end character
.bb03	98		tya				tya 								; use 2's complement to work out the byte size
.bb04	49 ff		eor #$ff			eor 	#$FF
.bb06	38		sec				sec
.bb07	65 36		adc $36				adc 	zTemp0
.bb09	1a		inc a				inc 	a 							; one extra for NULL
.bb0a	20 c5 bb	jsr $bbc5			jsr 	TOKWriteByte
.bb0d					_TOBlockLoop:
.bb0d	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bb0f	f0 09		beq $bb1a			beq 	_TOBlockExit
.bb11	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bb14	20 c5 bb	jsr $bbc5			jsr 	TOKWriteByte
.bb17	c8		iny				iny
.bb18	80 f3		bra $bb0d			bra 	_TOBlockLoop
.bb1a					_TOBlockExit:
.bb1a	a9 00		lda #$00			lda 	#0 							; add NULL.
.bb1c	20 c5 bb	jsr $bbc5			jsr 	TOKWriteByte
.bb1f	60		rts				rts
.bb20					TOKHexConstant:
.bb20	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bb22	20 c5 bb	jsr $bbc5			jsr 	TOKWriteByte
.bb25	e8		inx				inx									; start of quoted string.
.bb26	da		phx				phx 								; push start of constant on top
.bb27	ca		dex				dex
.bb28					_THFindLoop:
.bb28	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bb29	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bb2c	c9 30		cmp #$30			cmp 	#"0"
.bb2e	90 0c		bcc $bb3c			bcc 	_THFoundEnd
.bb30	c9 3a		cmp #$3a			cmp 	#"9"+1
.bb32	90 f4		bcc $bb28			bcc 	_THFindLoop
.bb34	c9 41		cmp #$41			cmp 	#"A"
.bb36	90 04		bcc $bb3c			bcc 	_THFoundEnd
.bb38	c9 47		cmp #$47			cmp 	#"F"+1
.bb3a	90 ec		bcc $bb28			bcc 	_THFindLoop
.bb3c					_THFoundEnd:
.bb3c	7a		ply				ply 								; restore start
.bb3d	20 01 bb	jsr $bb01			jsr 	TOKWriteBlockXY 			; output the block
.bb40	60		rts				rts
.bb41					TOKCalculateHash:
.bb41	da		phx				phx
.bb42	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bb45	a9 00		lda #$00			lda 	#0
.bb47					_TCHLoop:
.bb47	18		clc				clc
.bb48	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bb4b	e8		inx				inx
.bb4c	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bb4f	d0 f6		bne $bb47			bne 	_TCHLoop
.bb51	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bb54	fa		plx				plx
.bb55	60		rts				rts
.bb56					LCLFixLineBufferCase:
.bb56	a2 00		ldx #$00			ldx 	#0
.bb58					_FLBCLoop:
.bb58	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bb5b	f0 22		beq $bb7f			beq 	_FLBCExit 					; end of string.
.bb5d	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bb5f	f0 11		beq $bb72			beq 	_FLBCInQuotes
.bb61	e8		inx				inx
.bb62	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bb64	90 f2		bcc $bb58			bcc 	_FLBCLoop
.bb66	c9 7b		cmp #$7b			cmp 	#'z'+1
.bb68	b0 ee		bcs $bb58			bcs 	_FLBCLoop
.bb6a	38		sec				sec 								; make U/C
.bb6b	e9 20		sbc #$20			sbc 	#32
.bb6d	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bb70	80 e6		bra $bb58			bra 	_FLBCLoop
.bb72					_FLBCInQuotes:
.bb72	e8		inx				inx 								; advance
.bb73	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bb76	f0 07		beq $bb7f			beq 	_FLBCExit 					; exit on EOS
.bb78	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bb7a	d0 f6		bne $bb72			bne 	_FLBCInQuotes
.bb7c	e8		inx				inx 								; skip over it
.bb7d	80 d9		bra $bb58			bra 	_FLBCLoop
.bb7f					_FLBCExit:
.bb7f	60		rts				rts
.bb80					TOKExtractLineNumber:
.bb80	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bb83	48		pha				pha
.bb84	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bb87	48		pha				pha
.bb88	20 be bb	jsr $bbbe			jsr 	_LCLNTimes2 				; line # x 2
.bb8b	20 be bb	jsr $bbbe			jsr 	_LCLNTimes2 				; line # x 4
.bb8e	18		clc				clc 								; add stacked value
.bb8f	68		pla				pla
.bb90	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bb93	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bb96	68		pla				pla
.bb97	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bb9a	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bb9d	20 be bb	jsr $bbbe			jsr 	_LCLNTimes2 				; line # x 10
.bba0	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bba3	e8		inx				inx
.bba4	29 0f		and #$0f			and 	#15 						; add to line #
.bba6	18		clc				clc
.bba7	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bbaa	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bbad	90 03		bcc $bbb2			bcc 	_TLENNoCarry
.bbaf	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bbb2					_TLENNoCarry:
.bbb2	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bbb5	c9 30		cmp #$30			cmp 	#'0'
.bbb7	90 04		bcc $bbbd			bcc 	_TLENExit
.bbb9	c9 3a		cmp #$3a			cmp 	#'9'+1
.bbbb	90 c3		bcc $bb80			bcc 	TOKExtractLineNumber
.bbbd					_TLENExit:
.bbbd	60		rts				rts
.bbbe					_LCLNTimes2:
.bbbe	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bbc1	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bbc4	60		rts				rts
.bbc5					TOKWriteByte:
.bbc5	da		phx				phx
.bbc6	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bbc9	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bbcc	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bbcf	fa		plx				plx
.bbd0	60		rts				rts
.bbd1					TOKCheckCreateVariableRecord:
.bbd1	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bbd3	85 36		sta $36				sta 	0+zTemp0
.bbd5	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bbd7	85 37		sta $37				sta 	1+zTemp0
.bbd9					_CCVSearch:
.bbd9	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bbdb	f0 2c		beq $bc09			beq 	_CCVFail
.bbdd	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bbdf	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bbe1	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bbe4	d0 16		bne $bbfc			bne 	_CCVNext
.bbe6	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bbe8	ae 00 04	ldx $0400			ldx 	identStart
.bbeb					_CCVCompare:
.bbeb	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bbee	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bbf0	e8		inx				inx 								; advance pointers
.bbf1	c8		iny				iny
.bbf2	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bbf3	d0 07		bne $bbfc			bne 	_CCVNext  					; didn't match go to next.
.bbf5	90 f4		bcc $bbeb			bcc 	_CCVCompare 				; not finished yet.
.bbf7	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bbfa	f0 41		beq $bc3d			beq 	_CCVFound 					; yes, we were successful
.bbfc					_CCVNext:
.bbfc	18		clc				clc 								; go to next record.
.bbfd	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bbff	65 36		adc $36				adc 	zTemp0
.bc01	85 36		sta $36				sta 	zTemp0
.bc03	90 d4		bcc $bbd9			bcc 	_CCVSearch
.bc05	e6 37		inc $37				inc 	zTemp0+1
.bc07	80 d0		bra $bbd9			bra 	_CCVSearch
.bc09					_CCVFail:
.bc09	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bc0b	ad 03 04	lda $0403			lda 	identHash
.bc0e	91 36		sta ($36),y			sta 	(zTemp0),y
.bc10	c8		iny				iny 								; offset 2 is the type byte
.bc11	ad 04 04	lda $0404			lda 	identTypeByte
.bc14	91 36		sta ($36),y			sta 	(zTemp0),y
.bc16	c8		iny				iny
.bc17					_CCVData:
.bc17	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bc19	91 36		sta ($36),y			sta 	(zTemp0),y
.bc1b	c8		iny				iny
.bc1c	c0 08		cpy #$08			cpy 	#8
.bc1e	90 f7		bcc $bc17			bcc 	_CCVData
.bc20	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bc23					_CCVCopyName:
.bc23	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bc26	91 36		sta ($36),y			sta 	(zTemp0),y
.bc28	e8		inx				inx
.bc29	c8		iny				iny
.bc2a	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bc2d	d0 f4		bne $bc23			bne 	_CCVCopyName
.bc2f	98		tya				tya 								; patch offset
.bc30	92 36		sta ($36)			sta 	(zTemp0)
.bc32	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bc34	91 36		sta ($36),y			sta 	(zTemp0),y
.bc36	88		dey				dey
.bc37	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bc39	09 80		ora #$80			ora 	#$80
.bc3b	91 36		sta ($36),y			sta 	(zTemp0),y
.bc3d					_CCVFound:
.bc3d	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bc3f	38		sec				sec
.bc40	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bc42	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bc44	20 c5 bb	jsr $bbc5			jsr 	TOKWriteByte
.bc47	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bc49	20 c5 bb	jsr $bbc5			jsr 	TOKWriteByte
.bc4c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bc4d					SNDCheckChannel:
.bc4d	aa		tax				tax
.bc4e	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bc51	d0 38		bne $bc8b			bne 	_SNDCCExit
.bc53	da		phx				phx 								; save current channel
.bc54	8a		txa				txa 								; put in A
.bc55	20 d1 bc	jsr $bcd1			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bc58	68		pla				pla 								; channel # in A
.bc59	90 30		bcc $bc8b			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bc5b	a8		tay				tay 								; Y is the channel #
.bc5c	bd 80 06	lda $0680,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bc5f	99 7f 07	sta $077f,y			sta 	SNDPitchLow,y
.bc62	bd 81 06	lda $0681,x			lda 	SNDQueue+2,x
.bc65	99 83 07	sta $0783,y			sta 	SNDPitchHigh,y
.bc68	bd 82 06	lda $0682,x			lda 	SNDQueue+3,x
.bc6b	99 87 07	sta $0787,y			sta 	SNDVolume,y
.bc6e	bd 83 06	lda $0683,x			lda 	SNDQueue+4,x
.bc71	99 8b 07	sta $078b,y			sta 	SNDTimeLeft,y
.bc74	bd 84 06	lda $0684,x			lda 	SNDQueue+5,x
.bc77	99 8f 07	sta $078f,y			sta 	SNDAdjustLow,y
.bc7a	bd 85 06	lda $0685,x			lda 	SNDQueue+6,x
.bc7d	99 93 07	sta $0793,y			sta 	SNDAdjustHigh,y
.bc80	5a		phy				phy 								; save channel #
.bc81	20 eb bc	jsr $bceb			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bc84	ce 7e 06	dec $067e			dec 	SNDLength 					; reduce the queue length.
.bc87	68		pla				pla
.bc88	20 8c bc	jsr $bc8c			jsr 	SNDUpdateNote 				; update channel A
.bc8b					_SNDCCExit:
.bc8b	60		rts				rts
.bc8c					SNDUpdateNote:
.bc8c	aa		tax				tax 								; so we can access records
.bc8d	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bc8e	0a		asl a				asl 	a
.bc8f	0a		asl a				asl 	a
.bc90	0a		asl a				asl 	a
.bc91	0a		asl a				asl 	a
.bc92	8d 7d 06	sta $067d			sta 	SNDChannelBits
.bc95	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; are we silent
.bc98	f0 2e		beq $bcc8			beq 	_SNDUNIsSilent
.bc9a	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; push channel bits on stack
.bc9d	48		pha				pha
.bc9e	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bca1	29 0f		and #$0f			and 	#$0F
.bca3	0d 7d 06	ora $067d			ora 	SNDChannelBits 				; set channel bits
.bca6	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bca8	20 35 bd	jsr $bd35			jsr 	SNDWritePorts
.bcab	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bcae	8d 7d 06	sta $067d			sta 	SNDChannelBits
.bcb1	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.bcb4	4e 7d 06	lsr $067d			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bcb7	6a		ror a				ror 	a
.bcb8	4e 7d 06	lsr $067d			lsr 	SNDChannelBits
.bcbb	6a		ror a				ror 	a
.bcbc	4a		lsr a				lsr 	a 							; put in bits 0-5
.bcbd	4a		lsr a				lsr 	a
.bcbe	20 35 bd	jsr $bd35			jsr 	SNDWritePorts 				; write as rest of pitch register
.bcc1	68		pla				pla
.bcc2	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.bcc4	20 35 bd	jsr $bd35			jsr 	SNDWritePorts
.bcc7	60		rts				rts
.bcc8					_SNDUNIsSilent:
.bcc8	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; channel bits
.bccb	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.bccd	20 35 bd	jsr $bd35			jsr 	SNDWritePorts 				; write to the ports
.bcd0	60		rts				rts
.bcd1					SNDFindNextNoteForA:
.bcd1	ac 7e 06	ldy $067e			ldy 	SNDLength 					; queue size into Y
.bcd4	f0 13		beq $bce9			beq 	_SNDFNNFail 				; queue empty.
.bcd6	a2 00		ldx #$00			ldx 	#0
.bcd8					_SNDFNNSearch:
.bcd8	dd 7f 06	cmp $067f,x			cmp 	SNDQueue,x 					; does it match the channel
.bcdb	38		sec				sec
.bcdc	f0 0c		beq $bcea			beq 	_SNDFNNExit 				; if so exit with CS.
.bcde	e8		inx				inx 								; next queue slot.
.bcdf	e8		inx				inx
.bce0	e8		inx				inx
.bce1	e8		inx				inx
.bce2	e8		inx				inx
.bce3	e8		inx				inx
.bce4	e8		inx				inx
.bce5	e8		inx				inx
.bce6	88		dey				dey 								; done the whole queue
.bce7	d0 ef		bne $bcd8			bne 	_SNDFNNSearch 				; no, go back.
.bce9					_SNDFNNFail:
.bce9	18		clc				clc
.bcea					_SNDFNNexit:
.bcea	60		rts				rts
.bceb					SNDDeleteXFromQueue:
.bceb	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.bced	f0 09		beq $bcf8			beq 	_SNDDXExit
.bcef	bd 87 06	lda $0687,x			lda 	SNDQueue+8,x
.bcf2	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.bcf5	e8		inx				inx
.bcf6	80 f3		bra $bceb			bra 	SNDDeleteXFromQueue
.bcf8					_SNDDXExit:
.bcf8	60		rts				rts
.067d					SNDChannelBits:
>067d							.fill 	1
.bcf9					SNDQueueRequest:
.bcf9	86 36		stx $36				stx 	zTemp0						; save queue address
.bcfb	84 37		sty $37				sty 	zTemp0+1
.bcfd	ae 7e 06	ldx $067e			ldx 	SNDLength 					; queue is full, can't take any more.
.bd00	e0 20		cpx #$20			cpx 	#SNDQueueSize
.bd02	f0 21		beq $bd25			beq 	_SNDQRExit
.bd04	29 03		and #$03			and 	#3	 						; channel # and push on stack
.bd06	48		pha				pha
.bd07	8a		txa				txa  								; get offset in queue buffer/
.bd08	0a		asl a				asl 	a
.bd09	0a		asl a				asl 	a
.bd0a	0a		asl a				asl 	a
.bd0b	aa		tax				tax
.bd0c	68		pla				pla 								; get back and push again
.bd0d	48		pha				pha
.bd0e	9d 7f 06	sta $067f,x			sta 	SNDQueue+0,x 				; save the channel #
.bd11	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.bd13					_SNDQCopy:
.bd13	b1 36		lda ($36),y			lda 	(zTemp0),y
.bd15	e8		inx				inx
.bd16	c8		iny				iny
.bd17	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.bd1a	c0 06		cpy #$06			cpy 	#6
.bd1c	d0 f5		bne $bd13			bne 	_SNDQCopy
.bd1e	ee 7e 06	inc $067e			inc 	SNDLength 					; bump queue length.
.bd21	68		pla				pla 								; get channel # back
.bd22	20 4d bc	jsr $bc4d			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.bd25					_SNDQRExit:
.bd25	60		rts				rts
.bd26					SNDSilenceChannel:
.bd26	aa		tax				tax 								; zero time left.
.bd27	9e 8b 07	stz $078b,x			stz 	SNDTimeLeft,x
.bd2a	0a		asl a				asl 	a 							; shift into position
.bd2b	0a		asl a				asl 	a
.bd2c	0a		asl a				asl 	a
.bd2d	0a		asl a				asl 	a
.bd2e	0a		asl a				asl 	a
.bd2f	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.bd31	20 35 bd	jsr $bd35			jsr 	SNDWritePorts
.bd34	60		rts				rts
.bd35					SNDWritePorts:
.bd35	da		phx				phx 								; save X
.bd36	a6 01		ldx $01				ldx 	1 							; save I/O status
.bd38	64 01		stz $01				stz 	1 							; access I/O page 0
.bd3a	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.bd3d	8d 10 d6	sta $d610			sta 	$D610
.bd40	86 01		stx $01				stx 	1 							; restore I/O
.bd42	fa		plx				plx 								; restore X
.bd43	60		rts				rts
.bd44					Export_SNDCommand:
.bd44	da		phx				phx 								; save XY
.bd45	5a		phy				phy
.bd46	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.bd48	f0 1d		beq $bd67			beq 	_SNDInitialise
.bd4a	90 28		bcc $bd74			bcc 	_SNDExit
.bd4c	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.bd4e	f0 17		beq $bd67			beq 	_SNDSilence
.bd50	b0 22		bcs $bd74			bcs 	_SNDExit
.bd52	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.bd54	b0 09		bcs $bd5f			bcs 	_SNDQueryPlay
.bd56	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.bd58	b0 1a		bcs $bd74			bcs 	_SNDExit
.bd5a	20 f9 bc	jsr $bcf9			jsr 	SNDQueueRequest
.bd5d	80 15		bra $bd74			bra 	_SNDExit
.bd5f					_SNDQueryPlay:
.bd5f	29 03		and #$03			and 	#3 							; get channel #
.bd61	aa		tax				tax
.bd62	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.bd65	80 0d		bra $bd74			bra 	_SNDExit
.bd67					_SNDInitialise:
.bd67					_SNDSilence:
.bd67	9c 7e 06	stz $067e			stz 	SNDLength 					; empty the queue.
.bd6a	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.bd6c					_SNDSilenceLoop:
.bd6c	48		pha				pha
.bd6d	20 26 bd	jsr $bd26			jsr 	SNDSilenceChannel
.bd70	68		pla				pla
.bd71	3a		dec a				dec 	a
.bd72	10 f8		bpl $bd6c			bpl 	_SNDSilenceLoop
.bd74					_SNDExit:
.bd74	7a		ply				ply
.bd75	fa		plx				plx
.bd76	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.067e					SNDLength:
>067e							.fill 	1
.067f					SNDQueue:
>067f							.fill 	SNDQueueSize * 8
.077f					SNDPitchLow:
>077f							.fill 	4
.0783					SNDPitchHigh:
>0783							.fill 	4
.0787					SNDVolume:
>0787							.fill 	4
.078b					SNDTimeLeft:
>078b							.fill 	4
.078f					SNDAdjustLow:
>078f							.fill 	4
.0793					SNDAdjustHigh:
>0793							.fill 	4
.bd77					Export_SNDUpdate:
.bd77					PagedSNDUpdate:
.bd77	ad 8b 07	lda $078b			lda 	SNDTimeLeft+0 				; look at time remaining
.bd7a	f0 05		beq $bd81			beq 	_SNDUNot0 					; not playing
.bd7c	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.bd7e	20 a0 bd	jsr $bda0			jsr 	SNDUpdateChannel 			; update it.
.bd81					_SNDUNot0:
.bd81	ad 8c 07	lda $078c			lda 	SNDTimeLeft+1
.bd84	f0 05		beq $bd8b			beq 	_SNDUNot1
.bd86	a2 01		ldx #$01			ldx 	#1
.bd88	20 a0 bd	jsr $bda0			jsr 	SNDUpdateChannel
.bd8b					_SNDUNot1:
.bd8b	ad 8d 07	lda $078d			lda 	SNDTimeLeft+2
.bd8e	f0 05		beq $bd95			beq 	_SNDUNot2
.bd90	a2 02		ldx #$02			ldx 	#2
.bd92	20 a0 bd	jsr $bda0			jsr 	SNDUpdateChannel
.bd95					_SNDUNot2:
.bd95	ad 8e 07	lda $078e			lda 	SNDTimeLeft+3
.bd98	f0 05		beq $bd9f			beq 	_SNDUNot3
.bd9a	a2 03		ldx #$03			ldx 	#3
.bd9c	20 a0 bd	jsr $bda0			jsr 	SNDUpdateChannel
.bd9f					_SNDUNot3:
.bd9f	60		rts				rts
.bda0					SNDUpdateChannel:
.bda0	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.bda2	f0 2c		beq $bdd0			beq 	_SNDUCExit
.bda4	3a		dec a				dec 	a 							; decrement and update timer
.bda5	9d 8b 07	sta $078b,x			sta 	SNDTimeLeft,x
.bda8	f0 1d		beq $bdc7			beq 	_SNDUCUpdate 				; if zero, silence channel
.bdaa	bd 8f 07	lda $078f,x			lda 	SNDAdjustLow,x 				; adjust ?
.bdad	1d 93 07	ora $0793,x			ora 	SNDAdjustHigh,x
.bdb0	f0 1e		beq $bdd0			beq 	_SNDUCExit 					; if zero carry on at current tone.
.bdb2	18		clc				clc 								; add adjust, forcing into a 10 bit range
.bdb3	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.bdb6	7d 8f 07	adc $078f,x			adc 	SNDAdjustLow,x
.bdb9	9d 7f 07	sta $077f,x			sta 	SNDPitchLow,x
.bdbc	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x
.bdbf	7d 93 07	adc $0793,x			adc 	SNDAdjustHigh,x
.bdc2	29 03		and #$03			and 	#3
.bdc4	9d 83 07	sta $0783,x			sta 	SNDPitchHigh,x
.bdc7					_SNDUCUpdate:
.bdc7	8a		txa				txa 								; which channel.
.bdc8	48		pha				pha
.bdc9	20 8c bc	jsr $bc8c			jsr 	SNDUpdateNote 				; update the current note
.bdcc	68		pla				pla
.bdcd	20 4d bc	jsr $bc4d			jsr 	SNDCheckChannel 			; more to do ?
.bdd0					_SNDUCExit:
.bdd0	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
