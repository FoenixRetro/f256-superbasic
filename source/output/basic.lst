
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Mon Nov 21 15:39:28 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					tokenOffset:
>04a8							.fill 	1
.04a9					tokenLineNumber:
>04a9							.fill 	2
.04ab					tokenBuffer:
>04ab							.fill 	253
.05a8					lineBuffer:
>05a8							.fill 	MaxLineSize+1
.05f9					numberBuffer:
>05f9							.fill 	34
.061b					decimalBuffer:
>061b							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_LET                              = $bc; $bc LET
=$bd					KWD_LINE                             = $bd; $bd LINE
=$be					KWD_LOCAL                            = $be; $be LOCAL
=$bf					KWD_OFF                              = $bf; $bf OFF
=$c0					KWD_ON                               = $c0; $c0 ON
=$c1					KWD_OUTLINE                          = $c1; $c1 OUTLINE
=$c2					KWD_PALETTE                          = $c2; $c2 PALETTE
=$c3					KWD_PLOT                             = $c3; $c3 PLOT
=$c4					KWD_PRINT                            = $c4; $c4 PRINT
=$c5					KWD_READ                             = $c5; $c5 READ
=$c6					KWD_RECT                             = $c6; $c6 RECT
=$c7					KWD_REM                              = $c7; $c7 REM
=$c8					KWD_RETURN                           = $c8; $c8 RETURN
=$c9					KWD_SOLID                            = $c9; $c9 SOLID
=$ca					KWD_SOUND                            = $ca; $ca SOUND
=$cb					KWD_SPRITE                           = $cb; $cb SPRITE
=$cc					KWD_TEXT                             = $cc; $cc TEXT
=$cd					KWD_TO                               = $cd; $cd TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 39 aa	jsr $aa39			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 c2 8d	jsr $8dc2			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 3f b9	jsr $b93f			jsr 	SNDCommand
.8019	20 53 88	jsr $8853			jsr 	NewProgram 					; erase current program
.801c	20 e3 82	jsr $82e3			jsr 	BackloadProgram
.801f	4c ff 89	jmp $89ff			jmp 	CommandRun
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 4d 6f			.text "Built Monday 21-Nov-2022. Build 3456."
>804b	6e 64 61 79 20 32 31 2d 4e 6f 76 2d 32 30 32 32
>805b	2e 20 42 75 69 6c 64 20 33 34 35 36 2e

;******  Return to file: ./common/aa.system/00start.asm

>8068	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806b					AssembleGroup1:
.806b	a9 ff		lda #$ff			lda 	#$FF
.806d	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8070	80 02		bra $8074			bra 	AsmGroup12
.8072					AssembleGroup2:
.8072	a9 00		lda #$00			lda 	#$00
.8074					AsmGroup12:
.8074	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.8077	68		pla				pla 								; pop the return address to access the information following.
.8078	fa		plx				plx
.8079	20 02 81	jsr $8102			jsr 	AccessParameters 			; get opcode and save as base
.807c	8d a4 04	sta $04a4			sta 	BaseOpcode
.807f	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8082	d0 08		bne $808c			bne 	_AG12HaveMask
.8084	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8086	20 0a 81	jsr $810a			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8089	8d a5 04	sta $04a5			sta 	ModeMask
.808c					_AG12HaveMask:
.808c	20 45 82	jsr $8245			jsr 	TypeAndCalculateOperand 	; get zero page type
.808f	da		phx				phx 								; save found address mode
.8090	20 6e 81	jsr $816e			jsr 	AssembleModeX
.8093	fa		plx				plx  								; restore address mode
.8094	b0 0b		bcs $80a1			bcs 	_AG12Exit
.8096	20 a2 80	jsr $80a2			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8099	20 6e 81	jsr $816e			jsr 	AssembleModeX
.809c	b0 03		bcs $80a1			bcs 	_AG12Exit
.809e	4c b6 9f	jmp $9fb6			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a1					_AG12Exit:
.80a1	60		rts				rts
.80a2					PromoteToAbsolute:
.80a2	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a4	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a6	f0 19		beq $80c1			beq 	_PTADo
.80a8	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80aa	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80ac	f0 13		beq $80c1			beq 	_PTADo
.80ae	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b0	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b2	f0 0d		beq $80c1			beq 	_PTADo
.80b4	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b6	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b8	f0 07		beq $80c1			beq 	_PTADo
.80ba	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bc	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80be	f0 01		beq $80c1			beq 	_PTADo
.80c0	60		rts				rts
.80c1					_PTADo:
.80c1	aa		tax				tax
.80c2	60		rts				rts
.80c3					AssembleGroup3:
.80c3	68		pla				pla 								; get parameters, which is just the opcode.
.80c4	fa		plx				plx
.80c5	20 02 81	jsr $8102			jsr 	AccessParameters 			; get and output opcode
.80c8	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.80cb	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get a 16 bit operand
.80ce	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d1	38		sec				sec
.80d2	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d5	48		pha				pha 								; LSB in A
.80d6	ad 10 04	lda $0410			lda 	NSMantissa1
.80d9	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80dc	aa		tax				tax 								; MSB in X
.80dd	68		pla				pla
.80de	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80df	69 7f		adc #$7f			adc 	#$7F
.80e1	90 01		bcc $80e4			bcc 	_AG3NoCarry
.80e3	e8		inx				inx
.80e4					_AG3NoCarry:
.80e4	38		sec				sec 								; fix back and write out anyways.
.80e5	e9 80		sbc #$80			sbc 	#$80
.80e7	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.80ea	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ec	f0 0a		beq $80f8			beq 	_AG3Exit
.80ee	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f1	29 01		and #$01			and 	#1
.80f3	f0 03		beq $80f8			beq 	_AG3Exit
.80f5	4c bb 9f	jmp $9fbb			jmp 	RangeError 					; no, branch is out of range
.80f8					_AG3Exit:
.80f8	60		rts				rts
.80f9					AssembleGroup4:
.80f9	68		pla				pla 								; pop address
.80fa	fa		plx				plx
.80fb	20 02 81	jsr $8102			jsr 	AccessParameters 			; access and get first
.80fe	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte 			; output it.
.8101	60		rts				rts
.8102					AccessParameters:
.8102	8d a1 04	sta $04a1			sta 	ParamStart
.8105	8e a2 04	stx $04a2			stx 	ParamStart+1
.8108	a9 01		lda #$01			lda 	#1
.810a					GetParameter:
.810a	5a		phy				phy
.810b	a8		tay				tay
.810c	ad a1 04	lda $04a1			lda 	ParamStart
.810f	85 36		sta $36				sta 	zTemp0
.8111	ad a2 04	lda $04a2			lda 	ParamStart+1
.8114	85 37		sta $37				sta 	zTemp0+1
.8116	b1 36		lda ($36),y			lda 	(zTemp0),y
.8118	7a		ply				ply
.8119	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811a					AssemblerWriteByte:
.811a	48		pha			pha
.811b	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.811e	29 02		and #$02		and 	#2
.8120	f0 1b		beq $813d		beq 	_AWBNoPrint
.8122	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8125	20 58 81	jsr $8158		jsr 	PrintHex
.8128	ad 9e 04	lda $049e		lda		AssemblerAddress
.812b	20 58 81	jsr $8158		jsr 	PrintHex
.812e	a9 20		lda #$20		lda 	#' '
.8130	20 c5 a7	jsr $a7c5		jsr 	EXTPrintCharacter
.8133	68		pla			pla 									; print byte
.8134	48		pha			pha
.8135	20 58 81	jsr $8158		jsr 	PrintHex
.8138	a9 0d		lda #$0d		lda 	#13
.813a	20 c5 a7	jsr $a7c5		jsr 	EXTPrintCharacter
.813d					_AWBNoPrint:
.813d	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8140	85 36		sta $36			sta 	zTemp0
.8142	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8145	f0 0e		beq $8155		beq 	_AWBRange
.8147	85 37		sta $37			sta 	zTemp0+1
.8149	68		pla			pla 									; write byte out
.814a	92 36		sta ($36)		sta 	(zTemp0)
.814c	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.814f	d0 03		bne $8154		bne 	_AWBNoCarry
.8151	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8154					_AWBNoCarry:
.8154	60		rts			rts
.8155					_AWBRange:
.8155	4c bb 9f	jmp $9fbb		jmp 	RangeError
.8158					PrintHex:
.8158	48		pha				pha
.8159	4a		lsr a				lsr 	a
.815a	4a		lsr a				lsr 	a
.815b	4a		lsr a				lsr 	a
.815c	4a		lsr a				lsr 	a
.815d	20 61 81	jsr $8161			jsr 	_PrintNibble
.8160	68		pla				pla
.8161					_PrintNibble:
.8161	29 0f		and #$0f			and 	#15
.8163	c9 0a		cmp #$0a			cmp 	#10
.8165	90 02		bcc $8169			bcc 	_NoShift
.8167	69 06		adc #$06			adc 	#6
.8169					_NoShift:
.8169	69 30		adc #$30			adc 	#48
.816b	4c c5 a7	jmp $a7c5			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.816e					AssembleModeX:
.816e	5a		phy				phy
.816f	ad a3 04	lda $04a3			lda 	IsGroup1
.8172	f0 17		beq $818b			beq 	_AMXGroup2
.8174	8a		txa				txa 							; is it in group # 1
.8175	29 40		and #$40			and 	#AM_ISG1
.8177	f0 50		beq $81c9			beq 	_AMXFail 				; no, give up.
.8179	8a		txa				txa 							; get back.
.817a	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817c	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.817e	d0 22		bne $81a2			bne 	_AMXHaveInfo
.8180	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8183	c9 81		cmp #$81			cmp 	#$81
.8185	f0 42		beq $81c9			beq 	_AMXFail
.8187	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.8189	80 17		bra $81a2			bra 	_AMXHaveInfo 			; odd design decision there.
.818b					_AMXGroup2:
.818b	8a		txa				txa 							; is it in group 2 ?
.818c	29 20		and #$20			and 	#AM_ISG2
.818e	f0 39		beq $81c9			beq 	_AMXFail 				; no, give up.
.8190	8a		txa				txa 							; get the offset into Y
.8191	29 1f		and #$1f			and 	#$1F
.8193	4a		lsr a				lsr 	a 						; make it 0-7.
.8194	4a		lsr a				lsr  	a
.8195	a8		tay				tay
.8196	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.8199					_AMXCheckOkay:
.8199	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819a	88		dey				dey
.819b	10 fc		bpl $8199			bpl 	_AMXCheckOkay
.819d	90 2a		bcc $81c9			bcc 	_AMXFail 				; not allowed.
.819f	8a		txa				txa  							; get mask back
.81a0	29 1f		and #$1f			and 	#$1F
.81a2					_AMXHaveInfo:
.81a2	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a4	10 05		bpl $81ab			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a6	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81a9	d0 1e		bne $81c9			bne 	_AMXFail
.81ab					_AMXAnySize:
.81ab	18		clc				clc 							; add offset to the base opcode
.81ac	6d a4 04	adc $04a4			adc 	BaseOpcode
.81af					_AMXOutputCode:
.81af	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b2	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b4	f0 10		beq $81c6			beq 	_AMXExit
.81b6	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81b9	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.81bc	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81be	30 06		bmi $81c6			bmi 	_AMXExit
.81c0	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c3	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.81c6					_AMXExit:
.81c6	7a		ply				ply
.81c7	38		sec				sec
.81c8	60		rts				rts
.81c9					_AMXFail:
.81c9	a0 00		ldy #$00			ldy 	#0
.81cb					_AMXCheckOddities:
.81cb	8a		txa				txa
.81cc	d9 f4 81	cmp $81f4,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81cf	d0 16		bne $81e7			bne 	_AMXCONext
.81d1	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d4	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81d7	d0 0e		bne $81e7			bne 	_AMXCONext
.81d9	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81db	10 05		bpl $81e2			bpl 	_AMXCONotZero
.81dd	ad 10 04	lda $0410			lda 	NSMantissa1
.81e0	d0 05		bne $81e7			bne 	_AMXCONext
.81e2					_AMXCONotZero:
.81e2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e5	80 c8		bra $81af			bra 	_AMXOutputCode 			; and assemble it
.81e7					_AMXCONext:
.81e7	c8		iny				iny
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; end of table
.81ed	d0 dc		bne $81cb			bne 	_AMXCheckOddities
.81ef					_AMXCOFail:
.81ef	7a		ply				ply
.81f0	18		clc				clc
.81f1	60		rts				rts
.81f2					ExtraOpcode:
>81f2	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f5	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f8	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fb	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81fe	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8201	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8204	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8207	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820a	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820d	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8210	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8211					LabelHere:
.8211	c8		iny				iny 								; skip .
.8212	a2 00		ldx #$00			ldx 	#0 							; get a term
.8214	20 f2 97	jsr $97f2			jsr 	EvaluateTerm 				; get a term
.8217	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821a	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821c	d0 24		bne $8242			bne 	_ALType
.821e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8221	85 36		sta $36				sta 	zTemp0
.8223	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8226	85 37		sta $37				sta 	zTemp0+1
.8228	5a		phy				phy 								; copy address in.
.8229	a0 01		ldy #$01			ldy 	#1
.822b	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.822e	92 36		sta ($36)			sta 	(zTemp0)
.8230	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8233	91 36		sta ($36),y			sta 	(zTemp0),y
.8235	c8		iny				iny
.8236	a9 00		lda #$00			lda 	#0
.8238	91 36		sta ($36),y			sta 	(zTemp0),y
.823a	c8		iny				iny
.823b	91 36		sta ($36),y			sta 	(zTemp0),y
.823d	c8		iny				iny
.823e	91 36		sta ($36),y			sta 	(zTemp0),y
.8240	7a		ply				ply
.8241	60		rts				rts
.8242					_ALType:
.8242	4c c0 9f	jmp $9fc0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8245					TypeAndCalculateOperand:
.8245	b1 30		lda ($30),y			lda 	(codePtr),y
.8247	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8249	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824b	f0 5b		beq $82a8			beq 	_TACOExit
.824d	c9 80		cmp #$80			cmp 	#KWC_EOL
.824f	f0 57		beq $82a8			beq 	_TACOExit
.8251	c8		iny				iny
.8252	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8254	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8256	f0 51		beq $82a9			beq 	CalculateOperand
.8258	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825a	f0 1f		beq $827b			beq 	_TACOIndirect
.825c	88		dey				dey 								; undo get of first character
.825d	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get operand
.8260	b1 30		lda ($30),y			lda 	(codePtr),y
.8262	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8264	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8266	d0 40		bne $82a8			bne 	_TACOExit
.8268	c8		iny				iny
.8269	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826c	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826e	c9 58		cmp #$58			cmp 	#'X'
.8270	f0 36		beq $82a8			beq 	_TACOExit
.8272	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8274	c9 59		cmp #$59			cmp 	#'Y'
.8276	f0 30		beq $82a8			beq 	_TACOExit
.8278					_TACOSyntax:
.8278	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.827b					_TACOIndirect:
.827b	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get the operand
.827e	b1 30		lda ($30),y			lda 	(codePtr),y
.8280	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8282	f0 17		beq $829b			beq 	_TACOIndX
.8284	20 50 8d	jsr $8d50			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8287	b1 30		lda ($30),y			lda 	(codePtr),y
.8289	a2 d1		ldx #$d1			ldx 	#AM_IND
.828b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828d	d0 19		bne $82a8			bne 	_TACOExit
.828f	c8		iny				iny
.8290	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8293	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8295	d0 e1		bne $8278			bne 	_TACOSyntax
.8297	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8299	80 0d		bra $82a8			bra 	_TACOExit
.829b					_TACOIndX:
.829b	c8		iny				iny
.829c	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.829f	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a1	d0 d5		bne $8278			bne 	_TACOSyntax
.82a3	20 50 8d	jsr $8d50			jsr 	CheckRightBracket			; check )
.82a6	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a8					_TACOExit:
.82a8	60		rts				rts
.82a9					CalculateOperand:
.82a9	48		pha				pha
.82aa	da		phx				phx
.82ab	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ad	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.82b0	fa		plx				plx
.82b1	68		pla				pla
.82b2	60		rts				rts
.82b3					TACOCheckXY:
.82b3	b1 30		lda ($30),y			lda 	(codePtr),y
.82b5	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b7	c9 40		cmp #$40			cmp 	#$40
.82b9	d0 21		bne $82dc			bne 	_TCXYFail
.82bb	b1 30		lda ($30),y			lda 	(codePtr),y
.82bd	18		clc				clc
.82be	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c0	85 37		sta $37				sta 	zTemp0+1
.82c2	c8		iny				iny
.82c3	b1 30		lda ($30),y			lda 	(codePtr),y
.82c5	c8		iny				iny
.82c6	85 36		sta $36				sta 	zTemp0
.82c8	5a		phy				phy 								; save position
.82c9	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cb	b1 36		lda ($36),y			lda 	(zTemp0),y
.82cd	d0 0c		bne $82db			bne 	_TCXYPopFail
.82cf	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d1	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d3	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d5	f0 08		beq $82df			beq 	_TCXYFound
.82d7	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82d9	f0 04		beq $82df			beq 	_TCXYFound
.82db					_TCXYPopFail:
.82db	7a		ply				ply
.82dc					_TCXYFail:
.82dc	a9 00		lda #$00			lda 	#0
.82de	60		rts				rts
.82df					_TCXYFound:
.82df	7a		ply				ply 								; restore position
.82e0	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e3					BackloadProgram:
.82e3	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e5	8d 2b 06	sta $062b			sta 	0+BackLoadPointer
.82e8	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82ea	8d 2c 06	sta $062c			sta 	1+BackLoadPointer
.82ed					_BPLoop:
.82ed	a2 ff		ldx #$ff			ldx 	#$FF
.82ef	8e fa ff	stx $fffa			stx 	$FFFA 						; fast mode (autorun only)
.82f2	20 1c 83	jsr $831c			jsr 	BLReadByte
.82f5	30 1e		bmi $8315			bmi 	_BPExit
.82f7					_BPCopy:
.82f7	e8		inx				inx  								; copy byte in
.82f8	9d a8 05	sta $05a8,x			sta 	lineBuffer,x
.82fb	9e a9 05	stz $05a9,x			stz 	lineBuffer+1,x
.82fe	20 1c 83	jsr $831c			jsr 	BLReadByte 					; read next byte
.8301	30 0a		bmi $830d			bmi 	_BPEndLine 					; -ve = EOL
.8303	c9 09		cmp #$09			cmp 	#9 							; handle TAB
.8305	d0 02		bne $8309			bne 	_BPNotTab
.8307	a9 20		lda #$20			lda 	#' '
.8309					_BPNotTab:
.8309	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.830b	b0 ea		bcs $82f7			bcs 	_BPCopy
.830d					_BPEndLine:
.830d	20 cf b5	jsr $b5cf			jsr 	TokeniseLine 				; tokenise the line.
.8310	20 33 83	jsr $8333			jsr 	EditProgramCode
.8313	80 d8		bra $82ed			bra 	_BPLoop
.8315					_BPExit:
.8315	9c fa ff	stz $fffa			stz 	$FFFA 						; clear fast mode (autorun only)
.8318	20 f1 83	jsr $83f1			jsr 	ClearCommand 				; clear variables etc.
.831b	60		rts				rts
.831c					BLReadByte:
.831c	ad 2b 06	lda $062b			lda 	BackLoadPointer
.831f	85 36		sta $36				sta 	zTemp0
.8321	ad 2c 06	lda $062c			lda 	BackLoadPointer+1
.8324	85 37		sta $37				sta 	zTemp0+1
.8326	b2 36		lda ($36)			lda 	(zTemp0)
.8328	ee 2b 06	inc $062b			inc 	BackLoadPointer
.832b	d0 03		bne $8330			bne 	_BLNoCarry
.832d	ee 2c 06	inc $062c			inc 	BackLoadPointer+1
.8330					_BLNoCarry:
.8330	c9 00		cmp #$00			cmp 	#0
.8332	60		rts				rts
.062b					BackLoadPointer:
>062b							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8333					EditProgramCode:
.8333	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line.
.8336	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1
.8339	20 c5 a5	jsr $a5c5			jsr 	MemorySearch
.833c	90 05		bcc $8343			bcc 	_EPCNoDelete 				; reached the end don't delete
.833e	d0 03		bne $8343			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8340	20 e6 a4	jsr $a4e6			jsr 	MemoryDeleteLine 			; delete the line
.8343					_EPCNoDelete:
.8343	ad ab 04	lda $04ab			lda 	TokenBuffer 				; buffer empty
.8346	c9 80		cmp #$80			cmp 	#KWC_EOL
.8348	f0 0d		beq $8357			beq 	_EPCNoInsert
.834a	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line - it cannot exist.
.834d	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8350	20 c5 a5	jsr $a5c5			jsr 	MemorySearch
.8353	18		clc				clc 								; insert at this point.
.8354	20 1d a5	jsr $a51d			jsr 	MemoryInsertLine 			; insert the line
.8357					_EPCNoInsert:
.8357	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8358					WarmStart:
.8358	a2 ff		ldx #$ff			ldx 	#$FF
.835a	9a		txs				txs
.835b	20 53 a9	jsr $a953			jsr 	EXTInputLine 				; get line to lineBuffer
.835e	20 cf b5	jsr $b5cf			jsr 	TokeniseLine 				; tokenise the line
.8361	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; line number ?
.8364	0d aa 04	ora $04aa			ora 	TokenLineNumber+1
.8367	d0 17		bne $8380			bne 	_WSEditCode 				; if so,edit code.
.8369	9c a8 04	stz $04a8			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.836c	a9 a8		lda #$a8			lda 	#((TokenOffset) & $FF)
.836e	85 30		sta $30				sta 	codePtr
.8370	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8372	85 31		sta $31				sta 	codePtr+1
.8374	ad ab 04	lda $04ab			lda 	TokenBuffer 				; nothing to run
.8377	c9 80		cmp #$80			cmp 	#KWC_EOL
.8379	f0 dd		beq $8358			beq 	WarmStart
.837b	20 11 8a	jsr $8a11			jsr 	RUNCodePointerLine 			; execute that line.
.837e	80 d8		bra $8358			bra 	WarmStart
.8380					_WSEditCode:
.8380	20 33 83	jsr $8333			jsr 	EditProgramCode
.8383	20 f1 83	jsr $83f1			jsr 	ClearCommand
.8386	80 d0		bra $8358			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8388					AssembleCommand:
.8388	a2 00		ldx #$00			ldx 	#0
.838a	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger 		; start address
.838d	ad 08 04	lda $0408			lda 	NSMantissa0
.8390	8d 9e 04	sta $049e			sta 	AssemblerAddress
.8393	ad 10 04	lda $0410			lda 	NSMantissa1
.8396	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.8399	20 58 8d	jsr $8d58			jsr 	CheckComma
.839c	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; options
.839f	ad 08 04	lda $0408			lda 	NSMantissa0
.83a2	8d a0 04	sta $04a0			sta 	AssemblerControl
.83a5	60		rts				rts
.83a6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83a7					AssertCommand:
.83a7	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83a9	20 78 9d	jsr $9d78			jsr 	EvaluateInteger 			; the assert test
.83ac	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; exit if result is non zero.
.83af	d0 05		bne $83b6			bne 	_ACExit
.83b1	a9 0a		lda #$0a		lda	#10
.83b3	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.83b6					_ACExit:
.83b6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83b7					CallCommand:
.83b7	a2 00		ldx #$00			ldx 	#0
.83b9	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.83bc					_CCClear
.83bc	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83bd	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.83c0	e0 04		cpx #$04			cpx 	#4
.83c2	d0 f8		bne $83bc			bne 	_CCClear
.83c4	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83c6					_CCCParam:
.83c6	b1 30		lda ($30),y			lda 	(codePtr),y
.83c8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83ca	d0 09		bne $83d5			bne 	_CCCRun6502
.83cc	c8		iny				iny 								; skip comma
.83cd	e8		inx				inx	 								; next level
.83ce	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83d1	e0 03		cpx #$03			cpx 	#3
.83d3	90 f1		bcc $83c6			bcc 	_CCCParam 					; done all 3 ?
.83d5					_CCCRun6502:
.83d5	5a		phy				phy 								; save position
.83d6	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83d9	85 37		sta $37				sta 	zTemp0+1
.83db	ad 08 04	lda $0408			lda 	NSMantissa0
.83de	85 36		sta $36				sta 	zTemp0
.83e0	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83e3	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83e6	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83e9	20 ee 83	jsr $83ee			jsr 	_CCCZTemp0 					; call zTemp0
.83ec	7a		ply				ply 								; restore position and exit
.83ed	60		rts				rts
.83ee					_CCCZTemp0:
.83ee	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83f1					ClearCommand:
.83f1	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83f3	85 36		sta $36				sta 	0+zTemp0
.83f5	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f7	85 37		sta $37				sta 	1+zTemp0
.83f9					_ClearZeroLoop:
.83f9	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables
.83fb	f0 24		beq $8421			beq 	_ClearZeroEnd
.83fd	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83ff	a9 00		lda #$00			lda 	#0
.8401					_ClearOneVariable:
.8401	91 36		sta ($36),y			sta 	(zTemp0),y
.8403	c8		iny				iny
.8404	c0 08		cpy #$08			cpy 	#8
.8406	d0 f9		bne $8401			bne 	_ClearOneVariable
.8408	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.840a	b1 36		lda ($36),y			lda 	(zTemp0),y
.840c	c9 18		cmp #$18			cmp 	#NSTProcedure
.840e	d0 04		bne $8414			bne 	_ClearNotProcedure
.8410	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; set it back to an integer array
.8412	91 36		sta ($36),y			sta 	(zTemp0),y
.8414					_ClearNotProcedure:
.8414	18		clc				clc 								; go to the next variable
.8415	b2 36		lda ($36)			lda 	(zTemp0)
.8417	65 36		adc $36				adc 	zTemp0
.8419	85 36		sta $36				sta 	zTemp0
.841b	90 dc		bcc $83f9			bcc 	_ClearZeroLoop
.841d	e6 37		inc $37				inc 	zTemp0+1
.841f	80 d8		bra $83f9			bra 	_ClearZeroLoop
.8421					_ClearZeroEnd:
.8421	18		clc				clc
.8422	a5 36		lda $36				lda 	zTemp0
.8424	69 01		adc #$01			adc 	#1
.8426	8d 8c 04	sta $048c			sta 	lowMemPtr
.8429	a5 37		lda $37				lda 	zTemp0+1
.842b	69 00		adc #$00			adc 	#0
.842d	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.8430	20 ea a6	jsr $a6ea			jsr 	StackReset
.8433	20 54 a7	jsr $a754			jsr 	StringSystemInitialise
.8436	20 59 8c	jsr $8c59			jsr 	ProcedureScan
.8439	20 c0 89	jsr $89c0			jsr 	Command_Restore
.843c	9c 9e 04	stz $049e			stz 	AssemblerAddress
.843f	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.8442	9c a0 04	stz $04a0			stz 	AssemblerControl
.8445	20 f5 99	jsr $99f5			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8448	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8449					ClearScreen:
.8449	5a		phy				phy
.844a	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.844c	20 c5 a7	jsr $a7c5			jsr 	EXTPrintCharacter
.844f	7a		ply				ply
.8450	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8451					Command_Data:
.8451	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8453	a2 80		ldx #$80			ldx 	#KWC_EOL
.8455	20 ab 8c	jsr $8cab			jsr 	ScanForward
.8458	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8459					DimCommand:
.8459	b1 30		lda ($30),y			lda 	(codePtr),y
.845b	29 c0		and #$c0			and 	#$C0
.845d	c9 40		cmp #$40			cmp 	#$40
.845f	d0 7a		bne $84db			bne 	_DCSyntax
.8461	b1 30		lda ($30),y			lda 	(codePtr),y
.8463	18		clc				clc
.8464	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8466	85 3f		sta $3f				sta 	zaTemp+1
.8468	c8		iny				iny
.8469	b1 30		lda ($30),y			lda 	(codePtr),y
.846b	c8		iny				iny
.846c	85 3e		sta $3e				sta 	zaTemp
.846e	5a		phy				phy
.846f	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8471	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8473	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8475	c9 18		cmp #$18			cmp 	#NSTProcedure
.8477	f0 62		beq $84db			beq 	_DCSyntax
.8479	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.847b	29 04		and #$04			and 	#NSBIsArray
.847d	f0 64		beq $84e3			beq 	_DCType
.847f	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8481	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8483	d0 59		bne $84de			bne 	_DCRedefine
.8485	7a		ply				ply
.8486	20 e6 84	jsr $84e6			jsr 	_DCGetSize 				; get array size, check it.
.8489	5a		phy				phy
.848a	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.848c	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.848e	7a		ply				ply 							; is there a second (e.g. ,x)
.848f	b1 30		lda ($30),y			lda 	(codePtr),y
.8491	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8493	d0 0a		bne $849f			bne 	_DCOneDimension
.8495	c8		iny				iny 							; skip comma
.8496	20 e6 84	jsr $84e6			jsr 	_DCGetSize 				; get 2nd array size
.8499	5a		phy				phy
.849a	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.849c	91 3e		sta ($3e),y			sta 	(zaTemp),y
.849e	7a		ply				ply
.849f					_DCOneDimension:
.849f	5a		phy				phy 							; save position
.84a0	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84a2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a4	aa		tax				tax
.84a5	c8		iny				iny
.84a6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a8	e8		inx				inx 							; bump them.
.84a9	1a		inc a				inc 	a
.84aa	20 c1 9d	jsr $9dc1			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84ad	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84af	29 e0		and #$e0			and 	#$E0
.84b1	d0 23		bne $84d6			bne 	_DCSize
.84b3	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b7	20 f4 84	jsr $84f4			jsr 	ScaleByBaseType 		; scale by base type
.84ba	a5 36		lda $36				lda 	zTemp0
.84bc	a6 37		ldx $37				ldx 	zTemp0+1
.84be	20 b7 99	jsr $99b7			jsr 	AllocateXABytes 		; allocate memory
.84c1	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84c3	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c5	c8		iny				iny
.84c6	8a		txa				txa
.84c7	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c9	7a		ply				ply 							; get position back
.84ca	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 		; check )
.84cd	b1 30		lda ($30),y			lda 	(codePtr),y
.84cf	c8		iny				iny 							; consume in case
.84d0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84d2	f0 85		beq $8459			beq 	DimCommand
.84d4	88		dey				dey 							; undo consume
.84d5	60		rts				rts
.84d6					_DCSize:
.84d6	a9 16		lda #$16		lda	#22
.84d8	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.84db					_DCSyntax:
.84db	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.84de					_DCRedefine:
.84de	a9 15		lda #$15		lda	#21
.84e0	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.84e3					_DCType:
.84e3	4c c0 9f	jmp $9fc0			jmp 	TypeError
.84e6					_DCGetSize:
.84e6	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84e8	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 	; get array dimension
.84eb	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84ed	f0 e7		beq $84d6			beq 	_DCSize
.84ef	c9 fe		cmp #$fe			cmp 	#254
.84f1	f0 e3		beq $84d6			beq 	_DCSize
.84f3	60		rts				rts
.84f4					ScaleByBaseType:
.84f4	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f6	d0 19		bne $8511			bne 	_SBBTString
.84f8	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84fa	48		pha				pha
.84fb	a5 36		lda $36				lda 	zTemp0
.84fd	48		pha				pha
.84fe	06 36		asl $36				asl 	zTemp0 					; x 2
.8500	26 37		rol $37				rol 	zTemp0+1
.8502	06 36		asl $36				asl 	zTemp0 					; x 4
.8504	26 37		rol $37				rol 	zTemp0+1
.8506	68		pla				pla 							; add stacked value = x 5
.8507	65 36		adc $36				adc 	zTemp0
.8509	85 36		sta $36				sta 	zTemp0
.850b	68		pla				pla
.850c	65 37		adc $37				adc 	zTemp0+1
.850e	85 37		sta $37				sta 	zTemp0+1
.8510	60		rts				rts
.8511					_SBBTString:
.8511	06 36		asl $36				asl 	zTemp0
.8513	26 37		rol $37				rol 	zTemp0+1
.8515	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8516					EndCommand:
.8516	4c 58 83	jmp $8358			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8519					ForCommand:
.8519	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.851b	20 85 a6	jsr $a685			jsr 	StackOpen
.851e	a2 00		ldx #$00			ldx 	#0
.8520	20 f2 97	jsr $97f2			jsr 	EvaluateTerm
.8523	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8526	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8528	d0 49		bne $8573			bne		_FCError
.852a	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.852c	20 60 8d	jsr $8d60			jsr 	CheckNextA
.852f	e8		inx				inx
.8530	20 78 9d	jsr $9d78			jsr 	EvaluateInteger 			; <from> in +1
.8533	b1 30		lda ($30),y			lda 	(codePtr),y
.8535	c8		iny				iny 								; consume it
.8536	48		pha				pha 								; save on stack for later
.8537	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8539	f0 04		beq $853f			beq 	_FCNoSyntax
.853b	c9 cd		cmp #$cd			cmp 	#KWD_TO
.853d	d0 37		bne $8576			bne 	_FCSyntaxError
.853f					_FCNoSyntax:
.853f	e8		inx				inx
.8540	20 78 9d	jsr $9d78			jsr 	EvaluateInteger
.8543	20 c9 a6	jsr $a6c9			jsr 	STKSaveCodePosition 		; save loop back position
.8546	68		pla				pla 								; restore DOWNTO or TO
.8547	5a		phy				phy 								; save Y on the stack
.8548	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.854a	f0 02		beq $854e			beq 	_FCNotDownTo
.854c	a9 02		lda #$02			lda 	#2
.854e					_FCNotDownTo:
.854e	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.854f	a0 10		ldy #$10			ldy 	#16
.8551	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8553	a0 06		ldy #$06			ldy 	#6
.8555	ad 08 04	lda $0408			lda 	NSMantissa0
.8558	91 34		sta ($34),y			sta 	(basicStack),y
.855a	ad 10 04	lda $0410			lda 	NSMantissa1
.855d	c8		iny				iny
.855e	91 34		sta ($34),y			sta 	(basicStack),y
.8560	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8562	a2 01		ldx #$01			ldx 	#1
.8564	20 79 85	jsr $8579			jsr 	FCIntegerToStack
.8567	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8569	a2 02		ldx #$02			ldx 	#2
.856b	20 79 85	jsr $8579			jsr 	FCIntegerToStack
.856e	20 99 85	jsr $8599			jsr 	CopyIndexToReference
.8571	7a		ply				ply 								; restore position
.8572	60		rts				rts
.8573					_FCError:
.8573	4c c0 9f	jmp $9fc0			jmp 	TypeError
.8576					_FCSyntaxError:
.8576	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.8579					FCIntegerToStack:
.8579	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.857c	10 03		bpl $8581			bpl	 	_FCNotNegative
.857e	20 e1 9d	jsr $9de1			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8581					_FCNotNegative:
.8581	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8584	91 34		sta ($34),y			sta 	(basicStack),y
.8586	c8		iny				iny
.8587	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.858a	91 34		sta ($34),y			sta 	(basicStack),y
.858c	c8		iny				iny
.858d	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.8590	91 34		sta ($34),y			sta 	(basicStack),y
.8592	c8		iny				iny
.8593	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.8596	91 34		sta ($34),y			sta 	(basicStack),y
.8598	60		rts				rts
.8599					CopyIndexToReference:
.8599	5a		phy				phy
.859a	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.859c	38		sec				sec 								; (because we copy from offset 8)
.859d	b1 34		lda ($34),y			lda 	(basicStack),y
.859f	e9 08		sbc #$08			sbc 	#8
.85a1	85 36		sta $36				sta 	zTemp0
.85a3	c8		iny				iny
.85a4	b1 34		lda ($34),y			lda 	(basicStack),y
.85a6	e9 00		sbc #$00			sbc 	#0
.85a8	85 37		sta $37				sta 	zTemp0+1
.85aa	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85ac	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85ae	b1 34		lda ($34),y			lda 	(basicStack),y
.85b0	0a		asl a				asl 	a 							; into carry
.85b1	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85b3	90 14		bcc $85c9			bcc 	_CITRNormal
.85b5	38		sec				sec
.85b6					_CITRNegative:
.85b6	a9 00		lda #$00			lda 	#0
.85b8	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85ba	91 36		sta ($36),y			sta 	(zTemp0),y
.85bc	c8		iny				iny
.85bd	ca		dex				dex
.85be	d0 f6		bne $85b6			bne 	_CITRNegative
.85c0	88		dey				dey 								; look at MSB of mantissa
.85c1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85c3	09 80		ora #$80			ora 	#$80
.85c5	91 36		sta ($36),y			sta 	(zTemp0),y
.85c7	7a		ply				ply
.85c8	60		rts				rts
.85c9					_CITRNormal:
.85c9	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85cb	91 36		sta ($36),y			sta 	(zTemp0),y
.85cd	c8		iny				iny
.85ce	ca		dex				dex
.85cf	d0 f8		bne $85c9			bne 	_CITRNormal
.85d1	7a		ply				ply 								; and exit.
.85d2	60		rts				rts
.85d3					NextCommand:
.85d3	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85d5	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d7	20 b1 a6	jsr $a6b1			jsr 	StackCheckFrame
.85da	5a		phy				phy
.85db	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85dd	b1 34		lda ($34),y			lda 	(basicStack),y
.85df	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85e1	30 02		bmi $85e5			bmi 	_NCStepNeg
.85e3	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85e5					_NCStepNeg:
.85e5	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e7	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85e9	18		clc				clc
.85ea					_NCBump:
.85ea	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85ec	91 34		sta ($34),y			sta 	(basicStack),y
.85ee	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85f0	c8		iny				iny 								; next byte
.85f1	ca		dex				dex 								; do four times
.85f2	d0 f6		bne $85ea			bne 	_NCBump
.85f4	20 99 85	jsr $8599			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f7	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85f9	b1 34		lda ($34),y			lda 	(basicStack),y
.85fb	0a		asl a				asl 	a 							; sign bit to carry
.85fc	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85fe	85 38		sta $38				sta 	zTemp1
.8600	90 02		bcc $8604			bcc 	_NCCompRev 					; use if step is +ve
.8602	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8604					_NCCompRev:
.8604	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8606	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8608	85 39		sta $39				sta 	zTemp1+1
.860a	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.860c	38		sec				sec
.860d					_NCCompare:
.860d	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.860f	b1 34		lda ($34),y			lda 	(basicStack),y
.8611	a4 39		ldy $39				ldy 	zTemp1+1
.8613	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8615	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8617	e6 39		inc $39				inc 	zTemp1+1
.8619	ca		dex				dex 								; do it 4 times.
.861a	d0 f1		bne $860d			bne 	_NCCompare
.861c	50 02		bvc $8620			bvc 	_NCNoOverflow 				; convert to signed comparison
.861e	49 80		eor #$80			eor 	#$80
.8620					_NCNoOverflow:
.8620	7a		ply				ply 								; restore Y position
.8621	0a		asl a				asl 	a 							; is bit 7 set.
.8622	90 04		bcc $8628			bcc 	_NCLoopback 				; if no , >= so loop back
.8624	20 a3 a6	jsr $a6a3			jsr 	StackClose 					; exit the loop
.8627	60		rts				rts
.8628					_NCLoopBack:
.8628	20 da a6	jsr $a6da			jsr 	STKLoadCodePosition 		; loop back
.862b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.862c					Command_GOSUB:
.862c	a2 00		ldx #$00			ldx 	#0
.862e	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8631	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8633	20 85 a6	jsr $a685			jsr 	StackOpen 					; create frame
.8636	20 c9 a6	jsr $a6c9			jsr 	STKSaveCodePosition 		; save current position
.8639	4c 4f 86	jmp $864f			jmp 	GotoStackX
.863c					Command_RETURN:
.863c	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.863e	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8640	20 b1 a6	jsr $a6b1			jsr 	StackCheckFrame
.8643	20 da a6	jsr $a6da			jsr 	STKLoadCodePosition 		; restore code position
.8646	20 a3 a6	jsr $a6a3			jsr 	StackClose
.8649	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.864a					GotoCommand:
.864a	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.864c	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.864f					GotoStackX:
.864f	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8652	48		pha				pha 								; it is slightly inefficient, just in cases.
.8653	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8656	fa		plx				plx
.8657	20 c5 a5	jsr $a5c5			jsr 	MemorySearch 				; transfer to line number AX.
.865a	90 05		bcc $8661			bcc 	_GotoError 					; not found, off end.
.865c	d0 03		bne $8661			bne 	_GotoError 					; not found exactly
.865e	4c 0a 8a	jmp $8a0a			jmp 	RunNewLine 					; and go straight to new line code.
.8661					_GotoError:
.8661	a9 0d		lda #$0d		lda	#13
.8663	4c 69 8d	jmp $8d69		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8666					IfCommand:
.8666	a2 00		ldx #$00			ldx 	#0 							; If what.
.8668	20 55 9d	jsr $9d55			jsr 	EvaluateNumber
.866b	b1 30		lda ($30),y			lda 	(codePtr),y
.866d	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.866f	d0 0a		bne $867b			bne 	_IFStructured
.8671	c8		iny				iny 								; consume THEN
.8672	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; is it zero
.8675	f0 01		beq $8678			beq 	_IfFail 					; if fail, go to next line
.8677	60		rts				rts 								; if THEN just continue
.8678					_IfFail:
.8678	4c f2 89	jmp $89f2			jmp 	EOLCommand
.867b					_IfStructured:
.867b	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; is it zero
.867e	d0 07		bne $8687			bne 	_IfExit 					; if not, then continue normally.
.8680	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8682	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8684	20 ab 8c	jsr $8cab			jsr 	ScanForward 				; and run from there/
.8687					_IfExit:
.8687	60		rts				rts
.8688					ElseCode:
.8688	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.868a	aa		tax				tax 								; so just go to the structure exit
.868b	20 ab 8c	jsr $8cab			jsr 	ScanForward
.868e	60		rts				rts
.868f					EndIf:
.868f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8690					LetCommand:
.8690	a2 00		ldx #$00			ldx 	#0
.8692	b1 30		lda ($30),y			lda 	(codePtr),y
.8694	c9 10		cmp #$10			cmp 	#KWD_AT
.8696	d0 16		bne $86ae			bne 	_LCStandard
.8698	c8		iny				iny 								; skip equal
.8699	20 f2 97	jsr $97f2			jsr 	EvaluateTerm 				; get a number
.869c	20 36 96	jsr $9636			jsr 	Dereference 				; dereference it
.869f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.86a2	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.86a4	9d 00 04	sta $0400,x			sta 	NSStatus,x
.86a7	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.86a9	d0 10		bne $86bb			bne 	_LCMain
.86ab	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; was a reference before.
.86ae					_LCStandard:
.86ae	ad 00 93	lda $9300			lda 	PrecedenceLevel+"*"			; precedence > this
.86b1	20 1a 93	jsr $931a			jsr 	EvaluateExpressionAtPrecedence
.86b4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.86b7	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.86b9	f0 0e		beq $86c9			beq 	_LetGoProc 					; it's a procedure call.
.86bb					_LCMain:
.86bb	a9 3d		lda #$3d			lda 	#"=" 						; check =
.86bd	20 60 8d	jsr $8d60			jsr 	CheckNextA
.86c0	e8		inx				inx 								; RHS
.86c1	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue
.86c4	ca		dex				dex
.86c5	20 cc 86	jsr $86cc			jsr 	AssignVariable
.86c8	60		rts				rts
.86c9					_LetGoProc:
.86c9	4c ca 88	jmp $88ca			jmp 	CallProcedure
.86cc					AssignVariable:
.86cc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.86cf	48		pha				pha 								; save a copy
.86d0	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.86d3	29 10		and #$10			and 	#NSBIsString
.86d5	d0 0b		bne $86e2			bne 	_ASError
.86d7	68		pla				pla 								; get back
.86d8	29 10		and #$10			and 	#NSBIsString 				; check type
.86da	d0 03		bne $86df			bne 	_ASString
.86dc	4c 5e 95	jmp $955e			jmp 	AssignNumber
.86df					_ASString:
.86df	4c cc 95	jmp $95cc			jmp 	AssignString
.86e2					_ASError:
.86e2	4c c0 9f	jmp $9fc0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.86e5					Command_List:
.86e5	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.86e8	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.86eb	9c 14 04	stz $0414			stz 	NSMantissa1+4
.86ee	a9 ff		lda #$ff			lda 	#$FF
.86f0	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.86f3	8d 17 04	sta $0417			sta 	NSMantissa1+7
.86f6	b1 30		lda ($30),y			lda 	(codePtr),y
.86f8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.86fa	f0 1e		beq $871a			beq 	_CLSecond
.86fc	20 7b 87	jsr $877b			jsr 	CLIsDigit 					; if not digit, list all
.86ff	b0 24		bcs $8725			bcs 	_CLStart
.8701	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8703	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.8706	b1 30		lda ($30),y			lda 	(codePtr),y
.8708	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.870a	f0 0e		beq $871a			beq 	_CLSecond 					; if so go get it
.870c	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.870f	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.8712	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8715	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8718	80 0b		bra $8725			bra 	_CLStart
.871a					_CLSecond:
.871a	c8		iny				iny 								; consume comma
.871b	20 7b 87	jsr $877b			jsr 	CLIsDigit 					; digit found
.871e	b0 05		bcs $8725			bcs 	_CLStart 					; if not, continue listing
.8720	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8722	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.8725					_CLStart
.8725	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8727	85 30		sta $30				sta 	codePtr
.8729	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.872b	85 31		sta $31				sta 	codePtr+1
.872d					_CLLoop:
.872d	20 67 aa	jsr $aa67			jsr 	EXTBreakCheck 				; break check
.8730	f0 33		beq $8765			beq 	_CLExit
.8732	b2 30		lda ($30)			lda 	(codePtr)
.8734	f0 2f		beq $8765			beq 	_CLExit
.8736	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8738	20 68 87	jsr $8768			jsr 	CLCompareLineNo
.873b	90 1b		bcc $8758			bcc 	_CLNext
.873d	a2 07		ldx #$07			ldx 	#7
.873f	20 68 87	jsr $8768			jsr 	CLCompareLineNo
.8742	f0 02		beq $8746			beq 	_CLDoThisOne
.8744	b0 12		bcs $8758			bcs 	_CLNext
.8746					_CLDoThisOne:
.8746	20 0e 8d	jsr $8d0e			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8749	20 b1 b3	jsr $b3b1			jsr 	ListConvertLine 			; convert line into token Buffer
.874c	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.874e	a9 ab		lda #$ab			lda 	#(tokenBuffer & $FF)
.8750	20 c2 8d	jsr $8dc2			jsr 	PrintStringXA
.8753	a9 0d		lda #$0d			lda 	#13 						; new line
.8755	20 c5 a7	jsr $a7c5			jsr 	EXTPrintCharacter
.8758					_CLNext:
.8758	18		clc				clc
.8759	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.875b	65 30		adc $30				adc 	codePtr
.875d	85 30		sta $30				sta 	codePtr
.875f	90 02		bcc $8763			bcc 	_CREExit
.8761	e6 31		inc $31				inc 	codePtr+1
.8763					_CREExit:
.8763	80 c8		bra $872d			bra 	_CLLoop
.8765					_CLExit:
.8765	4c 58 83	jmp $8358			jmp 	WarmStart
.8768					CLCompareLineNo:
.8768	38		sec				sec
.8769	a0 01		ldy #$01			ldy 	#1
.876b	b1 30		lda ($30),y			lda 	(codePtr),y
.876d	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.8770	85 36		sta $36				sta 	zTemp0
.8772	c8		iny				iny
.8773	b1 30		lda ($30),y			lda 	(codePtr),y
.8775	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8778	05 36		ora $36				ora 	zTemp0
.877a	60		rts				rts
.877b					CLIsDigit:
.877b	b1 30		lda ($30),y			lda 	(codePtr),y
.877d	c9 30		cmp #$30			cmp 	#"0"
.877f	90 03		bcc $8784			bcc	 	_CLIDExitFalse
.8781	c9 3a		cmp #$3a			cmp 	#"9"+1
.8783	60		rts				rts
.8784					_CLIDExitFalse:
.8784	38		sec				sec
.8785	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8786					Command_LOCAL:
.8786	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8788	20 94 87	jsr $8794			jsr 	LocaliseNextTerm 			; convert term to a local.
.878b	b1 30		lda ($30),y			lda 	(codePtr),y
.878d	c8		iny				iny
.878e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8790	f0 f4		beq $8786			beq 	Command_LOCAL
.8792	88		dey				dey 								; unpick pre-get
.8793	60		rts				rts
.8794					LocaliseNextTerm:
.8794	20 f2 97	jsr $97f2			jsr 	EvaluateTerm 				; evaluate the term
.8797	bd 00 04	lda $0400,x			lda 	NSStatus,x
.879a	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.879c	f0 61		beq $87ff			beq		_LNTError
.879e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.87a1	85 36		sta $36				sta 	zTemp0
.87a3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87a6	85 37		sta $37				sta  	zTemp0+1
.87a8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.87ab	29 10		and #$10			and 	#NSBIsString
.87ad	d0 1e		bne $87cd			bne 	_LNTPushString
.87af	5a		phy				phy
.87b0	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.87b2					_LNTPushNumLoop:
.87b2	b1 36		lda ($36),y			lda		(zTemp0),y
.87b4	20 63 a6	jsr $a663			jsr 	StackPushByte
.87b7	c8		iny				iny
.87b8	c0 05		cpy #$05			cpy 	#5
.87ba	d0 f6		bne $87b2			bne 	_LNTPushNumLoop
.87bc	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.87be	20 63 a6	jsr $a663			jsr 	StackPushByte
.87c1	a5 37		lda $37				lda 	zTemp0+1
.87c3	20 63 a6	jsr $a663			jsr 	StackPushByte
.87c6	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.87c8	20 63 a6	jsr $a663			jsr 	StackPushByte
.87cb	7a		ply				ply
.87cc	60		rts				rts
.87cd					_LNTPushString:
.87cd	5a		phy				phy
.87ce	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.87d0	85 38		sta $38				sta 	zTemp1
.87d2	a0 01		ldy #$01			ldy 	#1
.87d4	b1 36		lda ($36),y			lda 	(zTemp0),y
.87d6	85 39		sta $39				sta 	zTemp1+1
.87d8	a0 00		ldy #$00			ldy 	#0 							; output string
.87da	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.87dc	f0 0a		beq $87e8			beq 	_LNTStringOut
.87de					_LNTPushStrLoop:
.87de	b1 38		lda ($38),y			lda 	(zTemp1),y
.87e0	f0 06		beq $87e8			beq 	_LNTStringOut
.87e2	20 63 a6	jsr $a663			jsr 	StackPushByte
.87e5	c8		iny				iny
.87e6	80 f6		bra $87de			bra 	_LNTPushStrLoop
.87e8					_LNTStringOut:
.87e8	98		tya				tya									; output length
.87e9	20 63 a6	jsr $a663			jsr 	StackPushByte
.87ec	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.87ef	20 63 a6	jsr $a663			jsr 	StackPushByte
.87f2	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87f5	20 63 a6	jsr $a663			jsr 	StackPushByte
.87f8	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.87fa	20 63 a6	jsr $a663			jsr 	StackPushByte
.87fd	7a		ply				ply
.87fe	60		rts				rts
.87ff					_LNTError:
.87ff	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.8802					LocalPopValue:
.8802	20 7c a6	jsr $a67c			jsr 	StackPopByte
.8805	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8807	d0 17		bne $8820			bne 	_LPVString
.8809	20 7c a6	jsr $a67c			jsr 	StackPopByte 				; address
.880c	85 37		sta $37				sta 	zTemp0+1
.880e	20 7c a6	jsr $a67c			jsr 	StackPopByte
.8811	85 36		sta $36				sta 	zTemp0
.8813	5a		phy				phy
.8814	a0 04		ldy #$04			ldy 	#4 							; copy back
.8816					_LPVNumberCopy:
.8816	20 7c a6	jsr $a67c			jsr 	StackPopByte
.8819	91 36		sta ($36),y			sta 	(zTemp0),y
.881b	88		dey				dey
.881c	10 f8		bpl $8816			bpl 	_LPVNumberCopy
.881e	7a		ply				ply 								; and complete
.881f	60		rts				rts
.8820					_LPVString:
.8820	20 7c a6	jsr $a67c			jsr 	StackPopByte 				; address of record => zTemp0
.8823	85 37		sta $37				sta 	zTemp0+1
.8825	20 7c a6	jsr $a67c			jsr 	StackPopByte
.8828	85 36		sta $36				sta 	zTemp0
.882a	5a		phy				phy
.882b	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.882d	85 38		sta $38				sta 	zTemp1
.882f	a0 01		ldy #$01			ldy 	#1
.8831	b1 36		lda ($36),y			lda 	(zTemp0),y
.8833	85 39		sta $39				sta 	zTemp1+1
.8835	20 7c a6	jsr $a67c			jsr 	StackPopByte 				; # to get => y
.8838	a8		tay				tay
.8839	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.883b	f0 0e		beq $884b			beq 	_LPVStringCopied
.883d	a9 00		lda #$00			lda 	#0 							; NULL on end
.883f	91 38		sta ($38),y			sta 	(zTemp1),y
.8841					_LPVStringCopy:
.8841	88		dey				dey
.8842	30 07		bmi $884b			bmi 	_LPVStringCopied
.8844	20 7c a6	jsr $a67c			jsr 	StackPopByte
.8847	91 38		sta ($38),y			sta 	(zTemp1),y
.8849	80 f6		bra $8841			bra 	_LPVStringCopy
.884b					_LPVStringCopied:
.884b	fa		plx				plx
.884c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.884d					NewCommand:
.884d	20 53 88	jsr $8853			jsr 	NewProgram
.8850	4c 58 83	jmp $8358			jmp 	WarmStart
.8853					NewProgram:
.8853	20 a3 a5	jsr $a5a3			jsr 	MemoryNew
.8856	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8859	20 f1 83	jsr $83f1			jsr 	ClearCommand 				; clear everything.
.885c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/print.asm

.885d					Command_Print:
.885d	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.885e					_CPLoop:
.885e	08		php				php 								; save last action flag
.885f	b1 30		lda ($30),y			lda 	(codePtr),y
.8861	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8863	f0 46		beq $88ab			beq 	_CPExit
.8865	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8867	f0 42		beq $88ab			beq 	_CPExit
.8869	68		pla				pla 								; throw last action flag
.886a	b1 30		lda ($30),y			lda 	(codePtr),y
.886c	c8		iny				iny
.886d	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.886f	f0 37		beq $88a8			beq 	_CPContinueWithSameLine
.8871	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8873	f0 2e		beq $88a3			beq 	_CPTab
.8875	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8877	f0 26		beq $889f			beq 	_CPNewLine
.8879	88		dey				dey 								; undo the get.
.887a	a2 00		ldx #$00			ldx 	#0
.887c	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue 				; get a value into slot 0
.887f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.8882	29 10		and #$10			and 	#NSBIsString
.8884	f0 0b		beq $8891			beq 	_CPNumber
.8886	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.8889	ad 08 04	lda $0408			lda 	NSMantissa0
.888c	20 b4 88	jsr $88b4			jsr 	CPPrintStringXA
.888f	80 cc		bra $885d			bra 	Command_Print 				; loop round clearing carry so NL if end
.8891					_CPNumber:
.8891	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8893	20 22 9c	jsr $9c22			jsr 	ConvertNumberToString 		; convert to string
.8896	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8898	a9 1b		lda #$1b			lda 	#DecimalBuffer & $FF
.889a	20 b4 88	jsr $88b4			jsr 	CPPrintStringXA
.889d	80 be		bra $885d			bra 	Command_Print 				; loop round clearing carry so NL if end
.889f					_CPNewLine:
.889f	a9 0d		lda #$0d			lda 	#13
.88a1	80 02		bra $88a5			bra 	_CPPrintChar
.88a3					_CPTab:
.88a3	a9 09		lda #$09			lda 	#9 							; print TAB
.88a5					_CPPrintChar:
.88a5	20 c7 88	jsr $88c7			jsr 	CPPrintVector
.88a8					_CPContinueWithSameLine:
.88a8	38		sec				sec 								; loop round with carry set, which
.88a9	80 b3		bra $885e			bra 	_CPLoop 					; will inhibit final CR
.88ab					_CPExit:
.88ab	28		plp				plp 								; get last action flag
.88ac	b0 05		bcs $88b3			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.88ae	a9 0d		lda #$0d			lda 	#13 						; print new line
.88b0	20 c7 88	jsr $88c7			jsr 	CPPrintVector
.88b3					_CPExit2:
.88b3	60		rts				rts
.88b4					CPPrintStringXA:
.88b4	5a		phy				phy
.88b5	86 37		stx $37				stx 	zTemp0+1
.88b7	85 36		sta $36				sta 	zTemp0
.88b9	a0 00		ldy #$00			ldy 	#0
.88bb					_PSXALoop:
.88bb	b1 36		lda ($36),y			lda 	(zTemp0),y
.88bd	f0 06		beq $88c5			beq 	_PSXAExit
.88bf	20 c7 88	jsr $88c7			jsr 	CPPrintVector
.88c2	c8		iny				iny
.88c3	80 f6		bra $88bb			bra 	_PSXALoop
.88c5					_PSXAExit:
.88c5	7a		ply				ply
.88c6	60		rts				rts
.88c7					CPPrintVector:
.88c7	4c c5 a7	jmp $a7c5			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.88ca					CallProcedure:
.88ca	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.88cc	b1 30		lda ($30),y			lda 	(codePtr),y
.88ce	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.88d0	f0 0c		beq $88de			beq 	_CPEndParam
.88d2					_CPParamLoop:
.88d2	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue 				; get parameter onto stack
.88d5	e8		inx				inx 								; bump next stack
.88d6	b1 30		lda ($30),y			lda 	(codePtr),y
.88d8	c8		iny				iny
.88d9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.88db	f0 f5		beq $88d2			beq 	_CPParamLoop
.88dd	88		dey				dey 								; unpick.
.88de					_CPEndParam:
.88de	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.88e1	c8		iny				iny									; skip right bracket
.88e2	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.88e4	20 85 a6	jsr $a685			jsr 	StackOpen
.88e7	20 c9 a6	jsr $a6c9			jsr 	STKSaveCodePosition 		; save loop position
.88ea	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.88ed	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.88ef	ad 10 04	lda $0410			lda 	NSMantissa1
.88f2	85 37		sta $37				sta 	zTemp0+1
.88f4	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.88f6	b2 36		lda ($36)			lda 	(zTemp0)
.88f8	85 30		sta $30				sta 	safePtr
.88fa	b1 36		lda ($36),y			lda 	(zTemp0),y
.88fc	85 31		sta $31				sta 	safePtr+1
.88fe	c8		iny				iny
.88ff	b1 36		lda ($36),y			lda 	(zTemp0),y
.8901	85 32		sta $32				sta 	safePtr+2
.8903	c8		iny				iny
.8904	b1 36		lda ($36),y			lda 	(zTemp0),y
.8906	85 33		sta $33				sta 	safePtr+3
.8908	c8		iny				iny 								; get Y offset -> Y
.8909	b1 36		lda ($36),y			lda 	(zTemp0),y
.890b	a8		tay				tay
.890c	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.890e	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.8911	f0 13		beq $8926			beq 	_ParamExit 					; if so, exit.
.8913					_ParamExtract:
.8913	ca		dex				dex 								; put a local term on the level before
.8914	20 94 87	jsr $8794			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8917	20 cc 86	jsr $86cc			jsr 	AssignVariable 				; assign stacked value to the variable.
.891a	e8		inx				inx 								; advance to next parameter to do.
.891b	e8		inx				inx
.891c	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.891f	f0 05		beq $8926			beq 	_ParamExit
.8921	20 58 8d	jsr $8d58			jsr 	CheckComma 					; comma seperating parameters
.8924	80 ed		bra $8913			bra 	_ParamExtract
.8926					_ParamExit:
.8926	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; check )
.8929	60		rts				rts 								; and continue from here
.892a					Command_ENDPROC:
.892a	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.892c	a2 14		ldx #$14			ldx 	#ERRID_PROC
.892e	20 b1 a6	jsr $a6b1			jsr 	StackCheckFrame
.8931	20 da a6	jsr $a6da			jsr 	STKLoadCodePosition 		; restore code position
.8934	20 a3 a6	jsr $a6a3			jsr 	StackClose
.8937	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8938					Command_Read:
.8938	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.893a	20 f2 97	jsr $97f2			jsr 	EvaluateTerm
.893d	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8940	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8942	f0 4a		beq $898e			beq 	_CRSyntax 					; check reference (bit 0)
.8944	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs 			; swap code and data
.8947	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.894a	d0 20		bne $896c			bne 	_CRContinueData
.894c					_CRKeepSearching:
.894c	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.894e	aa		tax				tax
.894f	20 ab 8c	jsr $8cab			jsr 	ScanForward
.8952	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8954	f0 16		beq $896c			beq 	_CRHaveData 				; found it
.8956	18		clc				clc
.8957	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8959	65 30		adc $30				adc 	codePtr
.895b	85 30		sta $30				sta 	codePtr
.895d	90 02		bcc $8961			bcc 	_CREExit
.895f	e6 31		inc $31				inc 	codePtr+1
.8961					_CREExit:
.8961	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8963	b2 30		lda ($30)			lda 	(codePtr)
.8965	d0 e5		bne $894c			bne 	_CRKeepSearching
.8967	a9 0b		lda #$0b		lda	#11
.8969	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.896c					_CRHaveData:
.896c					_CRContinueData:
.896c	a2 01		ldx #$01			ldx 	#1
.896e	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8971	ca		dex				dex
.8972	20 cc 86	jsr $86cc			jsr		AssignVariable 				; do the assignment
.8975	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.8978	b1 30		lda ($30),y			lda 	(codePtr),y
.897a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.897c	d0 04		bne $8982			bne 	_CRSwapBack
.897e	c8		iny				iny 								; consume comma
.897f	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8982					_CRSwapBack:
.8982	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs			; swap them back.
.8985	b1 30		lda ($30),y			lda 	(codePtr),y
.8987	c8		iny				iny
.8988	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.898a	f0 ac		beq $8938			beq 	Command_Read 				; if so go round again.
.898c	88		dey				dey 								; unpick get.
.898d	60		rts				rts
.898e					_CRSyntax:
.898e	4c b6 9f	jmp $9fb6			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8991					RemCommand:
.8991	b1 30		lda ($30),y			lda 	(codePtr),y
.8993	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8995	d0 06		bne $899d			bne 	_RMExit
.8997	c8		iny				iny
.8998	98		tya				tya
.8999	38		sec				sec
.899a	71 30		adc ($30),y			adc 	(codePtr),y
.899c	a8		tay				tay
.899d					_RMExit:
.899d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.899e					Command_REPEAT:
.899e	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.89a0	20 85 a6	jsr $a685			jsr 	StackOpen
.89a3	20 c9 a6	jsr $a6c9			jsr 	STKSaveCodePosition 		; save loop position
.89a6	60		rts				rts
.89a7					Command_UNTIL:
.89a7	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.89a9	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.89ab	20 b1 a6	jsr $a6b1			jsr 	StackCheckFrame
.89ae	a2 00		ldx #$00			ldx 	#0
.89b0	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; work out the number
.89b3	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; check if zero
.89b6	f0 04		beq $89bc			beq 	_CULoopBack 				; if so keep looping
.89b8	20 a3 a6	jsr $a6a3			jsr 	StackClose		 			; return
.89bb	60		rts				rts
.89bc					_CULoopBack:
.89bc	20 da a6	jsr $a6da			jsr 	STKLoadCodePosition 		; loop back
.89bf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.89c0					Command_Restore:
.89c0	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs 			; swap code and data
.89c3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.89c5	85 30		sta $30				sta 	codePtr
.89c7	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.89c9	85 31		sta $31				sta 	codePtr+1
.89cb	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs 			; put them back
.89ce	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.89d0	8d 9b 04	sta $049b			sta 	dataPointer+4
.89d3	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.89d6	60		rts				rts
.89d7					SwapDataCodePtrs:
.89d7	da		phx				phx
.89d8	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.89da					_SDCPLoop:
.89da	b5 30		lda $30,x			lda 	safePtr,x
.89dc	48		pha				pha
.89dd	bd 97 04	lda $0497,x			lda 	dataPointer,x
.89e0	95 30		sta $30,x			sta 	safePtr,x
.89e2	68		pla				pla
.89e3	9d 97 04	sta $0497,x			sta 	dataPointer,x
.89e6	ca		dex				dex
.89e7	10 f1		bpl $89da			bpl 	_SDCPLoop
.89e9	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.89ec	8c 9b 04	sty $049b			sty 	dataPointer+4
.89ef	a8		tay				tay
.89f0	fa		plx				plx
.89f1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.89f2					EOLCommand:
.89f2	18		clc				clc
.89f3	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.89f5	65 30		adc $30				adc 	codePtr
.89f7	85 30		sta $30				sta 	codePtr
.89f9	90 02		bcc $89fd			bcc 	_CREExit
.89fb	e6 31		inc $31				inc 	codePtr+1
.89fd					_CREExit:
.89fd	80 0b		bra $8a0a			bra 	RunNewLine
.89ff					CommandRUN:
.89ff	20 f1 83	jsr $83f1			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a02	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a04	85 30		sta $30				sta 	codePtr
.8a06	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a08	85 31		sta $31				sta 	codePtr+1
.8a0a					RUNNewLine:
.8a0a	b2 30		lda ($30)			lda 	(codePtr)
.8a0c	f0 72		beq $8a80			beq 	CRNoProgram         		; no then END.
.8a0e	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a10	9a		txs				txs
.8a11					RUNCodePointerLine:
.8a11	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a13					_CRIncMainLoop:
.8a13	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8a16	d0 19		bne $8a31			bne 	_CRNoBreakCheck
.8a18	20 67 aa	jsr $aa67			jsr 	EXTBreakCheck 				; break check
.8a1b	f0 5e		beq $8a7b			beq 	_CRBreak
.8a1d	64 01		stz $01				stz 	1 							; access I/O Page 0
.8a1f	38		sec				sec 								; calculate timer - LastTick
.8a20	ad 59 d6	lda $d659			lda 	$D659
.8a23	aa		tax				tax 								; saving timer in X
.8a24	ed 2d 06	sbc $062d			sbc 	LastTick
.8a27	c9 07		cmp #$07			cmp 	#7
.8a29	90 06		bcc $8a31			bcc 	_NoFireTick 				; if < 7 clocks don't fire.
.8a2b	8e 2d 06	stx $062d			stx 	LastTick 					; update last timer
.8a2e	20 6d b9	jsr $b96d			jsr 	TickHandler 				; go do the code.
.8a31					_NoFireTick:
.8a31					_CRNoBreakCheck:
.8a31	c8		iny				iny
.8a32					_CRMainLoop:
.8a32	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8a35	b1 30		lda ($30),y			lda 	(codePtr),y
.8a37	10 10		bpl $8a49			bpl 	_CRNotKeyword
.8a39	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8a3b	b0 04		bcs $8a41			bcs 	_CRIsKeyword
.8a3d	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8a3f	b0 34		bcs $8a75			bcs		_CRSyntaxError
.8a41					_CRIsKeyword:
.8a41	c8		iny				iny 								; consume command
.8a42	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8a43	aa		tax				tax 								; put in X for vector jump
.8a44	20 78 8a	jsr $8a78			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8a47	80 e9		bra $8a32			bra 	_CRMainLoop 				; and loop round
.8a49					_CRNotKeyword:
.8a49	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8a4b	f0 c6		beq $8a13			beq 	_CRIncMainLoop
.8a4d	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8a4f	90 05		bcc $8a56			bcc 	_CRNotVariable
.8a51					_CRGoLet:
.8a51	20 90 86	jsr $8690			jsr 	LetCommand
.8a54	80 dc		bra $8a32			bra 	_CRMainLoop
.8a56					_CRNotVariable:
.8a56	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8a58	f0 f7		beq $8a51			beq 	_CRGoLet
.8a5a	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8a5c	f0 f3		beq $8a51			beq 	_CRGoLet
.8a5e	c9 21		cmp #$21			cmp 	#KWD_PLING
.8a60	f0 ef		beq $8a51			beq 	_CRGoLet
.8a62	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8a64	f0 09		beq $8a6f			beq 	_CRGoRem
.8a66	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8a68	d0 0b		bne $8a75			bne 	_CRSyntaxError
.8a6a	20 11 82	jsr $8211			jsr 	LabelHere
.8a6d	80 c3		bra $8a32			bra 	_CRMainLoop
.8a6f					_CRGoRem:
.8a6f	c8		iny				iny
.8a70	20 91 89	jsr $8991			jsr 	RemCommand
.8a73	80 bd		bra $8a32			bra 	_CRMainLoop
.8a75					_CRSyntaxError:
.8a75	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.8a78					_CRCallVector0:
.8a78	7c 16 8b	jmp ($8b16,x)			jmp 	(VectorSet0,x)
.8a7b					_CRBreak:
.8a7b	a9 01		lda #$01		lda	#1
.8a7d	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.8a80					CRNoProgram:
.8a80	4c 16 85	jmp $8516			jmp 	EndCommand
.8a83					Shift1Command:
.8a83	b1 30		lda ($30),y			lda 	(codePtr),y
.8a85	c8		iny				iny
.8a86	0a		asl a				asl 	a
.8a87	aa		tax				tax
.8a88	7c b2 8b	jmp ($8bb2,x)			jmp 	(VectorSet1,x)
.8a8b					Shift2Command:
.8a8b	b1 30		lda ($30),y			lda 	(codePtr),y
.8a8d	c8		iny				iny
.8a8e	0a		asl a				asl 	a
.8a8f	aa		tax				tax
.8a90	7c cc 8b	jmp ($8bcc,x)			jmp 	(VectorSet2,x)
.8a93					Unused1:
.8a93					Unused2:
.8a93					Unused3:
.8a93					Unused4:
.8a93	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
>8a96							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8a96					VectorSetPunc:
>8a96	56 90					.word	ShiftLeft                        ; $00 <<
>8a98	0d 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8a9a	03 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8a9c	b6 9f					.word	SyntaxError                      ; $03 !!3
>8a9e	b6 9f					.word	SyntaxError                      ; $04 ><
>8aa0	17 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8aa2	59 90					.word	ShiftRight                       ; $06 >>
>8aa4	b6 9f					.word	SyntaxError                      ; $07 !!7
>8aa6	b6 9f					.word	SyntaxError                      ; $08 !!8
>8aa8	b6 9f					.word	SyntaxError                      ; $09 !!9
>8aaa	b6 9f					.word	SyntaxError                      ; $0a !!10
>8aac	b6 9f					.word	SyntaxError                      ; $0b !!11
>8aae	b6 9f					.word	SyntaxError                      ; $0c !!12
>8ab0	b6 9f					.word	SyntaxError                      ; $0d !!13
>8ab2	b6 9f					.word	SyntaxError                      ; $0e !!14
>8ab4	b6 9f					.word	SyntaxError                      ; $0f !!15
>8ab6	b6 9f					.word	SyntaxError                      ; $10 @
>8ab8	b6 9f					.word	SyntaxError                      ; $11 !!17
>8aba	b6 9f					.word	SyntaxError                      ; $12 !!18
>8abc	b6 9f					.word	SyntaxError                      ; $13 [
>8abe	da 8e					.word	IntegerDivide                    ; $14 \
>8ac0	b6 9f					.word	SyntaxError                      ; $15 ]
>8ac2	e7 91					.word	EorInteger                       ; $16 ^
>8ac4	b6 9f					.word	SyntaxError                      ; $17 _
>8ac6	b6 9f					.word	SyntaxError                      ; $18 `
>8ac8	b6 9f					.word	SyntaxError                      ; $19 !!25
>8aca	b6 9f					.word	SyntaxError                      ; $1a !!26
>8acc	b6 9f					.word	SyntaxError                      ; $1b {
>8ace	a1 91					.word	OraInteger                       ; $1c |
>8ad0	b6 9f					.word	SyntaxError                      ; $1d }
>8ad2	b6 9f					.word	SyntaxError                      ; $1e ~
>8ad4	b6 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8ad6	b6 9f					.word	SyntaxError                      ; $20
>8ad8	2d 92					.word	WordIndirect                     ; $21 !
>8ada	b6 9f					.word	SyntaxError                      ; $22 "
>8adc	b6 9f					.word	SyntaxError                      ; $23 #
>8ade	b6 9f					.word	SyntaxError                      ; $24 $
>8ae0	27 8f					.word	IntegerModulus                   ; $25 %
>8ae2	5b 91					.word	AndInteger                       ; $26 &
>8ae4	b6 9f					.word	SyntaxError                      ; $27 '
>8ae6	b6 9f					.word	SyntaxError                      ; $28 (
>8ae8	b6 9f					.word	SyntaxError                      ; $29 )
>8aea	9c 8f					.word	MulInteger                       ; $2a *
>8aec	ed 90					.word	AddInteger                       ; $2b +
>8aee	b6 9f					.word	SyntaxError                      ; $2c ,
>8af0	30 91					.word	SubInteger                       ; $2d -
>8af2	b6 9f					.word	SyntaxError                      ; $2e .
>8af4	18 94					.word	FDivideCommand                   ; $2f /
>8af6	b6 9f					.word	SyntaxError                      ; $30 0
>8af8	b6 9f					.word	SyntaxError                      ; $31 1
>8afa	b6 9f					.word	SyntaxError                      ; $32 2
>8afc	b6 9f					.word	SyntaxError                      ; $33 3
>8afe	b6 9f					.word	SyntaxError                      ; $34 4
>8b00	b6 9f					.word	SyntaxError                      ; $35 5
>8b02	b6 9f					.word	SyntaxError                      ; $36 6
>8b04	b6 9f					.word	SyntaxError                      ; $37 7
>8b06	b6 9f					.word	SyntaxError                      ; $38 8
>8b08	b6 9f					.word	SyntaxError                      ; $39 9
>8b0a	b6 9f					.word	SyntaxError                      ; $3a :
>8b0c	b6 9f					.word	SyntaxError                      ; $3b ;
>8b0e	ef 8d					.word	BinaryCompareLess                ; $3c <
>8b10	e5 8d					.word	BinaryCompareEqual               ; $3d =
>8b12	f9 8d					.word	BinaryCompareGreater             ; $3e >
>8b14	54 92					.word	ByteIndirect                     ; $3f ?
.8b16					VectorSet0:
>8b16	f2 89					.word	EOLCommand                       ; $80 !0:EOF
>8b18	83 8a					.word	Shift1Command                    ; $81 !1:SH1
>8b1a	8b 8a					.word	Shift2Command                    ; $82 !2:SH2
>8b1c	88 99					.word	AbsUnary                         ; $83 ABS(
>8b1e	98 99					.word	AllocUnary                       ; $84 ALLOC(
>8b20	08 9a					.word	AscUnary                         ; $85 ASC(
>8b22	d3 9b					.word	ChrUnary                         ; $86 CHR$(
>8b24	26 a4					.word	UnaryEvent                       ; $87 EVENT(
>8b26	e1 8d					.word	UnaryFalse                       ; $88 FALSE
>8b28	15 9a					.word	FracUnary                        ; $89 FRAC(
>8b2a	bc a3					.word	UnaryHit                         ; $8a HIT(
>8b2c	2b 9a					.word	IntUnary                         ; $8b INT(
>8b2e	92 9b					.word	IsValUnary                       ; $8c ISVAL(
>8b30	b6 a4					.word	UnaryJoyB                        ; $8d JOYB(
>8b32	8f a4					.word	UnaryJoyX                        ; $8e JOYX(
>8b34	92 a4					.word	UnaryJoyY                        ; $8f JOYY(
>8b36	ad 9c					.word	Unary_Left                       ; $90 LEFT$(
>8b38	3d 9a					.word	LenUnary                         ; $91 LEN(
>8b3a	5b 9a					.word	Unary_Max                        ; $92 MAX(
>8b3c	d7 9c					.word	Unary_Mid                        ; $93 MID$(
>8b3e	57 9a					.word	Unary_Min                        ; $94 MIN(
>8b40	b2 9a					.word	Unary_Not                        ; $95 NOT(
>8b42	b6 9f					.word	SyntaxError                      ; $96 PLAYING(
>8b44	c8 9a					.word	Unary_Random                     ; $97 RANDOM(
>8b46	bd 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8b48	e7 9a					.word	Unary_Rnd                        ; $99 RND(
>8b4a	68 9b					.word	SgnUnary                         ; $9a SGN(
>8b4c	e5 9b					.word	SpcUnary                         ; $9b SPC(
>8b4e	00 9c					.word	Unary_Str                        ; $9c STR$(
>8b50	ca a4					.word	UnaryTimer                       ; $9d TIMER(
>8b52	d5 8d					.word	UnaryTrue                        ; $9e TRUE
>8b54	88 9b					.word	ValUnary                         ; $9f VAL(
>8b56	19 85					.word	ForCommand                       ; $a0 FOR
>8b58	66 86					.word	IfCommand                        ; $a1 IF
>8b5a	93 8a					.word	Unused1                          ; $a2 PROC
>8b5c	9e 89					.word	Command_REPEAT                   ; $a3 REPEAT
>8b5e	21 8d					.word	Command_WHILE                    ; $a4 WHILE
>8b60	8f 86					.word	EndIf                            ; $a5 ENDIF
>8b62	2a 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8b64	d3 85					.word	NextCommand                      ; $a7 NEXT
>8b66	93 8a					.word	Unused4                          ; $a8 THEN
>8b68	a7 89					.word	Command_UNTIL                    ; $a9 UNTIL
>8b6a	42 8d					.word	Command_WEND                     ; $aa WEND
>8b6c	b6 9f					.word	SyntaxError                      ; $ab BY
>8b6e	b7 83					.word	CallCommand                      ; $ac CALL
>8b70	5e a1					.word	CircleCommand                    ; $ad CIRCLE
>8b72	f1 83					.word	ClearCommand                     ; $ae CLEAR
>8b74	49 84					.word	ClearScreen                      ; $af CLS
>8b76	b6 9f					.word	SyntaxError                      ; $b0 COLOR
>8b78	b6 9f					.word	SyntaxError                      ; $b1 COLOUR
>8b7a	51 84					.word	Command_Data                     ; $b2 DATA
>8b7c	59 84					.word	DimCommand                       ; $b3 DIM
>8b7e	93 8a					.word	Unused3                          ; $b4 DOWNTO
>8b80	88 86					.word	ElseCode                         ; $b5 ELSE
>8b82	b6 9f					.word	SyntaxError                      ; $b6 FROM
>8b84	8a a3					.word	GfxCommand                       ; $b7 GFX
>8b86	2c 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8b88	4a 86					.word	GotoCommand                      ; $b9 GOTO
>8b8a	b6 9f					.word	SyntaxError                      ; $ba HERE
>8b8c	88 a1					.word	ImageCommand                     ; $bb IMAGE
>8b8e	90 86					.word	LetCommand                       ; $bc LET
>8b90	dd a1					.word	LineCommand                      ; $bd LINE
>8b92	86 87					.word	Command_LOCAL                    ; $be LOCAL
>8b94	b6 9f					.word	SyntaxError                      ; $bf OFF
>8b96	b6 9f					.word	SyntaxError                      ; $c0 ON
>8b98	b6 9f					.word	SyntaxError                      ; $c1 OUTLINE
>8b9a	e2 a3					.word	PaletteCommand                   ; $c2 PALETTE
>8b9c	d6 a1					.word	PlotCommand                      ; $c3 PLOT
>8b9e	5d 88					.word	Command_Print                    ; $c4 PRINT
>8ba0	38 89					.word	Command_Read                     ; $c5 READ
>8ba2	5a a1					.word	RectangleCommand                 ; $c6 RECT
>8ba4	91 89					.word	RemCommand                       ; $c7 REM
>8ba6	3c 86					.word	Command_RETURN                   ; $c8 RETURN
>8ba8	b6 9f					.word	SyntaxError                      ; $c9 SOLID
>8baa	f8 a5					.word	SoundCommand                     ; $ca SOUND
>8bac	69 a1					.word	SpriteCommand                    ; $cb SPRITE
>8bae	a5 a1					.word	TextCommand                      ; $cc TEXT
>8bb0	93 8a					.word	Unused2                          ; $cd TO
.8bb2					VectorSet1:
>8bb2	b6 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bb4	b6 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bb6	b6 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bb8	88 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8bba	a7 83					.word	AssertCommand                    ; $84 ASSERT
>8bbc	2a a3					.word	BitmapCtrl                       ; $85 BITMAP
>8bbe	16 85					.word	EndCommand                       ; $86 END
>8bc0	e5 86					.word	Command_List                     ; $87 LIST
>8bc2	4d 88					.word	NewCommand                       ; $88 NEW
>8bc4	c0 89					.word	Command_Restore                  ; $89 RESTORE
>8bc6	ff 89					.word	CommandRUN                       ; $8a RUN
>8bc8	6f a3					.word	SpritesCtrl                      ; $8b SPRITES
>8bca	54 8c					.word	StopCommand                      ; $8c STOP
.8bcc					VectorSet2:
>8bcc	b6 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bce	b6 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bd0	b6 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bd2	75 9e					.word	Assemble_adc                     ; $83 ADC
>8bd4	6d 9e					.word	Assemble_and                     ; $84 AND
>8bd6	89 9e					.word	Assemble_asl                     ; $85 ASL
>8bd8	f3 9e					.word	Assemble_bcc                     ; $86 BCC
>8bda	f7 9e					.word	Assemble_bcs                     ; $87 BCS
>8bdc	ff 9e					.word	Assemble_beq                     ; $88 BEQ
>8bde	b6 9e					.word	Assemble_bit                     ; $89 BIT
>8be0	e7 9e					.word	Assemble_bmi                     ; $8a BMI
>8be2	fb 9e					.word	Assemble_bne                     ; $8b BNE
>8be4	e3 9e					.word	Assemble_bpl                     ; $8c BPL
>8be6	03 9f					.word	Assemble_bra                     ; $8d BRA
>8be8	07 9f					.word	Assemble_brk                     ; $8e BRK
>8bea	eb 9e					.word	Assemble_bvc                     ; $8f BVC
>8bec	ef 9e					.word	Assemble_bvs                     ; $90 BVS
>8bee	0f 9f					.word	Assemble_clc                     ; $91 CLC
>8bf0	63 9f					.word	Assemble_cld                     ; $92 CLD
>8bf2	23 9f					.word	Assemble_cli                     ; $93 CLI
>8bf4	53 9f					.word	Assemble_clv                     ; $94 CLV
>8bf6	81 9e					.word	Assemble_cmp                     ; $95 CMP
>8bf8	ca 9e					.word	Assemble_cpx                     ; $96 CPX
>8bfa	c5 9e					.word	Assemble_cpy                     ; $97 CPY
>8bfc	a7 9e					.word	Assemble_dec                     ; $98 DEC
>8bfe	5f 9f					.word	Assemble_dex                     ; $99 DEX
>8c00	3b 9f					.word	Assemble_dey                     ; $9a DEY
>8c02	71 9e					.word	Assemble_eor                     ; $9b EOR
>8c04	ac 9e					.word	Assemble_inc                     ; $9c INC
>8c06	6f 9f					.word	Assemble_inx                     ; $9d INX
>8c08	5b 9f					.word	Assemble_iny                     ; $9e INY
>8c0a	de 9e					.word	Assemble_jmp                     ; $9f JMP
>8c0c	d9 9e					.word	Assemble_jsr                     ; $a0 JSR
>8c0e	7d 9e					.word	Assemble_lda                     ; $a1 LDA
>8c10	a2 9e					.word	Assemble_ldx                     ; $a2 LDX
>8c12	c0 9e					.word	Assemble_ldy                     ; $a3 LDY
>8c14	93 9e					.word	Assemble_lsr                     ; $a4 LSR
>8c16	73 9f					.word	Assemble_nop                     ; $a5 NOP
>8c18	69 9e					.word	Assemble_ora                     ; $a6 ORA
>8c1a	1f 9f					.word	Assemble_pha                     ; $a7 PHA
>8c1c	0b 9f					.word	Assemble_php                     ; $a8 PHP
>8c1e	67 9f					.word	Assemble_phx                     ; $a9 PHX
>8c20	27 9f					.word	Assemble_phy                     ; $aa PHY
>8c22	2f 9f					.word	Assemble_pla                     ; $ab PLA
>8c24	13 9f					.word	Assemble_plp                     ; $ac PLP
>8c26	7b 9f					.word	Assemble_plx                     ; $ad PLX
>8c28	37 9f					.word	Assemble_ply                     ; $ae PLY
>8c2a	8e 9e					.word	Assemble_rol                     ; $af ROL
>8c2c	98 9e					.word	Assemble_ror                     ; $b0 ROR
>8c2e	1b 9f					.word	Assemble_rti                     ; $b1 RTI
>8c30	2b 9f					.word	Assemble_rts                     ; $b2 RTS
>8c32	85 9e					.word	Assemble_sbc                     ; $b3 SBC
>8c34	17 9f					.word	Assemble_sec                     ; $b4 SEC
>8c36	77 9f					.word	Assemble_sed                     ; $b5 SED
>8c38	33 9f					.word	Assemble_sei                     ; $b6 SEI
>8c3a	79 9e					.word	Assemble_sta                     ; $b7 STA
>8c3c	6b 9f					.word	Assemble_stp                     ; $b8 STP
>8c3e	9d 9e					.word	Assemble_stx                     ; $b9 STX
>8c40	bb 9e					.word	Assemble_sty                     ; $ba STY
>8c42	b1 9e					.word	Assemble_stz                     ; $bb STZ
>8c44	4f 9f					.word	Assemble_tax                     ; $bc TAX
>8c46	4b 9f					.word	Assemble_tay                     ; $bd TAY
>8c48	d4 9e					.word	Assemble_trb                     ; $be TRB
>8c4a	cf 9e					.word	Assemble_tsb                     ; $bf TSB
>8c4c	57 9f					.word	Assemble_tsx                     ; $c0 TSX
>8c4e	3f 9f					.word	Assemble_txa                     ; $c1 TXA
>8c50	47 9f					.word	Assemble_txs                     ; $c2 TXS
>8c52	43 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8c54					StopCommand:
.8c54	a9 08		lda #$08		lda	#8
.8c56	4c 69 8d	jmp $8d69		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8c59					ProcedureScan:
.8c59	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8c5b	85 30		sta $30				sta 	codePtr
.8c5d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8c5f	85 31		sta $31				sta 	codePtr+1
.8c61					_PSLoop:
.8c61	b2 30		lda ($30)			lda 	(codePtr)
.8c63	f0 42		beq $8ca7			beq 	_PSExit
.8c65	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8c67	b1 30		lda ($30),y			lda 	(codePtr),y
.8c69	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8c6b	d0 2d		bne $8c9a			bne 	_PSNext
.8c6d	c8		iny				iny 								; get the address of the record to zTemp0 and
.8c6e	b1 30		lda ($30),y			lda 	(codePtr),y
.8c70	29 c0		and #$c0			and 	#$C0
.8c72	c9 40		cmp #$40			cmp 	#$40
.8c74	d0 32		bne $8ca8			bne 	_PSSyntax
.8c76	b1 30		lda ($30),y			lda 	(codePtr),y
.8c78	18		clc				clc
.8c79	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8c7b	85 37		sta $37				sta 	zTemp0+1
.8c7d	c8		iny				iny 								; LSB
.8c7e	b1 30		lda ($30),y			lda 	(codePtr),y
.8c80	85 36		sta $36				sta 	zTemp0
.8c82	c8		iny				iny 								; character after variable call.
.8c83	98		tya				tya 								; save Y offset at +7
.8c84	a0 07		ldy #$07			ldy 	#7
.8c86	91 36		sta ($36),y			sta 	(zTemp0),y
.8c88	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8c8a	a0 02		ldy #$02			ldy 	#2
.8c8c	91 36		sta ($36),y			sta 	(zTemp0),y
.8c8e	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8c90					_PSCopy:
.8c90	b5 30		lda $30,x			lda 	safePtr,x
.8c92	c8		iny				iny
.8c93	91 36		sta ($36),y			sta 	(zTemp0),y
.8c95	e8		inx				inx
.8c96	e0 04		cpx #$04			cpx 	#4
.8c98	d0 f6		bne $8c90			bne 	_PSCopy
.8c9a					_PSNext:
.8c9a	18		clc				clc
.8c9b	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8c9d	65 30		adc $30				adc 	codePtr
.8c9f	85 30		sta $30				sta 	codePtr
.8ca1	90 02		bcc $8ca5			bcc 	_CREExit
.8ca3	e6 31		inc $31				inc 	codePtr+1
.8ca5					_CREExit:
.8ca5	80 ba		bra $8c61			bra 	_PSLoop
.8ca7					_PSExit:
.8ca7	60		rts				rts
.8ca8					_PSSyntax:
.8ca8	4c b6 9f	jmp $9fb6			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8cab					ScanForward:
.8cab	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8cad	86 37		stx $37				stx 	zTemp0+1
.8caf	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8cb1					_ScanLoop:
.8cb1	b1 30		lda ($30),y			lda 	(codePtr),y
.8cb3	c8		iny				iny
.8cb4	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8cb6	d0 0e		bne $8cc6			bne 	_ScanGoNext
.8cb8	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8cba	f0 04		beq $8cc0			beq 	_ScanMatch
.8cbc	c5 37		cmp $37				cmp 	zTemp0+1
.8cbe	d0 06		bne $8cc6			bne 	_ScanGoNext
.8cc0					_ScanMatch:
.8cc0	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8cc2	d0 01		bne $8cc5			bne 	_ScanNotEndEOL
.8cc4	88		dey				dey
.8cc5					_ScanNotEndEOL:
.8cc5	60		rts				rts
.8cc6					_ScanGoNext:
.8cc6	20 cb 8c	jsr $8ccb			jsr  	ScanForwardOne
.8cc9	80 e6		bra $8cb1			bra 	_ScanLoop
.8ccb					ScanForwardOne:
.8ccb	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8ccd	90 3e		bcc $8d0d			bcc 	_SFWExit
.8ccf	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8cd1	90 18		bcc $8ceb			bcc 	_ScanSkipOne
.8cd3	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8cd5	b0 2f		bcs $8d06			bcs 	_ScanSkipData
.8cd7	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8cd9	90 32		bcc $8d0d			bcc 	_SFWExit 					; if not, ordinary keywords.
.8cdb	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8cdd	b0 2e		bcs $8d0d			bcs 	_SFWExit
.8cdf	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8ce1	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8ce3	b0 28		bcs $8d0d			bcs 	_SFWExit
.8ce5	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8ce7	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8ce9	80 22		bra $8d0d			bra 	_SFWExit
.8ceb					_ScanSkipOne:
.8ceb	c8		iny				iny 								; consume the extra one.
.8cec	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8cee	d0 1d		bne $8d0d			bne 	_SFWExit
.8cf0	18		clc				clc
.8cf1	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8cf3	65 30		adc $30				adc 	codePtr
.8cf5	85 30		sta $30				sta 	codePtr
.8cf7	90 02		bcc $8cfb			bcc 	_CREExit
.8cf9	e6 31		inc $31				inc 	codePtr+1
.8cfb					_CREExit:
.8cfb	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8cfd	b2 30		lda ($30)			lda 	(codePtr)
.8cff	d0 0c		bne $8d0d			bne 	_SFWExit 					; if not zero, more to scan
.8d01	a9 13		lda #$13		lda	#19
.8d03	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.8d06					_ScanSkipData:
.8d06	88		dey				dey 								; point at data token
.8d07	c8		iny				iny
.8d08	98		tya				tya
.8d09	38		sec				sec
.8d0a	71 30		adc ($30),y			adc 	(codePtr),y
.8d0c	a8		tay				tay
.8d0d					_SFWExit:
.8d0d	60		rts				rts
.8d0e					ScanGetCurrentLineStep:
.8d0e	64 38		stz $38				stz 	zTemp1
.8d10	a0 03		ldy #$03			ldy 	#3
.8d12					_SGCLSLoop:
.8d12	b1 30		lda ($30),y			lda 	(codePtr),y
.8d14	c8		iny				iny
.8d15	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d17	f0 05		beq $8d1e			beq 	_SGCLSExit
.8d19	20 cb 8c	jsr $8ccb			jsr 	ScanForwardOne
.8d1c	80 f4		bra $8d12			bra 	_SGCLSLoop
.8d1e					_SGCLSExit:
.8d1e	a5 38		lda $38				lda 	zTemp1
.8d20	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8d21					Command_WHILE:
.8d21	5a		phy				phy 								; save position of the test
.8d22	a2 00		ldx #$00			ldx 	#0
.8d24	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; work out the number
.8d27	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; check if zero
.8d2a	f0 0e		beq $8d3a			beq 	_WHExitLoop 				; if so exit the loop
.8d2c	98		tya				tya 								; position *after* test.
.8d2d	7a		ply				ply 								; restore position before test, at WHILE
.8d2e	88		dey				dey
.8d2f	48		pha				pha 								; push after test on the stack
.8d30	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8d32	20 85 a6	jsr $a685			jsr 	StackOpen
.8d35	20 c9 a6	jsr $a6c9			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8d38	7a		ply				ply 								; restore the position *after* the test
.8d39	60		rts				rts
.8d3a					_WHExitLoop:
.8d3a	68		pla				pla 								; throw post loop position
.8d3b	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8d3d	aa		tax				tax
.8d3e	20 ab 8c	jsr $8cab			jsr 	ScanForward
.8d41	60		rts				rts
.8d42					Command_WEND:
.8d42	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8d44	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8d46	20 b1 a6	jsr $a6b1			jsr 	StackCheckFrame
.8d49	20 da a6	jsr $a6da			jsr 	STKLoadCodePosition 		; loop back
.8d4c	20 a3 a6	jsr $a6a3			jsr 	StackClose		 			; erase the frame
.8d4f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8d50					CheckRightBracket:
.8d50	b1 30		lda ($30),y			lda 	(codePtr),y
.8d52	c8		iny				iny
.8d53	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8d55	d0 0f		bne $8d66			bne 	CNAFail
.8d57	60		rts				rts
.8d58					CheckComma:
.8d58	b1 30		lda ($30),y			lda 	(codePtr),y
.8d5a	c8		iny				iny
.8d5b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8d5d	d0 07		bne $8d66			bne 	CNAFail
.8d5f	60		rts				rts
.8d60					CheckNextA:
.8d60	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8d62	d0 02		bne $8d66			bne 	CNAFail
.8d64	c8		iny				iny 								; skip character
.8d65	60		rts				rts 								; and exit
.8d66					CNAFail:
.8d66	4c b6 9f	jmp $9fb6			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8d69					ErrorHandler:
.8d69	a8		tay				tay 								; find the error text
.8d6a	f0 49		beq $8db5			beq 	_EHEnd
.8d6c	a2 00		ldx #$00			ldx 	#0
.8d6e	a9 cf		lda #$cf			lda 	#((ErrorText) & $FF)
.8d70	85 36		sta $36				sta 	0+zTemp0
.8d72	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8d74	85 37		sta $37				sta 	1+zTemp0
.8d76					_EHFind:
.8d76	88		dey				dey 								; found the error text ?
.8d77	f0 0e		beq $8d87			beq 	_EHFound
.8d79					_EHFindZero:
.8d79	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8d7b	e6 36		inc $36				inc 	zTemp0
.8d7d	d0 02		bne $8d81			bne 	_EHFNoCarry
.8d7f	e6 37		inc $37				inc 	zTemp0+1
.8d81					_EHFNoCarry:
.8d81	c9 00		cmp #$00			cmp 	#0
.8d83	d0 f4		bne $8d79			bne 	_EHFindZero
.8d85	80 ef		bra $8d76			bra 	_EHFind
.8d87					_EHFound:
.8d87	a5 36		lda $36				lda 	zTemp0 						; print message
.8d89	a6 37		ldx $37				ldx 	zTemp0+1
.8d8b	20 c2 8d	jsr $8dc2			jsr 	PrintStringXA
.8d8e	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8d90	b1 30		lda ($30),y			lda 	(codePtr),y
.8d92	d0 05		bne $8d99			bne 	_EHAtMsg
.8d94	c8		iny				iny
.8d95	b1 30		lda ($30),y			lda 	(codePtr),y
.8d97	f0 17		beq $8db0			beq 	_EHCREnd
.8d99					_EHAtMsg:
.8d99	a2 8d		ldx #$8d			ldx 	#_AtMsg >> 8 				; print " at "
.8d9b	a9 b8		lda #$b8			lda 	#_AtMsg & $FF
.8d9d	20 c2 8d	jsr $8dc2			jsr 	PrintStringXA
.8da0	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8da2	b1 30		lda ($30),y			lda 	(codePtr),y
.8da4	48		pha				pha
.8da5	c8		iny				iny
.8da6	b1 30		lda ($30),y			lda 	(codePtr),y
.8da8	aa		tax				tax
.8da9	68		pla				pla
.8daa	20 7b 92	jsr $927b			jsr 	LCLConvertInt16 				; convert XA to string
.8dad	20 c2 8d	jsr $8dc2			jsr 	PrintStringXA 				; and print it.
.8db0					_EHCREnd:
.8db0	a9 0d		lda #$0d			lda 	#13 						; new line
.8db2	20 c5 a7	jsr $a7c5			jsr 	EXTPrintCharacter
.8db5					_EHEnd:
.8db5	4c 58 83	jmp $8358			jmp 	WarmStart
>8db8	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8dc0	20 00
.8dc2					PrintStringXA:
.8dc2	5a		phy				phy
.8dc3	86 37		stx $37				stx 	zTemp0+1
.8dc5	85 36		sta $36				sta 	zTemp0
.8dc7	a0 00		ldy #$00			ldy 	#0
.8dc9					_PSXALoop:
.8dc9	b1 36		lda ($36),y			lda 	(zTemp0),y
.8dcb	f0 06		beq $8dd3			beq 	_PSXAExit
.8dcd	20 c5 a7	jsr $a7c5			jsr 	EXTPrintCharacter
.8dd0	c8		iny				iny
.8dd1	80 f6		bra $8dc9			bra 	_PSXALoop
.8dd3					_PSXAExit:
.8dd3	7a		ply				ply
.8dd4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8dd5					UnaryTrue:
.8dd5	fa		plx				plx
.8dd6					ReturnTrue:
.8dd6	a9 01		lda #$01			lda 	#1  						; set to 1
.8dd8	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.8ddb	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8ddd	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8de0	60		rts				rts
.8de1					UnaryFalse:
.8de1	fa		plx				plx
.8de2					ReturnFalse:
.8de2	4c 2c 9e	jmp $9e2c			jmp 	NSMSetZero 					; set it all to zero
.8de5					BinaryCompareEqual:
.8de5	fa		plx				plx
.8de6	20 21 8e	jsr $8e21			jsr 	CompareBaseCode
.8de9	c9 00		cmp #$00			cmp 	#0
.8deb	f0 e9		beq $8dd6			beq 	ReturnTrue
.8ded	80 f3		bra $8de2			bra 	ReturnFalse
.8def					BinaryCompareLess:
.8def	fa		plx				plx
.8df0	20 21 8e	jsr $8e21			jsr 	CompareBaseCode
.8df3	c9 ff		cmp #$ff			cmp 	#$FF
.8df5	f0 df		beq $8dd6			beq 	ReturnTrue
.8df7	80 e9		bra $8de2			bra 	ReturnFalse
.8df9					BinaryCompareGreater:
.8df9	fa		plx				plx
.8dfa	20 21 8e	jsr $8e21			jsr 	CompareBaseCode
.8dfd	c9 01		cmp #$01			cmp 	#1
.8dff	f0 d5		beq $8dd6			beq 	ReturnTrue
.8e01	80 df		bra $8de2			bra 	ReturnFalse
.8e03					BinaryCompareNotEqual:
.8e03	fa		plx				plx
.8e04	20 21 8e	jsr $8e21			jsr 	CompareBaseCode
.8e07	c9 00		cmp #$00			cmp 	#0
.8e09	d0 cb		bne $8dd6			bne 	ReturnTrue
.8e0b	80 d5		bra $8de2			bra 	ReturnFalse
.8e0d					BinaryCompareLessEqual:
.8e0d	fa		plx				plx
.8e0e	20 21 8e	jsr $8e21			jsr 	CompareBaseCode
.8e11	c9 01		cmp #$01			cmp 	#1
.8e13	d0 c1		bne $8dd6			bne 	ReturnTrue
.8e15	80 cb		bra $8de2			bra 	ReturnFalse
.8e17					BinaryCompareGreaterEqual:
.8e17	fa		plx				plx
.8e18	20 21 8e	jsr $8e21			jsr 	CompareBaseCode
.8e1b	c9 ff		cmp #$ff			cmp 	#$FF
.8e1d	d0 b7		bne $8dd6			bne 	ReturnTrue
.8e1f	80 c1		bra $8de2			bra 	ReturnFalse
.8e21					CompareBaseCode:
.8e21	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; make both values if references.
.8e24	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8e27	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e2a	29 10		and #$10			and 	#NSTString
.8e2c	d0 40		bne $8e6e			bne 	_CBCString
.8e2e	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8e31	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8e34	d0 3b		bne $8e71			bne 	_CBCFloat
.8e36	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8e39	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e3c	29 08		and #$08			and 	#NSTFloat
.8e3e	d0 31		bne $8e71			bne 	_CBCFloat
.8e40	20 74 8e	jsr $8e74			jsr 	CompareFixMinusZero
.8e43	e8		inx				inx
.8e44	20 74 8e	jsr $8e74			jsr 	CompareFixMinusZero
.8e47	ca		dex				dex
.8e48	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8e4b	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8e4e	10 0b		bpl $8e5b			bpl 	_CDCSameSign
.8e50	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8e53	30 16		bmi $8e6b			bmi 	_CBCLess 					; return $FF
.8e55					_CBCGreater:
.8e55	a9 01		lda #$01			lda 	#1
.8e57	60		rts				rts
.8e58					_CBCEqual:
.8e58	a9 00		lda #$00			lda 	#0
.8e5a	60		rts				rts
.8e5b					_CDCSameSign:
.8e5b	20 c7 90	jsr $90c7			jsr 	SubTopTwoStack 				; unsigned subtract
.8e5e	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; or the mantissa together
.8e61	f0 f5		beq $8e58			beq 	_CBCEqual 					; -0 == 0
.8e63	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8e66	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8e69	10 ea		bpl $8e55			bpl 	_CBCGreater
.8e6b					_CBCLess:
.8e6b	a9 ff		lda #$ff			lda 	#$FF
.8e6d	60		rts				rts
.8e6e					_CBCString:
.8e6e	4c 1d 90	jmp $901d			jmp 	CompareStrings
.8e71					_CBCFloat:
.8e71	4c fe 93	jmp $93fe			jmp 	CompareFloat
.8e74					CompareFixMinusZero:
.8e74	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero
.8e77	d0 03		bne $8e7c			bne 	_CFXMZNotZero
.8e79	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8e7c					_CFXMZNotZero:
.8e7c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8e7d					StringConcat:
.8e7d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8e80	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8e83	29 18		and #$18			and 	#NSBTypeMask
.8e85	c9 10		cmp #$10			cmp 	#NSTString
.8e87	d0 4e		bne $8ed7			bne		_SCType
.8e89	64 38		stz $38				stz 	zTemp1 						; counting total length
.8e8b	e8		inx				inx
.8e8c	20 aa 8e	jsr $8eaa			jsr 	_SCSetupZ0 					; setup for second
.8e8f	20 b5 8e	jsr $8eb5			jsr 	_SCLengthZ0 				; length for second
.8e92	ca		dex				dex
.8e93	20 aa 8e	jsr $8eaa			jsr 	_SCSetupZ0 					; setup for first
.8e96	20 b5 8e	jsr $8eb5			jsr 	_SCLengthZ0 				; length for first
.8e99	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8e9b	20 78 a7	jsr $a778			jsr 	StringTempAllocate
.8e9e	20 c8 8e	jsr $8ec8			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8ea1	e8		inx				inx
.8ea2	20 aa 8e	jsr $8eaa			jsr 	_SCSetupZ0 					; copy second out
.8ea5	20 c8 8e	jsr $8ec8			jsr 	_SCCopy
.8ea8	ca		dex				dex
.8ea9	60		rts				rts
.8eaa					_SCSetupZ0:
.8eaa	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8ead	85 36		sta $36				sta 	zTemp0
.8eaf	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8eb2	85 37		sta $37				sta 	zTemp0+1
.8eb4	60		rts				rts
.8eb5					_SCLengthZ0:
.8eb5	5a		phy				phy
.8eb6	a0 00		ldy #$00			ldy 	#0
.8eb8					_SCLenLoop:
.8eb8	b1 36		lda ($36),y			lda 	(zTemp0),y
.8eba	f0 0a		beq $8ec6			beq 	_SCLExit
.8ebc	c8		iny				iny
.8ebd	e6 38		inc $38				inc 	zTemp1
.8ebf	10 f7		bpl $8eb8			bpl		_SCLenLoop
.8ec1	a9 09		lda #$09		lda	#9
.8ec3	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.8ec6					_SCLExit:
.8ec6	7a		ply				ply
.8ec7	60		rts				rts
.8ec8					_SCCopy:
.8ec8	5a		phy				phy
.8ec9	a0 00		ldy #$00			ldy 	#0
.8ecb					_SCCopyLoop:
.8ecb	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ecd	f0 06		beq $8ed5			beq 	_SCCExit
.8ecf	20 b6 a7	jsr $a7b6			jsr 	StringTempWrite
.8ed2	c8		iny				iny
.8ed3	80 f6		bra $8ecb			bra 	_SCCopyLoop
.8ed5					_SCCExit:
.8ed5	7a		ply				ply
.8ed6	60		rts				rts
.8ed7					_SCType:
.8ed7	4c c0 9f	jmp $9fc0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8eda					IntegerDivide:
.8eda	fa		plx				plx
.8edb	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8ede	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ee1	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8ee2	0a		asl a				asl 	a
.8ee3	10 05		bpl $8eea			bpl 	_NotRef
.8ee5	48		pha				pha
.8ee6	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8ee9	68		pla				pla
.8eea					_NotRef:
.8eea	0a		asl a				asl 	a
.8eeb	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8eed	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8ef0	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8ef3	f0 03		beq $8ef8			beq 	_IntegerCode 				; if clear, then we have two integers
.8ef5	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.8ef8					_IntegerCode:
.8ef8	20 1a 8f	jsr $8f1a			jsr 	CheckDivideZero 			; do div zero check
.8efb	20 52 8f	jsr $8f52			jsr 	Int32Divide 				; do the division
.8efe	20 0f 90	jsr $900f			jsr 	CalculateSign 				; calculate result sign
.8f01					NSMCopyPlusTwoToZero:
.8f01	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f04	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8f07	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8f0a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8f0d	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8f10	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8f13	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8f16	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8f19	60		rts				rts
.8f1a					CheckDivideZero:
.8f1a	e8		inx				inx
.8f1b	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero
.8f1e	f0 02		beq $8f22			beq 	_CDVError
.8f20	ca		dex				dex
.8f21	60		rts				rts
.8f22					_CDVError:
.8f22	a9 03		lda #$03		lda	#3
.8f24	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.8f27					IntegerModulus:
.8f27	fa		plx				plx
.8f28	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f2b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f2e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f2f	0a		asl a				asl 	a
.8f30	10 05		bpl $8f37			bpl 	_NotRef
.8f32	48		pha				pha
.8f33	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f36	68		pla				pla
.8f37					_NotRef:
.8f37	0a		asl a				asl 	a
.8f38	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f3a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f3d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f40	f0 03		beq $8f45			beq 	_IntegerCode 				; if clear, then we have two integers
.8f42	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.8f45					_IntegerCode:
.8f45					IntegerModulusNoCheck:
.8f45	20 1a 8f	jsr $8f1a			jsr 	CheckDivideZero 			; do div zero check
.8f48	20 52 8f	jsr $8f52			jsr 	Int32Divide 				; do the division
.8f4b	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8f4e	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8f51	60		rts				rts
.8f52					Int32Divide:
.8f52	48		pha				pha 								; save AXY
.8f53	5a		phy				phy
.8f54	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8f57	20 28 9e	jsr $9e28			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8f5a	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8f5c					_I32DivideLoop:
.8f5c	e8		inx				inx
.8f5d	e8		inx				inx
.8f5e	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8f61	ca		dex				dex
.8f62	ca		dex				dex
.8f63	20 42 9e	jsr $9e42			jsr 	NSMRotateLeft
.8f66	20 92 8f	jsr $8f92			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f69	90 03		bcc $8f6e			bcc 	_I32DivideNoCarryIn
.8f6b	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8f6e					_I32DivideNoCarryIn:
.8f6e	88		dey				dey 								; loop round till division completed.
.8f6f	d0 eb		bne $8f5c			bne 	_I32DivideLoop
.8f71	7a		ply				ply 								; restore AXY and exit
.8f72	68		pla				pla
.8f73	60		rts				rts
.8f74					Int32ShiftDivide:
.8f74	48		pha				pha 								; save AY
.8f75	5a		phy				phy
.8f76	e8		inx				inx 								; clear S[X+2]
.8f77	e8		inx				inx
.8f78	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.8f7b	ca		dex				dex
.8f7c	ca		dex				dex
.8f7d	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.8f7f					_I32SDLoop:
.8f7f	20 92 8f	jsr $8f92			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f82	e8		inx				inx
.8f83	e8		inx				inx
.8f84	20 42 9e	jsr $9e42			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.8f87	ca		dex				dex
.8f88	ca		dex				dex
.8f89	20 42 9e	jsr $9e42			jsr 	NSMRotateLeft
.8f8c	88		dey				dey 	 							; do 31 times
.8f8d	d0 f0		bne $8f7f			bne 	_I32SDLoop
.8f8f	7a		ply				ply 								; restore AY and exit
.8f90	68		pla				pla
.8f91	60		rts				rts
.8f92					DivideCheckSubtract:
.8f92	20 c7 90	jsr $90c7			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.8f95	b0 04		bcs $8f9b			bcs 	_DCSExit 					; if carry set, then could do, exit
.8f97	20 a1 90	jsr $90a1			jsr 	AddTopTwoStack 				; add it back in
.8f9a	18		clc				clc 								; and return False
.8f9b					_DCSExit:
.8f9b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.8f9c					MulInteger:
.8f9c	fa		plx				plx
.8f9d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8fa0	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8fa3	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fa4	0a		asl a				asl 	a
.8fa5	10 05		bpl $8fac			bpl 	_NotRef
.8fa7	48		pha				pha
.8fa8	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fab	68		pla				pla
.8fac					_NotRef:
.8fac	0a		asl a				asl 	a 							; put MSB of type into A:7
.8fad	30 0b		bmi $8fba			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.8faf	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fb2	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fb5	f0 06		beq $8fbd			beq 	_IntegerCode 				; if clear, then we have two integers
.8fb7	4c d5 94	jmp $94d5			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.8fba					_StringData:
.8fba	4c ca 9f	jmp $9fca			jmp 	NotDoneError							; at least one string - don't know both are strings.
.8fbd					_IntegerCode:
.8fbd	20 ca 8f	jsr $8fca			jsr 	MultiplyShort
.8fc0	c9 00		cmp #$00			cmp 	#0
.8fc2	f0 05		beq $8fc9			beq 	_MIExit
.8fc4	a9 04		lda #$04		lda	#4
.8fc6	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.8fc9					_MIExit:
.8fc9	60		rts				rts
.8fca					MultiplyShort:
.8fca	5a		phy				phy 								; save Y
.8fcb	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fce	20 28 9e	jsr $9e28			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.8fd1	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.8fd3					_I32MLoop:
.8fd3	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.8fd6	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.8fd9	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.8fdc	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.8fdf	f0 28		beq $9009			beq 	_I32MExit 					; exit if zero
.8fe1	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.8fe4	29 01		and #$01			and 	#1
.8fe6	f0 0e		beq $8ff6			beq 	_I32MNoAdd
.8fe8	20 a1 90	jsr $90a1			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.8feb	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.8fee	10 06		bpl $8ff6			bpl 	_I32MNoAdd
.8ff0					_I32ShiftRight:
.8ff0	20 4f 9e	jsr $9e4f			jsr 	NSMShiftRight 				; shift S[X] right
.8ff3	c8		iny				iny 								; increment shift count
.8ff4	80 0a		bra $9000			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.8ff6					_I32MNoAdd:
.8ff6	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.8ff9	70 f5		bvs $8ff0			bvs 	_I32ShiftRight 				; instead.
.8ffb	e8		inx				inx
.8ffc	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.8fff	ca		dex				dex
.9000					_I32MShiftUpper:
.9000	e8		inx				inx 								; shift S[X+2] right
.9001	e8		inx				inx
.9002	20 4f 9e	jsr $9e4f			jsr 	NSMShiftRight
.9005	ca		dex				dex
.9006	ca		dex				dex
.9007	80 ca		bra $8fd3			bra 	_I32MLoop 					; try again.
.9009					_I32MExit:
.9009	20 0f 90	jsr $900f			jsr 	CalculateSign
.900c	98		tya				tya 								; shift in A
.900d	7a		ply				ply 								; restore Y and exit
.900e	60		rts				rts
.900f					CalculateSign:
.900f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9012	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.9015	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9018	0a		asl a				asl 	a 							; shift bit 7 into carry
.9019	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.901c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.901d					CompareStrings:
.901d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.9020	3d 01 04	and $0401,x			and 	NSStatus+1,x
.9023	29 10		and #$10			and 	#NSBIsString
.9025	f0 2c		beq $9053			beq 	_CSTypeError
.9027	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.902a	85 36		sta $36				sta 	zTemp0
.902c	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.902f	85 37		sta $37				sta 	zTemp0+1
.9031	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9034	85 38		sta $38				sta 	zTemp1
.9036	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9039	85 39		sta $39				sta 	zTemp1+1
.903b	5a		phy				phy 								; save Y so we can access strings
.903c	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.903e					_CSLoop:
.903e	c8		iny				iny
.903f	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.9041	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.9043	d0 06		bne $904b			bne 	_CSDifferent
.9045	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9047	d0 f5		bne $903e			bne 	_CSLoop 					; still comparing
.9049					_CSExit:
.9049	7a		ply				ply 								; reached end, return zero in A from EOS
.904a	60		rts				rts
.904b					_CSDifferent:
.904b	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.904d	90 fa		bcc $9049			bcc		_CSExit
.904f	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9051	80 f6		bra $9049			bra 	_CSExit
.9053					_CSTypeError:
.9053	4c c0 9f	jmp $9fc0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9056					ShiftLeft:
.9056	38		sec				sec
.9057	80 01		bra $905a			bra 	ShiftMain
.9059					ShiftRight:
.9059	18		clc				clc
.905a					ShiftMain:
.905a	fa		plx				plx 								; restore X
.905b	08		php				php 								; save direction
.905c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.905f	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9062	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9063	0a		asl a				asl 	a
.9064	10 05		bpl $906b			bpl 	_NotRef
.9066	48		pha				pha
.9067	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.906a	68		pla				pla
.906b					_NotRef:
.906b	0a		asl a				asl 	a
.906c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.906e	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9071	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9074	f0 03		beq $9079			beq 	_IntegerCode 				; if clear, then we have two integers
.9076	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.9079					_IntegerCode:
.9079	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.907c	29 e0		and #$e0			and 	#$E0
.907e	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.9081	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.9084	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9087	d0 13		bne $909c			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9089					_SMLoop:
.9089	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.908c	30 11		bmi $909f			bmi 	_SMExit 					; exit if done.
.908e	28		plp				plp 								; restore direcition setting
.908f	08		php				php
.9090	90 05		bcc $9097			bcc 	_SMRight
.9092	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; shift left if CS
.9095	80 f2		bra $9089			bra 	_SMLoop
.9097					_SMRight:
.9097	20 4f 9e	jsr $9e4f			jsr 	NSMShiftRight 				; shift right if CC
.909a	80 ed		bra $9089			bra 	_SMLoop
.909c					_SMExit0:
.909c	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero 					; return zero.
.909f					_SMExit:
.909f	28		plp				plp 								; throw direction
.90a0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.90a1					AddTopTwoStack:
.90a1	18		clc				clc
.90a2	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90a5	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.90a8	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90ab	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90ae	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.90b1	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90b4	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90b7	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.90ba	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90bd	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90c0	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.90c3	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90c6	60		rts				rts
.90c7					SubTopTwoStack:
.90c7	38		sec				sec
.90c8	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90cb	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.90ce	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90d1	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90d4	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.90d7	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90da	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90dd	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.90e0	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90e3	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90e6	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.90e9	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90ec	60		rts				rts
.90ed					AddInteger:
.90ed	fa		plx				plx
.90ee	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90f1	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90f4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90f5	0a		asl a				asl 	a
.90f6	10 05		bpl $90fd			bpl 	_NotRef
.90f8	48		pha				pha
.90f9	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90fc	68		pla				pla
.90fd					_NotRef:
.90fd	0a		asl a				asl 	a 							; put MSB of type into A:7
.90fe	30 0b		bmi $910b			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9100	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9103	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9106	f0 06		beq $910e			beq 	_IntegerCode 				; if clear, then we have two integers
.9108	4c 55 93	jmp $9355			jmp 	FloatingPointAdd 							; otherwise at least one float.
.910b					_StringData:
.910b	4c 7d 8e	jmp $8e7d			jmp 	StringConcat							; at least one string - don't know both are strings.
.910e					_IntegerCode:
.910e					AddCode:
.910e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9111	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9114	10 8b		bpl $90a1			bpl 	AddTopTwoStack
.9116	20 c7 90	jsr $90c7			jsr 	SubTopTwoStack 				; do a physical subtraction
.9119	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.911c	10 09		bpl $9127			bpl 	_AddExit
.911e	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9121	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9124	20 e1 9d	jsr $9de1			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9127					_AddExit:
.9127	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; check for -0
.912a	d0 03		bne $912f			bne 	_AddNonZero
.912c	9e 00 04	stz $0400,x			stz 	NSStatus,x
.912f					_AddNonZero:
.912f	60		rts				rts
.9130					SubInteger:
.9130	fa		plx				plx
.9131	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9134	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9137	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9138	0a		asl a				asl 	a
.9139	10 05		bpl $9140			bpl 	_NotRef
.913b	48		pha				pha
.913c	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.913f	68		pla				pla
.9140					_NotRef:
.9140	0a		asl a				asl 	a 							; put MSB of type into A:7
.9141	30 0b		bmi $914e			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9143	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9146	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9149	f0 06		beq $9151			beq 	_IntegerCode 				; if clear, then we have two integers
.914b	4c 5a 93	jmp $935a			jmp 	FloatingPointSub 							; otherwise at least one float.
.914e					_StringData:
.914e	4c ca 9f	jmp $9fca			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9151					_IntegerCode:
.9151	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.9154	49 80		eor #$80			eor 	#$80
.9156	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9159	80 b3		bra $910e			bra 	AddCode 					; and do the same code as add.
.915b					AndInteger:
.915b	fa		plx				plx
.915c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.915f	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9162	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9163	0a		asl a				asl 	a
.9164	10 05		bpl $916b			bpl 	_NotRef
.9166	48		pha				pha
.9167	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.916a	68		pla				pla
.916b					_NotRef:
.916b	0a		asl a				asl 	a
.916c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.916e	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9171	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9174	f0 03		beq $9179			beq 	_IntegerCode 				; if clear, then we have two integers
.9176	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.9179					_IntegerCode:
.9179	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.917c	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.917f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9182	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9185	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.9188	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.918b	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.918e	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.9191	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9194	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9197	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.919a	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.919d	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.91a0	60		rts				rts
.91a1					OraInteger:
.91a1	fa		plx				plx
.91a2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91a5	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91a8	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91a9	0a		asl a				asl 	a
.91aa	10 05		bpl $91b1			bpl 	_NotRef
.91ac	48		pha				pha
.91ad	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91b0	68		pla				pla
.91b1					_NotRef:
.91b1	0a		asl a				asl 	a
.91b2	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91b4	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91b7	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91ba	f0 03		beq $91bf			beq 	_IntegerCode 				; if clear, then we have two integers
.91bc	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.91bf					_IntegerCode:
.91bf	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.91c2	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.91c5	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.91c8	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.91cb	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.91ce	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.91d1	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.91d4	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.91d7	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.91da	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.91dd	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.91e0	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.91e3	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.91e6	60		rts				rts
.91e7					EorInteger:
.91e7	fa		plx				plx
.91e8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91eb	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91ee	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91ef	0a		asl a				asl 	a
.91f0	10 05		bpl $91f7			bpl 	_NotRef
.91f2	48		pha				pha
.91f3	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f6	68		pla				pla
.91f7					_NotRef:
.91f7	0a		asl a				asl 	a
.91f8	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91fa	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91fd	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9200	f0 03		beq $9205			beq 	_IntegerCode 				; if clear, then we have two integers
.9202	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.9205					_IntegerCode:
.9205	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9208	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.920b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.920e	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9211	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.9214	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9217	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.921a	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.921d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9220	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9223	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.9226	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9229	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.922c	60		rts				rts
.922d					WordIndirect:
.922d	fa		plx				plx
.922e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9231	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9234	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9235	0a		asl a				asl 	a
.9236	10 05		bpl $923d			bpl 	_NotRef
.9238	48		pha				pha
.9239	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.923c	68		pla				pla
.923d					_NotRef:
.923d	0a		asl a				asl 	a
.923e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9240	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9243	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9246	f0 03		beq $924b			beq 	_IntegerCode 				; if clear, then we have two integers
.9248	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.924b					_IntegerCode:
.924b	20 0e 91	jsr $910e			jsr 	AddCode 					; add the two values
.924e	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9250	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9253	60		rts				rts
.9254					ByteIndirect:
.9254	fa		plx				plx
.9255	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9258	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.925b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.925c	0a		asl a				asl 	a
.925d	10 05		bpl $9264			bpl 	_NotRef
.925f	48		pha				pha
.9260	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9263	68		pla				pla
.9264					_NotRef:
.9264	0a		asl a				asl 	a
.9265	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9267	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.926a	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.926d	f0 03		beq $9272			beq 	_IntegerCode 				; if clear, then we have two integers
.926f	4c c0 9f	jmp $9fc0			jmp 	TypeError 					; anything else, type mismatch.
.9272					_IntegerCode:
.9272	20 0e 91	jsr $910e			jsr 	AddCode 					; add the two values
.9275	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9277	9d 00 04	sta $0400,x			sta 	NSStatus,x
.927a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.927b					LCLConvertInt16:
.927b	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.927e	8e 10 04	stx $0410			stx 	NSMantissa1
.9281	9c 18 04	stz $0418			stz 	NSMantissa2
.9284	9c 20 04	stz $0420			stz 	NSMantissa3
.9287	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.928a	a2 00		ldx #$00			ldx 	#0 							; stack level
.928c	a9 0a		lda #$0a			lda 	#10 						; base
.928e	80 00		bra $9290			bra 	ConvertInt32
.9290					ConvertInt32:
.9290	5a		phy				phy
.9291	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9293	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.9296	10 08		bpl $92a0			bpl 	_CI32NotNeg
.9298	48		pha				pha
.9299	a9 2d		lda #$2d			lda 	#'-'
.929b	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.929e	c8		iny				iny
.929f	68		pla				pla
.92a0					_CI32NotNeg:
.92a0	20 ae 92	jsr $92ae			jsr 	_CI32DivideConvert 			; recursive conversion
.92a3	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.92a5	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.92a8	7a		ply				ply
.92a9	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.92ab	a9 f9		lda #$f9			lda 	#NumberBuffer & $FF
.92ad	60		rts				rts
.92ae					_CI32DivideConvert:
.92ae	e8		inx				inx 								; write to next slot up
.92af	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.92b2	ca		dex				dex
.92b3	20 52 8f	jsr $8f52			jsr 	Int32Divide 				; divide
.92b6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.92b9	48		pha				pha
.92ba	20 01 8f	jsr $8f01			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.92bd	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; is it zero ?
.92c0	f0 06		beq $92c8			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.92c2	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.92c5	20 ae 92	jsr $92ae			jsr 	_CI32DivideConvert 			; and recusrively call.
.92c8					_CI32NoRecurse:
.92c8	68		pla				pla 								; remainder
.92c9	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.92cb	90 02		bcc $92cf			bcc 	_CI32NotHex
.92cd	69 26		adc #$26			adc 	#6+32
.92cf					_CI32NotHex:
.92cf	69 30		adc #$30			adc 	#48
.92d1	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y 				; write out and exit
.92d4	c8		iny				iny
.92d5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.92d6					PrecedenceLevel:
>92d6	04					.byte	 4	; $00 <<
>92d7	02					.byte	 2	; $01 <=
>92d8	02					.byte	 2	; $02 <>
>92d9	00					.byte	 0	; $03 !!3
>92da	00					.byte	 0	; $04 ><
>92db	02					.byte	 2	; $05 >=
>92dc	04					.byte	 4	; $06 >>
>92dd	00					.byte	 0	; $07 !!7
>92de	00					.byte	 0	; $08 !!8
>92df	00					.byte	 0	; $09 !!9
>92e0	00					.byte	 0	; $0a !!10
>92e1	00					.byte	 0	; $0b !!11
>92e2	00					.byte	 0	; $0c !!12
>92e3	00					.byte	 0	; $0d !!13
>92e4	00					.byte	 0	; $0e !!14
>92e5	00					.byte	 0	; $0f !!15
>92e6	00					.byte	 0	; $10 @
>92e7	00					.byte	 0	; $11 !!17
>92e8	00					.byte	 0	; $12 !!18
>92e9	00					.byte	 0	; $13 [
>92ea	04					.byte	 4	; $14 \
>92eb	00					.byte	 0	; $15 ]
>92ec	01					.byte	 1	; $16 ^
>92ed	00					.byte	 0	; $17 _
>92ee	00					.byte	 0	; $18 `
>92ef	00					.byte	 0	; $19 !!25
>92f0	00					.byte	 0	; $1a !!26
>92f1	00					.byte	 0	; $1b {
>92f2	01					.byte	 1	; $1c |
>92f3	00					.byte	 0	; $1d }
>92f4	00					.byte	 0	; $1e ~
>92f5	00					.byte	 0	; $1f [7m<7F>[m
>92f6	00					.byte	 0	; $20
>92f7	05					.byte	 5	; $21 !
>92f8	00					.byte	 0	; $22 "
>92f9	00					.byte	 0	; $23 #
>92fa	05					.byte	 5	; $24 $
>92fb	04					.byte	 4	; $25 %
>92fc	01					.byte	 1	; $26 &
>92fd	00					.byte	 0	; $27 '
>92fe	00					.byte	 0	; $28 (
>92ff	00					.byte	 0	; $29 )
>9300	04					.byte	 4	; $2a *
>9301	03					.byte	 3	; $2b +
>9302	00					.byte	 0	; $2c ,
>9303	03					.byte	 3	; $2d -
>9304	00					.byte	 0	; $2e .
>9305	04					.byte	 4	; $2f /
>9306	00					.byte	 0	; $30 0
>9307	00					.byte	 0	; $31 1
>9308	00					.byte	 0	; $32 2
>9309	00					.byte	 0	; $33 3
>930a	00					.byte	 0	; $34 4
>930b	00					.byte	 0	; $35 5
>930c	00					.byte	 0	; $36 6
>930d	00					.byte	 0	; $37 7
>930e	00					.byte	 0	; $38 8
>930f	00					.byte	 0	; $39 9
>9310	00					.byte	 0	; $3a :
>9311	00					.byte	 0	; $3b ;
>9312	02					.byte	 2	; $3c <
>9313	02					.byte	 2	; $3d =
>9314	02					.byte	 2	; $3e >
>9315	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9316					EvaluateExpressionAt0:
.9316	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9318					EvaluateExpression:
.9318	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.931a					EvaluateExpressionAtPrecedence:
.931a	48		pha				pha 								; save precedence level
.931b	20 f2 97	jsr $97f2			jsr 	EvaluateTerm 				; evaluate term into level X.
.931e	68		pla				pla 								; restore precedence level.
.931f					_EXPRLoop:
.931f	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9321	b1 30		lda ($30),y			lda 	(codePtr),y
.9323	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9325	b0 25		bcs $934c			bcs 	_EXPRExit
.9327	da		phx				phx 								; read the operator precedence
.9328	aa		tax				tax
.9329	bd d6 92	lda $92d6,x			lda 	PrecedenceLevel,x
.932c	fa		plx				plx
.932d	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.932f	f0 1b		beq $934c			beq 	_EXPRExit
.9331	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9333	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9335	c5 37		cmp $37				cmp 	zTemp0+1
.9337	b0 13		bcs $934c			bcs		_EXPRExit 					; if current >= operator exit
.9339	48		pha				pha 								; save current precedence.
.933a	b1 30		lda ($30),y			lda 	(codePtr),y
.933c	c8		iny				iny
.933d	48		pha				pha
.933e	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9340	e8		inx				inx 								; work out the right hand side.
.9341	20 1a 93	jsr $931a			jsr 	EvaluateExpressionAtPrecedence
.9344	ca		dex				dex
.9345	68		pla				pla 								; get operator, call the code.
.9346	20 4f 93	jsr $934f			jsr 	_EXPRCaller
.9349	68		pla				pla 								; restore precedence level
.934a	80 d3		bra $931f			bra 	_EXPRLoop 					; and go round.
.934c					_EXPRExit:
.934c	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.934e	60		rts				rts
.934f					_EXPRCaller:
.934f	da		phx				phx 								; save on stack, first thing is to restore it
.9350	0a		asl a				asl 	a 							; double so can use vectors into X
.9351	aa		tax				tax
.9352	7c 96 8a	jmp ($8a96,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9355					FloatingPointAdd:
.9355	20 fe 94	jsr $94fe			jsr 	FloatPrepare 				; prepare for floats
.9358	80 0b		bra $9365			bra 	FloatAdd
.935a					FloatingPointSub:
.935a	20 fe 94	jsr $94fe			jsr 	FloatPrepare 				; prepare for floats
.935d					FloatSubtract:
.935d	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.9360	49 80		eor #$80			eor 	#$80
.9362	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.9365					FloatAdd:
.9365	48		pha				pha
.9366	5a		phy				phy
.9367	20 0f 95	jsr $950f			jsr 	NSNormalise 				; normalise S[X]
.936a	f0 5c		beq $93c8			beq 	_FAReturn1
.936c	e8		inx				inx 								; normalise S[X+1]
.936d	20 0f 95	jsr $950f			jsr 	NSNormalise
.9370	ca		dex				dex
.9371	c9 00		cmp #$00			cmp 	#0
.9373	f0 77		beq $93ec			beq 	_FAExit 					; if so, just return A
.9375	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.9378	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.937b	f0 1b		beq $9398			beq 	_FAExponentsEqual
.937d	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.9380	a8		tay				tay
.9381	38		sec				sec 								; do a signed comparison of the exponents.
.9382	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9385	50 02		bvc $9389			bvc 	_FANoSignedChange
.9387	49 80		eor #$80			eor 	#$80
.9389					_FANoSignedChange:
.9389	29 80		and #$80			and 	#$80
.938b	10 03		bpl $9390			bpl 	_FAHaveMax
.938d	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.9390					_FAHaveMax:
.9390	20 ef 93	jsr $93ef			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9393	e8		inx				inx
.9394	20 ef 93	jsr $93ef			jsr 	_FAShiftToExponent
.9397	ca		dex				dex
.9398					_FAExponentsEqual:
.9398	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.939b	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.939e	30 10		bmi $93b0			bmi 	_FADifferentSigns
.93a0	20 a1 90	jsr $90a1			jsr 	AddTopTwoStack 				; do the add of the mantissae
.93a3	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.93a6	10 44		bpl $93ec			bpl 	_FAExit 					; if no, we are done.
.93a8	20 4f 9e	jsr $9e4f			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.93ab	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.93ae	80 3c		bra $93ec			bra 	_FAExit
.93b0					_FADifferentSigns:
.93b0	20 c7 90	jsr $90c7			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.93b3	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.93b6	10 06		bpl $93be			bpl 	_FACheckZero 				; if no, check for -0
.93b8	20 d8 9d	jsr $9dd8			jsr 	NSMNegate 					; netate result
.93bb	20 e1 9d	jsr $9de1			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.93be					_FACheckZero:
.93be	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero	 				; check for -0
.93c1	d0 29		bne $93ec			bne 	_FAExit
.93c3	9e 00 04	stz $0400,x			stz 	NSStatus,x
.93c6	80 24		bra $93ec			bra 	_FAExit
.93c8					_FAReturn1:
.93c8	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.93cb	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.93ce	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.93d1	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.93d4	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.93d7	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.93da	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.93dd	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.93e0	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.93e3	9d 28 04	sta $0428,x			sta 	NSExponent,x
.93e6	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.93e9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.93ec					_FAExit:
.93ec	7a		ply				ply
.93ed	68		pla				pla
.93ee	60		rts				rts
.93ef					_FAShiftToExponent:
.93ef					_FAShiftToExponent2:
.93ef	98		tya				tya 								; compare Y to exponent
.93f0	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.93f3	f0 08		beq $93fd			beq 	_FASEExit 					; exit if so.
.93f5	20 4f 9e	jsr $9e4f			jsr 	NSMShiftRight	 			; shift the mantissa right
.93f8	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.93fb	80 f2		bra $93ef			bra 	_FAShiftToExponent2
.93fd					_FASEExit:
.93fd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.93fe					CompareFloat:
.93fe	20 5d 93	jsr $935d			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9401	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9404	29 f8		and #$f8			and 	#$F8
.9406	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9409	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.940c	f0 09		beq $9417			beq 	_FCExit 					; zero, so approximately identical
.940e	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9410	3c 00 04	bit $0400,x			bit 	NSStatus,x
.9413	10 02		bpl $9417			bpl 	_FCExit
.9415					_FCNegative:
.9415	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9417					_FCExit:
.9417	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9418					FDivideCommand:
.9418	fa		plx				plx	 								; restore stack position
.9419	20 fe 94	jsr $94fe			jsr 	FloatPrepare 				; prepare for floats
.941c					FloatDivide:
.941c	48		pha				pha
.941d	e8		inx				inx
.941e	20 0f 95	jsr $950f			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9421	ca		dex				dex
.9422	c9 00		cmp #$00			cmp 	#0
.9424	f0 20		beq $9446			beq 	_FDZero
.9426	20 0f 95	jsr $950f			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9429	f0 19		beq $9444			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.942b	20 74 8f	jsr $8f74			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.942e	20 01 8f	jsr $8f01			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9431	20 0f 95	jsr $950f			jsr		NSNormalise 				; renormalise
.9434	20 0f 90	jsr $900f			jsr 	CalculateSign 				; calculate result sign
.9437	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.943a	38		sec				sec
.943b	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.943e	38		sec				sec
.943f	e9 1e		sbc #$1e			sbc 	#30
.9441	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9444					_FDExit:
.9444	68		pla				pla
.9445	60		rts				rts
.9446					_FDZero:
.9446	a9 03		lda #$03		lda	#3
.9448	4c 69 8d	jmp $8d69		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.944b					FloatFractionalPart:
.944b	5a		phy				phy
.944c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.944f	29 7f		and #$7f			and 	#$7F
.9451	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9454	20 0f 95	jsr $950f			jsr 	NSNormalise
.9457	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.945a	38		sec				sec
.945b	e9 e0		sbc #$e0			sbc 	#$E0
.945d	90 31		bcc $9490			bcc 	_FFPExit 					; already fractional
.945f	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9461	b0 2a		bcs $948d			bcs 	_FFPZero
.9463	a8		tay				tay 								; put count to do in Y
.9464	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.9467	20 92 94	jsr $9492			jsr 	_FFPPartial
.946a	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.946d	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9470	20 92 94	jsr $9492			jsr 	_FFPPartial
.9473	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9476	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9479	20 92 94	jsr $9492			jsr 	_FFPPartial
.947c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.947f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9482	20 92 94	jsr $9492			jsr 	_FFPPartial
.9485	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9488	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; zeroed check.
.948b	d0 03		bne $9490			bne 	_FFPExit
.948d					_FFPZero:
.948d	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.9490					_FFPExit:
.9490	7a		ply				ply
.9491	60		rts				rts
.9492					_FFPPartial:
.9492	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9494	f0 17		beq $94ad			beq 	_FFFPPExit
.9496	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9498	b0 0c		bcs $94a6			bcs 	_FFFPPWholeByte
.949a	5a		phy				phy
.949b					_FFFPPLeft:
.949b	0a		asl a				asl 	a
.949c	88		dey				dey
.949d	d0 fc		bne $949b			bne 	_FFFPPLeft
.949f	7a		ply				ply
.94a0					_FFFPPRight:
.94a0	4a		lsr a				lsr 	a
.94a1	88		dey				dey
.94a2	d0 fc		bne $94a0			bne 	_FFFPPRight
.94a4	80 07		bra $94ad			bra 	_FFFPPExit
.94a6					_FFFPPWholeByte:
.94a6	98		tya				tya 								; subtract 8 from count
.94a7	38		sec				sec
.94a8	e9 08		sbc #$08			sbc 	#8
.94aa	a8		tay				tay
.94ab	a9 00		lda #$00			lda 	#0 							; and clear all
.94ad					_FFFPPExit:
.94ad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.94ae					FloatIntegerPart:
.94ae	48		pha				pha
.94af	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.94b2	f0 1f		beq $94d3			beq 	_FIPExit 					; if so do nothing
.94b4	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; is it zero ?
.94b7	f0 17		beq $94d0			beq 	_FIPZero 					; if so return zero.
.94b9	20 0f 95	jsr $950f			jsr 	NSNormalise 				; normalise
.94bc	f0 12		beq $94d0			beq 	_FIPZero 					; normalised to zero, exit zero
.94be					_FIPShift:
.94be	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.94c1	10 08		bpl $94cb			bpl 	_FIPCheckZero
.94c3	20 4f 9e	jsr $9e4f			jsr 	NSMShiftRight 				; shift mantissa right
.94c6	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.94c9	80 f3		bra $94be			bra 	_FIPShift
.94cb					_FIPCheckZero:
.94cb	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; avoid -0 problem
.94ce	d0 03		bne $94d3			bne 	_FIPExit 					; set to zero if mantissa zero.
.94d0					_FIPZero:
.94d0	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.94d3					_FIPExit:
.94d3	68		pla				pla
.94d4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.94d5					FloatingPointMultiply:
.94d5	20 fe 94	jsr $94fe			jsr 	FloatPrepare 				; prepare for floats
.94d8					FloatMultiply:
.94d8	48		pha				pha
.94d9	20 0f 95	jsr $950f			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94dc	f0 1b		beq $94f9			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94de	e8		inx				inx
.94df	20 0f 95	jsr $950f			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94e2	ca		dex				dex
.94e3	c9 00		cmp #$00			cmp 	#0
.94e5	f0 0f		beq $94f6			beq 	_FDSetZero
.94e7	20 ca 8f	jsr $8fca			jsr 	MultiplyShort 				; calculate the result.
.94ea	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.94ed	18		clc				clc
.94ee	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.94f1	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94f4	80 03		bra $94f9			bra 	_FDExit
.94f6					_FDSetZero:
.94f6	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero 					; return 0
.94f9					_FDExit:
.94f9	20 0f 95	jsr $950f			jsr 	NSNormalise 				; normalise the result
.94fc	68		pla				pla
.94fd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.94fe					FloatPrepare:
.94fe	20 31 96	jsr $9631			jsr 	DereferenceTopTwo 			; dereference the top two values
.9501	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.9504	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9507	29 10		and #$10			and 	#NSBIsString
.9509	d0 01		bne $950c			bne 	_FDType
.950b	60		rts				rts
.950c					_FDType:
.950c	4c c0 9f	jmp $9fc0			jmp 	TypeError
.950f					NSNormalise:
.950f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.9512	29 80		and #$80			and 	#$80
.9514	09 08		ora #$08			ora 	#NSTFloat
.9516	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9519	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; if zero exit
.951c	d0 09		bne $9527			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.951e	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.9521	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.9524	a9 00		lda #$00			lda 	#0 							; set Z flag
.9526	60		rts				rts
.9527					_NSNormaliseOptimise:
.9527	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.952a	d0 22		bne $954e			bne 	_NSNormaliseLoop
.952c	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.952f	30 1d		bmi $954e			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9531	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9534	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9537	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.953a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.953d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9540	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.9543	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9546	38		sec				sec
.9547	e9 08		sbc #$08			sbc 	#8
.9549	9d 28 04	sta $0428,x			sta 	NSExponent,x
.954c	80 d9		bra $9527			bra 	_NSNormaliseOptimise
.954e					_NSNormaliseLoop:
.954e	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9551	70 08		bvs $955b			bvs 	_NSNExit 					; exit if so with Z flag clear
.9553	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; shift mantissa left
.9556	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.9559	80 f3		bra $954e			bra 	_NSNormaliseLoop
.955b					_NSNExit:
.955b	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.955d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.955e					AssignNumber:
.955e	5a		phy				phy
.955f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9562	85 36		sta $36				sta 	zTemp0
.9564	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9567	85 37		sta $37				sta 	zTemp0+1
.9569	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.956c	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.956e	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9571	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9573	c9 08		cmp #$08			cmp 	#NSTFloat
.9575	f0 2a		beq $95a1			beq 	_ANFloat
.9577	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.957a	f0 05		beq $9581			beq		_ANNotFloat
.957c	e8		inx				inx
.957d	20 ae 94	jsr $94ae			jsr 	FloatIntegerPart 			; make it an integer
.9580	ca		dex				dex
.9581					_ANNotFloat:
.9581	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.9584	29 03		and #$03			and 	#3
.9586	d0 05		bne $958d			bne 	_ANByteWord
.9588	20 ad 95	jsr $95ad			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.958b	80 1e		bra $95ab			bra 	_ANExit
.958d					_ANByteWord:
.958d	48		pha				pha 								; save count
.958e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.9591	92 36		sta ($36)			sta 	(zTemp0)
.9593	68		pla				pla
.9594	c9 01		cmp #$01			cmp	 	#1
.9596	f0 13		beq $95ab			beq 	_ANExit
.9598	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.959b	a0 01		ldy #$01			ldy 	#1
.959d	91 36		sta ($36),y			sta 	(zTemp0),y
.959f	80 0a		bra $95ab			bra 	_ANExit
.95a1					_ANFloat:
.95a1	20 ad 95	jsr $95ad			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.95a4	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.95a7	a0 04		ldy #$04			ldy 	#4
.95a9	91 36		sta ($36),y			sta 	(zTemp0),y
.95ab					_ANExit:
.95ab	7a		ply				ply
.95ac	60		rts				rts
.95ad					_ANCopy4PackSign:
.95ad	a0 03		ldy #$03			ldy 	#3
.95af	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.95b2	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.95b4	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.95b7	91 36		sta ($36),y			sta 	(zTemp0),y
.95b9	88		dey				dey
.95ba	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.95bd	91 36		sta ($36),y			sta 	(zTemp0),y
.95bf	88		dey				dey
.95c0	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95c3	91 36		sta ($36),y			sta 	(zTemp0),y
.95c5	88		dey				dey
.95c6	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95c9	91 36		sta ($36),y			sta 	(zTemp0),y
.95cb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95cc					AssignString:
.95cc	5a		phy				phy
.95cd	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95d0	85 38		sta $38				sta 	zTemp1
.95d2	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95d5	85 39		sta $39				sta 	zTemp1+1
.95d7	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95da	85 36		sta $36				sta 	zTemp0
.95dc	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95df	85 37		sta $37				sta 	zTemp0+1
.95e1	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.95e3	b1 36		lda ($36),y			lda 	(zTemp0),y
.95e5	f0 23		beq $960a			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.95e7	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.95e8	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.95ea	e9 02		sbc #$02			sbc 	#2
.95ec	85 3c		sta $3c				sta 	zsTemp
.95ee	a0 01		ldy #$01			ldy 	#1
.95f0	b1 36		lda ($36),y			lda 	(zTemp0),y
.95f2	e9 00		sbc #$00			sbc 	#0
.95f4	85 3d		sta $3d				sta 	zsTemp+1
.95f6	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.95f8					_ASGetLength:
.95f8	c8		iny				iny
.95f9	b1 38		lda ($38),y			lda 	(zTemp1),y
.95fb	d0 fb		bne $95f8			bne 	_ASGetLength
.95fd	98		tya				tya 								; is this length <= current length
.95fe	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9600	90 20		bcc $9622			bcc 	_ASCopyString
.9602	f0 1e		beq $9622			beq 	_ASCopyString
.9604	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9606	a0 01		ldy #$01			ldy 	#1
.9608	91 3c		sta ($3c),y			sta 	(zsTemp),y
.960a					_ASNewStringRequired:
.960a	e8		inx				inx 								; concrete the new string.
.960b	20 f7 a6	jsr $a6f7			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.960e	ca		dex				dex
.960f	18		clc				clc
.9610	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9613	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9615	92 36		sta ($36)			sta 	(zTemp0)
.9617	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.961a	69 00		adc #$00			adc 	#0
.961c	a0 01		ldy #$01			ldy 	#1
.961e	91 36		sta ($36),y			sta 	(zTemp0),y
.9620	80 0d		bra $962f			bra 	_ASExit
.9622					_ASCopyString:
.9622	a0 00		ldy #$00			ldy 	#0
.9624					_ASCopyLoop:
.9624	b1 38		lda ($38),y			lda 	(zTemp1),y
.9626	c8		iny				iny
.9627	c8		iny				iny
.9628	91 3c		sta ($3c),y			sta 	(zsTemp),y
.962a	88		dey				dey
.962b	c9 00		cmp #$00			cmp 	#0
.962d	d0 f5		bne $9624			bne 	_ASCopyLoop
.962f					_ASExit:
.962f	7a		ply				ply
.9630	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9631					DereferenceTopTwo:
.9631	e8		inx				inx
.9632	20 36 96	jsr $9636			jsr 	Dereference 				; deref x+1
.9635	ca		dex				dex  								; falls through to deref x
.9636					Dereference:
.9636	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.9639	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.963b	f0 57		beq $9694			beq 	_DRFExit 					; not a reference
.963d	5a		phy				phy
.963e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9641	85 36		sta $36				sta 	zTemp0
.9643	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9646	85 37		sta $37				sta 	zTemp0+1
.9648	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.964b	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.964d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9650	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.9653	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9655	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9657	f0 0f		beq $9668			beq 	_DRFDereferenceTwo
.9659	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.965b	f0 39		beq $9696			beq 	_DRFFull
.965d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9660	29 03		and #$03			and 	#3
.9662	f0 32		beq $9696			beq 	_DRFFull 					; the whole word
.9664	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9666	f0 07		beq $966f			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9668					_DRFDereferenceTwo:
.9668	a0 01		ldy #$01			ldy 	#1
.966a	b1 36		lda ($36),y			lda 	(zTemp0),y
.966c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.966f					_DRFClear23:
.966f	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9672	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9675	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.9678	29 18		and #$18			and 	#NSBTypeMask
.967a	9d 00 04	sta $0400,x			sta 	NSStatus,x
.967d	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.967f	d0 12		bne $9693			bne 	_DRFNotString
.9681	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.9684	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9687	d0 0a		bne $9693			bne 	_DRFNotString
.9689	a9 95		lda #$95			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.968b	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.968e	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.9690	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.9693					_DRFNotString
.9693	7a		ply				ply 								; restore Y and exit
.9694					_DRFExit:
.9694	60		rts				rts
.9695					_DRFNullString:
>9695	00						.byte 	0
.9696					_DRFFull:
.9696	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9698	b1 36		lda ($36),y			lda 	(zTemp0),y
.969a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.969d	c8		iny				iny
.969e	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a0	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.96a3	c8		iny				iny
.96a4	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a6	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96a9	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.96ac	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.96af	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96b1	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.96b4	f0 06		beq $96bc			beq 	_DRFNoExponent
.96b6	c8		iny				iny 								; if not, read the exponent as well.
.96b7	b1 36		lda ($36),y			lda 	(zTemp0),y
.96b9	9d 28 04	sta $0428,x			sta 	NSExponent,x
.96bc					_DRFNoExponent:
.96bc	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96bf	10 0d		bpl $96ce			bpl 	_DRFExit2 					; if not, then exit.
.96c1	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96c3	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96c6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.96c9	09 80		ora #$80			ora 	#NSBIsNegative
.96cb	9d 00 04	sta $0400,x			sta 	NSStatus,x
.96ce					_DRFExit2:
.96ce	7a		ply				ply
.96cf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.96d0					EncodeNumberStart:
.96d0	38		sec				sec
.96d1	80 01		bra $96d4			bra 	EncodeNumberContinue+1
.96d3					EncodeNumberContinue:
.96d3	18		clc				clc
.96d4					EncodeNumber:
.96d4	08		php				php 								; save reset.
.96d5	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.96d7	f0 12		beq $96eb			beq 	_ENIsOkay
.96d9	c9 30		cmp #$30			cmp 	#"0"
.96db	90 04		bcc $96e1			bcc 	_ENBadNumber
.96dd	c9 3a		cmp #$3a			cmp 	#"9"+1
.96df	90 0a		bcc $96eb			bcc 	_ENIsOkay
.96e1					_ENBadNumber:
.96e1	28		plp				plp 								; throw saved reset
.96e2	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.96e5	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96e7	f0 7e		beq $9767			beq 	_ENConstructFinal
.96e9					_ENFail:
.96e9	18		clc				clc 								; not allowed
.96ea	60		rts				rts
.96eb					_ENIsOkay:
.96eb	28		plp				plp 								; are we restarting
.96ec	90 15		bcc $9703			bcc 	_ENNoRestart
.96ee					_ENStartEncode:
.96ee	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.96f0	f0 0c		beq $96fe			beq 	_ENFirstDP
.96f2	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.96f4	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.96f7	a9 01		lda #$01			lda 	#ESTA_Low
.96f9					_ENExitChange:
.96f9	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.96fc	38		sec				sec
.96fd	60		rts				rts
.96fe					_ENFirstDP:
.96fe	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero 					; clear integer part
.9701	80 3f		bra $9742			bra 	_ESTASwitchFloat			; go straight to float and exi
.9703					_ENNoRestart:
.9703	48		pha				pha 								; save on stack.
.9704	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.9707	c9 01		cmp #$01			cmp 	#ESTA_Low
.9709	f0 09		beq $9714			beq  	_ESTALowState
.970b	c9 02		cmp #$02			cmp 	#ESTA_High
.970d	f0 29		beq $9738			beq 	_ESTAHighState
.970f	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9711	f0 3b		beq $974e			beq 	_ESTADecimalState
>9713	db						.byte 	$DB 						; causes a break in the emulator
.9714					_ESTALowState:
.9714	68		pla				pla 								; get value back
.9715	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9717	f0 29		beq $9742			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9719	29 0f		and #$0f			and 	#15 						; make digit
.971b	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.971e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9721	0a		asl a				asl 	a
.9722	0a		asl a				asl 	a
.9723	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9726	0a		asl a				asl 	a
.9727	6d 86 04	adc $0486			adc 	DigitTemp
.972a	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.972d	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.972f	90 05		bcc $9736			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.9731	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.9733	8d 85 04	sta $0485			sta 	EncodeState
.9736					_ESTANoSwitch:
.9736	38		sec				sec
.9737	60		rts				rts
.9738					_ESTAHighState:
.9738	68		pla				pla 								; get value back
.9739	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.973b	f0 05		beq $9742			beq 	_ESTASwitchFloat
.973d	20 a1 97	jsr $97a1			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9740	38		sec				sec
.9741	60		rts				rts
.9742					_ESTASwitchFloat:
.9742	9c 87 04	stz $0487			stz 	DecimalCount
.9745	e8		inx				inx 								; zero the decimal additive.
.9746	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.9749	ca		dex				dex
.974a	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.974c	80 ab		bra $96f9			bra 	_ENExitChange
.974e					_ESTADecimalState:
.974e	68		pla				pla 								; digit.
.974f	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9751	f0 96		beq $96e9			beq 	_ENFail
.9753	e8		inx				inx 								; put digit into fractional part of X+1
.9754	20 a1 97	jsr $97a1			jsr 	ESTAShiftDigitIntoMantissa
.9757	ca		dex				dex
.9758	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.975b	ad 87 04	lda $0487			lda 	DecimalCount
.975e	c9 0b		cmp #$0b			cmp 	#11
.9760	f0 02		beq $9764			beq 	_ESTADSFail
.9762	38		sec				sec
.9763	60		rts				rts
.9764					_ESTADSFail:
.9764	4c bb 9f	jmp $9fbb			jmp 	RangeError
.9767					_ENConstructFinal:
.9767	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.976a	f0 33		beq $979f			beq 	_ENCFExit 					; no decimals
.976c	5a		phy				phy
.976d	0a		asl a				asl 	a 							; x 4 and CLC
.976e	0a		asl a				asl 	a
.976f	6d 87 04	adc $0487			adc 	DecimalCount
.9772	a8		tay				tay
.9773	b9 7a 9f	lda $9f7a,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9776	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9779	b9 7b 9f	lda $9f7b,y			lda 	DecimalScalarTable-5+1,y
.977c	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.977f	b9 7c 9f	lda $9f7c,y			lda 	DecimalScalarTable-5+2,y
.9782	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9785	b9 7d 9f	lda $9f7d,y			lda 	DecimalScalarTable-5+3,y
.9788	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.978b	b9 7e 9f	lda $9f7e,y			lda 	DecimalScalarTable-5+4,y
.978e	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9791	a9 08		lda #$08			lda 	#NSTFloat
.9793	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9796	7a		ply				ply
.9797	e8		inx				inx 								; multiply decimal const by decimal scalar
.9798	20 d8 94	jsr $94d8			jsr 	FloatMultiply
.979b	ca		dex				dex
.979c	20 65 93	jsr $9365			jsr 	FloatAdd 					; add to integer part.
.979f					_ENCFExit:
.979f	18		clc				clc 								; reject the digit.
.97a0	60		rts				rts
.97a1					ESTAShiftDigitIntoMantissa:
.97a1	29 0f		and #$0f			and 	#15 						; save digit
.97a3	48		pha				pha
.97a4	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.97a7	48		pha				pha
.97a8	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.97ab	48		pha				pha
.97ac	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.97af	48		pha				pha
.97b0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.97b3	48		pha				pha
.97b4	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 2
.97b7	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 4
.97ba	18		clc				clc 								; pop mantissa and add
.97bb	68		pla				pla
.97bc	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97bf	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97c2	68		pla				pla
.97c3	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.97c6	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.97c9	68		pla				pla
.97ca	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.97cd	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.97d0	68		pla				pla
.97d1	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.97d4	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.97d7	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 10
.97da	68		pla				pla 								; add digit
.97db	18		clc				clc
.97dc	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97df	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97e2	90 0d		bcc $97f1			bcc 	_ESTASDExit
.97e4	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.97e7	d0 08		bne $97f1			bne 	_ESTASDExit
.97e9	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.97ec	d0 03		bne $97f1			bne 	_ESTASDExit
.97ee	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.97f1					_ESTASDExit:
.97f1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.97f2					EvaluateTerm:
.97f2	b1 30		lda ($30),y			lda 	(codePtr),y
.97f4	30 18		bmi $980e			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.97f6	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.97f8	b0 6f		bcs $9869			bcs 	_ETVariable
.97fa	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.97fc	90 6e		bcc $986c			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.97fe	c9 3a		cmp #$3a			cmp 	#'9'+1
.9800	b0 6a		bcs $986c			bcs 	_ETPuncUnary
.9802	20 d0 96	jsr $96d0			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9805					_ETNumber:
.9805	c8		iny				iny 								; keep encoding until we have the numbers
.9806	b1 30		lda ($30),y			lda 	(codePtr),y
.9808	20 d3 96	jsr $96d3			jsr 	EncodeNumberContinue
.980b	b0 f8		bcs $9805			bcs 	_ETNumber 					; go back if accepted.
.980d	60		rts				rts
.980e					_ETCheckUnary:
.980e	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9810	f0 41		beq $9853			beq 	_ETString
.9812	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9814	f0 12		beq $9828			beq 	_ETHexConstant
.9816	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9818	90 0b		bcc $9825			bcc 	_ETSyntaxError
.981a	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.981c	b0 07		bcs $9825			bcs 	_ETSyntaxError
.981e	da		phx				phx 								; push X on the stack
.981f	0a		asl a				asl 	a 							; put vector x 2 into X
.9820	aa		tax				tax
.9821	c8		iny				iny 								; consume unary function token
.9822	7c 16 8b	jmp ($8b16,x)			jmp 	(VectorSet0,x) 				; and do it.
.9825					_ETSyntaxError:
.9825	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.9828					_ETHexConstant:
.9828	c8		iny				iny 								; skip #
.9829	c8		iny				iny 								; skip count
.982a	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero 					; clear result
.982d					_ETHLoop:
.982d	b1 30		lda ($30),y			lda 	(codePtr),y
.982f	c8		iny				iny 								; and consume
.9830	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9832	f0 1e		beq $9852			beq 	_ETHExit
.9834	48		pha				pha 								; save on stack.
.9835	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 2
.9838	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 4
.983b	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 8
.983e	20 41 9e	jsr $9e41			jsr 	NSMShiftLeft 				; x 16
.9841	68		pla				pla 								; ASCII
.9842	c9 41		cmp #$41			cmp 	#'A'
.9844	90 02		bcc $9848			bcc 	_ETHNotChar
.9846	e9 07		sbc #$07			sbc 	#7
.9848					_ETHNotChar:
.9848	29 0f		and #$0f			and 	#15 						; digit now
.984a	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.984d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9850	80 db		bra $982d			bra 	_ETHLoop 					; go round.
.9852					_ETHExit:
.9852	60		rts				rts
.9853					_ETString:
.9853	c8		iny				iny 								; look at length
.9854	b1 30		lda ($30),y			lda 	(codePtr),y
.9856	48		pha				pha
.9857	c8		iny				iny 								; first character
.9858	20 b0 a5	jsr $a5b0			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.985b	68		pla				pla 								; restore count and save
.985c	85 36		sta $36				sta 	zTemp0
.985e	98		tya				tya 								; add length to Y to skip it.
.985f	18		clc				clc
.9860	65 36		adc $36				adc 	zTemp0
.9862	a8		tay				tay
.9863	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9865	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9868	60		rts				rts
.9869					_ETVariable:
.9869	4c c3 98	jmp $98c3			jmp 	VariableHandler
.986c					_ETPuncUnary:
.986c	c8		iny				iny 								; consume the unary character
.986d	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.986f	f0 2d		beq $989e			beq 	_ETUnaryNegate
.9871	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9873	f0 39		beq $98ae			beq 	_ETDereference
.9875	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9877	f0 43		beq $98bc			beq 	_ETParenthesis
.9879	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.987b	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.987d	f0 06		beq $9885			beq 	_ETIndirection
.987f	e6 36		inc $36				inc 	zTemp0
.9881	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9883	d0 a0		bne $9825			bne 	_ETSyntaxError
.9885					_ETIndirection:
.9885	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9887	1a		inc a				inc 	a
.9888	48		pha				pha
.9889	20 f2 97	jsr $97f2			jsr 	EvaluateTerm				; evaluate the term
.988c	20 36 96	jsr $9636			jsr 	Dereference 				; dereference it.
.988f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.9892	d0 07		bne $989b			bne 	_ETTypeMismatch
.9894	68		pla				pla 								; indirection 1-2
.9895	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9897	9d 00 04	sta $0400,x			sta 	NSStatus,x
.989a	60		rts				rts
.989b					_ETTypeMismatch:
.989b	4c c0 9f	jmp $9fc0			jmp 	TypeError
.989e					_ETUnaryNegate:
.989e	20 f2 97	jsr $97f2			jsr 	EvaluateTerm				; evaluate the term
.98a1	20 36 96	jsr $9636			jsr 	Dereference 				; dereference it.
.98a4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.98a7	29 10		and #$10			and 	#NSTString
.98a9	d0 f0		bne $989b			bne 	_ETTypeMismatch
.98ab	4c d8 9d	jmp $9dd8			jmp 	NSMNegate  					; just toggles the sign bit.
.98ae					_ETDereference:
.98ae	20 f2 97	jsr $97f2			jsr 	EvaluateTerm				; evaluate the term
.98b1	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.98b4	29 20		and #$20			and 	#NSBIsReference
.98b6	f0 e3		beq $989b			beq 	_ETTypeMismatch
.98b8	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.98bb	60		rts				rts
.98bc					_ETParenthesis:
.98bc	20 18 93	jsr $9318			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.98bf	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; check for )
.98c2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.98c3					VariableHandler:
.98c3	b1 30		lda ($30),y			lda 	(codePtr),y
.98c5	18		clc				clc
.98c6	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98c8	85 37		sta $37				sta 	zTemp0+1
.98ca	c8		iny				iny
.98cb	b1 30		lda ($30),y			lda 	(codePtr),y
.98cd	85 36		sta $36				sta 	zTemp0
.98cf	c8		iny				iny
.98d0	18		clc				clc									; copy variable address+3 to mantissa
.98d1	69 03		adc #$03			adc 	#3
.98d3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98d6	a5 37		lda $37				lda 	zTemp0+1
.98d8	69 00		adc #$00			adc 	#0
.98da	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.98dd	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.98e0	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.98e3	9e 28 04	stz $0428,x			stz 	NSExponent,x
.98e6	5a		phy				phy
.98e7	a0 02		ldy #$02			ldy 	#2 							; read type
.98e9	b1 36		lda ($36),y			lda 	(zTemp0),y
.98eb	7a		ply				ply
.98ec	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98ee	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98f0	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98f3	29 04		and #$04			and 	#NSBIsArray
.98f5	d0 01		bne $98f8			bne 	_VHArray
.98f7	60		rts				rts
.98f8					_VHArray:
.98f8	e8		inx				inx
.98f9	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get the 1st index.
.98fc	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.98fe	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9901	b1 30		lda ($30),y			lda 	(codePtr),y
.9903	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9905	d0 06		bne $990d			bne 	_VHNoSecondIndex
.9907	c8		iny				iny 								; skip the comma
.9908	e8		inx				inx
.9909	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.990c	ca		dex				dex
.990d					_VHNoSecondIndex:
.990d	ca		dex				dex 								; set X back.
.990e	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; and check the right bracket.
.9911	5a		phy				phy 								; save position
.9912	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9914	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9916	f0 6b		beq $9983			beq 	_VHBadIndex
.9918	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.991b	85 3e		sta $3e				sta 	zaTemp
.991d	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9920	85 3f		sta $3f				sta 	zaTemp+1
.9922	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9924	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9926	f0 02		beq $992a			beq 	_VHHas2Mask
.9928	a9 ff		lda #$ff			lda 	#$FF
.992a					_VHHas2Mask:
.992a	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.992d	f0 54		beq $9983			beq 	_VHBadIndex
.992f	0a		asl a				asl 	a 							; carry will be set if a second index
.9930	90 09		bcc $993b			bcc 	_VHCheckFirstIndex
.9932	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9934	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9936	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.9939	90 48		bcc $9983			bcc 	_VHBadIndex
.993b					_VHCheckFirstIndex:
.993b	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.993d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.993f	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.9942	90 3f		bcc $9983			bcc 	_VHBadIndex
.9944	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9946	64 37		stz $37				stz 	zTemp0+1
.9948	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.994b	30 0f		bmi $995c			bmi 	_VHNoMultiply
.994d	da		phx				phx
.994e	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9951	48		pha				pha
.9952	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9954	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9956	1a		inc a				inc 	a 							; add 1 for zero base
.9957	fa		plx				plx
.9958	20 c1 9d	jsr $9dc1			jsr 	Multiply8x8 				; calculate -> Z0
.995b	fa		plx				plx
.995c					_VHNoMultiply:
.995c	18		clc				clc
.995d	a5 36		lda $36				lda 	zTemp0
.995f	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9962	85 36		sta $36				sta 	zTemp0
.9964	a5 37		lda $37				lda 	zTemp0+1
.9966	69 00		adc #$00			adc 	#0
.9968	85 37		sta $37				sta 	zTemp0+1
.996a	bd 00 04	lda $0400,x			lda 	NSStatus,x
.996d	20 f4 84	jsr $84f4			jsr 	ScaleByBaseType
.9970	18		clc				clc
.9971	b2 3e		lda ($3e)			lda 	(zaTemp)
.9973	65 36		adc $36				adc 	zTemp0
.9975	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9978	a0 01		ldy #$01			ldy 	#1
.997a	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.997c	65 37		adc $37				adc 	zTemp0+1
.997e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9981	7a		ply				ply 								; restore position
.9982	60		rts				rts
.9983					_VHBadIndex:
.9983	a9 17		lda #$17		lda	#23
.9985	4c 69 8d	jmp $8d69		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9988					AbsUnary:
.9988	fa		plx				plx 								; restore stack pos
.9989	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; get a float or int
.998c	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.998f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.9992	29 7f		and #$7f			and 	#$7F
.9994	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9997	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9998					AllocUnary:
.9998	fa		plx				plx 								; restore stack pos
.9999	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger		; get bytes required.
.999c	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.999f	da		phx				phx 								; save X/Y
.99a0	5a		phy				phy
.99a1	8a		txa				txa 								; copy X into Y
.99a2	a8		tay				tay
.99a3	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.99a6	aa		tax				tax
.99a7	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.99aa	20 b7 99	jsr $99b7			jsr 	AllocateXABytes 			; allocate memory
.99ad	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.99b0	8a		txa				txa
.99b1	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.99b4	7a		ply				ply
.99b5	fa		plx				plx
.99b6	60		rts				rts
.99b7					AllocateXABytes:
.99b7	5a		phy				phy
.99b8	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99bb	84 36		sty $36				sty 	zTemp0
.99bd	5a		phy				phy
.99be	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.99c1	84 37		sty $37				sty 	zTemp0+1
.99c3	5a		phy				phy
.99c4	18		clc				clc 								; add to low memory pointer
.99c5	6d 8c 04	adc $048c			adc 	lowMemPtr
.99c8	8d 8c 04	sta $048c			sta 	lowMemPtr
.99cb	8a		txa				txa
.99cc	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.99cf	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.99d2	b0 2f		bcs $9a03			bcs 	CISSMemory
.99d4	20 f5 99	jsr $99f5			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.99d7					_ClearMemory:
.99d7	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.99da	c5 36		cmp $36				cmp 	zTemp0
.99dc	d0 07		bne $99e5			bne 	_CMClearNext
.99de	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.99e1	c5 37		cmp $37				cmp 	zTemp0+1
.99e3	f0 0c		beq $99f1			beq 	_CMExit
.99e5					_CMClearNext:
.99e5	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99e7	92 36		sta ($36)			sta 	(zTemp0)
.99e9	e6 36		inc $36				inc 	zTemp0
.99eb	d0 ea		bne $99d7			bne 	_ClearMemory
.99ed	e6 37		inc $37				inc		zTemp0+1
.99ef	80 e6		bra $99d7			bra 	_ClearMemory
.99f1					_CMExit:
.99f1	fa		plx				plx
.99f2	68		pla				pla
.99f3	7a		ply				ply
.99f4	60		rts				rts
.99f5					CheckIdentifierStringSpace:
.99f5	48		pha				pha
.99f6	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.99f9	18		clc				clc
.99fa	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99fc	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.99ff	b0 02		bcs $9a03			bcs 	CISSMemory
.9a01	68		pla				pla
.9a02	60		rts				rts
.9a03					CISSMemory:
.9a03	a9 06		lda #$06		lda	#6
.9a05	4c 69 8d	jmp $8d69		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a08					AscUnary:
.9a08	fa		plx				plx 								; restore stack pos
.9a09	20 60 9d	jsr $9d60			jsr 	EvaluateString 				; get a string
.9a0c	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9a0e	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.9a11	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9a14	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a15					FracUnary:
.9a15	fa		plx				plx 								; restore stack pos
.9a16	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; get a float or int
.9a19	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9a1c	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a1f	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a21	f0 04		beq $9a27			beq 	_IUZero
.9a23	20 4b 94	jsr $944b			jsr 	FloatFractionalPart
.9a26	60		rts				rts
.9a27					_IUZero:
.9a27	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.9a2a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a2b					IntUnary:
.9a2b	fa		plx				plx 								; restore stack pos
.9a2c	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; get a float or int
.9a2f	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9a32	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a35	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a37	f0 03		beq $9a3c			beq 	_IUExit
.9a39	20 ae 94	jsr $94ae			jsr 	FloatIntegerPart
.9a3c					_IUExit:
.9a3c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a3d					LenUnary:
.9a3d	fa		plx				plx 								; restore stack pos
.9a3e	20 60 9d	jsr $9d60			jsr 	EvaluateString 				; get a string
.9a41	5a		phy				phy
.9a42	a0 00		ldy #$00			ldy 	#0 							; find length
.9a44					_LenFind:
.9a44	b1 36		lda ($36),y			lda 	(zTemp0),y
.9a46	f0 06		beq $9a4e			beq 	_LenExit
.9a48	c8		iny				iny
.9a49	d0 f9		bne $9a44			bne 	_LenFind
.9a4b	4c bb 9f	jmp $9fbb			jmp 	RangeError 					; string > 255
.9a4e					_LenExit:
.9a4e	98		tya				tya
.9a4f	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.9a52	7a		ply				ply
.9a53	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9a56	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a57					Unary_Min:
.9a57	a9 01		lda #$01			lda 	#1
.9a59	80 02		bra $9a5d			bra 	UnaryMinMaxMain
.9a5b					Unary_Max:
.9a5b	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a5d					UnaryMinMaxMain:
.9a5d	fa		plx				plx 								; get index on number stack
.9a5e	48		pha				pha 								; save comparator
.9a5f	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue 				; get the first value.
.9a62					_UMMMLoop:
.9a62	b1 30		lda ($30),y			lda 	(codePtr),y
.9a64	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a66	f0 22		beq $9a8a			beq 	_UMMMDone
.9a68	20 58 8d	jsr $8d58			jsr 	CheckComma 					; must be a comma
.9a6b	e8		inx				inx
.9a6c	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue
.9a6f	ca		dex				dex
.9a70	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a73	e8		inx				inx
.9a74	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a77	e8		inx				inx
.9a78	20 21 8e	jsr $8e21			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a7b	ca		dex				dex
.9a7c	ca		dex				dex
.9a7d	85 36		sta $36				sta 	zTemp0 						; save required result
.9a7f	68		pla				pla 								; get and save comparator
.9a80	48		pha				pha
.9a81	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a83	d0 dd		bne $9a62			bne 	_UMMMLoop
.9a85	20 8d 9a	jsr $9a8d			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a88	80 d8		bra $9a62			bra 	_UMMMLoop
.9a8a					_UMMMDone:
.9a8a	68		pla				pla 								; throw the comparator
.9a8b	c8		iny				iny 								; skip )
.9a8c	60		rts				rts
.9a8d					ExpCopyAboveDown:
.9a8d	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9a90	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a93	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9a96	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9a99	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9a9c	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a9f	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9aa2	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9aa5	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9aa8	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9aab	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9aae	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9ab1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9ab2					Unary_Not:
.9ab2	fa		plx				plx
.9ab3	20 78 9d	jsr $9d78			jsr 	EvaluateInteger 			; get integer
.9ab6	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9ab9	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; zero mantissa ?
.9abc	f0 04		beq $9ac2			beq 	_NotZero
.9abe	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.9ac1	60		rts				rts
.9ac2					_NotZero:
.9ac2	4c d6 8d	jmp $8dd6			jmp 	ReturnTrue
.9ac5					_UNBad:
.9ac5	4c c5 9f	jmp $9fc5			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9ac8					Unary_Random:
.9ac8	fa		plx				plx
.9ac9	20 47 9b	jsr $9b47			jsr 	Random32Bit 				; get a random number
.9acc	20 2c 9b	jsr $9b2c			jsr 	URCopyToMantissa  			; put in mantissa
.9acf	b1 30		lda ($30),y			lda 	(codePtr),y
.9ad1	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9ad3	f0 08		beq $9add			beq 	_URNoModulus
.9ad5	e8		inx				inx
.9ad6	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9ad9	ca		dex				dex
.9ada	20 45 8f	jsr $8f45			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9add					_URNoModulus:
.9add	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9ae0	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9ae3	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9ae6	60		rts				rts
.9ae7					Unary_Rnd:
.9ae7	fa		plx				plx
.9ae8	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; number to use.
.9aeb	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; closing bracket
.9aee	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9af1	f0 2b		beq $9b1e			beq 	_URCopySeed
.9af3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9af6	10 23		bpl $9b1b			bpl 	_URDontSeed
.9af8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9afb	49 17		eor #$17			eor 	#$17
.9afd	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b00	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9b03	49 a5		eor #$a5			eor 	#$A5
.9b05	8d 89 04	sta $0489			sta 	RandomSeed+1
.9b08	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9b0b	49 c2		eor #$c2			eor 	#$C2
.9b0d	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9b10	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9b13	49 9d		eor #$9d			eor 	#$9D
.9b15	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9b18	20 47 9b	jsr $9b47			jsr 	Random32Bit
.9b1b					_URDontSeed:
.9b1b	20 47 9b	jsr $9b47			jsr 	Random32Bit 				; generate a number.
.9b1e					_URCopySeed:
.9b1e	20 2c 9b	jsr $9b2c			jsr 	URCopyToMantissa 			; copy into mantissa
.9b21	a9 e1		lda #$e1			lda 	#-31 						; force into 0-1 range
.9b23	8d 28 04	sta $0428			sta 	NSExponent
.9b26	a9 08		lda #$08			lda 	#NSTFloat
.9b28	8d 00 04	sta $0400			sta 	NSStatus 					; positive.
.9b2b	60		rts				rts
.9b2c					URCopyToMantissa:
.9b2c	ad 88 04	lda $0488			lda 	RandomSeed+0
.9b2f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b32	ad 89 04	lda $0489			lda 	RandomSeed+1
.9b35	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b38	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9b3b	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b3e	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9b41	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b43	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b46	60		rts				rts
.9b47					Random32Bit:
.9b47	5a		phy				phy
.9b48	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b4a	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9b4d	d0 03		bne $9b52			bne 	_Random1
.9b4f	a8		tay				tay 								; if so do it 256 times
.9b50	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b52					_Random1:
.9b52	0a		asl a				asl 	a 							; LSFR RNG
.9b53	2e 89 04	rol $0489			rol 	RandomSeed+1
.9b56	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9b59	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9b5c	90 02		bcc $9b60			bcc 	_Random2
.9b5e	49 c5		eor #$c5			eor 	#$C5
.9b60					_Random2:
.9b60	88		dey				dey
.9b61	d0 ef		bne $9b52			bne 	_Random1
.9b63	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b66	7a		ply				ply
.9b67	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b68					SgnUnary:
.9b68	fa		plx				plx 								; restore stack pos
.9b69	20 55 9d	jsr $9d55			jsr 	EvaluateNumber 				; get a float or int
.9b6c	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9b6f	20 5c 9e	jsr $9e5c			jsr 	NSMIsZero 					; if zero
.9b72	f0 10		beq $9b84			beq 	_SGZero  					; return Int Zero
.9b74	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9b77	48		pha				pha
.9b78	a9 01		lda #$01			lda 	#1 							; set to 1
.9b7a	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.9b7d	68		pla				pla
.9b7e	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b80	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b83	60		rts				rts
.9b84	20 2c 9e	jsr $9e2c	_SGZero:jsr 	NSMSetZero
.9b87	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b88					ValUnary:
.9b88	fa		plx				plx 								; restore stack pos
.9b89	20 9e 9b	jsr $9b9e			jsr 	ValMainCode 				; do the main val() code
.9b8c	b0 01		bcs $9b8f			bcs 	_VUError 					; couldn't convert
.9b8e	60		rts				rts
.9b8f					_VUError:
.9b8f	4c c0 9f	jmp $9fc0			jmp 	TypeError
.9b92					IsValUnary:
.9b92	fa		plx				plx 								; restore stack pos
.9b93	20 9e 9b	jsr $9b9e			jsr 	ValMainCode 				; do the main val() code
.9b96	b0 03		bcs $9b9b			bcs 	_VUBad
.9b98	4c d6 8d	jmp $8dd6			jmp 	ReturnTrue
.9b9b					_VUBad:
.9b9b	4c e2 8d	jmp $8de2			jmp 	ReturnFalse
.9b9e					ValMainCode:
.9b9e	20 60 9d	jsr $9d60			jsr 	EvaluateString 				; get a string
.9ba1	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; check right bracket present
.9ba4	5a		phy				phy
.9ba5	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9ba7	f0 17		beq $9bc0			beq 	_VMCFail2
.9ba9	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9bab	48		pha				pha 								; save first character
.9bac	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9bae	d0 01		bne $9bb1			bne 	_VMCStart
.9bb0	c8		iny				iny 								; skip over -
.9bb1					_VMCStart:
.9bb1	38		sec				sec 								; initialise first time round.
.9bb2					_VMCNext:
.9bb2	c8		iny				iny 								; pre-increment
.9bb3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9bb5	f0 0c		beq $9bc3			beq 	_VMCSuccess 				; successful.
.9bb7	20 d4 96	jsr $96d4			jsr 	EncodeNumber 				; send it to the number-builder
.9bba	90 03		bcc $9bbf			bcc 	_VMCFail 					; if failed, give up.
.9bbc	18		clc				clc 								; next time round, countinue
.9bbd	80 f3		bra $9bb2			bra 	_VMCNext
.9bbf					_VMCFail:
.9bbf	68		pla				pla
.9bc0					_VMCFail2:
.9bc0	7a		ply				ply
.9bc1	38		sec				sec
.9bc2	60		rts				rts
.9bc3					_VMCSuccess:
.9bc3	a9 00		lda #$00			lda 	#0 							; construct final
.9bc5	20 d4 96	jsr $96d4			jsr 	EncodeNumber
.9bc8	68		pla				pla
.9bc9	c9 2d		cmp #$2d			cmp 	#"-"
.9bcb	d0 03		bne $9bd0			bne 	_VMCNotNegative
.9bcd	20 d8 9d	jsr $9dd8			jsr		NSMNegate
.9bd0					_VMCNotNegative:
.9bd0	7a		ply				ply
.9bd1	18		clc				clc
.9bd2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9bd3					ChrUnary:
.9bd3	fa		plx				plx 								; restore stack pos
.9bd4	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger			; get value
.9bd7	48		pha				pha
.9bd8	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9bdb	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9bdd	20 78 a7	jsr $a778			jsr 	StringTempAllocate
.9be0	68		pla				pla 								; write number to it
.9be1	20 b6 a7	jsr $a7b6			jsr 	StringTempWrite
.9be4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9be5					SpcUnary:
.9be5	fa		plx				plx 								; restore stack pos
.9be6	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger			; get value
.9be9	5a		phy				phy
.9bea	48		pha				pha 								; save count
.9beb	20 78 a7	jsr $a778			jsr 	StringTempAllocate
.9bee	7a		ply				ply 								; to do count in Y
.9bef					_SpcLoop:
.9bef	c0 00		cpy #$00			cpy 	#0
.9bf1	f0 08		beq $9bfb			beq 	_SpcExit
.9bf3	a9 20		lda #$20			lda 	#32
.9bf5	20 b6 a7	jsr $a7b6			jsr 	StringTempWrite
.9bf8	88		dey				dey
.9bf9	80 f4		bra $9bef			bra 	_SPCLoop
.9bfb					_SpcExit:
.9bfb	7a		ply				ply
.9bfc	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.9bff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c00					Unary_Str:
.9c00	fa		plx				plx
.9c01	20 55 9d	jsr $9d55			jsr 	EvaluateNumber  			; get number
.9c04	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; closing bracket
.9c07	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c09	20 22 9c	jsr $9c22			jsr 	ConvertNumberToString 		; do the conversion.
.9c0c	a9 21		lda #$21			lda		#33 						; create buffer
.9c0e	20 78 a7	jsr $a778			jsr 	StringTempAllocate 			; allocate memory
.9c11	da		phx				phx
.9c12	a2 00		ldx #$00			ldx 	#0
.9c14					_USCopy:
.9c14	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c17	20 b6 a7	jsr $a7b6			jsr 	StringTempWrite
.9c1a	e8		inx				inx
.9c1b	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c1e	d0 f4		bne $9c14			bne 	_USCopy
.9c20	fa		plx				plx
.9c21	60		rts				rts
.9c22					ConvertNumberToString:
.9c22	5a		phy				phy 								; save code position
.9c23	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9c26	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9c29	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9c2c	10 0a		bpl $9c38			bpl 	_CNTSNotNegative
.9c2e	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c30	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c33	a9 2d		lda #$2d			lda 	#"-"
.9c35	20 9e 9c	jsr $9c9e			jsr 	WriteDecimalBuffer
.9c38					_CNTSNotNegative:
.9c38	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9c3b	f0 15		beq $9c52			beq 	_CNTSNotFloat
.9c3d	e8		inx				inx 								; round up
.9c3e	a9 01		lda #$01			lda 	#1
.9c40	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.9c43	ca		dex				dex
.9c44	bd 28 04	lda $0428,x			lda		NSExponent,x
.9c47	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9c4a	a9 08		lda #$08			lda 	#NSTFloat
.9c4c	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9c4f	20 65 93	jsr $9365			jsr 	FloatAdd
.9c52					_CNTSNotFloat:
.9c52	20 80 9c	jsr $9c80			jsr 	MakePlusTwoString
.9c55	20 4b 94	jsr $944b			jsr 	FloatFractionalPart 		; get the fractional part
.9c58	20 0f 95	jsr $950f			jsr 	NSNormalise					; normalise , exit if zero
.9c5b	f0 21		beq $9c7e			beq 	_CNTSExit
.9c5d	a9 2e		lda #$2e			lda 	#"."
.9c5f	20 9e 9c	jsr $9c9e			jsr 	WriteDecimalBuffer 			; write decimal place
.9c62					_CNTSDecimal:
.9c62	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9c65	30 17		bmi $9c7e			bmi 	_CNTSExit
.9c67	e8		inx				inx 								; x 10.0
.9c68	a9 0a		lda #$0a			lda 	#10
.9c6a	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.9c6d	a9 08		lda #$08			lda 	#NSTFloat
.9c6f	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c72	ca		dex				dex
.9c73	20 d8 94	jsr $94d8			jsr 	FloatMultiply
.9c76	20 80 9c	jsr $9c80			jsr 	MakePlusTwoString
.9c79	20 4b 94	jsr $944b			jsr 	FloatFractionalPart 		; get the fractional part
.9c7c	80 e4		bra $9c62			bra 	_CNTSDecimal 				; keep going.
.9c7e					_CNTSExit:
.9c7e	7a		ply				ply
.9c7f	60		rts				rts
.9c80					MakePlusTwoString:
.9c80	da		phx				phx
.9c81	20 03 9e	jsr $9e03			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c84	e8		inx				inx 								; access it
.9c85	e8		inx				inx
.9c86	20 ae 94	jsr $94ae			jsr 	FloatIntegerPart 			; make it an integer
.9c89	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c8b	20 90 92	jsr $9290			jsr 	ConvertInt32
.9c8e	a2 00		ldx #$00			ldx	 	#0
.9c90					_MPTSCopy:
.9c90	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c93	20 9e 9c	jsr $9c9e			jsr 	WriteDecimalBuffer
.9c96	e8		inx				inx
.9c97	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c9a	d0 f4		bne $9c90			bne 	_MPTSCopy
.9c9c	fa		plx				plx
.9c9d	60		rts				rts
.9c9e					WriteDecimalBuffer:
.9c9e	da		phx				phx
.9c9f	ae 95 04	ldx $0495			ldx 	dbOffset
.9ca2	9d 1b 06	sta $061b,x			sta 	DecimalBuffer,x
.9ca5	9e 1c 06	stz $061c,x			stz 	DecimalBuffer+1,x
.9ca8	ee 95 04	inc $0495			inc 	dbOffset
.9cab	fa		plx				plx
.9cac	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9cad					Unary_Left:
.9cad	fa		plx				plx
.9cae	18		clc				clc 								; only one parameter
.9caf	20 24 9d	jsr $9d24			jsr 	SubstringInitial 			; set up.
.9cb2	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9cb5	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cb8	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9cbb	80 2c		bra $9ce9			bra 	SubstringMain
.9cbd					Unary_Right:
.9cbd	fa		plx				plx
.9cbe	18		clc				clc 								; only one parameter
.9cbf	20 24 9d	jsr $9d24			jsr 	SubstringInitial 			; set up.
.9cc2	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9cc5	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cc8	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9ccb	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cce	b0 02		bcs $9cd2			bcs 	_URNotUnderflow
.9cd0	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cd2					_URNotUnderFlow:
.9cd2	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cd5	80 12		bra $9ce9			bra 	SubStringMain
.9cd7					Unary_Mid:
.9cd7	fa		plx				plx
.9cd8	38		sec				sec 								; two parameters
.9cd9	20 24 9d	jsr $9d24			jsr 	SubstringInitial 			; set up.
.9cdc	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9cdf	f0 05		beq $9ce6			beq 	_UMError
.9ce1	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9ce4	80 03		bra $9ce9			bra 	SubStringMain
.9ce6					_UMError:
.9ce6	4c c5 9f	jmp $9fc5			jmp 	ArgumentError
.9ce9					SubStringMain:
.9ce9	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9cec	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9cef	b0 2d		bcs $9d1e			bcs 	_SSMNull 					; if so, return an empty string.
.9cf1	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9cf4	f0 28		beq $9d1e			beq 	_SSMNull 					; return empty string.
.9cf6	18		clc				clc 								; add the offset +1 to the address and
.9cf7	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9cfa	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9cfd	85 36		sta $36				sta 	zTemp0
.9cff	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9d02	69 00		adc #$00			adc 	#0
.9d04	85 37		sta $37				sta 	zTemp0+1
.9d06					_SSMNoCarry:
.9d06	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d09	20 78 a7	jsr $a778			jsr 	StringTempAllocate 			; allocate that many characters
.9d0c	5a		phy				phy 								; save Y
.9d0d	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d0f					_SSMCopy:
.9d0f	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d11	f0 09		beq $9d1c			beq 	_SSMEString 				; no more to copy
.9d13	20 b6 a7	jsr $a7b6			jsr 	StringTempWrite 			; and write it out.
.9d16	c8		iny				iny
.9d17	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9d1a	d0 f3		bne $9d0f			bne 	_SSMCopy
.9d1c					_SSMEString:
.9d1c	7a		ply				ply
.9d1d					_SSMExit:
.9d1d	60		rts				rts
.9d1e					_SSMNull:
.9d1e	a9 00		lda #$00			lda 	#0
.9d20	20 78 a7	jsr $a778			jsr 	StringTempAllocate
.9d23	60		rts				rts
.9d24					SubstringInitial:
.9d24	da		phx				phx 								; save initial stack position
.9d25	08		php				php 								; save carry on stack indicating 2 parameters
.9d26	20 60 9d	jsr $9d60			jsr 	EvaluateString 				; get a string
.9d29	5a		phy				phy 								; calculate length to exponent.
.9d2a	a0 ff		ldy #$ff			ldy 	#$FF
.9d2c					_SIFindLength:
.9d2c	c8		iny				iny
.9d2d	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d2f	d0 fb		bne $9d2c			bne 	_SIFindLength
.9d31	98		tya				tya
.9d32	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9d35	7a		ply				ply
.9d36	e8		inx				inx
.9d37	20 58 8d	jsr $8d58			jsr 	CheckComma 					; comma next
.9d3a	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get next parameter
.9d3d	28		plp				plp 								; is it the last parameter ?
.9d3e	90 07		bcc $9d47			bcc 	_SSIExit 					; if so, exit.
.9d40	e8		inx				inx
.9d41	20 58 8d	jsr $8d58			jsr 	CheckComma 					; comma next
.9d44	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get last parameter
.9d47					_SSIExit:
.9d47	fa		plx				plx
.9d48	20 50 8d	jsr $8d50			jsr 	CheckRightBracket 			; check closing bracket
.9d4b	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d4c					EvaluateValue:
.9d4c	48		pha				pha
.9d4d	20 18 93	jsr $9318			jsr		EvaluateExpression 			; expression
.9d50	20 36 96	jsr $9636			jsr 	Dereference					; derefernce it
.9d53	68		pla				pla
.9d54	60		rts				rts
.9d55					EvaluateNumber:
.9d55	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue 				; get a value
.9d58	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d5b	29 10		and #$10			and 	#NSBIsString
.9d5d	d0 16		bne $9d75			bne 	HelperTypeError
.9d5f	60		rts				rts
.9d60					EvaluateString:
.9d60	20 4c 9d	jsr $9d4c			jsr 	EvaluateValue 				; get a value
.9d63	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d66	29 10		and #$10			and 	#NSBIsString
.9d68	f0 0b		beq $9d75			beq 	HelperTypeError
.9d6a					CopyAddressToTemp0:
.9d6a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d6d	85 36		sta $36				sta 	zTemp0
.9d6f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9d72	85 37		sta $37				sta 	zTemp0+1
.9d74	60		rts				rts
.9d75					HelperTypeError:
.9d75	4c c0 9f	jmp $9fc0			jmp 	TypeError
.9d78					EvaluateInteger:
.9d78	20 55 9d	jsr $9d55			jsr 	EvaluateNumber
.9d7b	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9d7e	d0 0a		bne $9d8a			bne 	HelperValueError 			; if not, it's a float.
.9d80	60		rts				rts
.9d81					EvaluateUnsignedInteger:
.9d81	20 78 9d	jsr $9d78			jsr 	EvaluateInteger 			; check integer is +ve
.9d84	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9d87	30 01		bmi $9d8a			bmi 	HelperValueError
.9d89	60		rts				rts
.9d8a					HelperValueError:
.9d8a	4c c5 9f	jmp $9fc5			jmp 	ArgumentError
.9d8d					Evaluate16BitInteger:
.9d8d	20 81 9d	jsr $9d81			jsr	 	EvaluateUnsignedInteger		; get integer
.9d90	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d93	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9d96	d0 f2		bne $9d8a			bne 	HelperValueError
.9d98	60		rts				rts
.9d99					Evaluate16BitIntegerSigned:
.9d99	20 78 9d	jsr $9d78			jsr	 	EvaluateInteger				; get integer
.9d9c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d9f	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9da2	d0 e6		bne $9d8a			bne 	HelperValueError
.9da4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9da7	10 03		bpl $9dac			bpl 	_EISNotSigned
.9da9	20 e1 9d	jsr $9de1			jsr 	NSMNegateMantissa
.9dac					_EISNotSigned:
.9dac	60		rts				rts
.9dad					Evaluate8BitInteger:
.9dad	20 81 9d	jsr $9d81			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9db0	d0 d8		bne $9d8a			bne 	HelperValueError
.9db2	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9db5	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9db8	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9dbb	d0 cd		bne $9d8a			bne 	HelperValueError
.9dbd	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9dc0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dc1					Multiply8x8:
.9dc1	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dc2	85 36		sta $36			  	sta 	zTemp0
.9dc4	86 37		stx $37				stx 	zTemp0+1
.9dc6	a9 00		lda #$00			lda 	#0
.9dc8	a2 08		ldx #$08			ldx 	#8
.9dca					_M88Loop:
.9dca	90 03		bcc $9dcf			bcc 	_M88NoAdd
.9dcc	18		clc				clc
.9dcd	65 37		adc $37				adc 	zTemp0+1
.9dcf					_M88NoAdd:
.9dcf	6a		ror a				ror 	a
.9dd0	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dd2	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9dd3	d0 f5		bne $9dca			bne 	_M88Loop
.9dd5	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9dd7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9dd8					NSMNegate:
.9dd8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ddb	49 80		eor #$80			eor 	#NSBIsNegative
.9ddd	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9de0	60		rts				rts
.9de1					NSMNegateMantissa:
.9de1	38		sec				sec
.9de2	a9 00		lda #$00			lda 	#0
.9de4	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9de7	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9dea	a9 00		lda #$00			lda 	#0
.9dec	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9def	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9df2	a9 00		lda #$00			lda 	#0
.9df4	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9df7	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9dfa	a9 00		lda #$00			lda 	#0
.9dfc	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9dff	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9e02	60		rts				rts
.9e03					NSMShiftUpTwo:
.9e03	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e06	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9e09	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e0c	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9e0f	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9e12	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9e15	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e18	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9e1b	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9e1e	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9e21	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e24	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9e27	60		rts				rts
.9e28					NSMSetZeroMantissaOnly:
.9e28	a9 00		lda #$00			lda 	#0
.9e2a	80 08		bra $9e34			bra 	NSMSetMantissa
.9e2c					NSMSetZero:
.9e2c	a9 00		lda #$00			lda 	#0
.9e2e					NSMSetByte:
.9e2e	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e31	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9e34					NSMSetMantissa:
.9e34	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9e37	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9e3a	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9e3d	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9e40	60		rts				rts
.9e41					NSMShiftLeft:
.9e41	18		clc				clc
.9e42					NSMRotateLeft:
.9e42	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9e45	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9e48	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9e4b	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9e4e	60		rts				rts
.9e4f					NSMShiftRight:
.9e4f	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9e52	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9e55	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9e58	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9e5b	60		rts				rts
.9e5c					NSMIsZero:
.9e5c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e5f	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9e62	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9e65	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9e68	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.b96d					TickHandler:
.b96d	60		rts				rts
.062d					LastTick:
>062d							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e69					Assemble_ora:
.9e69	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e6c	01					.byte $01
.9e6d					Assemble_and:
.9e6d	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e70	21					.byte $21
.9e71					Assemble_eor:
.9e71	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e74	41					.byte $41
.9e75					Assemble_adc:
.9e75	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e78	61					.byte $61
.9e79					Assemble_sta:
.9e79	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e7c	81					.byte $81
.9e7d					Assemble_lda:
.9e7d	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e80	a1					.byte $a1
.9e81					Assemble_cmp:
.9e81	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e84	c1					.byte $c1
.9e85					Assemble_sbc:
.9e85	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e88	e1					.byte $e1
.9e89					Assemble_asl:
.9e89	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e8c	02					.byte $02
>9e8d	75					.byte $75
.9e8e					Assemble_rol:
.9e8e	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e91	22					.byte $22
>9e92	75					.byte $75
.9e93					Assemble_lsr:
.9e93	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e96	42					.byte $42
>9e97	75					.byte $75
.9e98					Assemble_ror:
.9e98	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e9b	62					.byte $62
>9e9c	75					.byte $75
.9e9d					Assemble_stx:
.9e9d	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ea0	82					.byte $82
>9ea1	50					.byte $50
.9ea2					Assemble_ldx:
.9ea2	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ea5	a2					.byte $a2
>9ea6	d0					.byte $d0
.9ea7					Assemble_dec:
.9ea7	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eaa	c2					.byte $c2
>9eab	55					.byte $55
.9eac					Assemble_inc:
.9eac	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eaf	e2					.byte $e2
>9eb0	55					.byte $55
.9eb1					Assemble_stz:
.9eb1	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eb4	60					.byte $60
>9eb5	44					.byte $44
.9eb6					Assemble_bit:
.9eb6	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eb9	20					.byte $20
>9eba	55					.byte $55
.9ebb					Assemble_sty:
.9ebb	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ebe	80					.byte $80
>9ebf	54					.byte $54
.9ec0					Assemble_ldy:
.9ec0	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ec3	a0					.byte $a0
>9ec4	d5					.byte $d5
.9ec5					Assemble_cpy:
.9ec5	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ec8	c0					.byte $c0
>9ec9	d4					.byte $d4
.9eca					Assemble_cpx:
.9eca	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ecd	e0					.byte $e0
>9ece	d0					.byte $d0
.9ecf					Assemble_tsb:
.9ecf	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ed2	00					.byte $00
>9ed3	50					.byte $50
.9ed4					Assemble_trb:
.9ed4	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ed7	10					.byte $10
>9ed8	50					.byte $50
.9ed9					Assemble_jsr:
.9ed9	20 72 80	jsr $8072		jsr	AssembleGroup2
>9edc	14					.byte $14
>9edd	10					.byte $10
.9ede					Assemble_jmp:
.9ede	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ee1	40					.byte $40
>9ee2	10					.byte $10
.9ee3					Assemble_bpl:
.9ee3	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ee6	10					.byte $10
.9ee7					Assemble_bmi:
.9ee7	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9eea	30					.byte $30
.9eeb					Assemble_bvc:
.9eeb	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9eee	50					.byte $50
.9eef					Assemble_bvs:
.9eef	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ef2	70					.byte $70
.9ef3					Assemble_bcc:
.9ef3	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ef6	90					.byte $90
.9ef7					Assemble_bcs:
.9ef7	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9efa	b0					.byte $b0
.9efb					Assemble_bne:
.9efb	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9efe	d0					.byte $d0
.9eff					Assemble_beq:
.9eff	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f02	f0					.byte $f0
.9f03					Assemble_bra:
.9f03	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f06	80					.byte $80
.9f07					Assemble_brk:
.9f07	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f0a	00					.byte $00
.9f0b					Assemble_php:
.9f0b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f0e	08					.byte $08
.9f0f					Assemble_clc:
.9f0f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f12	18					.byte $18
.9f13					Assemble_plp:
.9f13	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f16	28					.byte $28
.9f17					Assemble_sec:
.9f17	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f1a	38					.byte $38
.9f1b					Assemble_rti:
.9f1b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f1e	40					.byte $40
.9f1f					Assemble_pha:
.9f1f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f22	48					.byte $48
.9f23					Assemble_cli:
.9f23	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f26	58					.byte $58
.9f27					Assemble_phy:
.9f27	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f2a	5a					.byte $5a
.9f2b					Assemble_rts:
.9f2b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f2e	60					.byte $60
.9f2f					Assemble_pla:
.9f2f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f32	68					.byte $68
.9f33					Assemble_sei:
.9f33	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f36	78					.byte $78
.9f37					Assemble_ply:
.9f37	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f3a	7a					.byte $7a
.9f3b					Assemble_dey:
.9f3b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f3e	88					.byte $88
.9f3f					Assemble_txa:
.9f3f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f42	8a					.byte $8a
.9f43					Assemble_tya:
.9f43	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f46	98					.byte $98
.9f47					Assemble_txs:
.9f47	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f4a	9a					.byte $9a
.9f4b					Assemble_tay:
.9f4b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f4e	a8					.byte $a8
.9f4f					Assemble_tax:
.9f4f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f52	aa					.byte $aa
.9f53					Assemble_clv:
.9f53	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f56	b8					.byte $b8
.9f57					Assemble_tsx:
.9f57	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f5a	ba					.byte $ba
.9f5b					Assemble_iny:
.9f5b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f5e	c8					.byte $c8
.9f5f					Assemble_dex:
.9f5f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f62	ca					.byte $ca
.9f63					Assemble_cld:
.9f63	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f66	d8					.byte $d8
.9f67					Assemble_phx:
.9f67	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f6a	da					.byte $da
.9f6b					Assemble_stp:
.9f6b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f6e	db					.byte $db
.9f6f					Assemble_inx:
.9f6f	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f72	e8					.byte $e8
.9f73					Assemble_nop:
.9f73	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f76	ea					.byte $ea
.9f77					Assemble_sed:
.9f77	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f7a	f8					.byte $f8
.9f7b					Assemble_plx:
.9f7b	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f7e	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f7f					DecimalScalarTable:
>9f7f	66 66 66 66				.dword $66666666 ; 0.1
>9f83	de					.byte $de
>9f84	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f88	db					.byte $db
>9f89	4c 37 89 41				.dword $4189374c ; 0.001
>9f8d	d8					.byte $d8
>9f8e	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f92	d4					.byte $d4
>9f93	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f97	d1					.byte $d1
>9f98	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f9c	ce					.byte $ce
>9f9d	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9fa1	ca					.byte $ca
>9fa2	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9fa6	c7					.byte $c7
>9fa7	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9fab	c4					.byte $c4
>9fac	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9fb0	c0					.byte $c0
>9fb1	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fb5	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fb6					SyntaxError:
.9fb6	a9 02		lda #$02		lda	#2
.9fb8	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.9fbb					RangeError:
.9fbb	a9 04		lda #$04		lda	#4
.9fbd	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.9fc0					TypeError:
.9fc0	a9 05		lda #$05		lda	#5
.9fc2	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.9fc5					ArgumentError:
.9fc5	a9 07		lda #$07		lda	#7
.9fc7	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.9fca					NotDoneError:
.9fca	a9 0c		lda #$0c		lda	#12
.9fcc	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.9fcf					ErrorText:
>9fcf	42 72 65 61 6b 00			.text	"Break",0
>9fd5	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fdd	72 72 6f 72 00
>9fe2	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fea	20 62 79 20 7a 65 72 6f 00
>9ff3	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9ffb	61 6e 67 65 00
>a000	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a008	6d 61 74 63 68 00
>a00e	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a016	65 6d 6f 72 79 00
>a01c	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a024	61 72 67 75 6d 65 6e 74 00
>a02d	53 74 6f 70 00				.text	"Stop",0
>a032	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a03a	6f 6f 20 6c 6f 6e 67 00
>a042	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a04a	6e 20 66 61 69 6c 65 64 00
>a053	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a05b	61 74 61 00
>a05f	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a067	65 6e 74 65 64 00
>a06d	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a075	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a081	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a089	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a096	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a09e	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a0ab	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0b3	68 6f 75 74 20 57 68 69 6c 65 00
>a0be	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0c6	68 6f 75 74 20 46 6f 72 00
>a0cf	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0d7	61 63 6b 20 66 75 6c 6c 00
>a0e0	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0e8	75 63 74 75 72 65 00
>a0ef	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0f7	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a104	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a10c	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a11a	41 72 72 61 79 20 73 69			.text	"Array size",0
>a122	7a 65 00
>a125	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a12d	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a135	42 75 69 6c 74 20 4d 6f			.text "Built Monday 21-Nov-2022. Build 3456."
>a13d	6e 64 61 79 20 32 31 2d 4e 6f 76 2d 32 30 32 32
>a14d	2e 20 42 75 69 6c 64 20 33 34 35 36 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a15a					RectangleCommand:
.a15a	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a15c	80 02		bra $a160			bra 	ShapeDrawCmd
.a15e					CircleCommand:
.a15e	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a160					ShapeDrawCmd:
.a160	20 ee a1	jsr $a1ee			jsr 	RunGraphicsCommand
.a163					ShapeDraw:
.a163	0d 2f 06	ora $062f			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a166	4c e2 a1	jmp $a1e2			jmp 	ExecuteGraphicCommand	 	; and complete
.a169					SpriteCommand:
.a169	a2 00		ldx #$00			ldx 	#0
.a16b	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get image number.
.a16e	5a		phy				phy
.a16f	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a171	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a174	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a176	b0 0d		bcs $a185			bcs 	_SCRange
.a178	a0 ff		ldy #$ff			ldy 	#255
.a17a	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a17d	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a17f	7a		ply				ply
.a180	20 ee a1	jsr $a1ee			jsr 	RunGraphicsCommand
.a183	80 5d		bra $a1e2			bra 	ExecuteGraphicCommand
.a185					_SCRange:
.a185	4c bb 9f	jmp $9fbb			jmp 	RangeError
.a188					ImageCommand:
.a188	a2 00		ldx #$00			ldx 	#0
.a18a	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get image number.
.a18d	20 ee a1	jsr $a1ee			jsr 	RunGraphicsCommand
.a190					ImageRunDraw:
.a190	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a192	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a195	ad 35 06	lda $0635			lda 	gxDrawScale
.a198	0a		asl a				asl 	a
.a199	0a		asl a				asl 	a
.a19a	0a		asl a				asl 	a
.a19b	a8		tay				tay
.a19c	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a19e	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a1a1	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a1a4	60		rts				rts
.a1a5					TextCommand:
.a1a5	a2 00		ldx #$00			ldx 	#0
.a1a7	20 60 9d	jsr $9d60			jsr 	EvaluateString 				; get text
.a1aa	20 ee a1	jsr $a1ee			jsr 	RunGraphicsCommand
.a1ad					TextRunDraw:
.a1ad	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1af	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a1b2	a0 00		ldy #$00			ldy 	#0
.a1b4					_IRDLoop:
.a1b4	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a1b7	85 37		sta $37				sta 	zTemp0+1
.a1b9	ad 08 04	lda $0408			lda 	NSMantissa0
.a1bc	85 36		sta $36				sta 	zTemp0
.a1be	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1c0	f0 13		beq $a1d5			beq 	_IRDExit
.a1c2	5a		phy				phy									; save string pos
.a1c3	48		pha				pha 								; save char
.a1c4	ad 35 06	lda $0635			lda 	gxDrawScale 				; get scale
.a1c7	0a		asl a				asl 	a
.a1c8	0a		asl a				asl 	a
.a1c9	0a		asl a				asl 	a
.a1ca	a8		tay				tay
.a1cb	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1cd	fa		plx				plx 								; char to draw
.a1ce	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a1d1	7a		ply				ply 								; restore string pos
.a1d2	c8		iny				iny
.a1d3	90 df		bcc $a1b4			bcc 	_IRDLoop 					; go back if no error.
.a1d5					_IRDExit:
.a1d5	60		rts				rts
.a1d6					PlotCommand:
.a1d6	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1d8	20 ee a1	jsr $a1ee			jsr 	RunGraphicsCommand
.a1db	80 05		bra $a1e2			bra 	ExecuteGraphicCommand
.a1dd					LineCommand:
.a1dd	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1df	20 ee a1	jsr $a1ee			jsr 	RunGraphicsCommand
.a1e2					ExecuteGraphicCommand:
.a1e2	0d 2e 06	ora $062e			ora 	gxCommandID 				; make a full command
.a1e5	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw 				; draw it and exit
.a1e8	b0 01		bcs $a1eb			bcs 	_EGCError
.a1ea	60		rts				rts
.a1eb					_EGCError:
.a1eb	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.a1ee					RunGraphicsCommand:
.a1ee	8d 2e 06	sta $062e			sta 	gxCommandID					; save TODO graphics command.
.a1f1	68		pla				pla 								; pop handler address
.a1f2	fa		plx				plx
.a1f3	1a		inc a				inc 	a
.a1f4	d0 01		bne $a1f7			bne 	_RGINoCarry
.a1f6	e8		inx				inx
.a1f7					_RGINoCarry:
.a1f7	8d 33 06	sta $0633			sta 	GXHandler
.a1fa	8e 34 06	stx $0634			stx 	GXHandler+1
.a1fd					_RGICommandLoop:
.a1fd	b1 30		lda ($30),y			lda 	(codePtr),y
.a1ff	c8		iny				iny
.a200	c9 cd		cmp #$cd			cmp 	#KWD_TO						; is it TO x,y
.a202	f0 53		beq $a257			beq 	_RGI_To
.a204	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a206	f0 55		beq $a25d			beq 	_RGI_Here
.a208	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a20a	f0 3d		beq $a249			beq 	_RGI_Exit
.a20c	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a20e	f0 39		beq $a249			beq 	_RGI_Exit
.a210	c9 c1		cmp #$c1			cmp 	#KWD_OUTLINE 				; solid or outline
.a212	f0 3e		beq $a252			beq 	_RGI_Frame
.a214	c9 c9		cmp #$c9			cmp 	#KWD_SOLID
.a216	f0 33		beq $a24b			beq 	_RGI_Solid
.a218	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a21a	f0 4b		beq $a267			beq 	_RGI_By
.a21c	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a21e	f0 17		beq $a237			beq 	_RGI_Move2
.a220	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a222	f0 65		beq $a289			beq 	_RGI_Dim
.a224	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a226	f0 78		beq $a2a0			beq 	_RGI_Colour
.a228	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a22a	f0 74		beq $a2a0			beq 	_RGI_Colour
.a22c	ae 2e 06	ldx $062e			ldx 	gxCommandID
.a22f	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a231	d0 03		bne $a236			bne 	_RGI_Move 					; move
.a233	4c ca a2	jmp $a2ca			jmp		_RGI_SpriteInstructions
.a236					_RGI_Move:
.a236	88		dey				dey 								; unpick get.
.a237					_RGI_Move2:
.a237	20 f0 a2	jsr $a2f0			jsr 	GCGetCoordinatePair 		; move to here
.a23a	20 17 a3	jsr $a317			jsr 	GCCopyPairToStore 			; save
.a23d	5a		phy				phy
.a23e	20 0d a3	jsr $a30d			jsr 	GCLoadAXY 					; load in
.a241	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a243	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a246	7a		ply				ply
.a247	80 b4		bra $a1fd			bra 	_RGICommandLoop 			; and go round
.a249					_RGI_Exit:
.a249	88		dey				dey 								; unpick : / EOL
.a24a	60		rts				rts
.a24b					_RGI_Solid:
.a24b	a9 02		lda #$02			lda 	#2
.a24d	8d 2f 06	sta $062f			sta 	gxFillSolid
.a250	80 ab		bra $a1fd			bra 	_RGICommandLoop
.a252					_RGI_Frame:
.a252	9c 2f 06	stz $062f			stz 	gxFillSolid
.a255	80 a6		bra $a1fd			bra 	_RGICommandLoop
.a257					_RGI_To:
.a257	20 f0 a2	jsr $a2f0			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a25a	20 17 a3	jsr $a317			jsr 	GCCopyPairToStore
.a25d					_RGI_Here:
.a25d	5a		phy				phy
.a25e	20 0d a3	jsr $a30d			jsr 	GCLoadAXY 					; load it into AXY
.a261	20 c7 a2	jsr $a2c7			jsr 	_RGICallHandler 			; go do whatever it is.
.a264	7a		ply				ply
.a265	80 96		bra $a1fd			bra 	_RGICommandLoop 			; and go round
.a267					_RGI_By:
.a267	20 fd a2	jsr $a2fd			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a26a	18		clc				clc
.a26b	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a26e	6d 30 06	adc $0630			adc 	gxxPos
.a271	8d 30 06	sta $0630			sta 	gxXPos
.a274	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a277	6d 31 06	adc $0631			adc 	gxxPos+1
.a27a	8d 31 06	sta $0631			sta 	gxXPos+1
.a27d	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a280	18		clc				clc
.a281	6d 32 06	adc $0632			adc 	gxYPos
.a284	8d 32 06	sta $0632			sta 	gxYPos
.a287	80 d4		bra $a25d			bra 	_RGI_Here
.a289					_RGI_Dim:
.a289	a2 01		ldx #$01			ldx	 	#1
.a28b	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger
.a28e	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a291	c9 00		cmp #$00			cmp 	#0
.a293	f0 2f		beq $a2c4			beq 	_RGIRange
.a295	c9 09		cmp #$09			cmp 	#8+1
.a297	b0 2b		bcs $a2c4			bcs		_RGIRange
.a299	3a		dec a				dec 	a
.a29a	8d 35 06	sta $0635			sta 	gxDrawScale
.a29d	4c fd a1	jmp $a1fd			jmp 	_RGICommandLoop
.a2a0					_RGI_Colour:
.a2a0	a2 01		ldx #$01			ldx 	#1 							; colour
.a2a2	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger
.a2a5	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a2a7	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero
.a2aa	b1 30		lda ($30),y			lda 	(codePtr),y
.a2ac	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a2ae	d0 04		bne $a2b4			bne 	_RGICDefaultMode
.a2b0	c8		iny				iny
.a2b1	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger
.a2b4					_RGICDefaultMode:
.a2b4	5a		phy				phy
.a2b5	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2b7	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a2ba	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a2bd	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a2c0	7a		ply				ply
.a2c1	4c fd a1	jmp $a1fd			jmp 	_RGICommandLoop 			; and go round
.a2c4					_RGIRange:
.a2c4	4c bb 9f	jmp $9fbb			jmp 	RangeError
.a2c7					_RGICallHandler:
.a2c7	6c 33 06	jmp ($0633)			jmp 	(GXHandler)
.a2ca					_RGI_SpriteInstructions:
.a2ca	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a2cc	f0 07		beq $a2d5			beq 	_RGISpriteOff
.a2ce	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a2d0	f0 13		beq $a2e5			beq 	_RGISetImage
.a2d2	4c 36 a2	jmp $a236			jmp 	_RGI_Move
.a2d5					_RGISpriteOff:
.a2d5	5a		phy				phy
.a2d6	a0 01		ldy #$01			ldy 	#1
.a2d8	a2 00		ldx #$00			ldx 	#0
.a2da					_RGIDoCommandLoop:
.a2da	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2dc	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a2df	7a		ply				ply
.a2e0	b0 e2		bcs $a2c4			bcs 	_RGIRange
.a2e2	4c fd a1	jmp $a1fd			jmp 	_RGICommandLoop
.a2e5					_RGISetImage:
.a2e5	a2 01		ldx #$01			ldx 	#1
.a2e7	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger
.a2ea	5a		phy				phy
.a2eb	aa		tax				tax
.a2ec	a0 00		ldy #$00			ldy 	#0
.a2ee	80 ea		bra $a2da			bra 	_RGIDoCommandLoop
.a2f0					GCGetCoordinatePair:
.a2f0	a2 01		ldx #$01			ldx 	#1
.a2f2	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.a2f5	20 58 8d	jsr $8d58			jsr 	CheckComma
.a2f8	e8		inx				inx
.a2f9	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.a2fc	60		rts				rts
.a2fd					GCSignedCoordinatePair:
.a2fd	a2 01		ldx #$01			ldx 	#1
.a2ff	20 99 9d	jsr $9d99			jsr 	Evaluate16BitIntegerSigned
.a302	20 58 8d	jsr $8d58			jsr 	CheckComma
.a305	e8		inx				inx
.a306	20 99 9d	jsr $9d99			jsr 	Evaluate16BitIntegerSigned
.a309	60		rts				rts
.a30a					_GCCPRange:
.a30a	4c bb 9f	jmp $9fbb			jmp 	RangeError
.a30d					GCLoadAXY:
.a30d	ad 31 06	lda $0631			lda 	gxXPos+1
.a310	ae 30 06	ldx $0630			ldx 	gxXPos
.a313	ac 32 06	ldy $0632			ldy 	gxYPos
.a316	60		rts				rts
.a317					GCCopyPairToStore:
.a317	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a31a	8d 30 06	sta $0630			sta 	gxXPos
.a31d	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a320	8d 31 06	sta $0631			sta 	gxXPos+1
.a323	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a326	8d 32 06	sta $0632			sta 	gxYPos
.a329	60		rts				rts
.062e					gxCommandID:
>062e							.fill 	1
.062f					gxFillSolid:
>062f							.fill 	1
.0630					gxXPos:
>0630							.fill 	2
.0632					gxYPos:
>0632							.fill 	1
.0633					gxHandler:
>0633							.fill 	2
.0635					gxDrawScale:
>0635							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a32a					BitmapCtrl:
.a32a	b1 30		lda ($30),y			lda 	(codePtr),y
.a32c	c8		iny				iny
.a32d	a2 01		ldx #$01			ldx 	#1
.a32f	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a331	f0 11		beq $a344			beq 	BitmapSwitch
.a333	ca		dex				dex
.a334	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a336	f0 0c		beq $a344			beq 	BitmapSwitch
.a338	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get the colour
.a33b	5a		phy				phy
.a33c	aa		tax				tax
.a33d	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a33f	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a342	7a		ply				ply
.a343	60		rts				rts
.a344					BitmapSwitch:
.a344	5a		phy				phy
.a345	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a347	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a349	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a34c	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a34e	a0 00		ldy #$00			ldy 	#0
.a350	a2 ff		ldx #$ff			ldx 	#$FF
.a352	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a355	9c 2f 06	stz $062f			stz 	gxFillSolid
.a358	9c 30 06	stz $0630			stz 	gxXPos
.a35b	9c 31 06	stz $0631			stz 	gxXPos+1
.a35e	9c 32 06	stz $0632			stz 	gxYPos
.a361	9c 35 06	stz $0635			stz 	gxDrawScale
.a364	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a366	a2 00		ldx #$00			ldx 	#0
.a368	a0 00		ldy #$00			ldy 	#0
.a36a	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a36d	7a		ply				ply
.a36e	60		rts				rts
.a36f					SpritesCtrl:
.a36f	b1 30		lda ($30),y			lda 	(codePtr),y
.a371	c8		iny				iny
.a372	a2 01		ldx #$01			ldx 	#1
.a374	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a376	f0 08		beq $a380			beq 	SpriteSwitch
.a378	ca		dex				dex
.a379	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a37b	f0 03		beq $a380			beq 	SpriteSwitch
.a37d	4c b6 9f	jmp $9fb6			jmp 	SyntaxError
.a380					SpriteSwitch:
.a380	5a		phy				phy
.a381	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a383	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a385	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a388	7a		ply				ply
.a389	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a38a					GfxCommand:
.a38a	a2 00		ldx #$00			ldx 	#0
.a38c	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; command
.a38f	20 58 8d	jsr $8d58			jsr 	CheckComma
.a392	e8		inx				inx
.a393	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger 		; X
.a396	20 58 8d	jsr $8d58			jsr 	CheckComma
.a399	e8		inx				inx
.a39a	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; Y
.a39d	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a3a0	4a		lsr a				lsr 	a
.a3a1	d0 16		bne $a3b9			bne 	_GfxError
.a3a3	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a3a6	b0 11		bcs $a3b9			bcs 	_GfxError 					; bit 7 should have been zero
.a3a8	5a		phy				phy 								; save pos
.a3a9	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a3ac	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a3af	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a3b2	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw
.a3b5	b0 02		bcs $a3b9			bcs 	_GfxError
.a3b7	7a		ply				ply 								; restore pos and exit.
.a3b8	60		rts				rts
.a3b9					_GfxError:
.a3b9	4c bb 9f	jmp $9fbb			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a3bc					UnaryHit:
.a3bc	fa		plx				plx
.a3bd	a9 36		lda #$36			lda 	#zTemp0
.a3bf	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3c2	20 58 8d	jsr $8d58			jsr 	CheckComma
.a3c5	e8		inx				inx
.a3c6	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3c9	20 50 8d	jsr $8d50			jsr		CheckRightBracket
.a3cc	ca		dex				dex 								; fix back up again.
.a3cd	da		phx				phx 								; save X/Y
.a3ce	5a		phy				phy
.a3cf	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3d2	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a3d5	aa		tax				tax
.a3d6	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3d8	20 b1 aa	jsr $aab1			jsr 	GXGraphicDraw 				; calculate result
.a3db	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3dc	7a		ply				ply 								; restore XY
.a3dd	fa		plx				plx
.a3de	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte 					; return the hit result
.a3e1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3e2					PaletteCommand:
.a3e2	a2 00		ldx #$00			ldx 	#0
.a3e4	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; colour
.a3e7	20 58 8d	jsr $8d58			jsr 	CheckComma
.a3ea	e8		inx				inx
.a3eb	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger 		; r
.a3ee	20 58 8d	jsr $8d58			jsr 	CheckComma
.a3f1	e8		inx				inx
.a3f2	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; g
.a3f5	20 58 8d	jsr $8d58			jsr 	CheckComma
.a3f8	e8		inx				inx
.a3f9	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; b
.a3fc	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a3ff	85 36		sta $36				sta 	zTemp0
.a401	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a403	85 37		sta $37				sta 	zTemp0+1
.a405	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a407	26 37		rol $37				rol	 	zTemp0+1
.a409	06 36		asl $36				asl 	zTemp0
.a40b	26 37		rol $37				rol	 	zTemp0+1
.a40d	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a40f	85 01		sta $01				sta 	1
.a411	5a		phy				phy
.a412	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a415	92 36		sta ($36)			sta 	(zTemp0)
.a417	a0 01		ldy #$01			ldy 	#1
.a419	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a41c	91 36		sta ($36),y			sta 	(zTemp0),y
.a41e	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a421	c8		iny				iny
.a422	91 36		sta ($36),y			sta 	(zTemp0),y
.a424	7a		ply				ply
.a425	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a426					UnaryEvent:
.a426	fa		plx				plx
.a427	20 ce a4	jsr $a4ce			jsr 	TimerToStackX 				; timer in +0
.a42a	e8		inx				inx  								; put reference into +1
.a42b	20 f2 97	jsr $97f2			jsr 	EvaluateTerm
.a42e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a431	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a433	d0 57		bne $a48c			bne 	_UEType
.a435	e8		inx				inx 								; put the step in +2
.a436	20 58 8d	jsr $8d58			jsr 	CheckComma
.a439	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger
.a43c	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.a43f	ca		dex				dex
.a440	ca		dex				dex
.a441	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a444	85 36		sta $36				sta 	zTemp0
.a446	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a449	85 37		sta $37				sta 	zTemp0+1
.a44b	5a		phy				phy
.a44c	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a44e	b1 36		lda ($36),y			lda 	(zTemp0),y
.a450	30 36		bmi $a488			bmi 	_UEFalse 					; exit if signed.
.a452	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a454	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a457	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a459	c8		iny				iny
.a45a	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a45d	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a45f	c8		iny				iny
.a460	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a463	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a465	90 21		bcc $a488			bcc 	_UEFalse 					; no, return FALSE.
.a467	18		clc				clc
.a468	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a46a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a46d	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a470	91 36		sta ($36),y			sta 	(zTemp0),y
.a472	c8		iny				iny
.a473	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a476	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a479	91 36		sta ($36),y			sta 	(zTemp0),y
.a47b	c8		iny				iny
.a47c	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a47f	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a482	91 36		sta ($36),y			sta 	(zTemp0),y
.a484	7a		ply				ply
.a485	4c d6 8d	jmp $8dd6			jmp 	ReturnTrue
.a488					_UEFalse:
.a488	7a		ply				ply 								; restore Y
.a489	4c e2 8d	jmp $8de2			jmp 	ReturnFalse 				; and return False
.a48c					_UEType:
.a48c	4c c0 9f	jmp $9fc0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a48f					UnaryJoyX:
.a48f	18		clc				clc
.a490	80 01		bra $a493			bra 	JoyMain
.a492					UnaryJoyY:
.a492	38		sec				sec
.a493					JoyMain:
.a493	fa		plx				plx 								; get pos
.a494	08		php				php 								; save carry (set for Y)
.a495	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a498	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.a49b	20 6a aa	jsr $aa6a			jsr 	EXTReadController 			; read the controller.
.a49e	28		plp				plp
.a49f	90 02		bcc $a4a3			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a4a1	4a		lsr a				lsr 	a
.a4a2	4a		lsr a				lsr 	a
.a4a3					_JMNoShift:
.a4a3	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a4a4	b0 0a		bcs $a4b0			bcs 	_JMIsRight
.a4a6	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a4a7	b0 04		bcs $a4ad			bcs 	_JMIsLeft
.a4a9	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero 					; zero result
.a4ac	60		rts				rts
.a4ad					_JMIsLeft:
.a4ad	4c d6 8d	jmp $8dd6			jmp 	ReturnTrue
.a4b0					_JMIsRight:
.a4b0	a9 01		lda #$01			lda 	#1
.a4b2	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.a4b5	60		rts				rts
.a4b6					UnaryJoyB:
.a4b6	fa		plx				plx 								; get pos
.a4b7	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a4ba	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.a4bd	20 6a aa	jsr $aa6a			jsr 	EXTReadController 			; read the controller.
.a4c0	4a		lsr a				lsr 	a
.a4c1	4a		lsr a				lsr 	a
.a4c2	4a		lsr a				lsr 	a
.a4c3	4a		lsr a				lsr 	a
.a4c4	29 01		and #$01			and 	#1
.a4c6	20 2e 9e	jsr $9e2e			jsr 	NSMSetByte
.a4c9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4ca					UnaryTimer:
.a4ca	fa		plx				plx
.a4cb	20 50 8d	jsr $8d50			jsr 	CheckRightBracket
.a4ce					TimerToStackX:
.a4ce	20 2c 9e	jsr $9e2c			jsr 	NSMSetZero 					; zero result
.a4d1	64 01		stz $01				stz 	1 							; access I/O
.a4d3	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4d6	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a4d9	ad 5a d6	lda $d65a			lda 	$D65A
.a4dc	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a4df	ad 5b d6	lda $d65b			lda 	$D65B
.a4e2	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a4e5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4e6					MemoryDeleteLine:
.a4e6	20 05 a5	jsr $a505			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4e9	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4eb	a8		tay				tay
.a4ec					_MDDLLoop:
.a4ec	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4ee	92 30		sta ($30)			sta 	(codePtr)
.a4f0	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4f2	c5 3a		cmp $3a				cmp 	zTemp2
.a4f4	d0 07		bne $a4fd			bne 	_MDLDLNext
.a4f6	a5 31		lda $31				lda 	codePtr+1
.a4f8	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4fa	d0 01		bne $a4fd			bne 	_MDLDLNext
.a4fc					_MDDLExit:
.a4fc	60		rts				rts
.a4fd					_MDLDLNext:
.a4fd	e6 30		inc $30				inc 	codePtr						; next byte
.a4ff	d0 eb		bne $a4ec			bne 	_MDDLLoop
.a501	e6 31		inc $31				inc 	codePtr+1
.a503	80 e7		bra $a4ec			bra 	_MDDLLoop
.a505					IMemoryFindEnd:
.a505	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a507	85 3a		sta $3a				sta 	0+zTemp2
.a509	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a50b	85 3b		sta $3b				sta 	1+zTemp2
.a50d					_MDLFELoop:
.a50d	b2 3a		lda ($3a)			lda 	(zTemp2)
.a50f	f0 0b		beq $a51c			beq 	_MDLFEExit
.a511	18		clc				clc
.a512	65 3a		adc $3a				adc 	zTemp2
.a514	85 3a		sta $3a				sta 	zTemp2
.a516	90 f5		bcc $a50d			bcc 	_MDLFELoop
.a518	e6 3b		inc $3b				inc 	zTemp2+1
.a51a	80 f1		bra $a50d			bra 	_MDLFELoop
.a51c					_MDLFEExit:
.a51c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a51d					MemoryInsertLine:
.a51d	08		php				php
.a51e	20 05 a5	jsr $a505			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a521	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a523	1a		inc a				inc 	a
.a524	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a526	b0 36		bcs $a55e			bcs 	_MDLIError
.a528	28		plp				plp
.a529	90 08		bcc $a533			bcc 	_MDLIFound
.a52b	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a52d	85 30		sta $30				sta 	codePtr
.a52f	a5 3b		lda $3b				lda 	zTemp2+1
.a531	85 31		sta $31				sta 	codePtr+1
.a533					_MDLIFound:
.a533	ad a8 04	lda $04a8			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a536	a8		tay				tay
.a537					_MDLIInsert:
.a537	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a539	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a53b	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a53d	c5 3a		cmp $3a				cmp 	zTemp2
.a53f	d0 06		bne $a547			bne 	_MDLINext
.a541	a5 31		lda $31				lda 	codePtr+1
.a543	c5 3b		cmp $3b				cmp 	zTemp2+1
.a545	f0 0a		beq $a551			beq 	_MDLIHaveSpace
.a547					_MDLINext:
.a547	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a549	d0 02		bne $a54d			bne 	_MDLINoBorrow
.a54b	c6 3b		dec $3b				dec 	zTemp2+1
.a54d					_MDLINoBorrow:
.a54d	c6 3a		dec $3a				dec 	zTemp2
.a54f	80 e6		bra $a537			bra 	_MDLIInsert
.a551					_MDLIHaveSpace:
.a551	ac a8 04	ldy $04a8			ldy 	tokenOffset 				; bytes to copy
.a554	88		dey				dey 								; from offset-1 to 0
.a555					_MDLICopy:
.a555	b9 a8 04	lda $04a8,y			lda 	tokenOffset,y
.a558	91 30		sta ($30),y			sta 	(codePtr),y
.a55a	88		dey				dey
.a55b	10 f8		bpl $a555			bpl 	_MDLICopy
.a55d	60		rts				rts
.a55e					_MDLIError:
.a55e	a9 06		lda #$06		lda	#6
.a560	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.a563					MDLAppendLine:
.a563	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a565	85 36		sta $36				sta 	zTemp0
.a567	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a569	85 38		sta $38				sta 	0+zTemp1
.a56b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a56d	85 39		sta $39				sta 	1+zTemp1
.a56f	b2 38		lda ($38)			lda 	(zTemp1)
.a571	d0 0a		bne $a57d			bne 	_MDLANoInitialise
.a573	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a575	8d 36 06	sta $0636			sta 	0+AppendPointer
.a578	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a57a	8d 37 06	sta $0637			sta 	1+AppendPointer
.a57d					_MDLANoInitialise:
.a57d	18		clc				clc
.a57e	ad 36 06	lda $0636			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a581	85 38		sta $38				sta 	zTemp1
.a583	72 36		adc ($36)			adc 	(zTemp0)
.a585	8d 36 06	sta $0636			sta 	AppendPointer
.a588	ad 37 06	lda $0637			lda 	AppendPointer+1
.a58b	85 39		sta $39				sta 	zTemp1+1
.a58d	69 00		adc #$00			adc 	#0
.a58f	8d 37 06	sta $0637			sta 	AppendPointer+1
.a592	a0 00		ldy #$00			ldy 	#0
.a594					_MDLACopy:
.a594	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a596	91 38		sta ($38),y			sta 	(zTemp1),y
.a598	c8		iny				iny
.a599	98		tya				tya
.a59a	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a59c	d0 f6		bne $a594			bne 	_MDLACopy
.a59e	a9 00		lda #$00			lda 	#0 							; end of program.
.a5a0	91 38		sta ($38),y			sta 	(zTemp1),y
.a5a2	60		rts				rts
.0636					AppendPointer:
>0636							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a5a3					MemoryNew:
.a5a3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a5	85 30		sta $30				sta 	codePtr
.a5a7	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5a9	85 31		sta $31				sta 	codePtr+1
.a5ab	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a5ad	92 30		sta ($30)			sta 	(codePtr)
.a5af	60		rts				rts
.a5b0					MemoryInline:
.a5b0	98		tya				tya 								; put address into stack,x
.a5b1	18		clc				clc
.a5b2	65 30		adc $30				adc 	codePtr
.a5b4	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a5b7	a5 31		lda $31				lda 	codePtr+1
.a5b9	69 00		adc #$00			adc 	#0
.a5bb	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a5be	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a5c1	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a5c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a5c5					MemorySearch:
.a5c5	85 36		sta $36				sta 	zTemp0 						; save line number zTemp0
.a5c7	86 37		stx $37				stx 	zTemp0+1
.a5c9	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5cb	85 30		sta $30				sta 	codePtr
.a5cd	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5cf	85 31		sta $31				sta 	codePtr+1
.a5d1					_MTAXLoop:
.a5d1	b2 30		lda ($30)			lda 	(codePtr)
.a5d3	18		clc				clc
.a5d4	f0 21		beq $a5f7			beq 	_MTAXExit 					; reached end, exit with CC.
.a5d6	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5d8	b1 30		lda ($30),y			lda 	(codePtr),y
.a5da	38		sec				sec
.a5db	e5 36		sbc $36				sbc 	zTemp0
.a5dd	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5df	c8		iny				iny 								; do the MSB
.a5e0	b1 30		lda ($30),y			lda 	(codePtr),y
.a5e2	e5 37		sbc $37				sbc 	zTemp0+1
.a5e4	05 38		ora $38				ora 	zTemp1
.a5e6	f0 0f		beq $a5f7			beq 	_MTAXExit	 				; found
.a5e8	b0 0d		bcs $a5f7			bcs 	_MTAXExit 					; current < required exit
.a5ea	18		clc				clc
.a5eb	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.a5ed	65 30		adc $30				adc 	codePtr
.a5ef	85 30		sta $30				sta 	codePtr
.a5f1	90 02		bcc $a5f5			bcc 	_CREExit
.a5f3	e6 31		inc $31				inc 	codePtr+1
.a5f5					_CREExit:
.a5f5	80 da		bra $a5d1			bra 	_MTAXLoop
.a5f7					_MTAXExit:
.a5f7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a5f8					SoundCommand:
.a5f8	b1 30		lda ($30),y			lda 	(codePtr),y
.a5fa	c9 bf		cmp #$bf			cmp 	#KWD_OFF 					; SOUND OFF ?
.a5fc	d0 09		bne $a607			bne 	_SNDMain
.a5fe	c8		iny				iny 								; skip OFF
.a5ff	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a601	5a		phy				phy
.a602	20 3f b9	jsr $b93f			jsr 	SNDCommand
.a605	7a		ply				ply
.a606	60		rts				rts
.a607					_SNDMain:
.a607	a2 00		ldx #$00			ldx 	#0
.a609	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; channel
.a60c	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a60e	b0 50		bcs $a660			bcs 	_SndError
.a610	e8		inx				inx 								; do the rest in slot 1.
.a611	20 58 8d	jsr $8d58			jsr 	CheckComma
.a614	20 8d 9d	jsr $9d8d			jsr 	Evaluate16BitInteger 		; Pitch
.a617	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a61a	c9 10		cmp #$10			cmp 	#16
.a61c	b0 42		bcs $a660			bcs 	_SndError
.a61e	8d 39 06	sta $0639			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a621	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a624	8d 38 06	sta $0638			sta 	SoundCommandBlock
.a627	20 58 8d	jsr $8d58			jsr 	CheckComma
.a62a	20 ad 9d	jsr $9dad			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a62d	8d 3b 06	sta $063b			sta 	SoundCommandBlock+3
.a630	a9 0f		lda #$0f			lda 	#15
.a632	8d 3a 06	sta $063a			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a635	9c 3c 06	stz $063c			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a638	9c 3d 06	stz $063d			stz 	SoundCommandBlock+5
.a63b	b1 30		lda ($30),y			lda 	(codePtr),y
.a63d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a63f	d0 10		bne $a651			bne 	_SNDPlay
.a641	c8		iny				iny
.a642	20 99 9d	jsr $9d99			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a645	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a648	8d 3c 06	sta $063c			sta 	SoundCommandBlock+4
.a64b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a64e	8d 3d 06	sta $063d			sta 	SoundCommandBlock+5
.a651					_SNDPlay:
.a651	5a		phy				phy
.a652	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a655	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a657	a2 38		ldx #$38			ldx 	#(SoundCommandBlock & $FF)
.a659	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a65b	20 3f b9	jsr $b93f			jsr 	SNDCommand
.a65e	7a		ply				ply
.a65f	60		rts				rts
.a660					_SndError:
.a660	4c bb 9f	jmp $9fbb			jmp 	RangeError
.0638					SoundCommandBlock:
>0638							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a663					StackPushByte:
.a663	48		pha				pha 								; save byte
.a664	a5 34		lda $34				lda 	BasicStack
.a666	d0 09		bne $a671			bne 	_SPBNoBorrow
.a668	c6 35		dec $35				dec 	BasicStack+1
.a66a	48		pha				pha
.a66b	a5 35		lda $35				lda 	BasicStack+1
.a66d	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a66f	90 06		bcc $a677			bcc 	_SPBMemory
.a671					_SPBNoBorrow:
.a671	c6 34		dec $34				dec 	BasicStack
.a673	68		pla				pla 								; get back and write
.a674	92 34		sta ($34)			sta 	(BasicStack)
.a676	60		rts				rts
.a677					_SPBMemory:
.a677	a9 12		lda #$12		lda	#18
.a679	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.a67c					StackPopByte:
.a67c	b2 34		lda ($34)			lda 	(BasicStack)
.a67e	e6 34		inc $34				inc 	BasicStack
.a680	d0 02		bne $a684			bne 	_SPBNoCarry
.a682	e6 35		inc $35				inc 	BasicStack+1
.a684					_SPBNoCarry:
.a684	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a685					StackOpen:
.a685	48		pha				pha 								; save frame byte
.a686	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a688	0a		asl a				asl 	a 							; claim twice this for storage
.a689	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a68b	38		sec				sec 								; so basically subtracting from
.a68c	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a68e	85 34		sta $34				sta 	basicStack
.a690	b0 08		bcs $a69a			bcs 	_SONoBorrow
.a692	c6 35		dec $35				dec 	basicStack+1
.a694	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a696	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a698	90 04		bcc $a69e			bcc 	_SOMemory
.a69a					_SONoBorrow:
.a69a	68		pla				pla 								; get marker back and write at TOS
.a69b	92 34		sta ($34)			sta 	(basicStack)
.a69d	60		rts				rts
.a69e					_SOMemory:
.a69e	a9 12		lda #$12		lda	#18
.a6a0	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.a6a3					StackClose:
.a6a3	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6a5	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6a7	0a		asl a				asl 	a 							; claim twice this.
.a6a8	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6aa	85 34		sta $34				sta 	basicStack
.a6ac	90 02		bcc $a6b0			bcc 	_SCExit
.a6ae	e6 35		inc $35				inc 	basicStack+1
.a6b0					_SCExit:
.a6b0	60		rts				rts
.a6b1					StackCheckFrame:
.a6b1	48		pha				pha
.a6b2					_StackRemoveLocals:
.a6b2	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6b4	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a6b6	b0 05		bcs $a6bd			bcs 	_SCNoLocal
.a6b8	20 02 88	jsr $8802			jsr 	LocalPopValue
.a6bb	80 f5		bra $a6b2			bra 	_StackRemoveLocals
.a6bd					_SCNoLocal:
.a6bd	68		pla				pla
.a6be	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6c0	29 f0		and #$f0			and 	#$F0 						; check type bits
.a6c2	d0 01		bne $a6c5			bne 	_SCFError 					; different, we have structures mixed up
.a6c4	60		rts				rts
.a6c5					_SCFError:
.a6c5	8a		txa				txa 								; report error X
.a6c6	4c 69 8d	jmp $8d69			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a6c9					STKSaveCodePosition:
.a6c9	5a		phy				phy
.a6ca	98		tya				tya 								; save Y
.a6cb	a0 05		ldy #$05			ldy 	#5
.a6cd	91 34		sta ($34),y			sta 	(basicStack),y
.a6cf	88		dey				dey 								; save Code Pointer
.a6d0					_STKSaveLoop:
.a6d0	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a6d3	91 34		sta ($34),y			sta 	(basicStack),y
.a6d5	88		dey				dey
.a6d6	d0 f8		bne $a6d0			bne 	_STKSaveLoop
.a6d8	7a		ply				ply
.a6d9	60		rts				rts
.a6da					STKLoadCodePosition:
.a6da	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a6dc					_STKLoadLoop:
.a6dc	b1 34		lda ($34),y			lda 	(basicStack),y
.a6de	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a6e1	c8		iny				iny
.a6e2	c0 05		cpy #$05			cpy 	#5
.a6e4	d0 f6		bne $a6dc			bne 	_STKLoadLoop
.a6e6	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a6e8	a8		tay				tay
.a6e9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a6ea					StackReset:
.a6ea	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a6ec	85 34		sta $34				sta 	0+basicStack
.a6ee	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a6f0	85 35		sta $35				sta 	1+basicStack
.a6f2	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a6f4	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a6f6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a6f7					StringConcrete:
.a6f7	5a		phy				phy 								; save position on stack
.a6f8	20 f5 99	jsr $99f5			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a6fb	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a6fe	85 38		sta $38				sta 	zTemp1
.a700	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a703	85 39		sta $39				sta 	zTemp1+1
.a705	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a707					_SALength:
.a707	c8		iny				iny
.a708	b1 38		lda ($38),y			lda 	(zTemp1),y
.a70a	d0 fb		bne $a707			bne 	_SALength
.a70c	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a70e	b0 3f		bcs $a74f			bcs 	_SALengthError
.a710	98		tya				tya 				 				; length of the new string
.a711	18		clc				clc
.a712	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a714	90 02		bcc $a718			bcc 	_SAHaveLength
.a716	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a718					_SAHaveLength:
.a718	48		pha				pha 								; save length.
.a719	38		sec				sec
.a71a	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a71c	6d 8e 04	adc $048e			adc 	StringMemory
.a71f	8d 8e 04	sta $048e			sta 	StringMemory
.a722	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a724	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a727	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a729	6d 8f 04	adc $048f			adc 	StringMemory+1
.a72c	8d 8f 04	sta $048f			sta 	StringMemory+1
.a72f	85 3b		sta $3b				sta 	zTemp2+1
.a731	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a734	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a735	38		sec				sec
.a736	e9 03		sbc #$03			sbc 	#3
.a738	92 3a		sta ($3a)			sta 	(zTemp2)
.a73a	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a73c	a0 01		ldy #$01			ldy 	#1
.a73e	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a740					_SACopyNewString:
.a740	a0 00		ldy #$00			ldy 	#0
.a742					_SACopyNSLoop:
.a742	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a744	c8		iny				iny 								; write two on in string storage
.a745	c8		iny				iny
.a746	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a748	88		dey				dey 								; this makes it one one.
.a749	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a74b	d0 f5		bne $a742			bne 	_SACopyNSLoop
.a74d	7a		ply				ply
.a74e	60		rts				rts
.a74f					_SALengthError:
.a74f	a9 09		lda #$09		lda	#9
.a751	4c 69 8d	jmp $8d69		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a754					StringSystemInitialise:
.a754	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a756	8d 8e 04	sta $048e			sta 	0+StringMemory
.a759	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a75b	8d 8f 04	sta $048f			sta 	1+StringMemory
.a75e	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a761	60		rts				rts
.a762					StringSpaceInitialise:
.a762	20 f5 99	jsr $99f5			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a765	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a767	8d 90 04	sta $0490			sta 	StringInitialised
.a76a	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a76d	8d 91 04	sta $0491			sta 	StringTempPointer
.a770	ad 8f 04	lda $048f			lda 	StringMemory+1
.a773	3a		dec a				dec 	a
.a774	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a777	60		rts				rts
.a778					StringTempAllocate:
.a778	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a77a	b0 35		bcs $a7b1			bcs 	_STALength
.a77c	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a77f	30 05		bmi $a786			bmi 	_STAAllocate
.a781	48		pha				pha 								; save value to subtract.
.a782	20 62 a7	jsr $a762			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a785	68		pla				pla 								; restore it
.a786					_STAAllocate:
.a786	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a788	18		clc				clc  								; deliberate allows one more
.a789	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a78c	8d 91 04	sta $0491			sta 	StringTempPointer
.a78f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a792	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a794	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a797	69 ff		adc #$ff			adc 	#$FF
.a799	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a79c	85 3d		sta $3d				sta 	zsTemp+1
.a79e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a7a1	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a7a4	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a7a7	a9 10		lda #$10			lda 	#NSTString
.a7a9	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a7ac	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7ae	92 3c		sta ($3c)			sta 	(zsTemp)
.a7b0	60		rts				rts
.a7b1					_STALength:
.a7b1	a9 09		lda #$09		lda	#9
.a7b3	4c 69 8d	jmp $8d69		jmp	ErrorHandler
.a7b6					StringTempWrite:
.a7b6	48		pha				pha
.a7b7	92 3c		sta ($3c)			sta 	(zsTemp)
.a7b9	e6 3c		inc $3c				inc 	zsTemp
.a7bb	d0 02		bne $a7bf			bne 	_STWNoCarry
.a7bd	e6 3d		inc $3d				inc 	zsTemp+1
.a7bf					_STWNoCarry:
.a7bf	a9 00		lda #$00			lda 	#0
.a7c1	92 3c		sta ($3c)			sta 	(zsTemp)
.a7c3	68		pla				pla
.a7c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7c5					EXTPrintCharacter:
.a7c5	48		pha				pha
.a7c6	da		phx				phx
.a7c7	5a		phy				phy
.a7c8	a6 01		ldx $01				ldx 	1
.a7ca	da		phx				phx
.a7cb	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a7ce	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a7d0	30 48		bmi $a81a			bmi 	_EXPCColour
.a7d2	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a7d4	90 4d		bcc $a823			bcc 	_EXPCControl
.a7d6	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a7d8	86 01		stx $01				stx 	1
.a7da	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7dc	e6 01		inc $01				inc 	1 							; select colour memory
.a7de	ad 40 06	lda $0640			lda 	EXTTextColour
.a7e1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7e3	c8		iny				iny 								; advance horizontal position
.a7e4	8c 3f 06	sty $063f			sty 	EXTColumn
.a7e7	cc 41 06	cpy $0641			cpy 	EXTScreenWidth 				; reached RHS ?
.a7ea	90 66		bcc $a852			bcc 	_EXPCExit 					; no, then exit.
.a7ec					_EXPCCRLF:
.a7ec	ee 3e 06	inc $063e			inc 	EXTRow  					; bump row
.a7ef	9c 3f 06	stz $063f			stz 	EXTColumn 					; back to column 0
.a7f2	ad 3e 06	lda $063e			lda 	EXTRow 						; check if reached the bottom ?
.a7f5	cd 42 06	cmp $0642			cmp 	EXTScreenHeight 			; if so, then scroll.
.a7f8	f0 18		beq $a812			beq 	_EXPCScroll
.a7fa	18		clc				clc 								; add width to address.
.a7fb	a5 40		lda $40				lda 	EXTAddress
.a7fd	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a800	85 40		sta $40				sta 	EXTAddress
.a802	90 4e		bcc $a852			bcc 	_EXPCExit
.a804	e6 41		inc $41				inc 	EXTAddress+1
.a806	80 4a		bra $a852			bra 	_EXPCExit
.a808					_EXPCLeft:
.a808	ce 3f 06	dec $063f			dec 	EXTColumn
.a80b	10 45		bpl $a852			bpl 	_EXPCExit
.a80d					_EXPCBegin:
.a80d	9c 3f 06	stz $063f			stz 	EXTColumn
.a810	80 40		bra $a852			bra 	_EXPCExit
.a812					_EXPCScroll:
.a812	ce 3e 06	dec $063e			dec 	EXTRow 						; the height-1 th line.
.a815	20 df a8	jsr $a8df			jsr 	EXTScreenScroll 			; scroll the screen
.a818	80 38		bra $a852			bra 	_EXPCExit
.a81a					_EXPCColour:
.a81a	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a81c	b0 34		bcs $a852			bcs 	_EXPCExit
.a81e	20 bf a8	jsr $a8bf			jsr 	_EXPCHandleColour
.a821	80 2f		bra $a852			bra 	_EXPCExit
.a823					_EXPCControl:
.a823	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a825	b0 2b		bcs $a852			bcs 	_EXPCExit
.a827	0a		asl a				asl 	a 							; double into X
.a828	aa		tax				tax
.a829	7c 9d a8	jmp ($a89d,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a82c					_EXPCUp:
.a82c	ad 3e 06	lda $063e			lda 	EXTRow 						; already at top ?
.a82f	f0 21		beq $a852			beq 	_EXPCExit
.a831	ce 3e 06	dec $063e			dec 	EXTRow 						; up one in position/address
.a834	38		sec				sec
.a835	a5 40		lda $40				lda 	EXTAddress
.a837	ed 41 06	sbc $0641			sbc 	EXTScreenWidth
.a83a	85 40		sta $40				sta 	EXTAddress
.a83c	b0 14		bcs $a852			bcs 	_EXPCExit
.a83e	c6 41		dec $41				dec 	EXTAddress+1
.a840	80 10		bra $a852			bra 	_EXPCExit
.a842					_EXPCRight:
.a842	c8		iny				iny
.a843	8c 3f 06	sty $063f			sty 	EXTColumn
.a846	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a849	d0 07		bne $a852			bne 	_EXPCExit
.a84b					_EXPCEnd:
.a84b	ad 41 06	lda $0641			lda 	EXTScreenWidth
.a84e	3a		dec a				dec 	a
.a84f	8d 3f 06	sta $063f			sta 	EXTColumn
.a852					_EXPCExit:
.a852	20 34 a9	jsr $a934			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a855	68		pla				pla
.a856	85 01		sta $01				sta 	1
.a858	7a		ply				ply
.a859	fa		plx				plx
.a85a	68		pla				pla
.a85b	60		rts				rts
.a85c					_EXPCClearScreen:
.a85c	20 f1 a8	jsr $a8f1			jsr		EXTClearScreenCode
.a85f	80 f1		bra $a852			bra 	_EXPCExit
.a861					_EXPCDown:
.a861	ad 42 06	lda $0642			lda 	EXTScreenHeight 			; at the bottom
.a864	3a		dec a				dec 	a
.a865	cd 3e 06	cmp $063e			cmp 	EXTRow
.a868	f0 e8		beq $a852			beq 	_EXPCExit
.a86a	ee 3e 06	inc $063e			inc 	EXTRow 						; down one in position/address
.a86d	18		clc				clc
.a86e	a5 40		lda $40				lda 	EXTAddress
.a870	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a873	85 40		sta $40				sta 	EXTAddress
.a875	90 db		bcc $a852			bcc 	_EXPCExit
.a877	e6 41		inc $41				inc 	EXTAddress+1
.a879	80 d7		bra $a852			bra 	_EXPCExit
.a87b					_EXPCTab:
.a87b	ad 3f 06	lda $063f			lda 	EXTColumn 					; next tab stop
.a87e	29 f8		and #$f8			and 	#$F8
.a880	18		clc				clc
.a881	69 08		adc #$08			adc 	#8
.a883	8d 3f 06	sta $063f			sta 	EXTColumn
.a886	cd 41 06	cmp $0641			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a889	90 c7		bcc $a852			bcc 	_EXPCExit
.a88b	80 be		bra $a84b			bra 	_EXPCEnd
.a88d					_EXPCBackSpace:
.a88d	88		dey				dey
.a88e	30 c2		bmi $a852			bmi 	_EXPCExit
.a890	ce 3f 06	dec $063f			dec 	EXTColumn
.a893	a9 02		lda #$02			lda 	#2
.a895	85 01		sta $01				sta 	1
.a897	a9 20		lda #$20			lda 	#32
.a899	91 40		sta ($40),y			sta 	(EXTAddress),y
.a89b	80 b5		bra $a852			bra 	_EXPCExit
.a89d					_EXPCActionTable:
>a89d	52 a8						.word 	_EXPCExit 					; 00
>a89f	0d a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8a1	08 a8						.word 	_EXPCLeft 					; 02 B Left
>a8a3	52 a8						.word 	_EXPCExit 					; 03 <Break>
>a8a5	52 a8						.word 	_EXPCExit 					; 04
>a8a7	4b a8						.word 	_EXPCEnd 					; 05 E End of Line
>a8a9	42 a8						.word 	_EXPCRight 					; 06 F Right
>a8ab	52 a8						.word 	_EXPCExit 					; 07
>a8ad	8d a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a8af	7b a8						.word 	_EXPCTab 					; 09 I Tab
>a8b1	52 a8						.word 	_EXPCExit 					; 0A
>a8b3	52 a8						.word 	_EXPCExit 					; 0B
>a8b5	5c a8						.word 	_EXPCClearScreen			; 0C L CLS
>a8b7	ec a7						.word 	_EXPCCRLF 					; 0D M CR/LF
>a8b9	61 a8						.word 	_EXPCDown 					; 0E N Down
>a8bb	52 a8						.word 	_EXPCExit 					; 0F
>a8bd	2c a8						.word 	_EXPCUp 					; 10 P Up
.a8bf					_EXPCHandleColour
.a8bf	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a8c1	b0 16		bcs $a8d9			bcs 	_EXPCBackground
.a8c3	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a8c4	0a		asl a				asl 	a
.a8c5	0a		asl a				asl 	a
.a8c6	0a		asl a				asl 	a
.a8c7	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a8c9					_EXPCUpdate:
.a8c9	48		pha				pha 								; save new colour
.a8ca	8a		txa				txa 								; get mask
.a8cb	2d 40 06	and $0640			and 	EXTTextColour 				; mask out old.
.a8ce	8d 40 06	sta $0640			sta 	EXTTextColour
.a8d1	68		pla				pla 								; or in new colour
.a8d2	0d 40 06	ora $0640			ora 	EXTTextColour
.a8d5	8d 40 06	sta $0640			sta 	EXTTextColour
.a8d8	60		rts				rts
.a8d9					_EXPCBackground:
.a8d9	29 0f		and #$0f			and 	#$0F 						; get the colour
.a8db	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a8dd	80 ea		bra $a8c9			bra 	_EXPCUpdate
.a8df					EXTScreenScroll:
.a8df	a9 02		lda #$02			lda 	#2 							; select text page
.a8e1	85 01		sta $01				sta 	1
.a8e3	a9 20		lda #$20			lda		#32 						; fill with space
.a8e5	20 f4 a9	jsr $a9f4			jsr 	EXTScrollFill
.a8e8	e6 01		inc $01				inc 	1 							; select colour page
.a8ea	ad 40 06	lda $0640			lda 	EXTTextColour
.a8ed	20 f4 a9	jsr $a9f4			jsr 	EXTScrollFill
.a8f0	60		rts				rts
.a8f1					EXTClearScreenCode:
.a8f1	a9 02		lda #$02			lda 	#2 							; select text page
.a8f3	85 01		sta $01				sta 	1
.a8f5	a9 20		lda #$20			lda		#32 						; fill with space
.a8f7	20 04 a9	jsr $a904			jsr 	_EXTCSFill
.a8fa	e6 01		inc $01				inc 	1 							; select colour page
.a8fc	ad 40 06	lda $0640			lda 	EXTTextColour
.a8ff	20 04 a9	jsr $a904			jsr 	_EXTCSFill
.a902	80 22		bra $a926			bra 	EXTHomeCursor
.a904					_EXTCSFill:
.a904	aa		tax				tax
.a905	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a907	85 40		sta $40				sta 	EXTAddress
.a909	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a90b	85 41		sta $41				sta 	EXTAddress+1
.a90d					_EXTCSFill1:
.a90d	a0 00		ldy #$00			ldy 	#0
.a90f	8a		txa				txa
.a910					_EXTCSFill2:
.a910	91 40		sta ($40),y			sta 	(EXTAddress),y
.a912	c8		iny				iny
.a913	d0 fb		bne $a910			bne 	_EXTCSFill2
.a915	e6 41		inc $41				inc 	EXTAddress+1
.a917	a5 41		lda $41				lda 	EXTAddress+1
.a919	c9 d2		cmp #$d2			cmp 	#$D2
.a91b	d0 f0		bne $a90d			bne 	_EXTCSFill1
.a91d	8a		txa				txa
.a91e					_EXTCSFill3:
.a91e	91 40		sta ($40),y			sta 	(EXTAddress),y
.a920	c8		iny				iny
.a921	c0 c0		cpy #$c0			cpy 	#$C0
.a923	d0 f9		bne $a91e			bne 	_EXTCSFill3
.a925	60		rts				rts
.a926					EXTHomeCursor:
.a926	9c 3e 06	stz $063e			stz 	EXTRow 						; reset row & column
.a929	9c 3f 06	stz $063f			stz 	EXTColumn
.a92c	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a92e	85 40		sta $40				sta 	EXTAddress
.a930	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a932	85 41		sta $41				sta 	EXTAddress+1
.a934					EXTSetHardwareCursor:
.a934	64 01		stz $01				stz 	1 							; I/O Page zero
.a936	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a938	8d 10 d0	sta $d010			sta 	$D010
.a93b	a9 b1		lda #$b1			lda 	#$B1
.a93d	8d 12 d0	sta $d012			sta 	$D012
.a940	ad 3f 06	lda $063f			lda 	EXTColumn
.a943	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a946	9c 15 d0	stz $d015			stz 	$D015
.a949	ad 3e 06	lda $063e			lda 	EXTRow
.a94c	8d 16 d0	sta $d016			sta 	$D016
.a94f	9c 17 d0	stz $d017			stz 	$D017
.a952	60		rts				rts
.a953					EXTInputLine:
.a953	48		pha				pha
.a954	da		phx				phx
.a955	5a		phy				phy
.a956	a5 01		lda $01				lda 	1 							; save I/O page
.a958	48		pha				pha
.a959					_EILLoop:
.a959	20 5b aa	jsr $aa5b			jsr 	ExtInputSingleCharacter
.a95c	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a95e	f0 40		beq $a9a0			beq 	_EILExit
.a960	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a962	f0 1c		beq $a980			beq 	_EILBackspace
.a964	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a966	90 12		bcc $a97a			bcc 	_EILPrintLoop
.a968	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a96a	b0 0e		bcs $a97a			bcs 	_EILPrintLoop
.a96c	48		pha				pha 								; save character
.a96d	a9 02		lda #$02			lda 	#2  						; insert a space
.a96f	85 01		sta $01				sta 	1
.a971	20 e2 a9	jsr $a9e2			jsr 	EXTILInsert 				; insert in text screen
.a974	e6 01		inc $01				inc 	1
.a976	20 e2 a9	jsr $a9e2			jsr 	EXTILInsert 				; insert in colour screen
.a979	68		pla				pla 								; get character back.
.a97a					_EILPrintLoop:
.a97a	20 c5 a7	jsr $a7c5			jsr 	ExtPrintCharacter
.a97d	80 da		bra $a959			bra 	_EILLoop
.a97f	60		rts				rts
.a980					_EILBackspace:
.a980	ad 3f 06	lda $063f			lda 	EXTColumn					; can we backspace ?
.a983	f0 d4		beq $a959			beq 	_EILLoop
.a985	a9 02		lda #$02			lda 	#2 							; move cursor left
.a987	20 c5 a7	jsr $a7c5			jsr 	EXTPrintCharacter
.a98a	a9 02		lda #$02			lda 	#2 							; text block
.a98c	85 01		sta $01				sta 	1
.a98e	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a990	20 cd a9	jsr $a9cd			jsr 	EXTILDelete
.a993	e6 01		inc $01				inc 	1 							; colour block
.a995	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; get attribute of last character
.a998	88		dey				dey
.a999	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a99b	20 cd a9	jsr $a9cd			jsr 	EXTILDelete 				; backspace attribute
.a99e	80 b9		bra $a959			bra 	_EILLoop 					; and go round.
.a9a0					_EILExit:
.a9a0	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a9a2	85 01		sta $01				sta 	1
.a9a4	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a9a6					_EILScrapeLine:
.a9a6	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9a8	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9ab	c8		iny				iny
.a9ac	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9af	d0 f5		bne $a9a6			bne 	_EILScrapeLine
.a9b1					_EILTrimSpaces:
.a9b1	88		dey				dey
.a9b2	f0 08		beq $a9bc			beq 	_EILEndTrim
.a9b4	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.a9b7	c9 20		cmp #$20			cmp 	#' '
.a9b9	f0 f6		beq $a9b1			beq 	_EILTrimSpaces
.a9bb	c8		iny				iny 								; trim after non space character.
.a9bc					_EILEndTrim:
.a9bc	a9 00		lda #$00			lda 	#0 							; trim here.
.a9be	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9c1	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a9c3	20 c5 a7	jsr $a7c5			jsr 	ExtPrintCharacter
.a9c6	68		pla				pla 								; reset I/O page
.a9c7	85 01		sta $01				sta 	1
.a9c9	7a		ply				ply
.a9ca	fa		plx				plx
.a9cb	68		pla				pla
.a9cc	60		rts				rts
.a9cd					EXTILDelete:
.a9cd	48		pha				pha 								; save the new character
.a9ce	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; start copying from here.
.a9d1					_EXTDLoop:
.a9d1	c8		iny				iny 								; copy one byte down.
.a9d2	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9d4	88		dey				dey
.a9d5	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9d7	c8		iny				iny 								; do till end of line.
.a9d8	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9db	90 f4		bcc $a9d1			bcc 	_EXTDLoop
.a9dd	88		dey				dey 	 							; write in last slot.
.a9de	68		pla				pla
.a9df	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9e1	60		rts				rts
.a9e2					EXTILInsert:
.a9e2	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; end position
.a9e5					_EXTILoop:
.a9e5	88		dey				dey 								; back one
.a9e6	cc 3f 06	cpy $063f			cpy 	EXTColumn 					; exit if reached insert point.
.a9e9	f0 08		beq $a9f3			beq 	_EXTIExit
.a9eb	88		dey				dey 								; copy one byte up.
.a9ec	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9ee	c8		iny				iny
.a9ef	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9f1	80 f2		bra $a9e5			bra 	_EXTILoop
.a9f3					_EXTIExit:
.a9f3	60		rts				rts
.a9f4					EXTScrollFill:
.a9f4	aa		tax				tax									; save value to fill with
.a9f5	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a9f7	48		pha				pha
.a9f8	a5 37		lda $37				lda 	zTemp0+1
.a9fa	48		pha				pha
.a9fb	a5 38		lda $38				lda 	zTemp1
.a9fd	48		pha				pha
.a9fe	a5 39		lda $39				lda 	zTemp1+1
.aa00	48		pha				pha
.aa01	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa03	85 37		sta $37				sta 	zTemp0+1
.aa05	85 39		sta $39				sta 	zTemp1+1
.aa07	64 36		stz $36				stz 	zTemp0
.aa09	ad 41 06	lda $0641			lda 	EXTScreenWidth
.aa0c	85 38		sta $38				sta 	zTemp1
.aa0e	a0 00		ldy #$00			ldy 	#0
.aa10					_EXSFCopy1:
.aa10	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa12	91 36		sta ($36),y			sta 	(zTemp0),y
.aa14	c8		iny				iny
.aa15	d0 f9		bne $aa10			bne 	_EXSFCopy1
.aa17	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa19	e6 39		inc $39				inc 	zTemp1+1
.aa1b	a5 39		lda $39				lda 	zTemp1+1
.aa1d	c9 d3		cmp #$d3			cmp 	#$D3
.aa1f	d0 ef		bne $aa10			bne 	_EXSFCopy1
.aa21	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa24	8a		txa				txa
.aa25					_EXSFFill1:
.aa25	88		dey				dey
.aa26	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa28	c0 00		cpy #$00			cpy 	#0
.aa2a	10 f9		bpl $aa25			bpl 	_EXSFFill1
.aa2c	68		pla				pla
.aa2d	85 39		sta $39				sta 	zTemp1+1
.aa2f	68		pla				pla
.aa30	85 38		sta $38				sta 	zTemp1
.aa32	68		pla				pla
.aa33	85 37		sta $37				sta 	zTemp0+1
.aa35	68		pla				pla
.aa36	85 36		sta $36				sta 	zTemp0
.aa38	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063e					EXTRow:
>063e							.fill 	1
.063f					EXTColumn:
>063f							.fill 	1
.0640					EXTTextColour:
>0640							.fill 	1
.0641					EXTScreenWidth:
>0641							.fill 	1
.0642					EXTScreenHeight:
>0642							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa39					EXTInitialise:
.aa39	64 01		stz $01				stz 	1 							; Access I/O
.aa3b	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa3e	9c 08 d0	stz $d008			stz 	$D008
.aa41	9c 09 d0	stz $d009			stz 	$D009
.aa44	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aa46	8d 58 d6	sta $d658			sta 	$D658
.aa49	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.aa4b	8d 40 06	sta $0640			sta 	EXTTextColour
.aa4e	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aa50	8d 41 06	sta $0641			sta 	EXTScreenWidth
.aa53	a9 3c		lda #$3c			lda 	#60
.aa55	8d 42 06	sta $0642			sta 	EXTScreenHeight
.aa58	64 01		stz $01				stz 	1
.aa5a	60		rts				rts
.aa5b					EXTInputSingleCharacter:
.aa5b	da		phx				phx
.aa5c	5a		phy				phy
.aa5d					_EISCWait:
.aa5d	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.aa60	c9 00		cmp #$00			cmp 	#0
.aa62	f0 f9		beq $aa5d			beq 	_EISCWait
.aa64	7a		ply				ply
.aa65	fa		plx				plx
.aa66	60		rts				rts
.aa67					EXTBreakCheck:
.aa67	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aa6a					EXTReadController:
.aa6a	da		phx				phx
.aa6b	a2 00		ldx #$00			ldx 	#0
.aa6d	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aa6f	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa72	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aa74	f0 04		beq $aa7a			beq 	_NoSet1
.aa76	8a		txa				txa
.aa77	09 01		ora #$01			ora 	#1
.aa79	aa		tax				tax
.aa7a					_NoSet1:
.aa7a	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aa7c	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa7f	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aa81	f0 04		beq $aa87			beq 	_NoSet1
.aa83	8a		txa				txa
.aa84	09 02		ora #$02			ora 	#2
.aa86	aa		tax				tax
.aa87					_NoSet1:
.aa87	a9 06		lda #$06			lda 	#(($32) >> 3)
.aa89	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa8c	29 04		and #$04			and 	#($01 << (($32) & 7))
.aa8e	f0 04		beq $aa94			beq 	_NoSet1
.aa90	8a		txa				txa
.aa91	09 04		ora #$04			ora 	#4
.aa93	aa		tax				tax
.aa94					_NoSet1:
.aa94	a9 04		lda #$04			lda 	#(($25) >> 3)
.aa96	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa99	29 20		and #$20			and 	#($01 << (($25) & 7))
.aa9b	f0 04		beq $aaa1			beq 	_NoSet1
.aa9d	8a		txa				txa
.aa9e	09 08		ora #$08			ora 	#8
.aaa0	aa		tax				tax
.aaa1					_NoSet1:
.aaa1	a9 04		lda #$04			lda 	#(($26) >> 3)
.aaa3	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaa6	29 40		and #$40			and 	#($01 << (($26) & 7))
.aaa8	f0 04		beq $aaae			beq 	_NoSet1
.aaaa	8a		txa				txa
.aaab	09 10		ora #$10			ora 	#16
.aaad	aa		tax				tax
.aaae					_NoSet1:
.aaae	8a		txa				txa
.aaaf	fa		plx				plx
.aab0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.b96e					GRVectorTable:
>b96e	ac ac					.word	GXInitialise             ; $00 Initialise
>b970	c6 ac					.word	GXControlBitmap          ; $01 BitmapCtl
>b972	0e ad					.word	GXControlSprite          ; $02 SpriteCtl
>b974	5e ac					.word	GXClearBitmap            ; $03 Clear
>b976	9d ae					.word	GXSetColourMode          ; $04 Colour
>b978	65 b0					.word	GXFontHandler            ; $05 DrawFont
>b97a	ad b0					.word	GXSpriteHandler          ; $06 DrawSprite
>b97c	19 b1					.word	GXSelect                 ; $07 SpriteUse
>b97e	42 b1					.word	GXSelectImage            ; $08 SpriteImage
>b980	c9 b2					.word	GXCollide                ; $09 SpriteCollide
>b982	10 ab					.word	GRUndefined              ; $0a
>b984	10 ab					.word	GRUndefined              ; $0b
>b986	10 ab					.word	GRUndefined              ; $0c
>b988	10 ab					.word	GRUndefined              ; $0d
>b98a	10 ab					.word	GRUndefined              ; $0e
>b98c	10 ab					.word	GRUndefined              ; $0f
>b98e	10 ab					.word	GRUndefined              ; $10
>b990	10 ab					.word	GRUndefined              ; $11
>b992	10 ab					.word	GRUndefined              ; $12
>b994	10 ab					.word	GRUndefined              ; $13
>b996	10 ab					.word	GRUndefined              ; $14
>b998	10 ab					.word	GRUndefined              ; $15
>b99a	10 ab					.word	GRUndefined              ; $16
>b99c	10 ab					.word	GRUndefined              ; $17
>b99e	10 ab					.word	GRUndefined              ; $18
>b9a0	10 ab					.word	GRUndefined              ; $19
>b9a2	10 ab					.word	GRUndefined              ; $1a
>b9a4	10 ab					.word	GRUndefined              ; $1b
>b9a6	10 ab					.word	GRUndefined              ; $1c
>b9a8	10 ab					.word	GRUndefined              ; $1d
>b9aa	10 ab					.word	GRUndefined              ; $1e
>b9ac	10 ab					.word	GRUndefined              ; $1f
>b9ae	0e ab					.word	GXMove                   ; $20 Move
>b9b0	6b ad					.word	GXLine                   ; $21 Line
>b9b2	e6 ae					.word	GXFrameRectangle         ; $22 FrameRect
>b9b4	e3 ae					.word	GXFillRectangle          ; $23 FillRect
>b9b6	15 ab					.word	GXFrameCircle            ; $24 FrameCircle
>b9b8	11 ab					.word	GXFillCircle             ; $25 FillCircle
>b9ba	10 ab					.word	GRUndefined              ; $26
>b9bc	10 ab					.word	GRUndefined              ; $27
>b9be	cb ae					.word	GXPlotPoint              ; $28 Plot
>b9c0	d8 b1					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5f9					gxPixelBuffer = numberBuffer
.0643					gxCurrentX:
>0643							.fill 	2
.0645					gxCurrentY:
>0645							.fill 	2
.0647					gxLastX:
>0647							.fill 	2
.0649					gxLastY:
>0649							.fill 	2
.064b					gxX0:
>064b							.fill 	2
.064d					gxY0:
>064d							.fill 	2
.064f					gxX1:
>064f							.fill 	2
.0651					gxY1:
>0651							.fill 	2
.0653					gxSpritesOn:
>0653							.fill 	1
.0654					gxBitmapsOn:
>0654							.fill 	1
.0655					gxBasePage:
>0655							.fill 	1
.0656					gxSpritePage:
>0656							.fill 	1
.0657					gxHeight:
>0657							.fill 	1
.0658					gxMode:
>0658							.fill 	1
.0659					gxColour:
>0659							.fill 	1
.065a					gxEORValue:
>065a							.fill 	1
.065b					gxANDValue:
>065b							.fill 	1
.065c					gxOriginalLUTValue:
>065c							.fill 	1
.065d					gsOffset:
>065d							.fill 	1
.065e					GSCurrentSpriteID:
>065e							.fill 	1
.065f					GSCurrentSpriteAddr:
>065f							.fill 	2
.0661					GXSpriteOffsetBase:
>0661							.fill 	2
.0663					GXSpriteLow:
>0663							.fill 	64
.06a3					GXSpriteHigh:
>06a3							.fill 	64
.aab1					GXGraphicDraw:
.aab1	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aab3	b0 06		bcs $aabb			bcs 	_GDCoordinate
.aab5	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aab7	84 37		sty $37				sty 	gxzTemp0+1
.aab9	80 4b		bra $ab06			bra 	_GDExecuteA 				; and execute
.aabb					_GDCoordinate:
.aabb	48		pha				pha 								; save AXY
.aabc	da		phx				phx
.aabd	5a		phy				phy
.aabe	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aac0					_GDCopy1:
.aac0	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.aac3	9d 47 06	sta $0647,x			sta 	gxLastX,x
.aac6	ca		dex				dex
.aac7	10 f7		bpl $aac0			bpl 	_GDCopy1
.aac9	68		pla				pla 								; update Y
.aaca	8d 45 06	sta $0645			sta 	gxCurrentY
.aacd	9c 46 06	stz $0646			stz 	gxCurrentY+1
.aad0	68		pla				pla
.aad1	8d 43 06	sta $0643			sta 	gxCurrentX
.aad4	68		pla				pla 								; get A (command+X.1) back
.aad5	48		pha				pha
.aad6	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aad8	8d 44 06	sta $0644			sta 	gxCurrentX+1
.aadb	68		pla				pla 								; get command back
.aadc	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aade	48		pha				pha 								; push back.
.aadf	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aae1	f0 17		beq $aafa			beq 	_GDCopyToWorkArea
.aae3	ad 44 06	lda $0644			lda 	gxCurrentX+1 				; X < 256 X okay
.aae6	f0 07		beq $aaef			beq 	_GDCheckY
.aae8	ad 43 06	lda $0643			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aaeb	c9 40		cmp #$40			cmp 	#64
.aaed	b0 08		bcs $aaf7			bcs 	_GDError1
.aaef					_GDCheckY:
.aaef	ad 45 06	lda $0645			lda 	gxCurrentY 					; check Y < Height.
.aaf2	cd 57 06	cmp $0657			cmp 	gxHeight
.aaf5	90 03		bcc $aafa			bcc 	_GDCopyToWorkArea
.aaf7					_GDError1:
.aaf7	68		pla				pla
.aaf8					_GDError2:
.aaf8	38		sec				sec
.aaf9	60		rts				rts
.aafa					_GDCopyToWorkArea:
.aafa	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.aafc					_GDCopy2:
.aafc	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.aaff	9d 4b 06	sta $064b,x			sta 	gxX0,x
.ab02	ca		dex				dex
.ab03	10 f7		bpl $aafc			bpl 	_GDCopy2
.ab05	68		pla				pla 								; get command
.ab06					_GDExecuteA:
.ab06	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.ab08	b0 ee		bcs $aaf8			bcs 	_GDError2
.ab0a	aa		tax				tax
.ab0b	7c 6e b9	jmp ($b96e,x)			jmp 	(GRVectorTable,x)
.ab0e					GXMove:
.ab0e	18		clc				clc
.ab0f	60		rts				rts
.ab10					GRUndefined:
>ab10	db						.byte 	$DB 						; causes a break in the emulator
.ab11					GXFillCircle:
.ab11	a9 ff		lda #$ff			lda 	#255
.ab13	80 02		bra $ab17			bra 	GXCircle
.ab15					GXFrameCircle:
.ab15	a9 00		lda #$00			lda 	#0
.ab17					GXCircle:
.ab17	8d e6 06	sta $06e6			sta 	gxIsFillMode					; save Fill flag
.ab1a	ad 54 06	lda $0654			lda 	gxBitmapsOn
.ab1d	f0 26		beq $ab45			beq 	_GXCFail
.ab1f	20 70 b3	jsr $b370			jsr 	GXSortXY 					; topleft/bottomright
.ab22	20 48 b2	jsr $b248			jsr 	GXOpenBitmap 				; start drawing
.ab25	20 17 ac	jsr $ac17			jsr 	GXCircleSetup 				; set up for drawing
.ab28	9c e7 06	stz $06e7			stz 	gxYChanged
.ab2b					_GXCircleDraw:
.ab2b	ad e4 06	lda $06e4			lda 	gXCentre					; while x <= y
.ab2e	cd e5 06	cmp $06e5			cmp 	gYCentre
.ab31	90 0a		bcc $ab3d			bcc 	_GXCircleContinue
.ab33	d0 03		bne $ab38			bne 	_GXNoLast
.ab35	20 4a ab	jsr $ab4a			jsr 	GXPlot1
.ab38					_GXNoLast:
.ab38	20 50 b2	jsr $b250			jsr 	GXCloseBitmap 				; close the bitmap
.ab3b	18		clc				clc
.ab3c	60		rts				rts
.ab3d					_GXCircleContinue:
.ab3d	20 47 ab	jsr $ab47			jsr 	GXPlot2 					; draw it
.ab40	20 c4 ab	jsr $abc4			jsr 	GXCircleMove 				; adjust the coordinates
.ab43	80 e6		bra $ab2b			bra 	_GXCircleDraw
.ab45					_GXCFail:
.ab45	38		sec				sec
.ab46	60		rts				rts
.ab47					GXPlot2:
.ab47	20 4a ab	jsr $ab4a			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ab4a					GXPlot1:
.ab4a	ad e5 06	lda $06e5			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ab4d	f0 03		beq $ab52			beq 	_GXPlot1Only
.ab4f	20 6e ab	jsr $ab6e			jsr 	GXPlot0 						; plot and negate
.ab52					_GXPlot1Only:
.ab52	20 6e ab	jsr $ab6e			jsr 	GXPlot0 						; twice, undoing negation
.ab55	ad e4 06	lda $06e4			lda 	gXCentre 						; swap X and Y
.ab58	ae e5 06	ldx $06e5			ldx	 	gYCentre
.ab5b	8d e5 06	sta $06e5			sta 	gYCentre
.ab5e	8e e4 06	stx $06e4			stx 	gXCentre
.ab61	ad e7 06	lda $06e7			lda 	gxYChanged 						; toggle Y Changed flag
.ab64	a9 ff		lda #$ff			lda 	#$FF
.ab66	8d e7 06	sta $06e7			sta 	gxYChanged
.ab69	60		rts				rts
.ab6a	20 6e ab	jsr $ab6e			jsr 	GXPlot0 						; do once
.ab6d	60		rts				rts
.ab6e	ad e6 06	lda $06e6	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ab71	f0 05		beq $ab78			beq 	_GXPlot0Always
.ab73	ad e7 06	lda $06e7			lda 	gxYChanged						; fill mode, only draw if changed.
.ab76	f0 2d		beq $aba5			beq 	GXPlot0Exit
.ab78					_GXPlot0Always:
.ab78	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ab7a	ad e5 06	lda $06e5			lda 	gYCentre
.ab7d	20 a6 ab	jsr $aba6			jsr 	GXSubCopy
.ab80	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ab82	ad e4 06	lda $06e4			lda 	gXCentre
.ab85	20 a6 ab	jsr $aba6			jsr 	GXSubCopy
.ab88	48		pha				pha 									; save last offset X
.ab89	20 58 b2	jsr $b258			jsr 	GXPositionCalc 					; calculate position/offset.
.ab8c	68		pla				pla
.ab8d	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ab8e	85 36		sta $36				sta 	gxzTemp0
.ab90	64 37		stz $37				stz 	gxzTemp0+1
.ab92	26 37		rol $37				rol 	gxzTemp0+1
.ab94	ad e6 06	lda $06e6			lda 	gxIsFillMode
.ab97	69 80		adc #$80			adc 	#128
.ab99	20 36 af	jsr $af36			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ab9c	38		sec				sec 									; GY = -GY
.ab9d	a9 00		lda #$00			lda 	#0
.ab9f	ed e5 06	sbc $06e5			sbc 	gYCentre
.aba2	8d e5 06	sta $06e5			sta 	gYCentre
.aba5					GXPlot0Exit:
.aba5	60		rts				rts
.aba6					GXSubCopy:
.aba6	85 36		sta $36				sta 	gxzTemp0
.aba8	64 37		stz $37				stz 	gxzTemp0+1
.abaa	29 80		and #$80			and 	#$80
.abac	f0 02		beq $abb0			beq 	_GXNoSx
.abae	c6 37		dec $37				dec 	gxzTemp0+1
.abb0					_GXNoSx:
.abb0	38		sec				sec
.abb1	bd 4f 06	lda $064f,x			lda 	gXX1,x
.abb4	e5 36		sbc $36				sbc 	gxzTemp0
.abb6	9d 4b 06	sta $064b,x			sta 	gXX0,x
.abb9	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.abbc	e5 37		sbc $37				sbc 	gxzTemp0+1
.abbe	9d 4c 06	sta $064c,x			sta 	gXX0+1,x
.abc1	a5 36		lda $36				lda 	gxzTemp0 						; return A
.abc3	60		rts				rts
.abc4					GXCircleMove:
.abc4	9c e7 06	stz $06e7			stz 	gxYChanged 					; clear Y changed flag
.abc7	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.abc9	10 0d		bpl $abd8			bpl 	_GXEMPositive
.abcb	ee e4 06	inc $06e4			inc 	gXCentre 					; X++
.abce	ad e4 06	lda $06e4			lda 	gXCentre
.abd1	20 f7 ab	jsr $abf7			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abd4	a9 06		lda #$06			lda 	#6  						; and add 6
.abd6	80 15		bra $abed			bra 	_GXEMAddD
.abd8					_GXEMPositive:
.abd8	ee e4 06	inc $06e4			inc 	gXCentre					; X++
.abdb	ce e5 06	dec $06e5			dec 	gyCentre 					; Y--
.abde	38		sec				sec 								; calculate X-Y
.abdf	ad e4 06	lda $06e4			lda 	gXCentre
.abe2	ed e5 06	sbc $06e5			sbc 	gYCentre
.abe5	20 f7 ab	jsr $abf7			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abe8	a9 0a		lda #$0a			lda 	#10  						; and add 10
.abea	ce e7 06	dec $06e7			dec 	gxYChanged
.abed					_GXEMAddD:
.abed	18		clc				clc
.abee	65 38		adc $38				adc 	gxzTemp1
.abf0	85 38		sta $38				sta 	gxzTemp1
.abf2	90 02		bcc $abf6			bcc 	_GXEMNoCarry
.abf4	e6 39		inc $39				inc 	gxzTemp1+1
.abf6					_GXEMNoCarry:
.abf6	60		rts				rts
.abf7					_GXAdd4TimesToD:
.abf7	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.abf9	29 80		and #$80			and 	#$80
.abfb	f0 02		beq $abff			beq 	_GXA4Unsigned
.abfd	a9 ff		lda #$ff			lda 	#$FF
.abff					_GXA4Unsigned:
.abff	85 37		sta $37				sta 	gxzTemp0+1
.ac01	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ac03	26 37		rol $37				rol 	gxzTemp0+1
.ac05	06 36		asl $36				asl 	gxzTemp0
.ac07	26 37		rol $37				rol 	gxzTemp0+1
.ac09	18		clc				clc 								; add
.ac0a	a5 36		lda $36				lda		gxzTemp0
.ac0c	65 38		adc $38				adc 	gxzTemp1
.ac0e	85 38		sta $38				sta 	gxzTemp1
.ac10	a5 37		lda $37				lda		gxzTemp0+1
.ac12	65 39		adc $39				adc 	gxzTemp1+1
.ac14	85 39		sta $39				sta 	gxzTemp1+1
.ac16	60		rts				rts
.ac17					GXCircleSetup:
.ac17	38		sec				sec
.ac18	ad 51 06	lda $0651			lda 	gxY1
.ac1b	ed 4d 06	sbc $064d			sbc 	gxY0
.ac1e	4a		lsr a				lsr 	a
.ac1f	8d e3 06	sta $06e3			sta 	gxRadius
.ac22	a2 00		ldx #$00			ldx 	#0
.ac24	20 46 ac	jsr $ac46			jsr 	_GXCalculateCentre
.ac27	a2 02		ldx #$02			ldx 	#2
.ac29	20 46 ac	jsr $ac46			jsr 	_GXCalculateCentre
.ac2c	9c e4 06	stz $06e4			stz 	gXCentre
.ac2f	ad e3 06	lda $06e3			lda 	gxRadius
.ac32	8d e5 06	sta $06e5			sta 	gYCentre
.ac35	0a		asl a				asl 	a 							; R x 2
.ac36	85 36		sta $36				sta 	gxzTemp0
.ac38	38		sec				sec
.ac39	a9 03		lda #$03			lda 	#3
.ac3b	e5 36		sbc $36				sbc 	gxzTemp0
.ac3d	85 38		sta $38				sta 	gxzTemp1
.ac3f	a9 00		lda #$00			lda 	#0
.ac41	e9 00		sbc #$00			sbc 	#0
.ac43	85 39		sta $39				sta 	gxzTemp1+1
.ac45	60		rts				rts
.ac46					_GXCalculateCentre:
.ac46	38		sec				sec
.ac47	bd 4f 06	lda $064f,x			lda 	gxX1,x
.ac4a	7d 4b 06	adc $064b,x			adc 	gXX0,x
.ac4d	9d 4f 06	sta $064f,x			sta 	gXX1,x
.ac50	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.ac53	7d 4c 06	adc $064c,x			adc 	gXX0+1,x
.ac56	4a		lsr a				lsr 	a
.ac57	9d 50 06	sta $0650,x			sta 	gXX1+1,x
.ac5a	7e 4f 06	ror $064f,x			ror 	gXX1,x
.ac5d	60		rts				rts
.06e3					gxRadius:
>06e3							.fill 	1
.06e4					gXCentre:
>06e4							.fill 	1
.06e5					gYCentre:
>06e5							.fill 	1
.06e6					gxIsFillMode:
>06e6							.fill 	1
.06e7					gxYChanged:
>06e7							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ac5e					GXClearBitmap:
.ac5e	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP running.
.ac61	f0 24		beq $ac87			beq 	_GXCBFail
.ac63	20 48 b2	jsr $b248			jsr 	GXOpenBitmap 				; start access
.ac66	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac68	ad 57 06	lda $0657			lda 	gxHeight
.ac6b	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ac6d	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ac6f					_GXCalcLastPage:
.ac6f	98		tya				tya 								; add to base page
.ac70	18		clc				clc
.ac71	6d 55 06	adc $0655			adc 	gxBasePage
.ac74	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ac76					_GXClearAll:
.ac76	20 89 ac	jsr $ac89			jsr 	_GXClearBlock 				; clear 8k block
.ac79	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ac7b	a5 0b		lda $0b				lda 	GXEditSlot
.ac7d	cd 55 06	cmp $0655			cmp 	gxBasePage 					; until before base page
.ac80	b0 f4		bcs $ac76			bcs 	_GXClearAll
.ac82	20 50 b2	jsr $b250			jsr 	GXCloseBitmap	 			; stop access
.ac85	18		clc				clc
.ac86	60		rts				rts
.ac87					_GXCBFail:
.ac87	38		sec				sec
.ac88	60		rts				rts
.ac89					_GXClearBlock:
.ac89	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ac8b	85 38		sta $38				sta 	0+gxzTemp1
.ac8d	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ac8f	85 39		sta $39				sta 	1+gxzTemp1
.ac91					_GXCB0:
.ac91	a5 36		lda $36				lda 	gxzTemp0
.ac93	a0 00		ldy #$00			ldy 	#0
.ac95					_GXCB1:
.ac95	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac97	c8		iny				iny
.ac98	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac9a	c8		iny				iny
.ac9b	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac9d	c8		iny				iny
.ac9e	91 38		sta ($38),y			sta 	(gxzTemp1),y
.aca0	c8		iny				iny
.aca1	d0 f2		bne $ac95			bne 	_GXCB1
.aca3	e6 39		inc $39				inc 	gxzTemp1+1
.aca5	a5 39		lda $39				lda 	gxzTemp1+1
.aca7	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.aca9	d0 e6		bne $ac91			bne 	_GXCB0
.acab	60		rts				rts
.acac					GXInitialise:
.acac	64 01		stz $01				stz 	1
.acae	a9 01		lda #$01			lda 	#1
.acb0	8d 00 d0	sta $d000			sta 	$D000
.acb3	18		clc				clc
.acb4	9c 53 06	stz $0653			stz 	GXSpritesOn
.acb7	9c 54 06	stz $0654			stz 	GXBitmapsOn
.acba	a2 0f		ldx #$0f			ldx 	#15
.acbc					_GXIClear:
.acbc	9e 43 06	stz $0643,x			stz 	gxCurrentX,x
.acbf	ca		dex				dex
.acc0	10 fa		bpl $acbc			bpl 	_GXIClear
.acc2	20 5d ad	jsr $ad5d			jsr 	GXClearSpriteStore
.acc5	60		rts				rts
.acc6					GXControlBitmap:
.acc6	64 01		stz $01				stz 	1
.acc8	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acca	29 01		and #$01			and 	#1 							; set bitmap flag
.accc	8d 54 06	sta $0654			sta 	gxBitmapsOn
.accf	4a		lsr a				lsr 	a 							; bit 0 into carry.
.acd0	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.acd3	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.acd5	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.acd7	90 02		bcc $acdb			bcc 	_CBNotOn
.acd9	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.acdb					_CBNotOn:
.acdb	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.acde	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ace0	29 07		and #$07			and 	#7
.ace2	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.ace5	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ace7	d0 02		bne $aceb			bne 	_CBNotDefault
.ace9	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.aceb					_CBNotDefault:
.aceb	8d 55 06	sta $0655			sta 	gxBasePage
.acee	20 4f ad	jsr $ad4f			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.acf1	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.acf3	8d 03 d1	sta $d103			sta 	$D103
.acf6	a5 36		lda $36				lda 	gxzTemp0
.acf8	8d 02 d1	sta $d102			sta 	$D102
.acfb	9c 01 d1	stz $d101			stz 	$D101
.acfe	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ad00	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ad03	29 01		and #$01			and 	#1
.ad05	f0 02		beq $ad09			beq 	_CBHaveHeight
.ad07	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ad09					_CBHaveHeight
.ad09	8e 57 06	stx $0657			stx 	gxHeight
.ad0c	18		clc				clc
.ad0d	60		rts				rts
.ad0e					GXControlSprite:
.ad0e	64 01		stz $01				stz 	1
.ad10	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad12	29 01		and #$01			and 	#1 							; set sprites flag
.ad14	8d 53 06	sta $0653			sta 	gxSpritesOn
.ad17	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad18	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad1b	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad1d	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ad1f	90 02		bcc $ad23			bcc 	_CSNotOn
.ad21	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ad23					_CSNotOn:
.ad23	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad26	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad28	d0 02		bne $ad2c			bne 	_CSNotDefault
.ad2a	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ad2c					_CSNotDefault:
.ad2c	8d 56 06	sta $0656			sta 	gxSpritePage
.ad2f	20 4f ad	jsr $ad4f			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad32	a5 36		lda $36				lda 	zTemp0
.ad34	8d 61 06	sta $0661			sta 	GXSpriteOffsetBase
.ad37	a5 37		lda $37				lda 	zTemp0+1
.ad39	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase+1
.ad3c	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ad3e					_CSClear:
.ad3e	9e 00 d9	stz $d900,x			stz 	$D900,x
.ad41	9e 00 da	stz $da00,x			stz 	$DA00,x
.ad44	ca		dex				dex
.ad45	d0 f7		bne $ad3e			bne 	_CSClear
.ad47	9c 60 06	stz $0660			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ad4a	20 5d ad	jsr $ad5d			jsr 	GXClearSpriteStore
.ad4d	18		clc				clc
.ad4e	60		rts				rts
.ad4f					GXCalculateBaseAddress:
.ad4f	85 36		sta $36				sta 	gxzTemp0
.ad51	64 37		stz $37				stz 	gxzTemp0+1
.ad53	a9 05		lda #$05			lda 	#5
.ad55					_GXShift:
.ad55	06 36		asl $36				asl 	gxzTemp0
.ad57	26 37		rol $37				rol 	gxzTemp0+1
.ad59	3a		dec a				dec		a
.ad5a	d0 f9		bne $ad55			bne 	_GXShift
.ad5c	60		rts				rts
.ad5d					GXClearSpriteStore:
.ad5d	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ad5f					_GXCSSLoop:
.ad5f	9e a3 06	stz $06a3,x			stz 	GXSpriteHigh,x
.ad62	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad64	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.ad67	ca		dex				dex
.ad68	10 f5		bpl $ad5f			bpl 	_GXCSSLoop
.ad6a	60		rts				rts
.ad6b					GXLine:
.ad6b	ad 54 06	lda $0654			lda 	GXBitmapsOn
.ad6e	f0 28		beq $ad98			beq 	_GXLFail
.ad70	20 48 b2	jsr $b248			jsr 	GXOpenBitmap
.ad73	20 8e b3	jsr $b38e			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ad76	20 3e ae	jsr $ae3e			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ad79	20 58 b2	jsr $b258			jsr 	GXPositionCalc 				; calculate position/offset.
.ad7c					_GXDrawLoop:
.ad7c	ac 5d 06	ldy $065d			ldy 	gsOffset 					; draw the pixel
.ad7f	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ad81	2d 5b 06	and $065b			and 	gxANDValue
.ad84	4d 5a 06	eor $065a			eor 	gxEORValue
.ad87	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ad89	20 9a ad	jsr $ad9a			jsr 	GXLineIsComplete 			; is the line complete ?
.ad8c	f0 05		beq $ad93			beq 	_GXLExit
.ad8e	20 b5 ad	jsr $adb5			jsr 	GXLineAdvance 				; code as per advance method
.ad91	80 e9		bra $ad7c			bra 	_GXDrawLoop
.ad93					_GXLExit:
.ad93	20 50 b2	jsr $b250			jsr 	GXCloseBitmap
.ad96	18		clc				clc
.ad97	60		rts				rts
.ad98					_GXLFail:
.ad98	38		sec				sec
.ad99	60		rts				rts
.ad9a					GXLineIsComplete:
.ad9a	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger 			; is dy larger
.ad9d	d0 0f		bne $adae			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ad9f	ad 4b 06	lda $064b			lda 	GXX0 						; compare X, LSB and MSB
.ada2	4d 4f 06	eor $064f			eor 	GXX1
.ada5	d0 06		bne $adad			bne 	_GXLICExit
.ada7	ad 4c 06	lda $064c			lda 	GXX0+1
.adaa	4d 50 06	eor $0650			eor 	GXX1+1
.adad					_GXLICExit:
.adad	60		rts				rts
.adae					_GXLICCompareY:
.adae	ad 51 06	lda $0651			lda 	GXY1
.adb1	4d 4d 06	eor $064d			eor 	GXY0
.adb4	60		rts				rts
.adb5					GXLineAdvance:
.adb5	18		clc				clc 								; add adjust to position
.adb6	ad ec 06	lda $06ec			lda 	GXPosition
.adb9	6d ed 06	adc $06ed			adc 	GXAdjust
.adbc	8d ec 06	sta $06ec			sta 	GXPosition
.adbf	9c ef 06	stz $06ef			stz 	GXAddSelect 				; clear add select flag
.adc2	b0 05		bcs $adc9			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.adc4	cd ee 06	cmp $06ee			cmp 	GXTotal 					; if exceeded total
.adc7	90 0a		bcc $add3			bcc 	_GXLANoExtra
.adc9					_GXLAOverflow:
.adc9	ce ef 06	dec $06ef			dec 	GXAddSelect 				; set addselect to $FF
.adcc	38		sec				sec 								; subtract total and write back
.adcd	ed ee 06	sbc $06ee			sbc 	GXTotal
.add0	8d ec 06	sta $06ec			sta 	GXPosition
.add3					_GXLANoExtra:
.add3	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger
.add6	f0 0d		beq $ade5			beq 	_GXDXLarger
.add8	20 37 ae	jsr $ae37			jsr 	GXIncrementY
.addb	ad ef 06	lda $06ef			lda 	GXAddSelect
.adde	f0 10		beq $adf0			beq 	_GXLAExit
.ade0	20 f1 ad	jsr $adf1			jsr 	GXAdjustX
.ade3	80 0b		bra $adf0			bra 	_GXLAExit
.ade5					_GXDXLarger:
.ade5	20 f1 ad	jsr $adf1			jsr 	GXAdjustX
.ade8	ad ef 06	lda $06ef			lda 	GXAddSelect
.adeb	f0 03		beq $adf0			beq 	_GXLAExit
.aded	20 37 ae	jsr $ae37			jsr 	GXIncrementY
.adf0					_GXLAExit:
.adf0	60		rts				rts
.adf1					GXAdjustX:
.adf1	ad eb 06	lda $06eb			lda 	GXDXNegative
.adf4	10 25		bpl $ae1b			bpl 	_GXAXRight
.adf6	ad 4b 06	lda $064b			lda 	GXX0
.adf9	d0 03		bne $adfe			bne 	_GXAXNoBorrow
.adfb	ce 4c 06	dec $064c			dec 	GXX0+1
.adfe					_GXAXNoBorrow:
.adfe	ce 4b 06	dec $064b			dec 	GXX0
.ae01	ce 5d 06	dec $065d			dec 	gsOffset 					; pixel left
.ae04	ad 5d 06	lda $065d			lda 	gsOffset
.ae07	c9 ff		cmp #$ff			cmp 	#$FF
.ae09	d0 0f		bne $ae1a			bne 	_GXAYExit 					; underflow
.ae0b	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.ae0d	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.ae0f	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.ae11	b0 07		bcs $ae1a			bcs 	_GXAYExit
.ae13	18		clc				clc
.ae14	69 20		adc #$20			adc 	#$20 						; fix up
.ae16	85 3d		sta $3d				sta 	gxzScreen+1
.ae18	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ae1a					_GXAYExit:
.ae1a	60		rts				rts
.ae1b					_GXAXRight:
.ae1b	ee 4b 06	inc $064b			inc 	GXX0
.ae1e	d0 03		bne $ae23			bne 	_GXAXNoCarry
.ae20	ee 4c 06	inc $064c			inc 	GXX0+1
.ae23					_GXAXNoCarry:
.ae23	ee 5d 06	inc $065d			inc 	gsOffset 					; pixel right
.ae26	d0 0e		bne $ae36			bne 	_GXAXExit 					; if not overflowed, exit.
.ae28	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ae2a	a5 3d		lda $3d				lda 	gxzScreen+1
.ae2c	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ae2e	90 06		bcc $ae36			bcc 	_GXAXExit
.ae30	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae32	85 3d		sta $3d				sta 	gxzScreen+1
.ae34	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ae36					_GXAXExit:
.ae36	60		rts				rts
.ae37					GXIncrementY:
.ae37	ee 4d 06	inc $064d			inc 	GXY0
.ae3a	20 ae b2	jsr $b2ae			jsr 	GXMovePositionDown
.ae3d	60		rts				rts
.ae3e					GXLineSetup:
.ae3e	ad 51 06	lda $0651			lda 	GXY1
.ae41	38		sec				sec
.ae42	ed 4d 06	sbc $064d			sbc 	GXY0
.ae45	4a		lsr a				lsr 	a
.ae46	8d e9 06	sta $06e9			sta 	GXDiffY
.ae49	9c eb 06	stz $06eb			stz 	GXDXNegative 				; clear -ve flag
.ae4c	38		sec				sec
.ae4d	ad 4f 06	lda $064f			lda 	GXX1
.ae50	ed 4b 06	sbc $064b			sbc 	GXX0
.ae53	8d e8 06	sta $06e8			sta 	GXDiffX
.ae56	ad 50 06	lda $0650			lda 	GXX1+1 						; calculate MSB
.ae59	ed 4c 06	sbc $064c			sbc 	GXX0+1
.ae5c	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ae5d	6e e8 06	ror $06e8			ror 	GXDiffX
.ae60	0a		asl a				asl 	a
.ae61	10 0c		bpl $ae6f			bpl 	_GDXNotNegative
.ae63	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae65	38		sec				sec
.ae66	ed e8 06	sbc $06e8			sbc 	GXDiffX
.ae69	8d e8 06	sta $06e8			sta 	GXDiffX
.ae6c	ce eb 06	dec $06eb			dec 	GXDXNegative 				; -ve flag = $FF.
.ae6f					_GDXNotNegative:
.ae6f	9c ea 06	stz $06ea			stz 	GXIsDiffYLarger 			; clear larger flag
.ae72	ad e9 06	lda $06e9			lda 	GXDiffY 					; set adjust and total.
.ae75	8d ed 06	sta $06ed			sta 	GXAdjust
.ae78	ad e8 06	lda $06e8			lda 	GXDiffX
.ae7b	8d ee 06	sta $06ee			sta 	GXTotal
.ae7e	ad e9 06	lda $06e9			lda 	GXDiffY 					; if dy > dx
.ae81	cd e8 06	cmp $06e8			cmp 	GXDiffX
.ae84	90 0f		bcc $ae95			bcc 	_GDXNotLarger
.ae86	ce ea 06	dec $06ea			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ae89	ad e8 06	lda $06e8			lda 	GXDiffX 					; set adjust and total other way round
.ae8c	8d ed 06	sta $06ed			sta 	GXAdjust
.ae8f	ad e9 06	lda $06e9			lda 	GXDiffY
.ae92	8d ee 06	sta $06ee			sta 	GXTotal
.ae95					_GDXNotLarger:
.ae95	ad ee 06	lda $06ee			lda 	GXTotal
.ae98	4a		lsr a				lsr 	a
.ae99	8d ec 06	sta $06ec			sta 	GXPosition
.ae9c	60		rts				rts
.06e8					GXDiffX:
>06e8							.fill 	1
.06e9					GXDiffY:
>06e9							.fill 	1
.06ea					GXIsDiffYLarger:
>06ea							.fill 	1
.06eb					GXDXNegative:
>06eb							.fill 	1
.06ec					GXPosition:
>06ec							.fill 	1
.06ed					GXAdjust:
>06ed							.fill 	1
.06ee					GXTotal:
>06ee							.fill 	1
.06ef					GXAddSelect:
>06ef							.fill 	1
.ae9d					GXSetColourMode:
.ae9d	a6 36		ldx $36				ldx 	gxzTemp0
.ae9f	8e 59 06	stx $0659			stx 	gxColour 								; set colour
.aea2	a5 37		lda $37				lda 	gxzTemp0+1 								;
.aea4	8d 58 06	sta $0658			sta 	gxMode 									; set mode
.aea7	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.aea9	9c 5b 06	stz $065b			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.aeac	ae 59 06	ldx $0659			ldx 	gxColour
.aeaf	8e 5a 06	stx $065a			stx 	gxEORValue
.aeb2	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.aeb4	90 03		bcc $aeb9			bcc 	_GXSDCNotAndColour
.aeb6	8e 5b 06	stx $065b			stx 	gxANDValue
.aeb9					_GXSDCNotAndColour:
.aeb9	d0 03		bne $aebe			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.aebb	9c 5a 06	stz $065a			stz 	gxEORValue
.aebe					_GXSDCNotAnd:
.aebe	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.aebf	90 08		bcc $aec9			bcc 	_GXSDCNoFlip
.aec1	ad 5b 06	lda $065b			lda	 	gxANDValue
.aec4	49 ff		eor #$ff			eor 	#$FF
.aec6	8d 5b 06	sta $065b			sta 	gxANDValue
.aec9					_GXSDCNoFlip:
.aec9	18		clc				clc
.aeca	60		rts				rts
.aecb					GXPlotPoint:
.aecb	20 48 b2	jsr $b248			jsr 	GXOpenBitmap 				; start drawing
.aece	20 58 b2	jsr $b258			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aed1	ac 5d 06	ldy $065d			ldy 	gsOffset
.aed4	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.aed6	2d 5b 06	and $065b			and 	gxANDValue
.aed9	4d 5a 06	eor $065a			eor 	gxEORValue
.aedc	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aede	20 50 b2	jsr $b250			jsr 	GXCloseBitmap 				; stop drawing and exit
.aee1	18		clc				clc
.aee2	60		rts				rts
.aee3					GXFillRectangle:
.aee3	38		sec				sec
.aee4	80 01		bra $aee7			bra 	GXRectangle
.aee6					GXFrameRectangle:
.aee6	18		clc				clc
.aee7					GXRectangle:
.aee7	ad 54 06	lda $0654			lda 	gxBitmapsOn
.aeea	f0 35		beq $af21			beq 	_GXRFail
.aeec	08		php				php 								; save Fill flag (CS)
.aeed	20 48 b2	jsr $b248			jsr 	GXOpenBitmap 				; start drawing
.aef0	20 70 b3	jsr $b370			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.aef3	20 58 b2	jsr $b258			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aef6	38		sec				sec 								; sec = Draw line
.aef7	20 23 af	jsr $af23			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.aefa	ad 4d 06	lda $064d			lda 	gxY0 						; reached end of rectangle ?
.aefd	cd 51 06	cmp $0651			cmp 	gxY1
.af00	f0 19		beq $af1b			beq 	_GXRectangleExit
.af02					_GXRectLoop:
.af02	20 ae b2	jsr $b2ae			jsr 	GXMovePositionDown 			; down one.
.af05	ee 4d 06	inc $064d			inc 	gxY0 						; change Y pos
.af08	ad 4d 06	lda $064d			lda 	gxY0 						; reached last line
.af0b	cd 51 06	cmp $0651			cmp 	gXY1
.af0e	f0 07		beq $af17			beq 	_GXLastLine
.af10	28		plp				plp 								; get flag back
.af11	08		php				php
.af12	20 23 af	jsr $af23			jsr 	GXDrawLineX1X0 				; draw horizontal line
.af15	80 eb		bra $af02			bra 	_GXRectLoop
.af17					_GXLastLine:
.af17	38		sec				sec
.af18	20 23 af	jsr $af23			jsr 	GXDrawLineX1X0
.af1b					_GXRectangleExit:
.af1b	68		pla				pla 								; throw fill flag.
.af1c	20 50 b2	jsr $b250			jsr 	GXCloseBitmap 				; stop drawing and exit
.af1f	18		clc				clc
.af20	60		rts				rts
.af21					_GXRFail:
.af21	38		sec				sec
.af22	60		rts				rts
.af23					GXDrawLineX1X0:
.af23	08		php				php 								; save solid/either-end
.af24	38		sec				sec
.af25	ad 4f 06	lda $064f			lda		gXX1
.af28	ed 4b 06	sbc $064b			sbc 	gXX0
.af2b	85 36		sta $36				sta 	gxzTemp0
.af2d	ad 50 06	lda $0650			lda 	gXX1+1
.af30	ed 4c 06	sbc $064c			sbc 	gXX0+1
.af33	85 37		sta $37				sta 	gxzTemp0+1
.af35	28		plp				plp
.af36					GXDrawLineTemp0:
.af36	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.af38	48		pha				pha
.af39	a5 3d		lda $3d				lda 	gxzScreen+1
.af3b	48		pha				pha
.af3c	ad 5d 06	lda $065d			lda 	gsOffset
.af3f	48		pha				pha
.af40	a5 0b		lda $0b				lda 	GXEditSlot
.af42	48		pha				pha
.af43	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y offset
.af46	90 1e		bcc $af66			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.af48					_GXDLTLine:
.af48	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af4a	2d 5b 06	and $065b			and 	gxANDValue
.af4d	4d 5a 06	eor $065a			eor 	gxEORValue
.af50	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af52	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.af54	d0 04		bne $af5a			bne 	_GXDLTNoBorrow
.af56	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.af58	30 2e		bmi $af88			bmi 	_GXDLTExit
.af5a					_GXDLTNoBorrow:
.af5a	c6 36		dec $36				dec 	gxzTemp0
.af5c	c8		iny				iny 								; next slot.
.af5d	d0 e9		bne $af48			bne 	_GXDLTLine
.af5f	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.af61	20 96 af	jsr $af96			jsr 	GXDLTCheckWrap				; check for new page.
.af64	80 e2		bra $af48			bra 	_GXDLTLine
.af66					_GXDLTEndPoints:
.af66	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af68	2d 5b 06	and $065b			and 	gxANDValue
.af6b	4d 5a 06	eor $065a			eor 	gxEORValue
.af6e	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af70	98		tya				tya 								; advance to right side
.af71	18		clc				clc
.af72	65 36		adc $36				adc 	gxzTemp0
.af74	a8		tay				tay
.af75	a5 3d		lda $3d				lda 	gxzScreen+1
.af77	65 37		adc $37				adc 	gxzTemp0+1
.af79	85 3d		sta $3d				sta 	gxzScreen+1
.af7b	20 96 af	jsr $af96			jsr 	GXDLTCheckWrap 			; fix up.
.af7e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af80	2d 5b 06	and $065b			and 	gxANDValue
.af83	4d 5a 06	eor $065a			eor 	gxEORValue
.af86	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af88					_GXDLTExit:
.af88	68		pla				pla
.af89	85 0b		sta $0b				sta 	GXEditSlot
.af8b	68		pla				pla
.af8c	8d 5d 06	sta $065d			sta 	gsOffset
.af8f	68		pla				pla
.af90	85 3d		sta $3d				sta 	gxzScreen+1
.af92	68		pla				pla
.af93	85 3c		sta $3c				sta 	gxzScreen
.af95	60		rts				rts
.af96					GXDLTCheckWrap:
.af96	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.af98	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.af9a	90 06		bcc $afa2			bcc 	_GXDLTCWExit
.af9c	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af9e	85 3d		sta $3d				sta 	gxzScreen+1
.afa0	e6 0b		inc $0b				inc 	GXEditSlot
.afa2					_GXDLTCWExit:
.afa2	60		rts				rts
.afa3					GXDrawGraphicElement:
.afa3	8d f0 06	sta $06f0			sta 	gxSize 						; save size
.afa6	3a		dec a				dec 	a
.afa7	8d f1 06	sta $06f1			sta 	gxMask 						; and mask
.afaa	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP on
.afad	f0 67		beq $b016			beq 	_GXSLFail
.afaf	ad 4d 06	lda $064d			lda 	gxY0 						; push Y on stack
.afb2	48		pha				pha
.afb3	8c f3 06	sty $06f3			sty 	gxAcquireVector+1 			; and acquisition vector
.afb6	8e f2 06	stx $06f2			stx 	gxAcquireVector
.afb9	20 48 b2	jsr $b248			jsr 	gxOpenBitmap 				; open the bitmap.
.afbc	ad f5 06	lda $06f5			lda 	gxUseMode 					; scale bits
.afbf	4a		lsr a				lsr 	a
.afc0	4a		lsr a				lsr 	a
.afc1	4a		lsr a				lsr 	a
.afc2	29 07		and #$07			and		#7
.afc4	1a		inc a				inc 	a
.afc5	8d f4 06	sta $06f4			sta 	gxScale
.afc8	64 38		stz $38				stz 	gxzTemp1					; start first line
.afca					_GXGELoop:
.afca	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.afcc	2c f5 06	bit $06f5			bit 	gxUseMode 					; check for flip.
.afcf	10 06		bpl $afd7			bpl		_GXNoVFlip
.afd1	ad f1 06	lda $06f1			lda 	gxMask
.afd4	38		sec				sec
.afd5	e5 38		sbc $38				sbc 	gxzTemp1
.afd7					_GXNoVFlip:
.afd7	aa		tax				tax 								; get the Xth line.
.afd8	20 18 b0	jsr $b018			jsr 	_GXCallAcquire 				; get that data.
.afdb	ad f4 06	lda $06f4			lda 	gxScale 					; do scale identical copies of that line.
.afde	85 39		sta $39				sta 	gxzTemp1+1
.afe0					_GXGELoop2:
.afe0	ad 4d 06	lda $064d			lda 	gxY0 						; off screen
.afe3	cd 57 06	cmp $0657			cmp 	gxHeight
.afe6	b0 10		bcs $aff8			bcs 	_GXDGEExit
.afe8	20 1b b0	jsr $b01b			jsr 	GXRenderOneLine 			; render line
.afeb	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.afed	d0 f1		bne $afe0			bne 	_GXGELoop2
.afef	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.aff1	a5 38		lda $38				lda 	gxzTemp1
.aff3	cd f0 06	cmp $06f0			cmp 	gxSize
.aff6	d0 d2		bne $afca			bne 	_GXGELoop
.aff8					_GXDGEExit:
.aff8	68		pla				pla 								; restore Y for next time
.aff9	8d 4d 06	sta $064d			sta 	gxY0
.affc	ae f4 06	ldx $06f4			ldx 	gxScale 					; get scale (1-8)
.afff					_GXShiftLeft:
.afff	18		clc				clc
.b000	ad f0 06	lda $06f0			lda 	gxSize
.b003	6d 4b 06	adc $064b			adc 	gxX0
.b006	8d 4b 06	sta $064b			sta 	gxX0
.b009	90 03		bcc $b00e			bcc 	_GXSLNoCarry
.b00b	ee 4c 06	inc $064c			inc 	gxX0+1
.b00e					_GXSLNoCarry:
.b00e	ca		dex				dex
.b00f	d0 ee		bne $afff			bne 	_GXShiftLeft
.b011	20 50 b2	jsr $b250			jsr 	GXCloseBitmap
.b014	18		clc				clc
.b015	60		rts				rts
.b016					_GXSLFail:
.b016	38		sec				sec
.b017	60		rts				rts
.b018					_GXCallAcquire:
.b018	6c f2 06	jmp ($06f2)			jmp 	(gxAcquireVector)
.b01b					GXRenderOneLine:
.b01b	20 58 b2	jsr $b258			jsr 	GXPositionCalc 				; calculate position/offset.
.b01e	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y contains position.
.b021	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b023					_GXROLLoop1:
.b023	ad f4 06	lda $06f4			lda 	gxScale 					; set to do 'scale' times
.b026	85 3b		sta $3b				sta 	gxzTemp2+1
.b028					_GXROLLoop2:
.b028	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b02a	2c 58 06	bit $0658			bit 	gxMode 						; check H Flip
.b02d	50 06		bvc $b035			bvc 	_GXNoHFlip
.b02f	ad f1 06	lda $06f1			lda 	gxMask
.b032	38		sec				sec
.b033	e5 3a		sbc $3a				sbc 	gxzTemp2
.b035					_GXNoHFlip:
.b035	aa		tax				tax 								; read from the pixel buffer
.b036	bd f9 05	lda $05f9,x			lda 	gxPixelBuffer,x
.b039	d0 07		bne $b042			bne 	_GXDraw 					; draw if non zero
.b03b	ad f5 06	lda $06f5			lda 	gxUseMode 					; check to see if solid background
.b03e	29 04		and #$04			and 	#4
.b040	f0 0a		beq $b04c			beq 	_GXZeroPixel
.b042					_GXDraw:
.b042	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b044	2d 5b 06	and $065b			and 	gxANDValue
.b047	5d f9 05	eor $05f9,x			eor 	gxPixelBuffer,x
.b04a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b04c					_GXZeroPixel:
.b04c	c8		iny				iny 								; advance pointer
.b04d	d0 05		bne $b054			bne 	_GXNoShift
.b04f	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b051	20 96 af	jsr $af96			jsr 	GXDLTCheckWrap				; check for new page.
.b054					_GXNoShift:
.b054	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b056	d0 d0		bne $b028			bne 	_GXROLLoop2
.b058	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b05a	a5 3a		lda $3a				lda 	gxzTemp2
.b05c	cd f0 06	cmp $06f0			cmp 	gxSize
.b05f	d0 c2		bne $b023			bne 	_GXROLLoop1
.b061	ee 4d 06	inc $064d			inc 	gxY0
.b064	60		rts				rts
.06f0					gxSize:
>06f0							.fill 	1
.06f1					gxMask:
>06f1							.fill 	1
.06f2					gxAcquireVector:
>06f2							.fill 	2
.06f4					gxScale:
>06f4							.fill 	1
.06f5					gxUseMode:
>06f5							.fill 	1
.b065					GXFontHandler:
.b065	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b067	4d 58 06	eor $0658			eor 	gxMode
.b06a	8d f5 06	sta $06f5			sta 	gxUseMode
.b06d	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b06f	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b071	26 37		rol $37				rol	 	gxzTemp0+1
.b073	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b075	26 37		rol $37				rol	 	gxzTemp0+1
.b077	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b079	26 37		rol $37				rol	 	gxzTemp0+1
.b07b	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b07d	09 c0		ora #$c0			ora 	#$C0
.b07f	85 37		sta $37				sta 	gxzTemp0+1
.b081	a9 08		lda #$08			lda 	#8 							; size 8x8
.b083	a2 8b		ldx #$8b			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b085	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b087	20 a3 af	jsr $afa3			jsr 	GXDrawGraphicElement
.b08a	60		rts				rts
.b08b					GXGetGraphicDataFont:
.b08b	8a		txa				txa 								; X->Y
.b08c	a8		tay				tay
.b08d	a6 01		ldx $01				ldx 	1 							; preserve old value
.b08f	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b091	85 01		sta $01				sta 	1
.b093	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b095	86 01		stx $01				stx 	1 							; put old value back.
.b097	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b099					_GXExpand:
.b099	9e f9 05	stz $05f9,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b09c	0a		asl a				asl 	a 							; shift bit 7 into C
.b09d	90 08		bcc $b0a7			bcc 	_GXNoPixel
.b09f	48		pha				pha 								; if set, set pixel buffer to current colour.
.b0a0	ad 59 06	lda $0659			lda 	gxColour
.b0a3	9d f9 05	sta $05f9,x			sta 	gxPixelBuffer,x
.b0a6	68		pla				pla
.b0a7					_GXNoPixel:
.b0a7	e8		inx				inx 								; do the whole byte.
.b0a8	e0 08		cpx #$08			cpx 	#8
.b0aa	d0 ed		bne $b099			bne 	_GXExpand
.b0ac	60		rts				rts
.b0ad					GXSpriteHandler:
.b0ad	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b0af	4d 58 06	eor $0658			eor 	gxMode
.b0b2	8d f5 06	sta $06f5			sta 	gxUseMode
.b0b5	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b0b7	da		phx				phx
.b0b8	20 48 b2	jsr $b248			jsr 	GXOpenBitmap 				; can access sprite information
.b0bb	68		pla				pla
.b0bc	20 29 b3	jsr $b329			jsr 	GXFindSprite 				; get the sprite address
.b0bf	08		php				php
.b0c0	20 50 b2	jsr $b250			jsr 	GXCloseBitmap
.b0c3	28		plp				plp
.b0c4	b0 0a		bcs $b0d0			bcs		_GXSHExit 					; exit if find failed.
.b0c6	ad f6 06	lda $06f6			lda 	GXSizePixels 				; return size
.b0c9	a2 d1		ldx #$d1			ldx 	#GXSpriteAcquire & $FF
.b0cb	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b0cd	20 a3 af	jsr $afa3			jsr 	GXDrawGraphicElement
.b0d0					_GXSHExit:
.b0d0	60		rts				rts
.b0d1					GXSpriteAcquire:
.b0d1	ad 56 06	lda $0656			lda 	GXSpritePage				; point to base page
.b0d4	85 0b		sta $0b				sta 	GXEditSlot
.b0d6	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b0d8	a9 00		lda #$00			lda 	#0
.b0da	ae f7 06	ldx $06f7			ldx 	GXSizeBits
.b0dd					_GXTimesRowNumber:
.b0dd	18		clc				clc
.b0de	65 36		adc $36				adc 	zTemp0
.b0e0	ca		dex				dex
.b0e1	10 fa		bpl $b0dd			bpl 	_GXTimesRowNumber
.b0e3	64 37		stz $37				stz 	gxzTemp0+1
.b0e5	0a		asl a				asl 	a 							; row x 2,4,6,8
.b0e6	26 37		rol $37				rol 	gxzTemp0+1
.b0e8	0a		asl a				asl 	a 							; row x 4,8,12,16
.b0e9	26 37		rol $37				rol 	gxzTemp0+1
.b0eb	0a		asl a				asl 	a 							; row x 8,16,24,32
.b0ec	26 37		rol $37				rol 	gxzTemp0+1
.b0ee	85 36		sta $36				sta 	gxzTemp0
.b0f0	18		clc				clc 								; add base address.
.b0f1	a5 36		lda $36				lda 	gxzTemp0
.b0f3	6d f9 06	adc $06f9			adc 	GXSpriteOffset
.b0f6	85 36		sta $36				sta 	gxzTemp0
.b0f8	a5 37		lda $37				lda 	gxzTemp0+1
.b0fa	6d fa 06	adc $06fa			adc 	GXSpriteOffset+1
.b0fd					_GXSAFindPage:
.b0fd	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b0ff	90 06		bcc $b107			bcc 	_GXSAFoundPage
.b101	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b103	e6 0b		inc $0b				inc 	GXEditSlot
.b105	80 f6		bra $b0fd			bra 	_GXSAFindPage
.b107					_GXSAFoundPage:
.b107	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b109	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b10b	a0 00		ldy #$00			ldy 	#0
.b10d					_GXSACopyLoop:
.b10d	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b10f	99 f9 05	sta $05f9,y			sta 	gxPixelBuffer,y
.b112	c8		iny				iny
.b113	cc f6 06	cpy $06f6			cpy 	GXSizePixels
.b116	d0 f5		bne $b10d			bne 	_GXSACopyLoop
.b118	60		rts				rts
.b119					GXSelect:
.b119	ad 53 06	lda $0653			lda 	gxSpritesOn
.b11c	f0 22		beq $b140			beq 	_GXSFail
.b11e	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b120	c9 40		cmp #$40			cmp 	#64
.b122	b0 1c		bcs $b140			bcs 	_GXSFail
.b124	8d 5e 06	sta $065e			sta 	GSCurrentSpriteID
.b127	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b129	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b12b	06 36		asl $36				asl 	gxzTemp0
.b12d	06 36		asl $36				asl 	gxzTemp0
.b12f	06 36		asl $36				asl 	gxzTemp0
.b131	2a		rol a				rol 	a
.b132	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b134	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b137	85 37		sta $37				sta 	gxzTemp0+1
.b139	a5 36		lda $36				lda 	gxzTemp0
.b13b	8d 5f 06	sta $065f			sta 	GSCurrentSpriteAddr
.b13e	18		clc				clc
.b13f	60		rts				rts
.b140					_GXSFail:
.b140	38		sec				sec
.b141	60		rts				rts
.b142					GXSelectImage:
.b142	ad 53 06	lda $0653			lda 	gxSpritesOn
.b145	f0 74		beq $b1bb			beq 	_GXSIFail
.b147	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b14a	f0 6f		beq $b1bb			beq 	_GXSIFail 					; (checking the MSB)
.b14c	64 01		stz $01				stz 	1
.b14e	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b150	d0 6b		bne $b1bd			bne 	_GXSIHide
.b152	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b154	48		pha				pha
.b155	20 48 b2	jsr $b248			jsr 	GXOpenBitmap
.b158	68		pla				pla
.b159	20 29 b3	jsr $b329			jsr 	GXFindSprite
.b15c	b0 5a		bcs $b1b8			bcs 	_GXSICloseFail 				; no image
.b15e	a0 01		ldy #$01			ldy 	#1
.b160	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b163	85 36		sta $36				sta 	gxzTemp0
.b165	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b168	85 37		sta $37				sta 	gxzTemp0+1
.b16a	ad f9 06	lda $06f9			lda 	GXSpriteOffset
.b16d	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b16f	18		clc				clc
.b170	ad fa 06	lda $06fa			lda 	GXSpriteOffset+1
.b173	6d 61 06	adc $0661			adc 	GXSpriteOffsetBase
.b176	c8		iny				iny
.b177	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b179	ad 62 06	lda $0662			lda 	GXSpriteOffsetBase+1
.b17c	69 00		adc #$00			adc 	#0
.b17e	c8		iny				iny
.b17f	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b181	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get raw size
.b184	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b186	2a		rol a				rol 	a 							; x 2
.b187	0a		asl a				asl 	a 							; x 4
.b188	0a		asl a				asl 	a 							; x 8
.b189	0a		asl a				asl 	a 							; x 16
.b18a	0d f8 06	ora $06f8			ora 	GXSpriteLUT 				; Or with LUT
.b18d	0a		asl a				asl 	a 							; 1 shift
.b18e	09 01		ora #$01			ora 	#1 							; enable sprite.
.b190	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b192	20 50 b2	jsr $b250			jsr 	GXCloseBitmap
.b195	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b198	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b19b	29 3f		and #$3f			and 	#$3F
.b19d	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1a0	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get bit size
.b1a3	6a		ror a				ror 	a 							; shift into bits 6/7
.b1a4	6a		ror a				ror 	a
.b1a5	6a		ror a				ror 	a
.b1a6	29 c0		and #$c0			and 	#$C0
.b1a8	1d a3 06	ora $06a3,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b1ab	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1ae	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b1b1	29 7f		and #$7f			and 	#$7F
.b1b3	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b1b6	18		clc				clc
.b1b7	60		rts				rts
.b1b8					_GXSICloseFail:
.b1b8	20 50 b2	jsr $b250			jsr 	GXCloseBitmap
.b1bb					_GXSIFail:
.b1bb	38		sec				sec
.b1bc	60		rts				rts
.b1bd					_GXSIHide:
.b1bd	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b1c0	85 36		sta $36				sta 	gxzTemp0
.b1c2	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b1c5	85 37		sta $37				sta 	gxzTemp0+1
.b1c7	a9 00		lda #$00			lda 	#0
.b1c9	92 36		sta ($36)			sta 	(gxzTemp0)
.b1cb	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get sprite ID
.b1ce	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b1d1	09 80		ora #$80			ora 	#$80
.b1d3	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b1d6	18		clc				clc
.b1d7	60		rts				rts
.b1d8					GXMoveSprite:
.b1d8	ad 53 06	lda $0653			lda 	gxSpritesOn
.b1db	f0 65		beq $b242			beq 	_GXSIFail
.b1dd	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b1e0	f0 60		beq $b242			beq 	_GXSIFail
.b1e2	85 37		sta $37				sta 	gxzTemp0+1
.b1e4	a0 04		ldy #$04			ldy 	#4
.b1e6	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b1e9	85 36		sta $36				sta 	gxzTemp0
.b1eb	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b1ee	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b1f1	2a		rol a				rol 	a	 						; into bits 0,1.
.b1f2	2a		rol a				rol 	a
.b1f3	2a		rol a				rol 	a
.b1f4	29 03		and #$03			and 	#3
.b1f6	aa		tax				tax
.b1f7	bd 44 b2	lda $b244,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b1fa	48		pha				pha
.b1fb	18		clc				clc
.b1fc	6d 4b 06	adc $064b			adc 	gxX0						; copy position.
.b1ff	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b201	c8		iny				iny
.b202	ad 4c 06	lda $064c			lda 	gxX0+1
.b205	69 00		adc #$00			adc 	#0
.b207	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b209	c8		iny				iny
.b20a	68		pla				pla
.b20b	18		clc				clc
.b20c	6d 4d 06	adc $064d			adc 	gxY0
.b20f	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b211	a9 00		lda #$00			lda 	#0
.b213	69 00		adc #$00			adc 	#0
.b215	c8		iny				iny
.b216	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b218	4e 4c 06	lsr $064c			lsr 	gxX0+1 						; divide X by 4
.b21b	6e 4b 06	ror $064b			ror 	gxX0
.b21e	4e 4b 06	lsr $064b			lsr 	gxX0
.b221	4e 4d 06	lsr $064d			lsr 	gxY0 						; divide Y by 4
.b224	4e 4d 06	lsr $064d			lsr 	gxY0
.b227	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b22a	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x
.b22d	29 80		and #$80			and 	#$80
.b22f	0d 4b 06	ora $064b			ora 	gxX0
.b232	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b235	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b238	29 c0		and #$c0			and 	#$C0
.b23a	0d 4d 06	ora $064d			ora 	gxY0
.b23d	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b240	18		clc				clc
.b241	60		rts				rts
.b242					_GXSIFail:
.b242	38		sec				sec
.b243	60		rts				rts
.b244					_GXMSOffset:
>b244	1c						.byte 	32-8/2
>b245	18						.byte 	32-16/2
>b246	14						.byte 	32-24/2
>b247	10						.byte 	32-32/2
.b248					GXOpenBitmap:
.b248	78		sei				sei 								; no interrupts here
.b249	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b24b	8d 5c 06	sta $065c			sta 	gxOriginalLUTValue
.b24e	58		cli				cli
.b24f	60		rts				rts
.b250					GXCloseBitmap:
.b250	78		sei				sei
.b251	ad 5c 06	lda $065c			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b254	85 0b		sta $0b				sta 	GXEditSlot
.b256	58		cli				cli
.b257	60		rts				rts
.b258					GXPositionCalc:
.b258	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b25a	48		pha				pha
.b25b	ad 4d 06	lda $064d			lda 	GXY0 						; gxzScreen = Y0
.b25e	85 3c		sta $3c				sta 	gxzScreen
.b260	64 3d		stz $3d				stz 	gxzScreen+1
.b262	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b264	26 3d		rol $3d				rol 	gxzScreen+1
.b266	06 3c		asl $3c				asl 	gxzScreen
.b268	26 3d		rol $3d				rol 	gxzScreen+1
.b26a	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b26b	65 3c		adc $3c				adc 	gxzScreen
.b26d	85 3c		sta $3c				sta 	gxzScreen
.b26f	90 02		bcc $b273			bcc 	_GXPCNoCarry
.b271	e6 3d		inc $3d				inc 	gxzScreen+1
.b273					_GXPCNoCarry:
.b273	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b275	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b277	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b279	85 36		sta $36				sta 	gxzTemp0
.b27b	64 3d		stz $3d				stz 	gxzScreen+1
.b27d	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b27f					_GXPCMultiply32:
.b27f	06 3c		asl $3c				asl 	gxzScreen
.b281	26 3d		rol $3d				rol 	gxzScreen+1
.b283	3a		dec a				dec 	a
.b284	d0 f9		bne $b27f			bne 	_GXPCMultiply32
.b286	18		clc				clc
.b287	ad 4b 06	lda $064b			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b28a	65 3c		adc $3c				adc 	gxzScreen
.b28c	8d 5d 06	sta $065d			sta 	gsOffset
.b28f	ad 4c 06	lda $064c			lda 	GXX0+1
.b292	65 3d		adc $3d				adc 	gxzScreen+1
.b294	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b296	90 04		bcc $b29c			bcc 	_GXPCNoOverflow
.b298	29 1f		and #$1f			and 	#$1F 						; fix it up
.b29a	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b29c					_GXPCNoOverflow:
.b29c	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b29e	85 3d		sta $3d				sta 	gxzScreen+1
.b2a0	64 3c		stz $3c				stz 	gxzScreen
.b2a2	18		clc				clc
.b2a3	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b2a5	6d 55 06	adc $0655			adc 	gxBasePage 					; by adding the base page
.b2a8	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b2aa	68		pla				pla
.b2ab	85 36		sta $36				sta 	gxzTemp0
.b2ad	60		rts				rts
.b2ae					GXMovePositionDown:
.b2ae	18		clc				clc 								; add 320 to offset/temp+1
.b2af	ad 5d 06	lda $065d			lda 	gsOffset
.b2b2	69 40		adc #$40			adc 	#64
.b2b4	8d 5d 06	sta $065d			sta 	gsOffset
.b2b7	a5 3d		lda $3d				lda 	gxzScreen+1
.b2b9	69 01		adc #$01			adc 	#1
.b2bb	85 3d		sta $3d				sta 	gxzScreen+1
.b2bd	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b2bf	90 07		bcc $b2c8			bcc 	_GXMPDExit
.b2c1	38		sec				sec  								; next page
.b2c2	e9 20		sbc #$20			sbc 	#$20
.b2c4	85 3d		sta $3d				sta 	gxzScreen+1
.b2c6	e6 0b		inc $0b				inc 	GXEditSlot
.b2c8					_GXMPDExit:
.b2c8	60		rts				rts
.b2c9					GXCollide:
.b2c9	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b2cb	aa		tax				tax
.b2cc	05 37		ora $37				ora 	gxzTemp0+1
.b2ce	29 c0		and #$c0			and 	#$C0
.b2d0	38		sec				sec
.b2d1	d0 53		bne $b326			bne 	_GXCollideFail 				; if either >= 64, fail.
.b2d3	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b2d5	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b2d8	1d 63 06	ora $0663,x			ora 	GXSpriteLow,x
.b2db	30 48		bmi $b325			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b2dd	18		clc				clc 								; need to calculate sum of sizes.
.b2de	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y
.b2e1	7d a3 06	adc $06a3,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b2e4	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b2e6	6a		ror a				ror 	a 							; 5/6/7
.b2e7	4a		lsr a				lsr 	a 							; 4/5/6
.b2e8	4a		lsr a				lsr 	a 							; 3/4/5
.b2e9	4a		lsr a				lsr 	a 							; 2/3/4
.b2ea	18		clc				clc
.b2eb	69 08		adc #$08			adc 	#$08
.b2ed	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b2ee	4a		lsr a				lsr 	a
.b2ef	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b2f1	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b2f4	29 3f		and #$3f			and 	#$3F
.b2f6	85 39		sta $39				sta 	gxzTemp1+1
.b2f8	38		sec				sec
.b2f9	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b2fc	29 3f		and #$3f			and 	#$3F
.b2fe	e5 39		sbc $39				sbc 	gxzTemp1+1
.b300	b0 03		bcs $b305			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b302	49 ff		eor #$ff			eor 	#$FF
.b304	1a		inc a				inc 	a
.b305					_GXCAbs1:
.b305	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b307	b0 1c		bcs $b325			bcs 	_GXOkayFail
.b309	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b30b	38		sec				sec 								; calculate |x1-x0|
.b30c	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y
.b30f	fd 63 06	sbc $0663,x			sbc 	GXSpriteLow,x
.b312	b0 03		bcs $b317			bcs 	_GXCAbs2
.b314	49 ff		eor #$ff			eor 	#$FF
.b316	1a		inc a				inc 	a
.b317					_GXCAbs2:
.b317	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b319	b0 0a		bcs $b325			bcs 	_GXOkayFail
.b31b	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b31d	90 02		bcc $b321			bcc 	_GXCHaveLowest
.b31f	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b321					_GXCHaveLowest:
.b321	0a		asl a				asl 	a 							; scale to allow for >> 2
.b322	0a		asl a				asl 	a
.b323	18		clc				clc
.b324	60		rts				rts
.b325					_GXOkayFail:
.b325	18		clc				clc
.b326					_GXCollideFail:
.b326	a9 ff		lda #$ff			lda 	#$FF
.b328	60		rts				rts
.b329					GXFindSprite:
.b329	aa		tax				tax
.b32a	ad 56 06	lda $0656			lda 	GXSpritePage 				; access the base page of the sprite
.b32d	85 0b		sta $0b				sta 	GXEditSlot
.b32f	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b332	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b335	f0 33		beq $b36a			beq 	_GXFSFail
.b337	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b33a	8d fa 06	sta $06fa			sta 	GXSpriteOffset+1
.b33d	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b340	48		pha				pha 								; save twice
.b341	48		pha				pha
.b342	29 03		and #$03			and 	#3 							; get sprite size
.b344	8d f7 06	sta $06f7			sta 	GXSizeBits 					; save raw (0-3)
.b347	aa		tax				tax
.b348	bd 6c b3	lda $b36c,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b34b	8d f6 06	sta $06f6			sta 	GXSizePixels 					; save (8/16/24/32)
.b34e	68		pla				pla 								; get LUT
.b34f	4a		lsr a				lsr		a
.b350	4a		lsr a				lsr		a
.b351	29 03		and #$03			and 	#3
.b353	8d f8 06	sta $06f8			sta 	GXSpriteLUT
.b356	68		pla				pla 								; address, neeeds to be x 4
.b357	29 f0		and #$f0			and 	#$F0
.b359	8d f9 06	sta $06f9			sta 	GXSpriteOffset
.b35c	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b35f	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b362	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b365	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b368	18		clc				clc
.b369	60		rts				rts
.b36a					_GXFSFail:
.b36a	38		sec				sec
.b36b	60		rts				rts
.b36c					_GXFXSSTTable:
>b36c	08 10 18 20					.byte 	8,16,24,32
.06f6					GXSizePixels:
>06f6							.fill 	1
.06f7					GXSizeBits:
>06f7							.fill 	1
.06f8					GXSpriteLUT:
>06f8							.fill 	1
.06f9					GXSpriteOffset:
>06f9							.fill 	2
.b370					GXSortXY:
.b370	20 8e b3	jsr $b38e			jsr 	GXSortY 					; will be sorted on Y now
.b373	ad 4b 06	lda $064b			lda 	gxX0 						; compare X0 v X1
.b376	cd 4f 06	cmp $064f			cmp 	gxX1
.b379	ad 4c 06	lda $064c			lda 	gXX0+1
.b37c	ed 50 06	sbc $0650			sbc 	gXX1+1
.b37f	90 0c		bcc $b38d			bcc 	_GXSXYExit 					; X0 < X1 exit
.b381	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b383	a0 04		ldy #$04			ldy 	#4
.b385	20 a2 b3	jsr $b3a2			jsr 	GXSwapXY
.b388	e8		inx				inx
.b389	c8		iny				iny
.b38a	20 a2 b3	jsr $b3a2			jsr 	GXSwapXY
.b38d					_GXSXYExit:
.b38d	60		rts				rts
.b38e					GXSortY:
.b38e	ad 4d 06	lda $064d			lda 	gxY0 						; if Y0 >= Y1
.b391	cd 51 06	cmp $0651			cmp 	gxY1
.b394	90 0b		bcc $b3a1			bcc 	_GXSYSorted
.b396	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b398	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b39a					_GXSwap1:
.b39a	20 a2 b3	jsr $b3a2			jsr 	GXSwapXY
.b39d	88		dey				dey
.b39e	ca		dex				dex
.b39f	10 f9		bpl $b39a			bpl 	_GXSwap1
.b3a1					_GXSYSorted:
.b3a1	60		rts				rts
.b3a2					GXSwapXY:
.b3a2	bd 4b 06	lda $064b,x			lda 	gxX0,x
.b3a5	48		pha				pha
.b3a6	b9 4b 06	lda $064b,y			lda 	gxX0,y
.b3a9	9d 4b 06	sta $064b,x			sta 	gxX0,x
.b3ac	68		pla				pla
.b3ad	99 4b 06	sta $064b,y			sta 	gxX0,y
.b3b0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b9c2					KeywordSet0:
>b9c2	00 65					.text	0,$65,""               ; $80 !0:EOF
>b9c4	00 58					.text	0,$58,""               ; $81 !1:SH1
>b9c6	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b9c8	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b9ce	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b9d6	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b9dc	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b9e3	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>b9eb	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>b9f2	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>b9f9	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>b9ff	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>ba05	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>ba0d	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>ba14	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>ba1b	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>ba22	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>ba2a	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>ba30	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>ba36	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>ba3d	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>ba43	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>ba49	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>ba51	47 28
>ba53	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>ba5b	28
>ba5c	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>ba64	28
>ba65	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>ba6b	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>ba71	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>ba77	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>ba7e	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>ba86	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>ba8c	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>ba92	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>ba97	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>ba9b	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>baa1	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>baa9	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bab0	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bab7	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>babf	43
>bac0	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bac6	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bacc	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bad3	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bad9	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>badd	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bae3	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>baeb	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>baf2	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>baf7	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bafe	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bb06	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bb0c	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bb11	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bb19	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bb1f	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bb25	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bb2a	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bb31	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bb37	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bb3d	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bb44	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bc LET
>bb49	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $bd LINE
>bb4f	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $be LOCAL
>bb56	03 db 4f 46 46				.text	3,$db,"OFF"            ; $bf OFF
>bb5b	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c0 ON
>bb5f	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c1 OUTLINE
>bb67	45
>bb68	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c2 PALETTE
>bb70	45
>bb71	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c3 PLOT
>bb77	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c4 PRINT
>bb7e	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c5 READ
>bb84	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c6 RECT
>bb8a	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c7 REM
>bb8f	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c8 RETURN
>bb97	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $c9 SOLID
>bb9e	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $ca SOUND
>bba5	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cb SPRITE
>bbad	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cc TEXT
>bbb3	02 a3 54 4f				.text	2,$a3,"TO"             ; $cd TO
>bbb7	ff					.text	$FF
.bbb8					KeywordSet1:
>bbb8	00 65					.text	0,$65,""               ; $80 !0:EOF
>bbba	00 58					.text	0,$58,""               ; $81 !1:SH1
>bbbc	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bbbe	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bbc6	4c 45
>bbc8	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bbd0	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bbd8	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bbdd	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $87 LIST
>bbe3	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $88 NEW
>bbe8	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $89 RESTORE
>bbf0	45
>bbf1	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8a RUN
>bbf6	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8b SPRITES
>bbfe	53
>bbff	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8c STOP
>bc05	ff					.text	$FF
.bc06					KeywordSet2:
>bc06	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc08	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc0a	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc0c	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bc11	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bc16	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bc1b	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bc20	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bc25	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bc2a	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bc2f	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bc34	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bc39	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bc3e	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bc43	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bc48	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bc4d	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bc52	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bc57	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bc5c	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bc61	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bc66	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bc6b	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bc70	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bc75	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bc7a	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bc7f	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bc84	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bc89	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bc8e	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bc93	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bc98	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bc9d	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bca2	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bca7	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bcac	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bcb1	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bcb6	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bcbb	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bcc0	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bcc5	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bcca	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bccf	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bcd4	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bcd9	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bcde	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bce3	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bce8	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bced	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bcf2	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bcf7	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bcfc	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bd01	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bd06	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bd0b	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bd10	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bd15	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bd1a	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bd1f	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bd24	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bd29	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bd2e	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bd33	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bd38	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bd3d	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bd42	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bd47	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bd4c	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bd51	ff					.text	$FF
.b3b1					ListConvertLine:
.b3b1	48		pha				pha 								; save indent on the stack
.b3b2	9c 9d 04	stz $049d			stz 	tbOffset
.b3b5	9c ab 04	stz $04ab			stz 	tokenBuffer
.b3b8	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b3ba	b1 30		lda ($30),y			lda 	(codePtr),y
.b3bc	aa		tax				tax
.b3bd	88		dey				dey
.b3be	b1 30		lda ($30),y			lda 	(codePtr),y
.b3c0	20 7b 92	jsr $927b			jsr 	LCLConvertInt16
.b3c3	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b3c5	86 37		stx $37				stx 	zTemp0+1
.b3c7	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b3c9	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b3cc	a0 00		ldy #$00			ldy 	#0
.b3ce					_LCCopyNumber:
.b3ce	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3d0	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b3d3	c8		iny				iny
.b3d4	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3d6	d0 f6		bne $b3ce			bne 	_LCCopyNumber
.b3d8	68		pla				pla 								; adjustment to indent
.b3d9	48		pha				pha 								; save on stack
.b3da	10 0c		bpl $b3e8			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b3dc	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b3dd	6d a6 04	adc $04a6			adc 	listIndent
.b3e0	8d a6 04	sta $04a6			sta 	listIndent
.b3e3	10 03		bpl $b3e8			bpl 	_LCNoAdjust
.b3e5	9c a6 04	stz $04a6			stz 	listIndent
.b3e8					_LCNoAdjust:
.b3e8	18		clc				clc		 							; work out actual indent.
.b3e9	ad a6 04	lda $04a6			lda 	listIndent
.b3ec	0a		asl a				asl 	a
.b3ed	69 06		adc #$06			adc 	#6
.b3ef	85 36		sta $36				sta 	zTemp0
.b3f1					_LCPadOut:
.b3f1	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b3f3	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b3f6	ad 9d 04	lda $049d			lda 	tbOffset
.b3f9	c5 36		cmp $36				cmp 	zTemp0
.b3fb	d0 f4		bne $b3f1			bne 	_LCPadOut
.b3fd	a0 03		ldy #$03			ldy 	#3 							; start position.
.b3ff					_LCMainLoop:
.b3ff	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b401	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b404	b1 30		lda ($30),y			lda 	(codePtr),y
.b406	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b408	f0 17		beq $b421			beq 	_LCExit
.b40a	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b40c	90 1e		bcc $b42c			bcc 	_LCDoubles
.b40e	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b410	90 2a		bcc $b43c			bcc 	_LCShiftPunc
.b412	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b414	90 35		bcc $b44b			bcc 	_LCPunctuation
.b416	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b418	90 3e		bcc $b458			bcc 	_LCIdentifiers
.b41a	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b41c	90 5f		bcc $b47d			bcc 	_LCTokens
.b41e	4c dd b4	jmp $b4dd			jmp 	_LCData 					; 254-5 are data objects
.b421					_LCExit:
.b421	68		pla				pla 								; get old indent adjust
.b422	30 07		bmi $b42b			bmi 	_LCExit2
.b424	18		clc				clc 								; add to indent if +ve
.b425	6d a6 04	adc $04a6			adc 	listIndent
.b428	8d a6 04	sta $04a6			sta 	listIndent
.b42b					_LCExit2:
.b42b	60		rts				rts
.b42c					_LCDoubles:
.b42c	48		pha				pha
.b42d	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b42e	29 02		and #$02			and 	#2
.b430	09 3c		ora #$3c			ora 	#60 						; make < >
.b432	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b435	68		pla				pla 								; restore, do lower bit
.b436	29 03		and #$03			and 	#3
.b438	09 3c		ora #$3c			ora 	#60
.b43a	80 0f		bra $b44b			bra		_LCPunctuation 				; print, increment, loop
.b43c					_LCShiftPunc:
.b43c	aa		tax				tax 								; save in X
.b43d	29 07		and #$07			and 	#7 							; lower 3 bits
.b43f	f0 02		beq $b443			beq 	_LCNoAdd
.b441	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b443					_LCNoAdd:
.b443	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b445	90 02		bcc $b449			bcc 	_LCNoAdd2
.b447	09 20		ora #$20			ora 	#32 						; adds $20
.b449					_LCNoAdd2:
.b449	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b44b					_LCPunctuation:
.b44b	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b44d	d0 03		bne $b452			bne 	_LCPContinue
.b44f	20 24 b5	jsr $b524			jsr 	LCLDeleteLastSpace
.b452					_LCPContinue:
.b452	c8		iny				iny 								; consume character
.b453	20 0e b5	jsr $b50e			jsr 	LCLWrite 					; write it out.
.b456	80 a7		bra $b3ff			bra 	_LCMainLoop 				; go round again.
.b458					_LCIdentifiers:
.b458	18		clc				clc 								; convert to physical address
.b459	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b45b	85 37		sta $37				sta 	zTemp0+1
.b45d	c8		iny				iny
.b45e	b1 30		lda ($30),y			lda 	(codePtr),y
.b460	85 36		sta $36				sta 	zTemp0
.b462	c8		iny				iny
.b463	5a		phy				phy 								; save position
.b464	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b466	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b469	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b46b					_LCOutIdentifier:
.b46b	c8		iny				iny
.b46c	b1 36		lda ($36),y			lda 	(zTemp0),y
.b46e	29 7f		and #$7f			and 	#$7F
.b470	20 60 b5	jsr $b560			jsr 	LCLLowerCase
.b473	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b476	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b478	10 f1		bpl $b46b			bpl 	_LCOutIdentifier
.b47a	7a		ply				ply 								; restore position
.b47b	80 82		bra $b3ff			bra 	_LCMainLoop
.b47d					_LCTokens:
.b47d	aa		tax				tax 								; token in X
.b47e	a9 06		lda #$06			lda 	#((KeywordSet2) & $FF)
.b480	85 36		sta $36				sta 	0+zTemp0
.b482	a9 bc		lda #$bc			lda 	#((KeywordSet2) >> 8)
.b484	85 37		sta $37				sta 	1+zTemp0
.b486	e0 82		cpx #$82			cpx 	#$82
.b488	f0 16		beq $b4a0			beq 	_LCUseShift
.b48a	a9 b8		lda #$b8			lda 	#((KeywordSet1) & $FF)
.b48c	85 36		sta $36				sta 	0+zTemp0
.b48e	a9 bb		lda #$bb			lda 	#((KeywordSet1) >> 8)
.b490	85 37		sta $37				sta 	1+zTemp0
.b492	e0 81		cpx #$81			cpx 	#$81
.b494	f0 0a		beq $b4a0			beq 	_LCUseShift
.b496	a9 c2		lda #$c2			lda 	#((KeywordSet0) & $FF)
.b498	85 36		sta $36				sta 	0+zTemp0
.b49a	a9 b9		lda #$b9			lda 	#((KeywordSet0) >> 8)
.b49c	85 37		sta $37				sta 	1+zTemp0
.b49e	80 01		bra $b4a1			bra 	_LCNoShift
.b4a0					_LCUseShift:
.b4a0	c8		iny				iny
.b4a1					_LCNoShift:
.b4a1	20 38 b5	jsr $b538			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b4a4	b1 30		lda ($30),y			lda 	(codePtr),y
.b4a6	aa		tax				tax 								; into X
.b4a7					_LCFindText:
.b4a7	ca		dex				dex
.b4a8	10 0e		bpl $b4b8			bpl 	_LCFoundText 				; found text.
.b4aa	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b4ac	1a		inc a				inc 	a 							; one extra for size
.b4ad	38		sec				sec 								; one extra for checksum
.b4ae	65 36		adc $36				adc 	zTemp0 						; go to next token
.b4b0	85 36		sta $36				sta 	zTemp0
.b4b2	90 f3		bcc $b4a7			bcc 	_LCFindText
.b4b4	e6 37		inc $37				inc 	zTemp0+1
.b4b6	80 ef		bra $b4a7			bra 	_LCFindText
.b4b8					_LCFoundText:
.b4b8	5a		phy				phy 								; save List position
.b4b9	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b4bb	aa		tax				tax
.b4bc	a9 83		lda #$83			lda 	#CLIToken+$80
.b4be	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b4c1	a0 02		ldy #$02			ldy 	#2
.b4c3					_LCCopyToken:
.b4c3	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4c5	20 60 b5	jsr $b560			jsr 	LCLLowerCase
.b4c8	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b4cb	c8		iny				iny
.b4cc	ca		dex				dex
.b4cd	d0 f4		bne $b4c3			bne 	_LCCopyToken
.b4cf	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b4d1	f0 05		beq $b4d8			beq 	_LCNoSpace
.b4d3	a9 20		lda #$20			lda 	#' '
.b4d5	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b4d8					_LCNoSpace:
.b4d8	7a		ply				ply 								; restore position.
.b4d9	c8		iny				iny 								; consume token
.b4da	4c ff b3	jmp $b3ff			jmp 	_LCMainLoop 				; and go around again.
.b4dd					_LCData:
.b4dd	48		pha				pha 								; save type $FE/$FF
.b4de	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b4e0	c9 fe		cmp #$fe			cmp 	#$FE
.b4e2	f0 07		beq $b4eb			beq 	_LCHaveOpener
.b4e4	a2 22		ldx #$22			ldx 	#'"'
.b4e6	a9 81		lda #$81			lda 	#CLIData+$80
.b4e8	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b4eb					_LCHaveOpener:
.b4eb	8a		txa				txa 								; output prefix (# or ")
.b4ec	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b4ef	c8		iny				iny 								; get count
.b4f0	b1 30		lda ($30),y			lda 	(codePtr),y
.b4f2	aa		tax				tax
.b4f3	c8		iny				iny 								; point at first character
.b4f4					_LCOutData:
.b4f4	b1 30		lda ($30),y			lda 	(codePtr),y
.b4f6	c9 00		cmp #$00			cmp 	#0
.b4f8	f0 03		beq $b4fd			beq 	_LCNoPrint
.b4fa	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b4fd					_LCNoPrint:
.b4fd	c8		iny				iny
.b4fe	ca		dex				dex
.b4ff	d0 f3		bne $b4f4			bne 	_LCOutData
.b501	68		pla				pla 								; closing " required ?
.b502	c9 ff		cmp #$ff			cmp 	#$FF
.b504	d0 05		bne $b50b			bne 	_LCNoQuote
.b506	a9 22		lda #$22			lda 	#'"'
.b508	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b50b					_LCNoQuote:
.b50b	4c ff b3	jmp $b3ff			jmp 	_LCMainLoop
.b50e					LCLWrite:
.b50e	da		phx				phx
.b50f	ae 9d 04	ldx $049d			ldx 	tbOffset
.b512	9d ab 04	sta $04ab,x			sta 	tokenBuffer,x
.b515	9e ac 04	stz $04ac,x			stz 	tokenBuffer+1,x
.b518	ee 9d 04	inc $049d			inc 	tbOffset
.b51b	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b51d	30 03		bmi $b522			bmi 	_LCLNoColour
.b51f	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b522					_LCLNoColour:
.b522	fa		plx				plx
.b523	60		rts				rts
.b524					LCLDeleteLastSpace:
.b524	48		pha				pha
.b525	da		phx				phx
.b526	ae 9d 04	ldx $049d			ldx 	tbOffset
.b529	f0 0a		beq $b535			beq 	_LCDLSExit
.b52b	bd aa 04	lda $04aa,x			lda 	tokenBuffer-1,x
.b52e	c9 20		cmp #$20			cmp 	#' '
.b530	d0 03		bne $b535			bne 	_LCDLSExit
.b532	ce 9d 04	dec $049d			dec 	tbOffset
.b535					_LCDLSExit:
.b535	fa		plx				plx
.b536	68		pla				pla
.b537	60		rts				rts
.b538					LCLCheckSpaceRequired:
.b538	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b53b	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b53d	f0 1b		beq $b55a			beq 	_LCCSRSpace
.b53f	c9 29		cmp #$29			cmp 	#')'
.b541	f0 17		beq $b55a			beq 	_LCCSRSpace
.b543	c9 23		cmp #$23			cmp 	#'#'
.b545	f0 13		beq $b55a			beq 	_LCCSRSpace
.b547	20 60 b5	jsr $b560			jsr 	LCLLowerCase 				; saves a little effort
.b54a	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b54c	90 11		bcc $b55f			bcc 	_LCCSRExit
.b54e	c9 3a		cmp #$3a			cmp 	#"9"+1
.b550	90 08		bcc $b55a			bcc 	_LCCSRSpace
.b552	c9 61		cmp #$61			cmp 	#"a"
.b554	90 09		bcc $b55f			bcc 	_LCCSRExit
.b556	c9 7b		cmp #$7b			cmp 	#"z"+1
.b558	b0 05		bcs $b55f			bcs 	_LCCSRExit
.b55a					_LCCSRSpace:
.b55a	a9 20		lda #$20			lda 	#' '
.b55c	20 0e b5	jsr $b50e			jsr 	LCLWrite
.b55f					_LCCSRExit:
.b55f	60		rts				rts
.b560					LCLLowerCase:
.b560	c9 41		cmp #$41			cmp 	#"A"
.b562	90 06		bcc $b56a			bcc 	_LCLLCOut
.b564	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b566	b0 02		bcs $b56a			bcs 	_LCLLCOut
.b568	69 20		adc #$20			adc 	#$20
.b56a					_LCLLCOut:
.b56a	60		rts				rts
.b56b					LCLUpperCase:
.b56b	c9 61		cmp #$61			cmp 	#"a"
.b56d	90 06		bcc $b575			bcc 	_LCLUCOut
.b56f	c9 7b		cmp #$7b			cmp 	#"z"+1
.b571	b0 02		bcs $b575			bcs 	_LCLUCOut
.b573	e9 1f		sbc #$1f			sbc 	#$1F
.b575					_LCLUCOut:
.b575	60		rts				rts
.b576					TOKSearchTable:
.b576	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token.
.b578	85 36		sta $36				sta 	zTemp0
.b57a	a0 00		ldy #$00			ldy 	#0
.b57c	a9 80		lda #$80			lda 	#$80 						; token #
.b57e	85 38		sta $38				sta 	zTemp1
.b580					_TSTLoop:
.b580	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b582	30 49		bmi $b5cd			bmi 	_TSTFail 					; -ve = end of table
.b584	f0 2e		beq $b5b4			beq 	_TSTNext 					; zero, check next it's a dummy
.b586	c8		iny				iny 								; get the hash
.b587	b1 36		lda ($36),y			lda 	(zTemp0),y
.b589	88		dey				dey
.b58a	cd 83 04	cmp $0483			cmp 	identHash 					; check they match, if not go to next
.b58d	d0 25		bne $b5b4			bne 	_TSTNext
.b58f	ad 82 04	lda $0482			lda 	identTypeEnd 				; length of identifier
.b592	38		sec				sec
.b593	ed 80 04	sbc $0480			sbc 	identStart
.b596	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; no match, then return.
.b598	d0 1a		bne $b5b4			bne 	_TSTNext
.b59a	5a		phy				phy 								; save Y , we might fail
.b59b	c8		iny				iny 								; point to text
.b59c	c8		iny				iny
.b59d	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b5a0					_TSTCompareName:
.b5a0	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; compare text.
.b5a3	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b5a5	d0 0c		bne $b5b3			bne 	_TSTNextPullY 				; fail, pullY and do next
.b5a7	e8		inx				inx
.b5a8	c8		iny				iny
.b5a9	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b5ac	d0 f2		bne $b5a0			bne 	_TSTCompareName
.b5ae	7a		ply				ply 								; throw Y
.b5af	a5 38		lda $38				lda 	zTemp1 						; get token #
.b5b1	38		sec				sec 								; return with CS = passed.
.b5b2	60		rts				rts
.b5b3					_TSTNextPullY:
.b5b3	7a		ply				ply 								; restore current, fall through.
.b5b4					_TSTNext:
.b5b4	e6 38		inc $38				inc 	zTemp1 						; token counter
.b5b6	98		tya				tya
.b5b7	18		clc				clc
.b5b8	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b5ba	1a		inc a				inc 	a 							; +1
.b5bb	1a		inc a				inc 	a 							; +2
.b5bc	a8		tay				tay
.b5bd	10 c1		bpl $b580			bpl 	_TSTLoop 					; if Y < $80 loop back
.b5bf	98		tya				tya 								; add Y to zTemp0 and reset Y
.b5c0	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b5c2	18		clc				clc  								; but have tables > 255 bytes
.b5c3	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b5c5	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b5c7	90 b7		bcc $b580			bcc 	_TSTLoop
.b5c9	e6 37		inc $37				inc 	zTemp0+1
.b5cb	80 b3		bra $b580			bra 	_TSTLoop
.b5cd					_TSTFail:
.b5cd	18		clc				clc
.b5ce	60		rts				rts
.b5cf					TokeniseLine:
.b5cf	20 57 b7	jsr $b757			jsr 	LCLFixLineBufferCase 		; fix line case
.b5d2	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b5d4	8d a8 04	sta $04a8			sta 	tokenOffset
.b5d7	9c a9 04	stz $04a9			stz 	tokenLineNumber
.b5da	9c aa 04	stz $04aa			stz 	tokenLineNumber+1
.b5dd	a2 ff		ldx #$ff			ldx 	#$FF
.b5df					_TKFindFirst:
.b5df	e8		inx				inx
.b5e0	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b5e3	f0 79		beq $b65e			beq 	_TKExit
.b5e5	c9 20		cmp #$20			cmp 	#' '
.b5e7	90 f6		bcc $b5df			bcc 	_TKFindFirst
.b5e9	c9 30		cmp #$30			cmp 	#'0'
.b5eb	90 07		bcc $b5f4			bcc 	_TKNoLineNumber
.b5ed	c9 3a		cmp #$3a			cmp 	#'9'+1
.b5ef	b0 03		bcs $b5f4			bcs 	_TKNoLineNumber
.b5f1	20 81 b7	jsr $b781			jsr 	TOKExtractLineNumber
.b5f4					_TKNoLineNumber:
.b5f4					_TKTokeniseLoop:
.b5f4	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b5f7	f0 65		beq $b65e			beq 	_TKExit
.b5f9	e8		inx				inx
.b5fa	c9 20		cmp #$20			cmp 	#' '
.b5fc	f0 f6		beq $b5f4			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b5fe	ca		dex				dex 								; undo last get, A contains character, X is position.
.b5ff	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b601	f0 61		beq $b664			beq 	_TKTokeniseIdentifier
.b603	c9 41		cmp #$41			cmp 	#'A'
.b605	90 04		bcc $b60b			bcc 	_TKTokenisePunctuation
.b607	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b609	90 59		bcc $b664			bcc 	_TKTokeniseIdentifier
.b60b					_TKTokenisePunctuation:
.b60b	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b60d	f0 27		beq $b636			beq 	_TKString
.b60f	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant (# only appears at end of identifiers)
.b611	f0 28		beq $b63b			beq 	_TKHexConstant
.b613	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers.
.b615	f0 29		beq $b640			beq 	_TKCheckDouble
.b617	c9 3e		cmp #$3e			cmp 	#'>'
.b619	f0 25		beq $b640			beq 	_TKCheckDouble
.b61b					_TKStandardPunctuation:
.b61b	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get it back.
.b61e	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b620	90 0e		bcc $b630			bcc 	_TKNoShift
.b622	48		pha				pha 								; save
.b623	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b625	85 36		sta $36				sta 	zTemp0
.b627	68		pla				pla
.b628	29 20		and #$20			and 	#32 						; bit 5
.b62a	4a		lsr a				lsr 	a 							; shift into bit 3
.b62b	4a		lsr a				lsr 	a
.b62c	05 36		ora $36				ora 	zTemp0
.b62e	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b630					_TKNoShift:
.b630	20 c6 b7	jsr $b7c6			jsr 	TOKWriteByte 				; write the punctuation character
.b633	e8		inx				inx 								; consume the character
.b634	80 be		bra $b5f4			bra 	_TKTokeniseLoop 			; and loop round again.
.b636					_TKString:
.b636	20 e6 b6	jsr $b6e6			jsr 	TOKTokenString
.b639	80 b9		bra $b5f4			bra 	_TKTokeniseLoop
.b63b					_TKHexConstant:
.b63b	20 21 b7	jsr $b721			jsr 	TOKHexConstant
.b63e	80 b4		bra $b5f4			bra 	_TKTokeniseLoop
.b640					_TKCheckDouble:
.b640	bd a9 05	lda $05a9,x			lda 	lineBuffer+1,x 				; get next character
.b643	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b645	90 d4		bcc $b61b			bcc 	_TKStandardPunctuation
.b647	c9 3f		cmp #$3f			cmp 	#'>'+1
.b649	b0 d0		bcs $b61b			bcs 	_TKStandardPunctuation
.b64b	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b64e	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b650	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b651	7d a9 05	adc $05a9,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b654	38		sec				sec
.b655	e9 3c		sbc #$3c			sbc 	#'<'
.b657	20 c6 b7	jsr $b7c6			jsr 	TOKWriteByte 				; this is in the range 0-7
.b65a	e8		inx				inx 								; consume both
.b65b	e8		inx				inx
.b65c	80 96		bra $b5f4			bra 	_TKTokeniseLoop
.b65e	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b660	20 c6 b7	jsr $b7c6			jsr 	TOKWriteByte
.b663	60		rts				rts
.b664					_TKTokeniseIdentifier:
.b664	8e 80 04	stx $0480			stx 	identStart 					; save start
.b667	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b66a					_TKCheckLoop:
.b66a	e8		inx				inx 								; look at next, we know first is identifier.
.b66b	bd a8 05	lda $05a8,x			lda  	lineBuffer,x
.b66e	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b670	f0 f8		beq $b66a			beq 	_TKCheckLoop
.b672	c9 30		cmp #$30			cmp	 	#"0"
.b674	90 0c		bcc $b682			bcc 	_TKEndIdentifier
.b676	c9 3a		cmp #$3a			cmp 	#"9"+1
.b678	90 f0		bcc $b66a			bcc 	_TKCheckLoop
.b67a	c9 41		cmp #$41			cmp	 	#"A"
.b67c	90 04		bcc $b682			bcc 	_TKEndIdentifier
.b67e	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b680	90 e8		bcc $b66a			bcc 	_TKCheckLoop
.b682					_TKEndIdentifier:
.b682	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b685	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b687	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b689	f0 06		beq $b691			beq 	_TKHasTypeCharacter
.b68b	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b68d	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b68f	d0 07		bne $b698			bne 	_TKNoTypeCharacter
.b691					_TKHasTypeCharacter:
.b691	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b694	e8		inx				inx 								; read next
.b695	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b698					_TKNoTypeCharacter:
.b698	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b69a	d0 09		bne $b6a5			bne 	_TKNoArray
.b69c	e8		inx				inx 								; skip the (
.b69d	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array)
.b6a0	09 04		ora #$04			ora 	#$04
.b6a2	8d 84 04	sta $0484			sta 	identTypeByte
.b6a5					_TKNoArray:
.b6a5	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b6a8	20 42 b7	jsr $b742			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b6ab	a0 b9		ldy #$b9			ldy 	#(KeywordSet0) >> 8
.b6ad	a9 c2		lda #$c2			lda 	#(KeywordSet0) & $FF
.b6af	20 76 b5	jsr $b576			jsr 	TOKSearchTable
.b6b2	a2 00		ldx #$00			ldx 	#0
.b6b4	b0 1f		bcs $b6d5			bcs 	_TKFoundToken
.b6b6	a0 bb		ldy #$bb			ldy 	#(KeywordSet1) >> 8
.b6b8	a9 b8		lda #$b8			lda 	#(KeywordSet1) & $FF
.b6ba	20 76 b5	jsr $b576			jsr 	TOKSearchTable
.b6bd	a2 81		ldx #$81			ldx 	#$81
.b6bf	b0 14		bcs $b6d5			bcs 	_TKFoundToken
.b6c1	a0 bc		ldy #$bc			ldy 	#(KeywordSet2) >> 8
.b6c3	a9 06		lda #$06			lda 	#(KeywordSet2) & $FF
.b6c5	20 76 b5	jsr $b576			jsr 	TOKSearchTable
.b6c8	a2 82		ldx #$82			ldx 	#$82
.b6ca	b0 09		bcs $b6d5			bcs 	_TKFoundToken
.b6cc	20 d2 b7	jsr $b7d2			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b6cf	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6d2	4c f4 b5	jmp $b5f4			jmp 	_TKTokeniseLoop 			; and go round again.
.b6d5					_TKFoundToken:
.b6d5	48		pha				pha 								; save token
.b6d6	8a		txa				txa 								; shift in X, is there one ?
.b6d7	f0 03		beq $b6dc			beq 	_TKNoTShift
.b6d9	20 c6 b7	jsr $b7c6			jsr 	TOKWriteByte 				; if so, write it out
.b6dc					_TKNoTShift:
.b6dc	68		pla				pla 								; restore and write token
.b6dd	20 c6 b7	jsr $b7c6			jsr 	TOKWriteByte
.b6e0	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6e3	4c f4 b5	jmp $b5f4			jmp 	_TKTokeniseLoop 			; and go round again.
.b6e6					TOKTokenString:
.b6e6	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b6e8	20 c6 b7	jsr $b7c6			jsr 	TOKWriteByte
.b6eb	e8		inx				inx									; start of quoted string.
.b6ec	da		phx				phx 								; push start of string on top
.b6ed	ca		dex				dex
.b6ee					_TSFindEnd:
.b6ee	e8		inx				inx
.b6ef	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character
.b6f2	f0 04		beq $b6f8			beq 	_TSEndOfString
.b6f4	c9 22		cmp #$22			cmp 	#'"'
.b6f6	d0 f6		bne $b6ee			bne 	_TSFindEnd
.b6f8					_TSEndOfString:
.b6f8	7a		ply				ply  								; so now Y is first character, X is character after end.
.b6f9	48		pha				pha 								; save terminating character
.b6fa	20 02 b7	jsr $b702			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b6fd	68		pla				pla 								; terminating character
.b6fe	f0 01		beq $b701			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b700	e8		inx				inx
.b701					_TSNotQuote:
.b701	60		rts				rts
.b702					TOKWriteBlockXY:
.b702	86 36		stx $36				stx 	zTemp0 						; write end character
.b704	98		tya				tya
.b705	49 ff		eor #$ff			eor 	#$FF
.b707	38		sec				sec
.b708	65 36		adc $36				adc 	zTemp0
.b70a	1a		inc a				inc 	a 							; one extra for NULL
.b70b	20 c6 b7	jsr $b7c6			jsr 	TOKWriteByte
.b70e					_TOBlockLoop:
.b70e	c4 36		cpy $36				cpy 	zTemp0
.b710	f0 09		beq $b71b			beq 	_TOBlockExit
.b712	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.b715	20 c6 b7	jsr $b7c6			jsr 	TOKWriteByte
.b718	c8		iny				iny
.b719	80 f3		bra $b70e			bra 	_TOBlockLoop
.b71b					_TOBlockExit:
.b71b	a9 00		lda #$00			lda 	#0
.b71d	20 c6 b7	jsr $b7c6			jsr 	TOKWriteByte
.b720	60		rts				rts
.b721					TOKHexConstant:
.b721	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b723	20 c6 b7	jsr $b7c6			jsr 	TOKWriteByte
.b726	e8		inx				inx									; start of quoted string.
.b727	da		phx				phx 								; push start of constant on top
.b728	ca		dex				dex
.b729					_THFindLoop:
.b729	e8		inx				inx
.b72a	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b72d	c9 30		cmp #$30			cmp 	#"0"
.b72f	90 0c		bcc $b73d			bcc 	_THFoundEnd
.b731	c9 3a		cmp #$3a			cmp 	#"9"+1
.b733	90 f4		bcc $b729			bcc 	_THFindLoop
.b735	c9 41		cmp #$41			cmp 	#"A"
.b737	90 04		bcc $b73d			bcc 	_THFoundEnd
.b739	c9 47		cmp #$47			cmp 	#"F"+1
.b73b	90 ec		bcc $b729			bcc 	_THFindLoop
.b73d					_THFoundEnd:
.b73d	7a		ply				ply 								; restore start
.b73e	20 02 b7	jsr $b702			jsr 	TOKWriteBlockXY 			; output the block
.b741	60		rts				rts
.b742					TOKCalculateHash:
.b742	da		phx				phx
.b743	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum
.b746	a9 00		lda #$00			lda 	#0
.b748					_TCHLoop:
.b748	18		clc				clc
.b749	7d a8 05	adc $05a8,x			adc 	lineBuffer,x
.b74c	e8		inx				inx
.b74d	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b750	d0 f6		bne $b748			bne 	_TCHLoop
.b752	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b755	fa		plx				plx
.b756	60		rts				rts
.b757					LCLFixLineBufferCase:
.b757	a2 00		ldx #$00			ldx 	#0
.b759					_FLBCLoop:
.b759	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next character
.b75c	f0 22		beq $b780			beq 	_FLBCExit 					; end of string.
.b75e	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b760	f0 11		beq $b773			beq 	_FLBCInQuotes
.b762	e8		inx				inx
.b763	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b765	90 f2		bcc $b759			bcc 	_FLBCLoop
.b767	c9 7b		cmp #$7b			cmp 	#'z'+1
.b769	b0 ee		bcs $b759			bcs 	_FLBCLoop
.b76b	38		sec				sec 								; make U/C
.b76c	e9 20		sbc #$20			sbc 	#32
.b76e	9d a7 05	sta $05a7,x			sta	 	lineBuffer-1,x 				; write back
.b771	80 e6		bra $b759			bra 	_FLBCLoop
.b773					_FLBCInQuotes:
.b773	e8		inx				inx 								; advance
.b774	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next
.b777	f0 07		beq $b780			beq 	_FLBCExit 					; exit on EOS
.b779	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b77b	d0 f6		bne $b773			bne 	_FLBCInQuotes
.b77d	e8		inx				inx 								; skip over it
.b77e	80 d9		bra $b759			bra 	_FLBCLoop
.b780					_FLBCExit:
.b780	60		rts				rts
.b781					TOKExtractLineNumber:
.b781	ad aa 04	lda $04aa			lda 	tokenLineNumber+1 			; push current value on stack
.b784	48		pha				pha
.b785	ad a9 04	lda $04a9			lda 	tokenLineNumber
.b788	48		pha				pha
.b789	20 bf b7	jsr $b7bf			jsr 	_LCLNTimes2 				; line # x 4
.b78c	20 bf b7	jsr $b7bf			jsr 	_LCLNTimes2 				; line # x 2
.b78f	18		clc				clc 								; add stacked value
.b790	68		pla				pla
.b791	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b794	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b797	68		pla				pla
.b798	6d aa 04	adc $04aa			adc 	tokenLineNumber+1
.b79b	8d aa 04	sta $04aa			sta 	tokenLineNumber+1 			; line # x 5
.b79e	20 bf b7	jsr $b7bf			jsr 	_LCLNTimes2 				; line # x 10
.b7a1	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get and consume character
.b7a4	e8		inx				inx
.b7a5	29 0f		and #$0f			and 	#15 						; add to line #
.b7a7	18		clc				clc
.b7a8	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b7ab	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b7ae	90 03		bcc $b7b3			bcc 	_TLENNoCarry
.b7b0	ee aa 04	inc $04aa			inc 	tokenLineNumber+1
.b7b3					_TLENNoCarry:
.b7b3	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; more digits ?
.b7b6	c9 30		cmp #$30			cmp 	#'0'
.b7b8	90 04		bcc $b7be			bcc 	_TLENExit
.b7ba	c9 3a		cmp #$3a			cmp 	#'9'+1
.b7bc	90 c3		bcc $b781			bcc 	TOKExtractLineNumber
.b7be					_TLENExit:
.b7be	60		rts				rts
.b7bf					_LCLNTimes2:
.b7bf	0e a9 04	asl $04a9			asl 	tokenLineNumber
.b7c2	2e aa 04	rol $04aa			rol 	tokenLineNumber+1
.b7c5	60		rts				rts
.b7c6					TOKWriteByte:
.b7c6	da		phx				phx
.b7c7	ae a8 04	ldx $04a8			ldx 	tokenOffset 				; next slot to write to
.b7ca	9d a8 04	sta $04a8,x			sta 	tokenOffset,x 				; write byte out
.b7cd	ee a8 04	inc $04a8			inc 	tokenOffset 				; advance slot.
.b7d0	fa		plx				plx
.b7d1	60		rts				rts
.b7d2					TOKCheckCreateVariableRecord:
.b7d2	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b7d4	85 36		sta $36				sta 	0+zTemp0
.b7d6	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b7d8	85 37		sta $37				sta 	1+zTemp0
.b7da					_CCVSearch:
.b7da	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b7dc	f0 2c		beq $b80a			beq 	_CCVFail
.b7de	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b7e0	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b7e2	cd 83 04	cmp $0483			cmp 	identHash
.b7e5	d0 16		bne $b7fd			bne 	_CCVNext
.b7e7	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b7e9	ae 80 04	ldx $0480			ldx 	identStart
.b7ec					_CCVCompare:
.b7ec	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b7ef	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b7f1	e8		inx				inx 								; advance pointers
.b7f2	c8		iny				iny
.b7f3	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b7f4	d0 07		bne $b7fd			bne 	_CCVNext  					; didn't match go to next.
.b7f6	90 f4		bcc $b7ec			bcc 	_CCVCompare 				; not finished yet.
.b7f8	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b7fb	f0 41		beq $b83e			beq 	_CCVFound 					; yes, we were successful
.b7fd					_CCVNext:
.b7fd	18		clc				clc
.b7fe	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b800	65 36		adc $36				adc 	zTemp0
.b802	85 36		sta $36				sta 	zTemp0
.b804	90 d4		bcc $b7da			bcc 	_CCVSearch
.b806	e6 37		inc $37				inc 	zTemp0+1
.b808	80 d0		bra $b7da			bra 	_CCVSearch
.b80a					_CCVFail:
.b80a	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b80c	ad 83 04	lda $0483			lda 	identHash
.b80f	91 36		sta ($36),y			sta 	(zTemp0),y
.b811	c8		iny				iny 								; offset 2 is the type byte
.b812	ad 84 04	lda $0484			lda 	identTypeByte
.b815	91 36		sta ($36),y			sta 	(zTemp0),y
.b817	c8		iny				iny
.b818					_CCVData:
.b818	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b81a	91 36		sta ($36),y			sta 	(zTemp0),y
.b81c	c8		iny				iny
.b81d	c0 08		cpy #$08			cpy 	#8
.b81f	90 f7		bcc $b818			bcc 	_CCVData
.b821	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b824					_CCVCopyName:
.b824	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b827	91 36		sta ($36),y			sta 	(zTemp0),y
.b829	e8		inx				inx
.b82a	c8		iny				iny
.b82b	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b82e	d0 f4		bne $b824			bne 	_CCVCopyName
.b830	98		tya				tya 								; patch offset
.b831	92 36		sta ($36)			sta 	(zTemp0)
.b833	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b835	91 36		sta ($36),y			sta 	(zTemp0),y
.b837	88		dey				dey
.b838	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b83a	09 80		ora #$80			ora 	#$80
.b83c	91 36		sta ($36),y			sta 	(zTemp0),y
.b83e					_CCVFound:
.b83e	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b840	38		sec				sec
.b841	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b843	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b845	20 c6 b7	jsr $b7c6			jsr 	TOKWriteByte
.b848	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b84a	20 c6 b7	jsr $b7c6			jsr 	TOKWriteByte
.b84d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b84e					SNDCheckChannel:
.b84e	aa		tax				tax
.b84f	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b852	d0 38		bne $b88c			bne 	_SNDCCExit
.b854	da		phx				phx 								; save current channel
.b855	8a		txa				txa 								; put in A
.b856	20 d2 b8	jsr $b8d2			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b859	68		pla				pla 								; channel # in A
.b85a	90 30		bcc $b88c			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b85c	a8		tay				tay 								; Y is the channel #
.b85d	bd fe 06	lda $06fe,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b860	99 fd 07	sta $07fd,y			sta 	SNDPitchLow,y
.b863	bd ff 06	lda $06ff,x			lda 	SNDQueue+2,x
.b866	99 01 08	sta $0801,y			sta 	SNDPitchHigh,y
.b869	bd 00 07	lda $0700,x			lda 	SNDQueue+3,x
.b86c	99 05 08	sta $0805,y			sta 	SNDVolume,y
.b86f	bd 01 07	lda $0701,x			lda 	SNDQueue+4,x
.b872	99 09 08	sta $0809,y			sta 	SNDTimeLeft,y
.b875	bd 02 07	lda $0702,x			lda 	SNDQueue+5,x
.b878	99 0d 08	sta $080d,y			sta 	SNDAdjustLow,y
.b87b	bd 03 07	lda $0703,x			lda 	SNDQueue+6,x
.b87e	99 11 08	sta $0811,y			sta 	SNDAdjustHigh,y
.b881	5a		phy				phy 								; save channel #
.b882	20 ec b8	jsr $b8ec			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b885	ce fc 06	dec $06fc			dec 	SNDLength 					; reduce the queue length.
.b888	68		pla				pla
.b889	20 8d b8	jsr $b88d			jsr 	SNDUpdateNote 				; update channel A
.b88c					_SNDCCExit:
.b88c	60		rts				rts
.b88d					SNDUpdateNote:
.b88d	aa		tax				tax 								; so we can access records
.b88e	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b88f	0a		asl a				asl 	a
.b890	0a		asl a				asl 	a
.b891	0a		asl a				asl 	a
.b892	0a		asl a				asl 	a
.b893	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b896	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; are we silent
.b899	f0 2e		beq $b8c9			beq 	_SNDUNIsSilent
.b89b	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; push channel bits on stack
.b89e	48		pha				pha
.b89f	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b8a2	29 0f		and #$0f			and 	#$0F
.b8a4	0d fb 06	ora $06fb			ora 	SNDChannelBits 				; set channel bits
.b8a7	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b8a9	20 36 b9	jsr $b936			jsr 	SNDWritePorts
.b8ac	bd 01 08	lda $0801,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b8af	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b8b2	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x
.b8b5	4e fb 06	lsr $06fb			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b8b8	6a		ror a				ror 	a
.b8b9	4e fb 06	lsr $06fb			lsr 	SNDChannelBits
.b8bc	6a		ror a				ror 	a
.b8bd	4a		lsr a				lsr 	a 							; put in bits 0-5
.b8be	4a		lsr a				lsr 	a
.b8bf	20 36 b9	jsr $b936			jsr 	SNDWritePorts 				; write as rest of pitch register
.b8c2	68		pla				pla
.b8c3	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b8c5	20 36 b9	jsr $b936			jsr 	SNDWritePorts
.b8c8	60		rts				rts
.b8c9					_SNDUNIsSilent:
.b8c9	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; channel bits
.b8cc	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b8ce	20 36 b9	jsr $b936			jsr 	SNDWritePorts 				; write to the ports
.b8d1	60		rts				rts
.b8d2					SNDFindNextNoteForA:
.b8d2	ac fc 06	ldy $06fc			ldy 	SNDLength 					; queue size into Y
.b8d5	f0 13		beq $b8ea			beq 	_SNDFNNFail 				; queue empty.
.b8d7	a2 00		ldx #$00			ldx 	#0
.b8d9					_SNDFNNSearch:
.b8d9	dd fd 06	cmp $06fd,x			cmp 	SNDQueue,x 					; does it match the channel
.b8dc	38		sec				sec
.b8dd	f0 0c		beq $b8eb			beq 	_SNDFNNExit 				; if so exit with CS.
.b8df	e8		inx				inx 								; next queue slot.
.b8e0	e8		inx				inx
.b8e1	e8		inx				inx
.b8e2	e8		inx				inx
.b8e3	e8		inx				inx
.b8e4	e8		inx				inx
.b8e5	e8		inx				inx
.b8e6	e8		inx				inx
.b8e7	88		dey				dey 								; done the whole queue
.b8e8	d0 ef		bne $b8d9			bne 	_SNDFNNSearch 				; no, go back.
.b8ea					_SNDFNNFail:
.b8ea	18		clc				clc
.b8eb					_SNDFNNexit:
.b8eb	60		rts				rts
.b8ec					SNDDeleteXFromQueue:
.b8ec	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b8ee	f0 09		beq $b8f9			beq 	_SNDDXExit
.b8f0	bd 05 07	lda $0705,x			lda 	SNDQueue+8,x
.b8f3	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b8f6	e8		inx				inx
.b8f7	80 f3		bra $b8ec			bra 	SNDDeleteXFromQueue
.b8f9					_SNDDXExit:
.b8f9	60		rts				rts
.06fb					SNDChannelBits:
>06fb							.fill 	1
.b8fa					SNDQueueRequest:
.b8fa	86 36		stx $36				stx 	zTemp0						; save queue address
.b8fc	84 37		sty $37				sty 	zTemp0+1
.b8fe	ae fc 06	ldx $06fc			ldx 	SNDLength 					; queue is full, can't take any more.
.b901	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b903	f0 21		beq $b926			beq 	_SNDQRExit
.b905	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b907	48		pha				pha
.b908	8a		txa				txa  								; get offset in queue buffer/
.b909	0a		asl a				asl 	a
.b90a	0a		asl a				asl 	a
.b90b	0a		asl a				asl 	a
.b90c	aa		tax				tax
.b90d	68		pla				pla 								; get back and push again
.b90e	48		pha				pha
.b90f	9d fd 06	sta $06fd,x			sta 	SNDQueue+0,x 				; save the channel #
.b912	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b914					_SNDQCopy:
.b914	b1 36		lda ($36),y			lda 	(zTemp0),y
.b916	e8		inx				inx
.b917	c8		iny				iny
.b918	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b91b	c0 06		cpy #$06			cpy 	#6
.b91d	d0 f5		bne $b914			bne 	_SNDQCopy
.b91f	ee fc 06	inc $06fc			inc 	SNDLength 					; bump queue length.
.b922	68		pla				pla 								; get channel # back
.b923	20 4e b8	jsr $b84e			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b926					_SNDQRExit:
.b926	60		rts				rts
.b927					SNDSilenceChannel:
.b927	aa		tax				tax 								; zero time left.
.b928	9e 09 08	stz $0809,x			stz 	SNDTimeLeft,x
.b92b	0a		asl a				asl 	a 							; shift into position
.b92c	0a		asl a				asl 	a
.b92d	0a		asl a				asl 	a
.b92e	0a		asl a				asl 	a
.b92f	0a		asl a				asl 	a
.b930	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b932	20 36 b9	jsr $b936			jsr 	SNDWritePorts
.b935	60		rts				rts
.b936					SNDWritePorts:
.b936	64 01		stz $01				stz 	1
.b938	8d 00 d6	sta $d600			sta 	$D600
.b93b	8d 10 d6	sta $d610			sta 	$D610
.b93e	60		rts				rts
.b93f					SNDCommand:
.b93f	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b941	f0 1c		beq $b95f			beq 	_SNDInitialise
.b943	90 27		bcc $b96c			bcc 	_SNDExit
.b945	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b947	f0 16		beq $b95f			beq 	_SNDSilence
.b949	b0 21		bcs $b96c			bcs 	_SNDExit
.b94b	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b94d	b0 09		bcs $b958			bcs 	_SNDQueryPlay
.b94f	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b951	b0 19		bcs $b96c			bcs 	_SNDExit
.b953	20 fa b8	jsr $b8fa			jsr 	SNDQueueRequest
.b956	80 14		bra $b96c			bra 	_SNDExit
.b958					_SNDQueryPlay:
.b958	29 03		and #$03			and 	#3 							; get channel #
.b95a	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b95d	80 0d		bra $b96c			bra 	_SNDExit
.b95f					_SNDInitialise:
.b95f					_SNDSilence:
.b95f	9c fc 06	stz $06fc			stz 	SNDLength 					; empty the queue.
.b962	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b964					_SNDSilenceLoop:
.b964	48		pha				pha
.b965	20 27 b9	jsr $b927			jsr 	SNDSilenceChannel
.b968	68		pla				pla
.b969	3a		dec a				dec 	a
.b96a	10 f8		bpl $b964			bpl 	_SNDSilenceLoop
.b96c					_SNDExit:
.b96c	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fc					SNDLength:
>06fc							.fill 	1
.06fd					SNDQueue:
>06fd							.fill 	SNDQueueSize * 8
.07fd					SNDPitchLow:
>07fd							.fill 	4
.0801					SNDPitchHigh:
>0801							.fill 	4
.0805					SNDVolume:
>0805							.fill 	4
.0809					SNDTimeLeft:
>0809							.fill 	4
.080d					SNDAdjustLow:
>080d							.fill 	4
.0811					SNDAdjustHigh:
>0811							.fill 	4

;******  Return to file: _basic.asm


;******  End of listing
