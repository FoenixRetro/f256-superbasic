
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Mon Nov 21 15:34:15 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					tokenOffset:
>04a8							.fill 	1
.04a9					tokenLineNumber:
>04a9							.fill 	2
.04ab					tokenBuffer:
>04ab							.fill 	253
.05a8					lineBuffer:
>05a8							.fill 	MaxLineSize+1
.05f9					numberBuffer:
>05f9							.fill 	34
.061b					decimalBuffer:
>061b							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_LET                              = $bc; $bc LET
=$bd					KWD_LINE                             = $bd; $bd LINE
=$be					KWD_LOCAL                            = $be; $be LOCAL
=$bf					KWD_OFF                              = $bf; $bf OFF
=$c0					KWD_ON                               = $c0; $c0 ON
=$c1					KWD_OUTLINE                          = $c1; $c1 OUTLINE
=$c2					KWD_PALETTE                          = $c2; $c2 PALETTE
=$c3					KWD_PLOT                             = $c3; $c3 PLOT
=$c4					KWD_PRINT                            = $c4; $c4 PRINT
=$c5					KWD_READ                             = $c5; $c5 READ
=$c6					KWD_RECT                             = $c6; $c6 RECT
=$c7					KWD_REM                              = $c7; $c7 REM
=$c8					KWD_RETURN                           = $c8; $c8 RETURN
=$c9					KWD_SOLID                            = $c9; $c9 SOLID
=$ca					KWD_SOUND                            = $ca; $ca SOUND
=$cb					KWD_SPRITE                           = $cb; $cb SPRITE
=$cc					KWD_TEXT                             = $cc; $cc TEXT
=$cd					KWD_TO                               = $cd; $cd TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 3b aa	jsr $aa3b			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 c4 8d	jsr $8dc4			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 41 b9	jsr $b941			jsr 	SNDCommand
.8019	20 53 88	jsr $8853			jsr 	NewProgram 					; erase current program
.801c	20 e3 82	jsr $82e3			jsr 	BackloadProgram
.801f	4c ff 89	jmp $89ff			jmp 	CommandRun
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 4d 6f			.text "Built Monday 21-Nov-2022. Build 3451."
>804b	6e 64 61 79 20 32 31 2d 4e 6f 76 2d 32 30 32 32
>805b	2e 20 42 75 69 6c 64 20 33 34 35 31 2e

;******  Return to file: ./common/aa.system/00start.asm

>8068	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806b					AssembleGroup1:
.806b	a9 ff		lda #$ff			lda 	#$FF
.806d	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8070	80 02		bra $8074			bra 	AsmGroup12
.8072					AssembleGroup2:
.8072	a9 00		lda #$00			lda 	#$00
.8074					AsmGroup12:
.8074	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.8077	68		pla				pla 								; pop the return address to access the information following.
.8078	fa		plx				plx
.8079	20 02 81	jsr $8102			jsr 	AccessParameters 			; get opcode and save as base
.807c	8d a4 04	sta $04a4			sta 	BaseOpcode
.807f	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8082	d0 08		bne $808c			bne 	_AG12HaveMask
.8084	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8086	20 0a 81	jsr $810a			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8089	8d a5 04	sta $04a5			sta 	ModeMask
.808c					_AG12HaveMask:
.808c	20 45 82	jsr $8245			jsr 	TypeAndCalculateOperand 	; get zero page type
.808f	da		phx				phx 								; save found address mode
.8090	20 6e 81	jsr $816e			jsr 	AssembleModeX
.8093	fa		plx				plx  								; restore address mode
.8094	b0 0b		bcs $80a1			bcs 	_AG12Exit
.8096	20 a2 80	jsr $80a2			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8099	20 6e 81	jsr $816e			jsr 	AssembleModeX
.809c	b0 03		bcs $80a1			bcs 	_AG12Exit
.809e	4c b8 9f	jmp $9fb8			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a1					_AG12Exit:
.80a1	60		rts				rts
.80a2					PromoteToAbsolute:
.80a2	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a4	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a6	f0 19		beq $80c1			beq 	_PTADo
.80a8	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80aa	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80ac	f0 13		beq $80c1			beq 	_PTADo
.80ae	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b0	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b2	f0 0d		beq $80c1			beq 	_PTADo
.80b4	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b6	e0 d1		cpx #$d1			cpx 	#AM_IND
.80b8	f0 07		beq $80c1			beq 	_PTADo
.80ba	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bc	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80be	f0 01		beq $80c1			beq 	_PTADo
.80c0	60		rts				rts
.80c1					_PTADo:
.80c1	aa		tax				tax
.80c2	60		rts				rts
.80c3					AssembleGroup3:
.80c3	68		pla				pla 								; get parameters, which is just the opcode.
.80c4	fa		plx				plx
.80c5	20 02 81	jsr $8102			jsr 	AccessParameters 			; get and output opcode
.80c8	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.80cb	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get a 16 bit operand
.80ce	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d1	38		sec				sec
.80d2	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d5	48		pha				pha 								; LSB in A
.80d6	ad 10 04	lda $0410			lda 	NSMantissa1
.80d9	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80dc	aa		tax				tax 								; MSB in X
.80dd	68		pla				pla
.80de	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80df	69 7f		adc #$7f			adc 	#$7F
.80e1	90 01		bcc $80e4			bcc 	_AG3NoCarry
.80e3	e8		inx				inx
.80e4					_AG3NoCarry:
.80e4	38		sec				sec 								; fix back and write out anyways.
.80e5	e9 80		sbc #$80			sbc 	#$80
.80e7	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.80ea	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ec	f0 0a		beq $80f8			beq 	_AG3Exit
.80ee	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f1	29 01		and #$01			and 	#1
.80f3	f0 03		beq $80f8			beq 	_AG3Exit
.80f5	4c bd 9f	jmp $9fbd			jmp 	RangeError 					; no, branch is out of range
.80f8					_AG3Exit:
.80f8	60		rts				rts
.80f9					AssembleGroup4:
.80f9	68		pla				pla 								; pop address
.80fa	fa		plx				plx
.80fb	20 02 81	jsr $8102			jsr 	AccessParameters 			; access and get first
.80fe	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte 			; output it.
.8101	60		rts				rts
.8102					AccessParameters:
.8102	8d a1 04	sta $04a1			sta 	ParamStart
.8105	8e a2 04	stx $04a2			stx 	ParamStart+1
.8108	a9 01		lda #$01			lda 	#1
.810a					GetParameter:
.810a	5a		phy				phy
.810b	a8		tay				tay
.810c	ad a1 04	lda $04a1			lda 	ParamStart
.810f	85 36		sta $36				sta 	zTemp0
.8111	ad a2 04	lda $04a2			lda 	ParamStart+1
.8114	85 37		sta $37				sta 	zTemp0+1
.8116	b1 36		lda ($36),y			lda 	(zTemp0),y
.8118	7a		ply				ply
.8119	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811a					AssemblerWriteByte:
.811a	48		pha			pha
.811b	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.811e	29 02		and #$02		and 	#2
.8120	f0 1b		beq $813d		beq 	_AWBNoPrint
.8122	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8125	20 58 81	jsr $8158		jsr 	PrintHex
.8128	ad 9e 04	lda $049e		lda		AssemblerAddress
.812b	20 58 81	jsr $8158		jsr 	PrintHex
.812e	a9 20		lda #$20		lda 	#' '
.8130	20 c7 a7	jsr $a7c7		jsr 	EXTPrintCharacter
.8133	68		pla			pla 									; print byte
.8134	48		pha			pha
.8135	20 58 81	jsr $8158		jsr 	PrintHex
.8138	a9 0d		lda #$0d		lda 	#13
.813a	20 c7 a7	jsr $a7c7		jsr 	EXTPrintCharacter
.813d					_AWBNoPrint:
.813d	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8140	85 36		sta $36			sta 	zTemp0
.8142	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8145	f0 0e		beq $8155		beq 	_AWBRange
.8147	85 37		sta $37			sta 	zTemp0+1
.8149	68		pla			pla 									; write byte out
.814a	92 36		sta ($36)		sta 	(zTemp0)
.814c	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.814f	d0 03		bne $8154		bne 	_AWBNoCarry
.8151	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8154					_AWBNoCarry:
.8154	60		rts			rts
.8155					_AWBRange:
.8155	4c bd 9f	jmp $9fbd		jmp 	RangeError
.8158					PrintHex:
.8158	48		pha				pha
.8159	4a		lsr a				lsr 	a
.815a	4a		lsr a				lsr 	a
.815b	4a		lsr a				lsr 	a
.815c	4a		lsr a				lsr 	a
.815d	20 61 81	jsr $8161			jsr 	_PrintNibble
.8160	68		pla				pla
.8161					_PrintNibble:
.8161	29 0f		and #$0f			and 	#15
.8163	c9 0a		cmp #$0a			cmp 	#10
.8165	90 02		bcc $8169			bcc 	_NoShift
.8167	69 06		adc #$06			adc 	#6
.8169					_NoShift:
.8169	69 30		adc #$30			adc 	#48
.816b	4c c7 a7	jmp $a7c7			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.816e					AssembleModeX:
.816e	5a		phy				phy
.816f	ad a3 04	lda $04a3			lda 	IsGroup1
.8172	f0 17		beq $818b			beq 	_AMXGroup2
.8174	8a		txa				txa 							; is it in group # 1
.8175	29 40		and #$40			and 	#AM_ISG1
.8177	f0 50		beq $81c9			beq 	_AMXFail 				; no, give up.
.8179	8a		txa				txa 							; get back.
.817a	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817c	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.817e	d0 22		bne $81a2			bne 	_AMXHaveInfo
.8180	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8183	c9 81		cmp #$81			cmp 	#$81
.8185	f0 42		beq $81c9			beq 	_AMXFail
.8187	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.8189	80 17		bra $81a2			bra 	_AMXHaveInfo 			; odd design decision there.
.818b					_AMXGroup2:
.818b	8a		txa				txa 							; is it in group 2 ?
.818c	29 20		and #$20			and 	#AM_ISG2
.818e	f0 39		beq $81c9			beq 	_AMXFail 				; no, give up.
.8190	8a		txa				txa 							; get the offset into Y
.8191	29 1f		and #$1f			and 	#$1F
.8193	4a		lsr a				lsr 	a 						; make it 0-7.
.8194	4a		lsr a				lsr  	a
.8195	a8		tay				tay
.8196	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.8199					_AMXCheckOkay:
.8199	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819a	88		dey				dey
.819b	10 fc		bpl $8199			bpl 	_AMXCheckOkay
.819d	90 2a		bcc $81c9			bcc 	_AMXFail 				; not allowed.
.819f	8a		txa				txa  							; get mask back
.81a0	29 1f		and #$1f			and 	#$1F
.81a2					_AMXHaveInfo:
.81a2	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a4	10 05		bpl $81ab			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a6	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81a9	d0 1e		bne $81c9			bne 	_AMXFail
.81ab					_AMXAnySize:
.81ab	18		clc				clc 							; add offset to the base opcode
.81ac	6d a4 04	adc $04a4			adc 	BaseOpcode
.81af					_AMXOutputCode:
.81af	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b2	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b4	f0 10		beq $81c6			beq 	_AMXExit
.81b6	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81b9	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.81bc	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81be	30 06		bmi $81c6			bmi 	_AMXExit
.81c0	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c3	20 1a 81	jsr $811a			jsr 	AssemblerWriteByte
.81c6					_AMXExit:
.81c6	7a		ply				ply
.81c7	38		sec				sec
.81c8	60		rts				rts
.81c9					_AMXFail:
.81c9	a0 00		ldy #$00			ldy 	#0
.81cb					_AMXCheckOddities:
.81cb	8a		txa				txa
.81cc	d9 f4 81	cmp $81f4,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81cf	d0 16		bne $81e7			bne 	_AMXCONext
.81d1	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d4	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81d7	d0 0e		bne $81e7			bne 	_AMXCONext
.81d9	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81db	10 05		bpl $81e2			bpl 	_AMXCONotZero
.81dd	ad 10 04	lda $0410			lda 	NSMantissa1
.81e0	d0 05		bne $81e7			bne 	_AMXCONext
.81e2					_AMXCONotZero:
.81e2	b9 f3 81	lda $81f3,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e5	80 c8		bra $81af			bra 	_AMXOutputCode 			; and assemble it
.81e7					_AMXCONext:
.81e7	c8		iny				iny
.81e8	c8		iny				iny
.81e9	c8		iny				iny
.81ea	b9 f2 81	lda $81f2,y			lda 	ExtraOpcode+0,y 		; end of table
.81ed	d0 dc		bne $81cb			bne 	_AMXCheckOddities
.81ef					_AMXCOFail:
.81ef	7a		ply				ply
.81f0	18		clc				clc
.81f1	60		rts				rts
.81f2					ExtraOpcode:
>81f2	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f5	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81f8	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fb	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81fe	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8201	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8204	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8207	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820a	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820d	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8210	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8211					LabelHere:
.8211	c8		iny				iny 								; skip .
.8212	a2 00		ldx #$00			ldx 	#0 							; get a term
.8214	20 f4 97	jsr $97f4			jsr 	EvaluateTerm 				; get a term
.8217	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821a	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821c	d0 24		bne $8242			bne 	_ALType
.821e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8221	85 36		sta $36				sta 	zTemp0
.8223	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8226	85 37		sta $37				sta 	zTemp0+1
.8228	5a		phy				phy 								; copy address in.
.8229	a0 01		ldy #$01			ldy 	#1
.822b	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.822e	92 36		sta ($36)			sta 	(zTemp0)
.8230	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8233	91 36		sta ($36),y			sta 	(zTemp0),y
.8235	c8		iny				iny
.8236	a9 00		lda #$00			lda 	#0
.8238	91 36		sta ($36),y			sta 	(zTemp0),y
.823a	c8		iny				iny
.823b	91 36		sta ($36),y			sta 	(zTemp0),y
.823d	c8		iny				iny
.823e	91 36		sta ($36),y			sta 	(zTemp0),y
.8240	7a		ply				ply
.8241	60		rts				rts
.8242					_ALType:
.8242	4c c2 9f	jmp $9fc2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8245					TypeAndCalculateOperand:
.8245	b1 30		lda ($30),y			lda 	(codePtr),y
.8247	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8249	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824b	f0 5b		beq $82a8			beq 	_TACOExit
.824d	c9 80		cmp #$80			cmp 	#KWC_EOL
.824f	f0 57		beq $82a8			beq 	_TACOExit
.8251	c8		iny				iny
.8252	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8254	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8256	f0 51		beq $82a9			beq 	CalculateOperand
.8258	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825a	f0 1f		beq $827b			beq 	_TACOIndirect
.825c	88		dey				dey 								; undo get of first character
.825d	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get operand
.8260	b1 30		lda ($30),y			lda 	(codePtr),y
.8262	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8264	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8266	d0 40		bne $82a8			bne 	_TACOExit
.8268	c8		iny				iny
.8269	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826c	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.826e	c9 58		cmp #$58			cmp 	#'X'
.8270	f0 36		beq $82a8			beq 	_TACOExit
.8272	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8274	c9 59		cmp #$59			cmp 	#'Y'
.8276	f0 30		beq $82a8			beq 	_TACOExit
.8278					_TACOSyntax:
.8278	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.827b					_TACOIndirect:
.827b	20 a9 82	jsr $82a9			jsr 	CalculateOperand 			; get the operand
.827e	b1 30		lda ($30),y			lda 	(codePtr),y
.8280	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8282	f0 17		beq $829b			beq 	_TACOIndX
.8284	20 52 8d	jsr $8d52			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8287	b1 30		lda ($30),y			lda 	(codePtr),y
.8289	a2 d1		ldx #$d1			ldx 	#AM_IND
.828b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828d	d0 19		bne $82a8			bne 	_TACOExit
.828f	c8		iny				iny
.8290	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8293	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8295	d0 e1		bne $8278			bne 	_TACOSyntax
.8297	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8299	80 0d		bra $82a8			bra 	_TACOExit
.829b					_TACOIndX:
.829b	c8		iny				iny
.829c	20 b3 82	jsr $82b3			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.829f	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a1	d0 d5		bne $8278			bne 	_TACOSyntax
.82a3	20 52 8d	jsr $8d52			jsr 	CheckRightBracket			; check )
.82a6	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82a8					_TACOExit:
.82a8	60		rts				rts
.82a9					CalculateOperand:
.82a9	48		pha				pha
.82aa	da		phx				phx
.82ab	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82ad	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.82b0	fa		plx				plx
.82b1	68		pla				pla
.82b2	60		rts				rts
.82b3					TACOCheckXY:
.82b3	b1 30		lda ($30),y			lda 	(codePtr),y
.82b5	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b7	c9 40		cmp #$40			cmp 	#$40
.82b9	d0 21		bne $82dc			bne 	_TCXYFail
.82bb	b1 30		lda ($30),y			lda 	(codePtr),y
.82bd	18		clc				clc
.82be	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c0	85 37		sta $37				sta 	zTemp0+1
.82c2	c8		iny				iny
.82c3	b1 30		lda ($30),y			lda 	(codePtr),y
.82c5	c8		iny				iny
.82c6	85 36		sta $36				sta 	zTemp0
.82c8	5a		phy				phy 								; save position
.82c9	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cb	b1 36		lda ($36),y			lda 	(zTemp0),y
.82cd	d0 0c		bne $82db			bne 	_TCXYPopFail
.82cf	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d1	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d3	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d5	f0 08		beq $82df			beq 	_TCXYFound
.82d7	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82d9	f0 04		beq $82df			beq 	_TCXYFound
.82db					_TCXYPopFail:
.82db	7a		ply				ply
.82dc					_TCXYFail:
.82dc	a9 00		lda #$00			lda 	#0
.82de	60		rts				rts
.82df					_TCXYFound:
.82df	7a		ply				ply 								; restore position
.82e0	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e3					BackloadProgram:
.82e3	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e5	8d 2b 06	sta $062b			sta 	0+BackLoadPointer
.82e8	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82ea	8d 2c 06	sta $062c			sta 	1+BackLoadPointer
.82ed					_BPLoop:
.82ed	a2 ff		ldx #$ff			ldx 	#$FF
.82ef	8e fa ff	stx $fffa			stx 	$FFFA 						; fast mode (autorun only)
.82f2	20 1c 83	jsr $831c			jsr 	BLReadByte
.82f5	30 1e		bmi $8315			bmi 	_BPExit
.82f7					_BPCopy:
.82f7	e8		inx				inx  								; copy byte in
.82f8	9d a8 05	sta $05a8,x			sta 	lineBuffer,x
.82fb	9e a9 05	stz $05a9,x			stz 	lineBuffer+1,x
.82fe	20 1c 83	jsr $831c			jsr 	BLReadByte 					; read next byte
.8301	30 0a		bmi $830d			bmi 	_BPEndLine 					; -ve = EOL
.8303	c9 09		cmp #$09			cmp 	#9 							; handle TAB
.8305	d0 02		bne $8309			bne 	_BPNotTab
.8307	a9 20		lda #$20			lda 	#' '
.8309					_BPNotTab:
.8309	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.830b	b0 ea		bcs $82f7			bcs 	_BPCopy
.830d					_BPEndLine:
.830d	20 d1 b5	jsr $b5d1			jsr 	TokeniseLine 				; tokenise the line.
.8310	20 33 83	jsr $8333			jsr 	EditProgramCode
.8313	80 d8		bra $82ed			bra 	_BPLoop
.8315					_BPExit:
.8315	9c fa ff	stz $fffa			stz 	$FFFA 						; clear fast mode (autorun only)
.8318	20 f1 83	jsr $83f1			jsr 	ClearCommand 				; clear variables etc.
.831b	60		rts				rts
.831c					BLReadByte:
.831c	ad 2b 06	lda $062b			lda 	BackLoadPointer
.831f	85 36		sta $36				sta 	zTemp0
.8321	ad 2c 06	lda $062c			lda 	BackLoadPointer+1
.8324	85 37		sta $37				sta 	zTemp0+1
.8326	b2 36		lda ($36)			lda 	(zTemp0)
.8328	ee 2b 06	inc $062b			inc 	BackLoadPointer
.832b	d0 03		bne $8330			bne 	_BLNoCarry
.832d	ee 2c 06	inc $062c			inc 	BackLoadPointer+1
.8330					_BLNoCarry:
.8330	c9 00		cmp #$00			cmp 	#0
.8332	60		rts				rts
.062b					BackLoadPointer:
>062b							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8333					EditProgramCode:
.8333	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line.
.8336	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1
.8339	20 c7 a5	jsr $a5c7			jsr 	MemorySearch
.833c	90 05		bcc $8343			bcc 	_EPCNoDelete 				; reached the end don't delete
.833e	d0 03		bne $8343			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8340	20 e8 a4	jsr $a4e8			jsr 	MemoryDeleteLine 			; delete the line
.8343					_EPCNoDelete:
.8343	ad ab 04	lda $04ab			lda 	TokenBuffer 				; buffer empty
.8346	c9 80		cmp #$80			cmp 	#KWC_EOL
.8348	f0 0d		beq $8357			beq 	_EPCNoInsert
.834a	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; find the line - it cannot exist.
.834d	ae aa 04	ldx $04aa			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8350	20 c7 a5	jsr $a5c7			jsr 	MemorySearch
.8353	18		clc				clc 								; insert at this point.
.8354	20 1f a5	jsr $a51f			jsr 	MemoryInsertLine 			; insert the line
.8357					_EPCNoInsert:
.8357	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8358					WarmStart:
.8358	a2 ff		ldx #$ff			ldx 	#$FF
.835a	9a		txs				txs
.835b	20 55 a9	jsr $a955			jsr 	EXTInputLine 				; get line to lineBuffer
.835e	20 d1 b5	jsr $b5d1			jsr 	TokeniseLine 				; tokenise the line
.8361	ad a9 04	lda $04a9			lda 	TokenLineNumber 			; line number ?
.8364	0d aa 04	ora $04aa			ora 	TokenLineNumber+1
.8367	d0 17		bne $8380			bne 	_WSEditCode 				; if so,edit code.
.8369	9c a8 04	stz $04a8			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.836c	a9 a8		lda #$a8			lda 	#((TokenOffset) & $FF)
.836e	85 30		sta $30				sta 	codePtr
.8370	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8372	85 31		sta $31				sta 	codePtr+1
.8374	ad ab 04	lda $04ab			lda 	TokenBuffer 				; nothing to run
.8377	c9 80		cmp #$80			cmp 	#KWC_EOL
.8379	f0 dd		beq $8358			beq 	WarmStart
.837b	20 11 8a	jsr $8a11			jsr 	RUNCodePointerLine 			; execute that line.
.837e	80 d8		bra $8358			bra 	WarmStart
.8380					_WSEditCode:
.8380	20 33 83	jsr $8333			jsr 	EditProgramCode
.8383	20 f1 83	jsr $83f1			jsr 	ClearCommand
.8386	80 d0		bra $8358			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8388					AssembleCommand:
.8388	a2 00		ldx #$00			ldx 	#0
.838a	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger 		; start address
.838d	ad 08 04	lda $0408			lda 	NSMantissa0
.8390	8d 9e 04	sta $049e			sta 	AssemblerAddress
.8393	ad 10 04	lda $0410			lda 	NSMantissa1
.8396	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.8399	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.839c	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; options
.839f	ad 08 04	lda $0408			lda 	NSMantissa0
.83a2	8d a0 04	sta $04a0			sta 	AssemblerControl
.83a5	60		rts				rts
.83a6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83a7					AssertCommand:
.83a7	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83a9	20 7a 9d	jsr $9d7a			jsr 	EvaluateInteger 			; the assert test
.83ac	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; exit if result is non zero.
.83af	d0 05		bne $83b6			bne 	_ACExit
.83b1	a9 0a		lda #$0a		lda	#10
.83b3	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.83b6					_ACExit:
.83b6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83b7					CallCommand:
.83b7	a2 00		ldx #$00			ldx 	#0
.83b9	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.83bc					_CCClear
.83bc	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83bd	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.83c0	e0 04		cpx #$04			cpx 	#4
.83c2	d0 f8		bne $83bc			bne 	_CCClear
.83c4	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83c6					_CCCParam:
.83c6	b1 30		lda ($30),y			lda 	(codePtr),y
.83c8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83ca	d0 09		bne $83d5			bne 	_CCCRun6502
.83cc	c8		iny				iny 								; skip comma
.83cd	e8		inx				inx	 								; next level
.83ce	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83d1	e0 03		cpx #$03			cpx 	#3
.83d3	90 f1		bcc $83c6			bcc 	_CCCParam 					; done all 3 ?
.83d5					_CCCRun6502:
.83d5	5a		phy				phy 								; save position
.83d6	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83d9	85 37		sta $37				sta 	zTemp0+1
.83db	ad 08 04	lda $0408			lda 	NSMantissa0
.83de	85 36		sta $36				sta 	zTemp0
.83e0	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83e3	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83e6	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83e9	20 ee 83	jsr $83ee			jsr 	_CCCZTemp0 					; call zTemp0
.83ec	7a		ply				ply 								; restore position and exit
.83ed	60		rts				rts
.83ee					_CCCZTemp0:
.83ee	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83f1					ClearCommand:
.83f1	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83f3	85 36		sta $36				sta 	0+zTemp0
.83f5	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f7	85 37		sta $37				sta 	1+zTemp0
.83f9					_ClearZeroLoop:
.83f9	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables
.83fb	f0 24		beq $8421			beq 	_ClearZeroEnd
.83fd	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83ff	a9 00		lda #$00			lda 	#0
.8401					_ClearOneVariable:
.8401	91 36		sta ($36),y			sta 	(zTemp0),y
.8403	c8		iny				iny
.8404	c0 08		cpy #$08			cpy 	#8
.8406	d0 f9		bne $8401			bne 	_ClearOneVariable
.8408	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.840a	b1 36		lda ($36),y			lda 	(zTemp0),y
.840c	c9 18		cmp #$18			cmp 	#NSTProcedure
.840e	d0 04		bne $8414			bne 	_ClearNotProcedure
.8410	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; set it back to an integer array
.8412	91 36		sta ($36),y			sta 	(zTemp0),y
.8414					_ClearNotProcedure:
.8414	18		clc				clc 								; go to the next variable
.8415	b2 36		lda ($36)			lda 	(zTemp0)
.8417	65 36		adc $36				adc 	zTemp0
.8419	85 36		sta $36				sta 	zTemp0
.841b	90 dc		bcc $83f9			bcc 	_ClearZeroLoop
.841d	e6 37		inc $37				inc 	zTemp0+1
.841f	80 d8		bra $83f9			bra 	_ClearZeroLoop
.8421					_ClearZeroEnd:
.8421	18		clc				clc
.8422	a5 36		lda $36				lda 	zTemp0
.8424	69 01		adc #$01			adc 	#1
.8426	8d 8c 04	sta $048c			sta 	lowMemPtr
.8429	a5 37		lda $37				lda 	zTemp0+1
.842b	69 00		adc #$00			adc 	#0
.842d	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.8430	20 ec a6	jsr $a6ec			jsr 	StackReset
.8433	20 56 a7	jsr $a756			jsr 	StringSystemInitialise
.8436	20 5b 8c	jsr $8c5b			jsr 	ProcedureScan
.8439	20 c0 89	jsr $89c0			jsr 	Command_Restore
.843c	9c 9e 04	stz $049e			stz 	AssemblerAddress
.843f	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.8442	9c a0 04	stz $04a0			stz 	AssemblerControl
.8445	20 f7 99	jsr $99f7			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8448	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8449					ClearScreen:
.8449	5a		phy				phy
.844a	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.844c	20 c7 a7	jsr $a7c7			jsr 	EXTPrintCharacter
.844f	7a		ply				ply
.8450	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8451					Command_Data:
.8451	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8453	a2 80		ldx #$80			ldx 	#KWC_EOL
.8455	20 ad 8c	jsr $8cad			jsr 	ScanForward
.8458	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8459					DimCommand:
.8459	b1 30		lda ($30),y			lda 	(codePtr),y
.845b	29 c0		and #$c0			and 	#$C0
.845d	c9 40		cmp #$40			cmp 	#$40
.845f	d0 7a		bne $84db			bne 	_DCSyntax
.8461	b1 30		lda ($30),y			lda 	(codePtr),y
.8463	18		clc				clc
.8464	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8466	85 3f		sta $3f				sta 	zaTemp+1
.8468	c8		iny				iny
.8469	b1 30		lda ($30),y			lda 	(codePtr),y
.846b	c8		iny				iny
.846c	85 3e		sta $3e				sta 	zaTemp
.846e	5a		phy				phy
.846f	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8471	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8473	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8475	c9 18		cmp #$18			cmp 	#NSTProcedure
.8477	f0 62		beq $84db			beq 	_DCSyntax
.8479	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.847b	29 04		and #$04			and 	#NSBIsArray
.847d	f0 64		beq $84e3			beq 	_DCType
.847f	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8481	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8483	d0 59		bne $84de			bne 	_DCRedefine
.8485	7a		ply				ply
.8486	20 e6 84	jsr $84e6			jsr 	_DCGetSize 				; get array size, check it.
.8489	5a		phy				phy
.848a	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.848c	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.848e	7a		ply				ply 							; is there a second (e.g. ,x)
.848f	b1 30		lda ($30),y			lda 	(codePtr),y
.8491	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8493	d0 0a		bne $849f			bne 	_DCOneDimension
.8495	c8		iny				iny 							; skip comma
.8496	20 e6 84	jsr $84e6			jsr 	_DCGetSize 				; get 2nd array size
.8499	5a		phy				phy
.849a	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.849c	91 3e		sta ($3e),y			sta 	(zaTemp),y
.849e	7a		ply				ply
.849f					_DCOneDimension:
.849f	5a		phy				phy 							; save position
.84a0	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84a2	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a4	aa		tax				tax
.84a5	c8		iny				iny
.84a6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a8	e8		inx				inx 							; bump them.
.84a9	1a		inc a				inc 	a
.84aa	20 c3 9d	jsr $9dc3			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84ad	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84af	29 e0		and #$e0			and 	#$E0
.84b1	d0 23		bne $84d6			bne 	_DCSize
.84b3	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b7	20 f4 84	jsr $84f4			jsr 	ScaleByBaseType 		; scale by base type
.84ba	a5 36		lda $36				lda 	zTemp0
.84bc	a6 37		ldx $37				ldx 	zTemp0+1
.84be	20 b9 99	jsr $99b9			jsr 	AllocateXABytes 		; allocate memory
.84c1	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84c3	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c5	c8		iny				iny
.84c6	8a		txa				txa
.84c7	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c9	7a		ply				ply 							; get position back
.84ca	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 		; check )
.84cd	b1 30		lda ($30),y			lda 	(codePtr),y
.84cf	c8		iny				iny 							; consume in case
.84d0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84d2	f0 85		beq $8459			beq 	DimCommand
.84d4	88		dey				dey 							; undo consume
.84d5	60		rts				rts
.84d6					_DCSize:
.84d6	a9 16		lda #$16		lda	#22
.84d8	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.84db					_DCSyntax:
.84db	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.84de					_DCRedefine:
.84de	a9 15		lda #$15		lda	#21
.84e0	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.84e3					_DCType:
.84e3	4c c2 9f	jmp $9fc2			jmp 	TypeError
.84e6					_DCGetSize:
.84e6	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84e8	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 	; get array dimension
.84eb	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84ed	f0 e7		beq $84d6			beq 	_DCSize
.84ef	c9 fe		cmp #$fe			cmp 	#254
.84f1	f0 e3		beq $84d6			beq 	_DCSize
.84f3	60		rts				rts
.84f4					ScaleByBaseType:
.84f4	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f6	d0 19		bne $8511			bne 	_SBBTString
.84f8	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84fa	48		pha				pha
.84fb	a5 36		lda $36				lda 	zTemp0
.84fd	48		pha				pha
.84fe	06 36		asl $36				asl 	zTemp0 					; x 2
.8500	26 37		rol $37				rol 	zTemp0+1
.8502	06 36		asl $36				asl 	zTemp0 					; x 4
.8504	26 37		rol $37				rol 	zTemp0+1
.8506	68		pla				pla 							; add stacked value = x 5
.8507	65 36		adc $36				adc 	zTemp0
.8509	85 36		sta $36				sta 	zTemp0
.850b	68		pla				pla
.850c	65 37		adc $37				adc 	zTemp0+1
.850e	85 37		sta $37				sta 	zTemp0+1
.8510	60		rts				rts
.8511					_SBBTString:
.8511	06 36		asl $36				asl 	zTemp0
.8513	26 37		rol $37				rol 	zTemp0+1
.8515	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8516					EndCommand:
.8516	4c 58 83	jmp $8358			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8519					ForCommand:
.8519	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.851b	20 87 a6	jsr $a687			jsr 	StackOpen
.851e	a2 00		ldx #$00			ldx 	#0
.8520	20 f4 97	jsr $97f4			jsr 	EvaluateTerm
.8523	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8526	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8528	d0 49		bne $8573			bne		_FCError
.852a	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.852c	20 62 8d	jsr $8d62			jsr 	CheckNextA
.852f	e8		inx				inx
.8530	20 7a 9d	jsr $9d7a			jsr 	EvaluateInteger 			; <from> in +1
.8533	b1 30		lda ($30),y			lda 	(codePtr),y
.8535	c8		iny				iny 								; consume it
.8536	48		pha				pha 								; save on stack for later
.8537	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8539	f0 04		beq $853f			beq 	_FCNoSyntax
.853b	c9 cd		cmp #$cd			cmp 	#KWD_TO
.853d	d0 37		bne $8576			bne 	_FCSyntaxError
.853f					_FCNoSyntax:
.853f	e8		inx				inx
.8540	20 7a 9d	jsr $9d7a			jsr 	EvaluateInteger
.8543	20 cb a6	jsr $a6cb			jsr 	STKSaveCodePosition 		; save loop back position
.8546	68		pla				pla 								; restore DOWNTO or TO
.8547	5a		phy				phy 								; save Y on the stack
.8548	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.854a	f0 02		beq $854e			beq 	_FCNotDownTo
.854c	a9 02		lda #$02			lda 	#2
.854e					_FCNotDownTo:
.854e	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.854f	a0 10		ldy #$10			ldy 	#16
.8551	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8553	a0 06		ldy #$06			ldy 	#6
.8555	ad 08 04	lda $0408			lda 	NSMantissa0
.8558	91 34		sta ($34),y			sta 	(basicStack),y
.855a	ad 10 04	lda $0410			lda 	NSMantissa1
.855d	c8		iny				iny
.855e	91 34		sta ($34),y			sta 	(basicStack),y
.8560	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8562	a2 01		ldx #$01			ldx 	#1
.8564	20 79 85	jsr $8579			jsr 	FCIntegerToStack
.8567	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8569	a2 02		ldx #$02			ldx 	#2
.856b	20 79 85	jsr $8579			jsr 	FCIntegerToStack
.856e	20 99 85	jsr $8599			jsr 	CopyIndexToReference
.8571	7a		ply				ply 								; restore position
.8572	60		rts				rts
.8573					_FCError:
.8573	4c c2 9f	jmp $9fc2			jmp 	TypeError
.8576					_FCSyntaxError:
.8576	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.8579					FCIntegerToStack:
.8579	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.857c	10 03		bpl $8581			bpl	 	_FCNotNegative
.857e	20 e3 9d	jsr $9de3			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8581					_FCNotNegative:
.8581	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8584	91 34		sta ($34),y			sta 	(basicStack),y
.8586	c8		iny				iny
.8587	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.858a	91 34		sta ($34),y			sta 	(basicStack),y
.858c	c8		iny				iny
.858d	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.8590	91 34		sta ($34),y			sta 	(basicStack),y
.8592	c8		iny				iny
.8593	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.8596	91 34		sta ($34),y			sta 	(basicStack),y
.8598	60		rts				rts
.8599					CopyIndexToReference:
.8599	5a		phy				phy
.859a	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.859c	38		sec				sec 								; (because we copy from offset 8)
.859d	b1 34		lda ($34),y			lda 	(basicStack),y
.859f	e9 08		sbc #$08			sbc 	#8
.85a1	85 36		sta $36				sta 	zTemp0
.85a3	c8		iny				iny
.85a4	b1 34		lda ($34),y			lda 	(basicStack),y
.85a6	e9 00		sbc #$00			sbc 	#0
.85a8	85 37		sta $37				sta 	zTemp0+1
.85aa	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85ac	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85ae	b1 34		lda ($34),y			lda 	(basicStack),y
.85b0	0a		asl a				asl 	a 							; into carry
.85b1	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85b3	90 14		bcc $85c9			bcc 	_CITRNormal
.85b5	38		sec				sec
.85b6					_CITRNegative:
.85b6	a9 00		lda #$00			lda 	#0
.85b8	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85ba	91 36		sta ($36),y			sta 	(zTemp0),y
.85bc	c8		iny				iny
.85bd	ca		dex				dex
.85be	d0 f6		bne $85b6			bne 	_CITRNegative
.85c0	88		dey				dey 								; look at MSB of mantissa
.85c1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85c3	09 80		ora #$80			ora 	#$80
.85c5	91 36		sta ($36),y			sta 	(zTemp0),y
.85c7	7a		ply				ply
.85c8	60		rts				rts
.85c9					_CITRNormal:
.85c9	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85cb	91 36		sta ($36),y			sta 	(zTemp0),y
.85cd	c8		iny				iny
.85ce	ca		dex				dex
.85cf	d0 f8		bne $85c9			bne 	_CITRNormal
.85d1	7a		ply				ply 								; and exit.
.85d2	60		rts				rts
.85d3					NextCommand:
.85d3	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85d5	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d7	20 b3 a6	jsr $a6b3			jsr 	StackCheckFrame
.85da	5a		phy				phy
.85db	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85dd	b1 34		lda ($34),y			lda 	(basicStack),y
.85df	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85e1	30 02		bmi $85e5			bmi 	_NCStepNeg
.85e3	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85e5					_NCStepNeg:
.85e5	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e7	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85e9	18		clc				clc
.85ea					_NCBump:
.85ea	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85ec	91 34		sta ($34),y			sta 	(basicStack),y
.85ee	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85f0	c8		iny				iny 								; next byte
.85f1	ca		dex				dex 								; do four times
.85f2	d0 f6		bne $85ea			bne 	_NCBump
.85f4	20 99 85	jsr $8599			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f7	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85f9	b1 34		lda ($34),y			lda 	(basicStack),y
.85fb	0a		asl a				asl 	a 							; sign bit to carry
.85fc	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85fe	85 38		sta $38				sta 	zTemp1
.8600	90 02		bcc $8604			bcc 	_NCCompRev 					; use if step is +ve
.8602	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8604					_NCCompRev:
.8604	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8606	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8608	85 39		sta $39				sta 	zTemp1+1
.860a	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.860c	38		sec				sec
.860d					_NCCompare:
.860d	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.860f	b1 34		lda ($34),y			lda 	(basicStack),y
.8611	a4 39		ldy $39				ldy 	zTemp1+1
.8613	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8615	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8617	e6 39		inc $39				inc 	zTemp1+1
.8619	ca		dex				dex 								; do it 4 times.
.861a	d0 f1		bne $860d			bne 	_NCCompare
.861c	50 02		bvc $8620			bvc 	_NCNoOverflow 				; convert to signed comparison
.861e	49 80		eor #$80			eor 	#$80
.8620					_NCNoOverflow:
.8620	7a		ply				ply 								; restore Y position
.8621	0a		asl a				asl 	a 							; is bit 7 set.
.8622	90 04		bcc $8628			bcc 	_NCLoopback 				; if no , >= so loop back
.8624	20 a5 a6	jsr $a6a5			jsr 	StackClose 					; exit the loop
.8627	60		rts				rts
.8628					_NCLoopBack:
.8628	20 dc a6	jsr $a6dc			jsr 	STKLoadCodePosition 		; loop back
.862b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.862c					Command_GOSUB:
.862c	a2 00		ldx #$00			ldx 	#0
.862e	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8631	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8633	20 87 a6	jsr $a687			jsr 	StackOpen 					; create frame
.8636	20 cb a6	jsr $a6cb			jsr 	STKSaveCodePosition 		; save current position
.8639	4c 4f 86	jmp $864f			jmp 	GotoStackX
.863c					Command_RETURN:
.863c	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.863e	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8640	20 b3 a6	jsr $a6b3			jsr 	StackCheckFrame
.8643	20 dc a6	jsr $a6dc			jsr 	STKLoadCodePosition 		; restore code position
.8646	20 a5 a6	jsr $a6a5			jsr 	StackClose
.8649	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.864a					GotoCommand:
.864a	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.864c	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.864f					GotoStackX:
.864f	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8652	48		pha				pha 								; it is slightly inefficient, just in cases.
.8653	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8656	fa		plx				plx
.8657	20 c7 a5	jsr $a5c7			jsr 	MemorySearch 				; transfer to line number AX.
.865a	90 05		bcc $8661			bcc 	_GotoError 					; not found, off end.
.865c	d0 03		bne $8661			bne 	_GotoError 					; not found exactly
.865e	4c 0a 8a	jmp $8a0a			jmp 	RunNewLine 					; and go straight to new line code.
.8661					_GotoError:
.8661	a9 0d		lda #$0d		lda	#13
.8663	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8666					IfCommand:
.8666	a2 00		ldx #$00			ldx 	#0 							; If what.
.8668	20 57 9d	jsr $9d57			jsr 	EvaluateNumber
.866b	b1 30		lda ($30),y			lda 	(codePtr),y
.866d	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.866f	d0 0a		bne $867b			bne 	_IFStructured
.8671	c8		iny				iny 								; consume THEN
.8672	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; is it zero
.8675	f0 01		beq $8678			beq 	_IfFail 					; if fail, go to next line
.8677	60		rts				rts 								; if THEN just continue
.8678					_IfFail:
.8678	4c f2 89	jmp $89f2			jmp 	EOLCommand
.867b					_IfStructured:
.867b	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; is it zero
.867e	d0 07		bne $8687			bne 	_IfExit 					; if not, then continue normally.
.8680	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8682	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8684	20 ad 8c	jsr $8cad			jsr 	ScanForward 				; and run from there/
.8687					_IfExit:
.8687	60		rts				rts
.8688					ElseCode:
.8688	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.868a	aa		tax				tax 								; so just go to the structure exit
.868b	20 ad 8c	jsr $8cad			jsr 	ScanForward
.868e	60		rts				rts
.868f					EndIf:
.868f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8690					LetCommand:
.8690	a2 00		ldx #$00			ldx 	#0
.8692	b1 30		lda ($30),y			lda 	(codePtr),y
.8694	c9 10		cmp #$10			cmp 	#KWD_AT
.8696	d0 16		bne $86ae			bne 	_LCStandard
.8698	c8		iny				iny 								; skip equal
.8699	20 f4 97	jsr $97f4			jsr 	EvaluateTerm 				; get a number
.869c	20 38 96	jsr $9638			jsr 	Dereference 				; dereference it
.869f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.86a2	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.86a4	9d 00 04	sta $0400,x			sta 	NSStatus,x
.86a7	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.86a9	d0 10		bne $86bb			bne 	_LCMain
.86ab	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; was a reference before.
.86ae					_LCStandard:
.86ae	ad 02 93	lda $9302			lda 	PrecedenceLevel+"*"			; precedence > this
.86b1	20 1c 93	jsr $931c			jsr 	EvaluateExpressionAtPrecedence
.86b4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.86b7	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.86b9	f0 0e		beq $86c9			beq 	_LetGoProc 					; it's a procedure call.
.86bb					_LCMain:
.86bb	a9 3d		lda #$3d			lda 	#"=" 						; check =
.86bd	20 62 8d	jsr $8d62			jsr 	CheckNextA
.86c0	e8		inx				inx 								; RHS
.86c1	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue
.86c4	ca		dex				dex
.86c5	20 cc 86	jsr $86cc			jsr 	AssignVariable
.86c8	60		rts				rts
.86c9					_LetGoProc:
.86c9	4c ca 88	jmp $88ca			jmp 	CallProcedure
.86cc					AssignVariable:
.86cc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.86cf	48		pha				pha 								; save a copy
.86d0	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.86d3	29 10		and #$10			and 	#NSBIsString
.86d5	d0 0b		bne $86e2			bne 	_ASError
.86d7	68		pla				pla 								; get back
.86d8	29 10		and #$10			and 	#NSBIsString 				; check type
.86da	d0 03		bne $86df			bne 	_ASString
.86dc	4c 60 95	jmp $9560			jmp 	AssignNumber
.86df					_ASString:
.86df	4c ce 95	jmp $95ce			jmp 	AssignString
.86e2					_ASError:
.86e2	4c c2 9f	jmp $9fc2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.86e5					Command_List:
.86e5	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.86e8	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.86eb	9c 14 04	stz $0414			stz 	NSMantissa1+4
.86ee	a9 ff		lda #$ff			lda 	#$FF
.86f0	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.86f3	8d 17 04	sta $0417			sta 	NSMantissa1+7
.86f6	b1 30		lda ($30),y			lda 	(codePtr),y
.86f8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.86fa	f0 1e		beq $871a			beq 	_CLSecond
.86fc	20 7b 87	jsr $877b			jsr 	CLIsDigit 					; if not digit, list all
.86ff	b0 24		bcs $8725			bcs 	_CLStart
.8701	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8703	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.8706	b1 30		lda ($30),y			lda 	(codePtr),y
.8708	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.870a	f0 0e		beq $871a			beq 	_CLSecond 					; if so go get it
.870c	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.870f	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.8712	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8715	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8718	80 0b		bra $8725			bra 	_CLStart
.871a					_CLSecond:
.871a	c8		iny				iny 								; consume comma
.871b	20 7b 87	jsr $877b			jsr 	CLIsDigit 					; digit found
.871e	b0 05		bcs $8725			bcs 	_CLStart 					; if not, continue listing
.8720	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8722	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.8725					_CLStart
.8725	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8727	85 30		sta $30				sta 	codePtr
.8729	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.872b	85 31		sta $31				sta 	codePtr+1
.872d					_CLLoop:
.872d	20 69 aa	jsr $aa69			jsr 	EXTBreakCheck 				; break check
.8730	f0 33		beq $8765			beq 	_CLExit
.8732	b2 30		lda ($30)			lda 	(codePtr)
.8734	f0 2f		beq $8765			beq 	_CLExit
.8736	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8738	20 68 87	jsr $8768			jsr 	CLCompareLineNo
.873b	90 1b		bcc $8758			bcc 	_CLNext
.873d	a2 07		ldx #$07			ldx 	#7
.873f	20 68 87	jsr $8768			jsr 	CLCompareLineNo
.8742	f0 02		beq $8746			beq 	_CLDoThisOne
.8744	b0 12		bcs $8758			bcs 	_CLNext
.8746					_CLDoThisOne:
.8746	20 10 8d	jsr $8d10			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8749	20 b3 b3	jsr $b3b3			jsr 	ListConvertLine 			; convert line into token Buffer
.874c	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.874e	a9 ab		lda #$ab			lda 	#(tokenBuffer & $FF)
.8750	20 c4 8d	jsr $8dc4			jsr 	PrintStringXA
.8753	a9 0d		lda #$0d			lda 	#13 						; new line
.8755	20 c7 a7	jsr $a7c7			jsr 	EXTPrintCharacter
.8758					_CLNext:
.8758	18		clc				clc
.8759	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.875b	65 30		adc $30				adc 	codePtr
.875d	85 30		sta $30				sta 	codePtr
.875f	90 02		bcc $8763			bcc 	_CREExit
.8761	e6 31		inc $31				inc 	codePtr+1
.8763					_CREExit:
.8763	80 c8		bra $872d			bra 	_CLLoop
.8765					_CLExit:
.8765	4c 58 83	jmp $8358			jmp 	WarmStart
.8768					CLCompareLineNo:
.8768	38		sec				sec
.8769	a0 01		ldy #$01			ldy 	#1
.876b	b1 30		lda ($30),y			lda 	(codePtr),y
.876d	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.8770	85 36		sta $36				sta 	zTemp0
.8772	c8		iny				iny
.8773	b1 30		lda ($30),y			lda 	(codePtr),y
.8775	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8778	05 36		ora $36				ora 	zTemp0
.877a	60		rts				rts
.877b					CLIsDigit:
.877b	b1 30		lda ($30),y			lda 	(codePtr),y
.877d	c9 30		cmp #$30			cmp 	#"0"
.877f	90 03		bcc $8784			bcc	 	_CLIDExitFalse
.8781	c9 3a		cmp #$3a			cmp 	#"9"+1
.8783	60		rts				rts
.8784					_CLIDExitFalse:
.8784	38		sec				sec
.8785	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8786					Command_LOCAL:
.8786	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8788	20 94 87	jsr $8794			jsr 	LocaliseNextTerm 			; convert term to a local.
.878b	b1 30		lda ($30),y			lda 	(codePtr),y
.878d	c8		iny				iny
.878e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8790	f0 f4		beq $8786			beq 	Command_LOCAL
.8792	88		dey				dey 								; unpick pre-get
.8793	60		rts				rts
.8794					LocaliseNextTerm:
.8794	20 f4 97	jsr $97f4			jsr 	EvaluateTerm 				; evaluate the term
.8797	bd 00 04	lda $0400,x			lda 	NSStatus,x
.879a	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.879c	f0 61		beq $87ff			beq		_LNTError
.879e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.87a1	85 36		sta $36				sta 	zTemp0
.87a3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87a6	85 37		sta $37				sta  	zTemp0+1
.87a8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.87ab	29 10		and #$10			and 	#NSBIsString
.87ad	d0 1e		bne $87cd			bne 	_LNTPushString
.87af	5a		phy				phy
.87b0	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.87b2					_LNTPushNumLoop:
.87b2	b1 36		lda ($36),y			lda		(zTemp0),y
.87b4	20 65 a6	jsr $a665			jsr 	StackPushByte
.87b7	c8		iny				iny
.87b8	c0 05		cpy #$05			cpy 	#5
.87ba	d0 f6		bne $87b2			bne 	_LNTPushNumLoop
.87bc	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.87be	20 65 a6	jsr $a665			jsr 	StackPushByte
.87c1	a5 37		lda $37				lda 	zTemp0+1
.87c3	20 65 a6	jsr $a665			jsr 	StackPushByte
.87c6	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.87c8	20 65 a6	jsr $a665			jsr 	StackPushByte
.87cb	7a		ply				ply
.87cc	60		rts				rts
.87cd					_LNTPushString:
.87cd	5a		phy				phy
.87ce	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.87d0	85 38		sta $38				sta 	zTemp1
.87d2	a0 01		ldy #$01			ldy 	#1
.87d4	b1 36		lda ($36),y			lda 	(zTemp0),y
.87d6	85 39		sta $39				sta 	zTemp1+1
.87d8	a0 00		ldy #$00			ldy 	#0 							; output string
.87da	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.87dc	f0 0a		beq $87e8			beq 	_LNTStringOut
.87de					_LNTPushStrLoop:
.87de	b1 38		lda ($38),y			lda 	(zTemp1),y
.87e0	f0 06		beq $87e8			beq 	_LNTStringOut
.87e2	20 65 a6	jsr $a665			jsr 	StackPushByte
.87e5	c8		iny				iny
.87e6	80 f6		bra $87de			bra 	_LNTPushStrLoop
.87e8					_LNTStringOut:
.87e8	98		tya				tya									; output length
.87e9	20 65 a6	jsr $a665			jsr 	StackPushByte
.87ec	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.87ef	20 65 a6	jsr $a665			jsr 	StackPushByte
.87f2	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.87f5	20 65 a6	jsr $a665			jsr 	StackPushByte
.87f8	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.87fa	20 65 a6	jsr $a665			jsr 	StackPushByte
.87fd	7a		ply				ply
.87fe	60		rts				rts
.87ff					_LNTError:
.87ff	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.8802					LocalPopValue:
.8802	20 7e a6	jsr $a67e			jsr 	StackPopByte
.8805	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8807	d0 17		bne $8820			bne 	_LPVString
.8809	20 7e a6	jsr $a67e			jsr 	StackPopByte 				; address
.880c	85 37		sta $37				sta 	zTemp0+1
.880e	20 7e a6	jsr $a67e			jsr 	StackPopByte
.8811	85 36		sta $36				sta 	zTemp0
.8813	5a		phy				phy
.8814	a0 04		ldy #$04			ldy 	#4 							; copy back
.8816					_LPVNumberCopy:
.8816	20 7e a6	jsr $a67e			jsr 	StackPopByte
.8819	91 36		sta ($36),y			sta 	(zTemp0),y
.881b	88		dey				dey
.881c	10 f8		bpl $8816			bpl 	_LPVNumberCopy
.881e	7a		ply				ply 								; and complete
.881f	60		rts				rts
.8820					_LPVString:
.8820	20 7e a6	jsr $a67e			jsr 	StackPopByte 				; address of record => zTemp0
.8823	85 37		sta $37				sta 	zTemp0+1
.8825	20 7e a6	jsr $a67e			jsr 	StackPopByte
.8828	85 36		sta $36				sta 	zTemp0
.882a	5a		phy				phy
.882b	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.882d	85 38		sta $38				sta 	zTemp1
.882f	a0 01		ldy #$01			ldy 	#1
.8831	b1 36		lda ($36),y			lda 	(zTemp0),y
.8833	85 39		sta $39				sta 	zTemp1+1
.8835	20 7e a6	jsr $a67e			jsr 	StackPopByte 				; # to get => y
.8838	a8		tay				tay
.8839	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.883b	f0 0e		beq $884b			beq 	_LPVStringCopied
.883d	a9 00		lda #$00			lda 	#0 							; NULL on end
.883f	91 38		sta ($38),y			sta 	(zTemp1),y
.8841					_LPVStringCopy:
.8841	88		dey				dey
.8842	30 07		bmi $884b			bmi 	_LPVStringCopied
.8844	20 7e a6	jsr $a67e			jsr 	StackPopByte
.8847	91 38		sta ($38),y			sta 	(zTemp1),y
.8849	80 f6		bra $8841			bra 	_LPVStringCopy
.884b					_LPVStringCopied:
.884b	fa		plx				plx
.884c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.884d					NewCommand:
.884d	20 53 88	jsr $8853			jsr 	NewProgram
.8850	4c 58 83	jmp $8358			jmp 	WarmStart
.8853					NewProgram:
.8853	20 a5 a5	jsr $a5a5			jsr 	MemoryNew
.8856	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8859	20 f1 83	jsr $83f1			jsr 	ClearCommand 				; clear everything.
.885c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/print.asm

.885d					Command_Print:
.885d	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.885e					_CPLoop:
.885e	08		php				php 								; save last action flag
.885f	b1 30		lda ($30),y			lda 	(codePtr),y
.8861	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8863	f0 46		beq $88ab			beq 	_CPExit
.8865	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8867	f0 42		beq $88ab			beq 	_CPExit
.8869	68		pla				pla 								; throw last action flag
.886a	b1 30		lda ($30),y			lda 	(codePtr),y
.886c	c8		iny				iny
.886d	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.886f	f0 37		beq $88a8			beq 	_CPContinueWithSameLine
.8871	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8873	f0 2e		beq $88a3			beq 	_CPTab
.8875	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8877	f0 26		beq $889f			beq 	_CPNewLine
.8879	88		dey				dey 								; undo the get.
.887a	a2 00		ldx #$00			ldx 	#0
.887c	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue 				; get a value into slot 0
.887f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.8882	29 10		and #$10			and 	#NSBIsString
.8884	f0 0b		beq $8891			beq 	_CPNumber
.8886	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.8889	ad 08 04	lda $0408			lda 	NSMantissa0
.888c	20 b4 88	jsr $88b4			jsr 	CPPrintStringXA
.888f	80 cc		bra $885d			bra 	Command_Print 				; loop round clearing carry so NL if end
.8891					_CPNumber:
.8891	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8893	20 24 9c	jsr $9c24			jsr 	ConvertNumberToString 		; convert to string
.8896	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8898	a9 1b		lda #$1b			lda 	#DecimalBuffer & $FF
.889a	20 b4 88	jsr $88b4			jsr 	CPPrintStringXA
.889d	80 be		bra $885d			bra 	Command_Print 				; loop round clearing carry so NL if end
.889f					_CPNewLine:
.889f	a9 0d		lda #$0d			lda 	#13
.88a1	80 02		bra $88a5			bra 	_CPPrintChar
.88a3					_CPTab:
.88a3	a9 09		lda #$09			lda 	#9 							; print TAB
.88a5					_CPPrintChar:
.88a5	20 c7 88	jsr $88c7			jsr 	CPPrintVector
.88a8					_CPContinueWithSameLine:
.88a8	38		sec				sec 								; loop round with carry set, which
.88a9	80 b3		bra $885e			bra 	_CPLoop 					; will inhibit final CR
.88ab					_CPExit:
.88ab	28		plp				plp 								; get last action flag
.88ac	b0 05		bcs $88b3			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.88ae	a9 0d		lda #$0d			lda 	#13 						; print new line
.88b0	20 c7 88	jsr $88c7			jsr 	CPPrintVector
.88b3					_CPExit2:
.88b3	60		rts				rts
.88b4					CPPrintStringXA:
.88b4	5a		phy				phy
.88b5	86 37		stx $37				stx 	zTemp0+1
.88b7	85 36		sta $36				sta 	zTemp0
.88b9	a0 00		ldy #$00			ldy 	#0
.88bb					_PSXALoop:
.88bb	b1 36		lda ($36),y			lda 	(zTemp0),y
.88bd	f0 06		beq $88c5			beq 	_PSXAExit
.88bf	20 c7 88	jsr $88c7			jsr 	CPPrintVector
.88c2	c8		iny				iny
.88c3	80 f6		bra $88bb			bra 	_PSXALoop
.88c5					_PSXAExit:
.88c5	7a		ply				ply
.88c6	60		rts				rts
.88c7					CPPrintVector:
.88c7	4c c7 a7	jmp $a7c7			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.88ca					CallProcedure:
.88ca	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.88cc	b1 30		lda ($30),y			lda 	(codePtr),y
.88ce	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.88d0	f0 0c		beq $88de			beq 	_CPEndParam
.88d2					_CPParamLoop:
.88d2	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue 				; get parameter onto stack
.88d5	e8		inx				inx 								; bump next stack
.88d6	b1 30		lda ($30),y			lda 	(codePtr),y
.88d8	c8		iny				iny
.88d9	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.88db	f0 f5		beq $88d2			beq 	_CPParamLoop
.88dd	88		dey				dey 								; unpick.
.88de					_CPEndParam:
.88de	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.88e1	c8		iny				iny									; skip right bracket
.88e2	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.88e4	20 87 a6	jsr $a687			jsr 	StackOpen
.88e7	20 cb a6	jsr $a6cb			jsr 	STKSaveCodePosition 		; save loop position
.88ea	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.88ed	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.88ef	ad 10 04	lda $0410			lda 	NSMantissa1
.88f2	85 37		sta $37				sta 	zTemp0+1
.88f4	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.88f6	b2 36		lda ($36)			lda 	(zTemp0)
.88f8	85 30		sta $30				sta 	safePtr
.88fa	b1 36		lda ($36),y			lda 	(zTemp0),y
.88fc	85 31		sta $31				sta 	safePtr+1
.88fe	c8		iny				iny
.88ff	b1 36		lda ($36),y			lda 	(zTemp0),y
.8901	85 32		sta $32				sta 	safePtr+2
.8903	c8		iny				iny
.8904	b1 36		lda ($36),y			lda 	(zTemp0),y
.8906	85 33		sta $33				sta 	safePtr+3
.8908	c8		iny				iny 								; get Y offset -> Y
.8909	b1 36		lda ($36),y			lda 	(zTemp0),y
.890b	a8		tay				tay
.890c	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.890e	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.8911	f0 13		beq $8926			beq 	_ParamExit 					; if so, exit.
.8913					_ParamExtract:
.8913	ca		dex				dex 								; put a local term on the level before
.8914	20 94 87	jsr $8794			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8917	20 cc 86	jsr $86cc			jsr 	AssignVariable 				; assign stacked value to the variable.
.891a	e8		inx				inx 								; advance to next parameter to do.
.891b	e8		inx				inx
.891c	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.891f	f0 05		beq $8926			beq 	_ParamExit
.8921	20 5a 8d	jsr $8d5a			jsr 	CheckComma 					; comma seperating parameters
.8924	80 ed		bra $8913			bra 	_ParamExtract
.8926					_ParamExit:
.8926	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; check )
.8929	60		rts				rts 								; and continue from here
.892a					Command_ENDPROC:
.892a	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.892c	a2 14		ldx #$14			ldx 	#ERRID_PROC
.892e	20 b3 a6	jsr $a6b3			jsr 	StackCheckFrame
.8931	20 dc a6	jsr $a6dc			jsr 	STKLoadCodePosition 		; restore code position
.8934	20 a5 a6	jsr $a6a5			jsr 	StackClose
.8937	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8938					Command_Read:
.8938	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.893a	20 f4 97	jsr $97f4			jsr 	EvaluateTerm
.893d	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8940	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8942	f0 4a		beq $898e			beq 	_CRSyntax 					; check reference (bit 0)
.8944	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs 			; swap code and data
.8947	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.894a	d0 20		bne $896c			bne 	_CRContinueData
.894c					_CRKeepSearching:
.894c	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.894e	aa		tax				tax
.894f	20 ad 8c	jsr $8cad			jsr 	ScanForward
.8952	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8954	f0 16		beq $896c			beq 	_CRHaveData 				; found it
.8956	18		clc				clc
.8957	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8959	65 30		adc $30				adc 	codePtr
.895b	85 30		sta $30				sta 	codePtr
.895d	90 02		bcc $8961			bcc 	_CREExit
.895f	e6 31		inc $31				inc 	codePtr+1
.8961					_CREExit:
.8961	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8963	b2 30		lda ($30)			lda 	(codePtr)
.8965	d0 e5		bne $894c			bne 	_CRKeepSearching
.8967	a9 0b		lda #$0b		lda	#11
.8969	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.896c					_CRHaveData:
.896c					_CRContinueData:
.896c	a2 01		ldx #$01			ldx 	#1
.896e	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8971	ca		dex				dex
.8972	20 cc 86	jsr $86cc			jsr		AssignVariable 				; do the assignment
.8975	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.8978	b1 30		lda ($30),y			lda 	(codePtr),y
.897a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.897c	d0 04		bne $8982			bne 	_CRSwapBack
.897e	c8		iny				iny 								; consume comma
.897f	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8982					_CRSwapBack:
.8982	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs			; swap them back.
.8985	b1 30		lda ($30),y			lda 	(codePtr),y
.8987	c8		iny				iny
.8988	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.898a	f0 ac		beq $8938			beq 	Command_Read 				; if so go round again.
.898c	88		dey				dey 								; unpick get.
.898d	60		rts				rts
.898e					_CRSyntax:
.898e	4c b8 9f	jmp $9fb8			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8991					RemCommand:
.8991	b1 30		lda ($30),y			lda 	(codePtr),y
.8993	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8995	d0 06		bne $899d			bne 	_RMExit
.8997	c8		iny				iny
.8998	98		tya				tya
.8999	38		sec				sec
.899a	71 30		adc ($30),y			adc 	(codePtr),y
.899c	a8		tay				tay
.899d					_RMExit:
.899d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.899e					Command_REPEAT:
.899e	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.89a0	20 87 a6	jsr $a687			jsr 	StackOpen
.89a3	20 cb a6	jsr $a6cb			jsr 	STKSaveCodePosition 		; save loop position
.89a6	60		rts				rts
.89a7					Command_UNTIL:
.89a7	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.89a9	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.89ab	20 b3 a6	jsr $a6b3			jsr 	StackCheckFrame
.89ae	a2 00		ldx #$00			ldx 	#0
.89b0	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; work out the number
.89b3	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; check if zero
.89b6	f0 04		beq $89bc			beq 	_CULoopBack 				; if so keep looping
.89b8	20 a5 a6	jsr $a6a5			jsr 	StackClose		 			; return
.89bb	60		rts				rts
.89bc					_CULoopBack:
.89bc	20 dc a6	jsr $a6dc			jsr 	STKLoadCodePosition 		; loop back
.89bf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.89c0					Command_Restore:
.89c0	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs 			; swap code and data
.89c3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.89c5	85 30		sta $30				sta 	codePtr
.89c7	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.89c9	85 31		sta $31				sta 	codePtr+1
.89cb	20 d7 89	jsr $89d7			jsr 	SwapDataCodePtrs 			; put them back
.89ce	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.89d0	8d 9b 04	sta $049b			sta 	dataPointer+4
.89d3	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.89d6	60		rts				rts
.89d7					SwapDataCodePtrs:
.89d7	da		phx				phx
.89d8	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.89da					_SDCPLoop:
.89da	b5 30		lda $30,x			lda 	safePtr,x
.89dc	48		pha				pha
.89dd	bd 97 04	lda $0497,x			lda 	dataPointer,x
.89e0	95 30		sta $30,x			sta 	safePtr,x
.89e2	68		pla				pla
.89e3	9d 97 04	sta $0497,x			sta 	dataPointer,x
.89e6	ca		dex				dex
.89e7	10 f1		bpl $89da			bpl 	_SDCPLoop
.89e9	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.89ec	8c 9b 04	sty $049b			sty 	dataPointer+4
.89ef	a8		tay				tay
.89f0	fa		plx				plx
.89f1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.89f2					EOLCommand:
.89f2	18		clc				clc
.89f3	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.89f5	65 30		adc $30				adc 	codePtr
.89f7	85 30		sta $30				sta 	codePtr
.89f9	90 02		bcc $89fd			bcc 	_CREExit
.89fb	e6 31		inc $31				inc 	codePtr+1
.89fd					_CREExit:
.89fd	80 0b		bra $8a0a			bra 	RunNewLine
.89ff					CommandRUN:
.89ff	20 f1 83	jsr $83f1			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a02	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a04	85 30		sta $30				sta 	codePtr
.8a06	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a08	85 31		sta $31				sta 	codePtr+1
.8a0a					RUNNewLine:
.8a0a	b2 30		lda ($30)			lda 	(codePtr)
.8a0c	f0 74		beq $8a82			beq 	CRNoProgram         		; no then END.
.8a0e	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a10	9a		txs				txs
.8a11					RUNCodePointerLine:
.8a11	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a13					_CRIncMainLoop:
.8a13	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8a16	d0 1b		bne $8a33			bne 	_CRNoBreakCheck
.8a18	20 69 aa	jsr $aa69			jsr 	EXTBreakCheck 				; break check
.8a1b	f0 60		beq $8a7d			beq 	_CRBreak
.8a1d	64 01		stz $01				stz 	1 							; access I/O Page 0
.8a1f	38		sec				sec
.8a20	ad 59 d6	lda $d659			lda 	$D659
.8a23	aa		tax				tax
.8a24	ed 2d 06	sbc $062d			sbc 	LastTick
.8a27	c9 07		cmp #$07			cmp 	#7
.8a29	90 08		bcc $8a33			bcc 	_NoFireTick
.8a2b	8e 2d 06	stx $062d			stx 	LastTick
.8a2e	a9 2a		lda #$2a			lda 	#42
.8a30	20 c7 a7	jsr $a7c7			jsr 	EXTPrintCharacter
.8a33					_NoFireTick:
.8a33					_CRNoBreakCheck:
.8a33	c8		iny				iny
.8a34					_CRMainLoop:
.8a34	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8a37	b1 30		lda ($30),y			lda 	(codePtr),y
.8a39	10 10		bpl $8a4b			bpl 	_CRNotKeyword
.8a3b	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8a3d	b0 04		bcs $8a43			bcs 	_CRIsKeyword
.8a3f	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8a41	b0 34		bcs $8a77			bcs		_CRSyntaxError
.8a43					_CRIsKeyword:
.8a43	c8		iny				iny 								; consume command
.8a44	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8a45	aa		tax				tax 								; put in X for vector jump
.8a46	20 7a 8a	jsr $8a7a			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8a49	80 e9		bra $8a34			bra 	_CRMainLoop 				; and loop round
.8a4b					_CRNotKeyword:
.8a4b	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8a4d	f0 c4		beq $8a13			beq 	_CRIncMainLoop
.8a4f	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8a51	90 05		bcc $8a58			bcc 	_CRNotVariable
.8a53					_CRGoLet:
.8a53	20 90 86	jsr $8690			jsr 	LetCommand
.8a56	80 dc		bra $8a34			bra 	_CRMainLoop
.8a58					_CRNotVariable:
.8a58	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8a5a	f0 f7		beq $8a53			beq 	_CRGoLet
.8a5c	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8a5e	f0 f3		beq $8a53			beq 	_CRGoLet
.8a60	c9 21		cmp #$21			cmp 	#KWD_PLING
.8a62	f0 ef		beq $8a53			beq 	_CRGoLet
.8a64	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8a66	f0 09		beq $8a71			beq 	_CRGoRem
.8a68	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8a6a	d0 0b		bne $8a77			bne 	_CRSyntaxError
.8a6c	20 11 82	jsr $8211			jsr 	LabelHere
.8a6f	80 c3		bra $8a34			bra 	_CRMainLoop
.8a71					_CRGoRem:
.8a71	c8		iny				iny
.8a72	20 91 89	jsr $8991			jsr 	RemCommand
.8a75	80 bd		bra $8a34			bra 	_CRMainLoop
.8a77					_CRSyntaxError:
.8a77	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.8a7a					_CRCallVector0:
.8a7a	7c 18 8b	jmp ($8b18,x)			jmp 	(VectorSet0,x)
.8a7d					_CRBreak:
.8a7d	a9 01		lda #$01		lda	#1
.8a7f	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.8a82					CRNoProgram:
.8a82	4c 16 85	jmp $8516			jmp 	EndCommand
.8a85					Shift1Command:
.8a85	b1 30		lda ($30),y			lda 	(codePtr),y
.8a87	c8		iny				iny
.8a88	0a		asl a				asl 	a
.8a89	aa		tax				tax
.8a8a	7c b4 8b	jmp ($8bb4,x)			jmp 	(VectorSet1,x)
.8a8d					Shift2Command:
.8a8d	b1 30		lda ($30),y			lda 	(codePtr),y
.8a8f	c8		iny				iny
.8a90	0a		asl a				asl 	a
.8a91	aa		tax				tax
.8a92	7c ce 8b	jmp ($8bce,x)			jmp 	(VectorSet2,x)
.8a95					Unused1:
.8a95					Unused2:
.8a95					Unused3:
.8a95					Unused4:
.8a95	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
>8a98							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8a98					VectorSetPunc:
>8a98	58 90					.word	ShiftLeft                        ; $00 <<
>8a9a	0f 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8a9c	05 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8a9e	b8 9f					.word	SyntaxError                      ; $03 !!3
>8aa0	b8 9f					.word	SyntaxError                      ; $04 ><
>8aa2	19 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8aa4	5b 90					.word	ShiftRight                       ; $06 >>
>8aa6	b8 9f					.word	SyntaxError                      ; $07 !!7
>8aa8	b8 9f					.word	SyntaxError                      ; $08 !!8
>8aaa	b8 9f					.word	SyntaxError                      ; $09 !!9
>8aac	b8 9f					.word	SyntaxError                      ; $0a !!10
>8aae	b8 9f					.word	SyntaxError                      ; $0b !!11
>8ab0	b8 9f					.word	SyntaxError                      ; $0c !!12
>8ab2	b8 9f					.word	SyntaxError                      ; $0d !!13
>8ab4	b8 9f					.word	SyntaxError                      ; $0e !!14
>8ab6	b8 9f					.word	SyntaxError                      ; $0f !!15
>8ab8	b8 9f					.word	SyntaxError                      ; $10 @
>8aba	b8 9f					.word	SyntaxError                      ; $11 !!17
>8abc	b8 9f					.word	SyntaxError                      ; $12 !!18
>8abe	b8 9f					.word	SyntaxError                      ; $13 [
>8ac0	dc 8e					.word	IntegerDivide                    ; $14 \
>8ac2	b8 9f					.word	SyntaxError                      ; $15 ]
>8ac4	e9 91					.word	EorInteger                       ; $16 ^
>8ac6	b8 9f					.word	SyntaxError                      ; $17 _
>8ac8	b8 9f					.word	SyntaxError                      ; $18 `
>8aca	b8 9f					.word	SyntaxError                      ; $19 !!25
>8acc	b8 9f					.word	SyntaxError                      ; $1a !!26
>8ace	b8 9f					.word	SyntaxError                      ; $1b {
>8ad0	a3 91					.word	OraInteger                       ; $1c |
>8ad2	b8 9f					.word	SyntaxError                      ; $1d }
>8ad4	b8 9f					.word	SyntaxError                      ; $1e ~
>8ad6	b8 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8ad8	b8 9f					.word	SyntaxError                      ; $20
>8ada	2f 92					.word	WordIndirect                     ; $21 !
>8adc	b8 9f					.word	SyntaxError                      ; $22 "
>8ade	b8 9f					.word	SyntaxError                      ; $23 #
>8ae0	b8 9f					.word	SyntaxError                      ; $24 $
>8ae2	29 8f					.word	IntegerModulus                   ; $25 %
>8ae4	5d 91					.word	AndInteger                       ; $26 &
>8ae6	b8 9f					.word	SyntaxError                      ; $27 '
>8ae8	b8 9f					.word	SyntaxError                      ; $28 (
>8aea	b8 9f					.word	SyntaxError                      ; $29 )
>8aec	9e 8f					.word	MulInteger                       ; $2a *
>8aee	ef 90					.word	AddInteger                       ; $2b +
>8af0	b8 9f					.word	SyntaxError                      ; $2c ,
>8af2	32 91					.word	SubInteger                       ; $2d -
>8af4	b8 9f					.word	SyntaxError                      ; $2e .
>8af6	1a 94					.word	FDivideCommand                   ; $2f /
>8af8	b8 9f					.word	SyntaxError                      ; $30 0
>8afa	b8 9f					.word	SyntaxError                      ; $31 1
>8afc	b8 9f					.word	SyntaxError                      ; $32 2
>8afe	b8 9f					.word	SyntaxError                      ; $33 3
>8b00	b8 9f					.word	SyntaxError                      ; $34 4
>8b02	b8 9f					.word	SyntaxError                      ; $35 5
>8b04	b8 9f					.word	SyntaxError                      ; $36 6
>8b06	b8 9f					.word	SyntaxError                      ; $37 7
>8b08	b8 9f					.word	SyntaxError                      ; $38 8
>8b0a	b8 9f					.word	SyntaxError                      ; $39 9
>8b0c	b8 9f					.word	SyntaxError                      ; $3a :
>8b0e	b8 9f					.word	SyntaxError                      ; $3b ;
>8b10	f1 8d					.word	BinaryCompareLess                ; $3c <
>8b12	e7 8d					.word	BinaryCompareEqual               ; $3d =
>8b14	fb 8d					.word	BinaryCompareGreater             ; $3e >
>8b16	56 92					.word	ByteIndirect                     ; $3f ?
.8b18					VectorSet0:
>8b18	f2 89					.word	EOLCommand                       ; $80 !0:EOF
>8b1a	85 8a					.word	Shift1Command                    ; $81 !1:SH1
>8b1c	8d 8a					.word	Shift2Command                    ; $82 !2:SH2
>8b1e	8a 99					.word	AbsUnary                         ; $83 ABS(
>8b20	9a 99					.word	AllocUnary                       ; $84 ALLOC(
>8b22	0a 9a					.word	AscUnary                         ; $85 ASC(
>8b24	d5 9b					.word	ChrUnary                         ; $86 CHR$(
>8b26	28 a4					.word	UnaryEvent                       ; $87 EVENT(
>8b28	e3 8d					.word	UnaryFalse                       ; $88 FALSE
>8b2a	17 9a					.word	FracUnary                        ; $89 FRAC(
>8b2c	be a3					.word	UnaryHit                         ; $8a HIT(
>8b2e	2d 9a					.word	IntUnary                         ; $8b INT(
>8b30	94 9b					.word	IsValUnary                       ; $8c ISVAL(
>8b32	b8 a4					.word	UnaryJoyB                        ; $8d JOYB(
>8b34	91 a4					.word	UnaryJoyX                        ; $8e JOYX(
>8b36	94 a4					.word	UnaryJoyY                        ; $8f JOYY(
>8b38	af 9c					.word	Unary_Left                       ; $90 LEFT$(
>8b3a	3f 9a					.word	LenUnary                         ; $91 LEN(
>8b3c	5d 9a					.word	Unary_Max                        ; $92 MAX(
>8b3e	d9 9c					.word	Unary_Mid                        ; $93 MID$(
>8b40	59 9a					.word	Unary_Min                        ; $94 MIN(
>8b42	b4 9a					.word	Unary_Not                        ; $95 NOT(
>8b44	b8 9f					.word	SyntaxError                      ; $96 PLAYING(
>8b46	ca 9a					.word	Unary_Random                     ; $97 RANDOM(
>8b48	bf 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8b4a	e9 9a					.word	Unary_Rnd                        ; $99 RND(
>8b4c	6a 9b					.word	SgnUnary                         ; $9a SGN(
>8b4e	e7 9b					.word	SpcUnary                         ; $9b SPC(
>8b50	02 9c					.word	Unary_Str                        ; $9c STR$(
>8b52	cc a4					.word	UnaryTimer                       ; $9d TIMER(
>8b54	d7 8d					.word	UnaryTrue                        ; $9e TRUE
>8b56	8a 9b					.word	ValUnary                         ; $9f VAL(
>8b58	19 85					.word	ForCommand                       ; $a0 FOR
>8b5a	66 86					.word	IfCommand                        ; $a1 IF
>8b5c	95 8a					.word	Unused1                          ; $a2 PROC
>8b5e	9e 89					.word	Command_REPEAT                   ; $a3 REPEAT
>8b60	23 8d					.word	Command_WHILE                    ; $a4 WHILE
>8b62	8f 86					.word	EndIf                            ; $a5 ENDIF
>8b64	2a 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8b66	d3 85					.word	NextCommand                      ; $a7 NEXT
>8b68	95 8a					.word	Unused4                          ; $a8 THEN
>8b6a	a7 89					.word	Command_UNTIL                    ; $a9 UNTIL
>8b6c	44 8d					.word	Command_WEND                     ; $aa WEND
>8b6e	b8 9f					.word	SyntaxError                      ; $ab BY
>8b70	b7 83					.word	CallCommand                      ; $ac CALL
>8b72	60 a1					.word	CircleCommand                    ; $ad CIRCLE
>8b74	f1 83					.word	ClearCommand                     ; $ae CLEAR
>8b76	49 84					.word	ClearScreen                      ; $af CLS
>8b78	b8 9f					.word	SyntaxError                      ; $b0 COLOR
>8b7a	b8 9f					.word	SyntaxError                      ; $b1 COLOUR
>8b7c	51 84					.word	Command_Data                     ; $b2 DATA
>8b7e	59 84					.word	DimCommand                       ; $b3 DIM
>8b80	95 8a					.word	Unused3                          ; $b4 DOWNTO
>8b82	88 86					.word	ElseCode                         ; $b5 ELSE
>8b84	b8 9f					.word	SyntaxError                      ; $b6 FROM
>8b86	8c a3					.word	GfxCommand                       ; $b7 GFX
>8b88	2c 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8b8a	4a 86					.word	GotoCommand                      ; $b9 GOTO
>8b8c	b8 9f					.word	SyntaxError                      ; $ba HERE
>8b8e	8a a1					.word	ImageCommand                     ; $bb IMAGE
>8b90	90 86					.word	LetCommand                       ; $bc LET
>8b92	df a1					.word	LineCommand                      ; $bd LINE
>8b94	86 87					.word	Command_LOCAL                    ; $be LOCAL
>8b96	b8 9f					.word	SyntaxError                      ; $bf OFF
>8b98	b8 9f					.word	SyntaxError                      ; $c0 ON
>8b9a	b8 9f					.word	SyntaxError                      ; $c1 OUTLINE
>8b9c	e4 a3					.word	PaletteCommand                   ; $c2 PALETTE
>8b9e	d8 a1					.word	PlotCommand                      ; $c3 PLOT
>8ba0	5d 88					.word	Command_Print                    ; $c4 PRINT
>8ba2	38 89					.word	Command_Read                     ; $c5 READ
>8ba4	5c a1					.word	RectangleCommand                 ; $c6 RECT
>8ba6	91 89					.word	RemCommand                       ; $c7 REM
>8ba8	3c 86					.word	Command_RETURN                   ; $c8 RETURN
>8baa	b8 9f					.word	SyntaxError                      ; $c9 SOLID
>8bac	fa a5					.word	SoundCommand                     ; $ca SOUND
>8bae	6b a1					.word	SpriteCommand                    ; $cb SPRITE
>8bb0	a7 a1					.word	TextCommand                      ; $cc TEXT
>8bb2	95 8a					.word	Unused2                          ; $cd TO
.8bb4					VectorSet1:
>8bb4	b8 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bb6	b8 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bb8	b8 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bba	88 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8bbc	a7 83					.word	AssertCommand                    ; $84 ASSERT
>8bbe	2c a3					.word	BitmapCtrl                       ; $85 BITMAP
>8bc0	16 85					.word	EndCommand                       ; $86 END
>8bc2	e5 86					.word	Command_List                     ; $87 LIST
>8bc4	4d 88					.word	NewCommand                       ; $88 NEW
>8bc6	c0 89					.word	Command_Restore                  ; $89 RESTORE
>8bc8	ff 89					.word	CommandRUN                       ; $8a RUN
>8bca	71 a3					.word	SpritesCtrl                      ; $8b SPRITES
>8bcc	56 8c					.word	StopCommand                      ; $8c STOP
.8bce					VectorSet2:
>8bce	b8 9f					.word	SyntaxError                      ; $80 !0:EOF
>8bd0	b8 9f					.word	SyntaxError                      ; $81 !1:SH1
>8bd2	b8 9f					.word	SyntaxError                      ; $82 !2:SH2
>8bd4	77 9e					.word	Assemble_adc                     ; $83 ADC
>8bd6	6f 9e					.word	Assemble_and                     ; $84 AND
>8bd8	8b 9e					.word	Assemble_asl                     ; $85 ASL
>8bda	f5 9e					.word	Assemble_bcc                     ; $86 BCC
>8bdc	f9 9e					.word	Assemble_bcs                     ; $87 BCS
>8bde	01 9f					.word	Assemble_beq                     ; $88 BEQ
>8be0	b8 9e					.word	Assemble_bit                     ; $89 BIT
>8be2	e9 9e					.word	Assemble_bmi                     ; $8a BMI
>8be4	fd 9e					.word	Assemble_bne                     ; $8b BNE
>8be6	e5 9e					.word	Assemble_bpl                     ; $8c BPL
>8be8	05 9f					.word	Assemble_bra                     ; $8d BRA
>8bea	09 9f					.word	Assemble_brk                     ; $8e BRK
>8bec	ed 9e					.word	Assemble_bvc                     ; $8f BVC
>8bee	f1 9e					.word	Assemble_bvs                     ; $90 BVS
>8bf0	11 9f					.word	Assemble_clc                     ; $91 CLC
>8bf2	65 9f					.word	Assemble_cld                     ; $92 CLD
>8bf4	25 9f					.word	Assemble_cli                     ; $93 CLI
>8bf6	55 9f					.word	Assemble_clv                     ; $94 CLV
>8bf8	83 9e					.word	Assemble_cmp                     ; $95 CMP
>8bfa	cc 9e					.word	Assemble_cpx                     ; $96 CPX
>8bfc	c7 9e					.word	Assemble_cpy                     ; $97 CPY
>8bfe	a9 9e					.word	Assemble_dec                     ; $98 DEC
>8c00	61 9f					.word	Assemble_dex                     ; $99 DEX
>8c02	3d 9f					.word	Assemble_dey                     ; $9a DEY
>8c04	73 9e					.word	Assemble_eor                     ; $9b EOR
>8c06	ae 9e					.word	Assemble_inc                     ; $9c INC
>8c08	71 9f					.word	Assemble_inx                     ; $9d INX
>8c0a	5d 9f					.word	Assemble_iny                     ; $9e INY
>8c0c	e0 9e					.word	Assemble_jmp                     ; $9f JMP
>8c0e	db 9e					.word	Assemble_jsr                     ; $a0 JSR
>8c10	7f 9e					.word	Assemble_lda                     ; $a1 LDA
>8c12	a4 9e					.word	Assemble_ldx                     ; $a2 LDX
>8c14	c2 9e					.word	Assemble_ldy                     ; $a3 LDY
>8c16	95 9e					.word	Assemble_lsr                     ; $a4 LSR
>8c18	75 9f					.word	Assemble_nop                     ; $a5 NOP
>8c1a	6b 9e					.word	Assemble_ora                     ; $a6 ORA
>8c1c	21 9f					.word	Assemble_pha                     ; $a7 PHA
>8c1e	0d 9f					.word	Assemble_php                     ; $a8 PHP
>8c20	69 9f					.word	Assemble_phx                     ; $a9 PHX
>8c22	29 9f					.word	Assemble_phy                     ; $aa PHY
>8c24	31 9f					.word	Assemble_pla                     ; $ab PLA
>8c26	15 9f					.word	Assemble_plp                     ; $ac PLP
>8c28	7d 9f					.word	Assemble_plx                     ; $ad PLX
>8c2a	39 9f					.word	Assemble_ply                     ; $ae PLY
>8c2c	90 9e					.word	Assemble_rol                     ; $af ROL
>8c2e	9a 9e					.word	Assemble_ror                     ; $b0 ROR
>8c30	1d 9f					.word	Assemble_rti                     ; $b1 RTI
>8c32	2d 9f					.word	Assemble_rts                     ; $b2 RTS
>8c34	87 9e					.word	Assemble_sbc                     ; $b3 SBC
>8c36	19 9f					.word	Assemble_sec                     ; $b4 SEC
>8c38	79 9f					.word	Assemble_sed                     ; $b5 SED
>8c3a	35 9f					.word	Assemble_sei                     ; $b6 SEI
>8c3c	7b 9e					.word	Assemble_sta                     ; $b7 STA
>8c3e	6d 9f					.word	Assemble_stp                     ; $b8 STP
>8c40	9f 9e					.word	Assemble_stx                     ; $b9 STX
>8c42	bd 9e					.word	Assemble_sty                     ; $ba STY
>8c44	b3 9e					.word	Assemble_stz                     ; $bb STZ
>8c46	51 9f					.word	Assemble_tax                     ; $bc TAX
>8c48	4d 9f					.word	Assemble_tay                     ; $bd TAY
>8c4a	d6 9e					.word	Assemble_trb                     ; $be TRB
>8c4c	d1 9e					.word	Assemble_tsb                     ; $bf TSB
>8c4e	59 9f					.word	Assemble_tsx                     ; $c0 TSX
>8c50	41 9f					.word	Assemble_txa                     ; $c1 TXA
>8c52	49 9f					.word	Assemble_txs                     ; $c2 TXS
>8c54	45 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8c56					StopCommand:
.8c56	a9 08		lda #$08		lda	#8
.8c58	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8c5b					ProcedureScan:
.8c5b	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8c5d	85 30		sta $30				sta 	codePtr
.8c5f	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8c61	85 31		sta $31				sta 	codePtr+1
.8c63					_PSLoop:
.8c63	b2 30		lda ($30)			lda 	(codePtr)
.8c65	f0 42		beq $8ca9			beq 	_PSExit
.8c67	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8c69	b1 30		lda ($30),y			lda 	(codePtr),y
.8c6b	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8c6d	d0 2d		bne $8c9c			bne 	_PSNext
.8c6f	c8		iny				iny 								; get the address of the record to zTemp0 and
.8c70	b1 30		lda ($30),y			lda 	(codePtr),y
.8c72	29 c0		and #$c0			and 	#$C0
.8c74	c9 40		cmp #$40			cmp 	#$40
.8c76	d0 32		bne $8caa			bne 	_PSSyntax
.8c78	b1 30		lda ($30),y			lda 	(codePtr),y
.8c7a	18		clc				clc
.8c7b	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8c7d	85 37		sta $37				sta 	zTemp0+1
.8c7f	c8		iny				iny 								; LSB
.8c80	b1 30		lda ($30),y			lda 	(codePtr),y
.8c82	85 36		sta $36				sta 	zTemp0
.8c84	c8		iny				iny 								; character after variable call.
.8c85	98		tya				tya 								; save Y offset at +7
.8c86	a0 07		ldy #$07			ldy 	#7
.8c88	91 36		sta ($36),y			sta 	(zTemp0),y
.8c8a	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8c8c	a0 02		ldy #$02			ldy 	#2
.8c8e	91 36		sta ($36),y			sta 	(zTemp0),y
.8c90	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8c92					_PSCopy:
.8c92	b5 30		lda $30,x			lda 	safePtr,x
.8c94	c8		iny				iny
.8c95	91 36		sta ($36),y			sta 	(zTemp0),y
.8c97	e8		inx				inx
.8c98	e0 04		cpx #$04			cpx 	#4
.8c9a	d0 f6		bne $8c92			bne 	_PSCopy
.8c9c					_PSNext:
.8c9c	18		clc				clc
.8c9d	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8c9f	65 30		adc $30				adc 	codePtr
.8ca1	85 30		sta $30				sta 	codePtr
.8ca3	90 02		bcc $8ca7			bcc 	_CREExit
.8ca5	e6 31		inc $31				inc 	codePtr+1
.8ca7					_CREExit:
.8ca7	80 ba		bra $8c63			bra 	_PSLoop
.8ca9					_PSExit:
.8ca9	60		rts				rts
.8caa					_PSSyntax:
.8caa	4c b8 9f	jmp $9fb8			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8cad					ScanForward:
.8cad	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8caf	86 37		stx $37				stx 	zTemp0+1
.8cb1	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8cb3					_ScanLoop:
.8cb3	b1 30		lda ($30),y			lda 	(codePtr),y
.8cb5	c8		iny				iny
.8cb6	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8cb8	d0 0e		bne $8cc8			bne 	_ScanGoNext
.8cba	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8cbc	f0 04		beq $8cc2			beq 	_ScanMatch
.8cbe	c5 37		cmp $37				cmp 	zTemp0+1
.8cc0	d0 06		bne $8cc8			bne 	_ScanGoNext
.8cc2					_ScanMatch:
.8cc2	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8cc4	d0 01		bne $8cc7			bne 	_ScanNotEndEOL
.8cc6	88		dey				dey
.8cc7					_ScanNotEndEOL:
.8cc7	60		rts				rts
.8cc8					_ScanGoNext:
.8cc8	20 cd 8c	jsr $8ccd			jsr  	ScanForwardOne
.8ccb	80 e6		bra $8cb3			bra 	_ScanLoop
.8ccd					ScanForwardOne:
.8ccd	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8ccf	90 3e		bcc $8d0f			bcc 	_SFWExit
.8cd1	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8cd3	90 18		bcc $8ced			bcc 	_ScanSkipOne
.8cd5	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8cd7	b0 2f		bcs $8d08			bcs 	_ScanSkipData
.8cd9	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8cdb	90 32		bcc $8d0f			bcc 	_SFWExit 					; if not, ordinary keywords.
.8cdd	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8cdf	b0 2e		bcs $8d0f			bcs 	_SFWExit
.8ce1	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8ce3	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8ce5	b0 28		bcs $8d0f			bcs 	_SFWExit
.8ce7	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8ce9	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8ceb	80 22		bra $8d0f			bra 	_SFWExit
.8ced					_ScanSkipOne:
.8ced	c8		iny				iny 								; consume the extra one.
.8cee	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8cf0	d0 1d		bne $8d0f			bne 	_SFWExit
.8cf2	18		clc				clc
.8cf3	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8cf5	65 30		adc $30				adc 	codePtr
.8cf7	85 30		sta $30				sta 	codePtr
.8cf9	90 02		bcc $8cfd			bcc 	_CREExit
.8cfb	e6 31		inc $31				inc 	codePtr+1
.8cfd					_CREExit:
.8cfd	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8cff	b2 30		lda ($30)			lda 	(codePtr)
.8d01	d0 0c		bne $8d0f			bne 	_SFWExit 					; if not zero, more to scan
.8d03	a9 13		lda #$13		lda	#19
.8d05	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.8d08					_ScanSkipData:
.8d08	88		dey				dey 								; point at data token
.8d09	c8		iny				iny
.8d0a	98		tya				tya
.8d0b	38		sec				sec
.8d0c	71 30		adc ($30),y			adc 	(codePtr),y
.8d0e	a8		tay				tay
.8d0f					_SFWExit:
.8d0f	60		rts				rts
.8d10					ScanGetCurrentLineStep:
.8d10	64 38		stz $38				stz 	zTemp1
.8d12	a0 03		ldy #$03			ldy 	#3
.8d14					_SGCLSLoop:
.8d14	b1 30		lda ($30),y			lda 	(codePtr),y
.8d16	c8		iny				iny
.8d17	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8d19	f0 05		beq $8d20			beq 	_SGCLSExit
.8d1b	20 cd 8c	jsr $8ccd			jsr 	ScanForwardOne
.8d1e	80 f4		bra $8d14			bra 	_SGCLSLoop
.8d20					_SGCLSExit:
.8d20	a5 38		lda $38				lda 	zTemp1
.8d22	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8d23					Command_WHILE:
.8d23	5a		phy				phy 								; save position of the test
.8d24	a2 00		ldx #$00			ldx 	#0
.8d26	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; work out the number
.8d29	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; check if zero
.8d2c	f0 0e		beq $8d3c			beq 	_WHExitLoop 				; if so exit the loop
.8d2e	98		tya				tya 								; position *after* test.
.8d2f	7a		ply				ply 								; restore position before test, at WHILE
.8d30	88		dey				dey
.8d31	48		pha				pha 								; push after test on the stack
.8d32	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8d34	20 87 a6	jsr $a687			jsr 	StackOpen
.8d37	20 cb a6	jsr $a6cb			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8d3a	7a		ply				ply 								; restore the position *after* the test
.8d3b	60		rts				rts
.8d3c					_WHExitLoop:
.8d3c	68		pla				pla 								; throw post loop position
.8d3d	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8d3f	aa		tax				tax
.8d40	20 ad 8c	jsr $8cad			jsr 	ScanForward
.8d43	60		rts				rts
.8d44					Command_WEND:
.8d44	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8d46	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8d48	20 b3 a6	jsr $a6b3			jsr 	StackCheckFrame
.8d4b	20 dc a6	jsr $a6dc			jsr 	STKLoadCodePosition 		; loop back
.8d4e	20 a5 a6	jsr $a6a5			jsr 	StackClose		 			; erase the frame
.8d51	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8d52					CheckRightBracket:
.8d52	b1 30		lda ($30),y			lda 	(codePtr),y
.8d54	c8		iny				iny
.8d55	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8d57	d0 0f		bne $8d68			bne 	CNAFail
.8d59	60		rts				rts
.8d5a					CheckComma:
.8d5a	b1 30		lda ($30),y			lda 	(codePtr),y
.8d5c	c8		iny				iny
.8d5d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8d5f	d0 07		bne $8d68			bne 	CNAFail
.8d61	60		rts				rts
.8d62					CheckNextA:
.8d62	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8d64	d0 02		bne $8d68			bne 	CNAFail
.8d66	c8		iny				iny 								; skip character
.8d67	60		rts				rts 								; and exit
.8d68					CNAFail:
.8d68	4c b8 9f	jmp $9fb8			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8d6b					ErrorHandler:
.8d6b	a8		tay				tay 								; find the error text
.8d6c	f0 49		beq $8db7			beq 	_EHEnd
.8d6e	a2 00		ldx #$00			ldx 	#0
.8d70	a9 d1		lda #$d1			lda 	#((ErrorText) & $FF)
.8d72	85 36		sta $36				sta 	0+zTemp0
.8d74	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8d76	85 37		sta $37				sta 	1+zTemp0
.8d78					_EHFind:
.8d78	88		dey				dey 								; found the error text ?
.8d79	f0 0e		beq $8d89			beq 	_EHFound
.8d7b					_EHFindZero:
.8d7b	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8d7d	e6 36		inc $36				inc 	zTemp0
.8d7f	d0 02		bne $8d83			bne 	_EHFNoCarry
.8d81	e6 37		inc $37				inc 	zTemp0+1
.8d83					_EHFNoCarry:
.8d83	c9 00		cmp #$00			cmp 	#0
.8d85	d0 f4		bne $8d7b			bne 	_EHFindZero
.8d87	80 ef		bra $8d78			bra 	_EHFind
.8d89					_EHFound:
.8d89	a5 36		lda $36				lda 	zTemp0 						; print message
.8d8b	a6 37		ldx $37				ldx 	zTemp0+1
.8d8d	20 c4 8d	jsr $8dc4			jsr 	PrintStringXA
.8d90	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8d92	b1 30		lda ($30),y			lda 	(codePtr),y
.8d94	d0 05		bne $8d9b			bne 	_EHAtMsg
.8d96	c8		iny				iny
.8d97	b1 30		lda ($30),y			lda 	(codePtr),y
.8d99	f0 17		beq $8db2			beq 	_EHCREnd
.8d9b					_EHAtMsg:
.8d9b	a2 8d		ldx #$8d			ldx 	#_AtMsg >> 8 				; print " at "
.8d9d	a9 ba		lda #$ba			lda 	#_AtMsg & $FF
.8d9f	20 c4 8d	jsr $8dc4			jsr 	PrintStringXA
.8da2	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8da4	b1 30		lda ($30),y			lda 	(codePtr),y
.8da6	48		pha				pha
.8da7	c8		iny				iny
.8da8	b1 30		lda ($30),y			lda 	(codePtr),y
.8daa	aa		tax				tax
.8dab	68		pla				pla
.8dac	20 7d 92	jsr $927d			jsr 	LCLConvertInt16 				; convert XA to string
.8daf	20 c4 8d	jsr $8dc4			jsr 	PrintStringXA 				; and print it.
.8db2					_EHCREnd:
.8db2	a9 0d		lda #$0d			lda 	#13 						; new line
.8db4	20 c7 a7	jsr $a7c7			jsr 	EXTPrintCharacter
.8db7					_EHEnd:
.8db7	4c 58 83	jmp $8358			jmp 	WarmStart
>8dba	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8dc2	20 00
.8dc4					PrintStringXA:
.8dc4	5a		phy				phy
.8dc5	86 37		stx $37				stx 	zTemp0+1
.8dc7	85 36		sta $36				sta 	zTemp0
.8dc9	a0 00		ldy #$00			ldy 	#0
.8dcb					_PSXALoop:
.8dcb	b1 36		lda ($36),y			lda 	(zTemp0),y
.8dcd	f0 06		beq $8dd5			beq 	_PSXAExit
.8dcf	20 c7 a7	jsr $a7c7			jsr 	EXTPrintCharacter
.8dd2	c8		iny				iny
.8dd3	80 f6		bra $8dcb			bra 	_PSXALoop
.8dd5					_PSXAExit:
.8dd5	7a		ply				ply
.8dd6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8dd7					UnaryTrue:
.8dd7	fa		plx				plx
.8dd8					ReturnTrue:
.8dd8	a9 01		lda #$01			lda 	#1  						; set to 1
.8dda	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.8ddd	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8ddf	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8de2	60		rts				rts
.8de3					UnaryFalse:
.8de3	fa		plx				plx
.8de4					ReturnFalse:
.8de4	4c 2e 9e	jmp $9e2e			jmp 	NSMSetZero 					; set it all to zero
.8de7					BinaryCompareEqual:
.8de7	fa		plx				plx
.8de8	20 23 8e	jsr $8e23			jsr 	CompareBaseCode
.8deb	c9 00		cmp #$00			cmp 	#0
.8ded	f0 e9		beq $8dd8			beq 	ReturnTrue
.8def	80 f3		bra $8de4			bra 	ReturnFalse
.8df1					BinaryCompareLess:
.8df1	fa		plx				plx
.8df2	20 23 8e	jsr $8e23			jsr 	CompareBaseCode
.8df5	c9 ff		cmp #$ff			cmp 	#$FF
.8df7	f0 df		beq $8dd8			beq 	ReturnTrue
.8df9	80 e9		bra $8de4			bra 	ReturnFalse
.8dfb					BinaryCompareGreater:
.8dfb	fa		plx				plx
.8dfc	20 23 8e	jsr $8e23			jsr 	CompareBaseCode
.8dff	c9 01		cmp #$01			cmp 	#1
.8e01	f0 d5		beq $8dd8			beq 	ReturnTrue
.8e03	80 df		bra $8de4			bra 	ReturnFalse
.8e05					BinaryCompareNotEqual:
.8e05	fa		plx				plx
.8e06	20 23 8e	jsr $8e23			jsr 	CompareBaseCode
.8e09	c9 00		cmp #$00			cmp 	#0
.8e0b	d0 cb		bne $8dd8			bne 	ReturnTrue
.8e0d	80 d5		bra $8de4			bra 	ReturnFalse
.8e0f					BinaryCompareLessEqual:
.8e0f	fa		plx				plx
.8e10	20 23 8e	jsr $8e23			jsr 	CompareBaseCode
.8e13	c9 01		cmp #$01			cmp 	#1
.8e15	d0 c1		bne $8dd8			bne 	ReturnTrue
.8e17	80 cb		bra $8de4			bra 	ReturnFalse
.8e19					BinaryCompareGreaterEqual:
.8e19	fa		plx				plx
.8e1a	20 23 8e	jsr $8e23			jsr 	CompareBaseCode
.8e1d	c9 ff		cmp #$ff			cmp 	#$FF
.8e1f	d0 b7		bne $8dd8			bne 	ReturnTrue
.8e21	80 c1		bra $8de4			bra 	ReturnFalse
.8e23					CompareBaseCode:
.8e23	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; make both values if references.
.8e26	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8e29	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e2c	29 10		and #$10			and 	#NSTString
.8e2e	d0 40		bne $8e70			bne 	_CBCString
.8e30	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8e33	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8e36	d0 3b		bne $8e73			bne 	_CBCFloat
.8e38	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8e3b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8e3e	29 08		and #$08			and 	#NSTFloat
.8e40	d0 31		bne $8e73			bne 	_CBCFloat
.8e42	20 76 8e	jsr $8e76			jsr 	CompareFixMinusZero
.8e45	e8		inx				inx
.8e46	20 76 8e	jsr $8e76			jsr 	CompareFixMinusZero
.8e49	ca		dex				dex
.8e4a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8e4d	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8e50	10 0b		bpl $8e5d			bpl 	_CDCSameSign
.8e52	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8e55	30 16		bmi $8e6d			bmi 	_CBCLess 					; return $FF
.8e57					_CBCGreater:
.8e57	a9 01		lda #$01			lda 	#1
.8e59	60		rts				rts
.8e5a					_CBCEqual:
.8e5a	a9 00		lda #$00			lda 	#0
.8e5c	60		rts				rts
.8e5d					_CDCSameSign:
.8e5d	20 c9 90	jsr $90c9			jsr 	SubTopTwoStack 				; unsigned subtract
.8e60	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; or the mantissa together
.8e63	f0 f5		beq $8e5a			beq 	_CBCEqual 					; -0 == 0
.8e65	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8e68	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8e6b	10 ea		bpl $8e57			bpl 	_CBCGreater
.8e6d					_CBCLess:
.8e6d	a9 ff		lda #$ff			lda 	#$FF
.8e6f	60		rts				rts
.8e70					_CBCString:
.8e70	4c 1f 90	jmp $901f			jmp 	CompareStrings
.8e73					_CBCFloat:
.8e73	4c 00 94	jmp $9400			jmp 	CompareFloat
.8e76					CompareFixMinusZero:
.8e76	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero
.8e79	d0 03		bne $8e7e			bne 	_CFXMZNotZero
.8e7b	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8e7e					_CFXMZNotZero:
.8e7e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8e7f					StringConcat:
.8e7f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8e82	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8e85	29 18		and #$18			and 	#NSBTypeMask
.8e87	c9 10		cmp #$10			cmp 	#NSTString
.8e89	d0 4e		bne $8ed9			bne		_SCType
.8e8b	64 38		stz $38				stz 	zTemp1 						; counting total length
.8e8d	e8		inx				inx
.8e8e	20 ac 8e	jsr $8eac			jsr 	_SCSetupZ0 					; setup for second
.8e91	20 b7 8e	jsr $8eb7			jsr 	_SCLengthZ0 				; length for second
.8e94	ca		dex				dex
.8e95	20 ac 8e	jsr $8eac			jsr 	_SCSetupZ0 					; setup for first
.8e98	20 b7 8e	jsr $8eb7			jsr 	_SCLengthZ0 				; length for first
.8e9b	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8e9d	20 7a a7	jsr $a77a			jsr 	StringTempAllocate
.8ea0	20 ca 8e	jsr $8eca			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8ea3	e8		inx				inx
.8ea4	20 ac 8e	jsr $8eac			jsr 	_SCSetupZ0 					; copy second out
.8ea7	20 ca 8e	jsr $8eca			jsr 	_SCCopy
.8eaa	ca		dex				dex
.8eab	60		rts				rts
.8eac					_SCSetupZ0:
.8eac	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8eaf	85 36		sta $36				sta 	zTemp0
.8eb1	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8eb4	85 37		sta $37				sta 	zTemp0+1
.8eb6	60		rts				rts
.8eb7					_SCLengthZ0:
.8eb7	5a		phy				phy
.8eb8	a0 00		ldy #$00			ldy 	#0
.8eba					_SCLenLoop:
.8eba	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ebc	f0 0a		beq $8ec8			beq 	_SCLExit
.8ebe	c8		iny				iny
.8ebf	e6 38		inc $38				inc 	zTemp1
.8ec1	10 f7		bpl $8eba			bpl		_SCLenLoop
.8ec3	a9 09		lda #$09		lda	#9
.8ec5	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.8ec8					_SCLExit:
.8ec8	7a		ply				ply
.8ec9	60		rts				rts
.8eca					_SCCopy:
.8eca	5a		phy				phy
.8ecb	a0 00		ldy #$00			ldy 	#0
.8ecd					_SCCopyLoop:
.8ecd	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ecf	f0 06		beq $8ed7			beq 	_SCCExit
.8ed1	20 b8 a7	jsr $a7b8			jsr 	StringTempWrite
.8ed4	c8		iny				iny
.8ed5	80 f6		bra $8ecd			bra 	_SCCopyLoop
.8ed7					_SCCExit:
.8ed7	7a		ply				ply
.8ed8	60		rts				rts
.8ed9					_SCType:
.8ed9	4c c2 9f	jmp $9fc2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8edc					IntegerDivide:
.8edc	fa		plx				plx
.8edd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8ee0	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ee3	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8ee4	0a		asl a				asl 	a
.8ee5	10 05		bpl $8eec			bpl 	_NotRef
.8ee7	48		pha				pha
.8ee8	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8eeb	68		pla				pla
.8eec					_NotRef:
.8eec	0a		asl a				asl 	a
.8eed	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8eef	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8ef2	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8ef5	f0 03		beq $8efa			beq 	_IntegerCode 				; if clear, then we have two integers
.8ef7	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.8efa					_IntegerCode:
.8efa	20 1c 8f	jsr $8f1c			jsr 	CheckDivideZero 			; do div zero check
.8efd	20 54 8f	jsr $8f54			jsr 	Int32Divide 				; do the division
.8f00	20 11 90	jsr $9011			jsr 	CalculateSign 				; calculate result sign
.8f03					NSMCopyPlusTwoToZero:
.8f03	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f06	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8f09	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8f0c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8f0f	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8f12	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8f15	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8f18	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8f1b	60		rts				rts
.8f1c					CheckDivideZero:
.8f1c	e8		inx				inx
.8f1d	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero
.8f20	f0 02		beq $8f24			beq 	_CDVError
.8f22	ca		dex				dex
.8f23	60		rts				rts
.8f24					_CDVError:
.8f24	a9 03		lda #$03		lda	#3
.8f26	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.8f29					IntegerModulus:
.8f29	fa		plx				plx
.8f2a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f2d	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f30	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f31	0a		asl a				asl 	a
.8f32	10 05		bpl $8f39			bpl 	_NotRef
.8f34	48		pha				pha
.8f35	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f38	68		pla				pla
.8f39					_NotRef:
.8f39	0a		asl a				asl 	a
.8f3a	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f3c	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f3f	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f42	f0 03		beq $8f47			beq 	_IntegerCode 				; if clear, then we have two integers
.8f44	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.8f47					_IntegerCode:
.8f47					IntegerModulusNoCheck:
.8f47	20 1c 8f	jsr $8f1c			jsr 	CheckDivideZero 			; do div zero check
.8f4a	20 54 8f	jsr $8f54			jsr 	Int32Divide 				; do the division
.8f4d	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8f50	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8f53	60		rts				rts
.8f54					Int32Divide:
.8f54	48		pha				pha 								; save AXY
.8f55	5a		phy				phy
.8f56	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8f59	20 2a 9e	jsr $9e2a			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8f5c	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8f5e					_I32DivideLoop:
.8f5e	e8		inx				inx
.8f5f	e8		inx				inx
.8f60	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8f63	ca		dex				dex
.8f64	ca		dex				dex
.8f65	20 44 9e	jsr $9e44			jsr 	NSMRotateLeft
.8f68	20 94 8f	jsr $8f94			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f6b	90 03		bcc $8f70			bcc 	_I32DivideNoCarryIn
.8f6d	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8f70					_I32DivideNoCarryIn:
.8f70	88		dey				dey 								; loop round till division completed.
.8f71	d0 eb		bne $8f5e			bne 	_I32DivideLoop
.8f73	7a		ply				ply 								; restore AXY and exit
.8f74	68		pla				pla
.8f75	60		rts				rts
.8f76					Int32ShiftDivide:
.8f76	48		pha				pha 								; save AY
.8f77	5a		phy				phy
.8f78	e8		inx				inx 								; clear S[X+2]
.8f79	e8		inx				inx
.8f7a	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.8f7d	ca		dex				dex
.8f7e	ca		dex				dex
.8f7f	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.8f81					_I32SDLoop:
.8f81	20 94 8f	jsr $8f94			jsr 	DivideCheckSubtract 		; check if subtract possible
.8f84	e8		inx				inx
.8f85	e8		inx				inx
.8f86	20 44 9e	jsr $9e44			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.8f89	ca		dex				dex
.8f8a	ca		dex				dex
.8f8b	20 44 9e	jsr $9e44			jsr 	NSMRotateLeft
.8f8e	88		dey				dey 	 							; do 31 times
.8f8f	d0 f0		bne $8f81			bne 	_I32SDLoop
.8f91	7a		ply				ply 								; restore AY and exit
.8f92	68		pla				pla
.8f93	60		rts				rts
.8f94					DivideCheckSubtract:
.8f94	20 c9 90	jsr $90c9			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.8f97	b0 04		bcs $8f9d			bcs 	_DCSExit 					; if carry set, then could do, exit
.8f99	20 a3 90	jsr $90a3			jsr 	AddTopTwoStack 				; add it back in
.8f9c	18		clc				clc 								; and return False
.8f9d					_DCSExit:
.8f9d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.8f9e					MulInteger:
.8f9e	fa		plx				plx
.8f9f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8fa2	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8fa5	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fa6	0a		asl a				asl 	a
.8fa7	10 05		bpl $8fae			bpl 	_NotRef
.8fa9	48		pha				pha
.8faa	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fad	68		pla				pla
.8fae					_NotRef:
.8fae	0a		asl a				asl 	a 							; put MSB of type into A:7
.8faf	30 0b		bmi $8fbc			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.8fb1	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fb4	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fb7	f0 06		beq $8fbf			beq 	_IntegerCode 				; if clear, then we have two integers
.8fb9	4c d7 94	jmp $94d7			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.8fbc					_StringData:
.8fbc	4c cc 9f	jmp $9fcc			jmp 	NotDoneError							; at least one string - don't know both are strings.
.8fbf					_IntegerCode:
.8fbf	20 cc 8f	jsr $8fcc			jsr 	MultiplyShort
.8fc2	c9 00		cmp #$00			cmp 	#0
.8fc4	f0 05		beq $8fcb			beq 	_MIExit
.8fc6	a9 04		lda #$04		lda	#4
.8fc8	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.8fcb					_MIExit:
.8fcb	60		rts				rts
.8fcc					MultiplyShort:
.8fcc	5a		phy				phy 								; save Y
.8fcd	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fd0	20 2a 9e	jsr $9e2a			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.8fd3	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.8fd5					_I32MLoop:
.8fd5	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.8fd8	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.8fdb	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.8fde	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.8fe1	f0 28		beq $900b			beq 	_I32MExit 					; exit if zero
.8fe3	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.8fe6	29 01		and #$01			and 	#1
.8fe8	f0 0e		beq $8ff8			beq 	_I32MNoAdd
.8fea	20 a3 90	jsr $90a3			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.8fed	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.8ff0	10 06		bpl $8ff8			bpl 	_I32MNoAdd
.8ff2					_I32ShiftRight:
.8ff2	20 51 9e	jsr $9e51			jsr 	NSMShiftRight 				; shift S[X] right
.8ff5	c8		iny				iny 								; increment shift count
.8ff6	80 0a		bra $9002			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.8ff8					_I32MNoAdd:
.8ff8	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.8ffb	70 f5		bvs $8ff2			bvs 	_I32ShiftRight 				; instead.
.8ffd	e8		inx				inx
.8ffe	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9001	ca		dex				dex
.9002					_I32MShiftUpper:
.9002	e8		inx				inx 								; shift S[X+2] right
.9003	e8		inx				inx
.9004	20 51 9e	jsr $9e51			jsr 	NSMShiftRight
.9007	ca		dex				dex
.9008	ca		dex				dex
.9009	80 ca		bra $8fd5			bra 	_I32MLoop 					; try again.
.900b					_I32MExit:
.900b	20 11 90	jsr $9011			jsr 	CalculateSign
.900e	98		tya				tya 								; shift in A
.900f	7a		ply				ply 								; restore Y and exit
.9010	60		rts				rts
.9011					CalculateSign:
.9011	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9014	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.9017	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.901a	0a		asl a				asl 	a 							; shift bit 7 into carry
.901b	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.901e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.901f					CompareStrings:
.901f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.9022	3d 01 04	and $0401,x			and 	NSStatus+1,x
.9025	29 10		and #$10			and 	#NSBIsString
.9027	f0 2c		beq $9055			beq 	_CSTypeError
.9029	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.902c	85 36		sta $36				sta 	zTemp0
.902e	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9031	85 37		sta $37				sta 	zTemp0+1
.9033	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9036	85 38		sta $38				sta 	zTemp1
.9038	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.903b	85 39		sta $39				sta 	zTemp1+1
.903d	5a		phy				phy 								; save Y so we can access strings
.903e	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.9040					_CSLoop:
.9040	c8		iny				iny
.9041	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.9043	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.9045	d0 06		bne $904d			bne 	_CSDifferent
.9047	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.9049	d0 f5		bne $9040			bne 	_CSLoop 					; still comparing
.904b					_CSExit:
.904b	7a		ply				ply 								; reached end, return zero in A from EOS
.904c	60		rts				rts
.904d					_CSDifferent:
.904d	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.904f	90 fa		bcc $904b			bcc		_CSExit
.9051	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9053	80 f6		bra $904b			bra 	_CSExit
.9055					_CSTypeError:
.9055	4c c2 9f	jmp $9fc2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9058					ShiftLeft:
.9058	38		sec				sec
.9059	80 01		bra $905c			bra 	ShiftMain
.905b					ShiftRight:
.905b	18		clc				clc
.905c					ShiftMain:
.905c	fa		plx				plx 								; restore X
.905d	08		php				php 								; save direction
.905e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9061	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9064	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9065	0a		asl a				asl 	a
.9066	10 05		bpl $906d			bpl 	_NotRef
.9068	48		pha				pha
.9069	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.906c	68		pla				pla
.906d					_NotRef:
.906d	0a		asl a				asl 	a
.906e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9070	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9073	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9076	f0 03		beq $907b			beq 	_IntegerCode 				; if clear, then we have two integers
.9078	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.907b					_IntegerCode:
.907b	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.907e	29 e0		and #$e0			and 	#$E0
.9080	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.9083	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.9086	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9089	d0 13		bne $909e			bne 	_SMExit0 					; if >= 32 it will always return zero.
.908b					_SMLoop:
.908b	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.908e	30 11		bmi $90a1			bmi 	_SMExit 					; exit if done.
.9090	28		plp				plp 								; restore direcition setting
.9091	08		php				php
.9092	90 05		bcc $9099			bcc 	_SMRight
.9094	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; shift left if CS
.9097	80 f2		bra $908b			bra 	_SMLoop
.9099					_SMRight:
.9099	20 51 9e	jsr $9e51			jsr 	NSMShiftRight 				; shift right if CC
.909c	80 ed		bra $908b			bra 	_SMLoop
.909e					_SMExit0:
.909e	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero 					; return zero.
.90a1					_SMExit:
.90a1	28		plp				plp 								; throw direction
.90a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.90a3					AddTopTwoStack:
.90a3	18		clc				clc
.90a4	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90a7	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.90aa	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90ad	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90b0	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.90b3	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90b6	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90b9	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.90bc	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90bf	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90c2	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.90c5	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90c8	60		rts				rts
.90c9					SubTopTwoStack:
.90c9	38		sec				sec
.90ca	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.90cd	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.90d0	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.90d3	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.90d6	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.90d9	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.90dc	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.90df	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.90e2	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.90e5	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.90e8	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.90eb	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.90ee	60		rts				rts
.90ef					AddInteger:
.90ef	fa		plx				plx
.90f0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90f3	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90f6	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90f7	0a		asl a				asl 	a
.90f8	10 05		bpl $90ff			bpl 	_NotRef
.90fa	48		pha				pha
.90fb	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90fe	68		pla				pla
.90ff					_NotRef:
.90ff	0a		asl a				asl 	a 							; put MSB of type into A:7
.9100	30 0b		bmi $910d			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9102	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9105	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9108	f0 06		beq $9110			beq 	_IntegerCode 				; if clear, then we have two integers
.910a	4c 57 93	jmp $9357			jmp 	FloatingPointAdd 							; otherwise at least one float.
.910d					_StringData:
.910d	4c 7f 8e	jmp $8e7f			jmp 	StringConcat							; at least one string - don't know both are strings.
.9110					_IntegerCode:
.9110					AddCode:
.9110	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9113	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9116	10 8b		bpl $90a3			bpl 	AddTopTwoStack
.9118	20 c9 90	jsr $90c9			jsr 	SubTopTwoStack 				; do a physical subtraction
.911b	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.911e	10 09		bpl $9129			bpl 	_AddExit
.9120	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9123	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9126	20 e3 9d	jsr $9de3			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9129					_AddExit:
.9129	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; check for -0
.912c	d0 03		bne $9131			bne 	_AddNonZero
.912e	9e 00 04	stz $0400,x			stz 	NSStatus,x
.9131					_AddNonZero:
.9131	60		rts				rts
.9132					SubInteger:
.9132	fa		plx				plx
.9133	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9136	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9139	0a		asl a				asl 	a 							; shift reference bit into sign bit
.913a	0a		asl a				asl 	a
.913b	10 05		bpl $9142			bpl 	_NotRef
.913d	48		pha				pha
.913e	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9141	68		pla				pla
.9142					_NotRef:
.9142	0a		asl a				asl 	a 							; put MSB of type into A:7
.9143	30 0b		bmi $9150			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9145	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9148	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.914b	f0 06		beq $9153			beq 	_IntegerCode 				; if clear, then we have two integers
.914d	4c 5c 93	jmp $935c			jmp 	FloatingPointSub 							; otherwise at least one float.
.9150					_StringData:
.9150	4c cc 9f	jmp $9fcc			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9153					_IntegerCode:
.9153	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.9156	49 80		eor #$80			eor 	#$80
.9158	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.915b	80 b3		bra $9110			bra 	AddCode 					; and do the same code as add.
.915d					AndInteger:
.915d	fa		plx				plx
.915e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9161	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9164	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9165	0a		asl a				asl 	a
.9166	10 05		bpl $916d			bpl 	_NotRef
.9168	48		pha				pha
.9169	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.916c	68		pla				pla
.916d					_NotRef:
.916d	0a		asl a				asl 	a
.916e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9170	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9173	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9176	f0 03		beq $917b			beq 	_IntegerCode 				; if clear, then we have two integers
.9178	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.917b					_IntegerCode:
.917b	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.917e	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.9181	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9184	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9187	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.918a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.918d	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9190	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.9193	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9196	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9199	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.919c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.919f	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.91a2	60		rts				rts
.91a3					OraInteger:
.91a3	fa		plx				plx
.91a4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91a7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91aa	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91ab	0a		asl a				asl 	a
.91ac	10 05		bpl $91b3			bpl 	_NotRef
.91ae	48		pha				pha
.91af	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91b2	68		pla				pla
.91b3					_NotRef:
.91b3	0a		asl a				asl 	a
.91b4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91b6	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91b9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91bc	f0 03		beq $91c1			beq 	_IntegerCode 				; if clear, then we have two integers
.91be	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.91c1					_IntegerCode:
.91c1	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.91c4	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.91c7	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.91ca	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.91cd	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.91d0	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.91d3	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.91d6	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.91d9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.91dc	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.91df	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.91e2	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.91e5	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.91e8	60		rts				rts
.91e9					EorInteger:
.91e9	fa		plx				plx
.91ea	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91ed	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91f0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91f1	0a		asl a				asl 	a
.91f2	10 05		bpl $91f9			bpl 	_NotRef
.91f4	48		pha				pha
.91f5	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f8	68		pla				pla
.91f9					_NotRef:
.91f9	0a		asl a				asl 	a
.91fa	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91fc	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91ff	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9202	f0 03		beq $9207			beq 	_IntegerCode 				; if clear, then we have two integers
.9204	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.9207					_IntegerCode:
.9207	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.920a	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.920d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9210	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9213	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.9216	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9219	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.921c	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.921f	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9222	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9225	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.9228	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.922b	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.922e	60		rts				rts
.922f					WordIndirect:
.922f	fa		plx				plx
.9230	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9233	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9236	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9237	0a		asl a				asl 	a
.9238	10 05		bpl $923f			bpl 	_NotRef
.923a	48		pha				pha
.923b	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.923e	68		pla				pla
.923f					_NotRef:
.923f	0a		asl a				asl 	a
.9240	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9242	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9245	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9248	f0 03		beq $924d			beq 	_IntegerCode 				; if clear, then we have two integers
.924a	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.924d					_IntegerCode:
.924d	20 10 91	jsr $9110			jsr 	AddCode 					; add the two values
.9250	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9252	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9255	60		rts				rts
.9256					ByteIndirect:
.9256	fa		plx				plx
.9257	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.925a	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.925d	0a		asl a				asl 	a 							; shift reference bit into sign bit
.925e	0a		asl a				asl 	a
.925f	10 05		bpl $9266			bpl 	_NotRef
.9261	48		pha				pha
.9262	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9265	68		pla				pla
.9266					_NotRef:
.9266	0a		asl a				asl 	a
.9267	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9269	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.926c	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.926f	f0 03		beq $9274			beq 	_IntegerCode 				; if clear, then we have two integers
.9271	4c c2 9f	jmp $9fc2			jmp 	TypeError 					; anything else, type mismatch.
.9274					_IntegerCode:
.9274	20 10 91	jsr $9110			jsr 	AddCode 					; add the two values
.9277	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9279	9d 00 04	sta $0400,x			sta 	NSStatus,x
.927c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.927d					LCLConvertInt16:
.927d	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.9280	8e 10 04	stx $0410			stx 	NSMantissa1
.9283	9c 18 04	stz $0418			stz 	NSMantissa2
.9286	9c 20 04	stz $0420			stz 	NSMantissa3
.9289	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.928c	a2 00		ldx #$00			ldx 	#0 							; stack level
.928e	a9 0a		lda #$0a			lda 	#10 						; base
.9290	80 00		bra $9292			bra 	ConvertInt32
.9292					ConvertInt32:
.9292	5a		phy				phy
.9293	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9295	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.9298	10 08		bpl $92a2			bpl 	_CI32NotNeg
.929a	48		pha				pha
.929b	a9 2d		lda #$2d			lda 	#'-'
.929d	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.92a0	c8		iny				iny
.92a1	68		pla				pla
.92a2					_CI32NotNeg:
.92a2	20 b0 92	jsr $92b0			jsr 	_CI32DivideConvert 			; recursive conversion
.92a5	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.92a7	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y
.92aa	7a		ply				ply
.92ab	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.92ad	a9 f9		lda #$f9			lda 	#NumberBuffer & $FF
.92af	60		rts				rts
.92b0					_CI32DivideConvert:
.92b0	e8		inx				inx 								; write to next slot up
.92b1	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.92b4	ca		dex				dex
.92b5	20 54 8f	jsr $8f54			jsr 	Int32Divide 				; divide
.92b8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.92bb	48		pha				pha
.92bc	20 03 8f	jsr $8f03			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.92bf	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; is it zero ?
.92c2	f0 06		beq $92ca			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.92c4	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.92c7	20 b0 92	jsr $92b0			jsr 	_CI32DivideConvert 			; and recusrively call.
.92ca					_CI32NoRecurse:
.92ca	68		pla				pla 								; remainder
.92cb	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.92cd	90 02		bcc $92d1			bcc 	_CI32NotHex
.92cf	69 26		adc #$26			adc 	#6+32
.92d1					_CI32NotHex:
.92d1	69 30		adc #$30			adc 	#48
.92d3	99 f9 05	sta $05f9,y			sta 	NumberBuffer,y 				; write out and exit
.92d6	c8		iny				iny
.92d7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.92d8					PrecedenceLevel:
>92d8	04					.byte	 4	; $00 <<
>92d9	02					.byte	 2	; $01 <=
>92da	02					.byte	 2	; $02 <>
>92db	00					.byte	 0	; $03 !!3
>92dc	00					.byte	 0	; $04 ><
>92dd	02					.byte	 2	; $05 >=
>92de	04					.byte	 4	; $06 >>
>92df	00					.byte	 0	; $07 !!7
>92e0	00					.byte	 0	; $08 !!8
>92e1	00					.byte	 0	; $09 !!9
>92e2	00					.byte	 0	; $0a !!10
>92e3	00					.byte	 0	; $0b !!11
>92e4	00					.byte	 0	; $0c !!12
>92e5	00					.byte	 0	; $0d !!13
>92e6	00					.byte	 0	; $0e !!14
>92e7	00					.byte	 0	; $0f !!15
>92e8	00					.byte	 0	; $10 @
>92e9	00					.byte	 0	; $11 !!17
>92ea	00					.byte	 0	; $12 !!18
>92eb	00					.byte	 0	; $13 [
>92ec	04					.byte	 4	; $14 \
>92ed	00					.byte	 0	; $15 ]
>92ee	01					.byte	 1	; $16 ^
>92ef	00					.byte	 0	; $17 _
>92f0	00					.byte	 0	; $18 `
>92f1	00					.byte	 0	; $19 !!25
>92f2	00					.byte	 0	; $1a !!26
>92f3	00					.byte	 0	; $1b {
>92f4	01					.byte	 1	; $1c |
>92f5	00					.byte	 0	; $1d }
>92f6	00					.byte	 0	; $1e ~
>92f7	00					.byte	 0	; $1f [7m<7F>[m
>92f8	00					.byte	 0	; $20
>92f9	05					.byte	 5	; $21 !
>92fa	00					.byte	 0	; $22 "
>92fb	00					.byte	 0	; $23 #
>92fc	05					.byte	 5	; $24 $
>92fd	04					.byte	 4	; $25 %
>92fe	01					.byte	 1	; $26 &
>92ff	00					.byte	 0	; $27 '
>9300	00					.byte	 0	; $28 (
>9301	00					.byte	 0	; $29 )
>9302	04					.byte	 4	; $2a *
>9303	03					.byte	 3	; $2b +
>9304	00					.byte	 0	; $2c ,
>9305	03					.byte	 3	; $2d -
>9306	00					.byte	 0	; $2e .
>9307	04					.byte	 4	; $2f /
>9308	00					.byte	 0	; $30 0
>9309	00					.byte	 0	; $31 1
>930a	00					.byte	 0	; $32 2
>930b	00					.byte	 0	; $33 3
>930c	00					.byte	 0	; $34 4
>930d	00					.byte	 0	; $35 5
>930e	00					.byte	 0	; $36 6
>930f	00					.byte	 0	; $37 7
>9310	00					.byte	 0	; $38 8
>9311	00					.byte	 0	; $39 9
>9312	00					.byte	 0	; $3a :
>9313	00					.byte	 0	; $3b ;
>9314	02					.byte	 2	; $3c <
>9315	02					.byte	 2	; $3d =
>9316	02					.byte	 2	; $3e >
>9317	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9318					EvaluateExpressionAt0:
.9318	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.931a					EvaluateExpression:
.931a	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.931c					EvaluateExpressionAtPrecedence:
.931c	48		pha				pha 								; save precedence level
.931d	20 f4 97	jsr $97f4			jsr 	EvaluateTerm 				; evaluate term into level X.
.9320	68		pla				pla 								; restore precedence level.
.9321					_EXPRLoop:
.9321	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9323	b1 30		lda ($30),y			lda 	(codePtr),y
.9325	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9327	b0 25		bcs $934e			bcs 	_EXPRExit
.9329	da		phx				phx 								; read the operator precedence
.932a	aa		tax				tax
.932b	bd d8 92	lda $92d8,x			lda 	PrecedenceLevel,x
.932e	fa		plx				plx
.932f	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9331	f0 1b		beq $934e			beq 	_EXPRExit
.9333	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9335	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9337	c5 37		cmp $37				cmp 	zTemp0+1
.9339	b0 13		bcs $934e			bcs		_EXPRExit 					; if current >= operator exit
.933b	48		pha				pha 								; save current precedence.
.933c	b1 30		lda ($30),y			lda 	(codePtr),y
.933e	c8		iny				iny
.933f	48		pha				pha
.9340	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9342	e8		inx				inx 								; work out the right hand side.
.9343	20 1c 93	jsr $931c			jsr 	EvaluateExpressionAtPrecedence
.9346	ca		dex				dex
.9347	68		pla				pla 								; get operator, call the code.
.9348	20 51 93	jsr $9351			jsr 	_EXPRCaller
.934b	68		pla				pla 								; restore precedence level
.934c	80 d3		bra $9321			bra 	_EXPRLoop 					; and go round.
.934e					_EXPRExit:
.934e	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9350	60		rts				rts
.9351					_EXPRCaller:
.9351	da		phx				phx 								; save on stack, first thing is to restore it
.9352	0a		asl a				asl 	a 							; double so can use vectors into X
.9353	aa		tax				tax
.9354	7c 98 8a	jmp ($8a98,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9357					FloatingPointAdd:
.9357	20 00 95	jsr $9500			jsr 	FloatPrepare 				; prepare for floats
.935a	80 0b		bra $9367			bra 	FloatAdd
.935c					FloatingPointSub:
.935c	20 00 95	jsr $9500			jsr 	FloatPrepare 				; prepare for floats
.935f					FloatSubtract:
.935f	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.9362	49 80		eor #$80			eor 	#$80
.9364	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.9367					FloatAdd:
.9367	48		pha				pha
.9368	5a		phy				phy
.9369	20 11 95	jsr $9511			jsr 	NSNormalise 				; normalise S[X]
.936c	f0 5c		beq $93ca			beq 	_FAReturn1
.936e	e8		inx				inx 								; normalise S[X+1]
.936f	20 11 95	jsr $9511			jsr 	NSNormalise
.9372	ca		dex				dex
.9373	c9 00		cmp #$00			cmp 	#0
.9375	f0 77		beq $93ee			beq 	_FAExit 					; if so, just return A
.9377	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.937a	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.937d	f0 1b		beq $939a			beq 	_FAExponentsEqual
.937f	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.9382	a8		tay				tay
.9383	38		sec				sec 								; do a signed comparison of the exponents.
.9384	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9387	50 02		bvc $938b			bvc 	_FANoSignedChange
.9389	49 80		eor #$80			eor 	#$80
.938b					_FANoSignedChange:
.938b	29 80		and #$80			and 	#$80
.938d	10 03		bpl $9392			bpl 	_FAHaveMax
.938f	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.9392					_FAHaveMax:
.9392	20 f1 93	jsr $93f1			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9395	e8		inx				inx
.9396	20 f1 93	jsr $93f1			jsr 	_FAShiftToExponent
.9399	ca		dex				dex
.939a					_FAExponentsEqual:
.939a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.939d	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.93a0	30 10		bmi $93b2			bmi 	_FADifferentSigns
.93a2	20 a3 90	jsr $90a3			jsr 	AddTopTwoStack 				; do the add of the mantissae
.93a5	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.93a8	10 44		bpl $93ee			bpl 	_FAExit 					; if no, we are done.
.93aa	20 51 9e	jsr $9e51			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.93ad	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.93b0	80 3c		bra $93ee			bra 	_FAExit
.93b2					_FADifferentSigns:
.93b2	20 c9 90	jsr $90c9			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.93b5	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.93b8	10 06		bpl $93c0			bpl 	_FACheckZero 				; if no, check for -0
.93ba	20 da 9d	jsr $9dda			jsr 	NSMNegate 					; netate result
.93bd	20 e3 9d	jsr $9de3			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.93c0					_FACheckZero:
.93c0	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero	 				; check for -0
.93c3	d0 29		bne $93ee			bne 	_FAExit
.93c5	9e 00 04	stz $0400,x			stz 	NSStatus,x
.93c8	80 24		bra $93ee			bra 	_FAExit
.93ca					_FAReturn1:
.93ca	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.93cd	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.93d0	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.93d3	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.93d6	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.93d9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.93dc	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.93df	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.93e2	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.93e5	9d 28 04	sta $0428,x			sta 	NSExponent,x
.93e8	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.93eb	9d 00 04	sta $0400,x			sta 	NSStatus,x
.93ee					_FAExit:
.93ee	7a		ply				ply
.93ef	68		pla				pla
.93f0	60		rts				rts
.93f1					_FAShiftToExponent:
.93f1					_FAShiftToExponent2:
.93f1	98		tya				tya 								; compare Y to exponent
.93f2	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.93f5	f0 08		beq $93ff			beq 	_FASEExit 					; exit if so.
.93f7	20 51 9e	jsr $9e51			jsr 	NSMShiftRight	 			; shift the mantissa right
.93fa	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.93fd	80 f2		bra $93f1			bra 	_FAShiftToExponent2
.93ff					_FASEExit:
.93ff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9400					CompareFloat:
.9400	20 5f 93	jsr $935f			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9403	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9406	29 f8		and #$f8			and 	#$F8
.9408	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.940b	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.940e	f0 09		beq $9419			beq 	_FCExit 					; zero, so approximately identical
.9410	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9412	3c 00 04	bit $0400,x			bit 	NSStatus,x
.9415	10 02		bpl $9419			bpl 	_FCExit
.9417					_FCNegative:
.9417	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9419					_FCExit:
.9419	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.941a					FDivideCommand:
.941a	fa		plx				plx	 								; restore stack position
.941b	20 00 95	jsr $9500			jsr 	FloatPrepare 				; prepare for floats
.941e					FloatDivide:
.941e	48		pha				pha
.941f	e8		inx				inx
.9420	20 11 95	jsr $9511			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9423	ca		dex				dex
.9424	c9 00		cmp #$00			cmp 	#0
.9426	f0 20		beq $9448			beq 	_FDZero
.9428	20 11 95	jsr $9511			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.942b	f0 19		beq $9446			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.942d	20 76 8f	jsr $8f76			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.9430	20 03 8f	jsr $8f03			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9433	20 11 95	jsr $9511			jsr		NSNormalise 				; renormalise
.9436	20 11 90	jsr $9011			jsr 	CalculateSign 				; calculate result sign
.9439	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.943c	38		sec				sec
.943d	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9440	38		sec				sec
.9441	e9 1e		sbc #$1e			sbc 	#30
.9443	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9446					_FDExit:
.9446	68		pla				pla
.9447	60		rts				rts
.9448					_FDZero:
.9448	a9 03		lda #$03		lda	#3
.944a	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.944d					FloatFractionalPart:
.944d	5a		phy				phy
.944e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.9451	29 7f		and #$7f			and 	#$7F
.9453	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9456	20 11 95	jsr $9511			jsr 	NSNormalise
.9459	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.945c	38		sec				sec
.945d	e9 e0		sbc #$e0			sbc 	#$E0
.945f	90 31		bcc $9492			bcc 	_FFPExit 					; already fractional
.9461	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9463	b0 2a		bcs $948f			bcs 	_FFPZero
.9465	a8		tay				tay 								; put count to do in Y
.9466	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.9469	20 94 94	jsr $9494			jsr 	_FFPPartial
.946c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.946f	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9472	20 94 94	jsr $9494			jsr 	_FFPPartial
.9475	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9478	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.947b	20 94 94	jsr $9494			jsr 	_FFPPartial
.947e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9481	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9484	20 94 94	jsr $9494			jsr 	_FFPPartial
.9487	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.948a	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; zeroed check.
.948d	d0 03		bne $9492			bne 	_FFPExit
.948f					_FFPZero:
.948f	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.9492					_FFPExit:
.9492	7a		ply				ply
.9493	60		rts				rts
.9494					_FFPPartial:
.9494	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9496	f0 17		beq $94af			beq 	_FFFPPExit
.9498	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.949a	b0 0c		bcs $94a8			bcs 	_FFFPPWholeByte
.949c	5a		phy				phy
.949d					_FFFPPLeft:
.949d	0a		asl a				asl 	a
.949e	88		dey				dey
.949f	d0 fc		bne $949d			bne 	_FFFPPLeft
.94a1	7a		ply				ply
.94a2					_FFFPPRight:
.94a2	4a		lsr a				lsr 	a
.94a3	88		dey				dey
.94a4	d0 fc		bne $94a2			bne 	_FFFPPRight
.94a6	80 07		bra $94af			bra 	_FFFPPExit
.94a8					_FFFPPWholeByte:
.94a8	98		tya				tya 								; subtract 8 from count
.94a9	38		sec				sec
.94aa	e9 08		sbc #$08			sbc 	#8
.94ac	a8		tay				tay
.94ad	a9 00		lda #$00			lda 	#0 							; and clear all
.94af					_FFFPPExit:
.94af	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.94b0					FloatIntegerPart:
.94b0	48		pha				pha
.94b1	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.94b4	f0 1f		beq $94d5			beq 	_FIPExit 					; if so do nothing
.94b6	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; is it zero ?
.94b9	f0 17		beq $94d2			beq 	_FIPZero 					; if so return zero.
.94bb	20 11 95	jsr $9511			jsr 	NSNormalise 				; normalise
.94be	f0 12		beq $94d2			beq 	_FIPZero 					; normalised to zero, exit zero
.94c0					_FIPShift:
.94c0	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.94c3	10 08		bpl $94cd			bpl 	_FIPCheckZero
.94c5	20 51 9e	jsr $9e51			jsr 	NSMShiftRight 				; shift mantissa right
.94c8	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.94cb	80 f3		bra $94c0			bra 	_FIPShift
.94cd					_FIPCheckZero:
.94cd	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; avoid -0 problem
.94d0	d0 03		bne $94d5			bne 	_FIPExit 					; set to zero if mantissa zero.
.94d2					_FIPZero:
.94d2	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.94d5					_FIPExit:
.94d5	68		pla				pla
.94d6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.94d7					FloatingPointMultiply:
.94d7	20 00 95	jsr $9500			jsr 	FloatPrepare 				; prepare for floats
.94da					FloatMultiply:
.94da	48		pha				pha
.94db	20 11 95	jsr $9511			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94de	f0 1b		beq $94fb			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94e0	e8		inx				inx
.94e1	20 11 95	jsr $9511			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94e4	ca		dex				dex
.94e5	c9 00		cmp #$00			cmp 	#0
.94e7	f0 0f		beq $94f8			beq 	_FDSetZero
.94e9	20 cc 8f	jsr $8fcc			jsr 	MultiplyShort 				; calculate the result.
.94ec	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.94ef	18		clc				clc
.94f0	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.94f3	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94f6	80 03		bra $94fb			bra 	_FDExit
.94f8					_FDSetZero:
.94f8	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero 					; return 0
.94fb					_FDExit:
.94fb	20 11 95	jsr $9511			jsr 	NSNormalise 				; normalise the result
.94fe	68		pla				pla
.94ff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9500					FloatPrepare:
.9500	20 33 96	jsr $9633			jsr 	DereferenceTopTwo 			; dereference the top two values
.9503	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.9506	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9509	29 10		and #$10			and 	#NSBIsString
.950b	d0 01		bne $950e			bne 	_FDType
.950d	60		rts				rts
.950e					_FDType:
.950e	4c c2 9f	jmp $9fc2			jmp 	TypeError
.9511					NSNormalise:
.9511	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.9514	29 80		and #$80			and 	#$80
.9516	09 08		ora #$08			ora 	#NSTFloat
.9518	9d 00 04	sta $0400,x			sta 	NSStatus,x
.951b	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; if zero exit
.951e	d0 09		bne $9529			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.9520	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.9523	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.9526	a9 00		lda #$00			lda 	#0 							; set Z flag
.9528	60		rts				rts
.9529					_NSNormaliseOptimise:
.9529	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.952c	d0 22		bne $9550			bne 	_NSNormaliseLoop
.952e	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.9531	30 1d		bmi $9550			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9533	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9536	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9539	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.953c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.953f	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9542	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.9545	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9548	38		sec				sec
.9549	e9 08		sbc #$08			sbc 	#8
.954b	9d 28 04	sta $0428,x			sta 	NSExponent,x
.954e	80 d9		bra $9529			bra 	_NSNormaliseOptimise
.9550					_NSNormaliseLoop:
.9550	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9553	70 08		bvs $955d			bvs 	_NSNExit 					; exit if so with Z flag clear
.9555	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; shift mantissa left
.9558	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.955b	80 f3		bra $9550			bra 	_NSNormaliseLoop
.955d					_NSNExit:
.955d	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.955f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9560					AssignNumber:
.9560	5a		phy				phy
.9561	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9564	85 36		sta $36				sta 	zTemp0
.9566	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9569	85 37		sta $37				sta 	zTemp0+1
.956b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.956e	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9570	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9573	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9575	c9 08		cmp #$08			cmp 	#NSTFloat
.9577	f0 2a		beq $95a3			beq 	_ANFloat
.9579	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.957c	f0 05		beq $9583			beq		_ANNotFloat
.957e	e8		inx				inx
.957f	20 b0 94	jsr $94b0			jsr 	FloatIntegerPart 			; make it an integer
.9582	ca		dex				dex
.9583					_ANNotFloat:
.9583	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.9586	29 03		and #$03			and 	#3
.9588	d0 05		bne $958f			bne 	_ANByteWord
.958a	20 af 95	jsr $95af			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.958d	80 1e		bra $95ad			bra 	_ANExit
.958f					_ANByteWord:
.958f	48		pha				pha 								; save count
.9590	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.9593	92 36		sta ($36)			sta 	(zTemp0)
.9595	68		pla				pla
.9596	c9 01		cmp #$01			cmp	 	#1
.9598	f0 13		beq $95ad			beq 	_ANExit
.959a	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.959d	a0 01		ldy #$01			ldy 	#1
.959f	91 36		sta ($36),y			sta 	(zTemp0),y
.95a1	80 0a		bra $95ad			bra 	_ANExit
.95a3					_ANFloat:
.95a3	20 af 95	jsr $95af			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.95a6	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.95a9	a0 04		ldy #$04			ldy 	#4
.95ab	91 36		sta ($36),y			sta 	(zTemp0),y
.95ad					_ANExit:
.95ad	7a		ply				ply
.95ae	60		rts				rts
.95af					_ANCopy4PackSign:
.95af	a0 03		ldy #$03			ldy 	#3
.95b1	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.95b4	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.95b6	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.95b9	91 36		sta ($36),y			sta 	(zTemp0),y
.95bb	88		dey				dey
.95bc	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.95bf	91 36		sta ($36),y			sta 	(zTemp0),y
.95c1	88		dey				dey
.95c2	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95c5	91 36		sta ($36),y			sta 	(zTemp0),y
.95c7	88		dey				dey
.95c8	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95cb	91 36		sta ($36),y			sta 	(zTemp0),y
.95cd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95ce					AssignString:
.95ce	5a		phy				phy
.95cf	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.95d2	85 38		sta $38				sta 	zTemp1
.95d4	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.95d7	85 39		sta $39				sta 	zTemp1+1
.95d9	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95dc	85 36		sta $36				sta 	zTemp0
.95de	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95e1	85 37		sta $37				sta 	zTemp0+1
.95e3	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.95e5	b1 36		lda ($36),y			lda 	(zTemp0),y
.95e7	f0 23		beq $960c			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.95e9	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.95ea	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.95ec	e9 02		sbc #$02			sbc 	#2
.95ee	85 3c		sta $3c				sta 	zsTemp
.95f0	a0 01		ldy #$01			ldy 	#1
.95f2	b1 36		lda ($36),y			lda 	(zTemp0),y
.95f4	e9 00		sbc #$00			sbc 	#0
.95f6	85 3d		sta $3d				sta 	zsTemp+1
.95f8	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.95fa					_ASGetLength:
.95fa	c8		iny				iny
.95fb	b1 38		lda ($38),y			lda 	(zTemp1),y
.95fd	d0 fb		bne $95fa			bne 	_ASGetLength
.95ff	98		tya				tya 								; is this length <= current length
.9600	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9602	90 20		bcc $9624			bcc 	_ASCopyString
.9604	f0 1e		beq $9624			beq 	_ASCopyString
.9606	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9608	a0 01		ldy #$01			ldy 	#1
.960a	91 3c		sta ($3c),y			sta 	(zsTemp),y
.960c					_ASNewStringRequired:
.960c	e8		inx				inx 								; concrete the new string.
.960d	20 f9 a6	jsr $a6f9			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9610	ca		dex				dex
.9611	18		clc				clc
.9612	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9615	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9617	92 36		sta ($36)			sta 	(zTemp0)
.9619	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.961c	69 00		adc #$00			adc 	#0
.961e	a0 01		ldy #$01			ldy 	#1
.9620	91 36		sta ($36),y			sta 	(zTemp0),y
.9622	80 0d		bra $9631			bra 	_ASExit
.9624					_ASCopyString:
.9624	a0 00		ldy #$00			ldy 	#0
.9626					_ASCopyLoop:
.9626	b1 38		lda ($38),y			lda 	(zTemp1),y
.9628	c8		iny				iny
.9629	c8		iny				iny
.962a	91 3c		sta ($3c),y			sta 	(zsTemp),y
.962c	88		dey				dey
.962d	c9 00		cmp #$00			cmp 	#0
.962f	d0 f5		bne $9626			bne 	_ASCopyLoop
.9631					_ASExit:
.9631	7a		ply				ply
.9632	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9633					DereferenceTopTwo:
.9633	e8		inx				inx
.9634	20 38 96	jsr $9638			jsr 	Dereference 				; deref x+1
.9637	ca		dex				dex  								; falls through to deref x
.9638					Dereference:
.9638	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.963b	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.963d	f0 57		beq $9696			beq 	_DRFExit 					; not a reference
.963f	5a		phy				phy
.9640	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9643	85 36		sta $36				sta 	zTemp0
.9645	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9648	85 37		sta $37				sta 	zTemp0+1
.964a	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.964d	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.964f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9652	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.9655	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9657	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9659	f0 0f		beq $966a			beq 	_DRFDereferenceTwo
.965b	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.965d	f0 39		beq $9698			beq 	_DRFFull
.965f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9662	29 03		and #$03			and 	#3
.9664	f0 32		beq $9698			beq 	_DRFFull 					; the whole word
.9666	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9668	f0 07		beq $9671			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.966a					_DRFDereferenceTwo:
.966a	a0 01		ldy #$01			ldy 	#1
.966c	b1 36		lda ($36),y			lda 	(zTemp0),y
.966e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9671					_DRFClear23:
.9671	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9674	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9677	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.967a	29 18		and #$18			and 	#NSBTypeMask
.967c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.967f	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9681	d0 12		bne $9695			bne 	_DRFNotString
.9683	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.9686	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9689	d0 0a		bne $9695			bne 	_DRFNotString
.968b	a9 97		lda #$97			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.968d	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.9690	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.9692	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.9695					_DRFNotString
.9695	7a		ply				ply 								; restore Y and exit
.9696					_DRFExit:
.9696	60		rts				rts
.9697					_DRFNullString:
>9697	00						.byte 	0
.9698					_DRFFull:
.9698	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.969a	b1 36		lda ($36),y			lda 	(zTemp0),y
.969c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.969f	c8		iny				iny
.96a0	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a2	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.96a5	c8		iny				iny
.96a6	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a8	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96ab	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.96ae	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.96b1	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96b3	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.96b6	f0 06		beq $96be			beq 	_DRFNoExponent
.96b8	c8		iny				iny 								; if not, read the exponent as well.
.96b9	b1 36		lda ($36),y			lda 	(zTemp0),y
.96bb	9d 28 04	sta $0428,x			sta 	NSExponent,x
.96be					_DRFNoExponent:
.96be	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96c1	10 0d		bpl $96d0			bpl 	_DRFExit2 					; if not, then exit.
.96c3	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96c5	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.96c8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.96cb	09 80		ora #$80			ora 	#NSBIsNegative
.96cd	9d 00 04	sta $0400,x			sta 	NSStatus,x
.96d0					_DRFExit2:
.96d0	7a		ply				ply
.96d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.96d2					EncodeNumberStart:
.96d2	38		sec				sec
.96d3	80 01		bra $96d6			bra 	EncodeNumberContinue+1
.96d5					EncodeNumberContinue:
.96d5	18		clc				clc
.96d6					EncodeNumber:
.96d6	08		php				php 								; save reset.
.96d7	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.96d9	f0 12		beq $96ed			beq 	_ENIsOkay
.96db	c9 30		cmp #$30			cmp 	#"0"
.96dd	90 04		bcc $96e3			bcc 	_ENBadNumber
.96df	c9 3a		cmp #$3a			cmp 	#"9"+1
.96e1	90 0a		bcc $96ed			bcc 	_ENIsOkay
.96e3					_ENBadNumber:
.96e3	28		plp				plp 								; throw saved reset
.96e4	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.96e7	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96e9	f0 7e		beq $9769			beq 	_ENConstructFinal
.96eb					_ENFail:
.96eb	18		clc				clc 								; not allowed
.96ec	60		rts				rts
.96ed					_ENIsOkay:
.96ed	28		plp				plp 								; are we restarting
.96ee	90 15		bcc $9705			bcc 	_ENNoRestart
.96f0					_ENStartEncode:
.96f0	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.96f2	f0 0c		beq $9700			beq 	_ENFirstDP
.96f4	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.96f6	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.96f9	a9 01		lda #$01			lda 	#ESTA_Low
.96fb					_ENExitChange:
.96fb	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.96fe	38		sec				sec
.96ff	60		rts				rts
.9700					_ENFirstDP:
.9700	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero 					; clear integer part
.9703	80 3f		bra $9744			bra 	_ESTASwitchFloat			; go straight to float and exi
.9705					_ENNoRestart:
.9705	48		pha				pha 								; save on stack.
.9706	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.9709	c9 01		cmp #$01			cmp 	#ESTA_Low
.970b	f0 09		beq $9716			beq  	_ESTALowState
.970d	c9 02		cmp #$02			cmp 	#ESTA_High
.970f	f0 29		beq $973a			beq 	_ESTAHighState
.9711	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9713	f0 3b		beq $9750			beq 	_ESTADecimalState
>9715	db						.byte 	$DB 						; causes a break in the emulator
.9716					_ESTALowState:
.9716	68		pla				pla 								; get value back
.9717	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9719	f0 29		beq $9744			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.971b	29 0f		and #$0f			and 	#15 						; make digit
.971d	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.9720	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9723	0a		asl a				asl 	a
.9724	0a		asl a				asl 	a
.9725	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9728	0a		asl a				asl 	a
.9729	6d 86 04	adc $0486			adc 	DigitTemp
.972c	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.972f	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.9731	90 05		bcc $9738			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.9733	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.9735	8d 85 04	sta $0485			sta 	EncodeState
.9738					_ESTANoSwitch:
.9738	38		sec				sec
.9739	60		rts				rts
.973a					_ESTAHighState:
.973a	68		pla				pla 								; get value back
.973b	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.973d	f0 05		beq $9744			beq 	_ESTASwitchFloat
.973f	20 a3 97	jsr $97a3			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9742	38		sec				sec
.9743	60		rts				rts
.9744					_ESTASwitchFloat:
.9744	9c 87 04	stz $0487			stz 	DecimalCount
.9747	e8		inx				inx 								; zero the decimal additive.
.9748	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.974b	ca		dex				dex
.974c	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.974e	80 ab		bra $96fb			bra 	_ENExitChange
.9750					_ESTADecimalState:
.9750	68		pla				pla 								; digit.
.9751	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9753	f0 96		beq $96eb			beq 	_ENFail
.9755	e8		inx				inx 								; put digit into fractional part of X+1
.9756	20 a3 97	jsr $97a3			jsr 	ESTAShiftDigitIntoMantissa
.9759	ca		dex				dex
.975a	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.975d	ad 87 04	lda $0487			lda 	DecimalCount
.9760	c9 0b		cmp #$0b			cmp 	#11
.9762	f0 02		beq $9766			beq 	_ESTADSFail
.9764	38		sec				sec
.9765	60		rts				rts
.9766					_ESTADSFail:
.9766	4c bd 9f	jmp $9fbd			jmp 	RangeError
.9769					_ENConstructFinal:
.9769	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.976c	f0 33		beq $97a1			beq 	_ENCFExit 					; no decimals
.976e	5a		phy				phy
.976f	0a		asl a				asl 	a 							; x 4 and CLC
.9770	0a		asl a				asl 	a
.9771	6d 87 04	adc $0487			adc 	DecimalCount
.9774	a8		tay				tay
.9775	b9 7c 9f	lda $9f7c,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9778	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.977b	b9 7d 9f	lda $9f7d,y			lda 	DecimalScalarTable-5+1,y
.977e	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9781	b9 7e 9f	lda $9f7e,y			lda 	DecimalScalarTable-5+2,y
.9784	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9787	b9 7f 9f	lda $9f7f,y			lda 	DecimalScalarTable-5+3,y
.978a	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.978d	b9 80 9f	lda $9f80,y			lda 	DecimalScalarTable-5+4,y
.9790	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9793	a9 08		lda #$08			lda 	#NSTFloat
.9795	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9798	7a		ply				ply
.9799	e8		inx				inx 								; multiply decimal const by decimal scalar
.979a	20 da 94	jsr $94da			jsr 	FloatMultiply
.979d	ca		dex				dex
.979e	20 67 93	jsr $9367			jsr 	FloatAdd 					; add to integer part.
.97a1					_ENCFExit:
.97a1	18		clc				clc 								; reject the digit.
.97a2	60		rts				rts
.97a3					ESTAShiftDigitIntoMantissa:
.97a3	29 0f		and #$0f			and 	#15 						; save digit
.97a5	48		pha				pha
.97a6	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.97a9	48		pha				pha
.97aa	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.97ad	48		pha				pha
.97ae	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.97b1	48		pha				pha
.97b2	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.97b5	48		pha				pha
.97b6	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 2
.97b9	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 4
.97bc	18		clc				clc 								; pop mantissa and add
.97bd	68		pla				pla
.97be	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97c1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97c4	68		pla				pla
.97c5	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.97c8	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.97cb	68		pla				pla
.97cc	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.97cf	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.97d2	68		pla				pla
.97d3	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.97d6	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.97d9	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 10
.97dc	68		pla				pla 								; add digit
.97dd	18		clc				clc
.97de	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97e1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97e4	90 0d		bcc $97f3			bcc 	_ESTASDExit
.97e6	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.97e9	d0 08		bne $97f3			bne 	_ESTASDExit
.97eb	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.97ee	d0 03		bne $97f3			bne 	_ESTASDExit
.97f0	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.97f3					_ESTASDExit:
.97f3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.97f4					EvaluateTerm:
.97f4	b1 30		lda ($30),y			lda 	(codePtr),y
.97f6	30 18		bmi $9810			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.97f8	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.97fa	b0 6f		bcs $986b			bcs 	_ETVariable
.97fc	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.97fe	90 6e		bcc $986e			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9800	c9 3a		cmp #$3a			cmp 	#'9'+1
.9802	b0 6a		bcs $986e			bcs 	_ETPuncUnary
.9804	20 d2 96	jsr $96d2			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9807					_ETNumber:
.9807	c8		iny				iny 								; keep encoding until we have the numbers
.9808	b1 30		lda ($30),y			lda 	(codePtr),y
.980a	20 d5 96	jsr $96d5			jsr 	EncodeNumberContinue
.980d	b0 f8		bcs $9807			bcs 	_ETNumber 					; go back if accepted.
.980f	60		rts				rts
.9810					_ETCheckUnary:
.9810	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9812	f0 41		beq $9855			beq 	_ETString
.9814	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9816	f0 12		beq $982a			beq 	_ETHexConstant
.9818	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.981a	90 0b		bcc $9827			bcc 	_ETSyntaxError
.981c	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.981e	b0 07		bcs $9827			bcs 	_ETSyntaxError
.9820	da		phx				phx 								; push X on the stack
.9821	0a		asl a				asl 	a 							; put vector x 2 into X
.9822	aa		tax				tax
.9823	c8		iny				iny 								; consume unary function token
.9824	7c 18 8b	jmp ($8b18,x)			jmp 	(VectorSet0,x) 				; and do it.
.9827					_ETSyntaxError:
.9827	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.982a					_ETHexConstant:
.982a	c8		iny				iny 								; skip #
.982b	c8		iny				iny 								; skip count
.982c	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero 					; clear result
.982f					_ETHLoop:
.982f	b1 30		lda ($30),y			lda 	(codePtr),y
.9831	c8		iny				iny 								; and consume
.9832	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9834	f0 1e		beq $9854			beq 	_ETHExit
.9836	48		pha				pha 								; save on stack.
.9837	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 2
.983a	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 4
.983d	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 8
.9840	20 43 9e	jsr $9e43			jsr 	NSMShiftLeft 				; x 16
.9843	68		pla				pla 								; ASCII
.9844	c9 41		cmp #$41			cmp 	#'A'
.9846	90 02		bcc $984a			bcc 	_ETHNotChar
.9848	e9 07		sbc #$07			sbc 	#7
.984a					_ETHNotChar:
.984a	29 0f		and #$0f			and 	#15 						; digit now
.984c	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.984f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9852	80 db		bra $982f			bra 	_ETHLoop 					; go round.
.9854					_ETHExit:
.9854	60		rts				rts
.9855					_ETString:
.9855	c8		iny				iny 								; look at length
.9856	b1 30		lda ($30),y			lda 	(codePtr),y
.9858	48		pha				pha
.9859	c8		iny				iny 								; first character
.985a	20 b2 a5	jsr $a5b2			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.985d	68		pla				pla 								; restore count and save
.985e	85 36		sta $36				sta 	zTemp0
.9860	98		tya				tya 								; add length to Y to skip it.
.9861	18		clc				clc
.9862	65 36		adc $36				adc 	zTemp0
.9864	a8		tay				tay
.9865	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9867	9d 00 04	sta $0400,x			sta 	NSStatus,x
.986a	60		rts				rts
.986b					_ETVariable:
.986b	4c c5 98	jmp $98c5			jmp 	VariableHandler
.986e					_ETPuncUnary:
.986e	c8		iny				iny 								; consume the unary character
.986f	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9871	f0 2d		beq $98a0			beq 	_ETUnaryNegate
.9873	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9875	f0 39		beq $98b0			beq 	_ETDereference
.9877	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9879	f0 43		beq $98be			beq 	_ETParenthesis
.987b	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.987d	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.987f	f0 06		beq $9887			beq 	_ETIndirection
.9881	e6 36		inc $36				inc 	zTemp0
.9883	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9885	d0 a0		bne $9827			bne 	_ETSyntaxError
.9887					_ETIndirection:
.9887	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9889	1a		inc a				inc 	a
.988a	48		pha				pha
.988b	20 f4 97	jsr $97f4			jsr 	EvaluateTerm				; evaluate the term
.988e	20 38 96	jsr $9638			jsr 	Dereference 				; dereference it.
.9891	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.9894	d0 07		bne $989d			bne 	_ETTypeMismatch
.9896	68		pla				pla 								; indirection 1-2
.9897	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9899	9d 00 04	sta $0400,x			sta 	NSStatus,x
.989c	60		rts				rts
.989d					_ETTypeMismatch:
.989d	4c c2 9f	jmp $9fc2			jmp 	TypeError
.98a0					_ETUnaryNegate:
.98a0	20 f4 97	jsr $97f4			jsr 	EvaluateTerm				; evaluate the term
.98a3	20 38 96	jsr $9638			jsr 	Dereference 				; dereference it.
.98a6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.98a9	29 10		and #$10			and 	#NSTString
.98ab	d0 f0		bne $989d			bne 	_ETTypeMismatch
.98ad	4c da 9d	jmp $9dda			jmp 	NSMNegate  					; just toggles the sign bit.
.98b0					_ETDereference:
.98b0	20 f4 97	jsr $97f4			jsr 	EvaluateTerm				; evaluate the term
.98b3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.98b6	29 20		and #$20			and 	#NSBIsReference
.98b8	f0 e3		beq $989d			beq 	_ETTypeMismatch
.98ba	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.98bd	60		rts				rts
.98be					_ETParenthesis:
.98be	20 1a 93	jsr $931a			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.98c1	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; check for )
.98c4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.98c5					VariableHandler:
.98c5	b1 30		lda ($30),y			lda 	(codePtr),y
.98c7	18		clc				clc
.98c8	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98ca	85 37		sta $37				sta 	zTemp0+1
.98cc	c8		iny				iny
.98cd	b1 30		lda ($30),y			lda 	(codePtr),y
.98cf	85 36		sta $36				sta 	zTemp0
.98d1	c8		iny				iny
.98d2	18		clc				clc									; copy variable address+3 to mantissa
.98d3	69 03		adc #$03			adc 	#3
.98d5	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98d8	a5 37		lda $37				lda 	zTemp0+1
.98da	69 00		adc #$00			adc 	#0
.98dc	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.98df	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.98e2	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.98e5	9e 28 04	stz $0428,x			stz 	NSExponent,x
.98e8	5a		phy				phy
.98e9	a0 02		ldy #$02			ldy 	#2 							; read type
.98eb	b1 36		lda ($36),y			lda 	(zTemp0),y
.98ed	7a		ply				ply
.98ee	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98f0	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98f2	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98f5	29 04		and #$04			and 	#NSBIsArray
.98f7	d0 01		bne $98fa			bne 	_VHArray
.98f9	60		rts				rts
.98fa					_VHArray:
.98fa	e8		inx				inx
.98fb	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get the 1st index.
.98fe	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9900	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9903	b1 30		lda ($30),y			lda 	(codePtr),y
.9905	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9907	d0 06		bne $990f			bne 	_VHNoSecondIndex
.9909	c8		iny				iny 								; skip the comma
.990a	e8		inx				inx
.990b	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.990e	ca		dex				dex
.990f					_VHNoSecondIndex:
.990f	ca		dex				dex 								; set X back.
.9910	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; and check the right bracket.
.9913	5a		phy				phy 								; save position
.9914	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9916	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9918	f0 6b		beq $9985			beq 	_VHBadIndex
.991a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.991d	85 3e		sta $3e				sta 	zaTemp
.991f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9922	85 3f		sta $3f				sta 	zaTemp+1
.9924	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9926	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9928	f0 02		beq $992c			beq 	_VHHas2Mask
.992a	a9 ff		lda #$ff			lda 	#$FF
.992c					_VHHas2Mask:
.992c	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.992f	f0 54		beq $9985			beq 	_VHBadIndex
.9931	0a		asl a				asl 	a 							; carry will be set if a second index
.9932	90 09		bcc $993d			bcc 	_VHCheckFirstIndex
.9934	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9936	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9938	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.993b	90 48		bcc $9985			bcc 	_VHBadIndex
.993d					_VHCheckFirstIndex:
.993d	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.993f	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9941	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.9944	90 3f		bcc $9985			bcc 	_VHBadIndex
.9946	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9948	64 37		stz $37				stz 	zTemp0+1
.994a	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.994d	30 0f		bmi $995e			bmi 	_VHNoMultiply
.994f	da		phx				phx
.9950	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9953	48		pha				pha
.9954	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9956	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9958	1a		inc a				inc 	a 							; add 1 for zero base
.9959	fa		plx				plx
.995a	20 c3 9d	jsr $9dc3			jsr 	Multiply8x8 				; calculate -> Z0
.995d	fa		plx				plx
.995e					_VHNoMultiply:
.995e	18		clc				clc
.995f	a5 36		lda $36				lda 	zTemp0
.9961	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9964	85 36		sta $36				sta 	zTemp0
.9966	a5 37		lda $37				lda 	zTemp0+1
.9968	69 00		adc #$00			adc 	#0
.996a	85 37		sta $37				sta 	zTemp0+1
.996c	bd 00 04	lda $0400,x			lda 	NSStatus,x
.996f	20 f4 84	jsr $84f4			jsr 	ScaleByBaseType
.9972	18		clc				clc
.9973	b2 3e		lda ($3e)			lda 	(zaTemp)
.9975	65 36		adc $36				adc 	zTemp0
.9977	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.997a	a0 01		ldy #$01			ldy 	#1
.997c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.997e	65 37		adc $37				adc 	zTemp0+1
.9980	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9983	7a		ply				ply 								; restore position
.9984	60		rts				rts
.9985					_VHBadIndex:
.9985	a9 17		lda #$17		lda	#23
.9987	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.998a					AbsUnary:
.998a	fa		plx				plx 								; restore stack pos
.998b	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; get a float or int
.998e	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9991	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.9994	29 7f		and #$7f			and 	#$7F
.9996	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9999	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.999a					AllocUnary:
.999a	fa		plx				plx 								; restore stack pos
.999b	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger		; get bytes required.
.999e	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.99a1	da		phx				phx 								; save X/Y
.99a2	5a		phy				phy
.99a3	8a		txa				txa 								; copy X into Y
.99a4	a8		tay				tay
.99a5	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.99a8	aa		tax				tax
.99a9	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.99ac	20 b9 99	jsr $99b9			jsr 	AllocateXABytes 			; allocate memory
.99af	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.99b2	8a		txa				txa
.99b3	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.99b6	7a		ply				ply
.99b7	fa		plx				plx
.99b8	60		rts				rts
.99b9					AllocateXABytes:
.99b9	5a		phy				phy
.99ba	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.99bd	84 36		sty $36				sty 	zTemp0
.99bf	5a		phy				phy
.99c0	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.99c3	84 37		sty $37				sty 	zTemp0+1
.99c5	5a		phy				phy
.99c6	18		clc				clc 								; add to low memory pointer
.99c7	6d 8c 04	adc $048c			adc 	lowMemPtr
.99ca	8d 8c 04	sta $048c			sta 	lowMemPtr
.99cd	8a		txa				txa
.99ce	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.99d1	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.99d4	b0 2f		bcs $9a05			bcs 	CISSMemory
.99d6	20 f7 99	jsr $99f7			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.99d9					_ClearMemory:
.99d9	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.99dc	c5 36		cmp $36				cmp 	zTemp0
.99de	d0 07		bne $99e7			bne 	_CMClearNext
.99e0	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.99e3	c5 37		cmp $37				cmp 	zTemp0+1
.99e5	f0 0c		beq $99f3			beq 	_CMExit
.99e7					_CMClearNext:
.99e7	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99e9	92 36		sta ($36)			sta 	(zTemp0)
.99eb	e6 36		inc $36				inc 	zTemp0
.99ed	d0 ea		bne $99d9			bne 	_ClearMemory
.99ef	e6 37		inc $37				inc		zTemp0+1
.99f1	80 e6		bra $99d9			bra 	_ClearMemory
.99f3					_CMExit:
.99f3	fa		plx				plx
.99f4	68		pla				pla
.99f5	7a		ply				ply
.99f6	60		rts				rts
.99f7					CheckIdentifierStringSpace:
.99f7	48		pha				pha
.99f8	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.99fb	18		clc				clc
.99fc	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99fe	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a01	b0 02		bcs $9a05			bcs 	CISSMemory
.9a03	68		pla				pla
.9a04	60		rts				rts
.9a05					CISSMemory:
.9a05	a9 06		lda #$06		lda	#6
.9a07	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a0a					AscUnary:
.9a0a	fa		plx				plx 								; restore stack pos
.9a0b	20 62 9d	jsr $9d62			jsr 	EvaluateString 				; get a string
.9a0e	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9a10	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.9a13	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9a16	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a17					FracUnary:
.9a17	fa		plx				plx 								; restore stack pos
.9a18	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; get a float or int
.9a1b	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9a1e	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a21	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a23	f0 04		beq $9a29			beq 	_IUZero
.9a25	20 4d 94	jsr $944d			jsr 	FloatFractionalPart
.9a28	60		rts				rts
.9a29					_IUZero:
.9a29	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.9a2c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9a2d					IntUnary:
.9a2d	fa		plx				plx 								; restore stack pos
.9a2e	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; get a float or int
.9a31	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9a34	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a37	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a39	f0 03		beq $9a3e			beq 	_IUExit
.9a3b	20 b0 94	jsr $94b0			jsr 	FloatIntegerPart
.9a3e					_IUExit:
.9a3e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9a3f					LenUnary:
.9a3f	fa		plx				plx 								; restore stack pos
.9a40	20 62 9d	jsr $9d62			jsr 	EvaluateString 				; get a string
.9a43	5a		phy				phy
.9a44	a0 00		ldy #$00			ldy 	#0 							; find length
.9a46					_LenFind:
.9a46	b1 36		lda ($36),y			lda 	(zTemp0),y
.9a48	f0 06		beq $9a50			beq 	_LenExit
.9a4a	c8		iny				iny
.9a4b	d0 f9		bne $9a46			bne 	_LenFind
.9a4d	4c bd 9f	jmp $9fbd			jmp 	RangeError 					; string > 255
.9a50					_LenExit:
.9a50	98		tya				tya
.9a51	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.9a54	7a		ply				ply
.9a55	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9a58	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a59					Unary_Min:
.9a59	a9 01		lda #$01			lda 	#1
.9a5b	80 02		bra $9a5f			bra 	UnaryMinMaxMain
.9a5d					Unary_Max:
.9a5d	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a5f					UnaryMinMaxMain:
.9a5f	fa		plx				plx 								; get index on number stack
.9a60	48		pha				pha 								; save comparator
.9a61	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue 				; get the first value.
.9a64					_UMMMLoop:
.9a64	b1 30		lda ($30),y			lda 	(codePtr),y
.9a66	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a68	f0 22		beq $9a8c			beq 	_UMMMDone
.9a6a	20 5a 8d	jsr $8d5a			jsr 	CheckComma 					; must be a comma
.9a6d	e8		inx				inx
.9a6e	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue
.9a71	ca		dex				dex
.9a72	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a75	e8		inx				inx
.9a76	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a79	e8		inx				inx
.9a7a	20 23 8e	jsr $8e23			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a7d	ca		dex				dex
.9a7e	ca		dex				dex
.9a7f	85 36		sta $36				sta 	zTemp0 						; save required result
.9a81	68		pla				pla 								; get and save comparator
.9a82	48		pha				pha
.9a83	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a85	d0 dd		bne $9a64			bne 	_UMMMLoop
.9a87	20 8f 9a	jsr $9a8f			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a8a	80 d8		bra $9a64			bra 	_UMMMLoop
.9a8c					_UMMMDone:
.9a8c	68		pla				pla 								; throw the comparator
.9a8d	c8		iny				iny 								; skip )
.9a8e	60		rts				rts
.9a8f					ExpCopyAboveDown:
.9a8f	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9a92	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a95	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9a98	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9a9b	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9a9e	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9aa1	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9aa4	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9aa7	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9aaa	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9aad	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9ab0	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9ab3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9ab4					Unary_Not:
.9ab4	fa		plx				plx
.9ab5	20 7a 9d	jsr $9d7a			jsr 	EvaluateInteger 			; get integer
.9ab8	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9abb	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; zero mantissa ?
.9abe	f0 04		beq $9ac4			beq 	_NotZero
.9ac0	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.9ac3	60		rts				rts
.9ac4					_NotZero:
.9ac4	4c d8 8d	jmp $8dd8			jmp 	ReturnTrue
.9ac7					_UNBad:
.9ac7	4c c7 9f	jmp $9fc7			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9aca					Unary_Random:
.9aca	fa		plx				plx
.9acb	20 49 9b	jsr $9b49			jsr 	Random32Bit 				; get a random number
.9ace	20 2e 9b	jsr $9b2e			jsr 	URCopyToMantissa  			; put in mantissa
.9ad1	b1 30		lda ($30),y			lda 	(codePtr),y
.9ad3	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9ad5	f0 08		beq $9adf			beq 	_URNoModulus
.9ad7	e8		inx				inx
.9ad8	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9adb	ca		dex				dex
.9adc	20 47 8f	jsr $8f47			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9adf					_URNoModulus:
.9adf	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9ae2	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9ae5	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9ae8	60		rts				rts
.9ae9					Unary_Rnd:
.9ae9	fa		plx				plx
.9aea	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; number to use.
.9aed	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; closing bracket
.9af0	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9af3	f0 2b		beq $9b20			beq 	_URCopySeed
.9af5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9af8	10 23		bpl $9b1d			bpl 	_URDontSeed
.9afa	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9afd	49 17		eor #$17			eor 	#$17
.9aff	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b02	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9b05	49 a5		eor #$a5			eor 	#$A5
.9b07	8d 89 04	sta $0489			sta 	RandomSeed+1
.9b0a	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9b0d	49 c2		eor #$c2			eor 	#$C2
.9b0f	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9b12	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9b15	49 9d		eor #$9d			eor 	#$9D
.9b17	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9b1a	20 49 9b	jsr $9b49			jsr 	Random32Bit
.9b1d					_URDontSeed:
.9b1d	20 49 9b	jsr $9b49			jsr 	Random32Bit 				; generate a number.
.9b20					_URCopySeed:
.9b20	20 2e 9b	jsr $9b2e			jsr 	URCopyToMantissa 			; copy into mantissa
.9b23	a9 e1		lda #$e1			lda 	#-31 						; force into 0-1 range
.9b25	8d 28 04	sta $0428			sta 	NSExponent
.9b28	a9 08		lda #$08			lda 	#NSTFloat
.9b2a	8d 00 04	sta $0400			sta 	NSStatus 					; positive.
.9b2d	60		rts				rts
.9b2e					URCopyToMantissa:
.9b2e	ad 88 04	lda $0488			lda 	RandomSeed+0
.9b31	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b34	ad 89 04	lda $0489			lda 	RandomSeed+1
.9b37	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b3a	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9b3d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b40	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9b43	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9b45	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b48	60		rts				rts
.9b49					Random32Bit:
.9b49	5a		phy				phy
.9b4a	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9b4c	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9b4f	d0 03		bne $9b54			bne 	_Random1
.9b51	a8		tay				tay 								; if so do it 256 times
.9b52	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9b54					_Random1:
.9b54	0a		asl a				asl 	a 							; LSFR RNG
.9b55	2e 89 04	rol $0489			rol 	RandomSeed+1
.9b58	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9b5b	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9b5e	90 02		bcc $9b62			bcc 	_Random2
.9b60	49 c5		eor #$c5			eor 	#$C5
.9b62					_Random2:
.9b62	88		dey				dey
.9b63	d0 ef		bne $9b54			bne 	_Random1
.9b65	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b68	7a		ply				ply
.9b69	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b6a					SgnUnary:
.9b6a	fa		plx				plx 								; restore stack pos
.9b6b	20 57 9d	jsr $9d57			jsr 	EvaluateNumber 				; get a float or int
.9b6e	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9b71	20 5e 9e	jsr $9e5e			jsr 	NSMIsZero 					; if zero
.9b74	f0 10		beq $9b86			beq 	_SGZero  					; return Int Zero
.9b76	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9b79	48		pha				pha
.9b7a	a9 01		lda #$01			lda 	#1 							; set to 1
.9b7c	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.9b7f	68		pla				pla
.9b80	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b82	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b85	60		rts				rts
.9b86	20 2e 9e	jsr $9e2e	_SGZero:jsr 	NSMSetZero
.9b89	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b8a					ValUnary:
.9b8a	fa		plx				plx 								; restore stack pos
.9b8b	20 a0 9b	jsr $9ba0			jsr 	ValMainCode 				; do the main val() code
.9b8e	b0 01		bcs $9b91			bcs 	_VUError 					; couldn't convert
.9b90	60		rts				rts
.9b91					_VUError:
.9b91	4c c2 9f	jmp $9fc2			jmp 	TypeError
.9b94					IsValUnary:
.9b94	fa		plx				plx 								; restore stack pos
.9b95	20 a0 9b	jsr $9ba0			jsr 	ValMainCode 				; do the main val() code
.9b98	b0 03		bcs $9b9d			bcs 	_VUBad
.9b9a	4c d8 8d	jmp $8dd8			jmp 	ReturnTrue
.9b9d					_VUBad:
.9b9d	4c e4 8d	jmp $8de4			jmp 	ReturnFalse
.9ba0					ValMainCode:
.9ba0	20 62 9d	jsr $9d62			jsr 	EvaluateString 				; get a string
.9ba3	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; check right bracket present
.9ba6	5a		phy				phy
.9ba7	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9ba9	f0 17		beq $9bc2			beq 	_VMCFail2
.9bab	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9bad	48		pha				pha 								; save first character
.9bae	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9bb0	d0 01		bne $9bb3			bne 	_VMCStart
.9bb2	c8		iny				iny 								; skip over -
.9bb3					_VMCStart:
.9bb3	38		sec				sec 								; initialise first time round.
.9bb4					_VMCNext:
.9bb4	c8		iny				iny 								; pre-increment
.9bb5	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9bb7	f0 0c		beq $9bc5			beq 	_VMCSuccess 				; successful.
.9bb9	20 d6 96	jsr $96d6			jsr 	EncodeNumber 				; send it to the number-builder
.9bbc	90 03		bcc $9bc1			bcc 	_VMCFail 					; if failed, give up.
.9bbe	18		clc				clc 								; next time round, countinue
.9bbf	80 f3		bra $9bb4			bra 	_VMCNext
.9bc1					_VMCFail:
.9bc1	68		pla				pla
.9bc2					_VMCFail2:
.9bc2	7a		ply				ply
.9bc3	38		sec				sec
.9bc4	60		rts				rts
.9bc5					_VMCSuccess:
.9bc5	a9 00		lda #$00			lda 	#0 							; construct final
.9bc7	20 d6 96	jsr $96d6			jsr 	EncodeNumber
.9bca	68		pla				pla
.9bcb	c9 2d		cmp #$2d			cmp 	#"-"
.9bcd	d0 03		bne $9bd2			bne 	_VMCNotNegative
.9bcf	20 da 9d	jsr $9dda			jsr		NSMNegate
.9bd2					_VMCNotNegative:
.9bd2	7a		ply				ply
.9bd3	18		clc				clc
.9bd4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9bd5					ChrUnary:
.9bd5	fa		plx				plx 								; restore stack pos
.9bd6	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger			; get value
.9bd9	48		pha				pha
.9bda	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9bdd	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9bdf	20 7a a7	jsr $a77a			jsr 	StringTempAllocate
.9be2	68		pla				pla 								; write number to it
.9be3	20 b8 a7	jsr $a7b8			jsr 	StringTempWrite
.9be6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9be7					SpcUnary:
.9be7	fa		plx				plx 								; restore stack pos
.9be8	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger			; get value
.9beb	5a		phy				phy
.9bec	48		pha				pha 								; save count
.9bed	20 7a a7	jsr $a77a			jsr 	StringTempAllocate
.9bf0	7a		ply				ply 								; to do count in Y
.9bf1					_SpcLoop:
.9bf1	c0 00		cpy #$00			cpy 	#0
.9bf3	f0 08		beq $9bfd			beq 	_SpcExit
.9bf5	a9 20		lda #$20			lda 	#32
.9bf7	20 b8 a7	jsr $a7b8			jsr 	StringTempWrite
.9bfa	88		dey				dey
.9bfb	80 f4		bra $9bf1			bra 	_SPCLoop
.9bfd					_SpcExit:
.9bfd	7a		ply				ply
.9bfe	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.9c01	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c02					Unary_Str:
.9c02	fa		plx				plx
.9c03	20 57 9d	jsr $9d57			jsr 	EvaluateNumber  			; get number
.9c06	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; closing bracket
.9c09	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c0b	20 24 9c	jsr $9c24			jsr 	ConvertNumberToString 		; do the conversion.
.9c0e	a9 21		lda #$21			lda		#33 						; create buffer
.9c10	20 7a a7	jsr $a77a			jsr 	StringTempAllocate 			; allocate memory
.9c13	da		phx				phx
.9c14	a2 00		ldx #$00			ldx 	#0
.9c16					_USCopy:
.9c16	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c19	20 b8 a7	jsr $a7b8			jsr 	StringTempWrite
.9c1c	e8		inx				inx
.9c1d	bd 1b 06	lda $061b,x			lda 	DecimalBuffer,x
.9c20	d0 f4		bne $9c16			bne 	_USCopy
.9c22	fa		plx				plx
.9c23	60		rts				rts
.9c24					ConvertNumberToString:
.9c24	5a		phy				phy 								; save code position
.9c25	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9c28	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9c2b	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9c2e	10 0a		bpl $9c3a			bpl 	_CNTSNotNegative
.9c30	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c32	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c35	a9 2d		lda #$2d			lda 	#"-"
.9c37	20 a0 9c	jsr $9ca0			jsr 	WriteDecimalBuffer
.9c3a					_CNTSNotNegative:
.9c3a	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9c3d	f0 15		beq $9c54			beq 	_CNTSNotFloat
.9c3f	e8		inx				inx 								; round up
.9c40	a9 01		lda #$01			lda 	#1
.9c42	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.9c45	ca		dex				dex
.9c46	bd 28 04	lda $0428,x			lda		NSExponent,x
.9c49	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9c4c	a9 08		lda #$08			lda 	#NSTFloat
.9c4e	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9c51	20 67 93	jsr $9367			jsr 	FloatAdd
.9c54					_CNTSNotFloat:
.9c54	20 82 9c	jsr $9c82			jsr 	MakePlusTwoString
.9c57	20 4d 94	jsr $944d			jsr 	FloatFractionalPart 		; get the fractional part
.9c5a	20 11 95	jsr $9511			jsr 	NSNormalise					; normalise , exit if zero
.9c5d	f0 21		beq $9c80			beq 	_CNTSExit
.9c5f	a9 2e		lda #$2e			lda 	#"."
.9c61	20 a0 9c	jsr $9ca0			jsr 	WriteDecimalBuffer 			; write decimal place
.9c64					_CNTSDecimal:
.9c64	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9c67	30 17		bmi $9c80			bmi 	_CNTSExit
.9c69	e8		inx				inx 								; x 10.0
.9c6a	a9 0a		lda #$0a			lda 	#10
.9c6c	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.9c6f	a9 08		lda #$08			lda 	#NSTFloat
.9c71	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c74	ca		dex				dex
.9c75	20 da 94	jsr $94da			jsr 	FloatMultiply
.9c78	20 82 9c	jsr $9c82			jsr 	MakePlusTwoString
.9c7b	20 4d 94	jsr $944d			jsr 	FloatFractionalPart 		; get the fractional part
.9c7e	80 e4		bra $9c64			bra 	_CNTSDecimal 				; keep going.
.9c80					_CNTSExit:
.9c80	7a		ply				ply
.9c81	60		rts				rts
.9c82					MakePlusTwoString:
.9c82	da		phx				phx
.9c83	20 05 9e	jsr $9e05			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c86	e8		inx				inx 								; access it
.9c87	e8		inx				inx
.9c88	20 b0 94	jsr $94b0			jsr 	FloatIntegerPart 			; make it an integer
.9c8b	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c8d	20 92 92	jsr $9292			jsr 	ConvertInt32
.9c90	a2 00		ldx #$00			ldx	 	#0
.9c92					_MPTSCopy:
.9c92	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c95	20 a0 9c	jsr $9ca0			jsr 	WriteDecimalBuffer
.9c98	e8		inx				inx
.9c99	bd f9 05	lda $05f9,x			lda 	NumberBuffer,x
.9c9c	d0 f4		bne $9c92			bne 	_MPTSCopy
.9c9e	fa		plx				plx
.9c9f	60		rts				rts
.9ca0					WriteDecimalBuffer:
.9ca0	da		phx				phx
.9ca1	ae 95 04	ldx $0495			ldx 	dbOffset
.9ca4	9d 1b 06	sta $061b,x			sta 	DecimalBuffer,x
.9ca7	9e 1c 06	stz $061c,x			stz 	DecimalBuffer+1,x
.9caa	ee 95 04	inc $0495			inc 	dbOffset
.9cad	fa		plx				plx
.9cae	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9caf					Unary_Left:
.9caf	fa		plx				plx
.9cb0	18		clc				clc 								; only one parameter
.9cb1	20 26 9d	jsr $9d26			jsr 	SubstringInitial 			; set up.
.9cb4	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9cb7	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cba	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9cbd	80 2c		bra $9ceb			bra 	SubstringMain
.9cbf					Unary_Right:
.9cbf	fa		plx				plx
.9cc0	18		clc				clc 								; only one parameter
.9cc1	20 26 9d	jsr $9d26			jsr 	SubstringInitial 			; set up.
.9cc4	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9cc7	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9cca	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9ccd	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9cd0	b0 02		bcs $9cd4			bcs 	_URNotUnderflow
.9cd2	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9cd4					_URNotUnderFlow:
.9cd4	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9cd7	80 12		bra $9ceb			bra 	SubStringMain
.9cd9					Unary_Mid:
.9cd9	fa		plx				plx
.9cda	38		sec				sec 								; two parameters
.9cdb	20 26 9d	jsr $9d26			jsr 	SubstringInitial 			; set up.
.9cde	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9ce1	f0 05		beq $9ce8			beq 	_UMError
.9ce3	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9ce6	80 03		bra $9ceb			bra 	SubStringMain
.9ce8					_UMError:
.9ce8	4c c7 9f	jmp $9fc7			jmp 	ArgumentError
.9ceb					SubStringMain:
.9ceb	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9cee	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9cf1	b0 2d		bcs $9d20			bcs 	_SSMNull 					; if so, return an empty string.
.9cf3	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9cf6	f0 28		beq $9d20			beq 	_SSMNull 					; return empty string.
.9cf8	18		clc				clc 								; add the offset +1 to the address and
.9cf9	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9cfc	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9cff	85 36		sta $36				sta 	zTemp0
.9d01	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9d04	69 00		adc #$00			adc 	#0
.9d06	85 37		sta $37				sta 	zTemp0+1
.9d08					_SSMNoCarry:
.9d08	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d0b	20 7a a7	jsr $a77a			jsr 	StringTempAllocate 			; allocate that many characters
.9d0e	5a		phy				phy 								; save Y
.9d0f	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d11					_SSMCopy:
.9d11	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d13	f0 09		beq $9d1e			beq 	_SSMEString 				; no more to copy
.9d15	20 b8 a7	jsr $a7b8			jsr 	StringTempWrite 			; and write it out.
.9d18	c8		iny				iny
.9d19	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9d1c	d0 f3		bne $9d11			bne 	_SSMCopy
.9d1e					_SSMEString:
.9d1e	7a		ply				ply
.9d1f					_SSMExit:
.9d1f	60		rts				rts
.9d20					_SSMNull:
.9d20	a9 00		lda #$00			lda 	#0
.9d22	20 7a a7	jsr $a77a			jsr 	StringTempAllocate
.9d25	60		rts				rts
.9d26					SubstringInitial:
.9d26	da		phx				phx 								; save initial stack position
.9d27	08		php				php 								; save carry on stack indicating 2 parameters
.9d28	20 62 9d	jsr $9d62			jsr 	EvaluateString 				; get a string
.9d2b	5a		phy				phy 								; calculate length to exponent.
.9d2c	a0 ff		ldy #$ff			ldy 	#$FF
.9d2e					_SIFindLength:
.9d2e	c8		iny				iny
.9d2f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d31	d0 fb		bne $9d2e			bne 	_SIFindLength
.9d33	98		tya				tya
.9d34	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9d37	7a		ply				ply
.9d38	e8		inx				inx
.9d39	20 5a 8d	jsr $8d5a			jsr 	CheckComma 					; comma next
.9d3c	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get next parameter
.9d3f	28		plp				plp 								; is it the last parameter ?
.9d40	90 07		bcc $9d49			bcc 	_SSIExit 					; if so, exit.
.9d42	e8		inx				inx
.9d43	20 5a 8d	jsr $8d5a			jsr 	CheckComma 					; comma next
.9d46	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get last parameter
.9d49					_SSIExit:
.9d49	fa		plx				plx
.9d4a	20 52 8d	jsr $8d52			jsr 	CheckRightBracket 			; check closing bracket
.9d4d	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d4e					EvaluateValue:
.9d4e	48		pha				pha
.9d4f	20 1a 93	jsr $931a			jsr		EvaluateExpression 			; expression
.9d52	20 38 96	jsr $9638			jsr 	Dereference					; derefernce it
.9d55	68		pla				pla
.9d56	60		rts				rts
.9d57					EvaluateNumber:
.9d57	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue 				; get a value
.9d5a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d5d	29 10		and #$10			and 	#NSBIsString
.9d5f	d0 16		bne $9d77			bne 	HelperTypeError
.9d61	60		rts				rts
.9d62					EvaluateString:
.9d62	20 4e 9d	jsr $9d4e			jsr 	EvaluateValue 				; get a value
.9d65	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9d68	29 10		and #$10			and 	#NSBIsString
.9d6a	f0 0b		beq $9d77			beq 	HelperTypeError
.9d6c					CopyAddressToTemp0:
.9d6c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9d6f	85 36		sta $36				sta 	zTemp0
.9d71	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9d74	85 37		sta $37				sta 	zTemp0+1
.9d76	60		rts				rts
.9d77					HelperTypeError:
.9d77	4c c2 9f	jmp $9fc2			jmp 	TypeError
.9d7a					EvaluateInteger:
.9d7a	20 57 9d	jsr $9d57			jsr 	EvaluateNumber
.9d7d	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9d80	d0 0a		bne $9d8c			bne 	HelperValueError 			; if not, it's a float.
.9d82	60		rts				rts
.9d83					EvaluateUnsignedInteger:
.9d83	20 7a 9d	jsr $9d7a			jsr 	EvaluateInteger 			; check integer is +ve
.9d86	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9d89	30 01		bmi $9d8c			bmi 	HelperValueError
.9d8b	60		rts				rts
.9d8c					HelperValueError:
.9d8c	4c c7 9f	jmp $9fc7			jmp 	ArgumentError
.9d8f					Evaluate16BitInteger:
.9d8f	20 83 9d	jsr $9d83			jsr	 	EvaluateUnsignedInteger		; get integer
.9d92	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d95	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9d98	d0 f2		bne $9d8c			bne 	HelperValueError
.9d9a	60		rts				rts
.9d9b					Evaluate16BitIntegerSigned:
.9d9b	20 7a 9d	jsr $9d7a			jsr	 	EvaluateInteger				; get integer
.9d9e	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9da1	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9da4	d0 e6		bne $9d8c			bne 	HelperValueError
.9da6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9da9	10 03		bpl $9dae			bpl 	_EISNotSigned
.9dab	20 e3 9d	jsr $9de3			jsr 	NSMNegateMantissa
.9dae					_EISNotSigned:
.9dae	60		rts				rts
.9daf					Evaluate8BitInteger:
.9daf	20 83 9d	jsr $9d83			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9db2	d0 d8		bne $9d8c			bne 	HelperValueError
.9db4	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9db7	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9dba	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9dbd	d0 cd		bne $9d8c			bne 	HelperValueError
.9dbf	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9dc2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9dc3					Multiply8x8:
.9dc3	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9dc4	85 36		sta $36			  	sta 	zTemp0
.9dc6	86 37		stx $37				stx 	zTemp0+1
.9dc8	a9 00		lda #$00			lda 	#0
.9dca	a2 08		ldx #$08			ldx 	#8
.9dcc					_M88Loop:
.9dcc	90 03		bcc $9dd1			bcc 	_M88NoAdd
.9dce	18		clc				clc
.9dcf	65 37		adc $37				adc 	zTemp0+1
.9dd1					_M88NoAdd:
.9dd1	6a		ror a				ror 	a
.9dd2	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9dd4	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9dd5	d0 f5		bne $9dcc			bne 	_M88Loop
.9dd7	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9dd9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9dda					NSMNegate:
.9dda	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ddd	49 80		eor #$80			eor 	#NSBIsNegative
.9ddf	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9de2	60		rts				rts
.9de3					NSMNegateMantissa:
.9de3	38		sec				sec
.9de4	a9 00		lda #$00			lda 	#0
.9de6	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9de9	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9dec	a9 00		lda #$00			lda 	#0
.9dee	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9df1	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9df4	a9 00		lda #$00			lda 	#0
.9df6	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9df9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9dfc	a9 00		lda #$00			lda 	#0
.9dfe	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9e01	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9e04	60		rts				rts
.9e05					NSMShiftUpTwo:
.9e05	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e08	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9e0b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e0e	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9e11	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9e14	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9e17	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e1a	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9e1d	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9e20	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9e23	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e26	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9e29	60		rts				rts
.9e2a					NSMSetZeroMantissaOnly:
.9e2a	a9 00		lda #$00			lda 	#0
.9e2c	80 08		bra $9e36			bra 	NSMSetMantissa
.9e2e					NSMSetZero:
.9e2e	a9 00		lda #$00			lda 	#0
.9e30					NSMSetByte:
.9e30	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e33	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9e36					NSMSetMantissa:
.9e36	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9e39	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9e3c	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9e3f	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9e42	60		rts				rts
.9e43					NSMShiftLeft:
.9e43	18		clc				clc
.9e44					NSMRotateLeft:
.9e44	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9e47	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9e4a	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9e4d	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9e50	60		rts				rts
.9e51					NSMShiftRight:
.9e51	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9e54	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9e57	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9e5a	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9e5d	60		rts				rts
.9e5e					NSMIsZero:
.9e5e	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9e61	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9e64	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9e67	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9e6a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.062d					LastTick:
>062d							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e6b					Assemble_ora:
.9e6b	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e6e	01					.byte $01
.9e6f					Assemble_and:
.9e6f	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e72	21					.byte $21
.9e73					Assemble_eor:
.9e73	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e76	41					.byte $41
.9e77					Assemble_adc:
.9e77	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e7a	61					.byte $61
.9e7b					Assemble_sta:
.9e7b	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e7e	81					.byte $81
.9e7f					Assemble_lda:
.9e7f	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e82	a1					.byte $a1
.9e83					Assemble_cmp:
.9e83	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e86	c1					.byte $c1
.9e87					Assemble_sbc:
.9e87	20 6b 80	jsr $806b		jsr	AssembleGroup1
>9e8a	e1					.byte $e1
.9e8b					Assemble_asl:
.9e8b	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e8e	02					.byte $02
>9e8f	75					.byte $75
.9e90					Assemble_rol:
.9e90	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e93	22					.byte $22
>9e94	75					.byte $75
.9e95					Assemble_lsr:
.9e95	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e98	42					.byte $42
>9e99	75					.byte $75
.9e9a					Assemble_ror:
.9e9a	20 72 80	jsr $8072		jsr	AssembleGroup2
>9e9d	62					.byte $62
>9e9e	75					.byte $75
.9e9f					Assemble_stx:
.9e9f	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ea2	82					.byte $82
>9ea3	50					.byte $50
.9ea4					Assemble_ldx:
.9ea4	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ea7	a2					.byte $a2
>9ea8	d0					.byte $d0
.9ea9					Assemble_dec:
.9ea9	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eac	c2					.byte $c2
>9ead	55					.byte $55
.9eae					Assemble_inc:
.9eae	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eb1	e2					.byte $e2
>9eb2	55					.byte $55
.9eb3					Assemble_stz:
.9eb3	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eb6	60					.byte $60
>9eb7	44					.byte $44
.9eb8					Assemble_bit:
.9eb8	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ebb	20					.byte $20
>9ebc	55					.byte $55
.9ebd					Assemble_sty:
.9ebd	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ec0	80					.byte $80
>9ec1	54					.byte $54
.9ec2					Assemble_ldy:
.9ec2	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ec5	a0					.byte $a0
>9ec6	d5					.byte $d5
.9ec7					Assemble_cpy:
.9ec7	20 72 80	jsr $8072		jsr	AssembleGroup2
>9eca	c0					.byte $c0
>9ecb	d4					.byte $d4
.9ecc					Assemble_cpx:
.9ecc	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ecf	e0					.byte $e0
>9ed0	d0					.byte $d0
.9ed1					Assemble_tsb:
.9ed1	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ed4	00					.byte $00
>9ed5	50					.byte $50
.9ed6					Assemble_trb:
.9ed6	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ed9	10					.byte $10
>9eda	50					.byte $50
.9edb					Assemble_jsr:
.9edb	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ede	14					.byte $14
>9edf	10					.byte $10
.9ee0					Assemble_jmp:
.9ee0	20 72 80	jsr $8072		jsr	AssembleGroup2
>9ee3	40					.byte $40
>9ee4	10					.byte $10
.9ee5					Assemble_bpl:
.9ee5	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ee8	10					.byte $10
.9ee9					Assemble_bmi:
.9ee9	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9eec	30					.byte $30
.9eed					Assemble_bvc:
.9eed	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ef0	50					.byte $50
.9ef1					Assemble_bvs:
.9ef1	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ef4	70					.byte $70
.9ef5					Assemble_bcc:
.9ef5	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9ef8	90					.byte $90
.9ef9					Assemble_bcs:
.9ef9	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9efc	b0					.byte $b0
.9efd					Assemble_bne:
.9efd	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f00	d0					.byte $d0
.9f01					Assemble_beq:
.9f01	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f04	f0					.byte $f0
.9f05					Assemble_bra:
.9f05	20 c3 80	jsr $80c3		jsr	AssembleGroup3
>9f08	80					.byte $80
.9f09					Assemble_brk:
.9f09	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f0c	00					.byte $00
.9f0d					Assemble_php:
.9f0d	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f10	08					.byte $08
.9f11					Assemble_clc:
.9f11	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f14	18					.byte $18
.9f15					Assemble_plp:
.9f15	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f18	28					.byte $28
.9f19					Assemble_sec:
.9f19	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f1c	38					.byte $38
.9f1d					Assemble_rti:
.9f1d	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f20	40					.byte $40
.9f21					Assemble_pha:
.9f21	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f24	48					.byte $48
.9f25					Assemble_cli:
.9f25	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f28	58					.byte $58
.9f29					Assemble_phy:
.9f29	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f2c	5a					.byte $5a
.9f2d					Assemble_rts:
.9f2d	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f30	60					.byte $60
.9f31					Assemble_pla:
.9f31	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f34	68					.byte $68
.9f35					Assemble_sei:
.9f35	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f38	78					.byte $78
.9f39					Assemble_ply:
.9f39	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f3c	7a					.byte $7a
.9f3d					Assemble_dey:
.9f3d	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f40	88					.byte $88
.9f41					Assemble_txa:
.9f41	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f44	8a					.byte $8a
.9f45					Assemble_tya:
.9f45	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f48	98					.byte $98
.9f49					Assemble_txs:
.9f49	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f4c	9a					.byte $9a
.9f4d					Assemble_tay:
.9f4d	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f50	a8					.byte $a8
.9f51					Assemble_tax:
.9f51	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f54	aa					.byte $aa
.9f55					Assemble_clv:
.9f55	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f58	b8					.byte $b8
.9f59					Assemble_tsx:
.9f59	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f5c	ba					.byte $ba
.9f5d					Assemble_iny:
.9f5d	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f60	c8					.byte $c8
.9f61					Assemble_dex:
.9f61	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f64	ca					.byte $ca
.9f65					Assemble_cld:
.9f65	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f68	d8					.byte $d8
.9f69					Assemble_phx:
.9f69	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f6c	da					.byte $da
.9f6d					Assemble_stp:
.9f6d	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f70	db					.byte $db
.9f71					Assemble_inx:
.9f71	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f74	e8					.byte $e8
.9f75					Assemble_nop:
.9f75	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f78	ea					.byte $ea
.9f79					Assemble_sed:
.9f79	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f7c	f8					.byte $f8
.9f7d					Assemble_plx:
.9f7d	20 f9 80	jsr $80f9		jsr	AssembleGroup4
>9f80	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f81					DecimalScalarTable:
>9f81	66 66 66 66				.dword $66666666 ; 0.1
>9f85	de					.byte $de
>9f86	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f8a	db					.byte $db
>9f8b	4c 37 89 41				.dword $4189374c ; 0.001
>9f8f	d8					.byte $d8
>9f90	ac 8b db 68				.dword $68db8bac ; 0.0001
>9f94	d4					.byte $d4
>9f95	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9f99	d1					.byte $d1
>9f9a	83 de 1b 43				.dword $431bde83 ; 1e-06
>9f9e	ce					.byte $ce
>9f9f	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9fa3	ca					.byte $ca
>9fa4	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9fa8	c7					.byte $c7
>9fa9	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9fad	c4					.byte $c4
>9fae	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9fb2	c0					.byte $c0
>9fb3	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fb7	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fb8					SyntaxError:
.9fb8	a9 02		lda #$02		lda	#2
.9fba	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.9fbd					RangeError:
.9fbd	a9 04		lda #$04		lda	#4
.9fbf	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.9fc2					TypeError:
.9fc2	a9 05		lda #$05		lda	#5
.9fc4	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.9fc7					ArgumentError:
.9fc7	a9 07		lda #$07		lda	#7
.9fc9	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.9fcc					NotDoneError:
.9fcc	a9 0c		lda #$0c		lda	#12
.9fce	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.9fd1					ErrorText:
>9fd1	42 72 65 61 6b 00			.text	"Break",0
>9fd7	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fdf	72 72 6f 72 00
>9fe4	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9fec	20 62 79 20 7a 65 72 6f 00
>9ff5	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9ffd	61 6e 67 65 00
>a002	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a00a	6d 61 74 63 68 00
>a010	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a018	65 6d 6f 72 79 00
>a01e	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a026	61 72 67 75 6d 65 6e 74 00
>a02f	53 74 6f 70 00				.text	"Stop",0
>a034	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a03c	6f 6f 20 6c 6f 6e 67 00
>a044	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a04c	6e 20 66 61 69 6c 65 64 00
>a055	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a05d	61 74 61 00
>a061	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a069	65 6e 74 65 64 00
>a06f	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a077	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a083	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a08b	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a098	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a0a0	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a0ad	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0b5	68 6f 75 74 20 57 68 69 6c 65 00
>a0c0	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0c8	68 6f 75 74 20 46 6f 72 00
>a0d1	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0d9	61 63 6b 20 66 75 6c 6c 00
>a0e2	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0ea	75 63 74 75 72 65 00
>a0f1	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a0f9	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a106	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a10e	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a11c	41 72 72 61 79 20 73 69			.text	"Array size",0
>a124	7a 65 00
>a127	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a12f	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a137	42 75 69 6c 74 20 4d 6f			.text "Built Monday 21-Nov-2022. Build 3451."
>a13f	6e 64 61 79 20 32 31 2d 4e 6f 76 2d 32 30 32 32
>a14f	2e 20 42 75 69 6c 64 20 33 34 35 31 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a15c					RectangleCommand:
.a15c	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a15e	80 02		bra $a162			bra 	ShapeDrawCmd
.a160					CircleCommand:
.a160	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a162					ShapeDrawCmd:
.a162	20 f0 a1	jsr $a1f0			jsr 	RunGraphicsCommand
.a165					ShapeDraw:
.a165	0d 2f 06	ora $062f			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a168	4c e4 a1	jmp $a1e4			jmp 	ExecuteGraphicCommand	 	; and complete
.a16b					SpriteCommand:
.a16b	a2 00		ldx #$00			ldx 	#0
.a16d	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get image number.
.a170	5a		phy				phy
.a171	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a173	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a176	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a178	b0 0d		bcs $a187			bcs 	_SCRange
.a17a	a0 ff		ldy #$ff			ldy 	#255
.a17c	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a17f	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a181	7a		ply				ply
.a182	20 f0 a1	jsr $a1f0			jsr 	RunGraphicsCommand
.a185	80 5d		bra $a1e4			bra 	ExecuteGraphicCommand
.a187					_SCRange:
.a187	4c bd 9f	jmp $9fbd			jmp 	RangeError
.a18a					ImageCommand:
.a18a	a2 00		ldx #$00			ldx 	#0
.a18c	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get image number.
.a18f	20 f0 a1	jsr $a1f0			jsr 	RunGraphicsCommand
.a192					ImageRunDraw:
.a192	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a194	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a197	ad 35 06	lda $0635			lda 	gxDrawScale
.a19a	0a		asl a				asl 	a
.a19b	0a		asl a				asl 	a
.a19c	0a		asl a				asl 	a
.a19d	a8		tay				tay
.a19e	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a1a0	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a1a3	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a1a6	60		rts				rts
.a1a7					TextCommand:
.a1a7	a2 00		ldx #$00			ldx 	#0
.a1a9	20 62 9d	jsr $9d62			jsr 	EvaluateString 				; get text
.a1ac	20 f0 a1	jsr $a1f0			jsr 	RunGraphicsCommand
.a1af					TextRunDraw:
.a1af	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1b1	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a1b4	a0 00		ldy #$00			ldy 	#0
.a1b6					_IRDLoop:
.a1b6	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a1b9	85 37		sta $37				sta 	zTemp0+1
.a1bb	ad 08 04	lda $0408			lda 	NSMantissa0
.a1be	85 36		sta $36				sta 	zTemp0
.a1c0	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1c2	f0 13		beq $a1d7			beq 	_IRDExit
.a1c4	5a		phy				phy									; save string pos
.a1c5	48		pha				pha 								; save char
.a1c6	ad 35 06	lda $0635			lda 	gxDrawScale 				; get scale
.a1c9	0a		asl a				asl 	a
.a1ca	0a		asl a				asl 	a
.a1cb	0a		asl a				asl 	a
.a1cc	a8		tay				tay
.a1cd	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1cf	fa		plx				plx 								; char to draw
.a1d0	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a1d3	7a		ply				ply 								; restore string pos
.a1d4	c8		iny				iny
.a1d5	90 df		bcc $a1b6			bcc 	_IRDLoop 					; go back if no error.
.a1d7					_IRDExit:
.a1d7	60		rts				rts
.a1d8					PlotCommand:
.a1d8	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1da	20 f0 a1	jsr $a1f0			jsr 	RunGraphicsCommand
.a1dd	80 05		bra $a1e4			bra 	ExecuteGraphicCommand
.a1df					LineCommand:
.a1df	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1e1	20 f0 a1	jsr $a1f0			jsr 	RunGraphicsCommand
.a1e4					ExecuteGraphicCommand:
.a1e4	0d 2e 06	ora $062e			ora 	gxCommandID 				; make a full command
.a1e7	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw 				; draw it and exit
.a1ea	b0 01		bcs $a1ed			bcs 	_EGCError
.a1ec	60		rts				rts
.a1ed					_EGCError:
.a1ed	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.a1f0					RunGraphicsCommand:
.a1f0	8d 2e 06	sta $062e			sta 	gxCommandID					; save TODO graphics command.
.a1f3	68		pla				pla 								; pop handler address
.a1f4	fa		plx				plx
.a1f5	1a		inc a				inc 	a
.a1f6	d0 01		bne $a1f9			bne 	_RGINoCarry
.a1f8	e8		inx				inx
.a1f9					_RGINoCarry:
.a1f9	8d 33 06	sta $0633			sta 	GXHandler
.a1fc	8e 34 06	stx $0634			stx 	GXHandler+1
.a1ff					_RGICommandLoop:
.a1ff	b1 30		lda ($30),y			lda 	(codePtr),y
.a201	c8		iny				iny
.a202	c9 cd		cmp #$cd			cmp 	#KWD_TO						; is it TO x,y
.a204	f0 53		beq $a259			beq 	_RGI_To
.a206	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a208	f0 55		beq $a25f			beq 	_RGI_Here
.a20a	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a20c	f0 3d		beq $a24b			beq 	_RGI_Exit
.a20e	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a210	f0 39		beq $a24b			beq 	_RGI_Exit
.a212	c9 c1		cmp #$c1			cmp 	#KWD_OUTLINE 				; solid or outline
.a214	f0 3e		beq $a254			beq 	_RGI_Frame
.a216	c9 c9		cmp #$c9			cmp 	#KWD_SOLID
.a218	f0 33		beq $a24d			beq 	_RGI_Solid
.a21a	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a21c	f0 4b		beq $a269			beq 	_RGI_By
.a21e	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a220	f0 17		beq $a239			beq 	_RGI_Move2
.a222	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a224	f0 65		beq $a28b			beq 	_RGI_Dim
.a226	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a228	f0 78		beq $a2a2			beq 	_RGI_Colour
.a22a	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a22c	f0 74		beq $a2a2			beq 	_RGI_Colour
.a22e	ae 2e 06	ldx $062e			ldx 	gxCommandID
.a231	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a233	d0 03		bne $a238			bne 	_RGI_Move 					; move
.a235	4c cc a2	jmp $a2cc			jmp		_RGI_SpriteInstructions
.a238					_RGI_Move:
.a238	88		dey				dey 								; unpick get.
.a239					_RGI_Move2:
.a239	20 f2 a2	jsr $a2f2			jsr 	GCGetCoordinatePair 		; move to here
.a23c	20 19 a3	jsr $a319			jsr 	GCCopyPairToStore 			; save
.a23f	5a		phy				phy
.a240	20 0f a3	jsr $a30f			jsr 	GCLoadAXY 					; load in
.a243	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a245	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a248	7a		ply				ply
.a249	80 b4		bra $a1ff			bra 	_RGICommandLoop 			; and go round
.a24b					_RGI_Exit:
.a24b	88		dey				dey 								; unpick : / EOL
.a24c	60		rts				rts
.a24d					_RGI_Solid:
.a24d	a9 02		lda #$02			lda 	#2
.a24f	8d 2f 06	sta $062f			sta 	gxFillSolid
.a252	80 ab		bra $a1ff			bra 	_RGICommandLoop
.a254					_RGI_Frame:
.a254	9c 2f 06	stz $062f			stz 	gxFillSolid
.a257	80 a6		bra $a1ff			bra 	_RGICommandLoop
.a259					_RGI_To:
.a259	20 f2 a2	jsr $a2f2			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a25c	20 19 a3	jsr $a319			jsr 	GCCopyPairToStore
.a25f					_RGI_Here:
.a25f	5a		phy				phy
.a260	20 0f a3	jsr $a30f			jsr 	GCLoadAXY 					; load it into AXY
.a263	20 c9 a2	jsr $a2c9			jsr 	_RGICallHandler 			; go do whatever it is.
.a266	7a		ply				ply
.a267	80 96		bra $a1ff			bra 	_RGICommandLoop 			; and go round
.a269					_RGI_By:
.a269	20 ff a2	jsr $a2ff			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a26c	18		clc				clc
.a26d	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a270	6d 30 06	adc $0630			adc 	gxxPos
.a273	8d 30 06	sta $0630			sta 	gxXPos
.a276	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a279	6d 31 06	adc $0631			adc 	gxxPos+1
.a27c	8d 31 06	sta $0631			sta 	gxXPos+1
.a27f	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a282	18		clc				clc
.a283	6d 32 06	adc $0632			adc 	gxYPos
.a286	8d 32 06	sta $0632			sta 	gxYPos
.a289	80 d4		bra $a25f			bra 	_RGI_Here
.a28b					_RGI_Dim:
.a28b	a2 01		ldx #$01			ldx	 	#1
.a28d	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger
.a290	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a293	c9 00		cmp #$00			cmp 	#0
.a295	f0 2f		beq $a2c6			beq 	_RGIRange
.a297	c9 09		cmp #$09			cmp 	#8+1
.a299	b0 2b		bcs $a2c6			bcs		_RGIRange
.a29b	3a		dec a				dec 	a
.a29c	8d 35 06	sta $0635			sta 	gxDrawScale
.a29f	4c ff a1	jmp $a1ff			jmp 	_RGICommandLoop
.a2a2					_RGI_Colour:
.a2a2	a2 01		ldx #$01			ldx 	#1 							; colour
.a2a4	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger
.a2a7	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a2a9	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero
.a2ac	b1 30		lda ($30),y			lda 	(codePtr),y
.a2ae	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a2b0	d0 04		bne $a2b6			bne 	_RGICDefaultMode
.a2b2	c8		iny				iny
.a2b3	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger
.a2b6					_RGICDefaultMode:
.a2b6	5a		phy				phy
.a2b7	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2b9	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a2bc	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a2bf	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a2c2	7a		ply				ply
.a2c3	4c ff a1	jmp $a1ff			jmp 	_RGICommandLoop 			; and go round
.a2c6					_RGIRange:
.a2c6	4c bd 9f	jmp $9fbd			jmp 	RangeError
.a2c9					_RGICallHandler:
.a2c9	6c 33 06	jmp ($0633)			jmp 	(GXHandler)
.a2cc					_RGI_SpriteInstructions:
.a2cc	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a2ce	f0 07		beq $a2d7			beq 	_RGISpriteOff
.a2d0	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a2d2	f0 13		beq $a2e7			beq 	_RGISetImage
.a2d4	4c 38 a2	jmp $a238			jmp 	_RGI_Move
.a2d7					_RGISpriteOff:
.a2d7	5a		phy				phy
.a2d8	a0 01		ldy #$01			ldy 	#1
.a2da	a2 00		ldx #$00			ldx 	#0
.a2dc					_RGIDoCommandLoop:
.a2dc	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2de	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a2e1	7a		ply				ply
.a2e2	b0 e2		bcs $a2c6			bcs 	_RGIRange
.a2e4	4c ff a1	jmp $a1ff			jmp 	_RGICommandLoop
.a2e7					_RGISetImage:
.a2e7	a2 01		ldx #$01			ldx 	#1
.a2e9	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger
.a2ec	5a		phy				phy
.a2ed	aa		tax				tax
.a2ee	a0 00		ldy #$00			ldy 	#0
.a2f0	80 ea		bra $a2dc			bra 	_RGIDoCommandLoop
.a2f2					GCGetCoordinatePair:
.a2f2	a2 01		ldx #$01			ldx 	#1
.a2f4	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.a2f7	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a2fa	e8		inx				inx
.a2fb	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.a2fe	60		rts				rts
.a2ff					GCSignedCoordinatePair:
.a2ff	a2 01		ldx #$01			ldx 	#1
.a301	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitIntegerSigned
.a304	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a307	e8		inx				inx
.a308	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitIntegerSigned
.a30b	60		rts				rts
.a30c					_GCCPRange:
.a30c	4c bd 9f	jmp $9fbd			jmp 	RangeError
.a30f					GCLoadAXY:
.a30f	ad 31 06	lda $0631			lda 	gxXPos+1
.a312	ae 30 06	ldx $0630			ldx 	gxXPos
.a315	ac 32 06	ldy $0632			ldy 	gxYPos
.a318	60		rts				rts
.a319					GCCopyPairToStore:
.a319	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a31c	8d 30 06	sta $0630			sta 	gxXPos
.a31f	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a322	8d 31 06	sta $0631			sta 	gxXPos+1
.a325	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a328	8d 32 06	sta $0632			sta 	gxYPos
.a32b	60		rts				rts
.062e					gxCommandID:
>062e							.fill 	1
.062f					gxFillSolid:
>062f							.fill 	1
.0630					gxXPos:
>0630							.fill 	2
.0632					gxYPos:
>0632							.fill 	1
.0633					gxHandler:
>0633							.fill 	2
.0635					gxDrawScale:
>0635							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a32c					BitmapCtrl:
.a32c	b1 30		lda ($30),y			lda 	(codePtr),y
.a32e	c8		iny				iny
.a32f	a2 01		ldx #$01			ldx 	#1
.a331	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a333	f0 11		beq $a346			beq 	BitmapSwitch
.a335	ca		dex				dex
.a336	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a338	f0 0c		beq $a346			beq 	BitmapSwitch
.a33a	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get the colour
.a33d	5a		phy				phy
.a33e	aa		tax				tax
.a33f	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a341	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a344	7a		ply				ply
.a345	60		rts				rts
.a346					BitmapSwitch:
.a346	5a		phy				phy
.a347	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a349	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a34b	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a34e	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a350	a0 00		ldy #$00			ldy 	#0
.a352	a2 ff		ldx #$ff			ldx 	#$FF
.a354	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a357	9c 2f 06	stz $062f			stz 	gxFillSolid
.a35a	9c 30 06	stz $0630			stz 	gxXPos
.a35d	9c 31 06	stz $0631			stz 	gxXPos+1
.a360	9c 32 06	stz $0632			stz 	gxYPos
.a363	9c 35 06	stz $0635			stz 	gxDrawScale
.a366	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a368	a2 00		ldx #$00			ldx 	#0
.a36a	a0 00		ldy #$00			ldy 	#0
.a36c	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a36f	7a		ply				ply
.a370	60		rts				rts
.a371					SpritesCtrl:
.a371	b1 30		lda ($30),y			lda 	(codePtr),y
.a373	c8		iny				iny
.a374	a2 01		ldx #$01			ldx 	#1
.a376	c9 c0		cmp #$c0			cmp 	#KWD_ON
.a378	f0 08		beq $a382			beq 	SpriteSwitch
.a37a	ca		dex				dex
.a37b	c9 bf		cmp #$bf			cmp 	#KWD_OFF
.a37d	f0 03		beq $a382			beq 	SpriteSwitch
.a37f	4c b8 9f	jmp $9fb8			jmp 	SyntaxError
.a382					SpriteSwitch:
.a382	5a		phy				phy
.a383	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a385	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a387	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a38a	7a		ply				ply
.a38b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a38c					GfxCommand:
.a38c	a2 00		ldx #$00			ldx 	#0
.a38e	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; command
.a391	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a394	e8		inx				inx
.a395	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger 		; X
.a398	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a39b	e8		inx				inx
.a39c	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; Y
.a39f	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a3a2	4a		lsr a				lsr 	a
.a3a3	d0 16		bne $a3bb			bne 	_GfxError
.a3a5	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a3a8	b0 11		bcs $a3bb			bcs 	_GfxError 					; bit 7 should have been zero
.a3aa	5a		phy				phy 								; save pos
.a3ab	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a3ae	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a3b1	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a3b4	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw
.a3b7	b0 02		bcs $a3bb			bcs 	_GfxError
.a3b9	7a		ply				ply 								; restore pos and exit.
.a3ba	60		rts				rts
.a3bb					_GfxError:
.a3bb	4c bd 9f	jmp $9fbd			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a3be					UnaryHit:
.a3be	fa		plx				plx
.a3bf	a9 36		lda #$36			lda 	#zTemp0
.a3c1	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3c4	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a3c7	e8		inx				inx
.a3c8	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3cb	20 52 8d	jsr $8d52			jsr		CheckRightBracket
.a3ce	ca		dex				dex 								; fix back up again.
.a3cf	da		phx				phx 								; save X/Y
.a3d0	5a		phy				phy
.a3d1	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3d4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a3d7	aa		tax				tax
.a3d8	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3da	20 b3 aa	jsr $aab3			jsr 	GXGraphicDraw 				; calculate result
.a3dd	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3de	7a		ply				ply 								; restore XY
.a3df	fa		plx				plx
.a3e0	20 30 9e	jsr $9e30			jsr 	NSMSetByte 					; return the hit result
.a3e3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3e4					PaletteCommand:
.a3e4	a2 00		ldx #$00			ldx 	#0
.a3e6	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; colour
.a3e9	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a3ec	e8		inx				inx
.a3ed	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger 		; r
.a3f0	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a3f3	e8		inx				inx
.a3f4	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; g
.a3f7	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a3fa	e8		inx				inx
.a3fb	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; b
.a3fe	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a401	85 36		sta $36				sta 	zTemp0
.a403	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a405	85 37		sta $37				sta 	zTemp0+1
.a407	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a409	26 37		rol $37				rol	 	zTemp0+1
.a40b	06 36		asl $36				asl 	zTemp0
.a40d	26 37		rol $37				rol	 	zTemp0+1
.a40f	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a411	85 01		sta $01				sta 	1
.a413	5a		phy				phy
.a414	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a417	92 36		sta ($36)			sta 	(zTemp0)
.a419	a0 01		ldy #$01			ldy 	#1
.a41b	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a41e	91 36		sta ($36),y			sta 	(zTemp0),y
.a420	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a423	c8		iny				iny
.a424	91 36		sta ($36),y			sta 	(zTemp0),y
.a426	7a		ply				ply
.a427	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a428					UnaryEvent:
.a428	fa		plx				plx
.a429	20 d0 a4	jsr $a4d0			jsr 	TimerToStackX 				; timer in +0
.a42c	e8		inx				inx  								; put reference into +1
.a42d	20 f4 97	jsr $97f4			jsr 	EvaluateTerm
.a430	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a433	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a435	d0 57		bne $a48e			bne 	_UEType
.a437	e8		inx				inx 								; put the step in +2
.a438	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a43b	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger
.a43e	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.a441	ca		dex				dex
.a442	ca		dex				dex
.a443	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a446	85 36		sta $36				sta 	zTemp0
.a448	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a44b	85 37		sta $37				sta 	zTemp0+1
.a44d	5a		phy				phy
.a44e	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a450	b1 36		lda ($36),y			lda 	(zTemp0),y
.a452	30 36		bmi $a48a			bmi 	_UEFalse 					; exit if signed.
.a454	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a456	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a459	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a45b	c8		iny				iny
.a45c	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a45f	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a461	c8		iny				iny
.a462	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a465	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a467	90 21		bcc $a48a			bcc 	_UEFalse 					; no, return FALSE.
.a469	18		clc				clc
.a46a	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a46c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a46f	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a472	91 36		sta ($36),y			sta 	(zTemp0),y
.a474	c8		iny				iny
.a475	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a478	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a47b	91 36		sta ($36),y			sta 	(zTemp0),y
.a47d	c8		iny				iny
.a47e	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a481	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a484	91 36		sta ($36),y			sta 	(zTemp0),y
.a486	7a		ply				ply
.a487	4c d8 8d	jmp $8dd8			jmp 	ReturnTrue
.a48a					_UEFalse:
.a48a	7a		ply				ply 								; restore Y
.a48b	4c e4 8d	jmp $8de4			jmp 	ReturnFalse 				; and return False
.a48e					_UEType:
.a48e	4c c2 9f	jmp $9fc2			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a491					UnaryJoyX:
.a491	18		clc				clc
.a492	80 01		bra $a495			bra 	JoyMain
.a494					UnaryJoyY:
.a494	38		sec				sec
.a495					JoyMain:
.a495	fa		plx				plx 								; get pos
.a496	08		php				php 								; save carry (set for Y)
.a497	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a49a	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.a49d	20 6c aa	jsr $aa6c			jsr 	EXTReadController 			; read the controller.
.a4a0	28		plp				plp
.a4a1	90 02		bcc $a4a5			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a4a3	4a		lsr a				lsr 	a
.a4a4	4a		lsr a				lsr 	a
.a4a5					_JMNoShift:
.a4a5	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a4a6	b0 0a		bcs $a4b2			bcs 	_JMIsRight
.a4a8	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a4a9	b0 04		bcs $a4af			bcs 	_JMIsLeft
.a4ab	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero 					; zero result
.a4ae	60		rts				rts
.a4af					_JMIsLeft:
.a4af	4c d8 8d	jmp $8dd8			jmp 	ReturnTrue
.a4b2					_JMIsRight:
.a4b2	a9 01		lda #$01			lda 	#1
.a4b4	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.a4b7	60		rts				rts
.a4b8					UnaryJoyB:
.a4b8	fa		plx				plx 								; get pos
.a4b9	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a4bc	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.a4bf	20 6c aa	jsr $aa6c			jsr 	EXTReadController 			; read the controller.
.a4c2	4a		lsr a				lsr 	a
.a4c3	4a		lsr a				lsr 	a
.a4c4	4a		lsr a				lsr 	a
.a4c5	4a		lsr a				lsr 	a
.a4c6	29 01		and #$01			and 	#1
.a4c8	20 30 9e	jsr $9e30			jsr 	NSMSetByte
.a4cb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4cc					UnaryTimer:
.a4cc	fa		plx				plx
.a4cd	20 52 8d	jsr $8d52			jsr 	CheckRightBracket
.a4d0					TimerToStackX:
.a4d0	20 2e 9e	jsr $9e2e			jsr 	NSMSetZero 					; zero result
.a4d3	64 01		stz $01				stz 	1 							; access I/O
.a4d5	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4d8	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a4db	ad 5a d6	lda $d65a			lda 	$D65A
.a4de	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a4e1	ad 5b d6	lda $d65b			lda 	$D65B
.a4e4	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a4e7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4e8					MemoryDeleteLine:
.a4e8	20 07 a5	jsr $a507			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4eb	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4ed	a8		tay				tay
.a4ee					_MDDLLoop:
.a4ee	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4f0	92 30		sta ($30)			sta 	(codePtr)
.a4f2	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4f4	c5 3a		cmp $3a				cmp 	zTemp2
.a4f6	d0 07		bne $a4ff			bne 	_MDLDLNext
.a4f8	a5 31		lda $31				lda 	codePtr+1
.a4fa	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4fc	d0 01		bne $a4ff			bne 	_MDLDLNext
.a4fe					_MDDLExit:
.a4fe	60		rts				rts
.a4ff					_MDLDLNext:
.a4ff	e6 30		inc $30				inc 	codePtr						; next byte
.a501	d0 eb		bne $a4ee			bne 	_MDDLLoop
.a503	e6 31		inc $31				inc 	codePtr+1
.a505	80 e7		bra $a4ee			bra 	_MDDLLoop
.a507					IMemoryFindEnd:
.a507	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a509	85 3a		sta $3a				sta 	0+zTemp2
.a50b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a50d	85 3b		sta $3b				sta 	1+zTemp2
.a50f					_MDLFELoop:
.a50f	b2 3a		lda ($3a)			lda 	(zTemp2)
.a511	f0 0b		beq $a51e			beq 	_MDLFEExit
.a513	18		clc				clc
.a514	65 3a		adc $3a				adc 	zTemp2
.a516	85 3a		sta $3a				sta 	zTemp2
.a518	90 f5		bcc $a50f			bcc 	_MDLFELoop
.a51a	e6 3b		inc $3b				inc 	zTemp2+1
.a51c	80 f1		bra $a50f			bra 	_MDLFELoop
.a51e					_MDLFEExit:
.a51e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a51f					MemoryInsertLine:
.a51f	08		php				php
.a520	20 07 a5	jsr $a507			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a523	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a525	1a		inc a				inc 	a
.a526	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a528	b0 36		bcs $a560			bcs 	_MDLIError
.a52a	28		plp				plp
.a52b	90 08		bcc $a535			bcc 	_MDLIFound
.a52d	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a52f	85 30		sta $30				sta 	codePtr
.a531	a5 3b		lda $3b				lda 	zTemp2+1
.a533	85 31		sta $31				sta 	codePtr+1
.a535					_MDLIFound:
.a535	ad a8 04	lda $04a8			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a538	a8		tay				tay
.a539					_MDLIInsert:
.a539	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a53b	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a53d	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a53f	c5 3a		cmp $3a				cmp 	zTemp2
.a541	d0 06		bne $a549			bne 	_MDLINext
.a543	a5 31		lda $31				lda 	codePtr+1
.a545	c5 3b		cmp $3b				cmp 	zTemp2+1
.a547	f0 0a		beq $a553			beq 	_MDLIHaveSpace
.a549					_MDLINext:
.a549	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a54b	d0 02		bne $a54f			bne 	_MDLINoBorrow
.a54d	c6 3b		dec $3b				dec 	zTemp2+1
.a54f					_MDLINoBorrow:
.a54f	c6 3a		dec $3a				dec 	zTemp2
.a551	80 e6		bra $a539			bra 	_MDLIInsert
.a553					_MDLIHaveSpace:
.a553	ac a8 04	ldy $04a8			ldy 	tokenOffset 				; bytes to copy
.a556	88		dey				dey 								; from offset-1 to 0
.a557					_MDLICopy:
.a557	b9 a8 04	lda $04a8,y			lda 	tokenOffset,y
.a55a	91 30		sta ($30),y			sta 	(codePtr),y
.a55c	88		dey				dey
.a55d	10 f8		bpl $a557			bpl 	_MDLICopy
.a55f	60		rts				rts
.a560					_MDLIError:
.a560	a9 06		lda #$06		lda	#6
.a562	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.a565					MDLAppendLine:
.a565	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a567	85 36		sta $36				sta 	zTemp0
.a569	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a56b	85 38		sta $38				sta 	0+zTemp1
.a56d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a56f	85 39		sta $39				sta 	1+zTemp1
.a571	b2 38		lda ($38)			lda 	(zTemp1)
.a573	d0 0a		bne $a57f			bne 	_MDLANoInitialise
.a575	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a577	8d 36 06	sta $0636			sta 	0+AppendPointer
.a57a	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a57c	8d 37 06	sta $0637			sta 	1+AppendPointer
.a57f					_MDLANoInitialise:
.a57f	18		clc				clc
.a580	ad 36 06	lda $0636			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a583	85 38		sta $38				sta 	zTemp1
.a585	72 36		adc ($36)			adc 	(zTemp0)
.a587	8d 36 06	sta $0636			sta 	AppendPointer
.a58a	ad 37 06	lda $0637			lda 	AppendPointer+1
.a58d	85 39		sta $39				sta 	zTemp1+1
.a58f	69 00		adc #$00			adc 	#0
.a591	8d 37 06	sta $0637			sta 	AppendPointer+1
.a594	a0 00		ldy #$00			ldy 	#0
.a596					_MDLACopy:
.a596	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a598	91 38		sta ($38),y			sta 	(zTemp1),y
.a59a	c8		iny				iny
.a59b	98		tya				tya
.a59c	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a59e	d0 f6		bne $a596			bne 	_MDLACopy
.a5a0	a9 00		lda #$00			lda 	#0 							; end of program.
.a5a2	91 38		sta ($38),y			sta 	(zTemp1),y
.a5a4	60		rts				rts
.0636					AppendPointer:
>0636							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a5a5					MemoryNew:
.a5a5	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a7	85 30		sta $30				sta 	codePtr
.a5a9	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5ab	85 31		sta $31				sta 	codePtr+1
.a5ad	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a5af	92 30		sta ($30)			sta 	(codePtr)
.a5b1	60		rts				rts
.a5b2					MemoryInline:
.a5b2	98		tya				tya 								; put address into stack,x
.a5b3	18		clc				clc
.a5b4	65 30		adc $30				adc 	codePtr
.a5b6	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a5b9	a5 31		lda $31				lda 	codePtr+1
.a5bb	69 00		adc #$00			adc 	#0
.a5bd	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a5c0	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a5c3	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a5c6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a5c7					MemorySearch:
.a5c7	85 36		sta $36				sta 	zTemp0 						; save line number zTemp0
.a5c9	86 37		stx $37				stx 	zTemp0+1
.a5cb	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5cd	85 30		sta $30				sta 	codePtr
.a5cf	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5d1	85 31		sta $31				sta 	codePtr+1
.a5d3					_MTAXLoop:
.a5d3	b2 30		lda ($30)			lda 	(codePtr)
.a5d5	18		clc				clc
.a5d6	f0 21		beq $a5f9			beq 	_MTAXExit 					; reached end, exit with CC.
.a5d8	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5da	b1 30		lda ($30),y			lda 	(codePtr),y
.a5dc	38		sec				sec
.a5dd	e5 36		sbc $36				sbc 	zTemp0
.a5df	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5e1	c8		iny				iny 								; do the MSB
.a5e2	b1 30		lda ($30),y			lda 	(codePtr),y
.a5e4	e5 37		sbc $37				sbc 	zTemp0+1
.a5e6	05 38		ora $38				ora 	zTemp1
.a5e8	f0 0f		beq $a5f9			beq 	_MTAXExit	 				; found
.a5ea	b0 0d		bcs $a5f9			bcs 	_MTAXExit 					; current < required exit
.a5ec	18		clc				clc
.a5ed	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.a5ef	65 30		adc $30				adc 	codePtr
.a5f1	85 30		sta $30				sta 	codePtr
.a5f3	90 02		bcc $a5f7			bcc 	_CREExit
.a5f5	e6 31		inc $31				inc 	codePtr+1
.a5f7					_CREExit:
.a5f7	80 da		bra $a5d3			bra 	_MTAXLoop
.a5f9					_MTAXExit:
.a5f9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a5fa					SoundCommand:
.a5fa	b1 30		lda ($30),y			lda 	(codePtr),y
.a5fc	c9 bf		cmp #$bf			cmp 	#KWD_OFF 					; SOUND OFF ?
.a5fe	d0 09		bne $a609			bne 	_SNDMain
.a600	c8		iny				iny 								; skip OFF
.a601	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a603	5a		phy				phy
.a604	20 41 b9	jsr $b941			jsr 	SNDCommand
.a607	7a		ply				ply
.a608	60		rts				rts
.a609					_SNDMain:
.a609	a2 00		ldx #$00			ldx 	#0
.a60b	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; channel
.a60e	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a610	b0 50		bcs $a662			bcs 	_SndError
.a612	e8		inx				inx 								; do the rest in slot 1.
.a613	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a616	20 8f 9d	jsr $9d8f			jsr 	Evaluate16BitInteger 		; Pitch
.a619	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a61c	c9 10		cmp #$10			cmp 	#16
.a61e	b0 42		bcs $a662			bcs 	_SndError
.a620	8d 39 06	sta $0639			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a623	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a626	8d 38 06	sta $0638			sta 	SoundCommandBlock
.a629	20 5a 8d	jsr $8d5a			jsr 	CheckComma
.a62c	20 af 9d	jsr $9daf			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a62f	8d 3b 06	sta $063b			sta 	SoundCommandBlock+3
.a632	a9 0f		lda #$0f			lda 	#15
.a634	8d 3a 06	sta $063a			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a637	9c 3c 06	stz $063c			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a63a	9c 3d 06	stz $063d			stz 	SoundCommandBlock+5
.a63d	b1 30		lda ($30),y			lda 	(codePtr),y
.a63f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a641	d0 10		bne $a653			bne 	_SNDPlay
.a643	c8		iny				iny
.a644	20 9b 9d	jsr $9d9b			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a647	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a64a	8d 3c 06	sta $063c			sta 	SoundCommandBlock+4
.a64d	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a650	8d 3d 06	sta $063d			sta 	SoundCommandBlock+5
.a653					_SNDPlay:
.a653	5a		phy				phy
.a654	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a657	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a659	a2 38		ldx #$38			ldx 	#(SoundCommandBlock & $FF)
.a65b	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a65d	20 41 b9	jsr $b941			jsr 	SNDCommand
.a660	7a		ply				ply
.a661	60		rts				rts
.a662					_SndError:
.a662	4c bd 9f	jmp $9fbd			jmp 	RangeError
.0638					SoundCommandBlock:
>0638							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a665					StackPushByte:
.a665	48		pha				pha 								; save byte
.a666	a5 34		lda $34				lda 	BasicStack
.a668	d0 09		bne $a673			bne 	_SPBNoBorrow
.a66a	c6 35		dec $35				dec 	BasicStack+1
.a66c	48		pha				pha
.a66d	a5 35		lda $35				lda 	BasicStack+1
.a66f	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a671	90 06		bcc $a679			bcc 	_SPBMemory
.a673					_SPBNoBorrow:
.a673	c6 34		dec $34				dec 	BasicStack
.a675	68		pla				pla 								; get back and write
.a676	92 34		sta ($34)			sta 	(BasicStack)
.a678	60		rts				rts
.a679					_SPBMemory:
.a679	a9 12		lda #$12		lda	#18
.a67b	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.a67e					StackPopByte:
.a67e	b2 34		lda ($34)			lda 	(BasicStack)
.a680	e6 34		inc $34				inc 	BasicStack
.a682	d0 02		bne $a686			bne 	_SPBNoCarry
.a684	e6 35		inc $35				inc 	BasicStack+1
.a686					_SPBNoCarry:
.a686	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a687					StackOpen:
.a687	48		pha				pha 								; save frame byte
.a688	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a68a	0a		asl a				asl 	a 							; claim twice this for storage
.a68b	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a68d	38		sec				sec 								; so basically subtracting from
.a68e	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a690	85 34		sta $34				sta 	basicStack
.a692	b0 08		bcs $a69c			bcs 	_SONoBorrow
.a694	c6 35		dec $35				dec 	basicStack+1
.a696	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a698	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a69a	90 04		bcc $a6a0			bcc 	_SOMemory
.a69c					_SONoBorrow:
.a69c	68		pla				pla 								; get marker back and write at TOS
.a69d	92 34		sta ($34)			sta 	(basicStack)
.a69f	60		rts				rts
.a6a0					_SOMemory:
.a6a0	a9 12		lda #$12		lda	#18
.a6a2	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.a6a5					StackClose:
.a6a5	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6a7	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6a9	0a		asl a				asl 	a 							; claim twice this.
.a6aa	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a6ac	85 34		sta $34				sta 	basicStack
.a6ae	90 02		bcc $a6b2			bcc 	_SCExit
.a6b0	e6 35		inc $35				inc 	basicStack+1
.a6b2					_SCExit:
.a6b2	60		rts				rts
.a6b3					StackCheckFrame:
.a6b3	48		pha				pha
.a6b4					_StackRemoveLocals:
.a6b4	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a6b6	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a6b8	b0 05		bcs $a6bf			bcs 	_SCNoLocal
.a6ba	20 02 88	jsr $8802			jsr 	LocalPopValue
.a6bd	80 f5		bra $a6b4			bra 	_StackRemoveLocals
.a6bf					_SCNoLocal:
.a6bf	68		pla				pla
.a6c0	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a6c2	29 f0		and #$f0			and 	#$F0 						; check type bits
.a6c4	d0 01		bne $a6c7			bne 	_SCFError 					; different, we have structures mixed up
.a6c6	60		rts				rts
.a6c7					_SCFError:
.a6c7	8a		txa				txa 								; report error X
.a6c8	4c 6b 8d	jmp $8d6b			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a6cb					STKSaveCodePosition:
.a6cb	5a		phy				phy
.a6cc	98		tya				tya 								; save Y
.a6cd	a0 05		ldy #$05			ldy 	#5
.a6cf	91 34		sta ($34),y			sta 	(basicStack),y
.a6d1	88		dey				dey 								; save Code Pointer
.a6d2					_STKSaveLoop:
.a6d2	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a6d5	91 34		sta ($34),y			sta 	(basicStack),y
.a6d7	88		dey				dey
.a6d8	d0 f8		bne $a6d2			bne 	_STKSaveLoop
.a6da	7a		ply				ply
.a6db	60		rts				rts
.a6dc					STKLoadCodePosition:
.a6dc	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a6de					_STKLoadLoop:
.a6de	b1 34		lda ($34),y			lda 	(basicStack),y
.a6e0	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a6e3	c8		iny				iny
.a6e4	c0 05		cpy #$05			cpy 	#5
.a6e6	d0 f6		bne $a6de			bne 	_STKLoadLoop
.a6e8	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a6ea	a8		tay				tay
.a6eb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a6ec					StackReset:
.a6ec	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a6ee	85 34		sta $34				sta 	0+basicStack
.a6f0	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a6f2	85 35		sta $35				sta 	1+basicStack
.a6f4	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a6f6	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a6f8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a6f9					StringConcrete:
.a6f9	5a		phy				phy 								; save position on stack
.a6fa	20 f7 99	jsr $99f7			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a6fd	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a700	85 38		sta $38				sta 	zTemp1
.a702	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a705	85 39		sta $39				sta 	zTemp1+1
.a707	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a709					_SALength:
.a709	c8		iny				iny
.a70a	b1 38		lda ($38),y			lda 	(zTemp1),y
.a70c	d0 fb		bne $a709			bne 	_SALength
.a70e	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a710	b0 3f		bcs $a751			bcs 	_SALengthError
.a712	98		tya				tya 				 				; length of the new string
.a713	18		clc				clc
.a714	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a716	90 02		bcc $a71a			bcc 	_SAHaveLength
.a718	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a71a					_SAHaveLength:
.a71a	48		pha				pha 								; save length.
.a71b	38		sec				sec
.a71c	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a71e	6d 8e 04	adc $048e			adc 	StringMemory
.a721	8d 8e 04	sta $048e			sta 	StringMemory
.a724	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a726	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a729	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a72b	6d 8f 04	adc $048f			adc 	StringMemory+1
.a72e	8d 8f 04	sta $048f			sta 	StringMemory+1
.a731	85 3b		sta $3b				sta 	zTemp2+1
.a733	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a736	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a737	38		sec				sec
.a738	e9 03		sbc #$03			sbc 	#3
.a73a	92 3a		sta ($3a)			sta 	(zTemp2)
.a73c	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a73e	a0 01		ldy #$01			ldy 	#1
.a740	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a742					_SACopyNewString:
.a742	a0 00		ldy #$00			ldy 	#0
.a744					_SACopyNSLoop:
.a744	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a746	c8		iny				iny 								; write two on in string storage
.a747	c8		iny				iny
.a748	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a74a	88		dey				dey 								; this makes it one one.
.a74b	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a74d	d0 f5		bne $a744			bne 	_SACopyNSLoop
.a74f	7a		ply				ply
.a750	60		rts				rts
.a751					_SALengthError:
.a751	a9 09		lda #$09		lda	#9
.a753	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a756					StringSystemInitialise:
.a756	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a758	8d 8e 04	sta $048e			sta 	0+StringMemory
.a75b	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a75d	8d 8f 04	sta $048f			sta 	1+StringMemory
.a760	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a763	60		rts				rts
.a764					StringSpaceInitialise:
.a764	20 f7 99	jsr $99f7			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a767	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a769	8d 90 04	sta $0490			sta 	StringInitialised
.a76c	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a76f	8d 91 04	sta $0491			sta 	StringTempPointer
.a772	ad 8f 04	lda $048f			lda 	StringMemory+1
.a775	3a		dec a				dec 	a
.a776	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a779	60		rts				rts
.a77a					StringTempAllocate:
.a77a	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a77c	b0 35		bcs $a7b3			bcs 	_STALength
.a77e	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a781	30 05		bmi $a788			bmi 	_STAAllocate
.a783	48		pha				pha 								; save value to subtract.
.a784	20 64 a7	jsr $a764			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a787	68		pla				pla 								; restore it
.a788					_STAAllocate:
.a788	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a78a	18		clc				clc  								; deliberate allows one more
.a78b	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a78e	8d 91 04	sta $0491			sta 	StringTempPointer
.a791	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a794	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a796	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a799	69 ff		adc #$ff			adc 	#$FF
.a79b	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a79e	85 3d		sta $3d				sta 	zsTemp+1
.a7a0	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a7a3	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a7a6	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a7a9	a9 10		lda #$10			lda 	#NSTString
.a7ab	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a7ae	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7b0	92 3c		sta ($3c)			sta 	(zsTemp)
.a7b2	60		rts				rts
.a7b3					_STALength:
.a7b3	a9 09		lda #$09		lda	#9
.a7b5	4c 6b 8d	jmp $8d6b		jmp	ErrorHandler
.a7b8					StringTempWrite:
.a7b8	48		pha				pha
.a7b9	92 3c		sta ($3c)			sta 	(zsTemp)
.a7bb	e6 3c		inc $3c				inc 	zsTemp
.a7bd	d0 02		bne $a7c1			bne 	_STWNoCarry
.a7bf	e6 3d		inc $3d				inc 	zsTemp+1
.a7c1					_STWNoCarry:
.a7c1	a9 00		lda #$00			lda 	#0
.a7c3	92 3c		sta ($3c)			sta 	(zsTemp)
.a7c5	68		pla				pla
.a7c6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a7c7					EXTPrintCharacter:
.a7c7	48		pha				pha
.a7c8	da		phx				phx
.a7c9	5a		phy				phy
.a7ca	a6 01		ldx $01				ldx 	1
.a7cc	da		phx				phx
.a7cd	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a7d0	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a7d2	30 48		bmi $a81c			bmi 	_EXPCColour
.a7d4	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a7d6	90 4d		bcc $a825			bcc 	_EXPCControl
.a7d8	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a7da	86 01		stx $01				stx 	1
.a7dc	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7de	e6 01		inc $01				inc 	1 							; select colour memory
.a7e0	ad 40 06	lda $0640			lda 	EXTTextColour
.a7e3	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7e5	c8		iny				iny 								; advance horizontal position
.a7e6	8c 3f 06	sty $063f			sty 	EXTColumn
.a7e9	cc 41 06	cpy $0641			cpy 	EXTScreenWidth 				; reached RHS ?
.a7ec	90 66		bcc $a854			bcc 	_EXPCExit 					; no, then exit.
.a7ee					_EXPCCRLF:
.a7ee	ee 3e 06	inc $063e			inc 	EXTRow  					; bump row
.a7f1	9c 3f 06	stz $063f			stz 	EXTColumn 					; back to column 0
.a7f4	ad 3e 06	lda $063e			lda 	EXTRow 						; check if reached the bottom ?
.a7f7	cd 42 06	cmp $0642			cmp 	EXTScreenHeight 			; if so, then scroll.
.a7fa	f0 18		beq $a814			beq 	_EXPCScroll
.a7fc	18		clc				clc 								; add width to address.
.a7fd	a5 40		lda $40				lda 	EXTAddress
.a7ff	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a802	85 40		sta $40				sta 	EXTAddress
.a804	90 4e		bcc $a854			bcc 	_EXPCExit
.a806	e6 41		inc $41				inc 	EXTAddress+1
.a808	80 4a		bra $a854			bra 	_EXPCExit
.a80a					_EXPCLeft:
.a80a	ce 3f 06	dec $063f			dec 	EXTColumn
.a80d	10 45		bpl $a854			bpl 	_EXPCExit
.a80f					_EXPCBegin:
.a80f	9c 3f 06	stz $063f			stz 	EXTColumn
.a812	80 40		bra $a854			bra 	_EXPCExit
.a814					_EXPCScroll:
.a814	ce 3e 06	dec $063e			dec 	EXTRow 						; the height-1 th line.
.a817	20 e1 a8	jsr $a8e1			jsr 	EXTScreenScroll 			; scroll the screen
.a81a	80 38		bra $a854			bra 	_EXPCExit
.a81c					_EXPCColour:
.a81c	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a81e	b0 34		bcs $a854			bcs 	_EXPCExit
.a820	20 c1 a8	jsr $a8c1			jsr 	_EXPCHandleColour
.a823	80 2f		bra $a854			bra 	_EXPCExit
.a825					_EXPCControl:
.a825	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a827	b0 2b		bcs $a854			bcs 	_EXPCExit
.a829	0a		asl a				asl 	a 							; double into X
.a82a	aa		tax				tax
.a82b	7c 9f a8	jmp ($a89f,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a82e					_EXPCUp:
.a82e	ad 3e 06	lda $063e			lda 	EXTRow 						; already at top ?
.a831	f0 21		beq $a854			beq 	_EXPCExit
.a833	ce 3e 06	dec $063e			dec 	EXTRow 						; up one in position/address
.a836	38		sec				sec
.a837	a5 40		lda $40				lda 	EXTAddress
.a839	ed 41 06	sbc $0641			sbc 	EXTScreenWidth
.a83c	85 40		sta $40				sta 	EXTAddress
.a83e	b0 14		bcs $a854			bcs 	_EXPCExit
.a840	c6 41		dec $41				dec 	EXTAddress+1
.a842	80 10		bra $a854			bra 	_EXPCExit
.a844					_EXPCRight:
.a844	c8		iny				iny
.a845	8c 3f 06	sty $063f			sty 	EXTColumn
.a848	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a84b	d0 07		bne $a854			bne 	_EXPCExit
.a84d					_EXPCEnd:
.a84d	ad 41 06	lda $0641			lda 	EXTScreenWidth
.a850	3a		dec a				dec 	a
.a851	8d 3f 06	sta $063f			sta 	EXTColumn
.a854					_EXPCExit:
.a854	20 36 a9	jsr $a936			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a857	68		pla				pla
.a858	85 01		sta $01				sta 	1
.a85a	7a		ply				ply
.a85b	fa		plx				plx
.a85c	68		pla				pla
.a85d	60		rts				rts
.a85e					_EXPCClearScreen:
.a85e	20 f3 a8	jsr $a8f3			jsr		EXTClearScreenCode
.a861	80 f1		bra $a854			bra 	_EXPCExit
.a863					_EXPCDown:
.a863	ad 42 06	lda $0642			lda 	EXTScreenHeight 			; at the bottom
.a866	3a		dec a				dec 	a
.a867	cd 3e 06	cmp $063e			cmp 	EXTRow
.a86a	f0 e8		beq $a854			beq 	_EXPCExit
.a86c	ee 3e 06	inc $063e			inc 	EXTRow 						; down one in position/address
.a86f	18		clc				clc
.a870	a5 40		lda $40				lda 	EXTAddress
.a872	6d 41 06	adc $0641			adc 	EXTScreenWidth
.a875	85 40		sta $40				sta 	EXTAddress
.a877	90 db		bcc $a854			bcc 	_EXPCExit
.a879	e6 41		inc $41				inc 	EXTAddress+1
.a87b	80 d7		bra $a854			bra 	_EXPCExit
.a87d					_EXPCTab:
.a87d	ad 3f 06	lda $063f			lda 	EXTColumn 					; next tab stop
.a880	29 f8		and #$f8			and 	#$F8
.a882	18		clc				clc
.a883	69 08		adc #$08			adc 	#8
.a885	8d 3f 06	sta $063f			sta 	EXTColumn
.a888	cd 41 06	cmp $0641			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a88b	90 c7		bcc $a854			bcc 	_EXPCExit
.a88d	80 be		bra $a84d			bra 	_EXPCEnd
.a88f					_EXPCBackSpace:
.a88f	88		dey				dey
.a890	30 c2		bmi $a854			bmi 	_EXPCExit
.a892	ce 3f 06	dec $063f			dec 	EXTColumn
.a895	a9 02		lda #$02			lda 	#2
.a897	85 01		sta $01				sta 	1
.a899	a9 20		lda #$20			lda 	#32
.a89b	91 40		sta ($40),y			sta 	(EXTAddress),y
.a89d	80 b5		bra $a854			bra 	_EXPCExit
.a89f					_EXPCActionTable:
>a89f	54 a8						.word 	_EXPCExit 					; 00
>a8a1	0f a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a8a3	0a a8						.word 	_EXPCLeft 					; 02 B Left
>a8a5	54 a8						.word 	_EXPCExit 					; 03 <Break>
>a8a7	54 a8						.word 	_EXPCExit 					; 04
>a8a9	4d a8						.word 	_EXPCEnd 					; 05 E End of Line
>a8ab	44 a8						.word 	_EXPCRight 					; 06 F Right
>a8ad	54 a8						.word 	_EXPCExit 					; 07
>a8af	8f a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a8b1	7d a8						.word 	_EXPCTab 					; 09 I Tab
>a8b3	54 a8						.word 	_EXPCExit 					; 0A
>a8b5	54 a8						.word 	_EXPCExit 					; 0B
>a8b7	5e a8						.word 	_EXPCClearScreen			; 0C L CLS
>a8b9	ee a7						.word 	_EXPCCRLF 					; 0D M CR/LF
>a8bb	63 a8						.word 	_EXPCDown 					; 0E N Down
>a8bd	54 a8						.word 	_EXPCExit 					; 0F
>a8bf	2e a8						.word 	_EXPCUp 					; 10 P Up
.a8c1					_EXPCHandleColour
.a8c1	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a8c3	b0 16		bcs $a8db			bcs 	_EXPCBackground
.a8c5	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a8c6	0a		asl a				asl 	a
.a8c7	0a		asl a				asl 	a
.a8c8	0a		asl a				asl 	a
.a8c9	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a8cb					_EXPCUpdate:
.a8cb	48		pha				pha 								; save new colour
.a8cc	8a		txa				txa 								; get mask
.a8cd	2d 40 06	and $0640			and 	EXTTextColour 				; mask out old.
.a8d0	8d 40 06	sta $0640			sta 	EXTTextColour
.a8d3	68		pla				pla 								; or in new colour
.a8d4	0d 40 06	ora $0640			ora 	EXTTextColour
.a8d7	8d 40 06	sta $0640			sta 	EXTTextColour
.a8da	60		rts				rts
.a8db					_EXPCBackground:
.a8db	29 0f		and #$0f			and 	#$0F 						; get the colour
.a8dd	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a8df	80 ea		bra $a8cb			bra 	_EXPCUpdate
.a8e1					EXTScreenScroll:
.a8e1	a9 02		lda #$02			lda 	#2 							; select text page
.a8e3	85 01		sta $01				sta 	1
.a8e5	a9 20		lda #$20			lda		#32 						; fill with space
.a8e7	20 f6 a9	jsr $a9f6			jsr 	EXTScrollFill
.a8ea	e6 01		inc $01				inc 	1 							; select colour page
.a8ec	ad 40 06	lda $0640			lda 	EXTTextColour
.a8ef	20 f6 a9	jsr $a9f6			jsr 	EXTScrollFill
.a8f2	60		rts				rts
.a8f3					EXTClearScreenCode:
.a8f3	a9 02		lda #$02			lda 	#2 							; select text page
.a8f5	85 01		sta $01				sta 	1
.a8f7	a9 20		lda #$20			lda		#32 						; fill with space
.a8f9	20 06 a9	jsr $a906			jsr 	_EXTCSFill
.a8fc	e6 01		inc $01				inc 	1 							; select colour page
.a8fe	ad 40 06	lda $0640			lda 	EXTTextColour
.a901	20 06 a9	jsr $a906			jsr 	_EXTCSFill
.a904	80 22		bra $a928			bra 	EXTHomeCursor
.a906					_EXTCSFill:
.a906	aa		tax				tax
.a907	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a909	85 40		sta $40				sta 	EXTAddress
.a90b	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a90d	85 41		sta $41				sta 	EXTAddress+1
.a90f					_EXTCSFill1:
.a90f	a0 00		ldy #$00			ldy 	#0
.a911	8a		txa				txa
.a912					_EXTCSFill2:
.a912	91 40		sta ($40),y			sta 	(EXTAddress),y
.a914	c8		iny				iny
.a915	d0 fb		bne $a912			bne 	_EXTCSFill2
.a917	e6 41		inc $41				inc 	EXTAddress+1
.a919	a5 41		lda $41				lda 	EXTAddress+1
.a91b	c9 d2		cmp #$d2			cmp 	#$D2
.a91d	d0 f0		bne $a90f			bne 	_EXTCSFill1
.a91f	8a		txa				txa
.a920					_EXTCSFill3:
.a920	91 40		sta ($40),y			sta 	(EXTAddress),y
.a922	c8		iny				iny
.a923	c0 c0		cpy #$c0			cpy 	#$C0
.a925	d0 f9		bne $a920			bne 	_EXTCSFill3
.a927	60		rts				rts
.a928					EXTHomeCursor:
.a928	9c 3e 06	stz $063e			stz 	EXTRow 						; reset row & column
.a92b	9c 3f 06	stz $063f			stz 	EXTColumn
.a92e	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a930	85 40		sta $40				sta 	EXTAddress
.a932	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a934	85 41		sta $41				sta 	EXTAddress+1
.a936					EXTSetHardwareCursor:
.a936	64 01		stz $01				stz 	1 							; I/O Page zero
.a938	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a93a	8d 10 d0	sta $d010			sta 	$D010
.a93d	a9 b1		lda #$b1			lda 	#$B1
.a93f	8d 12 d0	sta $d012			sta 	$D012
.a942	ad 3f 06	lda $063f			lda 	EXTColumn
.a945	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a948	9c 15 d0	stz $d015			stz 	$D015
.a94b	ad 3e 06	lda $063e			lda 	EXTRow
.a94e	8d 16 d0	sta $d016			sta 	$D016
.a951	9c 17 d0	stz $d017			stz 	$D017
.a954	60		rts				rts
.a955					EXTInputLine:
.a955	48		pha				pha
.a956	da		phx				phx
.a957	5a		phy				phy
.a958	a5 01		lda $01				lda 	1 							; save I/O page
.a95a	48		pha				pha
.a95b					_EILLoop:
.a95b	20 5d aa	jsr $aa5d			jsr 	ExtInputSingleCharacter
.a95e	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a960	f0 40		beq $a9a2			beq 	_EILExit
.a962	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.a964	f0 1c		beq $a982			beq 	_EILBackspace
.a966	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a968	90 12		bcc $a97c			bcc 	_EILPrintLoop
.a96a	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a96c	b0 0e		bcs $a97c			bcs 	_EILPrintLoop
.a96e	48		pha				pha 								; save character
.a96f	a9 02		lda #$02			lda 	#2  						; insert a space
.a971	85 01		sta $01				sta 	1
.a973	20 e4 a9	jsr $a9e4			jsr 	EXTILInsert 				; insert in text screen
.a976	e6 01		inc $01				inc 	1
.a978	20 e4 a9	jsr $a9e4			jsr 	EXTILInsert 				; insert in colour screen
.a97b	68		pla				pla 								; get character back.
.a97c					_EILPrintLoop:
.a97c	20 c7 a7	jsr $a7c7			jsr 	ExtPrintCharacter
.a97f	80 da		bra $a95b			bra 	_EILLoop
.a981	60		rts				rts
.a982					_EILBackspace:
.a982	ad 3f 06	lda $063f			lda 	EXTColumn					; can we backspace ?
.a985	f0 d4		beq $a95b			beq 	_EILLoop
.a987	a9 02		lda #$02			lda 	#2 							; move cursor left
.a989	20 c7 a7	jsr $a7c7			jsr 	EXTPrintCharacter
.a98c	a9 02		lda #$02			lda 	#2 							; text block
.a98e	85 01		sta $01				sta 	1
.a990	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a992	20 cf a9	jsr $a9cf			jsr 	EXTILDelete
.a995	e6 01		inc $01				inc 	1 							; colour block
.a997	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; get attribute of last character
.a99a	88		dey				dey
.a99b	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a99d	20 cf a9	jsr $a9cf			jsr 	EXTILDelete 				; backspace attribute
.a9a0	80 b9		bra $a95b			bra 	_EILLoop 					; and go round.
.a9a2					_EILExit:
.a9a2	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a9a4	85 01		sta $01				sta 	1
.a9a6	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a9a8					_EILScrapeLine:
.a9a8	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9aa	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9ad	c8		iny				iny
.a9ae	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9b1	d0 f5		bne $a9a8			bne 	_EILScrapeLine
.a9b3					_EILTrimSpaces:
.a9b3	88		dey				dey
.a9b4	f0 08		beq $a9be			beq 	_EILEndTrim
.a9b6	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.a9b9	c9 20		cmp #$20			cmp 	#' '
.a9bb	f0 f6		beq $a9b3			beq 	_EILTrimSpaces
.a9bd	c8		iny				iny 								; trim after non space character.
.a9be					_EILEndTrim:
.a9be	a9 00		lda #$00			lda 	#0 							; trim here.
.a9c0	99 a8 05	sta $05a8,y			sta 	lineBuffer,y
.a9c3	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a9c5	20 c7 a7	jsr $a7c7			jsr 	ExtPrintCharacter
.a9c8	68		pla				pla 								; reset I/O page
.a9c9	85 01		sta $01				sta 	1
.a9cb	7a		ply				ply
.a9cc	fa		plx				plx
.a9cd	68		pla				pla
.a9ce	60		rts				rts
.a9cf					EXTILDelete:
.a9cf	48		pha				pha 								; save the new character
.a9d0	ac 3f 06	ldy $063f			ldy 	EXTColumn 					; start copying from here.
.a9d3					_EXTDLoop:
.a9d3	c8		iny				iny 								; copy one byte down.
.a9d4	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9d6	88		dey				dey
.a9d7	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9d9	c8		iny				iny 								; do till end of line.
.a9da	cc 41 06	cpy $0641			cpy 	EXTScreenWidth
.a9dd	90 f4		bcc $a9d3			bcc 	_EXTDLoop
.a9df	88		dey				dey 	 							; write in last slot.
.a9e0	68		pla				pla
.a9e1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9e3	60		rts				rts
.a9e4					EXTILInsert:
.a9e4	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; end position
.a9e7					_EXTILoop:
.a9e7	88		dey				dey 								; back one
.a9e8	cc 3f 06	cpy $063f			cpy 	EXTColumn 					; exit if reached insert point.
.a9eb	f0 08		beq $a9f5			beq 	_EXTIExit
.a9ed	88		dey				dey 								; copy one byte up.
.a9ee	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a9f0	c8		iny				iny
.a9f1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9f3	80 f2		bra $a9e7			bra 	_EXTILoop
.a9f5					_EXTIExit:
.a9f5	60		rts				rts
.a9f6					EXTScrollFill:
.a9f6	aa		tax				tax									; save value to fill with
.a9f7	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a9f9	48		pha				pha
.a9fa	a5 37		lda $37				lda 	zTemp0+1
.a9fc	48		pha				pha
.a9fd	a5 38		lda $38				lda 	zTemp1
.a9ff	48		pha				pha
.aa00	a5 39		lda $39				lda 	zTemp1+1
.aa02	48		pha				pha
.aa03	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa05	85 37		sta $37				sta 	zTemp0+1
.aa07	85 39		sta $39				sta 	zTemp1+1
.aa09	64 36		stz $36				stz 	zTemp0
.aa0b	ad 41 06	lda $0641			lda 	EXTScreenWidth
.aa0e	85 38		sta $38				sta 	zTemp1
.aa10	a0 00		ldy #$00			ldy 	#0
.aa12					_EXSFCopy1:
.aa12	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa14	91 36		sta ($36),y			sta 	(zTemp0),y
.aa16	c8		iny				iny
.aa17	d0 f9		bne $aa12			bne 	_EXSFCopy1
.aa19	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa1b	e6 39		inc $39				inc 	zTemp1+1
.aa1d	a5 39		lda $39				lda 	zTemp1+1
.aa1f	c9 d3		cmp #$d3			cmp 	#$D3
.aa21	d0 ef		bne $aa12			bne 	_EXSFCopy1
.aa23	ac 41 06	ldy $0641			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa26	8a		txa				txa
.aa27					_EXSFFill1:
.aa27	88		dey				dey
.aa28	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa2a	c0 00		cpy #$00			cpy 	#0
.aa2c	10 f9		bpl $aa27			bpl 	_EXSFFill1
.aa2e	68		pla				pla
.aa2f	85 39		sta $39				sta 	zTemp1+1
.aa31	68		pla				pla
.aa32	85 38		sta $38				sta 	zTemp1
.aa34	68		pla				pla
.aa35	85 37		sta $37				sta 	zTemp0+1
.aa37	68		pla				pla
.aa38	85 36		sta $36				sta 	zTemp0
.aa3a	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063e					EXTRow:
>063e							.fill 	1
.063f					EXTColumn:
>063f							.fill 	1
.0640					EXTTextColour:
>0640							.fill 	1
.0641					EXTScreenWidth:
>0641							.fill 	1
.0642					EXTScreenHeight:
>0642							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aa3b					EXTInitialise:
.aa3b	64 01		stz $01				stz 	1 							; Access I/O
.aa3d	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aa40	9c 08 d0	stz $d008			stz 	$D008
.aa43	9c 09 d0	stz $d009			stz 	$D009
.aa46	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aa48	8d 58 d6	sta $d658			sta 	$D658
.aa4b	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.aa4d	8d 40 06	sta $0640			sta 	EXTTextColour
.aa50	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aa52	8d 41 06	sta $0641			sta 	EXTScreenWidth
.aa55	a9 3c		lda #$3c			lda 	#60
.aa57	8d 42 06	sta $0642			sta 	EXTScreenHeight
.aa5a	64 01		stz $01				stz 	1
.aa5c	60		rts				rts
.aa5d					EXTInputSingleCharacter:
.aa5d	da		phx				phx
.aa5e	5a		phy				phy
.aa5f					_EISCWait:
.aa5f	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.aa62	c9 00		cmp #$00			cmp 	#0
.aa64	f0 f9		beq $aa5f			beq 	_EISCWait
.aa66	7a		ply				ply
.aa67	fa		plx				plx
.aa68	60		rts				rts
.aa69					EXTBreakCheck:
.aa69	4c e1 ff	jmp $ffe1			jmp		$FFE1
.aa6c					EXTReadController:
.aa6c	da		phx				phx
.aa6d	a2 00		ldx #$00			ldx 	#0
.aa6f	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aa71	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa74	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aa76	f0 04		beq $aa7c			beq 	_NoSet1
.aa78	8a		txa				txa
.aa79	09 01		ora #$01			ora 	#1
.aa7b	aa		tax				tax
.aa7c					_NoSet1:
.aa7c	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aa7e	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa81	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aa83	f0 04		beq $aa89			beq 	_NoSet1
.aa85	8a		txa				txa
.aa86	09 02		ora #$02			ora 	#2
.aa88	aa		tax				tax
.aa89					_NoSet1:
.aa89	a9 06		lda #$06			lda 	#(($32) >> 3)
.aa8b	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa8e	29 04		and #$04			and 	#($01 << (($32) & 7))
.aa90	f0 04		beq $aa96			beq 	_NoSet1
.aa92	8a		txa				txa
.aa93	09 04		ora #$04			ora 	#4
.aa95	aa		tax				tax
.aa96					_NoSet1:
.aa96	a9 04		lda #$04			lda 	#(($25) >> 3)
.aa98	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa9b	29 20		and #$20			and 	#($01 << (($25) & 7))
.aa9d	f0 04		beq $aaa3			beq 	_NoSet1
.aa9f	8a		txa				txa
.aaa0	09 08		ora #$08			ora 	#8
.aaa2	aa		tax				tax
.aaa3					_NoSet1:
.aaa3	a9 04		lda #$04			lda 	#(($26) >> 3)
.aaa5	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aaa8	29 40		and #$40			and 	#($01 << (($26) & 7))
.aaaa	f0 04		beq $aab0			beq 	_NoSet1
.aaac	8a		txa				txa
.aaad	09 10		ora #$10			ora 	#16
.aaaf	aa		tax				tax
.aab0					_NoSet1:
.aab0	8a		txa				txa
.aab1	fa		plx				plx
.aab2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.b96f					GRVectorTable:
>b96f	ae ac					.word	GXInitialise             ; $00 Initialise
>b971	c8 ac					.word	GXControlBitmap          ; $01 BitmapCtl
>b973	10 ad					.word	GXControlSprite          ; $02 SpriteCtl
>b975	60 ac					.word	GXClearBitmap            ; $03 Clear
>b977	9f ae					.word	GXSetColourMode          ; $04 Colour
>b979	67 b0					.word	GXFontHandler            ; $05 DrawFont
>b97b	af b0					.word	GXSpriteHandler          ; $06 DrawSprite
>b97d	1b b1					.word	GXSelect                 ; $07 SpriteUse
>b97f	44 b1					.word	GXSelectImage            ; $08 SpriteImage
>b981	cb b2					.word	GXCollide                ; $09 SpriteCollide
>b983	12 ab					.word	GRUndefined              ; $0a
>b985	12 ab					.word	GRUndefined              ; $0b
>b987	12 ab					.word	GRUndefined              ; $0c
>b989	12 ab					.word	GRUndefined              ; $0d
>b98b	12 ab					.word	GRUndefined              ; $0e
>b98d	12 ab					.word	GRUndefined              ; $0f
>b98f	12 ab					.word	GRUndefined              ; $10
>b991	12 ab					.word	GRUndefined              ; $11
>b993	12 ab					.word	GRUndefined              ; $12
>b995	12 ab					.word	GRUndefined              ; $13
>b997	12 ab					.word	GRUndefined              ; $14
>b999	12 ab					.word	GRUndefined              ; $15
>b99b	12 ab					.word	GRUndefined              ; $16
>b99d	12 ab					.word	GRUndefined              ; $17
>b99f	12 ab					.word	GRUndefined              ; $18
>b9a1	12 ab					.word	GRUndefined              ; $19
>b9a3	12 ab					.word	GRUndefined              ; $1a
>b9a5	12 ab					.word	GRUndefined              ; $1b
>b9a7	12 ab					.word	GRUndefined              ; $1c
>b9a9	12 ab					.word	GRUndefined              ; $1d
>b9ab	12 ab					.word	GRUndefined              ; $1e
>b9ad	12 ab					.word	GRUndefined              ; $1f
>b9af	10 ab					.word	GXMove                   ; $20 Move
>b9b1	6d ad					.word	GXLine                   ; $21 Line
>b9b3	e8 ae					.word	GXFrameRectangle         ; $22 FrameRect
>b9b5	e5 ae					.word	GXFillRectangle          ; $23 FillRect
>b9b7	17 ab					.word	GXFrameCircle            ; $24 FrameCircle
>b9b9	13 ab					.word	GXFillCircle             ; $25 FillCircle
>b9bb	12 ab					.word	GRUndefined              ; $26
>b9bd	12 ab					.word	GRUndefined              ; $27
>b9bf	cd ae					.word	GXPlotPoint              ; $28 Plot
>b9c1	da b1					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5f9					gxPixelBuffer = numberBuffer
.0643					gxCurrentX:
>0643							.fill 	2
.0645					gxCurrentY:
>0645							.fill 	2
.0647					gxLastX:
>0647							.fill 	2
.0649					gxLastY:
>0649							.fill 	2
.064b					gxX0:
>064b							.fill 	2
.064d					gxY0:
>064d							.fill 	2
.064f					gxX1:
>064f							.fill 	2
.0651					gxY1:
>0651							.fill 	2
.0653					gxSpritesOn:
>0653							.fill 	1
.0654					gxBitmapsOn:
>0654							.fill 	1
.0655					gxBasePage:
>0655							.fill 	1
.0656					gxSpritePage:
>0656							.fill 	1
.0657					gxHeight:
>0657							.fill 	1
.0658					gxMode:
>0658							.fill 	1
.0659					gxColour:
>0659							.fill 	1
.065a					gxEORValue:
>065a							.fill 	1
.065b					gxANDValue:
>065b							.fill 	1
.065c					gxOriginalLUTValue:
>065c							.fill 	1
.065d					gsOffset:
>065d							.fill 	1
.065e					GSCurrentSpriteID:
>065e							.fill 	1
.065f					GSCurrentSpriteAddr:
>065f							.fill 	2
.0661					GXSpriteOffsetBase:
>0661							.fill 	2
.0663					GXSpriteLow:
>0663							.fill 	64
.06a3					GXSpriteHigh:
>06a3							.fill 	64
.aab3					GXGraphicDraw:
.aab3	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aab5	b0 06		bcs $aabd			bcs 	_GDCoordinate
.aab7	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aab9	84 37		sty $37				sty 	gxzTemp0+1
.aabb	80 4b		bra $ab08			bra 	_GDExecuteA 				; and execute
.aabd					_GDCoordinate:
.aabd	48		pha				pha 								; save AXY
.aabe	da		phx				phx
.aabf	5a		phy				phy
.aac0	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aac2					_GDCopy1:
.aac2	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.aac5	9d 47 06	sta $0647,x			sta 	gxLastX,x
.aac8	ca		dex				dex
.aac9	10 f7		bpl $aac2			bpl 	_GDCopy1
.aacb	68		pla				pla 								; update Y
.aacc	8d 45 06	sta $0645			sta 	gxCurrentY
.aacf	9c 46 06	stz $0646			stz 	gxCurrentY+1
.aad2	68		pla				pla
.aad3	8d 43 06	sta $0643			sta 	gxCurrentX
.aad6	68		pla				pla 								; get A (command+X.1) back
.aad7	48		pha				pha
.aad8	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aada	8d 44 06	sta $0644			sta 	gxCurrentX+1
.aadd	68		pla				pla 								; get command back
.aade	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aae0	48		pha				pha 								; push back.
.aae1	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aae3	f0 17		beq $aafc			beq 	_GDCopyToWorkArea
.aae5	ad 44 06	lda $0644			lda 	gxCurrentX+1 				; X < 256 X okay
.aae8	f0 07		beq $aaf1			beq 	_GDCheckY
.aaea	ad 43 06	lda $0643			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aaed	c9 40		cmp #$40			cmp 	#64
.aaef	b0 08		bcs $aaf9			bcs 	_GDError1
.aaf1					_GDCheckY:
.aaf1	ad 45 06	lda $0645			lda 	gxCurrentY 					; check Y < Height.
.aaf4	cd 57 06	cmp $0657			cmp 	gxHeight
.aaf7	90 03		bcc $aafc			bcc 	_GDCopyToWorkArea
.aaf9					_GDError1:
.aaf9	68		pla				pla
.aafa					_GDError2:
.aafa	38		sec				sec
.aafb	60		rts				rts
.aafc					_GDCopyToWorkArea:
.aafc	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.aafe					_GDCopy2:
.aafe	bd 43 06	lda $0643,x			lda 	gxCurrentX,x
.ab01	9d 4b 06	sta $064b,x			sta 	gxX0,x
.ab04	ca		dex				dex
.ab05	10 f7		bpl $aafe			bpl 	_GDCopy2
.ab07	68		pla				pla 								; get command
.ab08					_GDExecuteA:
.ab08	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.ab0a	b0 ee		bcs $aafa			bcs 	_GDError2
.ab0c	aa		tax				tax
.ab0d	7c 6f b9	jmp ($b96f,x)			jmp 	(GRVectorTable,x)
.ab10					GXMove:
.ab10	18		clc				clc
.ab11	60		rts				rts
.ab12					GRUndefined:
>ab12	db						.byte 	$DB 						; causes a break in the emulator
.ab13					GXFillCircle:
.ab13	a9 ff		lda #$ff			lda 	#255
.ab15	80 02		bra $ab19			bra 	GXCircle
.ab17					GXFrameCircle:
.ab17	a9 00		lda #$00			lda 	#0
.ab19					GXCircle:
.ab19	8d e6 06	sta $06e6			sta 	gxIsFillMode					; save Fill flag
.ab1c	ad 54 06	lda $0654			lda 	gxBitmapsOn
.ab1f	f0 26		beq $ab47			beq 	_GXCFail
.ab21	20 72 b3	jsr $b372			jsr 	GXSortXY 					; topleft/bottomright
.ab24	20 4a b2	jsr $b24a			jsr 	GXOpenBitmap 				; start drawing
.ab27	20 19 ac	jsr $ac19			jsr 	GXCircleSetup 				; set up for drawing
.ab2a	9c e7 06	stz $06e7			stz 	gxYChanged
.ab2d					_GXCircleDraw:
.ab2d	ad e4 06	lda $06e4			lda 	gXCentre					; while x <= y
.ab30	cd e5 06	cmp $06e5			cmp 	gYCentre
.ab33	90 0a		bcc $ab3f			bcc 	_GXCircleContinue
.ab35	d0 03		bne $ab3a			bne 	_GXNoLast
.ab37	20 4c ab	jsr $ab4c			jsr 	GXPlot1
.ab3a					_GXNoLast:
.ab3a	20 52 b2	jsr $b252			jsr 	GXCloseBitmap 				; close the bitmap
.ab3d	18		clc				clc
.ab3e	60		rts				rts
.ab3f					_GXCircleContinue:
.ab3f	20 49 ab	jsr $ab49			jsr 	GXPlot2 					; draw it
.ab42	20 c6 ab	jsr $abc6			jsr 	GXCircleMove 				; adjust the coordinates
.ab45	80 e6		bra $ab2d			bra 	_GXCircleDraw
.ab47					_GXCFail:
.ab47	38		sec				sec
.ab48	60		rts				rts
.ab49					GXPlot2:
.ab49	20 4c ab	jsr $ab4c			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ab4c					GXPlot1:
.ab4c	ad e5 06	lda $06e5			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ab4f	f0 03		beq $ab54			beq 	_GXPlot1Only
.ab51	20 70 ab	jsr $ab70			jsr 	GXPlot0 						; plot and negate
.ab54					_GXPlot1Only:
.ab54	20 70 ab	jsr $ab70			jsr 	GXPlot0 						; twice, undoing negation
.ab57	ad e4 06	lda $06e4			lda 	gXCentre 						; swap X and Y
.ab5a	ae e5 06	ldx $06e5			ldx	 	gYCentre
.ab5d	8d e5 06	sta $06e5			sta 	gYCentre
.ab60	8e e4 06	stx $06e4			stx 	gXCentre
.ab63	ad e7 06	lda $06e7			lda 	gxYChanged 						; toggle Y Changed flag
.ab66	a9 ff		lda #$ff			lda 	#$FF
.ab68	8d e7 06	sta $06e7			sta 	gxYChanged
.ab6b	60		rts				rts
.ab6c	20 70 ab	jsr $ab70			jsr 	GXPlot0 						; do once
.ab6f	60		rts				rts
.ab70	ad e6 06	lda $06e6	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ab73	f0 05		beq $ab7a			beq 	_GXPlot0Always
.ab75	ad e7 06	lda $06e7			lda 	gxYChanged						; fill mode, only draw if changed.
.ab78	f0 2d		beq $aba7			beq 	GXPlot0Exit
.ab7a					_GXPlot0Always:
.ab7a	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ab7c	ad e5 06	lda $06e5			lda 	gYCentre
.ab7f	20 a8 ab	jsr $aba8			jsr 	GXSubCopy
.ab82	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ab84	ad e4 06	lda $06e4			lda 	gXCentre
.ab87	20 a8 ab	jsr $aba8			jsr 	GXSubCopy
.ab8a	48		pha				pha 									; save last offset X
.ab8b	20 5a b2	jsr $b25a			jsr 	GXPositionCalc 					; calculate position/offset.
.ab8e	68		pla				pla
.ab8f	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ab90	85 36		sta $36				sta 	gxzTemp0
.ab92	64 37		stz $37				stz 	gxzTemp0+1
.ab94	26 37		rol $37				rol 	gxzTemp0+1
.ab96	ad e6 06	lda $06e6			lda 	gxIsFillMode
.ab99	69 80		adc #$80			adc 	#128
.ab9b	20 38 af	jsr $af38			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ab9e	38		sec				sec 									; GY = -GY
.ab9f	a9 00		lda #$00			lda 	#0
.aba1	ed e5 06	sbc $06e5			sbc 	gYCentre
.aba4	8d e5 06	sta $06e5			sta 	gYCentre
.aba7					GXPlot0Exit:
.aba7	60		rts				rts
.aba8					GXSubCopy:
.aba8	85 36		sta $36				sta 	gxzTemp0
.abaa	64 37		stz $37				stz 	gxzTemp0+1
.abac	29 80		and #$80			and 	#$80
.abae	f0 02		beq $abb2			beq 	_GXNoSx
.abb0	c6 37		dec $37				dec 	gxzTemp0+1
.abb2					_GXNoSx:
.abb2	38		sec				sec
.abb3	bd 4f 06	lda $064f,x			lda 	gXX1,x
.abb6	e5 36		sbc $36				sbc 	gxzTemp0
.abb8	9d 4b 06	sta $064b,x			sta 	gXX0,x
.abbb	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.abbe	e5 37		sbc $37				sbc 	gxzTemp0+1
.abc0	9d 4c 06	sta $064c,x			sta 	gXX0+1,x
.abc3	a5 36		lda $36				lda 	gxzTemp0 						; return A
.abc5	60		rts				rts
.abc6					GXCircleMove:
.abc6	9c e7 06	stz $06e7			stz 	gxYChanged 					; clear Y changed flag
.abc9	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.abcb	10 0d		bpl $abda			bpl 	_GXEMPositive
.abcd	ee e4 06	inc $06e4			inc 	gXCentre 					; X++
.abd0	ad e4 06	lda $06e4			lda 	gXCentre
.abd3	20 f9 ab	jsr $abf9			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abd6	a9 06		lda #$06			lda 	#6  						; and add 6
.abd8	80 15		bra $abef			bra 	_GXEMAddD
.abda					_GXEMPositive:
.abda	ee e4 06	inc $06e4			inc 	gXCentre					; X++
.abdd	ce e5 06	dec $06e5			dec 	gyCentre 					; Y--
.abe0	38		sec				sec 								; calculate X-Y
.abe1	ad e4 06	lda $06e4			lda 	gXCentre
.abe4	ed e5 06	sbc $06e5			sbc 	gYCentre
.abe7	20 f9 ab	jsr $abf9			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abea	a9 0a		lda #$0a			lda 	#10  						; and add 10
.abec	ce e7 06	dec $06e7			dec 	gxYChanged
.abef					_GXEMAddD:
.abef	18		clc				clc
.abf0	65 38		adc $38				adc 	gxzTemp1
.abf2	85 38		sta $38				sta 	gxzTemp1
.abf4	90 02		bcc $abf8			bcc 	_GXEMNoCarry
.abf6	e6 39		inc $39				inc 	gxzTemp1+1
.abf8					_GXEMNoCarry:
.abf8	60		rts				rts
.abf9					_GXAdd4TimesToD:
.abf9	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.abfb	29 80		and #$80			and 	#$80
.abfd	f0 02		beq $ac01			beq 	_GXA4Unsigned
.abff	a9 ff		lda #$ff			lda 	#$FF
.ac01					_GXA4Unsigned:
.ac01	85 37		sta $37				sta 	gxzTemp0+1
.ac03	06 36		asl $36				asl 	gxzTemp0  					; x 4
.ac05	26 37		rol $37				rol 	gxzTemp0+1
.ac07	06 36		asl $36				asl 	gxzTemp0
.ac09	26 37		rol $37				rol 	gxzTemp0+1
.ac0b	18		clc				clc 								; add
.ac0c	a5 36		lda $36				lda		gxzTemp0
.ac0e	65 38		adc $38				adc 	gxzTemp1
.ac10	85 38		sta $38				sta 	gxzTemp1
.ac12	a5 37		lda $37				lda		gxzTemp0+1
.ac14	65 39		adc $39				adc 	gxzTemp1+1
.ac16	85 39		sta $39				sta 	gxzTemp1+1
.ac18	60		rts				rts
.ac19					GXCircleSetup:
.ac19	38		sec				sec
.ac1a	ad 51 06	lda $0651			lda 	gxY1
.ac1d	ed 4d 06	sbc $064d			sbc 	gxY0
.ac20	4a		lsr a				lsr 	a
.ac21	8d e3 06	sta $06e3			sta 	gxRadius
.ac24	a2 00		ldx #$00			ldx 	#0
.ac26	20 48 ac	jsr $ac48			jsr 	_GXCalculateCentre
.ac29	a2 02		ldx #$02			ldx 	#2
.ac2b	20 48 ac	jsr $ac48			jsr 	_GXCalculateCentre
.ac2e	9c e4 06	stz $06e4			stz 	gXCentre
.ac31	ad e3 06	lda $06e3			lda 	gxRadius
.ac34	8d e5 06	sta $06e5			sta 	gYCentre
.ac37	0a		asl a				asl 	a 							; R x 2
.ac38	85 36		sta $36				sta 	gxzTemp0
.ac3a	38		sec				sec
.ac3b	a9 03		lda #$03			lda 	#3
.ac3d	e5 36		sbc $36				sbc 	gxzTemp0
.ac3f	85 38		sta $38				sta 	gxzTemp1
.ac41	a9 00		lda #$00			lda 	#0
.ac43	e9 00		sbc #$00			sbc 	#0
.ac45	85 39		sta $39				sta 	gxzTemp1+1
.ac47	60		rts				rts
.ac48					_GXCalculateCentre:
.ac48	38		sec				sec
.ac49	bd 4f 06	lda $064f,x			lda 	gxX1,x
.ac4c	7d 4b 06	adc $064b,x			adc 	gXX0,x
.ac4f	9d 4f 06	sta $064f,x			sta 	gXX1,x
.ac52	bd 50 06	lda $0650,x			lda 	gXX1+1,x
.ac55	7d 4c 06	adc $064c,x			adc 	gXX0+1,x
.ac58	4a		lsr a				lsr 	a
.ac59	9d 50 06	sta $0650,x			sta 	gXX1+1,x
.ac5c	7e 4f 06	ror $064f,x			ror 	gXX1,x
.ac5f	60		rts				rts
.06e3					gxRadius:
>06e3							.fill 	1
.06e4					gXCentre:
>06e4							.fill 	1
.06e5					gYCentre:
>06e5							.fill 	1
.06e6					gxIsFillMode:
>06e6							.fill 	1
.06e7					gxYChanged:
>06e7							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ac60					GXClearBitmap:
.ac60	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP running.
.ac63	f0 24		beq $ac89			beq 	_GXCBFail
.ac65	20 4a b2	jsr $b24a			jsr 	GXOpenBitmap 				; start access
.ac68	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac6a	ad 57 06	lda $0657			lda 	gxHeight
.ac6d	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ac6f	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ac71					_GXCalcLastPage:
.ac71	98		tya				tya 								; add to base page
.ac72	18		clc				clc
.ac73	6d 55 06	adc $0655			adc 	gxBasePage
.ac76	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ac78					_GXClearAll:
.ac78	20 8b ac	jsr $ac8b			jsr 	_GXClearBlock 				; clear 8k block
.ac7b	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ac7d	a5 0b		lda $0b				lda 	GXEditSlot
.ac7f	cd 55 06	cmp $0655			cmp 	gxBasePage 					; until before base page
.ac82	b0 f4		bcs $ac78			bcs 	_GXClearAll
.ac84	20 52 b2	jsr $b252			jsr 	GXCloseBitmap	 			; stop access
.ac87	18		clc				clc
.ac88	60		rts				rts
.ac89					_GXCBFail:
.ac89	38		sec				sec
.ac8a	60		rts				rts
.ac8b					_GXClearBlock:
.ac8b	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ac8d	85 38		sta $38				sta 	0+gxzTemp1
.ac8f	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ac91	85 39		sta $39				sta 	1+gxzTemp1
.ac93					_GXCB0:
.ac93	a5 36		lda $36				lda 	gxzTemp0
.ac95	a0 00		ldy #$00			ldy 	#0
.ac97					_GXCB1:
.ac97	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac99	c8		iny				iny
.ac9a	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac9c	c8		iny				iny
.ac9d	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac9f	c8		iny				iny
.aca0	91 38		sta ($38),y			sta 	(gxzTemp1),y
.aca2	c8		iny				iny
.aca3	d0 f2		bne $ac97			bne 	_GXCB1
.aca5	e6 39		inc $39				inc 	gxzTemp1+1
.aca7	a5 39		lda $39				lda 	gxzTemp1+1
.aca9	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.acab	d0 e6		bne $ac93			bne 	_GXCB0
.acad	60		rts				rts
.acae					GXInitialise:
.acae	64 01		stz $01				stz 	1
.acb0	a9 01		lda #$01			lda 	#1
.acb2	8d 00 d0	sta $d000			sta 	$D000
.acb5	18		clc				clc
.acb6	9c 53 06	stz $0653			stz 	GXSpritesOn
.acb9	9c 54 06	stz $0654			stz 	GXBitmapsOn
.acbc	a2 0f		ldx #$0f			ldx 	#15
.acbe					_GXIClear:
.acbe	9e 43 06	stz $0643,x			stz 	gxCurrentX,x
.acc1	ca		dex				dex
.acc2	10 fa		bpl $acbe			bpl 	_GXIClear
.acc4	20 5f ad	jsr $ad5f			jsr 	GXClearSpriteStore
.acc7	60		rts				rts
.acc8					GXControlBitmap:
.acc8	64 01		stz $01				stz 	1
.acca	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.accc	29 01		and #$01			and 	#1 							; set bitmap flag
.acce	8d 54 06	sta $0654			sta 	gxBitmapsOn
.acd1	4a		lsr a				lsr 	a 							; bit 0 into carry.
.acd2	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.acd5	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.acd7	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.acd9	90 02		bcc $acdd			bcc 	_CBNotOn
.acdb	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.acdd					_CBNotOn:
.acdd	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ace0	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.ace2	29 07		and #$07			and 	#7
.ace4	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.ace7	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ace9	d0 02		bne $aced			bne 	_CBNotDefault
.aceb	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.aced					_CBNotDefault:
.aced	8d 55 06	sta $0655			sta 	gxBasePage
.acf0	20 51 ad	jsr $ad51			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.acf3	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.acf5	8d 03 d1	sta $d103			sta 	$D103
.acf8	a5 36		lda $36				lda 	gxzTemp0
.acfa	8d 02 d1	sta $d102			sta 	$D102
.acfd	9c 01 d1	stz $d101			stz 	$D101
.ad00	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ad02	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.ad05	29 01		and #$01			and 	#1
.ad07	f0 02		beq $ad0b			beq 	_CBHaveHeight
.ad09	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ad0b					_CBHaveHeight
.ad0b	8e 57 06	stx $0657			stx 	gxHeight
.ad0e	18		clc				clc
.ad0f	60		rts				rts
.ad10					GXControlSprite:
.ad10	64 01		stz $01				stz 	1
.ad12	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad14	29 01		and #$01			and 	#1 							; set sprites flag
.ad16	8d 53 06	sta $0653			sta 	gxSpritesOn
.ad19	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ad1a	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad1d	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad1f	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ad21	90 02		bcc $ad25			bcc 	_CSNotOn
.ad23	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ad25					_CSNotOn:
.ad25	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad28	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad2a	d0 02		bne $ad2e			bne 	_CSNotDefault
.ad2c	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ad2e					_CSNotDefault:
.ad2e	8d 56 06	sta $0656			sta 	gxSpritePage
.ad31	20 51 ad	jsr $ad51			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad34	a5 36		lda $36				lda 	zTemp0
.ad36	8d 61 06	sta $0661			sta 	GXSpriteOffsetBase
.ad39	a5 37		lda $37				lda 	zTemp0+1
.ad3b	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase+1
.ad3e	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ad40					_CSClear:
.ad40	9e 00 d9	stz $d900,x			stz 	$D900,x
.ad43	9e 00 da	stz $da00,x			stz 	$DA00,x
.ad46	ca		dex				dex
.ad47	d0 f7		bne $ad40			bne 	_CSClear
.ad49	9c 60 06	stz $0660			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ad4c	20 5f ad	jsr $ad5f			jsr 	GXClearSpriteStore
.ad4f	18		clc				clc
.ad50	60		rts				rts
.ad51					GXCalculateBaseAddress:
.ad51	85 36		sta $36				sta 	gxzTemp0
.ad53	64 37		stz $37				stz 	gxzTemp0+1
.ad55	a9 05		lda #$05			lda 	#5
.ad57					_GXShift:
.ad57	06 36		asl $36				asl 	gxzTemp0
.ad59	26 37		rol $37				rol 	gxzTemp0+1
.ad5b	3a		dec a				dec		a
.ad5c	d0 f9		bne $ad57			bne 	_GXShift
.ad5e	60		rts				rts
.ad5f					GXClearSpriteStore:
.ad5f	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ad61					_GXCSSLoop:
.ad61	9e a3 06	stz $06a3,x			stz 	GXSpriteHigh,x
.ad64	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad66	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.ad69	ca		dex				dex
.ad6a	10 f5		bpl $ad61			bpl 	_GXCSSLoop
.ad6c	60		rts				rts
.ad6d					GXLine:
.ad6d	ad 54 06	lda $0654			lda 	GXBitmapsOn
.ad70	f0 28		beq $ad9a			beq 	_GXLFail
.ad72	20 4a b2	jsr $b24a			jsr 	GXOpenBitmap
.ad75	20 90 b3	jsr $b390			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ad78	20 40 ae	jsr $ae40			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ad7b	20 5a b2	jsr $b25a			jsr 	GXPositionCalc 				; calculate position/offset.
.ad7e					_GXDrawLoop:
.ad7e	ac 5d 06	ldy $065d			ldy 	gsOffset 					; draw the pixel
.ad81	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ad83	2d 5b 06	and $065b			and 	gxANDValue
.ad86	4d 5a 06	eor $065a			eor 	gxEORValue
.ad89	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ad8b	20 9c ad	jsr $ad9c			jsr 	GXLineIsComplete 			; is the line complete ?
.ad8e	f0 05		beq $ad95			beq 	_GXLExit
.ad90	20 b7 ad	jsr $adb7			jsr 	GXLineAdvance 				; code as per advance method
.ad93	80 e9		bra $ad7e			bra 	_GXDrawLoop
.ad95					_GXLExit:
.ad95	20 52 b2	jsr $b252			jsr 	GXCloseBitmap
.ad98	18		clc				clc
.ad99	60		rts				rts
.ad9a					_GXLFail:
.ad9a	38		sec				sec
.ad9b	60		rts				rts
.ad9c					GXLineIsComplete:
.ad9c	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger 			; is dy larger
.ad9f	d0 0f		bne $adb0			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ada1	ad 4b 06	lda $064b			lda 	GXX0 						; compare X, LSB and MSB
.ada4	4d 4f 06	eor $064f			eor 	GXX1
.ada7	d0 06		bne $adaf			bne 	_GXLICExit
.ada9	ad 4c 06	lda $064c			lda 	GXX0+1
.adac	4d 50 06	eor $0650			eor 	GXX1+1
.adaf					_GXLICExit:
.adaf	60		rts				rts
.adb0					_GXLICCompareY:
.adb0	ad 51 06	lda $0651			lda 	GXY1
.adb3	4d 4d 06	eor $064d			eor 	GXY0
.adb6	60		rts				rts
.adb7					GXLineAdvance:
.adb7	18		clc				clc 								; add adjust to position
.adb8	ad ec 06	lda $06ec			lda 	GXPosition
.adbb	6d ed 06	adc $06ed			adc 	GXAdjust
.adbe	8d ec 06	sta $06ec			sta 	GXPosition
.adc1	9c ef 06	stz $06ef			stz 	GXAddSelect 				; clear add select flag
.adc4	b0 05		bcs $adcb			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.adc6	cd ee 06	cmp $06ee			cmp 	GXTotal 					; if exceeded total
.adc9	90 0a		bcc $add5			bcc 	_GXLANoExtra
.adcb					_GXLAOverflow:
.adcb	ce ef 06	dec $06ef			dec 	GXAddSelect 				; set addselect to $FF
.adce	38		sec				sec 								; subtract total and write back
.adcf	ed ee 06	sbc $06ee			sbc 	GXTotal
.add2	8d ec 06	sta $06ec			sta 	GXPosition
.add5					_GXLANoExtra:
.add5	ad ea 06	lda $06ea			lda 	GXIsDiffYLarger
.add8	f0 0d		beq $ade7			beq 	_GXDXLarger
.adda	20 39 ae	jsr $ae39			jsr 	GXIncrementY
.addd	ad ef 06	lda $06ef			lda 	GXAddSelect
.ade0	f0 10		beq $adf2			beq 	_GXLAExit
.ade2	20 f3 ad	jsr $adf3			jsr 	GXAdjustX
.ade5	80 0b		bra $adf2			bra 	_GXLAExit
.ade7					_GXDXLarger:
.ade7	20 f3 ad	jsr $adf3			jsr 	GXAdjustX
.adea	ad ef 06	lda $06ef			lda 	GXAddSelect
.aded	f0 03		beq $adf2			beq 	_GXLAExit
.adef	20 39 ae	jsr $ae39			jsr 	GXIncrementY
.adf2					_GXLAExit:
.adf2	60		rts				rts
.adf3					GXAdjustX:
.adf3	ad eb 06	lda $06eb			lda 	GXDXNegative
.adf6	10 25		bpl $ae1d			bpl 	_GXAXRight
.adf8	ad 4b 06	lda $064b			lda 	GXX0
.adfb	d0 03		bne $ae00			bne 	_GXAXNoBorrow
.adfd	ce 4c 06	dec $064c			dec 	GXX0+1
.ae00					_GXAXNoBorrow:
.ae00	ce 4b 06	dec $064b			dec 	GXX0
.ae03	ce 5d 06	dec $065d			dec 	gsOffset 					; pixel left
.ae06	ad 5d 06	lda $065d			lda 	gsOffset
.ae09	c9 ff		cmp #$ff			cmp 	#$FF
.ae0b	d0 0f		bne $ae1c			bne 	_GXAYExit 					; underflow
.ae0d	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.ae0f	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.ae11	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.ae13	b0 07		bcs $ae1c			bcs 	_GXAYExit
.ae15	18		clc				clc
.ae16	69 20		adc #$20			adc 	#$20 						; fix up
.ae18	85 3d		sta $3d				sta 	gxzScreen+1
.ae1a	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ae1c					_GXAYExit:
.ae1c	60		rts				rts
.ae1d					_GXAXRight:
.ae1d	ee 4b 06	inc $064b			inc 	GXX0
.ae20	d0 03		bne $ae25			bne 	_GXAXNoCarry
.ae22	ee 4c 06	inc $064c			inc 	GXX0+1
.ae25					_GXAXNoCarry:
.ae25	ee 5d 06	inc $065d			inc 	gsOffset 					; pixel right
.ae28	d0 0e		bne $ae38			bne 	_GXAXExit 					; if not overflowed, exit.
.ae2a	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ae2c	a5 3d		lda $3d				lda 	gxzScreen+1
.ae2e	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ae30	90 06		bcc $ae38			bcc 	_GXAXExit
.ae32	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae34	85 3d		sta $3d				sta 	gxzScreen+1
.ae36	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ae38					_GXAXExit:
.ae38	60		rts				rts
.ae39					GXIncrementY:
.ae39	ee 4d 06	inc $064d			inc 	GXY0
.ae3c	20 b0 b2	jsr $b2b0			jsr 	GXMovePositionDown
.ae3f	60		rts				rts
.ae40					GXLineSetup:
.ae40	ad 51 06	lda $0651			lda 	GXY1
.ae43	38		sec				sec
.ae44	ed 4d 06	sbc $064d			sbc 	GXY0
.ae47	4a		lsr a				lsr 	a
.ae48	8d e9 06	sta $06e9			sta 	GXDiffY
.ae4b	9c eb 06	stz $06eb			stz 	GXDXNegative 				; clear -ve flag
.ae4e	38		sec				sec
.ae4f	ad 4f 06	lda $064f			lda 	GXX1
.ae52	ed 4b 06	sbc $064b			sbc 	GXX0
.ae55	8d e8 06	sta $06e8			sta 	GXDiffX
.ae58	ad 50 06	lda $0650			lda 	GXX1+1 						; calculate MSB
.ae5b	ed 4c 06	sbc $064c			sbc 	GXX0+1
.ae5e	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ae5f	6e e8 06	ror $06e8			ror 	GXDiffX
.ae62	0a		asl a				asl 	a
.ae63	10 0c		bpl $ae71			bpl 	_GDXNotNegative
.ae65	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae67	38		sec				sec
.ae68	ed e8 06	sbc $06e8			sbc 	GXDiffX
.ae6b	8d e8 06	sta $06e8			sta 	GXDiffX
.ae6e	ce eb 06	dec $06eb			dec 	GXDXNegative 				; -ve flag = $FF.
.ae71					_GDXNotNegative:
.ae71	9c ea 06	stz $06ea			stz 	GXIsDiffYLarger 			; clear larger flag
.ae74	ad e9 06	lda $06e9			lda 	GXDiffY 					; set adjust and total.
.ae77	8d ed 06	sta $06ed			sta 	GXAdjust
.ae7a	ad e8 06	lda $06e8			lda 	GXDiffX
.ae7d	8d ee 06	sta $06ee			sta 	GXTotal
.ae80	ad e9 06	lda $06e9			lda 	GXDiffY 					; if dy > dx
.ae83	cd e8 06	cmp $06e8			cmp 	GXDiffX
.ae86	90 0f		bcc $ae97			bcc 	_GDXNotLarger
.ae88	ce ea 06	dec $06ea			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ae8b	ad e8 06	lda $06e8			lda 	GXDiffX 					; set adjust and total other way round
.ae8e	8d ed 06	sta $06ed			sta 	GXAdjust
.ae91	ad e9 06	lda $06e9			lda 	GXDiffY
.ae94	8d ee 06	sta $06ee			sta 	GXTotal
.ae97					_GDXNotLarger:
.ae97	ad ee 06	lda $06ee			lda 	GXTotal
.ae9a	4a		lsr a				lsr 	a
.ae9b	8d ec 06	sta $06ec			sta 	GXPosition
.ae9e	60		rts				rts
.06e8					GXDiffX:
>06e8							.fill 	1
.06e9					GXDiffY:
>06e9							.fill 	1
.06ea					GXIsDiffYLarger:
>06ea							.fill 	1
.06eb					GXDXNegative:
>06eb							.fill 	1
.06ec					GXPosition:
>06ec							.fill 	1
.06ed					GXAdjust:
>06ed							.fill 	1
.06ee					GXTotal:
>06ee							.fill 	1
.06ef					GXAddSelect:
>06ef							.fill 	1
.ae9f					GXSetColourMode:
.ae9f	a6 36		ldx $36				ldx 	gxzTemp0
.aea1	8e 59 06	stx $0659			stx 	gxColour 								; set colour
.aea4	a5 37		lda $37				lda 	gxzTemp0+1 								;
.aea6	8d 58 06	sta $0658			sta 	gxMode 									; set mode
.aea9	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.aeab	9c 5b 06	stz $065b			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.aeae	ae 59 06	ldx $0659			ldx 	gxColour
.aeb1	8e 5a 06	stx $065a			stx 	gxEORValue
.aeb4	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.aeb6	90 03		bcc $aebb			bcc 	_GXSDCNotAndColour
.aeb8	8e 5b 06	stx $065b			stx 	gxANDValue
.aebb					_GXSDCNotAndColour:
.aebb	d0 03		bne $aec0			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.aebd	9c 5a 06	stz $065a			stz 	gxEORValue
.aec0					_GXSDCNotAnd:
.aec0	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.aec1	90 08		bcc $aecb			bcc 	_GXSDCNoFlip
.aec3	ad 5b 06	lda $065b			lda	 	gxANDValue
.aec6	49 ff		eor #$ff			eor 	#$FF
.aec8	8d 5b 06	sta $065b			sta 	gxANDValue
.aecb					_GXSDCNoFlip:
.aecb	18		clc				clc
.aecc	60		rts				rts
.aecd					GXPlotPoint:
.aecd	20 4a b2	jsr $b24a			jsr 	GXOpenBitmap 				; start drawing
.aed0	20 5a b2	jsr $b25a			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aed3	ac 5d 06	ldy $065d			ldy 	gsOffset
.aed6	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.aed8	2d 5b 06	and $065b			and 	gxANDValue
.aedb	4d 5a 06	eor $065a			eor 	gxEORValue
.aede	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aee0	20 52 b2	jsr $b252			jsr 	GXCloseBitmap 				; stop drawing and exit
.aee3	18		clc				clc
.aee4	60		rts				rts
.aee5					GXFillRectangle:
.aee5	38		sec				sec
.aee6	80 01		bra $aee9			bra 	GXRectangle
.aee8					GXFrameRectangle:
.aee8	18		clc				clc
.aee9					GXRectangle:
.aee9	ad 54 06	lda $0654			lda 	gxBitmapsOn
.aeec	f0 35		beq $af23			beq 	_GXRFail
.aeee	08		php				php 								; save Fill flag (CS)
.aeef	20 4a b2	jsr $b24a			jsr 	GXOpenBitmap 				; start drawing
.aef2	20 72 b3	jsr $b372			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.aef5	20 5a b2	jsr $b25a			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aef8	38		sec				sec 								; sec = Draw line
.aef9	20 25 af	jsr $af25			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.aefc	ad 4d 06	lda $064d			lda 	gxY0 						; reached end of rectangle ?
.aeff	cd 51 06	cmp $0651			cmp 	gxY1
.af02	f0 19		beq $af1d			beq 	_GXRectangleExit
.af04					_GXRectLoop:
.af04	20 b0 b2	jsr $b2b0			jsr 	GXMovePositionDown 			; down one.
.af07	ee 4d 06	inc $064d			inc 	gxY0 						; change Y pos
.af0a	ad 4d 06	lda $064d			lda 	gxY0 						; reached last line
.af0d	cd 51 06	cmp $0651			cmp 	gXY1
.af10	f0 07		beq $af19			beq 	_GXLastLine
.af12	28		plp				plp 								; get flag back
.af13	08		php				php
.af14	20 25 af	jsr $af25			jsr 	GXDrawLineX1X0 				; draw horizontal line
.af17	80 eb		bra $af04			bra 	_GXRectLoop
.af19					_GXLastLine:
.af19	38		sec				sec
.af1a	20 25 af	jsr $af25			jsr 	GXDrawLineX1X0
.af1d					_GXRectangleExit:
.af1d	68		pla				pla 								; throw fill flag.
.af1e	20 52 b2	jsr $b252			jsr 	GXCloseBitmap 				; stop drawing and exit
.af21	18		clc				clc
.af22	60		rts				rts
.af23					_GXRFail:
.af23	38		sec				sec
.af24	60		rts				rts
.af25					GXDrawLineX1X0:
.af25	08		php				php 								; save solid/either-end
.af26	38		sec				sec
.af27	ad 4f 06	lda $064f			lda		gXX1
.af2a	ed 4b 06	sbc $064b			sbc 	gXX0
.af2d	85 36		sta $36				sta 	gxzTemp0
.af2f	ad 50 06	lda $0650			lda 	gXX1+1
.af32	ed 4c 06	sbc $064c			sbc 	gXX0+1
.af35	85 37		sta $37				sta 	gxzTemp0+1
.af37	28		plp				plp
.af38					GXDrawLineTemp0:
.af38	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.af3a	48		pha				pha
.af3b	a5 3d		lda $3d				lda 	gxzScreen+1
.af3d	48		pha				pha
.af3e	ad 5d 06	lda $065d			lda 	gsOffset
.af41	48		pha				pha
.af42	a5 0b		lda $0b				lda 	GXEditSlot
.af44	48		pha				pha
.af45	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y offset
.af48	90 1e		bcc $af68			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.af4a					_GXDLTLine:
.af4a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af4c	2d 5b 06	and $065b			and 	gxANDValue
.af4f	4d 5a 06	eor $065a			eor 	gxEORValue
.af52	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af54	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.af56	d0 04		bne $af5c			bne 	_GXDLTNoBorrow
.af58	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.af5a	30 2e		bmi $af8a			bmi 	_GXDLTExit
.af5c					_GXDLTNoBorrow:
.af5c	c6 36		dec $36				dec 	gxzTemp0
.af5e	c8		iny				iny 								; next slot.
.af5f	d0 e9		bne $af4a			bne 	_GXDLTLine
.af61	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.af63	20 98 af	jsr $af98			jsr 	GXDLTCheckWrap				; check for new page.
.af66	80 e2		bra $af4a			bra 	_GXDLTLine
.af68					_GXDLTEndPoints:
.af68	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af6a	2d 5b 06	and $065b			and 	gxANDValue
.af6d	4d 5a 06	eor $065a			eor 	gxEORValue
.af70	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af72	98		tya				tya 								; advance to right side
.af73	18		clc				clc
.af74	65 36		adc $36				adc 	gxzTemp0
.af76	a8		tay				tay
.af77	a5 3d		lda $3d				lda 	gxzScreen+1
.af79	65 37		adc $37				adc 	gxzTemp0+1
.af7b	85 3d		sta $3d				sta 	gxzScreen+1
.af7d	20 98 af	jsr $af98			jsr 	GXDLTCheckWrap 			; fix up.
.af80	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af82	2d 5b 06	and $065b			and 	gxANDValue
.af85	4d 5a 06	eor $065a			eor 	gxEORValue
.af88	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af8a					_GXDLTExit:
.af8a	68		pla				pla
.af8b	85 0b		sta $0b				sta 	GXEditSlot
.af8d	68		pla				pla
.af8e	8d 5d 06	sta $065d			sta 	gsOffset
.af91	68		pla				pla
.af92	85 3d		sta $3d				sta 	gxzScreen+1
.af94	68		pla				pla
.af95	85 3c		sta $3c				sta 	gxzScreen
.af97	60		rts				rts
.af98					GXDLTCheckWrap:
.af98	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.af9a	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.af9c	90 06		bcc $afa4			bcc 	_GXDLTCWExit
.af9e	e9 20		sbc #$20			sbc 	#$20 						; fix up
.afa0	85 3d		sta $3d				sta 	gxzScreen+1
.afa2	e6 0b		inc $0b				inc 	GXEditSlot
.afa4					_GXDLTCWExit:
.afa4	60		rts				rts
.afa5					GXDrawGraphicElement:
.afa5	8d f0 06	sta $06f0			sta 	gxSize 						; save size
.afa8	3a		dec a				dec 	a
.afa9	8d f1 06	sta $06f1			sta 	gxMask 						; and mask
.afac	ad 54 06	lda $0654			lda 	gxBitmapsOn 				; check BMP on
.afaf	f0 67		beq $b018			beq 	_GXSLFail
.afb1	ad 4d 06	lda $064d			lda 	gxY0 						; push Y on stack
.afb4	48		pha				pha
.afb5	8c f3 06	sty $06f3			sty 	gxAcquireVector+1 			; and acquisition vector
.afb8	8e f2 06	stx $06f2			stx 	gxAcquireVector
.afbb	20 4a b2	jsr $b24a			jsr 	gxOpenBitmap 				; open the bitmap.
.afbe	ad f5 06	lda $06f5			lda 	gxUseMode 					; scale bits
.afc1	4a		lsr a				lsr 	a
.afc2	4a		lsr a				lsr 	a
.afc3	4a		lsr a				lsr 	a
.afc4	29 07		and #$07			and		#7
.afc6	1a		inc a				inc 	a
.afc7	8d f4 06	sta $06f4			sta 	gxScale
.afca	64 38		stz $38				stz 	gxzTemp1					; start first line
.afcc					_GXGELoop:
.afcc	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.afce	2c f5 06	bit $06f5			bit 	gxUseMode 					; check for flip.
.afd1	10 06		bpl $afd9			bpl		_GXNoVFlip
.afd3	ad f1 06	lda $06f1			lda 	gxMask
.afd6	38		sec				sec
.afd7	e5 38		sbc $38				sbc 	gxzTemp1
.afd9					_GXNoVFlip:
.afd9	aa		tax				tax 								; get the Xth line.
.afda	20 1a b0	jsr $b01a			jsr 	_GXCallAcquire 				; get that data.
.afdd	ad f4 06	lda $06f4			lda 	gxScale 					; do scale identical copies of that line.
.afe0	85 39		sta $39				sta 	gxzTemp1+1
.afe2					_GXGELoop2:
.afe2	ad 4d 06	lda $064d			lda 	gxY0 						; off screen
.afe5	cd 57 06	cmp $0657			cmp 	gxHeight
.afe8	b0 10		bcs $affa			bcs 	_GXDGEExit
.afea	20 1d b0	jsr $b01d			jsr 	GXRenderOneLine 			; render line
.afed	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.afef	d0 f1		bne $afe2			bne 	_GXGELoop2
.aff1	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.aff3	a5 38		lda $38				lda 	gxzTemp1
.aff5	cd f0 06	cmp $06f0			cmp 	gxSize
.aff8	d0 d2		bne $afcc			bne 	_GXGELoop
.affa					_GXDGEExit:
.affa	68		pla				pla 								; restore Y for next time
.affb	8d 4d 06	sta $064d			sta 	gxY0
.affe	ae f4 06	ldx $06f4			ldx 	gxScale 					; get scale (1-8)
.b001					_GXShiftLeft:
.b001	18		clc				clc
.b002	ad f0 06	lda $06f0			lda 	gxSize
.b005	6d 4b 06	adc $064b			adc 	gxX0
.b008	8d 4b 06	sta $064b			sta 	gxX0
.b00b	90 03		bcc $b010			bcc 	_GXSLNoCarry
.b00d	ee 4c 06	inc $064c			inc 	gxX0+1
.b010					_GXSLNoCarry:
.b010	ca		dex				dex
.b011	d0 ee		bne $b001			bne 	_GXShiftLeft
.b013	20 52 b2	jsr $b252			jsr 	GXCloseBitmap
.b016	18		clc				clc
.b017	60		rts				rts
.b018					_GXSLFail:
.b018	38		sec				sec
.b019	60		rts				rts
.b01a					_GXCallAcquire:
.b01a	6c f2 06	jmp ($06f2)			jmp 	(gxAcquireVector)
.b01d					GXRenderOneLine:
.b01d	20 5a b2	jsr $b25a			jsr 	GXPositionCalc 				; calculate position/offset.
.b020	ac 5d 06	ldy $065d			ldy 	gsOffset 					; Y contains position.
.b023	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b025					_GXROLLoop1:
.b025	ad f4 06	lda $06f4			lda 	gxScale 					; set to do 'scale' times
.b028	85 3b		sta $3b				sta 	gxzTemp2+1
.b02a					_GXROLLoop2:
.b02a	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b02c	2c 58 06	bit $0658			bit 	gxMode 						; check H Flip
.b02f	50 06		bvc $b037			bvc 	_GXNoHFlip
.b031	ad f1 06	lda $06f1			lda 	gxMask
.b034	38		sec				sec
.b035	e5 3a		sbc $3a				sbc 	gxzTemp2
.b037					_GXNoHFlip:
.b037	aa		tax				tax 								; read from the pixel buffer
.b038	bd f9 05	lda $05f9,x			lda 	gxPixelBuffer,x
.b03b	d0 07		bne $b044			bne 	_GXDraw 					; draw if non zero
.b03d	ad f5 06	lda $06f5			lda 	gxUseMode 					; check to see if solid background
.b040	29 04		and #$04			and 	#4
.b042	f0 0a		beq $b04e			beq 	_GXZeroPixel
.b044					_GXDraw:
.b044	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b046	2d 5b 06	and $065b			and 	gxANDValue
.b049	5d f9 05	eor $05f9,x			eor 	gxPixelBuffer,x
.b04c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b04e					_GXZeroPixel:
.b04e	c8		iny				iny 								; advance pointer
.b04f	d0 05		bne $b056			bne 	_GXNoShift
.b051	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b053	20 98 af	jsr $af98			jsr 	GXDLTCheckWrap				; check for new page.
.b056					_GXNoShift:
.b056	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b058	d0 d0		bne $b02a			bne 	_GXROLLoop2
.b05a	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b05c	a5 3a		lda $3a				lda 	gxzTemp2
.b05e	cd f0 06	cmp $06f0			cmp 	gxSize
.b061	d0 c2		bne $b025			bne 	_GXROLLoop1
.b063	ee 4d 06	inc $064d			inc 	gxY0
.b066	60		rts				rts
.06f0					gxSize:
>06f0							.fill 	1
.06f1					gxMask:
>06f1							.fill 	1
.06f2					gxAcquireVector:
>06f2							.fill 	2
.06f4					gxScale:
>06f4							.fill 	1
.06f5					gxUseMode:
>06f5							.fill 	1
.b067					GXFontHandler:
.b067	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b069	4d 58 06	eor $0658			eor 	gxMode
.b06c	8d f5 06	sta $06f5			sta 	gxUseMode
.b06f	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b071	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b073	26 37		rol $37				rol	 	gxzTemp0+1
.b075	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b077	26 37		rol $37				rol	 	gxzTemp0+1
.b079	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b07b	26 37		rol $37				rol	 	gxzTemp0+1
.b07d	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b07f	09 c0		ora #$c0			ora 	#$C0
.b081	85 37		sta $37				sta 	gxzTemp0+1
.b083	a9 08		lda #$08			lda 	#8 							; size 8x8
.b085	a2 8d		ldx #$8d			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b087	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b089	20 a5 af	jsr $afa5			jsr 	GXDrawGraphicElement
.b08c	60		rts				rts
.b08d					GXGetGraphicDataFont:
.b08d	8a		txa				txa 								; X->Y
.b08e	a8		tay				tay
.b08f	a6 01		ldx $01				ldx 	1 							; preserve old value
.b091	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b093	85 01		sta $01				sta 	1
.b095	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b097	86 01		stx $01				stx 	1 							; put old value back.
.b099	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b09b					_GXExpand:
.b09b	9e f9 05	stz $05f9,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b09e	0a		asl a				asl 	a 							; shift bit 7 into C
.b09f	90 08		bcc $b0a9			bcc 	_GXNoPixel
.b0a1	48		pha				pha 								; if set, set pixel buffer to current colour.
.b0a2	ad 59 06	lda $0659			lda 	gxColour
.b0a5	9d f9 05	sta $05f9,x			sta 	gxPixelBuffer,x
.b0a8	68		pla				pla
.b0a9					_GXNoPixel:
.b0a9	e8		inx				inx 								; do the whole byte.
.b0aa	e0 08		cpx #$08			cpx 	#8
.b0ac	d0 ed		bne $b09b			bne 	_GXExpand
.b0ae	60		rts				rts
.b0af					GXSpriteHandler:
.b0af	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b0b1	4d 58 06	eor $0658			eor 	gxMode
.b0b4	8d f5 06	sta $06f5			sta 	gxUseMode
.b0b7	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b0b9	da		phx				phx
.b0ba	20 4a b2	jsr $b24a			jsr 	GXOpenBitmap 				; can access sprite information
.b0bd	68		pla				pla
.b0be	20 2b b3	jsr $b32b			jsr 	GXFindSprite 				; get the sprite address
.b0c1	08		php				php
.b0c2	20 52 b2	jsr $b252			jsr 	GXCloseBitmap
.b0c5	28		plp				plp
.b0c6	b0 0a		bcs $b0d2			bcs		_GXSHExit 					; exit if find failed.
.b0c8	ad f6 06	lda $06f6			lda 	GXSizePixels 				; return size
.b0cb	a2 d3		ldx #$d3			ldx 	#GXSpriteAcquire & $FF
.b0cd	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b0cf	20 a5 af	jsr $afa5			jsr 	GXDrawGraphicElement
.b0d2					_GXSHExit:
.b0d2	60		rts				rts
.b0d3					GXSpriteAcquire:
.b0d3	ad 56 06	lda $0656			lda 	GXSpritePage				; point to base page
.b0d6	85 0b		sta $0b				sta 	GXEditSlot
.b0d8	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b0da	a9 00		lda #$00			lda 	#0
.b0dc	ae f7 06	ldx $06f7			ldx 	GXSizeBits
.b0df					_GXTimesRowNumber:
.b0df	18		clc				clc
.b0e0	65 36		adc $36				adc 	zTemp0
.b0e2	ca		dex				dex
.b0e3	10 fa		bpl $b0df			bpl 	_GXTimesRowNumber
.b0e5	64 37		stz $37				stz 	gxzTemp0+1
.b0e7	0a		asl a				asl 	a 							; row x 2,4,6,8
.b0e8	26 37		rol $37				rol 	gxzTemp0+1
.b0ea	0a		asl a				asl 	a 							; row x 4,8,12,16
.b0eb	26 37		rol $37				rol 	gxzTemp0+1
.b0ed	0a		asl a				asl 	a 							; row x 8,16,24,32
.b0ee	26 37		rol $37				rol 	gxzTemp0+1
.b0f0	85 36		sta $36				sta 	gxzTemp0
.b0f2	18		clc				clc 								; add base address.
.b0f3	a5 36		lda $36				lda 	gxzTemp0
.b0f5	6d f9 06	adc $06f9			adc 	GXSpriteOffset
.b0f8	85 36		sta $36				sta 	gxzTemp0
.b0fa	a5 37		lda $37				lda 	gxzTemp0+1
.b0fc	6d fa 06	adc $06fa			adc 	GXSpriteOffset+1
.b0ff					_GXSAFindPage:
.b0ff	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b101	90 06		bcc $b109			bcc 	_GXSAFoundPage
.b103	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b105	e6 0b		inc $0b				inc 	GXEditSlot
.b107	80 f6		bra $b0ff			bra 	_GXSAFindPage
.b109					_GXSAFoundPage:
.b109	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b10b	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b10d	a0 00		ldy #$00			ldy 	#0
.b10f					_GXSACopyLoop:
.b10f	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b111	99 f9 05	sta $05f9,y			sta 	gxPixelBuffer,y
.b114	c8		iny				iny
.b115	cc f6 06	cpy $06f6			cpy 	GXSizePixels
.b118	d0 f5		bne $b10f			bne 	_GXSACopyLoop
.b11a	60		rts				rts
.b11b					GXSelect:
.b11b	ad 53 06	lda $0653			lda 	gxSpritesOn
.b11e	f0 22		beq $b142			beq 	_GXSFail
.b120	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b122	c9 40		cmp #$40			cmp 	#64
.b124	b0 1c		bcs $b142			bcs 	_GXSFail
.b126	8d 5e 06	sta $065e			sta 	GSCurrentSpriteID
.b129	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b12b	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b12d	06 36		asl $36				asl 	gxzTemp0
.b12f	06 36		asl $36				asl 	gxzTemp0
.b131	06 36		asl $36				asl 	gxzTemp0
.b133	2a		rol a				rol 	a
.b134	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b136	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b139	85 37		sta $37				sta 	gxzTemp0+1
.b13b	a5 36		lda $36				lda 	gxzTemp0
.b13d	8d 5f 06	sta $065f			sta 	GSCurrentSpriteAddr
.b140	18		clc				clc
.b141	60		rts				rts
.b142					_GXSFail:
.b142	38		sec				sec
.b143	60		rts				rts
.b144					GXSelectImage:
.b144	ad 53 06	lda $0653			lda 	gxSpritesOn
.b147	f0 74		beq $b1bd			beq 	_GXSIFail
.b149	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b14c	f0 6f		beq $b1bd			beq 	_GXSIFail 					; (checking the MSB)
.b14e	64 01		stz $01				stz 	1
.b150	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b152	d0 6b		bne $b1bf			bne 	_GXSIHide
.b154	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b156	48		pha				pha
.b157	20 4a b2	jsr $b24a			jsr 	GXOpenBitmap
.b15a	68		pla				pla
.b15b	20 2b b3	jsr $b32b			jsr 	GXFindSprite
.b15e	b0 5a		bcs $b1ba			bcs 	_GXSICloseFail 				; no image
.b160	a0 01		ldy #$01			ldy 	#1
.b162	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b165	85 36		sta $36				sta 	gxzTemp0
.b167	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b16a	85 37		sta $37				sta 	gxzTemp0+1
.b16c	ad f9 06	lda $06f9			lda 	GXSpriteOffset
.b16f	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b171	18		clc				clc
.b172	ad fa 06	lda $06fa			lda 	GXSpriteOffset+1
.b175	6d 61 06	adc $0661			adc 	GXSpriteOffsetBase
.b178	c8		iny				iny
.b179	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b17b	ad 62 06	lda $0662			lda 	GXSpriteOffsetBase+1
.b17e	69 00		adc #$00			adc 	#0
.b180	c8		iny				iny
.b181	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b183	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get raw size
.b186	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b188	2a		rol a				rol 	a 							; x 2
.b189	0a		asl a				asl 	a 							; x 4
.b18a	0a		asl a				asl 	a 							; x 8
.b18b	0a		asl a				asl 	a 							; x 16
.b18c	0d f8 06	ora $06f8			ora 	GXSpriteLUT 				; Or with LUT
.b18f	0a		asl a				asl 	a 							; 1 shift
.b190	09 01		ora #$01			ora 	#1 							; enable sprite.
.b192	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b194	20 52 b2	jsr $b252			jsr 	GXCloseBitmap
.b197	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b19a	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b19d	29 3f		and #$3f			and 	#$3F
.b19f	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1a2	ad f7 06	lda $06f7			lda 	GXSizeBits 					; get bit size
.b1a5	6a		ror a				ror 	a 							; shift into bits 6/7
.b1a6	6a		ror a				ror 	a
.b1a7	6a		ror a				ror 	a
.b1a8	29 c0		and #$c0			and 	#$C0
.b1aa	1d a3 06	ora $06a3,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b1ad	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b1b0	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b1b3	29 7f		and #$7f			and 	#$7F
.b1b5	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b1b8	18		clc				clc
.b1b9	60		rts				rts
.b1ba					_GXSICloseFail:
.b1ba	20 52 b2	jsr $b252			jsr 	GXCloseBitmap
.b1bd					_GXSIFail:
.b1bd	38		sec				sec
.b1be	60		rts				rts
.b1bf					_GXSIHide:
.b1bf	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b1c2	85 36		sta $36				sta 	gxzTemp0
.b1c4	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1
.b1c7	85 37		sta $37				sta 	gxzTemp0+1
.b1c9	a9 00		lda #$00			lda 	#0
.b1cb	92 36		sta ($36)			sta 	(gxzTemp0)
.b1cd	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get sprite ID
.b1d0	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b1d3	09 80		ora #$80			ora 	#$80
.b1d5	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b1d8	18		clc				clc
.b1d9	60		rts				rts
.b1da					GXMoveSprite:
.b1da	ad 53 06	lda $0653			lda 	gxSpritesOn
.b1dd	f0 65		beq $b244			beq 	_GXSIFail
.b1df	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b1e2	f0 60		beq $b244			beq 	_GXSIFail
.b1e4	85 37		sta $37				sta 	gxzTemp0+1
.b1e6	a0 04		ldy #$04			ldy 	#4
.b1e8	ad 5f 06	lda $065f			lda 	GSCurrentSpriteAddr
.b1eb	85 36		sta $36				sta 	gxzTemp0
.b1ed	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b1f0	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b1f3	2a		rol a				rol 	a	 						; into bits 0,1.
.b1f4	2a		rol a				rol 	a
.b1f5	2a		rol a				rol 	a
.b1f6	29 03		and #$03			and 	#3
.b1f8	aa		tax				tax
.b1f9	bd 46 b2	lda $b246,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b1fc	48		pha				pha
.b1fd	18		clc				clc
.b1fe	6d 4b 06	adc $064b			adc 	gxX0						; copy position.
.b201	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b203	c8		iny				iny
.b204	ad 4c 06	lda $064c			lda 	gxX0+1
.b207	69 00		adc #$00			adc 	#0
.b209	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b20b	c8		iny				iny
.b20c	68		pla				pla
.b20d	18		clc				clc
.b20e	6d 4d 06	adc $064d			adc 	gxY0
.b211	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b213	a9 00		lda #$00			lda 	#0
.b215	69 00		adc #$00			adc 	#0
.b217	c8		iny				iny
.b218	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b21a	4e 4c 06	lsr $064c			lsr 	gxX0+1 						; divide X by 4
.b21d	6e 4b 06	ror $064b			ror 	gxX0
.b220	4e 4b 06	lsr $064b			lsr 	gxX0
.b223	4e 4d 06	lsr $064d			lsr 	gxY0 						; divide Y by 4
.b226	4e 4d 06	lsr $064d			lsr 	gxY0
.b229	ae 5e 06	ldx $065e			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b22c	bd 63 06	lda $0663,x			lda 	GXSpriteLow,x
.b22f	29 80		and #$80			and 	#$80
.b231	0d 4b 06	ora $064b			ora 	gxX0
.b234	9d 63 06	sta $0663,x			sta 	GXSpriteLow,x
.b237	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b23a	29 c0		and #$c0			and 	#$C0
.b23c	0d 4d 06	ora $064d			ora 	gxY0
.b23f	9d a3 06	sta $06a3,x			sta 	GXSpriteHigh,x
.b242	18		clc				clc
.b243	60		rts				rts
.b244					_GXSIFail:
.b244	38		sec				sec
.b245	60		rts				rts
.b246					_GXMSOffset:
>b246	1c						.byte 	32-8/2
>b247	18						.byte 	32-16/2
>b248	14						.byte 	32-24/2
>b249	10						.byte 	32-32/2
.b24a					GXOpenBitmap:
.b24a	78		sei				sei 								; no interrupts here
.b24b	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b24d	8d 5c 06	sta $065c			sta 	gxOriginalLUTValue
.b250	58		cli				cli
.b251	60		rts				rts
.b252					GXCloseBitmap:
.b252	78		sei				sei
.b253	ad 5c 06	lda $065c			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b256	85 0b		sta $0b				sta 	GXEditSlot
.b258	58		cli				cli
.b259	60		rts				rts
.b25a					GXPositionCalc:
.b25a	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b25c	48		pha				pha
.b25d	ad 4d 06	lda $064d			lda 	GXY0 						; gxzScreen = Y0
.b260	85 3c		sta $3c				sta 	gxzScreen
.b262	64 3d		stz $3d				stz 	gxzScreen+1
.b264	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b266	26 3d		rol $3d				rol 	gxzScreen+1
.b268	06 3c		asl $3c				asl 	gxzScreen
.b26a	26 3d		rol $3d				rol 	gxzScreen+1
.b26c	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b26d	65 3c		adc $3c				adc 	gxzScreen
.b26f	85 3c		sta $3c				sta 	gxzScreen
.b271	90 02		bcc $b275			bcc 	_GXPCNoCarry
.b273	e6 3d		inc $3d				inc 	gxzScreen+1
.b275					_GXPCNoCarry:
.b275	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b277	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b279	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b27b	85 36		sta $36				sta 	gxzTemp0
.b27d	64 3d		stz $3d				stz 	gxzScreen+1
.b27f	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b281					_GXPCMultiply32:
.b281	06 3c		asl $3c				asl 	gxzScreen
.b283	26 3d		rol $3d				rol 	gxzScreen+1
.b285	3a		dec a				dec 	a
.b286	d0 f9		bne $b281			bne 	_GXPCMultiply32
.b288	18		clc				clc
.b289	ad 4b 06	lda $064b			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b28c	65 3c		adc $3c				adc 	gxzScreen
.b28e	8d 5d 06	sta $065d			sta 	gsOffset
.b291	ad 4c 06	lda $064c			lda 	GXX0+1
.b294	65 3d		adc $3d				adc 	gxzScreen+1
.b296	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b298	90 04		bcc $b29e			bcc 	_GXPCNoOverflow
.b29a	29 1f		and #$1f			and 	#$1F 						; fix it up
.b29c	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b29e					_GXPCNoOverflow:
.b29e	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b2a0	85 3d		sta $3d				sta 	gxzScreen+1
.b2a2	64 3c		stz $3c				stz 	gxzScreen
.b2a4	18		clc				clc
.b2a5	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b2a7	6d 55 06	adc $0655			adc 	gxBasePage 					; by adding the base page
.b2aa	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b2ac	68		pla				pla
.b2ad	85 36		sta $36				sta 	gxzTemp0
.b2af	60		rts				rts
.b2b0					GXMovePositionDown:
.b2b0	18		clc				clc 								; add 320 to offset/temp+1
.b2b1	ad 5d 06	lda $065d			lda 	gsOffset
.b2b4	69 40		adc #$40			adc 	#64
.b2b6	8d 5d 06	sta $065d			sta 	gsOffset
.b2b9	a5 3d		lda $3d				lda 	gxzScreen+1
.b2bb	69 01		adc #$01			adc 	#1
.b2bd	85 3d		sta $3d				sta 	gxzScreen+1
.b2bf	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b2c1	90 07		bcc $b2ca			bcc 	_GXMPDExit
.b2c3	38		sec				sec  								; next page
.b2c4	e9 20		sbc #$20			sbc 	#$20
.b2c6	85 3d		sta $3d				sta 	gxzScreen+1
.b2c8	e6 0b		inc $0b				inc 	GXEditSlot
.b2ca					_GXMPDExit:
.b2ca	60		rts				rts
.b2cb					GXCollide:
.b2cb	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b2cd	aa		tax				tax
.b2ce	05 37		ora $37				ora 	gxzTemp0+1
.b2d0	29 c0		and #$c0			and 	#$C0
.b2d2	38		sec				sec
.b2d3	d0 53		bne $b328			bne 	_GXCollideFail 				; if either >= 64, fail.
.b2d5	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b2d7	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b2da	1d 63 06	ora $0663,x			ora 	GXSpriteLow,x
.b2dd	30 48		bmi $b327			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b2df	18		clc				clc 								; need to calculate sum of sizes.
.b2e0	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y
.b2e3	7d a3 06	adc $06a3,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b2e6	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b2e8	6a		ror a				ror 	a 							; 5/6/7
.b2e9	4a		lsr a				lsr 	a 							; 4/5/6
.b2ea	4a		lsr a				lsr 	a 							; 3/4/5
.b2eb	4a		lsr a				lsr 	a 							; 2/3/4
.b2ec	18		clc				clc
.b2ed	69 08		adc #$08			adc 	#$08
.b2ef	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b2f0	4a		lsr a				lsr 	a
.b2f1	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b2f3	b9 a3 06	lda $06a3,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b2f6	29 3f		and #$3f			and 	#$3F
.b2f8	85 39		sta $39				sta 	gxzTemp1+1
.b2fa	38		sec				sec
.b2fb	bd a3 06	lda $06a3,x			lda 	GXSpriteHigh,x
.b2fe	29 3f		and #$3f			and 	#$3F
.b300	e5 39		sbc $39				sbc 	gxzTemp1+1
.b302	b0 03		bcs $b307			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b304	49 ff		eor #$ff			eor 	#$FF
.b306	1a		inc a				inc 	a
.b307					_GXCAbs1:
.b307	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b309	b0 1c		bcs $b327			bcs 	_GXOkayFail
.b30b	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b30d	38		sec				sec 								; calculate |x1-x0|
.b30e	b9 63 06	lda $0663,y			lda 	GXSpriteLow,y
.b311	fd 63 06	sbc $0663,x			sbc 	GXSpriteLow,x
.b314	b0 03		bcs $b319			bcs 	_GXCAbs2
.b316	49 ff		eor #$ff			eor 	#$FF
.b318	1a		inc a				inc 	a
.b319					_GXCAbs2:
.b319	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b31b	b0 0a		bcs $b327			bcs 	_GXOkayFail
.b31d	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b31f	90 02		bcc $b323			bcc 	_GXCHaveLowest
.b321	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b323					_GXCHaveLowest:
.b323	0a		asl a				asl 	a 							; scale to allow for >> 2
.b324	0a		asl a				asl 	a
.b325	18		clc				clc
.b326	60		rts				rts
.b327					_GXOkayFail:
.b327	18		clc				clc
.b328					_GXCollideFail:
.b328	a9 ff		lda #$ff			lda 	#$FF
.b32a	60		rts				rts
.b32b					GXFindSprite:
.b32b	aa		tax				tax
.b32c	ad 56 06	lda $0656			lda 	GXSpritePage 				; access the base page of the sprite
.b32f	85 0b		sta $0b				sta 	GXEditSlot
.b331	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b334	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b337	f0 33		beq $b36c			beq 	_GXFSFail
.b339	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b33c	8d fa 06	sta $06fa			sta 	GXSpriteOffset+1
.b33f	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b342	48		pha				pha 								; save twice
.b343	48		pha				pha
.b344	29 03		and #$03			and 	#3 							; get sprite size
.b346	8d f7 06	sta $06f7			sta 	GXSizeBits 					; save raw (0-3)
.b349	aa		tax				tax
.b34a	bd 6e b3	lda $b36e,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b34d	8d f6 06	sta $06f6			sta 	GXSizePixels 					; save (8/16/24/32)
.b350	68		pla				pla 								; get LUT
.b351	4a		lsr a				lsr		a
.b352	4a		lsr a				lsr		a
.b353	29 03		and #$03			and 	#3
.b355	8d f8 06	sta $06f8			sta 	GXSpriteLUT
.b358	68		pla				pla 								; address, neeeds to be x 4
.b359	29 f0		and #$f0			and 	#$F0
.b35b	8d f9 06	sta $06f9			sta 	GXSpriteOffset
.b35e	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b361	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b364	0e f9 06	asl $06f9			asl 	GXSpriteOffset
.b367	2e fa 06	rol $06fa			rol 	GXSpriteOffset+1
.b36a	18		clc				clc
.b36b	60		rts				rts
.b36c					_GXFSFail:
.b36c	38		sec				sec
.b36d	60		rts				rts
.b36e					_GXFXSSTTable:
>b36e	08 10 18 20					.byte 	8,16,24,32
.06f6					GXSizePixels:
>06f6							.fill 	1
.06f7					GXSizeBits:
>06f7							.fill 	1
.06f8					GXSpriteLUT:
>06f8							.fill 	1
.06f9					GXSpriteOffset:
>06f9							.fill 	2
.b372					GXSortXY:
.b372	20 90 b3	jsr $b390			jsr 	GXSortY 					; will be sorted on Y now
.b375	ad 4b 06	lda $064b			lda 	gxX0 						; compare X0 v X1
.b378	cd 4f 06	cmp $064f			cmp 	gxX1
.b37b	ad 4c 06	lda $064c			lda 	gXX0+1
.b37e	ed 50 06	sbc $0650			sbc 	gXX1+1
.b381	90 0c		bcc $b38f			bcc 	_GXSXYExit 					; X0 < X1 exit
.b383	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b385	a0 04		ldy #$04			ldy 	#4
.b387	20 a4 b3	jsr $b3a4			jsr 	GXSwapXY
.b38a	e8		inx				inx
.b38b	c8		iny				iny
.b38c	20 a4 b3	jsr $b3a4			jsr 	GXSwapXY
.b38f					_GXSXYExit:
.b38f	60		rts				rts
.b390					GXSortY:
.b390	ad 4d 06	lda $064d			lda 	gxY0 						; if Y0 >= Y1
.b393	cd 51 06	cmp $0651			cmp 	gxY1
.b396	90 0b		bcc $b3a3			bcc 	_GXSYSorted
.b398	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b39a	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b39c					_GXSwap1:
.b39c	20 a4 b3	jsr $b3a4			jsr 	GXSwapXY
.b39f	88		dey				dey
.b3a0	ca		dex				dex
.b3a1	10 f9		bpl $b39c			bpl 	_GXSwap1
.b3a3					_GXSYSorted:
.b3a3	60		rts				rts
.b3a4					GXSwapXY:
.b3a4	bd 4b 06	lda $064b,x			lda 	gxX0,x
.b3a7	48		pha				pha
.b3a8	b9 4b 06	lda $064b,y			lda 	gxX0,y
.b3ab	9d 4b 06	sta $064b,x			sta 	gxX0,x
.b3ae	68		pla				pla
.b3af	99 4b 06	sta $064b,y			sta 	gxX0,y
.b3b2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b9c3					KeywordSet0:
>b9c3	00 65					.text	0,$65,""               ; $80 !0:EOF
>b9c5	00 58					.text	0,$58,""               ; $81 !1:SH1
>b9c7	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b9c9	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b9cf	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b9d7	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b9dd	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b9e4	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>b9ec	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>b9f3	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>b9fa	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>ba00	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>ba06	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>ba0e	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>ba15	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>ba1c	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>ba23	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>ba2b	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>ba31	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>ba37	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>ba3e	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>ba44	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>ba4a	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>ba52	47 28
>ba54	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>ba5c	28
>ba5d	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>ba65	28
>ba66	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>ba6c	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>ba72	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>ba78	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>ba7f	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>ba87	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>ba8d	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>ba93	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>ba98	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>ba9c	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>baa2	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>baaa	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bab1	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bab8	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bac0	43
>bac1	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bac7	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bacd	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bad4	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bada	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bade	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bae4	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>baec	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>baf3	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>baf8	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>baff	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bb07	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bb0d	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bb12	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bb1a	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bb20	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bb26	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bb2b	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bb32	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bb38	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bb3e	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bb45	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bc LET
>bb4a	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $bd LINE
>bb50	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $be LOCAL
>bb57	03 db 4f 46 46				.text	3,$db,"OFF"            ; $bf OFF
>bb5c	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c0 ON
>bb60	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c1 OUTLINE
>bb68	45
>bb69	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c2 PALETTE
>bb71	45
>bb72	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c3 PLOT
>bb78	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c4 PRINT
>bb7f	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c5 READ
>bb85	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c6 RECT
>bb8b	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c7 REM
>bb90	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c8 RETURN
>bb98	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $c9 SOLID
>bb9f	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $ca SOUND
>bba6	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cb SPRITE
>bbae	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cc TEXT
>bbb4	02 a3 54 4f				.text	2,$a3,"TO"             ; $cd TO
>bbb8	ff					.text	$FF
.bbb9					KeywordSet1:
>bbb9	00 65					.text	0,$65,""               ; $80 !0:EOF
>bbbb	00 58					.text	0,$58,""               ; $81 !1:SH1
>bbbd	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bbbf	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bbc7	4c 45
>bbc9	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bbd1	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bbd9	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bbde	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $87 LIST
>bbe4	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $88 NEW
>bbe9	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $89 RESTORE
>bbf1	45
>bbf2	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8a RUN
>bbf7	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8b SPRITES
>bbff	53
>bc00	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8c STOP
>bc06	ff					.text	$FF
.bc07					KeywordSet2:
>bc07	00 65					.text	0,$65,""               ; $80 !0:EOF
>bc09	00 58					.text	0,$58,""               ; $81 !1:SH1
>bc0b	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bc0d	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bc12	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bc17	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bc1c	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bc21	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bc26	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bc2b	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bc30	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bc35	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bc3a	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bc3f	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bc44	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bc49	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bc4e	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bc53	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bc58	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bc5d	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bc62	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bc67	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bc6c	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bc71	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bc76	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bc7b	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bc80	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bc85	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bc8a	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bc8f	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bc94	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bc99	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bc9e	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bca3	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bca8	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bcad	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bcb2	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bcb7	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>bcbc	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>bcc1	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>bcc6	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>bccb	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>bcd0	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>bcd5	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>bcda	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>bcdf	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>bce4	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>bce9	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>bcee	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>bcf3	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>bcf8	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>bcfd	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>bd02	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>bd07	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>bd0c	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>bd11	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>bd16	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>bd1b	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>bd20	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>bd25	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>bd2a	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>bd2f	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>bd34	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bd39	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bd3e	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>bd43	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>bd48	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>bd4d	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bd52	ff					.text	$FF
.b3b3					ListConvertLine:
.b3b3	48		pha				pha 								; save indent on the stack
.b3b4	9c 9d 04	stz $049d			stz 	tbOffset
.b3b7	9c ab 04	stz $04ab			stz 	tokenBuffer
.b3ba	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b3bc	b1 30		lda ($30),y			lda 	(codePtr),y
.b3be	aa		tax				tax
.b3bf	88		dey				dey
.b3c0	b1 30		lda ($30),y			lda 	(codePtr),y
.b3c2	20 7d 92	jsr $927d			jsr 	LCLConvertInt16
.b3c5	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b3c7	86 37		stx $37				stx 	zTemp0+1
.b3c9	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b3cb	20 10 b5	jsr $b510			jsr 	LCLWrite
.b3ce	a0 00		ldy #$00			ldy 	#0
.b3d0					_LCCopyNumber:
.b3d0	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3d2	20 10 b5	jsr $b510			jsr 	LCLWrite
.b3d5	c8		iny				iny
.b3d6	b1 36		lda ($36),y			lda 	(zTemp0),y
.b3d8	d0 f6		bne $b3d0			bne 	_LCCopyNumber
.b3da	68		pla				pla 								; adjustment to indent
.b3db	48		pha				pha 								; save on stack
.b3dc	10 0c		bpl $b3ea			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b3de	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b3df	6d a6 04	adc $04a6			adc 	listIndent
.b3e2	8d a6 04	sta $04a6			sta 	listIndent
.b3e5	10 03		bpl $b3ea			bpl 	_LCNoAdjust
.b3e7	9c a6 04	stz $04a6			stz 	listIndent
.b3ea					_LCNoAdjust:
.b3ea	18		clc				clc		 							; work out actual indent.
.b3eb	ad a6 04	lda $04a6			lda 	listIndent
.b3ee	0a		asl a				asl 	a
.b3ef	69 06		adc #$06			adc 	#6
.b3f1	85 36		sta $36				sta 	zTemp0
.b3f3					_LCPadOut:
.b3f3	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b3f5	20 10 b5	jsr $b510			jsr 	LCLWrite
.b3f8	ad 9d 04	lda $049d			lda 	tbOffset
.b3fb	c5 36		cmp $36				cmp 	zTemp0
.b3fd	d0 f4		bne $b3f3			bne 	_LCPadOut
.b3ff	a0 03		ldy #$03			ldy 	#3 							; start position.
.b401					_LCMainLoop:
.b401	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b403	20 10 b5	jsr $b510			jsr 	LCLWrite
.b406	b1 30		lda ($30),y			lda 	(codePtr),y
.b408	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b40a	f0 17		beq $b423			beq 	_LCExit
.b40c	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b40e	90 1e		bcc $b42e			bcc 	_LCDoubles
.b410	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b412	90 2a		bcc $b43e			bcc 	_LCShiftPunc
.b414	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b416	90 35		bcc $b44d			bcc 	_LCPunctuation
.b418	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b41a	90 3e		bcc $b45a			bcc 	_LCIdentifiers
.b41c	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b41e	90 5f		bcc $b47f			bcc 	_LCTokens
.b420	4c df b4	jmp $b4df			jmp 	_LCData 					; 254-5 are data objects
.b423					_LCExit:
.b423	68		pla				pla 								; get old indent adjust
.b424	30 07		bmi $b42d			bmi 	_LCExit2
.b426	18		clc				clc 								; add to indent if +ve
.b427	6d a6 04	adc $04a6			adc 	listIndent
.b42a	8d a6 04	sta $04a6			sta 	listIndent
.b42d					_LCExit2:
.b42d	60		rts				rts
.b42e					_LCDoubles:
.b42e	48		pha				pha
.b42f	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b430	29 02		and #$02			and 	#2
.b432	09 3c		ora #$3c			ora 	#60 						; make < >
.b434	20 10 b5	jsr $b510			jsr 	LCLWrite
.b437	68		pla				pla 								; restore, do lower bit
.b438	29 03		and #$03			and 	#3
.b43a	09 3c		ora #$3c			ora 	#60
.b43c	80 0f		bra $b44d			bra		_LCPunctuation 				; print, increment, loop
.b43e					_LCShiftPunc:
.b43e	aa		tax				tax 								; save in X
.b43f	29 07		and #$07			and 	#7 							; lower 3 bits
.b441	f0 02		beq $b445			beq 	_LCNoAdd
.b443	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b445					_LCNoAdd:
.b445	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b447	90 02		bcc $b44b			bcc 	_LCNoAdd2
.b449	09 20		ora #$20			ora 	#32 						; adds $20
.b44b					_LCNoAdd2:
.b44b	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b44d					_LCPunctuation:
.b44d	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b44f	d0 03		bne $b454			bne 	_LCPContinue
.b451	20 26 b5	jsr $b526			jsr 	LCLDeleteLastSpace
.b454					_LCPContinue:
.b454	c8		iny				iny 								; consume character
.b455	20 10 b5	jsr $b510			jsr 	LCLWrite 					; write it out.
.b458	80 a7		bra $b401			bra 	_LCMainLoop 				; go round again.
.b45a					_LCIdentifiers:
.b45a	18		clc				clc 								; convert to physical address
.b45b	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b45d	85 37		sta $37				sta 	zTemp0+1
.b45f	c8		iny				iny
.b460	b1 30		lda ($30),y			lda 	(codePtr),y
.b462	85 36		sta $36				sta 	zTemp0
.b464	c8		iny				iny
.b465	5a		phy				phy 								; save position
.b466	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b468	20 10 b5	jsr $b510			jsr 	LCLWrite
.b46b	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b46d					_LCOutIdentifier:
.b46d	c8		iny				iny
.b46e	b1 36		lda ($36),y			lda 	(zTemp0),y
.b470	29 7f		and #$7f			and 	#$7F
.b472	20 62 b5	jsr $b562			jsr 	LCLLowerCase
.b475	20 10 b5	jsr $b510			jsr 	LCLWrite
.b478	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b47a	10 f1		bpl $b46d			bpl 	_LCOutIdentifier
.b47c	7a		ply				ply 								; restore position
.b47d	80 82		bra $b401			bra 	_LCMainLoop
.b47f					_LCTokens:
.b47f	aa		tax				tax 								; token in X
.b480	a9 07		lda #$07			lda 	#((KeywordSet2) & $FF)
.b482	85 36		sta $36				sta 	0+zTemp0
.b484	a9 bc		lda #$bc			lda 	#((KeywordSet2) >> 8)
.b486	85 37		sta $37				sta 	1+zTemp0
.b488	e0 82		cpx #$82			cpx 	#$82
.b48a	f0 16		beq $b4a2			beq 	_LCUseShift
.b48c	a9 b9		lda #$b9			lda 	#((KeywordSet1) & $FF)
.b48e	85 36		sta $36				sta 	0+zTemp0
.b490	a9 bb		lda #$bb			lda 	#((KeywordSet1) >> 8)
.b492	85 37		sta $37				sta 	1+zTemp0
.b494	e0 81		cpx #$81			cpx 	#$81
.b496	f0 0a		beq $b4a2			beq 	_LCUseShift
.b498	a9 c3		lda #$c3			lda 	#((KeywordSet0) & $FF)
.b49a	85 36		sta $36				sta 	0+zTemp0
.b49c	a9 b9		lda #$b9			lda 	#((KeywordSet0) >> 8)
.b49e	85 37		sta $37				sta 	1+zTemp0
.b4a0	80 01		bra $b4a3			bra 	_LCNoShift
.b4a2					_LCUseShift:
.b4a2	c8		iny				iny
.b4a3					_LCNoShift:
.b4a3	20 3a b5	jsr $b53a			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b4a6	b1 30		lda ($30),y			lda 	(codePtr),y
.b4a8	aa		tax				tax 								; into X
.b4a9					_LCFindText:
.b4a9	ca		dex				dex
.b4aa	10 0e		bpl $b4ba			bpl 	_LCFoundText 				; found text.
.b4ac	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b4ae	1a		inc a				inc 	a 							; one extra for size
.b4af	38		sec				sec 								; one extra for checksum
.b4b0	65 36		adc $36				adc 	zTemp0 						; go to next token
.b4b2	85 36		sta $36				sta 	zTemp0
.b4b4	90 f3		bcc $b4a9			bcc 	_LCFindText
.b4b6	e6 37		inc $37				inc 	zTemp0+1
.b4b8	80 ef		bra $b4a9			bra 	_LCFindText
.b4ba					_LCFoundText:
.b4ba	5a		phy				phy 								; save List position
.b4bb	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b4bd	aa		tax				tax
.b4be	a9 83		lda #$83			lda 	#CLIToken+$80
.b4c0	20 10 b5	jsr $b510			jsr 	LCLWrite
.b4c3	a0 02		ldy #$02			ldy 	#2
.b4c5					_LCCopyToken:
.b4c5	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4c7	20 62 b5	jsr $b562			jsr 	LCLLowerCase
.b4ca	20 10 b5	jsr $b510			jsr 	LCLWrite
.b4cd	c8		iny				iny
.b4ce	ca		dex				dex
.b4cf	d0 f4		bne $b4c5			bne 	_LCCopyToken
.b4d1	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b4d3	f0 05		beq $b4da			beq 	_LCNoSpace
.b4d5	a9 20		lda #$20			lda 	#' '
.b4d7	20 10 b5	jsr $b510			jsr 	LCLWrite
.b4da					_LCNoSpace:
.b4da	7a		ply				ply 								; restore position.
.b4db	c8		iny				iny 								; consume token
.b4dc	4c 01 b4	jmp $b401			jmp 	_LCMainLoop 				; and go around again.
.b4df					_LCData:
.b4df	48		pha				pha 								; save type $FE/$FF
.b4e0	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b4e2	c9 fe		cmp #$fe			cmp 	#$FE
.b4e4	f0 07		beq $b4ed			beq 	_LCHaveOpener
.b4e6	a2 22		ldx #$22			ldx 	#'"'
.b4e8	a9 81		lda #$81			lda 	#CLIData+$80
.b4ea	20 10 b5	jsr $b510			jsr 	LCLWrite
.b4ed					_LCHaveOpener:
.b4ed	8a		txa				txa 								; output prefix (# or ")
.b4ee	20 10 b5	jsr $b510			jsr 	LCLWrite
.b4f1	c8		iny				iny 								; get count
.b4f2	b1 30		lda ($30),y			lda 	(codePtr),y
.b4f4	aa		tax				tax
.b4f5	c8		iny				iny 								; point at first character
.b4f6					_LCOutData:
.b4f6	b1 30		lda ($30),y			lda 	(codePtr),y
.b4f8	c9 00		cmp #$00			cmp 	#0
.b4fa	f0 03		beq $b4ff			beq 	_LCNoPrint
.b4fc	20 10 b5	jsr $b510			jsr 	LCLWrite
.b4ff					_LCNoPrint:
.b4ff	c8		iny				iny
.b500	ca		dex				dex
.b501	d0 f3		bne $b4f6			bne 	_LCOutData
.b503	68		pla				pla 								; closing " required ?
.b504	c9 ff		cmp #$ff			cmp 	#$FF
.b506	d0 05		bne $b50d			bne 	_LCNoQuote
.b508	a9 22		lda #$22			lda 	#'"'
.b50a	20 10 b5	jsr $b510			jsr 	LCLWrite
.b50d					_LCNoQuote:
.b50d	4c 01 b4	jmp $b401			jmp 	_LCMainLoop
.b510					LCLWrite:
.b510	da		phx				phx
.b511	ae 9d 04	ldx $049d			ldx 	tbOffset
.b514	9d ab 04	sta $04ab,x			sta 	tokenBuffer,x
.b517	9e ac 04	stz $04ac,x			stz 	tokenBuffer+1,x
.b51a	ee 9d 04	inc $049d			inc 	tbOffset
.b51d	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b51f	30 03		bmi $b524			bmi 	_LCLNoColour
.b521	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b524					_LCLNoColour:
.b524	fa		plx				plx
.b525	60		rts				rts
.b526					LCLDeleteLastSpace:
.b526	48		pha				pha
.b527	da		phx				phx
.b528	ae 9d 04	ldx $049d			ldx 	tbOffset
.b52b	f0 0a		beq $b537			beq 	_LCDLSExit
.b52d	bd aa 04	lda $04aa,x			lda 	tokenBuffer-1,x
.b530	c9 20		cmp #$20			cmp 	#' '
.b532	d0 03		bne $b537			bne 	_LCDLSExit
.b534	ce 9d 04	dec $049d			dec 	tbOffset
.b537					_LCDLSExit:
.b537	fa		plx				plx
.b538	68		pla				pla
.b539	60		rts				rts
.b53a					LCLCheckSpaceRequired:
.b53a	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b53d	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b53f	f0 1b		beq $b55c			beq 	_LCCSRSpace
.b541	c9 29		cmp #$29			cmp 	#')'
.b543	f0 17		beq $b55c			beq 	_LCCSRSpace
.b545	c9 23		cmp #$23			cmp 	#'#'
.b547	f0 13		beq $b55c			beq 	_LCCSRSpace
.b549	20 62 b5	jsr $b562			jsr 	LCLLowerCase 				; saves a little effort
.b54c	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b54e	90 11		bcc $b561			bcc 	_LCCSRExit
.b550	c9 3a		cmp #$3a			cmp 	#"9"+1
.b552	90 08		bcc $b55c			bcc 	_LCCSRSpace
.b554	c9 61		cmp #$61			cmp 	#"a"
.b556	90 09		bcc $b561			bcc 	_LCCSRExit
.b558	c9 7b		cmp #$7b			cmp 	#"z"+1
.b55a	b0 05		bcs $b561			bcs 	_LCCSRExit
.b55c					_LCCSRSpace:
.b55c	a9 20		lda #$20			lda 	#' '
.b55e	20 10 b5	jsr $b510			jsr 	LCLWrite
.b561					_LCCSRExit:
.b561	60		rts				rts
.b562					LCLLowerCase:
.b562	c9 41		cmp #$41			cmp 	#"A"
.b564	90 06		bcc $b56c			bcc 	_LCLLCOut
.b566	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b568	b0 02		bcs $b56c			bcs 	_LCLLCOut
.b56a	69 20		adc #$20			adc 	#$20
.b56c					_LCLLCOut:
.b56c	60		rts				rts
.b56d					LCLUpperCase:
.b56d	c9 61		cmp #$61			cmp 	#"a"
.b56f	90 06		bcc $b577			bcc 	_LCLUCOut
.b571	c9 7b		cmp #$7b			cmp 	#"z"+1
.b573	b0 02		bcs $b577			bcs 	_LCLUCOut
.b575	e9 1f		sbc #$1f			sbc 	#$1F
.b577					_LCLUCOut:
.b577	60		rts				rts
.b578					TOKSearchTable:
.b578	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token.
.b57a	85 36		sta $36				sta 	zTemp0
.b57c	a0 00		ldy #$00			ldy 	#0
.b57e	a9 80		lda #$80			lda 	#$80 						; token #
.b580	85 38		sta $38				sta 	zTemp1
.b582					_TSTLoop:
.b582	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b584	30 49		bmi $b5cf			bmi 	_TSTFail 					; -ve = end of table
.b586	f0 2e		beq $b5b6			beq 	_TSTNext 					; zero, check next it's a dummy
.b588	c8		iny				iny 								; get the hash
.b589	b1 36		lda ($36),y			lda 	(zTemp0),y
.b58b	88		dey				dey
.b58c	cd 83 04	cmp $0483			cmp 	identHash 					; check they match, if not go to next
.b58f	d0 25		bne $b5b6			bne 	_TSTNext
.b591	ad 82 04	lda $0482			lda 	identTypeEnd 				; length of identifier
.b594	38		sec				sec
.b595	ed 80 04	sbc $0480			sbc 	identStart
.b598	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; no match, then return.
.b59a	d0 1a		bne $b5b6			bne 	_TSTNext
.b59c	5a		phy				phy 								; save Y , we might fail
.b59d	c8		iny				iny 								; point to text
.b59e	c8		iny				iny
.b59f	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b5a2					_TSTCompareName:
.b5a2	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; compare text.
.b5a5	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b5a7	d0 0c		bne $b5b5			bne 	_TSTNextPullY 				; fail, pullY and do next
.b5a9	e8		inx				inx
.b5aa	c8		iny				iny
.b5ab	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b5ae	d0 f2		bne $b5a2			bne 	_TSTCompareName
.b5b0	7a		ply				ply 								; throw Y
.b5b1	a5 38		lda $38				lda 	zTemp1 						; get token #
.b5b3	38		sec				sec 								; return with CS = passed.
.b5b4	60		rts				rts
.b5b5					_TSTNextPullY:
.b5b5	7a		ply				ply 								; restore current, fall through.
.b5b6					_TSTNext:
.b5b6	e6 38		inc $38				inc 	zTemp1 						; token counter
.b5b8	98		tya				tya
.b5b9	18		clc				clc
.b5ba	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b5bc	1a		inc a				inc 	a 							; +1
.b5bd	1a		inc a				inc 	a 							; +2
.b5be	a8		tay				tay
.b5bf	10 c1		bpl $b582			bpl 	_TSTLoop 					; if Y < $80 loop back
.b5c1	98		tya				tya 								; add Y to zTemp0 and reset Y
.b5c2	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b5c4	18		clc				clc  								; but have tables > 255 bytes
.b5c5	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b5c7	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b5c9	90 b7		bcc $b582			bcc 	_TSTLoop
.b5cb	e6 37		inc $37				inc 	zTemp0+1
.b5cd	80 b3		bra $b582			bra 	_TSTLoop
.b5cf					_TSTFail:
.b5cf	18		clc				clc
.b5d0	60		rts				rts
.b5d1					TokeniseLine:
.b5d1	20 59 b7	jsr $b759			jsr 	LCLFixLineBufferCase 		; fix line case
.b5d4	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b5d6	8d a8 04	sta $04a8			sta 	tokenOffset
.b5d9	9c a9 04	stz $04a9			stz 	tokenLineNumber
.b5dc	9c aa 04	stz $04aa			stz 	tokenLineNumber+1
.b5df	a2 ff		ldx #$ff			ldx 	#$FF
.b5e1					_TKFindFirst:
.b5e1	e8		inx				inx
.b5e2	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b5e5	f0 79		beq $b660			beq 	_TKExit
.b5e7	c9 20		cmp #$20			cmp 	#' '
.b5e9	90 f6		bcc $b5e1			bcc 	_TKFindFirst
.b5eb	c9 30		cmp #$30			cmp 	#'0'
.b5ed	90 07		bcc $b5f6			bcc 	_TKNoLineNumber
.b5ef	c9 3a		cmp #$3a			cmp 	#'9'+1
.b5f1	b0 03		bcs $b5f6			bcs 	_TKNoLineNumber
.b5f3	20 83 b7	jsr $b783			jsr 	TOKExtractLineNumber
.b5f6					_TKNoLineNumber:
.b5f6					_TKTokeniseLoop:
.b5f6	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b5f9	f0 65		beq $b660			beq 	_TKExit
.b5fb	e8		inx				inx
.b5fc	c9 20		cmp #$20			cmp 	#' '
.b5fe	f0 f6		beq $b5f6			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b600	ca		dex				dex 								; undo last get, A contains character, X is position.
.b601	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b603	f0 61		beq $b666			beq 	_TKTokeniseIdentifier
.b605	c9 41		cmp #$41			cmp 	#'A'
.b607	90 04		bcc $b60d			bcc 	_TKTokenisePunctuation
.b609	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b60b	90 59		bcc $b666			bcc 	_TKTokeniseIdentifier
.b60d					_TKTokenisePunctuation:
.b60d	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b60f	f0 27		beq $b638			beq 	_TKString
.b611	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant (# only appears at end of identifiers)
.b613	f0 28		beq $b63d			beq 	_TKHexConstant
.b615	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers.
.b617	f0 29		beq $b642			beq 	_TKCheckDouble
.b619	c9 3e		cmp #$3e			cmp 	#'>'
.b61b	f0 25		beq $b642			beq 	_TKCheckDouble
.b61d					_TKStandardPunctuation:
.b61d	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get it back.
.b620	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b622	90 0e		bcc $b632			bcc 	_TKNoShift
.b624	48		pha				pha 								; save
.b625	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b627	85 36		sta $36				sta 	zTemp0
.b629	68		pla				pla
.b62a	29 20		and #$20			and 	#32 						; bit 5
.b62c	4a		lsr a				lsr 	a 							; shift into bit 3
.b62d	4a		lsr a				lsr 	a
.b62e	05 36		ora $36				ora 	zTemp0
.b630	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b632					_TKNoShift:
.b632	20 c8 b7	jsr $b7c8			jsr 	TOKWriteByte 				; write the punctuation character
.b635	e8		inx				inx 								; consume the character
.b636	80 be		bra $b5f6			bra 	_TKTokeniseLoop 			; and loop round again.
.b638					_TKString:
.b638	20 e8 b6	jsr $b6e8			jsr 	TOKTokenString
.b63b	80 b9		bra $b5f6			bra 	_TKTokeniseLoop
.b63d					_TKHexConstant:
.b63d	20 23 b7	jsr $b723			jsr 	TOKHexConstant
.b640	80 b4		bra $b5f6			bra 	_TKTokeniseLoop
.b642					_TKCheckDouble:
.b642	bd a9 05	lda $05a9,x			lda 	lineBuffer+1,x 				; get next character
.b645	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b647	90 d4		bcc $b61d			bcc 	_TKStandardPunctuation
.b649	c9 3f		cmp #$3f			cmp 	#'>'+1
.b64b	b0 d0		bcs $b61d			bcs 	_TKStandardPunctuation
.b64d	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b650	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b652	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b653	7d a9 05	adc $05a9,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b656	38		sec				sec
.b657	e9 3c		sbc #$3c			sbc 	#'<'
.b659	20 c8 b7	jsr $b7c8			jsr 	TOKWriteByte 				; this is in the range 0-7
.b65c	e8		inx				inx 								; consume both
.b65d	e8		inx				inx
.b65e	80 96		bra $b5f6			bra 	_TKTokeniseLoop
.b660	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b662	20 c8 b7	jsr $b7c8			jsr 	TOKWriteByte
.b665	60		rts				rts
.b666					_TKTokeniseIdentifier:
.b666	8e 80 04	stx $0480			stx 	identStart 					; save start
.b669	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b66c					_TKCheckLoop:
.b66c	e8		inx				inx 								; look at next, we know first is identifier.
.b66d	bd a8 05	lda $05a8,x			lda  	lineBuffer,x
.b670	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b672	f0 f8		beq $b66c			beq 	_TKCheckLoop
.b674	c9 30		cmp #$30			cmp	 	#"0"
.b676	90 0c		bcc $b684			bcc 	_TKEndIdentifier
.b678	c9 3a		cmp #$3a			cmp 	#"9"+1
.b67a	90 f0		bcc $b66c			bcc 	_TKCheckLoop
.b67c	c9 41		cmp #$41			cmp	 	#"A"
.b67e	90 04		bcc $b684			bcc 	_TKEndIdentifier
.b680	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b682	90 e8		bcc $b66c			bcc 	_TKCheckLoop
.b684					_TKEndIdentifier:
.b684	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b687	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b689	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b68b	f0 06		beq $b693			beq 	_TKHasTypeCharacter
.b68d	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b68f	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b691	d0 07		bne $b69a			bne 	_TKNoTypeCharacter
.b693					_TKHasTypeCharacter:
.b693	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b696	e8		inx				inx 								; read next
.b697	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b69a					_TKNoTypeCharacter:
.b69a	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b69c	d0 09		bne $b6a7			bne 	_TKNoArray
.b69e	e8		inx				inx 								; skip the (
.b69f	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array)
.b6a2	09 04		ora #$04			ora 	#$04
.b6a4	8d 84 04	sta $0484			sta 	identTypeByte
.b6a7					_TKNoArray:
.b6a7	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b6aa	20 44 b7	jsr $b744			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b6ad	a0 b9		ldy #$b9			ldy 	#(KeywordSet0) >> 8
.b6af	a9 c3		lda #$c3			lda 	#(KeywordSet0) & $FF
.b6b1	20 78 b5	jsr $b578			jsr 	TOKSearchTable
.b6b4	a2 00		ldx #$00			ldx 	#0
.b6b6	b0 1f		bcs $b6d7			bcs 	_TKFoundToken
.b6b8	a0 bb		ldy #$bb			ldy 	#(KeywordSet1) >> 8
.b6ba	a9 b9		lda #$b9			lda 	#(KeywordSet1) & $FF
.b6bc	20 78 b5	jsr $b578			jsr 	TOKSearchTable
.b6bf	a2 81		ldx #$81			ldx 	#$81
.b6c1	b0 14		bcs $b6d7			bcs 	_TKFoundToken
.b6c3	a0 bc		ldy #$bc			ldy 	#(KeywordSet2) >> 8
.b6c5	a9 07		lda #$07			lda 	#(KeywordSet2) & $FF
.b6c7	20 78 b5	jsr $b578			jsr 	TOKSearchTable
.b6ca	a2 82		ldx #$82			ldx 	#$82
.b6cc	b0 09		bcs $b6d7			bcs 	_TKFoundToken
.b6ce	20 d4 b7	jsr $b7d4			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b6d1	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6d4	4c f6 b5	jmp $b5f6			jmp 	_TKTokeniseLoop 			; and go round again.
.b6d7					_TKFoundToken:
.b6d7	48		pha				pha 								; save token
.b6d8	8a		txa				txa 								; shift in X, is there one ?
.b6d9	f0 03		beq $b6de			beq 	_TKNoTShift
.b6db	20 c8 b7	jsr $b7c8			jsr 	TOKWriteByte 				; if so, write it out
.b6de					_TKNoTShift:
.b6de	68		pla				pla 								; restore and write token
.b6df	20 c8 b7	jsr $b7c8			jsr 	TOKWriteByte
.b6e2	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b6e5	4c f6 b5	jmp $b5f6			jmp 	_TKTokeniseLoop 			; and go round again.
.b6e8					TOKTokenString:
.b6e8	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b6ea	20 c8 b7	jsr $b7c8			jsr 	TOKWriteByte
.b6ed	e8		inx				inx									; start of quoted string.
.b6ee	da		phx				phx 								; push start of string on top
.b6ef	ca		dex				dex
.b6f0					_TSFindEnd:
.b6f0	e8		inx				inx
.b6f1	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; next character
.b6f4	f0 04		beq $b6fa			beq 	_TSEndOfString
.b6f6	c9 22		cmp #$22			cmp 	#'"'
.b6f8	d0 f6		bne $b6f0			bne 	_TSFindEnd
.b6fa					_TSEndOfString:
.b6fa	7a		ply				ply  								; so now Y is first character, X is character after end.
.b6fb	48		pha				pha 								; save terminating character
.b6fc	20 04 b7	jsr $b704			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b6ff	68		pla				pla 								; terminating character
.b700	f0 01		beq $b703			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b702	e8		inx				inx
.b703					_TSNotQuote:
.b703	60		rts				rts
.b704					TOKWriteBlockXY:
.b704	86 36		stx $36				stx 	zTemp0 						; write end character
.b706	98		tya				tya
.b707	49 ff		eor #$ff			eor 	#$FF
.b709	38		sec				sec
.b70a	65 36		adc $36				adc 	zTemp0
.b70c	1a		inc a				inc 	a 							; one extra for NULL
.b70d	20 c8 b7	jsr $b7c8			jsr 	TOKWriteByte
.b710					_TOBlockLoop:
.b710	c4 36		cpy $36				cpy 	zTemp0
.b712	f0 09		beq $b71d			beq 	_TOBlockExit
.b714	b9 a8 05	lda $05a8,y			lda 	lineBuffer,y
.b717	20 c8 b7	jsr $b7c8			jsr 	TOKWriteByte
.b71a	c8		iny				iny
.b71b	80 f3		bra $b710			bra 	_TOBlockLoop
.b71d					_TOBlockExit:
.b71d	a9 00		lda #$00			lda 	#0
.b71f	20 c8 b7	jsr $b7c8			jsr 	TOKWriteByte
.b722	60		rts				rts
.b723					TOKHexConstant:
.b723	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b725	20 c8 b7	jsr $b7c8			jsr 	TOKWriteByte
.b728	e8		inx				inx									; start of quoted string.
.b729	da		phx				phx 								; push start of constant on top
.b72a	ca		dex				dex
.b72b					_THFindLoop:
.b72b	e8		inx				inx
.b72c	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b72f	c9 30		cmp #$30			cmp 	#"0"
.b731	90 0c		bcc $b73f			bcc 	_THFoundEnd
.b733	c9 3a		cmp #$3a			cmp 	#"9"+1
.b735	90 f4		bcc $b72b			bcc 	_THFindLoop
.b737	c9 41		cmp #$41			cmp 	#"A"
.b739	90 04		bcc $b73f			bcc 	_THFoundEnd
.b73b	c9 47		cmp #$47			cmp 	#"F"+1
.b73d	90 ec		bcc $b72b			bcc 	_THFindLoop
.b73f					_THFoundEnd:
.b73f	7a		ply				ply 								; restore start
.b740	20 04 b7	jsr $b704			jsr 	TOKWriteBlockXY 			; output the block
.b743	60		rts				rts
.b744					TOKCalculateHash:
.b744	da		phx				phx
.b745	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum
.b748	a9 00		lda #$00			lda 	#0
.b74a					_TCHLoop:
.b74a	18		clc				clc
.b74b	7d a8 05	adc $05a8,x			adc 	lineBuffer,x
.b74e	e8		inx				inx
.b74f	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b752	d0 f6		bne $b74a			bne 	_TCHLoop
.b754	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b757	fa		plx				plx
.b758	60		rts				rts
.b759					LCLFixLineBufferCase:
.b759	a2 00		ldx #$00			ldx 	#0
.b75b					_FLBCLoop:
.b75b	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next character
.b75e	f0 22		beq $b782			beq 	_FLBCExit 					; end of string.
.b760	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b762	f0 11		beq $b775			beq 	_FLBCInQuotes
.b764	e8		inx				inx
.b765	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b767	90 f2		bcc $b75b			bcc 	_FLBCLoop
.b769	c9 7b		cmp #$7b			cmp 	#'z'+1
.b76b	b0 ee		bcs $b75b			bcs 	_FLBCLoop
.b76d	38		sec				sec 								; make U/C
.b76e	e9 20		sbc #$20			sbc 	#32
.b770	9d a7 05	sta $05a7,x			sta	 	lineBuffer-1,x 				; write back
.b773	80 e6		bra $b75b			bra 	_FLBCLoop
.b775					_FLBCInQuotes:
.b775	e8		inx				inx 								; advance
.b776	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get next
.b779	f0 07		beq $b782			beq 	_FLBCExit 					; exit on EOS
.b77b	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b77d	d0 f6		bne $b775			bne 	_FLBCInQuotes
.b77f	e8		inx				inx 								; skip over it
.b780	80 d9		bra $b75b			bra 	_FLBCLoop
.b782					_FLBCExit:
.b782	60		rts				rts
.b783					TOKExtractLineNumber:
.b783	ad aa 04	lda $04aa			lda 	tokenLineNumber+1 			; push current value on stack
.b786	48		pha				pha
.b787	ad a9 04	lda $04a9			lda 	tokenLineNumber
.b78a	48		pha				pha
.b78b	20 c1 b7	jsr $b7c1			jsr 	_LCLNTimes2 				; line # x 4
.b78e	20 c1 b7	jsr $b7c1			jsr 	_LCLNTimes2 				; line # x 2
.b791	18		clc				clc 								; add stacked value
.b792	68		pla				pla
.b793	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b796	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b799	68		pla				pla
.b79a	6d aa 04	adc $04aa			adc 	tokenLineNumber+1
.b79d	8d aa 04	sta $04aa			sta 	tokenLineNumber+1 			; line # x 5
.b7a0	20 c1 b7	jsr $b7c1			jsr 	_LCLNTimes2 				; line # x 10
.b7a3	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; get and consume character
.b7a6	e8		inx				inx
.b7a7	29 0f		and #$0f			and 	#15 						; add to line #
.b7a9	18		clc				clc
.b7aa	6d a9 04	adc $04a9			adc 	tokenLineNumber
.b7ad	8d a9 04	sta $04a9			sta 	tokenLineNumber
.b7b0	90 03		bcc $b7b5			bcc 	_TLENNoCarry
.b7b2	ee aa 04	inc $04aa			inc 	tokenLineNumber+1
.b7b5					_TLENNoCarry:
.b7b5	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; more digits ?
.b7b8	c9 30		cmp #$30			cmp 	#'0'
.b7ba	90 04		bcc $b7c0			bcc 	_TLENExit
.b7bc	c9 3a		cmp #$3a			cmp 	#'9'+1
.b7be	90 c3		bcc $b783			bcc 	TOKExtractLineNumber
.b7c0					_TLENExit:
.b7c0	60		rts				rts
.b7c1					_LCLNTimes2:
.b7c1	0e a9 04	asl $04a9			asl 	tokenLineNumber
.b7c4	2e aa 04	rol $04aa			rol 	tokenLineNumber+1
.b7c7	60		rts				rts
.b7c8					TOKWriteByte:
.b7c8	da		phx				phx
.b7c9	ae a8 04	ldx $04a8			ldx 	tokenOffset 				; next slot to write to
.b7cc	9d a8 04	sta $04a8,x			sta 	tokenOffset,x 				; write byte out
.b7cf	ee a8 04	inc $04a8			inc 	tokenOffset 				; advance slot.
.b7d2	fa		plx				plx
.b7d3	60		rts				rts
.b7d4					TOKCheckCreateVariableRecord:
.b7d4	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b7d6	85 36		sta $36				sta 	0+zTemp0
.b7d8	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b7da	85 37		sta $37				sta 	1+zTemp0
.b7dc					_CCVSearch:
.b7dc	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b7de	f0 2c		beq $b80c			beq 	_CCVFail
.b7e0	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b7e2	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b7e4	cd 83 04	cmp $0483			cmp 	identHash
.b7e7	d0 16		bne $b7ff			bne 	_CCVNext
.b7e9	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b7eb	ae 80 04	ldx $0480			ldx 	identStart
.b7ee					_CCVCompare:
.b7ee	bd a8 05	lda $05a8,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b7f1	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b7f3	e8		inx				inx 								; advance pointers
.b7f4	c8		iny				iny
.b7f5	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b7f6	d0 07		bne $b7ff			bne 	_CCVNext  					; didn't match go to next.
.b7f8	90 f4		bcc $b7ee			bcc 	_CCVCompare 				; not finished yet.
.b7fa	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b7fd	f0 41		beq $b840			beq 	_CCVFound 					; yes, we were successful
.b7ff					_CCVNext:
.b7ff	18		clc				clc
.b800	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b802	65 36		adc $36				adc 	zTemp0
.b804	85 36		sta $36				sta 	zTemp0
.b806	90 d4		bcc $b7dc			bcc 	_CCVSearch
.b808	e6 37		inc $37				inc 	zTemp0+1
.b80a	80 d0		bra $b7dc			bra 	_CCVSearch
.b80c					_CCVFail:
.b80c	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b80e	ad 83 04	lda $0483			lda 	identHash
.b811	91 36		sta ($36),y			sta 	(zTemp0),y
.b813	c8		iny				iny 								; offset 2 is the type byte
.b814	ad 84 04	lda $0484			lda 	identTypeByte
.b817	91 36		sta ($36),y			sta 	(zTemp0),y
.b819	c8		iny				iny
.b81a					_CCVData:
.b81a	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b81c	91 36		sta ($36),y			sta 	(zTemp0),y
.b81e	c8		iny				iny
.b81f	c0 08		cpy #$08			cpy 	#8
.b821	90 f7		bcc $b81a			bcc 	_CCVData
.b823	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b826					_CCVCopyName:
.b826	bd a8 05	lda $05a8,x			lda 	lineBuffer,x
.b829	91 36		sta ($36),y			sta 	(zTemp0),y
.b82b	e8		inx				inx
.b82c	c8		iny				iny
.b82d	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b830	d0 f4		bne $b826			bne 	_CCVCopyName
.b832	98		tya				tya 								; patch offset
.b833	92 36		sta ($36)			sta 	(zTemp0)
.b835	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b837	91 36		sta ($36),y			sta 	(zTemp0),y
.b839	88		dey				dey
.b83a	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b83c	09 80		ora #$80			ora 	#$80
.b83e	91 36		sta ($36),y			sta 	(zTemp0),y
.b840					_CCVFound:
.b840	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b842	38		sec				sec
.b843	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b845	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b847	20 c8 b7	jsr $b7c8			jsr 	TOKWriteByte
.b84a	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b84c	20 c8 b7	jsr $b7c8			jsr 	TOKWriteByte
.b84f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b850					SNDCheckChannel:
.b850	aa		tax				tax
.b851	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b854	d0 38		bne $b88e			bne 	_SNDCCExit
.b856	da		phx				phx 								; save current channel
.b857	8a		txa				txa 								; put in A
.b858	20 d4 b8	jsr $b8d4			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b85b	68		pla				pla 								; channel # in A
.b85c	90 30		bcc $b88e			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b85e	a8		tay				tay 								; Y is the channel #
.b85f	bd fe 06	lda $06fe,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b862	99 fd 07	sta $07fd,y			sta 	SNDPitchLow,y
.b865	bd ff 06	lda $06ff,x			lda 	SNDQueue+2,x
.b868	99 01 08	sta $0801,y			sta 	SNDPitchHigh,y
.b86b	bd 00 07	lda $0700,x			lda 	SNDQueue+3,x
.b86e	99 05 08	sta $0805,y			sta 	SNDVolume,y
.b871	bd 01 07	lda $0701,x			lda 	SNDQueue+4,x
.b874	99 09 08	sta $0809,y			sta 	SNDTimeLeft,y
.b877	bd 02 07	lda $0702,x			lda 	SNDQueue+5,x
.b87a	99 0d 08	sta $080d,y			sta 	SNDAdjustLow,y
.b87d	bd 03 07	lda $0703,x			lda 	SNDQueue+6,x
.b880	99 11 08	sta $0811,y			sta 	SNDAdjustHigh,y
.b883	5a		phy				phy 								; save channel #
.b884	20 ee b8	jsr $b8ee			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b887	ce fc 06	dec $06fc			dec 	SNDLength 					; reduce the queue length.
.b88a	68		pla				pla
.b88b	20 8f b8	jsr $b88f			jsr 	SNDUpdateNote 				; update channel A
.b88e					_SNDCCExit:
.b88e	60		rts				rts
.b88f					SNDUpdateNote:
.b88f	aa		tax				tax 								; so we can access records
.b890	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b891	0a		asl a				asl 	a
.b892	0a		asl a				asl 	a
.b893	0a		asl a				asl 	a
.b894	0a		asl a				asl 	a
.b895	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b898	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; are we silent
.b89b	f0 2e		beq $b8cb			beq 	_SNDUNIsSilent
.b89d	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; push channel bits on stack
.b8a0	48		pha				pha
.b8a1	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b8a4	29 0f		and #$0f			and 	#$0F
.b8a6	0d fb 06	ora $06fb			ora 	SNDChannelBits 				; set channel bits
.b8a9	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b8ab	20 38 b9	jsr $b938			jsr 	SNDWritePorts
.b8ae	bd 01 08	lda $0801,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b8b1	8d fb 06	sta $06fb			sta 	SNDChannelBits
.b8b4	bd fd 07	lda $07fd,x			lda 	SNDPitchLow,x
.b8b7	4e fb 06	lsr $06fb			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b8ba	6a		ror a				ror 	a
.b8bb	4e fb 06	lsr $06fb			lsr 	SNDChannelBits
.b8be	6a		ror a				ror 	a
.b8bf	4a		lsr a				lsr 	a 							; put in bits 0-5
.b8c0	4a		lsr a				lsr 	a
.b8c1	20 38 b9	jsr $b938			jsr 	SNDWritePorts 				; write as rest of pitch register
.b8c4	68		pla				pla
.b8c5	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b8c7	20 38 b9	jsr $b938			jsr 	SNDWritePorts
.b8ca	60		rts				rts
.b8cb					_SNDUNIsSilent:
.b8cb	ad fb 06	lda $06fb			lda 	SNDChannelBits 				; channel bits
.b8ce	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b8d0	20 38 b9	jsr $b938			jsr 	SNDWritePorts 				; write to the ports
.b8d3	60		rts				rts
.b8d4					SNDFindNextNoteForA:
.b8d4	ac fc 06	ldy $06fc			ldy 	SNDLength 					; queue size into Y
.b8d7	f0 13		beq $b8ec			beq 	_SNDFNNFail 				; queue empty.
.b8d9	a2 00		ldx #$00			ldx 	#0
.b8db					_SNDFNNSearch:
.b8db	dd fd 06	cmp $06fd,x			cmp 	SNDQueue,x 					; does it match the channel
.b8de	38		sec				sec
.b8df	f0 0c		beq $b8ed			beq 	_SNDFNNExit 				; if so exit with CS.
.b8e1	e8		inx				inx 								; next queue slot.
.b8e2	e8		inx				inx
.b8e3	e8		inx				inx
.b8e4	e8		inx				inx
.b8e5	e8		inx				inx
.b8e6	e8		inx				inx
.b8e7	e8		inx				inx
.b8e8	e8		inx				inx
.b8e9	88		dey				dey 								; done the whole queue
.b8ea	d0 ef		bne $b8db			bne 	_SNDFNNSearch 				; no, go back.
.b8ec					_SNDFNNFail:
.b8ec	18		clc				clc
.b8ed					_SNDFNNexit:
.b8ed	60		rts				rts
.b8ee					SNDDeleteXFromQueue:
.b8ee	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b8f0	f0 09		beq $b8fb			beq 	_SNDDXExit
.b8f2	bd 05 07	lda $0705,x			lda 	SNDQueue+8,x
.b8f5	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b8f8	e8		inx				inx
.b8f9	80 f3		bra $b8ee			bra 	SNDDeleteXFromQueue
.b8fb					_SNDDXExit:
.b8fb	60		rts				rts
.06fb					SNDChannelBits:
>06fb							.fill 	1
.b8fc					SNDQueueRequest:
.b8fc	86 36		stx $36				stx 	zTemp0						; save queue address
.b8fe	84 37		sty $37				sty 	zTemp0+1
.b900	ae fc 06	ldx $06fc			ldx 	SNDLength 					; queue is full, can't take any more.
.b903	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b905	f0 21		beq $b928			beq 	_SNDQRExit
.b907	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b909	48		pha				pha
.b90a	8a		txa				txa  								; get offset in queue buffer/
.b90b	0a		asl a				asl 	a
.b90c	0a		asl a				asl 	a
.b90d	0a		asl a				asl 	a
.b90e	aa		tax				tax
.b90f	68		pla				pla 								; get back and push again
.b910	48		pha				pha
.b911	9d fd 06	sta $06fd,x			sta 	SNDQueue+0,x 				; save the channel #
.b914	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b916					_SNDQCopy:
.b916	b1 36		lda ($36),y			lda 	(zTemp0),y
.b918	e8		inx				inx
.b919	c8		iny				iny
.b91a	9d fd 06	sta $06fd,x			sta 	SNDQueue,x
.b91d	c0 06		cpy #$06			cpy 	#6
.b91f	d0 f5		bne $b916			bne 	_SNDQCopy
.b921	ee fc 06	inc $06fc			inc 	SNDLength 					; bump queue length.
.b924	68		pla				pla 								; get channel # back
.b925	20 50 b8	jsr $b850			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b928					_SNDQRExit:
.b928	60		rts				rts
.b929					SNDSilenceChannel:
.b929	aa		tax				tax 								; zero time left.
.b92a	9e 09 08	stz $0809,x			stz 	SNDTimeLeft,x
.b92d	0a		asl a				asl 	a 							; shift into position
.b92e	0a		asl a				asl 	a
.b92f	0a		asl a				asl 	a
.b930	0a		asl a				asl 	a
.b931	0a		asl a				asl 	a
.b932	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.b934	20 38 b9	jsr $b938			jsr 	SNDWritePorts
.b937	60		rts				rts
.b938					SNDWritePorts:
.b938	64 01		stz $01				stz 	1
.b93a	8d 00 d6	sta $d600			sta 	$D600
.b93d	8d 10 d6	sta $d610			sta 	$D610
.b940	60		rts				rts
.b941					SNDCommand:
.b941	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.b943	f0 1c		beq $b961			beq 	_SNDInitialise
.b945	90 27		bcc $b96e			bcc 	_SNDExit
.b947	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.b949	f0 16		beq $b961			beq 	_SNDSilence
.b94b	b0 21		bcs $b96e			bcs 	_SNDExit
.b94d	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.b94f	b0 09		bcs $b95a			bcs 	_SNDQueryPlay
.b951	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.b953	b0 19		bcs $b96e			bcs 	_SNDExit
.b955	20 fc b8	jsr $b8fc			jsr 	SNDQueueRequest
.b958	80 14		bra $b96e			bra 	_SNDExit
.b95a					_SNDQueryPlay:
.b95a	29 03		and #$03			and 	#3 							; get channel #
.b95c	bd 09 08	lda $0809,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.b95f	80 0d		bra $b96e			bra 	_SNDExit
.b961					_SNDInitialise:
.b961					_SNDSilence:
.b961	9c fc 06	stz $06fc			stz 	SNDLength 					; empty the queue.
.b964	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.b966					_SNDSilenceLoop:
.b966	48		pha				pha
.b967	20 29 b9	jsr $b929			jsr 	SNDSilenceChannel
.b96a	68		pla				pla
.b96b	3a		dec a				dec 	a
.b96c	10 f8		bpl $b966			bpl 	_SNDSilenceLoop
.b96e					_SNDExit:
.b96e	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fc					SNDLength:
>06fc							.fill 	1
.06fd					SNDQueue:
>06fd							.fill 	SNDQueueSize * 8
.07fd					SNDPitchLow:
>07fd							.fill 	4
.0801					SNDPitchHigh:
>0801							.fill 	4
.0805					SNDVolume:
>0805							.fill 	4
.0809					SNDTimeLeft:
>0809							.fill 	4
.080d					SNDAdjustLow:
>080d							.fill 	4
.0811					SNDAdjustHigh:
>0811							.fill 	4

;******  Return to file: _basic.asm


;******  End of listing
