
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Mon Nov 28 20:56:01 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	MaxLineSize+1
.057b					numberBuffer:
>057b							.fill 	34
.059d					decimalBuffer:
>059d							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c 0b a7	jmp $a70b		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c a4 a9	jmp $a9a4		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c da a9	jmp $a9da		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c fa a9	jmp $a9fa		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c fd a9	jmp $a9fd		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c ba a8	jmp $a8ba		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c 98 aa	jmp $aa98		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 4d bd	jmp $bd4d		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c 80 bd	jmp $bd80		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 43 b7	jmp $b743		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c d7 b9	jmp $b9d7		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.802a	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.802c	aa		tax				tax
.802d	a8		tay				tay
.802e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.8031	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8033	20 18 80	jsr $8018			jsr 	SNDCommand
.8036	20 6f 89	jsr $896f			jsr 	NewProgram 					; erase current program
.8039	20 ae 82	jsr $82ae			jsr 	BackloadProgram
.803c	4c ab 8a	jmp $8aab			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.803f					AssembleGroup1:
.803f	a9 ff		lda #$ff			lda 	#$FF
.8041	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8044	80 02		bra $8048			bra 	AsmGroup12
.8046					AssembleGroup2:
.8046	a9 00		lda #$00			lda 	#$00
.8048					AsmGroup12:
.8048	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.804b	68		pla				pla 								; pop the return address to access the information following.
.804c	fa		plx				plx
.804d	20 d4 80	jsr $80d4			jsr 	AccessParameters 			; get opcode and save as base
.8050	8d 24 04	sta $0424			sta 	BaseOpcode
.8053	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8056	d0 08		bne $8060			bne 	_AG12HaveMask
.8058	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.805a	20 dc 80	jsr $80dc			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.805d	8d 25 04	sta $0425			sta 	ModeMask
.8060					_AG12HaveMask:
.8060	20 10 82	jsr $8210			jsr 	TypeAndCalculateOperand 	; get zero page type
.8063	da		phx				phx 								; save found address mode
.8064	20 40 81	jsr $8140			jsr 	AssembleModeX
.8067	fa		plx				plx  								; restore address mode
.8068	b0 0b		bcs $8075			bcs 	_AG12Exit
.806a	20 76 80	jsr $8076			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.806d	20 40 81	jsr $8140			jsr 	AssembleModeX
.8070	b0 03		bcs $8075			bcs 	_AG12Exit
.8072	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8075					_AG12Exit:
.8075	60		rts				rts
.8076					PromoteToAbsolute:
.8076	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.8078	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.807a	f0 19		beq $8095			beq 	_PTADo
.807c	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.807e	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.8080	f0 13		beq $8095			beq 	_PTADo
.8082	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.8084	e0 80		cpx #$80			cpx 	#AM_ZEROY
.8086	f0 0d		beq $8095			beq 	_PTADo
.8088	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.808a	e0 d1		cpx #$d1			cpx 	#AM_IND
.808c	f0 07		beq $8095			beq 	_PTADo
.808e	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.8090	e0 c0		cpx #$c0			cpx 	#AM_INDX
.8092	f0 01		beq $8095			beq 	_PTADo
.8094	60		rts				rts
.8095					_PTADo:
.8095	aa		tax				tax
.8096	60		rts				rts
.8097					AssembleGroup3:
.8097	68		pla				pla 								; get parameters, which is just the opcode.
.8098	fa		plx				plx
.8099	20 d4 80	jsr $80d4			jsr 	AccessParameters 			; get and output opcode
.809c	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte
.809f	20 74 82	jsr $8274			jsr 	CalculateOperand 			; get a 16 bit operand
.80a2	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80a4	38		sec				sec
.80a5	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80a8	48		pha				pha 								; LSB in A
.80a9	a5 60		lda $60				lda 	NSMantissa1
.80ab	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80ae	aa		tax				tax 								; MSB in X
.80af	68		pla				pla
.80b0	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80b1	69 7f		adc #$7f			adc 	#$7F
.80b3	90 01		bcc $80b6			bcc 	_AG3NoCarry
.80b5	e8		inx				inx
.80b6					_AG3NoCarry:
.80b6	38		sec				sec 								; fix back and write out anyways.
.80b7	e9 80		sbc #$80			sbc 	#$80
.80b9	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte
.80bc	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80be	f0 0a		beq $80ca			beq 	_AG3Exit
.80c0	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.80c3	29 01		and #$01			and 	#1
.80c5	f0 03		beq $80ca			beq 	_AG3Exit
.80c7	4c 14 9f	jmp $9f14			jmp 	RangeError 					; no, branch is out of range
.80ca					_AG3Exit:
.80ca	60		rts				rts
.80cb					AssembleGroup4:
.80cb	68		pla				pla 								; pop address
.80cc	fa		plx				plx
.80cd	20 d4 80	jsr $80d4			jsr 	AccessParameters 			; access and get first
.80d0	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte 			; output it.
.80d3	60		rts				rts
.80d4					AccessParameters:
.80d4	8d 21 04	sta $0421			sta 	ParamStart
.80d7	8e 22 04	stx $0422			stx 	ParamStart+1
.80da	a9 01		lda #$01			lda 	#1
.80dc					GetParameter:
.80dc	5a		phy				phy
.80dd	a8		tay				tay
.80de	ad 21 04	lda $0421			lda 	ParamStart
.80e1	85 36		sta $36				sta 	zTemp0
.80e3	ad 22 04	lda $0422			lda 	ParamStart+1
.80e6	85 37		sta $37				sta 	zTemp0+1
.80e8	b1 36		lda ($36),y			lda 	(zTemp0),y
.80ea	7a		ply				ply
.80eb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.80ec					AssemblerWriteByte:
.80ec	48		pha			pha
.80ed	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.80f0	29 02		and #$02		and 	#2
.80f2	f0 1b		beq $810f		beq 	_AWBNoPrint
.80f4	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.80f7	20 2a 81	jsr $812a		jsr 	PrintHex
.80fa	ad 1e 04	lda $041e		lda		AssemblerAddress
.80fd	20 2a 81	jsr $812a		jsr 	PrintHex
.8100	a9 20		lda #$20		lda 	#' '
.8102	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8105	68		pla			pla 									; print byte
.8106	48		pha			pha
.8107	20 2a 81	jsr $812a		jsr 	PrintHex
.810a	a9 0d		lda #$0d		lda 	#13
.810c	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.810f					_AWBNoPrint:
.810f	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8112	85 36		sta $36			sta 	zTemp0
.8114	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.8117	f0 0e		beq $8127		beq 	_AWBRange
.8119	85 37		sta $37			sta 	zTemp0+1
.811b	68		pla			pla 									; write byte out
.811c	92 36		sta ($36)		sta 	(zTemp0)
.811e	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8121	d0 03		bne $8126		bne 	_AWBNoCarry
.8123	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.8126					_AWBNoCarry:
.8126	60		rts			rts
.8127					_AWBRange:
.8127	4c 14 9f	jmp $9f14		jmp 	RangeError
.812a					PrintHex:
.812a	48		pha				pha
.812b	4a		lsr a				lsr 	a
.812c	4a		lsr a				lsr 	a
.812d	4a		lsr a				lsr 	a
.812e	4a		lsr a				lsr 	a
.812f	20 33 81	jsr $8133			jsr 	_PrintNibble
.8132	68		pla				pla
.8133					_PrintNibble:
.8133	29 0f		and #$0f			and 	#15
.8135	c9 0a		cmp #$0a			cmp 	#10
.8137	90 02		bcc $813b			bcc 	_NoShift
.8139	69 06		adc #$06			adc 	#6
.813b					_NoShift:
.813b	69 30		adc #$30			adc 	#48
.813d	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8140					AssembleModeX:
.8140	5a		phy				phy
.8141	ad 23 04	lda $0423			lda 	IsGroup1
.8144	f0 17		beq $815d			beq 	_AMXGroup2
.8146	8a		txa				txa 							; is it in group # 1
.8147	29 40		and #$40			and 	#AM_ISG1
.8149	f0 4d		beq $8198			beq 	_AMXFail 				; no, give up.
.814b	8a		txa				txa 							; get back.
.814c	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.814e	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8150	d0 22		bne $8174			bne 	_AMXHaveInfo
.8152	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8155	c9 81		cmp #$81			cmp 	#$81
.8157	f0 3f		beq $8198			beq 	_AMXFail
.8159	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.815b	80 17		bra $8174			bra 	_AMXHaveInfo 			; odd design decision there.
.815d					_AMXGroup2:
.815d	8a		txa				txa 							; is it in group 2 ?
.815e	29 20		and #$20			and 	#AM_ISG2
.8160	f0 36		beq $8198			beq 	_AMXFail 				; no, give up.
.8162	8a		txa				txa 							; get the offset into Y
.8163	29 1f		and #$1f			and 	#$1F
.8165	4a		lsr a				lsr 	a 						; make it 0-7.
.8166	4a		lsr a				lsr  	a
.8167	a8		tay				tay
.8168	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.816b					_AMXCheckOkay:
.816b	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.816c	88		dey				dey
.816d	10 fc		bpl $816b			bpl 	_AMXCheckOkay
.816f	90 27		bcc $8198			bcc 	_AMXFail 				; not allowed.
.8171	8a		txa				txa  							; get mask back
.8172	29 1f		and #$1f			and 	#$1F
.8174					_AMXHaveInfo:
.8174	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.8176	10 04		bpl $817c			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.8178	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.817a	d0 1c		bne $8198			bne 	_AMXFail
.817c					_AMXAnySize:
.817c	18		clc				clc 							; add offset to the base opcode
.817d	6d 24 04	adc $0424			adc 	BaseOpcode
.8180					_AMXOutputCode:
.8180	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte 		; write the opcode out.
.8183	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.8185	f0 0e		beq $8195			beq 	_AMXExit
.8187	a5 58		lda $58				lda 	NSMantissa0 				; write LSB operand
.8189	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte
.818c	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.818e	30 05		bmi $8195			bmi 	_AMXExit
.8190	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.8192	20 ec 80	jsr $80ec			jsr 	AssemblerWriteByte
.8195					_AMXExit:
.8195	7a		ply				ply
.8196	38		sec				sec
.8197	60		rts				rts
.8198					_AMXFail:
.8198	a0 00		ldy #$00			ldy 	#0
.819a					_AMXCheckOddities:
.819a	8a		txa				txa
.819b	d9 c2 81	cmp $81c2,y			cmp 	ExtraOpcode+2,y 		; match address mode
.819e	d0 15		bne $81b5			bne 	_AMXCONext
.81a0	b9 c0 81	lda $81c0,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81a3	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81a6	d0 0d		bne $81b5			bne 	_AMXCONext
.81a8	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81aa	10 04		bpl $81b0			bpl 	_AMXCONotZero
.81ac	a5 60		lda $60				lda 	NSMantissa1
.81ae	d0 05		bne $81b5			bne 	_AMXCONext
.81b0					_AMXCONotZero:
.81b0	b9 c1 81	lda $81c1,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81b3	80 cb		bra $8180			bra 	_AMXOutputCode 			; and assemble it
.81b5					_AMXCONext:
.81b5	c8		iny				iny
.81b6	c8		iny				iny
.81b7	c8		iny				iny
.81b8	b9 c0 81	lda $81c0,y			lda 	ExtraOpcode+0,y 		; end of table
.81bb	d0 dd		bne $819a			bne 	_AMXCheckOddities
.81bd					_AMXCOFail:
.81bd	7a		ply				ply
.81be	18		clc				clc
.81bf	60		rts				rts
.81c0					ExtraOpcode:
>81c0	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>81c3	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>81c6	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81c9	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>81cc	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>81cf	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>81d2	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>81d5	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>81d8	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>81db	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>81de	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.81df					LabelHere:
.81df	c8		iny				iny 								; skip .
.81e0	a2 00		ldx #$00			ldx 	#0 							; get a term
.81e2	20 d2 97	jsr $97d2			jsr 	EvaluateTerm 				; get a term
.81e5	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.81e7	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.81e9	d0 22		bne $820d			bne 	_ALType
.81eb	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.81ed	85 36		sta $36				sta 	zTemp0
.81ef	b5 60		lda $60,x			lda 	NSMantissa1,x
.81f1	85 37		sta $37				sta 	zTemp0+1
.81f3	5a		phy				phy 								; copy address in.
.81f4	a0 01		ldy #$01			ldy 	#1
.81f6	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.81f9	92 36		sta ($36)			sta 	(zTemp0)
.81fb	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.81fe	91 36		sta ($36),y			sta 	(zTemp0),y
.8200	c8		iny				iny
.8201	a9 00		lda #$00			lda 	#0
.8203	91 36		sta ($36),y			sta 	(zTemp0),y
.8205	c8		iny				iny
.8206	91 36		sta ($36),y			sta 	(zTemp0),y
.8208	c8		iny				iny
.8209	91 36		sta ($36),y			sta 	(zTemp0),y
.820b	7a		ply				ply
.820c	60		rts				rts
.820d					_ALType:
.820d	4c 19 9f	jmp $9f19			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8210					TypeAndCalculateOperand:
.8210	b1 30		lda ($30),y			lda 	(codePtr),y
.8212	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8214	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8216	f0 5b		beq $8273			beq 	_TACOExit
.8218	c9 80		cmp #$80			cmp 	#KWC_EOL
.821a	f0 57		beq $8273			beq 	_TACOExit
.821c	c8		iny				iny
.821d	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.821f	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8221	f0 51		beq $8274			beq 	CalculateOperand
.8223	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8225	f0 1f		beq $8246			beq 	_TACOIndirect
.8227	88		dey				dey 								; undo get of first character
.8228	20 74 82	jsr $8274			jsr 	CalculateOperand 			; get operand
.822b	b1 30		lda ($30),y			lda 	(codePtr),y
.822d	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.822f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8231	d0 40		bne $8273			bne 	_TACOExit
.8233	c8		iny				iny
.8234	20 7e 82	jsr $827e			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8237	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.8239	c9 58		cmp #$58			cmp 	#'X'
.823b	f0 36		beq $8273			beq 	_TACOExit
.823d	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.823f	c9 59		cmp #$59			cmp 	#'Y'
.8241	f0 30		beq $8273			beq 	_TACOExit
.8243					_TACOSyntax:
.8243	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError
.8246					_TACOIndirect:
.8246	20 74 82	jsr $8274			jsr 	CalculateOperand 			; get the operand
.8249	b1 30		lda ($30),y			lda 	(codePtr),y
.824b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.824d	f0 17		beq $8266			beq 	_TACOIndX
.824f	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8252	b1 30		lda ($30),y			lda 	(codePtr),y
.8254	a2 d1		ldx #$d1			ldx 	#AM_IND
.8256	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.8258	d0 19		bne $8273			bne 	_TACOExit
.825a	c8		iny				iny
.825b	20 7e 82	jsr $827e			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.825e	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8260	d0 e1		bne $8243			bne 	_TACOSyntax
.8262	a2 d0		ldx #$d0			ldx 	#AM_INDY
.8264	80 0d		bra $8273			bra 	_TACOExit
.8266					_TACOIndX:
.8266	c8		iny				iny
.8267	20 7e 82	jsr $827e			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.826a	c9 58		cmp #$58			cmp 	#'X' 						; check X
.826c	d0 d5		bne $8243			bne 	_TACOSyntax
.826e	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket			; check )
.8271	a2 c0		ldx #$c0			ldx 	#AM_INDX
.8273					_TACOExit:
.8273	60		rts				rts
.8274					CalculateOperand:
.8274	48		pha				pha
.8275	da		phx				phx
.8276	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.8278	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger
.827b	fa		plx				plx
.827c	68		pla				pla
.827d	60		rts				rts
.827e					TACOCheckXY:
.827e	b1 30		lda ($30),y			lda 	(codePtr),y
.8280	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.8282	c9 40		cmp #$40			cmp 	#$40
.8284	d0 21		bne $82a7			bne 	_TCXYFail
.8286	b1 30		lda ($30),y			lda 	(codePtr),y
.8288	18		clc				clc
.8289	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.828b	85 37		sta $37				sta 	zTemp0+1
.828d	c8		iny				iny
.828e	b1 30		lda ($30),y			lda 	(codePtr),y
.8290	c8		iny				iny
.8291	85 36		sta $36				sta 	zTemp0
.8293	5a		phy				phy 								; save position
.8294	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.8296	b1 36		lda ($36),y			lda 	(zTemp0),y
.8298	d0 0c		bne $82a6			bne 	_TCXYPopFail
.829a	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.829c	b1 36		lda ($36),y			lda 	(zTemp0),y
.829e	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82a0	f0 08		beq $82aa			beq 	_TCXYFound
.82a2	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82a4	f0 04		beq $82aa			beq 	_TCXYFound
.82a6					_TCXYPopFail:
.82a6	7a		ply				ply
.82a7					_TCXYFail:
.82a7	a9 00		lda #$00			lda 	#0
.82a9	60		rts				rts
.82aa					_TCXYFound:
.82aa	7a		ply				ply 								; restore position
.82ab	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82ad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82ae					BackloadProgram:
.82ae	a2 82		ldx #$82			ldx 	#_BLLoad >> 8
.82b0	a9 f5		lda #$f5			lda 	#_BLLoad & $FF
.82b2	20 dd 8e	jsr $8edd			jsr 	PrintStringXA
.82b5	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82b7	8d ad 05	sta $05ad			sta 	0+BackLoadPointer
.82ba	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82bc	8d ae 05	sta $05ae			sta 	1+BackLoadPointer
.82bf	a9 ff		lda #$ff			lda 	#$FF
.82c1	8d fa ff	sta $fffa			sta 	$FFFA
.82c4					_BPLoop:
.82c4	a2 ff		ldx #$ff			ldx 	#$FF
.82c6	20 0a 83	jsr $830a			jsr 	BLReadByte 					; read a byte
.82c9	c9 00		cmp #$00			cmp 	#0
.82cb	f0 21		beq $82ee			beq 	_BPExit 					; if 0 exit
.82cd	30 1f		bmi $82ee			bmi 	_BPExit 					; if -ve exit
.82cf					_BPCopy:
.82cf	e8		inx				inx  								; copy byte into the lineBuffer
.82d0	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.82d3	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.82d6	20 0a 83	jsr $830a			jsr 	BLReadByte 					; read next byte
.82d9	30 0a		bmi $82e5			bmi 	_BPEndLine 					; -ve = EOL
.82db	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.82dd	d0 02		bne $82e1			bne 	_BPNotTab
.82df	a9 20		lda #$20			lda 	#' '
.82e1					_BPNotTab:
.82e1	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.82e3	b0 ea		bcs $82cf			bcs 	_BPCopy 					; until a control character, should be 13 received.
.82e5					_BPEndLine:
.82e5	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.82e8	ea		nop				nop
.82e9	20 21 83	jsr $8321			jsr 	EditProgramCode
.82ec	80 d6		bra $82c4			bra 	_BPLoop
.82ee					_BPExit:
.82ee	9c fa ff	stz $fffa			stz 	$FFFA
.82f1	20 dc 83	jsr $83dc			jsr 	ClearCommand 				; clear variables etc.
.82f4	60		rts				rts
.82f5					_BLLoad:
>82f5	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>82fd	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.830a					BLReadByte:
.830a	ad ad 05	lda $05ad			lda 	BackLoadPointer 			; copy pointer to zTemp0
.830d	85 36		sta $36				sta 	zTemp0
.830f	ad ae 05	lda $05ae			lda 	BackLoadPointer+1
.8312	85 37		sta $37				sta 	zTemp0+1
.8314	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8316	ee ad 05	inc $05ad			inc 	BackLoadPointer 			; bump pointer
.8319	d0 03		bne $831e			bne 	_BLNoCarry
.831b	ee ae 05	inc $05ae			inc 	BackLoadPointer+1
.831e					_BLNoCarry:
.831e	c9 00		cmp #$00			cmp 	#0
.8320	60		rts				rts
.05ad					BackLoadPointer:
>05ad							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8321					EditProgramCode:
.8321	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line.
.8324	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.8327	20 fd a4	jsr $a4fd			jsr 	MemorySearch
.832a	90 05		bcc $8331			bcc 	_EPCNoDelete 				; reached the end don't delete
.832c	d0 03		bne $8331			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.832e	20 22 a4	jsr $a422			jsr 	MemoryDeleteLine 			; delete the line
.8331					_EPCNoDelete:
.8331	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty
.8334	c9 80		cmp #$80			cmp 	#KWC_EOL
.8336	f0 0d		beq $8345			beq 	_EPCNoInsert
.8338	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist.
.833b	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.833e	20 fd a4	jsr $a4fd			jsr 	MemorySearch
.8341	18		clc				clc 								; insert at this point.
.8342	20 59 a4	jsr $a459			jsr 	MemoryInsertLine 			; insert the line
.8345					_EPCNoInsert:
.8345	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8346					WarmStart:
.8346	a2 ff		ldx #$ff			ldx 	#$FF
.8348	9a		txs				txs
.8349	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour
.834b	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.834e	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.8351	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.8354	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number ?
.8357	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.835a	d0 17		bne $8373			bne 	_WSEditCode 				; if so,edit code.
.835c	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.835f	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.8361	85 30		sta $30				sta 	codePtr
.8363	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8365	85 31		sta $31				sta 	codePtr+1
.8367	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.836a	c9 80		cmp #$80			cmp 	#KWC_EOL
.836c	f0 d8		beq $8346			beq 	WarmStart
.836e	20 bd 8a	jsr $8abd			jsr 	RUNCodePointerLine 			; execute that line.
.8371	80 d3		bra $8346			bra 	WarmStart
.8373					_WSEditCode:
.8373	20 21 83	jsr $8321			jsr 	EditProgramCode
.8376	20 dc 83	jsr $83dc			jsr 	ClearCommand
.8379	80 cb		bra $8346			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.837b					AssembleCommand:
.837b	a2 00		ldx #$00			ldx 	#0
.837d	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger 		; start address
.8380	a5 58		lda $58				lda 	NSMantissa0
.8382	8d 1e 04	sta $041e			sta 	AssemblerAddress
.8385	a5 60		lda $60				lda 	NSMantissa1
.8387	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.838a	20 73 8e	jsr $8e73			jsr 	CheckComma
.838d	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; options
.8390	a5 58		lda $58				lda 	NSMantissa0
.8392	8d 20 04	sta $0420			sta 	AssemblerControl
.8395	60		rts				rts
.8396	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.8397					AssertCommand:
.8397	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8399	20 fe 9c	jsr $9cfe			jsr 	EvaluateInteger 			; the assert test
.839c	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; exit if result is non zero.
.839f	d0 05		bne $83a6			bne 	_ACExit
.83a1	a9 0a		lda #$0a		lda	#10
.83a3	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.83a6					_ACExit:
.83a6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83a7					CallCommand:
.83a7	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.83a9	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger
.83ac					_CCClear
.83ac	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83ad	20 91 9d	jsr $9d91			jsr 	NSMSetZero 					; these are optional sequentially.
.83b0	e0 04		cpx #$04			cpx 	#4
.83b2	d0 f8		bne $83ac			bne 	_CCClear
.83b4	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.83b6					_CCCParam:
.83b6	b1 30		lda ($30),y			lda 	(codePtr),y
.83b8	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83ba	d0 09		bne $83c5			bne 	_CCCRun6502
.83bc	c8		iny				iny 								; skip comma
.83bd	e8		inx				inx	 								; next level
.83be	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83c1	e0 03		cpx #$03			cpx 	#3
.83c3	90 f1		bcc $83b6			bcc 	_CCCParam 					; done all 3 ?
.83c5					_CCCRun6502:
.83c5	5a		phy				phy 								; save position
.83c6	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.83c8	85 37		sta $37				sta 	zTemp0+1
.83ca	a5 58		lda $58				lda 	NSMantissa0
.83cc	85 36		sta $36				sta 	zTemp0
.83ce	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.83d0	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.83d2	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.83d4	20 d9 83	jsr $83d9			jsr 	_CCCZTemp0 					; call zTemp0
.83d7	7a		ply				ply 								; restore position and exit
.83d8	60		rts				rts
.83d9					_CCCZTemp0:
.83d9	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83dc					ClearCommand:
.83dc	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83de	85 36		sta $36				sta 	0+zTemp0
.83e0	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83e2	85 37		sta $37				sta 	1+zTemp0
.83e4					_ClearZeroLoop:
.83e4	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.83e6	f0 24		beq $840c			beq 	_ClearZeroEnd
.83e8	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83ea	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.83ec					_ClearOneVariable:
.83ec	91 36		sta ($36),y			sta 	(zTemp0),y
.83ee	c8		iny				iny
.83ef	c0 08		cpy #$08			cpy 	#8
.83f1	d0 f9		bne $83ec			bne 	_ClearOneVariable
.83f3	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.83f5	b1 36		lda ($36),y			lda 	(zTemp0),y
.83f7	c9 18		cmp #$18			cmp 	#NSTProcedure
.83f9	d0 04		bne $83ff			bne 	_ClearNotProcedure
.83fb	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.83fd	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.83ff					_ClearNotProcedure:
.83ff	18		clc				clc 								; go to the next variable
.8400	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8402	65 36		adc $36				adc 	zTemp0
.8404	85 36		sta $36				sta 	zTemp0
.8406	90 dc		bcc $83e4			bcc 	_ClearZeroLoop
.8408	e6 37		inc $37				inc 	zTemp0+1
.840a	80 d8		bra $83e4			bra 	_ClearZeroLoop
.840c					_ClearZeroEnd:
.840c	18		clc				clc
.840d	a5 36		lda $36				lda 	zTemp0
.840f	69 01		adc #$01			adc 	#1
.8411	8d 0c 04	sta $040c			sta 	lowMemPtr
.8414	a5 37		lda $37				lda 	zTemp0+1
.8416	69 00		adc #$00			adc 	#0
.8418	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.841b	20 39 a6	jsr $a639			jsr 	StackReset
.841e	20 9f a6	jsr $a69f			jsr 	StringSystemInitialise
.8421	20 11 8d	jsr $8d11			jsr 	ProcedureScan
.8424	20 6c 8a	jsr $8a6c			jsr 	Command_Restore
.8427	9c 1e 04	stz $041e			stz 	AssemblerAddress
.842a	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.842d	9c 20 04	stz $0420			stz 	AssemblerControl
.8430	20 b9 99	jsr $99b9			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8433	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8434					ClearScreen:
.8434	5a		phy				phy
.8435	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8437	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.843a	7a		ply				ply
.843b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.843c					Command_Data:
.843c	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.843e	a2 80		ldx #$80			ldx 	#KWC_EOL
.8440	20 63 8d	jsr $8d63			jsr 	ScanForward
.8443	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8444					DimCommand:
.8444	b1 30		lda ($30),y			lda 	(codePtr),y
.8446	29 c0		and #$c0			and 	#$C0
.8448	c9 40		cmp #$40			cmp 	#$40
.844a	d0 7a		bne $84c6			bne 	_DCSyntax
.844c	b1 30		lda ($30),y			lda 	(codePtr),y
.844e	18		clc				clc
.844f	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8451	85 3f		sta $3f				sta 	zaTemp+1
.8453	c8		iny				iny
.8454	b1 30		lda ($30),y			lda 	(codePtr),y
.8456	c8		iny				iny
.8457	85 3e		sta $3e				sta 	zaTemp
.8459	5a		phy				phy
.845a	a0 02		ldy #$02			ldy 	#2 						; read type byte
.845c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.845e	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8460	c9 18		cmp #$18			cmp 	#NSTProcedure
.8462	f0 62		beq $84c6			beq 	_DCSyntax
.8464	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8466	29 04		and #$04			and 	#NSBIsArray
.8468	f0 64		beq $84ce			beq 	_DCType
.846a	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.846c	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.846e	d0 59		bne $84c9			bne 	_DCRedefine
.8470	7a		ply				ply
.8471	20 d1 84	jsr $84d1			jsr 	_DCGetSize 				; get array size, check it.
.8474	5a		phy				phy
.8475	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8477	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.8479	7a		ply				ply 							; is there a second (e.g. ,x)
.847a	b1 30		lda ($30),y			lda 	(codePtr),y
.847c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.847e	d0 0a		bne $848a			bne 	_DCOneDimension
.8480	c8		iny				iny 							; skip comma
.8481	20 d1 84	jsr $84d1			jsr 	_DCGetSize 				; get 2nd array size
.8484	5a		phy				phy
.8485	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8487	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8489	7a		ply				ply
.848a					_DCOneDimension:
.848a	5a		phy				phy 							; save position
.848b	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.848d	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.848f	aa		tax				tax
.8490	c8		iny				iny
.8491	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8493	e8		inx				inx 							; bump them.
.8494	1a		inc a				inc 	a
.8495	20 3c 9d	jsr $9d3c			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.8498	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.849a	29 e0		and #$e0			and 	#$E0
.849c	d0 23		bne $84c1			bne 	_DCSize
.849e	a0 02		ldy #$02			ldy 	#2 						; get base type
.84a0	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a2	20 df 84	jsr $84df			jsr 	ScaleByBaseType 		; scale by base type
.84a5	a5 36		lda $36				lda 	zTemp0
.84a7	a6 37		ldx $37				ldx 	zTemp0+1
.84a9	20 7b 99	jsr $997b			jsr 	AllocateXABytes 		; allocate memory
.84ac	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84ae	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84b0	c8		iny				iny
.84b1	8a		txa				txa
.84b2	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84b4	7a		ply				ply 							; get position back
.84b5	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket 		; check )
.84b8	b1 30		lda ($30),y			lda 	(codePtr),y
.84ba	c8		iny				iny 							; consume in case
.84bb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84bd	f0 85		beq $8444			beq 	DimCommand
.84bf	88		dey				dey 							; undo consume
.84c0	60		rts				rts
.84c1					_DCSize:
.84c1	a9 16		lda #$16		lda	#22
.84c3	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.84c6					_DCSyntax:
.84c6	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError
.84c9					_DCRedefine:
.84c9	a9 15		lda #$15		lda	#21
.84cb	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.84ce					_DCType:
.84ce	4c 19 9f	jmp $9f19			jmp 	TypeError
.84d1					_DCGetSize:
.84d1	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84d3	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 	; get array dimension
.84d6	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84d8	f0 e7		beq $84c1			beq 	_DCSize
.84da	c9 fe		cmp #$fe			cmp 	#254
.84dc	f0 e3		beq $84c1			beq 	_DCSize
.84de	60		rts				rts
.84df					ScaleByBaseType:
.84df	29 10		and #$10			and 	#NSBIsString 			; is it string
.84e1	d0 19		bne $84fc			bne 	_SBBTString
.84e3	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84e5	48		pha				pha
.84e6	a5 36		lda $36				lda 	zTemp0
.84e8	48		pha				pha
.84e9	06 36		asl $36				asl 	zTemp0 					; x 2
.84eb	26 37		rol $37				rol 	zTemp0+1
.84ed	06 36		asl $36				asl 	zTemp0 					; x 4
.84ef	26 37		rol $37				rol 	zTemp0+1
.84f1	68		pla				pla 							; add stacked value = x 5
.84f2	65 36		adc $36				adc 	zTemp0
.84f4	85 36		sta $36				sta 	zTemp0
.84f6	68		pla				pla
.84f7	65 37		adc $37				adc 	zTemp0+1
.84f9	85 37		sta $37				sta 	zTemp0+1
.84fb	60		rts				rts
.84fc					_SBBTString:
.84fc	06 36		asl $36				asl 	zTemp0
.84fe	26 37		rol $37				rol 	zTemp0+1
.8500	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8501					EndCommand:
.8501	4c 46 83	jmp $8346			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8504					ForCommand:
.8504	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.8506	20 d3 a5	jsr $a5d3			jsr 	StackOpen
.8509	a2 00		ldx #$00			ldx 	#0
.850b	20 d2 97	jsr $97d2			jsr 	EvaluateTerm
.850e	b5 50		lda $50,x			lda 	NSStatus,x
.8510	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8512	d0 47		bne $855b			bne		_FCError
.8514	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8516	20 7b 8e	jsr $8e7b			jsr 	CheckNextA
.8519	e8		inx				inx
.851a	20 fe 9c	jsr $9cfe			jsr 	EvaluateInteger 			; <from> in +1
.851d	b1 30		lda ($30),y			lda 	(codePtr),y
.851f	c8		iny				iny 								; consume it
.8520	48		pha				pha 								; save on stack for later
.8521	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8523	f0 04		beq $8529			beq 	_FCNoSyntax
.8525	c9 ce		cmp #$ce			cmp 	#KWD_TO
.8527	d0 35		bne $855e			bne 	_FCSyntaxError
.8529					_FCNoSyntax:
.8529	e8		inx				inx
.852a	20 fe 9c	jsr $9cfe			jsr 	EvaluateInteger
.852d	20 18 a6	jsr $a618			jsr 	STKSaveCodePosition 		; save loop back position
.8530	68		pla				pla 								; restore DOWNTO or TO
.8531	5a		phy				phy 								; save Y on the stack
.8532	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8534	f0 02		beq $8538			beq 	_FCNotDownTo
.8536	a9 02		lda #$02			lda 	#2
.8538					_FCNotDownTo:
.8538	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8539	a0 10		ldy #$10			ldy 	#16
.853b	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.853d	a0 06		ldy #$06			ldy 	#6
.853f	a5 58		lda $58				lda 	NSMantissa0
.8541	91 34		sta ($34),y			sta 	(basicStack),y
.8543	a5 60		lda $60				lda 	NSMantissa1
.8545	c8		iny				iny
.8546	91 34		sta ($34),y			sta 	(basicStack),y
.8548	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.854a	a2 01		ldx #$01			ldx 	#1
.854c	20 61 85	jsr $8561			jsr 	FCIntegerToStack
.854f	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8551	a2 02		ldx #$02			ldx 	#2
.8553	20 61 85	jsr $8561			jsr 	FCIntegerToStack
.8556	20 7c 85	jsr $857c			jsr 	CopyIndexToReference
.8559	7a		ply				ply 								; restore position
.855a	60		rts				rts
.855b					_FCError:
.855b	4c 19 9f	jmp $9f19			jmp 	TypeError
.855e					_FCSyntaxError:
.855e	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError
.8561					FCIntegerToStack:
.8561	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8563	10 03		bpl $8568			bpl	 	_FCNotNegative
.8565	20 5a 9d	jsr $9d5a			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8568					_FCNotNegative:
.8568	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.856a	91 34		sta ($34),y			sta 	(basicStack),y
.856c	c8		iny				iny
.856d	b5 60		lda $60,x			lda 	NSMantissa1,x
.856f	91 34		sta ($34),y			sta 	(basicStack),y
.8571	c8		iny				iny
.8572	b5 68		lda $68,x			lda 	NSMantissa2,x
.8574	91 34		sta ($34),y			sta 	(basicStack),y
.8576	c8		iny				iny
.8577	b5 70		lda $70,x			lda 	NSMantissa3,x
.8579	91 34		sta ($34),y			sta 	(basicStack),y
.857b	60		rts				rts
.857c					CopyIndexToReference:
.857c	5a		phy				phy
.857d	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.857f	38		sec				sec 								; (because we copy from offset 8)
.8580	b1 34		lda ($34),y			lda 	(basicStack),y
.8582	e9 08		sbc #$08			sbc 	#8
.8584	85 36		sta $36				sta 	zTemp0
.8586	c8		iny				iny
.8587	b1 34		lda ($34),y			lda 	(basicStack),y
.8589	e9 00		sbc #$00			sbc 	#0
.858b	85 37		sta $37				sta 	zTemp0+1
.858d	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.858f	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.8591	b1 34		lda ($34),y			lda 	(basicStack),y
.8593	0a		asl a				asl 	a 							; into carry
.8594	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8596	90 14		bcc $85ac			bcc 	_CITRNormal
.8598	38		sec				sec
.8599					_CITRNegative:
.8599	a9 00		lda #$00			lda 	#0
.859b	f1 34		sbc ($34),y			sbc 	(basicStack),y
.859d	91 36		sta ($36),y			sta 	(zTemp0),y
.859f	c8		iny				iny
.85a0	ca		dex				dex
.85a1	d0 f6		bne $8599			bne 	_CITRNegative
.85a3	88		dey				dey 								; look at MSB of mantissa
.85a4	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85a6	09 80		ora #$80			ora 	#$80
.85a8	91 36		sta ($36),y			sta 	(zTemp0),y
.85aa	7a		ply				ply
.85ab	60		rts				rts
.85ac					_CITRNormal:
.85ac	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85ae	91 36		sta ($36),y			sta 	(zTemp0),y
.85b0	c8		iny				iny
.85b1	ca		dex				dex
.85b2	d0 f8		bne $85ac			bne 	_CITRNormal
.85b4	7a		ply				ply 								; and exit.
.85b5	60		rts				rts
.85b6					NextCommand:
.85b6	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85b8	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85ba	20 00 a6	jsr $a600			jsr 	StackCheckFrame
.85bd	5a		phy				phy
.85be	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85c0	b1 34		lda ($34),y			lda 	(basicStack),y
.85c2	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85c4	30 02		bmi $85c8			bmi 	_NCStepNeg
.85c6	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85c8					_NCStepNeg:
.85c8	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85ca	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85cc	18		clc				clc
.85cd					_NCBump:
.85cd	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85cf	91 34		sta ($34),y			sta 	(basicStack),y
.85d1	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85d3	c8		iny				iny 								; next byte
.85d4	ca		dex				dex 								; do four times
.85d5	d0 f6		bne $85cd			bne 	_NCBump
.85d7	20 7c 85	jsr $857c			jsr		CopyIndexToReference		; copy it to the reference variable.
.85da	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85dc	b1 34		lda ($34),y			lda 	(basicStack),y
.85de	0a		asl a				asl 	a 							; sign bit to carry
.85df	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85e1	85 38		sta $38				sta 	zTemp1
.85e3	90 02		bcc $85e7			bcc 	_NCCompRev 					; use if step is +ve
.85e5	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.85e7					_NCCompRev:
.85e7	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.85e9	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.85eb	85 39		sta $39				sta 	zTemp1+1
.85ed	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.85ef	38		sec				sec
.85f0					_NCCompare:
.85f0	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.85f2	b1 34		lda ($34),y			lda 	(basicStack),y
.85f4	a4 39		ldy $39				ldy 	zTemp1+1
.85f6	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85f8	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.85fa	e6 39		inc $39				inc 	zTemp1+1
.85fc	ca		dex				dex 								; do it 4 times.
.85fd	d0 f1		bne $85f0			bne 	_NCCompare
.85ff	50 02		bvc $8603			bvc 	_NCNoOverflow 				; convert to signed comparison
.8601	49 80		eor #$80			eor 	#$80
.8603					_NCNoOverflow:
.8603	7a		ply				ply 								; restore Y position
.8604	0a		asl a				asl 	a 							; is bit 7 set.
.8605	90 04		bcc $860b			bcc 	_NCLoopback 				; if no , >= so loop back
.8607	20 f2 a5	jsr $a5f2			jsr 	StackClose 					; exit the loop
.860a	60		rts				rts
.860b					_NCLoopBack:
.860b	20 29 a6	jsr $a629			jsr 	STKLoadCodePosition 		; loop back
.860e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.860f					Command_GOSUB:
.860f	a2 00		ldx #$00			ldx 	#0
.8611	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8614	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8616	20 d3 a5	jsr $a5d3			jsr 	StackOpen 					; create frame
.8619	20 18 a6	jsr $a618			jsr 	STKSaveCodePosition 		; save current position
.861c	4c 32 86	jmp $8632			jmp 	GotoStackX
.861f					Command_RETURN:
.861f	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8621	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8623	20 00 a6	jsr $a600			jsr 	StackCheckFrame
.8626	20 29 a6	jsr $a629			jsr 	STKLoadCodePosition 		; restore code position
.8629	20 f2 a5	jsr $a5f2			jsr 	StackClose
.862c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.862d					GotoCommand:
.862d	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.862f	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger
.8632					GotoStackX:
.8632	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8634	48		pha				pha 								; it is slightly inefficient, just in cases.
.8635	b5 58		lda $58,x			lda 	NSMantissa0,x
.8637	fa		plx				plx
.8638	20 fd a4	jsr $a4fd			jsr 	MemorySearch 				; transfer to line number AX.
.863b	90 05		bcc $8642			bcc 	_GotoError 					; not found, off end.
.863d	d0 03		bne $8642			bne 	_GotoError 					; not found exactly
.863f	4c b6 8a	jmp $8ab6			jmp 	RunNewLine 					; and go straight to new line code.
.8642					_GotoError:
.8642	a9 0d		lda #$0d		lda	#13
.8644	4c 84 8e	jmp $8e84		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8647					IfCommand:
.8647	a2 00		ldx #$00			ldx 	#0 							; If what.
.8649	20 df 9c	jsr $9cdf			jsr 	EvaluateNumber
.864c	b1 30		lda ($30),y			lda 	(codePtr),y
.864e	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8650	d0 0a		bne $865c			bne 	_IFStructured
.8652	c8		iny				iny 								; consume THEN
.8653	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; is it zero
.8656	f0 01		beq $8659			beq 	_IfFail 					; if fail, go to next line
.8658	60		rts				rts 								; if THEN just continue
.8659					_IfFail:
.8659	4c 9e 8a	jmp $8a9e			jmp 	EOLCommand
.865c					_IfStructured:
.865c	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; is it zero
.865f	d0 07		bne $8668			bne 	_IfExit 					; if not, then continue normally.
.8661	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8663	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8665	20 63 8d	jsr $8d63			jsr 	ScanForward 				; and run from there/
.8668					_IfExit:
.8668	60		rts				rts
.8669					ElseCode:
.8669	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.866b	aa		tax				tax 								; so just go to the structure exit
.866c	20 63 8d	jsr $8d63			jsr 	ScanForward
.866f	60		rts				rts
.8670					EndIf:
.8670	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8671					Command_Input:
.8671	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.8673	8d 28 04	sta $0428			sta 	IsInputFlag
.8676	80 03		bra $867b			bra 	Command_IP_Main
.8678					Command_Print:
.8678	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.867b					Command_IP_Main:
.867b	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.867c					_CPLoop:
.867c	08		php				php 								; save last action flag
.867d	b1 30		lda ($30),y			lda 	(codePtr),y
.867f	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8681	f0 54		beq $86d7			beq 	_CPExit
.8683	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8685	f0 50		beq $86d7			beq 	_CPExit
.8687	68		pla				pla 								; throw last action flag
.8688	b1 30		lda ($30),y			lda 	(codePtr),y
.868a	c8		iny				iny
.868b	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.868d	f0 45		beq $86d4			beq 	_CPContinueWithSameLine
.868f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8691	f0 3c		beq $86cf			beq 	_CPTab
.8693	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8695	f0 34		beq $86cb			beq 	_CPNewLine
.8697	88		dey				dey 								; undo the get.
.8698	20 86 93	jsr $9386			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.869b	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.869d	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.869f	f0 0d		beq $86ae			beq 	_CPIsValue 					; no, display it.
.86a1	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.86a4	f0 05		beq $86ab			beq 	_CPIsPrint 					; otherwise display.
.86a6	20 e0 86	jsr $86e0			jsr 	CIInputValue 				; input a value to the reference
.86a9	80 20		bra $86cb			bra 	_CPNewLine
.86ab					_CPIsPrint:
.86ab	20 4b 96	jsr $964b			jsr 	Dereference 				; dereference if required.
.86ae					_CPIsValue:
.86ae	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.86b0	29 10		and #$10			and 	#NSBIsString
.86b2	f0 09		beq $86bd			beq 	_CPNumber
.86b4	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.86b6	a5 58		lda $58				lda 	NSMantissa0
.86b8	20 43 87	jsr $8743			jsr 	CPPrintStringXA
.86bb	80 be		bra $867b			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86bd					_CPNumber:
.86bd	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86bf	20 c6 9b	jsr $9bc6			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.86c2	a2 05		ldx #$05			ldx 	#DecimalBuffer >> 8
.86c4	a9 9d		lda #$9d			lda 	#DecimalBuffer & $FF
.86c6	20 43 87	jsr $8743			jsr 	CPPrintStringXA 			; print it.
.86c9	80 b0		bra $867b			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86cb					_CPNewLine:
.86cb	a9 0d		lda #$0d			lda 	#13
.86cd	80 02		bra $86d1			bra 	_CPPrintChar
.86cf					_CPTab:
.86cf	a9 09		lda #$09			lda 	#9 							; print TAB
.86d1					_CPPrintChar:
.86d1	20 56 87	jsr $8756			jsr 	CPPrintVector
.86d4					_CPContinueWithSameLine:
.86d4	38		sec				sec 								; loop round with carry set, which
.86d5	80 a5		bra $867c			bra 	_CPLoop 					; will inhibit final CR
.86d7					_CPExit:
.86d7	28		plp				plp 								; get last action flag
.86d8	b0 05		bcs $86df			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.86da	a9 0d		lda #$0d			lda 	#13 						; print new line
.86dc	20 56 87	jsr $8756			jsr 	CPPrintVector
.86df					_CPExit2:
.86df	60		rts				rts
.86e0					CIInputValue:
.86e0	a2 00		ldx #$00			ldx 	#0 							; input a line.
.86e2					_CIInputLine:
.86e2	20 59 87	jsr $8759			jsr 	CPInputVector 				; get key
.86e5	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.86e7	f0 1f		beq $8708			beq 	_CIHaveValue
.86e9	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.86eb	f0 11		beq $86fe			beq 	_CIBackspace
.86ed	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.86ef	90 f1		bcc $86e2			bcc 	_CIInputLine
.86f1	e0 50		cpx #$50			cpx 	#80 						; max length
.86f3	b0 ed		bcs $86e2			bcs 	_CIInputLine
.86f5	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.86f8	e8		inx				inx
.86f9	20 56 87	jsr $8756			jsr 	CPPrintVector 				; echo it.
.86fc	80 e4		bra $86e2			bra 	_CIInputLine
.86fe					_CIBackSpace:
.86fe	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8700	f0 e0		beq $86e2			beq 	_CIInputLine
.8702	20 56 87	jsr $8756			jsr 	CPPrintVector 				; echo it.
.8705	ca		dex				dex
.8706	80 da		bra $86e2			bra 	_CIInputLine
.8708					_CIHaveValue:
.8708	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.870b	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.870d	29 10		and #$10			and 	#NSBIsString
.870f	f0 17		beq $8728			beq 	_CIAssignNumber 			; assign a number
.8711	a2 01		ldx #$01			ldx 	#1
.8713	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8715	95 58		sta $58,x			sta 	NSMantissa0,x
.8717	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8719	95 60		sta $60,x			sta 	NSMantissa1,x
.871b	74 68		stz $68,x			stz 	NSMantissa2,x
.871d	74 70		stz $70,x			stz 	NSMantissa3,x
.871f	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8721	95 50		sta $50,x			sta  	NSStatus,x
.8723	ca		dex				dex 								; X = 0
.8724	20 95 87	jsr $8795			jsr 	AssignVariable
.8727	60		rts				rts
.8728					_CIAssignNumber:
.8728	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.872a	85 36		sta $36				sta 	zTemp0
.872c	a9 05		lda #$05			lda 	#lineBuffer >> 8
.872e	85 37		sta $37				sta 	zTemp0+1
.8730	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8732	20 48 9b	jsr $9b48			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8735	90 07		bcc $873e			bcc 	_CIIsOkay
.8737	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8739	20 56 87	jsr $8756			jsr 	CPPrintVector
.873c	80 a2		bra $86e0			bra 	CIInputValue
.873e					_CIIsOkay:
.873e	ca		dex				dex 								; X = 0
.873f	20 95 87	jsr $8795			jsr 	AssignVariable
.8742	60		rts				rts
.8743					CPPrintStringXA:
.8743	5a		phy				phy
.8744	86 37		stx $37				stx 	zTemp0+1
.8746	85 36		sta $36				sta 	zTemp0
.8748	a0 00		ldy #$00			ldy 	#0
.874a					_PSXALoop:
.874a	b1 36		lda ($36),y			lda 	(zTemp0),y
.874c	f0 06		beq $8754			beq 	_PSXAExit
.874e	20 56 87	jsr $8756			jsr 	CPPrintVector
.8751	c8		iny				iny
.8752	80 f6		bra $874a			bra 	_PSXALoop
.8754					_PSXAExit:
.8754	7a		ply				ply
.8755	60		rts				rts
.8756					CPPrintVector:
.8756	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.8759					CPInputVector:
.8759	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.875c					LetCommand:
.875c	a2 00		ldx #$00			ldx 	#0
.875e	b1 30		lda ($30),y			lda 	(codePtr),y
.8760	c9 10		cmp #$10			cmp 	#KWD_AT
.8762	d0 14		bne $8778			bne 	_LCStandard
.8764	c8		iny				iny 								; skip equal
.8765	20 d2 97	jsr $97d2			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.8768	20 4b 96	jsr $964b			jsr 	Dereference 				; dereference it to a value
.876b	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.876d	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.876f	95 50		sta $50,x			sta 	NSStatus,x
.8771	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8773	d0 0f		bne $8784			bne 	_LCMain
.8775	4c 19 9f	jmp $9f19			jmp 	TypeError 					; was a reference before.
.8778					_LCStandard:
.8778	ad 70 93	lda $9370			lda 	PrecedenceLevel+"*"			; precedence > this
.877b	20 8a 93	jsr $938a			jsr 	EvaluateExpressionAtPrecedence
.877e	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.8780	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.8782	f0 0e		beq $8792			beq 	_LetGoProc 					; it's a procedure call.
.8784					_LCMain:
.8784	a9 3d		lda #$3d			lda 	#"=" 						; check =
.8786	20 7b 8e	jsr $8e7b			jsr 	CheckNextA
.8789	e8		inx				inx 								; RHS
.878a	20 d6 9c	jsr $9cd6			jsr 	EvaluateValue
.878d	ca		dex				dex
.878e	20 95 87	jsr $8795			jsr 	AssignVariable
.8791	60		rts				rts
.8792					_LetGoProc:
.8792	4c 79 89	jmp $8979			jmp 	CallProcedure
.8795					AssignVariable:
.8795	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8797	48		pha				pha 								; save a copy
.8798	55 51		eor $51,x			eor 	NSStatus+1,x
.879a	29 10		and #$10			and 	#NSBIsString
.879c	d0 0b		bne $87a9			bne 	_ASError
.879e	68		pla				pla 								; get back
.879f	29 10		and #$10			and 	#NSBIsString 				; check type
.87a1	d0 03		bne $87a6			bne 	_ASString
.87a3	4c 89 95	jmp $9589			jmp 	AssignNumber
.87a6					_ASString:
.87a6	4c e7 95	jmp $95e7			jmp 	AssignString
.87a9					_ASError:
.87a9	4c 19 9f	jmp $9f19			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87ac					Command_List:
.87ac	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.87af	b1 30		lda ($30),y			lda 	(codePtr),y
.87b1	29 c0		and #$c0			and 	#$C0
.87b3	c9 40		cmp #$40			cmp 	#$40
.87b5	f0 69		beq $8820			beq 	_CLListProcedure
.87b7	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87b9	64 64		stz $64				stz 	NSMantissa1+4
.87bb	a9 ff		lda #$ff			lda 	#$FF
.87bd	85 5f		sta $5f				sta 	NSMantissa0+7
.87bf	85 67		sta $67				sta 	NSMantissa1+7
.87c1	b1 30		lda ($30),y			lda 	(codePtr),y
.87c3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87c5	f0 1a		beq $87e1			beq 	_CLSecond
.87c7	20 9d 88	jsr $889d			jsr 	CLIsDigit 					; if not digit, list all
.87ca	b0 20		bcs $87ec			bcs 	_CLStart
.87cc	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.87ce	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger
.87d1	b1 30		lda ($30),y			lda 	(codePtr),y
.87d3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87d5	f0 0a		beq $87e1			beq 	_CLSecond 					; if so go get it
.87d7	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.87d9	85 5f		sta $5f				sta 	NSMantissa0+7
.87db	a5 64		lda $64				lda 	NSMantissa1+4
.87dd	85 67		sta $67				sta 	NSMantissa1+7
.87df	80 0b		bra $87ec			bra 	_CLStart
.87e1					_CLSecond:
.87e1	c8		iny				iny 								; consume comma
.87e2	20 9d 88	jsr $889d			jsr 	CLIsDigit 					; digit found
.87e5	b0 05		bcs $87ec			bcs 	_CLStart 					; if not, continue listing
.87e7	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.87e9	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger
.87ec					_CLStart
.87ec	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.87ee	85 30		sta $30				sta 	codePtr
.87f0	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.87f2	85 31		sta $31				sta 	codePtr+1
.87f4					_CLLoop:
.87f4	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.87f7	f0 24		beq $881d			beq 	_CLExit
.87f9	b2 30		lda ($30)			lda 	(codePtr)
.87fb	f0 20		beq $881d			beq 	_CLExit
.87fd	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.87ff	20 8c 88	jsr $888c			jsr 	CLCompareLineNo
.8802	90 0c		bcc $8810			bcc 	_CLNext
.8804	a2 07		ldx #$07			ldx 	#7
.8806	20 8c 88	jsr $888c			jsr 	CLCompareLineNo
.8809	f0 02		beq $880d			beq 	_CLDoThisOne
.880b	b0 03		bcs $8810			bcs 	_CLNext
.880d					_CLDoThisOne:
.880d	20 79 88	jsr $8879			jsr 	CLListOneLine
.8810					_CLNext:
.8810	18		clc				clc
.8811	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8813	65 30		adc $30				adc 	codePtr
.8815	85 30		sta $30				sta 	codePtr
.8817	90 02		bcc $881b			bcc 	_CREExit
.8819	e6 31		inc $31				inc 	codePtr+1 					; carry
.881b					_CREExit:
.881b	80 d7		bra $87f4			bra 	_CLLoop
.881d					_CLExit:
.881d	4c 46 83	jmp $8346			jmp 	WarmStart
.8820					_CLListProcedure:
.8820	b1 30		lda ($30),y			lda 	(codePtr),y
.8822	85 38		sta $38				sta 	zTemp1
.8824	c8		iny				iny
.8825	b1 30		lda ($30),y			lda 	(codePtr),y
.8827	85 39		sta $39				sta 	zTemp1+1
.8829	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.882b	85 30		sta $30				sta 	codePtr
.882d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.882f	85 31		sta $31				sta 	codePtr+1
.8831					_CLLPSearch:
.8831	b2 30		lda ($30)			lda 	(codePtr)
.8833	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.8835	f0 e6		beq $881d			beq 	_CLExit
.8837	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.8839	b1 30		lda ($30),y			lda 	(codePtr),y
.883b	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.883d	d0 0e		bne $884d			bne 	_CLLPNext
.883f	c8		iny				iny 								; check if PROC this.
.8840	b1 30		lda ($30),y			lda 	(codePtr),y
.8842	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8844	d0 07		bne $884d			bne 	_CLLPNext
.8846	c8		iny				iny
.8847	b1 30		lda ($30),y			lda 	(codePtr),y
.8849	c5 39		cmp $39				cmp 	zTemp1+1
.884b	f0 0d		beq $885a			beq 	_CLLPFound
.884d					_CLLPNext:
.884d	18		clc				clc
.884e	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8850	65 30		adc $30				adc 	codePtr
.8852	85 30		sta $30				sta 	codePtr
.8854	90 02		bcc $8858			bcc 	_CREExit
.8856	e6 31		inc $31				inc 	codePtr+1 					; carry
.8858					_CREExit:
.8858	80 d7		bra $8831			bra 	_CLLPSearch
.885a					_CLLPFound:
.885a	b2 30		lda ($30)			lda 	(codePtr)
.885c	f0 bf		beq $881d			beq 	_CLExit
.885e	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.8860	b1 30		lda ($30),y			lda 	(codePtr),y
.8862	48		pha				pha
.8863	20 79 88	jsr $8879			jsr 	CLListOneLine 				; list line and go forward
.8866	18		clc				clc
.8867	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8869	65 30		adc $30				adc 	codePtr
.886b	85 30		sta $30				sta 	codePtr
.886d	90 02		bcc $8871			bcc 	_CREExit
.886f	e6 31		inc $31				inc 	codePtr+1 					; carry
.8871					_CREExit:
.8871	68		pla				pla 								; reached ENDPROC ?
.8872	c9 a6		cmp #$a6			cmp 	#KWD_ENDPROC
.8874	d0 e4		bne $885a			bne 	_CLLPFound
.8876	4c 46 83	jmp $8346			jmp 	WarmStart
.8879					CLListOneLine:
.8879	20 c6 8d	jsr $8dc6			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.887c	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.887f	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8881	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.8883	20 dd 8e	jsr $8edd			jsr 	PrintStringXA
.8886	a9 0d		lda #$0d			lda 	#13 						; new line
.8888	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.888b	60		rts				rts
.888c					CLCompareLineNo:
.888c	38		sec				sec
.888d	a0 01		ldy #$01			ldy 	#1
.888f	b1 30		lda ($30),y			lda 	(codePtr),y
.8891	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.8893	85 36		sta $36				sta 	zTemp0
.8895	c8		iny				iny
.8896	b1 30		lda ($30),y			lda 	(codePtr),y
.8898	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.889a	05 36		ora $36				ora 	zTemp0
.889c	60		rts				rts
.889d					CLIsDigit:
.889d	b1 30		lda ($30),y			lda 	(codePtr),y
.889f	c9 30		cmp #$30			cmp 	#"0"
.88a1	90 03		bcc $88a6			bcc	 	_CLIDExitFalse
.88a3	c9 3a		cmp #$3a			cmp 	#"9"+1
.88a5	60		rts				rts
.88a6					_CLIDExitFalse:
.88a6	38		sec				sec
.88a7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.88a8					Command_LOCAL:
.88a8	a2 00		ldx #$00			ldx 	#0 							; at level 0
.88aa	20 b6 88	jsr $88b6			jsr 	LocaliseNextTerm 			; convert term to a local.
.88ad	b1 30		lda ($30),y			lda 	(codePtr),y
.88af	c8		iny				iny
.88b0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.88b2	f0 f4		beq $88a8			beq 	Command_LOCAL
.88b4	88		dey				dey 								; unpick pre-get
.88b5	60		rts				rts
.88b6					LocaliseNextTerm:
.88b6	20 d2 97	jsr $97d2			jsr 	EvaluateTerm 				; evaluate the term
.88b9	b5 50		lda $50,x			lda 	NSStatus,x
.88bb	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.88bd	f0 5c		beq $891b			beq		_LNTError
.88bf	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.88c1	85 36		sta $36				sta 	zTemp0
.88c3	b5 60		lda $60,x			lda 	NSMantissa1,x
.88c5	85 37		sta $37				sta  	zTemp0+1
.88c7	b5 50		lda $50,x			lda 	NSStatus,x
.88c9	29 10		and #$10			and 	#NSBIsString
.88cb	d0 1e		bne $88eb			bne 	_LNTPushString
.88cd	5a		phy				phy
.88ce	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.88d0					_LNTPushNumLoop:
.88d0	b1 36		lda ($36),y			lda		(zTemp0),y
.88d2	20 b2 a5	jsr $a5b2			jsr 	StackPushByte
.88d5	c8		iny				iny
.88d6	c0 05		cpy #$05			cpy 	#5
.88d8	d0 f6		bne $88d0			bne 	_LNTPushNumLoop
.88da	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.88dc	20 b2 a5	jsr $a5b2			jsr 	StackPushByte
.88df	a5 37		lda $37				lda 	zTemp0+1
.88e1	20 b2 a5	jsr $a5b2			jsr 	StackPushByte
.88e4	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88e6	20 b2 a5	jsr $a5b2			jsr 	StackPushByte
.88e9	7a		ply				ply
.88ea	60		rts				rts
.88eb					_LNTPushString:
.88eb	5a		phy				phy
.88ec	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88ee	85 38		sta $38				sta 	zTemp1
.88f0	a0 01		ldy #$01			ldy 	#1
.88f2	b1 36		lda ($36),y			lda 	(zTemp0),y
.88f4	85 39		sta $39				sta 	zTemp1+1
.88f6	a0 00		ldy #$00			ldy 	#0 							; output string
.88f8	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88fa	f0 0a		beq $8906			beq 	_LNTStringOut
.88fc					_LNTPushStrLoop:
.88fc	b1 38		lda ($38),y			lda 	(zTemp1),y
.88fe	f0 06		beq $8906			beq 	_LNTStringOut
.8900	20 b2 a5	jsr $a5b2			jsr 	StackPushByte
.8903	c8		iny				iny
.8904	80 f6		bra $88fc			bra 	_LNTPushStrLoop
.8906					_LNTStringOut:
.8906	98		tya				tya									; output length
.8907	20 b2 a5	jsr $a5b2			jsr 	StackPushByte
.890a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.890c	20 b2 a5	jsr $a5b2			jsr 	StackPushByte
.890f	b5 60		lda $60,x			lda 	NSMantissa1,x
.8911	20 b2 a5	jsr $a5b2			jsr 	StackPushByte
.8914	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8916	20 b2 a5	jsr $a5b2			jsr 	StackPushByte
.8919	7a		ply				ply
.891a	60		rts				rts
.891b					_LNTError:
.891b	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError
.891e					LocalPopValue:
.891e	20 ca a5	jsr $a5ca			jsr 	StackPopByte
.8921	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8923	d0 17		bne $893c			bne 	_LPVString
.8925	20 ca a5	jsr $a5ca			jsr 	StackPopByte 				; address
.8928	85 37		sta $37				sta 	zTemp0+1
.892a	20 ca a5	jsr $a5ca			jsr 	StackPopByte
.892d	85 36		sta $36				sta 	zTemp0
.892f	5a		phy				phy
.8930	a0 04		ldy #$04			ldy 	#4 							; copy back
.8932					_LPVNumberCopy:
.8932	20 ca a5	jsr $a5ca			jsr 	StackPopByte
.8935	91 36		sta ($36),y			sta 	(zTemp0),y
.8937	88		dey				dey
.8938	10 f8		bpl $8932			bpl 	_LPVNumberCopy
.893a	7a		ply				ply 								; and complete
.893b	60		rts				rts
.893c					_LPVString:
.893c	20 ca a5	jsr $a5ca			jsr 	StackPopByte 				; address of record => zTemp0
.893f	85 37		sta $37				sta 	zTemp0+1
.8941	20 ca a5	jsr $a5ca			jsr 	StackPopByte
.8944	85 36		sta $36				sta 	zTemp0
.8946	5a		phy				phy
.8947	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8949	85 38		sta $38				sta 	zTemp1
.894b	a0 01		ldy #$01			ldy 	#1
.894d	b1 36		lda ($36),y			lda 	(zTemp0),y
.894f	85 39		sta $39				sta 	zTemp1+1
.8951	20 ca a5	jsr $a5ca			jsr 	StackPopByte 				; # to get => y
.8954	a8		tay				tay
.8955	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8957	f0 0e		beq $8967			beq 	_LPVStringCopied
.8959	a9 00		lda #$00			lda 	#0 							; NULL on end
.895b	91 38		sta ($38),y			sta 	(zTemp1),y
.895d					_LPVStringCopy:
.895d	88		dey				dey
.895e	30 07		bmi $8967			bmi 	_LPVStringCopied
.8960	20 ca a5	jsr $a5ca			jsr 	StackPopByte
.8963	91 38		sta ($38),y			sta 	(zTemp1),y
.8965	80 f6		bra $895d			bra 	_LPVStringCopy
.8967					_LPVStringCopied:
.8967	fa		plx				plx
.8968	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8969					NewCommand:
.8969	20 6f 89	jsr $896f			jsr 	NewProgram 					; does the actual NEW.
.896c	4c 46 83	jmp $8346			jmp 	WarmStart 					; and warm starts straight away.
.896f					NewProgram:
.896f	20 df a4	jsr $a4df			jsr 	MemoryNew
.8972	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8975	20 dc 83	jsr $83dc			jsr 	ClearCommand 				; clear everything.
.8978	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8979					CallProcedure:
.8979	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.897b	b1 30		lda ($30),y			lda 	(codePtr),y
.897d	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.897f	f0 0c		beq $898d			beq 	_CPEndParam
.8981					_CPParamLoop:
.8981	20 d6 9c	jsr $9cd6			jsr 	EvaluateValue 				; get parameter onto stack
.8984	e8		inx				inx 								; bump next stack
.8985	b1 30		lda ($30),y			lda 	(codePtr),y
.8987	c8		iny				iny
.8988	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.898a	f0 f5		beq $8981			beq 	_CPParamLoop
.898c	88		dey				dey 								; unpick.
.898d					_CPEndParam:
.898d	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8990	c8		iny				iny									; skip right bracket
.8991	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8993	20 d3 a5	jsr $a5d3			jsr 	StackOpen
.8996	20 18 a6	jsr $a618			jsr 	STKSaveCodePosition 		; save loop position
.8999	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.899b	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.899d	a5 60		lda $60				lda 	NSMantissa1
.899f	85 37		sta $37				sta 	zTemp0+1
.89a1	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.89a3	b2 36		lda ($36)			lda 	(zTemp0)
.89a5	85 30		sta $30				sta 	safePtr
.89a7	b1 36		lda ($36),y			lda 	(zTemp0),y
.89a9	85 31		sta $31				sta 	safePtr+1
.89ab	c8		iny				iny
.89ac	b1 36		lda ($36),y			lda 	(zTemp0),y
.89ae	85 32		sta $32				sta 	safePtr+2
.89b0	c8		iny				iny
.89b1	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b3	85 33		sta $33				sta 	safePtr+3
.89b5	c8		iny				iny 								; get Y offset -> Y
.89b6	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b8	a8		tay				tay
.89b9	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.89bb	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check no parameters at the start
.89be	f0 13		beq $89d3			beq 	_ParamExit 					; if so, exit.
.89c0					_ParamExtract:
.89c0	ca		dex				dex 								; put a local term on the level before
.89c1	20 b6 88	jsr $88b6			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.89c4	20 95 87	jsr $8795			jsr 	AssignVariable 				; assign stacked value to the variable.
.89c7	e8		inx				inx 								; advance to next parameter to do.
.89c8	e8		inx				inx
.89c9	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.89cc	f0 05		beq $89d3			beq 	_ParamExit
.89ce	20 73 8e	jsr $8e73			jsr 	CheckComma 					; comma seperating parameters
.89d1	80 ed		bra $89c0			bra 	_ParamExtract
.89d3					_ParamExit:
.89d3	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket 			; check )
.89d6	60		rts				rts 								; and continue from here
.89d7					Command_ENDPROC:
.89d7	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.89d9	a2 14		ldx #$14			ldx 	#ERRID_PROC
.89db	20 00 a6	jsr $a600			jsr 	StackCheckFrame
.89de	20 29 a6	jsr $a629			jsr 	STKLoadCodePosition 		; restore code position
.89e1	20 f2 a5	jsr $a5f2			jsr 	StackClose
.89e4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89e5					Command_Read:
.89e5	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89e7	20 d2 97	jsr $97d2			jsr 	EvaluateTerm
.89ea	b5 50		lda $50,x			lda 	NSStatus,x
.89ec	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89ee	f0 4a		beq $8a3a			beq 	_CRSyntax 					; check reference (bit 0)
.89f0	20 83 8a	jsr $8a83			jsr 	SwapDataCodePtrs 			; swap code and data
.89f3	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89f6	d0 20		bne $8a18			bne 	_CRContinueData
.89f8					_CRKeepSearching:
.89f8	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89fa	aa		tax				tax
.89fb	20 63 8d	jsr $8d63			jsr 	ScanForward
.89fe	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.8a00	f0 16		beq $8a18			beq 	_CRHaveData 				; found it
.8a02	18		clc				clc
.8a03	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a05	65 30		adc $30				adc 	codePtr
.8a07	85 30		sta $30				sta 	codePtr
.8a09	90 02		bcc $8a0d			bcc 	_CREExit
.8a0b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a0d					_CREExit:
.8a0d	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8a0f	b2 30		lda ($30)			lda 	(codePtr)
.8a11	d0 e5		bne $89f8			bne 	_CRKeepSearching
.8a13	a9 0b		lda #$0b		lda	#11
.8a15	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.8a18					_CRHaveData:
.8a18					_CRContinueData:
.8a18	a2 01		ldx #$01			ldx 	#1
.8a1a	20 d6 9c	jsr $9cd6			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a1d	ca		dex				dex
.8a1e	20 95 87	jsr $8795			jsr		AssignVariable 				; do the assignment
.8a21	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data
.8a24	b1 30		lda ($30),y			lda 	(codePtr),y
.8a26	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a28	d0 04		bne $8a2e			bne 	_CRSwapBack
.8a2a	c8		iny				iny 								; consume comma
.8a2b	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8a2e					_CRSwapBack:
.8a2e	20 83 8a	jsr $8a83			jsr 	SwapDataCodePtrs			; swap them back.
.8a31	b1 30		lda ($30),y			lda 	(codePtr),y
.8a33	c8		iny				iny
.8a34	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a36	f0 ad		beq $89e5			beq 	Command_Read 				; if so go round again.
.8a38	88		dey				dey 								; unpick get.
.8a39	60		rts				rts
.8a3a					_CRSyntax:
.8a3a	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a3d					RemCommand:
.8a3d	b1 30		lda ($30),y			lda 	(codePtr),y
.8a3f	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a41	d0 06		bne $8a49			bne 	_RMExit
.8a43	c8		iny				iny 								; point to offset
.8a44	98		tya				tya 								; A = offset position
.8a45	38		sec				sec 								; add size +1 hence SEC
.8a46	71 30		adc ($30),y			adc 	(codePtr),y
.8a48	a8		tay				tay 								; make current position.
.8a49					_RMExit:
.8a49	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a4a					Command_REPEAT:
.8a4a	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a4c	20 d3 a5	jsr $a5d3			jsr 	StackOpen
.8a4f	20 18 a6	jsr $a618			jsr 	STKSaveCodePosition 		; save loop position
.8a52	60		rts				rts
.8a53					Command_UNTIL:
.8a53	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a55	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a57	20 00 a6	jsr $a600			jsr 	StackCheckFrame
.8a5a	a2 00		ldx #$00			ldx 	#0
.8a5c	20 df 9c	jsr $9cdf			jsr 	EvaluateNumber 				; work out the number
.8a5f	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; check if zero
.8a62	f0 04		beq $8a68			beq 	_CULoopBack 				; if so keep looping
.8a64	20 f2 a5	jsr $a5f2			jsr 	StackClose		 			; return
.8a67	60		rts				rts
.8a68					_CULoopBack:
.8a68	20 29 a6	jsr $a629			jsr 	STKLoadCodePosition 		; loop back
.8a6b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a6c					Command_Restore:
.8a6c	20 83 8a	jsr $8a83			jsr 	SwapDataCodePtrs 			; swap code and data
.8a6f	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a71	85 30		sta $30				sta 	codePtr
.8a73	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a75	85 31		sta $31				sta 	codePtr+1
.8a77	20 83 8a	jsr $8a83			jsr 	SwapDataCodePtrs 			; put them back
.8a7a	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a7c	8d 1b 04	sta $041b			sta 	dataPointer+4
.8a7f	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8a82	60		rts				rts
.8a83					SwapDataCodePtrs:
.8a83	da		phx				phx
.8a84	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a86					_SDCPLoop:
.8a86	b5 30		lda $30,x			lda 	safePtr,x
.8a88	48		pha				pha
.8a89	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8a8c	95 30		sta $30,x			sta 	safePtr,x
.8a8e	68		pla				pla
.8a8f	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8a92	ca		dex				dex
.8a93	10 f1		bpl $8a86			bpl 	_SDCPLoop
.8a95	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8a98	8c 1b 04	sty $041b			sty 	dataPointer+4
.8a9b	a8		tay				tay
.8a9c	fa		plx				plx
.8a9d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a9e					EOLCommand:
.8a9e	18		clc				clc
.8a9f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8aa1	65 30		adc $30				adc 	codePtr
.8aa3	85 30		sta $30				sta 	codePtr
.8aa5	90 02		bcc $8aa9			bcc 	_CREExit
.8aa7	e6 31		inc $31				inc 	codePtr+1 					; carry
.8aa9					_CREExit:
.8aa9	80 0b		bra $8ab6			bra 	RunNewLine
.8aab					CommandRUN:
.8aab	20 dc 83	jsr $83dc			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8aae	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ab0	85 30		sta $30				sta 	codePtr
.8ab2	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8ab4	85 31		sta $31				sta 	codePtr+1
.8ab6					RUNNewLine:
.8ab6	b2 30		lda ($30)			lda 	(codePtr)
.8ab8	f0 75		beq $8b2f			beq 	CRNoProgram         		; no then END.
.8aba	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8abc	9a		txs				txs
.8abd					RUNCodePointerLine:
.8abd	a0 02		ldy #$02			ldy 	#2 							; start of program
.8abf					_CRIncMainLoop:
.8abf	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8ac2	d0 1c		bne $8ae0			bne 	_CRNoBreakCheck
.8ac4	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8ac7	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8aca	f0 5e		beq $8b2a			beq 	_CRBreak
.8acc	64 01		stz $01				stz 	1 							; access I/O Page 0
.8ace	38		sec				sec 								; calculate timer - LastTick
.8acf	ad 59 d6	lda $d659			lda 	$D659
.8ad2	aa		tax				tax 								; saving timer in X
.8ad3	ed af 05	sbc $05af			sbc 	LastTick
.8ad6	c9 03		cmp #$03			cmp 	#3
.8ad8	90 06		bcc $8ae0			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8ada	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.8add	20 bc 9d	jsr $9dbc			jsr 	TickHandler 							; go do the code.
.8ae0					_NoFireTick:
.8ae0					_CRNoBreakCheck:
.8ae0	c8		iny				iny									; next token
.8ae1					_CRMainLoop:
.8ae1	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8ae4	b1 30		lda ($30),y			lda 	(codePtr),y
.8ae6	10 10		bpl $8af8			bpl 	_CRNotKeyword				; not a token.
.8ae8	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8aea	b0 04		bcs $8af0			bcs 	_CRIsKeyword
.8aec	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8aee	b0 34		bcs $8b24			bcs		_CRSyntaxError
.8af0					_CRIsKeyword:
.8af0	c8		iny				iny 								; consume command
.8af1	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8af2	aa		tax				tax 								; put in X for vector jump
.8af3	20 27 8b	jsr $8b27			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8af6	80 e9		bra $8ae1			bra 	_CRMainLoop 				; and loop round
.8af8					_CRNotKeyword:
.8af8	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8afa	f0 c3		beq $8abf			beq 	_CRIncMainLoop
.8afc	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8afe	90 05		bcc $8b05			bcc 	_CRNotVariable
.8b00					_CRGoLet:
.8b00	20 5c 87	jsr $875c			jsr 	LetCommand
.8b03	80 dc		bra $8ae1			bra 	_CRMainLoop
.8b05					_CRNotVariable:
.8b05	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8b07	f0 f7		beq $8b00			beq 	_CRGoLet
.8b09	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8b0b	f0 f3		beq $8b00			beq 	_CRGoLet
.8b0d	c9 21		cmp #$21			cmp 	#KWD_PLING
.8b0f	f0 ef		beq $8b00			beq 	_CRGoLet
.8b11	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8b13	f0 09		beq $8b1e			beq 	_CRGoRem
.8b15	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8b17	d0 0b		bne $8b24			bne 	_CRSyntaxError
.8b19	20 df 81	jsr $81df			jsr 	LabelHere
.8b1c	80 c3		bra $8ae1			bra 	_CRMainLoop
.8b1e					_CRGoRem:
.8b1e	c8		iny				iny
.8b1f	20 3d 8a	jsr $8a3d			jsr 	RemCommand
.8b22	80 bd		bra $8ae1			bra 	_CRMainLoop
.8b24					_CRSyntaxError:
.8b24	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError
.8b27					_CRCallVector0:
.8b27	7c c6 8b	jmp ($8bc6,x)			jmp 	(VectorSet0,x)
.8b2a					_CRBreak:
.8b2a	a9 01		lda #$01		lda	#1
.8b2c	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.8b2f					CRNoProgram:
.8b2f	4c 01 85	jmp $8501			jmp 	EndCommand
.8b32					Shift1Command:
.8b32	b1 30		lda ($30),y			lda 	(codePtr),y
.8b34	c8		iny				iny
.8b35	0a		asl a				asl 	a
.8b36	aa		tax				tax
.8b37	7c 64 8c	jmp ($8c64,x)			jmp 	(VectorSet1,x)
.8b3a					Shift2Command:
.8b3a	b1 30		lda ($30),y			lda 	(codePtr),y
.8b3c	c8		iny				iny
.8b3d	0a		asl a				asl 	a
.8b3e	aa		tax				tax
.8b3f	7c 84 8c	jmp ($8c84,x)			jmp 	(VectorSet2,x)
.8b42					Unused1:
.8b42					Unused2:
.8b42					Unused3:
.8b42					Unused4:
.8b42	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError
>8b45							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b46					VectorSetPunc:
>8b46	3c 91					.word	ShiftLeft                        ; $00 <<
>8b48	27 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8b4a	1d 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8b4c	0f 9f					.word	SyntaxError                      ; $03 !!3
>8b4e	0f 9f					.word	SyntaxError                      ; $04 ><
>8b50	31 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b52	3f 91					.word	ShiftRight                       ; $06 >>
>8b54	0f 9f					.word	SyntaxError                      ; $07 !!7
>8b56	0f 9f					.word	SyntaxError                      ; $08 !!8
>8b58	0f 9f					.word	SyntaxError                      ; $09 !!9
>8b5a	0f 9f					.word	SyntaxError                      ; $0a !!10
>8b5c	0f 9f					.word	SyntaxError                      ; $0b !!11
>8b5e	0f 9f					.word	SyntaxError                      ; $0c !!12
>8b60	0f 9f					.word	SyntaxError                      ; $0d !!13
>8b62	0f 9f					.word	SyntaxError                      ; $0e !!14
>8b64	0f 9f					.word	SyntaxError                      ; $0f !!15
>8b66	0f 9f					.word	SyntaxError                      ; $10 @
>8b68	0f 9f					.word	SyntaxError                      ; $11 !!17
>8b6a	0f 9f					.word	SyntaxError                      ; $12 !!18
>8b6c	0f 9f					.word	SyntaxError                      ; $13 [
>8b6e	e8 8f					.word	IntegerDivide                    ; $14 \
>8b70	0f 9f					.word	SyntaxError                      ; $15 ]
>8b72	7a 92					.word	EorInteger                       ; $16 ^
>8b74	0f 9f					.word	SyntaxError                      ; $17 _
>8b76	0f 9f					.word	SyntaxError                      ; $18 `
>8b78	0f 9f					.word	SyntaxError                      ; $19 !!25
>8b7a	0f 9f					.word	SyntaxError                      ; $1a !!26
>8b7c	0f 9f					.word	SyntaxError                      ; $1b {
>8b7e	45 92					.word	OraInteger                       ; $1c |
>8b80	0f 9f					.word	SyntaxError                      ; $1d }
>8b82	0f 9f					.word	SyntaxError                      ; $1e ~
>8b84	0f 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b86	0f 9f					.word	SyntaxError                      ; $20
>8b88	af 92					.word	WordIndirect                     ; $21 !
>8b8a	0f 9f					.word	SyntaxError                      ; $22 "
>8b8c	0f 9f					.word	SyntaxError                      ; $23 #
>8b8e	0f 9f					.word	SyntaxError                      ; $24 $
>8b90	29 90					.word	IntegerModulus                   ; $25 %
>8b92	10 92					.word	AndInteger                       ; $26 &
>8b94	0f 9f					.word	SyntaxError                      ; $27 '
>8b96	0f 9f					.word	SyntaxError                      ; $28 (
>8b98	0f 9f					.word	SyntaxError                      ; $29 )
>8b9a	97 90					.word	MulInteger                       ; $2a *
>8b9c	b2 91					.word	AddInteger                       ; $2b +
>8b9e	0f 9f					.word	SyntaxError                      ; $2c ,
>8ba0	eb 91					.word	SubInteger                       ; $2d -
>8ba2	0f 9f					.word	SyntaxError                      ; $2e .
>8ba4	69 94					.word	FDivideCommand                   ; $2f /
>8ba6	0f 9f					.word	SyntaxError                      ; $30 0
>8ba8	0f 9f					.word	SyntaxError                      ; $31 1
>8baa	0f 9f					.word	SyntaxError                      ; $32 2
>8bac	0f 9f					.word	SyntaxError                      ; $33 3
>8bae	0f 9f					.word	SyntaxError                      ; $34 4
>8bb0	0f 9f					.word	SyntaxError                      ; $35 5
>8bb2	0f 9f					.word	SyntaxError                      ; $36 6
>8bb4	0f 9f					.word	SyntaxError                      ; $37 7
>8bb6	0f 9f					.word	SyntaxError                      ; $38 8
>8bb8	0f 9f					.word	SyntaxError                      ; $39 9
>8bba	0f 9f					.word	SyntaxError                      ; $3a :
>8bbc	0f 9f					.word	SyntaxError                      ; $3b ;
>8bbe	09 8f					.word	BinaryCompareLess                ; $3c <
>8bc0	ff 8e					.word	BinaryCompareEqual               ; $3d =
>8bc2	13 8f					.word	BinaryCompareGreater             ; $3e >
>8bc4	d1 92					.word	ByteIndirect                     ; $3f ?
.8bc6					VectorSet0:
>8bc6	9e 8a					.word	EOLCommand                       ; $80 !0:EOF
>8bc8	32 8b					.word	Shift1Command                    ; $81 !1:SH1
>8bca	3a 8b					.word	Shift2Command                    ; $82 !2:SH2
>8bcc	4e 99					.word	AbsUnary                         ; $83 ABS(
>8bce	5c 99					.word	AllocUnary                       ; $84 ALLOC(
>8bd0	cc 99					.word	AscUnary                         ; $85 ASC(
>8bd2	77 9b					.word	ChrUnary                         ; $86 CHR$(
>8bd4	5f a3					.word	UnaryEvent                       ; $87 EVENT(
>8bd6	fb 8e					.word	UnaryFalse                       ; $88 FALSE
>8bd8	d9 99					.word	FracUnary                        ; $89 FRAC(
>8bda	fb a2					.word	UnaryHit                         ; $8a HIT(
>8bdc	ee 99					.word	IntUnary                         ; $8b INT(
>8bde	36 9b					.word	IsValUnary                       ; $8c ISVAL(
>8be0	e3 a3					.word	UnaryJoyB                        ; $8d JOYB(
>8be2	bc a3					.word	UnaryJoyX                        ; $8e JOYX(
>8be4	bf a3					.word	UnaryJoyY                        ; $8f JOYY(
>8be6	4a 9c					.word	Unary_Left                       ; $90 LEFT$(
>8be8	ff 99					.word	LenUnary                         ; $91 LEN(
>8bea	1d 9a					.word	Unary_Max                        ; $92 MAX(
>8bec	6c 9c					.word	Unary_Mid                        ; $93 MID$(
>8bee	19 9a					.word	Unary_Min                        ; $94 MIN(
>8bf0	68 9a					.word	Unary_Not                        ; $95 NOT(
>8bf2	30 a5					.word	UnaryPlaying                     ; $96 PLAYING(
>8bf4	7b 9a					.word	Unary_Random                     ; $97 RANDOM(
>8bf6	57 9c					.word	Unary_Right                      ; $98 RIGHT$(
>8bf8	98 9a					.word	Unary_Rnd                        ; $99 RND(
>8bfa	0e 9b					.word	SgnUnary                         ; $9a SGN(
>8bfc	89 9b					.word	SpcUnary                         ; $9b SPC(
>8bfe	a4 9b					.word	Unary_Str                        ; $9c STR$(
>8c00	09 a4					.word	UnaryTimer                       ; $9d TIMER(
>8c02	f0 8e					.word	UnaryTrue                        ; $9e TRUE
>8c04	2c 9b					.word	ValUnary                         ; $9f VAL(
>8c06	04 85					.word	ForCommand                       ; $a0 FOR
>8c08	47 86					.word	IfCommand                        ; $a1 IF
>8c0a	42 8b					.word	Unused1                          ; $a2 PROC
>8c0c	4a 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8c0e	d9 8d					.word	Command_WHILE                    ; $a4 WHILE
>8c10	70 86					.word	EndIf                            ; $a5 ENDIF
>8c12	d7 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8c14	b6 85					.word	NextCommand                      ; $a7 NEXT
>8c16	42 8b					.word	Unused4                          ; $a8 THEN
>8c18	53 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8c1a	fa 8d					.word	Command_WEND                     ; $aa WEND
>8c1c	0f 9f					.word	SyntaxError                      ; $ab BY
>8c1e	a7 83					.word	CallCommand                      ; $ac CALL
>8c20	af a0					.word	CircleCommand                    ; $ad CIRCLE
>8c22	dc 83					.word	ClearCommand                     ; $ae CLEAR
>8c24	34 84					.word	ClearScreen                      ; $af CLS
>8c26	0f 9f					.word	SyntaxError                      ; $b0 COLOR
>8c28	0f 9f					.word	SyntaxError                      ; $b1 COLOUR
>8c2a	3c 84					.word	Command_Data                     ; $b2 DATA
>8c2c	44 84					.word	DimCommand                       ; $b3 DIM
>8c2e	42 8b					.word	Unused3                          ; $b4 DOWNTO
>8c30	69 86					.word	ElseCode                         ; $b5 ELSE
>8c32	0f 9f					.word	SyntaxError                      ; $b6 FROM
>8c34	ce a2					.word	GfxCommand                       ; $b7 GFX
>8c36	0f 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c38	2d 86					.word	GotoCommand                      ; $b9 GOTO
>8c3a	0f 9f					.word	SyntaxError                      ; $ba HERE
>8c3c	d8 a0					.word	ImageCommand                     ; $bb IMAGE
>8c3e	71 86					.word	Command_Input                    ; $bc INPUT
>8c40	5c 87					.word	LetCommand                       ; $bd LET
>8c42	2a a1					.word	LineCommand                      ; $be LINE
>8c44	a8 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c46	0f 9f					.word	SyntaxError                      ; $c0 OFF
>8c48	0f 9f					.word	SyntaxError                      ; $c1 ON
>8c4a	0f 9f					.word	SyntaxError                      ; $c2 OUTLINE
>8c4c	1f a3					.word	PaletteCommand                   ; $c3 PALETTE
>8c4e	23 a1					.word	PlotCommand                      ; $c4 PLOT
>8c50	78 86					.word	Command_Print                    ; $c5 PRINT
>8c52	e5 89					.word	Command_Read                     ; $c6 READ
>8c54	ab a0					.word	RectangleCommand                 ; $c7 RECT
>8c56	3d 8a					.word	RemCommand                       ; $c8 REM
>8c58	1f 86					.word	Command_RETURN                   ; $c9 RETURN
>8c5a	0f 9f					.word	SyntaxError                      ; $ca SOLID
>8c5c	4c a5					.word	SoundCommand                     ; $cb SOUND
>8c5e	ba a0					.word	SpriteCommand                    ; $cc SPRITE
>8c60	f4 a0					.word	TextCommand                      ; $cd TEXT
>8c62	42 8b					.word	Unused2                          ; $ce TO
.8c64					VectorSet1:
>8c64	0f 9f					.word	SyntaxError                      ; $80 !0:EOF
>8c66	0f 9f					.word	SyntaxError                      ; $81 !1:SH1
>8c68	0f 9f					.word	SyntaxError                      ; $82 !2:SH2
>8c6a	7b 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c6c	97 83					.word	AssertCommand                    ; $84 ASSERT
>8c6e	6e a2					.word	BitmapCtrl                       ; $85 BITMAP
>8c70	01 85					.word	EndCommand                       ; $86 END
>8c72	00 a4					.word	GoCommand                        ; $87 GO
>8c74	ac 87					.word	Command_List                     ; $88 LIST
>8c76	f7 a3					.word	LoadCommand                      ; $89 LOAD
>8c78	69 89					.word	NewCommand                       ; $8a NEW
>8c7a	6c 8a					.word	Command_Restore                  ; $8b RESTORE
>8c7c	ab 8a					.word	CommandRUN                       ; $8c RUN
>8c7e	b3 a2					.word	SpritesCtrl                      ; $8d SPRITES
>8c80	0c 8d					.word	StopCommand                      ; $8e STOP
>8c82	08 8e					.word	WhoCommand                       ; $8f WHO
.8c84					VectorSet2:
>8c84	0f 9f					.word	SyntaxError                      ; $80 !0:EOF
>8c86	0f 9f					.word	SyntaxError                      ; $81 !1:SH1
>8c88	0f 9f					.word	SyntaxError                      ; $82 !2:SH2
>8c8a	ce 9d					.word	Assemble_adc                     ; $83 ADC
>8c8c	c6 9d					.word	Assemble_and                     ; $84 AND
>8c8e	e2 9d					.word	Assemble_asl                     ; $85 ASL
>8c90	4c 9e					.word	Assemble_bcc                     ; $86 BCC
>8c92	50 9e					.word	Assemble_bcs                     ; $87 BCS
>8c94	58 9e					.word	Assemble_beq                     ; $88 BEQ
>8c96	0f 9e					.word	Assemble_bit                     ; $89 BIT
>8c98	40 9e					.word	Assemble_bmi                     ; $8a BMI
>8c9a	54 9e					.word	Assemble_bne                     ; $8b BNE
>8c9c	3c 9e					.word	Assemble_bpl                     ; $8c BPL
>8c9e	5c 9e					.word	Assemble_bra                     ; $8d BRA
>8ca0	60 9e					.word	Assemble_brk                     ; $8e BRK
>8ca2	44 9e					.word	Assemble_bvc                     ; $8f BVC
>8ca4	48 9e					.word	Assemble_bvs                     ; $90 BVS
>8ca6	68 9e					.word	Assemble_clc                     ; $91 CLC
>8ca8	bc 9e					.word	Assemble_cld                     ; $92 CLD
>8caa	7c 9e					.word	Assemble_cli                     ; $93 CLI
>8cac	ac 9e					.word	Assemble_clv                     ; $94 CLV
>8cae	da 9d					.word	Assemble_cmp                     ; $95 CMP
>8cb0	23 9e					.word	Assemble_cpx                     ; $96 CPX
>8cb2	1e 9e					.word	Assemble_cpy                     ; $97 CPY
>8cb4	00 9e					.word	Assemble_dec                     ; $98 DEC
>8cb6	b8 9e					.word	Assemble_dex                     ; $99 DEX
>8cb8	94 9e					.word	Assemble_dey                     ; $9a DEY
>8cba	ca 9d					.word	Assemble_eor                     ; $9b EOR
>8cbc	05 9e					.word	Assemble_inc                     ; $9c INC
>8cbe	c8 9e					.word	Assemble_inx                     ; $9d INX
>8cc0	b4 9e					.word	Assemble_iny                     ; $9e INY
>8cc2	37 9e					.word	Assemble_jmp                     ; $9f JMP
>8cc4	32 9e					.word	Assemble_jsr                     ; $a0 JSR
>8cc6	d6 9d					.word	Assemble_lda                     ; $a1 LDA
>8cc8	fb 9d					.word	Assemble_ldx                     ; $a2 LDX
>8cca	19 9e					.word	Assemble_ldy                     ; $a3 LDY
>8ccc	ec 9d					.word	Assemble_lsr                     ; $a4 LSR
>8cce	cc 9e					.word	Assemble_nop                     ; $a5 NOP
>8cd0	c2 9d					.word	Assemble_ora                     ; $a6 ORA
>8cd2	78 9e					.word	Assemble_pha                     ; $a7 PHA
>8cd4	64 9e					.word	Assemble_php                     ; $a8 PHP
>8cd6	c0 9e					.word	Assemble_phx                     ; $a9 PHX
>8cd8	80 9e					.word	Assemble_phy                     ; $aa PHY
>8cda	88 9e					.word	Assemble_pla                     ; $ab PLA
>8cdc	6c 9e					.word	Assemble_plp                     ; $ac PLP
>8cde	d4 9e					.word	Assemble_plx                     ; $ad PLX
>8ce0	90 9e					.word	Assemble_ply                     ; $ae PLY
>8ce2	e7 9d					.word	Assemble_rol                     ; $af ROL
>8ce4	f1 9d					.word	Assemble_ror                     ; $b0 ROR
>8ce6	74 9e					.word	Assemble_rti                     ; $b1 RTI
>8ce8	84 9e					.word	Assemble_rts                     ; $b2 RTS
>8cea	de 9d					.word	Assemble_sbc                     ; $b3 SBC
>8cec	70 9e					.word	Assemble_sec                     ; $b4 SEC
>8cee	d0 9e					.word	Assemble_sed                     ; $b5 SED
>8cf0	8c 9e					.word	Assemble_sei                     ; $b6 SEI
>8cf2	d2 9d					.word	Assemble_sta                     ; $b7 STA
>8cf4	c4 9e					.word	Assemble_stp                     ; $b8 STP
>8cf6	f6 9d					.word	Assemble_stx                     ; $b9 STX
>8cf8	14 9e					.word	Assemble_sty                     ; $ba STY
>8cfa	0a 9e					.word	Assemble_stz                     ; $bb STZ
>8cfc	a8 9e					.word	Assemble_tax                     ; $bc TAX
>8cfe	a4 9e					.word	Assemble_tay                     ; $bd TAY
>8d00	2d 9e					.word	Assemble_trb                     ; $be TRB
>8d02	28 9e					.word	Assemble_tsb                     ; $bf TSB
>8d04	b0 9e					.word	Assemble_tsx                     ; $c0 TSX
>8d06	98 9e					.word	Assemble_txa                     ; $c1 TXA
>8d08	a0 9e					.word	Assemble_txs                     ; $c2 TXS
>8d0a	9c 9e					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8d0c					StopCommand:
.8d0c	a9 08		lda #$08		lda	#8
.8d0e	4c 84 8e	jmp $8e84		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8d11					ProcedureScan:
.8d11	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8d13	85 30		sta $30				sta 	codePtr
.8d15	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8d17	85 31		sta $31				sta 	codePtr+1
.8d19					_PSLoop:
.8d19	b2 30		lda ($30)			lda 	(codePtr)
.8d1b	f0 42		beq $8d5f			beq 	_PSExit
.8d1d	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8d1f	b1 30		lda ($30),y			lda 	(codePtr),y
.8d21	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8d23	d0 2d		bne $8d52			bne 	_PSNext
.8d25	c8		iny				iny 								; get the address of the record to zTemp0 and
.8d26	b1 30		lda ($30),y			lda 	(codePtr),y
.8d28	29 c0		and #$c0			and 	#$C0
.8d2a	c9 40		cmp #$40			cmp 	#$40
.8d2c	d0 32		bne $8d60			bne 	_PSSyntax
.8d2e	b1 30		lda ($30),y			lda 	(codePtr),y
.8d30	18		clc				clc
.8d31	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d33	85 37		sta $37				sta 	zTemp0+1
.8d35	c8		iny				iny 								; LSB
.8d36	b1 30		lda ($30),y			lda 	(codePtr),y
.8d38	85 36		sta $36				sta 	zTemp0
.8d3a	c8		iny				iny 								; character after variable call.
.8d3b	98		tya				tya 								; save Y offset at +7
.8d3c	a0 07		ldy #$07			ldy 	#7
.8d3e	91 36		sta ($36),y			sta 	(zTemp0),y
.8d40	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d42	a0 02		ldy #$02			ldy 	#2
.8d44	91 36		sta ($36),y			sta 	(zTemp0),y
.8d46	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d48					_PSCopy:
.8d48	b5 30		lda $30,x			lda 	safePtr,x
.8d4a	c8		iny				iny
.8d4b	91 36		sta ($36),y			sta 	(zTemp0),y
.8d4d	e8		inx				inx
.8d4e	e0 04		cpx #$04			cpx 	#4
.8d50	d0 f6		bne $8d48			bne 	_PSCopy
.8d52					_PSNext:
.8d52	18		clc				clc
.8d53	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d55	65 30		adc $30				adc 	codePtr
.8d57	85 30		sta $30				sta 	codePtr
.8d59	90 02		bcc $8d5d			bcc 	_CREExit
.8d5b	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d5d					_CREExit:
.8d5d	80 ba		bra $8d19			bra 	_PSLoop
.8d5f					_PSExit:
.8d5f	60		rts				rts
.8d60					_PSSyntax:
.8d60	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d63					ScanForward:
.8d63	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d65	86 37		stx $37				stx 	zTemp0+1
.8d67	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d69					_ScanLoop:
.8d69	b1 30		lda ($30),y			lda 	(codePtr),y
.8d6b	c8		iny				iny
.8d6c	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d6e	d0 0e		bne $8d7e			bne 	_ScanGoNext
.8d70	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d72	f0 04		beq $8d78			beq 	_ScanMatch
.8d74	c5 37		cmp $37				cmp 	zTemp0+1
.8d76	d0 06		bne $8d7e			bne 	_ScanGoNext
.8d78					_ScanMatch:
.8d78	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d7a	d0 01		bne $8d7d			bne 	_ScanNotEndEOL
.8d7c	88		dey				dey
.8d7d					_ScanNotEndEOL:
.8d7d	60		rts				rts
.8d7e					_ScanGoNext:
.8d7e	20 83 8d	jsr $8d83			jsr  	ScanForwardOne
.8d81	80 e6		bra $8d69			bra 	_ScanLoop
.8d83					ScanForwardOne:
.8d83	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d85	90 3e		bcc $8dc5			bcc 	_SFWExit
.8d87	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d89	90 18		bcc $8da3			bcc 	_ScanSkipOne
.8d8b	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d8d	b0 2f		bcs $8dbe			bcs 	_ScanSkipData
.8d8f	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d91	90 32		bcc $8dc5			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d93	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d95	b0 2e		bcs $8dc5			bcs 	_SFWExit
.8d97	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d99	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d9b	b0 28		bcs $8dc5			bcs 	_SFWExit
.8d9d	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d9f	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8da1	80 22		bra $8dc5			bra 	_SFWExit
.8da3					_ScanSkipOne:
.8da3	c8		iny				iny 								; consume the extra one.
.8da4	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8da6	d0 1d		bne $8dc5			bne 	_SFWExit
.8da8	18		clc				clc
.8da9	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8dab	65 30		adc $30				adc 	codePtr
.8dad	85 30		sta $30				sta 	codePtr
.8daf	90 02		bcc $8db3			bcc 	_CREExit
.8db1	e6 31		inc $31				inc 	codePtr+1 					; carry
.8db3					_CREExit:
.8db3	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8db5	b2 30		lda ($30)			lda 	(codePtr)
.8db7	d0 0c		bne $8dc5			bne 	_SFWExit 					; if not zero, more to scan
.8db9	a9 13		lda #$13		lda	#19
.8dbb	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.8dbe					_ScanSkipData:
.8dbe	88		dey				dey 								; point at data token
.8dbf	c8		iny				iny 								; point to offset
.8dc0	98		tya				tya 								; A = offset position
.8dc1	38		sec				sec 								; add size +1 hence SEC
.8dc2	71 30		adc ($30),y			adc 	(codePtr),y
.8dc4	a8		tay				tay 								; make current position.
.8dc5					_SFWExit:
.8dc5	60		rts				rts
.8dc6					ScanGetCurrentLineStep:
.8dc6	64 38		stz $38				stz 	zTemp1
.8dc8	a0 03		ldy #$03			ldy 	#3
.8dca					_SGCLSLoop:
.8dca	b1 30		lda ($30),y			lda 	(codePtr),y
.8dcc	c8		iny				iny
.8dcd	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8dcf	f0 05		beq $8dd6			beq 	_SGCLSExit
.8dd1	20 83 8d	jsr $8d83			jsr 	ScanForwardOne
.8dd4	80 f4		bra $8dca			bra 	_SGCLSLoop
.8dd6					_SGCLSExit:
.8dd6	a5 38		lda $38				lda 	zTemp1
.8dd8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8dd9					Command_WHILE:
.8dd9	5a		phy				phy 								; save position of the test
.8dda	a2 00		ldx #$00			ldx 	#0
.8ddc	20 df 9c	jsr $9cdf			jsr 	EvaluateNumber 				; work out the number
.8ddf	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; check if zero
.8de2	f0 0e		beq $8df2			beq 	_WHExitLoop 				; if so exit the loop
.8de4	98		tya				tya 								; position *after* test.
.8de5	7a		ply				ply 								; restore position before test, at WHILE
.8de6	88		dey				dey
.8de7	48		pha				pha 								; push after test on the stack
.8de8	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8dea	20 d3 a5	jsr $a5d3			jsr 	StackOpen
.8ded	20 18 a6	jsr $a618			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8df0	7a		ply				ply 								; restore the position *after* the test
.8df1	60		rts				rts
.8df2					_WHExitLoop:
.8df2	68		pla				pla 								; throw post loop position
.8df3	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8df5	aa		tax				tax
.8df6	20 63 8d	jsr $8d63			jsr 	ScanForward
.8df9	60		rts				rts
.8dfa					Command_WEND:
.8dfa	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8dfc	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8dfe	20 00 a6	jsr $a600			jsr 	StackCheckFrame
.8e01	20 29 a6	jsr $a629			jsr 	STKLoadCodePosition 		; loop back
.8e04	20 f2 a5	jsr $a5f2			jsr 	StackClose		 			; erase the frame
.8e07	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8e08					WhoCommand:
.8e08	a2 8e		ldx #$8e			ldx 	#(_WHOMessage >> 8)
.8e0a	a9 10		lda #$10			lda 	#(_WHOMessage & $FF)
.8e0c	20 dd 8e	jsr $8edd			jsr 	PrintStringXA
.8e0f	60		rts				rts
.8e10					_WHOMessage:
>8e10	81						.byte 	$81
>8e11	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8e19	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8e26	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8e2e	20 41 6c 6c 61 69 72 65 0d
>8e37	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8e3f	4f 62 65 72 72 65 75 74 65 72 0d
>8e4a	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8e52	62 73 6f 6e 0d
>8e57	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8e5f	65 69 6e 67 61 72 74 6e 65 72 0d
>8e6a	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8e6b					CheckRightBracket:
.8e6b	b1 30		lda ($30),y			lda 	(codePtr),y
.8e6d	c8		iny				iny
.8e6e	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8e70	d0 0f		bne $8e81			bne 	CNAFail
.8e72	60		rts				rts
.8e73					CheckComma:
.8e73	b1 30		lda ($30),y			lda 	(codePtr),y
.8e75	c8		iny				iny
.8e76	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8e78	d0 07		bne $8e81			bne 	CNAFail
.8e7a	60		rts				rts
.8e7b					CheckNextA:
.8e7b	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8e7d	d0 02		bne $8e81			bne 	CNAFail
.8e7f	c8		iny				iny 								; skip character
.8e80	60		rts				rts 								; and exit
.8e81					CNAFail:
.8e81	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8e84					ErrorHandler:
.8e84	a8		tay				tay 								; find the error text
.8e85	f0 49		beq $8ed0			beq 	_EHEnd
.8e87	a2 00		ldx #$00			ldx 	#0
.8e89	a9 28		lda #$28			lda 	#((ErrorText) & $FF)
.8e8b	85 36		sta $36				sta 	0+zTemp0
.8e8d	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8e8f	85 37		sta $37				sta 	1+zTemp0
.8e91					_EHFind:
.8e91	88		dey				dey 								; keep looking through text
.8e92	f0 0e		beq $8ea2			beq 	_EHFound
.8e94					_EHFindZero:
.8e94	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e96	e6 36		inc $36				inc 	zTemp0
.8e98	d0 02		bne $8e9c			bne 	_EHFNoCarry
.8e9a	e6 37		inc $37				inc 	zTemp0+1
.8e9c					_EHFNoCarry:
.8e9c	c9 00		cmp #$00			cmp 	#0
.8e9e	d0 f4		bne $8e94			bne 	_EHFindZero
.8ea0	80 ef		bra $8e91			bra 	_EHFind
.8ea2					_EHFound:
.8ea2	a5 36		lda $36				lda 	zTemp0 						; print message
.8ea4	a6 37		ldx $37				ldx 	zTemp0+1
.8ea6	20 dd 8e	jsr $8edd			jsr 	PrintStringXA
.8ea9	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8eab	b1 30		lda ($30),y			lda 	(codePtr),y
.8ead	d0 05		bne $8eb4			bne 	_EHAtMsg
.8eaf	c8		iny				iny
.8eb0	b1 30		lda ($30),y			lda 	(codePtr),y
.8eb2	f0 17		beq $8ecb			beq 	_EHCREnd
.8eb4					_EHAtMsg:
.8eb4	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8eb6	a9 d3		lda #$d3			lda 	#_AtMsg & $FF
.8eb8	20 dd 8e	jsr $8edd			jsr 	PrintStringXA
.8ebb	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8ebd	b1 30		lda ($30),y			lda 	(codePtr),y
.8ebf	48		pha				pha
.8ec0	c8		iny				iny
.8ec1	b1 30		lda ($30),y			lda 	(codePtr),y
.8ec3	aa		tax				tax
.8ec4	68		pla				pla
.8ec5	20 f3 92	jsr $92f3			jsr 	ConvertInt16 				; convert XA to string
.8ec8	20 dd 8e	jsr $8edd			jsr 	PrintStringXA 				; and print it.
.8ecb					_EHCREnd:
.8ecb	a9 0d		lda #$0d			lda 	#13 						; new line
.8ecd	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8ed0					_EHEnd:
.8ed0	4c 46 83	jmp $8346			jmp 	WarmStart
>8ed3	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8edb	20 00
.8edd					PrintStringXA:
.8edd	5a		phy				phy
.8ede	86 37		stx $37				stx 	zTemp0+1
.8ee0	85 36		sta $36				sta 	zTemp0
.8ee2	a0 00		ldy #$00			ldy 	#0
.8ee4					_PSXALoop:
.8ee4	b1 36		lda ($36),y			lda 	(zTemp0),y
.8ee6	f0 06		beq $8eee			beq 	_PSXAExit
.8ee8	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8eeb	c8		iny				iny
.8eec	80 f6		bra $8ee4			bra 	_PSXALoop
.8eee					_PSXAExit:
.8eee	7a		ply				ply
.8eef	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8ef0					UnaryTrue:
.8ef0	fa		plx				plx
.8ef1					ReturnTrue:
.8ef1	a9 01		lda #$01			lda 	#1  						; set to 1
.8ef3	20 93 9d	jsr $9d93			jsr 	NSMSetByte
.8ef6	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8ef8	95 50		sta $50,x			sta 	NSStatus,x
.8efa	60		rts				rts
.8efb					UnaryFalse:
.8efb	fa		plx				plx
.8efc					ReturnFalse:
.8efc	4c 91 9d	jmp $9d91			jmp 	NSMSetZero 					; set it all to zero
.8eff					BinaryCompareEqual:
.8eff	fa		plx				plx
.8f00	20 3b 8f	jsr $8f3b			jsr 	CompareBaseCode
.8f03	c9 00		cmp #$00			cmp 	#0
.8f05	f0 ea		beq $8ef1			beq 	ReturnTrue
.8f07	80 f3		bra $8efc			bra 	ReturnFalse
.8f09					BinaryCompareLess:
.8f09	fa		plx				plx
.8f0a	20 3b 8f	jsr $8f3b			jsr 	CompareBaseCode
.8f0d	c9 ff		cmp #$ff			cmp 	#$FF
.8f0f	f0 e0		beq $8ef1			beq 	ReturnTrue
.8f11	80 e9		bra $8efc			bra 	ReturnFalse
.8f13					BinaryCompareGreater:
.8f13	fa		plx				plx
.8f14	20 3b 8f	jsr $8f3b			jsr 	CompareBaseCode
.8f17	c9 01		cmp #$01			cmp 	#1
.8f19	f0 d6		beq $8ef1			beq 	ReturnTrue
.8f1b	80 df		bra $8efc			bra 	ReturnFalse
.8f1d					BinaryCompareNotEqual:
.8f1d	fa		plx				plx
.8f1e	20 3b 8f	jsr $8f3b			jsr 	CompareBaseCode
.8f21	c9 00		cmp #$00			cmp 	#0
.8f23	d0 cc		bne $8ef1			bne 	ReturnTrue
.8f25	80 d5		bra $8efc			bra 	ReturnFalse
.8f27					BinaryCompareLessEqual:
.8f27	fa		plx				plx
.8f28	20 3b 8f	jsr $8f3b			jsr 	CompareBaseCode
.8f2b	c9 01		cmp #$01			cmp 	#1
.8f2d	d0 c2		bne $8ef1			bne 	ReturnTrue
.8f2f	80 cb		bra $8efc			bra 	ReturnFalse
.8f31					BinaryCompareGreaterEqual:
.8f31	fa		plx				plx
.8f32	20 3b 8f	jsr $8f3b			jsr 	CompareBaseCode
.8f35	c9 ff		cmp #$ff			cmp 	#$FF
.8f37	d0 b8		bne $8ef1			bne 	ReturnTrue
.8f39	80 c1		bra $8efc			bra 	ReturnFalse
.8f3b					CompareBaseCode:
.8f3b	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; make both values if references.
.8f3e	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8f40	15 51		ora $51,x			ora 	NSStatus+1,x
.8f42	29 10		and #$10			and 	#NSTString
.8f44	d0 37		bne $8f7d			bne 	_CBCString 					; if so do string code, which will check if both.
.8f46	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8f48	15 79		ora $79,x			ora 	NSExponent+1,x
.8f4a	d0 34		bne $8f80			bne 	_CBCFloat
.8f4c	b5 50		lda $50,x			lda 	NSStatus,x
.8f4e	15 51		ora $51,x			ora 	NSStatus+1,x
.8f50	29 08		and #$08			and 	#NSTFloat
.8f52	d0 2c		bne $8f80			bne 	_CBCFloat
.8f54	20 83 8f	jsr $8f83			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8f57	e8		inx				inx
.8f58	20 83 8f	jsr $8f83			jsr 	CompareFixMinusZero
.8f5b	ca		dex				dex
.8f5c	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.8f5e	55 51		eor $51,x			eor 	NSStatus+1,x
.8f60	10 0a		bpl $8f6c			bpl 	_CDCSameSign
.8f62	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.8f64	30 14		bmi $8f7a			bmi 	_CBCLess 					; return $FF
.8f66					_CBCGreater:
.8f66	a9 01		lda #$01			lda 	#1
.8f68	60		rts				rts
.8f69					_CBCEqual:
.8f69	a9 00		lda #$00			lda 	#0
.8f6b	60		rts				rts
.8f6c					_CDCSameSign:
.8f6c	20 98 91	jsr $9198			jsr 	SubTopTwoStack 				; unsigned subtract
.8f6f	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; or the mantissa together
.8f72	f0 f5		beq $8f69			beq 	_CBCEqual 					; -0 == 0
.8f74	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8f76	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8f78	10 ec		bpl $8f66			bpl 	_CBCGreater
.8f7a					_CBCLess:
.8f7a	a9 ff		lda #$ff			lda 	#$FF
.8f7c	60		rts				rts
.8f7d					_CBCString:
.8f7d	4c 09 91	jmp $9109			jmp 	CompareStrings
.8f80					_CBCFloat:
.8f80	4c 53 94	jmp $9453			jmp 	CompareFloat
.8f83					CompareFixMinusZero:
.8f83	20 b3 9d	jsr $9db3			jsr 	NSMIsZero
.8f86	d0 02		bne $8f8a			bne 	_CFXMZNotZero
.8f88	74 50		stz $50,x			stz 	NSStatus,x
.8f8a					_CFXMZNotZero:
.8f8a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f8b					StringConcat:
.8f8b	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.8f8d	35 51		and $51,x			and 	NSStatus+1,x
.8f8f	29 18		and #$18			and 	#NSBTypeMask
.8f91	c9 10		cmp #$10			cmp 	#NSTString
.8f93	d0 50		bne $8fe5			bne		_SCType
.8f95	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f97	e8		inx				inx
.8f98	20 b6 8f	jsr $8fb6			jsr 	_SCSetupZ0 					; setup for second
.8f9b	20 bf 8f	jsr $8fbf			jsr 	_SCLengthZ0 				; length for second
.8f9e	ca		dex				dex
.8f9f	20 b6 8f	jsr $8fb6			jsr 	_SCSetupZ0 					; setup for first
.8fa2	20 bf 8f	jsr $8fbf			jsr 	_SCLengthZ0 				; length for first
.8fa5	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.8fa7	20 c3 a6	jsr $a6c3			jsr 	StringTempAllocate
.8faa	20 d6 8f	jsr $8fd6			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8fad	e8		inx				inx
.8fae	20 b6 8f	jsr $8fb6			jsr 	_SCSetupZ0 					; copy second out
.8fb1	20 d6 8f	jsr $8fd6			jsr 	_SCCopy
.8fb4	ca		dex				dex
.8fb5	60		rts				rts
.8fb6					_SCSetupZ0:
.8fb6	b5 58		lda $58,x			lda 	NSMantissa0,x
.8fb8	85 36		sta $36				sta 	zTemp0
.8fba	b5 60		lda $60,x			lda 	NSMantissa1,x
.8fbc	85 37		sta $37				sta 	zTemp0+1
.8fbe	60		rts				rts
.8fbf					_SCLengthZ0:
.8fbf	5a		phy				phy
.8fc0	a0 00		ldy #$00			ldy 	#0
.8fc2					_SCLenLoop:
.8fc2	b1 36		lda ($36),y			lda 	(zTemp0),y
.8fc4	f0 0e		beq $8fd4			beq 	_SCLExit
.8fc6	c8		iny				iny
.8fc7	e6 38		inc $38				inc 	zTemp1
.8fc9	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.8fcb	c9 fd		cmp #$fd			cmp 	#253
.8fcd	d0 f3		bne $8fc2			bne		_SCLenLoop
.8fcf	a9 09		lda #$09		lda	#9
.8fd1	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.8fd4					_SCLExit:
.8fd4	7a		ply				ply
.8fd5	60		rts				rts
.8fd6					_SCCopy:
.8fd6	5a		phy				phy
.8fd7	a0 00		ldy #$00			ldy 	#0
.8fd9					_SCCopyLoop:
.8fd9	b1 36		lda ($36),y			lda 	(zTemp0),y
.8fdb	f0 06		beq $8fe3			beq 	_SCCExit
.8fdd	20 fc a6	jsr $a6fc			jsr 	StringTempWrite
.8fe0	c8		iny				iny
.8fe1	80 f6		bra $8fd9			bra 	_SCCopyLoop
.8fe3					_SCCExit:
.8fe3	7a		ply				ply
.8fe4	60		rts				rts
.8fe5					_SCType:
.8fe5	4c 19 9f	jmp $9f19			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8fe8					IntegerDivide:
.8fe8	fa		plx				plx
.8fe9	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.8feb	15 51		ora $51,x			ora 	NSStatus+1,x
.8fed	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fee	0a		asl a				asl 	a
.8fef	10 05		bpl $8ff6			bpl 	_NotRef
.8ff1	48		pha				pha
.8ff2	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8ff5	68		pla				pla
.8ff6					_NotRef:
.8ff6	0a		asl a				asl 	a
.8ff7	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8ff9	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8ffb	15 79		ora $79,x			ora 	NSExponent+1,x
.8ffd	f0 03		beq $9002			beq 	_IntegerCode 				; if clear, then we have two integers
.8fff	4c 19 9f	jmp $9f19			jmp 	TypeError 					; anything else, type mismatch.
.9002					_IntegerCode:
.9002	20 1c 90	jsr $901c			jsr 	CheckDivideZero 			; do div zero check
.9005	20 4e 90	jsr $904e			jsr 	Int32Divide 				; do the division
.9008	20 ff 90	jsr $90ff			jsr 	CalculateSign 				; calculate result sign
.900b					NSMCopyPlusTwoToZero:
.900b	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.900d	95 58		sta $58,x			sta 	NSMantissa0,x
.900f	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.9011	95 60		sta $60,x			sta 	NSMantissa1,x
.9013	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.9015	95 68		sta $68,x			sta 	NSMantissa2,x
.9017	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.9019	95 70		sta $70,x			sta 	NSMantissa3,x
.901b	60		rts				rts
.901c					CheckDivideZero:
.901c	e8		inx				inx
.901d	20 b3 9d	jsr $9db3			jsr 	NSMIsZero
.9020	f0 02		beq $9024			beq 	_CDVError
.9022	ca		dex				dex
.9023	60		rts				rts
.9024					_CDVError:
.9024	a9 03		lda #$03		lda	#3
.9026	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.9029					IntegerModulus:
.9029	fa		plx				plx
.902a	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.902c	15 51		ora $51,x			ora 	NSStatus+1,x
.902e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.902f	0a		asl a				asl 	a
.9030	10 05		bpl $9037			bpl 	_NotRef
.9032	48		pha				pha
.9033	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9036	68		pla				pla
.9037					_NotRef:
.9037	0a		asl a				asl 	a
.9038	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.903a	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.903c	15 79		ora $79,x			ora 	NSExponent+1,x
.903e	f0 03		beq $9043			beq 	_IntegerCode 				; if clear, then we have two integers
.9040	4c 19 9f	jmp $9f19			jmp 	TypeError 					; anything else, type mismatch.
.9043					_IntegerCode:
.9043					IntegerModulusNoCheck:
.9043	20 1c 90	jsr $901c			jsr 	CheckDivideZero 			; do div zero check
.9046	20 4e 90	jsr $904e			jsr 	Int32Divide 				; do the division
.9049	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.904b	56 50		lsr $50,x			lsr 	NSStatus,x
.904d	60		rts				rts
.904e					Int32Divide:
.904e	48		pha				pha 								; save AXY
.904f	5a		phy				phy
.9050	20 74 9d	jsr $9d74			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9053	20 8d 9d	jsr $9d8d			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.9056	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.9058					_I32DivideLoop:
.9058	e8		inx				inx
.9059	e8		inx				inx
.905a	20 a0 9d	jsr $9da0			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.905d	ca		dex				dex
.905e	ca		dex				dex
.905f	20 a1 9d	jsr $9da1			jsr 	NSMRotateLeft
.9062	20 8d 90	jsr $908d			jsr 	DivideCheckSubtract 		; check if subtract possible
.9065	90 02		bcc $9069			bcc 	_I32DivideNoCarryIn
.9067	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9069					_I32DivideNoCarryIn:
.9069	88		dey				dey 								; loop round till division completed.
.906a	d0 ec		bne $9058			bne 	_I32DivideLoop
.906c	7a		ply				ply 								; restore AXY and exit
.906d	68		pla				pla
.906e	60		rts				rts
.906f					Int32ShiftDivide:
.906f	48		pha				pha 								; save AY
.9070	5a		phy				phy
.9071	e8		inx				inx 								; clear S[X+2]
.9072	e8		inx				inx
.9073	20 91 9d	jsr $9d91			jsr 	NSMSetZero
.9076	ca		dex				dex
.9077	ca		dex				dex
.9078	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.907a					_I32SDLoop:
.907a	20 8d 90	jsr $908d			jsr 	DivideCheckSubtract 		; check if subtract possible
.907d	e8		inx				inx
.907e	e8		inx				inx
.907f	20 a1 9d	jsr $9da1			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.9082	ca		dex				dex
.9083	ca		dex				dex
.9084	20 a1 9d	jsr $9da1			jsr 	NSMRotateLeft
.9087	88		dey				dey 	 							; do 31 times
.9088	d0 f0		bne $907a			bne 	_I32SDLoop
.908a	7a		ply				ply 								; restore AY and exit
.908b	68		pla				pla
.908c	60		rts				rts
.908d					DivideCheckSubtract:
.908d	20 98 91	jsr $9198			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9090	b0 04		bcs $9096			bcs 	_DCSExit 					; if carry set, then could do, exit
.9092	20 7e 91	jsr $917e			jsr 	AddTopTwoStack 				; add it back in
.9095	18		clc				clc 								; and return False
.9096					_DCSExit:
.9096	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9097					MulInteger:
.9097	fa		plx				plx
.9098	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.909a	15 51		ora $51,x			ora 	NSStatus+1,x
.909c	0a		asl a				asl 	a 							; shift reference bit into sign bit
.909d	0a		asl a				asl 	a
.909e	10 05		bpl $90a5			bpl 	_NotRef
.90a0	48		pha				pha
.90a1	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90a4	68		pla				pla
.90a5					_NotRef:
.90a5	0a		asl a				asl 	a 							; put MSB of type into A:7
.90a6	30 09		bmi $90b1			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.90a8	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90aa	15 79		ora $79,x			ora 	NSExponent+1,x
.90ac	f0 06		beq $90b4			beq 	_IntegerCode 				; if clear, then we have two integers
.90ae	4c 15 95	jmp $9515			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.90b1					_StringData:
.90b1	4c 23 9f	jmp $9f23			jmp 	NotDoneError							; at least one string - don't know both are strings.
.90b4					_IntegerCode:
.90b4	20 c1 90	jsr $90c1			jsr 	MultiplyShort
.90b7	c9 00		cmp #$00			cmp 	#0
.90b9	f0 05		beq $90c0			beq 	_MIExit
.90bb	a9 04		lda #$04		lda	#4
.90bd	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.90c0					_MIExit:
.90c0	60		rts				rts
.90c1					MultiplyShort:
.90c1	5a		phy				phy 								; save Y
.90c2	20 74 9d	jsr $9d74			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90c5	20 8d 9d	jsr $9d8d			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.90c8	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.90ca					_I32MLoop:
.90ca	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.90cc	15 62		ora $62,x			ora 	NSMantissa1+2,x
.90ce	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.90d0	15 72		ora $72,x			ora 	NSMantissa3+2,x
.90d2	f0 25		beq $90f9			beq 	_I32MExit 					; exit if zero
.90d4	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.90d6	29 01		and #$01			and 	#1
.90d8	f0 0d		beq $90e7			beq 	_I32MNoAdd
.90da	20 7e 91	jsr $917e			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.90dd	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.90df	10 06		bpl $90e7			bpl 	_I32MNoAdd
.90e1					_I32ShiftRight:
.90e1	20 aa 9d	jsr $9daa			jsr 	NSMShiftRight 				; shift S[X] right
.90e4	c8		iny				iny 								; increment shift count
.90e5	80 09		bra $90f0			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.90e7					_I32MNoAdd:
.90e7	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.90e9	70 f6		bvs $90e1			bvs 	_I32ShiftRight 				; instead.
.90eb	e8		inx				inx
.90ec	20 a0 9d	jsr $9da0			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.90ef	ca		dex				dex
.90f0					_I32MShiftUpper:
.90f0	e8		inx				inx 								; shift S[X+2] right
.90f1	e8		inx				inx
.90f2	20 aa 9d	jsr $9daa			jsr 	NSMShiftRight
.90f5	ca		dex				dex
.90f6	ca		dex				dex
.90f7	80 d1		bra $90ca			bra 	_I32MLoop 					; try again.
.90f9					_I32MExit:
.90f9	20 ff 90	jsr $90ff			jsr 	CalculateSign
.90fc	98		tya				tya 								; shift in A
.90fd	7a		ply				ply 								; restore Y and exit
.90fe	60		rts				rts
.90ff					CalculateSign:
.90ff	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.9101	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.9103	55 51		eor $51,x			eor 	NSStatus+1,x
.9105	0a		asl a				asl 	a 							; shift bit 7 into carry
.9106	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.9108	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.9109					CompareStrings:
.9109	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.910b	35 51		and $51,x			and 	NSStatus+1,x
.910d	29 10		and #$10			and 	#NSBIsString
.910f	f0 28		beq $9139			beq 	_CSTypeError
.9111	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.9113	85 36		sta $36				sta 	zTemp0
.9115	b5 60		lda $60,x			lda 	NSMantissa1,x
.9117	85 37		sta $37				sta 	zTemp0+1
.9119	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.911b	85 38		sta $38				sta 	zTemp1
.911d	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.911f	85 39		sta $39				sta 	zTemp1+1
.9121	5a		phy				phy 								; save Y so we can access strings
.9122	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.9124					_CSLoop:
.9124	c8		iny				iny
.9125	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.9127	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.9129	d0 06		bne $9131			bne 	_CSDifferent
.912b	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.912d	d0 f5		bne $9124			bne 	_CSLoop 					; still comparing
.912f					_CSExit:
.912f	7a		ply				ply 								; reached end, return zero in A from EOS
.9130	60		rts				rts
.9131					_CSDifferent:
.9131	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.9133	90 fa		bcc $912f			bcc		_CSExit
.9135	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9137	80 f6		bra $912f			bra 	_CSExit
.9139					_CSTypeError:
.9139	4c 19 9f	jmp $9f19			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.913c					ShiftLeft:
.913c	38		sec				sec 								; common code, carry determines which way.
.913d	80 01		bra $9140			bra 	ShiftMain
.913f					ShiftRight:
.913f	18		clc				clc
.9140					ShiftMain:
.9140	fa		plx				plx 								; restore X
.9141	08		php				php 								; save direction
.9142	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9144	15 51		ora $51,x			ora 	NSStatus+1,x
.9146	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9147	0a		asl a				asl 	a
.9148	10 05		bpl $914f			bpl 	_NotRef
.914a	48		pha				pha
.914b	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.914e	68		pla				pla
.914f					_NotRef:
.914f	0a		asl a				asl 	a
.9150	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9152	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9154	15 79		ora $79,x			ora 	NSExponent+1,x
.9156	f0 03		beq $915b			beq 	_IntegerCode 				; if clear, then we have two integers
.9158	4c 19 9f	jmp $9f19			jmp 	TypeError 					; anything else, type mismatch.
.915b					_IntegerCode:
.915b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.915d	29 e0		and #$e0			and 	#$E0
.915f	15 61		ora $61,x			ora 	NSMantissa1+1,x
.9161	15 69		ora $69,x			ora 	NSMantissa2+1,x
.9163	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9165	d0 12		bne $9179			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9167					_SMLoop:
.9167	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9169	30 11		bmi $917c			bmi 	_SMExit 					; exit if done.
.916b	28		plp				plp 								; restore direction setting
.916c	08		php				php
.916d	90 05		bcc $9174			bcc 	_SMRight
.916f	20 a0 9d	jsr $9da0			jsr 	NSMShiftLeft 				; shift left if CS
.9172	80 f3		bra $9167			bra 	_SMLoop
.9174					_SMRight:
.9174	20 aa 9d	jsr $9daa			jsr 	NSMShiftRight 				; shift right if CC
.9177	80 ee		bra $9167			bra 	_SMLoop
.9179					_SMExit0:
.9179	20 91 9d	jsr $9d91			jsr 	NSMSetZero 					; return zero.
.917c					_SMExit:
.917c	28		plp				plp 								; throw direction
.917d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.917e					AddTopTwoStack:
.917e	18		clc				clc
.917f	b5 58		lda $58,x			lda		NSMantissa0,x
.9181	75 59		adc $59,x			adc 		NSMantissa0+1,x
.9183	95 58		sta $58,x			sta 	NSMantissa0,x
.9185	b5 60		lda $60,x			lda		NSMantissa1,x
.9187	75 61		adc $61,x			adc 		NSMantissa1+1,x
.9189	95 60		sta $60,x			sta 	NSMantissa1,x
.918b	b5 68		lda $68,x			lda		NSMantissa2,x
.918d	75 69		adc $69,x			adc 		NSMantissa2+1,x
.918f	95 68		sta $68,x			sta 	NSMantissa2,x
.9191	b5 70		lda $70,x			lda		NSMantissa3,x
.9193	75 71		adc $71,x			adc 		NSMantissa3+1,x
.9195	95 70		sta $70,x			sta 	NSMantissa3,x
.9197	60		rts				rts
.9198					SubTopTwoStack:
.9198	38		sec				sec
.9199	b5 58		lda $58,x			lda		NSMantissa0,x
.919b	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.919d	95 58		sta $58,x			sta 	NSMantissa0,x
.919f	b5 60		lda $60,x			lda		NSMantissa1,x
.91a1	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.91a3	95 60		sta $60,x			sta 	NSMantissa1,x
.91a5	b5 68		lda $68,x			lda		NSMantissa2,x
.91a7	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.91a9	95 68		sta $68,x			sta 	NSMantissa2,x
.91ab	b5 70		lda $70,x			lda		NSMantissa3,x
.91ad	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.91af	95 70		sta $70,x			sta 	NSMantissa3,x
.91b1	60		rts				rts
.91b2					AddInteger:
.91b2	fa		plx				plx
.91b3	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91b5	15 51		ora $51,x			ora 	NSStatus+1,x
.91b7	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91b8	0a		asl a				asl 	a
.91b9	10 05		bpl $91c0			bpl 	_NotRef
.91bb	48		pha				pha
.91bc	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91bf	68		pla				pla
.91c0					_NotRef:
.91c0	0a		asl a				asl 	a 							; put MSB of type into A:7
.91c1	30 09		bmi $91cc			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91c3	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91c5	15 79		ora $79,x			ora 	NSExponent+1,x
.91c7	f0 06		beq $91cf			beq 	_IntegerCode 				; if clear, then we have two integers
.91c9	4c c5 93	jmp $93c5			jmp 	FloatingPointAdd 							; otherwise at least one float.
.91cc					_StringData:
.91cc	4c 8b 8f	jmp $8f8b			jmp 	StringConcat							; at least one string - don't know both are strings.
.91cf					_IntegerCode:
.91cf					AddCode:
.91cf	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.91d1	55 51		eor $51,x			eor 	NSStatus+1,x
.91d3	10 a9		bpl $917e			bpl 	AddTopTwoStack
.91d5	20 98 91	jsr $9198			jsr 	SubTopTwoStack 				; do a physical subtraction
.91d8	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.91da	10 07		bpl $91e3			bpl 	_AddExit
.91dc	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.91de	95 50		sta $50,x			sta 	NSStatus,x
.91e0	20 5a 9d	jsr $9d5a			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.91e3					_AddExit:
.91e3	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; check for -0
.91e6	d0 02		bne $91ea			bne 	_AddNonZero
.91e8	74 50		stz $50,x			stz 	NSStatus,x
.91ea					_AddNonZero:
.91ea	60		rts				rts
.91eb					SubInteger:
.91eb	fa		plx				plx
.91ec	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91ee	15 51		ora $51,x			ora 	NSStatus+1,x
.91f0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91f1	0a		asl a				asl 	a
.91f2	10 05		bpl $91f9			bpl 	_NotRef
.91f4	48		pha				pha
.91f5	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f8	68		pla				pla
.91f9					_NotRef:
.91f9	0a		asl a				asl 	a 							; put MSB of type into A:7
.91fa	30 09		bmi $9205			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91fc	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91fe	15 79		ora $79,x			ora 	NSExponent+1,x
.9200	f0 06		beq $9208			beq 	_IntegerCode 				; if clear, then we have two integers
.9202	4c ca 93	jmp $93ca			jmp 	FloatingPointSub 							; otherwise at least one float.
.9205					_StringData:
.9205	4c 23 9f	jmp $9f23			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9208					_IntegerCode:
.9208	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.920a	49 80		eor #$80			eor 	#$80
.920c	95 51		sta $51,x			sta 	NSStatus+1,x
.920e	80 bf		bra $91cf			bra 	AddCode 					; and do the same code as add.
.9210					AndInteger:
.9210	fa		plx				plx
.9211	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9213	15 51		ora $51,x			ora 	NSStatus+1,x
.9215	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9216	0a		asl a				asl 	a
.9217	10 05		bpl $921e			bpl 	_NotRef
.9219	48		pha				pha
.921a	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.921d	68		pla				pla
.921e					_NotRef:
.921e	0a		asl a				asl 	a
.921f	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9221	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9223	15 79		ora $79,x			ora 	NSExponent+1,x
.9225	f0 03		beq $922a			beq 	_IntegerCode 				; if clear, then we have two integers
.9227	4c 19 9f	jmp $9f19			jmp 	TypeError 					; anything else, type mismatch.
.922a					_IntegerCode:
.922a	b5 58		lda $58,x			lda		NSMantissa0,x
.922c	35 59		and $59,x			and 		NSMantissa0+1,x
.922e	95 58		sta $58,x			sta 	NSMantissa0,x
.9230	b5 60		lda $60,x			lda		NSMantissa1,x
.9232	35 61		and $61,x			and 		NSMantissa1+1,x
.9234	95 60		sta $60,x			sta 	NSMantissa1,x
.9236	b5 68		lda $68,x			lda		NSMantissa2,x
.9238	35 69		and $69,x			and 		NSMantissa2+1,x
.923a	95 68		sta $68,x			sta 	NSMantissa2,x
.923c	b5 70		lda $70,x			lda		NSMantissa3,x
.923e	35 71		and $71,x			and 		NSMantissa3+1,x
.9240	95 70		sta $70,x			sta 	NSMantissa3,x
.9242	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9244	60		rts				rts
.9245					OraInteger:
.9245	fa		plx				plx
.9246	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9248	15 51		ora $51,x			ora 	NSStatus+1,x
.924a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.924b	0a		asl a				asl 	a
.924c	10 05		bpl $9253			bpl 	_NotRef
.924e	48		pha				pha
.924f	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9252	68		pla				pla
.9253					_NotRef:
.9253	0a		asl a				asl 	a
.9254	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9256	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9258	15 79		ora $79,x			ora 	NSExponent+1,x
.925a	f0 03		beq $925f			beq 	_IntegerCode 				; if clear, then we have two integers
.925c	4c 19 9f	jmp $9f19			jmp 	TypeError 					; anything else, type mismatch.
.925f					_IntegerCode:
.925f	b5 58		lda $58,x			lda		NSMantissa0,x
.9261	15 59		ora $59,x			ora 		NSMantissa0+1,x
.9263	95 58		sta $58,x			sta 	NSMantissa0,x
.9265	b5 60		lda $60,x			lda		NSMantissa1,x
.9267	15 61		ora $61,x			ora 		NSMantissa1+1,x
.9269	95 60		sta $60,x			sta 	NSMantissa1,x
.926b	b5 68		lda $68,x			lda		NSMantissa2,x
.926d	15 69		ora $69,x			ora 		NSMantissa2+1,x
.926f	95 68		sta $68,x			sta 	NSMantissa2,x
.9271	b5 70		lda $70,x			lda		NSMantissa3,x
.9273	15 71		ora $71,x			ora 		NSMantissa3+1,x
.9275	95 70		sta $70,x			sta 	NSMantissa3,x
.9277	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9279	60		rts				rts
.927a					EorInteger:
.927a	fa		plx				plx
.927b	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.927d	15 51		ora $51,x			ora 	NSStatus+1,x
.927f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9280	0a		asl a				asl 	a
.9281	10 05		bpl $9288			bpl 	_NotRef
.9283	48		pha				pha
.9284	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9287	68		pla				pla
.9288					_NotRef:
.9288	0a		asl a				asl 	a
.9289	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.928b	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.928d	15 79		ora $79,x			ora 	NSExponent+1,x
.928f	f0 03		beq $9294			beq 	_IntegerCode 				; if clear, then we have two integers
.9291	4c 19 9f	jmp $9f19			jmp 	TypeError 					; anything else, type mismatch.
.9294					_IntegerCode:
.9294	b5 58		lda $58,x			lda		NSMantissa0,x
.9296	55 59		eor $59,x			eor 		NSMantissa0+1,x
.9298	95 58		sta $58,x			sta 	NSMantissa0,x
.929a	b5 60		lda $60,x			lda		NSMantissa1,x
.929c	55 61		eor $61,x			eor 		NSMantissa1+1,x
.929e	95 60		sta $60,x			sta 	NSMantissa1,x
.92a0	b5 68		lda $68,x			lda		NSMantissa2,x
.92a2	55 69		eor $69,x			eor 		NSMantissa2+1,x
.92a4	95 68		sta $68,x			sta 	NSMantissa2,x
.92a6	b5 70		lda $70,x			lda		NSMantissa3,x
.92a8	55 71		eor $71,x			eor 		NSMantissa3+1,x
.92aa	95 70		sta $70,x			sta 	NSMantissa3,x
.92ac	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92ae	60		rts				rts
.92af					WordIndirect:
.92af	fa		plx				plx
.92b0	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92b2	15 51		ora $51,x			ora 	NSStatus+1,x
.92b4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92b5	0a		asl a				asl 	a
.92b6	10 05		bpl $92bd			bpl 	_NotRef
.92b8	48		pha				pha
.92b9	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92bc	68		pla				pla
.92bd					_NotRef:
.92bd	0a		asl a				asl 	a
.92be	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92c0	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92c2	15 79		ora $79,x			ora 	NSExponent+1,x
.92c4	f0 03		beq $92c9			beq 	_IntegerCode 				; if clear, then we have two integers
.92c6	4c 19 9f	jmp $9f19			jmp 	TypeError 					; anything else, type mismatch.
.92c9					_IntegerCode:
.92c9	20 cf 91	jsr $91cf			jsr 	AddCode 					; add the two values
.92cc	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.92ce	95 50		sta $50,x			sta 	NSStatus,x
.92d0	60		rts				rts
.92d1					ByteIndirect:
.92d1	fa		plx				plx
.92d2	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92d4	15 51		ora $51,x			ora 	NSStatus+1,x
.92d6	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92d7	0a		asl a				asl 	a
.92d8	10 05		bpl $92df			bpl 	_NotRef
.92da	48		pha				pha
.92db	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92de	68		pla				pla
.92df					_NotRef:
.92df	0a		asl a				asl 	a
.92e0	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92e2	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92e4	15 79		ora $79,x			ora 	NSExponent+1,x
.92e6	f0 03		beq $92eb			beq 	_IntegerCode 				; if clear, then we have two integers
.92e8	4c 19 9f	jmp $9f19			jmp 	TypeError 					; anything else, type mismatch.
.92eb					_IntegerCode:
.92eb	20 cf 91	jsr $91cf			jsr 	AddCode 					; add the two values
.92ee	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.92f0	95 50		sta $50,x			sta 	NSStatus,x
.92f2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.92f3					ConvertInt16:
.92f3	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.92f5	86 60		stx $60				stx 	NSMantissa1
.92f7	64 68		stz $68				stz 	NSMantissa2
.92f9	64 70		stz $70				stz 	NSMantissa3
.92fb	64 50		stz $50				stz 	NSStatus 					; positive integer
.92fd	a2 00		ldx #$00			ldx 	#0 							; stack level
.92ff	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.9301	80 00		bra $9303			bra 	ConvertInt32
.9303					ConvertInt32:
.9303	5a		phy				phy
.9304	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9306	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.9308	10 08		bpl $9312			bpl 	_CI32NotNeg
.930a	48		pha				pha
.930b	a9 2d		lda #$2d			lda 	#'-'
.930d	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.9310	c8		iny				iny
.9311	68		pla				pla
.9312					_CI32NotNeg:
.9312	20 20 93	jsr $9320			jsr 	_CI32DivideConvert 			; recursive conversion
.9315	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9317	99 7b 05	sta $057b,y			sta 	NumberBuffer,y
.931a	7a		ply				ply
.931b	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8 			; return address in XA
.931d	a9 7b		lda #$7b			lda 	#NumberBuffer & $FF
.931f	60		rts				rts
.9320					_CI32DivideConvert:
.9320	e8		inx				inx 								; write to next slot up
.9321	20 93 9d	jsr $9d93			jsr 	NSMSetByte 		 			; write the base out.
.9324	ca		dex				dex
.9325	20 4e 90	jsr $904e			jsr 	Int32Divide 				; divide
.9328	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.932a	48		pha				pha
.932b	20 0b 90	jsr $900b			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.932e	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; is it zero ?
.9331	f0 05		beq $9338			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9333	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9335	20 20 93	jsr $9320			jsr 	_CI32DivideConvert 			; and recusrively call.
.9338					_CI32NoRecurse:
.9338	68		pla				pla 								; remainder
.9339	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.933b	90 02		bcc $933f			bcc 	_CI32NotHex
.933d	69 26		adc #$26			adc 	#6+32
.933f					_CI32NotHex:
.933f	69 30		adc #$30			adc 	#48
.9341	99 7b 05	sta $057b,y			sta 	NumberBuffer,y 				; write out and exit
.9344	c8		iny				iny
.9345	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9346					PrecedenceLevel:
>9346	04					.byte	 4	; $00 <<
>9347	02					.byte	 2	; $01 <=
>9348	02					.byte	 2	; $02 <>
>9349	00					.byte	 0	; $03 !!3
>934a	00					.byte	 0	; $04 ><
>934b	02					.byte	 2	; $05 >=
>934c	04					.byte	 4	; $06 >>
>934d	00					.byte	 0	; $07 !!7
>934e	00					.byte	 0	; $08 !!8
>934f	00					.byte	 0	; $09 !!9
>9350	00					.byte	 0	; $0a !!10
>9351	00					.byte	 0	; $0b !!11
>9352	00					.byte	 0	; $0c !!12
>9353	00					.byte	 0	; $0d !!13
>9354	00					.byte	 0	; $0e !!14
>9355	00					.byte	 0	; $0f !!15
>9356	00					.byte	 0	; $10 @
>9357	00					.byte	 0	; $11 !!17
>9358	00					.byte	 0	; $12 !!18
>9359	00					.byte	 0	; $13 [
>935a	04					.byte	 4	; $14 \
>935b	00					.byte	 0	; $15 ]
>935c	01					.byte	 1	; $16 ^
>935d	00					.byte	 0	; $17 _
>935e	00					.byte	 0	; $18 `
>935f	00					.byte	 0	; $19 !!25
>9360	00					.byte	 0	; $1a !!26
>9361	00					.byte	 0	; $1b {
>9362	01					.byte	 1	; $1c |
>9363	00					.byte	 0	; $1d }
>9364	00					.byte	 0	; $1e ~
>9365	00					.byte	 0	; $1f [7m<7F>[m
>9366	00					.byte	 0	; $20
>9367	05					.byte	 5	; $21 !
>9368	00					.byte	 0	; $22 "
>9369	00					.byte	 0	; $23 #
>936a	05					.byte	 5	; $24 $
>936b	04					.byte	 4	; $25 %
>936c	01					.byte	 1	; $26 &
>936d	00					.byte	 0	; $27 '
>936e	00					.byte	 0	; $28 (
>936f	00					.byte	 0	; $29 )
>9370	04					.byte	 4	; $2a *
>9371	03					.byte	 3	; $2b +
>9372	00					.byte	 0	; $2c ,
>9373	03					.byte	 3	; $2d -
>9374	00					.byte	 0	; $2e .
>9375	04					.byte	 4	; $2f /
>9376	00					.byte	 0	; $30 0
>9377	00					.byte	 0	; $31 1
>9378	00					.byte	 0	; $32 2
>9379	00					.byte	 0	; $33 3
>937a	00					.byte	 0	; $34 4
>937b	00					.byte	 0	; $35 5
>937c	00					.byte	 0	; $36 6
>937d	00					.byte	 0	; $37 7
>937e	00					.byte	 0	; $38 8
>937f	00					.byte	 0	; $39 9
>9380	00					.byte	 0	; $3a :
>9381	00					.byte	 0	; $3b ;
>9382	02					.byte	 2	; $3c <
>9383	02					.byte	 2	; $3d =
>9384	02					.byte	 2	; $3e >
>9385	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9386					EvaluateExpressionAt0:
.9386	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9388					EvaluateExpression:
.9388	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.938a					EvaluateExpressionAtPrecedence:
.938a	48		pha				pha 								; save precedence level
.938b	20 d2 97	jsr $97d2			jsr 	EvaluateTerm 				; evaluate term into level X.
.938e	68		pla				pla 								; restore precedence level.
.938f					_EXPRLoop:
.938f	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9391	b1 30		lda ($30),y			lda 	(codePtr),y
.9393	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9395	b0 25		bcs $93bc			bcs 	_EXPRExit
.9397	da		phx				phx 								; read the operator precedence
.9398	aa		tax				tax
.9399	bd 46 93	lda $9346,x			lda 	PrecedenceLevel,x
.939c	fa		plx				plx
.939d	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.939f	f0 1b		beq $93bc			beq 	_EXPRExit
.93a1	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93a3	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93a5	c5 37		cmp $37				cmp 	zTemp0+1
.93a7	b0 13		bcs $93bc			bcs		_EXPRExit 					; if current >= operator exit
.93a9	48		pha				pha 								; save current precedence.
.93aa	b1 30		lda ($30),y			lda 	(codePtr),y
.93ac	c8		iny				iny
.93ad	48		pha				pha
.93ae	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93b0	e8		inx				inx 								; work out the right hand side.
.93b1	20 8a 93	jsr $938a			jsr 	EvaluateExpressionAtPrecedence
.93b4	ca		dex				dex
.93b5	68		pla				pla 								; get operator, call the code.
.93b6	20 bf 93	jsr $93bf			jsr 	_EXPRCaller
.93b9	68		pla				pla 								; restore precedence level
.93ba	80 d3		bra $938f			bra 	_EXPRLoop 					; and go round.
.93bc					_EXPRExit:
.93bc	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93be	60		rts				rts
.93bf					_EXPRCaller:
.93bf	da		phx				phx 								; save on stack, first thing is to restore it
.93c0	0a		asl a				asl 	a 							; double so can use vectors into X
.93c1	aa		tax				tax
.93c2	7c 46 8b	jmp ($8b46,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.93c5					FloatingPointAdd:
.93c5	20 3b 95	jsr $953b			jsr 	FloatPrepare 				; prepare for floats
.93c8	80 09		bra $93d3			bra 	FloatAdd
.93ca					FloatingPointSub:
.93ca	20 3b 95	jsr $953b			jsr 	FloatPrepare 				; prepare for floats
.93cd					FloatSubtract:
.93cd	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.93cf	49 80		eor #$80			eor 	#$80
.93d1	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.93d3					FloatAdd:
.93d3	48		pha				pha
.93d4	5a		phy				phy
.93d5	20 4a 95	jsr $954a			jsr 	NSNormalise 				; normalise S[X]
.93d8	f0 51		beq $942b			beq 	_FAReturn1
.93da	e8		inx				inx 								; normalise S[X+1]
.93db	20 4a 95	jsr $954a			jsr 	NSNormalise
.93de	ca		dex				dex
.93df	c9 00		cmp #$00			cmp 	#0
.93e1	f0 60		beq $9443			beq 	_FAExit 					; if so, just return A
.93e3	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.93e5	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.93e7	f0 18		beq $9401			beq 	_FAExponentsEqual
.93e9	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.93eb	a8		tay				tay
.93ec	38		sec				sec 								; do a signed comparison of the exponents.
.93ed	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.93ef	50 02		bvc $93f3			bvc 	_FANoSignedChange
.93f1	49 80		eor #$80			eor 	#$80
.93f3					_FANoSignedChange:
.93f3	29 80		and #$80			and 	#$80
.93f5	10 02		bpl $93f9			bpl 	_FAHaveMax
.93f7	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.93f9					_FAHaveMax:
.93f9	20 46 94	jsr $9446			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.93fc	e8		inx				inx
.93fd	20 46 94	jsr $9446			jsr 	_FAShiftToExponent
.9400	ca		dex				dex
.9401					_FAExponentsEqual:
.9401	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9403	55 51		eor $51,x			eor 	NSStatus+1,x
.9405	30 0e		bmi $9415			bmi 	_FADifferentSigns
.9407	20 7e 91	jsr $917e			jsr 	AddTopTwoStack 				; do the add of the mantissae
.940a	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.940c	10 35		bpl $9443			bpl 	_FAExit 					; if no, we are done.
.940e	20 aa 9d	jsr $9daa			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9411	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.9413	80 2e		bra $9443			bra 	_FAExit
.9415					_FADifferentSigns:
.9415	20 98 91	jsr $9198			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9418	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.941a	10 06		bpl $9422			bpl 	_FACheckZero 				; if no, check for -0
.941c	20 53 9d	jsr $9d53			jsr 	NSMNegate 					; netate result
.941f	20 5a 9d	jsr $9d5a			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9422					_FACheckZero:
.9422	20 b3 9d	jsr $9db3			jsr 	NSMIsZero	 				; check for -0
.9425	d0 1c		bne $9443			bne 	_FAExit
.9427	74 50		stz $50,x			stz 	NSStatus,x
.9429	80 18		bra $9443			bra 	_FAExit
.942b					_FAReturn1:
.942b	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.942d	95 58		sta $58,x			sta 	NSMantissa0,x
.942f	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9431	95 60		sta $60,x			sta 	NSMantissa1,x
.9433	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9435	95 68		sta $68,x			sta 	NSMantissa2,x
.9437	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9439	95 70		sta $70,x			sta 	NSMantissa3,x
.943b	b5 79		lda $79,x			lda 	NSExponent+1,x
.943d	95 78		sta $78,x			sta 	NSExponent,x
.943f	b5 51		lda $51,x			lda 	NSStatus+1,x
.9441	95 50		sta $50,x			sta 	NSStatus,x
.9443					_FAExit:
.9443	7a		ply				ply
.9444	68		pla				pla
.9445	60		rts				rts
.9446					_FAShiftToExponent:
.9446					_FAShiftToExponent2:
.9446	98		tya				tya 								; compare Y to exponent
.9447	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9449	f0 07		beq $9452			beq 	_FASEExit 					; exit if so.
.944b	20 aa 9d	jsr $9daa			jsr 	NSMShiftRight	 			; shift the mantissa right
.944e	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.9450	80 f4		bra $9446			bra 	_FAShiftToExponent2
.9452					_FASEExit:
.9452	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9453					CompareFloat:
.9453	20 cd 93	jsr $93cd			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9456	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9458	29 f8		and #$f8			and 	#$F8
.945a	15 68		ora $68,x			ora 	NSMantissa2,x
.945c	15 70		ora $70,x			ora 	NSMantissa3,x
.945e	f0 08		beq $9468			beq 	_FCExit 					; zero, so approximately identical
.9460	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9462	34 50		bit $50,x			bit 	NSStatus,x
.9464	10 02		bpl $9468			bpl 	_FCExit
.9466					_FCNegative:
.9466	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9468					_FCExit:
.9468	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9469					FDivideCommand:
.9469	fa		plx				plx	 								; restore stack position
.946a	20 3b 95	jsr $953b			jsr 	FloatPrepare 				; prepare for floats
.946d					FloatDivide:
.946d	48		pha				pha
.946e	e8		inx				inx
.946f	20 4a 95	jsr $954a			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9472	ca		dex				dex
.9473	c9 00		cmp #$00			cmp 	#0
.9475	f0 1d		beq $9494			beq 	_FDZero
.9477	20 4a 95	jsr $954a			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.947a	f0 16		beq $9492			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.947c	20 6f 90	jsr $906f			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.947f	20 0b 90	jsr $900b			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9482	20 4a 95	jsr $954a			jsr		NSNormalise 				; renormalise
.9485	20 ff 90	jsr $90ff			jsr 	CalculateSign 				; calculate result sign
.9488	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.948a	38		sec				sec
.948b	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.948d	38		sec				sec
.948e	e9 1e		sbc #$1e			sbc 	#30
.9490	95 78		sta $78,x			sta 	NSExponent,x
.9492					_FDExit:
.9492	68		pla				pla
.9493	60		rts				rts
.9494					_FDZero:
.9494	a9 03		lda #$03		lda	#3
.9496	4c 84 8e	jmp $8e84		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9499					FloatFractionalPart:
.9499	5a		phy				phy
.949a	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.949c	29 7f		and #$7f			and 	#$7F
.949e	95 50		sta $50,x			sta 	NSStatus,x
.94a0	20 4a 95	jsr $954a			jsr 	NSNormalise
.94a3	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.94a5	38		sec				sec
.94a6	e9 e0		sbc #$e0			sbc 	#$E0
.94a8	90 29		bcc $94d3			bcc 	_FFPExit 					; already fractional
.94aa	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.94ac	b0 22		bcs $94d0			bcs 	_FFPZero
.94ae	a8		tay				tay 								; put count to do in Y
.94af	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.94b1	20 d5 94	jsr $94d5			jsr 	_FFPPartial
.94b4	95 70		sta $70,x			sta 	NSMantissa3,x
.94b6	b5 68		lda $68,x			lda 	NSMantissa2,x
.94b8	20 d5 94	jsr $94d5			jsr 	_FFPPartial
.94bb	95 68		sta $68,x			sta 	NSMantissa2,x
.94bd	b5 60		lda $60,x			lda 	NSMantissa1,x
.94bf	20 d5 94	jsr $94d5			jsr 	_FFPPartial
.94c2	95 60		sta $60,x			sta 	NSMantissa1,x
.94c4	b5 58		lda $58,x			lda 	NSMantissa0,x
.94c6	20 d5 94	jsr $94d5			jsr 	_FFPPartial
.94c9	95 58		sta $58,x			sta 	NSMantissa0,x
.94cb	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; zeroed check.
.94ce	d0 03		bne $94d3			bne 	_FFPExit
.94d0					_FFPZero:
.94d0	20 91 9d	jsr $9d91			jsr 	NSMSetZero
.94d3					_FFPExit:
.94d3	7a		ply				ply
.94d4	60		rts				rts
.94d5					_FFPPartial:
.94d5	c0 00		cpy #$00			cpy 	#0 							; no more to do
.94d7	f0 17		beq $94f0			beq 	_FFFPPExit
.94d9	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.94db	b0 0c		bcs $94e9			bcs 	_FFFPPWholeByte
.94dd	5a		phy				phy
.94de					_FFFPPLeft:
.94de	0a		asl a				asl 	a
.94df	88		dey				dey
.94e0	d0 fc		bne $94de			bne 	_FFFPPLeft
.94e2	7a		ply				ply
.94e3					_FFFPPRight:
.94e3	4a		lsr a				lsr 	a
.94e4	88		dey				dey
.94e5	d0 fc		bne $94e3			bne 	_FFFPPRight
.94e7	80 07		bra $94f0			bra 	_FFFPPExit
.94e9					_FFFPPWholeByte:
.94e9	98		tya				tya 								; subtract 8 from count
.94ea	38		sec				sec
.94eb	e9 08		sbc #$08			sbc 	#8
.94ed	a8		tay				tay
.94ee	a9 00		lda #$00			lda 	#0 							; and clear all
.94f0					_FFFPPExit:
.94f0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.94f1					FloatIntegerPart:
.94f1	48		pha				pha
.94f2	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.94f4	f0 1d		beq $9513			beq 	_FIPExit 					; if so do nothing
.94f6	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; is it zero ?
.94f9	f0 15		beq $9510			beq 	_FIPZero 					; if so return zero.
.94fb	20 4a 95	jsr $954a			jsr 	NSNormalise 				; normalise
.94fe	f0 10		beq $9510			beq 	_FIPZero 					; normalised to zero, exit zero
.9500					_FIPShift:
.9500	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9502	10 07		bpl $950b			bpl 	_FIPCheckZero
.9504	20 aa 9d	jsr $9daa			jsr 	NSMShiftRight 				; shift mantissa right
.9507	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.9509	80 f5		bra $9500			bra 	_FIPShift
.950b					_FIPCheckZero:
.950b	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; avoid -0 problem
.950e	d0 03		bne $9513			bne 	_FIPExit 					; set to zero if mantissa zero.
.9510					_FIPZero:
.9510	20 91 9d	jsr $9d91			jsr 	NSMSetZero
.9513					_FIPExit:
.9513	68		pla				pla
.9514	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9515					FloatingPointMultiply:
.9515	20 3b 95	jsr $953b			jsr 	FloatPrepare 				; prepare for floats
.9518					FloatMultiply:
.9518	48		pha				pha
.9519	20 4a 95	jsr $954a			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.951c	f0 18		beq $9536			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.951e	e8		inx				inx
.951f	20 4a 95	jsr $954a			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9522	ca		dex				dex
.9523	c9 00		cmp #$00			cmp 	#0
.9525	f0 0c		beq $9533			beq 	_FDSetZero
.9527	20 c1 90	jsr $90c1			jsr 	MultiplyShort 				; calculate the result.
.952a	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.952c	18		clc				clc
.952d	75 79		adc $79,x			adc 	NSExponent+1,x
.952f	95 78		sta $78,x			sta 	NSExponent,x
.9531	80 03		bra $9536			bra 	_FDExit
.9533					_FDSetZero:
.9533	20 91 9d	jsr $9d91			jsr 	NSMSetZero 					; return 0
.9536					_FDExit:
.9536	20 4a 95	jsr $954a			jsr 	NSNormalise 				; normalise the result
.9539	68		pla				pla
.953a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.953b					FloatPrepare:
.953b	20 46 96	jsr $9646			jsr 	DereferenceTopTwo 			; dereference the top two values
.953e	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.9540	15 51		ora $51,x			ora 	NSStatus+1,x
.9542	29 10		and #$10			and 	#NSBIsString
.9544	d0 01		bne $9547			bne 	_FDType
.9546	60		rts				rts
.9547					_FDType:
.9547	4c 19 9f	jmp $9f19			jmp 	TypeError
.954a					NSNormalise:
.954a	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.954c	29 80		and #$80			and 	#$80
.954e	09 08		ora #$08			ora 	#NSTFloat
.9550	95 50		sta $50,x			sta 	NSStatus,x
.9552	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; if zero exit
.9555	d0 07		bne $955e			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.9557	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9559	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.955b	a9 00		lda #$00			lda 	#0 							; set Z flag
.955d	60		rts				rts
.955e					_NSNormaliseOptimise:
.955e	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.9560	d0 19		bne $957b			bne 	_NSNormaliseLoop
.9562	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.9564	30 15		bmi $957b			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9566	95 70		sta $70,x			sta 	NSMantissa3,x
.9568	b5 60		lda $60,x			lda 	NSMantissa1,x
.956a	95 68		sta $68,x			sta 	NSMantissa2,x
.956c	b5 58		lda $58,x			lda 	NSMantissa0,x
.956e	95 60		sta $60,x			sta 	NSMantissa1,x
.9570	74 58		stz $58,x			stz 	NSMantissa0,x
.9572	b5 78		lda $78,x			lda 	NSExponent,x
.9574	38		sec				sec
.9575	e9 08		sbc #$08			sbc 	#8
.9577	95 78		sta $78,x			sta 	NSExponent,x
.9579	80 e3		bra $955e			bra 	_NSNormaliseOptimise
.957b					_NSNormaliseLoop:
.957b	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.957d	70 07		bvs $9586			bvs 	_NSNExit 					; exit if so with Z flag clear
.957f	20 a0 9d	jsr $9da0			jsr 	NSMShiftLeft 				; shift mantissa left
.9582	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.9584	80 f5		bra $957b			bra 	_NSNormaliseLoop
.9586					_NSNExit:
.9586	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9588	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9589					AssignNumber:
.9589	5a		phy				phy
.958a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.958c	85 36		sta $36				sta 	zTemp0
.958e	b5 60		lda $60,x			lda 	NSMantissa1,x
.9590	85 37		sta $37				sta 	zTemp0+1
.9592	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9594	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9596	95 50		sta $50,x			sta 	NSStatus,x
.9598	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.959a	c9 08		cmp #$08			cmp 	#NSTFloat
.959c	f0 24		beq $95c2			beq 	_ANFloat
.959e	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.95a0	f0 03		beq $95a5			beq		_ANNotFloat
.95a2	4c 14 9f	jmp $9f14			jmp 	RangeError					; if it is, report an error.
.95a5					_ANNotFloat:
.95a5	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.95a7	29 03		and #$03			and 	#3
.95a9	d0 05		bne $95b0			bne 	_ANByteWord
.95ab	20 cd 95	jsr $95cd			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.95ae	80 1b		bra $95cb			bra 	_ANExit
.95b0					_ANByteWord:
.95b0	48		pha				pha 								; save count
.95b1	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.95b3	92 36		sta ($36)			sta 	(zTemp0)
.95b5	68		pla				pla
.95b6	c9 01		cmp #$01			cmp	 	#1
.95b8	f0 11		beq $95cb			beq 	_ANExit
.95ba	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.95bc	a0 01		ldy #$01			ldy 	#1
.95be	91 36		sta ($36),y			sta 	(zTemp0),y
.95c0	80 09		bra $95cb			bra 	_ANExit
.95c2					_ANFloat:
.95c2	20 cd 95	jsr $95cd			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.95c5	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.95c7	a0 04		ldy #$04			ldy 	#4
.95c9	91 36		sta ($36),y			sta 	(zTemp0),y
.95cb					_ANExit:
.95cb	7a		ply				ply
.95cc	60		rts				rts
.95cd					_ANCopy4PackSign:
.95cd	a0 03		ldy #$03			ldy 	#3
.95cf	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.95d1	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.95d3	15 71		ora $71,x			ora 	NSMantissa3+1,x
.95d5	91 36		sta ($36),y			sta 	(zTemp0),y
.95d7	88		dey				dey
.95d8	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.95da	91 36		sta ($36),y			sta 	(zTemp0),y
.95dc	88		dey				dey
.95dd	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.95df	91 36		sta ($36),y			sta 	(zTemp0),y
.95e1	88		dey				dey
.95e2	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.95e4	91 36		sta ($36),y			sta 	(zTemp0),y
.95e6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.95e7					AssignString:
.95e7	5a		phy				phy
.95e8	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.95ea	85 38		sta $38				sta 	zTemp1
.95ec	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.95ee	85 39		sta $39				sta 	zTemp1+1
.95f0	b5 58		lda $58,x			lda 	NSMantissa0,x
.95f2	85 36		sta $36				sta 	zTemp0
.95f4	b5 60		lda $60,x			lda 	NSMantissa1,x
.95f6	85 37		sta $37				sta 	zTemp0+1
.95f8	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.95fa	b1 36		lda ($36),y			lda 	(zTemp0),y
.95fc	f0 23		beq $9621			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.95fe	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.95ff	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9601	e9 02		sbc #$02			sbc 	#2
.9603	85 3c		sta $3c				sta 	zsTemp
.9605	a0 01		ldy #$01			ldy 	#1
.9607	b1 36		lda ($36),y			lda 	(zTemp0),y
.9609	e9 00		sbc #$00			sbc 	#0
.960b	85 3d		sta $3d				sta 	zsTemp+1
.960d	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.960f					_ASGetLength:
.960f	c8		iny				iny
.9610	b1 38		lda ($38),y			lda 	(zTemp1),y
.9612	d0 fb		bne $960f			bne 	_ASGetLength
.9614	98		tya				tya 								; is this length <= current length
.9615	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9617	90 1e		bcc $9637			bcc 	_ASCopyString
.9619	f0 1c		beq $9637			beq 	_ASCopyString
.961b	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.961d	a0 01		ldy #$01			ldy 	#1
.961f	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9621					_ASNewStringRequired:
.9621	e8		inx				inx 								; concrete the new string.
.9622	20 46 a6	jsr $a646			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9625	ca		dex				dex
.9626	18		clc				clc
.9627	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9629	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.962b	92 36		sta ($36)			sta 	(zTemp0)
.962d	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.962f	69 00		adc #$00			adc 	#0
.9631	a0 01		ldy #$01			ldy 	#1
.9633	91 36		sta ($36),y			sta 	(zTemp0),y
.9635	80 0d		bra $9644			bra 	_ASExit
.9637					_ASCopyString:
.9637	a0 00		ldy #$00			ldy 	#0
.9639					_ASCopyLoop:
.9639	b1 38		lda ($38),y			lda 	(zTemp1),y
.963b	c8		iny				iny
.963c	c8		iny				iny
.963d	91 3c		sta ($3c),y			sta 	(zsTemp),y
.963f	88		dey				dey
.9640	c9 00		cmp #$00			cmp 	#0
.9642	d0 f5		bne $9639			bne 	_ASCopyLoop
.9644					_ASExit:
.9644	7a		ply				ply
.9645	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9646					DereferenceTopTwo:
.9646	e8		inx				inx
.9647	20 4b 96	jsr $964b			jsr 	Dereference 				; deref x+1
.964a	ca		dex				dex  								; falls through to deref x
.964b					Dereference:
.964b	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.964d	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.964f	f0 48		beq $9699			beq 	_DRFExit 					; not a reference, so exit.
.9651	5a		phy				phy
.9652	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9654	85 36		sta $36				sta 	zTemp0
.9656	b5 60		lda $60,x			lda 	NSMantissa1,x
.9658	85 37		sta $37				sta 	zTemp0+1
.965a	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.965c	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.965e	95 58		sta $58,x			sta 	NSMantissa0,x
.9660	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.9662	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9664	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9666	f0 0e		beq $9676			beq 	_DRFDereferenceTwo
.9668	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.966a	f0 2f		beq $969b			beq 	_DRFFull
.966c	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.966e	29 03		and #$03			and 	#3
.9670	f0 29		beq $969b			beq 	_DRFFull 					; the whole word
.9672	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9674	f0 06		beq $967c			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9676					_DRFDereferenceTwo:
.9676	a0 01		ldy #$01			ldy 	#1
.9678	b1 36		lda ($36),y			lda 	(zTemp0),y
.967a	95 60		sta $60,x			sta 	NSMantissa1,x
.967c					_DRFClear23:
.967c	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.967e	74 70		stz $70,x			stz 	NSMantissa3,x
.9680	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.9682	29 18		and #$18			and 	#NSBTypeMask
.9684	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9686	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9688	d0 0e		bne $9698			bne 	_DRFNotString
.968a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.968c	15 60		ora $60,x			ora 	NSMantissa1,x
.968e	d0 08		bne $9698			bne 	_DRFNotString
.9690	a9 9a		lda #$9a			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9692	95 58		sta $58,x			sta 	NSMantissa0,X
.9694	a9 96		lda #$96			lda 	#_DRFNullString >> 8
.9696	95 60		sta $60,x			sta 	NSMantissa1,X
.9698					_DRFNotString
.9698	7a		ply				ply 								; restore Y and exit
.9699					_DRFExit:
.9699	60		rts				rts
.969a					_DRFNullString:
>969a	00						.byte 	0
.969b					_DRFFull:
.969b	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.969d	b1 36		lda ($36),y			lda 	(zTemp0),y
.969f	95 60		sta $60,x			sta 	NSMantissa1,x
.96a1	c8		iny				iny
.96a2	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a4	95 68		sta $68,x			sta 	NSMantissa2,x
.96a6	c8		iny				iny
.96a7	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a9	95 70		sta $70,x			sta 	NSMantissa3,x
.96ab	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.96ad	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.96af	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.96b1	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.96b3	f0 05		beq $96ba			beq 	_DRFNoExponent
.96b5	c8		iny				iny 								; if not, read the exponent as well.
.96b6	b1 36		lda ($36),y			lda 	(zTemp0),y
.96b8	95 78		sta $78,x			sta 	NSExponent,x
.96ba					_DRFNoExponent:
.96ba	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.96bc	10 0a		bpl $96c8			bpl 	_DRFExit2 					; if not, then exit.
.96be	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.96c0	95 70		sta $70,x			sta 	NSMantissa3,x
.96c2	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.96c4	09 80		ora #$80			ora 	#NSBIsNegative
.96c6	95 50		sta $50,x			sta 	NSStatus,x
.96c8					_DRFExit2:
.96c8	7a		ply				ply
.96c9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.96ca					EncodeNumberStart:
.96ca	38		sec				sec
.96cb	80 01		bra $96ce			bra 	EncodeNumberContinue+1
.96cd					EncodeNumberContinue:
.96cd	18		clc				clc
.96ce					EncodeNumber:
.96ce	08		php				php 								; save reset flag.
.96cf	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.96d1	f0 12		beq $96e5			beq 	_ENIsOkay
.96d3	c9 30		cmp #$30			cmp 	#"0"
.96d5	90 04		bcc $96db			bcc 	_ENBadNumber
.96d7	c9 3a		cmp #$3a			cmp 	#"9"+1
.96d9	90 0a		bcc $96e5			bcc 	_ENIsOkay
.96db					_ENBadNumber:
.96db	28		plp				plp 								; throw saved reset
.96dc	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.96df	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.96e1	f0 7b		beq $975e			beq 	_ENConstructFinal
.96e3					_ENFail:
.96e3	18		clc				clc 								; not allowed
.96e4	60		rts				rts
.96e5					_ENIsOkay:
.96e5	28		plp				plp 								; are we restarting
.96e6	90 15		bcc $96fd			bcc 	_ENNoRestart
.96e8					_ENStartEncode:
.96e8	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.96ea	f0 0c		beq $96f8			beq 	_ENFirstDP
.96ec	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.96ee	20 93 9d	jsr $9d93			jsr 	NSMSetByte 					; in single byte mode.
.96f1	a9 01		lda #$01			lda 	#ESTA_Low
.96f3					_ENExitChange:
.96f3	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.96f6	38		sec				sec
.96f7	60		rts				rts
.96f8					_ENFirstDP:
.96f8	20 91 9d	jsr $9d91			jsr 	NSMSetZero 					; clear integer part
.96fb	80 3c		bra $9739			bra 	_ESTASwitchFloat			; go straight to float and exi
.96fd					_ENNoRestart:
.96fd	48		pha				pha 								; save digit or DP on stack.
.96fe	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.9701	c9 01		cmp #$01			cmp 	#ESTA_Low
.9703	f0 09		beq $970e			beq  	_ESTALowState
.9705	c9 02		cmp #$02			cmp 	#ESTA_High
.9707	f0 26		beq $972f			beq 	_ESTAHighState
.9709	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.970b	f0 38		beq $9745			beq 	_ESTADecimalState
>970d	db						.byte 	$DB 						; causes a break in the emulator
.970e					_ESTALowState:
.970e	68		pla				pla 								; get value back
.970f	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9711	f0 26		beq $9739			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9713	29 0f		and #$0f			and 	#15 						; make digit
.9715	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.9718	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.971a	0a		asl a				asl 	a
.971b	0a		asl a				asl 	a
.971c	75 58		adc $58,x			adc 	NSMantissa0,x
.971e	0a		asl a				asl 	a
.971f	6d 06 04	adc $0406			adc 	DigitTemp
.9722	95 58		sta $58,x			sta 	NSMantissa0,x
.9724	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.9726	90 05		bcc $972d			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.9728	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.972a	8d 05 04	sta $0405			sta 	EncodeState
.972d					_ESTANoSwitch:
.972d	38		sec				sec
.972e	60		rts				rts
.972f					_ESTAHighState:
.972f	68		pla				pla 								; get value back
.9730	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.9732	f0 05		beq $9739			beq 	_ESTASwitchFloat
.9734	20 92 97	jsr $9792			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9737	38		sec				sec
.9738	60		rts				rts
.9739					_ESTASwitchFloat:
.9739	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.973c	e8		inx				inx 								; zero the decimal additive.
.973d	20 91 9d	jsr $9d91			jsr 	NSMSetZero
.9740	ca		dex				dex
.9741	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9743	80 ae		bra $96f3			bra 	_ENExitChange
.9745					_ESTADecimalState:
.9745	68		pla				pla 								; digit.
.9746	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9748	f0 99		beq $96e3			beq 	_ENFail
.974a	e8		inx				inx 								; put digit into fractional part of X+1
.974b	20 92 97	jsr $9792			jsr 	ESTAShiftDigitIntoMantissa
.974e	ca		dex				dex
.974f	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.9752	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.9755	c9 0b		cmp #$0b			cmp 	#11
.9757	f0 02		beq $975b			beq 	_ESTADSFail
.9759	38		sec				sec
.975a	60		rts				rts
.975b					_ESTADSFail:
.975b	4c 14 9f	jmp $9f14			jmp 	RangeError
.975e					_ENConstructFinal:
.975e	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.9761	f0 2d		beq $9790			beq 	_ENCFExit 					; no decimals
.9763	5a		phy				phy
.9764	0a		asl a				asl 	a 							; x 4 and CLC
.9765	0a		asl a				asl 	a
.9766	6d 07 04	adc $0407			adc 	DecimalCount
.9769	a8		tay				tay
.976a	b9 d3 9e	lda $9ed3,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.976d	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.976f	b9 d4 9e	lda $9ed4,y			lda 	DecimalScalarTable-5+1,y
.9772	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9774	b9 d5 9e	lda $9ed5,y			lda 	DecimalScalarTable-5+2,y
.9777	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9779	b9 d6 9e	lda $9ed6,y			lda 	DecimalScalarTable-5+3,y
.977c	95 72		sta $72,x			sta 	NSMantissa3+2,x
.977e	b9 d7 9e	lda $9ed7,y			lda 	DecimalScalarTable-5+4,y
.9781	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9783	a9 08		lda #$08			lda 	#NSTFloat
.9785	95 52		sta $52,x			sta 	NSStatus+2,x
.9787	7a		ply				ply
.9788	e8		inx				inx 								; multiply decimal const by decimal scalar
.9789	20 18 95	jsr $9518			jsr 	FloatMultiply
.978c	ca		dex				dex
.978d	20 d3 93	jsr $93d3			jsr 	FloatAdd 					; add to integer part.
.9790					_ENCFExit:
.9790	18		clc				clc 								; reject the digit.
.9791	60		rts				rts
.9792					ESTAShiftDigitIntoMantissa:
.9792	29 0f		and #$0f			and 	#15 						; save digit
.9794	48		pha				pha
.9795	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9797	48		pha				pha
.9798	b5 68		lda $68,x			lda 	NSMantissa2,x
.979a	48		pha				pha
.979b	b5 60		lda $60,x			lda 	NSMantissa1,x
.979d	48		pha				pha
.979e	b5 58		lda $58,x			lda 	NSMantissa0,x
.97a0	48		pha				pha
.97a1	20 a0 9d	jsr $9da0			jsr 	NSMShiftLeft 				; x 2
.97a4	20 a0 9d	jsr $9da0			jsr 	NSMShiftLeft 				; x 4
.97a7	18		clc				clc 								; pop mantissa and add
.97a8	68		pla				pla
.97a9	75 58		adc $58,x			adc 	NSMantissa0,x
.97ab	95 58		sta $58,x			sta 	NSMantissa0,x
.97ad	68		pla				pla
.97ae	75 60		adc $60,x			adc 	NSMantissa1,x
.97b0	95 60		sta $60,x			sta 	NSMantissa1,x
.97b2	68		pla				pla
.97b3	75 68		adc $68,x			adc 	NSMantissa2,x
.97b5	95 68		sta $68,x			sta 	NSMantissa2,x
.97b7	68		pla				pla
.97b8	75 70		adc $70,x			adc 	NSMantissa3,x
.97ba	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.97bc	20 a0 9d	jsr $9da0			jsr 	NSMShiftLeft 				; x 10
.97bf	68		pla				pla 								; add digit
.97c0	18		clc				clc
.97c1	75 58		adc $58,x			adc 	NSMantissa0,x
.97c3	95 58		sta $58,x			sta 	NSMantissa0,x
.97c5	90 0a		bcc $97d1			bcc 	_ESTASDExit
.97c7	f6 60		inc $60,x			inc 	NSMantissa1,x
.97c9	d0 06		bne $97d1			bne 	_ESTASDExit
.97cb	f6 68		inc $68,x			inc 	NSMantissa2,x
.97cd	d0 02		bne $97d1			bne 	_ESTASDExit
.97cf	f6 70		inc $70,x			inc 	NSMantissa3,x
.97d1					_ESTASDExit:
.97d1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.97d2					EvaluateTerm:
.97d2	b1 30		lda ($30),y			lda 	(codePtr),y
.97d4	30 18		bmi $97ee			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.97d6	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.97d8	b0 6c		bcs $9846			bcs 	_ETVariable
.97da	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.97dc	90 6b		bcc $9849			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.97de	c9 3a		cmp #$3a			cmp 	#'9'+1
.97e0	b0 67		bcs $9849			bcs 	_ETPuncUnary
.97e2	20 ca 96	jsr $96ca			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.97e5					_ETNumber:
.97e5	c8		iny				iny 								; keep encoding until we have the numbers
.97e6	b1 30		lda ($30),y			lda 	(codePtr),y
.97e8	20 cd 96	jsr $96cd			jsr 	EncodeNumberContinue
.97eb	b0 f8		bcs $97e5			bcs 	_ETNumber 					; go back if accepted.
.97ed	60		rts				rts
.97ee					_ETCheckUnary:
.97ee	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.97f0	f0 3f		beq $9831			beq 	_ETString
.97f2	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.97f4	f0 12		beq $9808			beq 	_ETHexConstant
.97f6	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.97f8	90 0b		bcc $9805			bcc 	_ETSyntaxError
.97fa	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.97fc	b0 07		bcs $9805			bcs 	_ETSyntaxError
.97fe	da		phx				phx 								; push X on the stack
.97ff	0a		asl a				asl 	a 							; put vector x 2 into X
.9800	aa		tax				tax
.9801	c8		iny				iny 								; consume unary function token
.9802	7c c6 8b	jmp ($8bc6,x)			jmp 	(VectorSet0,x) 				; and do it.
.9805					_ETSyntaxError:
.9805	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError
.9808					_ETHexConstant:
.9808	c8		iny				iny 								; skip #
.9809	c8		iny				iny 								; skip count
.980a	20 91 9d	jsr $9d91			jsr 	NSMSetZero 					; clear result
.980d					_ETHLoop:
.980d	b1 30		lda ($30),y			lda 	(codePtr),y
.980f	c8		iny				iny 								; and consume
.9810	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9812	f0 1c		beq $9830			beq 	_ETHExit
.9814	48		pha				pha 								; save on stack.
.9815	20 a0 9d	jsr $9da0			jsr 	NSMShiftLeft 				; x 2
.9818	20 a0 9d	jsr $9da0			jsr 	NSMShiftLeft 				; x 4
.981b	20 a0 9d	jsr $9da0			jsr 	NSMShiftLeft 				; x 8
.981e	20 a0 9d	jsr $9da0			jsr 	NSMShiftLeft 				; x 16
.9821	68		pla				pla 								; ASCII
.9822	c9 41		cmp #$41			cmp 	#'A'
.9824	90 02		bcc $9828			bcc 	_ETHNotChar
.9826	e9 07		sbc #$07			sbc 	#7
.9828					_ETHNotChar:
.9828	29 0f		and #$0f			and 	#15 						; digit now
.982a	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.982c	95 58		sta $58,x			sta 	NSMantissa0,x
.982e	80 dd		bra $980d			bra 	_ETHLoop 					; go round.
.9830					_ETHExit:
.9830	60		rts				rts
.9831					_ETString:
.9831	c8		iny				iny 								; look at length
.9832	b1 30		lda ($30),y			lda 	(codePtr),y
.9834	48		pha				pha
.9835	c8		iny				iny 								; first character
.9836	20 ec a4	jsr $a4ec			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9839	68		pla				pla 								; restore count and save
.983a	85 36		sta $36				sta 	zTemp0
.983c	98		tya				tya 								; add length to Y to skip it.
.983d	18		clc				clc
.983e	65 36		adc $36				adc 	zTemp0
.9840	a8		tay				tay
.9841	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9843	95 50		sta $50,x			sta 	NSStatus,x
.9845	60		rts				rts
.9846					_ETVariable:
.9846	4c 9b 98	jmp $989b			jmp 	VariableHandler
.9849					_ETPuncUnary:
.9849	c8		iny				iny 								; consume the unary character
.984a	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.984c	f0 2b		beq $9879			beq 	_ETUnaryNegate
.984e	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9850	f0 36		beq $9888			beq 	_ETDereference
.9852	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9854	f0 3e		beq $9894			beq 	_ETParenthesis
.9856	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9858	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.985a	f0 06		beq $9862			beq 	_ETIndirection
.985c	e6 36		inc $36				inc 	zTemp0
.985e	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9860	d0 a3		bne $9805			bne 	_ETSyntaxError
.9862					_ETIndirection:
.9862	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9864	1a		inc a				inc 	a
.9865	48		pha				pha
.9866	20 d2 97	jsr $97d2			jsr 	EvaluateTerm				; evaluate the term
.9869	20 4b 96	jsr $964b			jsr 	Dereference 				; dereference it.
.986c	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.986e	d0 06		bne $9876			bne 	_ETTypeMismatch
.9870	68		pla				pla 								; indirection 1-2
.9871	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9873	95 50		sta $50,x			sta 	NSStatus,x
.9875	60		rts				rts
.9876					_ETTypeMismatch:
.9876	4c 19 9f	jmp $9f19			jmp 	TypeError
.9879					_ETUnaryNegate:
.9879	20 d2 97	jsr $97d2			jsr 	EvaluateTerm				; evaluate the term
.987c	20 4b 96	jsr $964b			jsr 	Dereference 				; dereference it.
.987f	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.9881	29 10		and #$10			and 	#NSTString
.9883	d0 f1		bne $9876			bne 	_ETTypeMismatch
.9885	4c 53 9d	jmp $9d53			jmp 	NSMNegate  					; just toggles the sign bit.
.9888					_ETDereference:
.9888	20 d2 97	jsr $97d2			jsr 	EvaluateTerm				; evaluate the term
.988b	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.988d	29 20		and #$20			and 	#NSBIsReference
.988f	f0 e5		beq $9876			beq 	_ETTypeMismatch
.9891	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9893	60		rts				rts
.9894					_ETParenthesis:
.9894	20 88 93	jsr $9388			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9897	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket 			; check for )
.989a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.989b					VariableHandler:
.989b	b1 30		lda ($30),y			lda 	(codePtr),y
.989d	18		clc				clc
.989e	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.98a0	85 37		sta $37				sta 	zTemp0+1
.98a2	c8		iny				iny
.98a3	b1 30		lda ($30),y			lda 	(codePtr),y
.98a5	85 36		sta $36				sta 	zTemp0
.98a7	c8		iny				iny
.98a8	18		clc				clc									; copy variable address+3 to mantissa
.98a9	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.98ab	95 58		sta $58,x			sta 	NSMantissa0,x
.98ad	a5 37		lda $37				lda 	zTemp0+1
.98af	69 00		adc #$00			adc 	#0
.98b1	95 60		sta $60,x			sta 	NSMantissa1,x
.98b3	74 68		stz $68,x			stz 	NSMantissa2,x
.98b5	74 70		stz $70,x			stz 	NSMantissa3,x
.98b7	74 78		stz $78,x			stz 	NSExponent,x
.98b9	5a		phy				phy
.98ba	a0 02		ldy #$02			ldy 	#2 							; read type
.98bc	b1 36		lda ($36),y			lda 	(zTemp0),y
.98be	7a		ply				ply
.98bf	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.98c1	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.98c3	95 50		sta $50,x			sta 	NSStatus,x
.98c5	29 04		and #$04			and 	#NSBIsArray
.98c7	d0 01		bne $98ca			bne 	_VHArray
.98c9	60		rts				rts
.98ca					_VHArray:
.98ca	e8		inx				inx
.98cb	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; get the 1st index.
.98ce	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.98d0	95 51		sta $51,x			sta 	NSStatus+1,x
.98d2	b1 30		lda ($30),y			lda 	(codePtr),y
.98d4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.98d6	d0 06		bne $98de			bne 	_VHNoSecondIndex
.98d8	c8		iny				iny 								; skip the comma
.98d9	e8		inx				inx
.98da	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.98dd	ca		dex				dex
.98de					_VHNoSecondIndex:
.98de	ca		dex				dex 								; set X back.
.98df	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket 			; and check the right bracket.
.98e2	5a		phy				phy 								; save position
.98e3	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.98e5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98e7	f0 60		beq $9949			beq 	_VHBadIndex
.98e9	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.98eb	85 3e		sta $3e				sta 	zaTemp
.98ed	b5 60		lda $60,x			lda 	NSMantissa1,x
.98ef	85 3f		sta $3f				sta 	zaTemp+1
.98f1	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.98f3	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.98f5	f0 02		beq $98f9			beq 	_VHHas2Mask
.98f7	a9 ff		lda #$ff			lda 	#$FF
.98f9					_VHHas2Mask:
.98f9	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.98fb	f0 4c		beq $9949			beq 	_VHBadIndex
.98fd	0a		asl a				asl 	a 							; carry will be set if a second index
.98fe	90 08		bcc $9908			bcc 	_VHCheckFirstIndex
.9900	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9902	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9904	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.9906	90 41		bcc $9949			bcc 	_VHBadIndex
.9908					_VHCheckFirstIndex:
.9908	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.990a	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.990c	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.990e	90 39		bcc $9949			bcc 	_VHBadIndex
.9910	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9912	64 37		stz $37				stz 	zTemp0+1
.9914	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9916	30 0e		bmi $9926			bmi 	_VHNoMultiply
.9918	da		phx				phx
.9919	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.991b	48		pha				pha
.991c	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.991e	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9920	1a		inc a				inc 	a 							; add 1 for zero base
.9921	fa		plx				plx
.9922	20 3c 9d	jsr $9d3c			jsr 	Multiply8x8 				; calculate -> Z0
.9925	fa		plx				plx
.9926					_VHNoMultiply:
.9926	18		clc				clc
.9927	a5 36		lda $36				lda 	zTemp0
.9929	75 59		adc $59,x			adc 	NSMantissa0+1,x
.992b	85 36		sta $36				sta 	zTemp0
.992d	a5 37		lda $37				lda 	zTemp0+1
.992f	69 00		adc #$00			adc 	#0
.9931	85 37		sta $37				sta 	zTemp0+1
.9933	b5 50		lda $50,x			lda 	NSStatus,x
.9935	20 df 84	jsr $84df			jsr 	ScaleByBaseType
.9938	18		clc				clc
.9939	b2 3e		lda ($3e)			lda 	(zaTemp)
.993b	65 36		adc $36				adc 	zTemp0
.993d	95 58		sta $58,x			sta 	NSMantissa0,x
.993f	a0 01		ldy #$01			ldy 	#1
.9941	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9943	65 37		adc $37				adc 	zTemp0+1
.9945	95 60		sta $60,x			sta 	NSMantissa1,x
.9947	7a		ply				ply 								; restore position
.9948	60		rts				rts
.9949					_VHBadIndex:
.9949	a9 17		lda #$17		lda	#23
.994b	4c 84 8e	jmp $8e84		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.994e					AbsUnary:
.994e	fa		plx				plx 								; restore stack pos
.994f	20 df 9c	jsr $9cdf			jsr 	EvaluateNumber 				; get a float or int
.9952	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.9955	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.9957	29 7f		and #$7f			and 	#$7F
.9959	95 50		sta $50,x			sta 	NSStatus,x
.995b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.995c					AllocUnary:
.995c	fa		plx				plx 								; restore stack pos
.995d	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger		; get bytes required.
.9960	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.9963	da		phx				phx 								; save X/Y
.9964	5a		phy				phy
.9965	8a		txa				txa 								; copy X into Y
.9966	a8		tay				tay
.9967	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.996a	aa		tax				tax
.996b	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.996e	20 7b 99	jsr $997b			jsr 	AllocateXABytes 			; allocate memory
.9971	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.9974	8a		txa				txa 	 							; typing is 16 bit integer.
.9975	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.9978	7a		ply				ply
.9979	fa		plx				plx
.997a	60		rts				rts
.997b					AllocateXABytes:
.997b	5a		phy				phy
.997c	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.997f	84 36		sty $36				sty 	zTemp0
.9981	5a		phy				phy
.9982	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.9985	84 37		sty $37				sty 	zTemp0+1
.9987	5a		phy				phy
.9988	18		clc				clc 								; add to low memory pointer
.9989	6d 0c 04	adc $040c			adc 	lowMemPtr
.998c	8d 0c 04	sta $040c			sta 	lowMemPtr
.998f	8a		txa				txa
.9990	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9993	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9996	b0 2f		bcs $99c7			bcs 	CISSMemory
.9998	20 b9 99	jsr $99b9			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.999b					_ClearMemory:
.999b	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.999e	c5 36		cmp $36				cmp 	zTemp0
.99a0	d0 07		bne $99a9			bne 	_CMClearNext
.99a2	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.99a5	c5 37		cmp $37				cmp 	zTemp0+1
.99a7	f0 0c		beq $99b5			beq 	_CMExit
.99a9					_CMClearNext:
.99a9	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.99ab	92 36		sta ($36)			sta 	(zTemp0)
.99ad	e6 36		inc $36				inc 	zTemp0
.99af	d0 ea		bne $999b			bne 	_ClearMemory
.99b1	e6 37		inc $37				inc		zTemp0+1
.99b3	80 e6		bra $999b			bra 	_ClearMemory
.99b5					_CMExit:
.99b5	fa		plx				plx
.99b6	68		pla				pla
.99b7	7a		ply				ply
.99b8	60		rts				rts
.99b9					CheckIdentifierStringSpace:
.99b9	48		pha				pha
.99ba	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.99bd	18		clc				clc
.99be	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.99c0	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.99c3	b0 02		bcs $99c7			bcs 	CISSMemory
.99c5	68		pla				pla
.99c6	60		rts				rts
.99c7					CISSMemory:
.99c7	a9 06		lda #$06		lda	#6
.99c9	4c 84 8e	jmp $8e84		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.99cc					AscUnary:
.99cc	fa		plx				plx 								; restore stack pos
.99cd	20 e9 9c	jsr $9ce9			jsr 	EvaluateString 				; get a string
.99d0	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.99d2	20 93 9d	jsr $9d93			jsr 	NSMSetByte 					; ASC("") will return zero.
.99d5	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.99d8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.99d9					FracUnary:
.99d9	fa		plx				plx 								; restore stack pos
.99da	20 df 9c	jsr $9cdf			jsr 	EvaluateNumber 				; get a float or int
.99dd	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.99e0	b5 50		lda $50,x			lda 	NSStatus,x
.99e2	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.99e4	f0 04		beq $99ea			beq 	_IUZero
.99e6	20 99 94	jsr $9499			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.99e9	60		rts				rts
.99ea					_IUZero:
.99ea	20 91 9d	jsr $9d91			jsr 	NSMSetZero
.99ed	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.99ee					IntUnary:
.99ee	fa		plx				plx 								; restore stack pos
.99ef	20 df 9c	jsr $9cdf			jsr 	EvaluateNumber 				; get a float or int
.99f2	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.99f5	b5 50		lda $50,x			lda 	NSStatus,x
.99f7	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.99f9	f0 03		beq $99fe			beq 	_IUExit
.99fb	20 f1 94	jsr $94f1			jsr 	FloatIntegerPart 			; if it is get the integer part.
.99fe					_IUExit:
.99fe	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.99ff					LenUnary:
.99ff	fa		plx				plx 								; restore stack pos
.9a00	20 e9 9c	jsr $9ce9			jsr 	EvaluateString 				; get a string
.9a03	5a		phy				phy
.9a04	a0 00		ldy #$00			ldy 	#0 							; find length
.9a06					_LenFind:
.9a06	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9a08	f0 06		beq $9a10			beq 	_LenExit
.9a0a	c8		iny				iny
.9a0b	d0 f9		bne $9a06			bne 	_LenFind
.9a0d	4c 14 9f	jmp $9f14			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9a10					_LenExit:
.9a10	98		tya				tya		 							; return length
.9a11	20 93 9d	jsr $9d93			jsr 	NSMSetByte
.9a14	7a		ply				ply
.9a15	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.9a18	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9a19					Unary_Min:
.9a19	a9 01		lda #$01			lda 	#1
.9a1b	80 02		bra $9a1f			bra 	UnaryMinMaxMain
.9a1d					Unary_Max:
.9a1d	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9a1f					UnaryMinMaxMain:
.9a1f	fa		plx				plx 								; get index on number stack
.9a20	48		pha				pha 								; save comparator
.9a21	20 d6 9c	jsr $9cd6			jsr 	EvaluateValue 				; get the first value.
.9a24					_UMMMLoop:
.9a24	b1 30		lda ($30),y			lda 	(codePtr),y
.9a26	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9a28	f0 22		beq $9a4c			beq 	_UMMMDone
.9a2a	20 73 8e	jsr $8e73			jsr 	CheckComma 					; must be a comma
.9a2d	e8		inx				inx
.9a2e	20 d6 9c	jsr $9cd6			jsr 	EvaluateValue
.9a31	ca		dex				dex
.9a32	20 74 9d	jsr $9d74			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9a35	e8		inx				inx
.9a36	20 74 9d	jsr $9d74			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9a39	e8		inx				inx
.9a3a	20 3b 8f	jsr $8f3b			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9a3d	ca		dex				dex
.9a3e	ca		dex				dex
.9a3f	85 36		sta $36				sta 	zTemp0 						; save required result
.9a41	68		pla				pla 								; get and save comparator
.9a42	48		pha				pha
.9a43	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9a45	d0 dd		bne $9a24			bne 	_UMMMLoop
.9a47	20 4f 9a	jsr $9a4f			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9a4a	80 d8		bra $9a24			bra 	_UMMMLoop
.9a4c					_UMMMDone:
.9a4c	68		pla				pla 								; throw the comparator
.9a4d	c8		iny				iny 								; skip )
.9a4e	60		rts				rts
.9a4f					ExpCopyAboveDown:
.9a4f	b5 51		lda $51,x			lda 	NSStatus+1,x
.9a51	95 50		sta $50,x			sta 	NSStatus,x
.9a53	b5 79		lda $79,x			lda 	NSExponent+1,x
.9a55	95 78		sta $78,x			sta 	NSExponent,x
.9a57	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9a59	95 58		sta $58,x			sta 	NSMantissa0,x
.9a5b	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9a5d	95 60		sta $60,x			sta 	NSMantissa1,x
.9a5f	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9a61	95 68		sta $68,x			sta 	NSMantissa2,x
.9a63	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9a65	95 70		sta $70,x			sta 	NSMantissa3,x
.9a67	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9a68					Unary_Not:
.9a68	fa		plx				plx
.9a69	20 fe 9c	jsr $9cfe			jsr 	EvaluateInteger 			; get integer
.9a6c	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.9a6f	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; zero mantissa ?
.9a72	f0 04		beq $9a78			beq 	_NotZero
.9a74	20 91 9d	jsr $9d91			jsr 	NSMSetZero
.9a77	60		rts				rts
.9a78					_NotZero:
.9a78	4c f1 8e	jmp $8ef1			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9a7b					Unary_Random:
.9a7b	fa		plx				plx
.9a7c	20 ed 9a	jsr $9aed			jsr 	Random32Bit 				; get a random number
.9a7f	20 d6 9a	jsr $9ad6			jsr 	URCopyToMantissa  			; put in mantissa
.9a82	b1 30		lda ($30),y			lda 	(codePtr),y
.9a84	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9a86	f0 08		beq $9a90			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9a88	e8		inx				inx
.9a89	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9a8c	ca		dex				dex
.9a8d	20 43 90	jsr $9043			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9a90					_URNoModulus:
.9a90	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9a92	74 78		stz $78,x			stz 	NSExponent,x
.9a94	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.9a97	60		rts				rts
.9a98					Unary_Rnd:
.9a98	fa		plx				plx
.9a99	20 df 9c	jsr $9cdf			jsr 	EvaluateNumber 				; number to use.
.9a9c	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket 			; closing bracket
.9a9f	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9aa2	f0 26		beq $9aca			beq 	_URCopySeed
.9aa4	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9aa6	10 1f		bpl $9ac7			bpl 	_URDontSeed
.9aa8	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9aaa	49 17		eor #$17			eor 	#$17
.9aac	8d 08 04	sta $0408			sta 	RandomSeed+0
.9aaf	b5 60		lda $60,x			lda 	NSMantissa1,x
.9ab1	49 a5		eor #$a5			eor 	#$A5
.9ab3	8d 09 04	sta $0409			sta 	RandomSeed+1
.9ab6	b5 68		lda $68,x			lda 	NSMantissa2,x
.9ab8	49 c2		eor #$c2			eor 	#$C2
.9aba	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9abd	b5 70		lda $70,x			lda 	NSMantissa3,x
.9abf	49 9d		eor #$9d			eor 	#$9D
.9ac1	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9ac4	20 ed 9a	jsr $9aed			jsr 	Random32Bit
.9ac7					_URDontSeed:
.9ac7	20 ed 9a	jsr $9aed			jsr 	Random32Bit 				; generate a number
.9aca					_URCopySeed:
.9aca	20 d6 9a	jsr $9ad6			jsr 	URCopyToMantissa 			; copy into mantissa
.9acd	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9acf	95 78		sta $78,x			sta 	NSExponent,x
.9ad1	a9 08		lda #$08			lda 	#NSTFloat
.9ad3	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9ad5	60		rts				rts
.9ad6					URCopyToMantissa:
.9ad6	ad 08 04	lda $0408			lda 	RandomSeed+0
.9ad9	95 58		sta $58,x			sta 	NSMantissa0,x
.9adb	ad 09 04	lda $0409			lda 	RandomSeed+1
.9ade	95 60		sta $60,x			sta 	NSMantissa1,x
.9ae0	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9ae3	95 68		sta $68,x			sta 	NSMantissa2,x
.9ae5	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9ae8	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9aea	95 70		sta $70,x			sta 	NSMantissa3,x
.9aec	60		rts				rts
.9aed					Random32Bit:
.9aed	5a		phy				phy
.9aee	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9af0	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9af3	d0 03		bne $9af8			bne 	_Random1
.9af5	a8		tay				tay 								; if so do it 256 times
.9af6	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9af8					_Random1:
.9af8	0a		asl a				asl 	a 							; LSFR RNG
.9af9	2e 09 04	rol $0409			rol 	RandomSeed+1
.9afc	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9aff	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9b02	90 02		bcc $9b06			bcc 	_Random2
.9b04	49 c5		eor #$c5			eor 	#$C5
.9b06					_Random2:
.9b06	88		dey				dey
.9b07	d0 ef		bne $9af8			bne 	_Random1
.9b09	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b0c	7a		ply				ply
.9b0d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9b0e					SgnUnary:
.9b0e	fa		plx				plx 								; restore stack pos
.9b0f	20 df 9c	jsr $9cdf			jsr 	EvaluateNumber 				; get a float or int
.9b12	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.9b15	20 b3 9d	jsr $9db3			jsr 	NSMIsZero 					; if zero
.9b18	f0 0e		beq $9b28			beq 	_SGZero  					; return Int Zero
.9b1a	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9b1c	48		pha				pha
.9b1d	a9 01		lda #$01			lda 	#1 							; set to 1
.9b1f	20 93 9d	jsr $9d93			jsr 	NSMSetByte
.9b22	68		pla				pla
.9b23	29 80		and #$80			and		#$80 						; copy the sign byte out
.9b25	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9b27	60		rts				rts
.9b28	20 91 9d	jsr $9d91	_SGZero:jsr 	NSMSetZero
.9b2b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9b2c					ValUnary:
.9b2c	fa		plx				plx 								; restore stack pos
.9b2d	20 42 9b	jsr $9b42			jsr 	ValMainCode 				; do the main val() code
.9b30	b0 01		bcs $9b33			bcs 	_VUError 					; couldn't convert
.9b32	60		rts				rts
.9b33					_VUError:
.9b33	4c 19 9f	jmp $9f19			jmp 	TypeError
.9b36					IsValUnary:
.9b36	fa		plx				plx 								; restore stack pos
.9b37	20 42 9b	jsr $9b42			jsr 	ValMainCode 				; do the main val() code
.9b3a	b0 03		bcs $9b3f			bcs 	_VUBad
.9b3c	4c f1 8e	jmp $8ef1			jmp 	ReturnTrue
.9b3f					_VUBad:
.9b3f	4c fc 8e	jmp $8efc			jmp 	ReturnFalse
.9b42					ValMainCode:
.9b42	20 e9 9c	jsr $9ce9			jsr 	EvaluateString 				; get a string
.9b45	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket 			; check right bracket present
.9b48					ValEvaluateZTemp0:
.9b48	5a		phy				phy
.9b49	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9b4b	f0 17		beq $9b64			beq 	_VMCFail2
.9b4d	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9b4f	48		pha				pha 								; save first character
.9b50	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9b52	d0 01		bne $9b55			bne 	_VMCStart
.9b54	c8		iny				iny 								; skip over -
.9b55					_VMCStart:
.9b55	38		sec				sec 								; initialise first time round.
.9b56					_VMCNext:
.9b56	c8		iny				iny 								; pre-increment
.9b57	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9b59	f0 0c		beq $9b67			beq 	_VMCSuccess 				; successful.
.9b5b	20 ce 96	jsr $96ce			jsr 	EncodeNumber 				; send it to the number-builder
.9b5e	90 03		bcc $9b63			bcc 	_VMCFail 					; if failed, give up.
.9b60	18		clc				clc 								; next time round, countinue
.9b61	80 f3		bra $9b56			bra 	_VMCNext
.9b63					_VMCFail:
.9b63	68		pla				pla
.9b64					_VMCFail2:
.9b64	7a		ply				ply
.9b65	38		sec				sec
.9b66	60		rts				rts
.9b67					_VMCSuccess:
.9b67	a9 00		lda #$00			lda 	#0 							; construct final
.9b69	20 ce 96	jsr $96ce			jsr 	EncodeNumber 				; by sending a duff value.
.9b6c	68		pla				pla 								; if it was -ve
.9b6d	c9 2d		cmp #$2d			cmp 	#"-"
.9b6f	d0 03		bne $9b74			bne 	_VMCNotNegative
.9b71	20 53 9d	jsr $9d53			jsr		NSMNegate 					; negate it.
.9b74					_VMCNotNegative:
.9b74	7a		ply				ply
.9b75	18		clc				clc
.9b76	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9b77					ChrUnary:
.9b77	fa		plx				plx 								; restore stack pos
.9b78	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9b7b	48		pha				pha
.9b7c	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.9b7f	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9b81	20 c3 a6	jsr $a6c3			jsr 	StringTempAllocate
.9b84	68		pla				pla 								; write number to it
.9b85	20 fc a6	jsr $a6fc			jsr 	StringTempWrite
.9b88	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9b89					SpcUnary:
.9b89	fa		plx				plx 								; restore stack pos
.9b8a	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger			; get value
.9b8d	5a		phy				phy
.9b8e	48		pha				pha 								; save count
.9b8f	20 c3 a6	jsr $a6c3			jsr 	StringTempAllocate
.9b92	7a		ply				ply 								; to do count in Y
.9b93					_SpcLoop:
.9b93	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9b95	f0 08		beq $9b9f			beq 	_SpcExit
.9b97	a9 20		lda #$20			lda 	#32
.9b99	20 fc a6	jsr $a6fc			jsr 	StringTempWrite
.9b9c	88		dey				dey
.9b9d	80 f4		bra $9b93			bra 	_SPCLoop
.9b9f					_SpcExit:
.9b9f	7a		ply				ply
.9ba0	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.9ba3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9ba4					Unary_Str:
.9ba4	fa		plx				plx
.9ba5	20 df 9c	jsr $9cdf			jsr 	EvaluateNumber  			; get number
.9ba8	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket 			; closing bracket
.9bab	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9bad	20 c6 9b	jsr $9bc6			jsr 	ConvertNumberToString 		; do the conversion.
.9bb0	a9 21		lda #$21			lda		#33 						; create buffer
.9bb2	20 c3 a6	jsr $a6c3			jsr 	StringTempAllocate 			; allocate memory
.9bb5	da		phx				phx  								; copy the converted string into the buffer.
.9bb6	a2 00		ldx #$00			ldx 	#0
.9bb8					_USCopy:
.9bb8	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9bbb	20 fc a6	jsr $a6fc			jsr 	StringTempWrite
.9bbe	e8		inx				inx
.9bbf	bd 9d 05	lda $059d,x			lda 	DecimalBuffer,x
.9bc2	d0 f4		bne $9bb8			bne 	_USCopy
.9bc4	fa		plx				plx
.9bc5	60		rts				rts
.9bc6					ConvertNumberToString:
.9bc6	5a		phy				phy 								; save code position
.9bc7	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9bca	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9bcd	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9bcf	10 09		bpl $9bda			bpl 	_CNTSNotNegative
.9bd1	29 7f		and #$7f			and 	#$7F 						; make +ve
.9bd3	95 50		sta $50,x			sta 	NSStatus,x
.9bd5	a9 2d		lda #$2d			lda 	#"-"
.9bd7	20 3b 9c	jsr $9c3b			jsr 	WriteDecimalBuffer
.9bda					_CNTSNotNegative:
.9bda	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9bdc	f0 12		beq $9bf0			beq 	_CNTSNotFloat
.9bde	e8		inx				inx 								; round up so we don't get too many 6.999999
.9bdf	a9 01		lda #$01			lda 	#1
.9be1	20 93 9d	jsr $9d93			jsr 	NSMSetByte
.9be4	ca		dex				dex
.9be5	b5 78		lda $78,x			lda		NSExponent,x
.9be7	95 79		sta $79,x			sta 	NSExponent+1,x
.9be9	a9 08		lda #$08			lda 	#NSTFloat
.9beb	95 51		sta $51,x			sta 	NSStatus+1,x
.9bed	20 d3 93	jsr $93d3			jsr 	FloatAdd
.9bf0					_CNTSNotFloat:
.9bf0	20 1d 9c	jsr $9c1d			jsr 	MakePlusTwoString 			; do the integer part.
.9bf3	20 99 94	jsr $9499			jsr 	FloatFractionalPart 		; get the fractional part
.9bf6	20 4a 95	jsr $954a			jsr 	NSNormalise					; normalise , exit if zero
.9bf9	f0 20		beq $9c1b			beq 	_CNTSExit
.9bfb	a9 2e		lda #$2e			lda 	#"."
.9bfd	20 3b 9c	jsr $9c3b			jsr 	WriteDecimalBuffer 			; write decimal place
.9c00					_CNTSDecimal:
.9c00	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9c03	30 16		bmi $9c1b			bmi 	_CNTSExit
.9c05	e8		inx				inx 								; x 10.0
.9c06	a9 0a		lda #$0a			lda 	#10
.9c08	20 93 9d	jsr $9d93			jsr 	NSMSetByte
.9c0b	a9 08		lda #$08			lda 	#NSTFloat
.9c0d	95 50		sta $50,x			sta 	NSStatus,x
.9c0f	ca		dex				dex
.9c10	20 18 95	jsr $9518			jsr 	FloatMultiply
.9c13	20 1d 9c	jsr $9c1d			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9c16	20 99 94	jsr $9499			jsr 	FloatFractionalPart 		; get the fractional part
.9c19	80 e5		bra $9c00			bra 	_CNTSDecimal 				; keep going.
.9c1b					_CNTSExit:
.9c1b	7a		ply				ply
.9c1c	60		rts				rts
.9c1d					MakePlusTwoString:
.9c1d	da		phx				phx
.9c1e	20 74 9d	jsr $9d74			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9c21	e8		inx				inx 								; access it
.9c22	e8		inx				inx
.9c23	20 f1 94	jsr $94f1			jsr 	FloatIntegerPart 			; make it an integer
.9c26	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9c28	20 03 93	jsr $9303			jsr 	ConvertInt32
.9c2b	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9c2d					_MPTSCopy:
.9c2d	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9c30	20 3b 9c	jsr $9c3b			jsr 	WriteDecimalBuffer
.9c33	e8		inx				inx
.9c34	bd 7b 05	lda $057b,x			lda 	NumberBuffer,x
.9c37	d0 f4		bne $9c2d			bne 	_MPTSCopy
.9c39	fa		plx				plx
.9c3a	60		rts				rts
.9c3b					WriteDecimalBuffer:
.9c3b	da		phx				phx
.9c3c	ae 15 04	ldx $0415			ldx 	dbOffset
.9c3f	9d 9d 05	sta $059d,x			sta 	DecimalBuffer,x
.9c42	9e 9e 05	stz $059e,x			stz 	DecimalBuffer+1,x
.9c45	ee 15 04	inc $0415			inc 	dbOffset
.9c48	fa		plx				plx
.9c49	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9c4a					Unary_Left:
.9c4a	fa		plx				plx
.9c4b	18		clc				clc 								; only one parameter
.9c4c	20 af 9c	jsr $9caf			jsr 	SubstringInitial 			; set up.
.9c4f	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9c51	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c53	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9c55	80 25		bra $9c7c			bra 	SubstringMain
.9c57					Unary_Right:
.9c57	fa		plx				plx
.9c58	18		clc				clc 								; only one parameter
.9c59	20 af 9c	jsr $9caf			jsr 	SubstringInitial 			; set up.
.9c5c	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9c5e	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9c60	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9c62	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9c64	b0 02		bcs $9c68			bcs 	_URNotUnderflow
.9c66	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9c68					_URNotUnderFlow:
.9c68	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9c6a	80 10		bra $9c7c			bra 	SubStringMain
.9c6c					Unary_Mid:
.9c6c	fa		plx				plx
.9c6d	38		sec				sec 								; two parameters
.9c6e	20 af 9c	jsr $9caf			jsr 	SubstringInitial 			; set up.
.9c71	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9c73	f0 04		beq $9c79			beq 	_UMError
.9c75	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9c77	80 03		bra $9c7c			bra 	SubStringMain
.9c79					_UMError:
.9c79	4c 1e 9f	jmp $9f1e			jmp 	ArgumentError
.9c7c					SubStringMain:
.9c7c	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9c7e	d5 78		cmp $78,x			cmp 	NSExponent,x
.9c80	b0 27		bcs $9ca9			bcs 	_SSMNull 					; if so, return an empty string.
.9c82	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9c84	f0 23		beq $9ca9			beq 	_SSMNull 					; return empty string.
.9c86	18		clc				clc 								; add the offset +1 to the address and
.9c87	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9c89	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9c8b	85 36		sta $36				sta 	zTemp0
.9c8d	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9c8f	69 00		adc #$00			adc 	#0
.9c91	85 37		sta $37				sta 	zTemp0+1
.9c93					_SSMNoCarry:
.9c93	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9c95	20 c3 a6	jsr $a6c3			jsr 	StringTempAllocate 			; allocate that many characters
.9c98	5a		phy				phy 								; save Y
.9c99	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9c9b					_SSMCopy:
.9c9b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9c9d	f0 08		beq $9ca7			beq 	_SSMEString 				; no more to copy
.9c9f	20 fc a6	jsr $a6fc			jsr 	StringTempWrite 			; and write it out.
.9ca2	c8		iny				iny
.9ca3	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9ca5	d0 f4		bne $9c9b			bne 	_SSMCopy
.9ca7					_SSMEString:
.9ca7	7a		ply				ply
.9ca8					_SSMExit:
.9ca8	60		rts				rts
.9ca9					_SSMNull:
.9ca9	a9 00		lda #$00			lda 	#0
.9cab	20 c3 a6	jsr $a6c3			jsr 	StringTempAllocate
.9cae	60		rts				rts
.9caf					SubstringInitial:
.9caf	da		phx				phx 								; save initial stack position
.9cb0	08		php				php 								; save carry on stack indicating 2 parameters
.9cb1	20 e9 9c	jsr $9ce9			jsr 	EvaluateString 				; get a string
.9cb4	5a		phy				phy 								; calculate length to exponent.
.9cb5	a0 ff		ldy #$ff			ldy 	#$FF
.9cb7					_SIFindLength:
.9cb7	c8		iny				iny
.9cb8	b1 36		lda ($36),y			lda 	(zTemp0),y
.9cba	d0 fb		bne $9cb7			bne 	_SIFindLength
.9cbc	98		tya				tya
.9cbd	95 78		sta $78,x			sta 	NSExponent,x
.9cbf	7a		ply				ply
.9cc0	e8		inx				inx
.9cc1	20 73 8e	jsr $8e73			jsr 	CheckComma 					; comma next
.9cc4	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; get next parameter
.9cc7	28		plp				plp 								; is it the last parameter ?
.9cc8	90 07		bcc $9cd1			bcc 	_SSIExit 					; if so, exit.
.9cca	e8		inx				inx
.9ccb	20 73 8e	jsr $8e73			jsr 	CheckComma 					; comma next
.9cce	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; get last parameter
.9cd1					_SSIExit:
.9cd1	fa		plx				plx
.9cd2	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket 			; check closing bracket
.9cd5	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9cd6					EvaluateValue:
.9cd6	48		pha				pha
.9cd7	20 88 93	jsr $9388			jsr		EvaluateExpression 			; expression
.9cda	20 4b 96	jsr $964b			jsr 	Dereference					; derefernce it
.9cdd	68		pla				pla
.9cde	60		rts				rts
.9cdf					EvaluateNumber:
.9cdf	20 d6 9c	jsr $9cd6			jsr 	EvaluateValue 				; get a value
.9ce2	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9ce4	29 10		and #$10			and 	#NSBIsString
.9ce6	d0 13		bne $9cfb			bne 	HelperTypeError
.9ce8	60		rts				rts
.9ce9					EvaluateString:
.9ce9	20 d6 9c	jsr $9cd6			jsr 	EvaluateValue 				; get a value
.9cec	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9cee	29 10		and #$10			and 	#NSBIsString
.9cf0	f0 09		beq $9cfb			beq 	HelperTypeError
.9cf2					CopyAddressToTemp0:
.9cf2	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9cf4	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9cf6	b5 60		lda $60,x			lda 	NSMantissa1,x
.9cf8	85 37		sta $37				sta 	zTemp0+1
.9cfa	60		rts				rts
.9cfb					HelperTypeError:
.9cfb	4c 19 9f	jmp $9f19			jmp 	TypeError
.9cfe					EvaluateInteger:
.9cfe	20 df 9c	jsr $9cdf			jsr 	EvaluateNumber
.9d01	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9d03	d0 09		bne $9d0e			bne 	HelperValueError 			; if not, it's a float.
.9d05	60		rts				rts
.9d06					EvaluateUnsignedInteger:
.9d06	20 fe 9c	jsr $9cfe			jsr 	EvaluateInteger 			; check integer is +ve
.9d09	b5 50		lda $50,x			lda 	NSStatus,x
.9d0b	30 01		bmi $9d0e			bmi 	HelperValueError
.9d0d	60		rts				rts
.9d0e					HelperValueError:
.9d0e	4c 1e 9f	jmp $9f1e			jmp 	ArgumentError
.9d11						Evaluate16BitInteger:
.9d11	20 06 9d	jsr $9d06			jsr	 	EvaluateUnsignedInteger		; get integer
.9d14	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d16	15 68		ora $68,x			ora 	NSMantissa2,x
.9d18	d0 f4		bne $9d0e			bne 	HelperValueError
.9d1a	60		rts				rts
.9d1b					Evaluate16BitIntegerSigned:
.9d1b	20 fe 9c	jsr $9cfe			jsr	 	EvaluateInteger				; get integer
.9d1e	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9d20	15 68		ora $68,x			ora 	NSMantissa2,x
.9d22	d0 ea		bne $9d0e			bne 	HelperValueError
.9d24	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9d26	10 03		bpl $9d2b			bpl 	_EISNotSigned
.9d28	20 5a 9d	jsr $9d5a			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9d2b					_EISNotSigned:
.9d2b	60		rts				rts
.9d2c					Evaluate8BitInteger:
.9d2c	20 06 9d	jsr $9d06			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9d2f	d0 dd		bne $9d0e			bne 	HelperValueError
.9d31	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9d33	15 68		ora $68,x			ora 	NSMantissa2,x
.9d35	15 60		ora $60,x			ora 	NSMantissa1,x
.9d37	d0 d5		bne $9d0e			bne 	HelperValueError
.9d39	b5 58		lda $58,x			lda 	NSMantissa0,x
.9d3b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9d3c					Multiply8x8:
.9d3c	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9d3d	85 36		sta $36			  	sta 	zTemp0
.9d3f	86 37		stx $37				stx 	zTemp0+1
.9d41	a9 00		lda #$00			lda 	#0
.9d43	a2 08		ldx #$08			ldx 	#8
.9d45					_M88Loop:
.9d45	90 03		bcc $9d4a			bcc 	_M88NoAdd
.9d47	18		clc				clc
.9d48	65 37		adc $37				adc 	zTemp0+1
.9d4a					_M88NoAdd:
.9d4a	6a		ror a				ror 	a
.9d4b	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9d4d	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9d4e	d0 f5		bne $9d45			bne 	_M88Loop
.9d50	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9d52	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9d53					NSMNegate:
.9d53	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9d55	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9d57	95 50		sta $50,x			sta 	NSStatus,x
.9d59	60		rts				rts
.9d5a					NSMNegateMantissa:
.9d5a	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9d5b	a9 00		lda #$00			lda 	#0
.9d5d	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9d5f	95 58		sta $58,x			sta 	NSMantissa0,x
.9d61	a9 00		lda #$00			lda 	#0
.9d63	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9d65	95 60		sta $60,x			sta 	NSMantissa1,x
.9d67	a9 00		lda #$00			lda 	#0
.9d69	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9d6b	95 68		sta $68,x			sta 	NSMantissa2,x
.9d6d	a9 00		lda #$00			lda 	#0
.9d6f	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9d71	95 70		sta $70,x			sta 	NSMantissa3,x
.9d73	60		rts				rts
.9d74					NSMShiftUpTwo:
.9d74	b5 58		lda $58,x			lda 	NSMantissa0,x
.9d76	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d78	b5 60		lda $60,x			lda 	NSMantissa1,x
.9d7a	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9d7c	b5 68		lda $68,x			lda 	NSMantissa2,x
.9d7e	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9d80	b5 70		lda $70,x			lda 	NSMantissa3,x
.9d82	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9d84	b5 78		lda $78,x			lda 	NSExponent,x
.9d86	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9d88	b5 50		lda $50,x			lda 	NSStatus,x
.9d8a	95 52		sta $52,x			sta 	NSStatus+2,x
.9d8c	60		rts				rts
.9d8d					NSMSetZeroMantissaOnly:
.9d8d	a9 00		lda #$00			lda 	#0
.9d8f	80 06		bra $9d97			bra 	NSMSetMantissa
.9d91					NSMSetZero:
.9d91	a9 00		lda #$00			lda 	#0
.9d93					NSMSetByte:
.9d93	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9d95	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9d97					NSMSetMantissa:
.9d97	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9d99	74 60		stz $60,x			stz 	NSMantissa1,x
.9d9b	74 68		stz $68,x			stz 	NSMantissa2,x
.9d9d	74 70		stz $70,x			stz 	NSMantissa3,x
.9d9f	60		rts				rts
.9da0					NSMShiftLeft:
.9da0	18		clc				clc
.9da1					NSMRotateLeft:
.9da1	36 58		rol $58,x			rol 	NSMantissa0,x
.9da3	36 60		rol $60,x			rol		NSMantissa1,x
.9da5	36 68		rol $68,x			rol		NSMantissa2,x
.9da7	36 70		rol $70,x			rol		NSMantissa3,x
.9da9	60		rts				rts
.9daa					NSMShiftRight:
.9daa	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9dac	76 68		ror $68,x			ror		NSMantissa2,x
.9dae	76 60		ror $60,x			ror		NSMantissa1,x
.9db0	76 58		ror $58,x			ror		NSMantissa0,x
.9db2	60		rts				rts
.9db3					NSMIsZero:
.9db3	b5 70		lda $70,x			lda 	NSMantissa3,x
.9db5	15 68		ora $68,x			ora		NSMantissa2,x
.9db7	15 60		ora $60,x			ora		NSMantissa1,x
.9db9	15 58		ora $58,x			ora		NSMantissa0,x
.9dbb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9dbc					TickHandler:
.9dbc	5a		phy				phy 								; need to preserve Y
.9dbd	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9dc0	7a		ply				ply
.9dc1	60		rts				rts
.05af					LastTick:
>05af							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9dc2					Assemble_ora:
.9dc2	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dc5	01					.byte $01
.9dc6					Assemble_and:
.9dc6	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dc9	21					.byte $21
.9dca					Assemble_eor:
.9dca	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dcd	41					.byte $41
.9dce					Assemble_adc:
.9dce	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dd1	61					.byte $61
.9dd2					Assemble_sta:
.9dd2	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dd5	81					.byte $81
.9dd6					Assemble_lda:
.9dd6	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9dd9	a1					.byte $a1
.9dda					Assemble_cmp:
.9dda	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9ddd	c1					.byte $c1
.9dde					Assemble_sbc:
.9dde	20 3f 80	jsr $803f		jsr	AssembleGroup1
>9de1	e1					.byte $e1
.9de2					Assemble_asl:
.9de2	20 46 80	jsr $8046		jsr	AssembleGroup2
>9de5	02					.byte $02
>9de6	75					.byte $75
.9de7					Assemble_rol:
.9de7	20 46 80	jsr $8046		jsr	AssembleGroup2
>9dea	22					.byte $22
>9deb	75					.byte $75
.9dec					Assemble_lsr:
.9dec	20 46 80	jsr $8046		jsr	AssembleGroup2
>9def	42					.byte $42
>9df0	75					.byte $75
.9df1					Assemble_ror:
.9df1	20 46 80	jsr $8046		jsr	AssembleGroup2
>9df4	62					.byte $62
>9df5	75					.byte $75
.9df6					Assemble_stx:
.9df6	20 46 80	jsr $8046		jsr	AssembleGroup2
>9df9	82					.byte $82
>9dfa	50					.byte $50
.9dfb					Assemble_ldx:
.9dfb	20 46 80	jsr $8046		jsr	AssembleGroup2
>9dfe	a2					.byte $a2
>9dff	d0					.byte $d0
.9e00					Assemble_dec:
.9e00	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e03	c2					.byte $c2
>9e04	55					.byte $55
.9e05					Assemble_inc:
.9e05	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e08	e2					.byte $e2
>9e09	55					.byte $55
.9e0a					Assemble_stz:
.9e0a	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e0d	60					.byte $60
>9e0e	44					.byte $44
.9e0f					Assemble_bit:
.9e0f	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e12	20					.byte $20
>9e13	55					.byte $55
.9e14					Assemble_sty:
.9e14	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e17	80					.byte $80
>9e18	54					.byte $54
.9e19					Assemble_ldy:
.9e19	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e1c	a0					.byte $a0
>9e1d	d5					.byte $d5
.9e1e					Assemble_cpy:
.9e1e	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e21	c0					.byte $c0
>9e22	d4					.byte $d4
.9e23					Assemble_cpx:
.9e23	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e26	e0					.byte $e0
>9e27	d0					.byte $d0
.9e28					Assemble_tsb:
.9e28	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e2b	00					.byte $00
>9e2c	50					.byte $50
.9e2d					Assemble_trb:
.9e2d	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e30	10					.byte $10
>9e31	50					.byte $50
.9e32					Assemble_jsr:
.9e32	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e35	14					.byte $14
>9e36	10					.byte $10
.9e37					Assemble_jmp:
.9e37	20 46 80	jsr $8046		jsr	AssembleGroup2
>9e3a	40					.byte $40
>9e3b	10					.byte $10
.9e3c					Assemble_bpl:
.9e3c	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e3f	10					.byte $10
.9e40					Assemble_bmi:
.9e40	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e43	30					.byte $30
.9e44					Assemble_bvc:
.9e44	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e47	50					.byte $50
.9e48					Assemble_bvs:
.9e48	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e4b	70					.byte $70
.9e4c					Assemble_bcc:
.9e4c	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e4f	90					.byte $90
.9e50					Assemble_bcs:
.9e50	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e53	b0					.byte $b0
.9e54					Assemble_bne:
.9e54	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e57	d0					.byte $d0
.9e58					Assemble_beq:
.9e58	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e5b	f0					.byte $f0
.9e5c					Assemble_bra:
.9e5c	20 97 80	jsr $8097		jsr	AssembleGroup3
>9e5f	80					.byte $80
.9e60					Assemble_brk:
.9e60	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e63	00					.byte $00
.9e64					Assemble_php:
.9e64	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e67	08					.byte $08
.9e68					Assemble_clc:
.9e68	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e6b	18					.byte $18
.9e6c					Assemble_plp:
.9e6c	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e6f	28					.byte $28
.9e70					Assemble_sec:
.9e70	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e73	38					.byte $38
.9e74					Assemble_rti:
.9e74	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e77	40					.byte $40
.9e78					Assemble_pha:
.9e78	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e7b	48					.byte $48
.9e7c					Assemble_cli:
.9e7c	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e7f	58					.byte $58
.9e80					Assemble_phy:
.9e80	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e83	5a					.byte $5a
.9e84					Assemble_rts:
.9e84	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e87	60					.byte $60
.9e88					Assemble_pla:
.9e88	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e8b	68					.byte $68
.9e8c					Assemble_sei:
.9e8c	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e8f	78					.byte $78
.9e90					Assemble_ply:
.9e90	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e93	7a					.byte $7a
.9e94					Assemble_dey:
.9e94	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e97	88					.byte $88
.9e98					Assemble_txa:
.9e98	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e9b	8a					.byte $8a
.9e9c					Assemble_tya:
.9e9c	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9e9f	98					.byte $98
.9ea0					Assemble_txs:
.9ea0	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ea3	9a					.byte $9a
.9ea4					Assemble_tay:
.9ea4	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ea7	a8					.byte $a8
.9ea8					Assemble_tax:
.9ea8	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9eab	aa					.byte $aa
.9eac					Assemble_clv:
.9eac	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9eaf	b8					.byte $b8
.9eb0					Assemble_tsx:
.9eb0	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9eb3	ba					.byte $ba
.9eb4					Assemble_iny:
.9eb4	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9eb7	c8					.byte $c8
.9eb8					Assemble_dex:
.9eb8	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ebb	ca					.byte $ca
.9ebc					Assemble_cld:
.9ebc	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ebf	d8					.byte $d8
.9ec0					Assemble_phx:
.9ec0	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ec3	da					.byte $da
.9ec4					Assemble_stp:
.9ec4	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ec7	db					.byte $db
.9ec8					Assemble_inx:
.9ec8	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ecb	e8					.byte $e8
.9ecc					Assemble_nop:
.9ecc	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ecf	ea					.byte $ea
.9ed0					Assemble_sed:
.9ed0	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ed3	f8					.byte $f8
.9ed4					Assemble_plx:
.9ed4	20 cb 80	jsr $80cb		jsr	AssembleGroup4
>9ed7	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9ed8					DecimalScalarTable:
>9ed8	66 66 66 66				.dword $66666666 ; 0.1
>9edc	de					.byte $de
>9edd	1f 85 eb 51				.dword $51eb851f ; 0.01
>9ee1	db					.byte $db
>9ee2	4c 37 89 41				.dword $4189374c ; 0.001
>9ee6	d8					.byte $d8
>9ee7	ac 8b db 68				.dword $68db8bac ; 0.0001
>9eeb	d4					.byte $d4
>9eec	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9ef0	d1					.byte $d1
>9ef1	83 de 1b 43				.dword $431bde83 ; 1e-06
>9ef5	ce					.byte $ce
>9ef6	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9efa	ca					.byte $ca
>9efb	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9eff	c7					.byte $c7
>9f00	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9f04	c4					.byte $c4
>9f05	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9f09	c0					.byte $c0
>9f0a	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9f0e	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9f0f					SyntaxError:
.9f0f	a9 02		lda #$02		lda	#2
.9f11	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.9f14					RangeError:
.9f14	a9 04		lda #$04		lda	#4
.9f16	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.9f19					TypeError:
.9f19	a9 05		lda #$05		lda	#5
.9f1b	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.9f1e					ArgumentError:
.9f1e	a9 07		lda #$07		lda	#7
.9f20	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.9f23					NotDoneError:
.9f23	a9 0c		lda #$0c		lda	#12
.9f25	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.9f28					ErrorText:
>9f28	42 72 65 61 6b 00			.text	"Break",0
>9f2e	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9f36	72 72 6f 72 00
>9f3b	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9f43	20 62 79 20 7a 65 72 6f 00
>9f4c	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>9f54	61 6e 67 65 00
>9f59	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>9f61	6d 61 74 63 68 00
>9f67	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>9f6f	65 6d 6f 72 79 00
>9f75	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>9f7d	61 72 67 75 6d 65 6e 74 00
>9f86	53 74 6f 70 00				.text	"Stop",0
>9f8b	53 74 72 69 6e 67 20 74			.text	"String too long",0
>9f93	6f 6f 20 6c 6f 6e 67 00
>9f9b	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>9fa3	6e 20 66 61 69 6c 65 64 00
>9fac	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>9fb4	61 74 61 00
>9fb8	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>9fc0	65 6e 74 65 64 00
>9fc6	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>9fce	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>9fda	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>9fe2	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>9fef	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>9ff7	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a004	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a00c	68 6f 75 74 20 57 68 69 6c 65 00
>a017	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a01f	68 6f 75 74 20 46 6f 72 00
>a028	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a030	61 63 6b 20 66 75 6c 6c 00
>a039	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a041	75 63 74 75 72 65 00
>a048	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a050	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a05d	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a065	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a073	41 72 72 61 79 20 73 69			.text	"Array size",0
>a07b	7a 65 00
>a07e	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a086	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a08e	52 65 6c 65 61 73 65 20			.text "Release Alpha 7 (27-Nov-22). "
>a096	41 6c 70 68 61 20 37 20 28 32 37 2d 4e 6f 76 2d
>a0a6	32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a0ab					RectangleCommand:
.a0ab	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a0ad	80 02		bra $a0b1			bra 	ShapeDrawCmd
.a0af					CircleCommand:
.a0af	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a0b1					ShapeDrawCmd:
.a0b1	20 3b a1	jsr $a13b			jsr 	RunGraphicsCommand
.a0b4					ShapeDraw:
.a0b4	0d b1 05	ora $05b1			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a0b7	4c 2f a1	jmp $a12f			jmp 	ExecuteGraphicCommand	 	; and complete
.a0ba					SpriteCommand:
.a0ba	a2 00		ldx #$00			ldx 	#0
.a0bc	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; get image number.
.a0bf	5a		phy				phy
.a0c0	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a0c2	a6 58		ldx $58				ldx 	NSMantissa0
.a0c4	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a0c6	b0 0d		bcs $a0d5			bcs 	_SCRange
.a0c8	a0 ff		ldy #$ff			ldy 	#255
.a0ca	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a0cd	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a0cf	7a		ply				ply
.a0d0	20 3b a1	jsr $a13b			jsr 	RunGraphicsCommand
.a0d3	80 5a		bra $a12f			bra 	ExecuteGraphicCommand
.a0d5					_SCRange:
.a0d5	4c 14 9f	jmp $9f14			jmp 	RangeError
.a0d8					ImageCommand:
.a0d8	a2 00		ldx #$00			ldx 	#0
.a0da	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; get image number.
.a0dd	20 3b a1	jsr $a13b			jsr 	RunGraphicsCommand
.a0e0					ImageRunDraw:
.a0e0	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a0e2	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a0e5	ad b7 05	lda $05b7			lda 	gxDrawScale
.a0e8	0a		asl a				asl 	a
.a0e9	0a		asl a				asl 	a
.a0ea	0a		asl a				asl 	a
.a0eb	a8		tay				tay
.a0ec	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a0ee	a6 58		ldx $58				ldx 	NSMantissa0
.a0f0	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a0f3	60		rts				rts
.a0f4					TextCommand:
.a0f4	a2 00		ldx #$00			ldx 	#0
.a0f6	20 e9 9c	jsr $9ce9			jsr 	EvaluateString 				; get text
.a0f9	20 3b a1	jsr $a13b			jsr 	RunGraphicsCommand
.a0fc					TextRunDraw:
.a0fc	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a0fe	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a101	a0 00		ldy #$00			ldy 	#0
.a103					_IRDLoop:
.a103	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a105	85 37		sta $37				sta 	zTemp0+1
.a107	a5 58		lda $58				lda 	NSMantissa0
.a109	85 36		sta $36				sta 	zTemp0
.a10b	b1 36		lda ($36),y			lda 	(zTemp0),y
.a10d	f0 13		beq $a122			beq 	_IRDExit
.a10f	5a		phy				phy									; save string pos
.a110	48		pha				pha 								; save char
.a111	ad b7 05	lda $05b7			lda 	gxDrawScale 				; get scale
.a114	0a		asl a				asl 	a
.a115	0a		asl a				asl 	a
.a116	0a		asl a				asl 	a
.a117	a8		tay				tay
.a118	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a11a	fa		plx				plx 								; char to draw
.a11b	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a11e	7a		ply				ply 								; restore string pos
.a11f	c8		iny				iny
.a120	90 e1		bcc $a103			bcc 	_IRDLoop 					; go back if no error.
.a122					_IRDExit:
.a122	60		rts				rts
.a123					PlotCommand:
.a123	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a125	20 3b a1	jsr $a13b			jsr 	RunGraphicsCommand
.a128	80 05		bra $a12f			bra 	ExecuteGraphicCommand
.a12a					LineCommand:
.a12a	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a12c	20 3b a1	jsr $a13b			jsr 	RunGraphicsCommand
.a12f					ExecuteGraphicCommand:
.a12f	0d b0 05	ora $05b0			ora 	gxCommandID 				; make a full command
.a132	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a135	b0 01		bcs $a138			bcs 	_EGCError
.a137	60		rts				rts
.a138					_EGCError:
.a138	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError
.a13b					RunGraphicsCommand:
.a13b	8d b0 05	sta $05b0			sta 	gxCommandID					; save TODO graphics command.
.a13e	68		pla				pla 								; pop handler address
.a13f	fa		plx				plx
.a140	1a		inc a				inc 	a
.a141	d0 01		bne $a144			bne 	_RGINoCarry
.a143	e8		inx				inx
.a144					_RGINoCarry:
.a144	8d b5 05	sta $05b5			sta 	GXHandler
.a147	8e b6 05	stx $05b6			stx 	GXHandler+1
.a14a					_RGICommandLoop:
.a14a	b1 30		lda ($30),y			lda 	(codePtr),y
.a14c	c8		iny				iny
.a14d	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a14f	f0 53		beq $a1a4			beq 	_RGI_To
.a151	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a153	f0 55		beq $a1aa			beq 	_RGI_Here
.a155	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a157	f0 3d		beq $a196			beq 	_RGI_Exit
.a159	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a15b	f0 39		beq $a196			beq 	_RGI_Exit
.a15d	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a15f	f0 3e		beq $a19f			beq 	_RGI_Frame
.a161	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a163	f0 33		beq $a198			beq 	_RGI_Solid
.a165	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a167	f0 4b		beq $a1b4			beq 	_RGI_By
.a169	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a16b	f0 17		beq $a184			beq 	_RGI_Move2
.a16d	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a16f	f0 62		beq $a1d3			beq 	_RGI_Dim
.a171	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a173	f0 74		beq $a1e9			beq 	_RGI_Colour
.a175	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a177	f0 70		beq $a1e9			beq 	_RGI_Colour
.a179	ae b0 05	ldx $05b0			ldx 	gxCommandID
.a17c	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a17e	d0 03		bne $a183			bne 	_RGI_Move 					; move
.a180	4c 11 a2	jmp $a211			jmp		_RGI_SpriteInstructions
.a183					_RGI_Move:
.a183	88		dey				dey 								; unpick get.
.a184					_RGI_Move2:
.a184	20 37 a2	jsr $a237			jsr 	GCGetCoordinatePair 		; move to here
.a187	20 5e a2	jsr $a25e			jsr 	GCCopyPairToStore 			; save
.a18a	5a		phy				phy
.a18b	20 54 a2	jsr $a254			jsr 	GCLoadAXY 					; load in
.a18e	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a190	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a193	7a		ply				ply
.a194	80 b4		bra $a14a			bra 	_RGICommandLoop 			; and go round
.a196					_RGI_Exit:
.a196	88		dey				dey 								; unpick : / EOL
.a197	60		rts				rts
.a198					_RGI_Solid:
.a198	a9 02		lda #$02			lda 	#2
.a19a	8d b1 05	sta $05b1			sta 	gxFillSolid
.a19d	80 ab		bra $a14a			bra 	_RGICommandLoop
.a19f					_RGI_Frame:
.a19f	9c b1 05	stz $05b1			stz 	gxFillSolid
.a1a2	80 a6		bra $a14a			bra 	_RGICommandLoop
.a1a4					_RGI_To:
.a1a4	20 37 a2	jsr $a237			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a1a7	20 5e a2	jsr $a25e			jsr 	GCCopyPairToStore
.a1aa					_RGI_Here:
.a1aa	5a		phy				phy
.a1ab	20 54 a2	jsr $a254			jsr 	GCLoadAXY 					; load it into AXY
.a1ae	20 0e a2	jsr $a20e			jsr 	_RGICallHandler 			; go do whatever it is.
.a1b1	7a		ply				ply
.a1b2	80 96		bra $a14a			bra 	_RGICommandLoop 			; and go round
.a1b4					_RGI_By:
.a1b4	20 44 a2	jsr $a244			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a1b7	18		clc				clc
.a1b8	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a1ba	6d b2 05	adc $05b2			adc 	gxxPos
.a1bd	8d b2 05	sta $05b2			sta 	gxXPos
.a1c0	a5 61		lda $61				lda 	NSMantissa1+1
.a1c2	6d b3 05	adc $05b3			adc 	gxxPos+1
.a1c5	8d b3 05	sta $05b3			sta 	gxXPos+1
.a1c8	a5 5a		lda $5a				lda 	NSMantissa0+2
.a1ca	18		clc				clc
.a1cb	6d b4 05	adc $05b4			adc 	gxYPos
.a1ce	8d b4 05	sta $05b4			sta 	gxYPos
.a1d1	80 d7		bra $a1aa			bra 	_RGI_Here
.a1d3					_RGI_Dim:
.a1d3	a2 01		ldx #$01			ldx	 	#1
.a1d5	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger
.a1d8	a5 59		lda $59				lda 	NSMantissa0+1
.a1da	c9 00		cmp #$00			cmp 	#0
.a1dc	f0 2d		beq $a20b			beq 	_RGIRange
.a1de	c9 09		cmp #$09			cmp 	#8+1
.a1e0	b0 29		bcs $a20b			bcs		_RGIRange
.a1e2	3a		dec a				dec 	a
.a1e3	8d b7 05	sta $05b7			sta 	gxDrawScale
.a1e6	4c 4a a1	jmp $a14a			jmp 	_RGICommandLoop
.a1e9					_RGI_Colour:
.a1e9	a2 01		ldx #$01			ldx 	#1 							; colour
.a1eb	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger
.a1ee	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a1f0	20 91 9d	jsr $9d91			jsr 	NSMSetZero
.a1f3	b1 30		lda ($30),y			lda 	(codePtr),y
.a1f5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a1f7	d0 04		bne $a1fd			bne 	_RGICDefaultMode
.a1f9	c8		iny				iny
.a1fa	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger
.a1fd					_RGICDefaultMode:
.a1fd	5a		phy				phy
.a1fe	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a200	a6 59		ldx $59				ldx 	NSMantissa0+1
.a202	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a204	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a207	7a		ply				ply
.a208	4c 4a a1	jmp $a14a			jmp 	_RGICommandLoop 			; and go round
.a20b					_RGIRange:
.a20b	4c 14 9f	jmp $9f14			jmp 	RangeError
.a20e					_RGICallHandler:
.a20e	6c b5 05	jmp ($05b5)			jmp 	(GXHandler)
.a211					_RGI_SpriteInstructions:
.a211	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a213	f0 07		beq $a21c			beq 	_RGISpriteOff
.a215	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a217	f0 13		beq $a22c			beq 	_RGISetImage
.a219	4c 83 a1	jmp $a183			jmp 	_RGI_Move
.a21c					_RGISpriteOff:
.a21c	5a		phy				phy
.a21d	a0 01		ldy #$01			ldy 	#1
.a21f	a2 00		ldx #$00			ldx 	#0
.a221					_RGIDoCommandLoop:
.a221	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a223	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a226	7a		ply				ply
.a227	b0 e2		bcs $a20b			bcs 	_RGIRange
.a229	4c 4a a1	jmp $a14a			jmp 	_RGICommandLoop
.a22c					_RGISetImage:
.a22c	a2 01		ldx #$01			ldx 	#1
.a22e	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger
.a231	5a		phy				phy
.a232	aa		tax				tax
.a233	a0 00		ldy #$00			ldy 	#0
.a235	80 ea		bra $a221			bra 	_RGIDoCommandLoop
.a237					GCGetCoordinatePair:
.a237	a2 01		ldx #$01			ldx 	#1
.a239	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger
.a23c	20 73 8e	jsr $8e73			jsr 	CheckComma
.a23f	e8		inx				inx
.a240	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger
.a243	60		rts				rts
.a244					GCSignedCoordinatePair:
.a244	a2 01		ldx #$01			ldx 	#1
.a246	20 1b 9d	jsr $9d1b			jsr 	Evaluate16BitIntegerSigned
.a249	20 73 8e	jsr $8e73			jsr 	CheckComma
.a24c	e8		inx				inx
.a24d	20 1b 9d	jsr $9d1b			jsr 	Evaluate16BitIntegerSigned
.a250	60		rts				rts
.a251					_GCCPRange:
.a251	4c 14 9f	jmp $9f14			jmp 	RangeError
.a254					GCLoadAXY:
.a254	ad b3 05	lda $05b3			lda 	gxXPos+1
.a257	ae b2 05	ldx $05b2			ldx 	gxXPos
.a25a	ac b4 05	ldy $05b4			ldy 	gxYPos
.a25d	60		rts				rts
.a25e					GCCopyPairToStore:
.a25e	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a260	8d b2 05	sta $05b2			sta 	gxXPos
.a263	a5 61		lda $61				lda 	NSMantissa1+1
.a265	8d b3 05	sta $05b3			sta 	gxXPos+1
.a268	a5 5a		lda $5a				lda 	NSMantissa0+2
.a26a	8d b4 05	sta $05b4			sta 	gxYPos
.a26d	60		rts				rts
.05b0					gxCommandID:
>05b0							.fill 	1
.05b1					gxFillSolid:
>05b1							.fill 	1
.05b2					gxXPos:
>05b2							.fill 	2
.05b4					gxYPos:
>05b4							.fill 	1
.05b5					gxHandler:
>05b5							.fill 	2
.05b7					gxDrawScale:
>05b7							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a26e					BitmapCtrl:
.a26e	b1 30		lda ($30),y			lda 	(codePtr),y
.a270	c8		iny				iny
.a271	a2 01		ldx #$01			ldx 	#1
.a273	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a275	f0 11		beq $a288			beq 	BitmapSwitch
.a277	ca		dex				dex
.a278	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a27a	f0 0c		beq $a288			beq 	BitmapSwitch
.a27c	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; get the colour
.a27f	5a		phy				phy
.a280	aa		tax				tax
.a281	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a283	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a286	7a		ply				ply
.a287	60		rts				rts
.a288					BitmapSwitch:
.a288	5a		phy				phy
.a289	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a28b	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a28d	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a290	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a292	a0 00		ldy #$00			ldy 	#0
.a294	a2 ff		ldx #$ff			ldx 	#$FF
.a296	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a299	9c b1 05	stz $05b1			stz 	gxFillSolid
.a29c	9c b2 05	stz $05b2			stz 	gxXPos
.a29f	9c b3 05	stz $05b3			stz 	gxXPos+1
.a2a2	9c b4 05	stz $05b4			stz 	gxYPos
.a2a5	9c b7 05	stz $05b7			stz 	gxDrawScale
.a2a8	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a2aa	a2 00		ldx #$00			ldx 	#0
.a2ac	a0 00		ldy #$00			ldy 	#0
.a2ae	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2b1	7a		ply				ply
.a2b2	60		rts				rts
.a2b3					SpritesCtrl:
.a2b3	b1 30		lda ($30),y			lda 	(codePtr),y
.a2b5	c8		iny				iny
.a2b6	a2 01		ldx #$01			ldx 	#1
.a2b8	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a2ba	f0 08		beq $a2c4			beq 	SpriteSwitch
.a2bc	ca		dex				dex
.a2bd	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a2bf	f0 03		beq $a2c4			beq 	SpriteSwitch
.a2c1	4c 0f 9f	jmp $9f0f			jmp 	SyntaxError
.a2c4					SpriteSwitch:
.a2c4	5a		phy				phy
.a2c5	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a2c7	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a2c9	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2cc	7a		ply				ply
.a2cd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a2ce					GfxCommand:
.a2ce	a2 00		ldx #$00			ldx 	#0
.a2d0	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; command
.a2d3	20 73 8e	jsr $8e73			jsr 	CheckComma
.a2d6	e8		inx				inx
.a2d7	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger 		; X
.a2da	20 73 8e	jsr $8e73			jsr 	CheckComma
.a2dd	e8		inx				inx
.a2de	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; Y
.a2e1	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a2e3	4a		lsr a				lsr 	a
.a2e4	d0 12		bne $a2f8			bne 	_GfxError
.a2e6	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a2e8	b0 0e		bcs $a2f8			bcs 	_GfxError 					; bit 7 should have been zero
.a2ea	5a		phy				phy 								; save pos
.a2eb	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a2ed	a6 59		ldx $59				ldx 	NSMantissa0+1
.a2ef	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2f1	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2f4	b0 02		bcs $a2f8			bcs 	_GfxError
.a2f6	7a		ply				ply 								; restore pos and exit.
.a2f7	60		rts				rts
.a2f8					_GfxError:
.a2f8	4c 14 9f	jmp $9f14			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a2fb					UnaryHit:
.a2fb	fa		plx				plx
.a2fc	a9 36		lda #$36			lda 	#zTemp0
.a2fe	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a301	20 73 8e	jsr $8e73			jsr 	CheckComma
.a304	e8		inx				inx
.a305	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a308	20 6b 8e	jsr $8e6b			jsr		CheckRightBracket
.a30b	ca		dex				dex 								; fix back up again.
.a30c	da		phx				phx 								; save X/Y
.a30d	5a		phy				phy
.a30e	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a310	b5 58		lda $58,x			lda 	NSMantissa0,x
.a312	aa		tax				tax
.a313	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a315	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a318	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a319	7a		ply				ply 								; restore XY
.a31a	fa		plx				plx
.a31b	20 93 9d	jsr $9d93			jsr 	NSMSetByte 					; return the hit result
.a31e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a31f					PaletteCommand:
.a31f	a2 00		ldx #$00			ldx 	#0
.a321	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; colour
.a324	20 73 8e	jsr $8e73			jsr 	CheckComma
.a327	e8		inx				inx
.a328	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger 		; r
.a32b	20 73 8e	jsr $8e73			jsr 	CheckComma
.a32e	e8		inx				inx
.a32f	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; g
.a332	20 73 8e	jsr $8e73			jsr 	CheckComma
.a335	e8		inx				inx
.a336	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; b
.a339	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a33b	85 36		sta $36				sta 	zTemp0
.a33d	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a33f	85 37		sta $37				sta 	zTemp0+1
.a341	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a343	26 37		rol $37				rol	 	zTemp0+1
.a345	06 36		asl $36				asl 	zTemp0
.a347	26 37		rol $37				rol	 	zTemp0+1
.a349	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a34b	85 01		sta $01				sta 	1
.a34d	5a		phy				phy
.a34e	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a350	92 36		sta ($36)			sta 	(zTemp0)
.a352	a0 01		ldy #$01			ldy 	#1
.a354	a5 5a		lda $5a				lda 	NSMantissa0+2
.a356	91 36		sta ($36),y			sta 	(zTemp0),y
.a358	a5 59		lda $59				lda 	NSMantissa0+1
.a35a	c8		iny				iny
.a35b	91 36		sta ($36),y			sta 	(zTemp0),y
.a35d	7a		ply				ply
.a35e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a35f					UnaryEvent:
.a35f	fa		plx				plx
.a360	20 0d a4	jsr $a40d			jsr 	TimerToStackX 				; timer in +0
.a363	e8		inx				inx  								; put reference into +1
.a364	20 d2 97	jsr $97d2			jsr 	EvaluateTerm
.a367	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a369	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a36b	d0 4c		bne $a3b9			bne 	_UEType
.a36d	e8		inx				inx 								; put the step in +2
.a36e	20 73 8e	jsr $8e73			jsr 	CheckComma
.a371	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger
.a374	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.a377	ca		dex				dex
.a378	ca		dex				dex
.a379	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a37b	85 36		sta $36				sta 	zTemp0
.a37d	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a37f	85 37		sta $37				sta 	zTemp0+1
.a381	5a		phy				phy
.a382	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a384	b1 36		lda ($36),y			lda 	(zTemp0),y
.a386	30 2d		bmi $a3b5			bmi 	_UEFalse 					; exit if signed.
.a388	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a38a	b5 58		lda $58,x			lda 	NSMantissa0,x
.a38c	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a38e	c8		iny				iny
.a38f	b5 60		lda $60,x			lda 	NSMantissa1,x
.a391	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a393	c8		iny				iny
.a394	b5 68		lda $68,x			lda 	NSMantissa2,x
.a396	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a398	90 1b		bcc $a3b5			bcc 	_UEFalse 					; no, return FALSE.
.a39a	18		clc				clc
.a39b	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a39d	b5 58		lda $58,x			lda 	NSMantissa0,x
.a39f	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a3a1	91 36		sta ($36),y			sta 	(zTemp0),y
.a3a3	c8		iny				iny
.a3a4	b5 60		lda $60,x			lda 	NSMantissa1,x
.a3a6	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a3a8	91 36		sta ($36),y			sta 	(zTemp0),y
.a3aa	c8		iny				iny
.a3ab	b5 68		lda $68,x			lda 	NSMantissa2,x
.a3ad	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a3af	91 36		sta ($36),y			sta 	(zTemp0),y
.a3b1	7a		ply				ply
.a3b2	4c f1 8e	jmp $8ef1			jmp 	ReturnTrue
.a3b5					_UEFalse:
.a3b5	7a		ply				ply 								; restore Y
.a3b6	4c fc 8e	jmp $8efc			jmp 	ReturnFalse 				; and return False
.a3b9					_UEType:
.a3b9	4c 19 9f	jmp $9f19			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a3bc					UnaryJoyX:
.a3bc	18		clc				clc
.a3bd	80 01		bra $a3c0			bra 	JoyMain
.a3bf					UnaryJoyY:
.a3bf	38		sec				sec
.a3c0					JoyMain:
.a3c0	fa		plx				plx 								; get pos
.a3c1	08		php				php 								; save carry (set for Y)
.a3c2	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a3c5	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.a3c8	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a3cb	28		plp				plp
.a3cc	90 02		bcc $a3d0			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a3ce	4a		lsr a				lsr 	a
.a3cf	4a		lsr a				lsr 	a
.a3d0					_JMNoShift:
.a3d0	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a3d1	b0 0a		bcs $a3dd			bcs 	_JMIsRight
.a3d3	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a3d4	b0 04		bcs $a3da			bcs 	_JMIsLeft
.a3d6	20 91 9d	jsr $9d91			jsr 	NSMSetZero 					; zero result
.a3d9	60		rts				rts
.a3da					_JMIsLeft:
.a3da	4c f1 8e	jmp $8ef1			jmp 	ReturnTrue
.a3dd					_JMIsRight:
.a3dd	a9 01		lda #$01			lda 	#1
.a3df	20 93 9d	jsr $9d93			jsr 	NSMSetByte
.a3e2	60		rts				rts
.a3e3					UnaryJoyB:
.a3e3	fa		plx				plx 								; get pos
.a3e4	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a3e7	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.a3ea	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a3ed	4a		lsr a				lsr 	a
.a3ee	4a		lsr a				lsr 	a
.a3ef	4a		lsr a				lsr 	a
.a3f0	4a		lsr a				lsr 	a
.a3f1	29 01		and #$01			and 	#1
.a3f3	20 93 9d	jsr $9d93			jsr 	NSMSetByte
.a3f6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a3f7					LoadCommand:
.a3f7	20 6f 89	jsr $896f			jsr 	NewProgram
.a3fa	20 ae 82	jsr $82ae			jsr 	BackLoadProgram
.a3fd	4c 46 83	jmp $8346			jmp 	WarmStart
.a400					GoCommand:
.a400	20 6f 89	jsr $896f			jsr 	NewProgram
.a403	20 ae 82	jsr $82ae			jsr 	BackLoadProgram
.a406	4c ab 8a	jmp $8aab			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a409					UnaryTimer:
.a409	fa		plx				plx
.a40a	20 6b 8e	jsr $8e6b			jsr 	CheckRightBracket
.a40d					TimerToStackX:
.a40d	20 91 9d	jsr $9d91			jsr 	NSMSetZero 					; zero result
.a410	64 01		stz $01				stz 	1 							; access I/O
.a412	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a415	95 58		sta $58,x			sta 	NSMantissa0,x
.a417	ad 5a d6	lda $d65a			lda 	$D65A
.a41a	95 60		sta $60,x			sta 	NSMantissa1,x
.a41c	ad 5b d6	lda $d65b			lda 	$D65B
.a41f	95 68		sta $68,x			sta 	NSMantissa2,x
.a421	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a422					MemoryDeleteLine:
.a422	20 41 a4	jsr $a441			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a425	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a427	a8		tay				tay
.a428					_MDDLLoop:
.a428	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a42a	92 30		sta ($30)			sta 	(codePtr)
.a42c	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a42e	c5 3a		cmp $3a				cmp 	zTemp2
.a430	d0 07		bne $a439			bne 	_MDLDLNext
.a432	a5 31		lda $31				lda 	codePtr+1
.a434	c5 3b		cmp $3b				cmp 	zTemp2+1
.a436	d0 01		bne $a439			bne 	_MDLDLNext
.a438					_MDDLExit:
.a438	60		rts				rts
.a439					_MDLDLNext:
.a439	e6 30		inc $30				inc 	codePtr						; next byte
.a43b	d0 eb		bne $a428			bne 	_MDDLLoop
.a43d	e6 31		inc $31				inc 	codePtr+1
.a43f	80 e7		bra $a428			bra 	_MDDLLoop
.a441					IMemoryFindEnd:
.a441	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a443	85 3a		sta $3a				sta 	0+zTemp2
.a445	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a447	85 3b		sta $3b				sta 	1+zTemp2
.a449					_MDLFELoop:
.a449	b2 3a		lda ($3a)			lda 	(zTemp2)
.a44b	f0 0b		beq $a458			beq 	_MDLFEExit
.a44d	18		clc				clc
.a44e	65 3a		adc $3a				adc 	zTemp2
.a450	85 3a		sta $3a				sta 	zTemp2
.a452	90 f5		bcc $a449			bcc 	_MDLFELoop
.a454	e6 3b		inc $3b				inc 	zTemp2+1
.a456	80 f1		bra $a449			bra 	_MDLFELoop
.a458					_MDLFEExit:
.a458	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a459					MemoryInsertLine:
.a459	08		php				php
.a45a	20 41 a4	jsr $a441			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a45d	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a45f	1a		inc a				inc 	a
.a460	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a462	b0 36		bcs $a49a			bcs 	_MDLIError
.a464	28		plp				plp
.a465	90 08		bcc $a46f			bcc 	_MDLIFound
.a467	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a469	85 30		sta $30				sta 	codePtr
.a46b	a5 3b		lda $3b				lda 	zTemp2+1
.a46d	85 31		sta $31				sta 	codePtr+1
.a46f					_MDLIFound:
.a46f	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a472	a8		tay				tay
.a473					_MDLIInsert:
.a473	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a475	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a477	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a479	c5 3a		cmp $3a				cmp 	zTemp2
.a47b	d0 06		bne $a483			bne 	_MDLINext
.a47d	a5 31		lda $31				lda 	codePtr+1
.a47f	c5 3b		cmp $3b				cmp 	zTemp2+1
.a481	f0 0a		beq $a48d			beq 	_MDLIHaveSpace
.a483					_MDLINext:
.a483	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a485	d0 02		bne $a489			bne 	_MDLINoBorrow
.a487	c6 3b		dec $3b				dec 	zTemp2+1
.a489					_MDLINoBorrow:
.a489	c6 3a		dec $3a				dec 	zTemp2
.a48b	80 e6		bra $a473			bra 	_MDLIInsert
.a48d					_MDLIHaveSpace:
.a48d	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a490	88		dey				dey 								; from offset-1 to 0
.a491					_MDLICopy:
.a491	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a494	91 30		sta ($30),y			sta 	(codePtr),y
.a496	88		dey				dey
.a497	10 f8		bpl $a491			bpl 	_MDLICopy
.a499	60		rts				rts
.a49a					_MDLIError:
.a49a	a9 06		lda #$06		lda	#6
.a49c	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.a49f					MDLAppendLine:
.a49f	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a4a1	85 36		sta $36				sta 	zTemp0
.a4a3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4a5	85 38		sta $38				sta 	0+zTemp1
.a4a7	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4a9	85 39		sta $39				sta 	1+zTemp1
.a4ab	b2 38		lda ($38)			lda 	(zTemp1)
.a4ad	d0 0a		bne $a4b9			bne 	_MDLANoInitialise
.a4af	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4b1	8d b8 05	sta $05b8			sta 	0+AppendPointer
.a4b4	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4b6	8d b9 05	sta $05b9			sta 	1+AppendPointer
.a4b9					_MDLANoInitialise:
.a4b9	18		clc				clc
.a4ba	ad b8 05	lda $05b8			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a4bd	85 38		sta $38				sta 	zTemp1
.a4bf	72 36		adc ($36)			adc 	(zTemp0)
.a4c1	8d b8 05	sta $05b8			sta 	AppendPointer
.a4c4	ad b9 05	lda $05b9			lda 	AppendPointer+1
.a4c7	85 39		sta $39				sta 	zTemp1+1
.a4c9	69 00		adc #$00			adc 	#0
.a4cb	8d b9 05	sta $05b9			sta 	AppendPointer+1
.a4ce	a0 00		ldy #$00			ldy 	#0
.a4d0					_MDLACopy:
.a4d0	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a4d2	91 38		sta ($38),y			sta 	(zTemp1),y
.a4d4	c8		iny				iny
.a4d5	98		tya				tya
.a4d6	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a4d8	d0 f6		bne $a4d0			bne 	_MDLACopy
.a4da	a9 00		lda #$00			lda 	#0 							; end of program.
.a4dc	91 38		sta ($38),y			sta 	(zTemp1),y
.a4de	60		rts				rts
.05b8					AppendPointer:
>05b8							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a4df					MemoryNew:
.a4df	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4e1	85 30		sta $30				sta 	codePtr
.a4e3	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4e5	85 31		sta $31				sta 	codePtr+1
.a4e7	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a4e9	92 30		sta ($30)			sta 	(codePtr)
.a4eb	60		rts				rts
.a4ec					MemoryInline:
.a4ec	98		tya				tya 								; put address into stack,x
.a4ed	18		clc				clc  								; get the offset, add codePtr
.a4ee	65 30		adc $30				adc 	codePtr
.a4f0	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a4f2	a5 31		lda $31				lda 	codePtr+1
.a4f4	69 00		adc #$00			adc 	#0
.a4f6	95 60		sta $60,x			sta 	NSMantissa1,x
.a4f8	74 68		stz $68,x			stz 	NSMantissa2,x
.a4fa	74 70		stz $70,x			stz 	NSMantissa3,x
.a4fc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a4fd					MemorySearch:
.a4fd	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a4ff	86 37		stx $37				stx 	zTemp0+1
.a501	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a503	85 30		sta $30				sta 	codePtr
.a505	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a507	85 31		sta $31				sta 	codePtr+1
.a509					_MTAXLoop:
.a509	b2 30		lda ($30)			lda 	(codePtr)
.a50b	18		clc				clc
.a50c	f0 21		beq $a52f			beq 	_MTAXExit 					; reached end, exit with CC.
.a50e	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a510	b1 30		lda ($30),y			lda 	(codePtr),y
.a512	38		sec				sec
.a513	e5 36		sbc $36				sbc 	zTemp0
.a515	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a517	c8		iny				iny 								; do the MSB
.a518	b1 30		lda ($30),y			lda 	(codePtr),y
.a51a	e5 37		sbc $37				sbc 	zTemp0+1
.a51c	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a51e	f0 0f		beq $a52f			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a520	b0 0d		bcs $a52f			bcs 	_MTAXExit 					; current < required exit
.a522	18		clc				clc
.a523	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a525	65 30		adc $30				adc 	codePtr
.a527	85 30		sta $30				sta 	codePtr
.a529	90 02		bcc $a52d			bcc 	_CREExit
.a52b	e6 31		inc $31				inc 	codePtr+1 					; carry
.a52d					_CREExit:
.a52d	80 da		bra $a509			bra 	_MTAXLoop
.a52f					_MTAXExit:
.a52f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a530					UnaryPlaying:
.a530	fa		plx				plx
.a531	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; get channel #
.a534	48		pha				pha
.a535	20 6b 8e	jsr $8e6b			jsr		CheckRightBracket
.a538	68		pla				pla
.a539	c9 04		cmp #$04			cmp 	#4
.a53b	b0 0c		bcs $a549			bcs 	_UPNotPlaying
.a53d	09 20		ora #$20			ora 	#$20 						; query playing ?
.a53f	20 18 80	jsr $8018			jsr 	SNDCommand
.a542	c9 00		cmp #$00			cmp 	#0
.a544	f0 03		beq $a549			beq 	_UPNotPlaying
.a546	4c f1 8e	jmp $8ef1			jmp 	ReturnTrue
.a549					_UPNotPlaying:
.a549	4c fc 8e	jmp $8efc			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a54c					SoundCommand:
.a54c	b1 30		lda ($30),y			lda 	(codePtr),y
.a54e	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a550	d0 09		bne $a55b			bne 	_SNDMain
.a552	c8		iny				iny 								; skip OFF
.a553	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a555	5a		phy				phy
.a556	20 18 80	jsr $8018			jsr 	SNDCommand
.a559	7a		ply				ply
.a55a	60		rts				rts
.a55b					_SNDMain:
.a55b	a2 00		ldx #$00			ldx 	#0
.a55d	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; channel
.a560	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a562	b0 4b		bcs $a5af			bcs 	_SndError
.a564	e8		inx				inx 								; do the rest in slot 1.
.a565	20 73 8e	jsr $8e73			jsr 	CheckComma
.a568	20 11 9d	jsr $9d11			jsr 	Evaluate16BitInteger 		; Pitch
.a56b	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a56d	c9 10		cmp #$10			cmp 	#16
.a56f	b0 3e		bcs $a5af			bcs 	_SndError
.a571	8d bb 05	sta $05bb			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a574	b5 58		lda $58,x			lda 	NSMantissa0,x
.a576	8d ba 05	sta $05ba			sta 	SoundCommandBlock
.a579	20 73 8e	jsr $8e73			jsr 	CheckComma
.a57c	20 2c 9d	jsr $9d2c			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a57f	8d bd 05	sta $05bd			sta 	SoundCommandBlock+3
.a582	a9 0f		lda #$0f			lda 	#15
.a584	8d bc 05	sta $05bc			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a587	9c be 05	stz $05be			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a58a	9c bf 05	stz $05bf			stz 	SoundCommandBlock+5
.a58d	b1 30		lda ($30),y			lda 	(codePtr),y
.a58f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a591	d0 0e		bne $a5a1			bne 	_SNDPlay
.a593	c8		iny				iny
.a594	20 1b 9d	jsr $9d1b			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a597	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a599	8d be 05	sta $05be			sta 	SoundCommandBlock+4
.a59c	b5 60		lda $60,x			lda 	NSMantissa1,x
.a59e	8d bf 05	sta $05bf			sta 	SoundCommandBlock+5
.a5a1					_SNDPlay:
.a5a1	5a		phy				phy
.a5a2	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a5a4	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a5a6	a2 ba		ldx #$ba			ldx 	#(SoundCommandBlock & $FF)
.a5a8	a0 05		ldy #$05			ldy 	#(SoundCommandBlock >> 8)
.a5aa	20 18 80	jsr $8018			jsr 	SNDCommand
.a5ad	7a		ply				ply
.a5ae	60		rts				rts
.a5af					_SndError:
.a5af	4c 14 9f	jmp $9f14			jmp 	RangeError
.05ba					SoundCommandBlock:
>05ba							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a5b2					StackPushByte:
.a5b2	48		pha				pha 								; save byte on stack
.a5b3	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a5b5	d0 08		bne $a5bf			bne 	_SPBNoBorrow
.a5b7	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a5b9	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a5bb	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a5bd	90 06		bcc $a5c5			bcc 	_SPBMemory
.a5bf					_SPBNoBorrow:
.a5bf	c6 34		dec $34				dec 	BasicStack
.a5c1	68		pla				pla 								; get back and write
.a5c2	92 34		sta ($34)			sta 	(BasicStack)
.a5c4	60		rts				rts
.a5c5					_SPBMemory:
.a5c5	a9 12		lda #$12		lda	#18
.a5c7	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.a5ca					StackPopByte:
.a5ca	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a5cc	e6 34		inc $34				inc 	BasicStack
.a5ce	d0 02		bne $a5d2			bne 	_SPBNoCarry
.a5d0	e6 35		inc $35				inc 	BasicStack+1
.a5d2					_SPBNoCarry:
.a5d2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a5d3					StackOpen:
.a5d3	48		pha				pha 								; save frame byte
.a5d4	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a5d6	0a		asl a				asl 	a 							; claim twice this for storage
.a5d7	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a5d9	38		sec				sec 								; so basically subtracting from
.a5da	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a5dc	85 34		sta $34				sta 	basicStack
.a5de	b0 09		bcs $a5e9			bcs 	_SONoBorrow
>a5e0	db						.byte 	$DB 						; causes a break in the emulator
.a5e1	c6 35		dec $35				dec 	basicStack+1
.a5e3	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a5e5	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a5e7	90 04		bcc $a5ed			bcc 	_SOMemory
.a5e9					_SONoBorrow:
.a5e9	68		pla				pla 								; get marker back and write at TOS
.a5ea	92 34		sta ($34)			sta 	(basicStack)
.a5ec	60		rts				rts
.a5ed					_SOMemory:
.a5ed	a9 12		lda #$12		lda	#18
.a5ef	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.a5f2					StackClose:
.a5f2	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a5f4	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a5f6	0a		asl a				asl 	a 							; claim twice this.
.a5f7	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a5f9	85 34		sta $34				sta 	basicStack
.a5fb	90 02		bcc $a5ff			bcc 	_SCExit
.a5fd	e6 35		inc $35				inc 	basicStack+1
.a5ff					_SCExit:
.a5ff	60		rts				rts
.a600					StackCheckFrame:
.a600	48		pha				pha
.a601					_StackRemoveLocals:
.a601	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a603	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a605	b0 05		bcs $a60c			bcs 	_SCNoLocal
.a607	20 1e 89	jsr $891e			jsr 	LocalPopValue 				; restore the local value
.a60a	80 f5		bra $a601			bra 	_StackRemoveLocals 			; gr round again
.a60c					_SCNoLocal:
.a60c	68		pla				pla 								; get the frame check.
.a60d	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a60f	29 f0		and #$f0			and 	#$F0 						; check type bits
.a611	d0 01		bne $a614			bne 	_SCFError 					; different, we have structures mixed up
.a613	60		rts				rts
.a614					_SCFError:
.a614	8a		txa				txa 								; report error X
.a615	4c 84 8e	jmp $8e84			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a618					STKSaveCodePosition:
.a618	5a		phy				phy
.a619	98		tya				tya 								; save Y
.a61a	a0 05		ldy #$05			ldy 	#5
.a61c	91 34		sta ($34),y			sta 	(basicStack),y
.a61e	88		dey				dey 								; save Code Pointer
.a61f					_STKSaveLoop:
.a61f	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a622	91 34		sta ($34),y			sta 	(basicStack),y
.a624	88		dey				dey
.a625	d0 f8		bne $a61f			bne 	_STKSaveLoop
.a627	7a		ply				ply
.a628	60		rts				rts
.a629					STKLoadCodePosition:
.a629	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a62b					_STKLoadLoop:
.a62b	b1 34		lda ($34),y			lda 	(basicStack),y
.a62d	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a630	c8		iny				iny
.a631	c0 05		cpy #$05			cpy 	#5
.a633	d0 f6		bne $a62b			bne 	_STKLoadLoop
.a635	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a637	a8		tay				tay
.a638	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a639					StackReset:
.a639	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a63b	85 34		sta $34				sta 	0+basicStack
.a63d	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a63f	85 35		sta $35				sta 	1+basicStack
.a641	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a643	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a645	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a646					StringConcrete:
.a646	5a		phy				phy 								; save position on stack
.a647	20 b9 99	jsr $99b9			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a64a	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a64c	85 38		sta $38				sta 	zTemp1
.a64e	b5 60		lda $60,x			lda 	NSMantissa1,x
.a650	85 39		sta $39				sta 	zTemp1+1
.a652	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a654					_SALength:
.a654	c8		iny				iny
.a655	b1 38		lda ($38),y			lda 	(zTemp1),y
.a657	d0 fb		bne $a654			bne 	_SALength
.a659	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a65b	b0 3d		bcs $a69a			bcs 	_SALengthError
.a65d	98		tya				tya 				 				; length of the new string
.a65e	18		clc				clc
.a65f	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a661	90 02		bcc $a665			bcc 	_SAHaveLength
.a663	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a665					_SAHaveLength:
.a665	48		pha				pha 								; save length.
.a666	38		sec				sec
.a667	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a669	6d 0e 04	adc $040e			adc 	StringMemory
.a66c	8d 0e 04	sta $040e			sta 	StringMemory
.a66f	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a671	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a673	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a675	6d 0f 04	adc $040f			adc 	StringMemory+1
.a678	8d 0f 04	sta $040f			sta 	StringMemory+1
.a67b	85 3b		sta $3b				sta 	zTemp2+1
.a67d	95 60		sta $60,x			sta 	NSMantissa1,x
.a67f	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a680	38		sec				sec
.a681	e9 03		sbc #$03			sbc 	#3
.a683	92 3a		sta ($3a)			sta 	(zTemp2)
.a685	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a687	a0 01		ldy #$01			ldy 	#1
.a689	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a68b					_SACopyNewString:
.a68b	a0 00		ldy #$00			ldy 	#0
.a68d					_SACopyNSLoop:
.a68d	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a68f	c8		iny				iny 								; write two on in string storage
.a690	c8		iny				iny
.a691	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a693	88		dey				dey 								; this makes it one one.
.a694	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a696	d0 f5		bne $a68d			bne 	_SACopyNSLoop
.a698	7a		ply				ply
.a699	60		rts				rts
.a69a					_SALengthError:
.a69a	a9 09		lda #$09		lda	#9
.a69c	4c 84 8e	jmp $8e84		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a69f					StringSystemInitialise:
.a69f	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a6a1	8d 0e 04	sta $040e			sta 	0+StringMemory
.a6a4	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a6a6	8d 0f 04	sta $040f			sta 	1+StringMemory
.a6a9	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a6ac	60		rts				rts
.a6ad					StringSpaceInitialise:
.a6ad	20 b9 99	jsr $99b9			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a6b0	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a6b2	8d 10 04	sta $0410			sta 	StringInitialised
.a6b5	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a6b8	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a6bb	ad 0f 04	lda $040f			lda 	StringMemory+1
.a6be	3a		dec a				dec 	a
.a6bf	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a6c2	60		rts				rts
.a6c3					StringTempAllocate:
.a6c3	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a6c5	b0 30		bcs $a6f7			bcs 	_STALength
.a6c7	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a6ca	30 05		bmi $a6d1			bmi 	_STAAllocate
.a6cc	48		pha				pha 								; save value to subtract.
.a6cd	20 ad a6	jsr $a6ad			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a6d0	68		pla				pla 								; restore it
.a6d1					_STAAllocate:
.a6d1	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a6d3	18		clc				clc  								; deliberate allows one more
.a6d4	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a6d7	8d 11 04	sta $0411			sta 	StringTempPointer
.a6da	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a6dc	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a6de	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a6e1	69 ff		adc #$ff			adc 	#$FF
.a6e3	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a6e6	85 3d		sta $3d				sta 	zsTemp+1
.a6e8	95 60		sta $60,x			sta 	NSMantissa1,x
.a6ea	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a6ec	74 70		stz $70,x			stz 	NSMantissa3,x
.a6ee	a9 10		lda #$10			lda 	#NSTString
.a6f0	95 50		sta $50,x			sta 	NSStatus,x
.a6f2	a9 00		lda #$00			lda 	#0 							; clear the target string
.a6f4	92 3c		sta ($3c)			sta 	(zsTemp)
.a6f6	60		rts				rts
.a6f7					_STALength:
.a6f7	a9 09		lda #$09		lda	#9
.a6f9	4c 84 8e	jmp $8e84		jmp	ErrorHandler
.a6fc					StringTempWrite:
.a6fc	48		pha				pha
.a6fd	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a6ff	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a701	d0 02		bne $a705			bne 	_STWNoCarry
.a703	e6 3d		inc $3d				inc 	zsTemp+1
.a705					_STWNoCarry:
.a705	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a707	92 3c		sta ($3c)			sta 	(zsTemp)
.a709	68		pla				pla
.a70a	60		rts				rts

;******  Return to file: _basic.asm

.a70b					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a70b					Export_EXTPrintCharacter:
.a70b					PAGEDPrintCharacter:
.a70b	48		pha				pha
.a70c	da		phx				phx
.a70d	5a		phy				phy
.a70e	a6 01		ldx $01				ldx 	1
.a710	da		phx				phx
.a711	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a714	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a716	30 48		bmi $a760			bmi 	_EXPCColour
.a718	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a71a	90 4d		bcc $a769			bcc 	_EXPCControl
.a71c	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a71e	86 01		stx $01				stx 	1
.a720	91 40		sta ($40),y			sta 	(EXTAddress),y
.a722	e6 01		inc $01				inc 	1 							; select colour memory
.a724	ad c2 05	lda $05c2			lda 	EXTTextColour
.a727	91 40		sta ($40),y			sta 	(EXTAddress),y
.a729	c8		iny				iny 								; advance horizontal position
.a72a	8c c1 05	sty $05c1			sty 	EXTColumn
.a72d	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; reached RHS ?
.a730	90 63		bcc $a795			bcc 	_EXPCExit 					; no, then exit.
.a732					_EXPCCRLF:
.a732	ee c0 05	inc $05c0			inc 	EXTRow  					; bump row
.a735	9c c1 05	stz $05c1			stz 	EXTColumn 					; back to column 0
.a738	ad c0 05	lda $05c0			lda 	EXTRow 						; check if reached the bottom ?
.a73b	cd c4 05	cmp $05c4			cmp 	EXTScreenHeight 			; if so, then scroll.
.a73e	f0 18		beq $a758			beq 	_EXPCScroll
.a740	18		clc				clc 								; add width to address.
.a741	a5 40		lda $40				lda 	EXTAddress
.a743	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a746	85 40		sta $40				sta 	EXTAddress
.a748	90 4b		bcc $a795			bcc 	_EXPCExit
.a74a	e6 41		inc $41				inc 	EXTAddress+1
.a74c	80 47		bra $a795			bra 	_EXPCExit
.a74e					_EXPCLeft:
.a74e	ce c1 05	dec $05c1			dec 	EXTColumn
.a751	10 42		bpl $a795			bpl 	_EXPCExit
.a753					_EXPCBegin:
.a753	9c c1 05	stz $05c1			stz 	EXTColumn
.a756	80 3d		bra $a795			bra 	_EXPCExit
.a758					_EXPCScroll:
.a758	ce c0 05	dec $05c0			dec 	EXTRow 						; the height-1 th line.
.a75b	20 46 a8	jsr $a846			jsr 	EXTScreenScroll 			; scroll the screen
.a75e	80 35		bra $a795			bra 	_EXPCExit
.a760					_EXPCColour:
.a760	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a762	b0 31		bcs $a795			bcs 	_EXPCExit
.a764	20 26 a8	jsr $a826			jsr 	_EXPCHandleColour
.a767	80 2c		bra $a795			bra 	_EXPCExit
.a769					_EXPCControl:
.a769	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a76b	b0 28		bcs $a795			bcs 	_EXPCExit
.a76d	0a		asl a				asl 	a 							; double into X
.a76e	aa		tax				tax
.a76f	7c 04 a8	jmp ($a804,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a772					_EXPCUp:
.a772	ad c0 05	lda $05c0			lda 	EXTRow 						; already at top ?
.a775	f0 1e		beq $a795			beq 	_EXPCExit
.a777	ce c0 05	dec $05c0			dec 	EXTRow 						; up one in position/address
.a77a	38		sec				sec
.a77b	a5 40		lda $40				lda 	EXTAddress
.a77d	ed c3 05	sbc $05c3			sbc 	EXTScreenWidth
.a780	85 40		sta $40				sta 	EXTAddress
.a782	b0 11		bcs $a795			bcs 	_EXPCExit
.a784	c6 41		dec $41				dec 	EXTAddress+1
.a786	80 0d		bra $a795			bra 	_EXPCExit
.a788					_EXPCRight:
.a788	c8		iny				iny
.a789	8c c1 05	sty $05c1			sty 	EXTColumn
.a78c	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a78f	d0 04		bne $a795			bne 	_EXPCExit
.a791	88		dey				dey
.a792					_EXPCSetColumnY:
.a792	8c c1 05	sty $05c1			sty 	EXTColumn
.a795					_EXPCExit:
.a795	20 9b a8	jsr $a89b			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a798	68		pla				pla
.a799	85 01		sta $01				sta 	1
.a79b	7a		ply				ply
.a79c	fa		plx				plx
.a79d	68		pla				pla
.a79e	60		rts				rts
.a79f					_EXPCClearScreen:
.a79f	20 58 a8	jsr $a858			jsr		EXTClearScreenCode
.a7a2	80 f1		bra $a795			bra 	_EXPCExit
.a7a4					_EXPCDown:
.a7a4	ad c4 05	lda $05c4			lda 	EXTScreenHeight 			; at the bottom
.a7a7	3a		dec a				dec 	a
.a7a8	cd c0 05	cmp $05c0			cmp 	EXTRow
.a7ab	f0 e8		beq $a795			beq 	_EXPCExit
.a7ad	ee c0 05	inc $05c0			inc 	EXTRow 						; down one in position/address
.a7b0	18		clc				clc
.a7b1	a5 40		lda $40				lda 	EXTAddress
.a7b3	6d c3 05	adc $05c3			adc 	EXTScreenWidth
.a7b6	85 40		sta $40				sta 	EXTAddress
.a7b8	90 db		bcc $a795			bcc 	_EXPCExit
.a7ba	e6 41		inc $41				inc 	EXTAddress+1
.a7bc	80 d7		bra $a795			bra 	_EXPCExit
.a7be					_EXPCTab:
.a7be	ad c1 05	lda $05c1			lda 	EXTColumn 					; next tab stop
.a7c1	29 f8		and #$f8			and 	#$F8
.a7c3	18		clc				clc
.a7c4	69 08		adc #$08			adc 	#8
.a7c6	8d c1 05	sta $05c1			sta 	EXTColumn
.a7c9	cd c3 05	cmp $05c3			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a7cc	90 c7		bcc $a795			bcc 	_EXPCExit
.a7ce	80 10		bra $a7e0			bra 	_EXPCEnd
.a7d0					_EXPCBackSpace:
.a7d0	88		dey				dey
.a7d1	30 c2		bmi $a795			bmi 	_EXPCExit
.a7d3	ce c1 05	dec $05c1			dec 	EXTColumn
.a7d6	a9 02		lda #$02			lda 	#2
.a7d8	85 01		sta $01				sta 	1
.a7da	a9 20		lda #$20			lda 	#32
.a7dc	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7de	80 b5		bra $a795			bra 	_EXPCExit
.a7e0					_EXPCEnd:
.a7e0	a9 02		lda #$02			lda 	#2 							; access text screen
.a7e2	85 01		sta $01				sta 	1
.a7e4	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; point to last character
.a7e7	88		dey				dey
.a7e8					_EXPCEndSearch:
.a7e8	88		dey				dey 								; if past start, move to col 0.
.a7e9	30 06		bmi $a7f1			bmi 	_EXPCFound
.a7eb	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a7ed	c9 20		cmp #$20			cmp 	#' '
.a7ef	f0 f7		beq $a7e8			beq 	_EXPCEndSearch
.a7f1					_EXPCFound:
.a7f1	c8		iny				iny 								; move to following cell.
.a7f2	80 9e		bra $a792			bra 	_EXPCSetColumnY
.a7f4					_EXPCClearEOL:
.a7f4	a9 02		lda #$02			lda 	#2 							; access character RAM
.a7f6	85 01		sta $01				sta 	1
.a7f8	a9 20		lda #$20			lda 	#' ' 						; write space
.a7fa	91 40		sta ($40),y			sta 	(EXTAddress),y
.a7fc	c8		iny				iny
.a7fd	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth 				; until RHS of screen.
.a800	90 f2		bcc $a7f4			bcc 	_EXPCClearEOL
.a802	80 91		bra $a795			bra 	_EXPCExit
.a804					_EXPCActionTable:
>a804	95 a7						.word 	_EXPCExit 					; 00
>a806	53 a7						.word 	_EXPCBegin 					; 01 A Start of Line
>a808	4e a7						.word 	_EXPCLeft 					; 02 B Left
>a80a	95 a7						.word 	_EXPCExit 					; 03 <Break>
>a80c	95 a7						.word 	_EXPCExit 					; 04
>a80e	e0 a7						.word 	_EXPCEnd 					; 05 E End of Line
>a810	88 a7						.word 	_EXPCRight 					; 06 F Right
>a812	95 a7						.word 	_EXPCExit 					; 07
>a814	d0 a7						.word 	_EXPCBackspace 				; 08 H Backspace
>a816	be a7						.word 	_EXPCTab 					; 09 I Tab
>a818	95 a7						.word 	_EXPCExit 					; 0A
>a81a	f4 a7						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a81c	9f a7						.word 	_EXPCClearScreen			; 0C L CLS
>a81e	32 a7						.word 	_EXPCCRLF 					; 0D M CR/LF
>a820	a4 a7						.word 	_EXPCDown 					; 0E N Down
>a822	95 a7						.word 	_EXPCExit 					; 0F
>a824	72 a7						.word 	_EXPCUp 					; 10 P Up
.a826					_EXPCHandleColour
.a826	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a828	b0 16		bcs $a840			bcs 	_EXPCBackground
.a82a	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a82b	0a		asl a				asl 	a
.a82c	0a		asl a				asl 	a
.a82d	0a		asl a				asl 	a
.a82e	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a830					_EXPCUpdate:
.a830	48		pha				pha 								; save new colour
.a831	8a		txa				txa 								; get mask
.a832	2d c2 05	and $05c2			and 	EXTTextColour 				; mask out old.
.a835	8d c2 05	sta $05c2			sta 	EXTTextColour
.a838	68		pla				pla 								; or in new colour
.a839	0d c2 05	ora $05c2			ora 	EXTTextColour
.a83c	8d c2 05	sta $05c2			sta 	EXTTextColour
.a83f	60		rts				rts
.a840					_EXPCBackground:
.a840	29 0f		and #$0f			and 	#$0F 						; get the colour
.a842	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a844	80 ea		bra $a830			bra 	_EXPCUpdate
.a846					EXTScreenScroll:
.a846	a9 02		lda #$02			lda 	#2 							; select text page
.a848	85 01		sta $01				sta 	1
.a84a	a9 20		lda #$20			lda		#32 						; fill with space
.a84c	20 5f a9	jsr $a95f			jsr 	EXTScrollFill
.a84f	e6 01		inc $01				inc 	1 							; select colour page
.a851	ad c2 05	lda $05c2			lda 	EXTTextColour
.a854	20 5f a9	jsr $a95f			jsr 	EXTScrollFill
.a857	60		rts				rts
.a858					EXTClearScreenCode:
.a858	a9 02		lda #$02			lda 	#2 							; select text page
.a85a	85 01		sta $01				sta 	1
.a85c	a9 20		lda #$20			lda		#32 						; fill with space
.a85e	20 6b a8	jsr $a86b			jsr 	_EXTCSFill
.a861	e6 01		inc $01				inc 	1 							; select colour page
.a863	ad c2 05	lda $05c2			lda 	EXTTextColour
.a866	20 6b a8	jsr $a86b			jsr 	_EXTCSFill
.a869	80 22		bra $a88d			bra 	EXTHomeCursor
.a86b					_EXTCSFill:
.a86b	aa		tax				tax
.a86c	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a86e	85 40		sta $40				sta 	EXTAddress
.a870	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a872	85 41		sta $41				sta 	EXTAddress+1
.a874					_EXTCSFill1:
.a874	a0 00		ldy #$00			ldy 	#0
.a876	8a		txa				txa
.a877					_EXTCSFill2:
.a877	91 40		sta ($40),y			sta 	(EXTAddress),y
.a879	c8		iny				iny
.a87a	d0 fb		bne $a877			bne 	_EXTCSFill2
.a87c	e6 41		inc $41				inc 	EXTAddress+1
.a87e	a5 41		lda $41				lda 	EXTAddress+1
.a880	c9 d2		cmp #$d2			cmp 	#$D2
.a882	d0 f0		bne $a874			bne 	_EXTCSFill1
.a884	8a		txa				txa
.a885					_EXTCSFill3:
.a885	91 40		sta ($40),y			sta 	(EXTAddress),y
.a887	c8		iny				iny
.a888	c0 c0		cpy #$c0			cpy 	#$C0
.a88a	d0 f9		bne $a885			bne 	_EXTCSFill3
.a88c	60		rts				rts
.a88d					EXTHomeCursor:
.a88d	9c c0 05	stz $05c0			stz 	EXTRow 						; reset row & column
.a890	9c c1 05	stz $05c1			stz 	EXTColumn
.a893	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a895	85 40		sta $40				sta 	EXTAddress
.a897	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a899	85 41		sta $41				sta 	EXTAddress+1
.a89b					EXTSetHardwareCursor:
.a89b	64 01		stz $01				stz 	1 							; I/O Page zero
.a89d	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a89f	8d 10 d0	sta $d010			sta 	$D010
.a8a2	a9 b1		lda #$b1			lda 	#$B1
.a8a4	8d 12 d0	sta $d012			sta 	$D012
.a8a7	ad c1 05	lda $05c1			lda 	EXTColumn
.a8aa	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a8ad	9c 15 d0	stz $d015			stz 	$D015
.a8b0	ad c0 05	lda $05c0			lda 	EXTRow
.a8b3	8d 16 d0	sta $d016			sta 	$D016
.a8b6	9c 17 d0	stz $d017			stz 	$D017
.a8b9	60		rts				rts
.a8ba					Export_EXTInputLine:
.a8ba	48		pha				pha
.a8bb	da		phx				phx
.a8bc	5a		phy				phy
.a8bd	a5 01		lda $01				lda 	1 							; save I/O page
.a8bf	48		pha				pha
.a8c0					_EILLoop:
.a8c0	20 da a9	jsr $a9da			jsr 	PagedInputSingleCharacter
.a8c3	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a8c5	f0 44		beq $a90b			beq 	_EILExit
.a8c7	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a8c9	f0 2a		beq $a8f5			beq 	_EILDelete
.a8cb	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a8cd	f0 1c		beq $a8eb			beq 	_EILBackspace
.a8cf	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a8d1	90 12		bcc $a8e5			bcc 	_EILPrintLoop
.a8d3	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a8d5	b0 0e		bcs $a8e5			bcs 	_EILPrintLoop
.a8d7	48		pha				pha 								; save character
.a8d8	a9 02		lda #$02			lda 	#2  						; insert a space
.a8da	85 01		sta $01				sta 	1
.a8dc	20 4d a9	jsr $a94d			jsr 	EXTILInsert 				; insert in text screen
.a8df	e6 01		inc $01				inc 	1
.a8e1	20 4d a9	jsr $a94d			jsr 	EXTILInsert 				; insert in colour screen
.a8e4	68		pla				pla 								; get character back.
.a8e5					_EILPrintLoop:
.a8e5	20 0b a7	jsr $a70b			jsr 	PagedPrintCharacter
.a8e8	80 d6		bra $a8c0			bra 	_EILLoop
.a8ea	60		rts				rts
.a8eb					_EILBackspace:
.a8eb	ad c1 05	lda $05c1			lda 	EXTColumn					; can we backspace ?
.a8ee	f0 d0		beq $a8c0			beq 	_EILLoop
.a8f0	a9 02		lda #$02			lda 	#2 							; move cursor left
.a8f2	20 0b a7	jsr $a70b			jsr 	PagedPrintCharacter
.a8f5					_EILDelete
.a8f5	a9 02		lda #$02			lda 	#2 							; text block
.a8f7	85 01		sta $01				sta 	1
.a8f9	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.a8fb	20 38 a9	jsr $a938			jsr 	EXTILDelete
.a8fe	e6 01		inc $01				inc 	1 							; colour block
.a900	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; get attribute of last character
.a903	88		dey				dey
.a904	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a906	20 38 a9	jsr $a938			jsr 	EXTILDelete 				; backspace attribute
.a909	80 b5		bra $a8c0			bra 	_EILLoop 					; and go round.
.a90b					_EILExit:
.a90b	a9 02		lda #$02			lda 	#2 							; switch to page 2
.a90d	85 01		sta $01				sta 	1
.a90f	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.a911					_EILScrapeLine:
.a911	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a913	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a916	c8		iny				iny
.a917	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a91a	d0 f5		bne $a911			bne 	_EILScrapeLine
.a91c					_EILTrimSpaces:
.a91c	88		dey				dey
.a91d	f0 08		beq $a927			beq 	_EILEndTrim
.a91f	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.a922	c9 20		cmp #$20			cmp 	#' '
.a924	f0 f6		beq $a91c			beq 	_EILTrimSpaces
.a926	c8		iny				iny 								; trim after non space character.
.a927					_EILEndTrim:
.a927	a9 00		lda #$00			lda 	#0 							; trim here.
.a929	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.a92c	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.a92e	20 0b a7	jsr $a70b			jsr 	PagedPrintCharacter
.a931	68		pla				pla 								; reset I/O page
.a932	85 01		sta $01				sta 	1
.a934	7a		ply				ply
.a935	fa		plx				plx
.a936	68		pla				pla
.a937	60		rts				rts
.a938					EXTILDelete:
.a938	48		pha				pha 								; save the new character
.a939	ac c1 05	ldy $05c1			ldy 	EXTColumn 					; start copying from here.
.a93c					_EXTDLoop:
.a93c	c8		iny				iny 								; copy one byte down.
.a93d	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a93f	88		dey				dey
.a940	91 40		sta ($40),y			sta 	(EXTAddress),y
.a942	c8		iny				iny 								; do till end of line.
.a943	cc c3 05	cpy $05c3			cpy 	EXTScreenWidth
.a946	90 f4		bcc $a93c			bcc 	_EXTDLoop
.a948	88		dey				dey 	 							; write in last slot.
.a949	68		pla				pla
.a94a	91 40		sta ($40),y			sta 	(EXTAddress),y
.a94c	60		rts				rts
.a94d					EXTILInsert:
.a94d	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; end position
.a950					_EXTILoop:
.a950	88		dey				dey 								; back one
.a951	cc c1 05	cpy $05c1			cpy 	EXTColumn 					; exit if reached insert point.
.a954	f0 08		beq $a95e			beq 	_EXTIExit
.a956	88		dey				dey 								; copy one byte up.
.a957	b1 40		lda ($40),y			lda 	(EXTAddress),y
.a959	c8		iny				iny
.a95a	91 40		sta ($40),y			sta 	(EXTAddress),y
.a95c	80 f2		bra $a950			bra 	_EXTILoop
.a95e					_EXTIExit:
.a95e	60		rts				rts
.a95f					EXTScrollFill:
.a95f	aa		tax				tax									; save value to fill with
.a960	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.a962	48		pha				pha
.a963	a5 37		lda $37				lda 	zTemp0+1
.a965	48		pha				pha
.a966	a5 38		lda $38				lda 	zTemp1
.a968	48		pha				pha
.a969	a5 39		lda $39				lda 	zTemp1+1
.a96b	48		pha				pha
.a96c	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.a96e	85 37		sta $37				sta 	zTemp0+1
.a970	85 39		sta $39				sta 	zTemp1+1
.a972	64 36		stz $36				stz 	zTemp0
.a974	ad c3 05	lda $05c3			lda 	EXTScreenWidth
.a977	85 38		sta $38				sta 	zTemp1
.a979	a0 00		ldy #$00			ldy 	#0
.a97b					_EXSFCopy1:
.a97b	b1 38		lda ($38),y			lda 	(zTemp1),y
.a97d	91 36		sta ($36),y			sta 	(zTemp0),y
.a97f	c8		iny				iny
.a980	d0 f9		bne $a97b			bne 	_EXSFCopy1
.a982	e6 37		inc $37				inc 	zTemp0+1 					; next page
.a984	e6 39		inc $39				inc 	zTemp1+1
.a986	a5 39		lda $39				lda 	zTemp1+1
.a988	c9 d3		cmp #$d3			cmp 	#$D3
.a98a	d0 ef		bne $a97b			bne 	_EXSFCopy1
.a98c	ac c3 05	ldy $05c3			ldy 	EXTScreenWidth 				; blank the bottom line.
.a98f	8a		txa				txa
.a990					_EXSFFill1:
.a990	88		dey				dey
.a991	91 40		sta ($40),y			sta 	(EXTAddress),y
.a993	c0 00		cpy #$00			cpy 	#0
.a995	10 f9		bpl $a990			bpl 	_EXSFFill1
.a997	68		pla				pla
.a998	85 39		sta $39				sta 	zTemp1+1
.a99a	68		pla				pla
.a99b	85 38		sta $38				sta 	zTemp1
.a99d	68		pla				pla
.a99e	85 37		sta $37				sta 	zTemp0+1
.a9a0	68		pla				pla
.a9a1	85 36		sta $36				sta 	zTemp0
.a9a3	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.05c0					EXTRow:
>05c0							.fill 	1
.05c1					EXTColumn:
>05c1							.fill 	1
.05c2					EXTTextColour:
>05c2							.fill 	1
.05c3					EXTScreenWidth:
>05c3							.fill 	1
.05c4					EXTScreenHeight:
>05c4							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.a9a4					Export_EXTInitialise:
.a9a4	64 01		stz $01				stz 	1 							; Access I/O page 0
.a9a6	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.a9a9	9c 08 d0	stz $d008			stz 	$D008
.a9ac	9c 09 d0	stz $d009			stz 	$D009
.a9af	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.a9b1	8d 58 d6	sta $d658			sta 	$D658
.a9b4	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.a9b6	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.a9b8	ad 00 c0	lda $c000			lda 	$C000
.a9bb	8d c2 05	sta $05c2			sta 	EXTTextColour
.a9be	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.a9c0	8d c3 05	sta $05c3			sta 	EXTScreenWidth
.a9c3	a9 3c		lda #$3c			lda 	#60
.a9c5	8d c4 05	sta $05c4			sta 	EXTScreenHeight
.a9c8	20 8d a8	jsr $a88d			jsr 	EXTHomeCursor 				; home cursor
.a9cb					_EXMoveDown:
.a9cb	a9 0d		lda #$0d			lda 	#13
.a9cd	20 0b a7	jsr $a70b			jsr 	PAGEDPrintCharacter
.a9d0	ad c0 05	lda $05c0			lda 	EXTRow
.a9d3	c9 06		cmp #$06			cmp 	#6
.a9d5	d0 f4		bne $a9cb			bne 	_EXMoveDown
.a9d7	64 01		stz $01				stz 	1
.a9d9	60		rts				rts
.a9da					Export_EXTInputSingleCharacter:
.a9da					PagedInputSingleCharacter:
.a9da	da		phx				phx
.a9db	5a		phy				phy
.a9dc					_EISCWait:
.a9dc	64 01		stz $01				stz 	1 							; access I/O Page 0
.a9de	38		sec				sec 								; calculate timer - LastTick
.a9df	ad 59 d6	lda $d659			lda 	$D659
.a9e2	aa		tax				tax 								; saving timer in X
.a9e3	ed af 05	sbc $05af			sbc 	LastTick
.a9e6	c9 03		cmp #$03			cmp 	#3
.a9e8	90 06		bcc $a9f0			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.a9ea	8e af 05	stx $05af			stx 	LastTick 					; update last timer
.a9ed	20 80 bd	jsr $bd80			jsr 	PagedSNDUpdate 							; go do the code.
.a9f0					_NoFireTick:
.a9f0	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.a9f3	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.a9f5	f0 e5		beq $a9dc			beq 	_EISCWait
.a9f7	7a		ply				ply
.a9f8	fa		plx				plx
.a9f9	60		rts				rts
.a9fa					Export_EXTBreakCheck:
.a9fa	4c e1 ff	jmp $ffe1			jmp		$FFE1
.a9fd					Export_EXTReadController:
.a9fd	da		phx				phx
.a9fe	a2 00		ldx #$00			ldx 	#0
.aa00	a9 05		lda #$05			lda 	#(($2D) >> 3)
.aa02	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa05	29 20		and #$20			and 	#($01 << (($2D) & 7))
.aa07	f0 04		beq $aa0d			beq 	_NoSet1
.aa09	8a		txa				txa
.aa0a	09 01		ora #$01			ora 	#1
.aa0c	aa		tax				tax
.aa0d					_NoSet1:
.aa0d	a9 05		lda #$05			lda 	#(($2C) >> 3)
.aa0f	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa12	29 10		and #$10			and 	#($01 << (($2C) & 7))
.aa14	f0 04		beq $aa1a			beq 	_NoSet1
.aa16	8a		txa				txa
.aa17	09 02		ora #$02			ora 	#2
.aa19	aa		tax				tax
.aa1a					_NoSet1:
.aa1a	a9 06		lda #$06			lda 	#(($32) >> 3)
.aa1c	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa1f	29 04		and #$04			and 	#($01 << (($32) & 7))
.aa21	f0 04		beq $aa27			beq 	_NoSet1
.aa23	8a		txa				txa
.aa24	09 04		ora #$04			ora 	#4
.aa26	aa		tax				tax
.aa27					_NoSet1:
.aa27	a9 04		lda #$04			lda 	#(($25) >> 3)
.aa29	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa2c	29 20		and #$20			and 	#($01 << (($25) & 7))
.aa2e	f0 04		beq $aa34			beq 	_NoSet1
.aa30	8a		txa				txa
.aa31	09 08		ora #$08			ora 	#8
.aa33	aa		tax				tax
.aa34					_NoSet1:
.aa34	a9 04		lda #$04			lda 	#(($26) >> 3)
.aa36	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.aa39	29 40		and #$40			and 	#($01 << (($26) & 7))
.aa3b	f0 04		beq $aa41			beq 	_NoSet1
.aa3d	8a		txa				txa
.aa3e	09 10		ora #$10			ora 	#16
.aa40	aa		tax				tax
.aa41					_NoSet1:
.aa41	8a		txa				txa
.aa42	fa		plx				plx
.aa43	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.aa44					GRVectorTable:
>aa44	93 ac					.word	GXInitialise             ; $00 Initialise
>aa46	ad ac					.word	GXControlBitmap          ; $01 BitmapCtl
>aa48	f5 ac					.word	GXControlSprite          ; $02 SpriteCtl
>aa4a	45 ac					.word	GXClearBitmap            ; $03 Clear
>aa4c	84 ae					.word	GXSetColourMode          ; $04 Colour
>aa4e	4c b0					.word	GXFontHandler            ; $05 DrawFont
>aa50	94 b0					.word	GXSpriteHandler          ; $06 DrawSprite
>aa52	05 b1					.word	GXSelect                 ; $07 SpriteUse
>aa54	2e b1					.word	GXSelectImage            ; $08 SpriteImage
>aa56	b5 b2					.word	GXCollide                ; $09 SpriteCollide
>aa58	f7 aa					.word	GRUndefined              ; $0a
>aa5a	f7 aa					.word	GRUndefined              ; $0b
>aa5c	f7 aa					.word	GRUndefined              ; $0c
>aa5e	f7 aa					.word	GRUndefined              ; $0d
>aa60	f7 aa					.word	GRUndefined              ; $0e
>aa62	f7 aa					.word	GRUndefined              ; $0f
>aa64	f7 aa					.word	GRUndefined              ; $10
>aa66	f7 aa					.word	GRUndefined              ; $11
>aa68	f7 aa					.word	GRUndefined              ; $12
>aa6a	f7 aa					.word	GRUndefined              ; $13
>aa6c	f7 aa					.word	GRUndefined              ; $14
>aa6e	f7 aa					.word	GRUndefined              ; $15
>aa70	f7 aa					.word	GRUndefined              ; $16
>aa72	f7 aa					.word	GRUndefined              ; $17
>aa74	f7 aa					.word	GRUndefined              ; $18
>aa76	f7 aa					.word	GRUndefined              ; $19
>aa78	f7 aa					.word	GRUndefined              ; $1a
>aa7a	f7 aa					.word	GRUndefined              ; $1b
>aa7c	f7 aa					.word	GRUndefined              ; $1c
>aa7e	f7 aa					.word	GRUndefined              ; $1d
>aa80	f7 aa					.word	GRUndefined              ; $1e
>aa82	f7 aa					.word	GRUndefined              ; $1f
>aa84	f5 aa					.word	GXMove                   ; $20 Move
>aa86	52 ad					.word	GXLine                   ; $21 Line
>aa88	cd ae					.word	GXFrameRectangle         ; $22 FrameRect
>aa8a	ca ae					.word	GXFillRectangle          ; $23 FillRect
>aa8c	fc aa					.word	GXFrameCircle            ; $24 FrameCircle
>aa8e	f8 aa					.word	GXFillCircle             ; $25 FillCircle
>aa90	f7 aa					.word	GRUndefined              ; $26
>aa92	f7 aa					.word	GRUndefined              ; $27
>aa94	b2 ae					.word	GXPlotPoint              ; $28 Plot
>aa96	c4 b1					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$57b					gxPixelBuffer = numberBuffer
.05c5					gxCurrentX:
>05c5							.fill 	2
.05c7					gxCurrentY:
>05c7							.fill 	2
.05c9					gxLastX:
>05c9							.fill 	2
.05cb					gxLastY:
>05cb							.fill 	2
.05cd					gxX0:
>05cd							.fill 	2
.05cf					gxY0:
>05cf							.fill 	2
.05d1					gxX1:
>05d1							.fill 	2
.05d3					gxY1:
>05d3							.fill 	2
.05d5					gxSpritesOn:
>05d5							.fill 	1
.05d6					gxBitmapsOn:
>05d6							.fill 	1
.05d7					gxBasePage:
>05d7							.fill 	1
.05d8					gxSpritePage:
>05d8							.fill 	1
.05d9					gxHeight:
>05d9							.fill 	1
.05da					gxMode:
>05da							.fill 	1
.05db					gxColour:
>05db							.fill 	1
.05dc					gxEORValue:
>05dc							.fill 	1
.05dd					gxANDValue:
>05dd							.fill 	1
.05de					gxOriginalLUTValue:
>05de							.fill 	1
.05df					gsOffset:
>05df							.fill 	1
.05e0					GSCurrentSpriteID:
>05e0							.fill 	1
.05e1					GSCurrentSpriteAddr:
>05e1							.fill 	2
.05e3					GXSpriteOffsetBase:
>05e3							.fill 	2
.05e5					GXSpriteLow:
>05e5							.fill 	64
.0625					GXSpriteHigh:
>0625							.fill 	64
.aa98					Export_GXGraphicDraw:
.aa98	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aa9a	b0 06		bcs $aaa2			bcs 	_GDCoordinate
.aa9c	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.aa9e	84 37		sty $37				sty 	gxzTemp0+1
.aaa0	80 4b		bra $aaed			bra 	_GDExecuteA 				; and execute
.aaa2					_GDCoordinate:
.aaa2	48		pha				pha 								; save AXY
.aaa3	da		phx				phx
.aaa4	5a		phy				phy
.aaa5	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.aaa7					_GDCopy1:
.aaa7	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aaaa	9d c9 05	sta $05c9,x			sta 	gxLastX,x
.aaad	ca		dex				dex
.aaae	10 f7		bpl $aaa7			bpl 	_GDCopy1
.aab0	68		pla				pla 								; update Y
.aab1	8d c7 05	sta $05c7			sta 	gxCurrentY
.aab4	9c c8 05	stz $05c8			stz 	gxCurrentY+1
.aab7	68		pla				pla
.aab8	8d c5 05	sta $05c5			sta 	gxCurrentX
.aabb	68		pla				pla 								; get A (command+X.1) back
.aabc	48		pha				pha
.aabd	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aabf	8d c6 05	sta $05c6			sta 	gxCurrentX+1
.aac2	68		pla				pla 								; get command back
.aac3	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.aac5	48		pha				pha 								; push back.
.aac6	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.aac8	f0 17		beq $aae1			beq 	_GDCopyToWorkArea
.aaca	ad c6 05	lda $05c6			lda 	gxCurrentX+1 				; X < 256 X okay
.aacd	f0 07		beq $aad6			beq 	_GDCheckY
.aacf	ad c5 05	lda $05c5			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.aad2	c9 40		cmp #$40			cmp 	#64
.aad4	b0 08		bcs $aade			bcs 	_GDError1
.aad6					_GDCheckY:
.aad6	ad c7 05	lda $05c7			lda 	gxCurrentY 					; check Y < Height.
.aad9	cd d9 05	cmp $05d9			cmp 	gxHeight
.aadc	90 03		bcc $aae1			bcc 	_GDCopyToWorkArea
.aade					_GDError1:
.aade	68		pla				pla
.aadf					_GDError2:
.aadf	38		sec				sec
.aae0	60		rts				rts
.aae1					_GDCopyToWorkArea:
.aae1	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.aae3					_GDCopy2:
.aae3	bd c5 05	lda $05c5,x			lda 	gxCurrentX,x
.aae6	9d cd 05	sta $05cd,x			sta 	gxX0,x
.aae9	ca		dex				dex
.aaea	10 f7		bpl $aae3			bpl 	_GDCopy2
.aaec	68		pla				pla 								; get command
.aaed					_GDExecuteA:
.aaed	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.aaef	b0 ee		bcs $aadf			bcs 	_GDError2
.aaf1	aa		tax				tax
.aaf2	7c 44 aa	jmp ($aa44,x)			jmp 	(GRVectorTable,x)
.aaf5					GXMove:
.aaf5	18		clc				clc
.aaf6	60		rts				rts
.aaf7					GRUndefined:
>aaf7	db						.byte 	$DB 						; causes a break in the emulator
.aaf8					GXFillCircle:
.aaf8	a9 ff		lda #$ff			lda 	#255
.aafa	80 02		bra $aafe			bra 	GXCircle
.aafc					GXFrameCircle:
.aafc	a9 00		lda #$00			lda 	#0
.aafe					GXCircle:
.aafe	8d 68 06	sta $0668			sta 	gxIsFillMode					; save Fill flag
.ab01	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.ab04	f0 26		beq $ab2c			beq 	_GXCFail
.ab06	20 5c b3	jsr $b35c			jsr 	GXSortXY 					; topleft/bottomright
.ab09	20 34 b2	jsr $b234			jsr 	GXOpenBitmap 				; start drawing
.ab0c	20 fe ab	jsr $abfe			jsr 	GXCircleSetup 				; set up for drawing
.ab0f	9c 69 06	stz $0669			stz 	gxYChanged
.ab12					_GXCircleDraw:
.ab12	ad 66 06	lda $0666			lda 	gXCentre					; while x <= y
.ab15	cd 67 06	cmp $0667			cmp 	gYCentre
.ab18	90 0a		bcc $ab24			bcc 	_GXCircleContinue
.ab1a	d0 03		bne $ab1f			bne 	_GXNoLast
.ab1c	20 31 ab	jsr $ab31			jsr 	GXPlot1
.ab1f					_GXNoLast:
.ab1f	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap 				; close the bitmap
.ab22	18		clc				clc
.ab23	60		rts				rts
.ab24					_GXCircleContinue:
.ab24	20 2e ab	jsr $ab2e			jsr 	GXPlot2 					; draw it
.ab27	20 ab ab	jsr $abab			jsr 	GXCircleMove 				; adjust the coordinates
.ab2a	80 e6		bra $ab12			bra 	_GXCircleDraw
.ab2c					_GXCFail:
.ab2c	38		sec				sec
.ab2d	60		rts				rts
.ab2e					GXPlot2:
.ab2e	20 31 ab	jsr $ab31			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ab31					GXPlot1:
.ab31	ad 67 06	lda $0667			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ab34	f0 03		beq $ab39			beq 	_GXPlot1Only
.ab36	20 55 ab	jsr $ab55			jsr 	GXPlot0 						; plot and negate
.ab39					_GXPlot1Only:
.ab39	20 55 ab	jsr $ab55			jsr 	GXPlot0 						; twice, undoing negation
.ab3c	ad 66 06	lda $0666			lda 	gXCentre 						; swap X and Y
.ab3f	ae 67 06	ldx $0667			ldx	 	gYCentre
.ab42	8d 67 06	sta $0667			sta 	gYCentre
.ab45	8e 66 06	stx $0666			stx 	gXCentre
.ab48	ad 69 06	lda $0669			lda 	gxYChanged 						; toggle Y Changed flag
.ab4b	a9 ff		lda #$ff			lda 	#$FF
.ab4d	8d 69 06	sta $0669			sta 	gxYChanged
.ab50	60		rts				rts
.ab51	20 55 ab	jsr $ab55			jsr 	GXPlot0 						; do once
.ab54	60		rts				rts
.ab55	ad 68 06	lda $0668	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ab58	f0 05		beq $ab5f			beq 	_GXPlot0Always
.ab5a	ad 69 06	lda $0669			lda 	gxYChanged						; fill mode, only draw if changed.
.ab5d	f0 2d		beq $ab8c			beq 	GXPlot0Exit
.ab5f					_GXPlot0Always:
.ab5f	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ab61	ad 67 06	lda $0667			lda 	gYCentre
.ab64	20 8d ab	jsr $ab8d			jsr 	GXSubCopy
.ab67	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ab69	ad 66 06	lda $0666			lda 	gXCentre
.ab6c	20 8d ab	jsr $ab8d			jsr 	GXSubCopy
.ab6f	48		pha				pha 									; save last offset X
.ab70	20 44 b2	jsr $b244			jsr 	GXPositionCalc 					; calculate position/offset.
.ab73	68		pla				pla
.ab74	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ab75	85 36		sta $36				sta 	gxzTemp0
.ab77	64 37		stz $37				stz 	gxzTemp0+1
.ab79	26 37		rol $37				rol 	gxzTemp0+1
.ab7b	ad 68 06	lda $0668			lda 	gxIsFillMode
.ab7e	69 80		adc #$80			adc 	#128
.ab80	20 1d af	jsr $af1d			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ab83	38		sec				sec 									; GY = -GY
.ab84	a9 00		lda #$00			lda 	#0
.ab86	ed 67 06	sbc $0667			sbc 	gYCentre
.ab89	8d 67 06	sta $0667			sta 	gYCentre
.ab8c					GXPlot0Exit:
.ab8c	60		rts				rts
.ab8d					GXSubCopy:
.ab8d	85 36		sta $36				sta 	gxzTemp0
.ab8f	64 37		stz $37				stz 	gxzTemp0+1
.ab91	29 80		and #$80			and 	#$80
.ab93	f0 02		beq $ab97			beq 	_GXNoSx
.ab95	c6 37		dec $37				dec 	gxzTemp0+1
.ab97					_GXNoSx:
.ab97	38		sec				sec
.ab98	bd d1 05	lda $05d1,x			lda 	gXX1,x
.ab9b	e5 36		sbc $36				sbc 	gxzTemp0
.ab9d	9d cd 05	sta $05cd,x			sta 	gXX0,x
.aba0	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.aba3	e5 37		sbc $37				sbc 	gxzTemp0+1
.aba5	9d ce 05	sta $05ce,x			sta 	gXX0+1,x
.aba8	a5 36		lda $36				lda 	gxzTemp0 						; return A
.abaa	60		rts				rts
.abab					GXCircleMove:
.abab	9c 69 06	stz $0669			stz 	gxYChanged 					; clear Y changed flag
.abae	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.abb0	10 0d		bpl $abbf			bpl 	_GXEMPositive
.abb2	ee 66 06	inc $0666			inc 	gXCentre 					; X++
.abb5	ad 66 06	lda $0666			lda 	gXCentre
.abb8	20 de ab	jsr $abde			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abbb	a9 06		lda #$06			lda 	#6  						; and add 6
.abbd	80 15		bra $abd4			bra 	_GXEMAddD
.abbf					_GXEMPositive:
.abbf	ee 66 06	inc $0666			inc 	gXCentre					; X++
.abc2	ce 67 06	dec $0667			dec 	gyCentre 					; Y--
.abc5	38		sec				sec 								; calculate X-Y
.abc6	ad 66 06	lda $0666			lda 	gXCentre
.abc9	ed 67 06	sbc $0667			sbc 	gYCentre
.abcc	20 de ab	jsr $abde			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.abcf	a9 0a		lda #$0a			lda 	#10  						; and add 10
.abd1	ce 69 06	dec $0669			dec 	gxYChanged
.abd4					_GXEMAddD:
.abd4	18		clc				clc
.abd5	65 38		adc $38				adc 	gxzTemp1
.abd7	85 38		sta $38				sta 	gxzTemp1
.abd9	90 02		bcc $abdd			bcc 	_GXEMNoCarry
.abdb	e6 39		inc $39				inc 	gxzTemp1+1
.abdd					_GXEMNoCarry:
.abdd	60		rts				rts
.abde					_GXAdd4TimesToD:
.abde	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.abe0	29 80		and #$80			and 	#$80
.abe2	f0 02		beq $abe6			beq 	_GXA4Unsigned
.abe4	a9 ff		lda #$ff			lda 	#$FF
.abe6					_GXA4Unsigned:
.abe6	85 37		sta $37				sta 	gxzTemp0+1
.abe8	06 36		asl $36				asl 	gxzTemp0  					; x 4
.abea	26 37		rol $37				rol 	gxzTemp0+1
.abec	06 36		asl $36				asl 	gxzTemp0
.abee	26 37		rol $37				rol 	gxzTemp0+1
.abf0	18		clc				clc 								; add
.abf1	a5 36		lda $36				lda		gxzTemp0
.abf3	65 38		adc $38				adc 	gxzTemp1
.abf5	85 38		sta $38				sta 	gxzTemp1
.abf7	a5 37		lda $37				lda		gxzTemp0+1
.abf9	65 39		adc $39				adc 	gxzTemp1+1
.abfb	85 39		sta $39				sta 	gxzTemp1+1
.abfd	60		rts				rts
.abfe					GXCircleSetup:
.abfe	38		sec				sec
.abff	ad d3 05	lda $05d3			lda 	gxY1
.ac02	ed cf 05	sbc $05cf			sbc 	gxY0
.ac05	4a		lsr a				lsr 	a
.ac06	8d 65 06	sta $0665			sta 	gxRadius
.ac09	a2 00		ldx #$00			ldx 	#0
.ac0b	20 2d ac	jsr $ac2d			jsr 	_GXCalculateCentre
.ac0e	a2 02		ldx #$02			ldx 	#2
.ac10	20 2d ac	jsr $ac2d			jsr 	_GXCalculateCentre
.ac13	9c 66 06	stz $0666			stz 	gXCentre
.ac16	ad 65 06	lda $0665			lda 	gxRadius
.ac19	8d 67 06	sta $0667			sta 	gYCentre
.ac1c	0a		asl a				asl 	a 							; R x 2
.ac1d	85 36		sta $36				sta 	gxzTemp0
.ac1f	38		sec				sec
.ac20	a9 03		lda #$03			lda 	#3
.ac22	e5 36		sbc $36				sbc 	gxzTemp0
.ac24	85 38		sta $38				sta 	gxzTemp1
.ac26	a9 00		lda #$00			lda 	#0
.ac28	e9 00		sbc #$00			sbc 	#0
.ac2a	85 39		sta $39				sta 	gxzTemp1+1
.ac2c	60		rts				rts
.ac2d					_GXCalculateCentre:
.ac2d	38		sec				sec
.ac2e	bd d1 05	lda $05d1,x			lda 	gxX1,x
.ac31	7d cd 05	adc $05cd,x			adc 	gXX0,x
.ac34	9d d1 05	sta $05d1,x			sta 	gXX1,x
.ac37	bd d2 05	lda $05d2,x			lda 	gXX1+1,x
.ac3a	7d ce 05	adc $05ce,x			adc 	gXX0+1,x
.ac3d	4a		lsr a				lsr 	a
.ac3e	9d d2 05	sta $05d2,x			sta 	gXX1+1,x
.ac41	7e d1 05	ror $05d1,x			ror 	gXX1,x
.ac44	60		rts				rts
.0665					gxRadius:
>0665							.fill 	1
.0666					gXCentre:
>0666							.fill 	1
.0667					gYCentre:
>0667							.fill 	1
.0668					gxIsFillMode:
>0668							.fill 	1
.0669					gxYChanged:
>0669							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ac45					GXClearBitmap:
.ac45	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP running.
.ac48	f0 24		beq $ac6e			beq 	_GXCBFail
.ac4a	20 34 b2	jsr $b234			jsr 	GXOpenBitmap 				; start access
.ac4d	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ac4f	ad d9 05	lda $05d9			lda 	gxHeight
.ac52	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ac54	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ac56					_GXCalcLastPage:
.ac56	98		tya				tya 								; add to base page
.ac57	18		clc				clc
.ac58	6d d7 05	adc $05d7			adc 	gxBasePage
.ac5b	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ac5d					_GXClearAll:
.ac5d	20 70 ac	jsr $ac70			jsr 	_GXClearBlock 				; clear 8k block
.ac60	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ac62	a5 0b		lda $0b				lda 	GXEditSlot
.ac64	cd d7 05	cmp $05d7			cmp 	gxBasePage 					; until before base page
.ac67	b0 f4		bcs $ac5d			bcs 	_GXClearAll
.ac69	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap	 			; stop access
.ac6c	18		clc				clc
.ac6d	60		rts				rts
.ac6e					_GXCBFail:
.ac6e	38		sec				sec
.ac6f	60		rts				rts
.ac70					_GXClearBlock:
.ac70	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ac72	85 38		sta $38				sta 	0+gxzTemp1
.ac74	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ac76	85 39		sta $39				sta 	1+gxzTemp1
.ac78					_GXCB0:
.ac78	a5 36		lda $36				lda 	gxzTemp0
.ac7a	a0 00		ldy #$00			ldy 	#0
.ac7c					_GXCB1:
.ac7c	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac7e	c8		iny				iny
.ac7f	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac81	c8		iny				iny
.ac82	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac84	c8		iny				iny
.ac85	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ac87	c8		iny				iny
.ac88	d0 f2		bne $ac7c			bne 	_GXCB1
.ac8a	e6 39		inc $39				inc 	gxzTemp1+1
.ac8c	a5 39		lda $39				lda 	gxzTemp1+1
.ac8e	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ac90	d0 e6		bne $ac78			bne 	_GXCB0
.ac92	60		rts				rts
.ac93					GXInitialise:
.ac93	64 01		stz $01				stz 	1
.ac95	a9 01		lda #$01			lda 	#1
.ac97	8d 00 d0	sta $d000			sta 	$D000
.ac9a	18		clc				clc
.ac9b	9c d5 05	stz $05d5			stz 	GXSpritesOn
.ac9e	9c d6 05	stz $05d6			stz 	GXBitmapsOn
.aca1	a2 0f		ldx #$0f			ldx 	#15
.aca3					_GXIClear:
.aca3	9e c5 05	stz $05c5,x			stz 	gxCurrentX,x
.aca6	ca		dex				dex
.aca7	10 fa		bpl $aca3			bpl 	_GXIClear
.aca9	20 44 ad	jsr $ad44			jsr 	GXClearSpriteStore
.acac	60		rts				rts
.acad					GXControlBitmap:
.acad	64 01		stz $01				stz 	1
.acaf	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acb1	29 01		and #$01			and 	#1 							; set bitmap flag
.acb3	8d d6 05	sta $05d6			sta 	gxBitmapsOn
.acb6	4a		lsr a				lsr 	a 							; bit 0 into carry.
.acb7	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.acba	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.acbc	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.acbe	90 02		bcc $acc2			bcc 	_CBNotOn
.acc0	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.acc2					_CBNotOn:
.acc2	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.acc5	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.acc7	29 07		and #$07			and 	#7
.acc9	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.accc	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.acce	d0 02		bne $acd2			bne 	_CBNotDefault
.acd0	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.acd2					_CBNotDefault:
.acd2	8d d7 05	sta $05d7			sta 	gxBasePage
.acd5	20 36 ad	jsr $ad36			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.acd8	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.acda	8d 03 d1	sta $d103			sta 	$D103
.acdd	a5 36		lda $36				lda 	gxzTemp0
.acdf	8d 02 d1	sta $d102			sta 	$D102
.ace2	9c 01 d1	stz $d101			stz 	$D101
.ace5	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.ace7	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.acea	29 01		and #$01			and 	#1
.acec	f0 02		beq $acf0			beq 	_CBHaveHeight
.acee	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.acf0					_CBHaveHeight
.acf0	8e d9 05	stx $05d9			stx 	gxHeight
.acf3	18		clc				clc
.acf4	60		rts				rts
.acf5					GXControlSprite:
.acf5	64 01		stz $01				stz 	1
.acf7	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.acf9	29 01		and #$01			and 	#1 							; set sprites flag
.acfb	8d d5 05	sta $05d5			sta 	gxSpritesOn
.acfe	4a		lsr a				lsr 	a 							; bit 0 into carry.
.acff	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ad02	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ad04	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ad06	90 02		bcc $ad0a			bcc 	_CSNotOn
.ad08	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ad0a					_CSNotOn:
.ad0a	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ad0d	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ad0f	d0 02		bne $ad13			bne 	_CSNotDefault
.ad11	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ad13					_CSNotDefault:
.ad13	8d d8 05	sta $05d8			sta 	gxSpritePage
.ad16	20 36 ad	jsr $ad36			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ad19	a5 36		lda $36				lda 	zTemp0
.ad1b	8d e3 05	sta $05e3			sta 	GXSpriteOffsetBase
.ad1e	a5 37		lda $37				lda 	zTemp0+1
.ad20	8d e4 05	sta $05e4			sta 	GXSpriteOffsetBase+1
.ad23	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ad25					_CSClear:
.ad25	9e 00 d9	stz $d900,x			stz 	$D900,x
.ad28	9e 00 da	stz $da00,x			stz 	$DA00,x
.ad2b	ca		dex				dex
.ad2c	d0 f7		bne $ad25			bne 	_CSClear
.ad2e	9c e2 05	stz $05e2			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ad31	20 44 ad	jsr $ad44			jsr 	GXClearSpriteStore
.ad34	18		clc				clc
.ad35	60		rts				rts
.ad36					GXCalculateBaseAddress:
.ad36	85 36		sta $36				sta 	gxzTemp0
.ad38	64 37		stz $37				stz 	gxzTemp0+1
.ad3a	a9 05		lda #$05			lda 	#5
.ad3c					_GXShift:
.ad3c	06 36		asl $36				asl 	gxzTemp0
.ad3e	26 37		rol $37				rol 	gxzTemp0+1
.ad40	3a		dec a				dec		a
.ad41	d0 f9		bne $ad3c			bne 	_GXShift
.ad43	60		rts				rts
.ad44					GXClearSpriteStore:
.ad44	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ad46					_GXCSSLoop:
.ad46	9e 25 06	stz $0625,x			stz 	GXSpriteHigh,x
.ad49	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ad4b	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.ad4e	ca		dex				dex
.ad4f	10 f5		bpl $ad46			bpl 	_GXCSSLoop
.ad51	60		rts				rts
.ad52					GXLine:
.ad52	ad d6 05	lda $05d6			lda 	GXBitmapsOn
.ad55	f0 28		beq $ad7f			beq 	_GXLFail
.ad57	20 34 b2	jsr $b234			jsr 	GXOpenBitmap
.ad5a	20 7a b3	jsr $b37a			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ad5d	20 25 ae	jsr $ae25			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ad60	20 44 b2	jsr $b244			jsr 	GXPositionCalc 				; calculate position/offset.
.ad63					_GXDrawLoop:
.ad63	ac df 05	ldy $05df			ldy 	gsOffset 					; draw the pixel
.ad66	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ad68	2d dd 05	and $05dd			and 	gxANDValue
.ad6b	4d dc 05	eor $05dc			eor 	gxEORValue
.ad6e	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ad70	20 81 ad	jsr $ad81			jsr 	GXLineIsComplete 			; is the line complete ?
.ad73	f0 05		beq $ad7a			beq 	_GXLExit
.ad75	20 9c ad	jsr $ad9c			jsr 	GXLineAdvance 				; code as per advance method
.ad78	80 e9		bra $ad63			bra 	_GXDrawLoop
.ad7a					_GXLExit:
.ad7a	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap
.ad7d	18		clc				clc
.ad7e	60		rts				rts
.ad7f					_GXLFail:
.ad7f	38		sec				sec
.ad80	60		rts				rts
.ad81					GXLineIsComplete:
.ad81	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger 			; is dy larger
.ad84	d0 0f		bne $ad95			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ad86	ad cd 05	lda $05cd			lda 	GXX0 						; compare X, LSB and MSB
.ad89	4d d1 05	eor $05d1			eor 	GXX1
.ad8c	d0 06		bne $ad94			bne 	_GXLICExit
.ad8e	ad ce 05	lda $05ce			lda 	GXX0+1
.ad91	4d d2 05	eor $05d2			eor 	GXX1+1
.ad94					_GXLICExit:
.ad94	60		rts				rts
.ad95					_GXLICCompareY:
.ad95	ad d3 05	lda $05d3			lda 	GXY1
.ad98	4d cf 05	eor $05cf			eor 	GXY0
.ad9b	60		rts				rts
.ad9c					GXLineAdvance:
.ad9c	18		clc				clc 								; add adjust to position
.ad9d	ad 6e 06	lda $066e			lda 	GXPosition
.ada0	6d 6f 06	adc $066f			adc 	GXAdjust
.ada3	8d 6e 06	sta $066e			sta 	GXPosition
.ada6	9c 71 06	stz $0671			stz 	GXAddSelect 				; clear add select flag
.ada9	b0 05		bcs $adb0			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.adab	cd 70 06	cmp $0670			cmp 	GXTotal 					; if exceeded total
.adae	90 0a		bcc $adba			bcc 	_GXLANoExtra
.adb0					_GXLAOverflow:
.adb0	ce 71 06	dec $0671			dec 	GXAddSelect 				; set addselect to $FF
.adb3	38		sec				sec 								; subtract total and write back
.adb4	ed 70 06	sbc $0670			sbc 	GXTotal
.adb7	8d 6e 06	sta $066e			sta 	GXPosition
.adba					_GXLANoExtra:
.adba	ad 6c 06	lda $066c			lda 	GXIsDiffYLarger
.adbd	f0 0d		beq $adcc			beq 	_GXDXLarger
.adbf	20 1e ae	jsr $ae1e			jsr 	GXIncrementY
.adc2	ad 71 06	lda $0671			lda 	GXAddSelect
.adc5	f0 10		beq $add7			beq 	_GXLAExit
.adc7	20 d8 ad	jsr $add8			jsr 	GXAdjustX
.adca	80 0b		bra $add7			bra 	_GXLAExit
.adcc					_GXDXLarger:
.adcc	20 d8 ad	jsr $add8			jsr 	GXAdjustX
.adcf	ad 71 06	lda $0671			lda 	GXAddSelect
.add2	f0 03		beq $add7			beq 	_GXLAExit
.add4	20 1e ae	jsr $ae1e			jsr 	GXIncrementY
.add7					_GXLAExit:
.add7	60		rts				rts
.add8					GXAdjustX:
.add8	ad 6d 06	lda $066d			lda 	GXDXNegative
.addb	10 25		bpl $ae02			bpl 	_GXAXRight
.addd	ad cd 05	lda $05cd			lda 	GXX0
.ade0	d0 03		bne $ade5			bne 	_GXAXNoBorrow
.ade2	ce ce 05	dec $05ce			dec 	GXX0+1
.ade5					_GXAXNoBorrow:
.ade5	ce cd 05	dec $05cd			dec 	GXX0
.ade8	ce df 05	dec $05df			dec 	gsOffset 					; pixel left
.adeb	ad df 05	lda $05df			lda 	gsOffset
.adee	c9 ff		cmp #$ff			cmp 	#$FF
.adf0	d0 0f		bne $ae01			bne 	_GXAYExit 					; underflow
.adf2	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.adf4	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.adf6	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.adf8	b0 07		bcs $ae01			bcs 	_GXAYExit
.adfa	18		clc				clc
.adfb	69 20		adc #$20			adc 	#$20 						; fix up
.adfd	85 3d		sta $3d				sta 	gxzScreen+1
.adff	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.ae01					_GXAYExit:
.ae01	60		rts				rts
.ae02					_GXAXRight:
.ae02	ee cd 05	inc $05cd			inc 	GXX0
.ae05	d0 03		bne $ae0a			bne 	_GXAXNoCarry
.ae07	ee ce 05	inc $05ce			inc 	GXX0+1
.ae0a					_GXAXNoCarry:
.ae0a	ee df 05	inc $05df			inc 	gsOffset 					; pixel right
.ae0d	d0 0e		bne $ae1d			bne 	_GXAXExit 					; if not overflowed, exit.
.ae0f	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.ae11	a5 3d		lda $3d				lda 	gxzScreen+1
.ae13	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.ae15	90 06		bcc $ae1d			bcc 	_GXAXExit
.ae17	e9 20		sbc #$20			sbc 	#$20 						; fix up
.ae19	85 3d		sta $3d				sta 	gxzScreen+1
.ae1b	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.ae1d					_GXAXExit:
.ae1d	60		rts				rts
.ae1e					GXIncrementY:
.ae1e	ee cf 05	inc $05cf			inc 	GXY0
.ae21	20 9a b2	jsr $b29a			jsr 	GXMovePositionDown
.ae24	60		rts				rts
.ae25					GXLineSetup:
.ae25	ad d3 05	lda $05d3			lda 	GXY1
.ae28	38		sec				sec
.ae29	ed cf 05	sbc $05cf			sbc 	GXY0
.ae2c	4a		lsr a				lsr 	a
.ae2d	8d 6b 06	sta $066b			sta 	GXDiffY
.ae30	9c 6d 06	stz $066d			stz 	GXDXNegative 				; clear -ve flag
.ae33	38		sec				sec
.ae34	ad d1 05	lda $05d1			lda 	GXX1
.ae37	ed cd 05	sbc $05cd			sbc 	GXX0
.ae3a	8d 6a 06	sta $066a			sta 	GXDiffX
.ae3d	ad d2 05	lda $05d2			lda 	GXX1+1 						; calculate MSB
.ae40	ed ce 05	sbc $05ce			sbc 	GXX0+1
.ae43	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.ae44	6e 6a 06	ror $066a			ror 	GXDiffX
.ae47	0a		asl a				asl 	a
.ae48	10 0c		bpl $ae56			bpl 	_GDXNotNegative
.ae4a	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.ae4c	38		sec				sec
.ae4d	ed 6a 06	sbc $066a			sbc 	GXDiffX
.ae50	8d 6a 06	sta $066a			sta 	GXDiffX
.ae53	ce 6d 06	dec $066d			dec 	GXDXNegative 				; -ve flag = $FF.
.ae56					_GDXNotNegative:
.ae56	9c 6c 06	stz $066c			stz 	GXIsDiffYLarger 			; clear larger flag
.ae59	ad 6b 06	lda $066b			lda 	GXDiffY 					; set adjust and total.
.ae5c	8d 6f 06	sta $066f			sta 	GXAdjust
.ae5f	ad 6a 06	lda $066a			lda 	GXDiffX
.ae62	8d 70 06	sta $0670			sta 	GXTotal
.ae65	ad 6b 06	lda $066b			lda 	GXDiffY 					; if dy > dx
.ae68	cd 6a 06	cmp $066a			cmp 	GXDiffX
.ae6b	90 0f		bcc $ae7c			bcc 	_GDXNotLarger
.ae6d	ce 6c 06	dec $066c			dec 	GXIsDiffYLarger 			; set the dy larger flag
.ae70	ad 6a 06	lda $066a			lda 	GXDiffX 					; set adjust and total other way round
.ae73	8d 6f 06	sta $066f			sta 	GXAdjust
.ae76	ad 6b 06	lda $066b			lda 	GXDiffY
.ae79	8d 70 06	sta $0670			sta 	GXTotal
.ae7c					_GDXNotLarger:
.ae7c	ad 70 06	lda $0670			lda 	GXTotal
.ae7f	4a		lsr a				lsr 	a
.ae80	8d 6e 06	sta $066e			sta 	GXPosition
.ae83	60		rts				rts
.066a					GXDiffX:
>066a							.fill 	1
.066b					GXDiffY:
>066b							.fill 	1
.066c					GXIsDiffYLarger:
>066c							.fill 	1
.066d					GXDXNegative:
>066d							.fill 	1
.066e					GXPosition:
>066e							.fill 	1
.066f					GXAdjust:
>066f							.fill 	1
.0670					GXTotal:
>0670							.fill 	1
.0671					GXAddSelect:
>0671							.fill 	1
.ae84					GXSetColourMode:
.ae84	a6 36		ldx $36				ldx 	gxzTemp0
.ae86	8e db 05	stx $05db			stx 	gxColour 								; set colour
.ae89	a5 37		lda $37				lda 	gxzTemp0+1 								;
.ae8b	8d da 05	sta $05da			sta 	gxMode 									; set mode
.ae8e	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.ae90	9c dd 05	stz $05dd			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.ae93	ae db 05	ldx $05db			ldx 	gxColour
.ae96	8e dc 05	stx $05dc			stx 	gxEORValue
.ae99	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.ae9b	90 03		bcc $aea0			bcc 	_GXSDCNotAndColour
.ae9d	8e dd 05	stx $05dd			stx 	gxANDValue
.aea0					_GXSDCNotAndColour:
.aea0	d0 03		bne $aea5			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.aea2	9c dc 05	stz $05dc			stz 	gxEORValue
.aea5					_GXSDCNotAnd:
.aea5	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.aea6	90 08		bcc $aeb0			bcc 	_GXSDCNoFlip
.aea8	ad dd 05	lda $05dd			lda	 	gxANDValue
.aeab	49 ff		eor #$ff			eor 	#$FF
.aead	8d dd 05	sta $05dd			sta 	gxANDValue
.aeb0					_GXSDCNoFlip:
.aeb0	18		clc				clc
.aeb1	60		rts				rts
.aeb2					GXPlotPoint:
.aeb2	20 34 b2	jsr $b234			jsr 	GXOpenBitmap 				; start drawing
.aeb5	20 44 b2	jsr $b244			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aeb8	ac df 05	ldy $05df			ldy 	gsOffset
.aebb	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.aebd	2d dd 05	and $05dd			and 	gxANDValue
.aec0	4d dc 05	eor $05dc			eor 	gxEORValue
.aec3	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.aec5	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap 				; stop drawing and exit
.aec8	18		clc				clc
.aec9	60		rts				rts
.aeca					GXFillRectangle:
.aeca	38		sec				sec
.aecb	80 01		bra $aece			bra 	GXRectangle
.aecd					GXFrameRectangle:
.aecd	18		clc				clc
.aece					GXRectangle:
.aece	ad d6 05	lda $05d6			lda 	gxBitmapsOn
.aed1	f0 35		beq $af08			beq 	_GXRFail
.aed3	08		php				php 								; save Fill flag (CS)
.aed4	20 34 b2	jsr $b234			jsr 	GXOpenBitmap 				; start drawing
.aed7	20 5c b3	jsr $b35c			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.aeda	20 44 b2	jsr $b244			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.aedd	38		sec				sec 								; sec = Draw line
.aede	20 0a af	jsr $af0a			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.aee1	ad cf 05	lda $05cf			lda 	gxY0 						; reached end of rectangle ?
.aee4	cd d3 05	cmp $05d3			cmp 	gxY1
.aee7	f0 19		beq $af02			beq 	_GXRectangleExit
.aee9					_GXRectLoop:
.aee9	20 9a b2	jsr $b29a			jsr 	GXMovePositionDown 			; down one.
.aeec	ee cf 05	inc $05cf			inc 	gxY0 						; change Y pos
.aeef	ad cf 05	lda $05cf			lda 	gxY0 						; reached last line
.aef2	cd d3 05	cmp $05d3			cmp 	gXY1
.aef5	f0 07		beq $aefe			beq 	_GXLastLine
.aef7	28		plp				plp 								; get flag back
.aef8	08		php				php
.aef9	20 0a af	jsr $af0a			jsr 	GXDrawLineX1X0 				; draw horizontal line
.aefc	80 eb		bra $aee9			bra 	_GXRectLoop
.aefe					_GXLastLine:
.aefe	38		sec				sec
.aeff	20 0a af	jsr $af0a			jsr 	GXDrawLineX1X0
.af02					_GXRectangleExit:
.af02	68		pla				pla 								; throw fill flag.
.af03	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap 				; stop drawing and exit
.af06	18		clc				clc
.af07	60		rts				rts
.af08					_GXRFail:
.af08	38		sec				sec
.af09	60		rts				rts
.af0a					GXDrawLineX1X0:
.af0a	08		php				php 								; save solid/either-end
.af0b	38		sec				sec
.af0c	ad d1 05	lda $05d1			lda		gXX1
.af0f	ed cd 05	sbc $05cd			sbc 	gXX0
.af12	85 36		sta $36				sta 	gxzTemp0
.af14	ad d2 05	lda $05d2			lda 	gXX1+1
.af17	ed ce 05	sbc $05ce			sbc 	gXX0+1
.af1a	85 37		sta $37				sta 	gxzTemp0+1
.af1c	28		plp				plp
.af1d					GXDrawLineTemp0:
.af1d	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.af1f	48		pha				pha
.af20	a5 3d		lda $3d				lda 	gxzScreen+1
.af22	48		pha				pha
.af23	ad df 05	lda $05df			lda 	gsOffset
.af26	48		pha				pha
.af27	a5 0b		lda $0b				lda 	GXEditSlot
.af29	48		pha				pha
.af2a	ac df 05	ldy $05df			ldy 	gsOffset 					; Y offset
.af2d	90 1e		bcc $af4d			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.af2f					_GXDLTLine:
.af2f	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af31	2d dd 05	and $05dd			and 	gxANDValue
.af34	4d dc 05	eor $05dc			eor 	gxEORValue
.af37	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af39	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.af3b	d0 04		bne $af41			bne 	_GXDLTNoBorrow
.af3d	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.af3f	30 2e		bmi $af6f			bmi 	_GXDLTExit
.af41					_GXDLTNoBorrow:
.af41	c6 36		dec $36				dec 	gxzTemp0
.af43	c8		iny				iny 								; next slot.
.af44	d0 e9		bne $af2f			bne 	_GXDLTLine
.af46	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.af48	20 7d af	jsr $af7d			jsr 	GXDLTCheckWrap				; check for new page.
.af4b	80 e2		bra $af2f			bra 	_GXDLTLine
.af4d					_GXDLTEndPoints:
.af4d	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.af4f	2d dd 05	and $05dd			and 	gxANDValue
.af52	4d dc 05	eor $05dc			eor 	gxEORValue
.af55	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af57	98		tya				tya 								; advance to right side
.af58	18		clc				clc
.af59	65 36		adc $36				adc 	gxzTemp0
.af5b	a8		tay				tay
.af5c	a5 3d		lda $3d				lda 	gxzScreen+1
.af5e	65 37		adc $37				adc 	gxzTemp0+1
.af60	85 3d		sta $3d				sta 	gxzScreen+1
.af62	20 7d af	jsr $af7d			jsr 	GXDLTCheckWrap 			; fix up.
.af65	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.af67	2d dd 05	and $05dd			and 	gxANDValue
.af6a	4d dc 05	eor $05dc			eor 	gxEORValue
.af6d	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.af6f					_GXDLTExit:
.af6f	68		pla				pla
.af70	85 0b		sta $0b				sta 	GXEditSlot
.af72	68		pla				pla
.af73	8d df 05	sta $05df			sta 	gsOffset
.af76	68		pla				pla
.af77	85 3d		sta $3d				sta 	gxzScreen+1
.af79	68		pla				pla
.af7a	85 3c		sta $3c				sta 	gxzScreen
.af7c	60		rts				rts
.af7d					GXDLTCheckWrap:
.af7d	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.af7f	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.af81	90 06		bcc $af89			bcc 	_GXDLTCWExit
.af83	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af85	85 3d		sta $3d				sta 	gxzScreen+1
.af87	e6 0b		inc $0b				inc 	GXEditSlot
.af89					_GXDLTCWExit:
.af89	60		rts				rts
.af8a					GXDrawGraphicElement:
.af8a	8d 72 06	sta $0672			sta 	gxSize 						; save size
.af8d	3a		dec a				dec 	a
.af8e	8d 73 06	sta $0673			sta 	gxMask 						; and mask
.af91	ad d6 05	lda $05d6			lda 	gxBitmapsOn 				; check BMP on
.af94	f0 67		beq $affd			beq 	_GXSLFail
.af96	ad cf 05	lda $05cf			lda 	gxY0 						; push Y on stack
.af99	48		pha				pha
.af9a	8c 75 06	sty $0675			sty 	gxAcquireVector+1 			; and acquisition vector
.af9d	8e 74 06	stx $0674			stx 	gxAcquireVector
.afa0	20 34 b2	jsr $b234			jsr 	gxOpenBitmap 				; open the bitmap.
.afa3	ad 77 06	lda $0677			lda 	gxUseMode 					; scale bits
.afa6	4a		lsr a				lsr 	a
.afa7	4a		lsr a				lsr 	a
.afa8	4a		lsr a				lsr 	a
.afa9	29 07		and #$07			and		#7
.afab	1a		inc a				inc 	a
.afac	8d 76 06	sta $0676			sta 	gxScale
.afaf	64 38		stz $38				stz 	gxzTemp1					; start first line
.afb1					_GXGELoop:
.afb1	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.afb3	2c 77 06	bit $0677			bit 	gxUseMode 					; check for flip.
.afb6	10 06		bpl $afbe			bpl		_GXNoVFlip
.afb8	ad 73 06	lda $0673			lda 	gxMask
.afbb	38		sec				sec
.afbc	e5 38		sbc $38				sbc 	gxzTemp1
.afbe					_GXNoVFlip:
.afbe	aa		tax				tax 								; get the Xth line.
.afbf	20 ff af	jsr $afff			jsr 	_GXCallAcquire 				; get that data.
.afc2	ad 76 06	lda $0676			lda 	gxScale 					; do scale identical copies of that line.
.afc5	85 39		sta $39				sta 	gxzTemp1+1
.afc7					_GXGELoop2:
.afc7	ad cf 05	lda $05cf			lda 	gxY0 						; off screen
.afca	cd d9 05	cmp $05d9			cmp 	gxHeight
.afcd	b0 10		bcs $afdf			bcs 	_GXDGEExit
.afcf	20 02 b0	jsr $b002			jsr 	GXRenderOneLine 			; render line
.afd2	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.afd4	d0 f1		bne $afc7			bne 	_GXGELoop2
.afd6	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.afd8	a5 38		lda $38				lda 	gxzTemp1
.afda	cd 72 06	cmp $0672			cmp 	gxSize
.afdd	d0 d2		bne $afb1			bne 	_GXGELoop
.afdf					_GXDGEExit:
.afdf	68		pla				pla 								; restore Y for next time
.afe0	8d cf 05	sta $05cf			sta 	gxY0
.afe3	ae 76 06	ldx $0676			ldx 	gxScale 					; get scale (1-8)
.afe6					_GXShiftLeft:
.afe6	18		clc				clc
.afe7	ad 72 06	lda $0672			lda 	gxSize
.afea	6d cd 05	adc $05cd			adc 	gxX0
.afed	8d cd 05	sta $05cd			sta 	gxX0
.aff0	90 03		bcc $aff5			bcc 	_GXSLNoCarry
.aff2	ee ce 05	inc $05ce			inc 	gxX0+1
.aff5					_GXSLNoCarry:
.aff5	ca		dex				dex
.aff6	d0 ee		bne $afe6			bne 	_GXShiftLeft
.aff8	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap
.affb	18		clc				clc
.affc	60		rts				rts
.affd					_GXSLFail:
.affd	38		sec				sec
.affe	60		rts				rts
.afff					_GXCallAcquire:
.afff	6c 74 06	jmp ($0674)			jmp 	(gxAcquireVector)
.b002					GXRenderOneLine:
.b002	20 44 b2	jsr $b244			jsr 	GXPositionCalc 				; calculate position/offset.
.b005	ac df 05	ldy $05df			ldy 	gsOffset 					; Y contains position.
.b008	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b00a					_GXROLLoop1:
.b00a	ad 76 06	lda $0676			lda 	gxScale 					; set to do 'scale' times
.b00d	85 3b		sta $3b				sta 	gxzTemp2+1
.b00f					_GXROLLoop2:
.b00f	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b011	2c da 05	bit $05da			bit 	gxMode 						; check H Flip
.b014	50 06		bvc $b01c			bvc 	_GXNoHFlip
.b016	ad 73 06	lda $0673			lda 	gxMask
.b019	38		sec				sec
.b01a	e5 3a		sbc $3a				sbc 	gxzTemp2
.b01c					_GXNoHFlip:
.b01c	aa		tax				tax 								; read from the pixel buffer
.b01d	bd 7b 05	lda $057b,x			lda 	gxPixelBuffer,x
.b020	d0 07		bne $b029			bne 	_GXDraw 					; draw if non zero
.b022	ad 77 06	lda $0677			lda 	gxUseMode 					; check to see if solid background
.b025	29 04		and #$04			and 	#4
.b027	f0 0a		beq $b033			beq 	_GXZeroPixel
.b029					_GXDraw:
.b029	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b02b	2d dd 05	and $05dd			and 	gxANDValue
.b02e	5d 7b 05	eor $057b,x			eor 	gxPixelBuffer,x
.b031	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b033					_GXZeroPixel:
.b033	c8		iny				iny 								; advance pointer
.b034	d0 05		bne $b03b			bne 	_GXNoShift
.b036	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b038	20 7d af	jsr $af7d			jsr 	GXDLTCheckWrap				; check for new page.
.b03b					_GXNoShift:
.b03b	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b03d	d0 d0		bne $b00f			bne 	_GXROLLoop2
.b03f	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b041	a5 3a		lda $3a				lda 	gxzTemp2
.b043	cd 72 06	cmp $0672			cmp 	gxSize
.b046	d0 c2		bne $b00a			bne 	_GXROLLoop1
.b048	ee cf 05	inc $05cf			inc 	gxY0
.b04b	60		rts				rts
.0672					gxSize:
>0672							.fill 	1
.0673					gxMask:
>0673							.fill 	1
.0674					gxAcquireVector:
>0674							.fill 	2
.0676					gxScale:
>0676							.fill 	1
.0677					gxUseMode:
>0677							.fill 	1
.b04c					GXFontHandler:
.b04c	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b04e	4d da 05	eor $05da			eor 	gxMode
.b051	8d 77 06	sta $0677			sta 	gxUseMode
.b054	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b056	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b058	26 37		rol $37				rol	 	gxzTemp0+1
.b05a	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b05c	26 37		rol $37				rol	 	gxzTemp0+1
.b05e	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b060	26 37		rol $37				rol	 	gxzTemp0+1
.b062	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b064	09 c0		ora #$c0			ora 	#$C0
.b066	85 37		sta $37				sta 	gxzTemp0+1
.b068	a9 08		lda #$08			lda 	#8 							; size 8x8
.b06a	a2 72		ldx #$72			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b06c	a0 b0		ldy #$b0			ldy 	#GXGetGraphicDataFont >> 8
.b06e	20 8a af	jsr $af8a			jsr 	GXDrawGraphicElement
.b071	60		rts				rts
.b072					GXGetGraphicDataFont:
.b072	8a		txa				txa 								; X->Y
.b073	a8		tay				tay
.b074	a6 01		ldx $01				ldx 	1 							; preserve old value
.b076	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b078	85 01		sta $01				sta 	1
.b07a	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b07c	86 01		stx $01				stx 	1 							; put old value back.
.b07e	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b080					_GXExpand:
.b080	9e 7b 05	stz $057b,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b083	0a		asl a				asl 	a 							; shift bit 7 into C
.b084	90 08		bcc $b08e			bcc 	_GXNoPixel
.b086	48		pha				pha 								; if set, set pixel buffer to current colour.
.b087	ad db 05	lda $05db			lda 	gxColour
.b08a	9d 7b 05	sta $057b,x			sta 	gxPixelBuffer,x
.b08d	68		pla				pla
.b08e					_GXNoPixel:
.b08e	e8		inx				inx 								; do the whole byte.
.b08f	e0 08		cpx #$08			cpx 	#8
.b091	d0 ed		bne $b080			bne 	_GXExpand
.b093	60		rts				rts
.b094					GXSpriteHandler:
.b094	ad d5 05	lda $05d5			lda 	gxSpritesOn 				; sprites on ?
.b097	f0 23		beq $b0bc			beq 	_GXSHExit
.b099	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b09b	4d da 05	eor $05da			eor 	gxMode
.b09e	8d 77 06	sta $0677			sta 	gxUseMode
.b0a1	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b0a3	da		phx				phx
.b0a4	20 34 b2	jsr $b234			jsr 	GXOpenBitmap 				; can access sprite information
.b0a7	68		pla				pla
.b0a8	20 15 b3	jsr $b315			jsr 	GXFindSprite 				; get the sprite address
.b0ab	08		php				php
.b0ac	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap
.b0af	28		plp				plp
.b0b0	b0 0a		bcs $b0bc			bcs		_GXSHExit 					; exit if find failed.
.b0b2	ad 78 06	lda $0678			lda 	GXSizePixels 				; return size
.b0b5	a2 bd		ldx #$bd			ldx 	#GXSpriteAcquire & $FF
.b0b7	a0 b0		ldy #$b0			ldy 	#GXSpriteAcquire >> 8
.b0b9	20 8a af	jsr $af8a			jsr 	GXDrawGraphicElement
.b0bc					_GXSHExit:
.b0bc	60		rts				rts
.b0bd					GXSpriteAcquire:
.b0bd	ad d8 05	lda $05d8			lda 	GXSpritePage				; point to base page
.b0c0	85 0b		sta $0b				sta 	GXEditSlot
.b0c2	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b0c4	a9 00		lda #$00			lda 	#0
.b0c6	ae 79 06	ldx $0679			ldx 	GXSizeBits
.b0c9					_GXTimesRowNumber:
.b0c9	18		clc				clc
.b0ca	65 36		adc $36				adc 	zTemp0
.b0cc	ca		dex				dex
.b0cd	10 fa		bpl $b0c9			bpl 	_GXTimesRowNumber
.b0cf	64 37		stz $37				stz 	gxzTemp0+1
.b0d1	0a		asl a				asl 	a 							; row x 2,4,6,8
.b0d2	26 37		rol $37				rol 	gxzTemp0+1
.b0d4	0a		asl a				asl 	a 							; row x 4,8,12,16
.b0d5	26 37		rol $37				rol 	gxzTemp0+1
.b0d7	0a		asl a				asl 	a 							; row x 8,16,24,32
.b0d8	26 37		rol $37				rol 	gxzTemp0+1
.b0da	85 36		sta $36				sta 	gxzTemp0
.b0dc	18		clc				clc 								; add base address.
.b0dd	a5 36		lda $36				lda 	gxzTemp0
.b0df	6d 7b 06	adc $067b			adc 	GXSpriteOffset
.b0e2	85 36		sta $36				sta 	gxzTemp0
.b0e4	a5 37		lda $37				lda 	gxzTemp0+1
.b0e6	6d 7c 06	adc $067c			adc 	GXSpriteOffset+1
.b0e9					_GXSAFindPage:
.b0e9	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b0eb	90 06		bcc $b0f3			bcc 	_GXSAFoundPage
.b0ed	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b0ef	e6 0b		inc $0b				inc 	GXEditSlot
.b0f1	80 f6		bra $b0e9			bra 	_GXSAFindPage
.b0f3					_GXSAFoundPage:
.b0f3	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b0f5	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b0f7	a0 00		ldy #$00			ldy 	#0
.b0f9					_GXSACopyLoop:
.b0f9	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b0fb	99 7b 05	sta $057b,y			sta 	gxPixelBuffer,y
.b0fe	c8		iny				iny
.b0ff	cc 78 06	cpy $0678			cpy 	GXSizePixels
.b102	d0 f5		bne $b0f9			bne 	_GXSACopyLoop
.b104	60		rts				rts
.b105					GXSelect:
.b105	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b108	f0 22		beq $b12c			beq 	_GXSFail
.b10a	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b10c	c9 40		cmp #$40			cmp 	#64
.b10e	b0 1c		bcs $b12c			bcs 	_GXSFail
.b110	8d e0 05	sta $05e0			sta 	GSCurrentSpriteID
.b113	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b115	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b117	06 36		asl $36				asl 	gxzTemp0
.b119	06 36		asl $36				asl 	gxzTemp0
.b11b	06 36		asl $36				asl 	gxzTemp0
.b11d	2a		rol a				rol 	a
.b11e	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b120	8d e2 05	sta $05e2			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b123	85 37		sta $37				sta 	gxzTemp0+1
.b125	a5 36		lda $36				lda 	gxzTemp0
.b127	8d e1 05	sta $05e1			sta 	GSCurrentSpriteAddr
.b12a	18		clc				clc
.b12b	60		rts				rts
.b12c					_GXSFail:
.b12c	38		sec				sec
.b12d	60		rts				rts
.b12e					GXSelectImage:
.b12e	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b131	f0 74		beq $b1a7			beq 	_GXSIFail
.b133	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b136	f0 6f		beq $b1a7			beq 	_GXSIFail 					; (checking the MSB)
.b138	64 01		stz $01				stz 	1
.b13a	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b13c	d0 6b		bne $b1a9			bne 	_GXSIHide
.b13e	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b140	48		pha				pha
.b141	20 34 b2	jsr $b234			jsr 	GXOpenBitmap
.b144	68		pla				pla
.b145	20 15 b3	jsr $b315			jsr 	GXFindSprite
.b148	b0 5a		bcs $b1a4			bcs 	_GXSICloseFail 				; no image
.b14a	a0 01		ldy #$01			ldy 	#1
.b14c	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b14f	85 36		sta $36				sta 	gxzTemp0
.b151	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b154	85 37		sta $37				sta 	gxzTemp0+1
.b156	ad 7b 06	lda $067b			lda 	GXSpriteOffset
.b159	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b15b	18		clc				clc
.b15c	ad 7c 06	lda $067c			lda 	GXSpriteOffset+1
.b15f	6d e3 05	adc $05e3			adc 	GXSpriteOffsetBase
.b162	c8		iny				iny
.b163	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b165	ad e4 05	lda $05e4			lda 	GXSpriteOffsetBase+1
.b168	69 00		adc #$00			adc 	#0
.b16a	c8		iny				iny
.b16b	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b16d	ad 79 06	lda $0679			lda 	GXSizeBits 					; get raw size
.b170	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b172	2a		rol a				rol 	a 							; x 2
.b173	0a		asl a				asl 	a 							; x 4
.b174	0a		asl a				asl 	a 							; x 8
.b175	0a		asl a				asl 	a 							; x 16
.b176	0d 7a 06	ora $067a			ora 	GXSpriteLUT 				; Or with LUT
.b179	0a		asl a				asl 	a 							; 1 shift
.b17a	09 01		ora #$01			ora 	#1 							; enable sprite.
.b17c	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b17e	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap
.b181	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b184	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b187	29 3f		and #$3f			and 	#$3F
.b189	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b18c	ad 79 06	lda $0679			lda 	GXSizeBits 					; get bit size
.b18f	6a		ror a				ror 	a 							; shift into bits 6/7
.b190	6a		ror a				ror 	a
.b191	6a		ror a				ror 	a
.b192	29 c0		and #$c0			and 	#$C0
.b194	1d 25 06	ora $0625,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b197	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b19a	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b19d	29 7f		and #$7f			and 	#$7F
.b19f	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b1a2	18		clc				clc
.b1a3	60		rts				rts
.b1a4					_GXSICloseFail:
.b1a4	20 3c b2	jsr $b23c			jsr 	GXCloseBitmap
.b1a7					_GXSIFail:
.b1a7	38		sec				sec
.b1a8	60		rts				rts
.b1a9					_GXSIHide:
.b1a9	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b1ac	85 36		sta $36				sta 	gxzTemp0
.b1ae	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1
.b1b1	85 37		sta $37				sta 	gxzTemp0+1
.b1b3	a9 00		lda #$00			lda 	#0
.b1b5	92 36		sta ($36)			sta 	(gxzTemp0)
.b1b7	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get sprite ID
.b1ba	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b1bd	09 80		ora #$80			ora 	#$80
.b1bf	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b1c2	18		clc				clc
.b1c3	60		rts				rts
.b1c4					GXMoveSprite:
.b1c4	ad d5 05	lda $05d5			lda 	gxSpritesOn
.b1c7	f0 65		beq $b22e			beq 	_GXSIFail
.b1c9	ad e2 05	lda $05e2			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b1cc	f0 60		beq $b22e			beq 	_GXSIFail
.b1ce	85 37		sta $37				sta 	gxzTemp0+1
.b1d0	a0 04		ldy #$04			ldy 	#4
.b1d2	ad e1 05	lda $05e1			lda 	GSCurrentSpriteAddr
.b1d5	85 36		sta $36				sta 	gxzTemp0
.b1d7	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b1da	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b1dd	2a		rol a				rol 	a	 						; into bits 0,1.
.b1de	2a		rol a				rol 	a
.b1df	2a		rol a				rol 	a
.b1e0	29 03		and #$03			and 	#3
.b1e2	aa		tax				tax
.b1e3	bd 30 b2	lda $b230,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b1e6	48		pha				pha
.b1e7	18		clc				clc
.b1e8	6d cd 05	adc $05cd			adc 	gxX0						; copy position.
.b1eb	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1ed	c8		iny				iny
.b1ee	ad ce 05	lda $05ce			lda 	gxX0+1
.b1f1	69 00		adc #$00			adc 	#0
.b1f3	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1f5	c8		iny				iny
.b1f6	68		pla				pla
.b1f7	18		clc				clc
.b1f8	6d cf 05	adc $05cf			adc 	gxY0
.b1fb	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b1fd	a9 00		lda #$00			lda 	#0
.b1ff	69 00		adc #$00			adc 	#0
.b201	c8		iny				iny
.b202	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b204	4e ce 05	lsr $05ce			lsr 	gxX0+1 						; divide X by 4
.b207	6e cd 05	ror $05cd			ror 	gxX0
.b20a	4e cd 05	lsr $05cd			lsr 	gxX0
.b20d	4e cf 05	lsr $05cf			lsr 	gxY0 						; divide Y by 4
.b210	4e cf 05	lsr $05cf			lsr 	gxY0
.b213	ae e0 05	ldx $05e0			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b216	bd e5 05	lda $05e5,x			lda 	GXSpriteLow,x
.b219	29 80		and #$80			and 	#$80
.b21b	0d cd 05	ora $05cd			ora 	gxX0
.b21e	9d e5 05	sta $05e5,x			sta 	GXSpriteLow,x
.b221	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b224	29 c0		and #$c0			and 	#$C0
.b226	0d cf 05	ora $05cf			ora 	gxY0
.b229	9d 25 06	sta $0625,x			sta 	GXSpriteHigh,x
.b22c	18		clc				clc
.b22d	60		rts				rts
.b22e					_GXSIFail:
.b22e	38		sec				sec
.b22f	60		rts				rts
.b230					_GXMSOffset:
>b230	1c						.byte 	32-8/2
>b231	18						.byte 	32-16/2
>b232	14						.byte 	32-24/2
>b233	10						.byte 	32-32/2
.b234					GXOpenBitmap:
.b234	78		sei				sei 								; no interrupts here
.b235	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b237	8d de 05	sta $05de			sta 	gxOriginalLUTValue
.b23a	58		cli				cli
.b23b	60		rts				rts
.b23c					GXCloseBitmap:
.b23c	78		sei				sei
.b23d	ad de 05	lda $05de			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b240	85 0b		sta $0b				sta 	GXEditSlot
.b242	58		cli				cli
.b243	60		rts				rts
.b244					GXPositionCalc:
.b244	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b246	48		pha				pha
.b247	ad cf 05	lda $05cf			lda 	GXY0 						; gxzScreen = Y0
.b24a	85 3c		sta $3c				sta 	gxzScreen
.b24c	64 3d		stz $3d				stz 	gxzScreen+1
.b24e	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b250	26 3d		rol $3d				rol 	gxzScreen+1
.b252	06 3c		asl $3c				asl 	gxzScreen
.b254	26 3d		rol $3d				rol 	gxzScreen+1
.b256	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b257	65 3c		adc $3c				adc 	gxzScreen
.b259	85 3c		sta $3c				sta 	gxzScreen
.b25b	90 02		bcc $b25f			bcc 	_GXPCNoCarry
.b25d	e6 3d		inc $3d				inc 	gxzScreen+1
.b25f					_GXPCNoCarry:
.b25f	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b261	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b263	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b265	85 36		sta $36				sta 	gxzTemp0
.b267	64 3d		stz $3d				stz 	gxzScreen+1
.b269	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b26b					_GXPCMultiply32:
.b26b	06 3c		asl $3c				asl 	gxzScreen
.b26d	26 3d		rol $3d				rol 	gxzScreen+1
.b26f	3a		dec a				dec 	a
.b270	d0 f9		bne $b26b			bne 	_GXPCMultiply32
.b272	18		clc				clc
.b273	ad cd 05	lda $05cd			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b276	65 3c		adc $3c				adc 	gxzScreen
.b278	8d df 05	sta $05df			sta 	gsOffset
.b27b	ad ce 05	lda $05ce			lda 	GXX0+1
.b27e	65 3d		adc $3d				adc 	gxzScreen+1
.b280	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b282	90 04		bcc $b288			bcc 	_GXPCNoOverflow
.b284	29 1f		and #$1f			and 	#$1F 						; fix it up
.b286	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b288					_GXPCNoOverflow:
.b288	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b28a	85 3d		sta $3d				sta 	gxzScreen+1
.b28c	64 3c		stz $3c				stz 	gxzScreen
.b28e	18		clc				clc
.b28f	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b291	6d d7 05	adc $05d7			adc 	gxBasePage 					; by adding the base page
.b294	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b296	68		pla				pla
.b297	85 36		sta $36				sta 	gxzTemp0
.b299	60		rts				rts
.b29a					GXMovePositionDown:
.b29a	18		clc				clc 								; add 320 to offset/temp+1
.b29b	ad df 05	lda $05df			lda 	gsOffset
.b29e	69 40		adc #$40			adc 	#64
.b2a0	8d df 05	sta $05df			sta 	gsOffset
.b2a3	a5 3d		lda $3d				lda 	gxzScreen+1
.b2a5	69 01		adc #$01			adc 	#1
.b2a7	85 3d		sta $3d				sta 	gxzScreen+1
.b2a9	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b2ab	90 07		bcc $b2b4			bcc 	_GXMPDExit
.b2ad	38		sec				sec  								; next page
.b2ae	e9 20		sbc #$20			sbc 	#$20
.b2b0	85 3d		sta $3d				sta 	gxzScreen+1
.b2b2	e6 0b		inc $0b				inc 	GXEditSlot
.b2b4					_GXMPDExit:
.b2b4	60		rts				rts
.b2b5					GXCollide:
.b2b5	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b2b7	aa		tax				tax
.b2b8	05 37		ora $37				ora 	gxzTemp0+1
.b2ba	29 c0		and #$c0			and 	#$C0
.b2bc	38		sec				sec
.b2bd	d0 53		bne $b312			bne 	_GXCollideFail 				; if either >= 64, fail.
.b2bf	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b2c1	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b2c4	1d e5 05	ora $05e5,x			ora 	GXSpriteLow,x
.b2c7	30 48		bmi $b311			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b2c9	18		clc				clc 								; need to calculate sum of sizes.
.b2ca	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y
.b2cd	7d 25 06	adc $0625,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b2d0	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b2d2	6a		ror a				ror 	a 							; 5/6/7
.b2d3	4a		lsr a				lsr 	a 							; 4/5/6
.b2d4	4a		lsr a				lsr 	a 							; 3/4/5
.b2d5	4a		lsr a				lsr 	a 							; 2/3/4
.b2d6	18		clc				clc
.b2d7	69 08		adc #$08			adc 	#$08
.b2d9	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b2da	4a		lsr a				lsr 	a
.b2db	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b2dd	b9 25 06	lda $0625,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b2e0	29 3f		and #$3f			and 	#$3F
.b2e2	85 39		sta $39				sta 	gxzTemp1+1
.b2e4	38		sec				sec
.b2e5	bd 25 06	lda $0625,x			lda 	GXSpriteHigh,x
.b2e8	29 3f		and #$3f			and 	#$3F
.b2ea	e5 39		sbc $39				sbc 	gxzTemp1+1
.b2ec	b0 03		bcs $b2f1			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b2ee	49 ff		eor #$ff			eor 	#$FF
.b2f0	1a		inc a				inc 	a
.b2f1					_GXCAbs1:
.b2f1	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b2f3	b0 1c		bcs $b311			bcs 	_GXOkayFail
.b2f5	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b2f7	38		sec				sec 								; calculate |x1-x0|
.b2f8	b9 e5 05	lda $05e5,y			lda 	GXSpriteLow,y
.b2fb	fd e5 05	sbc $05e5,x			sbc 	GXSpriteLow,x
.b2fe	b0 03		bcs $b303			bcs 	_GXCAbs2
.b300	49 ff		eor #$ff			eor 	#$FF
.b302	1a		inc a				inc 	a
.b303					_GXCAbs2:
.b303	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b305	b0 0a		bcs $b311			bcs 	_GXOkayFail
.b307	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b309	90 02		bcc $b30d			bcc 	_GXCHaveLowest
.b30b	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b30d					_GXCHaveLowest:
.b30d	0a		asl a				asl 	a 							; scale to allow for >> 2
.b30e	0a		asl a				asl 	a
.b30f	18		clc				clc
.b310	60		rts				rts
.b311					_GXOkayFail:
.b311	18		clc				clc
.b312					_GXCollideFail:
.b312	a9 ff		lda #$ff			lda 	#$FF
.b314	60		rts				rts
.b315					GXFindSprite:
.b315	aa		tax				tax
.b316	ad d8 05	lda $05d8			lda 	GXSpritePage 				; access the base page of the sprite
.b319	85 0b		sta $0b				sta 	GXEditSlot
.b31b	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b31e	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b321	f0 33		beq $b356			beq 	_GXFSFail
.b323	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b326	8d 7c 06	sta $067c			sta 	GXSpriteOffset+1
.b329	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b32c	48		pha				pha 								; save twice
.b32d	48		pha				pha
.b32e	29 03		and #$03			and 	#3 							; get sprite size
.b330	8d 79 06	sta $0679			sta 	GXSizeBits 					; save raw (0-3)
.b333	aa		tax				tax
.b334	bd 58 b3	lda $b358,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b337	8d 78 06	sta $0678			sta 	GXSizePixels 					; save (8/16/24/32)
.b33a	68		pla				pla 								; get LUT
.b33b	4a		lsr a				lsr		a
.b33c	4a		lsr a				lsr		a
.b33d	29 03		and #$03			and 	#3
.b33f	8d 7a 06	sta $067a			sta 	GXSpriteLUT
.b342	68		pla				pla 								; address, neeeds to be x 4
.b343	29 f0		and #$f0			and 	#$F0
.b345	8d 7b 06	sta $067b			sta 	GXSpriteOffset
.b348	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b34b	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b34e	0e 7b 06	asl $067b			asl 	GXSpriteOffset
.b351	2e 7c 06	rol $067c			rol 	GXSpriteOffset+1
.b354	18		clc				clc
.b355	60		rts				rts
.b356					_GXFSFail:
.b356	38		sec				sec
.b357	60		rts				rts
.b358					_GXFXSSTTable:
>b358	08 10 18 20					.byte 	8,16,24,32
.0678					GXSizePixels:
>0678							.fill 	1
.0679					GXSizeBits:
>0679							.fill 	1
.067a					GXSpriteLUT:
>067a							.fill 	1
.067b					GXSpriteOffset:
>067b							.fill 	2
.b35c					GXSortXY:
.b35c	20 7a b3	jsr $b37a			jsr 	GXSortY 					; will be sorted on Y now
.b35f	ad cd 05	lda $05cd			lda 	gxX0 						; compare X0 v X1
.b362	cd d1 05	cmp $05d1			cmp 	gxX1
.b365	ad ce 05	lda $05ce			lda 	gXX0+1
.b368	ed d2 05	sbc $05d2			sbc 	gXX1+1
.b36b	90 0c		bcc $b379			bcc 	_GXSXYExit 					; X0 < X1 exit
.b36d	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b36f	a0 04		ldy #$04			ldy 	#4
.b371	20 8e b3	jsr $b38e			jsr 	GXSwapXY
.b374	e8		inx				inx
.b375	c8		iny				iny
.b376	20 8e b3	jsr $b38e			jsr 	GXSwapXY
.b379					_GXSXYExit:
.b379	60		rts				rts
.b37a					GXSortY:
.b37a	ad cf 05	lda $05cf			lda 	gxY0 						; if Y0 >= Y1
.b37d	cd d3 05	cmp $05d3			cmp 	gxY1
.b380	90 0b		bcc $b38d			bcc 	_GXSYSorted
.b382	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b384	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b386					_GXSwap1:
.b386	20 8e b3	jsr $b38e			jsr 	GXSwapXY
.b389	88		dey				dey
.b38a	ca		dex				dex
.b38b	10 f9		bpl $b386			bpl 	_GXSwap1
.b38d					_GXSYSorted:
.b38d	60		rts				rts
.b38e					GXSwapXY:
.b38e	bd cd 05	lda $05cd,x			lda 	gxX0,x
.b391	48		pha				pha
.b392	b9 cd 05	lda $05cd,y			lda 	gxX0,y
.b395	9d cd 05	sta $05cd,x			sta 	gxX0,x
.b398	68		pla				pla
.b399	99 cd 05	sta $05cd,y			sta 	gxX0,y
.b39c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b39d					KeywordSet0:
>b39d	00 65					.text	0,$65,""               ; $80 !0:EOF
>b39f	00 58					.text	0,$58,""               ; $81 !1:SH1
>b3a1	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b3a3	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b3a9	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b3b1	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b3b7	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b3be	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>b3c6	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>b3cd	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>b3d4	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>b3da	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>b3e0	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>b3e8	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>b3ef	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>b3f6	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>b3fd	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>b405	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>b40b	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>b411	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>b418	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>b41e	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>b424	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>b42c	47 28
>b42e	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>b436	28
>b437	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>b43f	28
>b440	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>b446	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>b44c	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>b452	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>b459	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>b461	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>b467	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>b46d	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>b472	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>b476	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>b47c	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>b484	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>b48b	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>b492	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>b49a	43
>b49b	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>b4a1	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>b4a7	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>b4ae	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>b4b4	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>b4b8	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>b4be	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>b4c6	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>b4cd	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>b4d2	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>b4d9	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>b4e1	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>b4e7	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>b4ec	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>b4f4	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>b4fa	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>b500	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>b505	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>b50c	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>b512	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>b518	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>b51f	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>b526	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>b52b	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>b531	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>b538	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>b53d	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>b541	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>b549	45
>b54a	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>b552	45
>b553	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>b559	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>b560	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>b566	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>b56c	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>b571	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>b579	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>b580	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>b587	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>b58f	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>b595	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>b599	ff					.text	$FF
.b59a					KeywordSet1:
>b59a	00 65					.text	0,$65,""               ; $80 !0:EOF
>b59c	00 58					.text	0,$58,""               ; $81 !1:SH1
>b59e	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b5a0	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b5a8	4c 45
>b5aa	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b5b2	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b5ba	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b5bf	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>b5c3	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>b5c9	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>b5cf	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>b5d4	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>b5dc	45
>b5dd	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>b5e2	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>b5ea	53
>b5eb	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>b5f1	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $8f WHO
>b5f6	ff					.text	$FF
.b5f7					KeywordSet2:
>b5f7	00 65					.text	0,$65,""               ; $80 !0:EOF
>b5f9	00 58					.text	0,$58,""               ; $81 !1:SH1
>b5fb	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b5fd	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b602	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b607	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b60c	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b611	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b616	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b61b	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b620	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b625	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b62a	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b62f	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b634	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b639	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b63e	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b643	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b648	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b64d	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b652	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b657	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b65c	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b661	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b666	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b66b	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b670	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b675	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b67a	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b67f	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b684	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b689	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b68e	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b693	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b698	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b69d	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b6a2	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b6a7	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b6ac	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b6b1	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b6b6	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b6bb	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b6c0	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b6c5	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b6ca	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b6cf	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b6d4	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b6d9	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b6de	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b6e3	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b6e8	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b6ed	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b6f2	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b6f7	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b6fc	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b701	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b706	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b70b	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b710	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b715	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b71a	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b71f	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b724	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b729	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b72e	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b733	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b738	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b73d	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b742	ff					.text	$FF
.b743					Export_TKListConvertLine:
.b743	48		pha				pha 								; save indent on the stack
.b744	9c 1d 04	stz $041d			stz 	tbOffset
.b747	9c 2d 04	stz $042d			stz 	tokenBuffer
.b74a	9c 29 04	stz $0429			stz 	currentListColour
.b74d	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b74f	20 cc b8	jsr $b8cc			jsr 	LCLWriteColour
.b752	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b754	b1 30		lda ($30),y			lda 	(codePtr),y
.b756	aa		tax				tax
.b757	88		dey				dey
.b758	b1 30		lda ($30),y			lda 	(codePtr),y
.b75a	20 3d b9	jsr $b93d			jsr 	LCLWriteNumberXA
.b75d	68		pla				pla 								; adjustment to indent
.b75e	48		pha				pha 								; save on stack
.b75f	10 0c		bpl $b76d			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b761	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b762	6d 26 04	adc $0426			adc 	listIndent
.b765	8d 26 04	sta $0426			sta 	listIndent
.b768	10 03		bpl $b76d			bpl 	_LCNoAdjust
.b76a	9c 26 04	stz $0426			stz 	listIndent
.b76d					_LCNoAdjust:
.b76d	18		clc				clc		 							; work out actual indent.
.b76e	ad 26 04	lda $0426			lda 	listIndent
.b771	0a		asl a				asl 	a
.b772	69 07		adc #$07			adc 	#7
.b774	85 36		sta $36				sta 	zTemp0
.b776					_LCPadOut:
.b776	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b778	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b77b	ad 1d 04	lda $041d			lda 	tbOffset
.b77e	c5 36		cmp $36				cmp 	zTemp0
.b780	d0 f4		bne $b776			bne 	_LCPadOut
.b782	a0 03		ldy #$03			ldy 	#3 							; start position.
.b784					_LCMainLoop:
.b784	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b786	20 cc b8	jsr $b8cc			jsr 	LCLWriteColour
.b789	b1 30		lda ($30),y			lda 	(codePtr),y
.b78b	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b78d	f0 17		beq $b7a6			beq 	_LCExit
.b78f	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b791	90 1e		bcc $b7b1			bcc 	_LCDoubles
.b793	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b795	90 2a		bcc $b7c1			bcc 	_LCShiftPunc
.b797	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b799	90 35		bcc $b7d0			bcc 	_LCPunctuation
.b79b	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b79d	90 51		bcc $b7f0			bcc 	_LCIdentifiers
.b79f	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b7a1	90 73		bcc $b816			bcc 	_LCTokens
.b7a3	4c 76 b8	jmp $b876			jmp 	_LCData 					; 254-5 are data objects
.b7a6					_LCExit:
.b7a6	68		pla				pla 								; get old indent adjust
.b7a7	30 07		bmi $b7b0			bmi 	_LCExit2
.b7a9	18		clc				clc 								; add to indent if +ve
.b7aa	6d 26 04	adc $0426			adc 	listIndent
.b7ad	8d 26 04	sta $0426			sta 	listIndent
.b7b0					_LCExit2:
.b7b0	60		rts				rts
.b7b1					_LCDoubles:
.b7b1	48		pha				pha
.b7b2	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b7b3	29 02		and #$02			and 	#2
.b7b5	09 3c		ora #$3c			ora 	#60 						; make < >
.b7b7	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b7ba	68		pla				pla 								; restore, do lower bit
.b7bb	29 03		and #$03			and 	#3
.b7bd	09 3c		ora #$3c			ora 	#60
.b7bf	80 0f		bra $b7d0			bra		_LCPunctuation 				; print, increment, loop
.b7c1					_LCShiftPunc:
.b7c1	aa		tax				tax 								; save in X
.b7c2	29 07		and #$07			and 	#7 							; lower 3 bits
.b7c4	f0 02		beq $b7c8			beq 	_LCNoAdd
.b7c6	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b7c8					_LCNoAdd:
.b7c8	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b7ca	90 02		bcc $b7ce			bcc 	_LCNoAdd2
.b7cc	09 20		ora #$20			ora 	#32 						; adds $20
.b7ce					_LCNoAdd2:
.b7ce	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b7d0					_LCPunctuation:
.b7d0	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b7d2	d0 03		bne $b7d7			bne 	_LCPContinue
.b7d4	20 eb b8	jsr $b8eb			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b7d7					_LCPContinue:
.b7d7	c9 2e		cmp #$2e			cmp 	#'.'
.b7d9	f0 08		beq $b7e3			beq 	_LCPIsConstant
.b7db	c9 30		cmp #$30			cmp 	#'0'
.b7dd	90 0b		bcc $b7ea			bcc 	_LCPNotConstant
.b7df	c9 3a		cmp #$3a			cmp 	#'9'+1
.b7e1	b0 07		bcs $b7ea			bcs 	_LCPNotConstant
.b7e3					_LCPIsConstant:
.b7e3	48		pha				pha
.b7e4	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b7e6	20 cc b8	jsr $b8cc			jsr 	LCLWriteColour
.b7e9	68		pla				pla
.b7ea					_LCPNotConstant:
.b7ea	c8		iny				iny 								; consume character
.b7eb	20 d5 b8	jsr $b8d5			jsr 	LCLWrite 					; write it out.
.b7ee	80 94		bra $b784			bra 	_LCMainLoop 				; go round again.
.b7f0					_LCIdentifiers:
.b7f0	18		clc				clc 								; convert to physical address
.b7f1	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b7f3	85 37		sta $37				sta 	zTemp0+1
.b7f5	c8		iny				iny
.b7f6	b1 30		lda ($30),y			lda 	(codePtr),y
.b7f8	85 36		sta $36				sta 	zTemp0
.b7fa	c8		iny				iny
.b7fb	5a		phy				phy 								; save position
.b7fc	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b7fe	20 cc b8	jsr $b8cc			jsr 	LCLWriteColour
.b801	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b803					_LCOutIdentifier:
.b803	c8		iny				iny
.b804	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b806	29 7f		and #$7f			and 	#$7F
.b808	20 27 b9	jsr $b927			jsr 	LCLLowerCase
.b80b	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b80e	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b810	10 f1		bpl $b803			bpl 	_LCOutIdentifier
.b812	7a		ply				ply 								; restore position
.b813	4c 84 b7	jmp $b784			jmp 	_LCMainLoop
.b816					_LCTokens:
.b816	aa		tax				tax 								; token in X
.b817	a9 f7		lda #$f7			lda 	#((KeywordSet2) & $FF)
.b819	85 36		sta $36				sta 	0+zTemp0
.b81b	a9 b5		lda #$b5			lda 	#((KeywordSet2) >> 8)
.b81d	85 37		sta $37				sta 	1+zTemp0
.b81f	e0 82		cpx #$82			cpx 	#$82
.b821	f0 16		beq $b839			beq 	_LCUseShift
.b823	a9 9a		lda #$9a			lda 	#((KeywordSet1) & $FF)
.b825	85 36		sta $36				sta 	0+zTemp0
.b827	a9 b5		lda #$b5			lda 	#((KeywordSet1) >> 8)
.b829	85 37		sta $37				sta 	1+zTemp0
.b82b	e0 81		cpx #$81			cpx 	#$81
.b82d	f0 0a		beq $b839			beq 	_LCUseShift
.b82f	a9 9d		lda #$9d			lda 	#((KeywordSet0) & $FF)
.b831	85 36		sta $36				sta 	0+zTemp0
.b833	a9 b3		lda #$b3			lda 	#((KeywordSet0) >> 8)
.b835	85 37		sta $37				sta 	1+zTemp0
.b837	80 01		bra $b83a			bra 	_LCNoShift
.b839					_LCUseShift:
.b839	c8		iny				iny
.b83a					_LCNoShift:
.b83a	20 ff b8	jsr $b8ff			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b83d	b1 30		lda ($30),y			lda 	(codePtr),y
.b83f	aa		tax				tax 								; into X
.b840					_LCFindText:
.b840	ca		dex				dex
.b841	10 0e		bpl $b851			bpl 	_LCFoundText 				; found text.
.b843	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b845	1a		inc a				inc 	a 							; one extra for size
.b846	38		sec				sec 								; one extra for checksum
.b847	65 36		adc $36				adc 	zTemp0 						; go to next token
.b849	85 36		sta $36				sta 	zTemp0
.b84b	90 f3		bcc $b840			bcc 	_LCFindText
.b84d	e6 37		inc $37				inc 	zTemp0+1
.b84f	80 ef		bra $b840			bra 	_LCFindText
.b851					_LCFoundText:
.b851	5a		phy				phy 								; save List position
.b852	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b854	aa		tax				tax
.b855	a9 83		lda #$83			lda 	#CLIToken+$80
.b857	20 cc b8	jsr $b8cc			jsr 	LCLWriteColour
.b85a	a0 02		ldy #$02			ldy 	#2
.b85c					_LCCopyToken:
.b85c	b1 36		lda ($36),y			lda 	(zTemp0),y
.b85e	20 27 b9	jsr $b927			jsr 	LCLLowerCase
.b861	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b864	c8		iny				iny
.b865	ca		dex				dex
.b866	d0 f4		bne $b85c			bne 	_LCCopyToken
.b868	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b86a	f0 05		beq $b871			beq 	_LCNoSpace
.b86c	a9 20		lda #$20			lda 	#' '
.b86e	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b871					_LCNoSpace:
.b871	7a		ply				ply 								; restore position.
.b872	c8		iny				iny 								; consume token
.b873	4c 84 b7	jmp $b784			jmp 	_LCMainLoop 				; and go around again.
.b876					_LCData:
.b876	48		pha				pha 								; save type $FE/$FF
.b877	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b879	c9 fe		cmp #$fe			cmp 	#$FE
.b87b	f0 22		beq $b89f			beq 	_LCHaveOpener
.b87d	a2 22		ldx #$22			ldx 	#'"'
.b87f	a9 81		lda #$81			lda 	#CLIData+$80
.b881	20 cc b8	jsr $b8cc			jsr 	LCLWriteColour
.b884	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b886	d0 17		bne $b89f			bne 	_LCHaveOpener
.b888	88		dey				dey 								; what precedes it ?
.b889	b1 30		lda ($30),y			lda 	(codePtr),y
.b88b	c8		iny				iny
.b88c	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b88e	d0 0f		bne $b89f			bne 	_LCHaveOpener
.b890	a9 09		lda #$09			lda 	#9 							; tab
.b892	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b895	a9 97		lda #$97			lda 	#$90+CLIBComment
.b897	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b89a	a9 80		lda #$80			lda 	#CLIFComment+$80
.b89c	20 cc b8	jsr $b8cc			jsr 	LCLWriteColour
.b89f					_LCHaveOpener:
.b89f	8a		txa				txa 								; output prefix (# or ")
.b8a0	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b8a3	c8		iny				iny 								; get count
.b8a4	b1 30		lda ($30),y			lda 	(codePtr),y
.b8a6	aa		tax				tax
.b8a7	c8		iny				iny 								; point at first character
.b8a8					_LCOutData:
.b8a8	b1 30		lda ($30),y			lda 	(codePtr),y
.b8aa	c9 00		cmp #$00			cmp 	#0
.b8ac	f0 03		beq $b8b1			beq 	_LCNoPrint
.b8ae	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b8b1					_LCNoPrint:
.b8b1	c8		iny				iny
.b8b2	ca		dex				dex
.b8b3	d0 f3		bne $b8a8			bne 	_LCOutData
.b8b5	68		pla				pla 								; closing " required ?
.b8b6	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b8b8	d0 0f		bne $b8c9			bne 	_LCNoQuote
.b8ba	a9 22		lda #$22			lda 	#'"'
.b8bc	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b8bf	ad c2 05	lda $05c2			lda 	EXTTextColour
.b8c2	29 0f		and #$0f			and 	#$0F
.b8c4	09 90		ora #$90			ora 	#$90
.b8c6	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b8c9					_LCNoQuote:
.b8c9	4c 84 b7	jmp $b784			jmp 	_LCMainLoop
.b8cc					LCLWriteColour:
.b8cc	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.b8cf	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.b8d2	d0 01		bne $b8d5			bne 	LCLWrite 					; if different, output it
.b8d4	60		rts				rts
.b8d5					LCLWrite:
.b8d5	da		phx				phx
.b8d6	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.b8d9	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.b8dc	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.b8df	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.b8e2	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.b8e4	30 03		bmi $b8e9			bmi 	_LCLNoColour
.b8e6	8d 27 04	sta $0427			sta 	LCLastCharacter
.b8e9					_LCLNoColour:
.b8e9	fa		plx				plx
.b8ea	60		rts				rts
.b8eb					LCLDeleteLastSpace:
.b8eb	48		pha				pha
.b8ec	da		phx				phx
.b8ed	ae 1d 04	ldx $041d			ldx 	tbOffset
.b8f0	f0 0a		beq $b8fc			beq 	_LCDLSExit
.b8f2	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.b8f5	c9 20		cmp #$20			cmp 	#' '
.b8f7	d0 03		bne $b8fc			bne 	_LCDLSExit
.b8f9	ce 1d 04	dec $041d			dec 	tbOffset
.b8fc					_LCDLSExit:
.b8fc	fa		plx				plx
.b8fd	68		pla				pla
.b8fe	60		rts				rts
.b8ff					LCLCheckSpaceRequired:
.b8ff	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.b902	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b904	f0 1b		beq $b921			beq 	_LCCSRSpace
.b906	c9 29		cmp #$29			cmp 	#')'
.b908	f0 17		beq $b921			beq 	_LCCSRSpace
.b90a	c9 23		cmp #$23			cmp 	#'#'
.b90c	f0 13		beq $b921			beq 	_LCCSRSpace
.b90e	20 27 b9	jsr $b927			jsr 	LCLLowerCase 				; saves a little effort
.b911	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b913	90 11		bcc $b926			bcc 	_LCCSRExit
.b915	c9 3a		cmp #$3a			cmp 	#"9"+1
.b917	90 08		bcc $b921			bcc 	_LCCSRSpace
.b919	c9 61		cmp #$61			cmp 	#"a"
.b91b	90 09		bcc $b926			bcc 	_LCCSRExit
.b91d	c9 7b		cmp #$7b			cmp 	#"z"+1
.b91f	b0 05		bcs $b926			bcs 	_LCCSRExit
.b921					_LCCSRSpace:
.b921	a9 20		lda #$20			lda 	#' '
.b923	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b926					_LCCSRExit:
.b926	60		rts				rts
.b927					LCLLowerCase:
.b927	c9 41		cmp #$41			cmp 	#"A"
.b929	90 06		bcc $b931			bcc 	_LCLLCOut
.b92b	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b92d	b0 02		bcs $b931			bcs 	_LCLLCOut
.b92f	69 20		adc #$20			adc 	#$20
.b931					_LCLLCOut:
.b931	60		rts				rts
.b932					LCLUpperCase:
.b932	c9 61		cmp #$61			cmp 	#"a"
.b934	90 06		bcc $b93c			bcc 	_LCLUCOut
.b936	c9 7b		cmp #$7b			cmp 	#"z"+1
.b938	b0 02		bcs $b93c			bcs 	_LCLUCOut
.b93a	e9 1f		sbc #$1f			sbc 	#$1F
.b93c					_LCLUCOut:
.b93c	60		rts				rts
.b93d					LCLWriteNumberXA:
.b93d	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.b93f					_LCLWNLoop1:
.b93f	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.b941					_LCLWNLoop2:
.b941	48		pha				pha 								; save initial LSB
.b942	38		sec				sec
.b943	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.b945	f9 76 b9	sbc $b976,y			sbc 	_LCLWNTable,y
.b948	48		pha				pha
.b949	8a		txa				txa
.b94a	f9 77 b9	sbc $b977,y			sbc 	_LCLWNTable+1,y
.b94d	90 07		bcc $b956			bcc 	_LCLWNUnderflow
.b94f	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.b951	aa		tax				tax 								; update X
.b952	68		pla				pla 								; restore A
.b953	7a		ply				ply 								; throw original
.b954	80 eb		bra $b941			bra 	_LCLWNLoop2 				; try again.
.b956					_LCLWNUnderflow:
.b956	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.b958	d0 06		bne $b960			bne 	_LCLWNOut
.b95a	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.b95d	3a		dec a				dec 	a
.b95e	f0 04		beq $b964			beq 	_LCLWNNext
.b960					_LCLWNOut:
.b960	98		tya				tya
.b961	20 70 b9	jsr $b970			jsr 	_LCLWNOutDigit
.b964					_LCLWNNext:
.b964	7a		ply				ply 							 	; restore original value.
.b965	68		pla				pla
.b966	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.b968	c8		iny				iny
.b969	c8		iny				iny
.b96a	84 37		sty $37				sty 	zTemp0+1
.b96c	c0 08		cpy #$08			cpy 	#8 							; done all 4
.b96e	d0 cf		bne $b93f			bne 	_LCLWNLoop1
.b970					_LCLWNOutDigit:
.b970	09 30		ora #$30			ora 	#'0'
.b972	20 d5 b8	jsr $b8d5			jsr 	LCLWrite
.b975	60		rts				rts
.b976					_LCLWNTable:
>b976	10 27						.word 	10000
>b978	e8 03						.word 	1000
>b97a	64 00						.word 	100
>b97c	0a 00						.word 	10
.b97e					TOKSearchTable:
.b97e	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b980	85 36		sta $36				sta 	zTemp0
.b982	a0 00		ldy #$00			ldy 	#0
.b984	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b986	85 38		sta $38				sta 	zTemp1
.b988					_TSTLoop:
.b988	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b98a	30 49		bmi $b9d5			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b98c	f0 2e		beq $b9bc			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b98e	c8		iny				iny 								; get the hash
.b98f	b1 36		lda ($36),y			lda 	(zTemp0),y
.b991	88		dey				dey
.b992	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b995	d0 25		bne $b9bc			bne 	_TSTNext
.b997	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.b99a	38		sec				sec
.b99b	ed 00 04	sbc $0400			sbc 	identStart
.b99e	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b9a0	d0 1a		bne $b9bc			bne 	_TSTNext
.b9a2	5a		phy				phy 								; save Y , we might fail to match.
.b9a3	c8		iny				iny 								; point to text
.b9a4	c8		iny				iny
.b9a5	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.b9a8					_TSTCompareName:
.b9a8	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.b9ab	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b9ad	d0 0c		bne $b9bb			bne 	_TSTNextPullY 				; fail, pullY and do next
.b9af	e8		inx				inx
.b9b0	c8		iny				iny
.b9b1	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.b9b4	d0 f2		bne $b9a8			bne 	_TSTCompareName
.b9b6	7a		ply				ply 								; throw Y
.b9b7	a5 38		lda $38				lda 	zTemp1 						; get token #
.b9b9	38		sec				sec 								; return with CS = passed.
.b9ba	60		rts				rts
.b9bb					_TSTNextPullY:
.b9bb	7a		ply				ply 								; restore current, fall through.
.b9bc					_TSTNext:
.b9bc	e6 38		inc $38				inc 	zTemp1 						; token counter
.b9be	98		tya				tya
.b9bf	18		clc				clc
.b9c0	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b9c2	1a		inc a				inc 	a 							; +1
.b9c3	1a		inc a				inc 	a 							; +2
.b9c4	a8		tay				tay
.b9c5	10 c1		bpl $b988			bpl 	_TSTLoop 					; if Y < $80 loop back
.b9c7	98		tya				tya 								; add Y to zTemp0 and reset Y
.b9c8	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b9ca	18		clc				clc  								; but have tables > 255 bytes
.b9cb	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b9cd	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b9cf	90 b7		bcc $b988			bcc 	_TSTLoop
.b9d1	e6 37		inc $37				inc 	zTemp0+1
.b9d3	80 b3		bra $b988			bra 	_TSTLoop
.b9d5					_TSTFail:
.b9d5	18		clc				clc
.b9d6	60		rts				rts
.b9d7					Export_TKTokeniseLine:
.b9d7	20 5f bb	jsr $bb5f			jsr 	LCLFixLineBufferCase 		; fix line case
.b9da	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b9dc	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b9df	9c 2b 04	stz $042b			stz 	tokenLineNumber
.b9e2	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.b9e5	a2 ff		ldx #$ff			ldx 	#$FF
.b9e7					_TKFindFirst:
.b9e7	e8		inx				inx
.b9e8	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.b9eb	f0 79		beq $ba66			beq 	_TKExit
.b9ed	c9 20		cmp #$20			cmp 	#' '
.b9ef	90 f6		bcc $b9e7			bcc 	_TKFindFirst
.b9f1	c9 30		cmp #$30			cmp 	#'0'
.b9f3	90 07		bcc $b9fc			bcc 	_TKNoLineNumber
.b9f5	c9 3a		cmp #$3a			cmp 	#'9'+1
.b9f7	b0 03		bcs $b9fc			bcs 	_TKNoLineNumber
.b9f9	20 89 bb	jsr $bb89			jsr 	TOKExtractLineNumber
.b9fc					_TKNoLineNumber:
.b9fc					_TKTokeniseLoop:
.b9fc	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b9ff	f0 65		beq $ba66			beq 	_TKExit
.ba01	e8		inx				inx
.ba02	c9 20		cmp #$20			cmp 	#' '
.ba04	f0 f6		beq $b9fc			beq 	_TKTokeniseLoop 			; keep looping if space found.
.ba06	ca		dex				dex 								; undo last get, A contains character, X is position.
.ba07	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.ba09	f0 61		beq $ba6c			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.ba0b	c9 41		cmp #$41			cmp 	#'A'
.ba0d	90 04		bcc $ba13			bcc 	_TKTokenisePunctuation
.ba0f	c9 5b		cmp #$5b			cmp 	#'Z'+1
.ba11	90 59		bcc $ba6c			bcc 	_TKTokeniseIdentifier
.ba13					_TKTokenisePunctuation:
.ba13	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.ba15	f0 27		beq $ba3e			beq 	_TKString
.ba17	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.ba19	f0 28		beq $ba43			beq 	_TKHexConstant
.ba1b	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.ba1d	f0 29		beq $ba48			beq 	_TKCheckDouble
.ba1f	c9 3e		cmp #$3e			cmp 	#'>'
.ba21	f0 25		beq $ba48			beq 	_TKCheckDouble
.ba23					_TKStandardPunctuation:
.ba23	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.ba26	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.ba28	90 0e		bcc $ba38			bcc 	_TKNoShift
.ba2a	48		pha				pha 								; save. we are about to convert this punctuation token from
.ba2b	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.ba2d	85 36		sta $36				sta 	zTemp0
.ba2f	68		pla				pla
.ba30	29 20		and #$20			and 	#32 						; bit 5
.ba32	4a		lsr a				lsr 	a 							; shift into bit 3
.ba33	4a		lsr a				lsr 	a
.ba34	05 36		ora $36				ora 	zTemp0
.ba36	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.ba38					_TKNoShift:
.ba38	20 ce bb	jsr $bbce			jsr 	TOKWriteByte 				; write the punctuation character
.ba3b	e8		inx				inx 								; consume the character
.ba3c	80 be		bra $b9fc			bra 	_TKTokeniseLoop 			; and loop round again.
.ba3e					_TKString:
.ba3e	20 ee ba	jsr $baee			jsr 	TOKTokenString
.ba41	80 b9		bra $b9fc			bra 	_TKTokeniseLoop
.ba43					_TKHexConstant:
.ba43	20 29 bb	jsr $bb29			jsr 	TOKHexConstant
.ba46	80 b4		bra $b9fc			bra 	_TKTokeniseLoop
.ba48					_TKCheckDouble:
.ba48	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.ba4b	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.ba4d	90 d4		bcc $ba23			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.ba4f	c9 3f		cmp #$3f			cmp 	#'>'+1
.ba51	b0 d0		bcs $ba23			bcs 	_TKStandardPunctuation
.ba53	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.ba56	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.ba58	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.ba59	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.ba5c	38		sec				sec
.ba5d	e9 3c		sbc #$3c			sbc 	#'<'
.ba5f	20 ce bb	jsr $bbce			jsr 	TOKWriteByte 				; this is in the range 0-7
.ba62	e8		inx				inx 								; consume both
.ba63	e8		inx				inx
.ba64	80 96		bra $b9fc			bra 	_TKTokeniseLoop
.ba66	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.ba68	20 ce bb	jsr $bbce			jsr 	TOKWriteByte
.ba6b	60		rts				rts
.ba6c					_TKTokeniseIdentifier:
.ba6c	8e 00 04	stx $0400			stx 	identStart 					; save start
.ba6f	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.ba72					_TKCheckLoop:
.ba72	e8		inx				inx 								; look at next, we know first is identifier already.
.ba73	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.ba76	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.ba78	f0 f8		beq $ba72			beq 	_TKCheckLoop
.ba7a	c9 30		cmp #$30			cmp	 	#"0"
.ba7c	90 0c		bcc $ba8a			bcc 	_TKEndIdentifier
.ba7e	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba80	90 f0		bcc $ba72			bcc 	_TKCheckLoop
.ba82	c9 41		cmp #$41			cmp	 	#"A"
.ba84	90 04		bcc $ba8a			bcc 	_TKEndIdentifier
.ba86	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba88	90 e8		bcc $ba72			bcc 	_TKCheckLoop
.ba8a					_TKEndIdentifier:
.ba8a	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.ba8d	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.ba8f	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.ba91	f0 06		beq $ba99			beq 	_TKHasTypeCharacter
.ba93	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.ba95	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.ba97	d0 07		bne $baa0			bne 	_TKNoTypeCharacter
.ba99					_TKHasTypeCharacter:
.ba99	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.ba9c	e8		inx				inx 								; consume the type character
.ba9d	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.baa0					_TKNoTypeCharacter:
.baa0	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.baa2	d0 09		bne $baad			bne 	_TKNoArray
.baa4	e8		inx				inx 								; skip the (
.baa5	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.baa8	09 04		ora #$04			ora 	#$04
.baaa	8d 04 04	sta $0404			sta 	identTypeByte
.baad					_TKNoArray:
.baad	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.bab0	20 4a bb	jsr $bb4a			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.bab3	a0 b3		ldy #$b3			ldy 	#(KeywordSet0) >> 8
.bab5	a9 9d		lda #$9d			lda 	#(KeywordSet0) & $FF
.bab7	20 7e b9	jsr $b97e			jsr 	TOKSearchTable
.baba	a2 00		ldx #$00			ldx 	#0
.babc	b0 1f		bcs $badd			bcs 	_TKFoundToken
.babe	a0 b5		ldy #$b5			ldy 	#(KeywordSet1) >> 8
.bac0	a9 9a		lda #$9a			lda 	#(KeywordSet1) & $FF
.bac2	20 7e b9	jsr $b97e			jsr 	TOKSearchTable
.bac5	a2 81		ldx #$81			ldx 	#$81
.bac7	b0 14		bcs $badd			bcs 	_TKFoundToken
.bac9	a0 b5		ldy #$b5			ldy 	#(KeywordSet2) >> 8
.bacb	a9 f7		lda #$f7			lda 	#(KeywordSet2) & $FF
.bacd	20 7e b9	jsr $b97e			jsr 	TOKSearchTable
.bad0	a2 82		ldx #$82			ldx 	#$82
.bad2	b0 09		bcs $badd			bcs 	_TKFoundToken
.bad4	20 da bb	jsr $bbda			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bad7	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bada	4c fc b9	jmp $b9fc			jmp 	_TKTokeniseLoop 			; and go round again.
.badd					_TKFoundToken:
.badd	48		pha				pha 								; save token
.bade	8a		txa				txa 								; shift in X, is there one ?
.badf	f0 03		beq $bae4			beq 	_TKNoTShift
.bae1	20 ce bb	jsr $bbce			jsr 	TOKWriteByte 				; if so, write it out
.bae4					_TKNoTShift:
.bae4	68		pla				pla 								; restore and write token
.bae5	20 ce bb	jsr $bbce			jsr 	TOKWriteByte
.bae8	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.baeb	4c fc b9	jmp $b9fc			jmp 	_TKTokeniseLoop 			; and go round again.
.baee					TOKTokenString:
.baee	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.baf0	20 ce bb	jsr $bbce			jsr 	TOKWriteByte
.baf3	e8		inx				inx									; start of quoted string.
.baf4	da		phx				phx 								; push start of string on top
.baf5	ca		dex				dex 								; because we pre-increment
.baf6					_TSFindEnd:
.baf6	e8		inx				inx
.baf7	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bafa	f0 04		beq $bb00			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bafc	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bafe	d0 f6		bne $baf6			bne 	_TSFindEnd
.bb00					_TSEndOfString:
.bb00	7a		ply				ply  								; so now Y is first character, X is character after end.
.bb01	48		pha				pha 								; save terminating character
.bb02	20 0a bb	jsr $bb0a			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bb05	68		pla				pla 								; terminating character
.bb06	f0 01		beq $bb09			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bb08	e8		inx				inx
.bb09					_TSNotQuote:
.bb09	60		rts				rts
.bb0a					TOKWriteBlockXY:
.bb0a	86 36		stx $36				stx 	zTemp0 						; save end character
.bb0c	98		tya				tya 								; use 2's complement to work out the byte size
.bb0d	49 ff		eor #$ff			eor 	#$FF
.bb0f	38		sec				sec
.bb10	65 36		adc $36				adc 	zTemp0
.bb12	1a		inc a				inc 	a 							; one extra for NULL
.bb13	20 ce bb	jsr $bbce			jsr 	TOKWriteByte
.bb16					_TOBlockLoop:
.bb16	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bb18	f0 09		beq $bb23			beq 	_TOBlockExit
.bb1a	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bb1d	20 ce bb	jsr $bbce			jsr 	TOKWriteByte
.bb20	c8		iny				iny
.bb21	80 f3		bra $bb16			bra 	_TOBlockLoop
.bb23					_TOBlockExit:
.bb23	a9 00		lda #$00			lda 	#0 							; add NULL.
.bb25	20 ce bb	jsr $bbce			jsr 	TOKWriteByte
.bb28	60		rts				rts
.bb29					TOKHexConstant:
.bb29	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bb2b	20 ce bb	jsr $bbce			jsr 	TOKWriteByte
.bb2e	e8		inx				inx									; start of quoted string.
.bb2f	da		phx				phx 								; push start of constant on top
.bb30	ca		dex				dex
.bb31					_THFindLoop:
.bb31	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bb32	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bb35	c9 30		cmp #$30			cmp 	#"0"
.bb37	90 0c		bcc $bb45			bcc 	_THFoundEnd
.bb39	c9 3a		cmp #$3a			cmp 	#"9"+1
.bb3b	90 f4		bcc $bb31			bcc 	_THFindLoop
.bb3d	c9 41		cmp #$41			cmp 	#"A"
.bb3f	90 04		bcc $bb45			bcc 	_THFoundEnd
.bb41	c9 47		cmp #$47			cmp 	#"F"+1
.bb43	90 ec		bcc $bb31			bcc 	_THFindLoop
.bb45					_THFoundEnd:
.bb45	7a		ply				ply 								; restore start
.bb46	20 0a bb	jsr $bb0a			jsr 	TOKWriteBlockXY 			; output the block
.bb49	60		rts				rts
.bb4a					TOKCalculateHash:
.bb4a	da		phx				phx
.bb4b	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bb4e	a9 00		lda #$00			lda 	#0
.bb50					_TCHLoop:
.bb50	18		clc				clc
.bb51	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bb54	e8		inx				inx
.bb55	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bb58	d0 f6		bne $bb50			bne 	_TCHLoop
.bb5a	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bb5d	fa		plx				plx
.bb5e	60		rts				rts
.bb5f					LCLFixLineBufferCase:
.bb5f	a2 00		ldx #$00			ldx 	#0
.bb61					_FLBCLoop:
.bb61	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bb64	f0 22		beq $bb88			beq 	_FLBCExit 					; end of string.
.bb66	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bb68	f0 11		beq $bb7b			beq 	_FLBCInQuotes
.bb6a	e8		inx				inx
.bb6b	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bb6d	90 f2		bcc $bb61			bcc 	_FLBCLoop
.bb6f	c9 7b		cmp #$7b			cmp 	#'z'+1
.bb71	b0 ee		bcs $bb61			bcs 	_FLBCLoop
.bb73	38		sec				sec 								; make U/C
.bb74	e9 20		sbc #$20			sbc 	#32
.bb76	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bb79	80 e6		bra $bb61			bra 	_FLBCLoop
.bb7b					_FLBCInQuotes:
.bb7b	e8		inx				inx 								; advance
.bb7c	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bb7f	f0 07		beq $bb88			beq 	_FLBCExit 					; exit on EOS
.bb81	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bb83	d0 f6		bne $bb7b			bne 	_FLBCInQuotes
.bb85	e8		inx				inx 								; skip over it
.bb86	80 d9		bra $bb61			bra 	_FLBCLoop
.bb88					_FLBCExit:
.bb88	60		rts				rts
.bb89					TOKExtractLineNumber:
.bb89	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bb8c	48		pha				pha
.bb8d	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bb90	48		pha				pha
.bb91	20 c7 bb	jsr $bbc7			jsr 	_LCLNTimes2 				; line # x 2
.bb94	20 c7 bb	jsr $bbc7			jsr 	_LCLNTimes2 				; line # x 4
.bb97	18		clc				clc 								; add stacked value
.bb98	68		pla				pla
.bb99	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bb9c	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bb9f	68		pla				pla
.bba0	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bba3	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bba6	20 c7 bb	jsr $bbc7			jsr 	_LCLNTimes2 				; line # x 10
.bba9	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bbac	e8		inx				inx
.bbad	29 0f		and #$0f			and 	#15 						; add to line #
.bbaf	18		clc				clc
.bbb0	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bbb3	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bbb6	90 03		bcc $bbbb			bcc 	_TLENNoCarry
.bbb8	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bbbb					_TLENNoCarry:
.bbbb	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bbbe	c9 30		cmp #$30			cmp 	#'0'
.bbc0	90 04		bcc $bbc6			bcc 	_TLENExit
.bbc2	c9 3a		cmp #$3a			cmp 	#'9'+1
.bbc4	90 c3		bcc $bb89			bcc 	TOKExtractLineNumber
.bbc6					_TLENExit:
.bbc6	60		rts				rts
.bbc7					_LCLNTimes2:
.bbc7	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bbca	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bbcd	60		rts				rts
.bbce					TOKWriteByte:
.bbce	da		phx				phx
.bbcf	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bbd2	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bbd5	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bbd8	fa		plx				plx
.bbd9	60		rts				rts
.bbda					TOKCheckCreateVariableRecord:
.bbda	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bbdc	85 36		sta $36				sta 	0+zTemp0
.bbde	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bbe0	85 37		sta $37				sta 	1+zTemp0
.bbe2					_CCVSearch:
.bbe2	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bbe4	f0 2c		beq $bc12			beq 	_CCVFail
.bbe6	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bbe8	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bbea	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bbed	d0 16		bne $bc05			bne 	_CCVNext
.bbef	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bbf1	ae 00 04	ldx $0400			ldx 	identStart
.bbf4					_CCVCompare:
.bbf4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bbf7	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bbf9	e8		inx				inx 								; advance pointers
.bbfa	c8		iny				iny
.bbfb	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bbfc	d0 07		bne $bc05			bne 	_CCVNext  					; didn't match go to next.
.bbfe	90 f4		bcc $bbf4			bcc 	_CCVCompare 				; not finished yet.
.bc00	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bc03	f0 41		beq $bc46			beq 	_CCVFound 					; yes, we were successful
.bc05					_CCVNext:
.bc05	18		clc				clc 								; go to next record.
.bc06	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bc08	65 36		adc $36				adc 	zTemp0
.bc0a	85 36		sta $36				sta 	zTemp0
.bc0c	90 d4		bcc $bbe2			bcc 	_CCVSearch
.bc0e	e6 37		inc $37				inc 	zTemp0+1
.bc10	80 d0		bra $bbe2			bra 	_CCVSearch
.bc12					_CCVFail:
.bc12	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bc14	ad 03 04	lda $0403			lda 	identHash
.bc17	91 36		sta ($36),y			sta 	(zTemp0),y
.bc19	c8		iny				iny 								; offset 2 is the type byte
.bc1a	ad 04 04	lda $0404			lda 	identTypeByte
.bc1d	91 36		sta ($36),y			sta 	(zTemp0),y
.bc1f	c8		iny				iny
.bc20					_CCVData:
.bc20	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bc22	91 36		sta ($36),y			sta 	(zTemp0),y
.bc24	c8		iny				iny
.bc25	c0 08		cpy #$08			cpy 	#8
.bc27	90 f7		bcc $bc20			bcc 	_CCVData
.bc29	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bc2c					_CCVCopyName:
.bc2c	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bc2f	91 36		sta ($36),y			sta 	(zTemp0),y
.bc31	e8		inx				inx
.bc32	c8		iny				iny
.bc33	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bc36	d0 f4		bne $bc2c			bne 	_CCVCopyName
.bc38	98		tya				tya 								; patch offset
.bc39	92 36		sta ($36)			sta 	(zTemp0)
.bc3b	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bc3d	91 36		sta ($36),y			sta 	(zTemp0),y
.bc3f	88		dey				dey
.bc40	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bc42	09 80		ora #$80			ora 	#$80
.bc44	91 36		sta ($36),y			sta 	(zTemp0),y
.bc46					_CCVFound:
.bc46	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bc48	38		sec				sec
.bc49	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bc4b	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bc4d	20 ce bb	jsr $bbce			jsr 	TOKWriteByte
.bc50	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bc52	20 ce bb	jsr $bbce			jsr 	TOKWriteByte
.bc55	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bc56					SNDCheckChannel:
.bc56	aa		tax				tax
.bc57	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bc5a	d0 38		bne $bc94			bne 	_SNDCCExit
.bc5c	da		phx				phx 								; save current channel
.bc5d	8a		txa				txa 								; put in A
.bc5e	20 da bc	jsr $bcda			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bc61	68		pla				pla 								; channel # in A
.bc62	90 30		bcc $bc94			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bc64	a8		tay				tay 								; Y is the channel #
.bc65	bd 80 06	lda $0680,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bc68	99 7f 07	sta $077f,y			sta 	SNDPitchLow,y
.bc6b	bd 81 06	lda $0681,x			lda 	SNDQueue+2,x
.bc6e	99 83 07	sta $0783,y			sta 	SNDPitchHigh,y
.bc71	bd 82 06	lda $0682,x			lda 	SNDQueue+3,x
.bc74	99 87 07	sta $0787,y			sta 	SNDVolume,y
.bc77	bd 83 06	lda $0683,x			lda 	SNDQueue+4,x
.bc7a	99 8b 07	sta $078b,y			sta 	SNDTimeLeft,y
.bc7d	bd 84 06	lda $0684,x			lda 	SNDQueue+5,x
.bc80	99 8f 07	sta $078f,y			sta 	SNDAdjustLow,y
.bc83	bd 85 06	lda $0685,x			lda 	SNDQueue+6,x
.bc86	99 93 07	sta $0793,y			sta 	SNDAdjustHigh,y
.bc89	5a		phy				phy 								; save channel #
.bc8a	20 f4 bc	jsr $bcf4			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bc8d	ce 7e 06	dec $067e			dec 	SNDLength 					; reduce the queue length.
.bc90	68		pla				pla
.bc91	20 95 bc	jsr $bc95			jsr 	SNDUpdateNote 				; update channel A
.bc94					_SNDCCExit:
.bc94	60		rts				rts
.bc95					SNDUpdateNote:
.bc95	aa		tax				tax 								; so we can access records
.bc96	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bc97	0a		asl a				asl 	a
.bc98	0a		asl a				asl 	a
.bc99	0a		asl a				asl 	a
.bc9a	0a		asl a				asl 	a
.bc9b	8d 7d 06	sta $067d			sta 	SNDChannelBits
.bc9e	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; are we silent
.bca1	f0 2e		beq $bcd1			beq 	_SNDUNIsSilent
.bca3	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; push channel bits on stack
.bca6	48		pha				pha
.bca7	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bcaa	29 0f		and #$0f			and 	#$0F
.bcac	0d 7d 06	ora $067d			ora 	SNDChannelBits 				; set channel bits
.bcaf	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bcb1	20 3e bd	jsr $bd3e			jsr 	SNDWritePorts
.bcb4	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bcb7	8d 7d 06	sta $067d			sta 	SNDChannelBits
.bcba	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.bcbd	4e 7d 06	lsr $067d			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.bcc0	6a		ror a				ror 	a
.bcc1	4e 7d 06	lsr $067d			lsr 	SNDChannelBits
.bcc4	6a		ror a				ror 	a
.bcc5	4a		lsr a				lsr 	a 							; put in bits 0-5
.bcc6	4a		lsr a				lsr 	a
.bcc7	20 3e bd	jsr $bd3e			jsr 	SNDWritePorts 				; write as rest of pitch register
.bcca	68		pla				pla
.bccb	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.bccd	20 3e bd	jsr $bd3e			jsr 	SNDWritePorts
.bcd0	60		rts				rts
.bcd1					_SNDUNIsSilent:
.bcd1	ad 7d 06	lda $067d			lda 	SNDChannelBits 				; channel bits
.bcd4	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.bcd6	20 3e bd	jsr $bd3e			jsr 	SNDWritePorts 				; write to the ports
.bcd9	60		rts				rts
.bcda					SNDFindNextNoteForA:
.bcda	ac 7e 06	ldy $067e			ldy 	SNDLength 					; queue size into Y
.bcdd	f0 13		beq $bcf2			beq 	_SNDFNNFail 				; queue empty.
.bcdf	a2 00		ldx #$00			ldx 	#0
.bce1					_SNDFNNSearch:
.bce1	dd 7f 06	cmp $067f,x			cmp 	SNDQueue,x 					; does it match the channel
.bce4	38		sec				sec
.bce5	f0 0c		beq $bcf3			beq 	_SNDFNNExit 				; if so exit with CS.
.bce7	e8		inx				inx 								; next queue slot.
.bce8	e8		inx				inx
.bce9	e8		inx				inx
.bcea	e8		inx				inx
.bceb	e8		inx				inx
.bcec	e8		inx				inx
.bced	e8		inx				inx
.bcee	e8		inx				inx
.bcef	88		dey				dey 								; done the whole queue
.bcf0	d0 ef		bne $bce1			bne 	_SNDFNNSearch 				; no, go back.
.bcf2					_SNDFNNFail:
.bcf2	18		clc				clc
.bcf3					_SNDFNNexit:
.bcf3	60		rts				rts
.bcf4					SNDDeleteXFromQueue:
.bcf4	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.bcf6	f0 09		beq $bd01			beq 	_SNDDXExit
.bcf8	bd 87 06	lda $0687,x			lda 	SNDQueue+8,x
.bcfb	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.bcfe	e8		inx				inx
.bcff	80 f3		bra $bcf4			bra 	SNDDeleteXFromQueue
.bd01					_SNDDXExit:
.bd01	60		rts				rts
.067d					SNDChannelBits:
>067d							.fill 	1
.bd02					SNDQueueRequest:
.bd02	86 36		stx $36				stx 	zTemp0						; save queue address
.bd04	84 37		sty $37				sty 	zTemp0+1
.bd06	ae 7e 06	ldx $067e			ldx 	SNDLength 					; queue is full, can't take any more.
.bd09	e0 20		cpx #$20			cpx 	#SNDQueueSize
.bd0b	f0 21		beq $bd2e			beq 	_SNDQRExit
.bd0d	29 03		and #$03			and 	#3	 						; channel # and push on stack
.bd0f	48		pha				pha
.bd10	8a		txa				txa  								; get offset in queue buffer/
.bd11	0a		asl a				asl 	a
.bd12	0a		asl a				asl 	a
.bd13	0a		asl a				asl 	a
.bd14	aa		tax				tax
.bd15	68		pla				pla 								; get back and push again
.bd16	48		pha				pha
.bd17	9d 7f 06	sta $067f,x			sta 	SNDQueue+0,x 				; save the channel #
.bd1a	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.bd1c					_SNDQCopy:
.bd1c	b1 36		lda ($36),y			lda 	(zTemp0),y
.bd1e	e8		inx				inx
.bd1f	c8		iny				iny
.bd20	9d 7f 06	sta $067f,x			sta 	SNDQueue,x
.bd23	c0 06		cpy #$06			cpy 	#6
.bd25	d0 f5		bne $bd1c			bne 	_SNDQCopy
.bd27	ee 7e 06	inc $067e			inc 	SNDLength 					; bump queue length.
.bd2a	68		pla				pla 								; get channel # back
.bd2b	20 56 bc	jsr $bc56			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.bd2e					_SNDQRExit:
.bd2e	60		rts				rts
.bd2f					SNDSilenceChannel:
.bd2f	aa		tax				tax 								; zero time left.
.bd30	9e 8b 07	stz $078b,x			stz 	SNDTimeLeft,x
.bd33	0a		asl a				asl 	a 							; shift into position
.bd34	0a		asl a				asl 	a
.bd35	0a		asl a				asl 	a
.bd36	0a		asl a				asl 	a
.bd37	0a		asl a				asl 	a
.bd38	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.bd3a	20 3e bd	jsr $bd3e			jsr 	SNDWritePorts
.bd3d	60		rts				rts
.bd3e					SNDWritePorts:
.bd3e	da		phx				phx 								; save X
.bd3f	a6 01		ldx $01				ldx 	1 							; save I/O status
.bd41	64 01		stz $01				stz 	1 							; access I/O page 0
.bd43	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.bd46	8d 10 d6	sta $d610			sta 	$D610
.bd49	86 01		stx $01				stx 	1 							; restore I/O
.bd4b	fa		plx				plx 								; restore X
.bd4c	60		rts				rts
.bd4d					Export_SNDCommand:
.bd4d	da		phx				phx 								; save XY
.bd4e	5a		phy				phy
.bd4f	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.bd51	f0 1d		beq $bd70			beq 	_SNDInitialise
.bd53	90 28		bcc $bd7d			bcc 	_SNDExit
.bd55	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.bd57	f0 17		beq $bd70			beq 	_SNDSilence
.bd59	b0 22		bcs $bd7d			bcs 	_SNDExit
.bd5b	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.bd5d	b0 09		bcs $bd68			bcs 	_SNDQueryPlay
.bd5f	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.bd61	b0 1a		bcs $bd7d			bcs 	_SNDExit
.bd63	20 02 bd	jsr $bd02			jsr 	SNDQueueRequest
.bd66	80 15		bra $bd7d			bra 	_SNDExit
.bd68					_SNDQueryPlay:
.bd68	29 03		and #$03			and 	#3 							; get channel #
.bd6a	aa		tax				tax
.bd6b	bd 8b 07	lda $078b,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.bd6e	80 0d		bra $bd7d			bra 	_SNDExit
.bd70					_SNDInitialise:
.bd70					_SNDSilence:
.bd70	9c 7e 06	stz $067e			stz 	SNDLength 					; empty the queue.
.bd73	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.bd75					_SNDSilenceLoop:
.bd75	48		pha				pha
.bd76	20 2f bd	jsr $bd2f			jsr 	SNDSilenceChannel
.bd79	68		pla				pla
.bd7a	3a		dec a				dec 	a
.bd7b	10 f8		bpl $bd75			bpl 	_SNDSilenceLoop
.bd7d					_SNDExit:
.bd7d	7a		ply				ply
.bd7e	fa		plx				plx
.bd7f	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.067e					SNDLength:
>067e							.fill 	1
.067f					SNDQueue:
>067f							.fill 	SNDQueueSize * 8
.077f					SNDPitchLow:
>077f							.fill 	4
.0783					SNDPitchHigh:
>0783							.fill 	4
.0787					SNDVolume:
>0787							.fill 	4
.078b					SNDTimeLeft:
>078b							.fill 	4
.078f					SNDAdjustLow:
>078f							.fill 	4
.0793					SNDAdjustHigh:
>0793							.fill 	4
.bd80					Export_SNDUpdate:
.bd80					PagedSNDUpdate:
.bd80	ad 8b 07	lda $078b			lda 	SNDTimeLeft+0 				; look at time remaining
.bd83	f0 05		beq $bd8a			beq 	_SNDUNot0 					; not playing
.bd85	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.bd87	20 a9 bd	jsr $bda9			jsr 	SNDUpdateChannel 			; update it.
.bd8a					_SNDUNot0:
.bd8a	ad 8c 07	lda $078c			lda 	SNDTimeLeft+1
.bd8d	f0 05		beq $bd94			beq 	_SNDUNot1
.bd8f	a2 01		ldx #$01			ldx 	#1
.bd91	20 a9 bd	jsr $bda9			jsr 	SNDUpdateChannel
.bd94					_SNDUNot1:
.bd94	ad 8d 07	lda $078d			lda 	SNDTimeLeft+2
.bd97	f0 05		beq $bd9e			beq 	_SNDUNot2
.bd99	a2 02		ldx #$02			ldx 	#2
.bd9b	20 a9 bd	jsr $bda9			jsr 	SNDUpdateChannel
.bd9e					_SNDUNot2:
.bd9e	ad 8e 07	lda $078e			lda 	SNDTimeLeft+3
.bda1	f0 05		beq $bda8			beq 	_SNDUNot3
.bda3	a2 03		ldx #$03			ldx 	#3
.bda5	20 a9 bd	jsr $bda9			jsr 	SNDUpdateChannel
.bda8					_SNDUNot3:
.bda8	60		rts				rts
.bda9					SNDUpdateChannel:
.bda9	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.bdab	f0 2c		beq $bdd9			beq 	_SNDUCExit
.bdad	3a		dec a				dec 	a 							; decrement and update timer
.bdae	9d 8b 07	sta $078b,x			sta 	SNDTimeLeft,x
.bdb1	f0 1d		beq $bdd0			beq 	_SNDUCUpdate 				; if zero, silence channel
.bdb3	bd 8f 07	lda $078f,x			lda 	SNDAdjustLow,x 				; adjust ?
.bdb6	1d 93 07	ora $0793,x			ora 	SNDAdjustHigh,x
.bdb9	f0 1e		beq $bdd9			beq 	_SNDUCExit 					; if zero carry on at current tone.
.bdbb	18		clc				clc 								; add adjust, forcing into a 10 bit range
.bdbc	bd 7f 07	lda $077f,x			lda 	SNDPitchLow,x
.bdbf	7d 8f 07	adc $078f,x			adc 	SNDAdjustLow,x
.bdc2	9d 7f 07	sta $077f,x			sta 	SNDPitchLow,x
.bdc5	bd 83 07	lda $0783,x			lda 	SNDPitchHigh,x
.bdc8	7d 93 07	adc $0793,x			adc 	SNDAdjustHigh,x
.bdcb	29 03		and #$03			and 	#3
.bdcd	9d 83 07	sta $0783,x			sta 	SNDPitchHigh,x
.bdd0					_SNDUCUpdate:
.bdd0	8a		txa				txa 								; which channel.
.bdd1	48		pha				pha
.bdd2	20 95 bc	jsr $bc95			jsr 	SNDUpdateNote 				; update the current note
.bdd5	68		pla				pla
.bdd6	20 56 bc	jsr $bc56			jsr 	SNDCheckChannel 			; more to do ?
.bdd9					_SNDUCExit:
.bdd9	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
