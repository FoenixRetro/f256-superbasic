
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Wed Nov 23 09:29:06 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					isInputFlag:
>04a8							.fill 	1
.04a9					tokenOffset:
>04a9							.fill 	1
.04aa					tokenLineNumber:
>04aa							.fill 	2
.04ac					tokenBuffer:
>04ac							.fill 	253
.05a9					lineBuffer:
>05a9							.fill 	MaxLineSize+1
.05fa					numberBuffer:
>05fa							.fill 	34
.061c					decimalBuffer:
>061c							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 f6 aa	jsr $aaf6			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 4e 8e	jsr $8e4e			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 10 ba	jsr $ba10			jsr 	SNDCommand
.8019	20 46 89	jsr $8946			jsr 	NewProgram 					; erase current program
.801c	20 e6 82	jsr $82e6			jsr 	BackloadProgram
.801f	4c 56 83	jmp $8356			jmp 	WarmStart
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 57 65			.text "Built Wednesday 23-Nov-2022. Build 3574."
>804b	64 6e 65 73 64 61 79 20 32 33 2d 4e 6f 76 2d 32
>805b	30 32 32 2e 20 42 75 69 6c 64 20 33 35 37 34 2e

;******  Return to file: ./common/aa.system/00start.asm

>806b	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806e					AssembleGroup1:
.806e	a9 ff		lda #$ff			lda 	#$FF
.8070	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8073	80 02		bra $8077			bra 	AsmGroup12
.8075					AssembleGroup2:
.8075	a9 00		lda #$00			lda 	#$00
.8077					AsmGroup12:
.8077	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.807a	68		pla				pla 								; pop the return address to access the information following.
.807b	fa		plx				plx
.807c	20 05 81	jsr $8105			jsr 	AccessParameters 			; get opcode and save as base
.807f	8d a4 04	sta $04a4			sta 	BaseOpcode
.8082	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8085	d0 08		bne $808f			bne 	_AG12HaveMask
.8087	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8089	20 0d 81	jsr $810d			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.808c	8d a5 04	sta $04a5			sta 	ModeMask
.808f					_AG12HaveMask:
.808f	20 48 82	jsr $8248			jsr 	TypeAndCalculateOperand 	; get zero page type
.8092	da		phx				phx 								; save found address mode
.8093	20 71 81	jsr $8171			jsr 	AssembleModeX
.8096	fa		plx				plx  								; restore address mode
.8097	b0 0b		bcs $80a4			bcs 	_AG12Exit
.8099	20 a5 80	jsr $80a5			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.809c	20 71 81	jsr $8171			jsr 	AssembleModeX
.809f	b0 03		bcs $80a4			bcs 	_AG12Exit
.80a1	4c 42 a0	jmp $a042			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a4					_AG12Exit:
.80a4	60		rts				rts
.80a5					PromoteToAbsolute:
.80a5	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a7	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a9	f0 19		beq $80c4			beq 	_PTADo
.80ab	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80ad	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80af	f0 13		beq $80c4			beq 	_PTADo
.80b1	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b3	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b5	f0 0d		beq $80c4			beq 	_PTADo
.80b7	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b9	e0 d1		cpx #$d1			cpx 	#AM_IND
.80bb	f0 07		beq $80c4			beq 	_PTADo
.80bd	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bf	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80c1	f0 01		beq $80c4			beq 	_PTADo
.80c3	60		rts				rts
.80c4					_PTADo:
.80c4	aa		tax				tax
.80c5	60		rts				rts
.80c6					AssembleGroup3:
.80c6	68		pla				pla 								; get parameters, which is just the opcode.
.80c7	fa		plx				plx
.80c8	20 05 81	jsr $8105			jsr 	AccessParameters 			; get and output opcode
.80cb	20 1d 81	jsr $811d			jsr 	AssemblerWriteByte
.80ce	20 ac 82	jsr $82ac			jsr 	CalculateOperand 			; get a 16 bit operand
.80d1	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d4	38		sec				sec
.80d5	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d8	48		pha				pha 								; LSB in A
.80d9	ad 10 04	lda $0410			lda 	NSMantissa1
.80dc	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80df	aa		tax				tax 								; MSB in X
.80e0	68		pla				pla
.80e1	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80e2	69 7f		adc #$7f			adc 	#$7F
.80e4	90 01		bcc $80e7			bcc 	_AG3NoCarry
.80e6	e8		inx				inx
.80e7					_AG3NoCarry:
.80e7	38		sec				sec 								; fix back and write out anyways.
.80e8	e9 80		sbc #$80			sbc 	#$80
.80ea	20 1d 81	jsr $811d			jsr 	AssemblerWriteByte
.80ed	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ef	f0 0a		beq $80fb			beq 	_AG3Exit
.80f1	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f4	29 01		and #$01			and 	#1
.80f6	f0 03		beq $80fb			beq 	_AG3Exit
.80f8	4c 47 a0	jmp $a047			jmp 	RangeError 					; no, branch is out of range
.80fb					_AG3Exit:
.80fb	60		rts				rts
.80fc					AssembleGroup4:
.80fc	68		pla				pla 								; pop address
.80fd	fa		plx				plx
.80fe	20 05 81	jsr $8105			jsr 	AccessParameters 			; access and get first
.8101	20 1d 81	jsr $811d			jsr 	AssemblerWriteByte 			; output it.
.8104	60		rts				rts
.8105					AccessParameters:
.8105	8d a1 04	sta $04a1			sta 	ParamStart
.8108	8e a2 04	stx $04a2			stx 	ParamStart+1
.810b	a9 01		lda #$01			lda 	#1
.810d					GetParameter:
.810d	5a		phy				phy
.810e	a8		tay				tay
.810f	ad a1 04	lda $04a1			lda 	ParamStart
.8112	85 36		sta $36				sta 	zTemp0
.8114	ad a2 04	lda $04a2			lda 	ParamStart+1
.8117	85 37		sta $37				sta 	zTemp0+1
.8119	b1 36		lda ($36),y			lda 	(zTemp0),y
.811b	7a		ply				ply
.811c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811d					AssemblerWriteByte:
.811d	48		pha			pha
.811e	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.8121	29 02		and #$02		and 	#2
.8123	f0 1b		beq $8140		beq 	_AWBNoPrint
.8125	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8128	20 5b 81	jsr $815b		jsr 	PrintHex
.812b	ad 9e 04	lda $049e		lda		AssemblerAddress
.812e	20 5b 81	jsr $815b		jsr 	PrintHex
.8131	a9 20		lda #$20		lda 	#' '
.8133	20 82 a8	jsr $a882		jsr 	EXTPrintCharacter
.8136	68		pla			pla 									; print byte
.8137	48		pha			pha
.8138	20 5b 81	jsr $815b		jsr 	PrintHex
.813b	a9 0d		lda #$0d		lda 	#13
.813d	20 82 a8	jsr $a882		jsr 	EXTPrintCharacter
.8140					_AWBNoPrint:
.8140	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8143	85 36		sta $36			sta 	zTemp0
.8145	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8148	f0 0e		beq $8158		beq 	_AWBRange
.814a	85 37		sta $37			sta 	zTemp0+1
.814c	68		pla			pla 									; write byte out
.814d	92 36		sta ($36)		sta 	(zTemp0)
.814f	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.8152	d0 03		bne $8157		bne 	_AWBNoCarry
.8154	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8157					_AWBNoCarry:
.8157	60		rts			rts
.8158					_AWBRange:
.8158	4c 47 a0	jmp $a047		jmp 	RangeError
.815b					PrintHex:
.815b	48		pha				pha
.815c	4a		lsr a				lsr 	a
.815d	4a		lsr a				lsr 	a
.815e	4a		lsr a				lsr 	a
.815f	4a		lsr a				lsr 	a
.8160	20 64 81	jsr $8164			jsr 	_PrintNibble
.8163	68		pla				pla
.8164					_PrintNibble:
.8164	29 0f		and #$0f			and 	#15
.8166	c9 0a		cmp #$0a			cmp 	#10
.8168	90 02		bcc $816c			bcc 	_NoShift
.816a	69 06		adc #$06			adc 	#6
.816c					_NoShift:
.816c	69 30		adc #$30			adc 	#48
.816e	4c 82 a8	jmp $a882			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8171					AssembleModeX:
.8171	5a		phy				phy
.8172	ad a3 04	lda $04a3			lda 	IsGroup1
.8175	f0 17		beq $818e			beq 	_AMXGroup2
.8177	8a		txa				txa 							; is it in group # 1
.8178	29 40		and #$40			and 	#AM_ISG1
.817a	f0 50		beq $81cc			beq 	_AMXFail 				; no, give up.
.817c	8a		txa				txa 							; get back.
.817d	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817f	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8181	d0 22		bne $81a5			bne 	_AMXHaveInfo
.8183	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8186	c9 81		cmp #$81			cmp 	#$81
.8188	f0 42		beq $81cc			beq 	_AMXFail
.818a	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.818c	80 17		bra $81a5			bra 	_AMXHaveInfo 			; odd design decision there.
.818e					_AMXGroup2:
.818e	8a		txa				txa 							; is it in group 2 ?
.818f	29 20		and #$20			and 	#AM_ISG2
.8191	f0 39		beq $81cc			beq 	_AMXFail 				; no, give up.
.8193	8a		txa				txa 							; get the offset into Y
.8194	29 1f		and #$1f			and 	#$1F
.8196	4a		lsr a				lsr 	a 						; make it 0-7.
.8197	4a		lsr a				lsr  	a
.8198	a8		tay				tay
.8199	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.819c					_AMXCheckOkay:
.819c	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819d	88		dey				dey
.819e	10 fc		bpl $819c			bpl 	_AMXCheckOkay
.81a0	90 2a		bcc $81cc			bcc 	_AMXFail 				; not allowed.
.81a2	8a		txa				txa  							; get mask back
.81a3	29 1f		and #$1f			and 	#$1F
.81a5					_AMXHaveInfo:
.81a5	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a7	10 05		bpl $81ae			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a9	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81ac	d0 1e		bne $81cc			bne 	_AMXFail
.81ae					_AMXAnySize:
.81ae	18		clc				clc 							; add offset to the base opcode
.81af	6d a4 04	adc $04a4			adc 	BaseOpcode
.81b2					_AMXOutputCode:
.81b2	20 1d 81	jsr $811d			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b5	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b7	f0 10		beq $81c9			beq 	_AMXExit
.81b9	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81bc	20 1d 81	jsr $811d			jsr 	AssemblerWriteByte
.81bf	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81c1	30 06		bmi $81c9			bmi 	_AMXExit
.81c3	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c6	20 1d 81	jsr $811d			jsr 	AssemblerWriteByte
.81c9					_AMXExit:
.81c9	7a		ply				ply
.81ca	38		sec				sec
.81cb	60		rts				rts
.81cc					_AMXFail:
.81cc	a0 00		ldy #$00			ldy 	#0
.81ce					_AMXCheckOddities:
.81ce	8a		txa				txa
.81cf	d9 f7 81	cmp $81f7,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d2	d0 16		bne $81ea			bne 	_AMXCONext
.81d4	b9 f5 81	lda $81f5,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d7	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81da	d0 0e		bne $81ea			bne 	_AMXCONext
.81dc	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81de	10 05		bpl $81e5			bpl 	_AMXCONotZero
.81e0	ad 10 04	lda $0410			lda 	NSMantissa1
.81e3	d0 05		bne $81ea			bne 	_AMXCONext
.81e5					_AMXCONotZero:
.81e5	b9 f6 81	lda $81f6,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e8	80 c8		bra $81b2			bra 	_AMXOutputCode 			; and assemble it
.81ea					_AMXCONext:
.81ea	c8		iny				iny
.81eb	c8		iny				iny
.81ec	c8		iny				iny
.81ed	b9 f5 81	lda $81f5,y			lda 	ExtraOpcode+0,y 		; end of table
.81f0	d0 dc		bne $81ce			bne 	_AMXCheckOddities
.81f2					_AMXCOFail:
.81f2	7a		ply				ply
.81f3	18		clc				clc
.81f4	60		rts				rts
.81f5					ExtraOpcode:
>81f5	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f8	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81fb	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fe	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>8201	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8204	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8207	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>820a	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820d	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>8210	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8213	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8214					LabelHere:
.8214	c8		iny				iny 								; skip .
.8215	a2 00		ldx #$00			ldx 	#0 							; get a term
.8217	20 7e 98	jsr $987e			jsr 	EvaluateTerm 				; get a term
.821a	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821d	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821f	d0 24		bne $8245			bne 	_ALType
.8221	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8224	85 36		sta $36				sta 	zTemp0
.8226	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8229	85 37		sta $37				sta 	zTemp0+1
.822b	5a		phy				phy 								; copy address in.
.822c	a0 01		ldy #$01			ldy 	#1
.822e	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.8231	92 36		sta ($36)			sta 	(zTemp0)
.8233	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8236	91 36		sta ($36),y			sta 	(zTemp0),y
.8238	c8		iny				iny
.8239	a9 00		lda #$00			lda 	#0
.823b	91 36		sta ($36),y			sta 	(zTemp0),y
.823d	c8		iny				iny
.823e	91 36		sta ($36),y			sta 	(zTemp0),y
.8240	c8		iny				iny
.8241	91 36		sta ($36),y			sta 	(zTemp0),y
.8243	7a		ply				ply
.8244	60		rts				rts
.8245					_ALType:
.8245	4c 4c a0	jmp $a04c			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8248					TypeAndCalculateOperand:
.8248	b1 30		lda ($30),y			lda 	(codePtr),y
.824a	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.824c	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824e	f0 5b		beq $82ab			beq 	_TACOExit
.8250	c9 80		cmp #$80			cmp 	#KWC_EOL
.8252	f0 57		beq $82ab			beq 	_TACOExit
.8254	c8		iny				iny
.8255	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8257	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8259	f0 51		beq $82ac			beq 	CalculateOperand
.825b	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825d	f0 1f		beq $827e			beq 	_TACOIndirect
.825f	88		dey				dey 								; undo get of first character
.8260	20 ac 82	jsr $82ac			jsr 	CalculateOperand 			; get operand
.8263	b1 30		lda ($30),y			lda 	(codePtr),y
.8265	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8267	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8269	d0 40		bne $82ab			bne 	_TACOExit
.826b	c8		iny				iny
.826c	20 b6 82	jsr $82b6			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826f	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.8271	c9 58		cmp #$58			cmp 	#'X'
.8273	f0 36		beq $82ab			beq 	_TACOExit
.8275	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8277	c9 59		cmp #$59			cmp 	#'Y'
.8279	f0 30		beq $82ab			beq 	_TACOExit
.827b					_TACOSyntax:
.827b	4c 42 a0	jmp $a042			jmp 	SyntaxError
.827e					_TACOIndirect:
.827e	20 ac 82	jsr $82ac			jsr 	CalculateOperand 			; get the operand
.8281	b1 30		lda ($30),y			lda 	(codePtr),y
.8283	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8285	f0 17		beq $829e			beq 	_TACOIndX
.8287	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.828a	b1 30		lda ($30),y			lda 	(codePtr),y
.828c	a2 d1		ldx #$d1			ldx 	#AM_IND
.828e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.8290	d0 19		bne $82ab			bne 	_TACOExit
.8292	c8		iny				iny
.8293	20 b6 82	jsr $82b6			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8296	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8298	d0 e1		bne $827b			bne 	_TACOSyntax
.829a	a2 d0		ldx #$d0			ldx 	#AM_INDY
.829c	80 0d		bra $82ab			bra 	_TACOExit
.829e					_TACOIndX:
.829e	c8		iny				iny
.829f	20 b6 82	jsr $82b6			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82a2	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a4	d0 d5		bne $827b			bne 	_TACOSyntax
.82a6	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket			; check )
.82a9	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82ab					_TACOExit:
.82ab	60		rts				rts
.82ac					CalculateOperand:
.82ac	48		pha				pha
.82ad	da		phx				phx
.82ae	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82b0	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger
.82b3	fa		plx				plx
.82b4	68		pla				pla
.82b5	60		rts				rts
.82b6					TACOCheckXY:
.82b6	b1 30		lda ($30),y			lda 	(codePtr),y
.82b8	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82ba	c9 40		cmp #$40			cmp 	#$40
.82bc	d0 21		bne $82df			bne 	_TCXYFail
.82be	b1 30		lda ($30),y			lda 	(codePtr),y
.82c0	18		clc				clc
.82c1	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c3	85 37		sta $37				sta 	zTemp0+1
.82c5	c8		iny				iny
.82c6	b1 30		lda ($30),y			lda 	(codePtr),y
.82c8	c8		iny				iny
.82c9	85 36		sta $36				sta 	zTemp0
.82cb	5a		phy				phy 								; save position
.82cc	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82ce	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d0	d0 0c		bne $82de			bne 	_TCXYPopFail
.82d2	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d4	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d6	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d8	f0 08		beq $82e2			beq 	_TCXYFound
.82da	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82dc	f0 04		beq $82e2			beq 	_TCXYFound
.82de					_TCXYPopFail:
.82de	7a		ply				ply
.82df					_TCXYFail:
.82df	a9 00		lda #$00			lda 	#0
.82e1	60		rts				rts
.82e2					_TCXYFound:
.82e2	7a		ply				ply 								; restore position
.82e3	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e6					BackloadProgram:
.82e6	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e8	8d 2c 06	sta $062c			sta 	0+BackLoadPointer
.82eb	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82ed	8d 2d 06	sta $062d			sta 	1+BackLoadPointer
.82f0					_BPLoop:
.82f0	a2 ff		ldx #$ff			ldx 	#$FF
.82f2	20 1a 83	jsr $831a			jsr 	BLReadByte
.82f5	30 1f		bmi $8316			bmi 	_BPExit
.82f7					_BPCopy:
.82f7	e8		inx				inx  								; copy byte in
.82f8	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.82fb	9e aa 05	stz $05aa,x			stz 	lineBuffer+1,x
.82fe	20 1a 83	jsr $831a			jsr 	BLReadByte 					; read next byte
.8301	30 0a		bmi $830d			bmi 	_BPEndLine 					; -ve = EOL
.8303	c9 09		cmp #$09			cmp 	#9 							; handle TAB
.8305	d0 02		bne $8309			bne 	_BPNotTab
.8307	a9 20		lda #$20			lda 	#' '
.8309					_BPNotTab:
.8309	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.830b	b0 ea		bcs $82f7			bcs 	_BPCopy
.830d					_BPEndLine:
.830d	20 a0 b6	jsr $b6a0			jsr 	TokeniseLine 				; tokenise the line.
.8310	38		sec				sec 								; append not insert
.8311	20 be a5	jsr $a5be			jsr 	MemoryInsertLine 			; append to current program
.8314	80 da		bra $82f0			bra 	_BPLoop
.8316					_BPExit:
.8316	20 ef 83	jsr $83ef			jsr 	ClearCommand 				; clear variables etc.
.8319	60		rts				rts
.831a					BLReadByte:
.831a	ad 2c 06	lda $062c			lda 	BackLoadPointer
.831d	85 36		sta $36				sta 	zTemp0
.831f	ad 2d 06	lda $062d			lda 	BackLoadPointer+1
.8322	85 37		sta $37				sta 	zTemp0+1
.8324	b2 36		lda ($36)			lda 	(zTemp0)
.8326	ee 2c 06	inc $062c			inc 	BackLoadPointer
.8329	d0 03		bne $832e			bne 	_BLNoCarry
.832b	ee 2d 06	inc $062d			inc 	BackLoadPointer+1
.832e					_BLNoCarry:
.832e	c9 00		cmp #$00			cmp 	#0
.8330	60		rts				rts
.062c					BackLoadPointer:
>062c							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8331					EditProgramCode:
.8331	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line.
.8334	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1
.8337	20 66 a6	jsr $a666			jsr 	MemorySearch
.833a	90 05		bcc $8341			bcc 	_EPCNoDelete 				; reached the end don't delete
.833c	d0 03		bne $8341			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.833e	20 87 a5	jsr $a587			jsr 	MemoryDeleteLine 			; delete the line
.8341					_EPCNoDelete:
.8341	ad ac 04	lda $04ac			lda 	TokenBuffer 				; buffer empty
.8344	c9 80		cmp #$80			cmp 	#KWC_EOL
.8346	f0 0d		beq $8355			beq 	_EPCNoInsert
.8348	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line - it cannot exist.
.834b	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.834e	20 66 a6	jsr $a666			jsr 	MemorySearch
.8351	18		clc				clc 								; insert at this point.
.8352	20 be a5	jsr $a5be			jsr 	MemoryInsertLine 			; insert the line
.8355					_EPCNoInsert:
.8355	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.8356					WarmStart:
.8356	a2 ff		ldx #$ff			ldx 	#$FF
.8358	9a		txs				txs
.8359	20 10 aa	jsr $aa10			jsr 	EXTInputLine 				; get line to lineBuffer
.835c	20 a0 b6	jsr $b6a0			jsr 	TokeniseLine 				; tokenise the line
.835f	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; line number ?
.8362	0d ab 04	ora $04ab			ora 	TokenLineNumber+1
.8365	d0 17		bne $837e			bne 	_WSEditCode 				; if so,edit code.
.8367	9c a9 04	stz $04a9			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.836a	a9 a9		lda #$a9			lda 	#((TokenOffset) & $FF)
.836c	85 30		sta $30				sta 	codePtr
.836e	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8370	85 31		sta $31				sta 	codePtr+1
.8372	ad ac 04	lda $04ac			lda 	TokenBuffer 				; nothing to run
.8375	c9 80		cmp #$80			cmp 	#KWC_EOL
.8377	f0 dd		beq $8356			beq 	WarmStart
.8379	20 97 8a	jsr $8a97			jsr 	RUNCodePointerLine 			; execute that line.
.837c	80 d8		bra $8356			bra 	WarmStart
.837e					_WSEditCode:
.837e	20 31 83	jsr $8331			jsr 	EditProgramCode
.8381	20 ef 83	jsr $83ef			jsr 	ClearCommand
.8384	80 d0		bra $8356			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.8386					AssembleCommand:
.8386	a2 00		ldx #$00			ldx 	#0
.8388	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger 		; start address
.838b	ad 08 04	lda $0408			lda 	NSMantissa0
.838e	8d 9e 04	sta $049e			sta 	AssemblerAddress
.8391	ad 10 04	lda $0410			lda 	NSMantissa1
.8394	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.8397	20 e4 8d	jsr $8de4			jsr 	CheckComma
.839a	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; options
.839d	ad 08 04	lda $0408			lda 	NSMantissa0
.83a0	8d a0 04	sta $04a0			sta 	AssemblerControl
.83a3	60		rts				rts
.83a4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83a5					AssertCommand:
.83a5	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83a7	20 04 9e	jsr $9e04			jsr 	EvaluateInteger 			; the assert test
.83aa	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; exit if result is non zero.
.83ad	d0 05		bne $83b4			bne 	_ACExit
.83af	a9 0a		lda #$0a		lda	#10
.83b1	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.83b4					_ACExit:
.83b4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83b5					CallCommand:
.83b5	a2 00		ldx #$00			ldx 	#0
.83b7	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger
.83ba					_CCClear
.83ba	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83bb	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero
.83be	e0 04		cpx #$04			cpx 	#4
.83c0	d0 f8		bne $83ba			bne 	_CCClear
.83c2	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83c4					_CCCParam:
.83c4	b1 30		lda ($30),y			lda 	(codePtr),y
.83c6	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83c8	d0 09		bne $83d3			bne 	_CCCRun6502
.83ca	c8		iny				iny 								; skip comma
.83cb	e8		inx				inx	 								; next level
.83cc	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83cf	e0 03		cpx #$03			cpx 	#3
.83d1	90 f1		bcc $83c4			bcc 	_CCCParam 					; done all 3 ?
.83d3					_CCCRun6502:
.83d3	5a		phy				phy 								; save position
.83d4	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83d7	85 37		sta $37				sta 	zTemp0+1
.83d9	ad 08 04	lda $0408			lda 	NSMantissa0
.83dc	85 36		sta $36				sta 	zTemp0
.83de	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83e1	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83e4	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83e7	20 ec 83	jsr $83ec			jsr 	_CCCZTemp0 					; call zTemp0
.83ea	7a		ply				ply 								; restore position and exit
.83eb	60		rts				rts
.83ec					_CCCZTemp0:
.83ec	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83ef					ClearCommand:
.83ef	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83f1	85 36		sta $36				sta 	0+zTemp0
.83f3	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83f5	85 37		sta $37				sta 	1+zTemp0
.83f7					_ClearZeroLoop:
.83f7	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables
.83f9	f0 24		beq $841f			beq 	_ClearZeroEnd
.83fb	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.83fd	a9 00		lda #$00			lda 	#0
.83ff					_ClearOneVariable:
.83ff	91 36		sta ($36),y			sta 	(zTemp0),y
.8401	c8		iny				iny
.8402	c0 08		cpy #$08			cpy 	#8
.8404	d0 f9		bne $83ff			bne 	_ClearOneVariable
.8406	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8408	b1 36		lda ($36),y			lda 	(zTemp0),y
.840a	c9 18		cmp #$18			cmp 	#NSTProcedure
.840c	d0 04		bne $8412			bne 	_ClearNotProcedure
.840e	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; set it back to an integer array
.8410	91 36		sta ($36),y			sta 	(zTemp0),y
.8412					_ClearNotProcedure:
.8412	18		clc				clc 								; go to the next variable
.8413	b2 36		lda ($36)			lda 	(zTemp0)
.8415	65 36		adc $36				adc 	zTemp0
.8417	85 36		sta $36				sta 	zTemp0
.8419	90 dc		bcc $83f7			bcc 	_ClearZeroLoop
.841b	e6 37		inc $37				inc 	zTemp0+1
.841d	80 d8		bra $83f7			bra 	_ClearZeroLoop
.841f					_ClearZeroEnd:
.841f	18		clc				clc
.8420	a5 36		lda $36				lda 	zTemp0
.8422	69 01		adc #$01			adc 	#1
.8424	8d 8c 04	sta $048c			sta 	lowMemPtr
.8427	a5 37		lda $37				lda 	zTemp0+1
.8429	69 00		adc #$00			adc 	#0
.842b	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.842e	20 a7 a7	jsr $a7a7			jsr 	StackReset
.8431	20 11 a8	jsr $a811			jsr 	StringSystemInitialise
.8434	20 e5 8c	jsr $8ce5			jsr 	ProcedureScan
.8437	20 46 8a	jsr $8a46			jsr 	Command_Restore
.843a	9c 9e 04	stz $049e			stz 	AssemblerAddress
.843d	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.8440	9c a0 04	stz $04a0			stz 	AssemblerControl
.8443	20 81 9a	jsr $9a81			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.8446	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8447					ClearScreen:
.8447	5a		phy				phy
.8448	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.844a	20 82 a8	jsr $a882			jsr 	EXTPrintCharacter
.844d	7a		ply				ply
.844e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.844f					Command_Data:
.844f	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8451	a2 80		ldx #$80			ldx 	#KWC_EOL
.8453	20 37 8d	jsr $8d37			jsr 	ScanForward
.8456	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8457					DimCommand:
.8457	b1 30		lda ($30),y			lda 	(codePtr),y
.8459	29 c0		and #$c0			and 	#$C0
.845b	c9 40		cmp #$40			cmp 	#$40
.845d	d0 7a		bne $84d9			bne 	_DCSyntax
.845f	b1 30		lda ($30),y			lda 	(codePtr),y
.8461	18		clc				clc
.8462	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8464	85 3f		sta $3f				sta 	zaTemp+1
.8466	c8		iny				iny
.8467	b1 30		lda ($30),y			lda 	(codePtr),y
.8469	c8		iny				iny
.846a	85 3e		sta $3e				sta 	zaTemp
.846c	5a		phy				phy
.846d	a0 02		ldy #$02			ldy 	#2 						; read type byte
.846f	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8471	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8473	c9 18		cmp #$18			cmp 	#NSTProcedure
.8475	f0 62		beq $84d9			beq 	_DCSyntax
.8477	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8479	29 04		and #$04			and 	#NSBIsArray
.847b	f0 64		beq $84e1			beq 	_DCType
.847d	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.847f	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8481	d0 59		bne $84dc			bne 	_DCRedefine
.8483	7a		ply				ply
.8484	20 e4 84	jsr $84e4			jsr 	_DCGetSize 				; get array size, check it.
.8487	5a		phy				phy
.8488	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.848a	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.848c	7a		ply				ply 							; is there a second (e.g. ,x)
.848d	b1 30		lda ($30),y			lda 	(codePtr),y
.848f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8491	d0 0a		bne $849d			bne 	_DCOneDimension
.8493	c8		iny				iny 							; skip comma
.8494	20 e4 84	jsr $84e4			jsr 	_DCGetSize 				; get 2nd array size
.8497	5a		phy				phy
.8498	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.849a	91 3e		sta ($3e),y			sta 	(zaTemp),y
.849c	7a		ply				ply
.849d					_DCOneDimension:
.849d	5a		phy				phy 							; save position
.849e	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84a0	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a2	aa		tax				tax
.84a3	c8		iny				iny
.84a4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a6	e8		inx				inx 							; bump them.
.84a7	1a		inc a				inc 	a
.84a8	20 4d 9e	jsr $9e4d			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84ab	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84ad	29 e0		and #$e0			and 	#$E0
.84af	d0 23		bne $84d4			bne 	_DCSize
.84b1	a0 02		ldy #$02			ldy 	#2 						; get base type
.84b3	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b5	20 f2 84	jsr $84f2			jsr 	ScaleByBaseType 		; scale by base type
.84b8	a5 36		lda $36				lda 	zTemp0
.84ba	a6 37		ldx $37				ldx 	zTemp0+1
.84bc	20 43 9a	jsr $9a43			jsr 	AllocateXABytes 		; allocate memory
.84bf	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84c1	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c3	c8		iny				iny
.84c4	8a		txa				txa
.84c5	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c7	7a		ply				ply 							; get position back
.84c8	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket 		; check )
.84cb	b1 30		lda ($30),y			lda 	(codePtr),y
.84cd	c8		iny				iny 							; consume in case
.84ce	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84d0	f0 85		beq $8457			beq 	DimCommand
.84d2	88		dey				dey 							; undo consume
.84d3	60		rts				rts
.84d4					_DCSize:
.84d4	a9 16		lda #$16		lda	#22
.84d6	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.84d9					_DCSyntax:
.84d9	4c 42 a0	jmp $a042			jmp 	SyntaxError
.84dc					_DCRedefine:
.84dc	a9 15		lda #$15		lda	#21
.84de	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.84e1					_DCType:
.84e1	4c 4c a0	jmp $a04c			jmp 	TypeError
.84e4					_DCGetSize:
.84e4	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84e6	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 	; get array dimension
.84e9	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84eb	f0 e7		beq $84d4			beq 	_DCSize
.84ed	c9 fe		cmp #$fe			cmp 	#254
.84ef	f0 e3		beq $84d4			beq 	_DCSize
.84f1	60		rts				rts
.84f2					ScaleByBaseType:
.84f2	29 10		and #$10			and 	#NSBIsString 			; is it string
.84f4	d0 19		bne $850f			bne 	_SBBTString
.84f6	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.84f8	48		pha				pha
.84f9	a5 36		lda $36				lda 	zTemp0
.84fb	48		pha				pha
.84fc	06 36		asl $36				asl 	zTemp0 					; x 2
.84fe	26 37		rol $37				rol 	zTemp0+1
.8500	06 36		asl $36				asl 	zTemp0 					; x 4
.8502	26 37		rol $37				rol 	zTemp0+1
.8504	68		pla				pla 							; add stacked value = x 5
.8505	65 36		adc $36				adc 	zTemp0
.8507	85 36		sta $36				sta 	zTemp0
.8509	68		pla				pla
.850a	65 37		adc $37				adc 	zTemp0+1
.850c	85 37		sta $37				sta 	zTemp0+1
.850e	60		rts				rts
.850f					_SBBTString:
.850f	06 36		asl $36				asl 	zTemp0
.8511	26 37		rol $37				rol 	zTemp0+1
.8513	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8514					EndCommand:
.8514	4c 56 83	jmp $8356			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8517					ForCommand:
.8517	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.8519	20 42 a7	jsr $a742			jsr 	StackOpen
.851c	a2 00		ldx #$00			ldx 	#0
.851e	20 7e 98	jsr $987e			jsr 	EvaluateTerm
.8521	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8524	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8526	d0 49		bne $8571			bne		_FCError
.8528	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.852a	20 ec 8d	jsr $8dec			jsr 	CheckNextA
.852d	e8		inx				inx
.852e	20 04 9e	jsr $9e04			jsr 	EvaluateInteger 			; <from> in +1
.8531	b1 30		lda ($30),y			lda 	(codePtr),y
.8533	c8		iny				iny 								; consume it
.8534	48		pha				pha 								; save on stack for later
.8535	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8537	f0 04		beq $853d			beq 	_FCNoSyntax
.8539	c9 ce		cmp #$ce			cmp 	#KWD_TO
.853b	d0 37		bne $8574			bne 	_FCSyntaxError
.853d					_FCNoSyntax:
.853d	e8		inx				inx
.853e	20 04 9e	jsr $9e04			jsr 	EvaluateInteger
.8541	20 86 a7	jsr $a786			jsr 	STKSaveCodePosition 		; save loop back position
.8544	68		pla				pla 								; restore DOWNTO or TO
.8545	5a		phy				phy 								; save Y on the stack
.8546	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8548	f0 02		beq $854c			beq 	_FCNotDownTo
.854a	a9 02		lda #$02			lda 	#2
.854c					_FCNotDownTo:
.854c	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.854d	a0 10		ldy #$10			ldy 	#16
.854f	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8551	a0 06		ldy #$06			ldy 	#6
.8553	ad 08 04	lda $0408			lda 	NSMantissa0
.8556	91 34		sta ($34),y			sta 	(basicStack),y
.8558	ad 10 04	lda $0410			lda 	NSMantissa1
.855b	c8		iny				iny
.855c	91 34		sta ($34),y			sta 	(basicStack),y
.855e	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8560	a2 01		ldx #$01			ldx 	#1
.8562	20 77 85	jsr $8577			jsr 	FCIntegerToStack
.8565	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8567	a2 02		ldx #$02			ldx 	#2
.8569	20 77 85	jsr $8577			jsr 	FCIntegerToStack
.856c	20 97 85	jsr $8597			jsr 	CopyIndexToReference
.856f	7a		ply				ply 								; restore position
.8570	60		rts				rts
.8571					_FCError:
.8571	4c 4c a0	jmp $a04c			jmp 	TypeError
.8574					_FCSyntaxError:
.8574	4c 42 a0	jmp $a042			jmp 	SyntaxError
.8577					FCIntegerToStack:
.8577	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.857a	10 03		bpl $857f			bpl	 	_FCNotNegative
.857c	20 6d 9e	jsr $9e6d			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.857f					_FCNotNegative:
.857f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8582	91 34		sta ($34),y			sta 	(basicStack),y
.8584	c8		iny				iny
.8585	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8588	91 34		sta ($34),y			sta 	(basicStack),y
.858a	c8		iny				iny
.858b	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.858e	91 34		sta ($34),y			sta 	(basicStack),y
.8590	c8		iny				iny
.8591	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.8594	91 34		sta ($34),y			sta 	(basicStack),y
.8596	60		rts				rts
.8597					CopyIndexToReference:
.8597	5a		phy				phy
.8598	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.859a	38		sec				sec 								; (because we copy from offset 8)
.859b	b1 34		lda ($34),y			lda 	(basicStack),y
.859d	e9 08		sbc #$08			sbc 	#8
.859f	85 36		sta $36				sta 	zTemp0
.85a1	c8		iny				iny
.85a2	b1 34		lda ($34),y			lda 	(basicStack),y
.85a4	e9 00		sbc #$00			sbc 	#0
.85a6	85 37		sta $37				sta 	zTemp0+1
.85a8	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85aa	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85ac	b1 34		lda ($34),y			lda 	(basicStack),y
.85ae	0a		asl a				asl 	a 							; into carry
.85af	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85b1	90 14		bcc $85c7			bcc 	_CITRNormal
.85b3	38		sec				sec
.85b4					_CITRNegative:
.85b4	a9 00		lda #$00			lda 	#0
.85b6	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85b8	91 36		sta ($36),y			sta 	(zTemp0),y
.85ba	c8		iny				iny
.85bb	ca		dex				dex
.85bc	d0 f6		bne $85b4			bne 	_CITRNegative
.85be	88		dey				dey 								; look at MSB of mantissa
.85bf	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85c1	09 80		ora #$80			ora 	#$80
.85c3	91 36		sta ($36),y			sta 	(zTemp0),y
.85c5	7a		ply				ply
.85c6	60		rts				rts
.85c7					_CITRNormal:
.85c7	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85c9	91 36		sta ($36),y			sta 	(zTemp0),y
.85cb	c8		iny				iny
.85cc	ca		dex				dex
.85cd	d0 f8		bne $85c7			bne 	_CITRNormal
.85cf	7a		ply				ply 								; and exit.
.85d0	60		rts				rts
.85d1					NextCommand:
.85d1	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85d3	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85d5	20 6e a7	jsr $a76e			jsr 	StackCheckFrame
.85d8	5a		phy				phy
.85d9	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85db	b1 34		lda ($34),y			lda 	(basicStack),y
.85dd	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85df	30 02		bmi $85e3			bmi 	_NCStepNeg
.85e1	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85e3					_NCStepNeg:
.85e3	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85e5	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85e7	18		clc				clc
.85e8					_NCBump:
.85e8	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85ea	91 34		sta ($34),y			sta 	(basicStack),y
.85ec	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85ee	c8		iny				iny 								; next byte
.85ef	ca		dex				dex 								; do four times
.85f0	d0 f6		bne $85e8			bne 	_NCBump
.85f2	20 97 85	jsr $8597			jsr		CopyIndexToReference		; copy it to the reference variable.
.85f5	a0 10		ldy #$10			ldy 	#16 						; get step count again
.85f7	b1 34		lda ($34),y			lda 	(basicStack),y
.85f9	0a		asl a				asl 	a 							; sign bit to carry
.85fa	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.85fc	85 38		sta $38				sta 	zTemp1
.85fe	90 02		bcc $8602			bcc 	_NCCompRev 					; use if step is +ve
.8600	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8602					_NCCompRev:
.8602	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8604	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8606	85 39		sta $39				sta 	zTemp1+1
.8608	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.860a	38		sec				sec
.860b					_NCCompare:
.860b	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.860d	b1 34		lda ($34),y			lda 	(basicStack),y
.860f	a4 39		ldy $39				ldy 	zTemp1+1
.8611	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8613	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8615	e6 39		inc $39				inc 	zTemp1+1
.8617	ca		dex				dex 								; do it 4 times.
.8618	d0 f1		bne $860b			bne 	_NCCompare
.861a	50 02		bvc $861e			bvc 	_NCNoOverflow 				; convert to signed comparison
.861c	49 80		eor #$80			eor 	#$80
.861e					_NCNoOverflow:
.861e	7a		ply				ply 								; restore Y position
.861f	0a		asl a				asl 	a 							; is bit 7 set.
.8620	90 04		bcc $8626			bcc 	_NCLoopback 				; if no , >= so loop back
.8622	20 60 a7	jsr $a760			jsr 	StackClose 					; exit the loop
.8625	60		rts				rts
.8626					_NCLoopBack:
.8626	20 97 a7	jsr $a797			jsr 	STKLoadCodePosition 		; loop back
.8629	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.862a					Command_GOSUB:
.862a	a2 00		ldx #$00			ldx 	#0
.862c	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.862f	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8631	20 42 a7	jsr $a742			jsr 	StackOpen 					; create frame
.8634	20 86 a7	jsr $a786			jsr 	STKSaveCodePosition 		; save current position
.8637	4c 4d 86	jmp $864d			jmp 	GotoStackX
.863a					Command_RETURN:
.863a	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.863c	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.863e	20 6e a7	jsr $a76e			jsr 	StackCheckFrame
.8641	20 97 a7	jsr $a797			jsr 	STKLoadCodePosition 		; restore code position
.8644	20 60 a7	jsr $a760			jsr 	StackClose
.8647	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8648					GotoCommand:
.8648	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.864a	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger
.864d					GotoStackX:
.864d	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8650	48		pha				pha 								; it is slightly inefficient, just in cases.
.8651	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8654	fa		plx				plx
.8655	20 66 a6	jsr $a666			jsr 	MemorySearch 				; transfer to line number AX.
.8658	90 05		bcc $865f			bcc 	_GotoError 					; not found, off end.
.865a	d0 03		bne $865f			bne 	_GotoError 					; not found exactly
.865c	4c 90 8a	jmp $8a90			jmp 	RunNewLine 					; and go straight to new line code.
.865f					_GotoError:
.865f	a9 0d		lda #$0d		lda	#13
.8661	4c f5 8d	jmp $8df5		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8664					IfCommand:
.8664	a2 00		ldx #$00			ldx 	#0 							; If what.
.8666	20 e1 9d	jsr $9de1			jsr 	EvaluateNumber
.8669	b1 30		lda ($30),y			lda 	(codePtr),y
.866b	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.866d	d0 0a		bne $8679			bne 	_IFStructured
.866f	c8		iny				iny 								; consume THEN
.8670	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; is it zero
.8673	f0 01		beq $8676			beq 	_IfFail 					; if fail, go to next line
.8675	60		rts				rts 								; if THEN just continue
.8676					_IfFail:
.8676	4c 78 8a	jmp $8a78			jmp 	EOLCommand
.8679					_IfStructured:
.8679	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; is it zero
.867c	d0 07		bne $8685			bne 	_IfExit 					; if not, then continue normally.
.867e	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8680	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.8682	20 37 8d	jsr $8d37			jsr 	ScanForward 				; and run from there/
.8685					_IfExit:
.8685	60		rts				rts
.8686					ElseCode:
.8686	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8688	aa		tax				tax 								; so just go to the structure exit
.8689	20 37 8d	jsr $8d37			jsr 	ScanForward
.868c	60		rts				rts
.868d					EndIf:
.868d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.868e					Command_Input:
.868e	a9 ff		lda #$ff			lda 	#$FF
.8690	8d a8 04	sta $04a8			sta 	IsInputFlag
.8693	80 03		bra $8698			bra 	Command_IP_Main
.8695					Command_Print:
.8695	9c a8 04	stz $04a8			stz 	IsInputFlag
.8698					Command_IP_Main:
.8698	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.8699					_CPLoop:
.8699	08		php				php 								; save last action flag
.869a	b1 30		lda ($30),y			lda 	(codePtr),y
.869c	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.869e	f0 58		beq $86f8			beq 	_CPExit
.86a0	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86a2	f0 54		beq $86f8			beq 	_CPExit
.86a4	68		pla				pla 								; throw last action flag
.86a5	b1 30		lda ($30),y			lda 	(codePtr),y
.86a7	c8		iny				iny
.86a8	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86aa	f0 49		beq $86f5			beq 	_CPContinueWithSameLine
.86ac	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86ae	f0 40		beq $86f0			beq 	_CPTab
.86b0	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86b2	f0 38		beq $86ec			beq 	_CPNewLine
.86b4	88		dey				dey 								; undo the get.
.86b5	20 a2 93	jsr $93a2			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86b8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; read the status
.86bb	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86bd	f0 0d		beq $86cc			beq 	_CPIsValue
.86bf	ad a8 04	lda $04a8			lda 	IsInputFlag 				; if print, dereference and print.
.86c2	f0 05		beq $86c9			beq 	_CPIsPrint
.86c4	20 01 87	jsr $8701			jsr 	CIInputValue 				; input a value to the reference
.86c7	80 23		bra $86ec			bra 	_CPNewLine
.86c9					_CPIsPrint:
.86c9	20 c2 96	jsr $96c2			jsr 	Dereference
.86cc					_CPIsValue:
.86cc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.86cf	29 10		and #$10			and 	#NSBIsString
.86d1	f0 0b		beq $86de			beq 	_CPNumber
.86d3	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.86d6	ad 08 04	lda $0408			lda 	NSMantissa0
.86d9	20 6a 87	jsr $876a			jsr 	CPPrintStringXA
.86dc	80 ba		bra $8698			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86de					_CPNumber:
.86de	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86e0	20 ae 9c	jsr $9cae			jsr 	ConvertNumberToString 		; convert to string
.86e3	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.86e5	a9 1c		lda #$1c			lda 	#DecimalBuffer & $FF
.86e7	20 6a 87	jsr $876a			jsr 	CPPrintStringXA
.86ea	80 ac		bra $8698			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86ec					_CPNewLine:
.86ec	a9 0d		lda #$0d			lda 	#13
.86ee	80 02		bra $86f2			bra 	_CPPrintChar
.86f0					_CPTab:
.86f0	a9 09		lda #$09			lda 	#9 							; print TAB
.86f2					_CPPrintChar:
.86f2	20 7d 87	jsr $877d			jsr 	CPPrintVector
.86f5					_CPContinueWithSameLine:
.86f5	38		sec				sec 								; loop round with carry set, which
.86f6	80 a1		bra $8699			bra 	_CPLoop 					; will inhibit final CR
.86f8					_CPExit:
.86f8	28		plp				plp 								; get last action flag
.86f9	b0 05		bcs $8700			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.86fb	a9 0d		lda #$0d			lda 	#13 						; print new line
.86fd	20 7d 87	jsr $877d			jsr 	CPPrintVector
.8700					_CPExit2:
.8700	60		rts				rts
.8701					CIInputValue:
.8701	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8703					_CIInputLine:
.8703	20 80 87	jsr $8780			jsr 	CPInputVector 				; get key
.8706	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8708	f0 1f		beq $8729			beq 	_CIHaveValue
.870a	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.870c	f0 11		beq $871f			beq 	_CIBackspace
.870e	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8710	90 f1		bcc $8703			bcc 	_CIInputLine
.8712	e0 50		cpx #$50			cpx 	#80 						; max length
.8714	b0 ed		bcs $8703			bcs 	_CIInputLine
.8716	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.8719	e8		inx				inx
.871a	20 7d 87	jsr $877d			jsr 	CPPrintVector 				; echo it.
.871d	80 e4		bra $8703			bra 	_CIInputLine
.871f					_CIBackSpace:
.871f	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8721	f0 e0		beq $8703			beq 	_CIInputLine
.8723	20 7d 87	jsr $877d			jsr 	CPPrintVector 				; echo it.
.8726	ca		dex				dex
.8727	80 da		bra $8703			bra 	_CIInputLine
.8729					_CIHaveValue:
.8729	9e a9 05	stz $05a9,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.872c	ad 00 04	lda $0400			lda 	NSStatus 					; was it a string assignment
.872f	29 10		and #$10			and 	#NSBIsString
.8731	f0 1c		beq $874f			beq 	_CIAssignNumber 			; assign a number
.8733	a2 01		ldx #$01			ldx 	#1
.8735	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.8737	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.873a	a9 05		lda #$05			lda 	#lineBuffer >> 8
.873c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.873f	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.8742	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.8745	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8747	9d 00 04	sta $0400,x			sta  	NSStatus,x
.874a	ca		dex				dex 								; X = 0
.874b	20 bf 87	jsr $87bf			jsr 	AssignVariable
.874e	60		rts				rts
.874f					_CIAssignNumber:
.874f	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.8751	85 36		sta $36				sta 	zTemp0
.8753	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8755	85 37		sta $37				sta 	zTemp0+1
.8757	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8759	20 30 9c	jsr $9c30			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.875c	90 07		bcc $8765			bcc 	_CIIsOkay
.875e	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8760	20 7d 87	jsr $877d			jsr 	CPPrintVector
.8763	80 9c		bra $8701			bra 	CIInputValue
.8765					_CIIsOkay:
.8765	ca		dex				dex 								; X = 0
.8766	20 bf 87	jsr $87bf			jsr 	AssignVariable
.8769	60		rts				rts
.876a					CPPrintStringXA:
.876a	5a		phy				phy
.876b	86 37		stx $37				stx 	zTemp0+1
.876d	85 36		sta $36				sta 	zTemp0
.876f	a0 00		ldy #$00			ldy 	#0
.8771					_PSXALoop:
.8771	b1 36		lda ($36),y			lda 	(zTemp0),y
.8773	f0 06		beq $877b			beq 	_PSXAExit
.8775	20 7d 87	jsr $877d			jsr 	CPPrintVector
.8778	c8		iny				iny
.8779	80 f6		bra $8771			bra 	_PSXALoop
.877b					_PSXAExit:
.877b	7a		ply				ply
.877c	60		rts				rts
.877d					CPPrintVector:
.877d	4c 82 a8	jmp $a882			jmp 	EXTPrintCharacter
.8780					CPInputVector:
.8780	4c 18 ab	jmp $ab18			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8783					LetCommand:
.8783	a2 00		ldx #$00			ldx 	#0
.8785	b1 30		lda ($30),y			lda 	(codePtr),y
.8787	c9 10		cmp #$10			cmp 	#KWD_AT
.8789	d0 16		bne $87a1			bne 	_LCStandard
.878b	c8		iny				iny 								; skip equal
.878c	20 7e 98	jsr $987e			jsr 	EvaluateTerm 				; get a number
.878f	20 c2 96	jsr $96c2			jsr 	Dereference 				; dereference it
.8792	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.8795	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8797	9d 00 04	sta $0400,x			sta 	NSStatus,x
.879a	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.879c	d0 10		bne $87ae			bne 	_LCMain
.879e	4c 4c a0	jmp $a04c			jmp 	TypeError 					; was a reference before.
.87a1					_LCStandard:
.87a1	ad 8c 93	lda $938c			lda 	PrecedenceLevel+"*"			; precedence > this
.87a4	20 a6 93	jsr $93a6			jsr 	EvaluateExpressionAtPrecedence
.87a7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.87aa	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87ac	f0 0e		beq $87bc			beq 	_LetGoProc 					; it's a procedure call.
.87ae					_LCMain:
.87ae	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87b0	20 ec 8d	jsr $8dec			jsr 	CheckNextA
.87b3	e8		inx				inx 								; RHS
.87b4	20 d8 9d	jsr $9dd8			jsr 	EvaluateValue
.87b7	ca		dex				dex
.87b8	20 bf 87	jsr $87bf			jsr 	AssignVariable
.87bb	60		rts				rts
.87bc					_LetGoProc:
.87bc	4c 50 89	jmp $8950			jmp 	CallProcedure
.87bf					AssignVariable:
.87bf	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.87c2	48		pha				pha 								; save a copy
.87c3	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.87c6	29 10		and #$10			and 	#NSBIsString
.87c8	d0 0b		bne $87d5			bne 	_ASError
.87ca	68		pla				pla 								; get back
.87cb	29 10		and #$10			and 	#NSBIsString 				; check type
.87cd	d0 03		bne $87d2			bne 	_ASString
.87cf	4c ea 95	jmp $95ea			jmp 	AssignNumber
.87d2					_ASString:
.87d2	4c 58 96	jmp $9658			jmp 	AssignString
.87d5					_ASError:
.87d5	4c 4c a0	jmp $a04c			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87d8					Command_List:
.87d8	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.87db	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87de	9c 14 04	stz $0414			stz 	NSMantissa1+4
.87e1	a9 ff		lda #$ff			lda 	#$FF
.87e3	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.87e6	8d 17 04	sta $0417			sta 	NSMantissa1+7
.87e9	b1 30		lda ($30),y			lda 	(codePtr),y
.87eb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87ed	f0 1e		beq $880d			beq 	_CLSecond
.87ef	20 6e 88	jsr $886e			jsr 	CLIsDigit 					; if not digit, list all
.87f2	b0 24		bcs $8818			bcs 	_CLStart
.87f4	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.87f6	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger
.87f9	b1 30		lda ($30),y			lda 	(codePtr),y
.87fb	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87fd	f0 0e		beq $880d			beq 	_CLSecond 					; if so go get it
.87ff	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.8802	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.8805	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8808	8d 17 04	sta $0417			sta 	NSMantissa1+7
.880b	80 0b		bra $8818			bra 	_CLStart
.880d					_CLSecond:
.880d	c8		iny				iny 								; consume comma
.880e	20 6e 88	jsr $886e			jsr 	CLIsDigit 					; digit found
.8811	b0 05		bcs $8818			bcs 	_CLStart 					; if not, continue listing
.8813	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8815	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger
.8818					_CLStart
.8818	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.881a	85 30		sta $30				sta 	codePtr
.881c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.881e	85 31		sta $31				sta 	codePtr+1
.8820					_CLLoop:
.8820	20 38 ab	jsr $ab38			jsr 	EXTBreakCheck 				; break check
.8823	f0 33		beq $8858			beq 	_CLExit
.8825	b2 30		lda ($30)			lda 	(codePtr)
.8827	f0 2f		beq $8858			beq 	_CLExit
.8829	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.882b	20 5b 88	jsr $885b			jsr 	CLCompareLineNo
.882e	90 1b		bcc $884b			bcc 	_CLNext
.8830	a2 07		ldx #$07			ldx 	#7
.8832	20 5b 88	jsr $885b			jsr 	CLCompareLineNo
.8835	f0 02		beq $8839			beq 	_CLDoThisOne
.8837	b0 12		bcs $884b			bcs 	_CLNext
.8839					_CLDoThisOne:
.8839	20 9a 8d	jsr $8d9a			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.883c	20 82 b4	jsr $b482			jsr 	ListConvertLine 			; convert line into token Buffer
.883f	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8841	a9 ac		lda #$ac			lda 	#(tokenBuffer & $FF)
.8843	20 4e 8e	jsr $8e4e			jsr 	PrintStringXA
.8846	a9 0d		lda #$0d			lda 	#13 						; new line
.8848	20 82 a8	jsr $a882			jsr 	EXTPrintCharacter
.884b					_CLNext:
.884b	18		clc				clc
.884c	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.884e	65 30		adc $30				adc 	codePtr
.8850	85 30		sta $30				sta 	codePtr
.8852	90 02		bcc $8856			bcc 	_CREExit
.8854	e6 31		inc $31				inc 	codePtr+1
.8856					_CREExit:
.8856	80 c8		bra $8820			bra 	_CLLoop
.8858					_CLExit:
.8858	4c 56 83	jmp $8356			jmp 	WarmStart
.885b					CLCompareLineNo:
.885b	38		sec				sec
.885c	a0 01		ldy #$01			ldy 	#1
.885e	b1 30		lda ($30),y			lda 	(codePtr),y
.8860	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.8863	85 36		sta $36				sta 	zTemp0
.8865	c8		iny				iny
.8866	b1 30		lda ($30),y			lda 	(codePtr),y
.8868	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.886b	05 36		ora $36				ora 	zTemp0
.886d	60		rts				rts
.886e					CLIsDigit:
.886e	b1 30		lda ($30),y			lda 	(codePtr),y
.8870	c9 30		cmp #$30			cmp 	#"0"
.8872	90 03		bcc $8877			bcc	 	_CLIDExitFalse
.8874	c9 3a		cmp #$3a			cmp 	#"9"+1
.8876	60		rts				rts
.8877					_CLIDExitFalse:
.8877	38		sec				sec
.8878	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8879					Command_LOCAL:
.8879	a2 00		ldx #$00			ldx 	#0 							; at level 0
.887b	20 87 88	jsr $8887			jsr 	LocaliseNextTerm 			; convert term to a local.
.887e	b1 30		lda ($30),y			lda 	(codePtr),y
.8880	c8		iny				iny
.8881	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8883	f0 f4		beq $8879			beq 	Command_LOCAL
.8885	88		dey				dey 								; unpick pre-get
.8886	60		rts				rts
.8887					LocaliseNextTerm:
.8887	20 7e 98	jsr $987e			jsr 	EvaluateTerm 				; evaluate the term
.888a	bd 00 04	lda $0400,x			lda 	NSStatus,x
.888d	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.888f	f0 61		beq $88f2			beq		_LNTError
.8891	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8894	85 36		sta $36				sta 	zTemp0
.8896	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8899	85 37		sta $37				sta  	zTemp0+1
.889b	bd 00 04	lda $0400,x			lda 	NSStatus,x
.889e	29 10		and #$10			and 	#NSBIsString
.88a0	d0 1e		bne $88c0			bne 	_LNTPushString
.88a2	5a		phy				phy
.88a3	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.88a5					_LNTPushNumLoop:
.88a5	b1 36		lda ($36),y			lda		(zTemp0),y
.88a7	20 20 a7	jsr $a720			jsr 	StackPushByte
.88aa	c8		iny				iny
.88ab	c0 05		cpy #$05			cpy 	#5
.88ad	d0 f6		bne $88a5			bne 	_LNTPushNumLoop
.88af	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.88b1	20 20 a7	jsr $a720			jsr 	StackPushByte
.88b4	a5 37		lda $37				lda 	zTemp0+1
.88b6	20 20 a7	jsr $a720			jsr 	StackPushByte
.88b9	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88bb	20 20 a7	jsr $a720			jsr 	StackPushByte
.88be	7a		ply				ply
.88bf	60		rts				rts
.88c0					_LNTPushString:
.88c0	5a		phy				phy
.88c1	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88c3	85 38		sta $38				sta 	zTemp1
.88c5	a0 01		ldy #$01			ldy 	#1
.88c7	b1 36		lda ($36),y			lda 	(zTemp0),y
.88c9	85 39		sta $39				sta 	zTemp1+1
.88cb	a0 00		ldy #$00			ldy 	#0 							; output string
.88cd	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88cf	f0 0a		beq $88db			beq 	_LNTStringOut
.88d1					_LNTPushStrLoop:
.88d1	b1 38		lda ($38),y			lda 	(zTemp1),y
.88d3	f0 06		beq $88db			beq 	_LNTStringOut
.88d5	20 20 a7	jsr $a720			jsr 	StackPushByte
.88d8	c8		iny				iny
.88d9	80 f6		bra $88d1			bra 	_LNTPushStrLoop
.88db					_LNTStringOut:
.88db	98		tya				tya									; output length
.88dc	20 20 a7	jsr $a720			jsr 	StackPushByte
.88df	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.88e2	20 20 a7	jsr $a720			jsr 	StackPushByte
.88e5	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.88e8	20 20 a7	jsr $a720			jsr 	StackPushByte
.88eb	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.88ed	20 20 a7	jsr $a720			jsr 	StackPushByte
.88f0	7a		ply				ply
.88f1	60		rts				rts
.88f2					_LNTError:
.88f2	4c 42 a0	jmp $a042			jmp 	SyntaxError
.88f5					LocalPopValue:
.88f5	20 39 a7	jsr $a739			jsr 	StackPopByte
.88f8	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.88fa	d0 17		bne $8913			bne 	_LPVString
.88fc	20 39 a7	jsr $a739			jsr 	StackPopByte 				; address
.88ff	85 37		sta $37				sta 	zTemp0+1
.8901	20 39 a7	jsr $a739			jsr 	StackPopByte
.8904	85 36		sta $36				sta 	zTemp0
.8906	5a		phy				phy
.8907	a0 04		ldy #$04			ldy 	#4 							; copy back
.8909					_LPVNumberCopy:
.8909	20 39 a7	jsr $a739			jsr 	StackPopByte
.890c	91 36		sta ($36),y			sta 	(zTemp0),y
.890e	88		dey				dey
.890f	10 f8		bpl $8909			bpl 	_LPVNumberCopy
.8911	7a		ply				ply 								; and complete
.8912	60		rts				rts
.8913					_LPVString:
.8913	20 39 a7	jsr $a739			jsr 	StackPopByte 				; address of record => zTemp0
.8916	85 37		sta $37				sta 	zTemp0+1
.8918	20 39 a7	jsr $a739			jsr 	StackPopByte
.891b	85 36		sta $36				sta 	zTemp0
.891d	5a		phy				phy
.891e	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8920	85 38		sta $38				sta 	zTemp1
.8922	a0 01		ldy #$01			ldy 	#1
.8924	b1 36		lda ($36),y			lda 	(zTemp0),y
.8926	85 39		sta $39				sta 	zTemp1+1
.8928	20 39 a7	jsr $a739			jsr 	StackPopByte 				; # to get => y
.892b	a8		tay				tay
.892c	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.892e	f0 0e		beq $893e			beq 	_LPVStringCopied
.8930	a9 00		lda #$00			lda 	#0 							; NULL on end
.8932	91 38		sta ($38),y			sta 	(zTemp1),y
.8934					_LPVStringCopy:
.8934	88		dey				dey
.8935	30 07		bmi $893e			bmi 	_LPVStringCopied
.8937	20 39 a7	jsr $a739			jsr 	StackPopByte
.893a	91 38		sta ($38),y			sta 	(zTemp1),y
.893c	80 f6		bra $8934			bra 	_LPVStringCopy
.893e					_LPVStringCopied:
.893e	fa		plx				plx
.893f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8940					NewCommand:
.8940	20 46 89	jsr $8946			jsr 	NewProgram
.8943	4c 56 83	jmp $8356			jmp 	WarmStart
.8946					NewProgram:
.8946	20 44 a6	jsr $a644			jsr 	MemoryNew
.8949	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.894c	20 ef 83	jsr $83ef			jsr 	ClearCommand 				; clear everything.
.894f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8950					CallProcedure:
.8950	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8952	b1 30		lda ($30),y			lda 	(codePtr),y
.8954	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8956	f0 0c		beq $8964			beq 	_CPEndParam
.8958					_CPParamLoop:
.8958	20 d8 9d	jsr $9dd8			jsr 	EvaluateValue 				; get parameter onto stack
.895b	e8		inx				inx 								; bump next stack
.895c	b1 30		lda ($30),y			lda 	(codePtr),y
.895e	c8		iny				iny
.895f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8961	f0 f5		beq $8958			beq 	_CPParamLoop
.8963	88		dey				dey 								; unpick.
.8964					_CPEndParam:
.8964	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.8967	c8		iny				iny									; skip right bracket
.8968	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.896a	20 42 a7	jsr $a742			jsr 	StackOpen
.896d	20 86 a7	jsr $a786			jsr 	STKSaveCodePosition 		; save loop position
.8970	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8973	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8975	ad 10 04	lda $0410			lda 	NSMantissa1
.8978	85 37		sta $37				sta 	zTemp0+1
.897a	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.897c	b2 36		lda ($36)			lda 	(zTemp0)
.897e	85 30		sta $30				sta 	safePtr
.8980	b1 36		lda ($36),y			lda 	(zTemp0),y
.8982	85 31		sta $31				sta 	safePtr+1
.8984	c8		iny				iny
.8985	b1 36		lda ($36),y			lda 	(zTemp0),y
.8987	85 32		sta $32				sta 	safePtr+2
.8989	c8		iny				iny
.898a	b1 36		lda ($36),y			lda 	(zTemp0),y
.898c	85 33		sta $33				sta 	safePtr+3
.898e	c8		iny				iny 								; get Y offset -> Y
.898f	b1 36		lda ($36),y			lda 	(zTemp0),y
.8991	a8		tay				tay
.8992	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8994	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.8997	f0 13		beq $89ac			beq 	_ParamExit 					; if so, exit.
.8999					_ParamExtract:
.8999	ca		dex				dex 								; put a local term on the level before
.899a	20 87 88	jsr $8887			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.899d	20 bf 87	jsr $87bf			jsr 	AssignVariable 				; assign stacked value to the variable.
.89a0	e8		inx				inx 								; advance to next parameter to do.
.89a1	e8		inx				inx
.89a2	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.89a5	f0 05		beq $89ac			beq 	_ParamExit
.89a7	20 e4 8d	jsr $8de4			jsr 	CheckComma 					; comma seperating parameters
.89aa	80 ed		bra $8999			bra 	_ParamExtract
.89ac					_ParamExit:
.89ac	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket 			; check )
.89af	60		rts				rts 								; and continue from here
.89b0					Command_ENDPROC:
.89b0	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.89b2	a2 14		ldx #$14			ldx 	#ERRID_PROC
.89b4	20 6e a7	jsr $a76e			jsr 	StackCheckFrame
.89b7	20 97 a7	jsr $a797			jsr 	STKLoadCodePosition 		; restore code position
.89ba	20 60 a7	jsr $a760			jsr 	StackClose
.89bd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89be					Command_Read:
.89be	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89c0	20 7e 98	jsr $987e			jsr 	EvaluateTerm
.89c3	bd 00 04	lda $0400,x			lda 	NSStatus,x
.89c6	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89c8	f0 4a		beq $8a14			beq 	_CRSyntax 					; check reference (bit 0)
.89ca	20 5d 8a	jsr $8a5d			jsr 	SwapDataCodePtrs 			; swap code and data
.89cd	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89d0	d0 20		bne $89f2			bne 	_CRContinueData
.89d2					_CRKeepSearching:
.89d2	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89d4	aa		tax				tax
.89d5	20 37 8d	jsr $8d37			jsr 	ScanForward
.89d8	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.89da	f0 16		beq $89f2			beq 	_CRHaveData 				; found it
.89dc	18		clc				clc
.89dd	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.89df	65 30		adc $30				adc 	codePtr
.89e1	85 30		sta $30				sta 	codePtr
.89e3	90 02		bcc $89e7			bcc 	_CREExit
.89e5	e6 31		inc $31				inc 	codePtr+1
.89e7					_CREExit:
.89e7	a0 03		ldy #$03			ldy 	#3 							; start of line.
.89e9	b2 30		lda ($30)			lda 	(codePtr)
.89eb	d0 e5		bne $89d2			bne 	_CRKeepSearching
.89ed	a9 0b		lda #$0b		lda	#11
.89ef	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.89f2					_CRHaveData:
.89f2					_CRContinueData:
.89f2	a2 01		ldx #$01			ldx 	#1
.89f4	20 d8 9d	jsr $9dd8			jsr 	EvaluateValue 				; evaluate value into slot # 1
.89f7	ca		dex				dex
.89f8	20 bf 87	jsr $87bf			jsr		AssignVariable 				; do the assignment
.89fb	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.89fe	b1 30		lda ($30),y			lda 	(codePtr),y
.8a00	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a02	d0 04		bne $8a08			bne 	_CRSwapBack
.8a04	c8		iny				iny 								; consume comma
.8a05	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8a08					_CRSwapBack:
.8a08	20 5d 8a	jsr $8a5d			jsr 	SwapDataCodePtrs			; swap them back.
.8a0b	b1 30		lda ($30),y			lda 	(codePtr),y
.8a0d	c8		iny				iny
.8a0e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a10	f0 ac		beq $89be			beq 	Command_Read 				; if so go round again.
.8a12	88		dey				dey 								; unpick get.
.8a13	60		rts				rts
.8a14					_CRSyntax:
.8a14	4c 42 a0	jmp $a042			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a17					RemCommand:
.8a17	b1 30		lda ($30),y			lda 	(codePtr),y
.8a19	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a1b	d0 06		bne $8a23			bne 	_RMExit
.8a1d	c8		iny				iny
.8a1e	98		tya				tya
.8a1f	38		sec				sec
.8a20	71 30		adc ($30),y			adc 	(codePtr),y
.8a22	a8		tay				tay
.8a23					_RMExit:
.8a23	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a24					Command_REPEAT:
.8a24	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a26	20 42 a7	jsr $a742			jsr 	StackOpen
.8a29	20 86 a7	jsr $a786			jsr 	STKSaveCodePosition 		; save loop position
.8a2c	60		rts				rts
.8a2d					Command_UNTIL:
.8a2d	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a2f	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a31	20 6e a7	jsr $a76e			jsr 	StackCheckFrame
.8a34	a2 00		ldx #$00			ldx 	#0
.8a36	20 e1 9d	jsr $9de1			jsr 	EvaluateNumber 				; work out the number
.8a39	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; check if zero
.8a3c	f0 04		beq $8a42			beq 	_CULoopBack 				; if so keep looping
.8a3e	20 60 a7	jsr $a760			jsr 	StackClose		 			; return
.8a41	60		rts				rts
.8a42					_CULoopBack:
.8a42	20 97 a7	jsr $a797			jsr 	STKLoadCodePosition 		; loop back
.8a45	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a46					Command_Restore:
.8a46	20 5d 8a	jsr $8a5d			jsr 	SwapDataCodePtrs 			; swap code and data
.8a49	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a4b	85 30		sta $30				sta 	codePtr
.8a4d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a4f	85 31		sta $31				sta 	codePtr+1
.8a51	20 5d 8a	jsr $8a5d			jsr 	SwapDataCodePtrs 			; put them back
.8a54	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a56	8d 9b 04	sta $049b			sta 	dataPointer+4
.8a59	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.8a5c	60		rts				rts
.8a5d					SwapDataCodePtrs:
.8a5d	da		phx				phx
.8a5e	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a60					_SDCPLoop:
.8a60	b5 30		lda $30,x			lda 	safePtr,x
.8a62	48		pha				pha
.8a63	bd 97 04	lda $0497,x			lda 	dataPointer,x
.8a66	95 30		sta $30,x			sta 	safePtr,x
.8a68	68		pla				pla
.8a69	9d 97 04	sta $0497,x			sta 	dataPointer,x
.8a6c	ca		dex				dex
.8a6d	10 f1		bpl $8a60			bpl 	_SDCPLoop
.8a6f	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.8a72	8c 9b 04	sty $049b			sty 	dataPointer+4
.8a75	a8		tay				tay
.8a76	fa		plx				plx
.8a77	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a78					EOLCommand:
.8a78	18		clc				clc
.8a79	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8a7b	65 30		adc $30				adc 	codePtr
.8a7d	85 30		sta $30				sta 	codePtr
.8a7f	90 02		bcc $8a83			bcc 	_CREExit
.8a81	e6 31		inc $31				inc 	codePtr+1
.8a83					_CREExit:
.8a83	80 0b		bra $8a90			bra 	RunNewLine
.8a85					CommandRUN:
.8a85	20 ef 83	jsr $83ef			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a88	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a8a	85 30		sta $30				sta 	codePtr
.8a8c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a8e	85 31		sta $31				sta 	codePtr+1
.8a90					RUNNewLine:
.8a90	b2 30		lda ($30)			lda 	(codePtr)
.8a92	f0 72		beq $8b06			beq 	CRNoProgram         		; no then END.
.8a94	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a96	9a		txs				txs
.8a97					RUNCodePointerLine:
.8a97	a0 02		ldy #$02			ldy 	#2 							; start of program
.8a99					_CRIncMainLoop:
.8a99	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8a9c	d0 19		bne $8ab7			bne 	_CRNoBreakCheck
.8a9e	20 38 ab	jsr $ab38			jsr 	EXTBreakCheck 				; break check
.8aa1	f0 5e		beq $8b01			beq 	_CRBreak
.8aa3	64 01		stz $01				stz 	1 							; access I/O Page 0
.8aa5	38		sec				sec 								; calculate timer - LastTick
.8aa6	ad 59 d6	lda $d659			lda 	$D659
.8aa9	aa		tax				tax 								; saving timer in X
.8aaa	ed 2e 06	sbc $062e			sbc 	LastTick
.8aad	c9 03		cmp #$03			cmp 	#3
.8aaf	90 06		bcc $8ab7			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8ab1	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.8ab4	20 9d ba	jsr $ba9d			jsr 	TickHandler 				; go do the code.
.8ab7					_NoFireTick:
.8ab7					_CRNoBreakCheck:
.8ab7	c8		iny				iny
.8ab8					_CRMainLoop:
.8ab8	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8abb	b1 30		lda ($30),y			lda 	(codePtr),y
.8abd	10 10		bpl $8acf			bpl 	_CRNotKeyword
.8abf	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8ac1	b0 04		bcs $8ac7			bcs 	_CRIsKeyword
.8ac3	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8ac5	b0 34		bcs $8afb			bcs		_CRSyntaxError
.8ac7					_CRIsKeyword:
.8ac7	c8		iny				iny 								; consume command
.8ac8	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8ac9	aa		tax				tax 								; put in X for vector jump
.8aca	20 fe 8a	jsr $8afe			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8acd	80 e9		bra $8ab8			bra 	_CRMainLoop 				; and loop round
.8acf					_CRNotKeyword:
.8acf	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8ad1	f0 c6		beq $8a99			beq 	_CRIncMainLoop
.8ad3	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8ad5	90 05		bcc $8adc			bcc 	_CRNotVariable
.8ad7					_CRGoLet:
.8ad7	20 83 87	jsr $8783			jsr 	LetCommand
.8ada	80 dc		bra $8ab8			bra 	_CRMainLoop
.8adc					_CRNotVariable:
.8adc	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8ade	f0 f7		beq $8ad7			beq 	_CRGoLet
.8ae0	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8ae2	f0 f3		beq $8ad7			beq 	_CRGoLet
.8ae4	c9 21		cmp #$21			cmp 	#KWD_PLING
.8ae6	f0 ef		beq $8ad7			beq 	_CRGoLet
.8ae8	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8aea	f0 09		beq $8af5			beq 	_CRGoRem
.8aec	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8aee	d0 0b		bne $8afb			bne 	_CRSyntaxError
.8af0	20 14 82	jsr $8214			jsr 	LabelHere
.8af3	80 c3		bra $8ab8			bra 	_CRMainLoop
.8af5					_CRGoRem:
.8af5	c8		iny				iny
.8af6	20 17 8a	jsr $8a17			jsr 	RemCommand
.8af9	80 bd		bra $8ab8			bra 	_CRMainLoop
.8afb					_CRSyntaxError:
.8afb	4c 42 a0	jmp $a042			jmp 	SyntaxError
.8afe					_CRCallVector0:
.8afe	7c 9c 8b	jmp ($8b9c,x)			jmp 	(VectorSet0,x)
.8b01					_CRBreak:
.8b01	a9 01		lda #$01		lda	#1
.8b03	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.8b06					CRNoProgram:
.8b06	4c 14 85	jmp $8514			jmp 	EndCommand
.8b09					Shift1Command:
.8b09	b1 30		lda ($30),y			lda 	(codePtr),y
.8b0b	c8		iny				iny
.8b0c	0a		asl a				asl 	a
.8b0d	aa		tax				tax
.8b0e	7c 3a 8c	jmp ($8c3a,x)			jmp 	(VectorSet1,x)
.8b11					Shift2Command:
.8b11	b1 30		lda ($30),y			lda 	(codePtr),y
.8b13	c8		iny				iny
.8b14	0a		asl a				asl 	a
.8b15	aa		tax				tax
.8b16	7c 58 8c	jmp ($8c58,x)			jmp 	(VectorSet2,x)
.8b19					Unused1:
.8b19					Unused2:
.8b19					Unused3:
.8b19					Unused4:
.8b19	4c 42 a0	jmp $a042			jmp 	SyntaxError
>8b1c							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b1c					VectorSetPunc:
>8b1c	e2 90					.word	ShiftLeft                        ; $00 <<
>8b1e	99 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8b20	8f 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8b22	42 a0					.word	SyntaxError                      ; $03 !!3
>8b24	42 a0					.word	SyntaxError                      ; $04 ><
>8b26	a3 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b28	e5 90					.word	ShiftRight                       ; $06 >>
>8b2a	42 a0					.word	SyntaxError                      ; $07 !!7
>8b2c	42 a0					.word	SyntaxError                      ; $08 !!8
>8b2e	42 a0					.word	SyntaxError                      ; $09 !!9
>8b30	42 a0					.word	SyntaxError                      ; $0a !!10
>8b32	42 a0					.word	SyntaxError                      ; $0b !!11
>8b34	42 a0					.word	SyntaxError                      ; $0c !!12
>8b36	42 a0					.word	SyntaxError                      ; $0d !!13
>8b38	42 a0					.word	SyntaxError                      ; $0e !!14
>8b3a	42 a0					.word	SyntaxError                      ; $0f !!15
>8b3c	42 a0					.word	SyntaxError                      ; $10 @
>8b3e	42 a0					.word	SyntaxError                      ; $11 !!17
>8b40	42 a0					.word	SyntaxError                      ; $12 !!18
>8b42	42 a0					.word	SyntaxError                      ; $13 [
>8b44	66 8f					.word	IntegerDivide                    ; $14 \
>8b46	42 a0					.word	SyntaxError                      ; $15 ]
>8b48	73 92					.word	EorInteger                       ; $16 ^
>8b4a	42 a0					.word	SyntaxError                      ; $17 _
>8b4c	42 a0					.word	SyntaxError                      ; $18 `
>8b4e	42 a0					.word	SyntaxError                      ; $19 !!25
>8b50	42 a0					.word	SyntaxError                      ; $1a !!26
>8b52	42 a0					.word	SyntaxError                      ; $1b {
>8b54	2d 92					.word	OraInteger                       ; $1c |
>8b56	42 a0					.word	SyntaxError                      ; $1d }
>8b58	42 a0					.word	SyntaxError                      ; $1e ~
>8b5a	42 a0					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b5c	42 a0					.word	SyntaxError                      ; $20
>8b5e	b9 92					.word	WordIndirect                     ; $21 !
>8b60	42 a0					.word	SyntaxError                      ; $22 "
>8b62	42 a0					.word	SyntaxError                      ; $23 #
>8b64	42 a0					.word	SyntaxError                      ; $24 $
>8b66	b3 8f					.word	IntegerModulus                   ; $25 %
>8b68	e7 91					.word	AndInteger                       ; $26 &
>8b6a	42 a0					.word	SyntaxError                      ; $27 '
>8b6c	42 a0					.word	SyntaxError                      ; $28 (
>8b6e	42 a0					.word	SyntaxError                      ; $29 )
>8b70	28 90					.word	MulInteger                       ; $2a *
>8b72	79 91					.word	AddInteger                       ; $2b +
>8b74	42 a0					.word	SyntaxError                      ; $2c ,
>8b76	bc 91					.word	SubInteger                       ; $2d -
>8b78	42 a0					.word	SyntaxError                      ; $2e .
>8b7a	a4 94					.word	FDivideCommand                   ; $2f /
>8b7c	42 a0					.word	SyntaxError                      ; $30 0
>8b7e	42 a0					.word	SyntaxError                      ; $31 1
>8b80	42 a0					.word	SyntaxError                      ; $32 2
>8b82	42 a0					.word	SyntaxError                      ; $33 3
>8b84	42 a0					.word	SyntaxError                      ; $34 4
>8b86	42 a0					.word	SyntaxError                      ; $35 5
>8b88	42 a0					.word	SyntaxError                      ; $36 6
>8b8a	42 a0					.word	SyntaxError                      ; $37 7
>8b8c	42 a0					.word	SyntaxError                      ; $38 8
>8b8e	42 a0					.word	SyntaxError                      ; $39 9
>8b90	42 a0					.word	SyntaxError                      ; $3a :
>8b92	42 a0					.word	SyntaxError                      ; $3b ;
>8b94	7b 8e					.word	BinaryCompareLess                ; $3c <
>8b96	71 8e					.word	BinaryCompareEqual               ; $3d =
>8b98	85 8e					.word	BinaryCompareGreater             ; $3e >
>8b9a	e0 92					.word	ByteIndirect                     ; $3f ?
.8b9c					VectorSet0:
>8b9c	78 8a					.word	EOLCommand                       ; $80 !0:EOF
>8b9e	09 8b					.word	Shift1Command                    ; $81 !1:SH1
>8ba0	11 8b					.word	Shift2Command                    ; $82 !2:SH2
>8ba2	14 9a					.word	AbsUnary                         ; $83 ABS(
>8ba4	24 9a					.word	AllocUnary                       ; $84 ALLOC(
>8ba6	94 9a					.word	AscUnary                         ; $85 ASC(
>8ba8	5f 9c					.word	ChrUnary                         ; $86 CHR$(
>8baa	b5 a4					.word	UnaryEvent                       ; $87 EVENT(
>8bac	6d 8e					.word	UnaryFalse                       ; $88 FALSE
>8bae	a1 9a					.word	FracUnary                        ; $89 FRAC(
>8bb0	4b a4					.word	UnaryHit                         ; $8a HIT(
>8bb2	b7 9a					.word	IntUnary                         ; $8b INT(
>8bb4	1e 9c					.word	IsValUnary                       ; $8c ISVAL(
>8bb6	45 a5					.word	UnaryJoyB                        ; $8d JOYB(
>8bb8	1e a5					.word	UnaryJoyX                        ; $8e JOYX(
>8bba	21 a5					.word	UnaryJoyY                        ; $8f JOYY(
>8bbc	39 9d					.word	Unary_Left                       ; $90 LEFT$(
>8bbe	c9 9a					.word	LenUnary                         ; $91 LEN(
>8bc0	e7 9a					.word	Unary_Max                        ; $92 MAX(
>8bc2	63 9d					.word	Unary_Mid                        ; $93 MID$(
>8bc4	e3 9a					.word	Unary_Min                        ; $94 MIN(
>8bc6	3e 9b					.word	Unary_Not                        ; $95 NOT(
>8bc8	99 a6					.word	UnaryPlaying                     ; $96 PLAYING(
>8bca	54 9b					.word	Unary_Random                     ; $97 RANDOM(
>8bcc	49 9d					.word	Unary_Right                      ; $98 RIGHT$(
>8bce	73 9b					.word	Unary_Rnd                        ; $99 RND(
>8bd0	f4 9b					.word	SgnUnary                         ; $9a SGN(
>8bd2	71 9c					.word	SpcUnary                         ; $9b SPC(
>8bd4	8c 9c					.word	Unary_Str                        ; $9c STR$(
>8bd6	6b a5					.word	UnaryTimer                       ; $9d TIMER(
>8bd8	61 8e					.word	UnaryTrue                        ; $9e TRUE
>8bda	14 9c					.word	ValUnary                         ; $9f VAL(
>8bdc	17 85					.word	ForCommand                       ; $a0 FOR
>8bde	64 86					.word	IfCommand                        ; $a1 IF
>8be0	19 8b					.word	Unused1                          ; $a2 PROC
>8be2	24 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8be4	ad 8d					.word	Command_WHILE                    ; $a4 WHILE
>8be6	8d 86					.word	EndIf                            ; $a5 ENDIF
>8be8	b0 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8bea	d1 85					.word	NextCommand                      ; $a7 NEXT
>8bec	19 8b					.word	Unused4                          ; $a8 THEN
>8bee	2d 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8bf0	ce 8d					.word	Command_WEND                     ; $aa WEND
>8bf2	42 a0					.word	SyntaxError                      ; $ab BY
>8bf4	b5 83					.word	CallCommand                      ; $ac CALL
>8bf6	ed a1					.word	CircleCommand                    ; $ad CIRCLE
>8bf8	ef 83					.word	ClearCommand                     ; $ae CLEAR
>8bfa	47 84					.word	ClearScreen                      ; $af CLS
>8bfc	42 a0					.word	SyntaxError                      ; $b0 COLOR
>8bfe	42 a0					.word	SyntaxError                      ; $b1 COLOUR
>8c00	4f 84					.word	Command_Data                     ; $b2 DATA
>8c02	57 84					.word	DimCommand                       ; $b3 DIM
>8c04	19 8b					.word	Unused3                          ; $b4 DOWNTO
>8c06	86 86					.word	ElseCode                         ; $b5 ELSE
>8c08	42 a0					.word	SyntaxError                      ; $b6 FROM
>8c0a	19 a4					.word	GfxCommand                       ; $b7 GFX
>8c0c	2a 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c0e	48 86					.word	GotoCommand                      ; $b9 GOTO
>8c10	42 a0					.word	SyntaxError                      ; $ba HERE
>8c12	17 a2					.word	ImageCommand                     ; $bb IMAGE
>8c14	8e 86					.word	Command_Input                    ; $bc INPUT
>8c16	83 87					.word	LetCommand                       ; $bd LET
>8c18	6c a2					.word	LineCommand                      ; $be LINE
>8c1a	79 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c1c	42 a0					.word	SyntaxError                      ; $c0 OFF
>8c1e	42 a0					.word	SyntaxError                      ; $c1 ON
>8c20	42 a0					.word	SyntaxError                      ; $c2 OUTLINE
>8c22	71 a4					.word	PaletteCommand                   ; $c3 PALETTE
>8c24	65 a2					.word	PlotCommand                      ; $c4 PLOT
>8c26	95 86					.word	Command_Print                    ; $c5 PRINT
>8c28	be 89					.word	Command_Read                     ; $c6 READ
>8c2a	e9 a1					.word	RectangleCommand                 ; $c7 RECT
>8c2c	17 8a					.word	RemCommand                       ; $c8 REM
>8c2e	3a 86					.word	Command_RETURN                   ; $c9 RETURN
>8c30	42 a0					.word	SyntaxError                      ; $ca SOLID
>8c32	b5 a6					.word	SoundCommand                     ; $cb SOUND
>8c34	f8 a1					.word	SpriteCommand                    ; $cc SPRITE
>8c36	34 a2					.word	TextCommand                      ; $cd TEXT
>8c38	19 8b					.word	Unused2                          ; $ce TO
.8c3a					VectorSet1:
>8c3a	42 a0					.word	SyntaxError                      ; $80 !0:EOF
>8c3c	42 a0					.word	SyntaxError                      ; $81 !1:SH1
>8c3e	42 a0					.word	SyntaxError                      ; $82 !2:SH2
>8c40	86 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c42	a5 83					.word	AssertCommand                    ; $84 ASSERT
>8c44	b9 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8c46	14 85					.word	EndCommand                       ; $86 END
>8c48	62 a5					.word	GoCommand                        ; $87 GO
>8c4a	d8 87					.word	Command_List                     ; $88 LIST
>8c4c	59 a5					.word	LoadCommand                      ; $89 LOAD
>8c4e	40 89					.word	NewCommand                       ; $8a NEW
>8c50	46 8a					.word	Command_Restore                  ; $8b RESTORE
>8c52	85 8a					.word	CommandRUN                       ; $8c RUN
>8c54	fe a3					.word	SpritesCtrl                      ; $8d SPRITES
>8c56	e0 8c					.word	StopCommand                      ; $8e STOP
.8c58					VectorSet2:
>8c58	42 a0					.word	SyntaxError                      ; $80 !0:EOF
>8c5a	42 a0					.word	SyntaxError                      ; $81 !1:SH1
>8c5c	42 a0					.word	SyntaxError                      ; $82 !2:SH2
>8c5e	01 9f					.word	Assemble_adc                     ; $83 ADC
>8c60	f9 9e					.word	Assemble_and                     ; $84 AND
>8c62	15 9f					.word	Assemble_asl                     ; $85 ASL
>8c64	7f 9f					.word	Assemble_bcc                     ; $86 BCC
>8c66	83 9f					.word	Assemble_bcs                     ; $87 BCS
>8c68	8b 9f					.word	Assemble_beq                     ; $88 BEQ
>8c6a	42 9f					.word	Assemble_bit                     ; $89 BIT
>8c6c	73 9f					.word	Assemble_bmi                     ; $8a BMI
>8c6e	87 9f					.word	Assemble_bne                     ; $8b BNE
>8c70	6f 9f					.word	Assemble_bpl                     ; $8c BPL
>8c72	8f 9f					.word	Assemble_bra                     ; $8d BRA
>8c74	93 9f					.word	Assemble_brk                     ; $8e BRK
>8c76	77 9f					.word	Assemble_bvc                     ; $8f BVC
>8c78	7b 9f					.word	Assemble_bvs                     ; $90 BVS
>8c7a	9b 9f					.word	Assemble_clc                     ; $91 CLC
>8c7c	ef 9f					.word	Assemble_cld                     ; $92 CLD
>8c7e	af 9f					.word	Assemble_cli                     ; $93 CLI
>8c80	df 9f					.word	Assemble_clv                     ; $94 CLV
>8c82	0d 9f					.word	Assemble_cmp                     ; $95 CMP
>8c84	56 9f					.word	Assemble_cpx                     ; $96 CPX
>8c86	51 9f					.word	Assemble_cpy                     ; $97 CPY
>8c88	33 9f					.word	Assemble_dec                     ; $98 DEC
>8c8a	eb 9f					.word	Assemble_dex                     ; $99 DEX
>8c8c	c7 9f					.word	Assemble_dey                     ; $9a DEY
>8c8e	fd 9e					.word	Assemble_eor                     ; $9b EOR
>8c90	38 9f					.word	Assemble_inc                     ; $9c INC
>8c92	fb 9f					.word	Assemble_inx                     ; $9d INX
>8c94	e7 9f					.word	Assemble_iny                     ; $9e INY
>8c96	6a 9f					.word	Assemble_jmp                     ; $9f JMP
>8c98	65 9f					.word	Assemble_jsr                     ; $a0 JSR
>8c9a	09 9f					.word	Assemble_lda                     ; $a1 LDA
>8c9c	2e 9f					.word	Assemble_ldx                     ; $a2 LDX
>8c9e	4c 9f					.word	Assemble_ldy                     ; $a3 LDY
>8ca0	1f 9f					.word	Assemble_lsr                     ; $a4 LSR
>8ca2	ff 9f					.word	Assemble_nop                     ; $a5 NOP
>8ca4	f5 9e					.word	Assemble_ora                     ; $a6 ORA
>8ca6	ab 9f					.word	Assemble_pha                     ; $a7 PHA
>8ca8	97 9f					.word	Assemble_php                     ; $a8 PHP
>8caa	f3 9f					.word	Assemble_phx                     ; $a9 PHX
>8cac	b3 9f					.word	Assemble_phy                     ; $aa PHY
>8cae	bb 9f					.word	Assemble_pla                     ; $ab PLA
>8cb0	9f 9f					.word	Assemble_plp                     ; $ac PLP
>8cb2	07 a0					.word	Assemble_plx                     ; $ad PLX
>8cb4	c3 9f					.word	Assemble_ply                     ; $ae PLY
>8cb6	1a 9f					.word	Assemble_rol                     ; $af ROL
>8cb8	24 9f					.word	Assemble_ror                     ; $b0 ROR
>8cba	a7 9f					.word	Assemble_rti                     ; $b1 RTI
>8cbc	b7 9f					.word	Assemble_rts                     ; $b2 RTS
>8cbe	11 9f					.word	Assemble_sbc                     ; $b3 SBC
>8cc0	a3 9f					.word	Assemble_sec                     ; $b4 SEC
>8cc2	03 a0					.word	Assemble_sed                     ; $b5 SED
>8cc4	bf 9f					.word	Assemble_sei                     ; $b6 SEI
>8cc6	05 9f					.word	Assemble_sta                     ; $b7 STA
>8cc8	f7 9f					.word	Assemble_stp                     ; $b8 STP
>8cca	29 9f					.word	Assemble_stx                     ; $b9 STX
>8ccc	47 9f					.word	Assemble_sty                     ; $ba STY
>8cce	3d 9f					.word	Assemble_stz                     ; $bb STZ
>8cd0	db 9f					.word	Assemble_tax                     ; $bc TAX
>8cd2	d7 9f					.word	Assemble_tay                     ; $bd TAY
>8cd4	60 9f					.word	Assemble_trb                     ; $be TRB
>8cd6	5b 9f					.word	Assemble_tsb                     ; $bf TSB
>8cd8	e3 9f					.word	Assemble_tsx                     ; $c0 TSX
>8cda	cb 9f					.word	Assemble_txa                     ; $c1 TXA
>8cdc	d3 9f					.word	Assemble_txs                     ; $c2 TXS
>8cde	cf 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8ce0					StopCommand:
.8ce0	a9 08		lda #$08		lda	#8
.8ce2	4c f5 8d	jmp $8df5		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8ce5					ProcedureScan:
.8ce5	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8ce7	85 30		sta $30				sta 	codePtr
.8ce9	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8ceb	85 31		sta $31				sta 	codePtr+1
.8ced					_PSLoop:
.8ced	b2 30		lda ($30)			lda 	(codePtr)
.8cef	f0 42		beq $8d33			beq 	_PSExit
.8cf1	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8cf3	b1 30		lda ($30),y			lda 	(codePtr),y
.8cf5	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8cf7	d0 2d		bne $8d26			bne 	_PSNext
.8cf9	c8		iny				iny 								; get the address of the record to zTemp0 and
.8cfa	b1 30		lda ($30),y			lda 	(codePtr),y
.8cfc	29 c0		and #$c0			and 	#$C0
.8cfe	c9 40		cmp #$40			cmp 	#$40
.8d00	d0 32		bne $8d34			bne 	_PSSyntax
.8d02	b1 30		lda ($30),y			lda 	(codePtr),y
.8d04	18		clc				clc
.8d05	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d07	85 37		sta $37				sta 	zTemp0+1
.8d09	c8		iny				iny 								; LSB
.8d0a	b1 30		lda ($30),y			lda 	(codePtr),y
.8d0c	85 36		sta $36				sta 	zTemp0
.8d0e	c8		iny				iny 								; character after variable call.
.8d0f	98		tya				tya 								; save Y offset at +7
.8d10	a0 07		ldy #$07			ldy 	#7
.8d12	91 36		sta ($36),y			sta 	(zTemp0),y
.8d14	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d16	a0 02		ldy #$02			ldy 	#2
.8d18	91 36		sta ($36),y			sta 	(zTemp0),y
.8d1a	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d1c					_PSCopy:
.8d1c	b5 30		lda $30,x			lda 	safePtr,x
.8d1e	c8		iny				iny
.8d1f	91 36		sta ($36),y			sta 	(zTemp0),y
.8d21	e8		inx				inx
.8d22	e0 04		cpx #$04			cpx 	#4
.8d24	d0 f6		bne $8d1c			bne 	_PSCopy
.8d26					_PSNext:
.8d26	18		clc				clc
.8d27	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8d29	65 30		adc $30				adc 	codePtr
.8d2b	85 30		sta $30				sta 	codePtr
.8d2d	90 02		bcc $8d31			bcc 	_CREExit
.8d2f	e6 31		inc $31				inc 	codePtr+1
.8d31					_CREExit:
.8d31	80 ba		bra $8ced			bra 	_PSLoop
.8d33					_PSExit:
.8d33	60		rts				rts
.8d34					_PSSyntax:
.8d34	4c 42 a0	jmp $a042			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d37					ScanForward:
.8d37	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d39	86 37		stx $37				stx 	zTemp0+1
.8d3b	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d3d					_ScanLoop:
.8d3d	b1 30		lda ($30),y			lda 	(codePtr),y
.8d3f	c8		iny				iny
.8d40	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d42	d0 0e		bne $8d52			bne 	_ScanGoNext
.8d44	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d46	f0 04		beq $8d4c			beq 	_ScanMatch
.8d48	c5 37		cmp $37				cmp 	zTemp0+1
.8d4a	d0 06		bne $8d52			bne 	_ScanGoNext
.8d4c					_ScanMatch:
.8d4c	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d4e	d0 01		bne $8d51			bne 	_ScanNotEndEOL
.8d50	88		dey				dey
.8d51					_ScanNotEndEOL:
.8d51	60		rts				rts
.8d52					_ScanGoNext:
.8d52	20 57 8d	jsr $8d57			jsr  	ScanForwardOne
.8d55	80 e6		bra $8d3d			bra 	_ScanLoop
.8d57					ScanForwardOne:
.8d57	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d59	90 3e		bcc $8d99			bcc 	_SFWExit
.8d5b	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d5d	90 18		bcc $8d77			bcc 	_ScanSkipOne
.8d5f	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d61	b0 2f		bcs $8d92			bcs 	_ScanSkipData
.8d63	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d65	90 32		bcc $8d99			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d67	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d69	b0 2e		bcs $8d99			bcs 	_SFWExit
.8d6b	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d6d	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d6f	b0 28		bcs $8d99			bcs 	_SFWExit
.8d71	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d73	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8d75	80 22		bra $8d99			bra 	_SFWExit
.8d77					_ScanSkipOne:
.8d77	c8		iny				iny 								; consume the extra one.
.8d78	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8d7a	d0 1d		bne $8d99			bne 	_SFWExit
.8d7c	18		clc				clc
.8d7d	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.8d7f	65 30		adc $30				adc 	codePtr
.8d81	85 30		sta $30				sta 	codePtr
.8d83	90 02		bcc $8d87			bcc 	_CREExit
.8d85	e6 31		inc $31				inc 	codePtr+1
.8d87					_CREExit:
.8d87	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8d89	b2 30		lda ($30)			lda 	(codePtr)
.8d8b	d0 0c		bne $8d99			bne 	_SFWExit 					; if not zero, more to scan
.8d8d	a9 13		lda #$13		lda	#19
.8d8f	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.8d92					_ScanSkipData:
.8d92	88		dey				dey 								; point at data token
.8d93	c8		iny				iny
.8d94	98		tya				tya
.8d95	38		sec				sec
.8d96	71 30		adc ($30),y			adc 	(codePtr),y
.8d98	a8		tay				tay
.8d99					_SFWExit:
.8d99	60		rts				rts
.8d9a					ScanGetCurrentLineStep:
.8d9a	64 38		stz $38				stz 	zTemp1
.8d9c	a0 03		ldy #$03			ldy 	#3
.8d9e					_SGCLSLoop:
.8d9e	b1 30		lda ($30),y			lda 	(codePtr),y
.8da0	c8		iny				iny
.8da1	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8da3	f0 05		beq $8daa			beq 	_SGCLSExit
.8da5	20 57 8d	jsr $8d57			jsr 	ScanForwardOne
.8da8	80 f4		bra $8d9e			bra 	_SGCLSLoop
.8daa					_SGCLSExit:
.8daa	a5 38		lda $38				lda 	zTemp1
.8dac	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8dad					Command_WHILE:
.8dad	5a		phy				phy 								; save position of the test
.8dae	a2 00		ldx #$00			ldx 	#0
.8db0	20 e1 9d	jsr $9de1			jsr 	EvaluateNumber 				; work out the number
.8db3	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; check if zero
.8db6	f0 0e		beq $8dc6			beq 	_WHExitLoop 				; if so exit the loop
.8db8	98		tya				tya 								; position *after* test.
.8db9	7a		ply				ply 								; restore position before test, at WHILE
.8dba	88		dey				dey
.8dbb	48		pha				pha 								; push after test on the stack
.8dbc	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8dbe	20 42 a7	jsr $a742			jsr 	StackOpen
.8dc1	20 86 a7	jsr $a786			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8dc4	7a		ply				ply 								; restore the position *after* the test
.8dc5	60		rts				rts
.8dc6					_WHExitLoop:
.8dc6	68		pla				pla 								; throw post loop position
.8dc7	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8dc9	aa		tax				tax
.8dca	20 37 8d	jsr $8d37			jsr 	ScanForward
.8dcd	60		rts				rts
.8dce					Command_WEND:
.8dce	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8dd0	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8dd2	20 6e a7	jsr $a76e			jsr 	StackCheckFrame
.8dd5	20 97 a7	jsr $a797			jsr 	STKLoadCodePosition 		; loop back
.8dd8	20 60 a7	jsr $a760			jsr 	StackClose		 			; erase the frame
.8ddb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8ddc					CheckRightBracket:
.8ddc	b1 30		lda ($30),y			lda 	(codePtr),y
.8dde	c8		iny				iny
.8ddf	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8de1	d0 0f		bne $8df2			bne 	CNAFail
.8de3	60		rts				rts
.8de4					CheckComma:
.8de4	b1 30		lda ($30),y			lda 	(codePtr),y
.8de6	c8		iny				iny
.8de7	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8de9	d0 07		bne $8df2			bne 	CNAFail
.8deb	60		rts				rts
.8dec					CheckNextA:
.8dec	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8dee	d0 02		bne $8df2			bne 	CNAFail
.8df0	c8		iny				iny 								; skip character
.8df1	60		rts				rts 								; and exit
.8df2					CNAFail:
.8df2	4c 42 a0	jmp $a042			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8df5					ErrorHandler:
.8df5	a8		tay				tay 								; find the error text
.8df6	f0 49		beq $8e41			beq 	_EHEnd
.8df8	a2 00		ldx #$00			ldx 	#0
.8dfa	a9 5b		lda #$5b			lda 	#((ErrorText) & $FF)
.8dfc	85 36		sta $36				sta 	0+zTemp0
.8dfe	a9 a0		lda #$a0			lda 	#((ErrorText) >> 8)
.8e00	85 37		sta $37				sta 	1+zTemp0
.8e02					_EHFind:
.8e02	88		dey				dey 								; found the error text ?
.8e03	f0 0e		beq $8e13			beq 	_EHFound
.8e05					_EHFindZero:
.8e05	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e07	e6 36		inc $36				inc 	zTemp0
.8e09	d0 02		bne $8e0d			bne 	_EHFNoCarry
.8e0b	e6 37		inc $37				inc 	zTemp0+1
.8e0d					_EHFNoCarry:
.8e0d	c9 00		cmp #$00			cmp 	#0
.8e0f	d0 f4		bne $8e05			bne 	_EHFindZero
.8e11	80 ef		bra $8e02			bra 	_EHFind
.8e13					_EHFound:
.8e13	a5 36		lda $36				lda 	zTemp0 						; print message
.8e15	a6 37		ldx $37				ldx 	zTemp0+1
.8e17	20 4e 8e	jsr $8e4e			jsr 	PrintStringXA
.8e1a	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8e1c	b1 30		lda ($30),y			lda 	(codePtr),y
.8e1e	d0 05		bne $8e25			bne 	_EHAtMsg
.8e20	c8		iny				iny
.8e21	b1 30		lda ($30),y			lda 	(codePtr),y
.8e23	f0 17		beq $8e3c			beq 	_EHCREnd
.8e25					_EHAtMsg:
.8e25	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8e27	a9 44		lda #$44			lda 	#_AtMsg & $FF
.8e29	20 4e 8e	jsr $8e4e			jsr 	PrintStringXA
.8e2c	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8e2e	b1 30		lda ($30),y			lda 	(codePtr),y
.8e30	48		pha				pha
.8e31	c8		iny				iny
.8e32	b1 30		lda ($30),y			lda 	(codePtr),y
.8e34	aa		tax				tax
.8e35	68		pla				pla
.8e36	20 07 93	jsr $9307			jsr 	LCLConvertInt16 				; convert XA to string
.8e39	20 4e 8e	jsr $8e4e			jsr 	PrintStringXA 				; and print it.
.8e3c					_EHCREnd:
.8e3c	a9 0d		lda #$0d			lda 	#13 						; new line
.8e3e	20 82 a8	jsr $a882			jsr 	EXTPrintCharacter
.8e41					_EHEnd:
.8e41	4c 56 83	jmp $8356			jmp 	WarmStart
>8e44	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8e4c	20 00
.8e4e					PrintStringXA:
.8e4e	5a		phy				phy
.8e4f	86 37		stx $37				stx 	zTemp0+1
.8e51	85 36		sta $36				sta 	zTemp0
.8e53	a0 00		ldy #$00			ldy 	#0
.8e55					_PSXALoop:
.8e55	b1 36		lda ($36),y			lda 	(zTemp0),y
.8e57	f0 06		beq $8e5f			beq 	_PSXAExit
.8e59	20 82 a8	jsr $a882			jsr 	EXTPrintCharacter
.8e5c	c8		iny				iny
.8e5d	80 f6		bra $8e55			bra 	_PSXALoop
.8e5f					_PSXAExit:
.8e5f	7a		ply				ply
.8e60	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8e61					UnaryTrue:
.8e61	fa		plx				plx
.8e62					ReturnTrue:
.8e62	a9 01		lda #$01			lda 	#1  						; set to 1
.8e64	20 ba 9e	jsr $9eba			jsr 	NSMSetByte
.8e67	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8e69	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8e6c	60		rts				rts
.8e6d					UnaryFalse:
.8e6d	fa		plx				plx
.8e6e					ReturnFalse:
.8e6e	4c b8 9e	jmp $9eb8			jmp 	NSMSetZero 					; set it all to zero
.8e71					BinaryCompareEqual:
.8e71	fa		plx				plx
.8e72	20 ad 8e	jsr $8ead			jsr 	CompareBaseCode
.8e75	c9 00		cmp #$00			cmp 	#0
.8e77	f0 e9		beq $8e62			beq 	ReturnTrue
.8e79	80 f3		bra $8e6e			bra 	ReturnFalse
.8e7b					BinaryCompareLess:
.8e7b	fa		plx				plx
.8e7c	20 ad 8e	jsr $8ead			jsr 	CompareBaseCode
.8e7f	c9 ff		cmp #$ff			cmp 	#$FF
.8e81	f0 df		beq $8e62			beq 	ReturnTrue
.8e83	80 e9		bra $8e6e			bra 	ReturnFalse
.8e85					BinaryCompareGreater:
.8e85	fa		plx				plx
.8e86	20 ad 8e	jsr $8ead			jsr 	CompareBaseCode
.8e89	c9 01		cmp #$01			cmp 	#1
.8e8b	f0 d5		beq $8e62			beq 	ReturnTrue
.8e8d	80 df		bra $8e6e			bra 	ReturnFalse
.8e8f					BinaryCompareNotEqual:
.8e8f	fa		plx				plx
.8e90	20 ad 8e	jsr $8ead			jsr 	CompareBaseCode
.8e93	c9 00		cmp #$00			cmp 	#0
.8e95	d0 cb		bne $8e62			bne 	ReturnTrue
.8e97	80 d5		bra $8e6e			bra 	ReturnFalse
.8e99					BinaryCompareLessEqual:
.8e99	fa		plx				plx
.8e9a	20 ad 8e	jsr $8ead			jsr 	CompareBaseCode
.8e9d	c9 01		cmp #$01			cmp 	#1
.8e9f	d0 c1		bne $8e62			bne 	ReturnTrue
.8ea1	80 cb		bra $8e6e			bra 	ReturnFalse
.8ea3					BinaryCompareGreaterEqual:
.8ea3	fa		plx				plx
.8ea4	20 ad 8e	jsr $8ead			jsr 	CompareBaseCode
.8ea7	c9 ff		cmp #$ff			cmp 	#$FF
.8ea9	d0 b7		bne $8e62			bne 	ReturnTrue
.8eab	80 c1		bra $8e6e			bra 	ReturnFalse
.8ead					CompareBaseCode:
.8ead	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; make both values if references.
.8eb0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8eb3	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8eb6	29 10		and #$10			and 	#NSTString
.8eb8	d0 40		bne $8efa			bne 	_CBCString
.8eba	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8ebd	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8ec0	d0 3b		bne $8efd			bne 	_CBCFloat
.8ec2	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8ec5	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ec8	29 08		and #$08			and 	#NSTFloat
.8eca	d0 31		bne $8efd			bne 	_CBCFloat
.8ecc	20 00 8f	jsr $8f00			jsr 	CompareFixMinusZero
.8ecf	e8		inx				inx
.8ed0	20 00 8f	jsr $8f00			jsr 	CompareFixMinusZero
.8ed3	ca		dex				dex
.8ed4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8ed7	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8eda	10 0b		bpl $8ee7			bpl 	_CDCSameSign
.8edc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8edf	30 16		bmi $8ef7			bmi 	_CBCLess 					; return $FF
.8ee1					_CBCGreater:
.8ee1	a9 01		lda #$01			lda 	#1
.8ee3	60		rts				rts
.8ee4					_CBCEqual:
.8ee4	a9 00		lda #$00			lda 	#0
.8ee6	60		rts				rts
.8ee7					_CDCSameSign:
.8ee7	20 53 91	jsr $9153			jsr 	SubTopTwoStack 				; unsigned subtract
.8eea	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; or the mantissa together
.8eed	f0 f5		beq $8ee4			beq 	_CBCEqual 					; -0 == 0
.8eef	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8ef2	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8ef5	10 ea		bpl $8ee1			bpl 	_CBCGreater
.8ef7					_CBCLess:
.8ef7	a9 ff		lda #$ff			lda 	#$FF
.8ef9	60		rts				rts
.8efa					_CBCString:
.8efa	4c a9 90	jmp $90a9			jmp 	CompareStrings
.8efd					_CBCFloat:
.8efd	4c 8a 94	jmp $948a			jmp 	CompareFloat
.8f00					CompareFixMinusZero:
.8f00	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero
.8f03	d0 03		bne $8f08			bne 	_CFXMZNotZero
.8f05	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8f08					_CFXMZNotZero:
.8f08	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f09					StringConcat:
.8f09	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8f0c	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8f0f	29 18		and #$18			and 	#NSBTypeMask
.8f11	c9 10		cmp #$10			cmp 	#NSTString
.8f13	d0 4e		bne $8f63			bne		_SCType
.8f15	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f17	e8		inx				inx
.8f18	20 36 8f	jsr $8f36			jsr 	_SCSetupZ0 					; setup for second
.8f1b	20 41 8f	jsr $8f41			jsr 	_SCLengthZ0 				; length for second
.8f1e	ca		dex				dex
.8f1f	20 36 8f	jsr $8f36			jsr 	_SCSetupZ0 					; setup for first
.8f22	20 41 8f	jsr $8f41			jsr 	_SCLengthZ0 				; length for first
.8f25	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8f27	20 35 a8	jsr $a835			jsr 	StringTempAllocate
.8f2a	20 54 8f	jsr $8f54			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8f2d	e8		inx				inx
.8f2e	20 36 8f	jsr $8f36			jsr 	_SCSetupZ0 					; copy second out
.8f31	20 54 8f	jsr $8f54			jsr 	_SCCopy
.8f34	ca		dex				dex
.8f35	60		rts				rts
.8f36					_SCSetupZ0:
.8f36	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8f39	85 36		sta $36				sta 	zTemp0
.8f3b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8f3e	85 37		sta $37				sta 	zTemp0+1
.8f40	60		rts				rts
.8f41					_SCLengthZ0:
.8f41	5a		phy				phy
.8f42	a0 00		ldy #$00			ldy 	#0
.8f44					_SCLenLoop:
.8f44	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f46	f0 0a		beq $8f52			beq 	_SCLExit
.8f48	c8		iny				iny
.8f49	e6 38		inc $38				inc 	zTemp1
.8f4b	10 f7		bpl $8f44			bpl		_SCLenLoop
.8f4d	a9 09		lda #$09		lda	#9
.8f4f	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.8f52					_SCLExit:
.8f52	7a		ply				ply
.8f53	60		rts				rts
.8f54					_SCCopy:
.8f54	5a		phy				phy
.8f55	a0 00		ldy #$00			ldy 	#0
.8f57					_SCCopyLoop:
.8f57	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f59	f0 06		beq $8f61			beq 	_SCCExit
.8f5b	20 73 a8	jsr $a873			jsr 	StringTempWrite
.8f5e	c8		iny				iny
.8f5f	80 f6		bra $8f57			bra 	_SCCopyLoop
.8f61					_SCCExit:
.8f61	7a		ply				ply
.8f62	60		rts				rts
.8f63					_SCType:
.8f63	4c 4c a0	jmp $a04c			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8f66					IntegerDivide:
.8f66	fa		plx				plx
.8f67	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f6a	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f6d	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f6e	0a		asl a				asl 	a
.8f6f	10 05		bpl $8f76			bpl 	_NotRef
.8f71	48		pha				pha
.8f72	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f75	68		pla				pla
.8f76					_NotRef:
.8f76	0a		asl a				asl 	a
.8f77	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f79	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f7c	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f7f	f0 03		beq $8f84			beq 	_IntegerCode 				; if clear, then we have two integers
.8f81	4c 4c a0	jmp $a04c			jmp 	TypeError 					; anything else, type mismatch.
.8f84					_IntegerCode:
.8f84	20 a6 8f	jsr $8fa6			jsr 	CheckDivideZero 			; do div zero check
.8f87	20 de 8f	jsr $8fde			jsr 	Int32Divide 				; do the division
.8f8a	20 9b 90	jsr $909b			jsr 	CalculateSign 				; calculate result sign
.8f8d					NSMCopyPlusTwoToZero:
.8f8d	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f90	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8f93	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8f96	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8f99	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8f9c	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8f9f	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8fa2	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8fa5	60		rts				rts
.8fa6					CheckDivideZero:
.8fa6	e8		inx				inx
.8fa7	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero
.8faa	f0 02		beq $8fae			beq 	_CDVError
.8fac	ca		dex				dex
.8fad	60		rts				rts
.8fae					_CDVError:
.8fae	a9 03		lda #$03		lda	#3
.8fb0	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.8fb3					IntegerModulus:
.8fb3	fa		plx				plx
.8fb4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8fb7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8fba	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fbb	0a		asl a				asl 	a
.8fbc	10 05		bpl $8fc3			bpl 	_NotRef
.8fbe	48		pha				pha
.8fbf	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fc2	68		pla				pla
.8fc3					_NotRef:
.8fc3	0a		asl a				asl 	a
.8fc4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8fc6	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fc9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fcc	f0 03		beq $8fd1			beq 	_IntegerCode 				; if clear, then we have two integers
.8fce	4c 4c a0	jmp $a04c			jmp 	TypeError 					; anything else, type mismatch.
.8fd1					_IntegerCode:
.8fd1					IntegerModulusNoCheck:
.8fd1	20 a6 8f	jsr $8fa6			jsr 	CheckDivideZero 			; do div zero check
.8fd4	20 de 8f	jsr $8fde			jsr 	Int32Divide 				; do the division
.8fd7	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8fda	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8fdd	60		rts				rts
.8fde					Int32Divide:
.8fde	48		pha				pha 								; save AXY
.8fdf	5a		phy				phy
.8fe0	20 8f 9e	jsr $9e8f			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fe3	20 b4 9e	jsr $9eb4			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8fe6	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8fe8					_I32DivideLoop:
.8fe8	e8		inx				inx
.8fe9	e8		inx				inx
.8fea	20 cd 9e	jsr $9ecd			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8fed	ca		dex				dex
.8fee	ca		dex				dex
.8fef	20 ce 9e	jsr $9ece			jsr 	NSMRotateLeft
.8ff2	20 1e 90	jsr $901e			jsr 	DivideCheckSubtract 		; check if subtract possible
.8ff5	90 03		bcc $8ffa			bcc 	_I32DivideNoCarryIn
.8ff7	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.8ffa					_I32DivideNoCarryIn:
.8ffa	88		dey				dey 								; loop round till division completed.
.8ffb	d0 eb		bne $8fe8			bne 	_I32DivideLoop
.8ffd	7a		ply				ply 								; restore AXY and exit
.8ffe	68		pla				pla
.8fff	60		rts				rts
.9000					Int32ShiftDivide:
.9000	48		pha				pha 								; save AY
.9001	5a		phy				phy
.9002	e8		inx				inx 								; clear S[X+2]
.9003	e8		inx				inx
.9004	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero
.9007	ca		dex				dex
.9008	ca		dex				dex
.9009	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.900b					_I32SDLoop:
.900b	20 1e 90	jsr $901e			jsr 	DivideCheckSubtract 		; check if subtract possible
.900e	e8		inx				inx
.900f	e8		inx				inx
.9010	20 ce 9e	jsr $9ece			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.9013	ca		dex				dex
.9014	ca		dex				dex
.9015	20 ce 9e	jsr $9ece			jsr 	NSMRotateLeft
.9018	88		dey				dey 	 							; do 31 times
.9019	d0 f0		bne $900b			bne 	_I32SDLoop
.901b	7a		ply				ply 								; restore AY and exit
.901c	68		pla				pla
.901d	60		rts				rts
.901e					DivideCheckSubtract:
.901e	20 53 91	jsr $9153			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9021	b0 04		bcs $9027			bcs 	_DCSExit 					; if carry set, then could do, exit
.9023	20 2d 91	jsr $912d			jsr 	AddTopTwoStack 				; add it back in
.9026	18		clc				clc 								; and return False
.9027					_DCSExit:
.9027	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9028					MulInteger:
.9028	fa		plx				plx
.9029	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.902c	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.902f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9030	0a		asl a				asl 	a
.9031	10 05		bpl $9038			bpl 	_NotRef
.9033	48		pha				pha
.9034	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9037	68		pla				pla
.9038					_NotRef:
.9038	0a		asl a				asl 	a 							; put MSB of type into A:7
.9039	30 0b		bmi $9046			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.903b	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.903e	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9041	f0 06		beq $9049			beq 	_IntegerCode 				; if clear, then we have two integers
.9043	4c 61 95	jmp $9561			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9046					_StringData:
.9046	4c 56 a0	jmp $a056			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9049					_IntegerCode:
.9049	20 56 90	jsr $9056			jsr 	MultiplyShort
.904c	c9 00		cmp #$00			cmp 	#0
.904e	f0 05		beq $9055			beq 	_MIExit
.9050	a9 04		lda #$04		lda	#4
.9052	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.9055					_MIExit:
.9055	60		rts				rts
.9056					MultiplyShort:
.9056	5a		phy				phy 								; save Y
.9057	20 8f 9e	jsr $9e8f			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.905a	20 b4 9e	jsr $9eb4			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.905d	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.905f					_I32MLoop:
.905f	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9062	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.9065	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.9068	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.906b	f0 28		beq $9095			beq 	_I32MExit 					; exit if zero
.906d	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9070	29 01		and #$01			and 	#1
.9072	f0 0e		beq $9082			beq 	_I32MNoAdd
.9074	20 2d 91	jsr $912d			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9077	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.907a	10 06		bpl $9082			bpl 	_I32MNoAdd
.907c					_I32ShiftRight:
.907c	20 db 9e	jsr $9edb			jsr 	NSMShiftRight 				; shift S[X] right
.907f	c8		iny				iny 								; increment shift count
.9080	80 0a		bra $908c			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9082					_I32MNoAdd:
.9082	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9085	70 f5		bvs $907c			bvs 	_I32ShiftRight 				; instead.
.9087	e8		inx				inx
.9088	20 cd 9e	jsr $9ecd			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.908b	ca		dex				dex
.908c					_I32MShiftUpper:
.908c	e8		inx				inx 								; shift S[X+2] right
.908d	e8		inx				inx
.908e	20 db 9e	jsr $9edb			jsr 	NSMShiftRight
.9091	ca		dex				dex
.9092	ca		dex				dex
.9093	80 ca		bra $905f			bra 	_I32MLoop 					; try again.
.9095					_I32MExit:
.9095	20 9b 90	jsr $909b			jsr 	CalculateSign
.9098	98		tya				tya 								; shift in A
.9099	7a		ply				ply 								; restore Y and exit
.909a	60		rts				rts
.909b					CalculateSign:
.909b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.909e	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.90a1	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.90a4	0a		asl a				asl 	a 							; shift bit 7 into carry
.90a5	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.90a8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.90a9					CompareStrings:
.90a9	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.90ac	3d 01 04	and $0401,x			and 	NSStatus+1,x
.90af	29 10		and #$10			and 	#NSBIsString
.90b1	f0 2c		beq $90df			beq 	_CSTypeError
.90b3	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.90b6	85 36		sta $36				sta 	zTemp0
.90b8	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.90bb	85 37		sta $37				sta 	zTemp0+1
.90bd	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.90c0	85 38		sta $38				sta 	zTemp1
.90c2	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.90c5	85 39		sta $39				sta 	zTemp1+1
.90c7	5a		phy				phy 								; save Y so we can access strings
.90c8	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.90ca					_CSLoop:
.90ca	c8		iny				iny
.90cb	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.90cd	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.90cf	d0 06		bne $90d7			bne 	_CSDifferent
.90d1	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.90d3	d0 f5		bne $90ca			bne 	_CSLoop 					; still comparing
.90d5					_CSExit:
.90d5	7a		ply				ply 								; reached end, return zero in A from EOS
.90d6	60		rts				rts
.90d7					_CSDifferent:
.90d7	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.90d9	90 fa		bcc $90d5			bcc		_CSExit
.90db	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.90dd	80 f6		bra $90d5			bra 	_CSExit
.90df					_CSTypeError:
.90df	4c 4c a0	jmp $a04c			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.90e2					ShiftLeft:
.90e2	38		sec				sec
.90e3	80 01		bra $90e6			bra 	ShiftMain
.90e5					ShiftRight:
.90e5	18		clc				clc
.90e6					ShiftMain:
.90e6	fa		plx				plx 								; restore X
.90e7	08		php				php 								; save direction
.90e8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90eb	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90ee	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90ef	0a		asl a				asl 	a
.90f0	10 05		bpl $90f7			bpl 	_NotRef
.90f2	48		pha				pha
.90f3	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90f6	68		pla				pla
.90f7					_NotRef:
.90f7	0a		asl a				asl 	a
.90f8	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90fa	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90fd	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9100	f0 03		beq $9105			beq 	_IntegerCode 				; if clear, then we have two integers
.9102	4c 4c a0	jmp $a04c			jmp 	TypeError 					; anything else, type mismatch.
.9105					_IntegerCode:
.9105	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.9108	29 e0		and #$e0			and 	#$E0
.910a	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.910d	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.9110	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9113	d0 13		bne $9128			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9115					_SMLoop:
.9115	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9118	30 11		bmi $912b			bmi 	_SMExit 					; exit if done.
.911a	28		plp				plp 								; restore direcition setting
.911b	08		php				php
.911c	90 05		bcc $9123			bcc 	_SMRight
.911e	20 cd 9e	jsr $9ecd			jsr 	NSMShiftLeft 				; shift left if CS
.9121	80 f2		bra $9115			bra 	_SMLoop
.9123					_SMRight:
.9123	20 db 9e	jsr $9edb			jsr 	NSMShiftRight 				; shift right if CC
.9126	80 ed		bra $9115			bra 	_SMLoop
.9128					_SMExit0:
.9128	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero 					; return zero.
.912b					_SMExit:
.912b	28		plp				plp 								; throw direction
.912c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.912d					AddTopTwoStack:
.912d	18		clc				clc
.912e	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9131	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.9134	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9137	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.913a	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.913d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9140	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9143	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.9146	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9149	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.914c	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.914f	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9152	60		rts				rts
.9153					SubTopTwoStack:
.9153	38		sec				sec
.9154	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9157	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.915a	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.915d	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9160	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.9163	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9166	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9169	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.916c	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.916f	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9172	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.9175	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9178	60		rts				rts
.9179					AddInteger:
.9179	fa		plx				plx
.917a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.917d	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9180	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9181	0a		asl a				asl 	a
.9182	10 05		bpl $9189			bpl 	_NotRef
.9184	48		pha				pha
.9185	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9188	68		pla				pla
.9189					_NotRef:
.9189	0a		asl a				asl 	a 							; put MSB of type into A:7
.918a	30 0b		bmi $9197			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.918c	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.918f	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9192	f0 06		beq $919a			beq 	_IntegerCode 				; if clear, then we have two integers
.9194	4c e1 93	jmp $93e1			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9197					_StringData:
.9197	4c 09 8f	jmp $8f09			jmp 	StringConcat							; at least one string - don't know both are strings.
.919a					_IntegerCode:
.919a					AddCode:
.919a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.919d	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.91a0	10 8b		bpl $912d			bpl 	AddTopTwoStack
.91a2	20 53 91	jsr $9153			jsr 	SubTopTwoStack 				; do a physical subtraction
.91a5	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.91a8	10 09		bpl $91b3			bpl 	_AddExit
.91aa	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.91ad	9d 00 04	sta $0400,x			sta 	NSStatus,x
.91b0	20 6d 9e	jsr $9e6d			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.91b3					_AddExit:
.91b3	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; check for -0
.91b6	d0 03		bne $91bb			bne 	_AddNonZero
.91b8	9e 00 04	stz $0400,x			stz 	NSStatus,x
.91bb					_AddNonZero:
.91bb	60		rts				rts
.91bc					SubInteger:
.91bc	fa		plx				plx
.91bd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91c0	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91c3	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91c4	0a		asl a				asl 	a
.91c5	10 05		bpl $91cc			bpl 	_NotRef
.91c7	48		pha				pha
.91c8	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91cb	68		pla				pla
.91cc					_NotRef:
.91cc	0a		asl a				asl 	a 							; put MSB of type into A:7
.91cd	30 0b		bmi $91da			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91cf	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91d2	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91d5	f0 06		beq $91dd			beq 	_IntegerCode 				; if clear, then we have two integers
.91d7	4c e6 93	jmp $93e6			jmp 	FloatingPointSub 							; otherwise at least one float.
.91da					_StringData:
.91da	4c 56 a0	jmp $a056			jmp 	NotDoneError							; at least one string - don't know both are strings.
.91dd					_IntegerCode:
.91dd	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.91e0	49 80		eor #$80			eor 	#$80
.91e2	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.91e5	80 b3		bra $919a			bra 	AddCode 					; and do the same code as add.
.91e7					AndInteger:
.91e7	fa		plx				plx
.91e8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91eb	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91ee	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91ef	0a		asl a				asl 	a
.91f0	10 05		bpl $91f7			bpl 	_NotRef
.91f2	48		pha				pha
.91f3	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f6	68		pla				pla
.91f7					_NotRef:
.91f7	0a		asl a				asl 	a
.91f8	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91fa	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91fd	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9200	f0 03		beq $9205			beq 	_IntegerCode 				; if clear, then we have two integers
.9202	4c 4c a0	jmp $a04c			jmp 	TypeError 					; anything else, type mismatch.
.9205					_IntegerCode:
.9205	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9208	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.920b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.920e	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9211	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.9214	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9217	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.921a	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.921d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9220	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9223	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.9226	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9229	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.922c	60		rts				rts
.922d					OraInteger:
.922d	fa		plx				plx
.922e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9231	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9234	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9235	0a		asl a				asl 	a
.9236	10 05		bpl $923d			bpl 	_NotRef
.9238	48		pha				pha
.9239	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.923c	68		pla				pla
.923d					_NotRef:
.923d	0a		asl a				asl 	a
.923e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9240	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9243	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9246	f0 03		beq $924b			beq 	_IntegerCode 				; if clear, then we have two integers
.9248	4c 4c a0	jmp $a04c			jmp 	TypeError 					; anything else, type mismatch.
.924b					_IntegerCode:
.924b	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.924e	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.9251	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9254	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9257	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.925a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.925d	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9260	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.9263	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9266	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9269	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.926c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.926f	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9272	60		rts				rts
.9273					EorInteger:
.9273	fa		plx				plx
.9274	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9277	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.927a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.927b	0a		asl a				asl 	a
.927c	10 05		bpl $9283			bpl 	_NotRef
.927e	48		pha				pha
.927f	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9282	68		pla				pla
.9283					_NotRef:
.9283	0a		asl a				asl 	a
.9284	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9286	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9289	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.928c	f0 03		beq $9291			beq 	_IntegerCode 				; if clear, then we have two integers
.928e	4c 4c a0	jmp $a04c			jmp 	TypeError 					; anything else, type mismatch.
.9291					_IntegerCode:
.9291	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9294	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.9297	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.929a	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.929d	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.92a0	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.92a3	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.92a6	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.92a9	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.92ac	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.92af	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.92b2	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.92b5	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.92b8	60		rts				rts
.92b9					WordIndirect:
.92b9	fa		plx				plx
.92ba	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92bd	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92c0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92c1	0a		asl a				asl 	a
.92c2	10 05		bpl $92c9			bpl 	_NotRef
.92c4	48		pha				pha
.92c5	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92c8	68		pla				pla
.92c9					_NotRef:
.92c9	0a		asl a				asl 	a
.92ca	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92cc	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92cf	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92d2	f0 03		beq $92d7			beq 	_IntegerCode 				; if clear, then we have two integers
.92d4	4c 4c a0	jmp $a04c			jmp 	TypeError 					; anything else, type mismatch.
.92d7					_IntegerCode:
.92d7	20 9a 91	jsr $919a			jsr 	AddCode 					; add the two values
.92da	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.92dc	9d 00 04	sta $0400,x			sta 	NSStatus,x
.92df	60		rts				rts
.92e0					ByteIndirect:
.92e0	fa		plx				plx
.92e1	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92e4	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92e7	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92e8	0a		asl a				asl 	a
.92e9	10 05		bpl $92f0			bpl 	_NotRef
.92eb	48		pha				pha
.92ec	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92ef	68		pla				pla
.92f0					_NotRef:
.92f0	0a		asl a				asl 	a
.92f1	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92f3	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92f6	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92f9	f0 03		beq $92fe			beq 	_IntegerCode 				; if clear, then we have two integers
.92fb	4c 4c a0	jmp $a04c			jmp 	TypeError 					; anything else, type mismatch.
.92fe					_IntegerCode:
.92fe	20 9a 91	jsr $919a			jsr 	AddCode 					; add the two values
.9301	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9303	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9306	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9307					LCLConvertInt16:
.9307	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.930a	8e 10 04	stx $0410			stx 	NSMantissa1
.930d	9c 18 04	stz $0418			stz 	NSMantissa2
.9310	9c 20 04	stz $0420			stz 	NSMantissa3
.9313	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.9316	a2 00		ldx #$00			ldx 	#0 							; stack level
.9318	a9 0a		lda #$0a			lda 	#10 						; base
.931a	80 00		bra $931c			bra 	ConvertInt32
.931c					ConvertInt32:
.931c	5a		phy				phy
.931d	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.931f	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.9322	10 08		bpl $932c			bpl 	_CI32NotNeg
.9324	48		pha				pha
.9325	a9 2d		lda #$2d			lda 	#'-'
.9327	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.932a	c8		iny				iny
.932b	68		pla				pla
.932c					_CI32NotNeg:
.932c	20 3a 93	jsr $933a			jsr 	_CI32DivideConvert 			; recursive conversion
.932f	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9331	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.9334	7a		ply				ply
.9335	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.9337	a9 fa		lda #$fa			lda 	#NumberBuffer & $FF
.9339	60		rts				rts
.933a					_CI32DivideConvert:
.933a	e8		inx				inx 								; write to next slot up
.933b	20 ba 9e	jsr $9eba			jsr 	NSMSetByte
.933e	ca		dex				dex
.933f	20 de 8f	jsr $8fde			jsr 	Int32Divide 				; divide
.9342	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.9345	48		pha				pha
.9346	20 8d 8f	jsr $8f8d			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.9349	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; is it zero ?
.934c	f0 06		beq $9354			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.934e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9351	20 3a 93	jsr $933a			jsr 	_CI32DivideConvert 			; and recusrively call.
.9354					_CI32NoRecurse:
.9354	68		pla				pla 								; remainder
.9355	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.9357	90 02		bcc $935b			bcc 	_CI32NotHex
.9359	69 26		adc #$26			adc 	#6+32
.935b					_CI32NotHex:
.935b	69 30		adc #$30			adc 	#48
.935d	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y 				; write out and exit
.9360	c8		iny				iny
.9361	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9362					PrecedenceLevel:
>9362	04					.byte	 4	; $00 <<
>9363	02					.byte	 2	; $01 <=
>9364	02					.byte	 2	; $02 <>
>9365	00					.byte	 0	; $03 !!3
>9366	00					.byte	 0	; $04 ><
>9367	02					.byte	 2	; $05 >=
>9368	04					.byte	 4	; $06 >>
>9369	00					.byte	 0	; $07 !!7
>936a	00					.byte	 0	; $08 !!8
>936b	00					.byte	 0	; $09 !!9
>936c	00					.byte	 0	; $0a !!10
>936d	00					.byte	 0	; $0b !!11
>936e	00					.byte	 0	; $0c !!12
>936f	00					.byte	 0	; $0d !!13
>9370	00					.byte	 0	; $0e !!14
>9371	00					.byte	 0	; $0f !!15
>9372	00					.byte	 0	; $10 @
>9373	00					.byte	 0	; $11 !!17
>9374	00					.byte	 0	; $12 !!18
>9375	00					.byte	 0	; $13 [
>9376	04					.byte	 4	; $14 \
>9377	00					.byte	 0	; $15 ]
>9378	01					.byte	 1	; $16 ^
>9379	00					.byte	 0	; $17 _
>937a	00					.byte	 0	; $18 `
>937b	00					.byte	 0	; $19 !!25
>937c	00					.byte	 0	; $1a !!26
>937d	00					.byte	 0	; $1b {
>937e	01					.byte	 1	; $1c |
>937f	00					.byte	 0	; $1d }
>9380	00					.byte	 0	; $1e ~
>9381	00					.byte	 0	; $1f [7m<7F>[m
>9382	00					.byte	 0	; $20
>9383	05					.byte	 5	; $21 !
>9384	00					.byte	 0	; $22 "
>9385	00					.byte	 0	; $23 #
>9386	05					.byte	 5	; $24 $
>9387	04					.byte	 4	; $25 %
>9388	01					.byte	 1	; $26 &
>9389	00					.byte	 0	; $27 '
>938a	00					.byte	 0	; $28 (
>938b	00					.byte	 0	; $29 )
>938c	04					.byte	 4	; $2a *
>938d	03					.byte	 3	; $2b +
>938e	00					.byte	 0	; $2c ,
>938f	03					.byte	 3	; $2d -
>9390	00					.byte	 0	; $2e .
>9391	04					.byte	 4	; $2f /
>9392	00					.byte	 0	; $30 0
>9393	00					.byte	 0	; $31 1
>9394	00					.byte	 0	; $32 2
>9395	00					.byte	 0	; $33 3
>9396	00					.byte	 0	; $34 4
>9397	00					.byte	 0	; $35 5
>9398	00					.byte	 0	; $36 6
>9399	00					.byte	 0	; $37 7
>939a	00					.byte	 0	; $38 8
>939b	00					.byte	 0	; $39 9
>939c	00					.byte	 0	; $3a :
>939d	00					.byte	 0	; $3b ;
>939e	02					.byte	 2	; $3c <
>939f	02					.byte	 2	; $3d =
>93a0	02					.byte	 2	; $3e >
>93a1	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93a2					EvaluateExpressionAt0:
.93a2	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93a4					EvaluateExpression:
.93a4	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93a6					EvaluateExpressionAtPrecedence:
.93a6	48		pha				pha 								; save precedence level
.93a7	20 7e 98	jsr $987e			jsr 	EvaluateTerm 				; evaluate term into level X.
.93aa	68		pla				pla 								; restore precedence level.
.93ab					_EXPRLoop:
.93ab	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.93ad	b1 30		lda ($30),y			lda 	(codePtr),y
.93af	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.93b1	b0 25		bcs $93d8			bcs 	_EXPRExit
.93b3	da		phx				phx 								; read the operator precedence
.93b4	aa		tax				tax
.93b5	bd 62 93	lda $9362,x			lda 	PrecedenceLevel,x
.93b8	fa		plx				plx
.93b9	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.93bb	f0 1b		beq $93d8			beq 	_EXPRExit
.93bd	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93bf	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93c1	c5 37		cmp $37				cmp 	zTemp0+1
.93c3	b0 13		bcs $93d8			bcs		_EXPRExit 					; if current >= operator exit
.93c5	48		pha				pha 								; save current precedence.
.93c6	b1 30		lda ($30),y			lda 	(codePtr),y
.93c8	c8		iny				iny
.93c9	48		pha				pha
.93ca	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93cc	e8		inx				inx 								; work out the right hand side.
.93cd	20 a6 93	jsr $93a6			jsr 	EvaluateExpressionAtPrecedence
.93d0	ca		dex				dex
.93d1	68		pla				pla 								; get operator, call the code.
.93d2	20 db 93	jsr $93db			jsr 	_EXPRCaller
.93d5	68		pla				pla 								; restore precedence level
.93d6	80 d3		bra $93ab			bra 	_EXPRLoop 					; and go round.
.93d8					_EXPRExit:
.93d8	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93da	60		rts				rts
.93db					_EXPRCaller:
.93db	da		phx				phx 								; save on stack, first thing is to restore it
.93dc	0a		asl a				asl 	a 							; double so can use vectors into X
.93dd	aa		tax				tax
.93de	7c 1c 8b	jmp ($8b1c,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.93e1					FloatingPointAdd:
.93e1	20 8a 95	jsr $958a			jsr 	FloatPrepare 				; prepare for floats
.93e4	80 0b		bra $93f1			bra 	FloatAdd
.93e6					FloatingPointSub:
.93e6	20 8a 95	jsr $958a			jsr 	FloatPrepare 				; prepare for floats
.93e9					FloatSubtract:
.93e9	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.93ec	49 80		eor #$80			eor 	#$80
.93ee	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.93f1					FloatAdd:
.93f1	48		pha				pha
.93f2	5a		phy				phy
.93f3	20 9b 95	jsr $959b			jsr 	NSNormalise 				; normalise S[X]
.93f6	f0 5c		beq $9454			beq 	_FAReturn1
.93f8	e8		inx				inx 								; normalise S[X+1]
.93f9	20 9b 95	jsr $959b			jsr 	NSNormalise
.93fc	ca		dex				dex
.93fd	c9 00		cmp #$00			cmp 	#0
.93ff	f0 77		beq $9478			beq 	_FAExit 					; if so, just return A
.9401	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.9404	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.9407	f0 1b		beq $9424			beq 	_FAExponentsEqual
.9409	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.940c	a8		tay				tay
.940d	38		sec				sec 								; do a signed comparison of the exponents.
.940e	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9411	50 02		bvc $9415			bvc 	_FANoSignedChange
.9413	49 80		eor #$80			eor 	#$80
.9415					_FANoSignedChange:
.9415	29 80		and #$80			and 	#$80
.9417	10 03		bpl $941c			bpl 	_FAHaveMax
.9419	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.941c					_FAHaveMax:
.941c	20 7b 94	jsr $947b			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.941f	e8		inx				inx
.9420	20 7b 94	jsr $947b			jsr 	_FAShiftToExponent
.9423	ca		dex				dex
.9424					_FAExponentsEqual:
.9424	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.9427	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.942a	30 10		bmi $943c			bmi 	_FADifferentSigns
.942c	20 2d 91	jsr $912d			jsr 	AddTopTwoStack 				; do the add of the mantissae
.942f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9432	10 44		bpl $9478			bpl 	_FAExit 					; if no, we are done.
.9434	20 db 9e	jsr $9edb			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9437	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.943a	80 3c		bra $9478			bra 	_FAExit
.943c					_FADifferentSigns:
.943c	20 53 91	jsr $9153			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.943f	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.9442	10 06		bpl $944a			bpl 	_FACheckZero 				; if no, check for -0
.9444	20 64 9e	jsr $9e64			jsr 	NSMNegate 					; netate result
.9447	20 6d 9e	jsr $9e6d			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.944a					_FACheckZero:
.944a	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero	 				; check for -0
.944d	d0 29		bne $9478			bne 	_FAExit
.944f	9e 00 04	stz $0400,x			stz 	NSStatus,x
.9452	80 24		bra $9478			bra 	_FAExit
.9454					_FAReturn1:
.9454	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9457	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.945a	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.945d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9460	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9463	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9466	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9469	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.946c	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.946f	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9472	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9475	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9478					_FAExit:
.9478	7a		ply				ply
.9479	68		pla				pla
.947a	60		rts				rts
.947b					_FAShiftToExponent:
.947b					_FAShiftToExponent2:
.947b	98		tya				tya 								; compare Y to exponent
.947c	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.947f	f0 08		beq $9489			beq 	_FASEExit 					; exit if so.
.9481	20 db 9e	jsr $9edb			jsr 	NSMShiftRight	 			; shift the mantissa right
.9484	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.9487	80 f2		bra $947b			bra 	_FAShiftToExponent2
.9489					_FASEExit:
.9489	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.948a					CompareFloat:
.948a	20 e9 93	jsr $93e9			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.948d	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9490	29 f8		and #$f8			and 	#$F8
.9492	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9495	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.9498	f0 09		beq $94a3			beq 	_FCExit 					; zero, so approximately identical
.949a	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.949c	3c 00 04	bit $0400,x			bit 	NSStatus,x
.949f	10 02		bpl $94a3			bpl 	_FCExit
.94a1					_FCNegative:
.94a1	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94a3					_FCExit:
.94a3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94a4					FDivideCommand:
.94a4	fa		plx				plx	 								; restore stack position
.94a5	20 8a 95	jsr $958a			jsr 	FloatPrepare 				; prepare for floats
.94a8					FloatDivide:
.94a8	48		pha				pha
.94a9	e8		inx				inx
.94aa	20 9b 95	jsr $959b			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94ad	ca		dex				dex
.94ae	c9 00		cmp #$00			cmp 	#0
.94b0	f0 20		beq $94d2			beq 	_FDZero
.94b2	20 9b 95	jsr $959b			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94b5	f0 19		beq $94d0			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94b7	20 00 90	jsr $9000			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94ba	20 8d 8f	jsr $8f8d			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94bd	20 9b 95	jsr $959b			jsr		NSNormalise 				; renormalise
.94c0	20 9b 90	jsr $909b			jsr 	CalculateSign 				; calculate result sign
.94c3	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.94c6	38		sec				sec
.94c7	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.94ca	38		sec				sec
.94cb	e9 1e		sbc #$1e			sbc 	#30
.94cd	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94d0					_FDExit:
.94d0	68		pla				pla
.94d1	60		rts				rts
.94d2					_FDZero:
.94d2	a9 03		lda #$03		lda	#3
.94d4	4c f5 8d	jmp $8df5		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.94d7					FloatFractionalPart:
.94d7	5a		phy				phy
.94d8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.94db	29 7f		and #$7f			and 	#$7F
.94dd	9d 00 04	sta $0400,x			sta 	NSStatus,x
.94e0	20 9b 95	jsr $959b			jsr 	NSNormalise
.94e3	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.94e6	38		sec				sec
.94e7	e9 e0		sbc #$e0			sbc 	#$E0
.94e9	90 31		bcc $951c			bcc 	_FFPExit 					; already fractional
.94eb	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.94ed	b0 2a		bcs $9519			bcs 	_FFPZero
.94ef	a8		tay				tay 								; put count to do in Y
.94f0	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.94f3	20 1e 95	jsr $951e			jsr 	_FFPPartial
.94f6	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.94f9	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.94fc	20 1e 95	jsr $951e			jsr 	_FFPPartial
.94ff	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9502	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9505	20 1e 95	jsr $951e			jsr 	_FFPPartial
.9508	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.950b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.950e	20 1e 95	jsr $951e			jsr 	_FFPPartial
.9511	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9514	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; zeroed check.
.9517	d0 03		bne $951c			bne 	_FFPExit
.9519					_FFPZero:
.9519	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero
.951c					_FFPExit:
.951c	7a		ply				ply
.951d	60		rts				rts
.951e					_FFPPartial:
.951e	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9520	f0 17		beq $9539			beq 	_FFFPPExit
.9522	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9524	b0 0c		bcs $9532			bcs 	_FFFPPWholeByte
.9526	5a		phy				phy
.9527					_FFFPPLeft:
.9527	0a		asl a				asl 	a
.9528	88		dey				dey
.9529	d0 fc		bne $9527			bne 	_FFFPPLeft
.952b	7a		ply				ply
.952c					_FFFPPRight:
.952c	4a		lsr a				lsr 	a
.952d	88		dey				dey
.952e	d0 fc		bne $952c			bne 	_FFFPPRight
.9530	80 07		bra $9539			bra 	_FFFPPExit
.9532					_FFFPPWholeByte:
.9532	98		tya				tya 								; subtract 8 from count
.9533	38		sec				sec
.9534	e9 08		sbc #$08			sbc 	#8
.9536	a8		tay				tay
.9537	a9 00		lda #$00			lda 	#0 							; and clear all
.9539					_FFFPPExit:
.9539	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.953a					FloatIntegerPart:
.953a	48		pha				pha
.953b	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.953e	f0 1f		beq $955f			beq 	_FIPExit 					; if so do nothing
.9540	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; is it zero ?
.9543	f0 17		beq $955c			beq 	_FIPZero 					; if so return zero.
.9545	20 9b 95	jsr $959b			jsr 	NSNormalise 				; normalise
.9548	f0 12		beq $955c			beq 	_FIPZero 					; normalised to zero, exit zero
.954a					_FIPShift:
.954a	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.954d	10 08		bpl $9557			bpl 	_FIPCheckZero
.954f	20 db 9e	jsr $9edb			jsr 	NSMShiftRight 				; shift mantissa right
.9552	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.9555	80 f3		bra $954a			bra 	_FIPShift
.9557					_FIPCheckZero:
.9557	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; avoid -0 problem
.955a	d0 03		bne $955f			bne 	_FIPExit 					; set to zero if mantissa zero.
.955c					_FIPZero:
.955c	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero
.955f					_FIPExit:
.955f	68		pla				pla
.9560	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9561					FloatingPointMultiply:
.9561	20 8a 95	jsr $958a			jsr 	FloatPrepare 				; prepare for floats
.9564					FloatMultiply:
.9564	48		pha				pha
.9565	20 9b 95	jsr $959b			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9568	f0 1b		beq $9585			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.956a	e8		inx				inx
.956b	20 9b 95	jsr $959b			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.956e	ca		dex				dex
.956f	c9 00		cmp #$00			cmp 	#0
.9571	f0 0f		beq $9582			beq 	_FDSetZero
.9573	20 56 90	jsr $9056			jsr 	MultiplyShort 				; calculate the result.
.9576	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9579	18		clc				clc
.957a	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.957d	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9580	80 03		bra $9585			bra 	_FDExit
.9582					_FDSetZero:
.9582	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero 					; return 0
.9585					_FDExit:
.9585	20 9b 95	jsr $959b			jsr 	NSNormalise 				; normalise the result
.9588	68		pla				pla
.9589	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.958a					FloatPrepare:
.958a	20 bd 96	jsr $96bd			jsr 	DereferenceTopTwo 			; dereference the top two values
.958d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.9590	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9593	29 10		and #$10			and 	#NSBIsString
.9595	d0 01		bne $9598			bne 	_FDType
.9597	60		rts				rts
.9598					_FDType:
.9598	4c 4c a0	jmp $a04c			jmp 	TypeError
.959b					NSNormalise:
.959b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.959e	29 80		and #$80			and 	#$80
.95a0	09 08		ora #$08			ora 	#NSTFloat
.95a2	9d 00 04	sta $0400,x			sta 	NSStatus,x
.95a5	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; if zero exit
.95a8	d0 09		bne $95b3			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95aa	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.95ad	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.95b0	a9 00		lda #$00			lda 	#0 							; set Z flag
.95b2	60		rts				rts
.95b3					_NSNormaliseOptimise:
.95b3	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95b6	d0 22		bne $95da			bne 	_NSNormaliseLoop
.95b8	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.95bb	30 1d		bmi $95da			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95bd	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.95c0	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95c3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.95c6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95c9	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.95cc	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.95cf	bd 28 04	lda $0428,x			lda 	NSExponent,x
.95d2	38		sec				sec
.95d3	e9 08		sbc #$08			sbc 	#8
.95d5	9d 28 04	sta $0428,x			sta 	NSExponent,x
.95d8	80 d9		bra $95b3			bra 	_NSNormaliseOptimise
.95da					_NSNormaliseLoop:
.95da	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95dd	70 08		bvs $95e7			bvs 	_NSNExit 					; exit if so with Z flag clear
.95df	20 cd 9e	jsr $9ecd			jsr 	NSMShiftLeft 				; shift mantissa left
.95e2	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.95e5	80 f3		bra $95da			bra 	_NSNormaliseLoop
.95e7					_NSNExit:
.95e7	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95e9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.95ea					AssignNumber:
.95ea	5a		phy				phy
.95eb	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.95ee	85 36		sta $36				sta 	zTemp0
.95f0	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95f3	85 37		sta $37				sta 	zTemp0+1
.95f5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.95f8	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.95fa	9d 00 04	sta $0400,x			sta 	NSStatus,x
.95fd	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.95ff	c9 08		cmp #$08			cmp 	#NSTFloat
.9601	f0 2a		beq $962d			beq 	_ANFloat
.9603	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.9606	f0 05		beq $960d			beq		_ANNotFloat
.9608	e8		inx				inx
.9609	20 3a 95	jsr $953a			jsr 	FloatIntegerPart 			; make it an integer
.960c	ca		dex				dex
.960d					_ANNotFloat:
.960d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.9610	29 03		and #$03			and 	#3
.9612	d0 05		bne $9619			bne 	_ANByteWord
.9614	20 39 96	jsr $9639			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9617	80 1e		bra $9637			bra 	_ANExit
.9619					_ANByteWord:
.9619	48		pha				pha 								; save count
.961a	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.961d	92 36		sta ($36)			sta 	(zTemp0)
.961f	68		pla				pla
.9620	c9 01		cmp #$01			cmp	 	#1
.9622	f0 13		beq $9637			beq 	_ANExit
.9624	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.9627	a0 01		ldy #$01			ldy 	#1
.9629	91 36		sta ($36),y			sta 	(zTemp0),y
.962b	80 0a		bra $9637			bra 	_ANExit
.962d					_ANFloat:
.962d	20 39 96	jsr $9639			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9630	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9633	a0 04		ldy #$04			ldy 	#4
.9635	91 36		sta ($36),y			sta 	(zTemp0),y
.9637					_ANExit:
.9637	7a		ply				ply
.9638	60		rts				rts
.9639					_ANCopy4PackSign:
.9639	a0 03		ldy #$03			ldy 	#3
.963b	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.963e	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9640	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9643	91 36		sta ($36),y			sta 	(zTemp0),y
.9645	88		dey				dey
.9646	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9649	91 36		sta ($36),y			sta 	(zTemp0),y
.964b	88		dey				dey
.964c	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.964f	91 36		sta ($36),y			sta 	(zTemp0),y
.9651	88		dey				dey
.9652	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9655	91 36		sta ($36),y			sta 	(zTemp0),y
.9657	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9658					AssignString:
.9658	5a		phy				phy
.9659	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.965c	85 38		sta $38				sta 	zTemp1
.965e	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9661	85 39		sta $39				sta 	zTemp1+1
.9663	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9666	85 36		sta $36				sta 	zTemp0
.9668	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.966b	85 37		sta $37				sta 	zTemp0+1
.966d	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.966f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9671	f0 23		beq $9696			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9673	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9674	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9676	e9 02		sbc #$02			sbc 	#2
.9678	85 3c		sta $3c				sta 	zsTemp
.967a	a0 01		ldy #$01			ldy 	#1
.967c	b1 36		lda ($36),y			lda 	(zTemp0),y
.967e	e9 00		sbc #$00			sbc 	#0
.9680	85 3d		sta $3d				sta 	zsTemp+1
.9682	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9684					_ASGetLength:
.9684	c8		iny				iny
.9685	b1 38		lda ($38),y			lda 	(zTemp1),y
.9687	d0 fb		bne $9684			bne 	_ASGetLength
.9689	98		tya				tya 								; is this length <= current length
.968a	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.968c	90 20		bcc $96ae			bcc 	_ASCopyString
.968e	f0 1e		beq $96ae			beq 	_ASCopyString
.9690	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9692	a0 01		ldy #$01			ldy 	#1
.9694	91 3c		sta ($3c),y			sta 	(zsTemp),y
.9696					_ASNewStringRequired:
.9696	e8		inx				inx 								; concrete the new string.
.9697	20 b4 a7	jsr $a7b4			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.969a	ca		dex				dex
.969b	18		clc				clc
.969c	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.969f	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96a1	92 36		sta ($36)			sta 	(zTemp0)
.96a3	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.96a6	69 00		adc #$00			adc 	#0
.96a8	a0 01		ldy #$01			ldy 	#1
.96aa	91 36		sta ($36),y			sta 	(zTemp0),y
.96ac	80 0d		bra $96bb			bra 	_ASExit
.96ae					_ASCopyString:
.96ae	a0 00		ldy #$00			ldy 	#0
.96b0					_ASCopyLoop:
.96b0	b1 38		lda ($38),y			lda 	(zTemp1),y
.96b2	c8		iny				iny
.96b3	c8		iny				iny
.96b4	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96b6	88		dey				dey
.96b7	c9 00		cmp #$00			cmp 	#0
.96b9	d0 f5		bne $96b0			bne 	_ASCopyLoop
.96bb					_ASExit:
.96bb	7a		ply				ply
.96bc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96bd					DereferenceTopTwo:
.96bd	e8		inx				inx
.96be	20 c2 96	jsr $96c2			jsr 	Dereference 				; deref x+1
.96c1	ca		dex				dex  								; falls through to deref x
.96c2					Dereference:
.96c2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.96c5	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.96c7	f0 57		beq $9720			beq 	_DRFExit 					; not a reference
.96c9	5a		phy				phy
.96ca	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96cd	85 36		sta $36				sta 	zTemp0
.96cf	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.96d2	85 37		sta $37				sta 	zTemp0+1
.96d4	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.96d7	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96d9	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.96dc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.96df	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96e1	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96e3	f0 0f		beq $96f4			beq 	_DRFDereferenceTwo
.96e5	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96e7	f0 39		beq $9722			beq 	_DRFFull
.96e9	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96ec	29 03		and #$03			and 	#3
.96ee	f0 32		beq $9722			beq 	_DRFFull 					; the whole word
.96f0	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96f2	f0 07		beq $96fb			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96f4					_DRFDereferenceTwo:
.96f4	a0 01		ldy #$01			ldy 	#1
.96f6	b1 36		lda ($36),y			lda 	(zTemp0),y
.96f8	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.96fb					_DRFClear23:
.96fb	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.96fe	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9701	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.9704	29 18		and #$18			and 	#NSBTypeMask
.9706	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9709	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.970b	d0 12		bne $971f			bne 	_DRFNotString
.970d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.9710	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9713	d0 0a		bne $971f			bne 	_DRFNotString
.9715	a9 21		lda #$21			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9717	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.971a	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.971c	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.971f					_DRFNotString
.971f	7a		ply				ply 								; restore Y and exit
.9720					_DRFExit:
.9720	60		rts				rts
.9721					_DRFNullString:
>9721	00						.byte 	0
.9722					_DRFFull:
.9722	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9724	b1 36		lda ($36),y			lda 	(zTemp0),y
.9726	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9729	c8		iny				iny
.972a	b1 36		lda ($36),y			lda 	(zTemp0),y
.972c	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.972f	c8		iny				iny
.9730	b1 36		lda ($36),y			lda 	(zTemp0),y
.9732	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9735	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.9738	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.973b	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.973d	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.9740	f0 06		beq $9748			beq 	_DRFNoExponent
.9742	c8		iny				iny 								; if not, read the exponent as well.
.9743	b1 36		lda ($36),y			lda 	(zTemp0),y
.9745	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9748					_DRFNoExponent:
.9748	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.974b	10 0d		bpl $975a			bpl 	_DRFExit2 					; if not, then exit.
.974d	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.974f	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9752	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.9755	09 80		ora #$80			ora 	#NSBIsNegative
.9757	9d 00 04	sta $0400,x			sta 	NSStatus,x
.975a					_DRFExit2:
.975a	7a		ply				ply
.975b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.975c					EncodeNumberStart:
.975c	38		sec				sec
.975d	80 01		bra $9760			bra 	EncodeNumberContinue+1
.975f					EncodeNumberContinue:
.975f	18		clc				clc
.9760					EncodeNumber:
.9760	08		php				php 								; save reset.
.9761	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9763	f0 12		beq $9777			beq 	_ENIsOkay
.9765	c9 30		cmp #$30			cmp 	#"0"
.9767	90 04		bcc $976d			bcc 	_ENBadNumber
.9769	c9 3a		cmp #$3a			cmp 	#"9"+1
.976b	90 0a		bcc $9777			bcc 	_ENIsOkay
.976d					_ENBadNumber:
.976d	28		plp				plp 								; throw saved reset
.976e	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.9771	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9773	f0 7e		beq $97f3			beq 	_ENConstructFinal
.9775					_ENFail:
.9775	18		clc				clc 								; not allowed
.9776	60		rts				rts
.9777					_ENIsOkay:
.9777	28		plp				plp 								; are we restarting
.9778	90 15		bcc $978f			bcc 	_ENNoRestart
.977a					_ENStartEncode:
.977a	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.977c	f0 0c		beq $978a			beq 	_ENFirstDP
.977e	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.9780	20 ba 9e	jsr $9eba			jsr 	NSMSetByte
.9783	a9 01		lda #$01			lda 	#ESTA_Low
.9785					_ENExitChange:
.9785	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.9788	38		sec				sec
.9789	60		rts				rts
.978a					_ENFirstDP:
.978a	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero 					; clear integer part
.978d	80 3f		bra $97ce			bra 	_ESTASwitchFloat			; go straight to float and exi
.978f					_ENNoRestart:
.978f	48		pha				pha 								; save on stack.
.9790	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.9793	c9 01		cmp #$01			cmp 	#ESTA_Low
.9795	f0 09		beq $97a0			beq  	_ESTALowState
.9797	c9 02		cmp #$02			cmp 	#ESTA_High
.9799	f0 29		beq $97c4			beq 	_ESTAHighState
.979b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.979d	f0 3b		beq $97da			beq 	_ESTADecimalState
>979f	db						.byte 	$DB 						; causes a break in the emulator
.97a0					_ESTALowState:
.97a0	68		pla				pla 								; get value back
.97a1	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.97a3	f0 29		beq $97ce			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.97a5	29 0f		and #$0f			and 	#15 						; make digit
.97a7	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.97aa	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97ad	0a		asl a				asl 	a
.97ae	0a		asl a				asl 	a
.97af	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97b2	0a		asl a				asl 	a
.97b3	6d 86 04	adc $0486			adc 	DigitTemp
.97b6	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97b9	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97bb	90 05		bcc $97c2			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97bd	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97bf	8d 85 04	sta $0485			sta 	EncodeState
.97c2					_ESTANoSwitch:
.97c2	38		sec				sec
.97c3	60		rts				rts
.97c4					_ESTAHighState:
.97c4	68		pla				pla 								; get value back
.97c5	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97c7	f0 05		beq $97ce			beq 	_ESTASwitchFloat
.97c9	20 2d 98	jsr $982d			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97cc	38		sec				sec
.97cd	60		rts				rts
.97ce					_ESTASwitchFloat:
.97ce	9c 87 04	stz $0487			stz 	DecimalCount
.97d1	e8		inx				inx 								; zero the decimal additive.
.97d2	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero
.97d5	ca		dex				dex
.97d6	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97d8	80 ab		bra $9785			bra 	_ENExitChange
.97da					_ESTADecimalState:
.97da	68		pla				pla 								; digit.
.97db	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97dd	f0 96		beq $9775			beq 	_ENFail
.97df	e8		inx				inx 								; put digit into fractional part of X+1
.97e0	20 2d 98	jsr $982d			jsr 	ESTAShiftDigitIntoMantissa
.97e3	ca		dex				dex
.97e4	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.97e7	ad 87 04	lda $0487			lda 	DecimalCount
.97ea	c9 0b		cmp #$0b			cmp 	#11
.97ec	f0 02		beq $97f0			beq 	_ESTADSFail
.97ee	38		sec				sec
.97ef	60		rts				rts
.97f0					_ESTADSFail:
.97f0	4c 47 a0	jmp $a047			jmp 	RangeError
.97f3					_ENConstructFinal:
.97f3	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.97f6	f0 33		beq $982b			beq 	_ENCFExit 					; no decimals
.97f8	5a		phy				phy
.97f9	0a		asl a				asl 	a 							; x 4 and CLC
.97fa	0a		asl a				asl 	a
.97fb	6d 87 04	adc $0487			adc 	DecimalCount
.97fe	a8		tay				tay
.97ff	b9 06 a0	lda $a006,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9802	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9805	b9 07 a0	lda $a007,y			lda 	DecimalScalarTable-5+1,y
.9808	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.980b	b9 08 a0	lda $a008,y			lda 	DecimalScalarTable-5+2,y
.980e	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9811	b9 09 a0	lda $a009,y			lda 	DecimalScalarTable-5+3,y
.9814	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9817	b9 0a a0	lda $a00a,y			lda 	DecimalScalarTable-5+4,y
.981a	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.981d	a9 08		lda #$08			lda 	#NSTFloat
.981f	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9822	7a		ply				ply
.9823	e8		inx				inx 								; multiply decimal const by decimal scalar
.9824	20 64 95	jsr $9564			jsr 	FloatMultiply
.9827	ca		dex				dex
.9828	20 f1 93	jsr $93f1			jsr 	FloatAdd 					; add to integer part.
.982b					_ENCFExit:
.982b	18		clc				clc 								; reject the digit.
.982c	60		rts				rts
.982d					ESTAShiftDigitIntoMantissa:
.982d	29 0f		and #$0f			and 	#15 						; save digit
.982f	48		pha				pha
.9830	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9833	48		pha				pha
.9834	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9837	48		pha				pha
.9838	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.983b	48		pha				pha
.983c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.983f	48		pha				pha
.9840	20 cd 9e	jsr $9ecd			jsr 	NSMShiftLeft 				; x 2
.9843	20 cd 9e	jsr $9ecd			jsr 	NSMShiftLeft 				; x 4
.9846	18		clc				clc 								; pop mantissa and add
.9847	68		pla				pla
.9848	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.984b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.984e	68		pla				pla
.984f	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.9852	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9855	68		pla				pla
.9856	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.9859	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.985c	68		pla				pla
.985d	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.9860	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.9863	20 cd 9e	jsr $9ecd			jsr 	NSMShiftLeft 				; x 10
.9866	68		pla				pla 								; add digit
.9867	18		clc				clc
.9868	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.986b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.986e	90 0d		bcc $987d			bcc 	_ESTASDExit
.9870	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.9873	d0 08		bne $987d			bne 	_ESTASDExit
.9875	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.9878	d0 03		bne $987d			bne 	_ESTASDExit
.987a	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.987d					_ESTASDExit:
.987d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.987e					EvaluateTerm:
.987e	b1 30		lda ($30),y			lda 	(codePtr),y
.9880	30 18		bmi $989a			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9882	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9884	b0 6f		bcs $98f5			bcs 	_ETVariable
.9886	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9888	90 6e		bcc $98f8			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.988a	c9 3a		cmp #$3a			cmp 	#'9'+1
.988c	b0 6a		bcs $98f8			bcs 	_ETPuncUnary
.988e	20 5c 97	jsr $975c			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9891					_ETNumber:
.9891	c8		iny				iny 								; keep encoding until we have the numbers
.9892	b1 30		lda ($30),y			lda 	(codePtr),y
.9894	20 5f 97	jsr $975f			jsr 	EncodeNumberContinue
.9897	b0 f8		bcs $9891			bcs 	_ETNumber 					; go back if accepted.
.9899	60		rts				rts
.989a					_ETCheckUnary:
.989a	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.989c	f0 41		beq $98df			beq 	_ETString
.989e	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.98a0	f0 12		beq $98b4			beq 	_ETHexConstant
.98a2	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.98a4	90 0b		bcc $98b1			bcc 	_ETSyntaxError
.98a6	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.98a8	b0 07		bcs $98b1			bcs 	_ETSyntaxError
.98aa	da		phx				phx 								; push X on the stack
.98ab	0a		asl a				asl 	a 							; put vector x 2 into X
.98ac	aa		tax				tax
.98ad	c8		iny				iny 								; consume unary function token
.98ae	7c 9c 8b	jmp ($8b9c,x)			jmp 	(VectorSet0,x) 				; and do it.
.98b1					_ETSyntaxError:
.98b1	4c 42 a0	jmp $a042			jmp 	SyntaxError
.98b4					_ETHexConstant:
.98b4	c8		iny				iny 								; skip #
.98b5	c8		iny				iny 								; skip count
.98b6	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero 					; clear result
.98b9					_ETHLoop:
.98b9	b1 30		lda ($30),y			lda 	(codePtr),y
.98bb	c8		iny				iny 								; and consume
.98bc	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.98be	f0 1e		beq $98de			beq 	_ETHExit
.98c0	48		pha				pha 								; save on stack.
.98c1	20 cd 9e	jsr $9ecd			jsr 	NSMShiftLeft 				; x 2
.98c4	20 cd 9e	jsr $9ecd			jsr 	NSMShiftLeft 				; x 4
.98c7	20 cd 9e	jsr $9ecd			jsr 	NSMShiftLeft 				; x 8
.98ca	20 cd 9e	jsr $9ecd			jsr 	NSMShiftLeft 				; x 16
.98cd	68		pla				pla 								; ASCII
.98ce	c9 41		cmp #$41			cmp 	#'A'
.98d0	90 02		bcc $98d4			bcc 	_ETHNotChar
.98d2	e9 07		sbc #$07			sbc 	#7
.98d4					_ETHNotChar:
.98d4	29 0f		and #$0f			and 	#15 						; digit now
.98d6	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98d9	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98dc	80 db		bra $98b9			bra 	_ETHLoop 					; go round.
.98de					_ETHExit:
.98de	60		rts				rts
.98df					_ETString:
.98df	c8		iny				iny 								; look at length
.98e0	b1 30		lda ($30),y			lda 	(codePtr),y
.98e2	48		pha				pha
.98e3	c8		iny				iny 								; first character
.98e4	20 51 a6	jsr $a651			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98e7	68		pla				pla 								; restore count and save
.98e8	85 36		sta $36				sta 	zTemp0
.98ea	98		tya				tya 								; add length to Y to skip it.
.98eb	18		clc				clc
.98ec	65 36		adc $36				adc 	zTemp0
.98ee	a8		tay				tay
.98ef	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98f1	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98f4	60		rts				rts
.98f5					_ETVariable:
.98f5	4c 4f 99	jmp $994f			jmp 	VariableHandler
.98f8					_ETPuncUnary:
.98f8	c8		iny				iny 								; consume the unary character
.98f9	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98fb	f0 2d		beq $992a			beq 	_ETUnaryNegate
.98fd	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98ff	f0 39		beq $993a			beq 	_ETDereference
.9901	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9903	f0 43		beq $9948			beq 	_ETParenthesis
.9905	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9907	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9909	f0 06		beq $9911			beq 	_ETIndirection
.990b	e6 36		inc $36				inc 	zTemp0
.990d	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.990f	d0 a0		bne $98b1			bne 	_ETSyntaxError
.9911					_ETIndirection:
.9911	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9913	1a		inc a				inc 	a
.9914	48		pha				pha
.9915	20 7e 98	jsr $987e			jsr 	EvaluateTerm				; evaluate the term
.9918	20 c2 96	jsr $96c2			jsr 	Dereference 				; dereference it.
.991b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.991e	d0 07		bne $9927			bne 	_ETTypeMismatch
.9920	68		pla				pla 								; indirection 1-2
.9921	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9923	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9926	60		rts				rts
.9927					_ETTypeMismatch:
.9927	4c 4c a0	jmp $a04c			jmp 	TypeError
.992a					_ETUnaryNegate:
.992a	20 7e 98	jsr $987e			jsr 	EvaluateTerm				; evaluate the term
.992d	20 c2 96	jsr $96c2			jsr 	Dereference 				; dereference it.
.9930	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.9933	29 10		and #$10			and 	#NSTString
.9935	d0 f0		bne $9927			bne 	_ETTypeMismatch
.9937	4c 64 9e	jmp $9e64			jmp 	NSMNegate  					; just toggles the sign bit.
.993a					_ETDereference:
.993a	20 7e 98	jsr $987e			jsr 	EvaluateTerm				; evaluate the term
.993d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.9940	29 20		and #$20			and 	#NSBIsReference
.9942	f0 e3		beq $9927			beq 	_ETTypeMismatch
.9944	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.9947	60		rts				rts
.9948					_ETParenthesis:
.9948	20 a4 93	jsr $93a4			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.994b	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket 			; check for )
.994e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.994f					VariableHandler:
.994f	b1 30		lda ($30),y			lda 	(codePtr),y
.9951	18		clc				clc
.9952	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9954	85 37		sta $37				sta 	zTemp0+1
.9956	c8		iny				iny
.9957	b1 30		lda ($30),y			lda 	(codePtr),y
.9959	85 36		sta $36				sta 	zTemp0
.995b	c8		iny				iny
.995c	18		clc				clc									; copy variable address+3 to mantissa
.995d	69 03		adc #$03			adc 	#3
.995f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9962	a5 37		lda $37				lda 	zTemp0+1
.9964	69 00		adc #$00			adc 	#0
.9966	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9969	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.996c	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.996f	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9972	5a		phy				phy
.9973	a0 02		ldy #$02			ldy 	#2 							; read type
.9975	b1 36		lda ($36),y			lda 	(zTemp0),y
.9977	7a		ply				ply
.9978	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.997a	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.997c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.997f	29 04		and #$04			and 	#NSBIsArray
.9981	d0 01		bne $9984			bne 	_VHArray
.9983	60		rts				rts
.9984					_VHArray:
.9984	e8		inx				inx
.9985	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9988	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.998a	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.998d	b1 30		lda ($30),y			lda 	(codePtr),y
.998f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9991	d0 06		bne $9999			bne 	_VHNoSecondIndex
.9993	c8		iny				iny 								; skip the comma
.9994	e8		inx				inx
.9995	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9998	ca		dex				dex
.9999					_VHNoSecondIndex:
.9999	ca		dex				dex 								; set X back.
.999a	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket 			; and check the right bracket.
.999d	5a		phy				phy 								; save position
.999e	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.99a0	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99a2	f0 6b		beq $9a0f			beq 	_VHBadIndex
.99a4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.99a7	85 3e		sta $3e				sta 	zaTemp
.99a9	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.99ac	85 3f		sta $3f				sta 	zaTemp+1
.99ae	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.99b0	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99b2	f0 02		beq $99b6			beq 	_VHHas2Mask
.99b4	a9 ff		lda #$ff			lda 	#$FF
.99b6					_VHHas2Mask:
.99b6	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.99b9	f0 54		beq $9a0f			beq 	_VHBadIndex
.99bb	0a		asl a				asl 	a 							; carry will be set if a second index
.99bc	90 09		bcc $99c7			bcc 	_VHCheckFirstIndex
.99be	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.99c0	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99c2	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.99c5	90 48		bcc $9a0f			bcc 	_VHBadIndex
.99c7					_VHCheckFirstIndex:
.99c7	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.99c9	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99cb	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.99ce	90 3f		bcc $9a0f			bcc 	_VHBadIndex
.99d0	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.99d2	64 37		stz $37				stz 	zTemp0+1
.99d4	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99d7	30 0f		bmi $99e8			bmi 	_VHNoMultiply
.99d9	da		phx				phx
.99da	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.99dd	48		pha				pha
.99de	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.99e0	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99e2	1a		inc a				inc 	a 							; add 1 for zero base
.99e3	fa		plx				plx
.99e4	20 4d 9e	jsr $9e4d			jsr 	Multiply8x8 				; calculate -> Z0
.99e7	fa		plx				plx
.99e8					_VHNoMultiply:
.99e8	18		clc				clc
.99e9	a5 36		lda $36				lda 	zTemp0
.99eb	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.99ee	85 36		sta $36				sta 	zTemp0
.99f0	a5 37		lda $37				lda 	zTemp0+1
.99f2	69 00		adc #$00			adc 	#0
.99f4	85 37		sta $37				sta 	zTemp0+1
.99f6	bd 00 04	lda $0400,x			lda 	NSStatus,x
.99f9	20 f2 84	jsr $84f2			jsr 	ScaleByBaseType
.99fc	18		clc				clc
.99fd	b2 3e		lda ($3e)			lda 	(zaTemp)
.99ff	65 36		adc $36				adc 	zTemp0
.9a01	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a04	a0 01		ldy #$01			ldy 	#1
.9a06	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9a08	65 37		adc $37				adc 	zTemp0+1
.9a0a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9a0d	7a		ply				ply 								; restore position
.9a0e	60		rts				rts
.9a0f					_VHBadIndex:
.9a0f	a9 17		lda #$17		lda	#23
.9a11	4c f5 8d	jmp $8df5		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9a14					AbsUnary:
.9a14	fa		plx				plx 								; restore stack pos
.9a15	20 e1 9d	jsr $9de1			jsr 	EvaluateNumber 				; get a float or int
.9a18	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.9a1b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.9a1e	29 7f		and #$7f			and 	#$7F
.9a20	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a23	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9a24					AllocUnary:
.9a24	fa		plx				plx 								; restore stack pos
.9a25	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger		; get bytes required.
.9a28	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.9a2b	da		phx				phx 								; save X/Y
.9a2c	5a		phy				phy
.9a2d	8a		txa				txa 								; copy X into Y
.9a2e	a8		tay				tay
.9a2f	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.9a32	aa		tax				tax
.9a33	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.9a36	20 43 9a	jsr $9a43			jsr 	AllocateXABytes 			; allocate memory
.9a39	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.9a3c	8a		txa				txa
.9a3d	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.9a40	7a		ply				ply
.9a41	fa		plx				plx
.9a42	60		rts				rts
.9a43					AllocateXABytes:
.9a43	5a		phy				phy
.9a44	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a47	84 36		sty $36				sty 	zTemp0
.9a49	5a		phy				phy
.9a4a	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.9a4d	84 37		sty $37				sty 	zTemp0+1
.9a4f	5a		phy				phy
.9a50	18		clc				clc 								; add to low memory pointer
.9a51	6d 8c 04	adc $048c			adc 	lowMemPtr
.9a54	8d 8c 04	sta $048c			sta 	lowMemPtr
.9a57	8a		txa				txa
.9a58	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.9a5b	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.9a5e	b0 2f		bcs $9a8f			bcs 	CISSMemory
.9a60	20 81 9a	jsr $9a81			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a63					_ClearMemory:
.9a63	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.9a66	c5 36		cmp $36				cmp 	zTemp0
.9a68	d0 07		bne $9a71			bne 	_CMClearNext
.9a6a	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.9a6d	c5 37		cmp $37				cmp 	zTemp0+1
.9a6f	f0 0c		beq $9a7d			beq 	_CMExit
.9a71					_CMClearNext:
.9a71	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a73	92 36		sta ($36)			sta 	(zTemp0)
.9a75	e6 36		inc $36				inc 	zTemp0
.9a77	d0 ea		bne $9a63			bne 	_ClearMemory
.9a79	e6 37		inc $37				inc		zTemp0+1
.9a7b	80 e6		bra $9a63			bra 	_ClearMemory
.9a7d					_CMExit:
.9a7d	fa		plx				plx
.9a7e	68		pla				pla
.9a7f	7a		ply				ply
.9a80	60		rts				rts
.9a81					CheckIdentifierStringSpace:
.9a81	48		pha				pha
.9a82	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.9a85	18		clc				clc
.9a86	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a88	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a8b	b0 02		bcs $9a8f			bcs 	CISSMemory
.9a8d	68		pla				pla
.9a8e	60		rts				rts
.9a8f					CISSMemory:
.9a8f	a9 06		lda #$06		lda	#6
.9a91	4c f5 8d	jmp $8df5		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a94					AscUnary:
.9a94	fa		plx				plx 								; restore stack pos
.9a95	20 ec 9d	jsr $9dec			jsr 	EvaluateString 				; get a string
.9a98	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9a9a	20 ba 9e	jsr $9eba			jsr 	NSMSetByte
.9a9d	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.9aa0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9aa1					FracUnary:
.9aa1	fa		plx				plx 								; restore stack pos
.9aa2	20 e1 9d	jsr $9de1			jsr 	EvaluateNumber 				; get a float or int
.9aa5	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.9aa8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9aab	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9aad	f0 04		beq $9ab3			beq 	_IUZero
.9aaf	20 d7 94	jsr $94d7			jsr 	FloatFractionalPart
.9ab2	60		rts				rts
.9ab3					_IUZero:
.9ab3	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero
.9ab6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9ab7					IntUnary:
.9ab7	fa		plx				plx 								; restore stack pos
.9ab8	20 e1 9d	jsr $9de1			jsr 	EvaluateNumber 				; get a float or int
.9abb	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.9abe	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ac1	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9ac3	f0 03		beq $9ac8			beq 	_IUExit
.9ac5	20 3a 95	jsr $953a			jsr 	FloatIntegerPart
.9ac8					_IUExit:
.9ac8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9ac9					LenUnary:
.9ac9	fa		plx				plx 								; restore stack pos
.9aca	20 ec 9d	jsr $9dec			jsr 	EvaluateString 				; get a string
.9acd	5a		phy				phy
.9ace	a0 00		ldy #$00			ldy 	#0 							; find length
.9ad0					_LenFind:
.9ad0	b1 36		lda ($36),y			lda 	(zTemp0),y
.9ad2	f0 06		beq $9ada			beq 	_LenExit
.9ad4	c8		iny				iny
.9ad5	d0 f9		bne $9ad0			bne 	_LenFind
.9ad7	4c 47 a0	jmp $a047			jmp 	RangeError 					; string > 255
.9ada					_LenExit:
.9ada	98		tya				tya
.9adb	20 ba 9e	jsr $9eba			jsr 	NSMSetByte
.9ade	7a		ply				ply
.9adf	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.9ae2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9ae3					Unary_Min:
.9ae3	a9 01		lda #$01			lda 	#1
.9ae5	80 02		bra $9ae9			bra 	UnaryMinMaxMain
.9ae7					Unary_Max:
.9ae7	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9ae9					UnaryMinMaxMain:
.9ae9	fa		plx				plx 								; get index on number stack
.9aea	48		pha				pha 								; save comparator
.9aeb	20 d8 9d	jsr $9dd8			jsr 	EvaluateValue 				; get the first value.
.9aee					_UMMMLoop:
.9aee	b1 30		lda ($30),y			lda 	(codePtr),y
.9af0	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9af2	f0 22		beq $9b16			beq 	_UMMMDone
.9af4	20 e4 8d	jsr $8de4			jsr 	CheckComma 					; must be a comma
.9af7	e8		inx				inx
.9af8	20 d8 9d	jsr $9dd8			jsr 	EvaluateValue
.9afb	ca		dex				dex
.9afc	20 8f 9e	jsr $9e8f			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9aff	e8		inx				inx
.9b00	20 8f 9e	jsr $9e8f			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9b03	e8		inx				inx
.9b04	20 ad 8e	jsr $8ead			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9b07	ca		dex				dex
.9b08	ca		dex				dex
.9b09	85 36		sta $36				sta 	zTemp0 						; save required result
.9b0b	68		pla				pla 								; get and save comparator
.9b0c	48		pha				pha
.9b0d	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9b0f	d0 dd		bne $9aee			bne 	_UMMMLoop
.9b11	20 19 9b	jsr $9b19			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9b14	80 d8		bra $9aee			bra 	_UMMMLoop
.9b16					_UMMMDone:
.9b16	68		pla				pla 								; throw the comparator
.9b17	c8		iny				iny 								; skip )
.9b18	60		rts				rts
.9b19					ExpCopyAboveDown:
.9b19	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9b1c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b1f	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9b22	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9b25	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9b28	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b2b	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9b2e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b31	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9b34	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b37	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9b3a	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b3d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b3e					Unary_Not:
.9b3e	fa		plx				plx
.9b3f	20 04 9e	jsr $9e04			jsr 	EvaluateInteger 			; get integer
.9b42	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.9b45	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; zero mantissa ?
.9b48	f0 04		beq $9b4e			beq 	_NotZero
.9b4a	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero
.9b4d	60		rts				rts
.9b4e					_NotZero:
.9b4e	4c 62 8e	jmp $8e62			jmp 	ReturnTrue
.9b51					_UNBad:
.9b51	4c 51 a0	jmp $a051			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b54					Unary_Random:
.9b54	fa		plx				plx
.9b55	20 d3 9b	jsr $9bd3			jsr 	Random32Bit 				; get a random number
.9b58	20 b8 9b	jsr $9bb8			jsr 	URCopyToMantissa  			; put in mantissa
.9b5b	b1 30		lda ($30),y			lda 	(codePtr),y
.9b5d	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b5f	f0 08		beq $9b69			beq 	_URNoModulus
.9b61	e8		inx				inx
.9b62	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b65	ca		dex				dex
.9b66	20 d1 8f	jsr $8fd1			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9b69					_URNoModulus:
.9b69	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9b6c	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9b6f	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.9b72	60		rts				rts
.9b73					Unary_Rnd:
.9b73	fa		plx				plx
.9b74	20 e1 9d	jsr $9de1			jsr 	EvaluateNumber 				; number to use.
.9b77	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket 			; closing bracket
.9b7a	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b7d	f0 2b		beq $9baa			beq 	_URCopySeed
.9b7f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b82	10 23		bpl $9ba7			bpl 	_URDontSeed
.9b84	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b87	49 17		eor #$17			eor 	#$17
.9b89	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b8c	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9b8f	49 a5		eor #$a5			eor 	#$A5
.9b91	8d 89 04	sta $0489			sta 	RandomSeed+1
.9b94	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9b97	49 c2		eor #$c2			eor 	#$C2
.9b99	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9b9c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9b9f	49 9d		eor #$9d			eor 	#$9D
.9ba1	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9ba4	20 d3 9b	jsr $9bd3			jsr 	Random32Bit
.9ba7					_URDontSeed:
.9ba7	20 d3 9b	jsr $9bd3			jsr 	Random32Bit 				; generate a number.
.9baa					_URCopySeed:
.9baa	20 b8 9b	jsr $9bb8			jsr 	URCopyToMantissa 			; copy into mantissa
.9bad	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9baf	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9bb2	a9 08		lda #$08			lda 	#NSTFloat
.9bb4	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; positive.
.9bb7	60		rts				rts
.9bb8					URCopyToMantissa:
.9bb8	ad 88 04	lda $0488			lda 	RandomSeed+0
.9bbb	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9bbe	ad 89 04	lda $0489			lda 	RandomSeed+1
.9bc1	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9bc4	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9bc7	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9bca	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9bcd	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9bcf	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9bd2	60		rts				rts
.9bd3					Random32Bit:
.9bd3	5a		phy				phy
.9bd4	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9bd6	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9bd9	d0 03		bne $9bde			bne 	_Random1
.9bdb	a8		tay				tay 								; if so do it 256 times
.9bdc	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9bde					_Random1:
.9bde	0a		asl a				asl 	a 							; LSFR RNG
.9bdf	2e 89 04	rol $0489			rol 	RandomSeed+1
.9be2	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9be5	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9be8	90 02		bcc $9bec			bcc 	_Random2
.9bea	49 c5		eor #$c5			eor 	#$C5
.9bec					_Random2:
.9bec	88		dey				dey
.9bed	d0 ef		bne $9bde			bne 	_Random1
.9bef	8d 88 04	sta $0488			sta 	RandomSeed+0
.9bf2	7a		ply				ply
.9bf3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9bf4					SgnUnary:
.9bf4	fa		plx				plx 								; restore stack pos
.9bf5	20 e1 9d	jsr $9de1			jsr 	EvaluateNumber 				; get a float or int
.9bf8	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.9bfb	20 e8 9e	jsr $9ee8			jsr 	NSMIsZero 					; if zero
.9bfe	f0 10		beq $9c10			beq 	_SGZero  					; return Int Zero
.9c00	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9c03	48		pha				pha
.9c04	a9 01		lda #$01			lda 	#1 							; set to 1
.9c06	20 ba 9e	jsr $9eba			jsr 	NSMSetByte
.9c09	68		pla				pla
.9c0a	29 80		and #$80			and		#$80 						; copy the sign byte out
.9c0c	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c0f	60		rts				rts
.9c10	20 b8 9e	jsr $9eb8	_SGZero:jsr 	NSMSetZero
.9c13	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9c14					ValUnary:
.9c14	fa		plx				plx 								; restore stack pos
.9c15	20 2a 9c	jsr $9c2a			jsr 	ValMainCode 				; do the main val() code
.9c18	b0 01		bcs $9c1b			bcs 	_VUError 					; couldn't convert
.9c1a	60		rts				rts
.9c1b					_VUError:
.9c1b	4c 4c a0	jmp $a04c			jmp 	TypeError
.9c1e					IsValUnary:
.9c1e	fa		plx				plx 								; restore stack pos
.9c1f	20 2a 9c	jsr $9c2a			jsr 	ValMainCode 				; do the main val() code
.9c22	b0 03		bcs $9c27			bcs 	_VUBad
.9c24	4c 62 8e	jmp $8e62			jmp 	ReturnTrue
.9c27					_VUBad:
.9c27	4c 6e 8e	jmp $8e6e			jmp 	ReturnFalse
.9c2a					ValMainCode:
.9c2a	20 ec 9d	jsr $9dec			jsr 	EvaluateString 				; get a string
.9c2d	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket 			; check right bracket present
.9c30					ValEvaluateZTemp0:
.9c30	5a		phy				phy
.9c31	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9c33	f0 17		beq $9c4c			beq 	_VMCFail2
.9c35	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9c37	48		pha				pha 								; save first character
.9c38	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9c3a	d0 01		bne $9c3d			bne 	_VMCStart
.9c3c	c8		iny				iny 								; skip over -
.9c3d					_VMCStart:
.9c3d	38		sec				sec 								; initialise first time round.
.9c3e					_VMCNext:
.9c3e	c8		iny				iny 								; pre-increment
.9c3f	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9c41	f0 0c		beq $9c4f			beq 	_VMCSuccess 				; successful.
.9c43	20 60 97	jsr $9760			jsr 	EncodeNumber 				; send it to the number-builder
.9c46	90 03		bcc $9c4b			bcc 	_VMCFail 					; if failed, give up.
.9c48	18		clc				clc 								; next time round, countinue
.9c49	80 f3		bra $9c3e			bra 	_VMCNext
.9c4b					_VMCFail:
.9c4b	68		pla				pla
.9c4c					_VMCFail2:
.9c4c	7a		ply				ply
.9c4d	38		sec				sec
.9c4e	60		rts				rts
.9c4f					_VMCSuccess:
.9c4f	a9 00		lda #$00			lda 	#0 							; construct final
.9c51	20 60 97	jsr $9760			jsr 	EncodeNumber
.9c54	68		pla				pla
.9c55	c9 2d		cmp #$2d			cmp 	#"-"
.9c57	d0 03		bne $9c5c			bne 	_VMCNotNegative
.9c59	20 64 9e	jsr $9e64			jsr		NSMNegate
.9c5c					_VMCNotNegative:
.9c5c	7a		ply				ply
.9c5d	18		clc				clc
.9c5e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c5f					ChrUnary:
.9c5f	fa		plx				plx 								; restore stack pos
.9c60	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger			; get value
.9c63	48		pha				pha
.9c64	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.9c67	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c69	20 35 a8	jsr $a835			jsr 	StringTempAllocate
.9c6c	68		pla				pla 								; write number to it
.9c6d	20 73 a8	jsr $a873			jsr 	StringTempWrite
.9c70	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c71					SpcUnary:
.9c71	fa		plx				plx 								; restore stack pos
.9c72	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger			; get value
.9c75	5a		phy				phy
.9c76	48		pha				pha 								; save count
.9c77	20 35 a8	jsr $a835			jsr 	StringTempAllocate
.9c7a	7a		ply				ply 								; to do count in Y
.9c7b					_SpcLoop:
.9c7b	c0 00		cpy #$00			cpy 	#0
.9c7d	f0 08		beq $9c87			beq 	_SpcExit
.9c7f	a9 20		lda #$20			lda 	#32
.9c81	20 73 a8	jsr $a873			jsr 	StringTempWrite
.9c84	88		dey				dey
.9c85	80 f4		bra $9c7b			bra 	_SPCLoop
.9c87					_SpcExit:
.9c87	7a		ply				ply
.9c88	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.9c8b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c8c					Unary_Str:
.9c8c	fa		plx				plx
.9c8d	20 e1 9d	jsr $9de1			jsr 	EvaluateNumber  			; get number
.9c90	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket 			; closing bracket
.9c93	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c95	20 ae 9c	jsr $9cae			jsr 	ConvertNumberToString 		; do the conversion.
.9c98	a9 21		lda #$21			lda		#33 						; create buffer
.9c9a	20 35 a8	jsr $a835			jsr 	StringTempAllocate 			; allocate memory
.9c9d	da		phx				phx
.9c9e	a2 00		ldx #$00			ldx 	#0
.9ca0					_USCopy:
.9ca0	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9ca3	20 73 a8	jsr $a873			jsr 	StringTempWrite
.9ca6	e8		inx				inx
.9ca7	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9caa	d0 f4		bne $9ca0			bne 	_USCopy
.9cac	fa		plx				plx
.9cad	60		rts				rts
.9cae					ConvertNumberToString:
.9cae	5a		phy				phy 								; save code position
.9caf	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9cb2	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9cb5	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9cb8	10 0a		bpl $9cc4			bpl 	_CNTSNotNegative
.9cba	29 7f		and #$7f			and 	#$7F 						; make +ve
.9cbc	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9cbf	a9 2d		lda #$2d			lda 	#"-"
.9cc1	20 2a 9d	jsr $9d2a			jsr 	WriteDecimalBuffer
.9cc4					_CNTSNotNegative:
.9cc4	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9cc7	f0 15		beq $9cde			beq 	_CNTSNotFloat
.9cc9	e8		inx				inx 								; round up
.9cca	a9 01		lda #$01			lda 	#1
.9ccc	20 ba 9e	jsr $9eba			jsr 	NSMSetByte
.9ccf	ca		dex				dex
.9cd0	bd 28 04	lda $0428,x			lda		NSExponent,x
.9cd3	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9cd6	a9 08		lda #$08			lda 	#NSTFloat
.9cd8	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9cdb	20 f1 93	jsr $93f1			jsr 	FloatAdd
.9cde					_CNTSNotFloat:
.9cde	20 0c 9d	jsr $9d0c			jsr 	MakePlusTwoString
.9ce1	20 d7 94	jsr $94d7			jsr 	FloatFractionalPart 		; get the fractional part
.9ce4	20 9b 95	jsr $959b			jsr 	NSNormalise					; normalise , exit if zero
.9ce7	f0 21		beq $9d0a			beq 	_CNTSExit
.9ce9	a9 2e		lda #$2e			lda 	#"."
.9ceb	20 2a 9d	jsr $9d2a			jsr 	WriteDecimalBuffer 			; write decimal place
.9cee					_CNTSDecimal:
.9cee	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9cf1	30 17		bmi $9d0a			bmi 	_CNTSExit
.9cf3	e8		inx				inx 								; x 10.0
.9cf4	a9 0a		lda #$0a			lda 	#10
.9cf6	20 ba 9e	jsr $9eba			jsr 	NSMSetByte
.9cf9	a9 08		lda #$08			lda 	#NSTFloat
.9cfb	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9cfe	ca		dex				dex
.9cff	20 64 95	jsr $9564			jsr 	FloatMultiply
.9d02	20 0c 9d	jsr $9d0c			jsr 	MakePlusTwoString
.9d05	20 d7 94	jsr $94d7			jsr 	FloatFractionalPart 		; get the fractional part
.9d08	80 e4		bra $9cee			bra 	_CNTSDecimal 				; keep going.
.9d0a					_CNTSExit:
.9d0a	7a		ply				ply
.9d0b	60		rts				rts
.9d0c					MakePlusTwoString:
.9d0c	da		phx				phx
.9d0d	20 8f 9e	jsr $9e8f			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9d10	e8		inx				inx 								; access it
.9d11	e8		inx				inx
.9d12	20 3a 95	jsr $953a			jsr 	FloatIntegerPart 			; make it an integer
.9d15	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9d17	20 1c 93	jsr $931c			jsr 	ConvertInt32
.9d1a	a2 00		ldx #$00			ldx	 	#0
.9d1c					_MPTSCopy:
.9d1c	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d1f	20 2a 9d	jsr $9d2a			jsr 	WriteDecimalBuffer
.9d22	e8		inx				inx
.9d23	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d26	d0 f4		bne $9d1c			bne 	_MPTSCopy
.9d28	fa		plx				plx
.9d29	60		rts				rts
.9d2a					WriteDecimalBuffer:
.9d2a	da		phx				phx
.9d2b	ae 95 04	ldx $0495			ldx 	dbOffset
.9d2e	9d 1c 06	sta $061c,x			sta 	DecimalBuffer,x
.9d31	9e 1d 06	stz $061d,x			stz 	DecimalBuffer+1,x
.9d34	ee 95 04	inc $0495			inc 	dbOffset
.9d37	fa		plx				plx
.9d38	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9d39					Unary_Left:
.9d39	fa		plx				plx
.9d3a	18		clc				clc 								; only one parameter
.9d3b	20 b0 9d	jsr $9db0			jsr 	SubstringInitial 			; set up.
.9d3e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9d41	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d44	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9d47	80 2c		bra $9d75			bra 	SubstringMain
.9d49					Unary_Right:
.9d49	fa		plx				plx
.9d4a	18		clc				clc 								; only one parameter
.9d4b	20 b0 9d	jsr $9db0			jsr 	SubstringInitial 			; set up.
.9d4e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9d51	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d54	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9d57	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d5a	b0 02		bcs $9d5e			bcs 	_URNotUnderflow
.9d5c	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d5e					_URNotUnderFlow:
.9d5e	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d61	80 12		bra $9d75			bra 	SubStringMain
.9d63					Unary_Mid:
.9d63	fa		plx				plx
.9d64	38		sec				sec 								; two parameters
.9d65	20 b0 9d	jsr $9db0			jsr 	SubstringInitial 			; set up.
.9d68	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d6b	f0 05		beq $9d72			beq 	_UMError
.9d6d	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d70	80 03		bra $9d75			bra 	SubStringMain
.9d72					_UMError:
.9d72	4c 51 a0	jmp $a051			jmp 	ArgumentError
.9d75					SubStringMain:
.9d75	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d78	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9d7b	b0 2d		bcs $9daa			bcs 	_SSMNull 					; if so, return an empty string.
.9d7d	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d80	f0 28		beq $9daa			beq 	_SSMNull 					; return empty string.
.9d82	18		clc				clc 								; add the offset +1 to the address and
.9d83	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9d86	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9d89	85 36		sta $36				sta 	zTemp0
.9d8b	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9d8e	69 00		adc #$00			adc 	#0
.9d90	85 37		sta $37				sta 	zTemp0+1
.9d92					_SSMNoCarry:
.9d92	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d95	20 35 a8	jsr $a835			jsr 	StringTempAllocate 			; allocate that many characters
.9d98	5a		phy				phy 								; save Y
.9d99	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d9b					_SSMCopy:
.9d9b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d9d	f0 09		beq $9da8			beq 	_SSMEString 				; no more to copy
.9d9f	20 73 a8	jsr $a873			jsr 	StringTempWrite 			; and write it out.
.9da2	c8		iny				iny
.9da3	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9da6	d0 f3		bne $9d9b			bne 	_SSMCopy
.9da8					_SSMEString:
.9da8	7a		ply				ply
.9da9					_SSMExit:
.9da9	60		rts				rts
.9daa					_SSMNull:
.9daa	a9 00		lda #$00			lda 	#0
.9dac	20 35 a8	jsr $a835			jsr 	StringTempAllocate
.9daf	60		rts				rts
.9db0					SubstringInitial:
.9db0	da		phx				phx 								; save initial stack position
.9db1	08		php				php 								; save carry on stack indicating 2 parameters
.9db2	20 ec 9d	jsr $9dec			jsr 	EvaluateString 				; get a string
.9db5	5a		phy				phy 								; calculate length to exponent.
.9db6	a0 ff		ldy #$ff			ldy 	#$FF
.9db8					_SIFindLength:
.9db8	c8		iny				iny
.9db9	b1 36		lda ($36),y			lda 	(zTemp0),y
.9dbb	d0 fb		bne $9db8			bne 	_SIFindLength
.9dbd	98		tya				tya
.9dbe	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9dc1	7a		ply				ply
.9dc2	e8		inx				inx
.9dc3	20 e4 8d	jsr $8de4			jsr 	CheckComma 					; comma next
.9dc6	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; get next parameter
.9dc9	28		plp				plp 								; is it the last parameter ?
.9dca	90 07		bcc $9dd3			bcc 	_SSIExit 					; if so, exit.
.9dcc	e8		inx				inx
.9dcd	20 e4 8d	jsr $8de4			jsr 	CheckComma 					; comma next
.9dd0	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; get last parameter
.9dd3					_SSIExit:
.9dd3	fa		plx				plx
.9dd4	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket 			; check closing bracket
.9dd7	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9dd8					EvaluateValue:
.9dd8	48		pha				pha
.9dd9	20 a4 93	jsr $93a4			jsr		EvaluateExpression 			; expression
.9ddc	20 c2 96	jsr $96c2			jsr 	Dereference					; derefernce it
.9ddf	68		pla				pla
.9de0	60		rts				rts
.9de1					EvaluateNumber:
.9de1	20 d8 9d	jsr $9dd8			jsr 	EvaluateValue 				; get a value
.9de4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9de7	29 10		and #$10			and 	#NSBIsString
.9de9	d0 16		bne $9e01			bne 	HelperTypeError
.9deb	60		rts				rts
.9dec					EvaluateString:
.9dec	20 d8 9d	jsr $9dd8			jsr 	EvaluateValue 				; get a value
.9def	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9df2	29 10		and #$10			and 	#NSBIsString
.9df4	f0 0b		beq $9e01			beq 	HelperTypeError
.9df6					CopyAddressToTemp0:
.9df6	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9df9	85 36		sta $36				sta 	zTemp0
.9dfb	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9dfe	85 37		sta $37				sta 	zTemp0+1
.9e00	60		rts				rts
.9e01					HelperTypeError:
.9e01	4c 4c a0	jmp $a04c			jmp 	TypeError
.9e04					EvaluateInteger:
.9e04	20 e1 9d	jsr $9de1			jsr 	EvaluateNumber
.9e07	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9e0a	d0 0a		bne $9e16			bne 	HelperValueError 			; if not, it's a float.
.9e0c	60		rts				rts
.9e0d					EvaluateUnsignedInteger:
.9e0d	20 04 9e	jsr $9e04			jsr 	EvaluateInteger 			; check integer is +ve
.9e10	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e13	30 01		bmi $9e16			bmi 	HelperValueError
.9e15	60		rts				rts
.9e16					HelperValueError:
.9e16	4c 51 a0	jmp $a051			jmp 	ArgumentError
.9e19					Evaluate16BitInteger:
.9e19	20 0d 9e	jsr $9e0d			jsr	 	EvaluateUnsignedInteger		; get integer
.9e1c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e1f	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e22	d0 f2		bne $9e16			bne 	HelperValueError
.9e24	60		rts				rts
.9e25					Evaluate16BitIntegerSigned:
.9e25	20 04 9e	jsr $9e04			jsr	 	EvaluateInteger				; get integer
.9e28	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e2b	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e2e	d0 e6		bne $9e16			bne 	HelperValueError
.9e30	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9e33	10 03		bpl $9e38			bpl 	_EISNotSigned
.9e35	20 6d 9e	jsr $9e6d			jsr 	NSMNegateMantissa
.9e38					_EISNotSigned:
.9e38	60		rts				rts
.9e39					Evaluate8BitInteger:
.9e39	20 0d 9e	jsr $9e0d			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9e3c	d0 d8		bne $9e16			bne 	HelperValueError
.9e3e	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9e41	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e44	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9e47	d0 cd		bne $9e16			bne 	HelperValueError
.9e49	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e4c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9e4d					Multiply8x8:
.9e4d	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9e4e	85 36		sta $36			  	sta 	zTemp0
.9e50	86 37		stx $37				stx 	zTemp0+1
.9e52	a9 00		lda #$00			lda 	#0
.9e54	a2 08		ldx #$08			ldx 	#8
.9e56					_M88Loop:
.9e56	90 03		bcc $9e5b			bcc 	_M88NoAdd
.9e58	18		clc				clc
.9e59	65 37		adc $37				adc 	zTemp0+1
.9e5b					_M88NoAdd:
.9e5b	6a		ror a				ror 	a
.9e5c	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9e5e	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9e5f	d0 f5		bne $9e56			bne 	_M88Loop
.9e61	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9e63	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9e64					NSMNegate:
.9e64	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e67	49 80		eor #$80			eor 	#NSBIsNegative
.9e69	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9e6c	60		rts				rts
.9e6d					NSMNegateMantissa:
.9e6d	38		sec				sec
.9e6e	a9 00		lda #$00			lda 	#0
.9e70	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9e73	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9e76	a9 00		lda #$00			lda 	#0
.9e78	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9e7b	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9e7e	a9 00		lda #$00			lda 	#0
.9e80	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9e83	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9e86	a9 00		lda #$00			lda 	#0
.9e88	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9e8b	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9e8e	60		rts				rts
.9e8f					NSMShiftUpTwo:
.9e8f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e92	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9e95	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e98	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9e9b	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9e9e	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9ea1	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9ea4	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9ea7	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9eaa	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9ead	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9eb0	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9eb3	60		rts				rts
.9eb4					NSMSetZeroMantissaOnly:
.9eb4	a9 00		lda #$00			lda 	#0
.9eb6	80 08		bra $9ec0			bra 	NSMSetMantissa
.9eb8					NSMSetZero:
.9eb8	a9 00		lda #$00			lda 	#0
.9eba					NSMSetByte:
.9eba	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9ebd	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9ec0					NSMSetMantissa:
.9ec0	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9ec3	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9ec6	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9ec9	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9ecc	60		rts				rts
.9ecd					NSMShiftLeft:
.9ecd	18		clc				clc
.9ece					NSMRotateLeft:
.9ece	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9ed1	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9ed4	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9ed7	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9eda	60		rts				rts
.9edb					NSMShiftRight:
.9edb	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9ede	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9ee1	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9ee4	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9ee7	60		rts				rts
.9ee8					NSMIsZero:
.9ee8	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9eeb	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9eee	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9ef1	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9ef4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.ba9d					TickHandler:
.ba9d	5a		phy				phy 								; need to preserve Y
.ba9e	20 43 ba	jsr $ba43			jsr 	SNDUpdate 					; update sound
.baa1	7a		ply				ply
.baa2	60		rts				rts
.062e					LastTick:
>062e							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9ef5					Assemble_ora:
.9ef5	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9ef8	01					.byte $01
.9ef9					Assemble_and:
.9ef9	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9efc	21					.byte $21
.9efd					Assemble_eor:
.9efd	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f00	41					.byte $41
.9f01					Assemble_adc:
.9f01	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f04	61					.byte $61
.9f05					Assemble_sta:
.9f05	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f08	81					.byte $81
.9f09					Assemble_lda:
.9f09	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f0c	a1					.byte $a1
.9f0d					Assemble_cmp:
.9f0d	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f10	c1					.byte $c1
.9f11					Assemble_sbc:
.9f11	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f14	e1					.byte $e1
.9f15					Assemble_asl:
.9f15	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f18	02					.byte $02
>9f19	75					.byte $75
.9f1a					Assemble_rol:
.9f1a	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f1d	22					.byte $22
>9f1e	75					.byte $75
.9f1f					Assemble_lsr:
.9f1f	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f22	42					.byte $42
>9f23	75					.byte $75
.9f24					Assemble_ror:
.9f24	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f27	62					.byte $62
>9f28	75					.byte $75
.9f29					Assemble_stx:
.9f29	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f2c	82					.byte $82
>9f2d	50					.byte $50
.9f2e					Assemble_ldx:
.9f2e	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f31	a2					.byte $a2
>9f32	d0					.byte $d0
.9f33					Assemble_dec:
.9f33	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f36	c2					.byte $c2
>9f37	55					.byte $55
.9f38					Assemble_inc:
.9f38	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f3b	e2					.byte $e2
>9f3c	55					.byte $55
.9f3d					Assemble_stz:
.9f3d	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f40	60					.byte $60
>9f41	44					.byte $44
.9f42					Assemble_bit:
.9f42	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f45	20					.byte $20
>9f46	55					.byte $55
.9f47					Assemble_sty:
.9f47	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f4a	80					.byte $80
>9f4b	54					.byte $54
.9f4c					Assemble_ldy:
.9f4c	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f4f	a0					.byte $a0
>9f50	d5					.byte $d5
.9f51					Assemble_cpy:
.9f51	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f54	c0					.byte $c0
>9f55	d4					.byte $d4
.9f56					Assemble_cpx:
.9f56	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f59	e0					.byte $e0
>9f5a	d0					.byte $d0
.9f5b					Assemble_tsb:
.9f5b	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f5e	00					.byte $00
>9f5f	50					.byte $50
.9f60					Assemble_trb:
.9f60	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f63	10					.byte $10
>9f64	50					.byte $50
.9f65					Assemble_jsr:
.9f65	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f68	14					.byte $14
>9f69	10					.byte $10
.9f6a					Assemble_jmp:
.9f6a	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f6d	40					.byte $40
>9f6e	10					.byte $10
.9f6f					Assemble_bpl:
.9f6f	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f72	10					.byte $10
.9f73					Assemble_bmi:
.9f73	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f76	30					.byte $30
.9f77					Assemble_bvc:
.9f77	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f7a	50					.byte $50
.9f7b					Assemble_bvs:
.9f7b	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f7e	70					.byte $70
.9f7f					Assemble_bcc:
.9f7f	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f82	90					.byte $90
.9f83					Assemble_bcs:
.9f83	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f86	b0					.byte $b0
.9f87					Assemble_bne:
.9f87	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f8a	d0					.byte $d0
.9f8b					Assemble_beq:
.9f8b	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f8e	f0					.byte $f0
.9f8f					Assemble_bra:
.9f8f	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f92	80					.byte $80
.9f93					Assemble_brk:
.9f93	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9f96	00					.byte $00
.9f97					Assemble_php:
.9f97	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9f9a	08					.byte $08
.9f9b					Assemble_clc:
.9f9b	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9f9e	18					.byte $18
.9f9f					Assemble_plp:
.9f9f	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fa2	28					.byte $28
.9fa3					Assemble_sec:
.9fa3	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fa6	38					.byte $38
.9fa7					Assemble_rti:
.9fa7	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9faa	40					.byte $40
.9fab					Assemble_pha:
.9fab	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fae	48					.byte $48
.9faf					Assemble_cli:
.9faf	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fb2	58					.byte $58
.9fb3					Assemble_phy:
.9fb3	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fb6	5a					.byte $5a
.9fb7					Assemble_rts:
.9fb7	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fba	60					.byte $60
.9fbb					Assemble_pla:
.9fbb	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fbe	68					.byte $68
.9fbf					Assemble_sei:
.9fbf	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fc2	78					.byte $78
.9fc3					Assemble_ply:
.9fc3	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fc6	7a					.byte $7a
.9fc7					Assemble_dey:
.9fc7	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fca	88					.byte $88
.9fcb					Assemble_txa:
.9fcb	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fce	8a					.byte $8a
.9fcf					Assemble_tya:
.9fcf	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fd2	98					.byte $98
.9fd3					Assemble_txs:
.9fd3	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fd6	9a					.byte $9a
.9fd7					Assemble_tay:
.9fd7	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fda	a8					.byte $a8
.9fdb					Assemble_tax:
.9fdb	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fde	aa					.byte $aa
.9fdf					Assemble_clv:
.9fdf	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fe2	b8					.byte $b8
.9fe3					Assemble_tsx:
.9fe3	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fe6	ba					.byte $ba
.9fe7					Assemble_iny:
.9fe7	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fea	c8					.byte $c8
.9feb					Assemble_dex:
.9feb	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fee	ca					.byte $ca
.9fef					Assemble_cld:
.9fef	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9ff2	d8					.byte $d8
.9ff3					Assemble_phx:
.9ff3	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9ff6	da					.byte $da
.9ff7					Assemble_stp:
.9ff7	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9ffa	db					.byte $db
.9ffb					Assemble_inx:
.9ffb	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9ffe	e8					.byte $e8
.9fff					Assemble_nop:
.9fff	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>a002	ea					.byte $ea
.a003					Assemble_sed:
.a003	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>a006	f8					.byte $f8
.a007					Assemble_plx:
.a007	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>a00a	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.a00b					DecimalScalarTable:
>a00b	66 66 66 66				.dword $66666666 ; 0.1
>a00f	de					.byte $de
>a010	1f 85 eb 51				.dword $51eb851f ; 0.01
>a014	db					.byte $db
>a015	4c 37 89 41				.dword $4189374c ; 0.001
>a019	d8					.byte $d8
>a01a	ac 8b db 68				.dword $68db8bac ; 0.0001
>a01e	d4					.byte $d4
>a01f	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>a023	d1					.byte $d1
>a024	83 de 1b 43				.dword $431bde83 ; 1e-06
>a028	ce					.byte $ce
>a029	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>a02d	ca					.byte $ca
>a02e	89 3b e6 55				.dword $55e63b89 ; 1e-08
>a032	c7					.byte $c7
>a033	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>a037	c4					.byte $c4
>a038	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>a03c	c0					.byte $c0
>a03d	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>a041	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.a042					SyntaxError:
.a042	a9 02		lda #$02		lda	#2
.a044	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.a047					RangeError:
.a047	a9 04		lda #$04		lda	#4
.a049	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.a04c					TypeError:
.a04c	a9 05		lda #$05		lda	#5
.a04e	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.a051					ArgumentError:
.a051	a9 07		lda #$07		lda	#7
.a053	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.a056					NotDoneError:
.a056	a9 0c		lda #$0c		lda	#12
.a058	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.a05b					ErrorText:
>a05b	42 72 65 61 6b 00			.text	"Break",0
>a061	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a069	72 72 6f 72 00
>a06e	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a076	20 62 79 20 7a 65 72 6f 00
>a07f	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a087	61 6e 67 65 00
>a08c	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a094	6d 61 74 63 68 00
>a09a	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a0a2	65 6d 6f 72 79 00
>a0a8	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a0b0	61 72 67 75 6d 65 6e 74 00
>a0b9	53 74 6f 70 00				.text	"Stop",0
>a0be	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a0c6	6f 6f 20 6c 6f 6e 67 00
>a0ce	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a0d6	6e 20 66 61 69 6c 65 64 00
>a0df	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a0e7	61 74 61 00
>a0eb	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a0f3	65 6e 74 65 64 00
>a0f9	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a101	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a10d	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a115	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a122	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a12a	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a137	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a13f	68 6f 75 74 20 57 68 69 6c 65 00
>a14a	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a152	68 6f 75 74 20 46 6f 72 00
>a15b	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a163	61 63 6b 20 66 75 6c 6c 00
>a16c	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a174	75 63 74 75 72 65 00
>a17b	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a183	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a190	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a198	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a1a6	41 72 72 61 79 20 73 69			.text	"Array size",0
>a1ae	7a 65 00
>a1b1	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a1b9	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a1c1	42 75 69 6c 74 20 57 65			.text "Built Wednesday 23-Nov-2022. Build 3574."
>a1c9	64 6e 65 73 64 61 79 20 32 33 2d 4e 6f 76 2d 32
>a1d9	30 32 32 2e 20 42 75 69 6c 64 20 33 35 37 34 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a1e9					RectangleCommand:
.a1e9	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a1eb	80 02		bra $a1ef			bra 	ShapeDrawCmd
.a1ed					CircleCommand:
.a1ed	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a1ef					ShapeDrawCmd:
.a1ef	20 7d a2	jsr $a27d			jsr 	RunGraphicsCommand
.a1f2					ShapeDraw:
.a1f2	0d 30 06	ora $0630			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a1f5	4c 71 a2	jmp $a271			jmp 	ExecuteGraphicCommand	 	; and complete
.a1f8					SpriteCommand:
.a1f8	a2 00		ldx #$00			ldx 	#0
.a1fa	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; get image number.
.a1fd	5a		phy				phy
.a1fe	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a200	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a203	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a205	b0 0d		bcs $a214			bcs 	_SCRange
.a207	a0 ff		ldy #$ff			ldy 	#255
.a209	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a20c	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a20e	7a		ply				ply
.a20f	20 7d a2	jsr $a27d			jsr 	RunGraphicsCommand
.a212	80 5d		bra $a271			bra 	ExecuteGraphicCommand
.a214					_SCRange:
.a214	4c 47 a0	jmp $a047			jmp 	RangeError
.a217					ImageCommand:
.a217	a2 00		ldx #$00			ldx 	#0
.a219	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; get image number.
.a21c	20 7d a2	jsr $a27d			jsr 	RunGraphicsCommand
.a21f					ImageRunDraw:
.a21f	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a221	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a224	ad 36 06	lda $0636			lda 	gxDrawScale
.a227	0a		asl a				asl 	a
.a228	0a		asl a				asl 	a
.a229	0a		asl a				asl 	a
.a22a	a8		tay				tay
.a22b	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a22d	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a230	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a233	60		rts				rts
.a234					TextCommand:
.a234	a2 00		ldx #$00			ldx 	#0
.a236	20 ec 9d	jsr $9dec			jsr 	EvaluateString 				; get text
.a239	20 7d a2	jsr $a27d			jsr 	RunGraphicsCommand
.a23c					TextRunDraw:
.a23c	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a23e	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a241	a0 00		ldy #$00			ldy 	#0
.a243					_IRDLoop:
.a243	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a246	85 37		sta $37				sta 	zTemp0+1
.a248	ad 08 04	lda $0408			lda 	NSMantissa0
.a24b	85 36		sta $36				sta 	zTemp0
.a24d	b1 36		lda ($36),y			lda 	(zTemp0),y
.a24f	f0 13		beq $a264			beq 	_IRDExit
.a251	5a		phy				phy									; save string pos
.a252	48		pha				pha 								; save char
.a253	ad 36 06	lda $0636			lda 	gxDrawScale 				; get scale
.a256	0a		asl a				asl 	a
.a257	0a		asl a				asl 	a
.a258	0a		asl a				asl 	a
.a259	a8		tay				tay
.a25a	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a25c	fa		plx				plx 								; char to draw
.a25d	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a260	7a		ply				ply 								; restore string pos
.a261	c8		iny				iny
.a262	90 df		bcc $a243			bcc 	_IRDLoop 					; go back if no error.
.a264					_IRDExit:
.a264	60		rts				rts
.a265					PlotCommand:
.a265	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a267	20 7d a2	jsr $a27d			jsr 	RunGraphicsCommand
.a26a	80 05		bra $a271			bra 	ExecuteGraphicCommand
.a26c					LineCommand:
.a26c	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a26e	20 7d a2	jsr $a27d			jsr 	RunGraphicsCommand
.a271					ExecuteGraphicCommand:
.a271	0d 2f 06	ora $062f			ora 	gxCommandID 				; make a full command
.a274	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw 				; draw it and exit
.a277	b0 01		bcs $a27a			bcs 	_EGCError
.a279	60		rts				rts
.a27a					_EGCError:
.a27a	4c 42 a0	jmp $a042			jmp 	SyntaxError
.a27d					RunGraphicsCommand:
.a27d	8d 2f 06	sta $062f			sta 	gxCommandID					; save TODO graphics command.
.a280	68		pla				pla 								; pop handler address
.a281	fa		plx				plx
.a282	1a		inc a				inc 	a
.a283	d0 01		bne $a286			bne 	_RGINoCarry
.a285	e8		inx				inx
.a286					_RGINoCarry:
.a286	8d 34 06	sta $0634			sta 	GXHandler
.a289	8e 35 06	stx $0635			stx 	GXHandler+1
.a28c					_RGICommandLoop:
.a28c	b1 30		lda ($30),y			lda 	(codePtr),y
.a28e	c8		iny				iny
.a28f	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a291	f0 53		beq $a2e6			beq 	_RGI_To
.a293	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a295	f0 55		beq $a2ec			beq 	_RGI_Here
.a297	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a299	f0 3d		beq $a2d8			beq 	_RGI_Exit
.a29b	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a29d	f0 39		beq $a2d8			beq 	_RGI_Exit
.a29f	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a2a1	f0 3e		beq $a2e1			beq 	_RGI_Frame
.a2a3	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a2a5	f0 33		beq $a2da			beq 	_RGI_Solid
.a2a7	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a2a9	f0 4b		beq $a2f6			beq 	_RGI_By
.a2ab	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a2ad	f0 17		beq $a2c6			beq 	_RGI_Move2
.a2af	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a2b1	f0 65		beq $a318			beq 	_RGI_Dim
.a2b3	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a2b5	f0 78		beq $a32f			beq 	_RGI_Colour
.a2b7	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a2b9	f0 74		beq $a32f			beq 	_RGI_Colour
.a2bb	ae 2f 06	ldx $062f			ldx 	gxCommandID
.a2be	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a2c0	d0 03		bne $a2c5			bne 	_RGI_Move 					; move
.a2c2	4c 59 a3	jmp $a359			jmp		_RGI_SpriteInstructions
.a2c5					_RGI_Move:
.a2c5	88		dey				dey 								; unpick get.
.a2c6					_RGI_Move2:
.a2c6	20 7f a3	jsr $a37f			jsr 	GCGetCoordinatePair 		; move to here
.a2c9	20 a6 a3	jsr $a3a6			jsr 	GCCopyPairToStore 			; save
.a2cc	5a		phy				phy
.a2cd	20 9c a3	jsr $a39c			jsr 	GCLoadAXY 					; load in
.a2d0	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a2d2	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a2d5	7a		ply				ply
.a2d6	80 b4		bra $a28c			bra 	_RGICommandLoop 			; and go round
.a2d8					_RGI_Exit:
.a2d8	88		dey				dey 								; unpick : / EOL
.a2d9	60		rts				rts
.a2da					_RGI_Solid:
.a2da	a9 02		lda #$02			lda 	#2
.a2dc	8d 30 06	sta $0630			sta 	gxFillSolid
.a2df	80 ab		bra $a28c			bra 	_RGICommandLoop
.a2e1					_RGI_Frame:
.a2e1	9c 30 06	stz $0630			stz 	gxFillSolid
.a2e4	80 a6		bra $a28c			bra 	_RGICommandLoop
.a2e6					_RGI_To:
.a2e6	20 7f a3	jsr $a37f			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a2e9	20 a6 a3	jsr $a3a6			jsr 	GCCopyPairToStore
.a2ec					_RGI_Here:
.a2ec	5a		phy				phy
.a2ed	20 9c a3	jsr $a39c			jsr 	GCLoadAXY 					; load it into AXY
.a2f0	20 56 a3	jsr $a356			jsr 	_RGICallHandler 			; go do whatever it is.
.a2f3	7a		ply				ply
.a2f4	80 96		bra $a28c			bra 	_RGICommandLoop 			; and go round
.a2f6					_RGI_By:
.a2f6	20 8c a3	jsr $a38c			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a2f9	18		clc				clc
.a2fa	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a2fd	6d 31 06	adc $0631			adc 	gxxPos
.a300	8d 31 06	sta $0631			sta 	gxXPos
.a303	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a306	6d 32 06	adc $0632			adc 	gxxPos+1
.a309	8d 32 06	sta $0632			sta 	gxXPos+1
.a30c	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a30f	18		clc				clc
.a310	6d 33 06	adc $0633			adc 	gxYPos
.a313	8d 33 06	sta $0633			sta 	gxYPos
.a316	80 d4		bra $a2ec			bra 	_RGI_Here
.a318					_RGI_Dim:
.a318	a2 01		ldx #$01			ldx	 	#1
.a31a	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger
.a31d	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a320	c9 00		cmp #$00			cmp 	#0
.a322	f0 2f		beq $a353			beq 	_RGIRange
.a324	c9 09		cmp #$09			cmp 	#8+1
.a326	b0 2b		bcs $a353			bcs		_RGIRange
.a328	3a		dec a				dec 	a
.a329	8d 36 06	sta $0636			sta 	gxDrawScale
.a32c	4c 8c a2	jmp $a28c			jmp 	_RGICommandLoop
.a32f					_RGI_Colour:
.a32f	a2 01		ldx #$01			ldx 	#1 							; colour
.a331	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger
.a334	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a336	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero
.a339	b1 30		lda ($30),y			lda 	(codePtr),y
.a33b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a33d	d0 04		bne $a343			bne 	_RGICDefaultMode
.a33f	c8		iny				iny
.a340	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger
.a343					_RGICDefaultMode:
.a343	5a		phy				phy
.a344	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a346	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a349	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a34c	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a34f	7a		ply				ply
.a350	4c 8c a2	jmp $a28c			jmp 	_RGICommandLoop 			; and go round
.a353					_RGIRange:
.a353	4c 47 a0	jmp $a047			jmp 	RangeError
.a356					_RGICallHandler:
.a356	6c 34 06	jmp ($0634)			jmp 	(GXHandler)
.a359					_RGI_SpriteInstructions:
.a359	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a35b	f0 07		beq $a364			beq 	_RGISpriteOff
.a35d	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a35f	f0 13		beq $a374			beq 	_RGISetImage
.a361	4c c5 a2	jmp $a2c5			jmp 	_RGI_Move
.a364					_RGISpriteOff:
.a364	5a		phy				phy
.a365	a0 01		ldy #$01			ldy 	#1
.a367	a2 00		ldx #$00			ldx 	#0
.a369					_RGIDoCommandLoop:
.a369	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a36b	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a36e	7a		ply				ply
.a36f	b0 e2		bcs $a353			bcs 	_RGIRange
.a371	4c 8c a2	jmp $a28c			jmp 	_RGICommandLoop
.a374					_RGISetImage:
.a374	a2 01		ldx #$01			ldx 	#1
.a376	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger
.a379	5a		phy				phy
.a37a	aa		tax				tax
.a37b	a0 00		ldy #$00			ldy 	#0
.a37d	80 ea		bra $a369			bra 	_RGIDoCommandLoop
.a37f					GCGetCoordinatePair:
.a37f	a2 01		ldx #$01			ldx 	#1
.a381	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger
.a384	20 e4 8d	jsr $8de4			jsr 	CheckComma
.a387	e8		inx				inx
.a388	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger
.a38b	60		rts				rts
.a38c					GCSignedCoordinatePair:
.a38c	a2 01		ldx #$01			ldx 	#1
.a38e	20 25 9e	jsr $9e25			jsr 	Evaluate16BitIntegerSigned
.a391	20 e4 8d	jsr $8de4			jsr 	CheckComma
.a394	e8		inx				inx
.a395	20 25 9e	jsr $9e25			jsr 	Evaluate16BitIntegerSigned
.a398	60		rts				rts
.a399					_GCCPRange:
.a399	4c 47 a0	jmp $a047			jmp 	RangeError
.a39c					GCLoadAXY:
.a39c	ad 32 06	lda $0632			lda 	gxXPos+1
.a39f	ae 31 06	ldx $0631			ldx 	gxXPos
.a3a2	ac 33 06	ldy $0633			ldy 	gxYPos
.a3a5	60		rts				rts
.a3a6					GCCopyPairToStore:
.a3a6	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a3a9	8d 31 06	sta $0631			sta 	gxXPos
.a3ac	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a3af	8d 32 06	sta $0632			sta 	gxXPos+1
.a3b2	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a3b5	8d 33 06	sta $0633			sta 	gxYPos
.a3b8	60		rts				rts
.062f					gxCommandID:
>062f							.fill 	1
.0630					gxFillSolid:
>0630							.fill 	1
.0631					gxXPos:
>0631							.fill 	2
.0633					gxYPos:
>0633							.fill 	1
.0634					gxHandler:
>0634							.fill 	2
.0636					gxDrawScale:
>0636							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a3b9					BitmapCtrl:
.a3b9	b1 30		lda ($30),y			lda 	(codePtr),y
.a3bb	c8		iny				iny
.a3bc	a2 01		ldx #$01			ldx 	#1
.a3be	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a3c0	f0 11		beq $a3d3			beq 	BitmapSwitch
.a3c2	ca		dex				dex
.a3c3	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a3c5	f0 0c		beq $a3d3			beq 	BitmapSwitch
.a3c7	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; get the colour
.a3ca	5a		phy				phy
.a3cb	aa		tax				tax
.a3cc	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a3ce	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a3d1	7a		ply				ply
.a3d2	60		rts				rts
.a3d3					BitmapSwitch:
.a3d3	5a		phy				phy
.a3d4	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a3d6	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a3d8	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a3db	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a3dd	a0 00		ldy #$00			ldy 	#0
.a3df	a2 ff		ldx #$ff			ldx 	#$FF
.a3e1	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a3e4	9c 30 06	stz $0630			stz 	gxFillSolid
.a3e7	9c 31 06	stz $0631			stz 	gxXPos
.a3ea	9c 32 06	stz $0632			stz 	gxXPos+1
.a3ed	9c 33 06	stz $0633			stz 	gxYPos
.a3f0	9c 36 06	stz $0636			stz 	gxDrawScale
.a3f3	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a3f5	a2 00		ldx #$00			ldx 	#0
.a3f7	a0 00		ldy #$00			ldy 	#0
.a3f9	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a3fc	7a		ply				ply
.a3fd	60		rts				rts
.a3fe					SpritesCtrl:
.a3fe	b1 30		lda ($30),y			lda 	(codePtr),y
.a400	c8		iny				iny
.a401	a2 01		ldx #$01			ldx 	#1
.a403	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a405	f0 08		beq $a40f			beq 	SpriteSwitch
.a407	ca		dex				dex
.a408	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a40a	f0 03		beq $a40f			beq 	SpriteSwitch
.a40c	4c 42 a0	jmp $a042			jmp 	SyntaxError
.a40f					SpriteSwitch:
.a40f	5a		phy				phy
.a410	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a412	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a414	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a417	7a		ply				ply
.a418	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a419					GfxCommand:
.a419	a2 00		ldx #$00			ldx 	#0
.a41b	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; command
.a41e	20 e4 8d	jsr $8de4			jsr 	CheckComma
.a421	e8		inx				inx
.a422	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger 		; X
.a425	20 e4 8d	jsr $8de4			jsr 	CheckComma
.a428	e8		inx				inx
.a429	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; Y
.a42c	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a42f	4a		lsr a				lsr 	a
.a430	d0 16		bne $a448			bne 	_GfxError
.a432	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a435	b0 11		bcs $a448			bcs 	_GfxError 					; bit 7 should have been zero
.a437	5a		phy				phy 								; save pos
.a438	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a43b	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a43e	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a441	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw
.a444	b0 02		bcs $a448			bcs 	_GfxError
.a446	7a		ply				ply 								; restore pos and exit.
.a447	60		rts				rts
.a448					_GfxError:
.a448	4c 47 a0	jmp $a047			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a44b					UnaryHit:
.a44b	fa		plx				plx
.a44c	a9 36		lda #$36			lda 	#zTemp0
.a44e	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a451	20 e4 8d	jsr $8de4			jsr 	CheckComma
.a454	e8		inx				inx
.a455	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a458	20 dc 8d	jsr $8ddc			jsr		CheckRightBracket
.a45b	ca		dex				dex 								; fix back up again.
.a45c	da		phx				phx 								; save X/Y
.a45d	5a		phy				phy
.a45e	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a461	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a464	aa		tax				tax
.a465	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a467	20 82 ab	jsr $ab82			jsr 	GXGraphicDraw 				; calculate result
.a46a	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a46b	7a		ply				ply 								; restore XY
.a46c	fa		plx				plx
.a46d	20 ba 9e	jsr $9eba			jsr 	NSMSetByte 					; return the hit result
.a470	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a471					PaletteCommand:
.a471	a2 00		ldx #$00			ldx 	#0
.a473	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; colour
.a476	20 e4 8d	jsr $8de4			jsr 	CheckComma
.a479	e8		inx				inx
.a47a	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger 		; r
.a47d	20 e4 8d	jsr $8de4			jsr 	CheckComma
.a480	e8		inx				inx
.a481	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; g
.a484	20 e4 8d	jsr $8de4			jsr 	CheckComma
.a487	e8		inx				inx
.a488	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; b
.a48b	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a48e	85 36		sta $36				sta 	zTemp0
.a490	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a492	85 37		sta $37				sta 	zTemp0+1
.a494	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a496	26 37		rol $37				rol	 	zTemp0+1
.a498	06 36		asl $36				asl 	zTemp0
.a49a	26 37		rol $37				rol	 	zTemp0+1
.a49c	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a49e	85 01		sta $01				sta 	1
.a4a0	5a		phy				phy
.a4a1	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a4a4	92 36		sta ($36)			sta 	(zTemp0)
.a4a6	a0 01		ldy #$01			ldy 	#1
.a4a8	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a4ab	91 36		sta ($36),y			sta 	(zTemp0),y
.a4ad	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a4b0	c8		iny				iny
.a4b1	91 36		sta ($36),y			sta 	(zTemp0),y
.a4b3	7a		ply				ply
.a4b4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a4b5					UnaryEvent:
.a4b5	fa		plx				plx
.a4b6	20 6f a5	jsr $a56f			jsr 	TimerToStackX 				; timer in +0
.a4b9	e8		inx				inx  								; put reference into +1
.a4ba	20 7e 98	jsr $987e			jsr 	EvaluateTerm
.a4bd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a4c0	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a4c2	d0 57		bne $a51b			bne 	_UEType
.a4c4	e8		inx				inx 								; put the step in +2
.a4c5	20 e4 8d	jsr $8de4			jsr 	CheckComma
.a4c8	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger
.a4cb	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.a4ce	ca		dex				dex
.a4cf	ca		dex				dex
.a4d0	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a4d3	85 36		sta $36				sta 	zTemp0
.a4d5	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a4d8	85 37		sta $37				sta 	zTemp0+1
.a4da	5a		phy				phy
.a4db	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a4dd	b1 36		lda ($36),y			lda 	(zTemp0),y
.a4df	30 36		bmi $a517			bmi 	_UEFalse 					; exit if signed.
.a4e1	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a4e3	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a4e6	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a4e8	c8		iny				iny
.a4e9	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a4ec	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4ee	c8		iny				iny
.a4ef	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a4f2	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4f4	90 21		bcc $a517			bcc 	_UEFalse 					; no, return FALSE.
.a4f6	18		clc				clc
.a4f7	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a4f9	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a4fc	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a4ff	91 36		sta ($36),y			sta 	(zTemp0),y
.a501	c8		iny				iny
.a502	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a505	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a508	91 36		sta ($36),y			sta 	(zTemp0),y
.a50a	c8		iny				iny
.a50b	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a50e	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a511	91 36		sta ($36),y			sta 	(zTemp0),y
.a513	7a		ply				ply
.a514	4c 62 8e	jmp $8e62			jmp 	ReturnTrue
.a517					_UEFalse:
.a517	7a		ply				ply 								; restore Y
.a518	4c 6e 8e	jmp $8e6e			jmp 	ReturnFalse 				; and return False
.a51b					_UEType:
.a51b	4c 4c a0	jmp $a04c			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a51e					UnaryJoyX:
.a51e	18		clc				clc
.a51f	80 01		bra $a522			bra 	JoyMain
.a521					UnaryJoyY:
.a521	38		sec				sec
.a522					JoyMain:
.a522	fa		plx				plx 								; get pos
.a523	08		php				php 								; save carry (set for Y)
.a524	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a527	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.a52a	20 3b ab	jsr $ab3b			jsr 	EXTReadController 			; read the controller.
.a52d	28		plp				plp
.a52e	90 02		bcc $a532			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a530	4a		lsr a				lsr 	a
.a531	4a		lsr a				lsr 	a
.a532					_JMNoShift:
.a532	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a533	b0 0a		bcs $a53f			bcs 	_JMIsRight
.a535	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a536	b0 04		bcs $a53c			bcs 	_JMIsLeft
.a538	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero 					; zero result
.a53b	60		rts				rts
.a53c					_JMIsLeft:
.a53c	4c 62 8e	jmp $8e62			jmp 	ReturnTrue
.a53f					_JMIsRight:
.a53f	a9 01		lda #$01			lda 	#1
.a541	20 ba 9e	jsr $9eba			jsr 	NSMSetByte
.a544	60		rts				rts
.a545					UnaryJoyB:
.a545	fa		plx				plx 								; get pos
.a546	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a549	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.a54c	20 3b ab	jsr $ab3b			jsr 	EXTReadController 			; read the controller.
.a54f	4a		lsr a				lsr 	a
.a550	4a		lsr a				lsr 	a
.a551	4a		lsr a				lsr 	a
.a552	4a		lsr a				lsr 	a
.a553	29 01		and #$01			and 	#1
.a555	20 ba 9e	jsr $9eba			jsr 	NSMSetByte
.a558	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a559					LoadCommand:
.a559	20 46 89	jsr $8946			jsr 	NewProgram
.a55c	20 e6 82	jsr $82e6			jsr 	BackLoadProgram
.a55f	4c 56 83	jmp $8356			jmp 	WarmStart
.a562					GoCommand:
.a562	20 46 89	jsr $8946			jsr 	NewProgram
.a565	20 e6 82	jsr $82e6			jsr 	BackLoadProgram
.a568	4c 85 8a	jmp $8a85			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a56b					UnaryTimer:
.a56b	fa		plx				plx
.a56c	20 dc 8d	jsr $8ddc			jsr 	CheckRightBracket
.a56f					TimerToStackX:
.a56f	20 b8 9e	jsr $9eb8			jsr 	NSMSetZero 					; zero result
.a572	64 01		stz $01				stz 	1 							; access I/O
.a574	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a577	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a57a	ad 5a d6	lda $d65a			lda 	$D65A
.a57d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a580	ad 5b d6	lda $d65b			lda 	$D65B
.a583	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a586	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a587					MemoryDeleteLine:
.a587	20 a6 a5	jsr $a5a6			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a58a	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a58c	a8		tay				tay
.a58d					_MDDLLoop:
.a58d	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a58f	92 30		sta ($30)			sta 	(codePtr)
.a591	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a593	c5 3a		cmp $3a				cmp 	zTemp2
.a595	d0 07		bne $a59e			bne 	_MDLDLNext
.a597	a5 31		lda $31				lda 	codePtr+1
.a599	c5 3b		cmp $3b				cmp 	zTemp2+1
.a59b	d0 01		bne $a59e			bne 	_MDLDLNext
.a59d					_MDDLExit:
.a59d	60		rts				rts
.a59e					_MDLDLNext:
.a59e	e6 30		inc $30				inc 	codePtr						; next byte
.a5a0	d0 eb		bne $a58d			bne 	_MDDLLoop
.a5a2	e6 31		inc $31				inc 	codePtr+1
.a5a4	80 e7		bra $a58d			bra 	_MDDLLoop
.a5a6					IMemoryFindEnd:
.a5a6	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5a8	85 3a		sta $3a				sta 	0+zTemp2
.a5aa	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5ac	85 3b		sta $3b				sta 	1+zTemp2
.a5ae					_MDLFELoop:
.a5ae	b2 3a		lda ($3a)			lda 	(zTemp2)
.a5b0	f0 0b		beq $a5bd			beq 	_MDLFEExit
.a5b2	18		clc				clc
.a5b3	65 3a		adc $3a				adc 	zTemp2
.a5b5	85 3a		sta $3a				sta 	zTemp2
.a5b7	90 f5		bcc $a5ae			bcc 	_MDLFELoop
.a5b9	e6 3b		inc $3b				inc 	zTemp2+1
.a5bb	80 f1		bra $a5ae			bra 	_MDLFELoop
.a5bd					_MDLFEExit:
.a5bd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a5be					MemoryInsertLine:
.a5be	08		php				php
.a5bf	20 a6 a5	jsr $a5a6			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a5c2	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a5c4	1a		inc a				inc 	a
.a5c5	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a5c7	b0 36		bcs $a5ff			bcs 	_MDLIError
.a5c9	28		plp				plp
.a5ca	90 08		bcc $a5d4			bcc 	_MDLIFound
.a5cc	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a5ce	85 30		sta $30				sta 	codePtr
.a5d0	a5 3b		lda $3b				lda 	zTemp2+1
.a5d2	85 31		sta $31				sta 	codePtr+1
.a5d4					_MDLIFound:
.a5d4	ad a9 04	lda $04a9			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a5d7	a8		tay				tay
.a5d8					_MDLIInsert:
.a5d8	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a5da	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a5dc	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a5de	c5 3a		cmp $3a				cmp 	zTemp2
.a5e0	d0 06		bne $a5e8			bne 	_MDLINext
.a5e2	a5 31		lda $31				lda 	codePtr+1
.a5e4	c5 3b		cmp $3b				cmp 	zTemp2+1
.a5e6	f0 0a		beq $a5f2			beq 	_MDLIHaveSpace
.a5e8					_MDLINext:
.a5e8	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a5ea	d0 02		bne $a5ee			bne 	_MDLINoBorrow
.a5ec	c6 3b		dec $3b				dec 	zTemp2+1
.a5ee					_MDLINoBorrow:
.a5ee	c6 3a		dec $3a				dec 	zTemp2
.a5f0	80 e6		bra $a5d8			bra 	_MDLIInsert
.a5f2					_MDLIHaveSpace:
.a5f2	ac a9 04	ldy $04a9			ldy 	tokenOffset 				; bytes to copy
.a5f5	88		dey				dey 								; from offset-1 to 0
.a5f6					_MDLICopy:
.a5f6	b9 a9 04	lda $04a9,y			lda 	tokenOffset,y
.a5f9	91 30		sta ($30),y			sta 	(codePtr),y
.a5fb	88		dey				dey
.a5fc	10 f8		bpl $a5f6			bpl 	_MDLICopy
.a5fe	60		rts				rts
.a5ff					_MDLIError:
.a5ff	a9 06		lda #$06		lda	#6
.a601	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.a604					MDLAppendLine:
.a604	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a606	85 36		sta $36				sta 	zTemp0
.a608	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a60a	85 38		sta $38				sta 	0+zTemp1
.a60c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a60e	85 39		sta $39				sta 	1+zTemp1
.a610	b2 38		lda ($38)			lda 	(zTemp1)
.a612	d0 0a		bne $a61e			bne 	_MDLANoInitialise
.a614	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a616	8d 37 06	sta $0637			sta 	0+AppendPointer
.a619	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a61b	8d 38 06	sta $0638			sta 	1+AppendPointer
.a61e					_MDLANoInitialise:
.a61e	18		clc				clc
.a61f	ad 37 06	lda $0637			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a622	85 38		sta $38				sta 	zTemp1
.a624	72 36		adc ($36)			adc 	(zTemp0)
.a626	8d 37 06	sta $0637			sta 	AppendPointer
.a629	ad 38 06	lda $0638			lda 	AppendPointer+1
.a62c	85 39		sta $39				sta 	zTemp1+1
.a62e	69 00		adc #$00			adc 	#0
.a630	8d 38 06	sta $0638			sta 	AppendPointer+1
.a633	a0 00		ldy #$00			ldy 	#0
.a635					_MDLACopy:
.a635	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a637	91 38		sta ($38),y			sta 	(zTemp1),y
.a639	c8		iny				iny
.a63a	98		tya				tya
.a63b	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a63d	d0 f6		bne $a635			bne 	_MDLACopy
.a63f	a9 00		lda #$00			lda 	#0 							; end of program.
.a641	91 38		sta ($38),y			sta 	(zTemp1),y
.a643	60		rts				rts
.0637					AppendPointer:
>0637							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a644					MemoryNew:
.a644	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a646	85 30		sta $30				sta 	codePtr
.a648	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a64a	85 31		sta $31				sta 	codePtr+1
.a64c	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a64e	92 30		sta ($30)			sta 	(codePtr)
.a650	60		rts				rts
.a651					MemoryInline:
.a651	98		tya				tya 								; put address into stack,x
.a652	18		clc				clc
.a653	65 30		adc $30				adc 	codePtr
.a655	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a658	a5 31		lda $31				lda 	codePtr+1
.a65a	69 00		adc #$00			adc 	#0
.a65c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a65f	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a662	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a665	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a666					MemorySearch:
.a666	85 36		sta $36				sta 	zTemp0 						; save line number zTemp0
.a668	86 37		stx $37				stx 	zTemp0+1
.a66a	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a66c	85 30		sta $30				sta 	codePtr
.a66e	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a670	85 31		sta $31				sta 	codePtr+1
.a672					_MTAXLoop:
.a672	b2 30		lda ($30)			lda 	(codePtr)
.a674	18		clc				clc
.a675	f0 21		beq $a698			beq 	_MTAXExit 					; reached end, exit with CC.
.a677	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a679	b1 30		lda ($30),y			lda 	(codePtr),y
.a67b	38		sec				sec
.a67c	e5 36		sbc $36				sbc 	zTemp0
.a67e	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a680	c8		iny				iny 								; do the MSB
.a681	b1 30		lda ($30),y			lda 	(codePtr),y
.a683	e5 37		sbc $37				sbc 	zTemp0+1
.a685	05 38		ora $38				ora 	zTemp1
.a687	f0 0f		beq $a698			beq 	_MTAXExit	 				; found
.a689	b0 0d		bcs $a698			bcs 	_MTAXExit 					; current < required exit
.a68b	18		clc				clc
.a68c	b2 30		lda ($30)			lda 	(codePtr)					; get offset
.a68e	65 30		adc $30				adc 	codePtr
.a690	85 30		sta $30				sta 	codePtr
.a692	90 02		bcc $a696			bcc 	_CREExit
.a694	e6 31		inc $31				inc 	codePtr+1
.a696					_CREExit:
.a696	80 da		bra $a672			bra 	_MTAXLoop
.a698					_MTAXExit:
.a698	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a699					UnaryPlaying:
.a699	fa		plx				plx
.a69a	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; get channel #
.a69d	48		pha				pha
.a69e	20 dc 8d	jsr $8ddc			jsr		CheckRightBracket
.a6a1	68		pla				pla
.a6a2	c9 04		cmp #$04			cmp 	#4
.a6a4	b0 0c		bcs $a6b2			bcs 	_UPNotPlaying
.a6a6	09 20		ora #$20			ora 	#$20 						; query playing ?
.a6a8	20 10 ba	jsr $ba10			jsr 	SNDCommand
.a6ab	c9 00		cmp #$00			cmp 	#0
.a6ad	f0 03		beq $a6b2			beq 	_UPNotPlaying
.a6af	4c 62 8e	jmp $8e62			jmp 	ReturnTrue
.a6b2					_UPNotPlaying:
.a6b2	4c 6e 8e	jmp $8e6e			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a6b5					SoundCommand:
.a6b5	b1 30		lda ($30),y			lda 	(codePtr),y
.a6b7	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a6b9	d0 09		bne $a6c4			bne 	_SNDMain
.a6bb	c8		iny				iny 								; skip OFF
.a6bc	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a6be	5a		phy				phy
.a6bf	20 10 ba	jsr $ba10			jsr 	SNDCommand
.a6c2	7a		ply				ply
.a6c3	60		rts				rts
.a6c4					_SNDMain:
.a6c4	a2 00		ldx #$00			ldx 	#0
.a6c6	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; channel
.a6c9	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a6cb	b0 50		bcs $a71d			bcs 	_SndError
.a6cd	e8		inx				inx 								; do the rest in slot 1.
.a6ce	20 e4 8d	jsr $8de4			jsr 	CheckComma
.a6d1	20 19 9e	jsr $9e19			jsr 	Evaluate16BitInteger 		; Pitch
.a6d4	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a6d7	c9 10		cmp #$10			cmp 	#16
.a6d9	b0 42		bcs $a71d			bcs 	_SndError
.a6db	8d 3a 06	sta $063a			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a6de	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a6e1	8d 39 06	sta $0639			sta 	SoundCommandBlock
.a6e4	20 e4 8d	jsr $8de4			jsr 	CheckComma
.a6e7	20 39 9e	jsr $9e39			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a6ea	8d 3c 06	sta $063c			sta 	SoundCommandBlock+3
.a6ed	a9 0f		lda #$0f			lda 	#15
.a6ef	8d 3b 06	sta $063b			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a6f2	9c 3d 06	stz $063d			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a6f5	9c 3e 06	stz $063e			stz 	SoundCommandBlock+5
.a6f8	b1 30		lda ($30),y			lda 	(codePtr),y
.a6fa	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a6fc	d0 10		bne $a70e			bne 	_SNDPlay
.a6fe	c8		iny				iny
.a6ff	20 25 9e	jsr $9e25			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a702	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a705	8d 3d 06	sta $063d			sta 	SoundCommandBlock+4
.a708	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a70b	8d 3e 06	sta $063e			sta 	SoundCommandBlock+5
.a70e					_SNDPlay:
.a70e	5a		phy				phy
.a70f	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a712	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a714	a2 39		ldx #$39			ldx 	#(SoundCommandBlock & $FF)
.a716	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a718	20 10 ba	jsr $ba10			jsr 	SNDCommand
.a71b	7a		ply				ply
.a71c	60		rts				rts
.a71d					_SndError:
.a71d	4c 47 a0	jmp $a047			jmp 	RangeError
.0639					SoundCommandBlock:
>0639							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a720					StackPushByte:
.a720	48		pha				pha 								; save byte
.a721	a5 34		lda $34				lda 	BasicStack
.a723	d0 09		bne $a72e			bne 	_SPBNoBorrow
.a725	c6 35		dec $35				dec 	BasicStack+1
.a727	48		pha				pha
.a728	a5 35		lda $35				lda 	BasicStack+1
.a72a	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a72c	90 06		bcc $a734			bcc 	_SPBMemory
.a72e					_SPBNoBorrow:
.a72e	c6 34		dec $34				dec 	BasicStack
.a730	68		pla				pla 								; get back and write
.a731	92 34		sta ($34)			sta 	(BasicStack)
.a733	60		rts				rts
.a734					_SPBMemory:
.a734	a9 12		lda #$12		lda	#18
.a736	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.a739					StackPopByte:
.a739	b2 34		lda ($34)			lda 	(BasicStack)
.a73b	e6 34		inc $34				inc 	BasicStack
.a73d	d0 02		bne $a741			bne 	_SPBNoCarry
.a73f	e6 35		inc $35				inc 	BasicStack+1
.a741					_SPBNoCarry:
.a741	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a742					StackOpen:
.a742	48		pha				pha 								; save frame byte
.a743	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a745	0a		asl a				asl 	a 							; claim twice this for storage
.a746	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a748	38		sec				sec 								; so basically subtracting from
.a749	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a74b	85 34		sta $34				sta 	basicStack
.a74d	b0 08		bcs $a757			bcs 	_SONoBorrow
.a74f	c6 35		dec $35				dec 	basicStack+1
.a751	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a753	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a755	90 04		bcc $a75b			bcc 	_SOMemory
.a757					_SONoBorrow:
.a757	68		pla				pla 								; get marker back and write at TOS
.a758	92 34		sta ($34)			sta 	(basicStack)
.a75a	60		rts				rts
.a75b					_SOMemory:
.a75b	a9 12		lda #$12		lda	#18
.a75d	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.a760					StackClose:
.a760	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a762	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a764	0a		asl a				asl 	a 							; claim twice this.
.a765	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a767	85 34		sta $34				sta 	basicStack
.a769	90 02		bcc $a76d			bcc 	_SCExit
.a76b	e6 35		inc $35				inc 	basicStack+1
.a76d					_SCExit:
.a76d	60		rts				rts
.a76e					StackCheckFrame:
.a76e	48		pha				pha
.a76f					_StackRemoveLocals:
.a76f	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a771	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a773	b0 05		bcs $a77a			bcs 	_SCNoLocal
.a775	20 f5 88	jsr $88f5			jsr 	LocalPopValue
.a778	80 f5		bra $a76f			bra 	_StackRemoveLocals
.a77a					_SCNoLocal:
.a77a	68		pla				pla
.a77b	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a77d	29 f0		and #$f0			and 	#$F0 						; check type bits
.a77f	d0 01		bne $a782			bne 	_SCFError 					; different, we have structures mixed up
.a781	60		rts				rts
.a782					_SCFError:
.a782	8a		txa				txa 								; report error X
.a783	4c f5 8d	jmp $8df5			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a786					STKSaveCodePosition:
.a786	5a		phy				phy
.a787	98		tya				tya 								; save Y
.a788	a0 05		ldy #$05			ldy 	#5
.a78a	91 34		sta ($34),y			sta 	(basicStack),y
.a78c	88		dey				dey 								; save Code Pointer
.a78d					_STKSaveLoop:
.a78d	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a790	91 34		sta ($34),y			sta 	(basicStack),y
.a792	88		dey				dey
.a793	d0 f8		bne $a78d			bne 	_STKSaveLoop
.a795	7a		ply				ply
.a796	60		rts				rts
.a797					STKLoadCodePosition:
.a797	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a799					_STKLoadLoop:
.a799	b1 34		lda ($34),y			lda 	(basicStack),y
.a79b	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a79e	c8		iny				iny
.a79f	c0 05		cpy #$05			cpy 	#5
.a7a1	d0 f6		bne $a799			bne 	_STKLoadLoop
.a7a3	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a7a5	a8		tay				tay
.a7a6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a7a7					StackReset:
.a7a7	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a7a9	85 34		sta $34				sta 	0+basicStack
.a7ab	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a7ad	85 35		sta $35				sta 	1+basicStack
.a7af	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a7b1	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a7b3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a7b4					StringConcrete:
.a7b4	5a		phy				phy 								; save position on stack
.a7b5	20 81 9a	jsr $9a81			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7b8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a7bb	85 38		sta $38				sta 	zTemp1
.a7bd	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a7c0	85 39		sta $39				sta 	zTemp1+1
.a7c2	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a7c4					_SALength:
.a7c4	c8		iny				iny
.a7c5	b1 38		lda ($38),y			lda 	(zTemp1),y
.a7c7	d0 fb		bne $a7c4			bne 	_SALength
.a7c9	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a7cb	b0 3f		bcs $a80c			bcs 	_SALengthError
.a7cd	98		tya				tya 				 				; length of the new string
.a7ce	18		clc				clc
.a7cf	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a7d1	90 02		bcc $a7d5			bcc 	_SAHaveLength
.a7d3	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a7d5					_SAHaveLength:
.a7d5	48		pha				pha 								; save length.
.a7d6	38		sec				sec
.a7d7	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a7d9	6d 8e 04	adc $048e			adc 	StringMemory
.a7dc	8d 8e 04	sta $048e			sta 	StringMemory
.a7df	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a7e1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a7e4	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a7e6	6d 8f 04	adc $048f			adc 	StringMemory+1
.a7e9	8d 8f 04	sta $048f			sta 	StringMemory+1
.a7ec	85 3b		sta $3b				sta 	zTemp2+1
.a7ee	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a7f1	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a7f2	38		sec				sec
.a7f3	e9 03		sbc #$03			sbc 	#3
.a7f5	92 3a		sta ($3a)			sta 	(zTemp2)
.a7f7	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a7f9	a0 01		ldy #$01			ldy 	#1
.a7fb	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a7fd					_SACopyNewString:
.a7fd	a0 00		ldy #$00			ldy 	#0
.a7ff					_SACopyNSLoop:
.a7ff	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a801	c8		iny				iny 								; write two on in string storage
.a802	c8		iny				iny
.a803	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a805	88		dey				dey 								; this makes it one one.
.a806	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a808	d0 f5		bne $a7ff			bne 	_SACopyNSLoop
.a80a	7a		ply				ply
.a80b	60		rts				rts
.a80c					_SALengthError:
.a80c	a9 09		lda #$09		lda	#9
.a80e	4c f5 8d	jmp $8df5		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a811					StringSystemInitialise:
.a811	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a813	8d 8e 04	sta $048e			sta 	0+StringMemory
.a816	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a818	8d 8f 04	sta $048f			sta 	1+StringMemory
.a81b	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a81e	60		rts				rts
.a81f					StringSpaceInitialise:
.a81f	20 81 9a	jsr $9a81			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a822	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a824	8d 90 04	sta $0490			sta 	StringInitialised
.a827	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a82a	8d 91 04	sta $0491			sta 	StringTempPointer
.a82d	ad 8f 04	lda $048f			lda 	StringMemory+1
.a830	3a		dec a				dec 	a
.a831	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a834	60		rts				rts
.a835					StringTempAllocate:
.a835	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a837	b0 35		bcs $a86e			bcs 	_STALength
.a839	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a83c	30 05		bmi $a843			bmi 	_STAAllocate
.a83e	48		pha				pha 								; save value to subtract.
.a83f	20 1f a8	jsr $a81f			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a842	68		pla				pla 								; restore it
.a843					_STAAllocate:
.a843	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a845	18		clc				clc  								; deliberate allows one more
.a846	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a849	8d 91 04	sta $0491			sta 	StringTempPointer
.a84c	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a84f	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a851	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a854	69 ff		adc #$ff			adc 	#$FF
.a856	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a859	85 3d		sta $3d				sta 	zsTemp+1
.a85b	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a85e	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a861	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a864	a9 10		lda #$10			lda 	#NSTString
.a866	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a869	a9 00		lda #$00			lda 	#0 							; clear the target string
.a86b	92 3c		sta ($3c)			sta 	(zsTemp)
.a86d	60		rts				rts
.a86e					_STALength:
.a86e	a9 09		lda #$09		lda	#9
.a870	4c f5 8d	jmp $8df5		jmp	ErrorHandler
.a873					StringTempWrite:
.a873	48		pha				pha
.a874	92 3c		sta ($3c)			sta 	(zsTemp)
.a876	e6 3c		inc $3c				inc 	zsTemp
.a878	d0 02		bne $a87c			bne 	_STWNoCarry
.a87a	e6 3d		inc $3d				inc 	zsTemp+1
.a87c					_STWNoCarry:
.a87c	a9 00		lda #$00			lda 	#0
.a87e	92 3c		sta ($3c)			sta 	(zsTemp)
.a880	68		pla				pla
.a881	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a882					EXTPrintCharacter:
.a882	48		pha				pha
.a883	da		phx				phx
.a884	5a		phy				phy
.a885	a6 01		ldx $01				ldx 	1
.a887	da		phx				phx
.a888	ac 40 06	ldy $0640			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a88b	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a88d	30 48		bmi $a8d7			bmi 	_EXPCColour
.a88f	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a891	90 4d		bcc $a8e0			bcc 	_EXPCControl
.a893	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a895	86 01		stx $01				stx 	1
.a897	91 40		sta ($40),y			sta 	(EXTAddress),y
.a899	e6 01		inc $01				inc 	1 							; select colour memory
.a89b	ad 41 06	lda $0641			lda 	EXTTextColour
.a89e	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8a0	c8		iny				iny 								; advance horizontal position
.a8a1	8c 40 06	sty $0640			sty 	EXTColumn
.a8a4	cc 42 06	cpy $0642			cpy 	EXTScreenWidth 				; reached RHS ?
.a8a7	90 66		bcc $a90f			bcc 	_EXPCExit 					; no, then exit.
.a8a9					_EXPCCRLF:
.a8a9	ee 3f 06	inc $063f			inc 	EXTRow  					; bump row
.a8ac	9c 40 06	stz $0640			stz 	EXTColumn 					; back to column 0
.a8af	ad 3f 06	lda $063f			lda 	EXTRow 						; check if reached the bottom ?
.a8b2	cd 43 06	cmp $0643			cmp 	EXTScreenHeight 			; if so, then scroll.
.a8b5	f0 18		beq $a8cf			beq 	_EXPCScroll
.a8b7	18		clc				clc 								; add width to address.
.a8b8	a5 40		lda $40				lda 	EXTAddress
.a8ba	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a8bd	85 40		sta $40				sta 	EXTAddress
.a8bf	90 4e		bcc $a90f			bcc 	_EXPCExit
.a8c1	e6 41		inc $41				inc 	EXTAddress+1
.a8c3	80 4a		bra $a90f			bra 	_EXPCExit
.a8c5					_EXPCLeft:
.a8c5	ce 40 06	dec $0640			dec 	EXTColumn
.a8c8	10 45		bpl $a90f			bpl 	_EXPCExit
.a8ca					_EXPCBegin:
.a8ca	9c 40 06	stz $0640			stz 	EXTColumn
.a8cd	80 40		bra $a90f			bra 	_EXPCExit
.a8cf					_EXPCScroll:
.a8cf	ce 3f 06	dec $063f			dec 	EXTRow 						; the height-1 th line.
.a8d2	20 9c a9	jsr $a99c			jsr 	EXTScreenScroll 			; scroll the screen
.a8d5	80 38		bra $a90f			bra 	_EXPCExit
.a8d7					_EXPCColour:
.a8d7	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a8d9	b0 34		bcs $a90f			bcs 	_EXPCExit
.a8db	20 7c a9	jsr $a97c			jsr 	_EXPCHandleColour
.a8de	80 2f		bra $a90f			bra 	_EXPCExit
.a8e0					_EXPCControl:
.a8e0	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a8e2	b0 2b		bcs $a90f			bcs 	_EXPCExit
.a8e4	0a		asl a				asl 	a 							; double into X
.a8e5	aa		tax				tax
.a8e6	7c 5a a9	jmp ($a95a,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a8e9					_EXPCUp:
.a8e9	ad 3f 06	lda $063f			lda 	EXTRow 						; already at top ?
.a8ec	f0 21		beq $a90f			beq 	_EXPCExit
.a8ee	ce 3f 06	dec $063f			dec 	EXTRow 						; up one in position/address
.a8f1	38		sec				sec
.a8f2	a5 40		lda $40				lda 	EXTAddress
.a8f4	ed 42 06	sbc $0642			sbc 	EXTScreenWidth
.a8f7	85 40		sta $40				sta 	EXTAddress
.a8f9	b0 14		bcs $a90f			bcs 	_EXPCExit
.a8fb	c6 41		dec $41				dec 	EXTAddress+1
.a8fd	80 10		bra $a90f			bra 	_EXPCExit
.a8ff					_EXPCRight:
.a8ff	c8		iny				iny
.a900	8c 40 06	sty $0640			sty 	EXTColumn
.a903	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.a906	d0 07		bne $a90f			bne 	_EXPCExit
.a908					_EXPCEnd:
.a908	ad 42 06	lda $0642			lda 	EXTScreenWidth
.a90b	3a		dec a				dec 	a
.a90c	8d 40 06	sta $0640			sta 	EXTColumn
.a90f					_EXPCExit:
.a90f	20 f1 a9	jsr $a9f1			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a912	68		pla				pla
.a913	85 01		sta $01				sta 	1
.a915	7a		ply				ply
.a916	fa		plx				plx
.a917	68		pla				pla
.a918	60		rts				rts
.a919					_EXPCClearScreen:
.a919	20 ae a9	jsr $a9ae			jsr		EXTClearScreenCode
.a91c	80 f1		bra $a90f			bra 	_EXPCExit
.a91e					_EXPCDown:
.a91e	ad 43 06	lda $0643			lda 	EXTScreenHeight 			; at the bottom
.a921	3a		dec a				dec 	a
.a922	cd 3f 06	cmp $063f			cmp 	EXTRow
.a925	f0 e8		beq $a90f			beq 	_EXPCExit
.a927	ee 3f 06	inc $063f			inc 	EXTRow 						; down one in position/address
.a92a	18		clc				clc
.a92b	a5 40		lda $40				lda 	EXTAddress
.a92d	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a930	85 40		sta $40				sta 	EXTAddress
.a932	90 db		bcc $a90f			bcc 	_EXPCExit
.a934	e6 41		inc $41				inc 	EXTAddress+1
.a936	80 d7		bra $a90f			bra 	_EXPCExit
.a938					_EXPCTab:
.a938	ad 40 06	lda $0640			lda 	EXTColumn 					; next tab stop
.a93b	29 f8		and #$f8			and 	#$F8
.a93d	18		clc				clc
.a93e	69 08		adc #$08			adc 	#8
.a940	8d 40 06	sta $0640			sta 	EXTColumn
.a943	cd 42 06	cmp $0642			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a946	90 c7		bcc $a90f			bcc 	_EXPCExit
.a948	80 be		bra $a908			bra 	_EXPCEnd
.a94a					_EXPCBackSpace:
.a94a	88		dey				dey
.a94b	30 c2		bmi $a90f			bmi 	_EXPCExit
.a94d	ce 40 06	dec $0640			dec 	EXTColumn
.a950	a9 02		lda #$02			lda 	#2
.a952	85 01		sta $01				sta 	1
.a954	a9 20		lda #$20			lda 	#32
.a956	91 40		sta ($40),y			sta 	(EXTAddress),y
.a958	80 b5		bra $a90f			bra 	_EXPCExit
.a95a					_EXPCActionTable:
>a95a	0f a9						.word 	_EXPCExit 					; 00
>a95c	ca a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a95e	c5 a8						.word 	_EXPCLeft 					; 02 B Left
>a960	0f a9						.word 	_EXPCExit 					; 03 <Break>
>a962	0f a9						.word 	_EXPCExit 					; 04
>a964	08 a9						.word 	_EXPCEnd 					; 05 E End of Line
>a966	ff a8						.word 	_EXPCRight 					; 06 F Right
>a968	0f a9						.word 	_EXPCExit 					; 07
>a96a	4a a9						.word 	_EXPCBackspace 				; 08 H Backspace
>a96c	38 a9						.word 	_EXPCTab 					; 09 I Tab
>a96e	0f a9						.word 	_EXPCExit 					; 0A
>a970	0f a9						.word 	_EXPCExit 					; 0B
>a972	19 a9						.word 	_EXPCClearScreen			; 0C L CLS
>a974	a9 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a976	1e a9						.word 	_EXPCDown 					; 0E N Down
>a978	0f a9						.word 	_EXPCExit 					; 0F
>a97a	e9 a8						.word 	_EXPCUp 					; 10 P Up
.a97c					_EXPCHandleColour
.a97c	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a97e	b0 16		bcs $a996			bcs 	_EXPCBackground
.a980	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a981	0a		asl a				asl 	a
.a982	0a		asl a				asl 	a
.a983	0a		asl a				asl 	a
.a984	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a986					_EXPCUpdate:
.a986	48		pha				pha 								; save new colour
.a987	8a		txa				txa 								; get mask
.a988	2d 41 06	and $0641			and 	EXTTextColour 				; mask out old.
.a98b	8d 41 06	sta $0641			sta 	EXTTextColour
.a98e	68		pla				pla 								; or in new colour
.a98f	0d 41 06	ora $0641			ora 	EXTTextColour
.a992	8d 41 06	sta $0641			sta 	EXTTextColour
.a995	60		rts				rts
.a996					_EXPCBackground:
.a996	29 0f		and #$0f			and 	#$0F 						; get the colour
.a998	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a99a	80 ea		bra $a986			bra 	_EXPCUpdate
.a99c					EXTScreenScroll:
.a99c	a9 02		lda #$02			lda 	#2 							; select text page
.a99e	85 01		sta $01				sta 	1
.a9a0	a9 20		lda #$20			lda		#32 						; fill with space
.a9a2	20 b1 aa	jsr $aab1			jsr 	EXTScrollFill
.a9a5	e6 01		inc $01				inc 	1 							; select colour page
.a9a7	ad 41 06	lda $0641			lda 	EXTTextColour
.a9aa	20 b1 aa	jsr $aab1			jsr 	EXTScrollFill
.a9ad	60		rts				rts
.a9ae					EXTClearScreenCode:
.a9ae	a9 02		lda #$02			lda 	#2 							; select text page
.a9b0	85 01		sta $01				sta 	1
.a9b2	a9 20		lda #$20			lda		#32 						; fill with space
.a9b4	20 c1 a9	jsr $a9c1			jsr 	_EXTCSFill
.a9b7	e6 01		inc $01				inc 	1 							; select colour page
.a9b9	ad 41 06	lda $0641			lda 	EXTTextColour
.a9bc	20 c1 a9	jsr $a9c1			jsr 	_EXTCSFill
.a9bf	80 22		bra $a9e3			bra 	EXTHomeCursor
.a9c1					_EXTCSFill:
.a9c1	aa		tax				tax
.a9c2	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a9c4	85 40		sta $40				sta 	EXTAddress
.a9c6	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9c8	85 41		sta $41				sta 	EXTAddress+1
.a9ca					_EXTCSFill1:
.a9ca	a0 00		ldy #$00			ldy 	#0
.a9cc	8a		txa				txa
.a9cd					_EXTCSFill2:
.a9cd	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9cf	c8		iny				iny
.a9d0	d0 fb		bne $a9cd			bne 	_EXTCSFill2
.a9d2	e6 41		inc $41				inc 	EXTAddress+1
.a9d4	a5 41		lda $41				lda 	EXTAddress+1
.a9d6	c9 d2		cmp #$d2			cmp 	#$D2
.a9d8	d0 f0		bne $a9ca			bne 	_EXTCSFill1
.a9da	8a		txa				txa
.a9db					_EXTCSFill3:
.a9db	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9dd	c8		iny				iny
.a9de	c0 c0		cpy #$c0			cpy 	#$C0
.a9e0	d0 f9		bne $a9db			bne 	_EXTCSFill3
.a9e2	60		rts				rts
.a9e3					EXTHomeCursor:
.a9e3	9c 3f 06	stz $063f			stz 	EXTRow 						; reset row & column
.a9e6	9c 40 06	stz $0640			stz 	EXTColumn
.a9e9	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a9eb	85 40		sta $40				sta 	EXTAddress
.a9ed	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9ef	85 41		sta $41				sta 	EXTAddress+1
.a9f1					EXTSetHardwareCursor:
.a9f1	64 01		stz $01				stz 	1 							; I/O Page zero
.a9f3	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a9f5	8d 10 d0	sta $d010			sta 	$D010
.a9f8	a9 b1		lda #$b1			lda 	#$B1
.a9fa	8d 12 d0	sta $d012			sta 	$D012
.a9fd	ad 40 06	lda $0640			lda 	EXTColumn
.aa00	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.aa03	9c 15 d0	stz $d015			stz 	$D015
.aa06	ad 3f 06	lda $063f			lda 	EXTRow
.aa09	8d 16 d0	sta $d016			sta 	$D016
.aa0c	9c 17 d0	stz $d017			stz 	$D017
.aa0f	60		rts				rts
.aa10					EXTInputLine:
.aa10	48		pha				pha
.aa11	da		phx				phx
.aa12	5a		phy				phy
.aa13	a5 01		lda $01				lda 	1 							; save I/O page
.aa15	48		pha				pha
.aa16					_EILLoop:
.aa16	20 18 ab	jsr $ab18			jsr 	ExtInputSingleCharacter
.aa19	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.aa1b	f0 40		beq $aa5d			beq 	_EILExit
.aa1d	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.aa1f	f0 1c		beq $aa3d			beq 	_EILBackspace
.aa21	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.aa23	90 12		bcc $aa37			bcc 	_EILPrintLoop
.aa25	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.aa27	b0 0e		bcs $aa37			bcs 	_EILPrintLoop
.aa29	48		pha				pha 								; save character
.aa2a	a9 02		lda #$02			lda 	#2  						; insert a space
.aa2c	85 01		sta $01				sta 	1
.aa2e	20 9f aa	jsr $aa9f			jsr 	EXTILInsert 				; insert in text screen
.aa31	e6 01		inc $01				inc 	1
.aa33	20 9f aa	jsr $aa9f			jsr 	EXTILInsert 				; insert in colour screen
.aa36	68		pla				pla 								; get character back.
.aa37					_EILPrintLoop:
.aa37	20 82 a8	jsr $a882			jsr 	ExtPrintCharacter
.aa3a	80 da		bra $aa16			bra 	_EILLoop
.aa3c	60		rts				rts
.aa3d					_EILBackspace:
.aa3d	ad 40 06	lda $0640			lda 	EXTColumn					; can we backspace ?
.aa40	f0 d4		beq $aa16			beq 	_EILLoop
.aa42	a9 02		lda #$02			lda 	#2 							; move cursor left
.aa44	20 82 a8	jsr $a882			jsr 	EXTPrintCharacter
.aa47	a9 02		lda #$02			lda 	#2 							; text block
.aa49	85 01		sta $01				sta 	1
.aa4b	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.aa4d	20 8a aa	jsr $aa8a			jsr 	EXTILDelete
.aa50	e6 01		inc $01				inc 	1 							; colour block
.aa52	ac 40 06	ldy $0640			ldy 	EXTColumn 					; get attribute of last character
.aa55	88		dey				dey
.aa56	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa58	20 8a aa	jsr $aa8a			jsr 	EXTILDelete 				; backspace attribute
.aa5b	80 b9		bra $aa16			bra 	_EILLoop 					; and go round.
.aa5d					_EILExit:
.aa5d	a9 02		lda #$02			lda 	#2 							; switch to page 2
.aa5f	85 01		sta $01				sta 	1
.aa61	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa63					_EILScrapeLine:
.aa63	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa65	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa68	c8		iny				iny
.aa69	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aa6c	d0 f5		bne $aa63			bne 	_EILScrapeLine
.aa6e					_EILTrimSpaces:
.aa6e	88		dey				dey
.aa6f	f0 08		beq $aa79			beq 	_EILEndTrim
.aa71	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y
.aa74	c9 20		cmp #$20			cmp 	#' '
.aa76	f0 f6		beq $aa6e			beq 	_EILTrimSpaces
.aa78	c8		iny				iny 								; trim after non space character.
.aa79					_EILEndTrim:
.aa79	a9 00		lda #$00			lda 	#0 							; trim here.
.aa7b	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa7e	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa80	20 82 a8	jsr $a882			jsr 	ExtPrintCharacter
.aa83	68		pla				pla 								; reset I/O page
.aa84	85 01		sta $01				sta 	1
.aa86	7a		ply				ply
.aa87	fa		plx				plx
.aa88	68		pla				pla
.aa89	60		rts				rts
.aa8a					EXTILDelete:
.aa8a	48		pha				pha 								; save the new character
.aa8b	ac 40 06	ldy $0640			ldy 	EXTColumn 					; start copying from here.
.aa8e					_EXTDLoop:
.aa8e	c8		iny				iny 								; copy one byte down.
.aa8f	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa91	88		dey				dey
.aa92	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa94	c8		iny				iny 								; do till end of line.
.aa95	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aa98	90 f4		bcc $aa8e			bcc 	_EXTDLoop
.aa9a	88		dey				dey 	 							; write in last slot.
.aa9b	68		pla				pla
.aa9c	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa9e	60		rts				rts
.aa9f					EXTILInsert:
.aa9f	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; end position
.aaa2					_EXTILoop:
.aaa2	88		dey				dey 								; back one
.aaa3	cc 40 06	cpy $0640			cpy 	EXTColumn 					; exit if reached insert point.
.aaa6	f0 08		beq $aab0			beq 	_EXTIExit
.aaa8	88		dey				dey 								; copy one byte up.
.aaa9	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aaab	c8		iny				iny
.aaac	91 40		sta ($40),y			sta 	(EXTAddress),y
.aaae	80 f2		bra $aaa2			bra 	_EXTILoop
.aab0					_EXTIExit:
.aab0	60		rts				rts
.aab1					EXTScrollFill:
.aab1	aa		tax				tax									; save value to fill with
.aab2	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aab4	48		pha				pha
.aab5	a5 37		lda $37				lda 	zTemp0+1
.aab7	48		pha				pha
.aab8	a5 38		lda $38				lda 	zTemp1
.aaba	48		pha				pha
.aabb	a5 39		lda $39				lda 	zTemp1+1
.aabd	48		pha				pha
.aabe	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aac0	85 37		sta $37				sta 	zTemp0+1
.aac2	85 39		sta $39				sta 	zTemp1+1
.aac4	64 36		stz $36				stz 	zTemp0
.aac6	ad 42 06	lda $0642			lda 	EXTScreenWidth
.aac9	85 38		sta $38				sta 	zTemp1
.aacb	a0 00		ldy #$00			ldy 	#0
.aacd					_EXSFCopy1:
.aacd	b1 38		lda ($38),y			lda 	(zTemp1),y
.aacf	91 36		sta ($36),y			sta 	(zTemp0),y
.aad1	c8		iny				iny
.aad2	d0 f9		bne $aacd			bne 	_EXSFCopy1
.aad4	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aad6	e6 39		inc $39				inc 	zTemp1+1
.aad8	a5 39		lda $39				lda 	zTemp1+1
.aada	c9 d3		cmp #$d3			cmp 	#$D3
.aadc	d0 ef		bne $aacd			bne 	_EXSFCopy1
.aade	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; blank the bottom line.
.aae1	8a		txa				txa
.aae2					_EXSFFill1:
.aae2	88		dey				dey
.aae3	91 40		sta ($40),y			sta 	(EXTAddress),y
.aae5	c0 00		cpy #$00			cpy 	#0
.aae7	10 f9		bpl $aae2			bpl 	_EXSFFill1
.aae9	68		pla				pla
.aaea	85 39		sta $39				sta 	zTemp1+1
.aaec	68		pla				pla
.aaed	85 38		sta $38				sta 	zTemp1
.aaef	68		pla				pla
.aaf0	85 37		sta $37				sta 	zTemp0+1
.aaf2	68		pla				pla
.aaf3	85 36		sta $36				sta 	zTemp0
.aaf5	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063f					EXTRow:
>063f							.fill 	1
.0640					EXTColumn:
>0640							.fill 	1
.0641					EXTTextColour:
>0641							.fill 	1
.0642					EXTScreenWidth:
>0642							.fill 	1
.0643					EXTScreenHeight:
>0643							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aaf6					EXTInitialise:
.aaf6	64 01		stz $01				stz 	1 							; Access I/O
.aaf8	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aafb	9c 08 d0	stz $d008			stz 	$D008
.aafe	9c 09 d0	stz $d009			stz 	$D009
.ab01	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.ab03	8d 58 d6	sta $d658			sta 	$D658
.ab06	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.ab08	8d 41 06	sta $0641			sta 	EXTTextColour
.ab0b	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.ab0d	8d 42 06	sta $0642			sta 	EXTScreenWidth
.ab10	a9 3c		lda #$3c			lda 	#60
.ab12	8d 43 06	sta $0643			sta 	EXTScreenHeight
.ab15	64 01		stz $01				stz 	1
.ab17	60		rts				rts
.ab18					EXTInputSingleCharacter:
.ab18	da		phx				phx
.ab19	5a		phy				phy
.ab1a					_EISCWait:
.ab1a	64 01		stz $01				stz 	1 							; access I/O Page 0
.ab1c	38		sec				sec 								; calculate timer - LastTick
.ab1d	ad 59 d6	lda $d659			lda 	$D659
.ab20	aa		tax				tax 								; saving timer in X
.ab21	ed 2e 06	sbc $062e			sbc 	LastTick
.ab24	c9 03		cmp #$03			cmp 	#3
.ab26	90 06		bcc $ab2e			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.ab28	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.ab2b	20 9d ba	jsr $ba9d			jsr 	TickHandler 				; go do the code.
.ab2e					_NoFireTick:
.ab2e	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.ab31	c9 00		cmp #$00			cmp 	#0
.ab33	f0 e5		beq $ab1a			beq 	_EISCWait
.ab35	7a		ply				ply
.ab36	fa		plx				plx
.ab37	60		rts				rts
.ab38					EXTBreakCheck:
.ab38	4c e1 ff	jmp $ffe1			jmp		$FFE1
.ab3b					EXTReadController:
.ab3b	da		phx				phx
.ab3c	a2 00		ldx #$00			ldx 	#0
.ab3e	a9 05		lda #$05			lda 	#(($2D) >> 3)
.ab40	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab43	29 20		and #$20			and 	#($01 << (($2D) & 7))
.ab45	f0 04		beq $ab4b			beq 	_NoSet1
.ab47	8a		txa				txa
.ab48	09 01		ora #$01			ora 	#1
.ab4a	aa		tax				tax
.ab4b					_NoSet1:
.ab4b	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab4d	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab50	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab52	f0 04		beq $ab58			beq 	_NoSet1
.ab54	8a		txa				txa
.ab55	09 02		ora #$02			ora 	#2
.ab57	aa		tax				tax
.ab58					_NoSet1:
.ab58	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab5a	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab5d	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab5f	f0 04		beq $ab65			beq 	_NoSet1
.ab61	8a		txa				txa
.ab62	09 04		ora #$04			ora 	#4
.ab64	aa		tax				tax
.ab65					_NoSet1:
.ab65	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab67	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab6a	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab6c	f0 04		beq $ab72			beq 	_NoSet1
.ab6e	8a		txa				txa
.ab6f	09 08		ora #$08			ora 	#8
.ab71	aa		tax				tax
.ab72					_NoSet1:
.ab72	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab74	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab77	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab79	f0 04		beq $ab7f			beq 	_NoSet1
.ab7b	8a		txa				txa
.ab7c	09 10		ora #$10			ora 	#16
.ab7e	aa		tax				tax
.ab7f					_NoSet1:
.ab7f	8a		txa				txa
.ab80	fa		plx				plx
.ab81	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.baa3					GRVectorTable:
>baa3	7d ad					.word	GXInitialise             ; $00 Initialise
>baa5	97 ad					.word	GXControlBitmap          ; $01 BitmapCtl
>baa7	df ad					.word	GXControlSprite          ; $02 SpriteCtl
>baa9	2f ad					.word	GXClearBitmap            ; $03 Clear
>baab	6e af					.word	GXSetColourMode          ; $04 Colour
>baad	36 b1					.word	GXFontHandler            ; $05 DrawFont
>baaf	7e b1					.word	GXSpriteHandler          ; $06 DrawSprite
>bab1	ea b1					.word	GXSelect                 ; $07 SpriteUse
>bab3	13 b2					.word	GXSelectImage            ; $08 SpriteImage
>bab5	9a b3					.word	GXCollide                ; $09 SpriteCollide
>bab7	e1 ab					.word	GRUndefined              ; $0a
>bab9	e1 ab					.word	GRUndefined              ; $0b
>babb	e1 ab					.word	GRUndefined              ; $0c
>babd	e1 ab					.word	GRUndefined              ; $0d
>babf	e1 ab					.word	GRUndefined              ; $0e
>bac1	e1 ab					.word	GRUndefined              ; $0f
>bac3	e1 ab					.word	GRUndefined              ; $10
>bac5	e1 ab					.word	GRUndefined              ; $11
>bac7	e1 ab					.word	GRUndefined              ; $12
>bac9	e1 ab					.word	GRUndefined              ; $13
>bacb	e1 ab					.word	GRUndefined              ; $14
>bacd	e1 ab					.word	GRUndefined              ; $15
>bacf	e1 ab					.word	GRUndefined              ; $16
>bad1	e1 ab					.word	GRUndefined              ; $17
>bad3	e1 ab					.word	GRUndefined              ; $18
>bad5	e1 ab					.word	GRUndefined              ; $19
>bad7	e1 ab					.word	GRUndefined              ; $1a
>bad9	e1 ab					.word	GRUndefined              ; $1b
>badb	e1 ab					.word	GRUndefined              ; $1c
>badd	e1 ab					.word	GRUndefined              ; $1d
>badf	e1 ab					.word	GRUndefined              ; $1e
>bae1	e1 ab					.word	GRUndefined              ; $1f
>bae3	df ab					.word	GXMove                   ; $20 Move
>bae5	3c ae					.word	GXLine                   ; $21 Line
>bae7	b7 af					.word	GXFrameRectangle         ; $22 FrameRect
>bae9	b4 af					.word	GXFillRectangle          ; $23 FillRect
>baeb	e6 ab					.word	GXFrameCircle            ; $24 FrameCircle
>baed	e2 ab					.word	GXFillCircle             ; $25 FillCircle
>baef	e1 ab					.word	GRUndefined              ; $26
>baf1	e1 ab					.word	GRUndefined              ; $27
>baf3	9c af					.word	GXPlotPoint              ; $28 Plot
>baf5	a9 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5fa					gxPixelBuffer = numberBuffer
.0644					gxCurrentX:
>0644							.fill 	2
.0646					gxCurrentY:
>0646							.fill 	2
.0648					gxLastX:
>0648							.fill 	2
.064a					gxLastY:
>064a							.fill 	2
.064c					gxX0:
>064c							.fill 	2
.064e					gxY0:
>064e							.fill 	2
.0650					gxX1:
>0650							.fill 	2
.0652					gxY1:
>0652							.fill 	2
.0654					gxSpritesOn:
>0654							.fill 	1
.0655					gxBitmapsOn:
>0655							.fill 	1
.0656					gxBasePage:
>0656							.fill 	1
.0657					gxSpritePage:
>0657							.fill 	1
.0658					gxHeight:
>0658							.fill 	1
.0659					gxMode:
>0659							.fill 	1
.065a					gxColour:
>065a							.fill 	1
.065b					gxEORValue:
>065b							.fill 	1
.065c					gxANDValue:
>065c							.fill 	1
.065d					gxOriginalLUTValue:
>065d							.fill 	1
.065e					gsOffset:
>065e							.fill 	1
.065f					GSCurrentSpriteID:
>065f							.fill 	1
.0660					GSCurrentSpriteAddr:
>0660							.fill 	2
.0662					GXSpriteOffsetBase:
>0662							.fill 	2
.0664					GXSpriteLow:
>0664							.fill 	64
.06a4					GXSpriteHigh:
>06a4							.fill 	64
.ab82					GXGraphicDraw:
.ab82	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab84	b0 06		bcs $ab8c			bcs 	_GDCoordinate
.ab86	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab88	84 37		sty $37				sty 	gxzTemp0+1
.ab8a	80 4b		bra $abd7			bra 	_GDExecuteA 				; and execute
.ab8c					_GDCoordinate:
.ab8c	48		pha				pha 								; save AXY
.ab8d	da		phx				phx
.ab8e	5a		phy				phy
.ab8f	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab91					_GDCopy1:
.ab91	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.ab94	9d 48 06	sta $0648,x			sta 	gxLastX,x
.ab97	ca		dex				dex
.ab98	10 f7		bpl $ab91			bpl 	_GDCopy1
.ab9a	68		pla				pla 								; update Y
.ab9b	8d 46 06	sta $0646			sta 	gxCurrentY
.ab9e	9c 47 06	stz $0647			stz 	gxCurrentY+1
.aba1	68		pla				pla
.aba2	8d 44 06	sta $0644			sta 	gxCurrentX
.aba5	68		pla				pla 								; get A (command+X.1) back
.aba6	48		pha				pha
.aba7	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.aba9	8d 45 06	sta $0645			sta 	gxCurrentX+1
.abac	68		pla				pla 								; get command back
.abad	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abaf	48		pha				pha 								; push back.
.abb0	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abb2	f0 17		beq $abcb			beq 	_GDCopyToWorkArea
.abb4	ad 45 06	lda $0645			lda 	gxCurrentX+1 				; X < 256 X okay
.abb7	f0 07		beq $abc0			beq 	_GDCheckY
.abb9	ad 44 06	lda $0644			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abbc	c9 40		cmp #$40			cmp 	#64
.abbe	b0 08		bcs $abc8			bcs 	_GDError1
.abc0					_GDCheckY:
.abc0	ad 46 06	lda $0646			lda 	gxCurrentY 					; check Y < Height.
.abc3	cd 58 06	cmp $0658			cmp 	gxHeight
.abc6	90 03		bcc $abcb			bcc 	_GDCopyToWorkArea
.abc8					_GDError1:
.abc8	68		pla				pla
.abc9					_GDError2:
.abc9	38		sec				sec
.abca	60		rts				rts
.abcb					_GDCopyToWorkArea:
.abcb	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abcd					_GDCopy2:
.abcd	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.abd0	9d 4c 06	sta $064c,x			sta 	gxX0,x
.abd3	ca		dex				dex
.abd4	10 f7		bpl $abcd			bpl 	_GDCopy2
.abd6	68		pla				pla 								; get command
.abd7					_GDExecuteA:
.abd7	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abd9	b0 ee		bcs $abc9			bcs 	_GDError2
.abdb	aa		tax				tax
.abdc	7c a3 ba	jmp ($baa3,x)			jmp 	(GRVectorTable,x)
.abdf					GXMove:
.abdf	18		clc				clc
.abe0	60		rts				rts
.abe1					GRUndefined:
>abe1	db						.byte 	$DB 						; causes a break in the emulator
.abe2					GXFillCircle:
.abe2	a9 ff		lda #$ff			lda 	#255
.abe4	80 02		bra $abe8			bra 	GXCircle
.abe6					GXFrameCircle:
.abe6	a9 00		lda #$00			lda 	#0
.abe8					GXCircle:
.abe8	8d e7 06	sta $06e7			sta 	gxIsFillMode					; save Fill flag
.abeb	ad 55 06	lda $0655			lda 	gxBitmapsOn
.abee	f0 26		beq $ac16			beq 	_GXCFail
.abf0	20 41 b4	jsr $b441			jsr 	GXSortXY 					; topleft/bottomright
.abf3	20 19 b3	jsr $b319			jsr 	GXOpenBitmap 				; start drawing
.abf6	20 e8 ac	jsr $ace8			jsr 	GXCircleSetup 				; set up for drawing
.abf9	9c e8 06	stz $06e8			stz 	gxYChanged
.abfc					_GXCircleDraw:
.abfc	ad e5 06	lda $06e5			lda 	gXCentre					; while x <= y
.abff	cd e6 06	cmp $06e6			cmp 	gYCentre
.ac02	90 0a		bcc $ac0e			bcc 	_GXCircleContinue
.ac04	d0 03		bne $ac09			bne 	_GXNoLast
.ac06	20 1b ac	jsr $ac1b			jsr 	GXPlot1
.ac09					_GXNoLast:
.ac09	20 21 b3	jsr $b321			jsr 	GXCloseBitmap 				; close the bitmap
.ac0c	18		clc				clc
.ac0d	60		rts				rts
.ac0e					_GXCircleContinue:
.ac0e	20 18 ac	jsr $ac18			jsr 	GXPlot2 					; draw it
.ac11	20 95 ac	jsr $ac95			jsr 	GXCircleMove 				; adjust the coordinates
.ac14	80 e6		bra $abfc			bra 	_GXCircleDraw
.ac16					_GXCFail:
.ac16	38		sec				sec
.ac17	60		rts				rts
.ac18					GXPlot2:
.ac18	20 1b ac	jsr $ac1b			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac1b					GXPlot1:
.ac1b	ad e6 06	lda $06e6			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac1e	f0 03		beq $ac23			beq 	_GXPlot1Only
.ac20	20 3f ac	jsr $ac3f			jsr 	GXPlot0 						; plot and negate
.ac23					_GXPlot1Only:
.ac23	20 3f ac	jsr $ac3f			jsr 	GXPlot0 						; twice, undoing negation
.ac26	ad e5 06	lda $06e5			lda 	gXCentre 						; swap X and Y
.ac29	ae e6 06	ldx $06e6			ldx	 	gYCentre
.ac2c	8d e6 06	sta $06e6			sta 	gYCentre
.ac2f	8e e5 06	stx $06e5			stx 	gXCentre
.ac32	ad e8 06	lda $06e8			lda 	gxYChanged 						; toggle Y Changed flag
.ac35	a9 ff		lda #$ff			lda 	#$FF
.ac37	8d e8 06	sta $06e8			sta 	gxYChanged
.ac3a	60		rts				rts
.ac3b	20 3f ac	jsr $ac3f			jsr 	GXPlot0 						; do once
.ac3e	60		rts				rts
.ac3f	ad e7 06	lda $06e7	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac42	f0 05		beq $ac49			beq 	_GXPlot0Always
.ac44	ad e8 06	lda $06e8			lda 	gxYChanged						; fill mode, only draw if changed.
.ac47	f0 2d		beq $ac76			beq 	GXPlot0Exit
.ac49					_GXPlot0Always:
.ac49	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac4b	ad e6 06	lda $06e6			lda 	gYCentre
.ac4e	20 77 ac	jsr $ac77			jsr 	GXSubCopy
.ac51	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac53	ad e5 06	lda $06e5			lda 	gXCentre
.ac56	20 77 ac	jsr $ac77			jsr 	GXSubCopy
.ac59	48		pha				pha 									; save last offset X
.ac5a	20 29 b3	jsr $b329			jsr 	GXPositionCalc 					; calculate position/offset.
.ac5d	68		pla				pla
.ac5e	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac5f	85 36		sta $36				sta 	gxzTemp0
.ac61	64 37		stz $37				stz 	gxzTemp0+1
.ac63	26 37		rol $37				rol 	gxzTemp0+1
.ac65	ad e7 06	lda $06e7			lda 	gxIsFillMode
.ac68	69 80		adc #$80			adc 	#128
.ac6a	20 07 b0	jsr $b007			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac6d	38		sec				sec 									; GY = -GY
.ac6e	a9 00		lda #$00			lda 	#0
.ac70	ed e6 06	sbc $06e6			sbc 	gYCentre
.ac73	8d e6 06	sta $06e6			sta 	gYCentre
.ac76					GXPlot0Exit:
.ac76	60		rts				rts
.ac77					GXSubCopy:
.ac77	85 36		sta $36				sta 	gxzTemp0
.ac79	64 37		stz $37				stz 	gxzTemp0+1
.ac7b	29 80		and #$80			and 	#$80
.ac7d	f0 02		beq $ac81			beq 	_GXNoSx
.ac7f	c6 37		dec $37				dec 	gxzTemp0+1
.ac81					_GXNoSx:
.ac81	38		sec				sec
.ac82	bd 50 06	lda $0650,x			lda 	gXX1,x
.ac85	e5 36		sbc $36				sbc 	gxzTemp0
.ac87	9d 4c 06	sta $064c,x			sta 	gXX0,x
.ac8a	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ac8d	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac8f	9d 4d 06	sta $064d,x			sta 	gXX0+1,x
.ac92	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ac94	60		rts				rts
.ac95					GXCircleMove:
.ac95	9c e8 06	stz $06e8			stz 	gxYChanged 					; clear Y changed flag
.ac98	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.ac9a	10 0d		bpl $aca9			bpl 	_GXEMPositive
.ac9c	ee e5 06	inc $06e5			inc 	gXCentre 					; X++
.ac9f	ad e5 06	lda $06e5			lda 	gXCentre
.aca2	20 c8 ac	jsr $acc8			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.aca5	a9 06		lda #$06			lda 	#6  						; and add 6
.aca7	80 15		bra $acbe			bra 	_GXEMAddD
.aca9					_GXEMPositive:
.aca9	ee e5 06	inc $06e5			inc 	gXCentre					; X++
.acac	ce e6 06	dec $06e6			dec 	gyCentre 					; Y--
.acaf	38		sec				sec 								; calculate X-Y
.acb0	ad e5 06	lda $06e5			lda 	gXCentre
.acb3	ed e6 06	sbc $06e6			sbc 	gYCentre
.acb6	20 c8 ac	jsr $acc8			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acb9	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acbb	ce e8 06	dec $06e8			dec 	gxYChanged
.acbe					_GXEMAddD:
.acbe	18		clc				clc
.acbf	65 38		adc $38				adc 	gxzTemp1
.acc1	85 38		sta $38				sta 	gxzTemp1
.acc3	90 02		bcc $acc7			bcc 	_GXEMNoCarry
.acc5	e6 39		inc $39				inc 	gxzTemp1+1
.acc7					_GXEMNoCarry:
.acc7	60		rts				rts
.acc8					_GXAdd4TimesToD:
.acc8	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acca	29 80		and #$80			and 	#$80
.accc	f0 02		beq $acd0			beq 	_GXA4Unsigned
.acce	a9 ff		lda #$ff			lda 	#$FF
.acd0					_GXA4Unsigned:
.acd0	85 37		sta $37				sta 	gxzTemp0+1
.acd2	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acd4	26 37		rol $37				rol 	gxzTemp0+1
.acd6	06 36		asl $36				asl 	gxzTemp0
.acd8	26 37		rol $37				rol 	gxzTemp0+1
.acda	18		clc				clc 								; add
.acdb	a5 36		lda $36				lda		gxzTemp0
.acdd	65 38		adc $38				adc 	gxzTemp1
.acdf	85 38		sta $38				sta 	gxzTemp1
.ace1	a5 37		lda $37				lda		gxzTemp0+1
.ace3	65 39		adc $39				adc 	gxzTemp1+1
.ace5	85 39		sta $39				sta 	gxzTemp1+1
.ace7	60		rts				rts
.ace8					GXCircleSetup:
.ace8	38		sec				sec
.ace9	ad 52 06	lda $0652			lda 	gxY1
.acec	ed 4e 06	sbc $064e			sbc 	gxY0
.acef	4a		lsr a				lsr 	a
.acf0	8d e4 06	sta $06e4			sta 	gxRadius
.acf3	a2 00		ldx #$00			ldx 	#0
.acf5	20 17 ad	jsr $ad17			jsr 	_GXCalculateCentre
.acf8	a2 02		ldx #$02			ldx 	#2
.acfa	20 17 ad	jsr $ad17			jsr 	_GXCalculateCentre
.acfd	9c e5 06	stz $06e5			stz 	gXCentre
.ad00	ad e4 06	lda $06e4			lda 	gxRadius
.ad03	8d e6 06	sta $06e6			sta 	gYCentre
.ad06	0a		asl a				asl 	a 							; R x 2
.ad07	85 36		sta $36				sta 	gxzTemp0
.ad09	38		sec				sec
.ad0a	a9 03		lda #$03			lda 	#3
.ad0c	e5 36		sbc $36				sbc 	gxzTemp0
.ad0e	85 38		sta $38				sta 	gxzTemp1
.ad10	a9 00		lda #$00			lda 	#0
.ad12	e9 00		sbc #$00			sbc 	#0
.ad14	85 39		sta $39				sta 	gxzTemp1+1
.ad16	60		rts				rts
.ad17					_GXCalculateCentre:
.ad17	38		sec				sec
.ad18	bd 50 06	lda $0650,x			lda 	gxX1,x
.ad1b	7d 4c 06	adc $064c,x			adc 	gXX0,x
.ad1e	9d 50 06	sta $0650,x			sta 	gXX1,x
.ad21	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ad24	7d 4d 06	adc $064d,x			adc 	gXX0+1,x
.ad27	4a		lsr a				lsr 	a
.ad28	9d 51 06	sta $0651,x			sta 	gXX1+1,x
.ad2b	7e 50 06	ror $0650,x			ror 	gXX1,x
.ad2e	60		rts				rts
.06e4					gxRadius:
>06e4							.fill 	1
.06e5					gXCentre:
>06e5							.fill 	1
.06e6					gYCentre:
>06e6							.fill 	1
.06e7					gxIsFillMode:
>06e7							.fill 	1
.06e8					gxYChanged:
>06e8							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad2f					GXClearBitmap:
.ad2f	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP running.
.ad32	f0 24		beq $ad58			beq 	_GXCBFail
.ad34	20 19 b3	jsr $b319			jsr 	GXOpenBitmap 				; start access
.ad37	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad39	ad 58 06	lda $0658			lda 	gxHeight
.ad3c	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad3e	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad40					_GXCalcLastPage:
.ad40	98		tya				tya 								; add to base page
.ad41	18		clc				clc
.ad42	6d 56 06	adc $0656			adc 	gxBasePage
.ad45	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad47					_GXClearAll:
.ad47	20 5a ad	jsr $ad5a			jsr 	_GXClearBlock 				; clear 8k block
.ad4a	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad4c	a5 0b		lda $0b				lda 	GXEditSlot
.ad4e	cd 56 06	cmp $0656			cmp 	gxBasePage 					; until before base page
.ad51	b0 f4		bcs $ad47			bcs 	_GXClearAll
.ad53	20 21 b3	jsr $b321			jsr 	GXCloseBitmap	 			; stop access
.ad56	18		clc				clc
.ad57	60		rts				rts
.ad58					_GXCBFail:
.ad58	38		sec				sec
.ad59	60		rts				rts
.ad5a					_GXClearBlock:
.ad5a	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad5c	85 38		sta $38				sta 	0+gxzTemp1
.ad5e	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad60	85 39		sta $39				sta 	1+gxzTemp1
.ad62					_GXCB0:
.ad62	a5 36		lda $36				lda 	gxzTemp0
.ad64	a0 00		ldy #$00			ldy 	#0
.ad66					_GXCB1:
.ad66	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad68	c8		iny				iny
.ad69	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad6b	c8		iny				iny
.ad6c	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad6e	c8		iny				iny
.ad6f	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad71	c8		iny				iny
.ad72	d0 f2		bne $ad66			bne 	_GXCB1
.ad74	e6 39		inc $39				inc 	gxzTemp1+1
.ad76	a5 39		lda $39				lda 	gxzTemp1+1
.ad78	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad7a	d0 e6		bne $ad62			bne 	_GXCB0
.ad7c	60		rts				rts
.ad7d					GXInitialise:
.ad7d	64 01		stz $01				stz 	1
.ad7f	a9 01		lda #$01			lda 	#1
.ad81	8d 00 d0	sta $d000			sta 	$D000
.ad84	18		clc				clc
.ad85	9c 54 06	stz $0654			stz 	GXSpritesOn
.ad88	9c 55 06	stz $0655			stz 	GXBitmapsOn
.ad8b	a2 0f		ldx #$0f			ldx 	#15
.ad8d					_GXIClear:
.ad8d	9e 44 06	stz $0644,x			stz 	gxCurrentX,x
.ad90	ca		dex				dex
.ad91	10 fa		bpl $ad8d			bpl 	_GXIClear
.ad93	20 2e ae	jsr $ae2e			jsr 	GXClearSpriteStore
.ad96	60		rts				rts
.ad97					GXControlBitmap:
.ad97	64 01		stz $01				stz 	1
.ad99	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ad9b	29 01		and #$01			and 	#1 							; set bitmap flag
.ad9d	8d 55 06	sta $0655			sta 	gxBitmapsOn
.ada0	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ada1	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ada4	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ada6	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.ada8	90 02		bcc $adac			bcc 	_CBNotOn
.adaa	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.adac					_CBNotOn:
.adac	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adaf	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.adb1	29 07		and #$07			and 	#7
.adb3	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adb6	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adb8	d0 02		bne $adbc			bne 	_CBNotDefault
.adba	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adbc					_CBNotDefault:
.adbc	8d 56 06	sta $0656			sta 	gxBasePage
.adbf	20 20 ae	jsr $ae20			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adc2	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.adc4	8d 03 d1	sta $d103			sta 	$D103
.adc7	a5 36		lda $36				lda 	gxzTemp0
.adc9	8d 02 d1	sta $d102			sta 	$D102
.adcc	9c 01 d1	stz $d101			stz 	$D101
.adcf	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.add1	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.add4	29 01		and #$01			and 	#1
.add6	f0 02		beq $adda			beq 	_CBHaveHeight
.add8	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.adda					_CBHaveHeight
.adda	8e 58 06	stx $0658			stx 	gxHeight
.addd	18		clc				clc
.adde	60		rts				rts
.addf					GXControlSprite:
.addf	64 01		stz $01				stz 	1
.ade1	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ade3	29 01		and #$01			and 	#1 							; set sprites flag
.ade5	8d 54 06	sta $0654			sta 	gxSpritesOn
.ade8	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ade9	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adec	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adee	29 df		and #$df			and 	#$DF 						; clear sprite bit
.adf0	90 02		bcc $adf4			bcc 	_CSNotOn
.adf2	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.adf4					_CSNotOn:
.adf4	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adf7	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adf9	d0 02		bne $adfd			bne 	_CSNotDefault
.adfb	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.adfd					_CSNotDefault:
.adfd	8d 57 06	sta $0657			sta 	gxSpritePage
.ae00	20 20 ae	jsr $ae20			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae03	a5 36		lda $36				lda 	zTemp0
.ae05	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase
.ae08	a5 37		lda $37				lda 	zTemp0+1
.ae0a	8d 63 06	sta $0663			sta 	GXSpriteOffsetBase+1
.ae0d	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae0f					_CSClear:
.ae0f	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae12	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae15	ca		dex				dex
.ae16	d0 f7		bne $ae0f			bne 	_CSClear
.ae18	9c 61 06	stz $0661			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae1b	20 2e ae	jsr $ae2e			jsr 	GXClearSpriteStore
.ae1e	18		clc				clc
.ae1f	60		rts				rts
.ae20					GXCalculateBaseAddress:
.ae20	85 36		sta $36				sta 	gxzTemp0
.ae22	64 37		stz $37				stz 	gxzTemp0+1
.ae24	a9 05		lda #$05			lda 	#5
.ae26					_GXShift:
.ae26	06 36		asl $36				asl 	gxzTemp0
.ae28	26 37		rol $37				rol 	gxzTemp0+1
.ae2a	3a		dec a				dec		a
.ae2b	d0 f9		bne $ae26			bne 	_GXShift
.ae2d	60		rts				rts
.ae2e					GXClearSpriteStore:
.ae2e	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae30					_GXCSSLoop:
.ae30	9e a4 06	stz $06a4,x			stz 	GXSpriteHigh,x
.ae33	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae35	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.ae38	ca		dex				dex
.ae39	10 f5		bpl $ae30			bpl 	_GXCSSLoop
.ae3b	60		rts				rts
.ae3c					GXLine:
.ae3c	ad 55 06	lda $0655			lda 	GXBitmapsOn
.ae3f	f0 28		beq $ae69			beq 	_GXLFail
.ae41	20 19 b3	jsr $b319			jsr 	GXOpenBitmap
.ae44	20 5f b4	jsr $b45f			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae47	20 0f af	jsr $af0f			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae4a	20 29 b3	jsr $b329			jsr 	GXPositionCalc 				; calculate position/offset.
.ae4d					_GXDrawLoop:
.ae4d	ac 5e 06	ldy $065e			ldy 	gsOffset 					; draw the pixel
.ae50	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae52	2d 5c 06	and $065c			and 	gxANDValue
.ae55	4d 5b 06	eor $065b			eor 	gxEORValue
.ae58	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae5a	20 6b ae	jsr $ae6b			jsr 	GXLineIsComplete 			; is the line complete ?
.ae5d	f0 05		beq $ae64			beq 	_GXLExit
.ae5f	20 86 ae	jsr $ae86			jsr 	GXLineAdvance 				; code as per advance method
.ae62	80 e9		bra $ae4d			bra 	_GXDrawLoop
.ae64					_GXLExit:
.ae64	20 21 b3	jsr $b321			jsr 	GXCloseBitmap
.ae67	18		clc				clc
.ae68	60		rts				rts
.ae69					_GXLFail:
.ae69	38		sec				sec
.ae6a	60		rts				rts
.ae6b					GXLineIsComplete:
.ae6b	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger 			; is dy larger
.ae6e	d0 0f		bne $ae7f			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae70	ad 4c 06	lda $064c			lda 	GXX0 						; compare X, LSB and MSB
.ae73	4d 50 06	eor $0650			eor 	GXX1
.ae76	d0 06		bne $ae7e			bne 	_GXLICExit
.ae78	ad 4d 06	lda $064d			lda 	GXX0+1
.ae7b	4d 51 06	eor $0651			eor 	GXX1+1
.ae7e					_GXLICExit:
.ae7e	60		rts				rts
.ae7f					_GXLICCompareY:
.ae7f	ad 52 06	lda $0652			lda 	GXY1
.ae82	4d 4e 06	eor $064e			eor 	GXY0
.ae85	60		rts				rts
.ae86					GXLineAdvance:
.ae86	18		clc				clc 								; add adjust to position
.ae87	ad ed 06	lda $06ed			lda 	GXPosition
.ae8a	6d ee 06	adc $06ee			adc 	GXAdjust
.ae8d	8d ed 06	sta $06ed			sta 	GXPosition
.ae90	9c f0 06	stz $06f0			stz 	GXAddSelect 				; clear add select flag
.ae93	b0 05		bcs $ae9a			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ae95	cd ef 06	cmp $06ef			cmp 	GXTotal 					; if exceeded total
.ae98	90 0a		bcc $aea4			bcc 	_GXLANoExtra
.ae9a					_GXLAOverflow:
.ae9a	ce f0 06	dec $06f0			dec 	GXAddSelect 				; set addselect to $FF
.ae9d	38		sec				sec 								; subtract total and write back
.ae9e	ed ef 06	sbc $06ef			sbc 	GXTotal
.aea1	8d ed 06	sta $06ed			sta 	GXPosition
.aea4					_GXLANoExtra:
.aea4	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger
.aea7	f0 0d		beq $aeb6			beq 	_GXDXLarger
.aea9	20 08 af	jsr $af08			jsr 	GXIncrementY
.aeac	ad f0 06	lda $06f0			lda 	GXAddSelect
.aeaf	f0 10		beq $aec1			beq 	_GXLAExit
.aeb1	20 c2 ae	jsr $aec2			jsr 	GXAdjustX
.aeb4	80 0b		bra $aec1			bra 	_GXLAExit
.aeb6					_GXDXLarger:
.aeb6	20 c2 ae	jsr $aec2			jsr 	GXAdjustX
.aeb9	ad f0 06	lda $06f0			lda 	GXAddSelect
.aebc	f0 03		beq $aec1			beq 	_GXLAExit
.aebe	20 08 af	jsr $af08			jsr 	GXIncrementY
.aec1					_GXLAExit:
.aec1	60		rts				rts
.aec2					GXAdjustX:
.aec2	ad ec 06	lda $06ec			lda 	GXDXNegative
.aec5	10 25		bpl $aeec			bpl 	_GXAXRight
.aec7	ad 4c 06	lda $064c			lda 	GXX0
.aeca	d0 03		bne $aecf			bne 	_GXAXNoBorrow
.aecc	ce 4d 06	dec $064d			dec 	GXX0+1
.aecf					_GXAXNoBorrow:
.aecf	ce 4c 06	dec $064c			dec 	GXX0
.aed2	ce 5e 06	dec $065e			dec 	gsOffset 					; pixel left
.aed5	ad 5e 06	lda $065e			lda 	gsOffset
.aed8	c9 ff		cmp #$ff			cmp 	#$FF
.aeda	d0 0f		bne $aeeb			bne 	_GXAYExit 					; underflow
.aedc	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aede	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aee0	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aee2	b0 07		bcs $aeeb			bcs 	_GXAYExit
.aee4	18		clc				clc
.aee5	69 20		adc #$20			adc 	#$20 						; fix up
.aee7	85 3d		sta $3d				sta 	gxzScreen+1
.aee9	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aeeb					_GXAYExit:
.aeeb	60		rts				rts
.aeec					_GXAXRight:
.aeec	ee 4c 06	inc $064c			inc 	GXX0
.aeef	d0 03		bne $aef4			bne 	_GXAXNoCarry
.aef1	ee 4d 06	inc $064d			inc 	GXX0+1
.aef4					_GXAXNoCarry:
.aef4	ee 5e 06	inc $065e			inc 	gsOffset 					; pixel right
.aef7	d0 0e		bne $af07			bne 	_GXAXExit 					; if not overflowed, exit.
.aef9	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.aefb	a5 3d		lda $3d				lda 	gxzScreen+1
.aefd	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.aeff	90 06		bcc $af07			bcc 	_GXAXExit
.af01	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af03	85 3d		sta $3d				sta 	gxzScreen+1
.af05	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af07					_GXAXExit:
.af07	60		rts				rts
.af08					GXIncrementY:
.af08	ee 4e 06	inc $064e			inc 	GXY0
.af0b	20 7f b3	jsr $b37f			jsr 	GXMovePositionDown
.af0e	60		rts				rts
.af0f					GXLineSetup:
.af0f	ad 52 06	lda $0652			lda 	GXY1
.af12	38		sec				sec
.af13	ed 4e 06	sbc $064e			sbc 	GXY0
.af16	4a		lsr a				lsr 	a
.af17	8d ea 06	sta $06ea			sta 	GXDiffY
.af1a	9c ec 06	stz $06ec			stz 	GXDXNegative 				; clear -ve flag
.af1d	38		sec				sec
.af1e	ad 50 06	lda $0650			lda 	GXX1
.af21	ed 4c 06	sbc $064c			sbc 	GXX0
.af24	8d e9 06	sta $06e9			sta 	GXDiffX
.af27	ad 51 06	lda $0651			lda 	GXX1+1 						; calculate MSB
.af2a	ed 4d 06	sbc $064d			sbc 	GXX0+1
.af2d	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af2e	6e e9 06	ror $06e9			ror 	GXDiffX
.af31	0a		asl a				asl 	a
.af32	10 0c		bpl $af40			bpl 	_GDXNotNegative
.af34	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af36	38		sec				sec
.af37	ed e9 06	sbc $06e9			sbc 	GXDiffX
.af3a	8d e9 06	sta $06e9			sta 	GXDiffX
.af3d	ce ec 06	dec $06ec			dec 	GXDXNegative 				; -ve flag = $FF.
.af40					_GDXNotNegative:
.af40	9c eb 06	stz $06eb			stz 	GXIsDiffYLarger 			; clear larger flag
.af43	ad ea 06	lda $06ea			lda 	GXDiffY 					; set adjust and total.
.af46	8d ee 06	sta $06ee			sta 	GXAdjust
.af49	ad e9 06	lda $06e9			lda 	GXDiffX
.af4c	8d ef 06	sta $06ef			sta 	GXTotal
.af4f	ad ea 06	lda $06ea			lda 	GXDiffY 					; if dy > dx
.af52	cd e9 06	cmp $06e9			cmp 	GXDiffX
.af55	90 0f		bcc $af66			bcc 	_GDXNotLarger
.af57	ce eb 06	dec $06eb			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af5a	ad e9 06	lda $06e9			lda 	GXDiffX 					; set adjust and total other way round
.af5d	8d ee 06	sta $06ee			sta 	GXAdjust
.af60	ad ea 06	lda $06ea			lda 	GXDiffY
.af63	8d ef 06	sta $06ef			sta 	GXTotal
.af66					_GDXNotLarger:
.af66	ad ef 06	lda $06ef			lda 	GXTotal
.af69	4a		lsr a				lsr 	a
.af6a	8d ed 06	sta $06ed			sta 	GXPosition
.af6d	60		rts				rts
.06e9					GXDiffX:
>06e9							.fill 	1
.06ea					GXDiffY:
>06ea							.fill 	1
.06eb					GXIsDiffYLarger:
>06eb							.fill 	1
.06ec					GXDXNegative:
>06ec							.fill 	1
.06ed					GXPosition:
>06ed							.fill 	1
.06ee					GXAdjust:
>06ee							.fill 	1
.06ef					GXTotal:
>06ef							.fill 	1
.06f0					GXAddSelect:
>06f0							.fill 	1
.af6e					GXSetColourMode:
.af6e	a6 36		ldx $36				ldx 	gxzTemp0
.af70	8e 5a 06	stx $065a			stx 	gxColour 								; set colour
.af73	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af75	8d 59 06	sta $0659			sta 	gxMode 									; set mode
.af78	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af7a	9c 5c 06	stz $065c			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af7d	ae 5a 06	ldx $065a			ldx 	gxColour
.af80	8e 5b 06	stx $065b			stx 	gxEORValue
.af83	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af85	90 03		bcc $af8a			bcc 	_GXSDCNotAndColour
.af87	8e 5c 06	stx $065c			stx 	gxANDValue
.af8a					_GXSDCNotAndColour:
.af8a	d0 03		bne $af8f			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af8c	9c 5b 06	stz $065b			stz 	gxEORValue
.af8f					_GXSDCNotAnd:
.af8f	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af90	90 08		bcc $af9a			bcc 	_GXSDCNoFlip
.af92	ad 5c 06	lda $065c			lda	 	gxANDValue
.af95	49 ff		eor #$ff			eor 	#$FF
.af97	8d 5c 06	sta $065c			sta 	gxANDValue
.af9a					_GXSDCNoFlip:
.af9a	18		clc				clc
.af9b	60		rts				rts
.af9c					GXPlotPoint:
.af9c	20 19 b3	jsr $b319			jsr 	GXOpenBitmap 				; start drawing
.af9f	20 29 b3	jsr $b329			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afa2	ac 5e 06	ldy $065e			ldy 	gsOffset
.afa5	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afa7	2d 5c 06	and $065c			and 	gxANDValue
.afaa	4d 5b 06	eor $065b			eor 	gxEORValue
.afad	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afaf	20 21 b3	jsr $b321			jsr 	GXCloseBitmap 				; stop drawing and exit
.afb2	18		clc				clc
.afb3	60		rts				rts
.afb4					GXFillRectangle:
.afb4	38		sec				sec
.afb5	80 01		bra $afb8			bra 	GXRectangle
.afb7					GXFrameRectangle:
.afb7	18		clc				clc
.afb8					GXRectangle:
.afb8	ad 55 06	lda $0655			lda 	gxBitmapsOn
.afbb	f0 35		beq $aff2			beq 	_GXRFail
.afbd	08		php				php 								; save Fill flag (CS)
.afbe	20 19 b3	jsr $b319			jsr 	GXOpenBitmap 				; start drawing
.afc1	20 41 b4	jsr $b441			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afc4	20 29 b3	jsr $b329			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afc7	38		sec				sec 								; sec = Draw line
.afc8	20 f4 af	jsr $aff4			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afcb	ad 4e 06	lda $064e			lda 	gxY0 						; reached end of rectangle ?
.afce	cd 52 06	cmp $0652			cmp 	gxY1
.afd1	f0 19		beq $afec			beq 	_GXRectangleExit
.afd3					_GXRectLoop:
.afd3	20 7f b3	jsr $b37f			jsr 	GXMovePositionDown 			; down one.
.afd6	ee 4e 06	inc $064e			inc 	gxY0 						; change Y pos
.afd9	ad 4e 06	lda $064e			lda 	gxY0 						; reached last line
.afdc	cd 52 06	cmp $0652			cmp 	gXY1
.afdf	f0 07		beq $afe8			beq 	_GXLastLine
.afe1	28		plp				plp 								; get flag back
.afe2	08		php				php
.afe3	20 f4 af	jsr $aff4			jsr 	GXDrawLineX1X0 				; draw horizontal line
.afe6	80 eb		bra $afd3			bra 	_GXRectLoop
.afe8					_GXLastLine:
.afe8	38		sec				sec
.afe9	20 f4 af	jsr $aff4			jsr 	GXDrawLineX1X0
.afec					_GXRectangleExit:
.afec	68		pla				pla 								; throw fill flag.
.afed	20 21 b3	jsr $b321			jsr 	GXCloseBitmap 				; stop drawing and exit
.aff0	18		clc				clc
.aff1	60		rts				rts
.aff2					_GXRFail:
.aff2	38		sec				sec
.aff3	60		rts				rts
.aff4					GXDrawLineX1X0:
.aff4	08		php				php 								; save solid/either-end
.aff5	38		sec				sec
.aff6	ad 50 06	lda $0650			lda		gXX1
.aff9	ed 4c 06	sbc $064c			sbc 	gXX0
.affc	85 36		sta $36				sta 	gxzTemp0
.affe	ad 51 06	lda $0651			lda 	gXX1+1
.b001	ed 4d 06	sbc $064d			sbc 	gXX0+1
.b004	85 37		sta $37				sta 	gxzTemp0+1
.b006	28		plp				plp
.b007					GXDrawLineTemp0:
.b007	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b009	48		pha				pha
.b00a	a5 3d		lda $3d				lda 	gxzScreen+1
.b00c	48		pha				pha
.b00d	ad 5e 06	lda $065e			lda 	gsOffset
.b010	48		pha				pha
.b011	a5 0b		lda $0b				lda 	GXEditSlot
.b013	48		pha				pha
.b014	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y offset
.b017	90 1e		bcc $b037			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b019					_GXDLTLine:
.b019	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b01b	2d 5c 06	and $065c			and 	gxANDValue
.b01e	4d 5b 06	eor $065b			eor 	gxEORValue
.b021	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b023	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b025	d0 04		bne $b02b			bne 	_GXDLTNoBorrow
.b027	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b029	30 2e		bmi $b059			bmi 	_GXDLTExit
.b02b					_GXDLTNoBorrow:
.b02b	c6 36		dec $36				dec 	gxzTemp0
.b02d	c8		iny				iny 								; next slot.
.b02e	d0 e9		bne $b019			bne 	_GXDLTLine
.b030	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b032	20 67 b0	jsr $b067			jsr 	GXDLTCheckWrap				; check for new page.
.b035	80 e2		bra $b019			bra 	_GXDLTLine
.b037					_GXDLTEndPoints:
.b037	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b039	2d 5c 06	and $065c			and 	gxANDValue
.b03c	4d 5b 06	eor $065b			eor 	gxEORValue
.b03f	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b041	98		tya				tya 								; advance to right side
.b042	18		clc				clc
.b043	65 36		adc $36				adc 	gxzTemp0
.b045	a8		tay				tay
.b046	a5 3d		lda $3d				lda 	gxzScreen+1
.b048	65 37		adc $37				adc 	gxzTemp0+1
.b04a	85 3d		sta $3d				sta 	gxzScreen+1
.b04c	20 67 b0	jsr $b067			jsr 	GXDLTCheckWrap 			; fix up.
.b04f	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b051	2d 5c 06	and $065c			and 	gxANDValue
.b054	4d 5b 06	eor $065b			eor 	gxEORValue
.b057	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b059					_GXDLTExit:
.b059	68		pla				pla
.b05a	85 0b		sta $0b				sta 	GXEditSlot
.b05c	68		pla				pla
.b05d	8d 5e 06	sta $065e			sta 	gsOffset
.b060	68		pla				pla
.b061	85 3d		sta $3d				sta 	gxzScreen+1
.b063	68		pla				pla
.b064	85 3c		sta $3c				sta 	gxzScreen
.b066	60		rts				rts
.b067					GXDLTCheckWrap:
.b067	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b069	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b06b	90 06		bcc $b073			bcc 	_GXDLTCWExit
.b06d	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b06f	85 3d		sta $3d				sta 	gxzScreen+1
.b071	e6 0b		inc $0b				inc 	GXEditSlot
.b073					_GXDLTCWExit:
.b073	60		rts				rts
.b074					GXDrawGraphicElement:
.b074	8d f1 06	sta $06f1			sta 	gxSize 						; save size
.b077	3a		dec a				dec 	a
.b078	8d f2 06	sta $06f2			sta 	gxMask 						; and mask
.b07b	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP on
.b07e	f0 67		beq $b0e7			beq 	_GXSLFail
.b080	ad 4e 06	lda $064e			lda 	gxY0 						; push Y on stack
.b083	48		pha				pha
.b084	8c f4 06	sty $06f4			sty 	gxAcquireVector+1 			; and acquisition vector
.b087	8e f3 06	stx $06f3			stx 	gxAcquireVector
.b08a	20 19 b3	jsr $b319			jsr 	gxOpenBitmap 				; open the bitmap.
.b08d	ad f6 06	lda $06f6			lda 	gxUseMode 					; scale bits
.b090	4a		lsr a				lsr 	a
.b091	4a		lsr a				lsr 	a
.b092	4a		lsr a				lsr 	a
.b093	29 07		and #$07			and		#7
.b095	1a		inc a				inc 	a
.b096	8d f5 06	sta $06f5			sta 	gxScale
.b099	64 38		stz $38				stz 	gxzTemp1					; start first line
.b09b					_GXGELoop:
.b09b	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b09d	2c f6 06	bit $06f6			bit 	gxUseMode 					; check for flip.
.b0a0	10 06		bpl $b0a8			bpl		_GXNoVFlip
.b0a2	ad f2 06	lda $06f2			lda 	gxMask
.b0a5	38		sec				sec
.b0a6	e5 38		sbc $38				sbc 	gxzTemp1
.b0a8					_GXNoVFlip:
.b0a8	aa		tax				tax 								; get the Xth line.
.b0a9	20 e9 b0	jsr $b0e9			jsr 	_GXCallAcquire 				; get that data.
.b0ac	ad f5 06	lda $06f5			lda 	gxScale 					; do scale identical copies of that line.
.b0af	85 39		sta $39				sta 	gxzTemp1+1
.b0b1					_GXGELoop2:
.b0b1	ad 4e 06	lda $064e			lda 	gxY0 						; off screen
.b0b4	cd 58 06	cmp $0658			cmp 	gxHeight
.b0b7	b0 10		bcs $b0c9			bcs 	_GXDGEExit
.b0b9	20 ec b0	jsr $b0ec			jsr 	GXRenderOneLine 			; render line
.b0bc	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0be	d0 f1		bne $b0b1			bne 	_GXGELoop2
.b0c0	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0c2	a5 38		lda $38				lda 	gxzTemp1
.b0c4	cd f1 06	cmp $06f1			cmp 	gxSize
.b0c7	d0 d2		bne $b09b			bne 	_GXGELoop
.b0c9					_GXDGEExit:
.b0c9	68		pla				pla 								; restore Y for next time
.b0ca	8d 4e 06	sta $064e			sta 	gxY0
.b0cd	ae f5 06	ldx $06f5			ldx 	gxScale 					; get scale (1-8)
.b0d0					_GXShiftLeft:
.b0d0	18		clc				clc
.b0d1	ad f1 06	lda $06f1			lda 	gxSize
.b0d4	6d 4c 06	adc $064c			adc 	gxX0
.b0d7	8d 4c 06	sta $064c			sta 	gxX0
.b0da	90 03		bcc $b0df			bcc 	_GXSLNoCarry
.b0dc	ee 4d 06	inc $064d			inc 	gxX0+1
.b0df					_GXSLNoCarry:
.b0df	ca		dex				dex
.b0e0	d0 ee		bne $b0d0			bne 	_GXShiftLeft
.b0e2	20 21 b3	jsr $b321			jsr 	GXCloseBitmap
.b0e5	18		clc				clc
.b0e6	60		rts				rts
.b0e7					_GXSLFail:
.b0e7	38		sec				sec
.b0e8	60		rts				rts
.b0e9					_GXCallAcquire:
.b0e9	6c f3 06	jmp ($06f3)			jmp 	(gxAcquireVector)
.b0ec					GXRenderOneLine:
.b0ec	20 29 b3	jsr $b329			jsr 	GXPositionCalc 				; calculate position/offset.
.b0ef	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y contains position.
.b0f2	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b0f4					_GXROLLoop1:
.b0f4	ad f5 06	lda $06f5			lda 	gxScale 					; set to do 'scale' times
.b0f7	85 3b		sta $3b				sta 	gxzTemp2+1
.b0f9					_GXROLLoop2:
.b0f9	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b0fb	2c 59 06	bit $0659			bit 	gxMode 						; check H Flip
.b0fe	50 06		bvc $b106			bvc 	_GXNoHFlip
.b100	ad f2 06	lda $06f2			lda 	gxMask
.b103	38		sec				sec
.b104	e5 3a		sbc $3a				sbc 	gxzTemp2
.b106					_GXNoHFlip:
.b106	aa		tax				tax 								; read from the pixel buffer
.b107	bd fa 05	lda $05fa,x			lda 	gxPixelBuffer,x
.b10a	d0 07		bne $b113			bne 	_GXDraw 					; draw if non zero
.b10c	ad f6 06	lda $06f6			lda 	gxUseMode 					; check to see if solid background
.b10f	29 04		and #$04			and 	#4
.b111	f0 0a		beq $b11d			beq 	_GXZeroPixel
.b113					_GXDraw:
.b113	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b115	2d 5c 06	and $065c			and 	gxANDValue
.b118	5d fa 05	eor $05fa,x			eor 	gxPixelBuffer,x
.b11b	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b11d					_GXZeroPixel:
.b11d	c8		iny				iny 								; advance pointer
.b11e	d0 05		bne $b125			bne 	_GXNoShift
.b120	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b122	20 67 b0	jsr $b067			jsr 	GXDLTCheckWrap				; check for new page.
.b125					_GXNoShift:
.b125	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b127	d0 d0		bne $b0f9			bne 	_GXROLLoop2
.b129	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b12b	a5 3a		lda $3a				lda 	gxzTemp2
.b12d	cd f1 06	cmp $06f1			cmp 	gxSize
.b130	d0 c2		bne $b0f4			bne 	_GXROLLoop1
.b132	ee 4e 06	inc $064e			inc 	gxY0
.b135	60		rts				rts
.06f1					gxSize:
>06f1							.fill 	1
.06f2					gxMask:
>06f2							.fill 	1
.06f3					gxAcquireVector:
>06f3							.fill 	2
.06f5					gxScale:
>06f5							.fill 	1
.06f6					gxUseMode:
>06f6							.fill 	1
.b136					GXFontHandler:
.b136	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b138	4d 59 06	eor $0659			eor 	gxMode
.b13b	8d f6 06	sta $06f6			sta 	gxUseMode
.b13e	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b140	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b142	26 37		rol $37				rol	 	gxzTemp0+1
.b144	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b146	26 37		rol $37				rol	 	gxzTemp0+1
.b148	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b14a	26 37		rol $37				rol	 	gxzTemp0+1
.b14c	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b14e	09 c0		ora #$c0			ora 	#$C0
.b150	85 37		sta $37				sta 	gxzTemp0+1
.b152	a9 08		lda #$08			lda 	#8 							; size 8x8
.b154	a2 5c		ldx #$5c			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b156	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b158	20 74 b0	jsr $b074			jsr 	GXDrawGraphicElement
.b15b	60		rts				rts
.b15c					GXGetGraphicDataFont:
.b15c	8a		txa				txa 								; X->Y
.b15d	a8		tay				tay
.b15e	a6 01		ldx $01				ldx 	1 							; preserve old value
.b160	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b162	85 01		sta $01				sta 	1
.b164	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b166	86 01		stx $01				stx 	1 							; put old value back.
.b168	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b16a					_GXExpand:
.b16a	9e fa 05	stz $05fa,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b16d	0a		asl a				asl 	a 							; shift bit 7 into C
.b16e	90 08		bcc $b178			bcc 	_GXNoPixel
.b170	48		pha				pha 								; if set, set pixel buffer to current colour.
.b171	ad 5a 06	lda $065a			lda 	gxColour
.b174	9d fa 05	sta $05fa,x			sta 	gxPixelBuffer,x
.b177	68		pla				pla
.b178					_GXNoPixel:
.b178	e8		inx				inx 								; do the whole byte.
.b179	e0 08		cpx #$08			cpx 	#8
.b17b	d0 ed		bne $b16a			bne 	_GXExpand
.b17d	60		rts				rts
.b17e					GXSpriteHandler:
.b17e	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b180	4d 59 06	eor $0659			eor 	gxMode
.b183	8d f6 06	sta $06f6			sta 	gxUseMode
.b186	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b188	da		phx				phx
.b189	20 19 b3	jsr $b319			jsr 	GXOpenBitmap 				; can access sprite information
.b18c	68		pla				pla
.b18d	20 fa b3	jsr $b3fa			jsr 	GXFindSprite 				; get the sprite address
.b190	08		php				php
.b191	20 21 b3	jsr $b321			jsr 	GXCloseBitmap
.b194	28		plp				plp
.b195	b0 0a		bcs $b1a1			bcs		_GXSHExit 					; exit if find failed.
.b197	ad f7 06	lda $06f7			lda 	GXSizePixels 				; return size
.b19a	a2 a2		ldx #$a2			ldx 	#GXSpriteAcquire & $FF
.b19c	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b19e	20 74 b0	jsr $b074			jsr 	GXDrawGraphicElement
.b1a1					_GXSHExit:
.b1a1	60		rts				rts
.b1a2					GXSpriteAcquire:
.b1a2	ad 57 06	lda $0657			lda 	GXSpritePage				; point to base page
.b1a5	85 0b		sta $0b				sta 	GXEditSlot
.b1a7	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1a9	a9 00		lda #$00			lda 	#0
.b1ab	ae f8 06	ldx $06f8			ldx 	GXSizeBits
.b1ae					_GXTimesRowNumber:
.b1ae	18		clc				clc
.b1af	65 36		adc $36				adc 	zTemp0
.b1b1	ca		dex				dex
.b1b2	10 fa		bpl $b1ae			bpl 	_GXTimesRowNumber
.b1b4	64 37		stz $37				stz 	gxzTemp0+1
.b1b6	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1b7	26 37		rol $37				rol 	gxzTemp0+1
.b1b9	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1ba	26 37		rol $37				rol 	gxzTemp0+1
.b1bc	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1bd	26 37		rol $37				rol 	gxzTemp0+1
.b1bf	85 36		sta $36				sta 	gxzTemp0
.b1c1	18		clc				clc 								; add base address.
.b1c2	a5 36		lda $36				lda 	gxzTemp0
.b1c4	6d fa 06	adc $06fa			adc 	GXSpriteOffset
.b1c7	85 36		sta $36				sta 	gxzTemp0
.b1c9	a5 37		lda $37				lda 	gxzTemp0+1
.b1cb	6d fb 06	adc $06fb			adc 	GXSpriteOffset+1
.b1ce					_GXSAFindPage:
.b1ce	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1d0	90 06		bcc $b1d8			bcc 	_GXSAFoundPage
.b1d2	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1d4	e6 0b		inc $0b				inc 	GXEditSlot
.b1d6	80 f6		bra $b1ce			bra 	_GXSAFindPage
.b1d8					_GXSAFoundPage:
.b1d8	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1da	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1dc	a0 00		ldy #$00			ldy 	#0
.b1de					_GXSACopyLoop:
.b1de	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1e0	99 fa 05	sta $05fa,y			sta 	gxPixelBuffer,y
.b1e3	c8		iny				iny
.b1e4	cc f7 06	cpy $06f7			cpy 	GXSizePixels
.b1e7	d0 f5		bne $b1de			bne 	_GXSACopyLoop
.b1e9	60		rts				rts
.b1ea					GXSelect:
.b1ea	ad 54 06	lda $0654			lda 	gxSpritesOn
.b1ed	f0 22		beq $b211			beq 	_GXSFail
.b1ef	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b1f1	c9 40		cmp #$40			cmp 	#64
.b1f3	b0 1c		bcs $b211			bcs 	_GXSFail
.b1f5	8d 5f 06	sta $065f			sta 	GSCurrentSpriteID
.b1f8	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b1fa	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b1fc	06 36		asl $36				asl 	gxzTemp0
.b1fe	06 36		asl $36				asl 	gxzTemp0
.b200	06 36		asl $36				asl 	gxzTemp0
.b202	2a		rol a				rol 	a
.b203	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b205	8d 61 06	sta $0661			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b208	85 37		sta $37				sta 	gxzTemp0+1
.b20a	a5 36		lda $36				lda 	gxzTemp0
.b20c	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr
.b20f	18		clc				clc
.b210	60		rts				rts
.b211					_GXSFail:
.b211	38		sec				sec
.b212	60		rts				rts
.b213					GXSelectImage:
.b213	ad 54 06	lda $0654			lda 	gxSpritesOn
.b216	f0 74		beq $b28c			beq 	_GXSIFail
.b218	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b21b	f0 6f		beq $b28c			beq 	_GXSIFail 					; (checking the MSB)
.b21d	64 01		stz $01				stz 	1
.b21f	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b221	d0 6b		bne $b28e			bne 	_GXSIHide
.b223	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b225	48		pha				pha
.b226	20 19 b3	jsr $b319			jsr 	GXOpenBitmap
.b229	68		pla				pla
.b22a	20 fa b3	jsr $b3fa			jsr 	GXFindSprite
.b22d	b0 5a		bcs $b289			bcs 	_GXSICloseFail 				; no image
.b22f	a0 01		ldy #$01			ldy 	#1
.b231	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b234	85 36		sta $36				sta 	gxzTemp0
.b236	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b239	85 37		sta $37				sta 	gxzTemp0+1
.b23b	ad fa 06	lda $06fa			lda 	GXSpriteOffset
.b23e	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b240	18		clc				clc
.b241	ad fb 06	lda $06fb			lda 	GXSpriteOffset+1
.b244	6d 62 06	adc $0662			adc 	GXSpriteOffsetBase
.b247	c8		iny				iny
.b248	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b24a	ad 63 06	lda $0663			lda 	GXSpriteOffsetBase+1
.b24d	69 00		adc #$00			adc 	#0
.b24f	c8		iny				iny
.b250	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b252	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get raw size
.b255	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b257	2a		rol a				rol 	a 							; x 2
.b258	0a		asl a				asl 	a 							; x 4
.b259	0a		asl a				asl 	a 							; x 8
.b25a	0a		asl a				asl 	a 							; x 16
.b25b	0d f9 06	ora $06f9			ora 	GXSpriteLUT 				; Or with LUT
.b25e	0a		asl a				asl 	a 							; 1 shift
.b25f	09 01		ora #$01			ora 	#1 							; enable sprite.
.b261	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b263	20 21 b3	jsr $b321			jsr 	GXCloseBitmap
.b266	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b269	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b26c	29 3f		and #$3f			and 	#$3F
.b26e	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b271	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get bit size
.b274	6a		ror a				ror 	a 							; shift into bits 6/7
.b275	6a		ror a				ror 	a
.b276	6a		ror a				ror 	a
.b277	29 c0		and #$c0			and 	#$C0
.b279	1d a4 06	ora $06a4,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b27c	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b27f	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b282	29 7f		and #$7f			and 	#$7F
.b284	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b287	18		clc				clc
.b288	60		rts				rts
.b289					_GXSICloseFail:
.b289	20 21 b3	jsr $b321			jsr 	GXCloseBitmap
.b28c					_GXSIFail:
.b28c	38		sec				sec
.b28d	60		rts				rts
.b28e					_GXSIHide:
.b28e	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b291	85 36		sta $36				sta 	gxzTemp0
.b293	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b296	85 37		sta $37				sta 	gxzTemp0+1
.b298	a9 00		lda #$00			lda 	#0
.b29a	92 36		sta ($36)			sta 	(gxzTemp0)
.b29c	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get sprite ID
.b29f	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2a2	09 80		ora #$80			ora 	#$80
.b2a4	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b2a7	18		clc				clc
.b2a8	60		rts				rts
.b2a9					GXMoveSprite:
.b2a9	ad 54 06	lda $0654			lda 	gxSpritesOn
.b2ac	f0 65		beq $b313			beq 	_GXSIFail
.b2ae	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2b1	f0 60		beq $b313			beq 	_GXSIFail
.b2b3	85 37		sta $37				sta 	gxzTemp0+1
.b2b5	a0 04		ldy #$04			ldy 	#4
.b2b7	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b2ba	85 36		sta $36				sta 	gxzTemp0
.b2bc	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2bf	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b2c2	2a		rol a				rol 	a	 						; into bits 0,1.
.b2c3	2a		rol a				rol 	a
.b2c4	2a		rol a				rol 	a
.b2c5	29 03		and #$03			and 	#3
.b2c7	aa		tax				tax
.b2c8	bd 15 b3	lda $b315,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2cb	48		pha				pha
.b2cc	18		clc				clc
.b2cd	6d 4c 06	adc $064c			adc 	gxX0						; copy position.
.b2d0	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2d2	c8		iny				iny
.b2d3	ad 4d 06	lda $064d			lda 	gxX0+1
.b2d6	69 00		adc #$00			adc 	#0
.b2d8	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2da	c8		iny				iny
.b2db	68		pla				pla
.b2dc	18		clc				clc
.b2dd	6d 4e 06	adc $064e			adc 	gxY0
.b2e0	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e2	a9 00		lda #$00			lda 	#0
.b2e4	69 00		adc #$00			adc 	#0
.b2e6	c8		iny				iny
.b2e7	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e9	4e 4d 06	lsr $064d			lsr 	gxX0+1 						; divide X by 4
.b2ec	6e 4c 06	ror $064c			ror 	gxX0
.b2ef	4e 4c 06	lsr $064c			lsr 	gxX0
.b2f2	4e 4e 06	lsr $064e			lsr 	gxY0 						; divide Y by 4
.b2f5	4e 4e 06	lsr $064e			lsr 	gxY0
.b2f8	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b2fb	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x
.b2fe	29 80		and #$80			and 	#$80
.b300	0d 4c 06	ora $064c			ora 	gxX0
.b303	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b306	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b309	29 c0		and #$c0			and 	#$C0
.b30b	0d 4e 06	ora $064e			ora 	gxY0
.b30e	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b311	18		clc				clc
.b312	60		rts				rts
.b313					_GXSIFail:
.b313	38		sec				sec
.b314	60		rts				rts
.b315					_GXMSOffset:
>b315	1c						.byte 	32-8/2
>b316	18						.byte 	32-16/2
>b317	14						.byte 	32-24/2
>b318	10						.byte 	32-32/2
.b319					GXOpenBitmap:
.b319	78		sei				sei 								; no interrupts here
.b31a	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b31c	8d 5d 06	sta $065d			sta 	gxOriginalLUTValue
.b31f	58		cli				cli
.b320	60		rts				rts
.b321					GXCloseBitmap:
.b321	78		sei				sei
.b322	ad 5d 06	lda $065d			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b325	85 0b		sta $0b				sta 	GXEditSlot
.b327	58		cli				cli
.b328	60		rts				rts
.b329					GXPositionCalc:
.b329	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b32b	48		pha				pha
.b32c	ad 4e 06	lda $064e			lda 	GXY0 						; gxzScreen = Y0
.b32f	85 3c		sta $3c				sta 	gxzScreen
.b331	64 3d		stz $3d				stz 	gxzScreen+1
.b333	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b335	26 3d		rol $3d				rol 	gxzScreen+1
.b337	06 3c		asl $3c				asl 	gxzScreen
.b339	26 3d		rol $3d				rol 	gxzScreen+1
.b33b	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b33c	65 3c		adc $3c				adc 	gxzScreen
.b33e	85 3c		sta $3c				sta 	gxzScreen
.b340	90 02		bcc $b344			bcc 	_GXPCNoCarry
.b342	e6 3d		inc $3d				inc 	gxzScreen+1
.b344					_GXPCNoCarry:
.b344	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b346	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b348	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b34a	85 36		sta $36				sta 	gxzTemp0
.b34c	64 3d		stz $3d				stz 	gxzScreen+1
.b34e	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b350					_GXPCMultiply32:
.b350	06 3c		asl $3c				asl 	gxzScreen
.b352	26 3d		rol $3d				rol 	gxzScreen+1
.b354	3a		dec a				dec 	a
.b355	d0 f9		bne $b350			bne 	_GXPCMultiply32
.b357	18		clc				clc
.b358	ad 4c 06	lda $064c			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b35b	65 3c		adc $3c				adc 	gxzScreen
.b35d	8d 5e 06	sta $065e			sta 	gsOffset
.b360	ad 4d 06	lda $064d			lda 	GXX0+1
.b363	65 3d		adc $3d				adc 	gxzScreen+1
.b365	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b367	90 04		bcc $b36d			bcc 	_GXPCNoOverflow
.b369	29 1f		and #$1f			and 	#$1F 						; fix it up
.b36b	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b36d					_GXPCNoOverflow:
.b36d	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b36f	85 3d		sta $3d				sta 	gxzScreen+1
.b371	64 3c		stz $3c				stz 	gxzScreen
.b373	18		clc				clc
.b374	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b376	6d 56 06	adc $0656			adc 	gxBasePage 					; by adding the base page
.b379	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b37b	68		pla				pla
.b37c	85 36		sta $36				sta 	gxzTemp0
.b37e	60		rts				rts
.b37f					GXMovePositionDown:
.b37f	18		clc				clc 								; add 320 to offset/temp+1
.b380	ad 5e 06	lda $065e			lda 	gsOffset
.b383	69 40		adc #$40			adc 	#64
.b385	8d 5e 06	sta $065e			sta 	gsOffset
.b388	a5 3d		lda $3d				lda 	gxzScreen+1
.b38a	69 01		adc #$01			adc 	#1
.b38c	85 3d		sta $3d				sta 	gxzScreen+1
.b38e	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b390	90 07		bcc $b399			bcc 	_GXMPDExit
.b392	38		sec				sec  								; next page
.b393	e9 20		sbc #$20			sbc 	#$20
.b395	85 3d		sta $3d				sta 	gxzScreen+1
.b397	e6 0b		inc $0b				inc 	GXEditSlot
.b399					_GXMPDExit:
.b399	60		rts				rts
.b39a					GXCollide:
.b39a	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b39c	aa		tax				tax
.b39d	05 37		ora $37				ora 	gxzTemp0+1
.b39f	29 c0		and #$c0			and 	#$C0
.b3a1	38		sec				sec
.b3a2	d0 53		bne $b3f7			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3a4	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3a6	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3a9	1d 64 06	ora $0664,x			ora 	GXSpriteLow,x
.b3ac	30 48		bmi $b3f6			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3ae	18		clc				clc 								; need to calculate sum of sizes.
.b3af	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y
.b3b2	7d a4 06	adc $06a4,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3b5	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3b7	6a		ror a				ror 	a 							; 5/6/7
.b3b8	4a		lsr a				lsr 	a 							; 4/5/6
.b3b9	4a		lsr a				lsr 	a 							; 3/4/5
.b3ba	4a		lsr a				lsr 	a 							; 2/3/4
.b3bb	18		clc				clc
.b3bc	69 08		adc #$08			adc 	#$08
.b3be	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3bf	4a		lsr a				lsr 	a
.b3c0	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3c2	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3c5	29 3f		and #$3f			and 	#$3F
.b3c7	85 39		sta $39				sta 	gxzTemp1+1
.b3c9	38		sec				sec
.b3ca	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b3cd	29 3f		and #$3f			and 	#$3F
.b3cf	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3d1	b0 03		bcs $b3d6			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3d3	49 ff		eor #$ff			eor 	#$FF
.b3d5	1a		inc a				inc 	a
.b3d6					_GXCAbs1:
.b3d6	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3d8	b0 1c		bcs $b3f6			bcs 	_GXOkayFail
.b3da	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3dc	38		sec				sec 								; calculate |x1-x0|
.b3dd	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y
.b3e0	fd 64 06	sbc $0664,x			sbc 	GXSpriteLow,x
.b3e3	b0 03		bcs $b3e8			bcs 	_GXCAbs2
.b3e5	49 ff		eor #$ff			eor 	#$FF
.b3e7	1a		inc a				inc 	a
.b3e8					_GXCAbs2:
.b3e8	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3ea	b0 0a		bcs $b3f6			bcs 	_GXOkayFail
.b3ec	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b3ee	90 02		bcc $b3f2			bcc 	_GXCHaveLowest
.b3f0	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b3f2					_GXCHaveLowest:
.b3f2	0a		asl a				asl 	a 							; scale to allow for >> 2
.b3f3	0a		asl a				asl 	a
.b3f4	18		clc				clc
.b3f5	60		rts				rts
.b3f6					_GXOkayFail:
.b3f6	18		clc				clc
.b3f7					_GXCollideFail:
.b3f7	a9 ff		lda #$ff			lda 	#$FF
.b3f9	60		rts				rts
.b3fa					GXFindSprite:
.b3fa	aa		tax				tax
.b3fb	ad 57 06	lda $0657			lda 	GXSpritePage 				; access the base page of the sprite
.b3fe	85 0b		sta $0b				sta 	GXEditSlot
.b400	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b403	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b406	f0 33		beq $b43b			beq 	_GXFSFail
.b408	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b40b	8d fb 06	sta $06fb			sta 	GXSpriteOffset+1
.b40e	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b411	48		pha				pha 								; save twice
.b412	48		pha				pha
.b413	29 03		and #$03			and 	#3 							; get sprite size
.b415	8d f8 06	sta $06f8			sta 	GXSizeBits 					; save raw (0-3)
.b418	aa		tax				tax
.b419	bd 3d b4	lda $b43d,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b41c	8d f7 06	sta $06f7			sta 	GXSizePixels 					; save (8/16/24/32)
.b41f	68		pla				pla 								; get LUT
.b420	4a		lsr a				lsr		a
.b421	4a		lsr a				lsr		a
.b422	29 03		and #$03			and 	#3
.b424	8d f9 06	sta $06f9			sta 	GXSpriteLUT
.b427	68		pla				pla 								; address, neeeds to be x 4
.b428	29 f0		and #$f0			and 	#$F0
.b42a	8d fa 06	sta $06fa			sta 	GXSpriteOffset
.b42d	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b430	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b433	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b436	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b439	18		clc				clc
.b43a	60		rts				rts
.b43b					_GXFSFail:
.b43b	38		sec				sec
.b43c	60		rts				rts
.b43d					_GXFXSSTTable:
>b43d	08 10 18 20					.byte 	8,16,24,32
.06f7					GXSizePixels:
>06f7							.fill 	1
.06f8					GXSizeBits:
>06f8							.fill 	1
.06f9					GXSpriteLUT:
>06f9							.fill 	1
.06fa					GXSpriteOffset:
>06fa							.fill 	2
.b441					GXSortXY:
.b441	20 5f b4	jsr $b45f			jsr 	GXSortY 					; will be sorted on Y now
.b444	ad 4c 06	lda $064c			lda 	gxX0 						; compare X0 v X1
.b447	cd 50 06	cmp $0650			cmp 	gxX1
.b44a	ad 4d 06	lda $064d			lda 	gXX0+1
.b44d	ed 51 06	sbc $0651			sbc 	gXX1+1
.b450	90 0c		bcc $b45e			bcc 	_GXSXYExit 					; X0 < X1 exit
.b452	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b454	a0 04		ldy #$04			ldy 	#4
.b456	20 73 b4	jsr $b473			jsr 	GXSwapXY
.b459	e8		inx				inx
.b45a	c8		iny				iny
.b45b	20 73 b4	jsr $b473			jsr 	GXSwapXY
.b45e					_GXSXYExit:
.b45e	60		rts				rts
.b45f					GXSortY:
.b45f	ad 4e 06	lda $064e			lda 	gxY0 						; if Y0 >= Y1
.b462	cd 52 06	cmp $0652			cmp 	gxY1
.b465	90 0b		bcc $b472			bcc 	_GXSYSorted
.b467	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b469	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b46b					_GXSwap1:
.b46b	20 73 b4	jsr $b473			jsr 	GXSwapXY
.b46e	88		dey				dey
.b46f	ca		dex				dex
.b470	10 f9		bpl $b46b			bpl 	_GXSwap1
.b472					_GXSYSorted:
.b472	60		rts				rts
.b473					GXSwapXY:
.b473	bd 4c 06	lda $064c,x			lda 	gxX0,x
.b476	48		pha				pha
.b477	b9 4c 06	lda $064c,y			lda 	gxX0,y
.b47a	9d 4c 06	sta $064c,x			sta 	gxX0,x
.b47d	68		pla				pla
.b47e	99 4c 06	sta $064c,y			sta 	gxX0,y
.b481	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.baf7					KeywordSet0:
>baf7	00 65					.text	0,$65,""               ; $80 !0:EOF
>baf9	00 58					.text	0,$58,""               ; $81 !1:SH1
>bafb	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bafd	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>bb03	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>bb0b	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>bb11	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>bb18	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>bb20	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>bb27	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>bb2e	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>bb34	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>bb3a	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>bb42	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>bb49	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>bb50	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>bb57	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>bb5f	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>bb65	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>bb6b	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>bb72	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bb78	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bb7e	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bb86	47 28
>bb88	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>bb90	28
>bb91	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>bb99	28
>bb9a	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bba0	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bba6	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>bbac	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>bbb3	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>bbbb	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bbc1	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bbc7	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bbcc	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bbd0	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bbd6	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bbde	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bbe5	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bbec	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bbf4	43
>bbf5	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bbfb	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bc01	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bc08	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bc0e	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bc12	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bc18	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bc20	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bc27	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bc2c	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bc33	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bc3b	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bc41	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bc46	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bc4e	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bc54	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bc5a	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bc5f	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bc66	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bc6c	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bc72	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bc79	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>bc80	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>bc85	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>bc8b	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>bc92	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>bc97	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>bc9b	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>bca3	45
>bca4	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>bcac	45
>bcad	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>bcb3	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>bcba	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>bcc0	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>bcc6	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>bccb	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bcd3	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>bcda	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bce1	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>bce9	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bcef	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bcf3	ff					.text	$FF
.bcf4					KeywordSet1:
>bcf4	00 65					.text	0,$65,""               ; $80 !0:EOF
>bcf6	00 58					.text	0,$58,""               ; $81 !1:SH1
>bcf8	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bcfa	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bd02	4c 45
>bd04	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bd0c	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bd14	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bd19	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>bd1d	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>bd23	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>bd29	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>bd2e	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>bd36	45
>bd37	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>bd3c	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>bd44	53
>bd45	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>bd4b	ff					.text	$FF
.bd4c					KeywordSet2:
>bd4c	00 65					.text	0,$65,""               ; $80 !0:EOF
>bd4e	00 58					.text	0,$58,""               ; $81 !1:SH1
>bd50	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bd52	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bd57	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bd5c	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bd61	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bd66	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bd6b	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bd70	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bd75	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bd7a	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bd7f	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bd84	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bd89	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bd8e	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bd93	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bd98	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bd9d	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bda2	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bda7	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bdac	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bdb1	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bdb6	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bdbb	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bdc0	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bdc5	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bdca	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bdcf	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bdd4	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bdd9	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bdde	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bde3	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bde8	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bded	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bdf2	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>bdf7	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>bdfc	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>be01	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>be06	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>be0b	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>be10	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>be15	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>be1a	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>be1f	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>be24	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>be29	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>be2e	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>be33	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>be38	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>be3d	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>be42	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>be47	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>be4c	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>be51	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>be56	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>be5b	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>be60	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>be65	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>be6a	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>be6f	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>be74	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>be79	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>be7e	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>be83	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>be88	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>be8d	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>be92	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>be97	ff					.text	$FF
.b482					ListConvertLine:
.b482	48		pha				pha 								; save indent on the stack
.b483	9c 9d 04	stz $049d			stz 	tbOffset
.b486	9c ac 04	stz $04ac			stz 	tokenBuffer
.b489	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b48b	b1 30		lda ($30),y			lda 	(codePtr),y
.b48d	aa		tax				tax
.b48e	88		dey				dey
.b48f	b1 30		lda ($30),y			lda 	(codePtr),y
.b491	20 07 93	jsr $9307			jsr 	LCLConvertInt16
.b494	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b496	86 37		stx $37				stx 	zTemp0+1
.b498	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b49a	20 df b5	jsr $b5df			jsr 	LCLWrite
.b49d	a0 00		ldy #$00			ldy 	#0
.b49f					_LCCopyNumber:
.b49f	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4a1	20 df b5	jsr $b5df			jsr 	LCLWrite
.b4a4	c8		iny				iny
.b4a5	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4a7	d0 f6		bne $b49f			bne 	_LCCopyNumber
.b4a9	68		pla				pla 								; adjustment to indent
.b4aa	48		pha				pha 								; save on stack
.b4ab	10 0c		bpl $b4b9			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b4ad	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b4ae	6d a6 04	adc $04a6			adc 	listIndent
.b4b1	8d a6 04	sta $04a6			sta 	listIndent
.b4b4	10 03		bpl $b4b9			bpl 	_LCNoAdjust
.b4b6	9c a6 04	stz $04a6			stz 	listIndent
.b4b9					_LCNoAdjust:
.b4b9	18		clc				clc		 							; work out actual indent.
.b4ba	ad a6 04	lda $04a6			lda 	listIndent
.b4bd	0a		asl a				asl 	a
.b4be	69 06		adc #$06			adc 	#6
.b4c0	85 36		sta $36				sta 	zTemp0
.b4c2					_LCPadOut:
.b4c2	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b4c4	20 df b5	jsr $b5df			jsr 	LCLWrite
.b4c7	ad 9d 04	lda $049d			lda 	tbOffset
.b4ca	c5 36		cmp $36				cmp 	zTemp0
.b4cc	d0 f4		bne $b4c2			bne 	_LCPadOut
.b4ce	a0 03		ldy #$03			ldy 	#3 							; start position.
.b4d0					_LCMainLoop:
.b4d0	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b4d2	20 df b5	jsr $b5df			jsr 	LCLWrite
.b4d5	b1 30		lda ($30),y			lda 	(codePtr),y
.b4d7	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b4d9	f0 17		beq $b4f2			beq 	_LCExit
.b4db	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b4dd	90 1e		bcc $b4fd			bcc 	_LCDoubles
.b4df	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b4e1	90 2a		bcc $b50d			bcc 	_LCShiftPunc
.b4e3	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b4e5	90 35		bcc $b51c			bcc 	_LCPunctuation
.b4e7	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b4e9	90 3e		bcc $b529			bcc 	_LCIdentifiers
.b4eb	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b4ed	90 5f		bcc $b54e			bcc 	_LCTokens
.b4ef	4c ae b5	jmp $b5ae			jmp 	_LCData 					; 254-5 are data objects
.b4f2					_LCExit:
.b4f2	68		pla				pla 								; get old indent adjust
.b4f3	30 07		bmi $b4fc			bmi 	_LCExit2
.b4f5	18		clc				clc 								; add to indent if +ve
.b4f6	6d a6 04	adc $04a6			adc 	listIndent
.b4f9	8d a6 04	sta $04a6			sta 	listIndent
.b4fc					_LCExit2:
.b4fc	60		rts				rts
.b4fd					_LCDoubles:
.b4fd	48		pha				pha
.b4fe	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b4ff	29 02		and #$02			and 	#2
.b501	09 3c		ora #$3c			ora 	#60 						; make < >
.b503	20 df b5	jsr $b5df			jsr 	LCLWrite
.b506	68		pla				pla 								; restore, do lower bit
.b507	29 03		and #$03			and 	#3
.b509	09 3c		ora #$3c			ora 	#60
.b50b	80 0f		bra $b51c			bra		_LCPunctuation 				; print, increment, loop
.b50d					_LCShiftPunc:
.b50d	aa		tax				tax 								; save in X
.b50e	29 07		and #$07			and 	#7 							; lower 3 bits
.b510	f0 02		beq $b514			beq 	_LCNoAdd
.b512	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b514					_LCNoAdd:
.b514	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b516	90 02		bcc $b51a			bcc 	_LCNoAdd2
.b518	09 20		ora #$20			ora 	#32 						; adds $20
.b51a					_LCNoAdd2:
.b51a	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b51c					_LCPunctuation:
.b51c	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b51e	d0 03		bne $b523			bne 	_LCPContinue
.b520	20 f5 b5	jsr $b5f5			jsr 	LCLDeleteLastSpace
.b523					_LCPContinue:
.b523	c8		iny				iny 								; consume character
.b524	20 df b5	jsr $b5df			jsr 	LCLWrite 					; write it out.
.b527	80 a7		bra $b4d0			bra 	_LCMainLoop 				; go round again.
.b529					_LCIdentifiers:
.b529	18		clc				clc 								; convert to physical address
.b52a	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b52c	85 37		sta $37				sta 	zTemp0+1
.b52e	c8		iny				iny
.b52f	b1 30		lda ($30),y			lda 	(codePtr),y
.b531	85 36		sta $36				sta 	zTemp0
.b533	c8		iny				iny
.b534	5a		phy				phy 								; save position
.b535	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b537	20 df b5	jsr $b5df			jsr 	LCLWrite
.b53a	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b53c					_LCOutIdentifier:
.b53c	c8		iny				iny
.b53d	b1 36		lda ($36),y			lda 	(zTemp0),y
.b53f	29 7f		and #$7f			and 	#$7F
.b541	20 31 b6	jsr $b631			jsr 	LCLLowerCase
.b544	20 df b5	jsr $b5df			jsr 	LCLWrite
.b547	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b549	10 f1		bpl $b53c			bpl 	_LCOutIdentifier
.b54b	7a		ply				ply 								; restore position
.b54c	80 82		bra $b4d0			bra 	_LCMainLoop
.b54e					_LCTokens:
.b54e	aa		tax				tax 								; token in X
.b54f	a9 4c		lda #$4c			lda 	#((KeywordSet2) & $FF)
.b551	85 36		sta $36				sta 	0+zTemp0
.b553	a9 bd		lda #$bd			lda 	#((KeywordSet2) >> 8)
.b555	85 37		sta $37				sta 	1+zTemp0
.b557	e0 82		cpx #$82			cpx 	#$82
.b559	f0 16		beq $b571			beq 	_LCUseShift
.b55b	a9 f4		lda #$f4			lda 	#((KeywordSet1) & $FF)
.b55d	85 36		sta $36				sta 	0+zTemp0
.b55f	a9 bc		lda #$bc			lda 	#((KeywordSet1) >> 8)
.b561	85 37		sta $37				sta 	1+zTemp0
.b563	e0 81		cpx #$81			cpx 	#$81
.b565	f0 0a		beq $b571			beq 	_LCUseShift
.b567	a9 f7		lda #$f7			lda 	#((KeywordSet0) & $FF)
.b569	85 36		sta $36				sta 	0+zTemp0
.b56b	a9 ba		lda #$ba			lda 	#((KeywordSet0) >> 8)
.b56d	85 37		sta $37				sta 	1+zTemp0
.b56f	80 01		bra $b572			bra 	_LCNoShift
.b571					_LCUseShift:
.b571	c8		iny				iny
.b572					_LCNoShift:
.b572	20 09 b6	jsr $b609			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b575	b1 30		lda ($30),y			lda 	(codePtr),y
.b577	aa		tax				tax 								; into X
.b578					_LCFindText:
.b578	ca		dex				dex
.b579	10 0e		bpl $b589			bpl 	_LCFoundText 				; found text.
.b57b	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b57d	1a		inc a				inc 	a 							; one extra for size
.b57e	38		sec				sec 								; one extra for checksum
.b57f	65 36		adc $36				adc 	zTemp0 						; go to next token
.b581	85 36		sta $36				sta 	zTemp0
.b583	90 f3		bcc $b578			bcc 	_LCFindText
.b585	e6 37		inc $37				inc 	zTemp0+1
.b587	80 ef		bra $b578			bra 	_LCFindText
.b589					_LCFoundText:
.b589	5a		phy				phy 								; save List position
.b58a	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b58c	aa		tax				tax
.b58d	a9 83		lda #$83			lda 	#CLIToken+$80
.b58f	20 df b5	jsr $b5df			jsr 	LCLWrite
.b592	a0 02		ldy #$02			ldy 	#2
.b594					_LCCopyToken:
.b594	b1 36		lda ($36),y			lda 	(zTemp0),y
.b596	20 31 b6	jsr $b631			jsr 	LCLLowerCase
.b599	20 df b5	jsr $b5df			jsr 	LCLWrite
.b59c	c8		iny				iny
.b59d	ca		dex				dex
.b59e	d0 f4		bne $b594			bne 	_LCCopyToken
.b5a0	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b5a2	f0 05		beq $b5a9			beq 	_LCNoSpace
.b5a4	a9 20		lda #$20			lda 	#' '
.b5a6	20 df b5	jsr $b5df			jsr 	LCLWrite
.b5a9					_LCNoSpace:
.b5a9	7a		ply				ply 								; restore position.
.b5aa	c8		iny				iny 								; consume token
.b5ab	4c d0 b4	jmp $b4d0			jmp 	_LCMainLoop 				; and go around again.
.b5ae					_LCData:
.b5ae	48		pha				pha 								; save type $FE/$FF
.b5af	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b5b1	c9 fe		cmp #$fe			cmp 	#$FE
.b5b3	f0 07		beq $b5bc			beq 	_LCHaveOpener
.b5b5	a2 22		ldx #$22			ldx 	#'"'
.b5b7	a9 81		lda #$81			lda 	#CLIData+$80
.b5b9	20 df b5	jsr $b5df			jsr 	LCLWrite
.b5bc					_LCHaveOpener:
.b5bc	8a		txa				txa 								; output prefix (# or ")
.b5bd	20 df b5	jsr $b5df			jsr 	LCLWrite
.b5c0	c8		iny				iny 								; get count
.b5c1	b1 30		lda ($30),y			lda 	(codePtr),y
.b5c3	aa		tax				tax
.b5c4	c8		iny				iny 								; point at first character
.b5c5					_LCOutData:
.b5c5	b1 30		lda ($30),y			lda 	(codePtr),y
.b5c7	c9 00		cmp #$00			cmp 	#0
.b5c9	f0 03		beq $b5ce			beq 	_LCNoPrint
.b5cb	20 df b5	jsr $b5df			jsr 	LCLWrite
.b5ce					_LCNoPrint:
.b5ce	c8		iny				iny
.b5cf	ca		dex				dex
.b5d0	d0 f3		bne $b5c5			bne 	_LCOutData
.b5d2	68		pla				pla 								; closing " required ?
.b5d3	c9 ff		cmp #$ff			cmp 	#$FF
.b5d5	d0 05		bne $b5dc			bne 	_LCNoQuote
.b5d7	a9 22		lda #$22			lda 	#'"'
.b5d9	20 df b5	jsr $b5df			jsr 	LCLWrite
.b5dc					_LCNoQuote:
.b5dc	4c d0 b4	jmp $b4d0			jmp 	_LCMainLoop
.b5df					LCLWrite:
.b5df	da		phx				phx
.b5e0	ae 9d 04	ldx $049d			ldx 	tbOffset
.b5e3	9d ac 04	sta $04ac,x			sta 	tokenBuffer,x
.b5e6	9e ad 04	stz $04ad,x			stz 	tokenBuffer+1,x
.b5e9	ee 9d 04	inc $049d			inc 	tbOffset
.b5ec	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b5ee	30 03		bmi $b5f3			bmi 	_LCLNoColour
.b5f0	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b5f3					_LCLNoColour:
.b5f3	fa		plx				plx
.b5f4	60		rts				rts
.b5f5					LCLDeleteLastSpace:
.b5f5	48		pha				pha
.b5f6	da		phx				phx
.b5f7	ae 9d 04	ldx $049d			ldx 	tbOffset
.b5fa	f0 0a		beq $b606			beq 	_LCDLSExit
.b5fc	bd ab 04	lda $04ab,x			lda 	tokenBuffer-1,x
.b5ff	c9 20		cmp #$20			cmp 	#' '
.b601	d0 03		bne $b606			bne 	_LCDLSExit
.b603	ce 9d 04	dec $049d			dec 	tbOffset
.b606					_LCDLSExit:
.b606	fa		plx				plx
.b607	68		pla				pla
.b608	60		rts				rts
.b609					LCLCheckSpaceRequired:
.b609	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b60c	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b60e	f0 1b		beq $b62b			beq 	_LCCSRSpace
.b610	c9 29		cmp #$29			cmp 	#')'
.b612	f0 17		beq $b62b			beq 	_LCCSRSpace
.b614	c9 23		cmp #$23			cmp 	#'#'
.b616	f0 13		beq $b62b			beq 	_LCCSRSpace
.b618	20 31 b6	jsr $b631			jsr 	LCLLowerCase 				; saves a little effort
.b61b	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b61d	90 11		bcc $b630			bcc 	_LCCSRExit
.b61f	c9 3a		cmp #$3a			cmp 	#"9"+1
.b621	90 08		bcc $b62b			bcc 	_LCCSRSpace
.b623	c9 61		cmp #$61			cmp 	#"a"
.b625	90 09		bcc $b630			bcc 	_LCCSRExit
.b627	c9 7b		cmp #$7b			cmp 	#"z"+1
.b629	b0 05		bcs $b630			bcs 	_LCCSRExit
.b62b					_LCCSRSpace:
.b62b	a9 20		lda #$20			lda 	#' '
.b62d	20 df b5	jsr $b5df			jsr 	LCLWrite
.b630					_LCCSRExit:
.b630	60		rts				rts
.b631					LCLLowerCase:
.b631	c9 41		cmp #$41			cmp 	#"A"
.b633	90 06		bcc $b63b			bcc 	_LCLLCOut
.b635	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b637	b0 02		bcs $b63b			bcs 	_LCLLCOut
.b639	69 20		adc #$20			adc 	#$20
.b63b					_LCLLCOut:
.b63b	60		rts				rts
.b63c					LCLUpperCase:
.b63c	c9 61		cmp #$61			cmp 	#"a"
.b63e	90 06		bcc $b646			bcc 	_LCLUCOut
.b640	c9 7b		cmp #$7b			cmp 	#"z"+1
.b642	b0 02		bcs $b646			bcs 	_LCLUCOut
.b644	e9 1f		sbc #$1f			sbc 	#$1F
.b646					_LCLUCOut:
.b646	60		rts				rts
.b647					TOKSearchTable:
.b647	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token.
.b649	85 36		sta $36				sta 	zTemp0
.b64b	a0 00		ldy #$00			ldy 	#0
.b64d	a9 80		lda #$80			lda 	#$80 						; token #
.b64f	85 38		sta $38				sta 	zTemp1
.b651					_TSTLoop:
.b651	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b653	30 49		bmi $b69e			bmi 	_TSTFail 					; -ve = end of table
.b655	f0 2e		beq $b685			beq 	_TSTNext 					; zero, check next it's a dummy
.b657	c8		iny				iny 								; get the hash
.b658	b1 36		lda ($36),y			lda 	(zTemp0),y
.b65a	88		dey				dey
.b65b	cd 83 04	cmp $0483			cmp 	identHash 					; check they match, if not go to next
.b65e	d0 25		bne $b685			bne 	_TSTNext
.b660	ad 82 04	lda $0482			lda 	identTypeEnd 				; length of identifier
.b663	38		sec				sec
.b664	ed 80 04	sbc $0480			sbc 	identStart
.b667	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; no match, then return.
.b669	d0 1a		bne $b685			bne 	_TSTNext
.b66b	5a		phy				phy 								; save Y , we might fail
.b66c	c8		iny				iny 								; point to text
.b66d	c8		iny				iny
.b66e	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b671					_TSTCompareName:
.b671	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; compare text.
.b674	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b676	d0 0c		bne $b684			bne 	_TSTNextPullY 				; fail, pullY and do next
.b678	e8		inx				inx
.b679	c8		iny				iny
.b67a	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b67d	d0 f2		bne $b671			bne 	_TSTCompareName
.b67f	7a		ply				ply 								; throw Y
.b680	a5 38		lda $38				lda 	zTemp1 						; get token #
.b682	38		sec				sec 								; return with CS = passed.
.b683	60		rts				rts
.b684					_TSTNextPullY:
.b684	7a		ply				ply 								; restore current, fall through.
.b685					_TSTNext:
.b685	e6 38		inc $38				inc 	zTemp1 						; token counter
.b687	98		tya				tya
.b688	18		clc				clc
.b689	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b68b	1a		inc a				inc 	a 							; +1
.b68c	1a		inc a				inc 	a 							; +2
.b68d	a8		tay				tay
.b68e	10 c1		bpl $b651			bpl 	_TSTLoop 					; if Y < $80 loop back
.b690	98		tya				tya 								; add Y to zTemp0 and reset Y
.b691	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b693	18		clc				clc  								; but have tables > 255 bytes
.b694	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b696	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b698	90 b7		bcc $b651			bcc 	_TSTLoop
.b69a	e6 37		inc $37				inc 	zTemp0+1
.b69c	80 b3		bra $b651			bra 	_TSTLoop
.b69e					_TSTFail:
.b69e	18		clc				clc
.b69f	60		rts				rts
.b6a0					TokeniseLine:
.b6a0	20 28 b8	jsr $b828			jsr 	LCLFixLineBufferCase 		; fix line case
.b6a3	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b6a5	8d a9 04	sta $04a9			sta 	tokenOffset
.b6a8	9c aa 04	stz $04aa			stz 	tokenLineNumber
.b6ab	9c ab 04	stz $04ab			stz 	tokenLineNumber+1
.b6ae	a2 ff		ldx #$ff			ldx 	#$FF
.b6b0					_TKFindFirst:
.b6b0	e8		inx				inx
.b6b1	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b6b4	f0 79		beq $b72f			beq 	_TKExit
.b6b6	c9 20		cmp #$20			cmp 	#' '
.b6b8	90 f6		bcc $b6b0			bcc 	_TKFindFirst
.b6ba	c9 30		cmp #$30			cmp 	#'0'
.b6bc	90 07		bcc $b6c5			bcc 	_TKNoLineNumber
.b6be	c9 3a		cmp #$3a			cmp 	#'9'+1
.b6c0	b0 03		bcs $b6c5			bcs 	_TKNoLineNumber
.b6c2	20 52 b8	jsr $b852			jsr 	TOKExtractLineNumber
.b6c5					_TKNoLineNumber:
.b6c5					_TKTokeniseLoop:
.b6c5	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b6c8	f0 65		beq $b72f			beq 	_TKExit
.b6ca	e8		inx				inx
.b6cb	c9 20		cmp #$20			cmp 	#' '
.b6cd	f0 f6		beq $b6c5			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b6cf	ca		dex				dex 								; undo last get, A contains character, X is position.
.b6d0	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b6d2	f0 61		beq $b735			beq 	_TKTokeniseIdentifier
.b6d4	c9 41		cmp #$41			cmp 	#'A'
.b6d6	90 04		bcc $b6dc			bcc 	_TKTokenisePunctuation
.b6d8	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b6da	90 59		bcc $b735			bcc 	_TKTokeniseIdentifier
.b6dc					_TKTokenisePunctuation:
.b6dc	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b6de	f0 27		beq $b707			beq 	_TKString
.b6e0	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant (# only appears at end of identifiers)
.b6e2	f0 28		beq $b70c			beq 	_TKHexConstant
.b6e4	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers.
.b6e6	f0 29		beq $b711			beq 	_TKCheckDouble
.b6e8	c9 3e		cmp #$3e			cmp 	#'>'
.b6ea	f0 25		beq $b711			beq 	_TKCheckDouble
.b6ec					_TKStandardPunctuation:
.b6ec	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get it back.
.b6ef	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b6f1	90 0e		bcc $b701			bcc 	_TKNoShift
.b6f3	48		pha				pha 								; save
.b6f4	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b6f6	85 36		sta $36				sta 	zTemp0
.b6f8	68		pla				pla
.b6f9	29 20		and #$20			and 	#32 						; bit 5
.b6fb	4a		lsr a				lsr 	a 							; shift into bit 3
.b6fc	4a		lsr a				lsr 	a
.b6fd	05 36		ora $36				ora 	zTemp0
.b6ff	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b701					_TKNoShift:
.b701	20 97 b8	jsr $b897			jsr 	TOKWriteByte 				; write the punctuation character
.b704	e8		inx				inx 								; consume the character
.b705	80 be		bra $b6c5			bra 	_TKTokeniseLoop 			; and loop round again.
.b707					_TKString:
.b707	20 b7 b7	jsr $b7b7			jsr 	TOKTokenString
.b70a	80 b9		bra $b6c5			bra 	_TKTokeniseLoop
.b70c					_TKHexConstant:
.b70c	20 f2 b7	jsr $b7f2			jsr 	TOKHexConstant
.b70f	80 b4		bra $b6c5			bra 	_TKTokeniseLoop
.b711					_TKCheckDouble:
.b711	bd aa 05	lda $05aa,x			lda 	lineBuffer+1,x 				; get next character
.b714	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b716	90 d4		bcc $b6ec			bcc 	_TKStandardPunctuation
.b718	c9 3f		cmp #$3f			cmp 	#'>'+1
.b71a	b0 d0		bcs $b6ec			bcs 	_TKStandardPunctuation
.b71c	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b71f	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b721	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b722	7d aa 05	adc $05aa,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b725	38		sec				sec
.b726	e9 3c		sbc #$3c			sbc 	#'<'
.b728	20 97 b8	jsr $b897			jsr 	TOKWriteByte 				; this is in the range 0-7
.b72b	e8		inx				inx 								; consume both
.b72c	e8		inx				inx
.b72d	80 96		bra $b6c5			bra 	_TKTokeniseLoop
.b72f	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b731	20 97 b8	jsr $b897			jsr 	TOKWriteByte
.b734	60		rts				rts
.b735					_TKTokeniseIdentifier:
.b735	8e 80 04	stx $0480			stx 	identStart 					; save start
.b738	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b73b					_TKCheckLoop:
.b73b	e8		inx				inx 								; look at next, we know first is identifier.
.b73c	bd a9 05	lda $05a9,x			lda  	lineBuffer,x
.b73f	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b741	f0 f8		beq $b73b			beq 	_TKCheckLoop
.b743	c9 30		cmp #$30			cmp	 	#"0"
.b745	90 0c		bcc $b753			bcc 	_TKEndIdentifier
.b747	c9 3a		cmp #$3a			cmp 	#"9"+1
.b749	90 f0		bcc $b73b			bcc 	_TKCheckLoop
.b74b	c9 41		cmp #$41			cmp	 	#"A"
.b74d	90 04		bcc $b753			bcc 	_TKEndIdentifier
.b74f	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b751	90 e8		bcc $b73b			bcc 	_TKCheckLoop
.b753					_TKEndIdentifier:
.b753	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b756	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b758	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b75a	f0 06		beq $b762			beq 	_TKHasTypeCharacter
.b75c	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b75e	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b760	d0 07		bne $b769			bne 	_TKNoTypeCharacter
.b762					_TKHasTypeCharacter:
.b762	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b765	e8		inx				inx 								; read next
.b766	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b769					_TKNoTypeCharacter:
.b769	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b76b	d0 09		bne $b776			bne 	_TKNoArray
.b76d	e8		inx				inx 								; skip the (
.b76e	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array)
.b771	09 04		ora #$04			ora 	#$04
.b773	8d 84 04	sta $0484			sta 	identTypeByte
.b776					_TKNoArray:
.b776	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b779	20 13 b8	jsr $b813			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b77c	a0 ba		ldy #$ba			ldy 	#(KeywordSet0) >> 8
.b77e	a9 f7		lda #$f7			lda 	#(KeywordSet0) & $FF
.b780	20 47 b6	jsr $b647			jsr 	TOKSearchTable
.b783	a2 00		ldx #$00			ldx 	#0
.b785	b0 1f		bcs $b7a6			bcs 	_TKFoundToken
.b787	a0 bc		ldy #$bc			ldy 	#(KeywordSet1) >> 8
.b789	a9 f4		lda #$f4			lda 	#(KeywordSet1) & $FF
.b78b	20 47 b6	jsr $b647			jsr 	TOKSearchTable
.b78e	a2 81		ldx #$81			ldx 	#$81
.b790	b0 14		bcs $b7a6			bcs 	_TKFoundToken
.b792	a0 bd		ldy #$bd			ldy 	#(KeywordSet2) >> 8
.b794	a9 4c		lda #$4c			lda 	#(KeywordSet2) & $FF
.b796	20 47 b6	jsr $b647			jsr 	TOKSearchTable
.b799	a2 82		ldx #$82			ldx 	#$82
.b79b	b0 09		bcs $b7a6			bcs 	_TKFoundToken
.b79d	20 a3 b8	jsr $b8a3			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b7a0	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b7a3	4c c5 b6	jmp $b6c5			jmp 	_TKTokeniseLoop 			; and go round again.
.b7a6					_TKFoundToken:
.b7a6	48		pha				pha 								; save token
.b7a7	8a		txa				txa 								; shift in X, is there one ?
.b7a8	f0 03		beq $b7ad			beq 	_TKNoTShift
.b7aa	20 97 b8	jsr $b897			jsr 	TOKWriteByte 				; if so, write it out
.b7ad					_TKNoTShift:
.b7ad	68		pla				pla 								; restore and write token
.b7ae	20 97 b8	jsr $b897			jsr 	TOKWriteByte
.b7b1	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b7b4	4c c5 b6	jmp $b6c5			jmp 	_TKTokeniseLoop 			; and go round again.
.b7b7					TOKTokenString:
.b7b7	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b7b9	20 97 b8	jsr $b897			jsr 	TOKWriteByte
.b7bc	e8		inx				inx									; start of quoted string.
.b7bd	da		phx				phx 								; push start of string on top
.b7be	ca		dex				dex
.b7bf					_TSFindEnd:
.b7bf	e8		inx				inx
.b7c0	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character
.b7c3	f0 04		beq $b7c9			beq 	_TSEndOfString
.b7c5	c9 22		cmp #$22			cmp 	#'"'
.b7c7	d0 f6		bne $b7bf			bne 	_TSFindEnd
.b7c9					_TSEndOfString:
.b7c9	7a		ply				ply  								; so now Y is first character, X is character after end.
.b7ca	48		pha				pha 								; save terminating character
.b7cb	20 d3 b7	jsr $b7d3			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b7ce	68		pla				pla 								; terminating character
.b7cf	f0 01		beq $b7d2			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b7d1	e8		inx				inx
.b7d2					_TSNotQuote:
.b7d2	60		rts				rts
.b7d3					TOKWriteBlockXY:
.b7d3	86 36		stx $36				stx 	zTemp0 						; write end character
.b7d5	98		tya				tya
.b7d6	49 ff		eor #$ff			eor 	#$FF
.b7d8	38		sec				sec
.b7d9	65 36		adc $36				adc 	zTemp0
.b7db	1a		inc a				inc 	a 							; one extra for NULL
.b7dc	20 97 b8	jsr $b897			jsr 	TOKWriteByte
.b7df					_TOBlockLoop:
.b7df	c4 36		cpy $36				cpy 	zTemp0
.b7e1	f0 09		beq $b7ec			beq 	_TOBlockExit
.b7e3	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y
.b7e6	20 97 b8	jsr $b897			jsr 	TOKWriteByte
.b7e9	c8		iny				iny
.b7ea	80 f3		bra $b7df			bra 	_TOBlockLoop
.b7ec					_TOBlockExit:
.b7ec	a9 00		lda #$00			lda 	#0
.b7ee	20 97 b8	jsr $b897			jsr 	TOKWriteByte
.b7f1	60		rts				rts
.b7f2					TOKHexConstant:
.b7f2	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b7f4	20 97 b8	jsr $b897			jsr 	TOKWriteByte
.b7f7	e8		inx				inx									; start of quoted string.
.b7f8	da		phx				phx 								; push start of constant on top
.b7f9	ca		dex				dex
.b7fa					_THFindLoop:
.b7fa	e8		inx				inx
.b7fb	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b7fe	c9 30		cmp #$30			cmp 	#"0"
.b800	90 0c		bcc $b80e			bcc 	_THFoundEnd
.b802	c9 3a		cmp #$3a			cmp 	#"9"+1
.b804	90 f4		bcc $b7fa			bcc 	_THFindLoop
.b806	c9 41		cmp #$41			cmp 	#"A"
.b808	90 04		bcc $b80e			bcc 	_THFoundEnd
.b80a	c9 47		cmp #$47			cmp 	#"F"+1
.b80c	90 ec		bcc $b7fa			bcc 	_THFindLoop
.b80e					_THFoundEnd:
.b80e	7a		ply				ply 								; restore start
.b80f	20 d3 b7	jsr $b7d3			jsr 	TOKWriteBlockXY 			; output the block
.b812	60		rts				rts
.b813					TOKCalculateHash:
.b813	da		phx				phx
.b814	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum
.b817	a9 00		lda #$00			lda 	#0
.b819					_TCHLoop:
.b819	18		clc				clc
.b81a	7d a9 05	adc $05a9,x			adc 	lineBuffer,x
.b81d	e8		inx				inx
.b81e	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b821	d0 f6		bne $b819			bne 	_TCHLoop
.b823	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b826	fa		plx				plx
.b827	60		rts				rts
.b828					LCLFixLineBufferCase:
.b828	a2 00		ldx #$00			ldx 	#0
.b82a					_FLBCLoop:
.b82a	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next character
.b82d	f0 22		beq $b851			beq 	_FLBCExit 					; end of string.
.b82f	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b831	f0 11		beq $b844			beq 	_FLBCInQuotes
.b833	e8		inx				inx
.b834	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b836	90 f2		bcc $b82a			bcc 	_FLBCLoop
.b838	c9 7b		cmp #$7b			cmp 	#'z'+1
.b83a	b0 ee		bcs $b82a			bcs 	_FLBCLoop
.b83c	38		sec				sec 								; make U/C
.b83d	e9 20		sbc #$20			sbc 	#32
.b83f	9d a8 05	sta $05a8,x			sta	 	lineBuffer-1,x 				; write back
.b842	80 e6		bra $b82a			bra 	_FLBCLoop
.b844					_FLBCInQuotes:
.b844	e8		inx				inx 								; advance
.b845	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next
.b848	f0 07		beq $b851			beq 	_FLBCExit 					; exit on EOS
.b84a	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b84c	d0 f6		bne $b844			bne 	_FLBCInQuotes
.b84e	e8		inx				inx 								; skip over it
.b84f	80 d9		bra $b82a			bra 	_FLBCLoop
.b851					_FLBCExit:
.b851	60		rts				rts
.b852					TOKExtractLineNumber:
.b852	ad ab 04	lda $04ab			lda 	tokenLineNumber+1 			; push current value on stack
.b855	48		pha				pha
.b856	ad aa 04	lda $04aa			lda 	tokenLineNumber
.b859	48		pha				pha
.b85a	20 90 b8	jsr $b890			jsr 	_LCLNTimes2 				; line # x 4
.b85d	20 90 b8	jsr $b890			jsr 	_LCLNTimes2 				; line # x 2
.b860	18		clc				clc 								; add stacked value
.b861	68		pla				pla
.b862	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b865	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b868	68		pla				pla
.b869	6d ab 04	adc $04ab			adc 	tokenLineNumber+1
.b86c	8d ab 04	sta $04ab			sta 	tokenLineNumber+1 			; line # x 5
.b86f	20 90 b8	jsr $b890			jsr 	_LCLNTimes2 				; line # x 10
.b872	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get and consume character
.b875	e8		inx				inx
.b876	29 0f		and #$0f			and 	#15 						; add to line #
.b878	18		clc				clc
.b879	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b87c	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b87f	90 03		bcc $b884			bcc 	_TLENNoCarry
.b881	ee ab 04	inc $04ab			inc 	tokenLineNumber+1
.b884					_TLENNoCarry:
.b884	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; more digits ?
.b887	c9 30		cmp #$30			cmp 	#'0'
.b889	90 04		bcc $b88f			bcc 	_TLENExit
.b88b	c9 3a		cmp #$3a			cmp 	#'9'+1
.b88d	90 c3		bcc $b852			bcc 	TOKExtractLineNumber
.b88f					_TLENExit:
.b88f	60		rts				rts
.b890					_LCLNTimes2:
.b890	0e aa 04	asl $04aa			asl 	tokenLineNumber
.b893	2e ab 04	rol $04ab			rol 	tokenLineNumber+1
.b896	60		rts				rts
.b897					TOKWriteByte:
.b897	da		phx				phx
.b898	ae a9 04	ldx $04a9			ldx 	tokenOffset 				; next slot to write to
.b89b	9d a9 04	sta $04a9,x			sta 	tokenOffset,x 				; write byte out
.b89e	ee a9 04	inc $04a9			inc 	tokenOffset 				; advance slot.
.b8a1	fa		plx				plx
.b8a2	60		rts				rts
.b8a3					TOKCheckCreateVariableRecord:
.b8a3	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b8a5	85 36		sta $36				sta 	0+zTemp0
.b8a7	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b8a9	85 37		sta $37				sta 	1+zTemp0
.b8ab					_CCVSearch:
.b8ab	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b8ad	f0 2c		beq $b8db			beq 	_CCVFail
.b8af	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b8b1	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b8b3	cd 83 04	cmp $0483			cmp 	identHash
.b8b6	d0 16		bne $b8ce			bne 	_CCVNext
.b8b8	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b8ba	ae 80 04	ldx $0480			ldx 	identStart
.b8bd					_CCVCompare:
.b8bd	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b8c0	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b8c2	e8		inx				inx 								; advance pointers
.b8c3	c8		iny				iny
.b8c4	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b8c5	d0 07		bne $b8ce			bne 	_CCVNext  					; didn't match go to next.
.b8c7	90 f4		bcc $b8bd			bcc 	_CCVCompare 				; not finished yet.
.b8c9	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b8cc	f0 41		beq $b90f			beq 	_CCVFound 					; yes, we were successful
.b8ce					_CCVNext:
.b8ce	18		clc				clc
.b8cf	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b8d1	65 36		adc $36				adc 	zTemp0
.b8d3	85 36		sta $36				sta 	zTemp0
.b8d5	90 d4		bcc $b8ab			bcc 	_CCVSearch
.b8d7	e6 37		inc $37				inc 	zTemp0+1
.b8d9	80 d0		bra $b8ab			bra 	_CCVSearch
.b8db					_CCVFail:
.b8db	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b8dd	ad 83 04	lda $0483			lda 	identHash
.b8e0	91 36		sta ($36),y			sta 	(zTemp0),y
.b8e2	c8		iny				iny 								; offset 2 is the type byte
.b8e3	ad 84 04	lda $0484			lda 	identTypeByte
.b8e6	91 36		sta ($36),y			sta 	(zTemp0),y
.b8e8	c8		iny				iny
.b8e9					_CCVData:
.b8e9	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b8eb	91 36		sta ($36),y			sta 	(zTemp0),y
.b8ed	c8		iny				iny
.b8ee	c0 08		cpy #$08			cpy 	#8
.b8f0	90 f7		bcc $b8e9			bcc 	_CCVData
.b8f2	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b8f5					_CCVCopyName:
.b8f5	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b8f8	91 36		sta ($36),y			sta 	(zTemp0),y
.b8fa	e8		inx				inx
.b8fb	c8		iny				iny
.b8fc	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b8ff	d0 f4		bne $b8f5			bne 	_CCVCopyName
.b901	98		tya				tya 								; patch offset
.b902	92 36		sta ($36)			sta 	(zTemp0)
.b904	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b906	91 36		sta ($36),y			sta 	(zTemp0),y
.b908	88		dey				dey
.b909	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b90b	09 80		ora #$80			ora 	#$80
.b90d	91 36		sta ($36),y			sta 	(zTemp0),y
.b90f					_CCVFound:
.b90f	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b911	38		sec				sec
.b912	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b914	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b916	20 97 b8	jsr $b897			jsr 	TOKWriteByte
.b919	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b91b	20 97 b8	jsr $b897			jsr 	TOKWriteByte
.b91e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b91f					SNDCheckChannel:
.b91f	aa		tax				tax
.b920	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b923	d0 38		bne $b95d			bne 	_SNDCCExit
.b925	da		phx				phx 								; save current channel
.b926	8a		txa				txa 								; put in A
.b927	20 a3 b9	jsr $b9a3			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b92a	68		pla				pla 								; channel # in A
.b92b	90 30		bcc $b95d			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b92d	a8		tay				tay 								; Y is the channel #
.b92e	bd ff 06	lda $06ff,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b931	99 fe 07	sta $07fe,y			sta 	SNDPitchLow,y
.b934	bd 00 07	lda $0700,x			lda 	SNDQueue+2,x
.b937	99 02 08	sta $0802,y			sta 	SNDPitchHigh,y
.b93a	bd 01 07	lda $0701,x			lda 	SNDQueue+3,x
.b93d	99 06 08	sta $0806,y			sta 	SNDVolume,y
.b940	bd 02 07	lda $0702,x			lda 	SNDQueue+4,x
.b943	99 0a 08	sta $080a,y			sta 	SNDTimeLeft,y
.b946	bd 03 07	lda $0703,x			lda 	SNDQueue+5,x
.b949	99 0e 08	sta $080e,y			sta 	SNDAdjustLow,y
.b94c	bd 04 07	lda $0704,x			lda 	SNDQueue+6,x
.b94f	99 12 08	sta $0812,y			sta 	SNDAdjustHigh,y
.b952	5a		phy				phy 								; save channel #
.b953	20 bd b9	jsr $b9bd			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b956	ce fd 06	dec $06fd			dec 	SNDLength 					; reduce the queue length.
.b959	68		pla				pla
.b95a	20 5e b9	jsr $b95e			jsr 	SNDUpdateNote 				; update channel A
.b95d					_SNDCCExit:
.b95d	60		rts				rts
.b95e					SNDUpdateNote:
.b95e	aa		tax				tax 								; so we can access records
.b95f	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b960	0a		asl a				asl 	a
.b961	0a		asl a				asl 	a
.b962	0a		asl a				asl 	a
.b963	0a		asl a				asl 	a
.b964	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b967	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; are we silent
.b96a	f0 2e		beq $b99a			beq 	_SNDUNIsSilent
.b96c	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; push channel bits on stack
.b96f	48		pha				pha
.b970	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b973	29 0f		and #$0f			and 	#$0F
.b975	0d fc 06	ora $06fc			ora 	SNDChannelBits 				; set channel bits
.b978	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b97a	20 07 ba	jsr $ba07			jsr 	SNDWritePorts
.b97d	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b980	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b983	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.b986	4e fc 06	lsr $06fc			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b989	6a		ror a				ror 	a
.b98a	4e fc 06	lsr $06fc			lsr 	SNDChannelBits
.b98d	6a		ror a				ror 	a
.b98e	4a		lsr a				lsr 	a 							; put in bits 0-5
.b98f	4a		lsr a				lsr 	a
.b990	20 07 ba	jsr $ba07			jsr 	SNDWritePorts 				; write as rest of pitch register
.b993	68		pla				pla
.b994	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b996	20 07 ba	jsr $ba07			jsr 	SNDWritePorts
.b999	60		rts				rts
.b99a					_SNDUNIsSilent:
.b99a	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; channel bits
.b99d	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b99f	20 07 ba	jsr $ba07			jsr 	SNDWritePorts 				; write to the ports
.b9a2	60		rts				rts
.b9a3					SNDFindNextNoteForA:
.b9a3	ac fd 06	ldy $06fd			ldy 	SNDLength 					; queue size into Y
.b9a6	f0 13		beq $b9bb			beq 	_SNDFNNFail 				; queue empty.
.b9a8	a2 00		ldx #$00			ldx 	#0
.b9aa					_SNDFNNSearch:
.b9aa	dd fe 06	cmp $06fe,x			cmp 	SNDQueue,x 					; does it match the channel
.b9ad	38		sec				sec
.b9ae	f0 0c		beq $b9bc			beq 	_SNDFNNExit 				; if so exit with CS.
.b9b0	e8		inx				inx 								; next queue slot.
.b9b1	e8		inx				inx
.b9b2	e8		inx				inx
.b9b3	e8		inx				inx
.b9b4	e8		inx				inx
.b9b5	e8		inx				inx
.b9b6	e8		inx				inx
.b9b7	e8		inx				inx
.b9b8	88		dey				dey 								; done the whole queue
.b9b9	d0 ef		bne $b9aa			bne 	_SNDFNNSearch 				; no, go back.
.b9bb					_SNDFNNFail:
.b9bb	18		clc				clc
.b9bc					_SNDFNNexit:
.b9bc	60		rts				rts
.b9bd					SNDDeleteXFromQueue:
.b9bd	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b9bf	f0 09		beq $b9ca			beq 	_SNDDXExit
.b9c1	bd 06 07	lda $0706,x			lda 	SNDQueue+8,x
.b9c4	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9c7	e8		inx				inx
.b9c8	80 f3		bra $b9bd			bra 	SNDDeleteXFromQueue
.b9ca					_SNDDXExit:
.b9ca	60		rts				rts
.06fc					SNDChannelBits:
>06fc							.fill 	1
.b9cb					SNDQueueRequest:
.b9cb	86 36		stx $36				stx 	zTemp0						; save queue address
.b9cd	84 37		sty $37				sty 	zTemp0+1
.b9cf	ae fd 06	ldx $06fd			ldx 	SNDLength 					; queue is full, can't take any more.
.b9d2	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b9d4	f0 21		beq $b9f7			beq 	_SNDQRExit
.b9d6	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b9d8	48		pha				pha
.b9d9	8a		txa				txa  								; get offset in queue buffer/
.b9da	0a		asl a				asl 	a
.b9db	0a		asl a				asl 	a
.b9dc	0a		asl a				asl 	a
.b9dd	aa		tax				tax
.b9de	68		pla				pla 								; get back and push again
.b9df	48		pha				pha
.b9e0	9d fe 06	sta $06fe,x			sta 	SNDQueue+0,x 				; save the channel #
.b9e3	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b9e5					_SNDQCopy:
.b9e5	b1 36		lda ($36),y			lda 	(zTemp0),y
.b9e7	e8		inx				inx
.b9e8	c8		iny				iny
.b9e9	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9ec	c0 06		cpy #$06			cpy 	#6
.b9ee	d0 f5		bne $b9e5			bne 	_SNDQCopy
.b9f0	ee fd 06	inc $06fd			inc 	SNDLength 					; bump queue length.
.b9f3	68		pla				pla 								; get channel # back
.b9f4	20 1f b9	jsr $b91f			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.b9f7					_SNDQRExit:
.b9f7	60		rts				rts
.b9f8					SNDSilenceChannel:
.b9f8	aa		tax				tax 								; zero time left.
.b9f9	9e 0a 08	stz $080a,x			stz 	SNDTimeLeft,x
.b9fc	0a		asl a				asl 	a 							; shift into position
.b9fd	0a		asl a				asl 	a
.b9fe	0a		asl a				asl 	a
.b9ff	0a		asl a				asl 	a
.ba00	0a		asl a				asl 	a
.ba01	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.ba03	20 07 ba	jsr $ba07			jsr 	SNDWritePorts
.ba06	60		rts				rts
.ba07					SNDWritePorts:
.ba07	64 01		stz $01				stz 	1
.ba09	8d 00 d6	sta $d600			sta 	$D600
.ba0c	8d 10 d6	sta $d610			sta 	$D610
.ba0f	60		rts				rts
.ba10					SNDCommand:
.ba10	da		phx				phx
.ba11	5a		phy				phy
.ba12	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.ba14	f0 1d		beq $ba33			beq 	_SNDInitialise
.ba16	90 28		bcc $ba40			bcc 	_SNDExit
.ba18	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.ba1a	f0 17		beq $ba33			beq 	_SNDSilence
.ba1c	b0 22		bcs $ba40			bcs 	_SNDExit
.ba1e	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.ba20	b0 09		bcs $ba2b			bcs 	_SNDQueryPlay
.ba22	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.ba24	b0 1a		bcs $ba40			bcs 	_SNDExit
.ba26	20 cb b9	jsr $b9cb			jsr 	SNDQueueRequest
.ba29	80 15		bra $ba40			bra 	_SNDExit
.ba2b					_SNDQueryPlay:
.ba2b	29 03		and #$03			and 	#3 							; get channel #
.ba2d	aa		tax				tax
.ba2e	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.ba31	80 0d		bra $ba40			bra 	_SNDExit
.ba33					_SNDInitialise:
.ba33					_SNDSilence:
.ba33	9c fd 06	stz $06fd			stz 	SNDLength 					; empty the queue.
.ba36	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.ba38					_SNDSilenceLoop:
.ba38	48		pha				pha
.ba39	20 f8 b9	jsr $b9f8			jsr 	SNDSilenceChannel
.ba3c	68		pla				pla
.ba3d	3a		dec a				dec 	a
.ba3e	10 f8		bpl $ba38			bpl 	_SNDSilenceLoop
.ba40					_SNDExit:
.ba40	7a		ply				ply
.ba41	fa		plx				plx
.ba42	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fd					SNDLength:
>06fd							.fill 	1
.06fe					SNDQueue:
>06fe							.fill 	SNDQueueSize * 8
.07fe					SNDPitchLow:
>07fe							.fill 	4
.0802					SNDPitchHigh:
>0802							.fill 	4
.0806					SNDVolume:
>0806							.fill 	4
.080a					SNDTimeLeft:
>080a							.fill 	4
.080e					SNDAdjustLow:
>080e							.fill 	4
.0812					SNDAdjustHigh:
>0812							.fill 	4
.ba43					SNDUpdate:
.ba43	ad 0a 08	lda $080a			lda 	SNDTimeLeft+0 				; look at time remaining
.ba46	f0 05		beq $ba4d			beq 	_SNDUNot0 					; not playing
.ba48	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.ba4a	20 6c ba	jsr $ba6c			jsr 	SNDUpdateChannel 			; update it.
.ba4d					_SNDUNot0:
.ba4d	ad 0b 08	lda $080b			lda 	SNDTimeLeft+1
.ba50	f0 05		beq $ba57			beq 	_SNDUNot1
.ba52	a2 01		ldx #$01			ldx 	#1
.ba54	20 6c ba	jsr $ba6c			jsr 	SNDUpdateChannel
.ba57					_SNDUNot1:
.ba57	ad 0c 08	lda $080c			lda 	SNDTimeLeft+2
.ba5a	f0 05		beq $ba61			beq 	_SNDUNot2
.ba5c	a2 02		ldx #$02			ldx 	#2
.ba5e	20 6c ba	jsr $ba6c			jsr 	SNDUpdateChannel
.ba61					_SNDUNot2:
.ba61	ad 0d 08	lda $080d			lda 	SNDTimeLeft+3
.ba64	f0 05		beq $ba6b			beq 	_SNDUNot3
.ba66	a2 03		ldx #$03			ldx 	#3
.ba68	20 6c ba	jsr $ba6c			jsr 	SNDUpdateChannel
.ba6b					_SNDUNot3:
.ba6b	60		rts				rts
.ba6c					SNDUpdateChannel:
.ba6c	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.ba6e	f0 2c		beq $ba9c			beq 	_SNDUCExit
.ba70	3a		dec a				dec 	a 							; decrement and update timer
.ba71	9d 0a 08	sta $080a,x			sta 	SNDTimeLeft,x
.ba74	f0 1d		beq $ba93			beq 	_SNDUCUpdate 				; if zero, silence channel
.ba76	bd 0e 08	lda $080e,x			lda 	SNDAdjustLow,x 				; adjust ?
.ba79	1d 12 08	ora $0812,x			ora 	SNDAdjustHigh,x
.ba7c	f0 1e		beq $ba9c			beq 	_SNDUCExit 					; if zero carry on at current tone.
.ba7e	18		clc				clc 								; add adjust, forcing into a 10 bit range
.ba7f	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.ba82	7d 0e 08	adc $080e,x			adc 	SNDAdjustLow,x
.ba85	9d fe 07	sta $07fe,x			sta 	SNDPitchLow,x
.ba88	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x
.ba8b	7d 12 08	adc $0812,x			adc 	SNDAdjustHigh,x
.ba8e	29 03		and #$03			and 	#3
.ba90	9d 02 08	sta $0802,x			sta 	SNDPitchHigh,x
.ba93					_SNDUCUpdate:
.ba93	8a		txa				txa 								; which channel.
.ba94	48		pha				pha
.ba95	20 5e b9	jsr $b95e			jsr 	SNDUpdateNote 				; update the current note
.ba98	68		pla				pla
.ba99	20 1f b9	jsr $b91f			jsr 	SNDCheckChannel 			; more to do ?
.ba9c					_SNDUCExit:
.ba9c	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
