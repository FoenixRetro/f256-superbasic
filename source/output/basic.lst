
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Thu Nov 24 21:42:47 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					isInputFlag:
>04a8							.fill 	1
.04a9					tokenOffset:
>04a9							.fill 	1
.04aa					tokenLineNumber:
>04aa							.fill 	2
.04ac					tokenBuffer:
>04ac							.fill 	253
.05a9					lineBuffer:
>05a9							.fill 	MaxLineSize+1
.05fa					numberBuffer:
>05fa							.fill 	34
.061c					decimalBuffer:
>061c							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 19 ab	jsr $ab19			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt display
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 72 8e	jsr $8e72			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 33 ba	jsr $ba33			jsr 	SNDCommand
.8019	20 6a 89	jsr $896a			jsr 	NewProgram 					; erase current program
.801c	20 e5 82	jsr $82e5			jsr 	BackloadProgram
.801f	4c a9 8a	jmp $8aa9			jmp 	CommandRun
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 54 68			.text "Built Thursday 24-Nov-2022. Build 3587."
>804b	75 72 73 64 61 79 20 32 34 2d 4e 6f 76 2d 32 30
>805b	32 32 2e 20 42 75 69 6c 64 20 33 35 38 37 2e

;******  Return to file: ./common/aa.system/00start.asm

>806a	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806d					AssembleGroup1:
.806d	a9 ff		lda #$ff			lda 	#$FF
.806f	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8072	80 02		bra $8076			bra 	AsmGroup12
.8074					AssembleGroup2:
.8074	a9 00		lda #$00			lda 	#$00
.8076					AsmGroup12:
.8076	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.8079	68		pla				pla 								; pop the return address to access the information following.
.807a	fa		plx				plx
.807b	20 04 81	jsr $8104			jsr 	AccessParameters 			; get opcode and save as base
.807e	8d a4 04	sta $04a4			sta 	BaseOpcode
.8081	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8084	d0 08		bne $808e			bne 	_AG12HaveMask
.8086	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8088	20 0c 81	jsr $810c			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.808b	8d a5 04	sta $04a5			sta 	ModeMask
.808e					_AG12HaveMask:
.808e	20 47 82	jsr $8247			jsr 	TypeAndCalculateOperand 	; get zero page type
.8091	da		phx				phx 								; save found address mode
.8092	20 70 81	jsr $8170			jsr 	AssembleModeX
.8095	fa		plx				plx  								; restore address mode
.8096	b0 0b		bcs $80a3			bcs 	_AG12Exit
.8098	20 a4 80	jsr $80a4			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.809b	20 70 81	jsr $8170			jsr 	AssembleModeX
.809e	b0 03		bcs $80a3			bcs 	_AG12Exit
.80a0	4c 66 a0	jmp $a066			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a3					_AG12Exit:
.80a3	60		rts				rts
.80a4					PromoteToAbsolute:
.80a4	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a6	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a8	f0 19		beq $80c3			beq 	_PTADo
.80aa	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80ac	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80ae	f0 13		beq $80c3			beq 	_PTADo
.80b0	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b2	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b4	f0 0d		beq $80c3			beq 	_PTADo
.80b6	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b8	e0 d1		cpx #$d1			cpx 	#AM_IND
.80ba	f0 07		beq $80c3			beq 	_PTADo
.80bc	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80be	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80c0	f0 01		beq $80c3			beq 	_PTADo
.80c2	60		rts				rts
.80c3					_PTADo:
.80c3	aa		tax				tax
.80c4	60		rts				rts
.80c5					AssembleGroup3:
.80c5	68		pla				pla 								; get parameters, which is just the opcode.
.80c6	fa		plx				plx
.80c7	20 04 81	jsr $8104			jsr 	AccessParameters 			; get and output opcode
.80ca	20 1c 81	jsr $811c			jsr 	AssemblerWriteByte
.80cd	20 ab 82	jsr $82ab			jsr 	CalculateOperand 			; get a 16 bit operand
.80d0	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d3	38		sec				sec
.80d4	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d7	48		pha				pha 								; LSB in A
.80d8	ad 10 04	lda $0410			lda 	NSMantissa1
.80db	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80de	aa		tax				tax 								; MSB in X
.80df	68		pla				pla
.80e0	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80e1	69 7f		adc #$7f			adc 	#$7F
.80e3	90 01		bcc $80e6			bcc 	_AG3NoCarry
.80e5	e8		inx				inx
.80e6					_AG3NoCarry:
.80e6	38		sec				sec 								; fix back and write out anyways.
.80e7	e9 80		sbc #$80			sbc 	#$80
.80e9	20 1c 81	jsr $811c			jsr 	AssemblerWriteByte
.80ec	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ee	f0 0a		beq $80fa			beq 	_AG3Exit
.80f0	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f3	29 01		and #$01			and 	#1
.80f5	f0 03		beq $80fa			beq 	_AG3Exit
.80f7	4c 6b a0	jmp $a06b			jmp 	RangeError 					; no, branch is out of range
.80fa					_AG3Exit:
.80fa	60		rts				rts
.80fb					AssembleGroup4:
.80fb	68		pla				pla 								; pop address
.80fc	fa		plx				plx
.80fd	20 04 81	jsr $8104			jsr 	AccessParameters 			; access and get first
.8100	20 1c 81	jsr $811c			jsr 	AssemblerWriteByte 			; output it.
.8103	60		rts				rts
.8104					AccessParameters:
.8104	8d a1 04	sta $04a1			sta 	ParamStart
.8107	8e a2 04	stx $04a2			stx 	ParamStart+1
.810a	a9 01		lda #$01			lda 	#1
.810c					GetParameter:
.810c	5a		phy				phy
.810d	a8		tay				tay
.810e	ad a1 04	lda $04a1			lda 	ParamStart
.8111	85 36		sta $36				sta 	zTemp0
.8113	ad a2 04	lda $04a2			lda 	ParamStart+1
.8116	85 37		sta $37				sta 	zTemp0+1
.8118	b1 36		lda ($36),y			lda 	(zTemp0),y
.811a	7a		ply				ply
.811b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811c					AssemblerWriteByte:
.811c	48		pha			pha
.811d	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.8120	29 02		and #$02		and 	#2
.8122	f0 1b		beq $813f		beq 	_AWBNoPrint
.8124	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8127	20 5a 81	jsr $815a		jsr 	PrintHex
.812a	ad 9e 04	lda $049e		lda		AssemblerAddress
.812d	20 5a 81	jsr $815a		jsr 	PrintHex
.8130	a9 20		lda #$20		lda 	#' '
.8132	20 a5 a8	jsr $a8a5		jsr 	EXTPrintCharacter
.8135	68		pla			pla 									; print byte
.8136	48		pha			pha
.8137	20 5a 81	jsr $815a		jsr 	PrintHex
.813a	a9 0d		lda #$0d		lda 	#13
.813c	20 a5 a8	jsr $a8a5		jsr 	EXTPrintCharacter
.813f					_AWBNoPrint:
.813f	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8142	85 36		sta $36			sta 	zTemp0
.8144	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8147	f0 0e		beq $8157		beq 	_AWBRange
.8149	85 37		sta $37			sta 	zTemp0+1
.814b	68		pla			pla 									; write byte out
.814c	92 36		sta ($36)		sta 	(zTemp0)
.814e	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.8151	d0 03		bne $8156		bne 	_AWBNoCarry
.8153	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8156					_AWBNoCarry:
.8156	60		rts			rts
.8157					_AWBRange:
.8157	4c 6b a0	jmp $a06b		jmp 	RangeError
.815a					PrintHex:
.815a	48		pha				pha
.815b	4a		lsr a				lsr 	a
.815c	4a		lsr a				lsr 	a
.815d	4a		lsr a				lsr 	a
.815e	4a		lsr a				lsr 	a
.815f	20 63 81	jsr $8163			jsr 	_PrintNibble
.8162	68		pla				pla
.8163					_PrintNibble:
.8163	29 0f		and #$0f			and 	#15
.8165	c9 0a		cmp #$0a			cmp 	#10
.8167	90 02		bcc $816b			bcc 	_NoShift
.8169	69 06		adc #$06			adc 	#6
.816b					_NoShift:
.816b	69 30		adc #$30			adc 	#48
.816d	4c a5 a8	jmp $a8a5			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8170					AssembleModeX:
.8170	5a		phy				phy
.8171	ad a3 04	lda $04a3			lda 	IsGroup1
.8174	f0 17		beq $818d			beq 	_AMXGroup2
.8176	8a		txa				txa 							; is it in group # 1
.8177	29 40		and #$40			and 	#AM_ISG1
.8179	f0 50		beq $81cb			beq 	_AMXFail 				; no, give up.
.817b	8a		txa				txa 							; get back.
.817c	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817e	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8180	d0 22		bne $81a4			bne 	_AMXHaveInfo
.8182	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8185	c9 81		cmp #$81			cmp 	#$81
.8187	f0 42		beq $81cb			beq 	_AMXFail
.8189	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.818b	80 17		bra $81a4			bra 	_AMXHaveInfo 			; odd design decision there.
.818d					_AMXGroup2:
.818d	8a		txa				txa 							; is it in group 2 ?
.818e	29 20		and #$20			and 	#AM_ISG2
.8190	f0 39		beq $81cb			beq 	_AMXFail 				; no, give up.
.8192	8a		txa				txa 							; get the offset into Y
.8193	29 1f		and #$1f			and 	#$1F
.8195	4a		lsr a				lsr 	a 						; make it 0-7.
.8196	4a		lsr a				lsr  	a
.8197	a8		tay				tay
.8198	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.819b					_AMXCheckOkay:
.819b	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819c	88		dey				dey
.819d	10 fc		bpl $819b			bpl 	_AMXCheckOkay
.819f	90 2a		bcc $81cb			bcc 	_AMXFail 				; not allowed.
.81a1	8a		txa				txa  							; get mask back
.81a2	29 1f		and #$1f			and 	#$1F
.81a4					_AMXHaveInfo:
.81a4	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a6	10 05		bpl $81ad			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a8	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81ab	d0 1e		bne $81cb			bne 	_AMXFail
.81ad					_AMXAnySize:
.81ad	18		clc				clc 							; add offset to the base opcode
.81ae	6d a4 04	adc $04a4			adc 	BaseOpcode
.81b1					_AMXOutputCode:
.81b1	20 1c 81	jsr $811c			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b4	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b6	f0 10		beq $81c8			beq 	_AMXExit
.81b8	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81bb	20 1c 81	jsr $811c			jsr 	AssemblerWriteByte
.81be	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81c0	30 06		bmi $81c8			bmi 	_AMXExit
.81c2	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c5	20 1c 81	jsr $811c			jsr 	AssemblerWriteByte
.81c8					_AMXExit:
.81c8	7a		ply				ply
.81c9	38		sec				sec
.81ca	60		rts				rts
.81cb					_AMXFail:
.81cb	a0 00		ldy #$00			ldy 	#0
.81cd					_AMXCheckOddities:
.81cd	8a		txa				txa
.81ce	d9 f6 81	cmp $81f6,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d1	d0 16		bne $81e9			bne 	_AMXCONext
.81d3	b9 f4 81	lda $81f4,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d6	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81d9	d0 0e		bne $81e9			bne 	_AMXCONext
.81db	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81dd	10 05		bpl $81e4			bpl 	_AMXCONotZero
.81df	ad 10 04	lda $0410			lda 	NSMantissa1
.81e2	d0 05		bne $81e9			bne 	_AMXCONext
.81e4					_AMXCONotZero:
.81e4	b9 f5 81	lda $81f5,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e7	80 c8		bra $81b1			bra 	_AMXOutputCode 			; and assemble it
.81e9					_AMXCONext:
.81e9	c8		iny				iny
.81ea	c8		iny				iny
.81eb	c8		iny				iny
.81ec	b9 f4 81	lda $81f4,y			lda 	ExtraOpcode+0,y 		; end of table
.81ef	d0 dc		bne $81cd			bne 	_AMXCheckOddities
.81f1					_AMXCOFail:
.81f1	7a		ply				ply
.81f2	18		clc				clc
.81f3	60		rts				rts
.81f4					ExtraOpcode:
>81f4	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f7	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81fa	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fd	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>8200	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8203	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8206	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8209	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820c	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>820f	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8212	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8213					LabelHere:
.8213	c8		iny				iny 								; skip .
.8214	a2 00		ldx #$00			ldx 	#0 							; get a term
.8216	20 a2 98	jsr $98a2			jsr 	EvaluateTerm 				; get a term
.8219	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821c	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821e	d0 24		bne $8244			bne 	_ALType
.8220	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8223	85 36		sta $36				sta 	zTemp0
.8225	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8228	85 37		sta $37				sta 	zTemp0+1
.822a	5a		phy				phy 								; copy address in.
.822b	a0 01		ldy #$01			ldy 	#1
.822d	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.8230	92 36		sta ($36)			sta 	(zTemp0)
.8232	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8235	91 36		sta ($36),y			sta 	(zTemp0),y
.8237	c8		iny				iny
.8238	a9 00		lda #$00			lda 	#0
.823a	91 36		sta ($36),y			sta 	(zTemp0),y
.823c	c8		iny				iny
.823d	91 36		sta ($36),y			sta 	(zTemp0),y
.823f	c8		iny				iny
.8240	91 36		sta ($36),y			sta 	(zTemp0),y
.8242	7a		ply				ply
.8243	60		rts				rts
.8244					_ALType:
.8244	4c 70 a0	jmp $a070			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8247					TypeAndCalculateOperand:
.8247	b1 30		lda ($30),y			lda 	(codePtr),y
.8249	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.824b	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824d	f0 5b		beq $82aa			beq 	_TACOExit
.824f	c9 80		cmp #$80			cmp 	#KWC_EOL
.8251	f0 57		beq $82aa			beq 	_TACOExit
.8253	c8		iny				iny
.8254	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8256	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8258	f0 51		beq $82ab			beq 	CalculateOperand
.825a	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825c	f0 1f		beq $827d			beq 	_TACOIndirect
.825e	88		dey				dey 								; undo get of first character
.825f	20 ab 82	jsr $82ab			jsr 	CalculateOperand 			; get operand
.8262	b1 30		lda ($30),y			lda 	(codePtr),y
.8264	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8266	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8268	d0 40		bne $82aa			bne 	_TACOExit
.826a	c8		iny				iny
.826b	20 b5 82	jsr $82b5			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826e	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.8270	c9 58		cmp #$58			cmp 	#'X'
.8272	f0 36		beq $82aa			beq 	_TACOExit
.8274	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8276	c9 59		cmp #$59			cmp 	#'Y'
.8278	f0 30		beq $82aa			beq 	_TACOExit
.827a					_TACOSyntax:
.827a	4c 66 a0	jmp $a066			jmp 	SyntaxError
.827d					_TACOIndirect:
.827d	20 ab 82	jsr $82ab			jsr 	CalculateOperand 			; get the operand
.8280	b1 30		lda ($30),y			lda 	(codePtr),y
.8282	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8284	f0 17		beq $829d			beq 	_TACOIndX
.8286	20 00 8e	jsr $8e00			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8289	b1 30		lda ($30),y			lda 	(codePtr),y
.828b	a2 d1		ldx #$d1			ldx 	#AM_IND
.828d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.828f	d0 19		bne $82aa			bne 	_TACOExit
.8291	c8		iny				iny
.8292	20 b5 82	jsr $82b5			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8295	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8297	d0 e1		bne $827a			bne 	_TACOSyntax
.8299	a2 d0		ldx #$d0			ldx 	#AM_INDY
.829b	80 0d		bra $82aa			bra 	_TACOExit
.829d					_TACOIndX:
.829d	c8		iny				iny
.829e	20 b5 82	jsr $82b5			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82a1	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a3	d0 d5		bne $827a			bne 	_TACOSyntax
.82a5	20 00 8e	jsr $8e00			jsr 	CheckRightBracket			; check )
.82a8	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82aa					_TACOExit:
.82aa	60		rts				rts
.82ab					CalculateOperand:
.82ab	48		pha				pha
.82ac	da		phx				phx
.82ad	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82af	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger
.82b2	fa		plx				plx
.82b3	68		pla				pla
.82b4	60		rts				rts
.82b5					TACOCheckXY:
.82b5	b1 30		lda ($30),y			lda 	(codePtr),y
.82b7	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82b9	c9 40		cmp #$40			cmp 	#$40
.82bb	d0 21		bne $82de			bne 	_TCXYFail
.82bd	b1 30		lda ($30),y			lda 	(codePtr),y
.82bf	18		clc				clc
.82c0	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c2	85 37		sta $37				sta 	zTemp0+1
.82c4	c8		iny				iny
.82c5	b1 30		lda ($30),y			lda 	(codePtr),y
.82c7	c8		iny				iny
.82c8	85 36		sta $36				sta 	zTemp0
.82ca	5a		phy				phy 								; save position
.82cb	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82cd	b1 36		lda ($36),y			lda 	(zTemp0),y
.82cf	d0 0c		bne $82dd			bne 	_TCXYPopFail
.82d1	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d3	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d5	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d7	f0 08		beq $82e1			beq 	_TCXYFound
.82d9	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82db	f0 04		beq $82e1			beq 	_TCXYFound
.82dd					_TCXYPopFail:
.82dd	7a		ply				ply
.82de					_TCXYFail:
.82de	a9 00		lda #$00			lda 	#0
.82e0	60		rts				rts
.82e1					_TCXYFound:
.82e1	7a		ply				ply 								; restore position
.82e2	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e5					BackloadProgram:
.82e5	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82e7	a9 29		lda #$29			lda 	#_BLLoad & $FF
.82e9	20 72 8e	jsr $8e72			jsr 	PrintStringXA
.82ec	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82ee	8d 2c 06	sta $062c			sta 	0+BackLoadPointer
.82f1	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82f3	8d 2d 06	sta $062d			sta 	1+BackLoadPointer
.82f6					_BPLoop:
.82f6	a2 ff		ldx #$ff			ldx 	#$FF
.82f8	8e fa ff	stx $fffa			stx 	$FFFA 						; fast mode (autorun on emulator only)
.82fb	20 3e 83	jsr $833e			jsr 	BLReadByte 					; read a byte
.82fe	c9 00		cmp #$00			cmp 	#0
.8300	f0 20		beq $8322			beq 	_BPExit 					; if 0 exit
.8302	30 1e		bmi $8322			bmi 	_BPExit 					; if -ve exit
.8304					_BPCopy:
.8304	e8		inx				inx  								; copy byte into the lineBuffer
.8305	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.8308	9e aa 05	stz $05aa,x			stz 	lineBuffer+1,x
.830b	20 3e 83	jsr $833e			jsr 	BLReadByte 					; read next byte
.830e	30 0a		bmi $831a			bmi 	_BPEndLine 					; -ve = EOL
.8310	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8312	d0 02		bne $8316			bne 	_BPNotTab
.8314	a9 20		lda #$20			lda 	#' '
.8316					_BPNotTab:
.8316	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8318	b0 ea		bcs $8304			bcs 	_BPCopy 					; until a control character, should be 13 received.
.831a					_BPEndLine:
.831a	20 c3 b6	jsr $b6c3			jsr 	TokeniseLine 				; tokenise the line.
.831d	20 55 83	jsr $8355			jsr 	EditProgramCode
.8320	80 d4		bra $82f6			bra 	_BPLoop
.8322					_BPExit:
.8322	9c fa ff	stz $fffa			stz 	$FFFA 						; clear fast mode (autorun only)
.8325	20 13 84	jsr $8413			jsr 	ClearCommand 				; clear variables etc.
.8328	60		rts				rts
.8329					_BLLoad:
>8329	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8331	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.833e					BLReadByte:
.833e	ad 2c 06	lda $062c			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8341	85 36		sta $36				sta 	zTemp0
.8343	ad 2d 06	lda $062d			lda 	BackLoadPointer+1
.8346	85 37		sta $37				sta 	zTemp0+1
.8348	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.834a	ee 2c 06	inc $062c			inc 	BackLoadPointer 			; bump pointer
.834d	d0 03		bne $8352			bne 	_BLNoCarry
.834f	ee 2d 06	inc $062d			inc 	BackLoadPointer+1
.8352					_BLNoCarry:
.8352	c9 00		cmp #$00			cmp 	#0
.8354	60		rts				rts
.062c					BackLoadPointer:
>062c							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.8355					EditProgramCode:
.8355	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line.
.8358	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1
.835b	20 89 a6	jsr $a689			jsr 	MemorySearch
.835e	90 05		bcc $8365			bcc 	_EPCNoDelete 				; reached the end don't delete
.8360	d0 03		bne $8365			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8362	20 aa a5	jsr $a5aa			jsr 	MemoryDeleteLine 			; delete the line
.8365					_EPCNoDelete:
.8365	ad ac 04	lda $04ac			lda 	TokenBuffer 				; buffer empty
.8368	c9 80		cmp #$80			cmp 	#KWC_EOL
.836a	f0 0d		beq $8379			beq 	_EPCNoInsert
.836c	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line - it cannot exist.
.836f	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8372	20 89 a6	jsr $a689			jsr 	MemorySearch
.8375	18		clc				clc 								; insert at this point.
.8376	20 e1 a5	jsr $a5e1			jsr 	MemoryInsertLine 			; insert the line
.8379					_EPCNoInsert:
.8379	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.837a					WarmStart:
.837a	a2 ff		ldx #$ff			ldx 	#$FF
.837c	9a		txs				txs
.837d	20 33 aa	jsr $aa33			jsr 	EXTInputLine 				; get line to lineBuffer
.8380	20 c3 b6	jsr $b6c3			jsr 	TokeniseLine 				; tokenise the line
.8383	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; line number ?
.8386	0d ab 04	ora $04ab			ora 	TokenLineNumber+1
.8389	d0 17		bne $83a2			bne 	_WSEditCode 				; if so,edit code.
.838b	9c a9 04	stz $04a9			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.838e	a9 a9		lda #$a9			lda 	#((TokenOffset) & $FF)
.8390	85 30		sta $30				sta 	codePtr
.8392	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8394	85 31		sta $31				sta 	codePtr+1
.8396	ad ac 04	lda $04ac			lda 	TokenBuffer 				; nothing to run
.8399	c9 80		cmp #$80			cmp 	#KWC_EOL
.839b	f0 dd		beq $837a			beq 	WarmStart
.839d	20 bb 8a	jsr $8abb			jsr 	RUNCodePointerLine 			; execute that line.
.83a0	80 d8		bra $837a			bra 	WarmStart
.83a2					_WSEditCode:
.83a2	20 55 83	jsr $8355			jsr 	EditProgramCode
.83a5	20 13 84	jsr $8413			jsr 	ClearCommand
.83a8	80 d0		bra $837a			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.83aa					AssembleCommand:
.83aa	a2 00		ldx #$00			ldx 	#0
.83ac	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger 		; start address
.83af	ad 08 04	lda $0408			lda 	NSMantissa0
.83b2	8d 9e 04	sta $049e			sta 	AssemblerAddress
.83b5	ad 10 04	lda $0410			lda 	NSMantissa1
.83b8	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.83bb	20 08 8e	jsr $8e08			jsr 	CheckComma
.83be	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; options
.83c1	ad 08 04	lda $0408			lda 	NSMantissa0
.83c4	8d a0 04	sta $04a0			sta 	AssemblerControl
.83c7	60		rts				rts
.83c8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83c9					AssertCommand:
.83c9	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83cb	20 28 9e	jsr $9e28			jsr 	EvaluateInteger 			; the assert test
.83ce	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; exit if result is non zero.
.83d1	d0 05		bne $83d8			bne 	_ACExit
.83d3	a9 0a		lda #$0a		lda	#10
.83d5	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.83d8					_ACExit:
.83d8	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83d9					CallCommand:
.83d9	a2 00		ldx #$00			ldx 	#0
.83db	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger
.83de					_CCClear
.83de	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83df	20 dc 9e	jsr $9edc			jsr 	NSMSetZero
.83e2	e0 04		cpx #$04			cpx 	#4
.83e4	d0 f8		bne $83de			bne 	_CCClear
.83e6	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83e8					_CCCParam:
.83e8	b1 30		lda ($30),y			lda 	(codePtr),y
.83ea	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83ec	d0 09		bne $83f7			bne 	_CCCRun6502
.83ee	c8		iny				iny 								; skip comma
.83ef	e8		inx				inx	 								; next level
.83f0	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83f3	e0 03		cpx #$03			cpx 	#3
.83f5	90 f1		bcc $83e8			bcc 	_CCCParam 					; done all 3 ?
.83f7					_CCCRun6502:
.83f7	5a		phy				phy 								; save position
.83f8	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83fb	85 37		sta $37				sta 	zTemp0+1
.83fd	ad 08 04	lda $0408			lda 	NSMantissa0
.8400	85 36		sta $36				sta 	zTemp0
.8402	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.8405	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.8408	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.840b	20 10 84	jsr $8410			jsr 	_CCCZTemp0 					; call zTemp0
.840e	7a		ply				ply 								; restore position and exit
.840f	60		rts				rts
.8410					_CCCZTemp0:
.8410	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.8413					ClearCommand:
.8413	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8415	85 36		sta $36				sta 	0+zTemp0
.8417	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.8419	85 37		sta $37				sta 	1+zTemp0
.841b					_ClearZeroLoop:
.841b	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.841d	f0 24		beq $8443			beq 	_ClearZeroEnd
.841f	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.8421	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8423					_ClearOneVariable:
.8423	91 36		sta ($36),y			sta 	(zTemp0),y
.8425	c8		iny				iny
.8426	c0 08		cpy #$08			cpy 	#8
.8428	d0 f9		bne $8423			bne 	_ClearOneVariable
.842a	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.842c	b1 36		lda ($36),y			lda 	(zTemp0),y
.842e	c9 18		cmp #$18			cmp 	#NSTProcedure
.8430	d0 04		bne $8436			bne 	_ClearNotProcedure
.8432	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8434	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8436					_ClearNotProcedure:
.8436	18		clc				clc 								; go to the next variable
.8437	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.8439	65 36		adc $36				adc 	zTemp0
.843b	85 36		sta $36				sta 	zTemp0
.843d	90 dc		bcc $841b			bcc 	_ClearZeroLoop
.843f	e6 37		inc $37				inc 	zTemp0+1
.8441	80 d8		bra $841b			bra 	_ClearZeroLoop
.8443					_ClearZeroEnd:
.8443	18		clc				clc
.8444	a5 36		lda $36				lda 	zTemp0
.8446	69 01		adc #$01			adc 	#1
.8448	8d 8c 04	sta $048c			sta 	lowMemPtr
.844b	a5 37		lda $37				lda 	zTemp0+1
.844d	69 00		adc #$00			adc 	#0
.844f	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.8452	20 ca a7	jsr $a7ca			jsr 	StackReset
.8455	20 34 a8	jsr $a834			jsr 	StringSystemInitialise
.8458	20 09 8d	jsr $8d09			jsr 	ProcedureScan
.845b	20 6a 8a	jsr $8a6a			jsr 	Command_Restore
.845e	9c 9e 04	stz $049e			stz 	AssemblerAddress
.8461	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.8464	9c a0 04	stz $04a0			stz 	AssemblerControl
.8467	20 a5 9a	jsr $9aa5			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.846a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.846b					ClearScreen:
.846b	5a		phy				phy
.846c	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.846e	20 a5 a8	jsr $a8a5			jsr 	EXTPrintCharacter
.8471	7a		ply				ply
.8472	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8473					Command_Data:
.8473	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.8475	a2 80		ldx #$80			ldx 	#KWC_EOL
.8477	20 5b 8d	jsr $8d5b			jsr 	ScanForward
.847a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.847b					DimCommand:
.847b	b1 30		lda ($30),y			lda 	(codePtr),y
.847d	29 c0		and #$c0			and 	#$C0
.847f	c9 40		cmp #$40			cmp 	#$40
.8481	d0 7a		bne $84fd			bne 	_DCSyntax
.8483	b1 30		lda ($30),y			lda 	(codePtr),y
.8485	18		clc				clc
.8486	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8488	85 3f		sta $3f				sta 	zaTemp+1
.848a	c8		iny				iny
.848b	b1 30		lda ($30),y			lda 	(codePtr),y
.848d	c8		iny				iny
.848e	85 3e		sta $3e				sta 	zaTemp
.8490	5a		phy				phy
.8491	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8493	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8495	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.8497	c9 18		cmp #$18			cmp 	#NSTProcedure
.8499	f0 62		beq $84fd			beq 	_DCSyntax
.849b	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.849d	29 04		and #$04			and 	#NSBIsArray
.849f	f0 64		beq $8505			beq 	_DCType
.84a1	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.84a3	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84a5	d0 59		bne $8500			bne 	_DCRedefine
.84a7	7a		ply				ply
.84a8	20 08 85	jsr $8508			jsr 	_DCGetSize 				; get array size, check it.
.84ab	5a		phy				phy
.84ac	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.84ae	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.84b0	7a		ply				ply 							; is there a second (e.g. ,x)
.84b1	b1 30		lda ($30),y			lda 	(codePtr),y
.84b3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84b5	d0 0a		bne $84c1			bne 	_DCOneDimension
.84b7	c8		iny				iny 							; skip comma
.84b8	20 08 85	jsr $8508			jsr 	_DCGetSize 				; get 2nd array size
.84bb	5a		phy				phy
.84bc	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84be	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84c0	7a		ply				ply
.84c1					_DCOneDimension:
.84c1	5a		phy				phy 							; save position
.84c2	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84c4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84c6	aa		tax				tax
.84c7	c8		iny				iny
.84c8	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ca	e8		inx				inx 							; bump them.
.84cb	1a		inc a				inc 	a
.84cc	20 71 9e	jsr $9e71			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84cf	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84d1	29 e0		and #$e0			and 	#$E0
.84d3	d0 23		bne $84f8			bne 	_DCSize
.84d5	a0 02		ldy #$02			ldy 	#2 						; get base type
.84d7	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84d9	20 16 85	jsr $8516			jsr 	ScaleByBaseType 		; scale by base type
.84dc	a5 36		lda $36				lda 	zTemp0
.84de	a6 37		ldx $37				ldx 	zTemp0+1
.84e0	20 67 9a	jsr $9a67			jsr 	AllocateXABytes 		; allocate memory
.84e3	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84e5	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84e7	c8		iny				iny
.84e8	8a		txa				txa
.84e9	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84eb	7a		ply				ply 							; get position back
.84ec	20 00 8e	jsr $8e00			jsr 	CheckRightBracket 		; check )
.84ef	b1 30		lda ($30),y			lda 	(codePtr),y
.84f1	c8		iny				iny 							; consume in case
.84f2	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84f4	f0 85		beq $847b			beq 	DimCommand
.84f6	88		dey				dey 							; undo consume
.84f7	60		rts				rts
.84f8					_DCSize:
.84f8	a9 16		lda #$16		lda	#22
.84fa	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.84fd					_DCSyntax:
.84fd	4c 66 a0	jmp $a066			jmp 	SyntaxError
.8500					_DCRedefine:
.8500	a9 15		lda #$15		lda	#21
.8502	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.8505					_DCType:
.8505	4c 70 a0	jmp $a070			jmp 	TypeError
.8508					_DCGetSize:
.8508	a2 00		ldx #$00			ldx 	#0 						; get first index.
.850a	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 	; get array dimension
.850d	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.850f	f0 e7		beq $84f8			beq 	_DCSize
.8511	c9 fe		cmp #$fe			cmp 	#254
.8513	f0 e3		beq $84f8			beq 	_DCSize
.8515	60		rts				rts
.8516					ScaleByBaseType:
.8516	29 10		and #$10			and 	#NSBIsString 			; is it string
.8518	d0 19		bne $8533			bne 	_SBBTString
.851a	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.851c	48		pha				pha
.851d	a5 36		lda $36				lda 	zTemp0
.851f	48		pha				pha
.8520	06 36		asl $36				asl 	zTemp0 					; x 2
.8522	26 37		rol $37				rol 	zTemp0+1
.8524	06 36		asl $36				asl 	zTemp0 					; x 4
.8526	26 37		rol $37				rol 	zTemp0+1
.8528	68		pla				pla 							; add stacked value = x 5
.8529	65 36		adc $36				adc 	zTemp0
.852b	85 36		sta $36				sta 	zTemp0
.852d	68		pla				pla
.852e	65 37		adc $37				adc 	zTemp0+1
.8530	85 37		sta $37				sta 	zTemp0+1
.8532	60		rts				rts
.8533					_SBBTString:
.8533	06 36		asl $36				asl 	zTemp0
.8535	26 37		rol $37				rol 	zTemp0+1
.8537	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8538					EndCommand:
.8538	4c 7a 83	jmp $837a			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.853b					ForCommand:
.853b	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.853d	20 65 a7	jsr $a765			jsr 	StackOpen
.8540	a2 00		ldx #$00			ldx 	#0
.8542	20 a2 98	jsr $98a2			jsr 	EvaluateTerm
.8545	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8548	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.854a	d0 49		bne $8595			bne		_FCError
.854c	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.854e	20 10 8e	jsr $8e10			jsr 	CheckNextA
.8551	e8		inx				inx
.8552	20 28 9e	jsr $9e28			jsr 	EvaluateInteger 			; <from> in +1
.8555	b1 30		lda ($30),y			lda 	(codePtr),y
.8557	c8		iny				iny 								; consume it
.8558	48		pha				pha 								; save on stack for later
.8559	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.855b	f0 04		beq $8561			beq 	_FCNoSyntax
.855d	c9 ce		cmp #$ce			cmp 	#KWD_TO
.855f	d0 37		bne $8598			bne 	_FCSyntaxError
.8561					_FCNoSyntax:
.8561	e8		inx				inx
.8562	20 28 9e	jsr $9e28			jsr 	EvaluateInteger
.8565	20 a9 a7	jsr $a7a9			jsr 	STKSaveCodePosition 		; save loop back position
.8568	68		pla				pla 								; restore DOWNTO or TO
.8569	5a		phy				phy 								; save Y on the stack
.856a	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.856c	f0 02		beq $8570			beq 	_FCNotDownTo
.856e	a9 02		lda #$02			lda 	#2
.8570					_FCNotDownTo:
.8570	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8571	a0 10		ldy #$10			ldy 	#16
.8573	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8575	a0 06		ldy #$06			ldy 	#6
.8577	ad 08 04	lda $0408			lda 	NSMantissa0
.857a	91 34		sta ($34),y			sta 	(basicStack),y
.857c	ad 10 04	lda $0410			lda 	NSMantissa1
.857f	c8		iny				iny
.8580	91 34		sta ($34),y			sta 	(basicStack),y
.8582	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8584	a2 01		ldx #$01			ldx 	#1
.8586	20 9b 85	jsr $859b			jsr 	FCIntegerToStack
.8589	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.858b	a2 02		ldx #$02			ldx 	#2
.858d	20 9b 85	jsr $859b			jsr 	FCIntegerToStack
.8590	20 bb 85	jsr $85bb			jsr 	CopyIndexToReference
.8593	7a		ply				ply 								; restore position
.8594	60		rts				rts
.8595					_FCError:
.8595	4c 70 a0	jmp $a070			jmp 	TypeError
.8598					_FCSyntaxError:
.8598	4c 66 a0	jmp $a066			jmp 	SyntaxError
.859b					FCIntegerToStack:
.859b	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.859e	10 03		bpl $85a3			bpl	 	_FCNotNegative
.85a0	20 91 9e	jsr $9e91			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.85a3					_FCNotNegative:
.85a3	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.85a6	91 34		sta ($34),y			sta 	(basicStack),y
.85a8	c8		iny				iny
.85a9	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.85ac	91 34		sta ($34),y			sta 	(basicStack),y
.85ae	c8		iny				iny
.85af	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.85b2	91 34		sta ($34),y			sta 	(basicStack),y
.85b4	c8		iny				iny
.85b5	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.85b8	91 34		sta ($34),y			sta 	(basicStack),y
.85ba	60		rts				rts
.85bb					CopyIndexToReference:
.85bb	5a		phy				phy
.85bc	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85be	38		sec				sec 								; (because we copy from offset 8)
.85bf	b1 34		lda ($34),y			lda 	(basicStack),y
.85c1	e9 08		sbc #$08			sbc 	#8
.85c3	85 36		sta $36				sta 	zTemp0
.85c5	c8		iny				iny
.85c6	b1 34		lda ($34),y			lda 	(basicStack),y
.85c8	e9 00		sbc #$00			sbc 	#0
.85ca	85 37		sta $37				sta 	zTemp0+1
.85cc	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85ce	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85d0	b1 34		lda ($34),y			lda 	(basicStack),y
.85d2	0a		asl a				asl 	a 							; into carry
.85d3	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85d5	90 14		bcc $85eb			bcc 	_CITRNormal
.85d7	38		sec				sec
.85d8					_CITRNegative:
.85d8	a9 00		lda #$00			lda 	#0
.85da	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85dc	91 36		sta ($36),y			sta 	(zTemp0),y
.85de	c8		iny				iny
.85df	ca		dex				dex
.85e0	d0 f6		bne $85d8			bne 	_CITRNegative
.85e2	88		dey				dey 								; look at MSB of mantissa
.85e3	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85e5	09 80		ora #$80			ora 	#$80
.85e7	91 36		sta ($36),y			sta 	(zTemp0),y
.85e9	7a		ply				ply
.85ea	60		rts				rts
.85eb					_CITRNormal:
.85eb	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85ed	91 36		sta ($36),y			sta 	(zTemp0),y
.85ef	c8		iny				iny
.85f0	ca		dex				dex
.85f1	d0 f8		bne $85eb			bne 	_CITRNormal
.85f3	7a		ply				ply 								; and exit.
.85f4	60		rts				rts
.85f5					NextCommand:
.85f5	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85f7	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85f9	20 91 a7	jsr $a791			jsr 	StackCheckFrame
.85fc	5a		phy				phy
.85fd	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85ff	b1 34		lda ($34),y			lda 	(basicStack),y
.8601	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.8603	30 02		bmi $8607			bmi 	_NCStepNeg
.8605	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8607					_NCStepNeg:
.8607	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8609	a2 04		ldx #$04			ldx 	#4 							; count to bump
.860b	18		clc				clc
.860c					_NCBump:
.860c	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.860e	91 34		sta ($34),y			sta 	(basicStack),y
.8610	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8612	c8		iny				iny 								; next byte
.8613	ca		dex				dex 								; do four times
.8614	d0 f6		bne $860c			bne 	_NCBump
.8616	20 bb 85	jsr $85bb			jsr		CopyIndexToReference		; copy it to the reference variable.
.8619	a0 10		ldy #$10			ldy 	#16 						; get step count again
.861b	b1 34		lda ($34),y			lda 	(basicStack),y
.861d	0a		asl a				asl 	a 							; sign bit to carry
.861e	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8620	85 38		sta $38				sta 	zTemp1
.8622	90 02		bcc $8626			bcc 	_NCCompRev 					; use if step is +ve
.8624	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8626					_NCCompRev:
.8626	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8628	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.862a	85 39		sta $39				sta 	zTemp1+1
.862c	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.862e	38		sec				sec
.862f					_NCCompare:
.862f	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8631	b1 34		lda ($34),y			lda 	(basicStack),y
.8633	a4 39		ldy $39				ldy 	zTemp1+1
.8635	f1 34		sbc ($34),y			sbc 	(basicStack),y
.8637	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8639	e6 39		inc $39				inc 	zTemp1+1
.863b	ca		dex				dex 								; do it 4 times.
.863c	d0 f1		bne $862f			bne 	_NCCompare
.863e	50 02		bvc $8642			bvc 	_NCNoOverflow 				; convert to signed comparison
.8640	49 80		eor #$80			eor 	#$80
.8642					_NCNoOverflow:
.8642	7a		ply				ply 								; restore Y position
.8643	0a		asl a				asl 	a 							; is bit 7 set.
.8644	90 04		bcc $864a			bcc 	_NCLoopback 				; if no , >= so loop back
.8646	20 83 a7	jsr $a783			jsr 	StackClose 					; exit the loop
.8649	60		rts				rts
.864a					_NCLoopBack:
.864a	20 ba a7	jsr $a7ba			jsr 	STKLoadCodePosition 		; loop back
.864d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.864e					Command_GOSUB:
.864e	a2 00		ldx #$00			ldx 	#0
.8650	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8653	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8655	20 65 a7	jsr $a765			jsr 	StackOpen 					; create frame
.8658	20 a9 a7	jsr $a7a9			jsr 	STKSaveCodePosition 		; save current position
.865b	4c 71 86	jmp $8671			jmp 	GotoStackX
.865e					Command_RETURN:
.865e	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8660	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8662	20 91 a7	jsr $a791			jsr 	StackCheckFrame
.8665	20 ba a7	jsr $a7ba			jsr 	STKLoadCodePosition 		; restore code position
.8668	20 83 a7	jsr $a783			jsr 	StackClose
.866b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.866c					GotoCommand:
.866c	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.866e	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger
.8671					GotoStackX:
.8671	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8674	48		pha				pha 								; it is slightly inefficient, just in cases.
.8675	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8678	fa		plx				plx
.8679	20 89 a6	jsr $a689			jsr 	MemorySearch 				; transfer to line number AX.
.867c	90 05		bcc $8683			bcc 	_GotoError 					; not found, off end.
.867e	d0 03		bne $8683			bne 	_GotoError 					; not found exactly
.8680	4c b4 8a	jmp $8ab4			jmp 	RunNewLine 					; and go straight to new line code.
.8683					_GotoError:
.8683	a9 0d		lda #$0d		lda	#13
.8685	4c 19 8e	jmp $8e19		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8688					IfCommand:
.8688	a2 00		ldx #$00			ldx 	#0 							; If what.
.868a	20 05 9e	jsr $9e05			jsr 	EvaluateNumber
.868d	b1 30		lda ($30),y			lda 	(codePtr),y
.868f	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8691	d0 0a		bne $869d			bne 	_IFStructured
.8693	c8		iny				iny 								; consume THEN
.8694	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; is it zero
.8697	f0 01		beq $869a			beq 	_IfFail 					; if fail, go to next line
.8699	60		rts				rts 								; if THEN just continue
.869a					_IfFail:
.869a	4c 9c 8a	jmp $8a9c			jmp 	EOLCommand
.869d					_IfStructured:
.869d	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; is it zero
.86a0	d0 07		bne $86a9			bne 	_IfExit 					; if not, then continue normally.
.86a2	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.86a4	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.86a6	20 5b 8d	jsr $8d5b			jsr 	ScanForward 				; and run from there/
.86a9					_IfExit:
.86a9	60		rts				rts
.86aa					ElseCode:
.86aa	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.86ac	aa		tax				tax 								; so just go to the structure exit
.86ad	20 5b 8d	jsr $8d5b			jsr 	ScanForward
.86b0	60		rts				rts
.86b1					EndIf:
.86b1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.86b2					Command_Input:
.86b2	a9 ff		lda #$ff			lda 	#$FF
.86b4	8d a8 04	sta $04a8			sta 	IsInputFlag
.86b7	80 03		bra $86bc			bra 	Command_IP_Main
.86b9					Command_Print:
.86b9	9c a8 04	stz $04a8			stz 	IsInputFlag
.86bc					Command_IP_Main:
.86bc	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86bd					_CPLoop:
.86bd	08		php				php 								; save last action flag
.86be	b1 30		lda ($30),y			lda 	(codePtr),y
.86c0	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86c2	f0 58		beq $871c			beq 	_CPExit
.86c4	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86c6	f0 54		beq $871c			beq 	_CPExit
.86c8	68		pla				pla 								; throw last action flag
.86c9	b1 30		lda ($30),y			lda 	(codePtr),y
.86cb	c8		iny				iny
.86cc	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86ce	f0 49		beq $8719			beq 	_CPContinueWithSameLine
.86d0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86d2	f0 40		beq $8714			beq 	_CPTab
.86d4	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86d6	f0 38		beq $8710			beq 	_CPNewLine
.86d8	88		dey				dey 								; undo the get.
.86d9	20 c6 93	jsr $93c6			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86dc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; read the status
.86df	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86e1	f0 0d		beq $86f0			beq 	_CPIsValue
.86e3	ad a8 04	lda $04a8			lda 	IsInputFlag 				; if print, dereference and print.
.86e6	f0 05		beq $86ed			beq 	_CPIsPrint
.86e8	20 25 87	jsr $8725			jsr 	CIInputValue 				; input a value to the reference
.86eb	80 23		bra $8710			bra 	_CPNewLine
.86ed					_CPIsPrint:
.86ed	20 e6 96	jsr $96e6			jsr 	Dereference
.86f0					_CPIsValue:
.86f0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.86f3	29 10		and #$10			and 	#NSBIsString
.86f5	f0 0b		beq $8702			beq 	_CPNumber
.86f7	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.86fa	ad 08 04	lda $0408			lda 	NSMantissa0
.86fd	20 8e 87	jsr $878e			jsr 	CPPrintStringXA
.8700	80 ba		bra $86bc			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8702					_CPNumber:
.8702	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8704	20 d2 9c	jsr $9cd2			jsr 	ConvertNumberToString 		; convert to string
.8707	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8709	a9 1c		lda #$1c			lda 	#DecimalBuffer & $FF
.870b	20 8e 87	jsr $878e			jsr 	CPPrintStringXA
.870e	80 ac		bra $86bc			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8710					_CPNewLine:
.8710	a9 0d		lda #$0d			lda 	#13
.8712	80 02		bra $8716			bra 	_CPPrintChar
.8714					_CPTab:
.8714	a9 09		lda #$09			lda 	#9 							; print TAB
.8716					_CPPrintChar:
.8716	20 a1 87	jsr $87a1			jsr 	CPPrintVector
.8719					_CPContinueWithSameLine:
.8719	38		sec				sec 								; loop round with carry set, which
.871a	80 a1		bra $86bd			bra 	_CPLoop 					; will inhibit final CR
.871c					_CPExit:
.871c	28		plp				plp 								; get last action flag
.871d	b0 05		bcs $8724			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.871f	a9 0d		lda #$0d			lda 	#13 						; print new line
.8721	20 a1 87	jsr $87a1			jsr 	CPPrintVector
.8724					_CPExit2:
.8724	60		rts				rts
.8725					CIInputValue:
.8725	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8727					_CIInputLine:
.8727	20 a4 87	jsr $87a4			jsr 	CPInputVector 				; get key
.872a	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.872c	f0 1f		beq $874d			beq 	_CIHaveValue
.872e	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8730	f0 11		beq $8743			beq 	_CIBackspace
.8732	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8734	90 f1		bcc $8727			bcc 	_CIInputLine
.8736	e0 50		cpx #$50			cpx 	#80 						; max length
.8738	b0 ed		bcs $8727			bcs 	_CIInputLine
.873a	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.873d	e8		inx				inx
.873e	20 a1 87	jsr $87a1			jsr 	CPPrintVector 				; echo it.
.8741	80 e4		bra $8727			bra 	_CIInputLine
.8743					_CIBackSpace:
.8743	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8745	f0 e0		beq $8727			beq 	_CIInputLine
.8747	20 a1 87	jsr $87a1			jsr 	CPPrintVector 				; echo it.
.874a	ca		dex				dex
.874b	80 da		bra $8727			bra 	_CIInputLine
.874d					_CIHaveValue:
.874d	9e a9 05	stz $05a9,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.8750	ad 00 04	lda $0400			lda 	NSStatus 					; was it a string assignment
.8753	29 10		and #$10			and 	#NSBIsString
.8755	f0 1c		beq $8773			beq 	_CIAssignNumber 			; assign a number
.8757	a2 01		ldx #$01			ldx 	#1
.8759	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.875b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.875e	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8760	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8763	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.8766	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.8769	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.876b	9d 00 04	sta $0400,x			sta  	NSStatus,x
.876e	ca		dex				dex 								; X = 0
.876f	20 e3 87	jsr $87e3			jsr 	AssignVariable
.8772	60		rts				rts
.8773					_CIAssignNumber:
.8773	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.8775	85 36		sta $36				sta 	zTemp0
.8777	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8779	85 37		sta $37				sta 	zTemp0+1
.877b	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.877d	20 54 9c	jsr $9c54			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8780	90 07		bcc $8789			bcc 	_CIIsOkay
.8782	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8784	20 a1 87	jsr $87a1			jsr 	CPPrintVector
.8787	80 9c		bra $8725			bra 	CIInputValue
.8789					_CIIsOkay:
.8789	ca		dex				dex 								; X = 0
.878a	20 e3 87	jsr $87e3			jsr 	AssignVariable
.878d	60		rts				rts
.878e					CPPrintStringXA:
.878e	5a		phy				phy
.878f	86 37		stx $37				stx 	zTemp0+1
.8791	85 36		sta $36				sta 	zTemp0
.8793	a0 00		ldy #$00			ldy 	#0
.8795					_PSXALoop:
.8795	b1 36		lda ($36),y			lda 	(zTemp0),y
.8797	f0 06		beq $879f			beq 	_PSXAExit
.8799	20 a1 87	jsr $87a1			jsr 	CPPrintVector
.879c	c8		iny				iny
.879d	80 f6		bra $8795			bra 	_PSXALoop
.879f					_PSXAExit:
.879f	7a		ply				ply
.87a0	60		rts				rts
.87a1					CPPrintVector:
.87a1	4c a5 a8	jmp $a8a5			jmp 	EXTPrintCharacter
.87a4					CPInputVector:
.87a4	4c 3b ab	jmp $ab3b			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.87a7					LetCommand:
.87a7	a2 00		ldx #$00			ldx 	#0
.87a9	b1 30		lda ($30),y			lda 	(codePtr),y
.87ab	c9 10		cmp #$10			cmp 	#KWD_AT
.87ad	d0 16		bne $87c5			bne 	_LCStandard
.87af	c8		iny				iny 								; skip equal
.87b0	20 a2 98	jsr $98a2			jsr 	EvaluateTerm 				; get a number
.87b3	20 e6 96	jsr $96e6			jsr 	Dereference 				; dereference it
.87b6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.87b9	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.87bb	9d 00 04	sta $0400,x			sta 	NSStatus,x
.87be	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.87c0	d0 10		bne $87d2			bne 	_LCMain
.87c2	4c 70 a0	jmp $a070			jmp 	TypeError 					; was a reference before.
.87c5					_LCStandard:
.87c5	ad b0 93	lda $93b0			lda 	PrecedenceLevel+"*"			; precedence > this
.87c8	20 ca 93	jsr $93ca			jsr 	EvaluateExpressionAtPrecedence
.87cb	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.87ce	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87d0	f0 0e		beq $87e0			beq 	_LetGoProc 					; it's a procedure call.
.87d2					_LCMain:
.87d2	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87d4	20 10 8e	jsr $8e10			jsr 	CheckNextA
.87d7	e8		inx				inx 								; RHS
.87d8	20 fc 9d	jsr $9dfc			jsr 	EvaluateValue
.87db	ca		dex				dex
.87dc	20 e3 87	jsr $87e3			jsr 	AssignVariable
.87df	60		rts				rts
.87e0					_LetGoProc:
.87e0	4c 74 89	jmp $8974			jmp 	CallProcedure
.87e3					AssignVariable:
.87e3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.87e6	48		pha				pha 								; save a copy
.87e7	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.87ea	29 10		and #$10			and 	#NSBIsString
.87ec	d0 0b		bne $87f9			bne 	_ASError
.87ee	68		pla				pla 								; get back
.87ef	29 10		and #$10			and 	#NSBIsString 				; check type
.87f1	d0 03		bne $87f6			bne 	_ASString
.87f3	4c 0e 96	jmp $960e			jmp 	AssignNumber
.87f6					_ASString:
.87f6	4c 7c 96	jmp $967c			jmp 	AssignString
.87f9					_ASError:
.87f9	4c 70 a0	jmp $a070			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87fc					Command_List:
.87fc	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.87ff	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.8802	9c 14 04	stz $0414			stz 	NSMantissa1+4
.8805	a9 ff		lda #$ff			lda 	#$FF
.8807	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.880a	8d 17 04	sta $0417			sta 	NSMantissa1+7
.880d	b1 30		lda ($30),y			lda 	(codePtr),y
.880f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8811	f0 1e		beq $8831			beq 	_CLSecond
.8813	20 92 88	jsr $8892			jsr 	CLIsDigit 					; if not digit, list all
.8816	b0 24		bcs $883c			bcs 	_CLStart
.8818	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.881a	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger
.881d	b1 30		lda ($30),y			lda 	(codePtr),y
.881f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8821	f0 0e		beq $8831			beq 	_CLSecond 					; if so go get it
.8823	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.8826	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.8829	ad 14 04	lda $0414			lda 	NSMantissa1+4
.882c	8d 17 04	sta $0417			sta 	NSMantissa1+7
.882f	80 0b		bra $883c			bra 	_CLStart
.8831					_CLSecond:
.8831	c8		iny				iny 								; consume comma
.8832	20 92 88	jsr $8892			jsr 	CLIsDigit 					; digit found
.8835	b0 05		bcs $883c			bcs 	_CLStart 					; if not, continue listing
.8837	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8839	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger
.883c					_CLStart
.883c	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.883e	85 30		sta $30				sta 	codePtr
.8840	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8842	85 31		sta $31				sta 	codePtr+1
.8844					_CLLoop:
.8844	20 5b ab	jsr $ab5b			jsr 	EXTBreakCheck 				; break check
.8847	f0 33		beq $887c			beq 	_CLExit
.8849	b2 30		lda ($30)			lda 	(codePtr)
.884b	f0 2f		beq $887c			beq 	_CLExit
.884d	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.884f	20 7f 88	jsr $887f			jsr 	CLCompareLineNo
.8852	90 1b		bcc $886f			bcc 	_CLNext
.8854	a2 07		ldx #$07			ldx 	#7
.8856	20 7f 88	jsr $887f			jsr 	CLCompareLineNo
.8859	f0 02		beq $885d			beq 	_CLDoThisOne
.885b	b0 12		bcs $886f			bcs 	_CLNext
.885d					_CLDoThisOne:
.885d	20 be 8d	jsr $8dbe			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8860	20 a5 b4	jsr $b4a5			jsr 	ListConvertLine 			; convert line into token Buffer
.8863	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8865	a9 ac		lda #$ac			lda 	#(tokenBuffer & $FF)
.8867	20 72 8e	jsr $8e72			jsr 	PrintStringXA
.886a	a9 0d		lda #$0d			lda 	#13 						; new line
.886c	20 a5 a8	jsr $a8a5			jsr 	EXTPrintCharacter
.886f					_CLNext:
.886f	18		clc				clc
.8870	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8872	65 30		adc $30				adc 	codePtr
.8874	85 30		sta $30				sta 	codePtr
.8876	90 02		bcc $887a			bcc 	_CREExit
.8878	e6 31		inc $31				inc 	codePtr+1 					; carry
.887a					_CREExit:
.887a	80 c8		bra $8844			bra 	_CLLoop
.887c					_CLExit:
.887c	4c 7a 83	jmp $837a			jmp 	WarmStart
.887f					CLCompareLineNo:
.887f	38		sec				sec
.8880	a0 01		ldy #$01			ldy 	#1
.8882	b1 30		lda ($30),y			lda 	(codePtr),y
.8884	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.8887	85 36		sta $36				sta 	zTemp0
.8889	c8		iny				iny
.888a	b1 30		lda ($30),y			lda 	(codePtr),y
.888c	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.888f	05 36		ora $36				ora 	zTemp0
.8891	60		rts				rts
.8892					CLIsDigit:
.8892	b1 30		lda ($30),y			lda 	(codePtr),y
.8894	c9 30		cmp #$30			cmp 	#"0"
.8896	90 03		bcc $889b			bcc	 	_CLIDExitFalse
.8898	c9 3a		cmp #$3a			cmp 	#"9"+1
.889a	60		rts				rts
.889b					_CLIDExitFalse:
.889b	38		sec				sec
.889c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.889d					Command_LOCAL:
.889d	a2 00		ldx #$00			ldx 	#0 							; at level 0
.889f	20 ab 88	jsr $88ab			jsr 	LocaliseNextTerm 			; convert term to a local.
.88a2	b1 30		lda ($30),y			lda 	(codePtr),y
.88a4	c8		iny				iny
.88a5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.88a7	f0 f4		beq $889d			beq 	Command_LOCAL
.88a9	88		dey				dey 								; unpick pre-get
.88aa	60		rts				rts
.88ab					LocaliseNextTerm:
.88ab	20 a2 98	jsr $98a2			jsr 	EvaluateTerm 				; evaluate the term
.88ae	bd 00 04	lda $0400,x			lda 	NSStatus,x
.88b1	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.88b3	f0 61		beq $8916			beq		_LNTError
.88b5	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.88b8	85 36		sta $36				sta 	zTemp0
.88ba	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.88bd	85 37		sta $37				sta  	zTemp0+1
.88bf	bd 00 04	lda $0400,x			lda 	NSStatus,x
.88c2	29 10		and #$10			and 	#NSBIsString
.88c4	d0 1e		bne $88e4			bne 	_LNTPushString
.88c6	5a		phy				phy
.88c7	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.88c9					_LNTPushNumLoop:
.88c9	b1 36		lda ($36),y			lda		(zTemp0),y
.88cb	20 43 a7	jsr $a743			jsr 	StackPushByte
.88ce	c8		iny				iny
.88cf	c0 05		cpy #$05			cpy 	#5
.88d1	d0 f6		bne $88c9			bne 	_LNTPushNumLoop
.88d3	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.88d5	20 43 a7	jsr $a743			jsr 	StackPushByte
.88d8	a5 37		lda $37				lda 	zTemp0+1
.88da	20 43 a7	jsr $a743			jsr 	StackPushByte
.88dd	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88df	20 43 a7	jsr $a743			jsr 	StackPushByte
.88e2	7a		ply				ply
.88e3	60		rts				rts
.88e4					_LNTPushString:
.88e4	5a		phy				phy
.88e5	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88e7	85 38		sta $38				sta 	zTemp1
.88e9	a0 01		ldy #$01			ldy 	#1
.88eb	b1 36		lda ($36),y			lda 	(zTemp0),y
.88ed	85 39		sta $39				sta 	zTemp1+1
.88ef	a0 00		ldy #$00			ldy 	#0 							; output string
.88f1	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88f3	f0 0a		beq $88ff			beq 	_LNTStringOut
.88f5					_LNTPushStrLoop:
.88f5	b1 38		lda ($38),y			lda 	(zTemp1),y
.88f7	f0 06		beq $88ff			beq 	_LNTStringOut
.88f9	20 43 a7	jsr $a743			jsr 	StackPushByte
.88fc	c8		iny				iny
.88fd	80 f6		bra $88f5			bra 	_LNTPushStrLoop
.88ff					_LNTStringOut:
.88ff	98		tya				tya									; output length
.8900	20 43 a7	jsr $a743			jsr 	StackPushByte
.8903	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.8906	20 43 a7	jsr $a743			jsr 	StackPushByte
.8909	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.890c	20 43 a7	jsr $a743			jsr 	StackPushByte
.890f	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8911	20 43 a7	jsr $a743			jsr 	StackPushByte
.8914	7a		ply				ply
.8915	60		rts				rts
.8916					_LNTError:
.8916	4c 66 a0	jmp $a066			jmp 	SyntaxError
.8919					LocalPopValue:
.8919	20 5c a7	jsr $a75c			jsr 	StackPopByte
.891c	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.891e	d0 17		bne $8937			bne 	_LPVString
.8920	20 5c a7	jsr $a75c			jsr 	StackPopByte 				; address
.8923	85 37		sta $37				sta 	zTemp0+1
.8925	20 5c a7	jsr $a75c			jsr 	StackPopByte
.8928	85 36		sta $36				sta 	zTemp0
.892a	5a		phy				phy
.892b	a0 04		ldy #$04			ldy 	#4 							; copy back
.892d					_LPVNumberCopy:
.892d	20 5c a7	jsr $a75c			jsr 	StackPopByte
.8930	91 36		sta ($36),y			sta 	(zTemp0),y
.8932	88		dey				dey
.8933	10 f8		bpl $892d			bpl 	_LPVNumberCopy
.8935	7a		ply				ply 								; and complete
.8936	60		rts				rts
.8937					_LPVString:
.8937	20 5c a7	jsr $a75c			jsr 	StackPopByte 				; address of record => zTemp0
.893a	85 37		sta $37				sta 	zTemp0+1
.893c	20 5c a7	jsr $a75c			jsr 	StackPopByte
.893f	85 36		sta $36				sta 	zTemp0
.8941	5a		phy				phy
.8942	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8944	85 38		sta $38				sta 	zTemp1
.8946	a0 01		ldy #$01			ldy 	#1
.8948	b1 36		lda ($36),y			lda 	(zTemp0),y
.894a	85 39		sta $39				sta 	zTemp1+1
.894c	20 5c a7	jsr $a75c			jsr 	StackPopByte 				; # to get => y
.894f	a8		tay				tay
.8950	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8952	f0 0e		beq $8962			beq 	_LPVStringCopied
.8954	a9 00		lda #$00			lda 	#0 							; NULL on end
.8956	91 38		sta ($38),y			sta 	(zTemp1),y
.8958					_LPVStringCopy:
.8958	88		dey				dey
.8959	30 07		bmi $8962			bmi 	_LPVStringCopied
.895b	20 5c a7	jsr $a75c			jsr 	StackPopByte
.895e	91 38		sta ($38),y			sta 	(zTemp1),y
.8960	80 f6		bra $8958			bra 	_LPVStringCopy
.8962					_LPVStringCopied:
.8962	fa		plx				plx
.8963	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8964					NewCommand:
.8964	20 6a 89	jsr $896a			jsr 	NewProgram 					; does the actual NEW.
.8967	4c 7a 83	jmp $837a			jmp 	WarmStart 					; and warm starts straight away.
.896a					NewProgram:
.896a	20 67 a6	jsr $a667			jsr 	MemoryNew
.896d	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8970	20 13 84	jsr $8413			jsr 	ClearCommand 				; clear everything.
.8973	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8974					CallProcedure:
.8974	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8976	b1 30		lda ($30),y			lda 	(codePtr),y
.8978	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.897a	f0 0c		beq $8988			beq 	_CPEndParam
.897c					_CPParamLoop:
.897c	20 fc 9d	jsr $9dfc			jsr 	EvaluateValue 				; get parameter onto stack
.897f	e8		inx				inx 								; bump next stack
.8980	b1 30		lda ($30),y			lda 	(codePtr),y
.8982	c8		iny				iny
.8983	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8985	f0 f5		beq $897c			beq 	_CPParamLoop
.8987	88		dey				dey 								; unpick.
.8988					_CPEndParam:
.8988	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.898b	c8		iny				iny									; skip right bracket
.898c	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.898e	20 65 a7	jsr $a765			jsr 	StackOpen
.8991	20 a9 a7	jsr $a7a9			jsr 	STKSaveCodePosition 		; save loop position
.8994	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8997	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8999	ad 10 04	lda $0410			lda 	NSMantissa1
.899c	85 37		sta $37				sta 	zTemp0+1
.899e	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.89a0	b2 36		lda ($36)			lda 	(zTemp0)
.89a2	85 30		sta $30				sta 	safePtr
.89a4	b1 36		lda ($36),y			lda 	(zTemp0),y
.89a6	85 31		sta $31				sta 	safePtr+1
.89a8	c8		iny				iny
.89a9	b1 36		lda ($36),y			lda 	(zTemp0),y
.89ab	85 32		sta $32				sta 	safePtr+2
.89ad	c8		iny				iny
.89ae	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b0	85 33		sta $33				sta 	safePtr+3
.89b2	c8		iny				iny 								; get Y offset -> Y
.89b3	b1 36		lda ($36),y			lda 	(zTemp0),y
.89b5	a8		tay				tay
.89b6	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.89b8	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.89bb	f0 13		beq $89d0			beq 	_ParamExit 					; if so, exit.
.89bd					_ParamExtract:
.89bd	ca		dex				dex 								; put a local term on the level before
.89be	20 ab 88	jsr $88ab			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.89c1	20 e3 87	jsr $87e3			jsr 	AssignVariable 				; assign stacked value to the variable.
.89c4	e8		inx				inx 								; advance to next parameter to do.
.89c5	e8		inx				inx
.89c6	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.89c9	f0 05		beq $89d0			beq 	_ParamExit
.89cb	20 08 8e	jsr $8e08			jsr 	CheckComma 					; comma seperating parameters
.89ce	80 ed		bra $89bd			bra 	_ParamExtract
.89d0					_ParamExit:
.89d0	20 00 8e	jsr $8e00			jsr 	CheckRightBracket 			; check )
.89d3	60		rts				rts 								; and continue from here
.89d4					Command_ENDPROC:
.89d4	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.89d6	a2 14		ldx #$14			ldx 	#ERRID_PROC
.89d8	20 91 a7	jsr $a791			jsr 	StackCheckFrame
.89db	20 ba a7	jsr $a7ba			jsr 	STKLoadCodePosition 		; restore code position
.89de	20 83 a7	jsr $a783			jsr 	StackClose
.89e1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89e2					Command_Read:
.89e2	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89e4	20 a2 98	jsr $98a2			jsr 	EvaluateTerm
.89e7	bd 00 04	lda $0400,x			lda 	NSStatus,x
.89ea	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89ec	f0 4a		beq $8a38			beq 	_CRSyntax 					; check reference (bit 0)
.89ee	20 81 8a	jsr $8a81			jsr 	SwapDataCodePtrs 			; swap code and data
.89f1	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89f4	d0 20		bne $8a16			bne 	_CRContinueData
.89f6					_CRKeepSearching:
.89f6	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89f8	aa		tax				tax
.89f9	20 5b 8d	jsr $8d5b			jsr 	ScanForward
.89fc	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.89fe	f0 16		beq $8a16			beq 	_CRHaveData 				; found it
.8a00	18		clc				clc
.8a01	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a03	65 30		adc $30				adc 	codePtr
.8a05	85 30		sta $30				sta 	codePtr
.8a07	90 02		bcc $8a0b			bcc 	_CREExit
.8a09	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a0b					_CREExit:
.8a0b	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8a0d	b2 30		lda ($30)			lda 	(codePtr)
.8a0f	d0 e5		bne $89f6			bne 	_CRKeepSearching
.8a11	a9 0b		lda #$0b		lda	#11
.8a13	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.8a16					_CRHaveData:
.8a16					_CRContinueData:
.8a16	a2 01		ldx #$01			ldx 	#1
.8a18	20 fc 9d	jsr $9dfc			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a1b	ca		dex				dex
.8a1c	20 e3 87	jsr $87e3			jsr		AssignVariable 				; do the assignment
.8a1f	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.8a22	b1 30		lda ($30),y			lda 	(codePtr),y
.8a24	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a26	d0 04		bne $8a2c			bne 	_CRSwapBack
.8a28	c8		iny				iny 								; consume comma
.8a29	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8a2c					_CRSwapBack:
.8a2c	20 81 8a	jsr $8a81			jsr 	SwapDataCodePtrs			; swap them back.
.8a2f	b1 30		lda ($30),y			lda 	(codePtr),y
.8a31	c8		iny				iny
.8a32	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a34	f0 ac		beq $89e2			beq 	Command_Read 				; if so go round again.
.8a36	88		dey				dey 								; unpick get.
.8a37	60		rts				rts
.8a38					_CRSyntax:
.8a38	4c 66 a0	jmp $a066			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a3b					RemCommand:
.8a3b	b1 30		lda ($30),y			lda 	(codePtr),y
.8a3d	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a3f	d0 06		bne $8a47			bne 	_RMExit
.8a41	c8		iny				iny 								; point to offset
.8a42	98		tya				tya 								; A = offset position
.8a43	38		sec				sec 								; add size +1 hence SEC
.8a44	71 30		adc ($30),y			adc 	(codePtr),y
.8a46	a8		tay				tay 								; make current position.
.8a47					_RMExit:
.8a47	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a48					Command_REPEAT:
.8a48	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a4a	20 65 a7	jsr $a765			jsr 	StackOpen
.8a4d	20 a9 a7	jsr $a7a9			jsr 	STKSaveCodePosition 		; save loop position
.8a50	60		rts				rts
.8a51					Command_UNTIL:
.8a51	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a53	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a55	20 91 a7	jsr $a791			jsr 	StackCheckFrame
.8a58	a2 00		ldx #$00			ldx 	#0
.8a5a	20 05 9e	jsr $9e05			jsr 	EvaluateNumber 				; work out the number
.8a5d	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; check if zero
.8a60	f0 04		beq $8a66			beq 	_CULoopBack 				; if so keep looping
.8a62	20 83 a7	jsr $a783			jsr 	StackClose		 			; return
.8a65	60		rts				rts
.8a66					_CULoopBack:
.8a66	20 ba a7	jsr $a7ba			jsr 	STKLoadCodePosition 		; loop back
.8a69	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a6a					Command_Restore:
.8a6a	20 81 8a	jsr $8a81			jsr 	SwapDataCodePtrs 			; swap code and data
.8a6d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a6f	85 30		sta $30				sta 	codePtr
.8a71	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a73	85 31		sta $31				sta 	codePtr+1
.8a75	20 81 8a	jsr $8a81			jsr 	SwapDataCodePtrs 			; put them back
.8a78	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a7a	8d 9b 04	sta $049b			sta 	dataPointer+4
.8a7d	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.8a80	60		rts				rts
.8a81					SwapDataCodePtrs:
.8a81	da		phx				phx
.8a82	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a84					_SDCPLoop:
.8a84	b5 30		lda $30,x			lda 	safePtr,x
.8a86	48		pha				pha
.8a87	bd 97 04	lda $0497,x			lda 	dataPointer,x
.8a8a	95 30		sta $30,x			sta 	safePtr,x
.8a8c	68		pla				pla
.8a8d	9d 97 04	sta $0497,x			sta 	dataPointer,x
.8a90	ca		dex				dex
.8a91	10 f1		bpl $8a84			bpl 	_SDCPLoop
.8a93	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.8a96	8c 9b 04	sty $049b			sty 	dataPointer+4
.8a99	a8		tay				tay
.8a9a	fa		plx				plx
.8a9b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a9c					EOLCommand:
.8a9c	18		clc				clc
.8a9d	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a9f	65 30		adc $30				adc 	codePtr
.8aa1	85 30		sta $30				sta 	codePtr
.8aa3	90 02		bcc $8aa7			bcc 	_CREExit
.8aa5	e6 31		inc $31				inc 	codePtr+1 					; carry
.8aa7					_CREExit:
.8aa7	80 0b		bra $8ab4			bra 	RunNewLine
.8aa9					CommandRUN:
.8aa9	20 13 84	jsr $8413			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8aac	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8aae	85 30		sta $30				sta 	codePtr
.8ab0	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8ab2	85 31		sta $31				sta 	codePtr+1
.8ab4					RUNNewLine:
.8ab4	b2 30		lda ($30)			lda 	(codePtr)
.8ab6	f0 72		beq $8b2a			beq 	CRNoProgram         		; no then END.
.8ab8	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8aba	9a		txs				txs
.8abb					RUNCodePointerLine:
.8abb	a0 02		ldy #$02			ldy 	#2 							; start of program
.8abd					_CRIncMainLoop:
.8abd	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8ac0	d0 19		bne $8adb			bne 	_CRNoBreakCheck
.8ac2	20 5b ab	jsr $ab5b			jsr 	EXTBreakCheck 				; break check
.8ac5	f0 5e		beq $8b25			beq 	_CRBreak
.8ac7	64 01		stz $01				stz 	1 							; access I/O Page 0
.8ac9	38		sec				sec 								; calculate timer - LastTick
.8aca	ad 59 d6	lda $d659			lda 	$D659
.8acd	aa		tax				tax 								; saving timer in X
.8ace	ed 2e 06	sbc $062e			sbc 	LastTick
.8ad1	c9 03		cmp #$03			cmp 	#3
.8ad3	90 06		bcc $8adb			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8ad5	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.8ad8	20 c0 ba	jsr $bac0			jsr 	TickHandler 				; go do the code.
.8adb					_NoFireTick:
.8adb					_CRNoBreakCheck:
.8adb	c8		iny				iny
.8adc					_CRMainLoop:
.8adc	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8adf	b1 30		lda ($30),y			lda 	(codePtr),y
.8ae1	10 10		bpl $8af3			bpl 	_CRNotKeyword
.8ae3	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8ae5	b0 04		bcs $8aeb			bcs 	_CRIsKeyword
.8ae7	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8ae9	b0 34		bcs $8b1f			bcs		_CRSyntaxError
.8aeb					_CRIsKeyword:
.8aeb	c8		iny				iny 								; consume command
.8aec	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8aed	aa		tax				tax 								; put in X for vector jump
.8aee	20 22 8b	jsr $8b22			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8af1	80 e9		bra $8adc			bra 	_CRMainLoop 				; and loop round
.8af3					_CRNotKeyword:
.8af3	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8af5	f0 c6		beq $8abd			beq 	_CRIncMainLoop
.8af7	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8af9	90 05		bcc $8b00			bcc 	_CRNotVariable
.8afb					_CRGoLet:
.8afb	20 a7 87	jsr $87a7			jsr 	LetCommand
.8afe	80 dc		bra $8adc			bra 	_CRMainLoop
.8b00					_CRNotVariable:
.8b00	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8b02	f0 f7		beq $8afb			beq 	_CRGoLet
.8b04	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8b06	f0 f3		beq $8afb			beq 	_CRGoLet
.8b08	c9 21		cmp #$21			cmp 	#KWD_PLING
.8b0a	f0 ef		beq $8afb			beq 	_CRGoLet
.8b0c	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8b0e	f0 09		beq $8b19			beq 	_CRGoRem
.8b10	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8b12	d0 0b		bne $8b1f			bne 	_CRSyntaxError
.8b14	20 13 82	jsr $8213			jsr 	LabelHere
.8b17	80 c3		bra $8adc			bra 	_CRMainLoop
.8b19					_CRGoRem:
.8b19	c8		iny				iny
.8b1a	20 3b 8a	jsr $8a3b			jsr 	RemCommand
.8b1d	80 bd		bra $8adc			bra 	_CRMainLoop
.8b1f					_CRSyntaxError:
.8b1f	4c 66 a0	jmp $a066			jmp 	SyntaxError
.8b22					_CRCallVector0:
.8b22	7c c0 8b	jmp ($8bc0,x)			jmp 	(VectorSet0,x)
.8b25					_CRBreak:
.8b25	a9 01		lda #$01		lda	#1
.8b27	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.8b2a					CRNoProgram:
.8b2a	4c 38 85	jmp $8538			jmp 	EndCommand
.8b2d					Shift1Command:
.8b2d	b1 30		lda ($30),y			lda 	(codePtr),y
.8b2f	c8		iny				iny
.8b30	0a		asl a				asl 	a
.8b31	aa		tax				tax
.8b32	7c 5e 8c	jmp ($8c5e,x)			jmp 	(VectorSet1,x)
.8b35					Shift2Command:
.8b35	b1 30		lda ($30),y			lda 	(codePtr),y
.8b37	c8		iny				iny
.8b38	0a		asl a				asl 	a
.8b39	aa		tax				tax
.8b3a	7c 7c 8c	jmp ($8c7c,x)			jmp 	(VectorSet2,x)
.8b3d					Unused1:
.8b3d					Unused2:
.8b3d					Unused3:
.8b3d					Unused4:
.8b3d	4c 66 a0	jmp $a066			jmp 	SyntaxError
>8b40							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b40					VectorSetPunc:
>8b40	06 91					.word	ShiftLeft                        ; $00 <<
>8b42	bd 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8b44	b3 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8b46	66 a0					.word	SyntaxError                      ; $03 !!3
>8b48	66 a0					.word	SyntaxError                      ; $04 ><
>8b4a	c7 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b4c	09 91					.word	ShiftRight                       ; $06 >>
>8b4e	66 a0					.word	SyntaxError                      ; $07 !!7
>8b50	66 a0					.word	SyntaxError                      ; $08 !!8
>8b52	66 a0					.word	SyntaxError                      ; $09 !!9
>8b54	66 a0					.word	SyntaxError                      ; $0a !!10
>8b56	66 a0					.word	SyntaxError                      ; $0b !!11
>8b58	66 a0					.word	SyntaxError                      ; $0c !!12
>8b5a	66 a0					.word	SyntaxError                      ; $0d !!13
>8b5c	66 a0					.word	SyntaxError                      ; $0e !!14
>8b5e	66 a0					.word	SyntaxError                      ; $0f !!15
>8b60	66 a0					.word	SyntaxError                      ; $10 @
>8b62	66 a0					.word	SyntaxError                      ; $11 !!17
>8b64	66 a0					.word	SyntaxError                      ; $12 !!18
>8b66	66 a0					.word	SyntaxError                      ; $13 [
>8b68	8a 8f					.word	IntegerDivide                    ; $14 \
>8b6a	66 a0					.word	SyntaxError                      ; $15 ]
>8b6c	97 92					.word	EorInteger                       ; $16 ^
>8b6e	66 a0					.word	SyntaxError                      ; $17 _
>8b70	66 a0					.word	SyntaxError                      ; $18 `
>8b72	66 a0					.word	SyntaxError                      ; $19 !!25
>8b74	66 a0					.word	SyntaxError                      ; $1a !!26
>8b76	66 a0					.word	SyntaxError                      ; $1b {
>8b78	51 92					.word	OraInteger                       ; $1c |
>8b7a	66 a0					.word	SyntaxError                      ; $1d }
>8b7c	66 a0					.word	SyntaxError                      ; $1e ~
>8b7e	66 a0					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b80	66 a0					.word	SyntaxError                      ; $20
>8b82	dd 92					.word	WordIndirect                     ; $21 !
>8b84	66 a0					.word	SyntaxError                      ; $22 "
>8b86	66 a0					.word	SyntaxError                      ; $23 #
>8b88	66 a0					.word	SyntaxError                      ; $24 $
>8b8a	d7 8f					.word	IntegerModulus                   ; $25 %
>8b8c	0b 92					.word	AndInteger                       ; $26 &
>8b8e	66 a0					.word	SyntaxError                      ; $27 '
>8b90	66 a0					.word	SyntaxError                      ; $28 (
>8b92	66 a0					.word	SyntaxError                      ; $29 )
>8b94	4c 90					.word	MulInteger                       ; $2a *
>8b96	9d 91					.word	AddInteger                       ; $2b +
>8b98	66 a0					.word	SyntaxError                      ; $2c ,
>8b9a	e0 91					.word	SubInteger                       ; $2d -
>8b9c	66 a0					.word	SyntaxError                      ; $2e .
>8b9e	c8 94					.word	FDivideCommand                   ; $2f /
>8ba0	66 a0					.word	SyntaxError                      ; $30 0
>8ba2	66 a0					.word	SyntaxError                      ; $31 1
>8ba4	66 a0					.word	SyntaxError                      ; $32 2
>8ba6	66 a0					.word	SyntaxError                      ; $33 3
>8ba8	66 a0					.word	SyntaxError                      ; $34 4
>8baa	66 a0					.word	SyntaxError                      ; $35 5
>8bac	66 a0					.word	SyntaxError                      ; $36 6
>8bae	66 a0					.word	SyntaxError                      ; $37 7
>8bb0	66 a0					.word	SyntaxError                      ; $38 8
>8bb2	66 a0					.word	SyntaxError                      ; $39 9
>8bb4	66 a0					.word	SyntaxError                      ; $3a :
>8bb6	66 a0					.word	SyntaxError                      ; $3b ;
>8bb8	9f 8e					.word	BinaryCompareLess                ; $3c <
>8bba	95 8e					.word	BinaryCompareEqual               ; $3d =
>8bbc	a9 8e					.word	BinaryCompareGreater             ; $3e >
>8bbe	04 93					.word	ByteIndirect                     ; $3f ?
.8bc0					VectorSet0:
>8bc0	9c 8a					.word	EOLCommand                       ; $80 !0:EOF
>8bc2	2d 8b					.word	Shift1Command                    ; $81 !1:SH1
>8bc4	35 8b					.word	Shift2Command                    ; $82 !2:SH2
>8bc6	38 9a					.word	AbsUnary                         ; $83 ABS(
>8bc8	48 9a					.word	AllocUnary                       ; $84 ALLOC(
>8bca	b8 9a					.word	AscUnary                         ; $85 ASC(
>8bcc	83 9c					.word	ChrUnary                         ; $86 CHR$(
>8bce	d8 a4					.word	UnaryEvent                       ; $87 EVENT(
>8bd0	91 8e					.word	UnaryFalse                       ; $88 FALSE
>8bd2	c5 9a					.word	FracUnary                        ; $89 FRAC(
>8bd4	6e a4					.word	UnaryHit                         ; $8a HIT(
>8bd6	db 9a					.word	IntUnary                         ; $8b INT(
>8bd8	42 9c					.word	IsValUnary                       ; $8c ISVAL(
>8bda	68 a5					.word	UnaryJoyB                        ; $8d JOYB(
>8bdc	41 a5					.word	UnaryJoyX                        ; $8e JOYX(
>8bde	44 a5					.word	UnaryJoyY                        ; $8f JOYY(
>8be0	5d 9d					.word	Unary_Left                       ; $90 LEFT$(
>8be2	ed 9a					.word	LenUnary                         ; $91 LEN(
>8be4	0b 9b					.word	Unary_Max                        ; $92 MAX(
>8be6	87 9d					.word	Unary_Mid                        ; $93 MID$(
>8be8	07 9b					.word	Unary_Min                        ; $94 MIN(
>8bea	62 9b					.word	Unary_Not                        ; $95 NOT(
>8bec	bc a6					.word	UnaryPlaying                     ; $96 PLAYING(
>8bee	78 9b					.word	Unary_Random                     ; $97 RANDOM(
>8bf0	6d 9d					.word	Unary_Right                      ; $98 RIGHT$(
>8bf2	97 9b					.word	Unary_Rnd                        ; $99 RND(
>8bf4	18 9c					.word	SgnUnary                         ; $9a SGN(
>8bf6	95 9c					.word	SpcUnary                         ; $9b SPC(
>8bf8	b0 9c					.word	Unary_Str                        ; $9c STR$(
>8bfa	8e a5					.word	UnaryTimer                       ; $9d TIMER(
>8bfc	85 8e					.word	UnaryTrue                        ; $9e TRUE
>8bfe	38 9c					.word	ValUnary                         ; $9f VAL(
>8c00	3b 85					.word	ForCommand                       ; $a0 FOR
>8c02	88 86					.word	IfCommand                        ; $a1 IF
>8c04	3d 8b					.word	Unused1                          ; $a2 PROC
>8c06	48 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8c08	d1 8d					.word	Command_WHILE                    ; $a4 WHILE
>8c0a	b1 86					.word	EndIf                            ; $a5 ENDIF
>8c0c	d4 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8c0e	f5 85					.word	NextCommand                      ; $a7 NEXT
>8c10	3d 8b					.word	Unused4                          ; $a8 THEN
>8c12	51 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8c14	f2 8d					.word	Command_WEND                     ; $aa WEND
>8c16	66 a0					.word	SyntaxError                      ; $ab BY
>8c18	d9 83					.word	CallCommand                      ; $ac CALL
>8c1a	10 a2					.word	CircleCommand                    ; $ad CIRCLE
>8c1c	13 84					.word	ClearCommand                     ; $ae CLEAR
>8c1e	6b 84					.word	ClearScreen                      ; $af CLS
>8c20	66 a0					.word	SyntaxError                      ; $b0 COLOR
>8c22	66 a0					.word	SyntaxError                      ; $b1 COLOUR
>8c24	73 84					.word	Command_Data                     ; $b2 DATA
>8c26	7b 84					.word	DimCommand                       ; $b3 DIM
>8c28	3d 8b					.word	Unused3                          ; $b4 DOWNTO
>8c2a	aa 86					.word	ElseCode                         ; $b5 ELSE
>8c2c	66 a0					.word	SyntaxError                      ; $b6 FROM
>8c2e	3c a4					.word	GfxCommand                       ; $b7 GFX
>8c30	4e 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c32	6c 86					.word	GotoCommand                      ; $b9 GOTO
>8c34	66 a0					.word	SyntaxError                      ; $ba HERE
>8c36	3a a2					.word	ImageCommand                     ; $bb IMAGE
>8c38	b2 86					.word	Command_Input                    ; $bc INPUT
>8c3a	a7 87					.word	LetCommand                       ; $bd LET
>8c3c	8f a2					.word	LineCommand                      ; $be LINE
>8c3e	9d 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c40	66 a0					.word	SyntaxError                      ; $c0 OFF
>8c42	66 a0					.word	SyntaxError                      ; $c1 ON
>8c44	66 a0					.word	SyntaxError                      ; $c2 OUTLINE
>8c46	94 a4					.word	PaletteCommand                   ; $c3 PALETTE
>8c48	88 a2					.word	PlotCommand                      ; $c4 PLOT
>8c4a	b9 86					.word	Command_Print                    ; $c5 PRINT
>8c4c	e2 89					.word	Command_Read                     ; $c6 READ
>8c4e	0c a2					.word	RectangleCommand                 ; $c7 RECT
>8c50	3b 8a					.word	RemCommand                       ; $c8 REM
>8c52	5e 86					.word	Command_RETURN                   ; $c9 RETURN
>8c54	66 a0					.word	SyntaxError                      ; $ca SOLID
>8c56	d8 a6					.word	SoundCommand                     ; $cb SOUND
>8c58	1b a2					.word	SpriteCommand                    ; $cc SPRITE
>8c5a	57 a2					.word	TextCommand                      ; $cd TEXT
>8c5c	3d 8b					.word	Unused2                          ; $ce TO
.8c5e					VectorSet1:
>8c5e	66 a0					.word	SyntaxError                      ; $80 !0:EOF
>8c60	66 a0					.word	SyntaxError                      ; $81 !1:SH1
>8c62	66 a0					.word	SyntaxError                      ; $82 !2:SH2
>8c64	aa 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c66	c9 83					.word	AssertCommand                    ; $84 ASSERT
>8c68	dc a3					.word	BitmapCtrl                       ; $85 BITMAP
>8c6a	38 85					.word	EndCommand                       ; $86 END
>8c6c	85 a5					.word	GoCommand                        ; $87 GO
>8c6e	fc 87					.word	Command_List                     ; $88 LIST
>8c70	7c a5					.word	LoadCommand                      ; $89 LOAD
>8c72	64 89					.word	NewCommand                       ; $8a NEW
>8c74	6a 8a					.word	Command_Restore                  ; $8b RESTORE
>8c76	a9 8a					.word	CommandRUN                       ; $8c RUN
>8c78	21 a4					.word	SpritesCtrl                      ; $8d SPRITES
>8c7a	04 8d					.word	StopCommand                      ; $8e STOP
.8c7c					VectorSet2:
>8c7c	66 a0					.word	SyntaxError                      ; $80 !0:EOF
>8c7e	66 a0					.word	SyntaxError                      ; $81 !1:SH1
>8c80	66 a0					.word	SyntaxError                      ; $82 !2:SH2
>8c82	25 9f					.word	Assemble_adc                     ; $83 ADC
>8c84	1d 9f					.word	Assemble_and                     ; $84 AND
>8c86	39 9f					.word	Assemble_asl                     ; $85 ASL
>8c88	a3 9f					.word	Assemble_bcc                     ; $86 BCC
>8c8a	a7 9f					.word	Assemble_bcs                     ; $87 BCS
>8c8c	af 9f					.word	Assemble_beq                     ; $88 BEQ
>8c8e	66 9f					.word	Assemble_bit                     ; $89 BIT
>8c90	97 9f					.word	Assemble_bmi                     ; $8a BMI
>8c92	ab 9f					.word	Assemble_bne                     ; $8b BNE
>8c94	93 9f					.word	Assemble_bpl                     ; $8c BPL
>8c96	b3 9f					.word	Assemble_bra                     ; $8d BRA
>8c98	b7 9f					.word	Assemble_brk                     ; $8e BRK
>8c9a	9b 9f					.word	Assemble_bvc                     ; $8f BVC
>8c9c	9f 9f					.word	Assemble_bvs                     ; $90 BVS
>8c9e	bf 9f					.word	Assemble_clc                     ; $91 CLC
>8ca0	13 a0					.word	Assemble_cld                     ; $92 CLD
>8ca2	d3 9f					.word	Assemble_cli                     ; $93 CLI
>8ca4	03 a0					.word	Assemble_clv                     ; $94 CLV
>8ca6	31 9f					.word	Assemble_cmp                     ; $95 CMP
>8ca8	7a 9f					.word	Assemble_cpx                     ; $96 CPX
>8caa	75 9f					.word	Assemble_cpy                     ; $97 CPY
>8cac	57 9f					.word	Assemble_dec                     ; $98 DEC
>8cae	0f a0					.word	Assemble_dex                     ; $99 DEX
>8cb0	eb 9f					.word	Assemble_dey                     ; $9a DEY
>8cb2	21 9f					.word	Assemble_eor                     ; $9b EOR
>8cb4	5c 9f					.word	Assemble_inc                     ; $9c INC
>8cb6	1f a0					.word	Assemble_inx                     ; $9d INX
>8cb8	0b a0					.word	Assemble_iny                     ; $9e INY
>8cba	8e 9f					.word	Assemble_jmp                     ; $9f JMP
>8cbc	89 9f					.word	Assemble_jsr                     ; $a0 JSR
>8cbe	2d 9f					.word	Assemble_lda                     ; $a1 LDA
>8cc0	52 9f					.word	Assemble_ldx                     ; $a2 LDX
>8cc2	70 9f					.word	Assemble_ldy                     ; $a3 LDY
>8cc4	43 9f					.word	Assemble_lsr                     ; $a4 LSR
>8cc6	23 a0					.word	Assemble_nop                     ; $a5 NOP
>8cc8	19 9f					.word	Assemble_ora                     ; $a6 ORA
>8cca	cf 9f					.word	Assemble_pha                     ; $a7 PHA
>8ccc	bb 9f					.word	Assemble_php                     ; $a8 PHP
>8cce	17 a0					.word	Assemble_phx                     ; $a9 PHX
>8cd0	d7 9f					.word	Assemble_phy                     ; $aa PHY
>8cd2	df 9f					.word	Assemble_pla                     ; $ab PLA
>8cd4	c3 9f					.word	Assemble_plp                     ; $ac PLP
>8cd6	2b a0					.word	Assemble_plx                     ; $ad PLX
>8cd8	e7 9f					.word	Assemble_ply                     ; $ae PLY
>8cda	3e 9f					.word	Assemble_rol                     ; $af ROL
>8cdc	48 9f					.word	Assemble_ror                     ; $b0 ROR
>8cde	cb 9f					.word	Assemble_rti                     ; $b1 RTI
>8ce0	db 9f					.word	Assemble_rts                     ; $b2 RTS
>8ce2	35 9f					.word	Assemble_sbc                     ; $b3 SBC
>8ce4	c7 9f					.word	Assemble_sec                     ; $b4 SEC
>8ce6	27 a0					.word	Assemble_sed                     ; $b5 SED
>8ce8	e3 9f					.word	Assemble_sei                     ; $b6 SEI
>8cea	29 9f					.word	Assemble_sta                     ; $b7 STA
>8cec	1b a0					.word	Assemble_stp                     ; $b8 STP
>8cee	4d 9f					.word	Assemble_stx                     ; $b9 STX
>8cf0	6b 9f					.word	Assemble_sty                     ; $ba STY
>8cf2	61 9f					.word	Assemble_stz                     ; $bb STZ
>8cf4	ff 9f					.word	Assemble_tax                     ; $bc TAX
>8cf6	fb 9f					.word	Assemble_tay                     ; $bd TAY
>8cf8	84 9f					.word	Assemble_trb                     ; $be TRB
>8cfa	7f 9f					.word	Assemble_tsb                     ; $bf TSB
>8cfc	07 a0					.word	Assemble_tsx                     ; $c0 TSX
>8cfe	ef 9f					.word	Assemble_txa                     ; $c1 TXA
>8d00	f7 9f					.word	Assemble_txs                     ; $c2 TXS
>8d02	f3 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8d04					StopCommand:
.8d04	a9 08		lda #$08		lda	#8
.8d06	4c 19 8e	jmp $8e19		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8d09					ProcedureScan:
.8d09	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8d0b	85 30		sta $30				sta 	codePtr
.8d0d	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8d0f	85 31		sta $31				sta 	codePtr+1
.8d11					_PSLoop:
.8d11	b2 30		lda ($30)			lda 	(codePtr)
.8d13	f0 42		beq $8d57			beq 	_PSExit
.8d15	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8d17	b1 30		lda ($30),y			lda 	(codePtr),y
.8d19	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8d1b	d0 2d		bne $8d4a			bne 	_PSNext
.8d1d	c8		iny				iny 								; get the address of the record to zTemp0 and
.8d1e	b1 30		lda ($30),y			lda 	(codePtr),y
.8d20	29 c0		and #$c0			and 	#$C0
.8d22	c9 40		cmp #$40			cmp 	#$40
.8d24	d0 32		bne $8d58			bne 	_PSSyntax
.8d26	b1 30		lda ($30),y			lda 	(codePtr),y
.8d28	18		clc				clc
.8d29	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d2b	85 37		sta $37				sta 	zTemp0+1
.8d2d	c8		iny				iny 								; LSB
.8d2e	b1 30		lda ($30),y			lda 	(codePtr),y
.8d30	85 36		sta $36				sta 	zTemp0
.8d32	c8		iny				iny 								; character after variable call.
.8d33	98		tya				tya 								; save Y offset at +7
.8d34	a0 07		ldy #$07			ldy 	#7
.8d36	91 36		sta ($36),y			sta 	(zTemp0),y
.8d38	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d3a	a0 02		ldy #$02			ldy 	#2
.8d3c	91 36		sta ($36),y			sta 	(zTemp0),y
.8d3e	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d40					_PSCopy:
.8d40	b5 30		lda $30,x			lda 	safePtr,x
.8d42	c8		iny				iny
.8d43	91 36		sta ($36),y			sta 	(zTemp0),y
.8d45	e8		inx				inx
.8d46	e0 04		cpx #$04			cpx 	#4
.8d48	d0 f6		bne $8d40			bne 	_PSCopy
.8d4a					_PSNext:
.8d4a	18		clc				clc
.8d4b	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d4d	65 30		adc $30				adc 	codePtr
.8d4f	85 30		sta $30				sta 	codePtr
.8d51	90 02		bcc $8d55			bcc 	_CREExit
.8d53	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d55					_CREExit:
.8d55	80 ba		bra $8d11			bra 	_PSLoop
.8d57					_PSExit:
.8d57	60		rts				rts
.8d58					_PSSyntax:
.8d58	4c 66 a0	jmp $a066			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d5b					ScanForward:
.8d5b	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d5d	86 37		stx $37				stx 	zTemp0+1
.8d5f	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d61					_ScanLoop:
.8d61	b1 30		lda ($30),y			lda 	(codePtr),y
.8d63	c8		iny				iny
.8d64	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d66	d0 0e		bne $8d76			bne 	_ScanGoNext
.8d68	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d6a	f0 04		beq $8d70			beq 	_ScanMatch
.8d6c	c5 37		cmp $37				cmp 	zTemp0+1
.8d6e	d0 06		bne $8d76			bne 	_ScanGoNext
.8d70					_ScanMatch:
.8d70	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d72	d0 01		bne $8d75			bne 	_ScanNotEndEOL
.8d74	88		dey				dey
.8d75					_ScanNotEndEOL:
.8d75	60		rts				rts
.8d76					_ScanGoNext:
.8d76	20 7b 8d	jsr $8d7b			jsr  	ScanForwardOne
.8d79	80 e6		bra $8d61			bra 	_ScanLoop
.8d7b					ScanForwardOne:
.8d7b	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d7d	90 3e		bcc $8dbd			bcc 	_SFWExit
.8d7f	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d81	90 18		bcc $8d9b			bcc 	_ScanSkipOne
.8d83	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d85	b0 2f		bcs $8db6			bcs 	_ScanSkipData
.8d87	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d89	90 32		bcc $8dbd			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d8b	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d8d	b0 2e		bcs $8dbd			bcs 	_SFWExit
.8d8f	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d91	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d93	b0 28		bcs $8dbd			bcs 	_SFWExit
.8d95	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d97	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8d99	80 22		bra $8dbd			bra 	_SFWExit
.8d9b					_ScanSkipOne:
.8d9b	c8		iny				iny 								; consume the extra one.
.8d9c	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8d9e	d0 1d		bne $8dbd			bne 	_SFWExit
.8da0	18		clc				clc
.8da1	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8da3	65 30		adc $30				adc 	codePtr
.8da5	85 30		sta $30				sta 	codePtr
.8da7	90 02		bcc $8dab			bcc 	_CREExit
.8da9	e6 31		inc $31				inc 	codePtr+1 					; carry
.8dab					_CREExit:
.8dab	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8dad	b2 30		lda ($30)			lda 	(codePtr)
.8daf	d0 0c		bne $8dbd			bne 	_SFWExit 					; if not zero, more to scan
.8db1	a9 13		lda #$13		lda	#19
.8db3	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.8db6					_ScanSkipData:
.8db6	88		dey				dey 								; point at data token
.8db7	c8		iny				iny 								; point to offset
.8db8	98		tya				tya 								; A = offset position
.8db9	38		sec				sec 								; add size +1 hence SEC
.8dba	71 30		adc ($30),y			adc 	(codePtr),y
.8dbc	a8		tay				tay 								; make current position.
.8dbd					_SFWExit:
.8dbd	60		rts				rts
.8dbe					ScanGetCurrentLineStep:
.8dbe	64 38		stz $38				stz 	zTemp1
.8dc0	a0 03		ldy #$03			ldy 	#3
.8dc2					_SGCLSLoop:
.8dc2	b1 30		lda ($30),y			lda 	(codePtr),y
.8dc4	c8		iny				iny
.8dc5	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8dc7	f0 05		beq $8dce			beq 	_SGCLSExit
.8dc9	20 7b 8d	jsr $8d7b			jsr 	ScanForwardOne
.8dcc	80 f4		bra $8dc2			bra 	_SGCLSLoop
.8dce					_SGCLSExit:
.8dce	a5 38		lda $38				lda 	zTemp1
.8dd0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8dd1					Command_WHILE:
.8dd1	5a		phy				phy 								; save position of the test
.8dd2	a2 00		ldx #$00			ldx 	#0
.8dd4	20 05 9e	jsr $9e05			jsr 	EvaluateNumber 				; work out the number
.8dd7	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; check if zero
.8dda	f0 0e		beq $8dea			beq 	_WHExitLoop 				; if so exit the loop
.8ddc	98		tya				tya 								; position *after* test.
.8ddd	7a		ply				ply 								; restore position before test, at WHILE
.8dde	88		dey				dey
.8ddf	48		pha				pha 								; push after test on the stack
.8de0	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8de2	20 65 a7	jsr $a765			jsr 	StackOpen
.8de5	20 a9 a7	jsr $a7a9			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8de8	7a		ply				ply 								; restore the position *after* the test
.8de9	60		rts				rts
.8dea					_WHExitLoop:
.8dea	68		pla				pla 								; throw post loop position
.8deb	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8ded	aa		tax				tax
.8dee	20 5b 8d	jsr $8d5b			jsr 	ScanForward
.8df1	60		rts				rts
.8df2					Command_WEND:
.8df2	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8df4	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8df6	20 91 a7	jsr $a791			jsr 	StackCheckFrame
.8df9	20 ba a7	jsr $a7ba			jsr 	STKLoadCodePosition 		; loop back
.8dfc	20 83 a7	jsr $a783			jsr 	StackClose		 			; erase the frame
.8dff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8e00					CheckRightBracket:
.8e00	b1 30		lda ($30),y			lda 	(codePtr),y
.8e02	c8		iny				iny
.8e03	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8e05	d0 0f		bne $8e16			bne 	CNAFail
.8e07	60		rts				rts
.8e08					CheckComma:
.8e08	b1 30		lda ($30),y			lda 	(codePtr),y
.8e0a	c8		iny				iny
.8e0b	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8e0d	d0 07		bne $8e16			bne 	CNAFail
.8e0f	60		rts				rts
.8e10					CheckNextA:
.8e10	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8e12	d0 02		bne $8e16			bne 	CNAFail
.8e14	c8		iny				iny 								; skip character
.8e15	60		rts				rts 								; and exit
.8e16					CNAFail:
.8e16	4c 66 a0	jmp $a066			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8e19					ErrorHandler:
.8e19	a8		tay				tay 								; find the error text
.8e1a	f0 49		beq $8e65			beq 	_EHEnd
.8e1c	a2 00		ldx #$00			ldx 	#0
.8e1e	a9 7f		lda #$7f			lda 	#((ErrorText) & $FF)
.8e20	85 36		sta $36				sta 	0+zTemp0
.8e22	a9 a0		lda #$a0			lda 	#((ErrorText) >> 8)
.8e24	85 37		sta $37				sta 	1+zTemp0
.8e26					_EHFind:
.8e26	88		dey				dey 								; found the error text ?
.8e27	f0 0e		beq $8e37			beq 	_EHFound
.8e29					_EHFindZero:
.8e29	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e2b	e6 36		inc $36				inc 	zTemp0
.8e2d	d0 02		bne $8e31			bne 	_EHFNoCarry
.8e2f	e6 37		inc $37				inc 	zTemp0+1
.8e31					_EHFNoCarry:
.8e31	c9 00		cmp #$00			cmp 	#0
.8e33	d0 f4		bne $8e29			bne 	_EHFindZero
.8e35	80 ef		bra $8e26			bra 	_EHFind
.8e37					_EHFound:
.8e37	a5 36		lda $36				lda 	zTemp0 						; print message
.8e39	a6 37		ldx $37				ldx 	zTemp0+1
.8e3b	20 72 8e	jsr $8e72			jsr 	PrintStringXA
.8e3e	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8e40	b1 30		lda ($30),y			lda 	(codePtr),y
.8e42	d0 05		bne $8e49			bne 	_EHAtMsg
.8e44	c8		iny				iny
.8e45	b1 30		lda ($30),y			lda 	(codePtr),y
.8e47	f0 17		beq $8e60			beq 	_EHCREnd
.8e49					_EHAtMsg:
.8e49	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8e4b	a9 68		lda #$68			lda 	#_AtMsg & $FF
.8e4d	20 72 8e	jsr $8e72			jsr 	PrintStringXA
.8e50	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8e52	b1 30		lda ($30),y			lda 	(codePtr),y
.8e54	48		pha				pha
.8e55	c8		iny				iny
.8e56	b1 30		lda ($30),y			lda 	(codePtr),y
.8e58	aa		tax				tax
.8e59	68		pla				pla
.8e5a	20 2b 93	jsr $932b			jsr 	LCLConvertInt16 				; convert XA to string
.8e5d	20 72 8e	jsr $8e72			jsr 	PrintStringXA 				; and print it.
.8e60					_EHCREnd:
.8e60	a9 0d		lda #$0d			lda 	#13 						; new line
.8e62	20 a5 a8	jsr $a8a5			jsr 	EXTPrintCharacter
.8e65					_EHEnd:
.8e65	4c 7a 83	jmp $837a			jmp 	WarmStart
>8e68	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8e70	20 00
.8e72					PrintStringXA:
.8e72	5a		phy				phy
.8e73	86 37		stx $37				stx 	zTemp0+1
.8e75	85 36		sta $36				sta 	zTemp0
.8e77	a0 00		ldy #$00			ldy 	#0
.8e79					_PSXALoop:
.8e79	b1 36		lda ($36),y			lda 	(zTemp0),y
.8e7b	f0 06		beq $8e83			beq 	_PSXAExit
.8e7d	20 a5 a8	jsr $a8a5			jsr 	EXTPrintCharacter
.8e80	c8		iny				iny
.8e81	80 f6		bra $8e79			bra 	_PSXALoop
.8e83					_PSXAExit:
.8e83	7a		ply				ply
.8e84	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8e85					UnaryTrue:
.8e85	fa		plx				plx
.8e86					ReturnTrue:
.8e86	a9 01		lda #$01			lda 	#1  						; set to 1
.8e88	20 de 9e	jsr $9ede			jsr 	NSMSetByte
.8e8b	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8e8d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8e90	60		rts				rts
.8e91					UnaryFalse:
.8e91	fa		plx				plx
.8e92					ReturnFalse:
.8e92	4c dc 9e	jmp $9edc			jmp 	NSMSetZero 					; set it all to zero
.8e95					BinaryCompareEqual:
.8e95	fa		plx				plx
.8e96	20 d1 8e	jsr $8ed1			jsr 	CompareBaseCode
.8e99	c9 00		cmp #$00			cmp 	#0
.8e9b	f0 e9		beq $8e86			beq 	ReturnTrue
.8e9d	80 f3		bra $8e92			bra 	ReturnFalse
.8e9f					BinaryCompareLess:
.8e9f	fa		plx				plx
.8ea0	20 d1 8e	jsr $8ed1			jsr 	CompareBaseCode
.8ea3	c9 ff		cmp #$ff			cmp 	#$FF
.8ea5	f0 df		beq $8e86			beq 	ReturnTrue
.8ea7	80 e9		bra $8e92			bra 	ReturnFalse
.8ea9					BinaryCompareGreater:
.8ea9	fa		plx				plx
.8eaa	20 d1 8e	jsr $8ed1			jsr 	CompareBaseCode
.8ead	c9 01		cmp #$01			cmp 	#1
.8eaf	f0 d5		beq $8e86			beq 	ReturnTrue
.8eb1	80 df		bra $8e92			bra 	ReturnFalse
.8eb3					BinaryCompareNotEqual:
.8eb3	fa		plx				plx
.8eb4	20 d1 8e	jsr $8ed1			jsr 	CompareBaseCode
.8eb7	c9 00		cmp #$00			cmp 	#0
.8eb9	d0 cb		bne $8e86			bne 	ReturnTrue
.8ebb	80 d5		bra $8e92			bra 	ReturnFalse
.8ebd					BinaryCompareLessEqual:
.8ebd	fa		plx				plx
.8ebe	20 d1 8e	jsr $8ed1			jsr 	CompareBaseCode
.8ec1	c9 01		cmp #$01			cmp 	#1
.8ec3	d0 c1		bne $8e86			bne 	ReturnTrue
.8ec5	80 cb		bra $8e92			bra 	ReturnFalse
.8ec7					BinaryCompareGreaterEqual:
.8ec7	fa		plx				plx
.8ec8	20 d1 8e	jsr $8ed1			jsr 	CompareBaseCode
.8ecb	c9 ff		cmp #$ff			cmp 	#$FF
.8ecd	d0 b7		bne $8e86			bne 	ReturnTrue
.8ecf	80 c1		bra $8e92			bra 	ReturnFalse
.8ed1					CompareBaseCode:
.8ed1	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; make both values if references.
.8ed4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8ed7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8eda	29 10		and #$10			and 	#NSTString
.8edc	d0 40		bne $8f1e			bne 	_CBCString
.8ede	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8ee1	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8ee4	d0 3b		bne $8f21			bne 	_CBCFloat
.8ee6	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8ee9	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8eec	29 08		and #$08			and 	#NSTFloat
.8eee	d0 31		bne $8f21			bne 	_CBCFloat
.8ef0	20 24 8f	jsr $8f24			jsr 	CompareFixMinusZero
.8ef3	e8		inx				inx
.8ef4	20 24 8f	jsr $8f24			jsr 	CompareFixMinusZero
.8ef7	ca		dex				dex
.8ef8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8efb	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8efe	10 0b		bpl $8f0b			bpl 	_CDCSameSign
.8f00	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8f03	30 16		bmi $8f1b			bmi 	_CBCLess 					; return $FF
.8f05					_CBCGreater:
.8f05	a9 01		lda #$01			lda 	#1
.8f07	60		rts				rts
.8f08					_CBCEqual:
.8f08	a9 00		lda #$00			lda 	#0
.8f0a	60		rts				rts
.8f0b					_CDCSameSign:
.8f0b	20 77 91	jsr $9177			jsr 	SubTopTwoStack 				; unsigned subtract
.8f0e	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; or the mantissa together
.8f11	f0 f5		beq $8f08			beq 	_CBCEqual 					; -0 == 0
.8f13	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8f16	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8f19	10 ea		bpl $8f05			bpl 	_CBCGreater
.8f1b					_CBCLess:
.8f1b	a9 ff		lda #$ff			lda 	#$FF
.8f1d	60		rts				rts
.8f1e					_CBCString:
.8f1e	4c cd 90	jmp $90cd			jmp 	CompareStrings
.8f21					_CBCFloat:
.8f21	4c ae 94	jmp $94ae			jmp 	CompareFloat
.8f24					CompareFixMinusZero:
.8f24	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero
.8f27	d0 03		bne $8f2c			bne 	_CFXMZNotZero
.8f29	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8f2c					_CFXMZNotZero:
.8f2c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f2d					StringConcat:
.8f2d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8f30	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8f33	29 18		and #$18			and 	#NSBTypeMask
.8f35	c9 10		cmp #$10			cmp 	#NSTString
.8f37	d0 4e		bne $8f87			bne		_SCType
.8f39	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f3b	e8		inx				inx
.8f3c	20 5a 8f	jsr $8f5a			jsr 	_SCSetupZ0 					; setup for second
.8f3f	20 65 8f	jsr $8f65			jsr 	_SCLengthZ0 				; length for second
.8f42	ca		dex				dex
.8f43	20 5a 8f	jsr $8f5a			jsr 	_SCSetupZ0 					; setup for first
.8f46	20 65 8f	jsr $8f65			jsr 	_SCLengthZ0 				; length for first
.8f49	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8f4b	20 58 a8	jsr $a858			jsr 	StringTempAllocate
.8f4e	20 78 8f	jsr $8f78			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8f51	e8		inx				inx
.8f52	20 5a 8f	jsr $8f5a			jsr 	_SCSetupZ0 					; copy second out
.8f55	20 78 8f	jsr $8f78			jsr 	_SCCopy
.8f58	ca		dex				dex
.8f59	60		rts				rts
.8f5a					_SCSetupZ0:
.8f5a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8f5d	85 36		sta $36				sta 	zTemp0
.8f5f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8f62	85 37		sta $37				sta 	zTemp0+1
.8f64	60		rts				rts
.8f65					_SCLengthZ0:
.8f65	5a		phy				phy
.8f66	a0 00		ldy #$00			ldy 	#0
.8f68					_SCLenLoop:
.8f68	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f6a	f0 0a		beq $8f76			beq 	_SCLExit
.8f6c	c8		iny				iny
.8f6d	e6 38		inc $38				inc 	zTemp1
.8f6f	10 f7		bpl $8f68			bpl		_SCLenLoop
.8f71	a9 09		lda #$09		lda	#9
.8f73	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.8f76					_SCLExit:
.8f76	7a		ply				ply
.8f77	60		rts				rts
.8f78					_SCCopy:
.8f78	5a		phy				phy
.8f79	a0 00		ldy #$00			ldy 	#0
.8f7b					_SCCopyLoop:
.8f7b	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f7d	f0 06		beq $8f85			beq 	_SCCExit
.8f7f	20 96 a8	jsr $a896			jsr 	StringTempWrite
.8f82	c8		iny				iny
.8f83	80 f6		bra $8f7b			bra 	_SCCopyLoop
.8f85					_SCCExit:
.8f85	7a		ply				ply
.8f86	60		rts				rts
.8f87					_SCType:
.8f87	4c 70 a0	jmp $a070			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8f8a					IntegerDivide:
.8f8a	fa		plx				plx
.8f8b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f8e	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f91	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f92	0a		asl a				asl 	a
.8f93	10 05		bpl $8f9a			bpl 	_NotRef
.8f95	48		pha				pha
.8f96	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f99	68		pla				pla
.8f9a					_NotRef:
.8f9a	0a		asl a				asl 	a
.8f9b	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f9d	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fa0	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fa3	f0 03		beq $8fa8			beq 	_IntegerCode 				; if clear, then we have two integers
.8fa5	4c 70 a0	jmp $a070			jmp 	TypeError 					; anything else, type mismatch.
.8fa8					_IntegerCode:
.8fa8	20 ca 8f	jsr $8fca			jsr 	CheckDivideZero 			; do div zero check
.8fab	20 02 90	jsr $9002			jsr 	Int32Divide 				; do the division
.8fae	20 bf 90	jsr $90bf			jsr 	CalculateSign 				; calculate result sign
.8fb1					NSMCopyPlusTwoToZero:
.8fb1	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8fb4	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8fb7	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8fba	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8fbd	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8fc0	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8fc3	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8fc6	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8fc9	60		rts				rts
.8fca					CheckDivideZero:
.8fca	e8		inx				inx
.8fcb	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero
.8fce	f0 02		beq $8fd2			beq 	_CDVError
.8fd0	ca		dex				dex
.8fd1	60		rts				rts
.8fd2					_CDVError:
.8fd2	a9 03		lda #$03		lda	#3
.8fd4	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.8fd7					IntegerModulus:
.8fd7	fa		plx				plx
.8fd8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8fdb	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8fde	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fdf	0a		asl a				asl 	a
.8fe0	10 05		bpl $8fe7			bpl 	_NotRef
.8fe2	48		pha				pha
.8fe3	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fe6	68		pla				pla
.8fe7					_NotRef:
.8fe7	0a		asl a				asl 	a
.8fe8	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8fea	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fed	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8ff0	f0 03		beq $8ff5			beq 	_IntegerCode 				; if clear, then we have two integers
.8ff2	4c 70 a0	jmp $a070			jmp 	TypeError 					; anything else, type mismatch.
.8ff5					_IntegerCode:
.8ff5					IntegerModulusNoCheck:
.8ff5	20 ca 8f	jsr $8fca			jsr 	CheckDivideZero 			; do div zero check
.8ff8	20 02 90	jsr $9002			jsr 	Int32Divide 				; do the division
.8ffb	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8ffe	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.9001	60		rts				rts
.9002					Int32Divide:
.9002	48		pha				pha 								; save AXY
.9003	5a		phy				phy
.9004	20 b3 9e	jsr $9eb3			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9007	20 d8 9e	jsr $9ed8			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.900a	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.900c					_I32DivideLoop:
.900c	e8		inx				inx
.900d	e8		inx				inx
.900e	20 f1 9e	jsr $9ef1			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.9011	ca		dex				dex
.9012	ca		dex				dex
.9013	20 f2 9e	jsr $9ef2			jsr 	NSMRotateLeft
.9016	20 42 90	jsr $9042			jsr 	DivideCheckSubtract 		; check if subtract possible
.9019	90 03		bcc $901e			bcc 	_I32DivideNoCarryIn
.901b	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.901e					_I32DivideNoCarryIn:
.901e	88		dey				dey 								; loop round till division completed.
.901f	d0 eb		bne $900c			bne 	_I32DivideLoop
.9021	7a		ply				ply 								; restore AXY and exit
.9022	68		pla				pla
.9023	60		rts				rts
.9024					Int32ShiftDivide:
.9024	48		pha				pha 								; save AY
.9025	5a		phy				phy
.9026	e8		inx				inx 								; clear S[X+2]
.9027	e8		inx				inx
.9028	20 dc 9e	jsr $9edc			jsr 	NSMSetZero
.902b	ca		dex				dex
.902c	ca		dex				dex
.902d	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.902f					_I32SDLoop:
.902f	20 42 90	jsr $9042			jsr 	DivideCheckSubtract 		; check if subtract possible
.9032	e8		inx				inx
.9033	e8		inx				inx
.9034	20 f2 9e	jsr $9ef2			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.9037	ca		dex				dex
.9038	ca		dex				dex
.9039	20 f2 9e	jsr $9ef2			jsr 	NSMRotateLeft
.903c	88		dey				dey 	 							; do 31 times
.903d	d0 f0		bne $902f			bne 	_I32SDLoop
.903f	7a		ply				ply 								; restore AY and exit
.9040	68		pla				pla
.9041	60		rts				rts
.9042					DivideCheckSubtract:
.9042	20 77 91	jsr $9177			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9045	b0 04		bcs $904b			bcs 	_DCSExit 					; if carry set, then could do, exit
.9047	20 51 91	jsr $9151			jsr 	AddTopTwoStack 				; add it back in
.904a	18		clc				clc 								; and return False
.904b					_DCSExit:
.904b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.904c					MulInteger:
.904c	fa		plx				plx
.904d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9050	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9053	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9054	0a		asl a				asl 	a
.9055	10 05		bpl $905c			bpl 	_NotRef
.9057	48		pha				pha
.9058	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.905b	68		pla				pla
.905c					_NotRef:
.905c	0a		asl a				asl 	a 							; put MSB of type into A:7
.905d	30 0b		bmi $906a			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.905f	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9062	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9065	f0 06		beq $906d			beq 	_IntegerCode 				; if clear, then we have two integers
.9067	4c 85 95	jmp $9585			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.906a					_StringData:
.906a	4c 7a a0	jmp $a07a			jmp 	NotDoneError							; at least one string - don't know both are strings.
.906d					_IntegerCode:
.906d	20 7a 90	jsr $907a			jsr 	MultiplyShort
.9070	c9 00		cmp #$00			cmp 	#0
.9072	f0 05		beq $9079			beq 	_MIExit
.9074	a9 04		lda #$04		lda	#4
.9076	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.9079					_MIExit:
.9079	60		rts				rts
.907a					MultiplyShort:
.907a	5a		phy				phy 								; save Y
.907b	20 b3 9e	jsr $9eb3			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.907e	20 d8 9e	jsr $9ed8			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9081	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9083					_I32MLoop:
.9083	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9086	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.9089	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.908c	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.908f	f0 28		beq $90b9			beq 	_I32MExit 					; exit if zero
.9091	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9094	29 01		and #$01			and 	#1
.9096	f0 0e		beq $90a6			beq 	_I32MNoAdd
.9098	20 51 91	jsr $9151			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.909b	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.909e	10 06		bpl $90a6			bpl 	_I32MNoAdd
.90a0					_I32ShiftRight:
.90a0	20 ff 9e	jsr $9eff			jsr 	NSMShiftRight 				; shift S[X] right
.90a3	c8		iny				iny 								; increment shift count
.90a4	80 0a		bra $90b0			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.90a6					_I32MNoAdd:
.90a6	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.90a9	70 f5		bvs $90a0			bvs 	_I32ShiftRight 				; instead.
.90ab	e8		inx				inx
.90ac	20 f1 9e	jsr $9ef1			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.90af	ca		dex				dex
.90b0					_I32MShiftUpper:
.90b0	e8		inx				inx 								; shift S[X+2] right
.90b1	e8		inx				inx
.90b2	20 ff 9e	jsr $9eff			jsr 	NSMShiftRight
.90b5	ca		dex				dex
.90b6	ca		dex				dex
.90b7	80 ca		bra $9083			bra 	_I32MLoop 					; try again.
.90b9					_I32MExit:
.90b9	20 bf 90	jsr $90bf			jsr 	CalculateSign
.90bc	98		tya				tya 								; shift in A
.90bd	7a		ply				ply 								; restore Y and exit
.90be	60		rts				rts
.90bf					CalculateSign:
.90bf	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.90c2	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.90c5	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.90c8	0a		asl a				asl 	a 							; shift bit 7 into carry
.90c9	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.90cc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.90cd					CompareStrings:
.90cd	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.90d0	3d 01 04	and $0401,x			and 	NSStatus+1,x
.90d3	29 10		and #$10			and 	#NSBIsString
.90d5	f0 2c		beq $9103			beq 	_CSTypeError
.90d7	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.90da	85 36		sta $36				sta 	zTemp0
.90dc	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.90df	85 37		sta $37				sta 	zTemp0+1
.90e1	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.90e4	85 38		sta $38				sta 	zTemp1
.90e6	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.90e9	85 39		sta $39				sta 	zTemp1+1
.90eb	5a		phy				phy 								; save Y so we can access strings
.90ec	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.90ee					_CSLoop:
.90ee	c8		iny				iny
.90ef	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.90f1	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.90f3	d0 06		bne $90fb			bne 	_CSDifferent
.90f5	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.90f7	d0 f5		bne $90ee			bne 	_CSLoop 					; still comparing
.90f9					_CSExit:
.90f9	7a		ply				ply 								; reached end, return zero in A from EOS
.90fa	60		rts				rts
.90fb					_CSDifferent:
.90fb	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.90fd	90 fa		bcc $90f9			bcc		_CSExit
.90ff	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.9101	80 f6		bra $90f9			bra 	_CSExit
.9103					_CSTypeError:
.9103	4c 70 a0	jmp $a070			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.9106					ShiftLeft:
.9106	38		sec				sec
.9107	80 01		bra $910a			bra 	ShiftMain
.9109					ShiftRight:
.9109	18		clc				clc
.910a					ShiftMain:
.910a	fa		plx				plx 								; restore X
.910b	08		php				php 								; save direction
.910c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.910f	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9112	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9113	0a		asl a				asl 	a
.9114	10 05		bpl $911b			bpl 	_NotRef
.9116	48		pha				pha
.9117	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.911a	68		pla				pla
.911b					_NotRef:
.911b	0a		asl a				asl 	a
.911c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.911e	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9121	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9124	f0 03		beq $9129			beq 	_IntegerCode 				; if clear, then we have two integers
.9126	4c 70 a0	jmp $a070			jmp 	TypeError 					; anything else, type mismatch.
.9129					_IntegerCode:
.9129	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.912c	29 e0		and #$e0			and 	#$E0
.912e	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.9131	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.9134	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9137	d0 13		bne $914c			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9139					_SMLoop:
.9139	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.913c	30 11		bmi $914f			bmi 	_SMExit 					; exit if done.
.913e	28		plp				plp 								; restore direcition setting
.913f	08		php				php
.9140	90 05		bcc $9147			bcc 	_SMRight
.9142	20 f1 9e	jsr $9ef1			jsr 	NSMShiftLeft 				; shift left if CS
.9145	80 f2		bra $9139			bra 	_SMLoop
.9147					_SMRight:
.9147	20 ff 9e	jsr $9eff			jsr 	NSMShiftRight 				; shift right if CC
.914a	80 ed		bra $9139			bra 	_SMLoop
.914c					_SMExit0:
.914c	20 dc 9e	jsr $9edc			jsr 	NSMSetZero 					; return zero.
.914f					_SMExit:
.914f	28		plp				plp 								; throw direction
.9150	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9151					AddTopTwoStack:
.9151	18		clc				clc
.9152	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9155	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.9158	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.915b	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.915e	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.9161	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9164	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9167	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.916a	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.916d	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9170	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.9173	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9176	60		rts				rts
.9177					SubTopTwoStack:
.9177	38		sec				sec
.9178	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.917b	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.917e	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9181	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9184	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.9187	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.918a	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.918d	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.9190	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9193	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9196	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.9199	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.919c	60		rts				rts
.919d					AddInteger:
.919d	fa		plx				plx
.919e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91a1	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91a4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91a5	0a		asl a				asl 	a
.91a6	10 05		bpl $91ad			bpl 	_NotRef
.91a8	48		pha				pha
.91a9	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91ac	68		pla				pla
.91ad					_NotRef:
.91ad	0a		asl a				asl 	a 							; put MSB of type into A:7
.91ae	30 0b		bmi $91bb			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91b0	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91b3	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91b6	f0 06		beq $91be			beq 	_IntegerCode 				; if clear, then we have two integers
.91b8	4c 05 94	jmp $9405			jmp 	FloatingPointAdd 							; otherwise at least one float.
.91bb					_StringData:
.91bb	4c 2d 8f	jmp $8f2d			jmp 	StringConcat							; at least one string - don't know both are strings.
.91be					_IntegerCode:
.91be					AddCode:
.91be	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.91c1	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.91c4	10 8b		bpl $9151			bpl 	AddTopTwoStack
.91c6	20 77 91	jsr $9177			jsr 	SubTopTwoStack 				; do a physical subtraction
.91c9	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.91cc	10 09		bpl $91d7			bpl 	_AddExit
.91ce	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.91d1	9d 00 04	sta $0400,x			sta 	NSStatus,x
.91d4	20 91 9e	jsr $9e91			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.91d7					_AddExit:
.91d7	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; check for -0
.91da	d0 03		bne $91df			bne 	_AddNonZero
.91dc	9e 00 04	stz $0400,x			stz 	NSStatus,x
.91df					_AddNonZero:
.91df	60		rts				rts
.91e0					SubInteger:
.91e0	fa		plx				plx
.91e1	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91e4	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91e7	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91e8	0a		asl a				asl 	a
.91e9	10 05		bpl $91f0			bpl 	_NotRef
.91eb	48		pha				pha
.91ec	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91ef	68		pla				pla
.91f0					_NotRef:
.91f0	0a		asl a				asl 	a 							; put MSB of type into A:7
.91f1	30 0b		bmi $91fe			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91f3	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91f6	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91f9	f0 06		beq $9201			beq 	_IntegerCode 				; if clear, then we have two integers
.91fb	4c 0a 94	jmp $940a			jmp 	FloatingPointSub 							; otherwise at least one float.
.91fe					_StringData:
.91fe	4c 7a a0	jmp $a07a			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9201					_IntegerCode:
.9201	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.9204	49 80		eor #$80			eor 	#$80
.9206	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9209	80 b3		bra $91be			bra 	AddCode 					; and do the same code as add.
.920b					AndInteger:
.920b	fa		plx				plx
.920c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.920f	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9212	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9213	0a		asl a				asl 	a
.9214	10 05		bpl $921b			bpl 	_NotRef
.9216	48		pha				pha
.9217	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.921a	68		pla				pla
.921b					_NotRef:
.921b	0a		asl a				asl 	a
.921c	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.921e	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9221	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9224	f0 03		beq $9229			beq 	_IntegerCode 				; if clear, then we have two integers
.9226	4c 70 a0	jmp $a070			jmp 	TypeError 					; anything else, type mismatch.
.9229					_IntegerCode:
.9229	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.922c	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.922f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9232	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9235	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.9238	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.923b	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.923e	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.9241	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9244	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9247	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.924a	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.924d	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9250	60		rts				rts
.9251					OraInteger:
.9251	fa		plx				plx
.9252	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9255	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9258	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9259	0a		asl a				asl 	a
.925a	10 05		bpl $9261			bpl 	_NotRef
.925c	48		pha				pha
.925d	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9260	68		pla				pla
.9261					_NotRef:
.9261	0a		asl a				asl 	a
.9262	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9264	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9267	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.926a	f0 03		beq $926f			beq 	_IntegerCode 				; if clear, then we have two integers
.926c	4c 70 a0	jmp $a070			jmp 	TypeError 					; anything else, type mismatch.
.926f					_IntegerCode:
.926f	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9272	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.9275	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9278	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.927b	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.927e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9281	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9284	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.9287	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.928a	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.928d	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.9290	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9293	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9296	60		rts				rts
.9297					EorInteger:
.9297	fa		plx				plx
.9298	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.929b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.929e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.929f	0a		asl a				asl 	a
.92a0	10 05		bpl $92a7			bpl 	_NotRef
.92a2	48		pha				pha
.92a3	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92a6	68		pla				pla
.92a7					_NotRef:
.92a7	0a		asl a				asl 	a
.92a8	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92aa	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92ad	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92b0	f0 03		beq $92b5			beq 	_IntegerCode 				; if clear, then we have two integers
.92b2	4c 70 a0	jmp $a070			jmp 	TypeError 					; anything else, type mismatch.
.92b5					_IntegerCode:
.92b5	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.92b8	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.92bb	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.92be	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.92c1	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.92c4	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.92c7	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.92ca	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.92cd	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.92d0	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.92d3	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.92d6	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.92d9	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.92dc	60		rts				rts
.92dd					WordIndirect:
.92dd	fa		plx				plx
.92de	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92e1	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92e4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92e5	0a		asl a				asl 	a
.92e6	10 05		bpl $92ed			bpl 	_NotRef
.92e8	48		pha				pha
.92e9	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92ec	68		pla				pla
.92ed					_NotRef:
.92ed	0a		asl a				asl 	a
.92ee	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92f0	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92f3	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92f6	f0 03		beq $92fb			beq 	_IntegerCode 				; if clear, then we have two integers
.92f8	4c 70 a0	jmp $a070			jmp 	TypeError 					; anything else, type mismatch.
.92fb					_IntegerCode:
.92fb	20 be 91	jsr $91be			jsr 	AddCode 					; add the two values
.92fe	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9300	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9303	60		rts				rts
.9304					ByteIndirect:
.9304	fa		plx				plx
.9305	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9308	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.930b	0a		asl a				asl 	a 							; shift reference bit into sign bit
.930c	0a		asl a				asl 	a
.930d	10 05		bpl $9314			bpl 	_NotRef
.930f	48		pha				pha
.9310	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9313	68		pla				pla
.9314					_NotRef:
.9314	0a		asl a				asl 	a
.9315	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9317	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.931a	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.931d	f0 03		beq $9322			beq 	_IntegerCode 				; if clear, then we have two integers
.931f	4c 70 a0	jmp $a070			jmp 	TypeError 					; anything else, type mismatch.
.9322					_IntegerCode:
.9322	20 be 91	jsr $91be			jsr 	AddCode 					; add the two values
.9325	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9327	9d 00 04	sta $0400,x			sta 	NSStatus,x
.932a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.932b					LCLConvertInt16:
.932b	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.932e	8e 10 04	stx $0410			stx 	NSMantissa1
.9331	9c 18 04	stz $0418			stz 	NSMantissa2
.9334	9c 20 04	stz $0420			stz 	NSMantissa3
.9337	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.933a	a2 00		ldx #$00			ldx 	#0 							; stack level
.933c	a9 0a		lda #$0a			lda 	#10 						; base
.933e	80 00		bra $9340			bra 	ConvertInt32
.9340					ConvertInt32:
.9340	5a		phy				phy
.9341	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9343	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.9346	10 08		bpl $9350			bpl 	_CI32NotNeg
.9348	48		pha				pha
.9349	a9 2d		lda #$2d			lda 	#'-'
.934b	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.934e	c8		iny				iny
.934f	68		pla				pla
.9350					_CI32NotNeg:
.9350	20 5e 93	jsr $935e			jsr 	_CI32DivideConvert 			; recursive conversion
.9353	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.9355	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.9358	7a		ply				ply
.9359	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.935b	a9 fa		lda #$fa			lda 	#NumberBuffer & $FF
.935d	60		rts				rts
.935e					_CI32DivideConvert:
.935e	e8		inx				inx 								; write to next slot up
.935f	20 de 9e	jsr $9ede			jsr 	NSMSetByte
.9362	ca		dex				dex
.9363	20 02 90	jsr $9002			jsr 	Int32Divide 				; divide
.9366	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.9369	48		pha				pha
.936a	20 b1 8f	jsr $8fb1			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.936d	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; is it zero ?
.9370	f0 06		beq $9378			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9372	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.9375	20 5e 93	jsr $935e			jsr 	_CI32DivideConvert 			; and recusrively call.
.9378					_CI32NoRecurse:
.9378	68		pla				pla 								; remainder
.9379	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.937b	90 02		bcc $937f			bcc 	_CI32NotHex
.937d	69 26		adc #$26			adc 	#6+32
.937f					_CI32NotHex:
.937f	69 30		adc #$30			adc 	#48
.9381	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y 				; write out and exit
.9384	c8		iny				iny
.9385	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.9386					PrecedenceLevel:
>9386	04					.byte	 4	; $00 <<
>9387	02					.byte	 2	; $01 <=
>9388	02					.byte	 2	; $02 <>
>9389	00					.byte	 0	; $03 !!3
>938a	00					.byte	 0	; $04 ><
>938b	02					.byte	 2	; $05 >=
>938c	04					.byte	 4	; $06 >>
>938d	00					.byte	 0	; $07 !!7
>938e	00					.byte	 0	; $08 !!8
>938f	00					.byte	 0	; $09 !!9
>9390	00					.byte	 0	; $0a !!10
>9391	00					.byte	 0	; $0b !!11
>9392	00					.byte	 0	; $0c !!12
>9393	00					.byte	 0	; $0d !!13
>9394	00					.byte	 0	; $0e !!14
>9395	00					.byte	 0	; $0f !!15
>9396	00					.byte	 0	; $10 @
>9397	00					.byte	 0	; $11 !!17
>9398	00					.byte	 0	; $12 !!18
>9399	00					.byte	 0	; $13 [
>939a	04					.byte	 4	; $14 \
>939b	00					.byte	 0	; $15 ]
>939c	01					.byte	 1	; $16 ^
>939d	00					.byte	 0	; $17 _
>939e	00					.byte	 0	; $18 `
>939f	00					.byte	 0	; $19 !!25
>93a0	00					.byte	 0	; $1a !!26
>93a1	00					.byte	 0	; $1b {
>93a2	01					.byte	 1	; $1c |
>93a3	00					.byte	 0	; $1d }
>93a4	00					.byte	 0	; $1e ~
>93a5	00					.byte	 0	; $1f [7m<7F>[m
>93a6	00					.byte	 0	; $20
>93a7	05					.byte	 5	; $21 !
>93a8	00					.byte	 0	; $22 "
>93a9	00					.byte	 0	; $23 #
>93aa	05					.byte	 5	; $24 $
>93ab	04					.byte	 4	; $25 %
>93ac	01					.byte	 1	; $26 &
>93ad	00					.byte	 0	; $27 '
>93ae	00					.byte	 0	; $28 (
>93af	00					.byte	 0	; $29 )
>93b0	04					.byte	 4	; $2a *
>93b1	03					.byte	 3	; $2b +
>93b2	00					.byte	 0	; $2c ,
>93b3	03					.byte	 3	; $2d -
>93b4	00					.byte	 0	; $2e .
>93b5	04					.byte	 4	; $2f /
>93b6	00					.byte	 0	; $30 0
>93b7	00					.byte	 0	; $31 1
>93b8	00					.byte	 0	; $32 2
>93b9	00					.byte	 0	; $33 3
>93ba	00					.byte	 0	; $34 4
>93bb	00					.byte	 0	; $35 5
>93bc	00					.byte	 0	; $36 6
>93bd	00					.byte	 0	; $37 7
>93be	00					.byte	 0	; $38 8
>93bf	00					.byte	 0	; $39 9
>93c0	00					.byte	 0	; $3a :
>93c1	00					.byte	 0	; $3b ;
>93c2	02					.byte	 2	; $3c <
>93c3	02					.byte	 2	; $3d =
>93c4	02					.byte	 2	; $3e >
>93c5	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93c6					EvaluateExpressionAt0:
.93c6	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93c8					EvaluateExpression:
.93c8	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93ca					EvaluateExpressionAtPrecedence:
.93ca	48		pha				pha 								; save precedence level
.93cb	20 a2 98	jsr $98a2			jsr 	EvaluateTerm 				; evaluate term into level X.
.93ce	68		pla				pla 								; restore precedence level.
.93cf					_EXPRLoop:
.93cf	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.93d1	b1 30		lda ($30),y			lda 	(codePtr),y
.93d3	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.93d5	b0 25		bcs $93fc			bcs 	_EXPRExit
.93d7	da		phx				phx 								; read the operator precedence
.93d8	aa		tax				tax
.93d9	bd 86 93	lda $9386,x			lda 	PrecedenceLevel,x
.93dc	fa		plx				plx
.93dd	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.93df	f0 1b		beq $93fc			beq 	_EXPRExit
.93e1	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93e3	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93e5	c5 37		cmp $37				cmp 	zTemp0+1
.93e7	b0 13		bcs $93fc			bcs		_EXPRExit 					; if current >= operator exit
.93e9	48		pha				pha 								; save current precedence.
.93ea	b1 30		lda ($30),y			lda 	(codePtr),y
.93ec	c8		iny				iny
.93ed	48		pha				pha
.93ee	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93f0	e8		inx				inx 								; work out the right hand side.
.93f1	20 ca 93	jsr $93ca			jsr 	EvaluateExpressionAtPrecedence
.93f4	ca		dex				dex
.93f5	68		pla				pla 								; get operator, call the code.
.93f6	20 ff 93	jsr $93ff			jsr 	_EXPRCaller
.93f9	68		pla				pla 								; restore precedence level
.93fa	80 d3		bra $93cf			bra 	_EXPRLoop 					; and go round.
.93fc					_EXPRExit:
.93fc	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93fe	60		rts				rts
.93ff					_EXPRCaller:
.93ff	da		phx				phx 								; save on stack, first thing is to restore it
.9400	0a		asl a				asl 	a 							; double so can use vectors into X
.9401	aa		tax				tax
.9402	7c 40 8b	jmp ($8b40,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9405					FloatingPointAdd:
.9405	20 ae 95	jsr $95ae			jsr 	FloatPrepare 				; prepare for floats
.9408	80 0b		bra $9415			bra 	FloatAdd
.940a					FloatingPointSub:
.940a	20 ae 95	jsr $95ae			jsr 	FloatPrepare 				; prepare for floats
.940d					FloatSubtract:
.940d	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.9410	49 80		eor #$80			eor 	#$80
.9412	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.9415					FloatAdd:
.9415	48		pha				pha
.9416	5a		phy				phy
.9417	20 bf 95	jsr $95bf			jsr 	NSNormalise 				; normalise S[X]
.941a	f0 5c		beq $9478			beq 	_FAReturn1
.941c	e8		inx				inx 								; normalise S[X+1]
.941d	20 bf 95	jsr $95bf			jsr 	NSNormalise
.9420	ca		dex				dex
.9421	c9 00		cmp #$00			cmp 	#0
.9423	f0 77		beq $949c			beq 	_FAExit 					; if so, just return A
.9425	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.9428	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.942b	f0 1b		beq $9448			beq 	_FAExponentsEqual
.942d	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.9430	a8		tay				tay
.9431	38		sec				sec 								; do a signed comparison of the exponents.
.9432	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.9435	50 02		bvc $9439			bvc 	_FANoSignedChange
.9437	49 80		eor #$80			eor 	#$80
.9439					_FANoSignedChange:
.9439	29 80		and #$80			and 	#$80
.943b	10 03		bpl $9440			bpl 	_FAHaveMax
.943d	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.9440					_FAHaveMax:
.9440	20 9f 94	jsr $949f			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9443	e8		inx				inx
.9444	20 9f 94	jsr $949f			jsr 	_FAShiftToExponent
.9447	ca		dex				dex
.9448					_FAExponentsEqual:
.9448	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.944b	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.944e	30 10		bmi $9460			bmi 	_FADifferentSigns
.9450	20 51 91	jsr $9151			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9453	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9456	10 44		bpl $949c			bpl 	_FAExit 					; if no, we are done.
.9458	20 ff 9e	jsr $9eff			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.945b	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.945e	80 3c		bra $949c			bra 	_FAExit
.9460					_FADifferentSigns:
.9460	20 77 91	jsr $9177			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9463	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.9466	10 06		bpl $946e			bpl 	_FACheckZero 				; if no, check for -0
.9468	20 88 9e	jsr $9e88			jsr 	NSMNegate 					; netate result
.946b	20 91 9e	jsr $9e91			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.946e					_FACheckZero:
.946e	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero	 				; check for -0
.9471	d0 29		bne $949c			bne 	_FAExit
.9473	9e 00 04	stz $0400,x			stz 	NSStatus,x
.9476	80 24		bra $949c			bra 	_FAExit
.9478					_FAReturn1:
.9478	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.947b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.947e	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9481	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9484	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9487	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.948a	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.948d	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9490	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9493	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9496	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9499	9d 00 04	sta $0400,x			sta 	NSStatus,x
.949c					_FAExit:
.949c	7a		ply				ply
.949d	68		pla				pla
.949e	60		rts				rts
.949f					_FAShiftToExponent:
.949f					_FAShiftToExponent2:
.949f	98		tya				tya 								; compare Y to exponent
.94a0	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.94a3	f0 08		beq $94ad			beq 	_FASEExit 					; exit if so.
.94a5	20 ff 9e	jsr $9eff			jsr 	NSMShiftRight	 			; shift the mantissa right
.94a8	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.94ab	80 f2		bra $949f			bra 	_FAShiftToExponent2
.94ad					_FASEExit:
.94ad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94ae					CompareFloat:
.94ae	20 0d 94	jsr $940d			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94b1	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94b4	29 f8		and #$f8			and 	#$F8
.94b6	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.94b9	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.94bc	f0 09		beq $94c7			beq 	_FCExit 					; zero, so approximately identical
.94be	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94c0	3c 00 04	bit $0400,x			bit 	NSStatus,x
.94c3	10 02		bpl $94c7			bpl 	_FCExit
.94c5					_FCNegative:
.94c5	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94c7					_FCExit:
.94c7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94c8					FDivideCommand:
.94c8	fa		plx				plx	 								; restore stack position
.94c9	20 ae 95	jsr $95ae			jsr 	FloatPrepare 				; prepare for floats
.94cc					FloatDivide:
.94cc	48		pha				pha
.94cd	e8		inx				inx
.94ce	20 bf 95	jsr $95bf			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94d1	ca		dex				dex
.94d2	c9 00		cmp #$00			cmp 	#0
.94d4	f0 20		beq $94f6			beq 	_FDZero
.94d6	20 bf 95	jsr $95bf			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94d9	f0 19		beq $94f4			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94db	20 24 90	jsr $9024			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94de	20 b1 8f	jsr $8fb1			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94e1	20 bf 95	jsr $95bf			jsr		NSNormalise 				; renormalise
.94e4	20 bf 90	jsr $90bf			jsr 	CalculateSign 				; calculate result sign
.94e7	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.94ea	38		sec				sec
.94eb	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.94ee	38		sec				sec
.94ef	e9 1e		sbc #$1e			sbc 	#30
.94f1	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94f4					_FDExit:
.94f4	68		pla				pla
.94f5	60		rts				rts
.94f6					_FDZero:
.94f6	a9 03		lda #$03		lda	#3
.94f8	4c 19 8e	jmp $8e19		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.94fb					FloatFractionalPart:
.94fb	5a		phy				phy
.94fc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.94ff	29 7f		and #$7f			and 	#$7F
.9501	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9504	20 bf 95	jsr $95bf			jsr 	NSNormalise
.9507	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.950a	38		sec				sec
.950b	e9 e0		sbc #$e0			sbc 	#$E0
.950d	90 31		bcc $9540			bcc 	_FFPExit 					; already fractional
.950f	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9511	b0 2a		bcs $953d			bcs 	_FFPZero
.9513	a8		tay				tay 								; put count to do in Y
.9514	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.9517	20 42 95	jsr $9542			jsr 	_FFPPartial
.951a	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.951d	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9520	20 42 95	jsr $9542			jsr 	_FFPPartial
.9523	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9526	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9529	20 42 95	jsr $9542			jsr 	_FFPPartial
.952c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.952f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9532	20 42 95	jsr $9542			jsr 	_FFPPartial
.9535	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9538	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; zeroed check.
.953b	d0 03		bne $9540			bne 	_FFPExit
.953d					_FFPZero:
.953d	20 dc 9e	jsr $9edc			jsr 	NSMSetZero
.9540					_FFPExit:
.9540	7a		ply				ply
.9541	60		rts				rts
.9542					_FFPPartial:
.9542	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9544	f0 17		beq $955d			beq 	_FFFPPExit
.9546	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9548	b0 0c		bcs $9556			bcs 	_FFFPPWholeByte
.954a	5a		phy				phy
.954b					_FFFPPLeft:
.954b	0a		asl a				asl 	a
.954c	88		dey				dey
.954d	d0 fc		bne $954b			bne 	_FFFPPLeft
.954f	7a		ply				ply
.9550					_FFFPPRight:
.9550	4a		lsr a				lsr 	a
.9551	88		dey				dey
.9552	d0 fc		bne $9550			bne 	_FFFPPRight
.9554	80 07		bra $955d			bra 	_FFFPPExit
.9556					_FFFPPWholeByte:
.9556	98		tya				tya 								; subtract 8 from count
.9557	38		sec				sec
.9558	e9 08		sbc #$08			sbc 	#8
.955a	a8		tay				tay
.955b	a9 00		lda #$00			lda 	#0 							; and clear all
.955d					_FFFPPExit:
.955d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.955e					FloatIntegerPart:
.955e	48		pha				pha
.955f	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.9562	f0 1f		beq $9583			beq 	_FIPExit 					; if so do nothing
.9564	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; is it zero ?
.9567	f0 17		beq $9580			beq 	_FIPZero 					; if so return zero.
.9569	20 bf 95	jsr $95bf			jsr 	NSNormalise 				; normalise
.956c	f0 12		beq $9580			beq 	_FIPZero 					; normalised to zero, exit zero
.956e					_FIPShift:
.956e	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9571	10 08		bpl $957b			bpl 	_FIPCheckZero
.9573	20 ff 9e	jsr $9eff			jsr 	NSMShiftRight 				; shift mantissa right
.9576	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.9579	80 f3		bra $956e			bra 	_FIPShift
.957b					_FIPCheckZero:
.957b	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; avoid -0 problem
.957e	d0 03		bne $9583			bne 	_FIPExit 					; set to zero if mantissa zero.
.9580					_FIPZero:
.9580	20 dc 9e	jsr $9edc			jsr 	NSMSetZero
.9583					_FIPExit:
.9583	68		pla				pla
.9584	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9585					FloatingPointMultiply:
.9585	20 ae 95	jsr $95ae			jsr 	FloatPrepare 				; prepare for floats
.9588					FloatMultiply:
.9588	48		pha				pha
.9589	20 bf 95	jsr $95bf			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.958c	f0 1b		beq $95a9			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.958e	e8		inx				inx
.958f	20 bf 95	jsr $95bf			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9592	ca		dex				dex
.9593	c9 00		cmp #$00			cmp 	#0
.9595	f0 0f		beq $95a6			beq 	_FDSetZero
.9597	20 7a 90	jsr $907a			jsr 	MultiplyShort 				; calculate the result.
.959a	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.959d	18		clc				clc
.959e	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.95a1	9d 28 04	sta $0428,x			sta 	NSExponent,x
.95a4	80 03		bra $95a9			bra 	_FDExit
.95a6					_FDSetZero:
.95a6	20 dc 9e	jsr $9edc			jsr 	NSMSetZero 					; return 0
.95a9					_FDExit:
.95a9	20 bf 95	jsr $95bf			jsr 	NSNormalise 				; normalise the result
.95ac	68		pla				pla
.95ad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95ae					FloatPrepare:
.95ae	20 e1 96	jsr $96e1			jsr 	DereferenceTopTwo 			; dereference the top two values
.95b1	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.95b4	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.95b7	29 10		and #$10			and 	#NSBIsString
.95b9	d0 01		bne $95bc			bne 	_FDType
.95bb	60		rts				rts
.95bc					_FDType:
.95bc	4c 70 a0	jmp $a070			jmp 	TypeError
.95bf					NSNormalise:
.95bf	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.95c2	29 80		and #$80			and 	#$80
.95c4	09 08		ora #$08			ora 	#NSTFloat
.95c6	9d 00 04	sta $0400,x			sta 	NSStatus,x
.95c9	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; if zero exit
.95cc	d0 09		bne $95d7			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95ce	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.95d1	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.95d4	a9 00		lda #$00			lda 	#0 							; set Z flag
.95d6	60		rts				rts
.95d7					_NSNormaliseOptimise:
.95d7	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95da	d0 22		bne $95fe			bne 	_NSNormaliseLoop
.95dc	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.95df	30 1d		bmi $95fe			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95e1	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.95e4	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95e7	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.95ea	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95ed	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.95f0	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.95f3	bd 28 04	lda $0428,x			lda 	NSExponent,x
.95f6	38		sec				sec
.95f7	e9 08		sbc #$08			sbc 	#8
.95f9	9d 28 04	sta $0428,x			sta 	NSExponent,x
.95fc	80 d9		bra $95d7			bra 	_NSNormaliseOptimise
.95fe					_NSNormaliseLoop:
.95fe	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9601	70 08		bvs $960b			bvs 	_NSNExit 					; exit if so with Z flag clear
.9603	20 f1 9e	jsr $9ef1			jsr 	NSMShiftLeft 				; shift mantissa left
.9606	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.9609	80 f3		bra $95fe			bra 	_NSNormaliseLoop
.960b					_NSNExit:
.960b	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.960d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.960e					AssignNumber:
.960e	5a		phy				phy
.960f	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9612	85 36		sta $36				sta 	zTemp0
.9614	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9617	85 37		sta $37				sta 	zTemp0+1
.9619	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.961c	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.961e	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9621	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9623	c9 08		cmp #$08			cmp 	#NSTFloat
.9625	f0 2a		beq $9651			beq 	_ANFloat
.9627	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.962a	f0 05		beq $9631			beq		_ANNotFloat
.962c	e8		inx				inx
.962d	20 5e 95	jsr $955e			jsr 	FloatIntegerPart 			; make it an integer
.9630	ca		dex				dex
.9631					_ANNotFloat:
.9631	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.9634	29 03		and #$03			and 	#3
.9636	d0 05		bne $963d			bne 	_ANByteWord
.9638	20 5d 96	jsr $965d			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.963b	80 1e		bra $965b			bra 	_ANExit
.963d					_ANByteWord:
.963d	48		pha				pha 								; save count
.963e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.9641	92 36		sta ($36)			sta 	(zTemp0)
.9643	68		pla				pla
.9644	c9 01		cmp #$01			cmp	 	#1
.9646	f0 13		beq $965b			beq 	_ANExit
.9648	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.964b	a0 01		ldy #$01			ldy 	#1
.964d	91 36		sta ($36),y			sta 	(zTemp0),y
.964f	80 0a		bra $965b			bra 	_ANExit
.9651					_ANFloat:
.9651	20 5d 96	jsr $965d			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9654	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9657	a0 04		ldy #$04			ldy 	#4
.9659	91 36		sta ($36),y			sta 	(zTemp0),y
.965b					_ANExit:
.965b	7a		ply				ply
.965c	60		rts				rts
.965d					_ANCopy4PackSign:
.965d	a0 03		ldy #$03			ldy 	#3
.965f	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.9662	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9664	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.9667	91 36		sta ($36),y			sta 	(zTemp0),y
.9669	88		dey				dey
.966a	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.966d	91 36		sta ($36),y			sta 	(zTemp0),y
.966f	88		dey				dey
.9670	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9673	91 36		sta ($36),y			sta 	(zTemp0),y
.9675	88		dey				dey
.9676	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9679	91 36		sta ($36),y			sta 	(zTemp0),y
.967b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.967c					AssignString:
.967c	5a		phy				phy
.967d	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9680	85 38		sta $38				sta 	zTemp1
.9682	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9685	85 39		sta $39				sta 	zTemp1+1
.9687	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.968a	85 36		sta $36				sta 	zTemp0
.968c	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.968f	85 37		sta $37				sta 	zTemp0+1
.9691	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9693	b1 36		lda ($36),y			lda 	(zTemp0),y
.9695	f0 23		beq $96ba			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9697	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9698	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.969a	e9 02		sbc #$02			sbc 	#2
.969c	85 3c		sta $3c				sta 	zsTemp
.969e	a0 01		ldy #$01			ldy 	#1
.96a0	b1 36		lda ($36),y			lda 	(zTemp0),y
.96a2	e9 00		sbc #$00			sbc 	#0
.96a4	85 3d		sta $3d				sta 	zsTemp+1
.96a6	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.96a8					_ASGetLength:
.96a8	c8		iny				iny
.96a9	b1 38		lda ($38),y			lda 	(zTemp1),y
.96ab	d0 fb		bne $96a8			bne 	_ASGetLength
.96ad	98		tya				tya 								; is this length <= current length
.96ae	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.96b0	90 20		bcc $96d2			bcc 	_ASCopyString
.96b2	f0 1e		beq $96d2			beq 	_ASCopyString
.96b4	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.96b6	a0 01		ldy #$01			ldy 	#1
.96b8	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96ba					_ASNewStringRequired:
.96ba	e8		inx				inx 								; concrete the new string.
.96bb	20 d7 a7	jsr $a7d7			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.96be	ca		dex				dex
.96bf	18		clc				clc
.96c0	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96c3	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96c5	92 36		sta ($36)			sta 	(zTemp0)
.96c7	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.96ca	69 00		adc #$00			adc 	#0
.96cc	a0 01		ldy #$01			ldy 	#1
.96ce	91 36		sta ($36),y			sta 	(zTemp0),y
.96d0	80 0d		bra $96df			bra 	_ASExit
.96d2					_ASCopyString:
.96d2	a0 00		ldy #$00			ldy 	#0
.96d4					_ASCopyLoop:
.96d4	b1 38		lda ($38),y			lda 	(zTemp1),y
.96d6	c8		iny				iny
.96d7	c8		iny				iny
.96d8	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96da	88		dey				dey
.96db	c9 00		cmp #$00			cmp 	#0
.96dd	d0 f5		bne $96d4			bne 	_ASCopyLoop
.96df					_ASExit:
.96df	7a		ply				ply
.96e0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96e1					DereferenceTopTwo:
.96e1	e8		inx				inx
.96e2	20 e6 96	jsr $96e6			jsr 	Dereference 				; deref x+1
.96e5	ca		dex				dex  								; falls through to deref x
.96e6					Dereference:
.96e6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.96e9	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.96eb	f0 57		beq $9744			beq 	_DRFExit 					; not a reference
.96ed	5a		phy				phy
.96ee	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96f1	85 36		sta $36				sta 	zTemp0
.96f3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.96f6	85 37		sta $37				sta 	zTemp0+1
.96f8	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.96fb	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96fd	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9700	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.9703	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9705	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9707	f0 0f		beq $9718			beq 	_DRFDereferenceTwo
.9709	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.970b	f0 39		beq $9746			beq 	_DRFFull
.970d	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9710	29 03		and #$03			and 	#3
.9712	f0 32		beq $9746			beq 	_DRFFull 					; the whole word
.9714	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9716	f0 07		beq $971f			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9718					_DRFDereferenceTwo:
.9718	a0 01		ldy #$01			ldy 	#1
.971a	b1 36		lda ($36),y			lda 	(zTemp0),y
.971c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.971f					_DRFClear23:
.971f	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9722	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9725	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.9728	29 18		and #$18			and 	#NSBTypeMask
.972a	9d 00 04	sta $0400,x			sta 	NSStatus,x
.972d	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.972f	d0 12		bne $9743			bne 	_DRFNotString
.9731	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.9734	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9737	d0 0a		bne $9743			bne 	_DRFNotString
.9739	a9 45		lda #$45			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.973b	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.973e	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9740	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.9743					_DRFNotString
.9743	7a		ply				ply 								; restore Y and exit
.9744					_DRFExit:
.9744	60		rts				rts
.9745					_DRFNullString:
>9745	00						.byte 	0
.9746					_DRFFull:
.9746	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9748	b1 36		lda ($36),y			lda 	(zTemp0),y
.974a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.974d	c8		iny				iny
.974e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9750	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9753	c8		iny				iny
.9754	b1 36		lda ($36),y			lda 	(zTemp0),y
.9756	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9759	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.975c	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.975f	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9761	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.9764	f0 06		beq $976c			beq 	_DRFNoExponent
.9766	c8		iny				iny 								; if not, read the exponent as well.
.9767	b1 36		lda ($36),y			lda 	(zTemp0),y
.9769	9d 28 04	sta $0428,x			sta 	NSExponent,x
.976c					_DRFNoExponent:
.976c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.976f	10 0d		bpl $977e			bpl 	_DRFExit2 					; if not, then exit.
.9771	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9773	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9776	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.9779	09 80		ora #$80			ora 	#NSBIsNegative
.977b	9d 00 04	sta $0400,x			sta 	NSStatus,x
.977e					_DRFExit2:
.977e	7a		ply				ply
.977f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9780					EncodeNumberStart:
.9780	38		sec				sec
.9781	80 01		bra $9784			bra 	EncodeNumberContinue+1
.9783					EncodeNumberContinue:
.9783	18		clc				clc
.9784					EncodeNumber:
.9784	08		php				php 								; save reset.
.9785	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9787	f0 12		beq $979b			beq 	_ENIsOkay
.9789	c9 30		cmp #$30			cmp 	#"0"
.978b	90 04		bcc $9791			bcc 	_ENBadNumber
.978d	c9 3a		cmp #$3a			cmp 	#"9"+1
.978f	90 0a		bcc $979b			bcc 	_ENIsOkay
.9791					_ENBadNumber:
.9791	28		plp				plp 								; throw saved reset
.9792	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.9795	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9797	f0 7e		beq $9817			beq 	_ENConstructFinal
.9799					_ENFail:
.9799	18		clc				clc 								; not allowed
.979a	60		rts				rts
.979b					_ENIsOkay:
.979b	28		plp				plp 								; are we restarting
.979c	90 15		bcc $97b3			bcc 	_ENNoRestart
.979e					_ENStartEncode:
.979e	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.97a0	f0 0c		beq $97ae			beq 	_ENFirstDP
.97a2	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.97a4	20 de 9e	jsr $9ede			jsr 	NSMSetByte
.97a7	a9 01		lda #$01			lda 	#ESTA_Low
.97a9					_ENExitChange:
.97a9	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.97ac	38		sec				sec
.97ad	60		rts				rts
.97ae					_ENFirstDP:
.97ae	20 dc 9e	jsr $9edc			jsr 	NSMSetZero 					; clear integer part
.97b1	80 3f		bra $97f2			bra 	_ESTASwitchFloat			; go straight to float and exi
.97b3					_ENNoRestart:
.97b3	48		pha				pha 								; save on stack.
.97b4	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.97b7	c9 01		cmp #$01			cmp 	#ESTA_Low
.97b9	f0 09		beq $97c4			beq  	_ESTALowState
.97bb	c9 02		cmp #$02			cmp 	#ESTA_High
.97bd	f0 29		beq $97e8			beq 	_ESTAHighState
.97bf	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.97c1	f0 3b		beq $97fe			beq 	_ESTADecimalState
>97c3	db						.byte 	$DB 						; causes a break in the emulator
.97c4					_ESTALowState:
.97c4	68		pla				pla 								; get value back
.97c5	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.97c7	f0 29		beq $97f2			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.97c9	29 0f		and #$0f			and 	#15 						; make digit
.97cb	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.97ce	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97d1	0a		asl a				asl 	a
.97d2	0a		asl a				asl 	a
.97d3	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97d6	0a		asl a				asl 	a
.97d7	6d 86 04	adc $0486			adc 	DigitTemp
.97da	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97dd	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97df	90 05		bcc $97e6			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97e1	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97e3	8d 85 04	sta $0485			sta 	EncodeState
.97e6					_ESTANoSwitch:
.97e6	38		sec				sec
.97e7	60		rts				rts
.97e8					_ESTAHighState:
.97e8	68		pla				pla 								; get value back
.97e9	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97eb	f0 05		beq $97f2			beq 	_ESTASwitchFloat
.97ed	20 51 98	jsr $9851			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97f0	38		sec				sec
.97f1	60		rts				rts
.97f2					_ESTASwitchFloat:
.97f2	9c 87 04	stz $0487			stz 	DecimalCount
.97f5	e8		inx				inx 								; zero the decimal additive.
.97f6	20 dc 9e	jsr $9edc			jsr 	NSMSetZero
.97f9	ca		dex				dex
.97fa	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97fc	80 ab		bra $97a9			bra 	_ENExitChange
.97fe					_ESTADecimalState:
.97fe	68		pla				pla 								; digit.
.97ff	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9801	f0 96		beq $9799			beq 	_ENFail
.9803	e8		inx				inx 								; put digit into fractional part of X+1
.9804	20 51 98	jsr $9851			jsr 	ESTAShiftDigitIntoMantissa
.9807	ca		dex				dex
.9808	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.980b	ad 87 04	lda $0487			lda 	DecimalCount
.980e	c9 0b		cmp #$0b			cmp 	#11
.9810	f0 02		beq $9814			beq 	_ESTADSFail
.9812	38		sec				sec
.9813	60		rts				rts
.9814					_ESTADSFail:
.9814	4c 6b a0	jmp $a06b			jmp 	RangeError
.9817					_ENConstructFinal:
.9817	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.981a	f0 33		beq $984f			beq 	_ENCFExit 					; no decimals
.981c	5a		phy				phy
.981d	0a		asl a				asl 	a 							; x 4 and CLC
.981e	0a		asl a				asl 	a
.981f	6d 87 04	adc $0487			adc 	DecimalCount
.9822	a8		tay				tay
.9823	b9 2a a0	lda $a02a,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9826	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9829	b9 2b a0	lda $a02b,y			lda 	DecimalScalarTable-5+1,y
.982c	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.982f	b9 2c a0	lda $a02c,y			lda 	DecimalScalarTable-5+2,y
.9832	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9835	b9 2d a0	lda $a02d,y			lda 	DecimalScalarTable-5+3,y
.9838	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.983b	b9 2e a0	lda $a02e,y			lda 	DecimalScalarTable-5+4,y
.983e	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9841	a9 08		lda #$08			lda 	#NSTFloat
.9843	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9846	7a		ply				ply
.9847	e8		inx				inx 								; multiply decimal const by decimal scalar
.9848	20 88 95	jsr $9588			jsr 	FloatMultiply
.984b	ca		dex				dex
.984c	20 15 94	jsr $9415			jsr 	FloatAdd 					; add to integer part.
.984f					_ENCFExit:
.984f	18		clc				clc 								; reject the digit.
.9850	60		rts				rts
.9851					ESTAShiftDigitIntoMantissa:
.9851	29 0f		and #$0f			and 	#15 						; save digit
.9853	48		pha				pha
.9854	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9857	48		pha				pha
.9858	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.985b	48		pha				pha
.985c	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.985f	48		pha				pha
.9860	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9863	48		pha				pha
.9864	20 f1 9e	jsr $9ef1			jsr 	NSMShiftLeft 				; x 2
.9867	20 f1 9e	jsr $9ef1			jsr 	NSMShiftLeft 				; x 4
.986a	18		clc				clc 								; pop mantissa and add
.986b	68		pla				pla
.986c	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.986f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9872	68		pla				pla
.9873	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.9876	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9879	68		pla				pla
.987a	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.987d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9880	68		pla				pla
.9881	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.9884	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.9887	20 f1 9e	jsr $9ef1			jsr 	NSMShiftLeft 				; x 10
.988a	68		pla				pla 								; add digit
.988b	18		clc				clc
.988c	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.988f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9892	90 0d		bcc $98a1			bcc 	_ESTASDExit
.9894	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.9897	d0 08		bne $98a1			bne 	_ESTASDExit
.9899	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.989c	d0 03		bne $98a1			bne 	_ESTASDExit
.989e	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.98a1					_ESTASDExit:
.98a1	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.98a2					EvaluateTerm:
.98a2	b1 30		lda ($30),y			lda 	(codePtr),y
.98a4	30 18		bmi $98be			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.98a6	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.98a8	b0 6f		bcs $9919			bcs 	_ETVariable
.98aa	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.98ac	90 6e		bcc $991c			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.98ae	c9 3a		cmp #$3a			cmp 	#'9'+1
.98b0	b0 6a		bcs $991c			bcs 	_ETPuncUnary
.98b2	20 80 97	jsr $9780			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.98b5					_ETNumber:
.98b5	c8		iny				iny 								; keep encoding until we have the numbers
.98b6	b1 30		lda ($30),y			lda 	(codePtr),y
.98b8	20 83 97	jsr $9783			jsr 	EncodeNumberContinue
.98bb	b0 f8		bcs $98b5			bcs 	_ETNumber 					; go back if accepted.
.98bd	60		rts				rts
.98be					_ETCheckUnary:
.98be	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.98c0	f0 41		beq $9903			beq 	_ETString
.98c2	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.98c4	f0 12		beq $98d8			beq 	_ETHexConstant
.98c6	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.98c8	90 0b		bcc $98d5			bcc 	_ETSyntaxError
.98ca	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.98cc	b0 07		bcs $98d5			bcs 	_ETSyntaxError
.98ce	da		phx				phx 								; push X on the stack
.98cf	0a		asl a				asl 	a 							; put vector x 2 into X
.98d0	aa		tax				tax
.98d1	c8		iny				iny 								; consume unary function token
.98d2	7c c0 8b	jmp ($8bc0,x)			jmp 	(VectorSet0,x) 				; and do it.
.98d5					_ETSyntaxError:
.98d5	4c 66 a0	jmp $a066			jmp 	SyntaxError
.98d8					_ETHexConstant:
.98d8	c8		iny				iny 								; skip #
.98d9	c8		iny				iny 								; skip count
.98da	20 dc 9e	jsr $9edc			jsr 	NSMSetZero 					; clear result
.98dd					_ETHLoop:
.98dd	b1 30		lda ($30),y			lda 	(codePtr),y
.98df	c8		iny				iny 								; and consume
.98e0	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.98e2	f0 1e		beq $9902			beq 	_ETHExit
.98e4	48		pha				pha 								; save on stack.
.98e5	20 f1 9e	jsr $9ef1			jsr 	NSMShiftLeft 				; x 2
.98e8	20 f1 9e	jsr $9ef1			jsr 	NSMShiftLeft 				; x 4
.98eb	20 f1 9e	jsr $9ef1			jsr 	NSMShiftLeft 				; x 8
.98ee	20 f1 9e	jsr $9ef1			jsr 	NSMShiftLeft 				; x 16
.98f1	68		pla				pla 								; ASCII
.98f2	c9 41		cmp #$41			cmp 	#'A'
.98f4	90 02		bcc $98f8			bcc 	_ETHNotChar
.98f6	e9 07		sbc #$07			sbc 	#7
.98f8					_ETHNotChar:
.98f8	29 0f		and #$0f			and 	#15 						; digit now
.98fa	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98fd	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9900	80 db		bra $98dd			bra 	_ETHLoop 					; go round.
.9902					_ETHExit:
.9902	60		rts				rts
.9903					_ETString:
.9903	c8		iny				iny 								; look at length
.9904	b1 30		lda ($30),y			lda 	(codePtr),y
.9906	48		pha				pha
.9907	c8		iny				iny 								; first character
.9908	20 74 a6	jsr $a674			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.990b	68		pla				pla 								; restore count and save
.990c	85 36		sta $36				sta 	zTemp0
.990e	98		tya				tya 								; add length to Y to skip it.
.990f	18		clc				clc
.9910	65 36		adc $36				adc 	zTemp0
.9912	a8		tay				tay
.9913	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9915	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9918	60		rts				rts
.9919					_ETVariable:
.9919	4c 73 99	jmp $9973			jmp 	VariableHandler
.991c					_ETPuncUnary:
.991c	c8		iny				iny 								; consume the unary character
.991d	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.991f	f0 2d		beq $994e			beq 	_ETUnaryNegate
.9921	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9923	f0 39		beq $995e			beq 	_ETDereference
.9925	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9927	f0 43		beq $996c			beq 	_ETParenthesis
.9929	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.992b	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.992d	f0 06		beq $9935			beq 	_ETIndirection
.992f	e6 36		inc $36				inc 	zTemp0
.9931	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9933	d0 a0		bne $98d5			bne 	_ETSyntaxError
.9935					_ETIndirection:
.9935	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9937	1a		inc a				inc 	a
.9938	48		pha				pha
.9939	20 a2 98	jsr $98a2			jsr 	EvaluateTerm				; evaluate the term
.993c	20 e6 96	jsr $96e6			jsr 	Dereference 				; dereference it.
.993f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.9942	d0 07		bne $994b			bne 	_ETTypeMismatch
.9944	68		pla				pla 								; indirection 1-2
.9945	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9947	9d 00 04	sta $0400,x			sta 	NSStatus,x
.994a	60		rts				rts
.994b					_ETTypeMismatch:
.994b	4c 70 a0	jmp $a070			jmp 	TypeError
.994e					_ETUnaryNegate:
.994e	20 a2 98	jsr $98a2			jsr 	EvaluateTerm				; evaluate the term
.9951	20 e6 96	jsr $96e6			jsr 	Dereference 				; dereference it.
.9954	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.9957	29 10		and #$10			and 	#NSTString
.9959	d0 f0		bne $994b			bne 	_ETTypeMismatch
.995b	4c 88 9e	jmp $9e88			jmp 	NSMNegate  					; just toggles the sign bit.
.995e					_ETDereference:
.995e	20 a2 98	jsr $98a2			jsr 	EvaluateTerm				; evaluate the term
.9961	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.9964	29 20		and #$20			and 	#NSBIsReference
.9966	f0 e3		beq $994b			beq 	_ETTypeMismatch
.9968	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.996b	60		rts				rts
.996c					_ETParenthesis:
.996c	20 c8 93	jsr $93c8			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.996f	20 00 8e	jsr $8e00			jsr 	CheckRightBracket 			; check for )
.9972	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9973					VariableHandler:
.9973	b1 30		lda ($30),y			lda 	(codePtr),y
.9975	18		clc				clc
.9976	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9978	85 37		sta $37				sta 	zTemp0+1
.997a	c8		iny				iny
.997b	b1 30		lda ($30),y			lda 	(codePtr),y
.997d	85 36		sta $36				sta 	zTemp0
.997f	c8		iny				iny
.9980	18		clc				clc									; copy variable address+3 to mantissa
.9981	69 03		adc #$03			adc 	#3
.9983	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9986	a5 37		lda $37				lda 	zTemp0+1
.9988	69 00		adc #$00			adc 	#0
.998a	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.998d	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9990	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9993	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9996	5a		phy				phy
.9997	a0 02		ldy #$02			ldy 	#2 							; read type
.9999	b1 36		lda ($36),y			lda 	(zTemp0),y
.999b	7a		ply				ply
.999c	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.999e	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.99a0	9d 00 04	sta $0400,x			sta 	NSStatus,x
.99a3	29 04		and #$04			and 	#NSBIsArray
.99a5	d0 01		bne $99a8			bne 	_VHArray
.99a7	60		rts				rts
.99a8					_VHArray:
.99a8	e8		inx				inx
.99a9	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; get the 1st index.
.99ac	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.99ae	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.99b1	b1 30		lda ($30),y			lda 	(codePtr),y
.99b3	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.99b5	d0 06		bne $99bd			bne 	_VHNoSecondIndex
.99b7	c8		iny				iny 								; skip the comma
.99b8	e8		inx				inx
.99b9	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.99bc	ca		dex				dex
.99bd					_VHNoSecondIndex:
.99bd	ca		dex				dex 								; set X back.
.99be	20 00 8e	jsr $8e00			jsr 	CheckRightBracket 			; and check the right bracket.
.99c1	5a		phy				phy 								; save position
.99c2	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.99c4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99c6	f0 6b		beq $9a33			beq 	_VHBadIndex
.99c8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.99cb	85 3e		sta $3e				sta 	zaTemp
.99cd	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.99d0	85 3f		sta $3f				sta 	zaTemp+1
.99d2	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.99d4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99d6	f0 02		beq $99da			beq 	_VHHas2Mask
.99d8	a9 ff		lda #$ff			lda 	#$FF
.99da					_VHHas2Mask:
.99da	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.99dd	f0 54		beq $9a33			beq 	_VHBadIndex
.99df	0a		asl a				asl 	a 							; carry will be set if a second index
.99e0	90 09		bcc $99eb			bcc 	_VHCheckFirstIndex
.99e2	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.99e4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99e6	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.99e9	90 48		bcc $9a33			bcc 	_VHBadIndex
.99eb					_VHCheckFirstIndex:
.99eb	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.99ed	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99ef	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.99f2	90 3f		bcc $9a33			bcc 	_VHBadIndex
.99f4	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.99f6	64 37		stz $37				stz 	zTemp0+1
.99f8	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99fb	30 0f		bmi $9a0c			bmi 	_VHNoMultiply
.99fd	da		phx				phx
.99fe	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9a01	48		pha				pha
.9a02	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9a04	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9a06	1a		inc a				inc 	a 							; add 1 for zero base
.9a07	fa		plx				plx
.9a08	20 71 9e	jsr $9e71			jsr 	Multiply8x8 				; calculate -> Z0
.9a0b	fa		plx				plx
.9a0c					_VHNoMultiply:
.9a0c	18		clc				clc
.9a0d	a5 36		lda $36				lda 	zTemp0
.9a0f	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9a12	85 36		sta $36				sta 	zTemp0
.9a14	a5 37		lda $37				lda 	zTemp0+1
.9a16	69 00		adc #$00			adc 	#0
.9a18	85 37		sta $37				sta 	zTemp0+1
.9a1a	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a1d	20 16 85	jsr $8516			jsr 	ScaleByBaseType
.9a20	18		clc				clc
.9a21	b2 3e		lda ($3e)			lda 	(zaTemp)
.9a23	65 36		adc $36				adc 	zTemp0
.9a25	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a28	a0 01		ldy #$01			ldy 	#1
.9a2a	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9a2c	65 37		adc $37				adc 	zTemp0+1
.9a2e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9a31	7a		ply				ply 								; restore position
.9a32	60		rts				rts
.9a33					_VHBadIndex:
.9a33	a9 17		lda #$17		lda	#23
.9a35	4c 19 8e	jmp $8e19		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9a38					AbsUnary:
.9a38	fa		plx				plx 								; restore stack pos
.9a39	20 05 9e	jsr $9e05			jsr 	EvaluateNumber 				; get a float or int
.9a3c	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.9a3f	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.9a42	29 7f		and #$7f			and 	#$7F
.9a44	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a47	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9a48					AllocUnary:
.9a48	fa		plx				plx 								; restore stack pos
.9a49	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger		; get bytes required.
.9a4c	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.9a4f	da		phx				phx 								; save X/Y
.9a50	5a		phy				phy
.9a51	8a		txa				txa 								; copy X into Y
.9a52	a8		tay				tay
.9a53	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.9a56	aa		tax				tax
.9a57	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.9a5a	20 67 9a	jsr $9a67			jsr 	AllocateXABytes 			; allocate memory
.9a5d	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.9a60	8a		txa				txa
.9a61	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.9a64	7a		ply				ply
.9a65	fa		plx				plx
.9a66	60		rts				rts
.9a67					AllocateXABytes:
.9a67	5a		phy				phy
.9a68	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a6b	84 36		sty $36				sty 	zTemp0
.9a6d	5a		phy				phy
.9a6e	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.9a71	84 37		sty $37				sty 	zTemp0+1
.9a73	5a		phy				phy
.9a74	18		clc				clc 								; add to low memory pointer
.9a75	6d 8c 04	adc $048c			adc 	lowMemPtr
.9a78	8d 8c 04	sta $048c			sta 	lowMemPtr
.9a7b	8a		txa				txa
.9a7c	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.9a7f	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.9a82	b0 2f		bcs $9ab3			bcs 	CISSMemory
.9a84	20 a5 9a	jsr $9aa5			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a87					_ClearMemory:
.9a87	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.9a8a	c5 36		cmp $36				cmp 	zTemp0
.9a8c	d0 07		bne $9a95			bne 	_CMClearNext
.9a8e	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.9a91	c5 37		cmp $37				cmp 	zTemp0+1
.9a93	f0 0c		beq $9aa1			beq 	_CMExit
.9a95					_CMClearNext:
.9a95	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a97	92 36		sta ($36)			sta 	(zTemp0)
.9a99	e6 36		inc $36				inc 	zTemp0
.9a9b	d0 ea		bne $9a87			bne 	_ClearMemory
.9a9d	e6 37		inc $37				inc		zTemp0+1
.9a9f	80 e6		bra $9a87			bra 	_ClearMemory
.9aa1					_CMExit:
.9aa1	fa		plx				plx
.9aa2	68		pla				pla
.9aa3	7a		ply				ply
.9aa4	60		rts				rts
.9aa5					CheckIdentifierStringSpace:
.9aa5	48		pha				pha
.9aa6	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.9aa9	18		clc				clc
.9aaa	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9aac	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.9aaf	b0 02		bcs $9ab3			bcs 	CISSMemory
.9ab1	68		pla				pla
.9ab2	60		rts				rts
.9ab3					CISSMemory:
.9ab3	a9 06		lda #$06		lda	#6
.9ab5	4c 19 8e	jmp $8e19		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9ab8					AscUnary:
.9ab8	fa		plx				plx 								; restore stack pos
.9ab9	20 10 9e	jsr $9e10			jsr 	EvaluateString 				; get a string
.9abc	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9abe	20 de 9e	jsr $9ede			jsr 	NSMSetByte
.9ac1	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.9ac4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9ac5					FracUnary:
.9ac5	fa		plx				plx 								; restore stack pos
.9ac6	20 05 9e	jsr $9e05			jsr 	EvaluateNumber 				; get a float or int
.9ac9	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.9acc	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9acf	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9ad1	f0 04		beq $9ad7			beq 	_IUZero
.9ad3	20 fb 94	jsr $94fb			jsr 	FloatFractionalPart
.9ad6	60		rts				rts
.9ad7					_IUZero:
.9ad7	20 dc 9e	jsr $9edc			jsr 	NSMSetZero
.9ada	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9adb					IntUnary:
.9adb	fa		plx				plx 								; restore stack pos
.9adc	20 05 9e	jsr $9e05			jsr 	EvaluateNumber 				; get a float or int
.9adf	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.9ae2	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ae5	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9ae7	f0 03		beq $9aec			beq 	_IUExit
.9ae9	20 5e 95	jsr $955e			jsr 	FloatIntegerPart
.9aec					_IUExit:
.9aec	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9aed					LenUnary:
.9aed	fa		plx				plx 								; restore stack pos
.9aee	20 10 9e	jsr $9e10			jsr 	EvaluateString 				; get a string
.9af1	5a		phy				phy
.9af2	a0 00		ldy #$00			ldy 	#0 							; find length
.9af4					_LenFind:
.9af4	b1 36		lda ($36),y			lda 	(zTemp0),y
.9af6	f0 06		beq $9afe			beq 	_LenExit
.9af8	c8		iny				iny
.9af9	d0 f9		bne $9af4			bne 	_LenFind
.9afb	4c 6b a0	jmp $a06b			jmp 	RangeError 					; string > 255
.9afe					_LenExit:
.9afe	98		tya				tya
.9aff	20 de 9e	jsr $9ede			jsr 	NSMSetByte
.9b02	7a		ply				ply
.9b03	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.9b06	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9b07					Unary_Min:
.9b07	a9 01		lda #$01			lda 	#1
.9b09	80 02		bra $9b0d			bra 	UnaryMinMaxMain
.9b0b					Unary_Max:
.9b0b	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9b0d					UnaryMinMaxMain:
.9b0d	fa		plx				plx 								; get index on number stack
.9b0e	48		pha				pha 								; save comparator
.9b0f	20 fc 9d	jsr $9dfc			jsr 	EvaluateValue 				; get the first value.
.9b12					_UMMMLoop:
.9b12	b1 30		lda ($30),y			lda 	(codePtr),y
.9b14	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9b16	f0 22		beq $9b3a			beq 	_UMMMDone
.9b18	20 08 8e	jsr $8e08			jsr 	CheckComma 					; must be a comma
.9b1b	e8		inx				inx
.9b1c	20 fc 9d	jsr $9dfc			jsr 	EvaluateValue
.9b1f	ca		dex				dex
.9b20	20 b3 9e	jsr $9eb3			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9b23	e8		inx				inx
.9b24	20 b3 9e	jsr $9eb3			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9b27	e8		inx				inx
.9b28	20 d1 8e	jsr $8ed1			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9b2b	ca		dex				dex
.9b2c	ca		dex				dex
.9b2d	85 36		sta $36				sta 	zTemp0 						; save required result
.9b2f	68		pla				pla 								; get and save comparator
.9b30	48		pha				pha
.9b31	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9b33	d0 dd		bne $9b12			bne 	_UMMMLoop
.9b35	20 3d 9b	jsr $9b3d			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9b38	80 d8		bra $9b12			bra 	_UMMMLoop
.9b3a					_UMMMDone:
.9b3a	68		pla				pla 								; throw the comparator
.9b3b	c8		iny				iny 								; skip )
.9b3c	60		rts				rts
.9b3d					ExpCopyAboveDown:
.9b3d	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9b40	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b43	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9b46	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9b49	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9b4c	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b4f	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9b52	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b55	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9b58	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b5b	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9b5e	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b61	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b62					Unary_Not:
.9b62	fa		plx				plx
.9b63	20 28 9e	jsr $9e28			jsr 	EvaluateInteger 			; get integer
.9b66	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.9b69	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; zero mantissa ?
.9b6c	f0 04		beq $9b72			beq 	_NotZero
.9b6e	20 dc 9e	jsr $9edc			jsr 	NSMSetZero
.9b71	60		rts				rts
.9b72					_NotZero:
.9b72	4c 86 8e	jmp $8e86			jmp 	ReturnTrue
.9b75					_UNBad:
.9b75	4c 75 a0	jmp $a075			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b78					Unary_Random:
.9b78	fa		plx				plx
.9b79	20 f7 9b	jsr $9bf7			jsr 	Random32Bit 				; get a random number
.9b7c	20 dc 9b	jsr $9bdc			jsr 	URCopyToMantissa  			; put in mantissa
.9b7f	b1 30		lda ($30),y			lda 	(codePtr),y
.9b81	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b83	f0 08		beq $9b8d			beq 	_URNoModulus
.9b85	e8		inx				inx
.9b86	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b89	ca		dex				dex
.9b8a	20 f5 8f	jsr $8ff5			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9b8d					_URNoModulus:
.9b8d	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9b90	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9b93	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.9b96	60		rts				rts
.9b97					Unary_Rnd:
.9b97	fa		plx				plx
.9b98	20 05 9e	jsr $9e05			jsr 	EvaluateNumber 				; number to use.
.9b9b	20 00 8e	jsr $8e00			jsr 	CheckRightBracket 			; closing bracket
.9b9e	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9ba1	f0 2b		beq $9bce			beq 	_URCopySeed
.9ba3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9ba6	10 23		bpl $9bcb			bpl 	_URDontSeed
.9ba8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9bab	49 17		eor #$17			eor 	#$17
.9bad	8d 88 04	sta $0488			sta 	RandomSeed+0
.9bb0	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9bb3	49 a5		eor #$a5			eor 	#$A5
.9bb5	8d 89 04	sta $0489			sta 	RandomSeed+1
.9bb8	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9bbb	49 c2		eor #$c2			eor 	#$C2
.9bbd	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9bc0	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9bc3	49 9d		eor #$9d			eor 	#$9D
.9bc5	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9bc8	20 f7 9b	jsr $9bf7			jsr 	Random32Bit
.9bcb					_URDontSeed:
.9bcb	20 f7 9b	jsr $9bf7			jsr 	Random32Bit 				; generate a number.
.9bce					_URCopySeed:
.9bce	20 dc 9b	jsr $9bdc			jsr 	URCopyToMantissa 			; copy into mantissa
.9bd1	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9bd3	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9bd6	a9 08		lda #$08			lda 	#NSTFloat
.9bd8	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; positive.
.9bdb	60		rts				rts
.9bdc					URCopyToMantissa:
.9bdc	ad 88 04	lda $0488			lda 	RandomSeed+0
.9bdf	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9be2	ad 89 04	lda $0489			lda 	RandomSeed+1
.9be5	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9be8	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9beb	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9bee	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9bf1	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9bf3	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9bf6	60		rts				rts
.9bf7					Random32Bit:
.9bf7	5a		phy				phy
.9bf8	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9bfa	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9bfd	d0 03		bne $9c02			bne 	_Random1
.9bff	a8		tay				tay 								; if so do it 256 times
.9c00	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9c02					_Random1:
.9c02	0a		asl a				asl 	a 							; LSFR RNG
.9c03	2e 89 04	rol $0489			rol 	RandomSeed+1
.9c06	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9c09	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9c0c	90 02		bcc $9c10			bcc 	_Random2
.9c0e	49 c5		eor #$c5			eor 	#$C5
.9c10					_Random2:
.9c10	88		dey				dey
.9c11	d0 ef		bne $9c02			bne 	_Random1
.9c13	8d 88 04	sta $0488			sta 	RandomSeed+0
.9c16	7a		ply				ply
.9c17	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9c18					SgnUnary:
.9c18	fa		plx				plx 								; restore stack pos
.9c19	20 05 9e	jsr $9e05			jsr 	EvaluateNumber 				; get a float or int
.9c1c	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.9c1f	20 0c 9f	jsr $9f0c			jsr 	NSMIsZero 					; if zero
.9c22	f0 10		beq $9c34			beq 	_SGZero  					; return Int Zero
.9c24	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9c27	48		pha				pha
.9c28	a9 01		lda #$01			lda 	#1 							; set to 1
.9c2a	20 de 9e	jsr $9ede			jsr 	NSMSetByte
.9c2d	68		pla				pla
.9c2e	29 80		and #$80			and		#$80 						; copy the sign byte out
.9c30	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c33	60		rts				rts
.9c34	20 dc 9e	jsr $9edc	_SGZero:jsr 	NSMSetZero
.9c37	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9c38					ValUnary:
.9c38	fa		plx				plx 								; restore stack pos
.9c39	20 4e 9c	jsr $9c4e			jsr 	ValMainCode 				; do the main val() code
.9c3c	b0 01		bcs $9c3f			bcs 	_VUError 					; couldn't convert
.9c3e	60		rts				rts
.9c3f					_VUError:
.9c3f	4c 70 a0	jmp $a070			jmp 	TypeError
.9c42					IsValUnary:
.9c42	fa		plx				plx 								; restore stack pos
.9c43	20 4e 9c	jsr $9c4e			jsr 	ValMainCode 				; do the main val() code
.9c46	b0 03		bcs $9c4b			bcs 	_VUBad
.9c48	4c 86 8e	jmp $8e86			jmp 	ReturnTrue
.9c4b					_VUBad:
.9c4b	4c 92 8e	jmp $8e92			jmp 	ReturnFalse
.9c4e					ValMainCode:
.9c4e	20 10 9e	jsr $9e10			jsr 	EvaluateString 				; get a string
.9c51	20 00 8e	jsr $8e00			jsr 	CheckRightBracket 			; check right bracket present
.9c54					ValEvaluateZTemp0:
.9c54	5a		phy				phy
.9c55	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9c57	f0 17		beq $9c70			beq 	_VMCFail2
.9c59	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9c5b	48		pha				pha 								; save first character
.9c5c	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9c5e	d0 01		bne $9c61			bne 	_VMCStart
.9c60	c8		iny				iny 								; skip over -
.9c61					_VMCStart:
.9c61	38		sec				sec 								; initialise first time round.
.9c62					_VMCNext:
.9c62	c8		iny				iny 								; pre-increment
.9c63	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9c65	f0 0c		beq $9c73			beq 	_VMCSuccess 				; successful.
.9c67	20 84 97	jsr $9784			jsr 	EncodeNumber 				; send it to the number-builder
.9c6a	90 03		bcc $9c6f			bcc 	_VMCFail 					; if failed, give up.
.9c6c	18		clc				clc 								; next time round, countinue
.9c6d	80 f3		bra $9c62			bra 	_VMCNext
.9c6f					_VMCFail:
.9c6f	68		pla				pla
.9c70					_VMCFail2:
.9c70	7a		ply				ply
.9c71	38		sec				sec
.9c72	60		rts				rts
.9c73					_VMCSuccess:
.9c73	a9 00		lda #$00			lda 	#0 							; construct final
.9c75	20 84 97	jsr $9784			jsr 	EncodeNumber
.9c78	68		pla				pla
.9c79	c9 2d		cmp #$2d			cmp 	#"-"
.9c7b	d0 03		bne $9c80			bne 	_VMCNotNegative
.9c7d	20 88 9e	jsr $9e88			jsr		NSMNegate
.9c80					_VMCNotNegative:
.9c80	7a		ply				ply
.9c81	18		clc				clc
.9c82	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c83					ChrUnary:
.9c83	fa		plx				plx 								; restore stack pos
.9c84	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger			; get value
.9c87	48		pha				pha
.9c88	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.9c8b	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c8d	20 58 a8	jsr $a858			jsr 	StringTempAllocate
.9c90	68		pla				pla 								; write number to it
.9c91	20 96 a8	jsr $a896			jsr 	StringTempWrite
.9c94	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c95					SpcUnary:
.9c95	fa		plx				plx 								; restore stack pos
.9c96	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger			; get value
.9c99	5a		phy				phy
.9c9a	48		pha				pha 								; save count
.9c9b	20 58 a8	jsr $a858			jsr 	StringTempAllocate
.9c9e	7a		ply				ply 								; to do count in Y
.9c9f					_SpcLoop:
.9c9f	c0 00		cpy #$00			cpy 	#0
.9ca1	f0 08		beq $9cab			beq 	_SpcExit
.9ca3	a9 20		lda #$20			lda 	#32
.9ca5	20 96 a8	jsr $a896			jsr 	StringTempWrite
.9ca8	88		dey				dey
.9ca9	80 f4		bra $9c9f			bra 	_SPCLoop
.9cab					_SpcExit:
.9cab	7a		ply				ply
.9cac	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.9caf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9cb0					Unary_Str:
.9cb0	fa		plx				plx
.9cb1	20 05 9e	jsr $9e05			jsr 	EvaluateNumber  			; get number
.9cb4	20 00 8e	jsr $8e00			jsr 	CheckRightBracket 			; closing bracket
.9cb7	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9cb9	20 d2 9c	jsr $9cd2			jsr 	ConvertNumberToString 		; do the conversion.
.9cbc	a9 21		lda #$21			lda		#33 						; create buffer
.9cbe	20 58 a8	jsr $a858			jsr 	StringTempAllocate 			; allocate memory
.9cc1	da		phx				phx
.9cc2	a2 00		ldx #$00			ldx 	#0
.9cc4					_USCopy:
.9cc4	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9cc7	20 96 a8	jsr $a896			jsr 	StringTempWrite
.9cca	e8		inx				inx
.9ccb	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9cce	d0 f4		bne $9cc4			bne 	_USCopy
.9cd0	fa		plx				plx
.9cd1	60		rts				rts
.9cd2					ConvertNumberToString:
.9cd2	5a		phy				phy 								; save code position
.9cd3	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9cd6	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9cd9	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9cdc	10 0a		bpl $9ce8			bpl 	_CNTSNotNegative
.9cde	29 7f		and #$7f			and 	#$7F 						; make +ve
.9ce0	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9ce3	a9 2d		lda #$2d			lda 	#"-"
.9ce5	20 4e 9d	jsr $9d4e			jsr 	WriteDecimalBuffer
.9ce8					_CNTSNotNegative:
.9ce8	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9ceb	f0 15		beq $9d02			beq 	_CNTSNotFloat
.9ced	e8		inx				inx 								; round up
.9cee	a9 01		lda #$01			lda 	#1
.9cf0	20 de 9e	jsr $9ede			jsr 	NSMSetByte
.9cf3	ca		dex				dex
.9cf4	bd 28 04	lda $0428,x			lda		NSExponent,x
.9cf7	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9cfa	a9 08		lda #$08			lda 	#NSTFloat
.9cfc	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9cff	20 15 94	jsr $9415			jsr 	FloatAdd
.9d02					_CNTSNotFloat:
.9d02	20 30 9d	jsr $9d30			jsr 	MakePlusTwoString
.9d05	20 fb 94	jsr $94fb			jsr 	FloatFractionalPart 		; get the fractional part
.9d08	20 bf 95	jsr $95bf			jsr 	NSNormalise					; normalise , exit if zero
.9d0b	f0 21		beq $9d2e			beq 	_CNTSExit
.9d0d	a9 2e		lda #$2e			lda 	#"."
.9d0f	20 4e 9d	jsr $9d4e			jsr 	WriteDecimalBuffer 			; write decimal place
.9d12					_CNTSDecimal:
.9d12	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9d15	30 17		bmi $9d2e			bmi 	_CNTSExit
.9d17	e8		inx				inx 								; x 10.0
.9d18	a9 0a		lda #$0a			lda 	#10
.9d1a	20 de 9e	jsr $9ede			jsr 	NSMSetByte
.9d1d	a9 08		lda #$08			lda 	#NSTFloat
.9d1f	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9d22	ca		dex				dex
.9d23	20 88 95	jsr $9588			jsr 	FloatMultiply
.9d26	20 30 9d	jsr $9d30			jsr 	MakePlusTwoString
.9d29	20 fb 94	jsr $94fb			jsr 	FloatFractionalPart 		; get the fractional part
.9d2c	80 e4		bra $9d12			bra 	_CNTSDecimal 				; keep going.
.9d2e					_CNTSExit:
.9d2e	7a		ply				ply
.9d2f	60		rts				rts
.9d30					MakePlusTwoString:
.9d30	da		phx				phx
.9d31	20 b3 9e	jsr $9eb3			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9d34	e8		inx				inx 								; access it
.9d35	e8		inx				inx
.9d36	20 5e 95	jsr $955e			jsr 	FloatIntegerPart 			; make it an integer
.9d39	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9d3b	20 40 93	jsr $9340			jsr 	ConvertInt32
.9d3e	a2 00		ldx #$00			ldx	 	#0
.9d40					_MPTSCopy:
.9d40	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d43	20 4e 9d	jsr $9d4e			jsr 	WriteDecimalBuffer
.9d46	e8		inx				inx
.9d47	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d4a	d0 f4		bne $9d40			bne 	_MPTSCopy
.9d4c	fa		plx				plx
.9d4d	60		rts				rts
.9d4e					WriteDecimalBuffer:
.9d4e	da		phx				phx
.9d4f	ae 95 04	ldx $0495			ldx 	dbOffset
.9d52	9d 1c 06	sta $061c,x			sta 	DecimalBuffer,x
.9d55	9e 1d 06	stz $061d,x			stz 	DecimalBuffer+1,x
.9d58	ee 95 04	inc $0495			inc 	dbOffset
.9d5b	fa		plx				plx
.9d5c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9d5d					Unary_Left:
.9d5d	fa		plx				plx
.9d5e	18		clc				clc 								; only one parameter
.9d5f	20 d4 9d	jsr $9dd4			jsr 	SubstringInitial 			; set up.
.9d62	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9d65	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d68	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9d6b	80 2c		bra $9d99			bra 	SubstringMain
.9d6d					Unary_Right:
.9d6d	fa		plx				plx
.9d6e	18		clc				clc 								; only one parameter
.9d6f	20 d4 9d	jsr $9dd4			jsr 	SubstringInitial 			; set up.
.9d72	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9d75	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d78	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9d7b	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d7e	b0 02		bcs $9d82			bcs 	_URNotUnderflow
.9d80	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d82					_URNotUnderFlow:
.9d82	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d85	80 12		bra $9d99			bra 	SubStringMain
.9d87					Unary_Mid:
.9d87	fa		plx				plx
.9d88	38		sec				sec 								; two parameters
.9d89	20 d4 9d	jsr $9dd4			jsr 	SubstringInitial 			; set up.
.9d8c	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d8f	f0 05		beq $9d96			beq 	_UMError
.9d91	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d94	80 03		bra $9d99			bra 	SubStringMain
.9d96					_UMError:
.9d96	4c 75 a0	jmp $a075			jmp 	ArgumentError
.9d99					SubStringMain:
.9d99	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d9c	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9d9f	b0 2d		bcs $9dce			bcs 	_SSMNull 					; if so, return an empty string.
.9da1	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9da4	f0 28		beq $9dce			beq 	_SSMNull 					; return empty string.
.9da6	18		clc				clc 								; add the offset +1 to the address and
.9da7	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9daa	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9dad	85 36		sta $36				sta 	zTemp0
.9daf	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9db2	69 00		adc #$00			adc 	#0
.9db4	85 37		sta $37				sta 	zTemp0+1
.9db6					_SSMNoCarry:
.9db6	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9db9	20 58 a8	jsr $a858			jsr 	StringTempAllocate 			; allocate that many characters
.9dbc	5a		phy				phy 								; save Y
.9dbd	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9dbf					_SSMCopy:
.9dbf	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9dc1	f0 09		beq $9dcc			beq 	_SSMEString 				; no more to copy
.9dc3	20 96 a8	jsr $a896			jsr 	StringTempWrite 			; and write it out.
.9dc6	c8		iny				iny
.9dc7	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9dca	d0 f3		bne $9dbf			bne 	_SSMCopy
.9dcc					_SSMEString:
.9dcc	7a		ply				ply
.9dcd					_SSMExit:
.9dcd	60		rts				rts
.9dce					_SSMNull:
.9dce	a9 00		lda #$00			lda 	#0
.9dd0	20 58 a8	jsr $a858			jsr 	StringTempAllocate
.9dd3	60		rts				rts
.9dd4					SubstringInitial:
.9dd4	da		phx				phx 								; save initial stack position
.9dd5	08		php				php 								; save carry on stack indicating 2 parameters
.9dd6	20 10 9e	jsr $9e10			jsr 	EvaluateString 				; get a string
.9dd9	5a		phy				phy 								; calculate length to exponent.
.9dda	a0 ff		ldy #$ff			ldy 	#$FF
.9ddc					_SIFindLength:
.9ddc	c8		iny				iny
.9ddd	b1 36		lda ($36),y			lda 	(zTemp0),y
.9ddf	d0 fb		bne $9ddc			bne 	_SIFindLength
.9de1	98		tya				tya
.9de2	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9de5	7a		ply				ply
.9de6	e8		inx				inx
.9de7	20 08 8e	jsr $8e08			jsr 	CheckComma 					; comma next
.9dea	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; get next parameter
.9ded	28		plp				plp 								; is it the last parameter ?
.9dee	90 07		bcc $9df7			bcc 	_SSIExit 					; if so, exit.
.9df0	e8		inx				inx
.9df1	20 08 8e	jsr $8e08			jsr 	CheckComma 					; comma next
.9df4	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; get last parameter
.9df7					_SSIExit:
.9df7	fa		plx				plx
.9df8	20 00 8e	jsr $8e00			jsr 	CheckRightBracket 			; check closing bracket
.9dfb	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9dfc					EvaluateValue:
.9dfc	48		pha				pha
.9dfd	20 c8 93	jsr $93c8			jsr		EvaluateExpression 			; expression
.9e00	20 e6 96	jsr $96e6			jsr 	Dereference					; derefernce it
.9e03	68		pla				pla
.9e04	60		rts				rts
.9e05					EvaluateNumber:
.9e05	20 fc 9d	jsr $9dfc			jsr 	EvaluateValue 				; get a value
.9e08	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9e0b	29 10		and #$10			and 	#NSBIsString
.9e0d	d0 16		bne $9e25			bne 	HelperTypeError
.9e0f	60		rts				rts
.9e10					EvaluateString:
.9e10	20 fc 9d	jsr $9dfc			jsr 	EvaluateValue 				; get a value
.9e13	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9e16	29 10		and #$10			and 	#NSBIsString
.9e18	f0 0b		beq $9e25			beq 	HelperTypeError
.9e1a					CopyAddressToTemp0:
.9e1a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9e1d	85 36		sta $36				sta 	zTemp0
.9e1f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e22	85 37		sta $37				sta 	zTemp0+1
.9e24	60		rts				rts
.9e25					HelperTypeError:
.9e25	4c 70 a0	jmp $a070			jmp 	TypeError
.9e28					EvaluateInteger:
.9e28	20 05 9e	jsr $9e05			jsr 	EvaluateNumber
.9e2b	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9e2e	d0 0a		bne $9e3a			bne 	HelperValueError 			; if not, it's a float.
.9e30	60		rts				rts
.9e31					EvaluateUnsignedInteger:
.9e31	20 28 9e	jsr $9e28			jsr 	EvaluateInteger 			; check integer is +ve
.9e34	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e37	30 01		bmi $9e3a			bmi 	HelperValueError
.9e39	60		rts				rts
.9e3a					HelperValueError:
.9e3a	4c 75 a0	jmp $a075			jmp 	ArgumentError
.9e3d					Evaluate16BitInteger:
.9e3d	20 31 9e	jsr $9e31			jsr	 	EvaluateUnsignedInteger		; get integer
.9e40	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e43	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e46	d0 f2		bne $9e3a			bne 	HelperValueError
.9e48	60		rts				rts
.9e49					Evaluate16BitIntegerSigned:
.9e49	20 28 9e	jsr $9e28			jsr	 	EvaluateInteger				; get integer
.9e4c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e4f	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e52	d0 e6		bne $9e3a			bne 	HelperValueError
.9e54	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9e57	10 03		bpl $9e5c			bpl 	_EISNotSigned
.9e59	20 91 9e	jsr $9e91			jsr 	NSMNegateMantissa
.9e5c					_EISNotSigned:
.9e5c	60		rts				rts
.9e5d					Evaluate8BitInteger:
.9e5d	20 31 9e	jsr $9e31			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9e60	d0 d8		bne $9e3a			bne 	HelperValueError
.9e62	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9e65	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e68	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9e6b	d0 cd		bne $9e3a			bne 	HelperValueError
.9e6d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e70	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9e71					Multiply8x8:
.9e71	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9e72	85 36		sta $36			  	sta 	zTemp0
.9e74	86 37		stx $37				stx 	zTemp0+1
.9e76	a9 00		lda #$00			lda 	#0
.9e78	a2 08		ldx #$08			ldx 	#8
.9e7a					_M88Loop:
.9e7a	90 03		bcc $9e7f			bcc 	_M88NoAdd
.9e7c	18		clc				clc
.9e7d	65 37		adc $37				adc 	zTemp0+1
.9e7f					_M88NoAdd:
.9e7f	6a		ror a				ror 	a
.9e80	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9e82	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9e83	d0 f5		bne $9e7a			bne 	_M88Loop
.9e85	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9e87	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9e88					NSMNegate:
.9e88	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e8b	49 80		eor #$80			eor 	#NSBIsNegative
.9e8d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9e90	60		rts				rts
.9e91					NSMNegateMantissa:
.9e91	38		sec				sec
.9e92	a9 00		lda #$00			lda 	#0
.9e94	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9e97	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9e9a	a9 00		lda #$00			lda 	#0
.9e9c	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9e9f	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9ea2	a9 00		lda #$00			lda 	#0
.9ea4	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9ea7	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9eaa	a9 00		lda #$00			lda 	#0
.9eac	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9eaf	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9eb2	60		rts				rts
.9eb3					NSMShiftUpTwo:
.9eb3	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9eb6	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9eb9	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9ebc	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9ebf	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9ec2	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9ec5	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9ec8	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9ecb	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9ece	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9ed1	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ed4	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9ed7	60		rts				rts
.9ed8					NSMSetZeroMantissaOnly:
.9ed8	a9 00		lda #$00			lda 	#0
.9eda	80 08		bra $9ee4			bra 	NSMSetMantissa
.9edc					NSMSetZero:
.9edc	a9 00		lda #$00			lda 	#0
.9ede					NSMSetByte:
.9ede	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9ee1	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9ee4					NSMSetMantissa:
.9ee4	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9ee7	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9eea	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9eed	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9ef0	60		rts				rts
.9ef1					NSMShiftLeft:
.9ef1	18		clc				clc
.9ef2					NSMRotateLeft:
.9ef2	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9ef5	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9ef8	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9efb	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9efe	60		rts				rts
.9eff					NSMShiftRight:
.9eff	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9f02	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9f05	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9f08	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9f0b	60		rts				rts
.9f0c					NSMIsZero:
.9f0c	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9f0f	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9f12	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9f15	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9f18	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.bac0					TickHandler:
.bac0	5a		phy				phy 								; need to preserve Y
.bac1	20 66 ba	jsr $ba66			jsr 	SNDUpdate 					; update sound
.bac4	7a		ply				ply
.bac5	60		rts				rts
.062e					LastTick:
>062e							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9f19					Assemble_ora:
.9f19	20 6d 80	jsr $806d		jsr	AssembleGroup1
>9f1c	01					.byte $01
.9f1d					Assemble_and:
.9f1d	20 6d 80	jsr $806d		jsr	AssembleGroup1
>9f20	21					.byte $21
.9f21					Assemble_eor:
.9f21	20 6d 80	jsr $806d		jsr	AssembleGroup1
>9f24	41					.byte $41
.9f25					Assemble_adc:
.9f25	20 6d 80	jsr $806d		jsr	AssembleGroup1
>9f28	61					.byte $61
.9f29					Assemble_sta:
.9f29	20 6d 80	jsr $806d		jsr	AssembleGroup1
>9f2c	81					.byte $81
.9f2d					Assemble_lda:
.9f2d	20 6d 80	jsr $806d		jsr	AssembleGroup1
>9f30	a1					.byte $a1
.9f31					Assemble_cmp:
.9f31	20 6d 80	jsr $806d		jsr	AssembleGroup1
>9f34	c1					.byte $c1
.9f35					Assemble_sbc:
.9f35	20 6d 80	jsr $806d		jsr	AssembleGroup1
>9f38	e1					.byte $e1
.9f39					Assemble_asl:
.9f39	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f3c	02					.byte $02
>9f3d	75					.byte $75
.9f3e					Assemble_rol:
.9f3e	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f41	22					.byte $22
>9f42	75					.byte $75
.9f43					Assemble_lsr:
.9f43	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f46	42					.byte $42
>9f47	75					.byte $75
.9f48					Assemble_ror:
.9f48	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f4b	62					.byte $62
>9f4c	75					.byte $75
.9f4d					Assemble_stx:
.9f4d	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f50	82					.byte $82
>9f51	50					.byte $50
.9f52					Assemble_ldx:
.9f52	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f55	a2					.byte $a2
>9f56	d0					.byte $d0
.9f57					Assemble_dec:
.9f57	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f5a	c2					.byte $c2
>9f5b	55					.byte $55
.9f5c					Assemble_inc:
.9f5c	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f5f	e2					.byte $e2
>9f60	55					.byte $55
.9f61					Assemble_stz:
.9f61	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f64	60					.byte $60
>9f65	44					.byte $44
.9f66					Assemble_bit:
.9f66	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f69	20					.byte $20
>9f6a	55					.byte $55
.9f6b					Assemble_sty:
.9f6b	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f6e	80					.byte $80
>9f6f	54					.byte $54
.9f70					Assemble_ldy:
.9f70	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f73	a0					.byte $a0
>9f74	d5					.byte $d5
.9f75					Assemble_cpy:
.9f75	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f78	c0					.byte $c0
>9f79	d4					.byte $d4
.9f7a					Assemble_cpx:
.9f7a	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f7d	e0					.byte $e0
>9f7e	d0					.byte $d0
.9f7f					Assemble_tsb:
.9f7f	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f82	00					.byte $00
>9f83	50					.byte $50
.9f84					Assemble_trb:
.9f84	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f87	10					.byte $10
>9f88	50					.byte $50
.9f89					Assemble_jsr:
.9f89	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f8c	14					.byte $14
>9f8d	10					.byte $10
.9f8e					Assemble_jmp:
.9f8e	20 74 80	jsr $8074		jsr	AssembleGroup2
>9f91	40					.byte $40
>9f92	10					.byte $10
.9f93					Assemble_bpl:
.9f93	20 c5 80	jsr $80c5		jsr	AssembleGroup3
>9f96	10					.byte $10
.9f97					Assemble_bmi:
.9f97	20 c5 80	jsr $80c5		jsr	AssembleGroup3
>9f9a	30					.byte $30
.9f9b					Assemble_bvc:
.9f9b	20 c5 80	jsr $80c5		jsr	AssembleGroup3
>9f9e	50					.byte $50
.9f9f					Assemble_bvs:
.9f9f	20 c5 80	jsr $80c5		jsr	AssembleGroup3
>9fa2	70					.byte $70
.9fa3					Assemble_bcc:
.9fa3	20 c5 80	jsr $80c5		jsr	AssembleGroup3
>9fa6	90					.byte $90
.9fa7					Assemble_bcs:
.9fa7	20 c5 80	jsr $80c5		jsr	AssembleGroup3
>9faa	b0					.byte $b0
.9fab					Assemble_bne:
.9fab	20 c5 80	jsr $80c5		jsr	AssembleGroup3
>9fae	d0					.byte $d0
.9faf					Assemble_beq:
.9faf	20 c5 80	jsr $80c5		jsr	AssembleGroup3
>9fb2	f0					.byte $f0
.9fb3					Assemble_bra:
.9fb3	20 c5 80	jsr $80c5		jsr	AssembleGroup3
>9fb6	80					.byte $80
.9fb7					Assemble_brk:
.9fb7	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fba	00					.byte $00
.9fbb					Assemble_php:
.9fbb	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fbe	08					.byte $08
.9fbf					Assemble_clc:
.9fbf	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fc2	18					.byte $18
.9fc3					Assemble_plp:
.9fc3	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fc6	28					.byte $28
.9fc7					Assemble_sec:
.9fc7	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fca	38					.byte $38
.9fcb					Assemble_rti:
.9fcb	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fce	40					.byte $40
.9fcf					Assemble_pha:
.9fcf	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fd2	48					.byte $48
.9fd3					Assemble_cli:
.9fd3	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fd6	58					.byte $58
.9fd7					Assemble_phy:
.9fd7	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fda	5a					.byte $5a
.9fdb					Assemble_rts:
.9fdb	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fde	60					.byte $60
.9fdf					Assemble_pla:
.9fdf	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fe2	68					.byte $68
.9fe3					Assemble_sei:
.9fe3	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fe6	78					.byte $78
.9fe7					Assemble_ply:
.9fe7	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fea	7a					.byte $7a
.9feb					Assemble_dey:
.9feb	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9fee	88					.byte $88
.9fef					Assemble_txa:
.9fef	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9ff2	8a					.byte $8a
.9ff3					Assemble_tya:
.9ff3	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9ff6	98					.byte $98
.9ff7					Assemble_txs:
.9ff7	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9ffa	9a					.byte $9a
.9ffb					Assemble_tay:
.9ffb	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>9ffe	a8					.byte $a8
.9fff					Assemble_tax:
.9fff	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>a002	aa					.byte $aa
.a003					Assemble_clv:
.a003	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>a006	b8					.byte $b8
.a007					Assemble_tsx:
.a007	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>a00a	ba					.byte $ba
.a00b					Assemble_iny:
.a00b	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>a00e	c8					.byte $c8
.a00f					Assemble_dex:
.a00f	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>a012	ca					.byte $ca
.a013					Assemble_cld:
.a013	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>a016	d8					.byte $d8
.a017					Assemble_phx:
.a017	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>a01a	da					.byte $da
.a01b					Assemble_stp:
.a01b	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>a01e	db					.byte $db
.a01f					Assemble_inx:
.a01f	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>a022	e8					.byte $e8
.a023					Assemble_nop:
.a023	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>a026	ea					.byte $ea
.a027					Assemble_sed:
.a027	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>a02a	f8					.byte $f8
.a02b					Assemble_plx:
.a02b	20 fb 80	jsr $80fb		jsr	AssembleGroup4
>a02e	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.a02f					DecimalScalarTable:
>a02f	66 66 66 66				.dword $66666666 ; 0.1
>a033	de					.byte $de
>a034	1f 85 eb 51				.dword $51eb851f ; 0.01
>a038	db					.byte $db
>a039	4c 37 89 41				.dword $4189374c ; 0.001
>a03d	d8					.byte $d8
>a03e	ac 8b db 68				.dword $68db8bac ; 0.0001
>a042	d4					.byte $d4
>a043	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>a047	d1					.byte $d1
>a048	83 de 1b 43				.dword $431bde83 ; 1e-06
>a04c	ce					.byte $ce
>a04d	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>a051	ca					.byte $ca
>a052	89 3b e6 55				.dword $55e63b89 ; 1e-08
>a056	c7					.byte $c7
>a057	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>a05b	c4					.byte $c4
>a05c	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>a060	c0					.byte $c0
>a061	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>a065	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.a066					SyntaxError:
.a066	a9 02		lda #$02		lda	#2
.a068	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.a06b					RangeError:
.a06b	a9 04		lda #$04		lda	#4
.a06d	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.a070					TypeError:
.a070	a9 05		lda #$05		lda	#5
.a072	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.a075					ArgumentError:
.a075	a9 07		lda #$07		lda	#7
.a077	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.a07a					NotDoneError:
.a07a	a9 0c		lda #$0c		lda	#12
.a07c	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.a07f					ErrorText:
>a07f	42 72 65 61 6b 00			.text	"Break",0
>a085	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a08d	72 72 6f 72 00
>a092	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a09a	20 62 79 20 7a 65 72 6f 00
>a0a3	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a0ab	61 6e 67 65 00
>a0b0	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a0b8	6d 61 74 63 68 00
>a0be	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a0c6	65 6d 6f 72 79 00
>a0cc	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a0d4	61 72 67 75 6d 65 6e 74 00
>a0dd	53 74 6f 70 00				.text	"Stop",0
>a0e2	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a0ea	6f 6f 20 6c 6f 6e 67 00
>a0f2	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a0fa	6e 20 66 61 69 6c 65 64 00
>a103	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a10b	61 74 61 00
>a10f	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a117	65 6e 74 65 64 00
>a11d	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a125	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a131	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a139	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a146	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a14e	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a15b	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a163	68 6f 75 74 20 57 68 69 6c 65 00
>a16e	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a176	68 6f 75 74 20 46 6f 72 00
>a17f	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a187	61 63 6b 20 66 75 6c 6c 00
>a190	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a198	75 63 74 75 72 65 00
>a19f	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a1a7	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a1b4	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a1bc	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a1ca	41 72 72 61 79 20 73 69			.text	"Array size",0
>a1d2	7a 65 00
>a1d5	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a1dd	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a1e5	42 75 69 6c 74 20 54 68			.text "Built Thursday 24-Nov-2022. Build 3587."
>a1ed	75 72 73 64 61 79 20 32 34 2d 4e 6f 76 2d 32 30
>a1fd	32 32 2e 20 42 75 69 6c 64 20 33 35 38 37 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a20c					RectangleCommand:
.a20c	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a20e	80 02		bra $a212			bra 	ShapeDrawCmd
.a210					CircleCommand:
.a210	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a212					ShapeDrawCmd:
.a212	20 a0 a2	jsr $a2a0			jsr 	RunGraphicsCommand
.a215					ShapeDraw:
.a215	0d 30 06	ora $0630			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a218	4c 94 a2	jmp $a294			jmp 	ExecuteGraphicCommand	 	; and complete
.a21b					SpriteCommand:
.a21b	a2 00		ldx #$00			ldx 	#0
.a21d	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; get image number.
.a220	5a		phy				phy
.a221	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a223	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a226	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a228	b0 0d		bcs $a237			bcs 	_SCRange
.a22a	a0 ff		ldy #$ff			ldy 	#255
.a22c	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a22f	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a231	7a		ply				ply
.a232	20 a0 a2	jsr $a2a0			jsr 	RunGraphicsCommand
.a235	80 5d		bra $a294			bra 	ExecuteGraphicCommand
.a237					_SCRange:
.a237	4c 6b a0	jmp $a06b			jmp 	RangeError
.a23a					ImageCommand:
.a23a	a2 00		ldx #$00			ldx 	#0
.a23c	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; get image number.
.a23f	20 a0 a2	jsr $a2a0			jsr 	RunGraphicsCommand
.a242					ImageRunDraw:
.a242	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a244	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a247	ad 36 06	lda $0636			lda 	gxDrawScale
.a24a	0a		asl a				asl 	a
.a24b	0a		asl a				asl 	a
.a24c	0a		asl a				asl 	a
.a24d	a8		tay				tay
.a24e	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a250	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a253	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a256	60		rts				rts
.a257					TextCommand:
.a257	a2 00		ldx #$00			ldx 	#0
.a259	20 10 9e	jsr $9e10			jsr 	EvaluateString 				; get text
.a25c	20 a0 a2	jsr $a2a0			jsr 	RunGraphicsCommand
.a25f					TextRunDraw:
.a25f	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a261	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a264	a0 00		ldy #$00			ldy 	#0
.a266					_IRDLoop:
.a266	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a269	85 37		sta $37				sta 	zTemp0+1
.a26b	ad 08 04	lda $0408			lda 	NSMantissa0
.a26e	85 36		sta $36				sta 	zTemp0
.a270	b1 36		lda ($36),y			lda 	(zTemp0),y
.a272	f0 13		beq $a287			beq 	_IRDExit
.a274	5a		phy				phy									; save string pos
.a275	48		pha				pha 								; save char
.a276	ad 36 06	lda $0636			lda 	gxDrawScale 				; get scale
.a279	0a		asl a				asl 	a
.a27a	0a		asl a				asl 	a
.a27b	0a		asl a				asl 	a
.a27c	a8		tay				tay
.a27d	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a27f	fa		plx				plx 								; char to draw
.a280	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a283	7a		ply				ply 								; restore string pos
.a284	c8		iny				iny
.a285	90 df		bcc $a266			bcc 	_IRDLoop 					; go back if no error.
.a287					_IRDExit:
.a287	60		rts				rts
.a288					PlotCommand:
.a288	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a28a	20 a0 a2	jsr $a2a0			jsr 	RunGraphicsCommand
.a28d	80 05		bra $a294			bra 	ExecuteGraphicCommand
.a28f					LineCommand:
.a28f	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a291	20 a0 a2	jsr $a2a0			jsr 	RunGraphicsCommand
.a294					ExecuteGraphicCommand:
.a294	0d 2f 06	ora $062f			ora 	gxCommandID 				; make a full command
.a297	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw 				; draw it and exit
.a29a	b0 01		bcs $a29d			bcs 	_EGCError
.a29c	60		rts				rts
.a29d					_EGCError:
.a29d	4c 66 a0	jmp $a066			jmp 	SyntaxError
.a2a0					RunGraphicsCommand:
.a2a0	8d 2f 06	sta $062f			sta 	gxCommandID					; save TODO graphics command.
.a2a3	68		pla				pla 								; pop handler address
.a2a4	fa		plx				plx
.a2a5	1a		inc a				inc 	a
.a2a6	d0 01		bne $a2a9			bne 	_RGINoCarry
.a2a8	e8		inx				inx
.a2a9					_RGINoCarry:
.a2a9	8d 34 06	sta $0634			sta 	GXHandler
.a2ac	8e 35 06	stx $0635			stx 	GXHandler+1
.a2af					_RGICommandLoop:
.a2af	b1 30		lda ($30),y			lda 	(codePtr),y
.a2b1	c8		iny				iny
.a2b2	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a2b4	f0 53		beq $a309			beq 	_RGI_To
.a2b6	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a2b8	f0 55		beq $a30f			beq 	_RGI_Here
.a2ba	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a2bc	f0 3d		beq $a2fb			beq 	_RGI_Exit
.a2be	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a2c0	f0 39		beq $a2fb			beq 	_RGI_Exit
.a2c2	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a2c4	f0 3e		beq $a304			beq 	_RGI_Frame
.a2c6	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a2c8	f0 33		beq $a2fd			beq 	_RGI_Solid
.a2ca	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a2cc	f0 4b		beq $a319			beq 	_RGI_By
.a2ce	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a2d0	f0 17		beq $a2e9			beq 	_RGI_Move2
.a2d2	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a2d4	f0 65		beq $a33b			beq 	_RGI_Dim
.a2d6	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a2d8	f0 78		beq $a352			beq 	_RGI_Colour
.a2da	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a2dc	f0 74		beq $a352			beq 	_RGI_Colour
.a2de	ae 2f 06	ldx $062f			ldx 	gxCommandID
.a2e1	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a2e3	d0 03		bne $a2e8			bne 	_RGI_Move 					; move
.a2e5	4c 7c a3	jmp $a37c			jmp		_RGI_SpriteInstructions
.a2e8					_RGI_Move:
.a2e8	88		dey				dey 								; unpick get.
.a2e9					_RGI_Move2:
.a2e9	20 a2 a3	jsr $a3a2			jsr 	GCGetCoordinatePair 		; move to here
.a2ec	20 c9 a3	jsr $a3c9			jsr 	GCCopyPairToStore 			; save
.a2ef	5a		phy				phy
.a2f0	20 bf a3	jsr $a3bf			jsr 	GCLoadAXY 					; load in
.a2f3	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a2f5	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a2f8	7a		ply				ply
.a2f9	80 b4		bra $a2af			bra 	_RGICommandLoop 			; and go round
.a2fb					_RGI_Exit:
.a2fb	88		dey				dey 								; unpick : / EOL
.a2fc	60		rts				rts
.a2fd					_RGI_Solid:
.a2fd	a9 02		lda #$02			lda 	#2
.a2ff	8d 30 06	sta $0630			sta 	gxFillSolid
.a302	80 ab		bra $a2af			bra 	_RGICommandLoop
.a304					_RGI_Frame:
.a304	9c 30 06	stz $0630			stz 	gxFillSolid
.a307	80 a6		bra $a2af			bra 	_RGICommandLoop
.a309					_RGI_To:
.a309	20 a2 a3	jsr $a3a2			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a30c	20 c9 a3	jsr $a3c9			jsr 	GCCopyPairToStore
.a30f					_RGI_Here:
.a30f	5a		phy				phy
.a310	20 bf a3	jsr $a3bf			jsr 	GCLoadAXY 					; load it into AXY
.a313	20 79 a3	jsr $a379			jsr 	_RGICallHandler 			; go do whatever it is.
.a316	7a		ply				ply
.a317	80 96		bra $a2af			bra 	_RGICommandLoop 			; and go round
.a319					_RGI_By:
.a319	20 af a3	jsr $a3af			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a31c	18		clc				clc
.a31d	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a320	6d 31 06	adc $0631			adc 	gxxPos
.a323	8d 31 06	sta $0631			sta 	gxXPos
.a326	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a329	6d 32 06	adc $0632			adc 	gxxPos+1
.a32c	8d 32 06	sta $0632			sta 	gxXPos+1
.a32f	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a332	18		clc				clc
.a333	6d 33 06	adc $0633			adc 	gxYPos
.a336	8d 33 06	sta $0633			sta 	gxYPos
.a339	80 d4		bra $a30f			bra 	_RGI_Here
.a33b					_RGI_Dim:
.a33b	a2 01		ldx #$01			ldx	 	#1
.a33d	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger
.a340	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a343	c9 00		cmp #$00			cmp 	#0
.a345	f0 2f		beq $a376			beq 	_RGIRange
.a347	c9 09		cmp #$09			cmp 	#8+1
.a349	b0 2b		bcs $a376			bcs		_RGIRange
.a34b	3a		dec a				dec 	a
.a34c	8d 36 06	sta $0636			sta 	gxDrawScale
.a34f	4c af a2	jmp $a2af			jmp 	_RGICommandLoop
.a352					_RGI_Colour:
.a352	a2 01		ldx #$01			ldx 	#1 							; colour
.a354	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger
.a357	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a359	20 dc 9e	jsr $9edc			jsr 	NSMSetZero
.a35c	b1 30		lda ($30),y			lda 	(codePtr),y
.a35e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a360	d0 04		bne $a366			bne 	_RGICDefaultMode
.a362	c8		iny				iny
.a363	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger
.a366					_RGICDefaultMode:
.a366	5a		phy				phy
.a367	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a369	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a36c	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a36f	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a372	7a		ply				ply
.a373	4c af a2	jmp $a2af			jmp 	_RGICommandLoop 			; and go round
.a376					_RGIRange:
.a376	4c 6b a0	jmp $a06b			jmp 	RangeError
.a379					_RGICallHandler:
.a379	6c 34 06	jmp ($0634)			jmp 	(GXHandler)
.a37c					_RGI_SpriteInstructions:
.a37c	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a37e	f0 07		beq $a387			beq 	_RGISpriteOff
.a380	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a382	f0 13		beq $a397			beq 	_RGISetImage
.a384	4c e8 a2	jmp $a2e8			jmp 	_RGI_Move
.a387					_RGISpriteOff:
.a387	5a		phy				phy
.a388	a0 01		ldy #$01			ldy 	#1
.a38a	a2 00		ldx #$00			ldx 	#0
.a38c					_RGIDoCommandLoop:
.a38c	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a38e	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a391	7a		ply				ply
.a392	b0 e2		bcs $a376			bcs 	_RGIRange
.a394	4c af a2	jmp $a2af			jmp 	_RGICommandLoop
.a397					_RGISetImage:
.a397	a2 01		ldx #$01			ldx 	#1
.a399	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger
.a39c	5a		phy				phy
.a39d	aa		tax				tax
.a39e	a0 00		ldy #$00			ldy 	#0
.a3a0	80 ea		bra $a38c			bra 	_RGIDoCommandLoop
.a3a2					GCGetCoordinatePair:
.a3a2	a2 01		ldx #$01			ldx 	#1
.a3a4	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger
.a3a7	20 08 8e	jsr $8e08			jsr 	CheckComma
.a3aa	e8		inx				inx
.a3ab	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger
.a3ae	60		rts				rts
.a3af					GCSignedCoordinatePair:
.a3af	a2 01		ldx #$01			ldx 	#1
.a3b1	20 49 9e	jsr $9e49			jsr 	Evaluate16BitIntegerSigned
.a3b4	20 08 8e	jsr $8e08			jsr 	CheckComma
.a3b7	e8		inx				inx
.a3b8	20 49 9e	jsr $9e49			jsr 	Evaluate16BitIntegerSigned
.a3bb	60		rts				rts
.a3bc					_GCCPRange:
.a3bc	4c 6b a0	jmp $a06b			jmp 	RangeError
.a3bf					GCLoadAXY:
.a3bf	ad 32 06	lda $0632			lda 	gxXPos+1
.a3c2	ae 31 06	ldx $0631			ldx 	gxXPos
.a3c5	ac 33 06	ldy $0633			ldy 	gxYPos
.a3c8	60		rts				rts
.a3c9					GCCopyPairToStore:
.a3c9	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a3cc	8d 31 06	sta $0631			sta 	gxXPos
.a3cf	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a3d2	8d 32 06	sta $0632			sta 	gxXPos+1
.a3d5	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a3d8	8d 33 06	sta $0633			sta 	gxYPos
.a3db	60		rts				rts
.062f					gxCommandID:
>062f							.fill 	1
.0630					gxFillSolid:
>0630							.fill 	1
.0631					gxXPos:
>0631							.fill 	2
.0633					gxYPos:
>0633							.fill 	1
.0634					gxHandler:
>0634							.fill 	2
.0636					gxDrawScale:
>0636							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a3dc					BitmapCtrl:
.a3dc	b1 30		lda ($30),y			lda 	(codePtr),y
.a3de	c8		iny				iny
.a3df	a2 01		ldx #$01			ldx 	#1
.a3e1	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a3e3	f0 11		beq $a3f6			beq 	BitmapSwitch
.a3e5	ca		dex				dex
.a3e6	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a3e8	f0 0c		beq $a3f6			beq 	BitmapSwitch
.a3ea	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; get the colour
.a3ed	5a		phy				phy
.a3ee	aa		tax				tax
.a3ef	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a3f1	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a3f4	7a		ply				ply
.a3f5	60		rts				rts
.a3f6					BitmapSwitch:
.a3f6	5a		phy				phy
.a3f7	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a3f9	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a3fb	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a3fe	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a400	a0 00		ldy #$00			ldy 	#0
.a402	a2 ff		ldx #$ff			ldx 	#$FF
.a404	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a407	9c 30 06	stz $0630			stz 	gxFillSolid
.a40a	9c 31 06	stz $0631			stz 	gxXPos
.a40d	9c 32 06	stz $0632			stz 	gxXPos+1
.a410	9c 33 06	stz $0633			stz 	gxYPos
.a413	9c 36 06	stz $0636			stz 	gxDrawScale
.a416	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a418	a2 00		ldx #$00			ldx 	#0
.a41a	a0 00		ldy #$00			ldy 	#0
.a41c	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a41f	7a		ply				ply
.a420	60		rts				rts
.a421					SpritesCtrl:
.a421	b1 30		lda ($30),y			lda 	(codePtr),y
.a423	c8		iny				iny
.a424	a2 01		ldx #$01			ldx 	#1
.a426	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a428	f0 08		beq $a432			beq 	SpriteSwitch
.a42a	ca		dex				dex
.a42b	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a42d	f0 03		beq $a432			beq 	SpriteSwitch
.a42f	4c 66 a0	jmp $a066			jmp 	SyntaxError
.a432					SpriteSwitch:
.a432	5a		phy				phy
.a433	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a435	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a437	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a43a	7a		ply				ply
.a43b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a43c					GfxCommand:
.a43c	a2 00		ldx #$00			ldx 	#0
.a43e	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; command
.a441	20 08 8e	jsr $8e08			jsr 	CheckComma
.a444	e8		inx				inx
.a445	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger 		; X
.a448	20 08 8e	jsr $8e08			jsr 	CheckComma
.a44b	e8		inx				inx
.a44c	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; Y
.a44f	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a452	4a		lsr a				lsr 	a
.a453	d0 16		bne $a46b			bne 	_GfxError
.a455	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a458	b0 11		bcs $a46b			bcs 	_GfxError 					; bit 7 should have been zero
.a45a	5a		phy				phy 								; save pos
.a45b	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a45e	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a461	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a464	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw
.a467	b0 02		bcs $a46b			bcs 	_GfxError
.a469	7a		ply				ply 								; restore pos and exit.
.a46a	60		rts				rts
.a46b					_GfxError:
.a46b	4c 6b a0	jmp $a06b			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a46e					UnaryHit:
.a46e	fa		plx				plx
.a46f	a9 36		lda #$36			lda 	#zTemp0
.a471	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a474	20 08 8e	jsr $8e08			jsr 	CheckComma
.a477	e8		inx				inx
.a478	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a47b	20 00 8e	jsr $8e00			jsr		CheckRightBracket
.a47e	ca		dex				dex 								; fix back up again.
.a47f	da		phx				phx 								; save X/Y
.a480	5a		phy				phy
.a481	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a484	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a487	aa		tax				tax
.a488	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a48a	20 a5 ab	jsr $aba5			jsr 	GXGraphicDraw 				; calculate result
.a48d	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a48e	7a		ply				ply 								; restore XY
.a48f	fa		plx				plx
.a490	20 de 9e	jsr $9ede			jsr 	NSMSetByte 					; return the hit result
.a493	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a494					PaletteCommand:
.a494	a2 00		ldx #$00			ldx 	#0
.a496	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; colour
.a499	20 08 8e	jsr $8e08			jsr 	CheckComma
.a49c	e8		inx				inx
.a49d	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger 		; r
.a4a0	20 08 8e	jsr $8e08			jsr 	CheckComma
.a4a3	e8		inx				inx
.a4a4	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; g
.a4a7	20 08 8e	jsr $8e08			jsr 	CheckComma
.a4aa	e8		inx				inx
.a4ab	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; b
.a4ae	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a4b1	85 36		sta $36				sta 	zTemp0
.a4b3	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a4b5	85 37		sta $37				sta 	zTemp0+1
.a4b7	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a4b9	26 37		rol $37				rol	 	zTemp0+1
.a4bb	06 36		asl $36				asl 	zTemp0
.a4bd	26 37		rol $37				rol	 	zTemp0+1
.a4bf	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a4c1	85 01		sta $01				sta 	1
.a4c3	5a		phy				phy
.a4c4	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a4c7	92 36		sta ($36)			sta 	(zTemp0)
.a4c9	a0 01		ldy #$01			ldy 	#1
.a4cb	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a4ce	91 36		sta ($36),y			sta 	(zTemp0),y
.a4d0	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a4d3	c8		iny				iny
.a4d4	91 36		sta ($36),y			sta 	(zTemp0),y
.a4d6	7a		ply				ply
.a4d7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a4d8					UnaryEvent:
.a4d8	fa		plx				plx
.a4d9	20 92 a5	jsr $a592			jsr 	TimerToStackX 				; timer in +0
.a4dc	e8		inx				inx  								; put reference into +1
.a4dd	20 a2 98	jsr $98a2			jsr 	EvaluateTerm
.a4e0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a4e3	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a4e5	d0 57		bne $a53e			bne 	_UEType
.a4e7	e8		inx				inx 								; put the step in +2
.a4e8	20 08 8e	jsr $8e08			jsr 	CheckComma
.a4eb	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger
.a4ee	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.a4f1	ca		dex				dex
.a4f2	ca		dex				dex
.a4f3	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a4f6	85 36		sta $36				sta 	zTemp0
.a4f8	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a4fb	85 37		sta $37				sta 	zTemp0+1
.a4fd	5a		phy				phy
.a4fe	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a500	b1 36		lda ($36),y			lda 	(zTemp0),y
.a502	30 36		bmi $a53a			bmi 	_UEFalse 					; exit if signed.
.a504	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a506	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a509	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a50b	c8		iny				iny
.a50c	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a50f	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a511	c8		iny				iny
.a512	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a515	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a517	90 21		bcc $a53a			bcc 	_UEFalse 					; no, return FALSE.
.a519	18		clc				clc
.a51a	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a51c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a51f	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a522	91 36		sta ($36),y			sta 	(zTemp0),y
.a524	c8		iny				iny
.a525	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a528	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a52b	91 36		sta ($36),y			sta 	(zTemp0),y
.a52d	c8		iny				iny
.a52e	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a531	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a534	91 36		sta ($36),y			sta 	(zTemp0),y
.a536	7a		ply				ply
.a537	4c 86 8e	jmp $8e86			jmp 	ReturnTrue
.a53a					_UEFalse:
.a53a	7a		ply				ply 								; restore Y
.a53b	4c 92 8e	jmp $8e92			jmp 	ReturnFalse 				; and return False
.a53e					_UEType:
.a53e	4c 70 a0	jmp $a070			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a541					UnaryJoyX:
.a541	18		clc				clc
.a542	80 01		bra $a545			bra 	JoyMain
.a544					UnaryJoyY:
.a544	38		sec				sec
.a545					JoyMain:
.a545	fa		plx				plx 								; get pos
.a546	08		php				php 								; save carry (set for Y)
.a547	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a54a	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.a54d	20 5e ab	jsr $ab5e			jsr 	EXTReadController 			; read the controller.
.a550	28		plp				plp
.a551	90 02		bcc $a555			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a553	4a		lsr a				lsr 	a
.a554	4a		lsr a				lsr 	a
.a555					_JMNoShift:
.a555	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a556	b0 0a		bcs $a562			bcs 	_JMIsRight
.a558	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a559	b0 04		bcs $a55f			bcs 	_JMIsLeft
.a55b	20 dc 9e	jsr $9edc			jsr 	NSMSetZero 					; zero result
.a55e	60		rts				rts
.a55f					_JMIsLeft:
.a55f	4c 86 8e	jmp $8e86			jmp 	ReturnTrue
.a562					_JMIsRight:
.a562	a9 01		lda #$01			lda 	#1
.a564	20 de 9e	jsr $9ede			jsr 	NSMSetByte
.a567	60		rts				rts
.a568					UnaryJoyB:
.a568	fa		plx				plx 								; get pos
.a569	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a56c	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.a56f	20 5e ab	jsr $ab5e			jsr 	EXTReadController 			; read the controller.
.a572	4a		lsr a				lsr 	a
.a573	4a		lsr a				lsr 	a
.a574	4a		lsr a				lsr 	a
.a575	4a		lsr a				lsr 	a
.a576	29 01		and #$01			and 	#1
.a578	20 de 9e	jsr $9ede			jsr 	NSMSetByte
.a57b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a57c					LoadCommand:
.a57c	20 6a 89	jsr $896a			jsr 	NewProgram
.a57f	20 e5 82	jsr $82e5			jsr 	BackLoadProgram
.a582	4c 7a 83	jmp $837a			jmp 	WarmStart
.a585					GoCommand:
.a585	20 6a 89	jsr $896a			jsr 	NewProgram
.a588	20 e5 82	jsr $82e5			jsr 	BackLoadProgram
.a58b	4c a9 8a	jmp $8aa9			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a58e					UnaryTimer:
.a58e	fa		plx				plx
.a58f	20 00 8e	jsr $8e00			jsr 	CheckRightBracket
.a592					TimerToStackX:
.a592	20 dc 9e	jsr $9edc			jsr 	NSMSetZero 					; zero result
.a595	64 01		stz $01				stz 	1 							; access I/O
.a597	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a59a	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a59d	ad 5a d6	lda $d65a			lda 	$D65A
.a5a0	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a5a3	ad 5b d6	lda $d65b			lda 	$D65B
.a5a6	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a5a9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a5aa					MemoryDeleteLine:
.a5aa	20 c9 a5	jsr $a5c9			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a5ad	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a5af	a8		tay				tay
.a5b0					_MDDLLoop:
.a5b0	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a5b2	92 30		sta ($30)			sta 	(codePtr)
.a5b4	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a5b6	c5 3a		cmp $3a				cmp 	zTemp2
.a5b8	d0 07		bne $a5c1			bne 	_MDLDLNext
.a5ba	a5 31		lda $31				lda 	codePtr+1
.a5bc	c5 3b		cmp $3b				cmp 	zTemp2+1
.a5be	d0 01		bne $a5c1			bne 	_MDLDLNext
.a5c0					_MDDLExit:
.a5c0	60		rts				rts
.a5c1					_MDLDLNext:
.a5c1	e6 30		inc $30				inc 	codePtr						; next byte
.a5c3	d0 eb		bne $a5b0			bne 	_MDDLLoop
.a5c5	e6 31		inc $31				inc 	codePtr+1
.a5c7	80 e7		bra $a5b0			bra 	_MDDLLoop
.a5c9					IMemoryFindEnd:
.a5c9	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5cb	85 3a		sta $3a				sta 	0+zTemp2
.a5cd	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5cf	85 3b		sta $3b				sta 	1+zTemp2
.a5d1					_MDLFELoop:
.a5d1	b2 3a		lda ($3a)			lda 	(zTemp2)
.a5d3	f0 0b		beq $a5e0			beq 	_MDLFEExit
.a5d5	18		clc				clc
.a5d6	65 3a		adc $3a				adc 	zTemp2
.a5d8	85 3a		sta $3a				sta 	zTemp2
.a5da	90 f5		bcc $a5d1			bcc 	_MDLFELoop
.a5dc	e6 3b		inc $3b				inc 	zTemp2+1
.a5de	80 f1		bra $a5d1			bra 	_MDLFELoop
.a5e0					_MDLFEExit:
.a5e0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a5e1					MemoryInsertLine:
.a5e1	08		php				php
.a5e2	20 c9 a5	jsr $a5c9			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a5e5	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a5e7	1a		inc a				inc 	a
.a5e8	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a5ea	b0 36		bcs $a622			bcs 	_MDLIError
.a5ec	28		plp				plp
.a5ed	90 08		bcc $a5f7			bcc 	_MDLIFound
.a5ef	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a5f1	85 30		sta $30				sta 	codePtr
.a5f3	a5 3b		lda $3b				lda 	zTemp2+1
.a5f5	85 31		sta $31				sta 	codePtr+1
.a5f7					_MDLIFound:
.a5f7	ad a9 04	lda $04a9			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a5fa	a8		tay				tay
.a5fb					_MDLIInsert:
.a5fb	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a5fd	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a5ff	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a601	c5 3a		cmp $3a				cmp 	zTemp2
.a603	d0 06		bne $a60b			bne 	_MDLINext
.a605	a5 31		lda $31				lda 	codePtr+1
.a607	c5 3b		cmp $3b				cmp 	zTemp2+1
.a609	f0 0a		beq $a615			beq 	_MDLIHaveSpace
.a60b					_MDLINext:
.a60b	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a60d	d0 02		bne $a611			bne 	_MDLINoBorrow
.a60f	c6 3b		dec $3b				dec 	zTemp2+1
.a611					_MDLINoBorrow:
.a611	c6 3a		dec $3a				dec 	zTemp2
.a613	80 e6		bra $a5fb			bra 	_MDLIInsert
.a615					_MDLIHaveSpace:
.a615	ac a9 04	ldy $04a9			ldy 	tokenOffset 				; bytes to copy
.a618	88		dey				dey 								; from offset-1 to 0
.a619					_MDLICopy:
.a619	b9 a9 04	lda $04a9,y			lda 	tokenOffset,y
.a61c	91 30		sta ($30),y			sta 	(codePtr),y
.a61e	88		dey				dey
.a61f	10 f8		bpl $a619			bpl 	_MDLICopy
.a621	60		rts				rts
.a622					_MDLIError:
.a622	a9 06		lda #$06		lda	#6
.a624	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.a627					MDLAppendLine:
.a627	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a629	85 36		sta $36				sta 	zTemp0
.a62b	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a62d	85 38		sta $38				sta 	0+zTemp1
.a62f	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a631	85 39		sta $39				sta 	1+zTemp1
.a633	b2 38		lda ($38)			lda 	(zTemp1)
.a635	d0 0a		bne $a641			bne 	_MDLANoInitialise
.a637	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a639	8d 37 06	sta $0637			sta 	0+AppendPointer
.a63c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a63e	8d 38 06	sta $0638			sta 	1+AppendPointer
.a641					_MDLANoInitialise:
.a641	18		clc				clc
.a642	ad 37 06	lda $0637			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a645	85 38		sta $38				sta 	zTemp1
.a647	72 36		adc ($36)			adc 	(zTemp0)
.a649	8d 37 06	sta $0637			sta 	AppendPointer
.a64c	ad 38 06	lda $0638			lda 	AppendPointer+1
.a64f	85 39		sta $39				sta 	zTemp1+1
.a651	69 00		adc #$00			adc 	#0
.a653	8d 38 06	sta $0638			sta 	AppendPointer+1
.a656	a0 00		ldy #$00			ldy 	#0
.a658					_MDLACopy:
.a658	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a65a	91 38		sta ($38),y			sta 	(zTemp1),y
.a65c	c8		iny				iny
.a65d	98		tya				tya
.a65e	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a660	d0 f6		bne $a658			bne 	_MDLACopy
.a662	a9 00		lda #$00			lda 	#0 							; end of program.
.a664	91 38		sta ($38),y			sta 	(zTemp1),y
.a666	60		rts				rts
.0637					AppendPointer:
>0637							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a667					MemoryNew:
.a667	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a669	85 30		sta $30				sta 	codePtr
.a66b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a66d	85 31		sta $31				sta 	codePtr+1
.a66f	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a671	92 30		sta ($30)			sta 	(codePtr)
.a673	60		rts				rts
.a674					MemoryInline:
.a674	98		tya				tya 								; put address into stack,x
.a675	18		clc				clc  								; get the offset, add codePtr
.a676	65 30		adc $30				adc 	codePtr
.a678	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a67b	a5 31		lda $31				lda 	codePtr+1
.a67d	69 00		adc #$00			adc 	#0
.a67f	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a682	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a685	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a688	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a689					MemorySearch:
.a689	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a68b	86 37		stx $37				stx 	zTemp0+1
.a68d	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a68f	85 30		sta $30				sta 	codePtr
.a691	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a693	85 31		sta $31				sta 	codePtr+1
.a695					_MTAXLoop:
.a695	b2 30		lda ($30)			lda 	(codePtr)
.a697	18		clc				clc
.a698	f0 21		beq $a6bb			beq 	_MTAXExit 					; reached end, exit with CC.
.a69a	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a69c	b1 30		lda ($30),y			lda 	(codePtr),y
.a69e	38		sec				sec
.a69f	e5 36		sbc $36				sbc 	zTemp0
.a6a1	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a6a3	c8		iny				iny 								; do the MSB
.a6a4	b1 30		lda ($30),y			lda 	(codePtr),y
.a6a6	e5 37		sbc $37				sbc 	zTemp0+1
.a6a8	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a6aa	f0 0f		beq $a6bb			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a6ac	b0 0d		bcs $a6bb			bcs 	_MTAXExit 					; current < required exit
.a6ae	18		clc				clc
.a6af	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a6b1	65 30		adc $30				adc 	codePtr
.a6b3	85 30		sta $30				sta 	codePtr
.a6b5	90 02		bcc $a6b9			bcc 	_CREExit
.a6b7	e6 31		inc $31				inc 	codePtr+1 					; carry
.a6b9					_CREExit:
.a6b9	80 da		bra $a695			bra 	_MTAXLoop
.a6bb					_MTAXExit:
.a6bb	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a6bc					UnaryPlaying:
.a6bc	fa		plx				plx
.a6bd	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; get channel #
.a6c0	48		pha				pha
.a6c1	20 00 8e	jsr $8e00			jsr		CheckRightBracket
.a6c4	68		pla				pla
.a6c5	c9 04		cmp #$04			cmp 	#4
.a6c7	b0 0c		bcs $a6d5			bcs 	_UPNotPlaying
.a6c9	09 20		ora #$20			ora 	#$20 						; query playing ?
.a6cb	20 33 ba	jsr $ba33			jsr 	SNDCommand
.a6ce	c9 00		cmp #$00			cmp 	#0
.a6d0	f0 03		beq $a6d5			beq 	_UPNotPlaying
.a6d2	4c 86 8e	jmp $8e86			jmp 	ReturnTrue
.a6d5					_UPNotPlaying:
.a6d5	4c 92 8e	jmp $8e92			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a6d8					SoundCommand:
.a6d8	b1 30		lda ($30),y			lda 	(codePtr),y
.a6da	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a6dc	d0 09		bne $a6e7			bne 	_SNDMain
.a6de	c8		iny				iny 								; skip OFF
.a6df	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a6e1	5a		phy				phy
.a6e2	20 33 ba	jsr $ba33			jsr 	SNDCommand
.a6e5	7a		ply				ply
.a6e6	60		rts				rts
.a6e7					_SNDMain:
.a6e7	a2 00		ldx #$00			ldx 	#0
.a6e9	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; channel
.a6ec	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a6ee	b0 50		bcs $a740			bcs 	_SndError
.a6f0	e8		inx				inx 								; do the rest in slot 1.
.a6f1	20 08 8e	jsr $8e08			jsr 	CheckComma
.a6f4	20 3d 9e	jsr $9e3d			jsr 	Evaluate16BitInteger 		; Pitch
.a6f7	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a6fa	c9 10		cmp #$10			cmp 	#16
.a6fc	b0 42		bcs $a740			bcs 	_SndError
.a6fe	8d 3a 06	sta $063a			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a701	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a704	8d 39 06	sta $0639			sta 	SoundCommandBlock
.a707	20 08 8e	jsr $8e08			jsr 	CheckComma
.a70a	20 5d 9e	jsr $9e5d			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a70d	8d 3c 06	sta $063c			sta 	SoundCommandBlock+3
.a710	a9 0f		lda #$0f			lda 	#15
.a712	8d 3b 06	sta $063b			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a715	9c 3d 06	stz $063d			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a718	9c 3e 06	stz $063e			stz 	SoundCommandBlock+5
.a71b	b1 30		lda ($30),y			lda 	(codePtr),y
.a71d	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a71f	d0 10		bne $a731			bne 	_SNDPlay
.a721	c8		iny				iny
.a722	20 49 9e	jsr $9e49			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a725	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a728	8d 3d 06	sta $063d			sta 	SoundCommandBlock+4
.a72b	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a72e	8d 3e 06	sta $063e			sta 	SoundCommandBlock+5
.a731					_SNDPlay:
.a731	5a		phy				phy
.a732	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a735	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a737	a2 39		ldx #$39			ldx 	#(SoundCommandBlock & $FF)
.a739	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a73b	20 33 ba	jsr $ba33			jsr 	SNDCommand
.a73e	7a		ply				ply
.a73f	60		rts				rts
.a740					_SndError:
.a740	4c 6b a0	jmp $a06b			jmp 	RangeError
.0639					SoundCommandBlock:
>0639							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a743					StackPushByte:
.a743	48		pha				pha 								; save byte
.a744	a5 34		lda $34				lda 	BasicStack
.a746	d0 09		bne $a751			bne 	_SPBNoBorrow
.a748	c6 35		dec $35				dec 	BasicStack+1
.a74a	48		pha				pha
.a74b	a5 35		lda $35				lda 	BasicStack+1
.a74d	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a74f	90 06		bcc $a757			bcc 	_SPBMemory
.a751					_SPBNoBorrow:
.a751	c6 34		dec $34				dec 	BasicStack
.a753	68		pla				pla 								; get back and write
.a754	92 34		sta ($34)			sta 	(BasicStack)
.a756	60		rts				rts
.a757					_SPBMemory:
.a757	a9 12		lda #$12		lda	#18
.a759	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.a75c					StackPopByte:
.a75c	b2 34		lda ($34)			lda 	(BasicStack)
.a75e	e6 34		inc $34				inc 	BasicStack
.a760	d0 02		bne $a764			bne 	_SPBNoCarry
.a762	e6 35		inc $35				inc 	BasicStack+1
.a764					_SPBNoCarry:
.a764	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a765					StackOpen:
.a765	48		pha				pha 								; save frame byte
.a766	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a768	0a		asl a				asl 	a 							; claim twice this for storage
.a769	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a76b	38		sec				sec 								; so basically subtracting from
.a76c	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a76e	85 34		sta $34				sta 	basicStack
.a770	b0 08		bcs $a77a			bcs 	_SONoBorrow
.a772	c6 35		dec $35				dec 	basicStack+1
.a774	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a776	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a778	90 04		bcc $a77e			bcc 	_SOMemory
.a77a					_SONoBorrow:
.a77a	68		pla				pla 								; get marker back and write at TOS
.a77b	92 34		sta ($34)			sta 	(basicStack)
.a77d	60		rts				rts
.a77e					_SOMemory:
.a77e	a9 12		lda #$12		lda	#18
.a780	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.a783					StackClose:
.a783	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a785	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a787	0a		asl a				asl 	a 							; claim twice this.
.a788	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a78a	85 34		sta $34				sta 	basicStack
.a78c	90 02		bcc $a790			bcc 	_SCExit
.a78e	e6 35		inc $35				inc 	basicStack+1
.a790					_SCExit:
.a790	60		rts				rts
.a791					StackCheckFrame:
.a791	48		pha				pha
.a792					_StackRemoveLocals:
.a792	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a794	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a796	b0 05		bcs $a79d			bcs 	_SCNoLocal
.a798	20 19 89	jsr $8919			jsr 	LocalPopValue
.a79b	80 f5		bra $a792			bra 	_StackRemoveLocals
.a79d					_SCNoLocal:
.a79d	68		pla				pla
.a79e	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a7a0	29 f0		and #$f0			and 	#$F0 						; check type bits
.a7a2	d0 01		bne $a7a5			bne 	_SCFError 					; different, we have structures mixed up
.a7a4	60		rts				rts
.a7a5					_SCFError:
.a7a5	8a		txa				txa 								; report error X
.a7a6	4c 19 8e	jmp $8e19			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a7a9					STKSaveCodePosition:
.a7a9	5a		phy				phy
.a7aa	98		tya				tya 								; save Y
.a7ab	a0 05		ldy #$05			ldy 	#5
.a7ad	91 34		sta ($34),y			sta 	(basicStack),y
.a7af	88		dey				dey 								; save Code Pointer
.a7b0					_STKSaveLoop:
.a7b0	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a7b3	91 34		sta ($34),y			sta 	(basicStack),y
.a7b5	88		dey				dey
.a7b6	d0 f8		bne $a7b0			bne 	_STKSaveLoop
.a7b8	7a		ply				ply
.a7b9	60		rts				rts
.a7ba					STKLoadCodePosition:
.a7ba	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a7bc					_STKLoadLoop:
.a7bc	b1 34		lda ($34),y			lda 	(basicStack),y
.a7be	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a7c1	c8		iny				iny
.a7c2	c0 05		cpy #$05			cpy 	#5
.a7c4	d0 f6		bne $a7bc			bne 	_STKLoadLoop
.a7c6	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a7c8	a8		tay				tay
.a7c9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a7ca					StackReset:
.a7ca	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a7cc	85 34		sta $34				sta 	0+basicStack
.a7ce	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a7d0	85 35		sta $35				sta 	1+basicStack
.a7d2	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a7d4	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a7d6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a7d7					StringConcrete:
.a7d7	5a		phy				phy 								; save position on stack
.a7d8	20 a5 9a	jsr $9aa5			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7db	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a7de	85 38		sta $38				sta 	zTemp1
.a7e0	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a7e3	85 39		sta $39				sta 	zTemp1+1
.a7e5	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a7e7					_SALength:
.a7e7	c8		iny				iny
.a7e8	b1 38		lda ($38),y			lda 	(zTemp1),y
.a7ea	d0 fb		bne $a7e7			bne 	_SALength
.a7ec	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a7ee	b0 3f		bcs $a82f			bcs 	_SALengthError
.a7f0	98		tya				tya 				 				; length of the new string
.a7f1	18		clc				clc
.a7f2	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a7f4	90 02		bcc $a7f8			bcc 	_SAHaveLength
.a7f6	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a7f8					_SAHaveLength:
.a7f8	48		pha				pha 								; save length.
.a7f9	38		sec				sec
.a7fa	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a7fc	6d 8e 04	adc $048e			adc 	StringMemory
.a7ff	8d 8e 04	sta $048e			sta 	StringMemory
.a802	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a804	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a807	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a809	6d 8f 04	adc $048f			adc 	StringMemory+1
.a80c	8d 8f 04	sta $048f			sta 	StringMemory+1
.a80f	85 3b		sta $3b				sta 	zTemp2+1
.a811	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a814	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a815	38		sec				sec
.a816	e9 03		sbc #$03			sbc 	#3
.a818	92 3a		sta ($3a)			sta 	(zTemp2)
.a81a	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a81c	a0 01		ldy #$01			ldy 	#1
.a81e	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a820					_SACopyNewString:
.a820	a0 00		ldy #$00			ldy 	#0
.a822					_SACopyNSLoop:
.a822	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a824	c8		iny				iny 								; write two on in string storage
.a825	c8		iny				iny
.a826	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a828	88		dey				dey 								; this makes it one one.
.a829	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a82b	d0 f5		bne $a822			bne 	_SACopyNSLoop
.a82d	7a		ply				ply
.a82e	60		rts				rts
.a82f					_SALengthError:
.a82f	a9 09		lda #$09		lda	#9
.a831	4c 19 8e	jmp $8e19		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a834					StringSystemInitialise:
.a834	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a836	8d 8e 04	sta $048e			sta 	0+StringMemory
.a839	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a83b	8d 8f 04	sta $048f			sta 	1+StringMemory
.a83e	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a841	60		rts				rts
.a842					StringSpaceInitialise:
.a842	20 a5 9a	jsr $9aa5			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a845	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a847	8d 90 04	sta $0490			sta 	StringInitialised
.a84a	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a84d	8d 91 04	sta $0491			sta 	StringTempPointer
.a850	ad 8f 04	lda $048f			lda 	StringMemory+1
.a853	3a		dec a				dec 	a
.a854	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a857	60		rts				rts
.a858					StringTempAllocate:
.a858	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a85a	b0 35		bcs $a891			bcs 	_STALength
.a85c	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a85f	30 05		bmi $a866			bmi 	_STAAllocate
.a861	48		pha				pha 								; save value to subtract.
.a862	20 42 a8	jsr $a842			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a865	68		pla				pla 								; restore it
.a866					_STAAllocate:
.a866	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a868	18		clc				clc  								; deliberate allows one more
.a869	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a86c	8d 91 04	sta $0491			sta 	StringTempPointer
.a86f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a872	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a874	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a877	69 ff		adc #$ff			adc 	#$FF
.a879	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a87c	85 3d		sta $3d				sta 	zsTemp+1
.a87e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a881	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a884	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a887	a9 10		lda #$10			lda 	#NSTString
.a889	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a88c	a9 00		lda #$00			lda 	#0 							; clear the target string
.a88e	92 3c		sta ($3c)			sta 	(zsTemp)
.a890	60		rts				rts
.a891					_STALength:
.a891	a9 09		lda #$09		lda	#9
.a893	4c 19 8e	jmp $8e19		jmp	ErrorHandler
.a896					StringTempWrite:
.a896	48		pha				pha
.a897	92 3c		sta ($3c)			sta 	(zsTemp)
.a899	e6 3c		inc $3c				inc 	zsTemp
.a89b	d0 02		bne $a89f			bne 	_STWNoCarry
.a89d	e6 3d		inc $3d				inc 	zsTemp+1
.a89f					_STWNoCarry:
.a89f	a9 00		lda #$00			lda 	#0
.a8a1	92 3c		sta ($3c)			sta 	(zsTemp)
.a8a3	68		pla				pla
.a8a4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a8a5					EXTPrintCharacter:
.a8a5	48		pha				pha
.a8a6	da		phx				phx
.a8a7	5a		phy				phy
.a8a8	a6 01		ldx $01				ldx 	1
.a8aa	da		phx				phx
.a8ab	ac 40 06	ldy $0640			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a8ae	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a8b0	30 48		bmi $a8fa			bmi 	_EXPCColour
.a8b2	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a8b4	90 4d		bcc $a903			bcc 	_EXPCControl
.a8b6	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a8b8	86 01		stx $01				stx 	1
.a8ba	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8bc	e6 01		inc $01				inc 	1 							; select colour memory
.a8be	ad 41 06	lda $0641			lda 	EXTTextColour
.a8c1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8c3	c8		iny				iny 								; advance horizontal position
.a8c4	8c 40 06	sty $0640			sty 	EXTColumn
.a8c7	cc 42 06	cpy $0642			cpy 	EXTScreenWidth 				; reached RHS ?
.a8ca	90 66		bcc $a932			bcc 	_EXPCExit 					; no, then exit.
.a8cc					_EXPCCRLF:
.a8cc	ee 3f 06	inc $063f			inc 	EXTRow  					; bump row
.a8cf	9c 40 06	stz $0640			stz 	EXTColumn 					; back to column 0
.a8d2	ad 3f 06	lda $063f			lda 	EXTRow 						; check if reached the bottom ?
.a8d5	cd 43 06	cmp $0643			cmp 	EXTScreenHeight 			; if so, then scroll.
.a8d8	f0 18		beq $a8f2			beq 	_EXPCScroll
.a8da	18		clc				clc 								; add width to address.
.a8db	a5 40		lda $40				lda 	EXTAddress
.a8dd	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a8e0	85 40		sta $40				sta 	EXTAddress
.a8e2	90 4e		bcc $a932			bcc 	_EXPCExit
.a8e4	e6 41		inc $41				inc 	EXTAddress+1
.a8e6	80 4a		bra $a932			bra 	_EXPCExit
.a8e8					_EXPCLeft:
.a8e8	ce 40 06	dec $0640			dec 	EXTColumn
.a8eb	10 45		bpl $a932			bpl 	_EXPCExit
.a8ed					_EXPCBegin:
.a8ed	9c 40 06	stz $0640			stz 	EXTColumn
.a8f0	80 40		bra $a932			bra 	_EXPCExit
.a8f2					_EXPCScroll:
.a8f2	ce 3f 06	dec $063f			dec 	EXTRow 						; the height-1 th line.
.a8f5	20 bf a9	jsr $a9bf			jsr 	EXTScreenScroll 			; scroll the screen
.a8f8	80 38		bra $a932			bra 	_EXPCExit
.a8fa					_EXPCColour:
.a8fa	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a8fc	b0 34		bcs $a932			bcs 	_EXPCExit
.a8fe	20 9f a9	jsr $a99f			jsr 	_EXPCHandleColour
.a901	80 2f		bra $a932			bra 	_EXPCExit
.a903					_EXPCControl:
.a903	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a905	b0 2b		bcs $a932			bcs 	_EXPCExit
.a907	0a		asl a				asl 	a 							; double into X
.a908	aa		tax				tax
.a909	7c 7d a9	jmp ($a97d,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a90c					_EXPCUp:
.a90c	ad 3f 06	lda $063f			lda 	EXTRow 						; already at top ?
.a90f	f0 21		beq $a932			beq 	_EXPCExit
.a911	ce 3f 06	dec $063f			dec 	EXTRow 						; up one in position/address
.a914	38		sec				sec
.a915	a5 40		lda $40				lda 	EXTAddress
.a917	ed 42 06	sbc $0642			sbc 	EXTScreenWidth
.a91a	85 40		sta $40				sta 	EXTAddress
.a91c	b0 14		bcs $a932			bcs 	_EXPCExit
.a91e	c6 41		dec $41				dec 	EXTAddress+1
.a920	80 10		bra $a932			bra 	_EXPCExit
.a922					_EXPCRight:
.a922	c8		iny				iny
.a923	8c 40 06	sty $0640			sty 	EXTColumn
.a926	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.a929	d0 07		bne $a932			bne 	_EXPCExit
.a92b					_EXPCEnd:
.a92b	ad 42 06	lda $0642			lda 	EXTScreenWidth
.a92e	3a		dec a				dec 	a
.a92f	8d 40 06	sta $0640			sta 	EXTColumn
.a932					_EXPCExit:
.a932	20 14 aa	jsr $aa14			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a935	68		pla				pla
.a936	85 01		sta $01				sta 	1
.a938	7a		ply				ply
.a939	fa		plx				plx
.a93a	68		pla				pla
.a93b	60		rts				rts
.a93c					_EXPCClearScreen:
.a93c	20 d1 a9	jsr $a9d1			jsr		EXTClearScreenCode
.a93f	80 f1		bra $a932			bra 	_EXPCExit
.a941					_EXPCDown:
.a941	ad 43 06	lda $0643			lda 	EXTScreenHeight 			; at the bottom
.a944	3a		dec a				dec 	a
.a945	cd 3f 06	cmp $063f			cmp 	EXTRow
.a948	f0 e8		beq $a932			beq 	_EXPCExit
.a94a	ee 3f 06	inc $063f			inc 	EXTRow 						; down one in position/address
.a94d	18		clc				clc
.a94e	a5 40		lda $40				lda 	EXTAddress
.a950	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a953	85 40		sta $40				sta 	EXTAddress
.a955	90 db		bcc $a932			bcc 	_EXPCExit
.a957	e6 41		inc $41				inc 	EXTAddress+1
.a959	80 d7		bra $a932			bra 	_EXPCExit
.a95b					_EXPCTab:
.a95b	ad 40 06	lda $0640			lda 	EXTColumn 					; next tab stop
.a95e	29 f8		and #$f8			and 	#$F8
.a960	18		clc				clc
.a961	69 08		adc #$08			adc 	#8
.a963	8d 40 06	sta $0640			sta 	EXTColumn
.a966	cd 42 06	cmp $0642			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a969	90 c7		bcc $a932			bcc 	_EXPCExit
.a96b	80 be		bra $a92b			bra 	_EXPCEnd
.a96d					_EXPCBackSpace:
.a96d	88		dey				dey
.a96e	30 c2		bmi $a932			bmi 	_EXPCExit
.a970	ce 40 06	dec $0640			dec 	EXTColumn
.a973	a9 02		lda #$02			lda 	#2
.a975	85 01		sta $01				sta 	1
.a977	a9 20		lda #$20			lda 	#32
.a979	91 40		sta ($40),y			sta 	(EXTAddress),y
.a97b	80 b5		bra $a932			bra 	_EXPCExit
.a97d					_EXPCActionTable:
>a97d	32 a9						.word 	_EXPCExit 					; 00
>a97f	ed a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a981	e8 a8						.word 	_EXPCLeft 					; 02 B Left
>a983	32 a9						.word 	_EXPCExit 					; 03 <Break>
>a985	32 a9						.word 	_EXPCExit 					; 04
>a987	2b a9						.word 	_EXPCEnd 					; 05 E End of Line
>a989	22 a9						.word 	_EXPCRight 					; 06 F Right
>a98b	32 a9						.word 	_EXPCExit 					; 07
>a98d	6d a9						.word 	_EXPCBackspace 				; 08 H Backspace
>a98f	5b a9						.word 	_EXPCTab 					; 09 I Tab
>a991	32 a9						.word 	_EXPCExit 					; 0A
>a993	32 a9						.word 	_EXPCExit 					; 0B
>a995	3c a9						.word 	_EXPCClearScreen			; 0C L CLS
>a997	cc a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a999	41 a9						.word 	_EXPCDown 					; 0E N Down
>a99b	32 a9						.word 	_EXPCExit 					; 0F
>a99d	0c a9						.word 	_EXPCUp 					; 10 P Up
.a99f					_EXPCHandleColour
.a99f	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a9a1	b0 16		bcs $a9b9			bcs 	_EXPCBackground
.a9a3	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a9a4	0a		asl a				asl 	a
.a9a5	0a		asl a				asl 	a
.a9a6	0a		asl a				asl 	a
.a9a7	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a9a9					_EXPCUpdate:
.a9a9	48		pha				pha 								; save new colour
.a9aa	8a		txa				txa 								; get mask
.a9ab	2d 41 06	and $0641			and 	EXTTextColour 				; mask out old.
.a9ae	8d 41 06	sta $0641			sta 	EXTTextColour
.a9b1	68		pla				pla 								; or in new colour
.a9b2	0d 41 06	ora $0641			ora 	EXTTextColour
.a9b5	8d 41 06	sta $0641			sta 	EXTTextColour
.a9b8	60		rts				rts
.a9b9					_EXPCBackground:
.a9b9	29 0f		and #$0f			and 	#$0F 						; get the colour
.a9bb	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a9bd	80 ea		bra $a9a9			bra 	_EXPCUpdate
.a9bf					EXTScreenScroll:
.a9bf	a9 02		lda #$02			lda 	#2 							; select text page
.a9c1	85 01		sta $01				sta 	1
.a9c3	a9 20		lda #$20			lda		#32 						; fill with space
.a9c5	20 d4 aa	jsr $aad4			jsr 	EXTScrollFill
.a9c8	e6 01		inc $01				inc 	1 							; select colour page
.a9ca	ad 41 06	lda $0641			lda 	EXTTextColour
.a9cd	20 d4 aa	jsr $aad4			jsr 	EXTScrollFill
.a9d0	60		rts				rts
.a9d1					EXTClearScreenCode:
.a9d1	a9 02		lda #$02			lda 	#2 							; select text page
.a9d3	85 01		sta $01				sta 	1
.a9d5	a9 20		lda #$20			lda		#32 						; fill with space
.a9d7	20 e4 a9	jsr $a9e4			jsr 	_EXTCSFill
.a9da	e6 01		inc $01				inc 	1 							; select colour page
.a9dc	ad 41 06	lda $0641			lda 	EXTTextColour
.a9df	20 e4 a9	jsr $a9e4			jsr 	_EXTCSFill
.a9e2	80 22		bra $aa06			bra 	EXTHomeCursor
.a9e4					_EXTCSFill:
.a9e4	aa		tax				tax
.a9e5	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a9e7	85 40		sta $40				sta 	EXTAddress
.a9e9	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9eb	85 41		sta $41				sta 	EXTAddress+1
.a9ed					_EXTCSFill1:
.a9ed	a0 00		ldy #$00			ldy 	#0
.a9ef	8a		txa				txa
.a9f0					_EXTCSFill2:
.a9f0	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9f2	c8		iny				iny
.a9f3	d0 fb		bne $a9f0			bne 	_EXTCSFill2
.a9f5	e6 41		inc $41				inc 	EXTAddress+1
.a9f7	a5 41		lda $41				lda 	EXTAddress+1
.a9f9	c9 d2		cmp #$d2			cmp 	#$D2
.a9fb	d0 f0		bne $a9ed			bne 	_EXTCSFill1
.a9fd	8a		txa				txa
.a9fe					_EXTCSFill3:
.a9fe	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa00	c8		iny				iny
.aa01	c0 c0		cpy #$c0			cpy 	#$C0
.aa03	d0 f9		bne $a9fe			bne 	_EXTCSFill3
.aa05	60		rts				rts
.aa06					EXTHomeCursor:
.aa06	9c 3f 06	stz $063f			stz 	EXTRow 						; reset row & column
.aa09	9c 40 06	stz $0640			stz 	EXTColumn
.aa0c	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.aa0e	85 40		sta $40				sta 	EXTAddress
.aa10	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.aa12	85 41		sta $41				sta 	EXTAddress+1
.aa14					EXTSetHardwareCursor:
.aa14	64 01		stz $01				stz 	1 							; I/O Page zero
.aa16	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.aa18	8d 10 d0	sta $d010			sta 	$D010
.aa1b	a9 b1		lda #$b1			lda 	#$B1
.aa1d	8d 12 d0	sta $d012			sta 	$D012
.aa20	ad 40 06	lda $0640			lda 	EXTColumn
.aa23	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.aa26	9c 15 d0	stz $d015			stz 	$D015
.aa29	ad 3f 06	lda $063f			lda 	EXTRow
.aa2c	8d 16 d0	sta $d016			sta 	$D016
.aa2f	9c 17 d0	stz $d017			stz 	$D017
.aa32	60		rts				rts
.aa33					EXTInputLine:
.aa33	48		pha				pha
.aa34	da		phx				phx
.aa35	5a		phy				phy
.aa36	a5 01		lda $01				lda 	1 							; save I/O page
.aa38	48		pha				pha
.aa39					_EILLoop:
.aa39	20 3b ab	jsr $ab3b			jsr 	ExtInputSingleCharacter
.aa3c	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.aa3e	f0 40		beq $aa80			beq 	_EILExit
.aa40	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.aa42	f0 1c		beq $aa60			beq 	_EILBackspace
.aa44	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.aa46	90 12		bcc $aa5a			bcc 	_EILPrintLoop
.aa48	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.aa4a	b0 0e		bcs $aa5a			bcs 	_EILPrintLoop
.aa4c	48		pha				pha 								; save character
.aa4d	a9 02		lda #$02			lda 	#2  						; insert a space
.aa4f	85 01		sta $01				sta 	1
.aa51	20 c2 aa	jsr $aac2			jsr 	EXTILInsert 				; insert in text screen
.aa54	e6 01		inc $01				inc 	1
.aa56	20 c2 aa	jsr $aac2			jsr 	EXTILInsert 				; insert in colour screen
.aa59	68		pla				pla 								; get character back.
.aa5a					_EILPrintLoop:
.aa5a	20 a5 a8	jsr $a8a5			jsr 	ExtPrintCharacter
.aa5d	80 da		bra $aa39			bra 	_EILLoop
.aa5f	60		rts				rts
.aa60					_EILBackspace:
.aa60	ad 40 06	lda $0640			lda 	EXTColumn					; can we backspace ?
.aa63	f0 d4		beq $aa39			beq 	_EILLoop
.aa65	a9 02		lda #$02			lda 	#2 							; move cursor left
.aa67	20 a5 a8	jsr $a8a5			jsr 	EXTPrintCharacter
.aa6a	a9 02		lda #$02			lda 	#2 							; text block
.aa6c	85 01		sta $01				sta 	1
.aa6e	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.aa70	20 ad aa	jsr $aaad			jsr 	EXTILDelete
.aa73	e6 01		inc $01				inc 	1 							; colour block
.aa75	ac 40 06	ldy $0640			ldy 	EXTColumn 					; get attribute of last character
.aa78	88		dey				dey
.aa79	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa7b	20 ad aa	jsr $aaad			jsr 	EXTILDelete 				; backspace attribute
.aa7e	80 b9		bra $aa39			bra 	_EILLoop 					; and go round.
.aa80					_EILExit:
.aa80	a9 02		lda #$02			lda 	#2 							; switch to page 2
.aa82	85 01		sta $01				sta 	1
.aa84	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa86					_EILScrapeLine:
.aa86	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa88	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa8b	c8		iny				iny
.aa8c	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aa8f	d0 f5		bne $aa86			bne 	_EILScrapeLine
.aa91					_EILTrimSpaces:
.aa91	88		dey				dey
.aa92	f0 08		beq $aa9c			beq 	_EILEndTrim
.aa94	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y
.aa97	c9 20		cmp #$20			cmp 	#' '
.aa99	f0 f6		beq $aa91			beq 	_EILTrimSpaces
.aa9b	c8		iny				iny 								; trim after non space character.
.aa9c					_EILEndTrim:
.aa9c	a9 00		lda #$00			lda 	#0 							; trim here.
.aa9e	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aaa1	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aaa3	20 a5 a8	jsr $a8a5			jsr 	ExtPrintCharacter
.aaa6	68		pla				pla 								; reset I/O page
.aaa7	85 01		sta $01				sta 	1
.aaa9	7a		ply				ply
.aaaa	fa		plx				plx
.aaab	68		pla				pla
.aaac	60		rts				rts
.aaad					EXTILDelete:
.aaad	48		pha				pha 								; save the new character
.aaae	ac 40 06	ldy $0640			ldy 	EXTColumn 					; start copying from here.
.aab1					_EXTDLoop:
.aab1	c8		iny				iny 								; copy one byte down.
.aab2	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aab4	88		dey				dey
.aab5	91 40		sta ($40),y			sta 	(EXTAddress),y
.aab7	c8		iny				iny 								; do till end of line.
.aab8	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aabb	90 f4		bcc $aab1			bcc 	_EXTDLoop
.aabd	88		dey				dey 	 							; write in last slot.
.aabe	68		pla				pla
.aabf	91 40		sta ($40),y			sta 	(EXTAddress),y
.aac1	60		rts				rts
.aac2					EXTILInsert:
.aac2	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; end position
.aac5					_EXTILoop:
.aac5	88		dey				dey 								; back one
.aac6	cc 40 06	cpy $0640			cpy 	EXTColumn 					; exit if reached insert point.
.aac9	f0 08		beq $aad3			beq 	_EXTIExit
.aacb	88		dey				dey 								; copy one byte up.
.aacc	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aace	c8		iny				iny
.aacf	91 40		sta ($40),y			sta 	(EXTAddress),y
.aad1	80 f2		bra $aac5			bra 	_EXTILoop
.aad3					_EXTIExit:
.aad3	60		rts				rts
.aad4					EXTScrollFill:
.aad4	aa		tax				tax									; save value to fill with
.aad5	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aad7	48		pha				pha
.aad8	a5 37		lda $37				lda 	zTemp0+1
.aada	48		pha				pha
.aadb	a5 38		lda $38				lda 	zTemp1
.aadd	48		pha				pha
.aade	a5 39		lda $39				lda 	zTemp1+1
.aae0	48		pha				pha
.aae1	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aae3	85 37		sta $37				sta 	zTemp0+1
.aae5	85 39		sta $39				sta 	zTemp1+1
.aae7	64 36		stz $36				stz 	zTemp0
.aae9	ad 42 06	lda $0642			lda 	EXTScreenWidth
.aaec	85 38		sta $38				sta 	zTemp1
.aaee	a0 00		ldy #$00			ldy 	#0
.aaf0					_EXSFCopy1:
.aaf0	b1 38		lda ($38),y			lda 	(zTemp1),y
.aaf2	91 36		sta ($36),y			sta 	(zTemp0),y
.aaf4	c8		iny				iny
.aaf5	d0 f9		bne $aaf0			bne 	_EXSFCopy1
.aaf7	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aaf9	e6 39		inc $39				inc 	zTemp1+1
.aafb	a5 39		lda $39				lda 	zTemp1+1
.aafd	c9 d3		cmp #$d3			cmp 	#$D3
.aaff	d0 ef		bne $aaf0			bne 	_EXSFCopy1
.ab01	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; blank the bottom line.
.ab04	8a		txa				txa
.ab05					_EXSFFill1:
.ab05	88		dey				dey
.ab06	91 40		sta ($40),y			sta 	(EXTAddress),y
.ab08	c0 00		cpy #$00			cpy 	#0
.ab0a	10 f9		bpl $ab05			bpl 	_EXSFFill1
.ab0c	68		pla				pla
.ab0d	85 39		sta $39				sta 	zTemp1+1
.ab0f	68		pla				pla
.ab10	85 38		sta $38				sta 	zTemp1
.ab12	68		pla				pla
.ab13	85 37		sta $37				sta 	zTemp0+1
.ab15	68		pla				pla
.ab16	85 36		sta $36				sta 	zTemp0
.ab18	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063f					EXTRow:
>063f							.fill 	1
.0640					EXTColumn:
>0640							.fill 	1
.0641					EXTTextColour:
>0641							.fill 	1
.0642					EXTScreenWidth:
>0642							.fill 	1
.0643					EXTScreenHeight:
>0643							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.ab19					EXTInitialise:
.ab19	64 01		stz $01				stz 	1 							; Access I/O
.ab1b	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.ab1e	9c 08 d0	stz $d008			stz 	$D008
.ab21	9c 09 d0	stz $d009			stz 	$D009
.ab24	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.ab26	8d 58 d6	sta $d658			sta 	$D658
.ab29	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.ab2b	8d 41 06	sta $0641			sta 	EXTTextColour
.ab2e	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.ab30	8d 42 06	sta $0642			sta 	EXTScreenWidth
.ab33	a9 3c		lda #$3c			lda 	#60
.ab35	8d 43 06	sta $0643			sta 	EXTScreenHeight
.ab38	64 01		stz $01				stz 	1
.ab3a	60		rts				rts
.ab3b					EXTInputSingleCharacter:
.ab3b	da		phx				phx
.ab3c	5a		phy				phy
.ab3d					_EISCWait:
.ab3d	64 01		stz $01				stz 	1 							; access I/O Page 0
.ab3f	38		sec				sec 								; calculate timer - LastTick
.ab40	ad 59 d6	lda $d659			lda 	$D659
.ab43	aa		tax				tax 								; saving timer in X
.ab44	ed 2e 06	sbc $062e			sbc 	LastTick
.ab47	c9 03		cmp #$03			cmp 	#3
.ab49	90 06		bcc $ab51			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.ab4b	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.ab4e	20 c0 ba	jsr $bac0			jsr 	TickHandler 				; go do the code.
.ab51					_NoFireTick:
.ab51	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.ab54	c9 00		cmp #$00			cmp 	#0
.ab56	f0 e5		beq $ab3d			beq 	_EISCWait
.ab58	7a		ply				ply
.ab59	fa		plx				plx
.ab5a	60		rts				rts
.ab5b					EXTBreakCheck:
.ab5b	4c e1 ff	jmp $ffe1			jmp		$FFE1
.ab5e					EXTReadController:
.ab5e	da		phx				phx
.ab5f	a2 00		ldx #$00			ldx 	#0
.ab61	a9 05		lda #$05			lda 	#(($2D) >> 3)
.ab63	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab66	29 20		and #$20			and 	#($01 << (($2D) & 7))
.ab68	f0 04		beq $ab6e			beq 	_NoSet1
.ab6a	8a		txa				txa
.ab6b	09 01		ora #$01			ora 	#1
.ab6d	aa		tax				tax
.ab6e					_NoSet1:
.ab6e	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab70	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab73	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab75	f0 04		beq $ab7b			beq 	_NoSet1
.ab77	8a		txa				txa
.ab78	09 02		ora #$02			ora 	#2
.ab7a	aa		tax				tax
.ab7b					_NoSet1:
.ab7b	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab7d	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab80	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab82	f0 04		beq $ab88			beq 	_NoSet1
.ab84	8a		txa				txa
.ab85	09 04		ora #$04			ora 	#4
.ab87	aa		tax				tax
.ab88					_NoSet1:
.ab88	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab8a	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab8d	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab8f	f0 04		beq $ab95			beq 	_NoSet1
.ab91	8a		txa				txa
.ab92	09 08		ora #$08			ora 	#8
.ab94	aa		tax				tax
.ab95					_NoSet1:
.ab95	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab97	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab9a	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab9c	f0 04		beq $aba2			beq 	_NoSet1
.ab9e	8a		txa				txa
.ab9f	09 10		ora #$10			ora 	#16
.aba1	aa		tax				tax
.aba2					_NoSet1:
.aba2	8a		txa				txa
.aba3	fa		plx				plx
.aba4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.bac6					GRVectorTable:
>bac6	a0 ad					.word	GXInitialise             ; $00 Initialise
>bac8	ba ad					.word	GXControlBitmap          ; $01 BitmapCtl
>baca	02 ae					.word	GXControlSprite          ; $02 SpriteCtl
>bacc	52 ad					.word	GXClearBitmap            ; $03 Clear
>bace	91 af					.word	GXSetColourMode          ; $04 Colour
>bad0	59 b1					.word	GXFontHandler            ; $05 DrawFont
>bad2	a1 b1					.word	GXSpriteHandler          ; $06 DrawSprite
>bad4	0d b2					.word	GXSelect                 ; $07 SpriteUse
>bad6	36 b2					.word	GXSelectImage            ; $08 SpriteImage
>bad8	bd b3					.word	GXCollide                ; $09 SpriteCollide
>bada	04 ac					.word	GRUndefined              ; $0a
>badc	04 ac					.word	GRUndefined              ; $0b
>bade	04 ac					.word	GRUndefined              ; $0c
>bae0	04 ac					.word	GRUndefined              ; $0d
>bae2	04 ac					.word	GRUndefined              ; $0e
>bae4	04 ac					.word	GRUndefined              ; $0f
>bae6	04 ac					.word	GRUndefined              ; $10
>bae8	04 ac					.word	GRUndefined              ; $11
>baea	04 ac					.word	GRUndefined              ; $12
>baec	04 ac					.word	GRUndefined              ; $13
>baee	04 ac					.word	GRUndefined              ; $14
>baf0	04 ac					.word	GRUndefined              ; $15
>baf2	04 ac					.word	GRUndefined              ; $16
>baf4	04 ac					.word	GRUndefined              ; $17
>baf6	04 ac					.word	GRUndefined              ; $18
>baf8	04 ac					.word	GRUndefined              ; $19
>bafa	04 ac					.word	GRUndefined              ; $1a
>bafc	04 ac					.word	GRUndefined              ; $1b
>bafe	04 ac					.word	GRUndefined              ; $1c
>bb00	04 ac					.word	GRUndefined              ; $1d
>bb02	04 ac					.word	GRUndefined              ; $1e
>bb04	04 ac					.word	GRUndefined              ; $1f
>bb06	02 ac					.word	GXMove                   ; $20 Move
>bb08	5f ae					.word	GXLine                   ; $21 Line
>bb0a	da af					.word	GXFrameRectangle         ; $22 FrameRect
>bb0c	d7 af					.word	GXFillRectangle          ; $23 FillRect
>bb0e	09 ac					.word	GXFrameCircle            ; $24 FrameCircle
>bb10	05 ac					.word	GXFillCircle             ; $25 FillCircle
>bb12	04 ac					.word	GRUndefined              ; $26
>bb14	04 ac					.word	GRUndefined              ; $27
>bb16	bf af					.word	GXPlotPoint              ; $28 Plot
>bb18	cc b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5fa					gxPixelBuffer = numberBuffer
.0644					gxCurrentX:
>0644							.fill 	2
.0646					gxCurrentY:
>0646							.fill 	2
.0648					gxLastX:
>0648							.fill 	2
.064a					gxLastY:
>064a							.fill 	2
.064c					gxX0:
>064c							.fill 	2
.064e					gxY0:
>064e							.fill 	2
.0650					gxX1:
>0650							.fill 	2
.0652					gxY1:
>0652							.fill 	2
.0654					gxSpritesOn:
>0654							.fill 	1
.0655					gxBitmapsOn:
>0655							.fill 	1
.0656					gxBasePage:
>0656							.fill 	1
.0657					gxSpritePage:
>0657							.fill 	1
.0658					gxHeight:
>0658							.fill 	1
.0659					gxMode:
>0659							.fill 	1
.065a					gxColour:
>065a							.fill 	1
.065b					gxEORValue:
>065b							.fill 	1
.065c					gxANDValue:
>065c							.fill 	1
.065d					gxOriginalLUTValue:
>065d							.fill 	1
.065e					gsOffset:
>065e							.fill 	1
.065f					GSCurrentSpriteID:
>065f							.fill 	1
.0660					GSCurrentSpriteAddr:
>0660							.fill 	2
.0662					GXSpriteOffsetBase:
>0662							.fill 	2
.0664					GXSpriteLow:
>0664							.fill 	64
.06a4					GXSpriteHigh:
>06a4							.fill 	64
.aba5					GXGraphicDraw:
.aba5	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aba7	b0 06		bcs $abaf			bcs 	_GDCoordinate
.aba9	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.abab	84 37		sty $37				sty 	gxzTemp0+1
.abad	80 4b		bra $abfa			bra 	_GDExecuteA 				; and execute
.abaf					_GDCoordinate:
.abaf	48		pha				pha 								; save AXY
.abb0	da		phx				phx
.abb1	5a		phy				phy
.abb2	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.abb4					_GDCopy1:
.abb4	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.abb7	9d 48 06	sta $0648,x			sta 	gxLastX,x
.abba	ca		dex				dex
.abbb	10 f7		bpl $abb4			bpl 	_GDCopy1
.abbd	68		pla				pla 								; update Y
.abbe	8d 46 06	sta $0646			sta 	gxCurrentY
.abc1	9c 47 06	stz $0647			stz 	gxCurrentY+1
.abc4	68		pla				pla
.abc5	8d 44 06	sta $0644			sta 	gxCurrentX
.abc8	68		pla				pla 								; get A (command+X.1) back
.abc9	48		pha				pha
.abca	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.abcc	8d 45 06	sta $0645			sta 	gxCurrentX+1
.abcf	68		pla				pla 								; get command back
.abd0	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abd2	48		pha				pha 								; push back.
.abd3	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abd5	f0 17		beq $abee			beq 	_GDCopyToWorkArea
.abd7	ad 45 06	lda $0645			lda 	gxCurrentX+1 				; X < 256 X okay
.abda	f0 07		beq $abe3			beq 	_GDCheckY
.abdc	ad 44 06	lda $0644			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abdf	c9 40		cmp #$40			cmp 	#64
.abe1	b0 08		bcs $abeb			bcs 	_GDError1
.abe3					_GDCheckY:
.abe3	ad 46 06	lda $0646			lda 	gxCurrentY 					; check Y < Height.
.abe6	cd 58 06	cmp $0658			cmp 	gxHeight
.abe9	90 03		bcc $abee			bcc 	_GDCopyToWorkArea
.abeb					_GDError1:
.abeb	68		pla				pla
.abec					_GDError2:
.abec	38		sec				sec
.abed	60		rts				rts
.abee					_GDCopyToWorkArea:
.abee	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abf0					_GDCopy2:
.abf0	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.abf3	9d 4c 06	sta $064c,x			sta 	gxX0,x
.abf6	ca		dex				dex
.abf7	10 f7		bpl $abf0			bpl 	_GDCopy2
.abf9	68		pla				pla 								; get command
.abfa					_GDExecuteA:
.abfa	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abfc	b0 ee		bcs $abec			bcs 	_GDError2
.abfe	aa		tax				tax
.abff	7c c6 ba	jmp ($bac6,x)			jmp 	(GRVectorTable,x)
.ac02					GXMove:
.ac02	18		clc				clc
.ac03	60		rts				rts
.ac04					GRUndefined:
>ac04	db						.byte 	$DB 						; causes a break in the emulator
.ac05					GXFillCircle:
.ac05	a9 ff		lda #$ff			lda 	#255
.ac07	80 02		bra $ac0b			bra 	GXCircle
.ac09					GXFrameCircle:
.ac09	a9 00		lda #$00			lda 	#0
.ac0b					GXCircle:
.ac0b	8d e7 06	sta $06e7			sta 	gxIsFillMode					; save Fill flag
.ac0e	ad 55 06	lda $0655			lda 	gxBitmapsOn
.ac11	f0 26		beq $ac39			beq 	_GXCFail
.ac13	20 64 b4	jsr $b464			jsr 	GXSortXY 					; topleft/bottomright
.ac16	20 3c b3	jsr $b33c			jsr 	GXOpenBitmap 				; start drawing
.ac19	20 0b ad	jsr $ad0b			jsr 	GXCircleSetup 				; set up for drawing
.ac1c	9c e8 06	stz $06e8			stz 	gxYChanged
.ac1f					_GXCircleDraw:
.ac1f	ad e5 06	lda $06e5			lda 	gXCentre					; while x <= y
.ac22	cd e6 06	cmp $06e6			cmp 	gYCentre
.ac25	90 0a		bcc $ac31			bcc 	_GXCircleContinue
.ac27	d0 03		bne $ac2c			bne 	_GXNoLast
.ac29	20 3e ac	jsr $ac3e			jsr 	GXPlot1
.ac2c					_GXNoLast:
.ac2c	20 44 b3	jsr $b344			jsr 	GXCloseBitmap 				; close the bitmap
.ac2f	18		clc				clc
.ac30	60		rts				rts
.ac31					_GXCircleContinue:
.ac31	20 3b ac	jsr $ac3b			jsr 	GXPlot2 					; draw it
.ac34	20 b8 ac	jsr $acb8			jsr 	GXCircleMove 				; adjust the coordinates
.ac37	80 e6		bra $ac1f			bra 	_GXCircleDraw
.ac39					_GXCFail:
.ac39	38		sec				sec
.ac3a	60		rts				rts
.ac3b					GXPlot2:
.ac3b	20 3e ac	jsr $ac3e			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac3e					GXPlot1:
.ac3e	ad e6 06	lda $06e6			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac41	f0 03		beq $ac46			beq 	_GXPlot1Only
.ac43	20 62 ac	jsr $ac62			jsr 	GXPlot0 						; plot and negate
.ac46					_GXPlot1Only:
.ac46	20 62 ac	jsr $ac62			jsr 	GXPlot0 						; twice, undoing negation
.ac49	ad e5 06	lda $06e5			lda 	gXCentre 						; swap X and Y
.ac4c	ae e6 06	ldx $06e6			ldx	 	gYCentre
.ac4f	8d e6 06	sta $06e6			sta 	gYCentre
.ac52	8e e5 06	stx $06e5			stx 	gXCentre
.ac55	ad e8 06	lda $06e8			lda 	gxYChanged 						; toggle Y Changed flag
.ac58	a9 ff		lda #$ff			lda 	#$FF
.ac5a	8d e8 06	sta $06e8			sta 	gxYChanged
.ac5d	60		rts				rts
.ac5e	20 62 ac	jsr $ac62			jsr 	GXPlot0 						; do once
.ac61	60		rts				rts
.ac62	ad e7 06	lda $06e7	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac65	f0 05		beq $ac6c			beq 	_GXPlot0Always
.ac67	ad e8 06	lda $06e8			lda 	gxYChanged						; fill mode, only draw if changed.
.ac6a	f0 2d		beq $ac99			beq 	GXPlot0Exit
.ac6c					_GXPlot0Always:
.ac6c	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac6e	ad e6 06	lda $06e6			lda 	gYCentre
.ac71	20 9a ac	jsr $ac9a			jsr 	GXSubCopy
.ac74	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac76	ad e5 06	lda $06e5			lda 	gXCentre
.ac79	20 9a ac	jsr $ac9a			jsr 	GXSubCopy
.ac7c	48		pha				pha 									; save last offset X
.ac7d	20 4c b3	jsr $b34c			jsr 	GXPositionCalc 					; calculate position/offset.
.ac80	68		pla				pla
.ac81	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac82	85 36		sta $36				sta 	gxzTemp0
.ac84	64 37		stz $37				stz 	gxzTemp0+1
.ac86	26 37		rol $37				rol 	gxzTemp0+1
.ac88	ad e7 06	lda $06e7			lda 	gxIsFillMode
.ac8b	69 80		adc #$80			adc 	#128
.ac8d	20 2a b0	jsr $b02a			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac90	38		sec				sec 									; GY = -GY
.ac91	a9 00		lda #$00			lda 	#0
.ac93	ed e6 06	sbc $06e6			sbc 	gYCentre
.ac96	8d e6 06	sta $06e6			sta 	gYCentre
.ac99					GXPlot0Exit:
.ac99	60		rts				rts
.ac9a					GXSubCopy:
.ac9a	85 36		sta $36				sta 	gxzTemp0
.ac9c	64 37		stz $37				stz 	gxzTemp0+1
.ac9e	29 80		and #$80			and 	#$80
.aca0	f0 02		beq $aca4			beq 	_GXNoSx
.aca2	c6 37		dec $37				dec 	gxzTemp0+1
.aca4					_GXNoSx:
.aca4	38		sec				sec
.aca5	bd 50 06	lda $0650,x			lda 	gXX1,x
.aca8	e5 36		sbc $36				sbc 	gxzTemp0
.acaa	9d 4c 06	sta $064c,x			sta 	gXX0,x
.acad	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.acb0	e5 37		sbc $37				sbc 	gxzTemp0+1
.acb2	9d 4d 06	sta $064d,x			sta 	gXX0+1,x
.acb5	a5 36		lda $36				lda 	gxzTemp0 						; return A
.acb7	60		rts				rts
.acb8					GXCircleMove:
.acb8	9c e8 06	stz $06e8			stz 	gxYChanged 					; clear Y changed flag
.acbb	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.acbd	10 0d		bpl $accc			bpl 	_GXEMPositive
.acbf	ee e5 06	inc $06e5			inc 	gXCentre 					; X++
.acc2	ad e5 06	lda $06e5			lda 	gXCentre
.acc5	20 eb ac	jsr $aceb			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acc8	a9 06		lda #$06			lda 	#6  						; and add 6
.acca	80 15		bra $ace1			bra 	_GXEMAddD
.accc					_GXEMPositive:
.accc	ee e5 06	inc $06e5			inc 	gXCentre					; X++
.accf	ce e6 06	dec $06e6			dec 	gyCentre 					; Y--
.acd2	38		sec				sec 								; calculate X-Y
.acd3	ad e5 06	lda $06e5			lda 	gXCentre
.acd6	ed e6 06	sbc $06e6			sbc 	gYCentre
.acd9	20 eb ac	jsr $aceb			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acdc	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acde	ce e8 06	dec $06e8			dec 	gxYChanged
.ace1					_GXEMAddD:
.ace1	18		clc				clc
.ace2	65 38		adc $38				adc 	gxzTemp1
.ace4	85 38		sta $38				sta 	gxzTemp1
.ace6	90 02		bcc $acea			bcc 	_GXEMNoCarry
.ace8	e6 39		inc $39				inc 	gxzTemp1+1
.acea					_GXEMNoCarry:
.acea	60		rts				rts
.aceb					_GXAdd4TimesToD:
.aceb	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.aced	29 80		and #$80			and 	#$80
.acef	f0 02		beq $acf3			beq 	_GXA4Unsigned
.acf1	a9 ff		lda #$ff			lda 	#$FF
.acf3					_GXA4Unsigned:
.acf3	85 37		sta $37				sta 	gxzTemp0+1
.acf5	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acf7	26 37		rol $37				rol 	gxzTemp0+1
.acf9	06 36		asl $36				asl 	gxzTemp0
.acfb	26 37		rol $37				rol 	gxzTemp0+1
.acfd	18		clc				clc 								; add
.acfe	a5 36		lda $36				lda		gxzTemp0
.ad00	65 38		adc $38				adc 	gxzTemp1
.ad02	85 38		sta $38				sta 	gxzTemp1
.ad04	a5 37		lda $37				lda		gxzTemp0+1
.ad06	65 39		adc $39				adc 	gxzTemp1+1
.ad08	85 39		sta $39				sta 	gxzTemp1+1
.ad0a	60		rts				rts
.ad0b					GXCircleSetup:
.ad0b	38		sec				sec
.ad0c	ad 52 06	lda $0652			lda 	gxY1
.ad0f	ed 4e 06	sbc $064e			sbc 	gxY0
.ad12	4a		lsr a				lsr 	a
.ad13	8d e4 06	sta $06e4			sta 	gxRadius
.ad16	a2 00		ldx #$00			ldx 	#0
.ad18	20 3a ad	jsr $ad3a			jsr 	_GXCalculateCentre
.ad1b	a2 02		ldx #$02			ldx 	#2
.ad1d	20 3a ad	jsr $ad3a			jsr 	_GXCalculateCentre
.ad20	9c e5 06	stz $06e5			stz 	gXCentre
.ad23	ad e4 06	lda $06e4			lda 	gxRadius
.ad26	8d e6 06	sta $06e6			sta 	gYCentre
.ad29	0a		asl a				asl 	a 							; R x 2
.ad2a	85 36		sta $36				sta 	gxzTemp0
.ad2c	38		sec				sec
.ad2d	a9 03		lda #$03			lda 	#3
.ad2f	e5 36		sbc $36				sbc 	gxzTemp0
.ad31	85 38		sta $38				sta 	gxzTemp1
.ad33	a9 00		lda #$00			lda 	#0
.ad35	e9 00		sbc #$00			sbc 	#0
.ad37	85 39		sta $39				sta 	gxzTemp1+1
.ad39	60		rts				rts
.ad3a					_GXCalculateCentre:
.ad3a	38		sec				sec
.ad3b	bd 50 06	lda $0650,x			lda 	gxX1,x
.ad3e	7d 4c 06	adc $064c,x			adc 	gXX0,x
.ad41	9d 50 06	sta $0650,x			sta 	gXX1,x
.ad44	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ad47	7d 4d 06	adc $064d,x			adc 	gXX0+1,x
.ad4a	4a		lsr a				lsr 	a
.ad4b	9d 51 06	sta $0651,x			sta 	gXX1+1,x
.ad4e	7e 50 06	ror $0650,x			ror 	gXX1,x
.ad51	60		rts				rts
.06e4					gxRadius:
>06e4							.fill 	1
.06e5					gXCentre:
>06e5							.fill 	1
.06e6					gYCentre:
>06e6							.fill 	1
.06e7					gxIsFillMode:
>06e7							.fill 	1
.06e8					gxYChanged:
>06e8							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad52					GXClearBitmap:
.ad52	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP running.
.ad55	f0 24		beq $ad7b			beq 	_GXCBFail
.ad57	20 3c b3	jsr $b33c			jsr 	GXOpenBitmap 				; start access
.ad5a	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad5c	ad 58 06	lda $0658			lda 	gxHeight
.ad5f	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad61	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad63					_GXCalcLastPage:
.ad63	98		tya				tya 								; add to base page
.ad64	18		clc				clc
.ad65	6d 56 06	adc $0656			adc 	gxBasePage
.ad68	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad6a					_GXClearAll:
.ad6a	20 7d ad	jsr $ad7d			jsr 	_GXClearBlock 				; clear 8k block
.ad6d	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad6f	a5 0b		lda $0b				lda 	GXEditSlot
.ad71	cd 56 06	cmp $0656			cmp 	gxBasePage 					; until before base page
.ad74	b0 f4		bcs $ad6a			bcs 	_GXClearAll
.ad76	20 44 b3	jsr $b344			jsr 	GXCloseBitmap	 			; stop access
.ad79	18		clc				clc
.ad7a	60		rts				rts
.ad7b					_GXCBFail:
.ad7b	38		sec				sec
.ad7c	60		rts				rts
.ad7d					_GXClearBlock:
.ad7d	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad7f	85 38		sta $38				sta 	0+gxzTemp1
.ad81	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad83	85 39		sta $39				sta 	1+gxzTemp1
.ad85					_GXCB0:
.ad85	a5 36		lda $36				lda 	gxzTemp0
.ad87	a0 00		ldy #$00			ldy 	#0
.ad89					_GXCB1:
.ad89	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad8b	c8		iny				iny
.ad8c	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad8e	c8		iny				iny
.ad8f	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad91	c8		iny				iny
.ad92	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad94	c8		iny				iny
.ad95	d0 f2		bne $ad89			bne 	_GXCB1
.ad97	e6 39		inc $39				inc 	gxzTemp1+1
.ad99	a5 39		lda $39				lda 	gxzTemp1+1
.ad9b	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad9d	d0 e6		bne $ad85			bne 	_GXCB0
.ad9f	60		rts				rts
.ada0					GXInitialise:
.ada0	64 01		stz $01				stz 	1
.ada2	a9 01		lda #$01			lda 	#1
.ada4	8d 00 d0	sta $d000			sta 	$D000
.ada7	18		clc				clc
.ada8	9c 54 06	stz $0654			stz 	GXSpritesOn
.adab	9c 55 06	stz $0655			stz 	GXBitmapsOn
.adae	a2 0f		ldx #$0f			ldx 	#15
.adb0					_GXIClear:
.adb0	9e 44 06	stz $0644,x			stz 	gxCurrentX,x
.adb3	ca		dex				dex
.adb4	10 fa		bpl $adb0			bpl 	_GXIClear
.adb6	20 51 ae	jsr $ae51			jsr 	GXClearSpriteStore
.adb9	60		rts				rts
.adba					GXControlBitmap:
.adba	64 01		stz $01				stz 	1
.adbc	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adbe	29 01		and #$01			and 	#1 							; set bitmap flag
.adc0	8d 55 06	sta $0655			sta 	gxBitmapsOn
.adc3	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adc4	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adc7	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adc9	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.adcb	90 02		bcc $adcf			bcc 	_CBNotOn
.adcd	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.adcf					_CBNotOn:
.adcf	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.add2	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.add4	29 07		and #$07			and 	#7
.add6	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.add9	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.addb	d0 02		bne $addf			bne 	_CBNotDefault
.addd	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.addf					_CBNotDefault:
.addf	8d 56 06	sta $0656			sta 	gxBasePage
.ade2	20 43 ae	jsr $ae43			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ade5	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ade7	8d 03 d1	sta $d103			sta 	$D103
.adea	a5 36		lda $36				lda 	gxzTemp0
.adec	8d 02 d1	sta $d102			sta 	$D102
.adef	9c 01 d1	stz $d101			stz 	$D101
.adf2	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.adf4	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.adf7	29 01		and #$01			and 	#1
.adf9	f0 02		beq $adfd			beq 	_CBHaveHeight
.adfb	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.adfd					_CBHaveHeight
.adfd	8e 58 06	stx $0658			stx 	gxHeight
.ae00	18		clc				clc
.ae01	60		rts				rts
.ae02					GXControlSprite:
.ae02	64 01		stz $01				stz 	1
.ae04	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ae06	29 01		and #$01			and 	#1 							; set sprites flag
.ae08	8d 54 06	sta $0654			sta 	gxSpritesOn
.ae0b	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ae0c	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ae0f	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ae11	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ae13	90 02		bcc $ae17			bcc 	_CSNotOn
.ae15	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ae17					_CSNotOn:
.ae17	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ae1a	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ae1c	d0 02		bne $ae20			bne 	_CSNotDefault
.ae1e	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ae20					_CSNotDefault:
.ae20	8d 57 06	sta $0657			sta 	gxSpritePage
.ae23	20 43 ae	jsr $ae43			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae26	a5 36		lda $36				lda 	zTemp0
.ae28	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase
.ae2b	a5 37		lda $37				lda 	zTemp0+1
.ae2d	8d 63 06	sta $0663			sta 	GXSpriteOffsetBase+1
.ae30	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae32					_CSClear:
.ae32	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae35	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae38	ca		dex				dex
.ae39	d0 f7		bne $ae32			bne 	_CSClear
.ae3b	9c 61 06	stz $0661			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae3e	20 51 ae	jsr $ae51			jsr 	GXClearSpriteStore
.ae41	18		clc				clc
.ae42	60		rts				rts
.ae43					GXCalculateBaseAddress:
.ae43	85 36		sta $36				sta 	gxzTemp0
.ae45	64 37		stz $37				stz 	gxzTemp0+1
.ae47	a9 05		lda #$05			lda 	#5
.ae49					_GXShift:
.ae49	06 36		asl $36				asl 	gxzTemp0
.ae4b	26 37		rol $37				rol 	gxzTemp0+1
.ae4d	3a		dec a				dec		a
.ae4e	d0 f9		bne $ae49			bne 	_GXShift
.ae50	60		rts				rts
.ae51					GXClearSpriteStore:
.ae51	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae53					_GXCSSLoop:
.ae53	9e a4 06	stz $06a4,x			stz 	GXSpriteHigh,x
.ae56	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae58	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.ae5b	ca		dex				dex
.ae5c	10 f5		bpl $ae53			bpl 	_GXCSSLoop
.ae5e	60		rts				rts
.ae5f					GXLine:
.ae5f	ad 55 06	lda $0655			lda 	GXBitmapsOn
.ae62	f0 28		beq $ae8c			beq 	_GXLFail
.ae64	20 3c b3	jsr $b33c			jsr 	GXOpenBitmap
.ae67	20 82 b4	jsr $b482			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae6a	20 32 af	jsr $af32			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae6d	20 4c b3	jsr $b34c			jsr 	GXPositionCalc 				; calculate position/offset.
.ae70					_GXDrawLoop:
.ae70	ac 5e 06	ldy $065e			ldy 	gsOffset 					; draw the pixel
.ae73	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae75	2d 5c 06	and $065c			and 	gxANDValue
.ae78	4d 5b 06	eor $065b			eor 	gxEORValue
.ae7b	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae7d	20 8e ae	jsr $ae8e			jsr 	GXLineIsComplete 			; is the line complete ?
.ae80	f0 05		beq $ae87			beq 	_GXLExit
.ae82	20 a9 ae	jsr $aea9			jsr 	GXLineAdvance 				; code as per advance method
.ae85	80 e9		bra $ae70			bra 	_GXDrawLoop
.ae87					_GXLExit:
.ae87	20 44 b3	jsr $b344			jsr 	GXCloseBitmap
.ae8a	18		clc				clc
.ae8b	60		rts				rts
.ae8c					_GXLFail:
.ae8c	38		sec				sec
.ae8d	60		rts				rts
.ae8e					GXLineIsComplete:
.ae8e	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger 			; is dy larger
.ae91	d0 0f		bne $aea2			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae93	ad 4c 06	lda $064c			lda 	GXX0 						; compare X, LSB and MSB
.ae96	4d 50 06	eor $0650			eor 	GXX1
.ae99	d0 06		bne $aea1			bne 	_GXLICExit
.ae9b	ad 4d 06	lda $064d			lda 	GXX0+1
.ae9e	4d 51 06	eor $0651			eor 	GXX1+1
.aea1					_GXLICExit:
.aea1	60		rts				rts
.aea2					_GXLICCompareY:
.aea2	ad 52 06	lda $0652			lda 	GXY1
.aea5	4d 4e 06	eor $064e			eor 	GXY0
.aea8	60		rts				rts
.aea9					GXLineAdvance:
.aea9	18		clc				clc 								; add adjust to position
.aeaa	ad ed 06	lda $06ed			lda 	GXPosition
.aead	6d ee 06	adc $06ee			adc 	GXAdjust
.aeb0	8d ed 06	sta $06ed			sta 	GXPosition
.aeb3	9c f0 06	stz $06f0			stz 	GXAddSelect 				; clear add select flag
.aeb6	b0 05		bcs $aebd			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.aeb8	cd ef 06	cmp $06ef			cmp 	GXTotal 					; if exceeded total
.aebb	90 0a		bcc $aec7			bcc 	_GXLANoExtra
.aebd					_GXLAOverflow:
.aebd	ce f0 06	dec $06f0			dec 	GXAddSelect 				; set addselect to $FF
.aec0	38		sec				sec 								; subtract total and write back
.aec1	ed ef 06	sbc $06ef			sbc 	GXTotal
.aec4	8d ed 06	sta $06ed			sta 	GXPosition
.aec7					_GXLANoExtra:
.aec7	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger
.aeca	f0 0d		beq $aed9			beq 	_GXDXLarger
.aecc	20 2b af	jsr $af2b			jsr 	GXIncrementY
.aecf	ad f0 06	lda $06f0			lda 	GXAddSelect
.aed2	f0 10		beq $aee4			beq 	_GXLAExit
.aed4	20 e5 ae	jsr $aee5			jsr 	GXAdjustX
.aed7	80 0b		bra $aee4			bra 	_GXLAExit
.aed9					_GXDXLarger:
.aed9	20 e5 ae	jsr $aee5			jsr 	GXAdjustX
.aedc	ad f0 06	lda $06f0			lda 	GXAddSelect
.aedf	f0 03		beq $aee4			beq 	_GXLAExit
.aee1	20 2b af	jsr $af2b			jsr 	GXIncrementY
.aee4					_GXLAExit:
.aee4	60		rts				rts
.aee5					GXAdjustX:
.aee5	ad ec 06	lda $06ec			lda 	GXDXNegative
.aee8	10 25		bpl $af0f			bpl 	_GXAXRight
.aeea	ad 4c 06	lda $064c			lda 	GXX0
.aeed	d0 03		bne $aef2			bne 	_GXAXNoBorrow
.aeef	ce 4d 06	dec $064d			dec 	GXX0+1
.aef2					_GXAXNoBorrow:
.aef2	ce 4c 06	dec $064c			dec 	GXX0
.aef5	ce 5e 06	dec $065e			dec 	gsOffset 					; pixel left
.aef8	ad 5e 06	lda $065e			lda 	gsOffset
.aefb	c9 ff		cmp #$ff			cmp 	#$FF
.aefd	d0 0f		bne $af0e			bne 	_GXAYExit 					; underflow
.aeff	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.af01	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.af03	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.af05	b0 07		bcs $af0e			bcs 	_GXAYExit
.af07	18		clc				clc
.af08	69 20		adc #$20			adc 	#$20 						; fix up
.af0a	85 3d		sta $3d				sta 	gxzScreen+1
.af0c	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.af0e					_GXAYExit:
.af0e	60		rts				rts
.af0f					_GXAXRight:
.af0f	ee 4c 06	inc $064c			inc 	GXX0
.af12	d0 03		bne $af17			bne 	_GXAXNoCarry
.af14	ee 4d 06	inc $064d			inc 	GXX0+1
.af17					_GXAXNoCarry:
.af17	ee 5e 06	inc $065e			inc 	gsOffset 					; pixel right
.af1a	d0 0e		bne $af2a			bne 	_GXAXExit 					; if not overflowed, exit.
.af1c	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.af1e	a5 3d		lda $3d				lda 	gxzScreen+1
.af20	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.af22	90 06		bcc $af2a			bcc 	_GXAXExit
.af24	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af26	85 3d		sta $3d				sta 	gxzScreen+1
.af28	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af2a					_GXAXExit:
.af2a	60		rts				rts
.af2b					GXIncrementY:
.af2b	ee 4e 06	inc $064e			inc 	GXY0
.af2e	20 a2 b3	jsr $b3a2			jsr 	GXMovePositionDown
.af31	60		rts				rts
.af32					GXLineSetup:
.af32	ad 52 06	lda $0652			lda 	GXY1
.af35	38		sec				sec
.af36	ed 4e 06	sbc $064e			sbc 	GXY0
.af39	4a		lsr a				lsr 	a
.af3a	8d ea 06	sta $06ea			sta 	GXDiffY
.af3d	9c ec 06	stz $06ec			stz 	GXDXNegative 				; clear -ve flag
.af40	38		sec				sec
.af41	ad 50 06	lda $0650			lda 	GXX1
.af44	ed 4c 06	sbc $064c			sbc 	GXX0
.af47	8d e9 06	sta $06e9			sta 	GXDiffX
.af4a	ad 51 06	lda $0651			lda 	GXX1+1 						; calculate MSB
.af4d	ed 4d 06	sbc $064d			sbc 	GXX0+1
.af50	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af51	6e e9 06	ror $06e9			ror 	GXDiffX
.af54	0a		asl a				asl 	a
.af55	10 0c		bpl $af63			bpl 	_GDXNotNegative
.af57	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af59	38		sec				sec
.af5a	ed e9 06	sbc $06e9			sbc 	GXDiffX
.af5d	8d e9 06	sta $06e9			sta 	GXDiffX
.af60	ce ec 06	dec $06ec			dec 	GXDXNegative 				; -ve flag = $FF.
.af63					_GDXNotNegative:
.af63	9c eb 06	stz $06eb			stz 	GXIsDiffYLarger 			; clear larger flag
.af66	ad ea 06	lda $06ea			lda 	GXDiffY 					; set adjust and total.
.af69	8d ee 06	sta $06ee			sta 	GXAdjust
.af6c	ad e9 06	lda $06e9			lda 	GXDiffX
.af6f	8d ef 06	sta $06ef			sta 	GXTotal
.af72	ad ea 06	lda $06ea			lda 	GXDiffY 					; if dy > dx
.af75	cd e9 06	cmp $06e9			cmp 	GXDiffX
.af78	90 0f		bcc $af89			bcc 	_GDXNotLarger
.af7a	ce eb 06	dec $06eb			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af7d	ad e9 06	lda $06e9			lda 	GXDiffX 					; set adjust and total other way round
.af80	8d ee 06	sta $06ee			sta 	GXAdjust
.af83	ad ea 06	lda $06ea			lda 	GXDiffY
.af86	8d ef 06	sta $06ef			sta 	GXTotal
.af89					_GDXNotLarger:
.af89	ad ef 06	lda $06ef			lda 	GXTotal
.af8c	4a		lsr a				lsr 	a
.af8d	8d ed 06	sta $06ed			sta 	GXPosition
.af90	60		rts				rts
.06e9					GXDiffX:
>06e9							.fill 	1
.06ea					GXDiffY:
>06ea							.fill 	1
.06eb					GXIsDiffYLarger:
>06eb							.fill 	1
.06ec					GXDXNegative:
>06ec							.fill 	1
.06ed					GXPosition:
>06ed							.fill 	1
.06ee					GXAdjust:
>06ee							.fill 	1
.06ef					GXTotal:
>06ef							.fill 	1
.06f0					GXAddSelect:
>06f0							.fill 	1
.af91					GXSetColourMode:
.af91	a6 36		ldx $36				ldx 	gxzTemp0
.af93	8e 5a 06	stx $065a			stx 	gxColour 								; set colour
.af96	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af98	8d 59 06	sta $0659			sta 	gxMode 									; set mode
.af9b	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af9d	9c 5c 06	stz $065c			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.afa0	ae 5a 06	ldx $065a			ldx 	gxColour
.afa3	8e 5b 06	stx $065b			stx 	gxEORValue
.afa6	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.afa8	90 03		bcc $afad			bcc 	_GXSDCNotAndColour
.afaa	8e 5c 06	stx $065c			stx 	gxANDValue
.afad					_GXSDCNotAndColour:
.afad	d0 03		bne $afb2			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.afaf	9c 5b 06	stz $065b			stz 	gxEORValue
.afb2					_GXSDCNotAnd:
.afb2	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.afb3	90 08		bcc $afbd			bcc 	_GXSDCNoFlip
.afb5	ad 5c 06	lda $065c			lda	 	gxANDValue
.afb8	49 ff		eor #$ff			eor 	#$FF
.afba	8d 5c 06	sta $065c			sta 	gxANDValue
.afbd					_GXSDCNoFlip:
.afbd	18		clc				clc
.afbe	60		rts				rts
.afbf					GXPlotPoint:
.afbf	20 3c b3	jsr $b33c			jsr 	GXOpenBitmap 				; start drawing
.afc2	20 4c b3	jsr $b34c			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afc5	ac 5e 06	ldy $065e			ldy 	gsOffset
.afc8	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afca	2d 5c 06	and $065c			and 	gxANDValue
.afcd	4d 5b 06	eor $065b			eor 	gxEORValue
.afd0	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afd2	20 44 b3	jsr $b344			jsr 	GXCloseBitmap 				; stop drawing and exit
.afd5	18		clc				clc
.afd6	60		rts				rts
.afd7					GXFillRectangle:
.afd7	38		sec				sec
.afd8	80 01		bra $afdb			bra 	GXRectangle
.afda					GXFrameRectangle:
.afda	18		clc				clc
.afdb					GXRectangle:
.afdb	ad 55 06	lda $0655			lda 	gxBitmapsOn
.afde	f0 35		beq $b015			beq 	_GXRFail
.afe0	08		php				php 								; save Fill flag (CS)
.afe1	20 3c b3	jsr $b33c			jsr 	GXOpenBitmap 				; start drawing
.afe4	20 64 b4	jsr $b464			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afe7	20 4c b3	jsr $b34c			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afea	38		sec				sec 								; sec = Draw line
.afeb	20 17 b0	jsr $b017			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afee	ad 4e 06	lda $064e			lda 	gxY0 						; reached end of rectangle ?
.aff1	cd 52 06	cmp $0652			cmp 	gxY1
.aff4	f0 19		beq $b00f			beq 	_GXRectangleExit
.aff6					_GXRectLoop:
.aff6	20 a2 b3	jsr $b3a2			jsr 	GXMovePositionDown 			; down one.
.aff9	ee 4e 06	inc $064e			inc 	gxY0 						; change Y pos
.affc	ad 4e 06	lda $064e			lda 	gxY0 						; reached last line
.afff	cd 52 06	cmp $0652			cmp 	gXY1
.b002	f0 07		beq $b00b			beq 	_GXLastLine
.b004	28		plp				plp 								; get flag back
.b005	08		php				php
.b006	20 17 b0	jsr $b017			jsr 	GXDrawLineX1X0 				; draw horizontal line
.b009	80 eb		bra $aff6			bra 	_GXRectLoop
.b00b					_GXLastLine:
.b00b	38		sec				sec
.b00c	20 17 b0	jsr $b017			jsr 	GXDrawLineX1X0
.b00f					_GXRectangleExit:
.b00f	68		pla				pla 								; throw fill flag.
.b010	20 44 b3	jsr $b344			jsr 	GXCloseBitmap 				; stop drawing and exit
.b013	18		clc				clc
.b014	60		rts				rts
.b015					_GXRFail:
.b015	38		sec				sec
.b016	60		rts				rts
.b017					GXDrawLineX1X0:
.b017	08		php				php 								; save solid/either-end
.b018	38		sec				sec
.b019	ad 50 06	lda $0650			lda		gXX1
.b01c	ed 4c 06	sbc $064c			sbc 	gXX0
.b01f	85 36		sta $36				sta 	gxzTemp0
.b021	ad 51 06	lda $0651			lda 	gXX1+1
.b024	ed 4d 06	sbc $064d			sbc 	gXX0+1
.b027	85 37		sta $37				sta 	gxzTemp0+1
.b029	28		plp				plp
.b02a					GXDrawLineTemp0:
.b02a	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b02c	48		pha				pha
.b02d	a5 3d		lda $3d				lda 	gxzScreen+1
.b02f	48		pha				pha
.b030	ad 5e 06	lda $065e			lda 	gsOffset
.b033	48		pha				pha
.b034	a5 0b		lda $0b				lda 	GXEditSlot
.b036	48		pha				pha
.b037	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y offset
.b03a	90 1e		bcc $b05a			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b03c					_GXDLTLine:
.b03c	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b03e	2d 5c 06	and $065c			and 	gxANDValue
.b041	4d 5b 06	eor $065b			eor 	gxEORValue
.b044	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b046	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b048	d0 04		bne $b04e			bne 	_GXDLTNoBorrow
.b04a	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b04c	30 2e		bmi $b07c			bmi 	_GXDLTExit
.b04e					_GXDLTNoBorrow:
.b04e	c6 36		dec $36				dec 	gxzTemp0
.b050	c8		iny				iny 								; next slot.
.b051	d0 e9		bne $b03c			bne 	_GXDLTLine
.b053	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b055	20 8a b0	jsr $b08a			jsr 	GXDLTCheckWrap				; check for new page.
.b058	80 e2		bra $b03c			bra 	_GXDLTLine
.b05a					_GXDLTEndPoints:
.b05a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b05c	2d 5c 06	and $065c			and 	gxANDValue
.b05f	4d 5b 06	eor $065b			eor 	gxEORValue
.b062	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b064	98		tya				tya 								; advance to right side
.b065	18		clc				clc
.b066	65 36		adc $36				adc 	gxzTemp0
.b068	a8		tay				tay
.b069	a5 3d		lda $3d				lda 	gxzScreen+1
.b06b	65 37		adc $37				adc 	gxzTemp0+1
.b06d	85 3d		sta $3d				sta 	gxzScreen+1
.b06f	20 8a b0	jsr $b08a			jsr 	GXDLTCheckWrap 			; fix up.
.b072	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b074	2d 5c 06	and $065c			and 	gxANDValue
.b077	4d 5b 06	eor $065b			eor 	gxEORValue
.b07a	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b07c					_GXDLTExit:
.b07c	68		pla				pla
.b07d	85 0b		sta $0b				sta 	GXEditSlot
.b07f	68		pla				pla
.b080	8d 5e 06	sta $065e			sta 	gsOffset
.b083	68		pla				pla
.b084	85 3d		sta $3d				sta 	gxzScreen+1
.b086	68		pla				pla
.b087	85 3c		sta $3c				sta 	gxzScreen
.b089	60		rts				rts
.b08a					GXDLTCheckWrap:
.b08a	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b08c	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b08e	90 06		bcc $b096			bcc 	_GXDLTCWExit
.b090	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b092	85 3d		sta $3d				sta 	gxzScreen+1
.b094	e6 0b		inc $0b				inc 	GXEditSlot
.b096					_GXDLTCWExit:
.b096	60		rts				rts
.b097					GXDrawGraphicElement:
.b097	8d f1 06	sta $06f1			sta 	gxSize 						; save size
.b09a	3a		dec a				dec 	a
.b09b	8d f2 06	sta $06f2			sta 	gxMask 						; and mask
.b09e	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP on
.b0a1	f0 67		beq $b10a			beq 	_GXSLFail
.b0a3	ad 4e 06	lda $064e			lda 	gxY0 						; push Y on stack
.b0a6	48		pha				pha
.b0a7	8c f4 06	sty $06f4			sty 	gxAcquireVector+1 			; and acquisition vector
.b0aa	8e f3 06	stx $06f3			stx 	gxAcquireVector
.b0ad	20 3c b3	jsr $b33c			jsr 	gxOpenBitmap 				; open the bitmap.
.b0b0	ad f6 06	lda $06f6			lda 	gxUseMode 					; scale bits
.b0b3	4a		lsr a				lsr 	a
.b0b4	4a		lsr a				lsr 	a
.b0b5	4a		lsr a				lsr 	a
.b0b6	29 07		and #$07			and		#7
.b0b8	1a		inc a				inc 	a
.b0b9	8d f5 06	sta $06f5			sta 	gxScale
.b0bc	64 38		stz $38				stz 	gxzTemp1					; start first line
.b0be					_GXGELoop:
.b0be	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b0c0	2c f6 06	bit $06f6			bit 	gxUseMode 					; check for flip.
.b0c3	10 06		bpl $b0cb			bpl		_GXNoVFlip
.b0c5	ad f2 06	lda $06f2			lda 	gxMask
.b0c8	38		sec				sec
.b0c9	e5 38		sbc $38				sbc 	gxzTemp1
.b0cb					_GXNoVFlip:
.b0cb	aa		tax				tax 								; get the Xth line.
.b0cc	20 0c b1	jsr $b10c			jsr 	_GXCallAcquire 				; get that data.
.b0cf	ad f5 06	lda $06f5			lda 	gxScale 					; do scale identical copies of that line.
.b0d2	85 39		sta $39				sta 	gxzTemp1+1
.b0d4					_GXGELoop2:
.b0d4	ad 4e 06	lda $064e			lda 	gxY0 						; off screen
.b0d7	cd 58 06	cmp $0658			cmp 	gxHeight
.b0da	b0 10		bcs $b0ec			bcs 	_GXDGEExit
.b0dc	20 0f b1	jsr $b10f			jsr 	GXRenderOneLine 			; render line
.b0df	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0e1	d0 f1		bne $b0d4			bne 	_GXGELoop2
.b0e3	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0e5	a5 38		lda $38				lda 	gxzTemp1
.b0e7	cd f1 06	cmp $06f1			cmp 	gxSize
.b0ea	d0 d2		bne $b0be			bne 	_GXGELoop
.b0ec					_GXDGEExit:
.b0ec	68		pla				pla 								; restore Y for next time
.b0ed	8d 4e 06	sta $064e			sta 	gxY0
.b0f0	ae f5 06	ldx $06f5			ldx 	gxScale 					; get scale (1-8)
.b0f3					_GXShiftLeft:
.b0f3	18		clc				clc
.b0f4	ad f1 06	lda $06f1			lda 	gxSize
.b0f7	6d 4c 06	adc $064c			adc 	gxX0
.b0fa	8d 4c 06	sta $064c			sta 	gxX0
.b0fd	90 03		bcc $b102			bcc 	_GXSLNoCarry
.b0ff	ee 4d 06	inc $064d			inc 	gxX0+1
.b102					_GXSLNoCarry:
.b102	ca		dex				dex
.b103	d0 ee		bne $b0f3			bne 	_GXShiftLeft
.b105	20 44 b3	jsr $b344			jsr 	GXCloseBitmap
.b108	18		clc				clc
.b109	60		rts				rts
.b10a					_GXSLFail:
.b10a	38		sec				sec
.b10b	60		rts				rts
.b10c					_GXCallAcquire:
.b10c	6c f3 06	jmp ($06f3)			jmp 	(gxAcquireVector)
.b10f					GXRenderOneLine:
.b10f	20 4c b3	jsr $b34c			jsr 	GXPositionCalc 				; calculate position/offset.
.b112	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y contains position.
.b115	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b117					_GXROLLoop1:
.b117	ad f5 06	lda $06f5			lda 	gxScale 					; set to do 'scale' times
.b11a	85 3b		sta $3b				sta 	gxzTemp2+1
.b11c					_GXROLLoop2:
.b11c	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b11e	2c 59 06	bit $0659			bit 	gxMode 						; check H Flip
.b121	50 06		bvc $b129			bvc 	_GXNoHFlip
.b123	ad f2 06	lda $06f2			lda 	gxMask
.b126	38		sec				sec
.b127	e5 3a		sbc $3a				sbc 	gxzTemp2
.b129					_GXNoHFlip:
.b129	aa		tax				tax 								; read from the pixel buffer
.b12a	bd fa 05	lda $05fa,x			lda 	gxPixelBuffer,x
.b12d	d0 07		bne $b136			bne 	_GXDraw 					; draw if non zero
.b12f	ad f6 06	lda $06f6			lda 	gxUseMode 					; check to see if solid background
.b132	29 04		and #$04			and 	#4
.b134	f0 0a		beq $b140			beq 	_GXZeroPixel
.b136					_GXDraw:
.b136	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b138	2d 5c 06	and $065c			and 	gxANDValue
.b13b	5d fa 05	eor $05fa,x			eor 	gxPixelBuffer,x
.b13e	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b140					_GXZeroPixel:
.b140	c8		iny				iny 								; advance pointer
.b141	d0 05		bne $b148			bne 	_GXNoShift
.b143	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b145	20 8a b0	jsr $b08a			jsr 	GXDLTCheckWrap				; check for new page.
.b148					_GXNoShift:
.b148	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b14a	d0 d0		bne $b11c			bne 	_GXROLLoop2
.b14c	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b14e	a5 3a		lda $3a				lda 	gxzTemp2
.b150	cd f1 06	cmp $06f1			cmp 	gxSize
.b153	d0 c2		bne $b117			bne 	_GXROLLoop1
.b155	ee 4e 06	inc $064e			inc 	gxY0
.b158	60		rts				rts
.06f1					gxSize:
>06f1							.fill 	1
.06f2					gxMask:
>06f2							.fill 	1
.06f3					gxAcquireVector:
>06f3							.fill 	2
.06f5					gxScale:
>06f5							.fill 	1
.06f6					gxUseMode:
>06f6							.fill 	1
.b159					GXFontHandler:
.b159	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b15b	4d 59 06	eor $0659			eor 	gxMode
.b15e	8d f6 06	sta $06f6			sta 	gxUseMode
.b161	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b163	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b165	26 37		rol $37				rol	 	gxzTemp0+1
.b167	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b169	26 37		rol $37				rol	 	gxzTemp0+1
.b16b	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b16d	26 37		rol $37				rol	 	gxzTemp0+1
.b16f	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b171	09 c0		ora #$c0			ora 	#$C0
.b173	85 37		sta $37				sta 	gxzTemp0+1
.b175	a9 08		lda #$08			lda 	#8 							; size 8x8
.b177	a2 7f		ldx #$7f			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b179	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b17b	20 97 b0	jsr $b097			jsr 	GXDrawGraphicElement
.b17e	60		rts				rts
.b17f					GXGetGraphicDataFont:
.b17f	8a		txa				txa 								; X->Y
.b180	a8		tay				tay
.b181	a6 01		ldx $01				ldx 	1 							; preserve old value
.b183	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b185	85 01		sta $01				sta 	1
.b187	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b189	86 01		stx $01				stx 	1 							; put old value back.
.b18b	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b18d					_GXExpand:
.b18d	9e fa 05	stz $05fa,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b190	0a		asl a				asl 	a 							; shift bit 7 into C
.b191	90 08		bcc $b19b			bcc 	_GXNoPixel
.b193	48		pha				pha 								; if set, set pixel buffer to current colour.
.b194	ad 5a 06	lda $065a			lda 	gxColour
.b197	9d fa 05	sta $05fa,x			sta 	gxPixelBuffer,x
.b19a	68		pla				pla
.b19b					_GXNoPixel:
.b19b	e8		inx				inx 								; do the whole byte.
.b19c	e0 08		cpx #$08			cpx 	#8
.b19e	d0 ed		bne $b18d			bne 	_GXExpand
.b1a0	60		rts				rts
.b1a1					GXSpriteHandler:
.b1a1	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b1a3	4d 59 06	eor $0659			eor 	gxMode
.b1a6	8d f6 06	sta $06f6			sta 	gxUseMode
.b1a9	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b1ab	da		phx				phx
.b1ac	20 3c b3	jsr $b33c			jsr 	GXOpenBitmap 				; can access sprite information
.b1af	68		pla				pla
.b1b0	20 1d b4	jsr $b41d			jsr 	GXFindSprite 				; get the sprite address
.b1b3	08		php				php
.b1b4	20 44 b3	jsr $b344			jsr 	GXCloseBitmap
.b1b7	28		plp				plp
.b1b8	b0 0a		bcs $b1c4			bcs		_GXSHExit 					; exit if find failed.
.b1ba	ad f7 06	lda $06f7			lda 	GXSizePixels 				; return size
.b1bd	a2 c5		ldx #$c5			ldx 	#GXSpriteAcquire & $FF
.b1bf	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b1c1	20 97 b0	jsr $b097			jsr 	GXDrawGraphicElement
.b1c4					_GXSHExit:
.b1c4	60		rts				rts
.b1c5					GXSpriteAcquire:
.b1c5	ad 57 06	lda $0657			lda 	GXSpritePage				; point to base page
.b1c8	85 0b		sta $0b				sta 	GXEditSlot
.b1ca	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1cc	a9 00		lda #$00			lda 	#0
.b1ce	ae f8 06	ldx $06f8			ldx 	GXSizeBits
.b1d1					_GXTimesRowNumber:
.b1d1	18		clc				clc
.b1d2	65 36		adc $36				adc 	zTemp0
.b1d4	ca		dex				dex
.b1d5	10 fa		bpl $b1d1			bpl 	_GXTimesRowNumber
.b1d7	64 37		stz $37				stz 	gxzTemp0+1
.b1d9	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1da	26 37		rol $37				rol 	gxzTemp0+1
.b1dc	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1dd	26 37		rol $37				rol 	gxzTemp0+1
.b1df	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1e0	26 37		rol $37				rol 	gxzTemp0+1
.b1e2	85 36		sta $36				sta 	gxzTemp0
.b1e4	18		clc				clc 								; add base address.
.b1e5	a5 36		lda $36				lda 	gxzTemp0
.b1e7	6d fa 06	adc $06fa			adc 	GXSpriteOffset
.b1ea	85 36		sta $36				sta 	gxzTemp0
.b1ec	a5 37		lda $37				lda 	gxzTemp0+1
.b1ee	6d fb 06	adc $06fb			adc 	GXSpriteOffset+1
.b1f1					_GXSAFindPage:
.b1f1	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1f3	90 06		bcc $b1fb			bcc 	_GXSAFoundPage
.b1f5	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1f7	e6 0b		inc $0b				inc 	GXEditSlot
.b1f9	80 f6		bra $b1f1			bra 	_GXSAFindPage
.b1fb					_GXSAFoundPage:
.b1fb	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1fd	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1ff	a0 00		ldy #$00			ldy 	#0
.b201					_GXSACopyLoop:
.b201	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b203	99 fa 05	sta $05fa,y			sta 	gxPixelBuffer,y
.b206	c8		iny				iny
.b207	cc f7 06	cpy $06f7			cpy 	GXSizePixels
.b20a	d0 f5		bne $b201			bne 	_GXSACopyLoop
.b20c	60		rts				rts
.b20d					GXSelect:
.b20d	ad 54 06	lda $0654			lda 	gxSpritesOn
.b210	f0 22		beq $b234			beq 	_GXSFail
.b212	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b214	c9 40		cmp #$40			cmp 	#64
.b216	b0 1c		bcs $b234			bcs 	_GXSFail
.b218	8d 5f 06	sta $065f			sta 	GSCurrentSpriteID
.b21b	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b21d	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b21f	06 36		asl $36				asl 	gxzTemp0
.b221	06 36		asl $36				asl 	gxzTemp0
.b223	06 36		asl $36				asl 	gxzTemp0
.b225	2a		rol a				rol 	a
.b226	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b228	8d 61 06	sta $0661			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b22b	85 37		sta $37				sta 	gxzTemp0+1
.b22d	a5 36		lda $36				lda 	gxzTemp0
.b22f	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr
.b232	18		clc				clc
.b233	60		rts				rts
.b234					_GXSFail:
.b234	38		sec				sec
.b235	60		rts				rts
.b236					GXSelectImage:
.b236	ad 54 06	lda $0654			lda 	gxSpritesOn
.b239	f0 74		beq $b2af			beq 	_GXSIFail
.b23b	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b23e	f0 6f		beq $b2af			beq 	_GXSIFail 					; (checking the MSB)
.b240	64 01		stz $01				stz 	1
.b242	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b244	d0 6b		bne $b2b1			bne 	_GXSIHide
.b246	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b248	48		pha				pha
.b249	20 3c b3	jsr $b33c			jsr 	GXOpenBitmap
.b24c	68		pla				pla
.b24d	20 1d b4	jsr $b41d			jsr 	GXFindSprite
.b250	b0 5a		bcs $b2ac			bcs 	_GXSICloseFail 				; no image
.b252	a0 01		ldy #$01			ldy 	#1
.b254	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b257	85 36		sta $36				sta 	gxzTemp0
.b259	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b25c	85 37		sta $37				sta 	gxzTemp0+1
.b25e	ad fa 06	lda $06fa			lda 	GXSpriteOffset
.b261	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b263	18		clc				clc
.b264	ad fb 06	lda $06fb			lda 	GXSpriteOffset+1
.b267	6d 62 06	adc $0662			adc 	GXSpriteOffsetBase
.b26a	c8		iny				iny
.b26b	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b26d	ad 63 06	lda $0663			lda 	GXSpriteOffsetBase+1
.b270	69 00		adc #$00			adc 	#0
.b272	c8		iny				iny
.b273	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b275	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get raw size
.b278	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b27a	2a		rol a				rol 	a 							; x 2
.b27b	0a		asl a				asl 	a 							; x 4
.b27c	0a		asl a				asl 	a 							; x 8
.b27d	0a		asl a				asl 	a 							; x 16
.b27e	0d f9 06	ora $06f9			ora 	GXSpriteLUT 				; Or with LUT
.b281	0a		asl a				asl 	a 							; 1 shift
.b282	09 01		ora #$01			ora 	#1 							; enable sprite.
.b284	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b286	20 44 b3	jsr $b344			jsr 	GXCloseBitmap
.b289	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b28c	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b28f	29 3f		and #$3f			and 	#$3F
.b291	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b294	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get bit size
.b297	6a		ror a				ror 	a 							; shift into bits 6/7
.b298	6a		ror a				ror 	a
.b299	6a		ror a				ror 	a
.b29a	29 c0		and #$c0			and 	#$C0
.b29c	1d a4 06	ora $06a4,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b29f	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b2a2	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b2a5	29 7f		and #$7f			and 	#$7F
.b2a7	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b2aa	18		clc				clc
.b2ab	60		rts				rts
.b2ac					_GXSICloseFail:
.b2ac	20 44 b3	jsr $b344			jsr 	GXCloseBitmap
.b2af					_GXSIFail:
.b2af	38		sec				sec
.b2b0	60		rts				rts
.b2b1					_GXSIHide:
.b2b1	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b2b4	85 36		sta $36				sta 	gxzTemp0
.b2b6	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b2b9	85 37		sta $37				sta 	gxzTemp0+1
.b2bb	a9 00		lda #$00			lda 	#0
.b2bd	92 36		sta ($36)			sta 	(gxzTemp0)
.b2bf	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get sprite ID
.b2c2	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2c5	09 80		ora #$80			ora 	#$80
.b2c7	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b2ca	18		clc				clc
.b2cb	60		rts				rts
.b2cc					GXMoveSprite:
.b2cc	ad 54 06	lda $0654			lda 	gxSpritesOn
.b2cf	f0 65		beq $b336			beq 	_GXSIFail
.b2d1	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2d4	f0 60		beq $b336			beq 	_GXSIFail
.b2d6	85 37		sta $37				sta 	gxzTemp0+1
.b2d8	a0 04		ldy #$04			ldy 	#4
.b2da	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b2dd	85 36		sta $36				sta 	gxzTemp0
.b2df	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2e2	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b2e5	2a		rol a				rol 	a	 						; into bits 0,1.
.b2e6	2a		rol a				rol 	a
.b2e7	2a		rol a				rol 	a
.b2e8	29 03		and #$03			and 	#3
.b2ea	aa		tax				tax
.b2eb	bd 38 b3	lda $b338,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2ee	48		pha				pha
.b2ef	18		clc				clc
.b2f0	6d 4c 06	adc $064c			adc 	gxX0						; copy position.
.b2f3	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f5	c8		iny				iny
.b2f6	ad 4d 06	lda $064d			lda 	gxX0+1
.b2f9	69 00		adc #$00			adc 	#0
.b2fb	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2fd	c8		iny				iny
.b2fe	68		pla				pla
.b2ff	18		clc				clc
.b300	6d 4e 06	adc $064e			adc 	gxY0
.b303	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b305	a9 00		lda #$00			lda 	#0
.b307	69 00		adc #$00			adc 	#0
.b309	c8		iny				iny
.b30a	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b30c	4e 4d 06	lsr $064d			lsr 	gxX0+1 						; divide X by 4
.b30f	6e 4c 06	ror $064c			ror 	gxX0
.b312	4e 4c 06	lsr $064c			lsr 	gxX0
.b315	4e 4e 06	lsr $064e			lsr 	gxY0 						; divide Y by 4
.b318	4e 4e 06	lsr $064e			lsr 	gxY0
.b31b	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b31e	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x
.b321	29 80		and #$80			and 	#$80
.b323	0d 4c 06	ora $064c			ora 	gxX0
.b326	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b329	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b32c	29 c0		and #$c0			and 	#$C0
.b32e	0d 4e 06	ora $064e			ora 	gxY0
.b331	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b334	18		clc				clc
.b335	60		rts				rts
.b336					_GXSIFail:
.b336	38		sec				sec
.b337	60		rts				rts
.b338					_GXMSOffset:
>b338	1c						.byte 	32-8/2
>b339	18						.byte 	32-16/2
>b33a	14						.byte 	32-24/2
>b33b	10						.byte 	32-32/2
.b33c					GXOpenBitmap:
.b33c	78		sei				sei 								; no interrupts here
.b33d	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b33f	8d 5d 06	sta $065d			sta 	gxOriginalLUTValue
.b342	58		cli				cli
.b343	60		rts				rts
.b344					GXCloseBitmap:
.b344	78		sei				sei
.b345	ad 5d 06	lda $065d			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b348	85 0b		sta $0b				sta 	GXEditSlot
.b34a	58		cli				cli
.b34b	60		rts				rts
.b34c					GXPositionCalc:
.b34c	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b34e	48		pha				pha
.b34f	ad 4e 06	lda $064e			lda 	GXY0 						; gxzScreen = Y0
.b352	85 3c		sta $3c				sta 	gxzScreen
.b354	64 3d		stz $3d				stz 	gxzScreen+1
.b356	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b358	26 3d		rol $3d				rol 	gxzScreen+1
.b35a	06 3c		asl $3c				asl 	gxzScreen
.b35c	26 3d		rol $3d				rol 	gxzScreen+1
.b35e	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b35f	65 3c		adc $3c				adc 	gxzScreen
.b361	85 3c		sta $3c				sta 	gxzScreen
.b363	90 02		bcc $b367			bcc 	_GXPCNoCarry
.b365	e6 3d		inc $3d				inc 	gxzScreen+1
.b367					_GXPCNoCarry:
.b367	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b369	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b36b	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b36d	85 36		sta $36				sta 	gxzTemp0
.b36f	64 3d		stz $3d				stz 	gxzScreen+1
.b371	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b373					_GXPCMultiply32:
.b373	06 3c		asl $3c				asl 	gxzScreen
.b375	26 3d		rol $3d				rol 	gxzScreen+1
.b377	3a		dec a				dec 	a
.b378	d0 f9		bne $b373			bne 	_GXPCMultiply32
.b37a	18		clc				clc
.b37b	ad 4c 06	lda $064c			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b37e	65 3c		adc $3c				adc 	gxzScreen
.b380	8d 5e 06	sta $065e			sta 	gsOffset
.b383	ad 4d 06	lda $064d			lda 	GXX0+1
.b386	65 3d		adc $3d				adc 	gxzScreen+1
.b388	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b38a	90 04		bcc $b390			bcc 	_GXPCNoOverflow
.b38c	29 1f		and #$1f			and 	#$1F 						; fix it up
.b38e	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b390					_GXPCNoOverflow:
.b390	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b392	85 3d		sta $3d				sta 	gxzScreen+1
.b394	64 3c		stz $3c				stz 	gxzScreen
.b396	18		clc				clc
.b397	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b399	6d 56 06	adc $0656			adc 	gxBasePage 					; by adding the base page
.b39c	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b39e	68		pla				pla
.b39f	85 36		sta $36				sta 	gxzTemp0
.b3a1	60		rts				rts
.b3a2					GXMovePositionDown:
.b3a2	18		clc				clc 								; add 320 to offset/temp+1
.b3a3	ad 5e 06	lda $065e			lda 	gsOffset
.b3a6	69 40		adc #$40			adc 	#64
.b3a8	8d 5e 06	sta $065e			sta 	gsOffset
.b3ab	a5 3d		lda $3d				lda 	gxzScreen+1
.b3ad	69 01		adc #$01			adc 	#1
.b3af	85 3d		sta $3d				sta 	gxzScreen+1
.b3b1	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b3b3	90 07		bcc $b3bc			bcc 	_GXMPDExit
.b3b5	38		sec				sec  								; next page
.b3b6	e9 20		sbc #$20			sbc 	#$20
.b3b8	85 3d		sta $3d				sta 	gxzScreen+1
.b3ba	e6 0b		inc $0b				inc 	GXEditSlot
.b3bc					_GXMPDExit:
.b3bc	60		rts				rts
.b3bd					GXCollide:
.b3bd	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b3bf	aa		tax				tax
.b3c0	05 37		ora $37				ora 	gxzTemp0+1
.b3c2	29 c0		and #$c0			and 	#$C0
.b3c4	38		sec				sec
.b3c5	d0 53		bne $b41a			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3c7	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3c9	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3cc	1d 64 06	ora $0664,x			ora 	GXSpriteLow,x
.b3cf	30 48		bmi $b419			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3d1	18		clc				clc 								; need to calculate sum of sizes.
.b3d2	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y
.b3d5	7d a4 06	adc $06a4,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3d8	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3da	6a		ror a				ror 	a 							; 5/6/7
.b3db	4a		lsr a				lsr 	a 							; 4/5/6
.b3dc	4a		lsr a				lsr 	a 							; 3/4/5
.b3dd	4a		lsr a				lsr 	a 							; 2/3/4
.b3de	18		clc				clc
.b3df	69 08		adc #$08			adc 	#$08
.b3e1	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3e2	4a		lsr a				lsr 	a
.b3e3	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3e5	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3e8	29 3f		and #$3f			and 	#$3F
.b3ea	85 39		sta $39				sta 	gxzTemp1+1
.b3ec	38		sec				sec
.b3ed	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b3f0	29 3f		and #$3f			and 	#$3F
.b3f2	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3f4	b0 03		bcs $b3f9			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3f6	49 ff		eor #$ff			eor 	#$FF
.b3f8	1a		inc a				inc 	a
.b3f9					_GXCAbs1:
.b3f9	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3fb	b0 1c		bcs $b419			bcs 	_GXOkayFail
.b3fd	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3ff	38		sec				sec 								; calculate |x1-x0|
.b400	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y
.b403	fd 64 06	sbc $0664,x			sbc 	GXSpriteLow,x
.b406	b0 03		bcs $b40b			bcs 	_GXCAbs2
.b408	49 ff		eor #$ff			eor 	#$FF
.b40a	1a		inc a				inc 	a
.b40b					_GXCAbs2:
.b40b	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b40d	b0 0a		bcs $b419			bcs 	_GXOkayFail
.b40f	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b411	90 02		bcc $b415			bcc 	_GXCHaveLowest
.b413	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b415					_GXCHaveLowest:
.b415	0a		asl a				asl 	a 							; scale to allow for >> 2
.b416	0a		asl a				asl 	a
.b417	18		clc				clc
.b418	60		rts				rts
.b419					_GXOkayFail:
.b419	18		clc				clc
.b41a					_GXCollideFail:
.b41a	a9 ff		lda #$ff			lda 	#$FF
.b41c	60		rts				rts
.b41d					GXFindSprite:
.b41d	aa		tax				tax
.b41e	ad 57 06	lda $0657			lda 	GXSpritePage 				; access the base page of the sprite
.b421	85 0b		sta $0b				sta 	GXEditSlot
.b423	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b426	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b429	f0 33		beq $b45e			beq 	_GXFSFail
.b42b	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b42e	8d fb 06	sta $06fb			sta 	GXSpriteOffset+1
.b431	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b434	48		pha				pha 								; save twice
.b435	48		pha				pha
.b436	29 03		and #$03			and 	#3 							; get sprite size
.b438	8d f8 06	sta $06f8			sta 	GXSizeBits 					; save raw (0-3)
.b43b	aa		tax				tax
.b43c	bd 60 b4	lda $b460,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b43f	8d f7 06	sta $06f7			sta 	GXSizePixels 					; save (8/16/24/32)
.b442	68		pla				pla 								; get LUT
.b443	4a		lsr a				lsr		a
.b444	4a		lsr a				lsr		a
.b445	29 03		and #$03			and 	#3
.b447	8d f9 06	sta $06f9			sta 	GXSpriteLUT
.b44a	68		pla				pla 								; address, neeeds to be x 4
.b44b	29 f0		and #$f0			and 	#$F0
.b44d	8d fa 06	sta $06fa			sta 	GXSpriteOffset
.b450	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b453	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b456	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b459	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b45c	18		clc				clc
.b45d	60		rts				rts
.b45e					_GXFSFail:
.b45e	38		sec				sec
.b45f	60		rts				rts
.b460					_GXFXSSTTable:
>b460	08 10 18 20					.byte 	8,16,24,32
.06f7					GXSizePixels:
>06f7							.fill 	1
.06f8					GXSizeBits:
>06f8							.fill 	1
.06f9					GXSpriteLUT:
>06f9							.fill 	1
.06fa					GXSpriteOffset:
>06fa							.fill 	2
.b464					GXSortXY:
.b464	20 82 b4	jsr $b482			jsr 	GXSortY 					; will be sorted on Y now
.b467	ad 4c 06	lda $064c			lda 	gxX0 						; compare X0 v X1
.b46a	cd 50 06	cmp $0650			cmp 	gxX1
.b46d	ad 4d 06	lda $064d			lda 	gXX0+1
.b470	ed 51 06	sbc $0651			sbc 	gXX1+1
.b473	90 0c		bcc $b481			bcc 	_GXSXYExit 					; X0 < X1 exit
.b475	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b477	a0 04		ldy #$04			ldy 	#4
.b479	20 96 b4	jsr $b496			jsr 	GXSwapXY
.b47c	e8		inx				inx
.b47d	c8		iny				iny
.b47e	20 96 b4	jsr $b496			jsr 	GXSwapXY
.b481					_GXSXYExit:
.b481	60		rts				rts
.b482					GXSortY:
.b482	ad 4e 06	lda $064e			lda 	gxY0 						; if Y0 >= Y1
.b485	cd 52 06	cmp $0652			cmp 	gxY1
.b488	90 0b		bcc $b495			bcc 	_GXSYSorted
.b48a	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b48c	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b48e					_GXSwap1:
.b48e	20 96 b4	jsr $b496			jsr 	GXSwapXY
.b491	88		dey				dey
.b492	ca		dex				dex
.b493	10 f9		bpl $b48e			bpl 	_GXSwap1
.b495					_GXSYSorted:
.b495	60		rts				rts
.b496					GXSwapXY:
.b496	bd 4c 06	lda $064c,x			lda 	gxX0,x
.b499	48		pha				pha
.b49a	b9 4c 06	lda $064c,y			lda 	gxX0,y
.b49d	9d 4c 06	sta $064c,x			sta 	gxX0,x
.b4a0	68		pla				pla
.b4a1	99 4c 06	sta $064c,y			sta 	gxX0,y
.b4a4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.bb1a					KeywordSet0:
>bb1a	00 65					.text	0,$65,""               ; $80 !0:EOF
>bb1c	00 58					.text	0,$58,""               ; $81 !1:SH1
>bb1e	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bb20	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>bb26	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>bb2e	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>bb34	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>bb3b	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>bb43	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>bb4a	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>bb51	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>bb57	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>bb5d	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>bb65	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>bb6c	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>bb73	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>bb7a	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>bb82	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>bb88	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>bb8e	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>bb95	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bb9b	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bba1	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bba9	47 28
>bbab	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>bbb3	28
>bbb4	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>bbbc	28
>bbbd	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bbc3	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bbc9	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>bbcf	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>bbd6	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>bbde	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bbe4	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bbea	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bbef	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bbf3	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bbf9	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bc01	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bc08	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bc0f	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bc17	43
>bc18	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bc1e	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bc24	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bc2b	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bc31	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bc35	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bc3b	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bc43	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bc4a	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bc4f	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bc56	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bc5e	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bc64	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bc69	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bc71	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bc77	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bc7d	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bc82	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bc89	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bc8f	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bc95	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bc9c	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>bca3	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>bca8	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>bcae	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>bcb5	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>bcba	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>bcbe	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>bcc6	45
>bcc7	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>bccf	45
>bcd0	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>bcd6	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>bcdd	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>bce3	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>bce9	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>bcee	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bcf6	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>bcfd	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bd04	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>bd0c	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bd12	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bd16	ff					.text	$FF
.bd17					KeywordSet1:
>bd17	00 65					.text	0,$65,""               ; $80 !0:EOF
>bd19	00 58					.text	0,$58,""               ; $81 !1:SH1
>bd1b	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bd1d	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bd25	4c 45
>bd27	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bd2f	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bd37	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bd3c	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>bd40	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>bd46	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>bd4c	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>bd51	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>bd59	45
>bd5a	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>bd5f	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>bd67	53
>bd68	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>bd6e	ff					.text	$FF
.bd6f					KeywordSet2:
>bd6f	00 65					.text	0,$65,""               ; $80 !0:EOF
>bd71	00 58					.text	0,$58,""               ; $81 !1:SH1
>bd73	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bd75	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bd7a	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bd7f	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bd84	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bd89	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bd8e	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bd93	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bd98	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bd9d	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bda2	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bda7	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bdac	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bdb1	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bdb6	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bdbb	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bdc0	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bdc5	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bdca	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bdcf	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bdd4	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bdd9	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bdde	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bde3	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bde8	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bded	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bdf2	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bdf7	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bdfc	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>be01	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>be06	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>be0b	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>be10	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>be15	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>be1a	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>be1f	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>be24	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>be29	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>be2e	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>be33	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>be38	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>be3d	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>be42	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>be47	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>be4c	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>be51	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>be56	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>be5b	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>be60	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>be65	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>be6a	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>be6f	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>be74	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>be79	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>be7e	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>be83	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>be88	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>be8d	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>be92	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>be97	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>be9c	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>bea1	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>bea6	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>beab	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>beb0	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>beb5	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>beba	ff					.text	$FF
.b4a5					ListConvertLine:
.b4a5	48		pha				pha 								; save indent on the stack
.b4a6	9c 9d 04	stz $049d			stz 	tbOffset
.b4a9	9c ac 04	stz $04ac			stz 	tokenBuffer
.b4ac	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b4ae	b1 30		lda ($30),y			lda 	(codePtr),y
.b4b0	aa		tax				tax
.b4b1	88		dey				dey
.b4b2	b1 30		lda ($30),y			lda 	(codePtr),y
.b4b4	20 2b 93	jsr $932b			jsr 	LCLConvertInt16
.b4b7	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b4b9	86 37		stx $37				stx 	zTemp0+1
.b4bb	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b4bd	20 02 b6	jsr $b602			jsr 	LCLWrite
.b4c0	a0 00		ldy #$00			ldy 	#0
.b4c2					_LCCopyNumber:
.b4c2	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4c4	20 02 b6	jsr $b602			jsr 	LCLWrite
.b4c7	c8		iny				iny
.b4c8	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4ca	d0 f6		bne $b4c2			bne 	_LCCopyNumber
.b4cc	68		pla				pla 								; adjustment to indent
.b4cd	48		pha				pha 								; save on stack
.b4ce	10 0c		bpl $b4dc			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b4d0	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b4d1	6d a6 04	adc $04a6			adc 	listIndent
.b4d4	8d a6 04	sta $04a6			sta 	listIndent
.b4d7	10 03		bpl $b4dc			bpl 	_LCNoAdjust
.b4d9	9c a6 04	stz $04a6			stz 	listIndent
.b4dc					_LCNoAdjust:
.b4dc	18		clc				clc		 							; work out actual indent.
.b4dd	ad a6 04	lda $04a6			lda 	listIndent
.b4e0	0a		asl a				asl 	a
.b4e1	69 06		adc #$06			adc 	#6
.b4e3	85 36		sta $36				sta 	zTemp0
.b4e5					_LCPadOut:
.b4e5	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b4e7	20 02 b6	jsr $b602			jsr 	LCLWrite
.b4ea	ad 9d 04	lda $049d			lda 	tbOffset
.b4ed	c5 36		cmp $36				cmp 	zTemp0
.b4ef	d0 f4		bne $b4e5			bne 	_LCPadOut
.b4f1	a0 03		ldy #$03			ldy 	#3 							; start position.
.b4f3					_LCMainLoop:
.b4f3	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b4f5	20 02 b6	jsr $b602			jsr 	LCLWrite
.b4f8	b1 30		lda ($30),y			lda 	(codePtr),y
.b4fa	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b4fc	f0 17		beq $b515			beq 	_LCExit
.b4fe	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b500	90 1e		bcc $b520			bcc 	_LCDoubles
.b502	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b504	90 2a		bcc $b530			bcc 	_LCShiftPunc
.b506	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b508	90 35		bcc $b53f			bcc 	_LCPunctuation
.b50a	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b50c	90 3e		bcc $b54c			bcc 	_LCIdentifiers
.b50e	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b510	90 5f		bcc $b571			bcc 	_LCTokens
.b512	4c d1 b5	jmp $b5d1			jmp 	_LCData 					; 254-5 are data objects
.b515					_LCExit:
.b515	68		pla				pla 								; get old indent adjust
.b516	30 07		bmi $b51f			bmi 	_LCExit2
.b518	18		clc				clc 								; add to indent if +ve
.b519	6d a6 04	adc $04a6			adc 	listIndent
.b51c	8d a6 04	sta $04a6			sta 	listIndent
.b51f					_LCExit2:
.b51f	60		rts				rts
.b520					_LCDoubles:
.b520	48		pha				pha
.b521	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b522	29 02		and #$02			and 	#2
.b524	09 3c		ora #$3c			ora 	#60 						; make < >
.b526	20 02 b6	jsr $b602			jsr 	LCLWrite
.b529	68		pla				pla 								; restore, do lower bit
.b52a	29 03		and #$03			and 	#3
.b52c	09 3c		ora #$3c			ora 	#60
.b52e	80 0f		bra $b53f			bra		_LCPunctuation 				; print, increment, loop
.b530					_LCShiftPunc:
.b530	aa		tax				tax 								; save in X
.b531	29 07		and #$07			and 	#7 							; lower 3 bits
.b533	f0 02		beq $b537			beq 	_LCNoAdd
.b535	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b537					_LCNoAdd:
.b537	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b539	90 02		bcc $b53d			bcc 	_LCNoAdd2
.b53b	09 20		ora #$20			ora 	#32 						; adds $20
.b53d					_LCNoAdd2:
.b53d	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b53f					_LCPunctuation:
.b53f	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b541	d0 03		bne $b546			bne 	_LCPContinue
.b543	20 18 b6	jsr $b618			jsr 	LCLDeleteLastSpace
.b546					_LCPContinue:
.b546	c8		iny				iny 								; consume character
.b547	20 02 b6	jsr $b602			jsr 	LCLWrite 					; write it out.
.b54a	80 a7		bra $b4f3			bra 	_LCMainLoop 				; go round again.
.b54c					_LCIdentifiers:
.b54c	18		clc				clc 								; convert to physical address
.b54d	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b54f	85 37		sta $37				sta 	zTemp0+1
.b551	c8		iny				iny
.b552	b1 30		lda ($30),y			lda 	(codePtr),y
.b554	85 36		sta $36				sta 	zTemp0
.b556	c8		iny				iny
.b557	5a		phy				phy 								; save position
.b558	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b55a	20 02 b6	jsr $b602			jsr 	LCLWrite
.b55d	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b55f					_LCOutIdentifier:
.b55f	c8		iny				iny
.b560	b1 36		lda ($36),y			lda 	(zTemp0),y
.b562	29 7f		and #$7f			and 	#$7F
.b564	20 54 b6	jsr $b654			jsr 	LCLLowerCase
.b567	20 02 b6	jsr $b602			jsr 	LCLWrite
.b56a	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b56c	10 f1		bpl $b55f			bpl 	_LCOutIdentifier
.b56e	7a		ply				ply 								; restore position
.b56f	80 82		bra $b4f3			bra 	_LCMainLoop
.b571					_LCTokens:
.b571	aa		tax				tax 								; token in X
.b572	a9 6f		lda #$6f			lda 	#((KeywordSet2) & $FF)
.b574	85 36		sta $36				sta 	0+zTemp0
.b576	a9 bd		lda #$bd			lda 	#((KeywordSet2) >> 8)
.b578	85 37		sta $37				sta 	1+zTemp0
.b57a	e0 82		cpx #$82			cpx 	#$82
.b57c	f0 16		beq $b594			beq 	_LCUseShift
.b57e	a9 17		lda #$17			lda 	#((KeywordSet1) & $FF)
.b580	85 36		sta $36				sta 	0+zTemp0
.b582	a9 bd		lda #$bd			lda 	#((KeywordSet1) >> 8)
.b584	85 37		sta $37				sta 	1+zTemp0
.b586	e0 81		cpx #$81			cpx 	#$81
.b588	f0 0a		beq $b594			beq 	_LCUseShift
.b58a	a9 1a		lda #$1a			lda 	#((KeywordSet0) & $FF)
.b58c	85 36		sta $36				sta 	0+zTemp0
.b58e	a9 bb		lda #$bb			lda 	#((KeywordSet0) >> 8)
.b590	85 37		sta $37				sta 	1+zTemp0
.b592	80 01		bra $b595			bra 	_LCNoShift
.b594					_LCUseShift:
.b594	c8		iny				iny
.b595					_LCNoShift:
.b595	20 2c b6	jsr $b62c			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b598	b1 30		lda ($30),y			lda 	(codePtr),y
.b59a	aa		tax				tax 								; into X
.b59b					_LCFindText:
.b59b	ca		dex				dex
.b59c	10 0e		bpl $b5ac			bpl 	_LCFoundText 				; found text.
.b59e	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b5a0	1a		inc a				inc 	a 							; one extra for size
.b5a1	38		sec				sec 								; one extra for checksum
.b5a2	65 36		adc $36				adc 	zTemp0 						; go to next token
.b5a4	85 36		sta $36				sta 	zTemp0
.b5a6	90 f3		bcc $b59b			bcc 	_LCFindText
.b5a8	e6 37		inc $37				inc 	zTemp0+1
.b5aa	80 ef		bra $b59b			bra 	_LCFindText
.b5ac					_LCFoundText:
.b5ac	5a		phy				phy 								; save List position
.b5ad	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b5af	aa		tax				tax
.b5b0	a9 83		lda #$83			lda 	#CLIToken+$80
.b5b2	20 02 b6	jsr $b602			jsr 	LCLWrite
.b5b5	a0 02		ldy #$02			ldy 	#2
.b5b7					_LCCopyToken:
.b5b7	b1 36		lda ($36),y			lda 	(zTemp0),y
.b5b9	20 54 b6	jsr $b654			jsr 	LCLLowerCase
.b5bc	20 02 b6	jsr $b602			jsr 	LCLWrite
.b5bf	c8		iny				iny
.b5c0	ca		dex				dex
.b5c1	d0 f4		bne $b5b7			bne 	_LCCopyToken
.b5c3	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b5c5	f0 05		beq $b5cc			beq 	_LCNoSpace
.b5c7	a9 20		lda #$20			lda 	#' '
.b5c9	20 02 b6	jsr $b602			jsr 	LCLWrite
.b5cc					_LCNoSpace:
.b5cc	7a		ply				ply 								; restore position.
.b5cd	c8		iny				iny 								; consume token
.b5ce	4c f3 b4	jmp $b4f3			jmp 	_LCMainLoop 				; and go around again.
.b5d1					_LCData:
.b5d1	48		pha				pha 								; save type $FE/$FF
.b5d2	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b5d4	c9 fe		cmp #$fe			cmp 	#$FE
.b5d6	f0 07		beq $b5df			beq 	_LCHaveOpener
.b5d8	a2 22		ldx #$22			ldx 	#'"'
.b5da	a9 81		lda #$81			lda 	#CLIData+$80
.b5dc	20 02 b6	jsr $b602			jsr 	LCLWrite
.b5df					_LCHaveOpener:
.b5df	8a		txa				txa 								; output prefix (# or ")
.b5e0	20 02 b6	jsr $b602			jsr 	LCLWrite
.b5e3	c8		iny				iny 								; get count
.b5e4	b1 30		lda ($30),y			lda 	(codePtr),y
.b5e6	aa		tax				tax
.b5e7	c8		iny				iny 								; point at first character
.b5e8					_LCOutData:
.b5e8	b1 30		lda ($30),y			lda 	(codePtr),y
.b5ea	c9 00		cmp #$00			cmp 	#0
.b5ec	f0 03		beq $b5f1			beq 	_LCNoPrint
.b5ee	20 02 b6	jsr $b602			jsr 	LCLWrite
.b5f1					_LCNoPrint:
.b5f1	c8		iny				iny
.b5f2	ca		dex				dex
.b5f3	d0 f3		bne $b5e8			bne 	_LCOutData
.b5f5	68		pla				pla 								; closing " required ?
.b5f6	c9 ff		cmp #$ff			cmp 	#$FF
.b5f8	d0 05		bne $b5ff			bne 	_LCNoQuote
.b5fa	a9 22		lda #$22			lda 	#'"'
.b5fc	20 02 b6	jsr $b602			jsr 	LCLWrite
.b5ff					_LCNoQuote:
.b5ff	4c f3 b4	jmp $b4f3			jmp 	_LCMainLoop
.b602					LCLWrite:
.b602	da		phx				phx
.b603	ae 9d 04	ldx $049d			ldx 	tbOffset
.b606	9d ac 04	sta $04ac,x			sta 	tokenBuffer,x
.b609	9e ad 04	stz $04ad,x			stz 	tokenBuffer+1,x
.b60c	ee 9d 04	inc $049d			inc 	tbOffset
.b60f	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b611	30 03		bmi $b616			bmi 	_LCLNoColour
.b613	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b616					_LCLNoColour:
.b616	fa		plx				plx
.b617	60		rts				rts
.b618					LCLDeleteLastSpace:
.b618	48		pha				pha
.b619	da		phx				phx
.b61a	ae 9d 04	ldx $049d			ldx 	tbOffset
.b61d	f0 0a		beq $b629			beq 	_LCDLSExit
.b61f	bd ab 04	lda $04ab,x			lda 	tokenBuffer-1,x
.b622	c9 20		cmp #$20			cmp 	#' '
.b624	d0 03		bne $b629			bne 	_LCDLSExit
.b626	ce 9d 04	dec $049d			dec 	tbOffset
.b629					_LCDLSExit:
.b629	fa		plx				plx
.b62a	68		pla				pla
.b62b	60		rts				rts
.b62c					LCLCheckSpaceRequired:
.b62c	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b62f	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b631	f0 1b		beq $b64e			beq 	_LCCSRSpace
.b633	c9 29		cmp #$29			cmp 	#')'
.b635	f0 17		beq $b64e			beq 	_LCCSRSpace
.b637	c9 23		cmp #$23			cmp 	#'#'
.b639	f0 13		beq $b64e			beq 	_LCCSRSpace
.b63b	20 54 b6	jsr $b654			jsr 	LCLLowerCase 				; saves a little effort
.b63e	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b640	90 11		bcc $b653			bcc 	_LCCSRExit
.b642	c9 3a		cmp #$3a			cmp 	#"9"+1
.b644	90 08		bcc $b64e			bcc 	_LCCSRSpace
.b646	c9 61		cmp #$61			cmp 	#"a"
.b648	90 09		bcc $b653			bcc 	_LCCSRExit
.b64a	c9 7b		cmp #$7b			cmp 	#"z"+1
.b64c	b0 05		bcs $b653			bcs 	_LCCSRExit
.b64e					_LCCSRSpace:
.b64e	a9 20		lda #$20			lda 	#' '
.b650	20 02 b6	jsr $b602			jsr 	LCLWrite
.b653					_LCCSRExit:
.b653	60		rts				rts
.b654					LCLLowerCase:
.b654	c9 41		cmp #$41			cmp 	#"A"
.b656	90 06		bcc $b65e			bcc 	_LCLLCOut
.b658	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b65a	b0 02		bcs $b65e			bcs 	_LCLLCOut
.b65c	69 20		adc #$20			adc 	#$20
.b65e					_LCLLCOut:
.b65e	60		rts				rts
.b65f					LCLUpperCase:
.b65f	c9 61		cmp #$61			cmp 	#"a"
.b661	90 06		bcc $b669			bcc 	_LCLUCOut
.b663	c9 7b		cmp #$7b			cmp 	#"z"+1
.b665	b0 02		bcs $b669			bcs 	_LCLUCOut
.b667	e9 1f		sbc #$1f			sbc 	#$1F
.b669					_LCLUCOut:
.b669	60		rts				rts
.b66a					TOKSearchTable:
.b66a	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b66c	85 36		sta $36				sta 	zTemp0
.b66e	a0 00		ldy #$00			ldy 	#0
.b670	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b672	85 38		sta $38				sta 	zTemp1
.b674					_TSTLoop:
.b674	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b676	30 49		bmi $b6c1			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b678	f0 2e		beq $b6a8			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b67a	c8		iny				iny 								; get the hash
.b67b	b1 36		lda ($36),y			lda 	(zTemp0),y
.b67d	88		dey				dey
.b67e	cd 83 04	cmp $0483			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b681	d0 25		bne $b6a8			bne 	_TSTNext
.b683	ad 82 04	lda $0482			lda 	identTypeEnd 				; get length of identifier from end-start
.b686	38		sec				sec
.b687	ed 80 04	sbc $0480			sbc 	identStart
.b68a	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b68c	d0 1a		bne $b6a8			bne 	_TSTNext
.b68e	5a		phy				phy 								; save Y , we might fail to match.
.b68f	c8		iny				iny 								; point to text
.b690	c8		iny				iny
.b691	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b694					_TSTCompareName:
.b694	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; compare text.
.b697	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b699	d0 0c		bne $b6a7			bne 	_TSTNextPullY 				; fail, pullY and do next
.b69b	e8		inx				inx
.b69c	c8		iny				iny
.b69d	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b6a0	d0 f2		bne $b694			bne 	_TSTCompareName
.b6a2	7a		ply				ply 								; throw Y
.b6a3	a5 38		lda $38				lda 	zTemp1 						; get token #
.b6a5	38		sec				sec 								; return with CS = passed.
.b6a6	60		rts				rts
.b6a7					_TSTNextPullY:
.b6a7	7a		ply				ply 								; restore current, fall through.
.b6a8					_TSTNext:
.b6a8	e6 38		inc $38				inc 	zTemp1 						; token counter
.b6aa	98		tya				tya
.b6ab	18		clc				clc
.b6ac	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b6ae	1a		inc a				inc 	a 							; +1
.b6af	1a		inc a				inc 	a 							; +2
.b6b0	a8		tay				tay
.b6b1	10 c1		bpl $b674			bpl 	_TSTLoop 					; if Y < $80 loop back
.b6b3	98		tya				tya 								; add Y to zTemp0 and reset Y
.b6b4	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b6b6	18		clc				clc  								; but have tables > 255 bytes
.b6b7	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b6b9	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b6bb	90 b7		bcc $b674			bcc 	_TSTLoop
.b6bd	e6 37		inc $37				inc 	zTemp0+1
.b6bf	80 b3		bra $b674			bra 	_TSTLoop
.b6c1					_TSTFail:
.b6c1	18		clc				clc
.b6c2	60		rts				rts
.b6c3					TokeniseLine:
.b6c3	20 4b b8	jsr $b84b			jsr 	LCLFixLineBufferCase 		; fix line case
.b6c6	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b6c8	8d a9 04	sta $04a9			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b6cb	9c aa 04	stz $04aa			stz 	tokenLineNumber
.b6ce	9c ab 04	stz $04ab			stz 	tokenLineNumber+1
.b6d1	a2 ff		ldx #$ff			ldx 	#$FF
.b6d3					_TKFindFirst:
.b6d3	e8		inx				inx
.b6d4	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b6d7	f0 79		beq $b752			beq 	_TKExit
.b6d9	c9 20		cmp #$20			cmp 	#' '
.b6db	90 f6		bcc $b6d3			bcc 	_TKFindFirst
.b6dd	c9 30		cmp #$30			cmp 	#'0'
.b6df	90 07		bcc $b6e8			bcc 	_TKNoLineNumber
.b6e1	c9 3a		cmp #$3a			cmp 	#'9'+1
.b6e3	b0 03		bcs $b6e8			bcs 	_TKNoLineNumber
.b6e5	20 75 b8	jsr $b875			jsr 	TOKExtractLineNumber
.b6e8					_TKNoLineNumber:
.b6e8					_TKTokeniseLoop:
.b6e8	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b6eb	f0 65		beq $b752			beq 	_TKExit
.b6ed	e8		inx				inx
.b6ee	c9 20		cmp #$20			cmp 	#' '
.b6f0	f0 f6		beq $b6e8			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b6f2	ca		dex				dex 								; undo last get, A contains character, X is position.
.b6f3	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b6f5	f0 61		beq $b758			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.b6f7	c9 41		cmp #$41			cmp 	#'A'
.b6f9	90 04		bcc $b6ff			bcc 	_TKTokenisePunctuation
.b6fb	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b6fd	90 59		bcc $b758			bcc 	_TKTokeniseIdentifier
.b6ff					_TKTokenisePunctuation:
.b6ff	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b701	f0 27		beq $b72a			beq 	_TKString
.b703	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.b705	f0 28		beq $b72f			beq 	_TKHexConstant
.b707	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.b709	f0 29		beq $b734			beq 	_TKCheckDouble
.b70b	c9 3e		cmp #$3e			cmp 	#'>'
.b70d	f0 25		beq $b734			beq 	_TKCheckDouble
.b70f					_TKStandardPunctuation:
.b70f	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get the punctuation token back.
.b712	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b714	90 0e		bcc $b724			bcc 	_TKNoShift
.b716	48		pha				pha 								; save. we are about to convert this punctuation token from
.b717	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b719	85 36		sta $36				sta 	zTemp0
.b71b	68		pla				pla
.b71c	29 20		and #$20			and 	#32 						; bit 5
.b71e	4a		lsr a				lsr 	a 							; shift into bit 3
.b71f	4a		lsr a				lsr 	a
.b720	05 36		ora $36				ora 	zTemp0
.b722	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b724					_TKNoShift:
.b724	20 ba b8	jsr $b8ba			jsr 	TOKWriteByte 				; write the punctuation character
.b727	e8		inx				inx 								; consume the character
.b728	80 be		bra $b6e8			bra 	_TKTokeniseLoop 			; and loop round again.
.b72a					_TKString:
.b72a	20 da b7	jsr $b7da			jsr 	TOKTokenString
.b72d	80 b9		bra $b6e8			bra 	_TKTokeniseLoop
.b72f					_TKHexConstant:
.b72f	20 15 b8	jsr $b815			jsr 	TOKHexConstant
.b732	80 b4		bra $b6e8			bra 	_TKTokeniseLoop
.b734					_TKCheckDouble:
.b734	bd aa 05	lda $05aa,x			lda 	lineBuffer+1,x 				; get next character
.b737	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b739	90 d4		bcc $b70f			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.b73b	c9 3f		cmp #$3f			cmp 	#'>'+1
.b73d	b0 d0		bcs $b70f			bcs 	_TKStandardPunctuation
.b73f	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b742	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b744	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b745	7d aa 05	adc $05aa,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b748	38		sec				sec
.b749	e9 3c		sbc #$3c			sbc 	#'<'
.b74b	20 ba b8	jsr $b8ba			jsr 	TOKWriteByte 				; this is in the range 0-7
.b74e	e8		inx				inx 								; consume both
.b74f	e8		inx				inx
.b750	80 96		bra $b6e8			bra 	_TKTokeniseLoop
.b752	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b754	20 ba b8	jsr $b8ba			jsr 	TOKWriteByte
.b757	60		rts				rts
.b758					_TKTokeniseIdentifier:
.b758	8e 80 04	stx $0480			stx 	identStart 					; save start
.b75b	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b75e					_TKCheckLoop:
.b75e	e8		inx				inx 								; look at next, we know first is identifier already.
.b75f	bd a9 05	lda $05a9,x			lda  	lineBuffer,x
.b762	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b764	f0 f8		beq $b75e			beq 	_TKCheckLoop
.b766	c9 30		cmp #$30			cmp	 	#"0"
.b768	90 0c		bcc $b776			bcc 	_TKEndIdentifier
.b76a	c9 3a		cmp #$3a			cmp 	#"9"+1
.b76c	90 f0		bcc $b75e			bcc 	_TKCheckLoop
.b76e	c9 41		cmp #$41			cmp	 	#"A"
.b770	90 04		bcc $b776			bcc 	_TKEndIdentifier
.b772	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b774	90 e8		bcc $b75e			bcc 	_TKCheckLoop
.b776					_TKEndIdentifier:
.b776	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b779	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b77b	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b77d	f0 06		beq $b785			beq 	_TKHasTypeCharacter
.b77f	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b781	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b783	d0 07		bne $b78c			bne 	_TKNoTypeCharacter
.b785					_TKHasTypeCharacter:
.b785	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b788	e8		inx				inx 								; consume the type character
.b789	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b78c					_TKNoTypeCharacter:
.b78c	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b78e	d0 09		bne $b799			bne 	_TKNoArray
.b790	e8		inx				inx 								; skip the (
.b791	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.b794	09 04		ora #$04			ora 	#$04
.b796	8d 84 04	sta $0484			sta 	identTypeByte
.b799					_TKNoArray:
.b799	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b79c	20 36 b8	jsr $b836			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b79f	a0 bb		ldy #$bb			ldy 	#(KeywordSet0) >> 8
.b7a1	a9 1a		lda #$1a			lda 	#(KeywordSet0) & $FF
.b7a3	20 6a b6	jsr $b66a			jsr 	TOKSearchTable
.b7a6	a2 00		ldx #$00			ldx 	#0
.b7a8	b0 1f		bcs $b7c9			bcs 	_TKFoundToken
.b7aa	a0 bd		ldy #$bd			ldy 	#(KeywordSet1) >> 8
.b7ac	a9 17		lda #$17			lda 	#(KeywordSet1) & $FF
.b7ae	20 6a b6	jsr $b66a			jsr 	TOKSearchTable
.b7b1	a2 81		ldx #$81			ldx 	#$81
.b7b3	b0 14		bcs $b7c9			bcs 	_TKFoundToken
.b7b5	a0 bd		ldy #$bd			ldy 	#(KeywordSet2) >> 8
.b7b7	a9 6f		lda #$6f			lda 	#(KeywordSet2) & $FF
.b7b9	20 6a b6	jsr $b66a			jsr 	TOKSearchTable
.b7bc	a2 82		ldx #$82			ldx 	#$82
.b7be	b0 09		bcs $b7c9			bcs 	_TKFoundToken
.b7c0	20 c6 b8	jsr $b8c6			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b7c3	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b7c6	4c e8 b6	jmp $b6e8			jmp 	_TKTokeniseLoop 			; and go round again.
.b7c9					_TKFoundToken:
.b7c9	48		pha				pha 								; save token
.b7ca	8a		txa				txa 								; shift in X, is there one ?
.b7cb	f0 03		beq $b7d0			beq 	_TKNoTShift
.b7cd	20 ba b8	jsr $b8ba			jsr 	TOKWriteByte 				; if so, write it out
.b7d0					_TKNoTShift:
.b7d0	68		pla				pla 								; restore and write token
.b7d1	20 ba b8	jsr $b8ba			jsr 	TOKWriteByte
.b7d4	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b7d7	4c e8 b6	jmp $b6e8			jmp 	_TKTokeniseLoop 			; and go round again.
.b7da					TOKTokenString:
.b7da	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b7dc	20 ba b8	jsr $b8ba			jsr 	TOKWriteByte
.b7df	e8		inx				inx									; start of quoted string.
.b7e0	da		phx				phx 								; push start of string on top
.b7e1	ca		dex				dex 								; because we pre-increment
.b7e2					_TSFindEnd:
.b7e2	e8		inx				inx
.b7e3	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character
.b7e6	f0 04		beq $b7ec			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.b7e8	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.b7ea	d0 f6		bne $b7e2			bne 	_TSFindEnd
.b7ec					_TSEndOfString:
.b7ec	7a		ply				ply  								; so now Y is first character, X is character after end.
.b7ed	48		pha				pha 								; save terminating character
.b7ee	20 f6 b7	jsr $b7f6			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b7f1	68		pla				pla 								; terminating character
.b7f2	f0 01		beq $b7f5			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b7f4	e8		inx				inx
.b7f5					_TSNotQuote:
.b7f5	60		rts				rts
.b7f6					TOKWriteBlockXY:
.b7f6	86 36		stx $36				stx 	zTemp0 						; save end character
.b7f8	98		tya				tya 								; use 2's complement to work out the byte size
.b7f9	49 ff		eor #$ff			eor 	#$FF
.b7fb	38		sec				sec
.b7fc	65 36		adc $36				adc 	zTemp0
.b7fe	1a		inc a				inc 	a 							; one extra for NULL
.b7ff	20 ba b8	jsr $b8ba			jsr 	TOKWriteByte
.b802					_TOBlockLoop:
.b802	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.b804	f0 09		beq $b80f			beq 	_TOBlockExit
.b806	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y 				; write byte out.
.b809	20 ba b8	jsr $b8ba			jsr 	TOKWriteByte
.b80c	c8		iny				iny
.b80d	80 f3		bra $b802			bra 	_TOBlockLoop
.b80f					_TOBlockExit:
.b80f	a9 00		lda #$00			lda 	#0 							; add NULL.
.b811	20 ba b8	jsr $b8ba			jsr 	TOKWriteByte
.b814	60		rts				rts
.b815					TOKHexConstant:
.b815	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b817	20 ba b8	jsr $b8ba			jsr 	TOKWriteByte
.b81a	e8		inx				inx									; start of quoted string.
.b81b	da		phx				phx 								; push start of constant on top
.b81c	ca		dex				dex
.b81d					_THFindLoop:
.b81d	e8		inx				inx 	 							; this is stored in a block, so find out how long
.b81e	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; the hex constant is.
.b821	c9 30		cmp #$30			cmp 	#"0"
.b823	90 0c		bcc $b831			bcc 	_THFoundEnd
.b825	c9 3a		cmp #$3a			cmp 	#"9"+1
.b827	90 f4		bcc $b81d			bcc 	_THFindLoop
.b829	c9 41		cmp #$41			cmp 	#"A"
.b82b	90 04		bcc $b831			bcc 	_THFoundEnd
.b82d	c9 47		cmp #$47			cmp 	#"F"+1
.b82f	90 ec		bcc $b81d			bcc 	_THFindLoop
.b831					_THFoundEnd:
.b831	7a		ply				ply 								; restore start
.b832	20 f6 b7	jsr $b7f6			jsr 	TOKWriteBlockXY 			; output the block
.b835	60		rts				rts
.b836					TOKCalculateHash:
.b836	da		phx				phx
.b837	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.b83a	a9 00		lda #$00			lda 	#0
.b83c					_TCHLoop:
.b83c	18		clc				clc
.b83d	7d a9 05	adc $05a9,x			adc 	lineBuffer,x
.b840	e8		inx				inx
.b841	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b844	d0 f6		bne $b83c			bne 	_TCHLoop
.b846	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b849	fa		plx				plx
.b84a	60		rts				rts
.b84b					LCLFixLineBufferCase:
.b84b	a2 00		ldx #$00			ldx 	#0
.b84d					_FLBCLoop:
.b84d	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next character
.b850	f0 22		beq $b874			beq 	_FLBCExit 					; end of string.
.b852	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b854	f0 11		beq $b867			beq 	_FLBCInQuotes
.b856	e8		inx				inx
.b857	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b859	90 f2		bcc $b84d			bcc 	_FLBCLoop
.b85b	c9 7b		cmp #$7b			cmp 	#'z'+1
.b85d	b0 ee		bcs $b84d			bcs 	_FLBCLoop
.b85f	38		sec				sec 								; make U/C
.b860	e9 20		sbc #$20			sbc 	#32
.b862	9d a8 05	sta $05a8,x			sta	 	lineBuffer-1,x 				; write back
.b865	80 e6		bra $b84d			bra 	_FLBCLoop
.b867					_FLBCInQuotes:
.b867	e8		inx				inx 								; advance
.b868	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next
.b86b	f0 07		beq $b874			beq 	_FLBCExit 					; exit on EOS
.b86d	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b86f	d0 f6		bne $b867			bne 	_FLBCInQuotes
.b871	e8		inx				inx 								; skip over it
.b872	80 d9		bra $b84d			bra 	_FLBCLoop
.b874					_FLBCExit:
.b874	60		rts				rts
.b875					TOKExtractLineNumber:
.b875	ad ab 04	lda $04ab			lda 	tokenLineNumber+1 			; push current value on stack
.b878	48		pha				pha
.b879	ad aa 04	lda $04aa			lda 	tokenLineNumber
.b87c	48		pha				pha
.b87d	20 b3 b8	jsr $b8b3			jsr 	_LCLNTimes2 				; line # x 2
.b880	20 b3 b8	jsr $b8b3			jsr 	_LCLNTimes2 				; line # x 4
.b883	18		clc				clc 								; add stacked value
.b884	68		pla				pla
.b885	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b888	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b88b	68		pla				pla
.b88c	6d ab 04	adc $04ab			adc 	tokenLineNumber+1
.b88f	8d ab 04	sta $04ab			sta 	tokenLineNumber+1 			; line # x 5
.b892	20 b3 b8	jsr $b8b3			jsr 	_LCLNTimes2 				; line # x 10
.b895	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get and consume character
.b898	e8		inx				inx
.b899	29 0f		and #$0f			and 	#15 						; add to line #
.b89b	18		clc				clc
.b89c	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b89f	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b8a2	90 03		bcc $b8a7			bcc 	_TLENNoCarry
.b8a4	ee ab 04	inc $04ab			inc 	tokenLineNumber+1
.b8a7					_TLENNoCarry:
.b8a7	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; more digits ?
.b8aa	c9 30		cmp #$30			cmp 	#'0'
.b8ac	90 04		bcc $b8b2			bcc 	_TLENExit
.b8ae	c9 3a		cmp #$3a			cmp 	#'9'+1
.b8b0	90 c3		bcc $b875			bcc 	TOKExtractLineNumber
.b8b2					_TLENExit:
.b8b2	60		rts				rts
.b8b3					_LCLNTimes2:
.b8b3	0e aa 04	asl $04aa			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.b8b6	2e ab 04	rol $04ab			rol 	tokenLineNumber+1
.b8b9	60		rts				rts
.b8ba					TOKWriteByte:
.b8ba	da		phx				phx
.b8bb	ae a9 04	ldx $04a9			ldx 	tokenOffset 				; next slot to write to
.b8be	9d a9 04	sta $04a9,x			sta 	tokenOffset,x 				; write byte out
.b8c1	ee a9 04	inc $04a9			inc 	tokenOffset 				; advance slot.
.b8c4	fa		plx				plx
.b8c5	60		rts				rts
.b8c6					TOKCheckCreateVariableRecord:
.b8c6	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b8c8	85 36		sta $36				sta 	0+zTemp0
.b8ca	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b8cc	85 37		sta $37				sta 	1+zTemp0
.b8ce					_CCVSearch:
.b8ce	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b8d0	f0 2c		beq $b8fe			beq 	_CCVFail
.b8d2	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b8d4	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b8d6	cd 83 04	cmp $0483			cmp 	identHash
.b8d9	d0 16		bne $b8f1			bne 	_CCVNext
.b8db	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b8dd	ae 80 04	ldx $0480			ldx 	identStart
.b8e0					_CCVCompare:
.b8e0	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b8e3	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b8e5	e8		inx				inx 								; advance pointers
.b8e6	c8		iny				iny
.b8e7	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b8e8	d0 07		bne $b8f1			bne 	_CCVNext  					; didn't match go to next.
.b8ea	90 f4		bcc $b8e0			bcc 	_CCVCompare 				; not finished yet.
.b8ec	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b8ef	f0 41		beq $b932			beq 	_CCVFound 					; yes, we were successful
.b8f1					_CCVNext:
.b8f1	18		clc				clc
.b8f2	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b8f4	65 36		adc $36				adc 	zTemp0
.b8f6	85 36		sta $36				sta 	zTemp0
.b8f8	90 d4		bcc $b8ce			bcc 	_CCVSearch
.b8fa	e6 37		inc $37				inc 	zTemp0+1
.b8fc	80 d0		bra $b8ce			bra 	_CCVSearch
.b8fe					_CCVFail:
.b8fe	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b900	ad 83 04	lda $0483			lda 	identHash
.b903	91 36		sta ($36),y			sta 	(zTemp0),y
.b905	c8		iny				iny 								; offset 2 is the type byte
.b906	ad 84 04	lda $0484			lda 	identTypeByte
.b909	91 36		sta ($36),y			sta 	(zTemp0),y
.b90b	c8		iny				iny
.b90c					_CCVData:
.b90c	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b90e	91 36		sta ($36),y			sta 	(zTemp0),y
.b910	c8		iny				iny
.b911	c0 08		cpy #$08			cpy 	#8
.b913	90 f7		bcc $b90c			bcc 	_CCVData
.b915	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b918					_CCVCopyName:
.b918	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b91b	91 36		sta ($36),y			sta 	(zTemp0),y
.b91d	e8		inx				inx
.b91e	c8		iny				iny
.b91f	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b922	d0 f4		bne $b918			bne 	_CCVCopyName
.b924	98		tya				tya 								; patch offset
.b925	92 36		sta ($36)			sta 	(zTemp0)
.b927	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b929	91 36		sta ($36),y			sta 	(zTemp0),y
.b92b	88		dey				dey
.b92c	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b92e	09 80		ora #$80			ora 	#$80
.b930	91 36		sta ($36),y			sta 	(zTemp0),y
.b932					_CCVFound:
.b932	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b934	38		sec				sec
.b935	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b937	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b939	20 ba b8	jsr $b8ba			jsr 	TOKWriteByte
.b93c	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b93e	20 ba b8	jsr $b8ba			jsr 	TOKWriteByte
.b941	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b942					SNDCheckChannel:
.b942	aa		tax				tax
.b943	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b946	d0 38		bne $b980			bne 	_SNDCCExit
.b948	da		phx				phx 								; save current channel
.b949	8a		txa				txa 								; put in A
.b94a	20 c6 b9	jsr $b9c6			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b94d	68		pla				pla 								; channel # in A
.b94e	90 30		bcc $b980			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b950	a8		tay				tay 								; Y is the channel #
.b951	bd ff 06	lda $06ff,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b954	99 fe 07	sta $07fe,y			sta 	SNDPitchLow,y
.b957	bd 00 07	lda $0700,x			lda 	SNDQueue+2,x
.b95a	99 02 08	sta $0802,y			sta 	SNDPitchHigh,y
.b95d	bd 01 07	lda $0701,x			lda 	SNDQueue+3,x
.b960	99 06 08	sta $0806,y			sta 	SNDVolume,y
.b963	bd 02 07	lda $0702,x			lda 	SNDQueue+4,x
.b966	99 0a 08	sta $080a,y			sta 	SNDTimeLeft,y
.b969	bd 03 07	lda $0703,x			lda 	SNDQueue+5,x
.b96c	99 0e 08	sta $080e,y			sta 	SNDAdjustLow,y
.b96f	bd 04 07	lda $0704,x			lda 	SNDQueue+6,x
.b972	99 12 08	sta $0812,y			sta 	SNDAdjustHigh,y
.b975	5a		phy				phy 								; save channel #
.b976	20 e0 b9	jsr $b9e0			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b979	ce fd 06	dec $06fd			dec 	SNDLength 					; reduce the queue length.
.b97c	68		pla				pla
.b97d	20 81 b9	jsr $b981			jsr 	SNDUpdateNote 				; update channel A
.b980					_SNDCCExit:
.b980	60		rts				rts
.b981					SNDUpdateNote:
.b981	aa		tax				tax 								; so we can access records
.b982	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b983	0a		asl a				asl 	a
.b984	0a		asl a				asl 	a
.b985	0a		asl a				asl 	a
.b986	0a		asl a				asl 	a
.b987	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b98a	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; are we silent
.b98d	f0 2e		beq $b9bd			beq 	_SNDUNIsSilent
.b98f	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; push channel bits on stack
.b992	48		pha				pha
.b993	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b996	29 0f		and #$0f			and 	#$0F
.b998	0d fc 06	ora $06fc			ora 	SNDChannelBits 				; set channel bits
.b99b	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b99d	20 2a ba	jsr $ba2a			jsr 	SNDWritePorts
.b9a0	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b9a3	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b9a6	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.b9a9	4e fc 06	lsr $06fc			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b9ac	6a		ror a				ror 	a
.b9ad	4e fc 06	lsr $06fc			lsr 	SNDChannelBits
.b9b0	6a		ror a				ror 	a
.b9b1	4a		lsr a				lsr 	a 							; put in bits 0-5
.b9b2	4a		lsr a				lsr 	a
.b9b3	20 2a ba	jsr $ba2a			jsr 	SNDWritePorts 				; write as rest of pitch register
.b9b6	68		pla				pla
.b9b7	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b9b9	20 2a ba	jsr $ba2a			jsr 	SNDWritePorts
.b9bc	60		rts				rts
.b9bd					_SNDUNIsSilent:
.b9bd	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; channel bits
.b9c0	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b9c2	20 2a ba	jsr $ba2a			jsr 	SNDWritePorts 				; write to the ports
.b9c5	60		rts				rts
.b9c6					SNDFindNextNoteForA:
.b9c6	ac fd 06	ldy $06fd			ldy 	SNDLength 					; queue size into Y
.b9c9	f0 13		beq $b9de			beq 	_SNDFNNFail 				; queue empty.
.b9cb	a2 00		ldx #$00			ldx 	#0
.b9cd					_SNDFNNSearch:
.b9cd	dd fe 06	cmp $06fe,x			cmp 	SNDQueue,x 					; does it match the channel
.b9d0	38		sec				sec
.b9d1	f0 0c		beq $b9df			beq 	_SNDFNNExit 				; if so exit with CS.
.b9d3	e8		inx				inx 								; next queue slot.
.b9d4	e8		inx				inx
.b9d5	e8		inx				inx
.b9d6	e8		inx				inx
.b9d7	e8		inx				inx
.b9d8	e8		inx				inx
.b9d9	e8		inx				inx
.b9da	e8		inx				inx
.b9db	88		dey				dey 								; done the whole queue
.b9dc	d0 ef		bne $b9cd			bne 	_SNDFNNSearch 				; no, go back.
.b9de					_SNDFNNFail:
.b9de	18		clc				clc
.b9df					_SNDFNNexit:
.b9df	60		rts				rts
.b9e0					SNDDeleteXFromQueue:
.b9e0	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b9e2	f0 09		beq $b9ed			beq 	_SNDDXExit
.b9e4	bd 06 07	lda $0706,x			lda 	SNDQueue+8,x
.b9e7	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9ea	e8		inx				inx
.b9eb	80 f3		bra $b9e0			bra 	SNDDeleteXFromQueue
.b9ed					_SNDDXExit:
.b9ed	60		rts				rts
.06fc					SNDChannelBits:
>06fc							.fill 	1
.b9ee					SNDQueueRequest:
.b9ee	86 36		stx $36				stx 	zTemp0						; save queue address
.b9f0	84 37		sty $37				sty 	zTemp0+1
.b9f2	ae fd 06	ldx $06fd			ldx 	SNDLength 					; queue is full, can't take any more.
.b9f5	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b9f7	f0 21		beq $ba1a			beq 	_SNDQRExit
.b9f9	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b9fb	48		pha				pha
.b9fc	8a		txa				txa  								; get offset in queue buffer/
.b9fd	0a		asl a				asl 	a
.b9fe	0a		asl a				asl 	a
.b9ff	0a		asl a				asl 	a
.ba00	aa		tax				tax
.ba01	68		pla				pla 								; get back and push again
.ba02	48		pha				pha
.ba03	9d fe 06	sta $06fe,x			sta 	SNDQueue+0,x 				; save the channel #
.ba06	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.ba08					_SNDQCopy:
.ba08	b1 36		lda ($36),y			lda 	(zTemp0),y
.ba0a	e8		inx				inx
.ba0b	c8		iny				iny
.ba0c	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.ba0f	c0 06		cpy #$06			cpy 	#6
.ba11	d0 f5		bne $ba08			bne 	_SNDQCopy
.ba13	ee fd 06	inc $06fd			inc 	SNDLength 					; bump queue length.
.ba16	68		pla				pla 								; get channel # back
.ba17	20 42 b9	jsr $b942			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.ba1a					_SNDQRExit:
.ba1a	60		rts				rts
.ba1b					SNDSilenceChannel:
.ba1b	aa		tax				tax 								; zero time left.
.ba1c	9e 0a 08	stz $080a,x			stz 	SNDTimeLeft,x
.ba1f	0a		asl a				asl 	a 							; shift into position
.ba20	0a		asl a				asl 	a
.ba21	0a		asl a				asl 	a
.ba22	0a		asl a				asl 	a
.ba23	0a		asl a				asl 	a
.ba24	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.ba26	20 2a ba	jsr $ba2a			jsr 	SNDWritePorts
.ba29	60		rts				rts
.ba2a					SNDWritePorts:
.ba2a	64 01		stz $01				stz 	1
.ba2c	8d 00 d6	sta $d600			sta 	$D600
.ba2f	8d 10 d6	sta $d610			sta 	$D610
.ba32	60		rts				rts
.ba33					SNDCommand:
.ba33	da		phx				phx
.ba34	5a		phy				phy
.ba35	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.ba37	f0 1d		beq $ba56			beq 	_SNDInitialise
.ba39	90 28		bcc $ba63			bcc 	_SNDExit
.ba3b	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.ba3d	f0 17		beq $ba56			beq 	_SNDSilence
.ba3f	b0 22		bcs $ba63			bcs 	_SNDExit
.ba41	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.ba43	b0 09		bcs $ba4e			bcs 	_SNDQueryPlay
.ba45	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.ba47	b0 1a		bcs $ba63			bcs 	_SNDExit
.ba49	20 ee b9	jsr $b9ee			jsr 	SNDQueueRequest
.ba4c	80 15		bra $ba63			bra 	_SNDExit
.ba4e					_SNDQueryPlay:
.ba4e	29 03		and #$03			and 	#3 							; get channel #
.ba50	aa		tax				tax
.ba51	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.ba54	80 0d		bra $ba63			bra 	_SNDExit
.ba56					_SNDInitialise:
.ba56					_SNDSilence:
.ba56	9c fd 06	stz $06fd			stz 	SNDLength 					; empty the queue.
.ba59	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.ba5b					_SNDSilenceLoop:
.ba5b	48		pha				pha
.ba5c	20 1b ba	jsr $ba1b			jsr 	SNDSilenceChannel
.ba5f	68		pla				pla
.ba60	3a		dec a				dec 	a
.ba61	10 f8		bpl $ba5b			bpl 	_SNDSilenceLoop
.ba63					_SNDExit:
.ba63	7a		ply				ply
.ba64	fa		plx				plx
.ba65	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fd					SNDLength:
>06fd							.fill 	1
.06fe					SNDQueue:
>06fe							.fill 	SNDQueueSize * 8
.07fe					SNDPitchLow:
>07fe							.fill 	4
.0802					SNDPitchHigh:
>0802							.fill 	4
.0806					SNDVolume:
>0806							.fill 	4
.080a					SNDTimeLeft:
>080a							.fill 	4
.080e					SNDAdjustLow:
>080e							.fill 	4
.0812					SNDAdjustHigh:
>0812							.fill 	4
.ba66					SNDUpdate:
.ba66	ad 0a 08	lda $080a			lda 	SNDTimeLeft+0 				; look at time remaining
.ba69	f0 05		beq $ba70			beq 	_SNDUNot0 					; not playing
.ba6b	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.ba6d	20 8f ba	jsr $ba8f			jsr 	SNDUpdateChannel 			; update it.
.ba70					_SNDUNot0:
.ba70	ad 0b 08	lda $080b			lda 	SNDTimeLeft+1
.ba73	f0 05		beq $ba7a			beq 	_SNDUNot1
.ba75	a2 01		ldx #$01			ldx 	#1
.ba77	20 8f ba	jsr $ba8f			jsr 	SNDUpdateChannel
.ba7a					_SNDUNot1:
.ba7a	ad 0c 08	lda $080c			lda 	SNDTimeLeft+2
.ba7d	f0 05		beq $ba84			beq 	_SNDUNot2
.ba7f	a2 02		ldx #$02			ldx 	#2
.ba81	20 8f ba	jsr $ba8f			jsr 	SNDUpdateChannel
.ba84					_SNDUNot2:
.ba84	ad 0d 08	lda $080d			lda 	SNDTimeLeft+3
.ba87	f0 05		beq $ba8e			beq 	_SNDUNot3
.ba89	a2 03		ldx #$03			ldx 	#3
.ba8b	20 8f ba	jsr $ba8f			jsr 	SNDUpdateChannel
.ba8e					_SNDUNot3:
.ba8e	60		rts				rts
.ba8f					SNDUpdateChannel:
.ba8f	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.ba91	f0 2c		beq $babf			beq 	_SNDUCExit
.ba93	3a		dec a				dec 	a 							; decrement and update timer
.ba94	9d 0a 08	sta $080a,x			sta 	SNDTimeLeft,x
.ba97	f0 1d		beq $bab6			beq 	_SNDUCUpdate 				; if zero, silence channel
.ba99	bd 0e 08	lda $080e,x			lda 	SNDAdjustLow,x 				; adjust ?
.ba9c	1d 12 08	ora $0812,x			ora 	SNDAdjustHigh,x
.ba9f	f0 1e		beq $babf			beq 	_SNDUCExit 					; if zero carry on at current tone.
.baa1	18		clc				clc 								; add adjust, forcing into a 10 bit range
.baa2	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.baa5	7d 0e 08	adc $080e,x			adc 	SNDAdjustLow,x
.baa8	9d fe 07	sta $07fe,x			sta 	SNDPitchLow,x
.baab	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x
.baae	7d 12 08	adc $0812,x			adc 	SNDAdjustHigh,x
.bab1	29 03		and #$03			and 	#3
.bab3	9d 02 08	sta $0802,x			sta 	SNDPitchHigh,x
.bab6					_SNDUCUpdate:
.bab6	8a		txa				txa 								; which channel.
.bab7	48		pha				pha
.bab8	20 81 b9	jsr $b981			jsr 	SNDUpdateNote 				; update the current note
.babb	68		pla				pla
.babc	20 42 b9	jsr $b942			jsr 	SNDCheckChannel 			; more to do ?
.babf					_SNDUCExit:
.babf	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
