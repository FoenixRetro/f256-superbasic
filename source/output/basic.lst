
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o build/basic.rom _basic.asm
; Mon Dec  5 15:39:50 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=0					AUTORUN=0
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$28000					 SOURCE_ADDRESS=$28000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$50					ZeroPagePreference = $50
=$400					MemoryStorage = $400
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0050					NSStatus:
>0050							.fill 	MathStackSize
.0058					NSMantissa0:
>0058							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0060					NSMantissa1:
>0060							.fill 	MathStackSize
.0068					NSMantissa2:
>0068							.fill 	MathStackSize
.0070					NSMantissa3:
>0070							.fill 	MathStackSize
.0078					NSExponent:
>0078							.fill 	MathStackSize
.0400					identStart:
>0400							.fill 	1
.0401					identTypeStart:
>0401							.fill 	1
.0402					identTypeEnd:
>0402							.fill 	1
.0403					identHash:
>0403							.fill 	1
.0404					identTypeByte:
>0404							.fill 	1	 						; (see tokenising.pdf)
.0405					encodeState:
>0405							.fill 	1
.0406					digitTemp:
>0406							.fill 	1
.0407					decimalCount:
>0407							.fill 	1
.0408					randomSeed:
>0408							.fill 	4
.040c					lowMemPtr:
>040c							.fill 	2
.040e					stringMemory:
>040e							.fill 	2
.0410					stringInitialised:
>0410							.fill 	1
.0411					stringTempPointer:
>0411							.fill 	2
.0413					breakCheck:
>0413							.fill 	1
.0414					decimalPlaces:
>0414							.fill 	1
.0415					dbOffset:
>0415							.fill 	1
.0416					lastParameter:
>0416							.fill 	1
.0417					dataPointer:
>0417							.fill 	5
.041c					inDataStatement:
>041c							.fill 	1
.041d					tbOffset:
>041d							.fill 	1
.041e					AssemblerAddress:
>041e							.fill 	2
.0420					AssemblerControl:
>0420							.fill 	1
.0421					ParamStart:
>0421							.fill 	2
.0423					IsGroup1:
>0423							.fill 	1
.0424					BaseOpcode:
>0424							.fill 	1
.0425					ModeMask:
>0425							.fill 	1
.0426					listIndent:
>0426							.fill 	1
.0427					lcLastCharacter:
>0427							.fill 	1
.0428					isInputFlag:
>0428							.fill 	1
.0429					currentListColour:
>0429							.fill 	1
.042a					tokenOffset:
>042a							.fill 	1
.042b					tokenLineNumber:
>042b							.fill 	2
.042d					tokenBuffer:
>042d							.fill 	253
.052a					lineBuffer:
>052a							.fill 	253
.0627					numberBuffer:
>0627							.fill 	34
.0649					decimalBuffer:
>0649							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_DEEKLPAREN                       = $87; $87 DEEK(
=$88					KWD_EVENTLPAREN                      = $88; $88 EVENT(
=$89					KWD_FALSE                            = $89; $89 FALSE
=$8a					KWD_FRACLPAREN                       = $8a; $8a FRAC(
=$8b					KWD_HITLPAREN                        = $8b; $8b HIT(
=$8c					KWD_INTLPAREN                        = $8c; $8c INT(
=$8d					KWD_ISVALLPAREN                      = $8d; $8d ISVAL(
=$8e					KWD_JOYBLPAREN                       = $8e; $8e JOYB(
=$8f					KWD_JOYXLPAREN                       = $8f; $8f JOYX(
=$90					KWD_JOYYLPAREN                       = $90; $90 JOYY(
=$91					KWD_LEFTDOLLARLPAREN                 = $91; $91 LEFT$(
=$92					KWD_LENLPAREN                        = $92; $92 LEN(
=$93					KWD_MAXLPAREN                        = $93; $93 MAX(
=$94					KWD_MIDDOLLARLPAREN                  = $94; $94 MID$(
=$95					KWD_MINLPAREN                        = $95; $95 MIN(
=$96					KWD_NOTLPAREN                        = $96; $96 NOT(
=$97					KWD_PEEKLPAREN                       = $97; $97 PEEK(
=$98					KWD_PLAYINGLPAREN                    = $98; $98 PLAYING(
=$99					KWD_RANDOMLPAREN                     = $99; $99 RANDOM(
=$9a					KWD_RIGHTDOLLARLPAREN                = $9a; $9a RIGHT$(
=$9b					KWD_RNDLPAREN                        = $9b; $9b RND(
=$9c					KWD_SGNLPAREN                        = $9c; $9c SGN(
=$9d					KWD_SPCLPAREN                        = $9d; $9d SPC(
=$9e					KWD_STRDOLLARLPAREN                  = $9e; $9e STR$(
=$9f					KWD_TIMERLPAREN                      = $9f; $9f TIMER(
=$a0					KWD_TRUE                             = $a0; $a0 TRUE
=$a1					KWD_VALLPAREN                        = $a1; $a1 VAL(
=$a2					KWD_FOR                              = $a2; $a2 FOR
=$a3					KWD_IF                               = $a3; $a3 IF
=$a4					KWD_PROC                             = $a4; $a4 PROC
=$a5					KWD_REPEAT                           = $a5; $a5 REPEAT
=$a6					KWD_WHILE                            = $a6; $a6 WHILE
=$a7					KWD_ENDIF                            = $a7; $a7 ENDIF
=$a8					KWD_ENDPROC                          = $a8; $a8 ENDPROC
=$a9					KWD_NEXT                             = $a9; $a9 NEXT
=$aa					KWD_THEN                             = $aa; $aa THEN
=$ab					KWD_UNTIL                            = $ab; $ab UNTIL
=$ac					KWD_WEND                             = $ac; $ac WEND
=$ad					KWD_BY                               = $ad; $ad BY
=$ae					KWD_CALL                             = $ae; $ae CALL
=$af					KWD_CIRCLE                           = $af; $af CIRCLE
=$b0					KWD_CLEAR                            = $b0; $b0 CLEAR
=$b1					KWD_CLS                              = $b1; $b1 CLS
=$b2					KWD_COLOR                            = $b2; $b2 COLOR
=$b3					KWD_COLOUR                           = $b3; $b3 COLOUR
=$b4					KWD_DATA                             = $b4; $b4 DATA
=$b5					KWD_DIM                              = $b5; $b5 DIM
=$b6					KWD_DOKE                             = $b6; $b6 DOKE
=$b7					KWD_DOWNTO                           = $b7; $b7 DOWNTO
=$b8					KWD_ELSE                             = $b8; $b8 ELSE
=$b9					KWD_FROM                             = $b9; $b9 FROM
=$ba					KWD_GFX                              = $ba; $ba GFX
=$bb					KWD_GOSUB                            = $bb; $bb GOSUB
=$bc					KWD_GOTO                             = $bc; $bc GOTO
=$bd					KWD_HERE                             = $bd; $bd HERE
=$be					KWD_IMAGE                            = $be; $be IMAGE
=$bf					KWD_INPUT                            = $bf; $bf INPUT
=$c0					KWD_LET                              = $c0; $c0 LET
=$c1					KWD_LINE                             = $c1; $c1 LINE
=$c2					KWD_LOCAL                            = $c2; $c2 LOCAL
=$c3					KWD_OFF                              = $c3; $c3 OFF
=$c4					KWD_ON                               = $c4; $c4 ON
=$c5					KWD_OUTLINE                          = $c5; $c5 OUTLINE
=$c6					KWD_PALETTE                          = $c6; $c6 PALETTE
=$c7					KWD_PLOT                             = $c7; $c7 PLOT
=$c8					KWD_POKE                             = $c8; $c8 POKE
=$c9					KWD_PRINT                            = $c9; $c9 PRINT
=$ca					KWD_READ                             = $ca; $ca READ
=$cb					KWD_RECT                             = $cb; $cb RECT
=$cc					KWD_REM                              = $cc; $cc REM
=$cd					KWD_RETURN                           = $cd; $cd RETURN
=$ce					KWD_SOLID                            = $ce; $ce SOLID
=$cf					KWD_SOUND                            = $cf; $cf SOUND
=$d0					KWD_SPRITE                           = $d0; $d0 SPRITE
=$d1					KWD_TEXT                             = $d1; $d1 TEXT
=$d2					KWD_TO                               = $d2; $d2 TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a2					KWC_FIRST_STRUCTURE = $a2
=$a7					KWC_FIRST_STRUCTURE_DEC = $a7
=$ac					KWC_LAST_STRUCTURE = $ac
=$83					KWC_FIRST_UNARY = $83
=$a1					KWC_LAST_UNARY = $a1

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	4c 24 80	jmp $8024	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/_build/_linker.module

=0					PagingEnabled = 0
.8003					EXTPrintCharacter:
.8003	4c 13 a8	jmp $a813		jmp	Export_EXTPrintCharacter
.8006					EXTInitialise:
.8006	4c ac aa	jmp $aaac		jmp	Export_EXTInitialise
.8009					EXTInputSingleCharacter:
.8009	4c e2 aa	jmp $aae2		jmp	Export_EXTInputSingleCharacter
.800c					EXTBreakCheck:
.800c	4c 08 ab	jmp $ab08		jmp	Export_EXTBreakCheck
.800f					EXTReadController:
.800f	4c 0b ab	jmp $ab0b		jmp	Export_EXTReadController
.8012					EXTInputLine:
.8012	4c c2 a9	jmp $a9c2		jmp	Export_EXTInputLine
.8015					GXGraphicDraw:
.8015	4c a6 ab	jmp $aba6		jmp	Export_GXGraphicDraw
.8018					SNDCommand:
.8018	4c 90 be	jmp $be90		jmp	Export_SNDCommand
.801b					SNDUpdate:
.801b	4c c3 be	jmp $bec3		jmp	Export_SNDUpdate
.801e					TKListConvertLine:
.801e	4c 86 b8	jmp $b886		jmp	Export_TKListConvertLine
.8021					TKTokeniseLine:
.8021	4c 1a bb	jmp $bb1a		jmp	Export_TKTokeniseLine

;******  Return to file: ./common/aa.system/00start.asm

.8024	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8026	9a		txs				txs
.8027	a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.8029	09 80		ora #$80			ora 	#$80
.802b	85 00		sta $00				sta 	0
.802d	20 06 80	jsr $8006			jsr 	EXTInitialise 				; hardware initialise
.8030	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.8032	aa		tax				tax
.8033	a8		tay				tay
.8034	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.8037	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8039	20 18 80	jsr $8018			jsr 	SNDCommand
.803c	a2 80		ldx #$80			ldx 	#Prompt >> 8 				; display prompt
.803e	a9 54		lda #$54			lda 	#Prompt & $FF
.8040	20 7f 8f	jsr $8f7f			jsr 	PrintStringXA
.8043	20 e1 ff	jsr $ffe1			jsr 	$FFE1
.8046	08		php				php
.8047	68		pla				pla
.8048	20 6b 81	jsr $816b			jsr	 	PrintHex
.804b	20 f6 89	jsr $89f6			jsr 	NewProgram 					; erase current program
.804e	4c 9f 83	jmp $839f			jmp 	WarmStart					; make same size.
.8051	4c 9f 83	jmp $839f			jmp 	WarmStart
>8054	46 32 35 36 20 42 41 53		Prompt:	.text 	"F256 BASIC "
>805c	49 43 20

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>805f	52 65 6c 65 61 73 65 20			.text "Release Alpha 11 (05-Dec-22). "
>8067	41 6c 70 68 61 20 31 31 20 28 30 35 2d 44 65 63
>8077	2d 32 32 29 2e 20

;******  Return to file: ./common/aa.system/00start.asm

>807d	0d 0d 00					.text 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.8080					AssembleGroup1:
.8080	a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.8082	8d 25 04	sta $0425			sta 	ModeMask 					; initialise the mode mask - all for all
.8085	80 02		bra $8089			bra 	AsmGroup12
.8087					AssembleGroup2:
.8087	a9 00		lda #$00			lda 	#$00 						; flag for group 2
.8089					AsmGroup12:
.8089	8d 23 04	sta $0423			sta 	IsGroup1 					; save the 'group 1' flag
.808c	68		pla				pla 								; pop the return address to access the information following.
.808d	fa		plx				plx
.808e	20 15 81	jsr $8115			jsr 	AccessParameters 			; get opcode and save as base
.8091	8d 24 04	sta $0424			sta 	BaseOpcode
.8094	ad 23 04	lda $0423			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8097	d0 08		bne $80a1			bne 	_AG12HaveMask
.8099	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.809b	20 1d 81	jsr $811d			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.809e	8d 25 04	sta $0425			sta 	ModeMask
.80a1					_AG12HaveMask:
.80a1	20 51 82	jsr $8251			jsr 	TypeAndCalculateOperand 	; get zero page type
.80a4	da		phx				phx 								; save found address mode
.80a5	20 81 81	jsr $8181			jsr 	AssembleModeX
.80a8	fa		plx				plx  								; restore address mode
.80a9	b0 0b		bcs $80b6			bcs 	_AG12Exit
.80ab	20 b7 80	jsr $80b7			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.80ae	20 81 81	jsr $8181			jsr 	AssembleModeX
.80b1	b0 03		bcs $80b6			bcs 	_AG12Exit
.80b3	4c c6 9f	jmp $9fc6			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80b6					_AG12Exit:
.80b6	60		rts				rts
.80b7					PromoteToAbsolute:
.80b7	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80b9	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80bb	f0 19		beq $80d6			beq 	_PTADo
.80bd	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80bf	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80c1	f0 13		beq $80d6			beq 	_PTADo
.80c3	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80c5	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80c7	f0 0d		beq $80d6			beq 	_PTADo
.80c9	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80cb	e0 d1		cpx #$d1			cpx 	#AM_IND
.80cd	f0 07		beq $80d6			beq 	_PTADo
.80cf	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80d1	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80d3	f0 01		beq $80d6			beq 	_PTADo
.80d5	60		rts				rts
.80d6					_PTADo:
.80d6	aa		tax				tax
.80d7	60		rts				rts
.80d8					AssembleGroup3:
.80d8	68		pla				pla 								; get parameters, which is just the opcode.
.80d9	fa		plx				plx
.80da	20 15 81	jsr $8115			jsr 	AccessParameters 			; get and output opcode
.80dd	20 2d 81	jsr $812d			jsr 	AssemblerWriteByte
.80e0	20 b5 82	jsr $82b5			jsr 	CalculateOperand 			; get a 16 bit operand
.80e3	a5 58		lda $58				lda 	NSMantissa0 				; calculate the offset
.80e5	38		sec				sec
.80e6	ed 1e 04	sbc $041e			sbc 	AssemblerAddress
.80e9	48		pha				pha 								; LSB in A
.80ea	a5 60		lda $60				lda 	NSMantissa1
.80ec	ed 1f 04	sbc $041f			sbc 	AssemblerAddress+1
.80ef	aa		tax				tax 								; MSB in X
.80f0	68		pla				pla
.80f1	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80f2	69 7f		adc #$7f			adc 	#$7F
.80f4	90 01		bcc $80f7			bcc 	_AG3NoCarry
.80f6	e8		inx				inx
.80f7					_AG3NoCarry:
.80f7	38		sec				sec 								; fix back and write out anyways.
.80f8	e9 80		sbc #$80			sbc 	#$80
.80fa	20 2d 81	jsr $812d			jsr 	AssemblerWriteByte
.80fd	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ff	f0 0a		beq $810b			beq 	_AG3Exit
.8101	ad 20 04	lda $0420			lda 	AssemblerControl 			; are we allowing bad values ?
.8104	29 01		and #$01			and 	#1
.8106	f0 03		beq $810b			beq 	_AG3Exit
.8108	4c cb 9f	jmp $9fcb			jmp 	RangeError 					; no, branch is out of range
.810b					_AG3Exit:
.810b	60		rts				rts
.810c					AssembleGroup4:
.810c	68		pla				pla 								; pop address
.810d	fa		plx				plx
.810e	20 15 81	jsr $8115			jsr 	AccessParameters 			; access and get first
.8111	20 2d 81	jsr $812d			jsr 	AssemblerWriteByte 			; output it.
.8114	60		rts				rts
.8115					AccessParameters:
.8115	8d 21 04	sta $0421			sta 	ParamStart
.8118	8e 22 04	stx $0422			stx 	ParamStart+1
.811b	a9 01		lda #$01			lda 	#1
.811d					GetParameter:
.811d	5a		phy				phy
.811e	a8		tay				tay
.811f	ad 21 04	lda $0421			lda 	ParamStart
.8122	85 36		sta $36				sta 	zTemp0
.8124	ad 22 04	lda $0422			lda 	ParamStart+1
.8127	85 37		sta $37				sta 	zTemp0+1
.8129	b1 36		lda ($36),y			lda 	(zTemp0),y
.812b	7a		ply				ply
.812c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.812d					AssemblerWriteByte:
.812d	48		pha			pha
.812e	ad 20 04	lda $0420		lda 	AssemblerControl 				; check printing bytes ?
.8131	29 02		and #$02		and 	#2
.8133	f0 1b		beq $8150		beq 	_AWBNoPrint
.8135	ad 1f 04	lda $041f		lda		AssemblerAddress+1 				; print address
.8138	20 6b 81	jsr $816b		jsr 	PrintHex
.813b	ad 1e 04	lda $041e		lda		AssemblerAddress
.813e	20 6b 81	jsr $816b		jsr 	PrintHex
.8141	a9 20		lda #$20		lda 	#' '
.8143	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8146	68		pla			pla 									; print byte
.8147	48		pha			pha
.8148	20 6b 81	jsr $816b		jsr 	PrintHex
.814b	a9 0d		lda #$0d		lda 	#13
.814d	20 03 80	jsr $8003		jsr 	EXTPrintCharacter
.8150					_AWBNoPrint:
.8150	ad 1e 04	lda $041e		lda		AssemblerAddress				; copy address to zTemp0
.8153	85 36		sta $36			sta 	zTemp0
.8155	ad 1f 04	lda $041f		lda		AssemblerAddress+1
.8158	f0 0e		beq $8168		beq 	_AWBRange
.815a	85 37		sta $37			sta 	zTemp0+1
.815c	68		pla			pla 									; write byte out
.815d	92 36		sta ($36)		sta 	(zTemp0)
.815f	ee 1e 04	inc $041e		inc 	AssemblerAddress 				; bump address
.8162	d0 03		bne $8167		bne 	_AWBNoCarry
.8164	ee 1f 04	inc $041f		inc 	AssemblerAddress+1
.8167					_AWBNoCarry:
.8167	60		rts			rts
.8168					_AWBRange:
.8168	4c cb 9f	jmp $9fcb		jmp 	RangeError
.816b					PrintHex:
.816b	48		pha				pha
.816c	4a		lsr a				lsr 	a
.816d	4a		lsr a				lsr 	a
.816e	4a		lsr a				lsr 	a
.816f	4a		lsr a				lsr 	a
.8170	20 74 81	jsr $8174			jsr 	_PrintNibble
.8173	68		pla				pla
.8174					_PrintNibble:
.8174	29 0f		and #$0f			and 	#15
.8176	c9 0a		cmp #$0a			cmp 	#10
.8178	90 02		bcc $817c			bcc 	_NoShift
.817a	69 06		adc #$06			adc 	#6
.817c					_NoShift:
.817c	69 30		adc #$30			adc 	#48
.817e	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8181					AssembleModeX:
.8181	5a		phy				phy
.8182	ad 23 04	lda $0423			lda 	IsGroup1
.8185	f0 17		beq $819e			beq 	_AMXGroup2
.8187	8a		txa				txa 							; is it in group # 1
.8188	29 40		and #$40			and 	#AM_ISG1
.818a	f0 4d		beq $81d9			beq 	_AMXFail 				; no, give up.
.818c	8a		txa				txa 							; get back.
.818d	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.818f	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8191	d0 22		bne $81b5			bne 	_AMXHaveInfo
.8193	ad 24 04	lda $0424			lda 	BaseOpcode 				; cannot store immediate.
.8196	c9 81		cmp #$81			cmp 	#$81
.8198	f0 3f		beq $81d9			beq 	_AMXFail
.819a	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.819c	80 17		bra $81b5			bra 	_AMXHaveInfo 			; odd design decision there.
.819e					_AMXGroup2:
.819e	8a		txa				txa 							; is it in group 2 ?
.819f	29 20		and #$20			and 	#AM_ISG2
.81a1	f0 36		beq $81d9			beq 	_AMXFail 				; no, give up.
.81a3	8a		txa				txa 							; get the offset into Y
.81a4	29 1f		and #$1f			and 	#$1F
.81a6	4a		lsr a				lsr 	a 						; make it 0-7.
.81a7	4a		lsr a				lsr  	a
.81a8	a8		tay				tay
.81a9	ad 25 04	lda $0425			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.81ac					_AMXCheckOkay:
.81ac	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.81ad	88		dey				dey
.81ae	10 fc		bpl $81ac			bpl 	_AMXCheckOkay
.81b0	90 27		bcc $81d9			bcc 	_AMXFail 				; not allowed.
.81b2	8a		txa				txa  							; get mask back
.81b3	29 1f		and #$1f			and 	#$1F
.81b5					_AMXHaveInfo:
.81b5	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81b7	10 04		bpl $81bd			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81b9	a4 60		ldy $60				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81bb	d0 1c		bne $81d9			bne 	_AMXFail
.81bd					_AMXAnySize:
.81bd	18		clc				clc 							; add offset to the base opcode
.81be	6d 24 04	adc $0424			adc 	BaseOpcode
.81c1					_AMXOutputCode:
.81c1	20 2d 81	jsr $812d			jsr 	AssemblerWriteByte 		; write the opcode out.
.81c4	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.81c6	f0 0e		beq $81d6			beq 	_AMXExit
.81c8	a5 58		lda $58				lda 	NSMantissa0 			; write LSB operand
.81ca	20 2d 81	jsr $812d			jsr 	AssemblerWriteByte
.81cd	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81cf	30 05		bmi $81d6			bmi 	_AMXExit
.81d1	a5 60		lda $60				lda 	NSMantissa1 			; write MSB operand
.81d3	20 2d 81	jsr $812d			jsr 	AssemblerWriteByte
.81d6					_AMXExit:
.81d6	7a		ply				ply
.81d7	38		sec				sec
.81d8	60		rts				rts
.81d9					_AMXFail:
.81d9	a0 00		ldy #$00			ldy 	#0
.81db					_AMXCheckOddities:
.81db	8a		txa				txa
.81dc	d9 03 82	cmp $8203,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81df	d0 15		bne $81f6			bne 	_AMXCONext
.81e1	b9 01 82	lda $8201,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81e4	cd 24 04	cmp $0424			cmp 	BaseOpcode
.81e7	d0 0d		bne $81f6			bne 	_AMXCONext
.81e9	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81eb	10 04		bpl $81f1			bpl 	_AMXCONotZero
.81ed	a5 60		lda $60				lda 	NSMantissa1
.81ef	d0 05		bne $81f6			bne 	_AMXCONext
.81f1					_AMXCONotZero:
.81f1	b9 02 82	lda $8202,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81f4	80 cb		bra $81c1			bra 	_AMXOutputCode 			; and assemble it
.81f6					_AMXCONext:
.81f6	c8		iny				iny
.81f7	c8		iny				iny
.81f8	c8		iny				iny
.81f9	b9 01 82	lda $8201,y			lda 	ExtraOpcode+0,y 		; end of table
.81fc	d0 dd		bne $81db			bne 	_AMXCheckOddities
.81fe					_AMXCOFail:
.81fe	7a		ply				ply
.81ff	18		clc				clc
.8200	60		rts				rts
.8201					ExtraOpcode:
>8201	40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>8204	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>8207	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>820a	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>820d	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8210	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8213	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>8216	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>8219	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>821c	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>821f	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8220					LabelHere:
.8220	c8		iny				iny 								; skip .
.8221	a2 00		ldx #$00			ldx 	#0 							; get a term
.8223	20 74 98	jsr $9874			jsr 	EvaluateTerm
.8226	a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.8228	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.822a	d0 22		bne $824e			bne 	_ALType 					; otherwise typing error
.822c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.822e	85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.8230	b5 60		lda $60,x			lda 	NSMantissa1,x
.8232	85 37		sta $37				sta 	zTemp0+1
.8234	5a		phy				phy 								; copy address in (64k)
.8235	a0 01		ldy #$01			ldy 	#1
.8237	ad 1e 04	lda $041e			lda	 	AssemblerAddress
.823a	92 36		sta ($36)			sta 	(zTemp0)
.823c	ad 1f 04	lda $041f			lda	 	AssemblerAddress+1
.823f	91 36		sta ($36),y			sta 	(zTemp0),y
.8241	c8		iny				iny
.8242	a9 00		lda #$00			lda 	#0 							; zero the rest.
.8244	91 36		sta ($36),y			sta 	(zTemp0),y
.8246	c8		iny				iny
.8247	91 36		sta ($36),y			sta 	(zTemp0),y
.8249	c8		iny				iny
.824a	91 36		sta ($36),y			sta 	(zTemp0),y
.824c	7a		ply				ply
.824d	60		rts				rts
.824e					_ALType:
.824e	4c d0 9f	jmp $9fd0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8251					TypeAndCalculateOperand:
.8251	b1 30		lda ($30),y			lda 	(codePtr),y
.8253	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.8255	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8257	f0 5b		beq $82b4			beq 	_TACOExit
.8259	c9 80		cmp #$80			cmp 	#KWC_EOL
.825b	f0 57		beq $82b4			beq 	_TACOExit
.825d	c8		iny				iny
.825e	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8260	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8262	f0 51		beq $82b5			beq 	CalculateOperand
.8264	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8266	f0 1f		beq $8287			beq 	_TACOIndirect
.8268	88		dey				dey 								; undo get of first character
.8269	20 b5 82	jsr $82b5			jsr 	CalculateOperand 			; get operand
.826c	b1 30		lda ($30),y			lda 	(codePtr),y
.826e	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8270	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8272	d0 40		bne $82b4			bne 	_TACOExit
.8274	c8		iny				iny
.8275	20 bf 82	jsr $82bf			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8278	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.827a	c9 58		cmp #$58			cmp 	#'X'
.827c	f0 36		beq $82b4			beq 	_TACOExit
.827e	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8280	c9 59		cmp #$59			cmp 	#'Y'
.8282	f0 30		beq $82b4			beq 	_TACOExit
.8284					_TACOSyntax:
.8284	4c c6 9f	jmp $9fc6			jmp 	SyntaxError
.8287					_TACOIndirect:
.8287	20 b5 82	jsr $82b5			jsr 	CalculateOperand 			; get the operand
.828a	b1 30		lda ($30),y			lda 	(codePtr),y
.828c	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.828e	f0 17		beq $82a7			beq 	_TACOIndX
.8290	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.8293	b1 30		lda ($30),y			lda 	(codePtr),y
.8295	a2 d1		ldx #$d1			ldx 	#AM_IND
.8297	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.8299	d0 19		bne $82b4			bne 	_TACOExit
.829b	c8		iny				iny
.829c	20 bf 82	jsr $82bf			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.829f	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.82a1	d0 e1		bne $8284			bne 	_TACOSyntax
.82a3	a2 d0		ldx #$d0			ldx 	#AM_INDY
.82a5	80 0d		bra $82b4			bra 	_TACOExit
.82a7					_TACOIndX:
.82a7	c8		iny				iny
.82a8	20 bf 82	jsr $82bf			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82ab	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82ad	d0 d5		bne $8284			bne 	_TACOSyntax
.82af	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket			; check )
.82b2	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82b4					_TACOExit:
.82b4	60		rts				rts
.82b5					CalculateOperand:
.82b5	48		pha				pha
.82b6	da		phx				phx
.82b7	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82b9	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger
.82bc	fa		plx				plx
.82bd	68		pla				pla
.82be	60		rts				rts
.82bf					TACOCheckXY:
.82bf	b1 30		lda ($30),y			lda 	(codePtr),y
.82c1	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82c3	c9 40		cmp #$40			cmp 	#$40
.82c5	d0 21		bne $82e8			bne 	_TCXYFail
.82c7	b1 30		lda ($30),y			lda 	(codePtr),y
.82c9	18		clc				clc
.82ca	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82cc	85 37		sta $37				sta 	zTemp0+1
.82ce	c8		iny				iny
.82cf	b1 30		lda ($30),y			lda 	(codePtr),y
.82d1	c8		iny				iny
.82d2	85 36		sta $36				sta 	zTemp0
.82d4	5a		phy				phy 								; save position
.82d5	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82d7	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d9	d0 0c		bne $82e7			bne 	_TCXYPopFail
.82db	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82dd	b1 36		lda ($36),y			lda 	(zTemp0),y
.82df	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82e1	f0 08		beq $82eb			beq 	_TCXYFound
.82e3	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82e5	f0 04		beq $82eb			beq 	_TCXYFound
.82e7					_TCXYPopFail:
.82e7	7a		ply				ply
.82e8					_TCXYFail:
.82e8	a9 00		lda #$00			lda 	#0
.82ea	60		rts				rts
.82eb					_TCXYFound:
.82eb	7a		ply				ply 								; restore position
.82ec	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82ee	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82ef					BackloadProgram:
.82ef	20 f6 89	jsr $89f6			jsr 	NewProgram 					; does the actual NEW.
.82f2	a2 83		ldx #$83			ldx 	#_BLLoad >> 8
.82f4	a9 43		lda #$43			lda 	#_BLLoad & $FF
.82f6	20 7f 8f	jsr $8f7f			jsr 	PrintStringXA
.82f9	a5 0b		lda $0b				lda 	8+3 						; save current mapping for $6000
.82fb	48		pha				pha
.82fc	a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; map source code in there.
.82fe	85 0b		sta $0b				sta 	8+3
.8300	a9 00		lda #$00			lda 	#(($6000) & $FF)
.8302	8d 59 06	sta $0659			sta 	0+BackLoadPointer
.8305	a9 60		lda #$60			lda 	#(($6000) >> 8)
.8307	8d 5a 06	sta $065a			sta 	1+BackLoadPointer
.830a	a9 ff		lda #$ff			lda 	#$FF
.830c	8d fa ff	sta $fffa			sta 	$FFFA
.830f					_BPLoop:
.830f	a2 ff		ldx #$ff			ldx 	#$FF
.8311	20 58 83	jsr $8358			jsr 	BLReadByte 					; read a byte
.8314	c9 00		cmp #$00			cmp 	#0
.8316	f0 21		beq $8339			beq 	_BPExit 					; if 0 exit
.8318	30 1f		bmi $8339			bmi 	_BPExit 					; if -ve exit
.831a					_BPCopy:
.831a	e8		inx				inx  								; copy byte into the lineBuffer
.831b	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.831e	9e 2b 05	stz $052b,x			stz 	lineBuffer+1,x
.8321	20 58 83	jsr $8358			jsr 	BLReadByte 					; read next byte
.8324	30 0a		bmi $8330			bmi 	_BPEndLine 					; -ve = EOL
.8326	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.8328	d0 02		bne $832c			bne 	_BPNotTab
.832a	a9 20		lda #$20			lda 	#' '
.832c					_BPNotTab:
.832c	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.832e	b0 ea		bcs $831a			bcs 	_BPCopy 					; until a control character, should be 13 received.
.8330					_BPEndLine:
.8330	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line.
.8333	38		sec				sec 								; append not insert
.8334	20 11 a5	jsr $a511			jsr 	MemoryInsertLine 			; append to current program
.8337	80 d6		bra $830f			bra 	_BPLoop
.8339					_BPExit:
.8339	68		pla				pla 								; restore memory setup.
.833a	85 0b		sta $0b				sta 	8+3
.833c	9c fa ff	stz $fffa			stz 	$FFFA
.833f	20 35 84	jsr $8435			jsr 	ClearCommand 				; clear variables etc.
.8342	60		rts				rts
.8343					_BLLoad:
>8343	4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>834b	66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.8358					BLReadByte:
.8358	ad 59 06	lda $0659			lda 	BackLoadPointer 			; copy pointer to zTemp0
.835b	85 36		sta $36				sta 	zTemp0
.835d	ad 5a 06	lda $065a			lda 	BackLoadPointer+1
.8360	85 37		sta $37				sta 	zTemp0+1
.8362	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8364	ee 59 06	inc $0659			inc 	BackLoadPointer 			; bump pointer
.8367	d0 0e		bne $8377			bne 	_BLNoCarry
.8369	ee 5a 06	inc $065a			inc 	BackLoadPointer+1
.836c	10 09		bpl $8377			bpl 	_BLNoCarry 					; need a new page
.836e	48		pha				pha
.836f	a9 60		lda #$60			lda 	#$60 						; reset pointer
.8371	8d 5a 06	sta $065a			sta 	BackLoadPointer+1
.8374	e6 0b		inc $0b				inc 	8+3 						; next page from source.
.8376	68		pla				pla
.8377					_BLNoCarry:
.8377	c9 00		cmp #$00			cmp 	#0
.8379	60		rts				rts
.0659					BackLoadPointer:
>0659							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.837a					EditProgramCode:
.837a	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; try to find the line.
.837d	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1
.8380	20 b5 a5	jsr $a5b5			jsr 	MemorySearch
.8383	90 05		bcc $838a			bcc 	_EPCNoDelete 				; reached the end : don't delete
.8385	d0 03		bne $838a			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.8387	20 da a4	jsr $a4da			jsr 	MemoryDeleteLine 			; delete the line
.838a					_EPCNoDelete:
.838a	ad 2d 04	lda $042d			lda 	TokenBuffer 				; buffer empty - we just want to delete a line.
.838d	c9 80		cmp #$80			cmp 	#KWC_EOL
.838f	f0 0d		beq $839e			beq 	_EPCNoInsert
.8391	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.8394	ae 2c 04	ldx $042c			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8397	20 b5 a5	jsr $a5b5			jsr 	MemorySearch
.839a	18		clc				clc 								; insert at this point.
.839b	20 11 a5	jsr $a511			jsr 	MemoryInsertLine 			; insert the line
.839e					_EPCNoInsert:
.839e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.839f					WarmStart:
.839f	a2 ff		ldx #$ff			ldx 	#$FF
.83a1	9a		txs				txs
.83a2	a9 85		lda #$85			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.83a4	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.83a7	20 12 80	jsr $8012			jsr 	EXTInputLine 				; get line to lineBuffer
.83aa	20 21 80	jsr $8021			jsr 	TKTokeniseLine 				; tokenise the line
.83ad	ad 2b 04	lda $042b			lda 	TokenLineNumber 			; line number <> 0
.83b0	0d 2c 04	ora $042c			ora 	TokenLineNumber+1
.83b3	d0 17		bne $83cc			bne 	_WSEditCode 				; if so,edit code.
.83b5	9c 2a 04	stz $042a			stz 	TokenOffset 				; zero the "offset", meaning it only runs one line.
.83b8	a9 2a		lda #$2a			lda 	#((TokenOffset) & $FF)
.83ba	85 30		sta $30				sta 	codePtr
.83bc	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.83be	85 31		sta $31				sta 	codePtr+1
.83c0	ad 2d 04	lda $042d			lda 	TokenBuffer 				; nothing to run
.83c3	c9 80		cmp #$80			cmp 	#KWC_EOL
.83c5	f0 d8		beq $839f			beq 	WarmStart
.83c7	20 49 8b	jsr $8b49			jsr 	RUNCodePointerLine 			; execute that line.
.83ca	80 d3		bra $839f			bra 	WarmStart
.83cc					_WSEditCode:
.83cc	20 7a 83	jsr $837a			jsr 	EditProgramCode 			; edit the program code
.83cf	20 35 84	jsr $8435			jsr 	ClearCommand 				; clear all variables etc.
.83d2	80 cb		bra $839f			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.83d4					AssembleCommand:
.83d4	a2 00		ldx #$00			ldx 	#0
.83d6	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger 		; start address
.83d9	a5 58		lda $58				lda 	NSMantissa0
.83db	8d 1e 04	sta $041e			sta 	AssemblerAddress
.83de	a5 60		lda $60				lda 	NSMantissa1
.83e0	8d 1f 04	sta $041f			sta 	AssemblerAddress+1
.83e3	20 15 8f	jsr $8f15			jsr 	CheckComma
.83e6	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; options 0-3
.83e9	a5 58		lda $58				lda 	NSMantissa0
.83eb	8d 20 04	sta $0420			sta 	AssemblerControl
.83ee	60		rts				rts
.83ef	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83f0					AssertCommand:
.83f0	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83f2	20 b5 9d	jsr $9db5			jsr 	EvaluateInteger 			; the assert test
.83f5	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; exit if result is non zero.
.83f8	d0 05		bne $83ff			bne 	_ACExit
.83fa	a9 0a		lda #$0a		lda	#10
.83fc	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.83ff					_ACExit:
.83ff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.8400					CallCommand:
.8400	a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.8402	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger
.8405					_CCClear
.8405	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.8406	20 48 9e	jsr $9e48			jsr 	NSMSetZero 					; these are optional sequentially.
.8409	e0 04		cpx #$04			cpx 	#4
.840b	d0 f8		bne $8405			bne 	_CCClear
.840d	a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.840f					_CCCParam:
.840f	b1 30		lda ($30),y			lda 	(codePtr),y
.8411	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8413	d0 09		bne $841e			bne 	_CCCRun6502
.8415	c8		iny				iny 								; skip comma
.8416	e8		inx				inx	 								; next level
.8417	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; get A/X/Y
.841a	e0 03		cpx #$03			cpx 	#3
.841c	90 f1		bcc $840f			bcc 	_CCCParam 					; done all 3 ?
.841e					_CCCRun6502:
.841e	5a		phy				phy 								; save position
.841f	a5 60		lda $60				lda 	NSMantissa1 				; put address in zTemp0
.8421	85 37		sta $37				sta 	zTemp0+1
.8423	a5 58		lda $58				lda 	NSMantissa0
.8425	85 36		sta $36				sta 	zTemp0
.8427	a5 59		lda $59				lda 	NSMantissa0+1 				; get registers into A X Y
.8429	a6 5a		ldx $5a				ldx 	NSMantissa0+2
.842b	a4 5b		ldy $5b				ldy 	NSMantissa0+3
.842d	20 32 84	jsr $8432			jsr 	_CCCZTemp0 					; call zTemp0
.8430	7a		ply				ply 								; restore position and exit
.8431	60		rts				rts
.8432					_CCCZTemp0:
.8432	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.8435					ClearCommand:
.8435	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.8437	85 36		sta $36				sta 	0+zTemp0
.8439	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.843b	85 37		sta $37				sta 	1+zTemp0
.843d					_ClearZeroLoop:
.843d	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.843f	f0 24		beq $8465			beq 	_ClearZeroEnd
.8441	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.8443	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8445					_ClearOneVariable:
.8445	91 36		sta ($36),y			sta 	(zTemp0),y
.8447	c8		iny				iny
.8448	c0 08		cpy #$08			cpy 	#8
.844a	d0 f9		bne $8445			bne 	_ClearOneVariable
.844c	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.844e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8450	c9 18		cmp #$18			cmp 	#NSTProcedure
.8452	d0 04		bne $8458			bne 	_ClearNotProcedure
.8454	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8456	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.8458					_ClearNotProcedure:
.8458	18		clc				clc 								; go to the next variable
.8459	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.845b	65 36		adc $36				adc 	zTemp0
.845d	85 36		sta $36				sta 	zTemp0
.845f	90 dc		bcc $843d			bcc 	_ClearZeroLoop
.8461	e6 37		inc $37				inc 	zTemp0+1
.8463	80 d8		bra $843d			bra 	_ClearZeroLoop
.8465					_ClearZeroEnd:
.8465	18		clc				clc
.8466	a5 36		lda $36				lda 	zTemp0
.8468	69 01		adc #$01			adc 	#1
.846a	8d 0c 04	sta $040c			sta 	lowMemPtr
.846d	a5 37		lda $37				lda 	zTemp0+1
.846f	69 00		adc #$00			adc 	#0
.8471	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.8474	20 41 a7	jsr $a741			jsr 	StackReset
.8477	20 a7 a7	jsr $a7a7			jsr 	StringSystemInitialise
.847a	20 b3 8d	jsr $8db3			jsr 	ProcedureScan
.847d	20 f8 8a	jsr $8af8			jsr 	Command_Restore
.8480	9c 1e 04	stz $041e			stz 	AssemblerAddress
.8483	9c 1f 04	stz $041f			stz 	AssemblerAddress+1
.8486	9c 20 04	stz $0420			stz 	AssemblerControl
.8489	20 5b 9a	jsr $9a5b			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.848c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.848d					ClearScreen:
.848d	5a		phy				phy
.848e	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8490	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8493	7a		ply				ply
.8494	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8495					Command_Data:
.8495	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.8497	a2 80		ldx #$80			ldx 	#KWC_EOL
.8499	20 05 8e	jsr $8e05			jsr 	ScanForward
.849c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.849d					DimCommand:
.849d	b1 30		lda ($30),y			lda 	(codePtr),y
.849f	29 c0		and #$c0			and 	#$C0
.84a1	c9 40		cmp #$40			cmp 	#$40
.84a3	d0 7a		bne $851f			bne 	_DCSyntax 				; n o, error.
.84a5	b1 30		lda ($30),y			lda 	(codePtr),y
.84a7	18		clc				clc
.84a8	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.84aa	85 3f		sta $3f				sta 	zaTemp+1
.84ac	c8		iny				iny
.84ad	b1 30		lda ($30),y			lda 	(codePtr),y
.84af	c8		iny				iny
.84b0	85 3e		sta $3e				sta 	zaTemp
.84b2	5a		phy				phy
.84b3	a0 02		ldy #$02			ldy 	#2 						; read type byte
.84b5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84b7	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.84b9	c9 18		cmp #$18			cmp 	#NSTProcedure
.84bb	f0 62		beq $851f			beq 	_DCSyntax
.84bd	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.84bf	29 04		and #$04			and 	#NSBIsArray
.84c1	f0 64		beq $8527			beq 	_DCType
.84c3	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.84c5	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84c7	d0 59		bne $8522			bne 	_DCRedefine
.84c9	7a		ply				ply
.84ca	20 2a 85	jsr $852a			jsr 	_DCGetSize 				; get array size, check it.
.84cd	5a		phy				phy
.84ce	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.84d0	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.84d2	7a		ply				ply 							; is there a second (e.g. ,x)
.84d3	b1 30		lda ($30),y			lda 	(codePtr),y
.84d5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.84d7	d0 0a		bne $84e3			bne 	_DCOneDimension
.84d9	c8		iny				iny 							; skip comma
.84da	20 2a 85	jsr $852a			jsr 	_DCGetSize 				; get 2nd array size
.84dd	5a		phy				phy
.84de	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84e0	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84e2	7a		ply				ply
.84e3					_DCOneDimension:
.84e3	5a		phy				phy 							; save position
.84e4	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84e6	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84e8	aa		tax				tax
.84e9	c8		iny				iny
.84ea	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ec	e8		inx				inx 							; bump them.
.84ed	1a		inc a				inc 	a
.84ee	20 f3 9d	jsr $9df3			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84f1	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84f3	29 e0		and #$e0			and 	#$E0
.84f5	d0 23		bne $851a			bne 	_DCSize
.84f7	a0 02		ldy #$02			ldy 	#2 						; get base type
.84f9	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84fb	20 38 85	jsr $8538			jsr 	ScaleByBaseType 		; scale by base type
.84fe	a5 36		lda $36				lda 	zTemp0
.8500	a6 37		ldx $37				ldx 	zTemp0+1
.8502	20 1d 9a	jsr $9a1d			jsr 	AllocateXABytes 		; allocate memory
.8505	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.8507	91 3e		sta ($3e),y			sta 	(zaTemp),y
.8509	c8		iny				iny
.850a	8a		txa				txa
.850b	91 3e		sta ($3e),y			sta 	(zaTemp),y
.850d	7a		ply				ply 							; get position back
.850e	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket 		; check )
.8511	b1 30		lda ($30),y			lda 	(codePtr),y
.8513	c8		iny				iny 							; consume in case
.8514	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.8516	f0 85		beq $849d			beq 	DimCommand
.8518	88		dey				dey 							; undo consume
.8519	60		rts				rts
.851a					_DCSize:
.851a	a9 16		lda #$16		lda	#22
.851c	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.851f					_DCSyntax:
.851f	4c c6 9f	jmp $9fc6			jmp 	SyntaxError
.8522					_DCRedefine:
.8522	a9 15		lda #$15		lda	#21
.8524	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.8527					_DCType:
.8527	4c d0 9f	jmp $9fd0			jmp 	TypeError
.852a					_DCGetSize:
.852a	a2 00		ldx #$00			ldx 	#0 						; get first index.
.852c	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 	; get array dimension
.852f	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8531	f0 e7		beq $851a			beq 	_DCSize
.8533	c9 fe		cmp #$fe			cmp 	#254
.8535	f0 e3		beq $851a			beq 	_DCSize
.8537	60		rts				rts
.8538					ScaleByBaseType:
.8538	29 10		and #$10			and 	#NSBIsString 			; is it string
.853a	d0 19		bne $8555			bne 	_SBBTString
.853c	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.853e	48		pha				pha
.853f	a5 36		lda $36				lda 	zTemp0
.8541	48		pha				pha
.8542	06 36		asl $36				asl 	zTemp0 					; x 2
.8544	26 37		rol $37				rol 	zTemp0+1
.8546	06 36		asl $36				asl 	zTemp0 					; x 4
.8548	26 37		rol $37				rol 	zTemp0+1
.854a	68		pla				pla 							; add stacked value = x 5
.854b	65 36		adc $36				adc 	zTemp0
.854d	85 36		sta $36				sta 	zTemp0
.854f	68		pla				pla
.8550	65 37		adc $37				adc 	zTemp0+1
.8552	85 37		sta $37				sta 	zTemp0+1
.8554	60		rts				rts
.8555					_SBBTString:
.8555	06 36		asl $36				asl 	zTemp0
.8557	26 37		rol $37				rol 	zTemp0+1
.8559	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dokepoke.asm

.855a					PokeCommand:
.855a	18		clc				clc
.855b	80 01		bra $855e			bra 	DPCommand
.855d					DokeCommand:
.855d	38		sec				sec
.855e					DPCommand:
.855e	08		php				php									; save on stack, CS = Doke, CC = Poke
.855f	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8561	20 c8 9d	jsr $9dc8			jsr		Evaluate16BitInteger 		; address
.8564	20 15 8f	jsr $8f15			jsr 	CheckComma
.8567	e8		inx				inx
.8568	20 c8 9d	jsr $9dc8			jsr		Evaluate16BitInteger 		; data
.856b	a5 58		lda $58				lda 	NSMantissa0 				; copy address
.856d	85 36		sta $36				sta 	zTemp0
.856f	a5 60		lda $60				lda 	NSMantissa1
.8571	85 37		sta $37				sta 	zTemp0+1
.8573	a5 59		lda $59				lda 	NSMantissa0+1 				; low byte
.8575	92 36		sta ($36)			sta 	(zTemp0)
.8577	28		plp				plp 								; done if POKE
.8578	90 08		bcc $8582			bcc 	_DPExit
.857a	5a		phy				phy 								; write high byte out.
.857b	a0 01		ldy #$01			ldy 	#1
.857d	a5 61		lda $61				lda 	NSMantissa1+1
.857f	91 36		sta ($36),y			sta 	(zTemp0),y
.8581	7a		ply				ply
.8582					_DPExit:
.8582	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8583					EndCommand:
.8583	4c 9f 83	jmp $839f			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8586					ForCommand:
.8586	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.8588	20 db a6	jsr $a6db			jsr 	StackOpen
.858b	a2 00		ldx #$00			ldx 	#0
.858d	20 74 98	jsr $9874			jsr 	EvaluateTerm
.8590	b5 50		lda $50,x			lda 	NSStatus,x
.8592	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8594	d0 47		bne $85dd			bne		_FCError
.8596	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8598	20 1d 8f	jsr $8f1d			jsr 	CheckNextA
.859b	e8		inx				inx
.859c	20 b5 9d	jsr $9db5			jsr 	EvaluateInteger 			; <from> in +1
.859f	b1 30		lda ($30),y			lda 	(codePtr),y
.85a1	c8		iny				iny 								; consume it
.85a2	48		pha				pha 								; save on stack for later
.85a3	c9 b7		cmp #$b7			cmp 	#KWD_DOWNTO
.85a5	f0 04		beq $85ab			beq 	_FCNoSyntax
.85a7	c9 d2		cmp #$d2			cmp 	#KWD_TO
.85a9	d0 35		bne $85e0			bne 	_FCSyntaxError
.85ab					_FCNoSyntax:
.85ab	e8		inx				inx
.85ac	20 b5 9d	jsr $9db5			jsr 	EvaluateInteger
.85af	20 20 a7	jsr $a720			jsr 	STKSaveCodePosition 		; save loop back position
.85b2	68		pla				pla 								; restore DOWNTO or TO
.85b3	5a		phy				phy 								; save Y on the stack
.85b4	49 b7		eor #$b7			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.85b6	f0 02		beq $85ba			beq 	_FCNotDownTo
.85b8	a9 02		lda #$02			lda 	#2
.85ba					_FCNotDownTo:
.85ba	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.85bb	a0 10		ldy #$10			ldy 	#16
.85bd	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.85bf	a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.85c1	a5 58		lda $58				lda 	NSMantissa0
.85c3	91 34		sta ($34),y			sta 	(basicStack),y
.85c5	a5 60		lda $60				lda 	NSMantissa1
.85c7	c8		iny				iny
.85c8	91 34		sta ($34),y			sta 	(basicStack),y
.85ca	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.85cc	a2 01		ldx #$01			ldx 	#1
.85ce	20 e3 85	jsr $85e3			jsr 	FCIntegerToStack
.85d1	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.85d3	a2 02		ldx #$02			ldx 	#2
.85d5	20 e3 85	jsr $85e3			jsr 	FCIntegerToStack
.85d8	20 fe 85	jsr $85fe			jsr 	CopyIndexToReference
.85db	7a		ply				ply 								; restore position
.85dc	60		rts				rts
.85dd					_FCError:
.85dd	4c d0 9f	jmp $9fd0			jmp 	TypeError
.85e0					_FCSyntaxError:
.85e0	4c c6 9f	jmp $9fc6			jmp 	SyntaxError
.85e3					FCIntegerToStack:
.85e3	34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.85e5	10 03		bpl $85ea			bpl	 	_FCNotNegative
.85e7	20 11 9e	jsr $9e11			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.85ea					_FCNotNegative:
.85ea	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.85ec	91 34		sta ($34),y			sta 	(basicStack),y
.85ee	c8		iny				iny
.85ef	b5 60		lda $60,x			lda 	NSMantissa1,x
.85f1	91 34		sta ($34),y			sta 	(basicStack),y
.85f3	c8		iny				iny
.85f4	b5 68		lda $68,x			lda 	NSMantissa2,x
.85f6	91 34		sta ($34),y			sta 	(basicStack),y
.85f8	c8		iny				iny
.85f9	b5 70		lda $70,x			lda 	NSMantissa3,x
.85fb	91 34		sta ($34),y			sta 	(basicStack),y
.85fd	60		rts				rts
.85fe					CopyIndexToReference:
.85fe	5a		phy				phy
.85ff	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8601	38		sec				sec 								; (because we copy from offset 8)
.8602	b1 34		lda ($34),y			lda 	(basicStack),y
.8604	e9 08		sbc #$08			sbc 	#8
.8606	85 36		sta $36				sta 	zTemp0
.8608	c8		iny				iny
.8609	b1 34		lda ($34),y			lda 	(basicStack),y
.860b	e9 00		sbc #$00			sbc 	#0
.860d	85 37		sta $37				sta 	zTemp0+1
.860f	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.8611	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.8613	b1 34		lda ($34),y			lda 	(basicStack),y
.8615	0a		asl a				asl 	a 							; into carry
.8616	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8618	90 14		bcc $862e			bcc 	_CITRNormal
.861a	38		sec				sec
.861b					_CITRNegative:
.861b	a9 00		lda #$00			lda 	#0
.861d	f1 34		sbc ($34),y			sbc 	(basicStack),y
.861f	91 36		sta ($36),y			sta 	(zTemp0),y
.8621	c8		iny				iny
.8622	ca		dex				dex
.8623	d0 f6		bne $861b			bne 	_CITRNegative
.8625	88		dey				dey 								; look at MSB of mantissa
.8626	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.8628	09 80		ora #$80			ora 	#$80
.862a	91 36		sta ($36),y			sta 	(zTemp0),y
.862c	7a		ply				ply
.862d	60		rts				rts
.862e					_CITRNormal:
.862e	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.8630	91 36		sta ($36),y			sta 	(zTemp0),y
.8632	c8		iny				iny
.8633	ca		dex				dex
.8634	d0 f8		bne $862e			bne 	_CITRNormal
.8636	7a		ply				ply 								; and exit.
.8637	60		rts				rts
.8638					NextCommand:
.8638	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.863a	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.863c	20 08 a7	jsr $a708			jsr 	StackCheckFrame
.863f	5a		phy				phy
.8640	a0 10		ldy #$10			ldy 	#16 						; get the step count
.8642	b1 34		lda ($34),y			lda 	(basicStack),y
.8644	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.8646	30 02		bmi $864a			bmi 	_NCStepNeg
.8648	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.864a					_NCStepNeg:
.864a	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.864c	a2 04		ldx #$04			ldx 	#4 							; count to bump
.864e	18		clc				clc
.864f					_NCBump:
.864f	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8651	91 34		sta ($34),y			sta 	(basicStack),y
.8653	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8655	c8		iny				iny 								; next byte
.8656	ca		dex				dex 								; do four times
.8657	d0 f6		bne $864f			bne 	_NCBump
.8659	20 fe 85	jsr $85fe			jsr		CopyIndexToReference		; copy it to the reference variable.
.865c	a0 10		ldy #$10			ldy 	#16 						; get step count again
.865e	b1 34		lda ($34),y			lda 	(basicStack),y
.8660	0a		asl a				asl 	a 							; sign bit to carry
.8661	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8663	85 38		sta $38				sta 	zTemp1
.8665	90 02		bcc $8669			bcc 	_NCCompRev 					; use if step is +ve
.8667	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8669					_NCCompRev:
.8669	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.866b	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.866d	85 39		sta $39				sta 	zTemp1+1
.866f	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8671	38		sec				sec
.8672					_NCCompare:
.8672	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8674	b1 34		lda ($34),y			lda 	(basicStack),y
.8676	a4 39		ldy $39				ldy 	zTemp1+1
.8678	f1 34		sbc ($34),y			sbc 	(basicStack),y
.867a	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.867c	e6 39		inc $39				inc 	zTemp1+1
.867e	ca		dex				dex 								; do it 4 times.
.867f	d0 f1		bne $8672			bne 	_NCCompare
.8681	50 02		bvc $8685			bvc 	_NCNoOverflow 				; convert to signed comparison
.8683	49 80		eor #$80			eor 	#$80
.8685					_NCNoOverflow:
.8685	7a		ply				ply 								; restore Y position
.8686	0a		asl a				asl 	a 							; is bit 7 set.
.8687	90 04		bcc $868d			bcc 	_NCLoopback 				; if no , >= so loop back
.8689	20 fa a6	jsr $a6fa			jsr 	StackClose 					; exit the loop
.868c	60		rts				rts
.868d					_NCLoopBack:
.868d	20 31 a7	jsr $a731			jsr 	STKLoadCodePosition 		; loop back
.8690	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8691					Command_GOSUB:
.8691	a2 00		ldx #$00			ldx 	#0
.8693	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8696	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8698	20 db a6	jsr $a6db			jsr 	StackOpen 					; create frame
.869b	20 20 a7	jsr $a720			jsr 	STKSaveCodePosition 		; save current position
.869e	4c b4 86	jmp $86b4			jmp 	GotoStackX
.86a1					Command_RETURN:
.86a1	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.86a3	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.86a5	20 08 a7	jsr $a708			jsr 	StackCheckFrame
.86a8	20 31 a7	jsr $a731			jsr 	STKLoadCodePosition 		; restore code position
.86ab	20 fa a6	jsr $a6fa			jsr 	StackClose
.86ae	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.86af					GotoCommand:
.86af	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.86b1	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger
.86b4					GotoStackX:
.86b4	b5 60		lda $60,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.86b6	48		pha				pha 								; it is slightly inefficient, just in cases.
.86b7	b5 58		lda $58,x			lda 	NSMantissa0,x
.86b9	fa		plx				plx
.86ba	20 b5 a5	jsr $a5b5			jsr 	MemorySearch 				; transfer to line number AX.
.86bd	90 05		bcc $86c4			bcc 	_GotoError 					; not found, off end.
.86bf	d0 03		bne $86c4			bne 	_GotoError 					; not found exactly
.86c1	4c 42 8b	jmp $8b42			jmp 	RunNewLine 					; and go straight to new line code.
.86c4					_GotoError:
.86c4	a9 0d		lda #$0d		lda	#13
.86c6	4c 26 8f	jmp $8f26		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.86c9					IfCommand:
.86c9	a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.86cb	20 96 9d	jsr $9d96			jsr 	EvaluateNumber
.86ce	b1 30		lda ($30),y			lda 	(codePtr),y
.86d0	c9 aa		cmp #$aa			cmp 	#KWD_THEN  					; could be THEN <stuff>
.86d2	d0 0a		bne $86de			bne 	_IFStructured 				; we still support it.
.86d4	c8		iny				iny 								; consume THEN
.86d5	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; is it zero
.86d8	f0 01		beq $86db			beq 	_IfFail 					; if fail, go to next line
.86da	60		rts				rts 								; if THEN just continue
.86db					_IfFail:
.86db	4c 2a 8b	jmp $8b2a			jmp 	EOLCommand
.86de					_IfStructured:
.86de	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; is it zero
.86e1	d0 07		bne $86ea			bne 	_IfExit 					; if not, then continue normally.
.86e3	a9 b8		lda #$b8			lda 	#KWD_ELSE 					; look for else/endif
.86e5	a2 a7		ldx #$a7			ldx 	#KWD_ENDIF
.86e7	20 05 8e	jsr $8e05			jsr 	ScanForward 				; and run from there
.86ea					_IfExit:
.86ea	60		rts				rts
.86eb					ElseCode:
.86eb	a9 a7		lda #$a7			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.86ed	aa		tax				tax 								; so just go to the structure exit
.86ee	20 05 8e	jsr $8e05			jsr 	ScanForward
.86f1	60		rts				rts
.86f2					EndIf:
.86f2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.86f3					Command_Input:
.86f3	a9 ff		lda #$ff			lda 	#$FF 						; set input flag
.86f5	8d 28 04	sta $0428			sta 	IsInputFlag
.86f8	80 03		bra $86fd			bra 	Command_IP_Main
.86fa					Command_Print:
.86fa	9c 28 04	stz $0428			stz 	IsInputFlag 				; clear input flag
.86fd					Command_IP_Main:
.86fd	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86fe					_CPLoop:
.86fe	08		php				php 								; save last action flag
.86ff	b1 30		lda ($30),y			lda 	(codePtr),y
.8701	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8703	f0 54		beq $8759			beq 	_CPExit
.8705	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8707	f0 50		beq $8759			beq 	_CPExit
.8709	68		pla				pla 								; throw last action flag
.870a	b1 30		lda ($30),y			lda 	(codePtr),y
.870c	c8		iny				iny
.870d	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.870f	f0 45		beq $8756			beq 	_CPContinueWithSameLine
.8711	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8713	f0 3c		beq $8751			beq 	_CPTab
.8715	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8717	f0 34		beq $874d			beq 	_CPNewLine
.8719	88		dey				dey 								; undo the get.
.871a	20 28 94	jsr $9428			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.871d	b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.871f	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.8721	f0 0d		beq $8730			beq 	_CPIsValue 					; no, display it.
.8723	ad 28 04	lda $0428			lda 	IsInputFlag 				; if print, dereference and print.
.8726	f0 05		beq $872d			beq 	_CPIsPrint 					; otherwise display.
.8728	20 62 87	jsr $8762			jsr 	CIInputValue 				; input a value to the reference
.872b	80 20		bra $874d			bra 	_CPNewLine
.872d					_CPIsPrint:
.872d	20 ed 96	jsr $96ed			jsr 	Dereference 				; dereference if required.
.8730					_CPIsValue:
.8730	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.8732	29 10		and #$10			and 	#NSBIsString
.8734	f0 09		beq $873f			beq 	_CPNumber
.8736	a6 60		ldx $60				ldx 	NSMantissa1 				; string, print the text.
.8738	a5 58		lda $58				lda 	NSMantissa0
.873a	20 c5 87	jsr $87c5			jsr 	CPPrintStringXA
.873d	80 be		bra $86fd			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.873f					_CPNumber:
.873f	a9 05		lda #$05			lda 	#5 							; maximum decimals
.8741	20 7d 9c	jsr $9c7d			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.8744	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.8746	a9 49		lda #$49			lda 	#DecimalBuffer & $FF
.8748	20 c5 87	jsr $87c5			jsr 	CPPrintStringXA 			; print it.
.874b	80 b0		bra $86fd			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.874d					_CPNewLine:
.874d	a9 0d		lda #$0d			lda 	#13
.874f	80 02		bra $8753			bra 	_CPPrintChar
.8751					_CPTab:
.8751	a9 09		lda #$09			lda 	#9 							; print TAB
.8753					_CPPrintChar:
.8753	20 d8 87	jsr $87d8			jsr 	CPPrintVector
.8756					_CPContinueWithSameLine:
.8756	38		sec				sec 								; loop round with carry set, which
.8757	80 a5		bra $86fe			bra 	_CPLoop 					; will inhibit final CR
.8759					_CPExit:
.8759	28		plp				plp 								; get last action flag
.875a	b0 05		bcs $8761			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.875c	a9 0d		lda #$0d			lda 	#13 						; print new line
.875e	20 d8 87	jsr $87d8			jsr 	CPPrintVector
.8761					_CPExit2:
.8761	60		rts				rts
.8762					CIInputValue:
.8762	a2 00		ldx #$00			ldx 	#0 							; input a line.
.8764					_CIInputLine:
.8764	20 db 87	jsr $87db			jsr 	CPInputVector 				; get key
.8767	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8769	f0 1f		beq $878a			beq 	_CIHaveValue
.876b	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.876d	f0 11		beq $8780			beq 	_CIBackspace
.876f	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8771	90 f1		bcc $8764			bcc 	_CIInputLine
.8773	e0 50		cpx #$50			cpx 	#80 						; max length
.8775	b0 ed		bcs $8764			bcs 	_CIInputLine
.8777	9d 2a 05	sta $052a,x			sta 	lineBuffer,x
.877a	e8		inx				inx
.877b	20 d8 87	jsr $87d8			jsr 	CPPrintVector 				; echo it.
.877e	80 e4		bra $8764			bra 	_CIInputLine
.8780					_CIBackSpace:
.8780	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8782	f0 e0		beq $8764			beq 	_CIInputLine
.8784	20 d8 87	jsr $87d8			jsr 	CPPrintVector 				; echo it.
.8787	ca		dex				dex
.8788	80 da		bra $8764			bra 	_CIInputLine
.878a					_CIHaveValue:
.878a	9e 2a 05	stz $052a,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.878d	a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.878f	29 10		and #$10			and 	#NSBIsString
.8791	f0 17		beq $87aa			beq 	_CIAssignNumber 			; assign a number
.8793	a2 01		ldx #$01			ldx 	#1
.8795	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.8797	95 58		sta $58,x			sta 	NSMantissa0,x
.8799	a9 05		lda #$05			lda 	#lineBuffer >> 8
.879b	95 60		sta $60,x			sta 	NSMantissa1,x
.879d	74 68		stz $68,x			stz 	NSMantissa2,x
.879f	74 70		stz $70,x			stz 	NSMantissa3,x
.87a1	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.87a3	95 50		sta $50,x			sta  	NSStatus,x
.87a5	ca		dex				dex 								; X = 0
.87a6	20 17 88	jsr $8817			jsr 	AssignVariable
.87a9	60		rts				rts
.87aa					_CIAssignNumber:
.87aa	a9 2a		lda #$2a			lda 	#lineBuffer & $FF 			; set up to point to new string
.87ac	85 36		sta $36				sta 	zTemp0
.87ae	a9 05		lda #$05			lda 	#lineBuffer >> 8
.87b0	85 37		sta $37				sta 	zTemp0+1
.87b2	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.87b4	20 ff 9b	jsr $9bff			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.87b7	90 07		bcc $87c0			bcc 	_CIIsOkay
.87b9	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.87bb	20 d8 87	jsr $87d8			jsr 	CPPrintVector
.87be	80 a2		bra $8762			bra 	CIInputValue
.87c0					_CIIsOkay:
.87c0	ca		dex				dex 								; X = 0
.87c1	20 17 88	jsr $8817			jsr 	AssignVariable
.87c4	60		rts				rts
.87c5					CPPrintStringXA:
.87c5	5a		phy				phy
.87c6	86 37		stx $37				stx 	zTemp0+1
.87c8	85 36		sta $36				sta 	zTemp0
.87ca	a0 00		ldy #$00			ldy 	#0
.87cc					_PSXALoop:
.87cc	b1 36		lda ($36),y			lda 	(zTemp0),y
.87ce	f0 06		beq $87d6			beq 	_PSXAExit
.87d0	20 d8 87	jsr $87d8			jsr 	CPPrintVector
.87d3	c8		iny				iny
.87d4	80 f6		bra $87cc			bra 	_PSXALoop
.87d6					_PSXAExit:
.87d6	7a		ply				ply
.87d7	60		rts				rts
.87d8					CPPrintVector:
.87d8	4c 03 80	jmp $8003			jmp 	EXTPrintCharacter
.87db					CPInputVector:
.87db	4c 09 80	jmp $8009			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.87de					LetCommand:
.87de	a2 00		ldx #$00			ldx 	#0
.87e0	b1 30		lda ($30),y			lda 	(codePtr),y
.87e2	c9 10		cmp #$10			cmp 	#KWD_AT
.87e4	d0 14		bne $87fa			bne 	_LCStandard
.87e6	c8		iny				iny 								; skip equal
.87e7	20 74 98	jsr $9874			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.87ea	20 ed 96	jsr $96ed			jsr 	Dereference 				; dereference it to a value
.87ed	b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.87ef	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.87f1	95 50		sta $50,x			sta 	NSStatus,x
.87f3	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.87f5	d0 0f		bne $8806			bne 	_LCMain
.87f7	4c d0 9f	jmp $9fd0			jmp 	TypeError 					; was a reference before.
.87fa					_LCStandard:
.87fa	ad 12 94	lda $9412			lda 	PrecedenceLevel+"*"			; precedence > this
.87fd	20 2c 94	jsr $942c			jsr 	EvaluateExpressionAtPrecedence
.8800	b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.8802	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.8804	f0 0e		beq $8814			beq 	_LetGoProc 					; it's a procedure call.
.8806					_LCMain:
.8806	a9 3d		lda #$3d			lda 	#"=" 						; check =
.8808	20 1d 8f	jsr $8f1d			jsr 	CheckNextA
.880b	e8		inx				inx 								; RHS
.880c	20 8d 9d	jsr $9d8d			jsr 	EvaluateValue
.880f	ca		dex				dex
.8810	20 17 88	jsr $8817			jsr 	AssignVariable
.8813	60		rts				rts
.8814					_LetGoProc:
.8814	4c 00 8a	jmp $8a00			jmp 	CallProcedure
.8817					AssignVariable:
.8817	b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8819	48		pha				pha 								; save a copy
.881a	55 51		eor $51,x			eor 	NSStatus+1,x
.881c	29 10		and #$10			and 	#NSBIsString
.881e	d0 0b		bne $882b			bne 	_ASError
.8820	68		pla				pla 								; get back
.8821	29 10		and #$10			and 	#NSBIsString 				; check type
.8823	d0 03		bne $8828			bne 	_ASString
.8825	4c 2b 96	jmp $962b			jmp 	AssignNumber
.8828					_ASString:
.8828	4c 89 96	jmp $9689			jmp 	AssignString
.882b					_ASError:
.882b	4c d0 9f	jmp $9fd0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.882e					Command_List:
.882e	9c 26 04	stz $0426			stz 	listIndent 					; reset indent.
.8831	b1 30		lda ($30),y			lda 	(codePtr),y
.8833	29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.8835	c9 40		cmp #$40			cmp 	#$40  						; of code.
.8837	f0 6e		beq $88a7			beq 	_CLListProcedure
.8839	64 5c		stz $5c				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.883b	64 64		stz $64				stz 	NSMantissa1+4 				; these are the default top and bottom.
.883d	a9 ff		lda #$ff			lda 	#$FF
.883f	85 5f		sta $5f				sta 	NSMantissa0+7
.8841	85 67		sta $67				sta 	NSMantissa1+7
.8843	b1 30		lda ($30),y			lda 	(codePtr),y
.8845	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8847	f0 1a		beq $8863			beq 	_CLSecond
.8849	20 24 89	jsr $8924			jsr 	CLIsDigit 					; if not digit, list all
.884c	b0 20		bcs $886e			bcs 	_CLStart
.884e	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8850	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger
.8853	b1 30		lda ($30),y			lda 	(codePtr),y
.8855	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8857	f0 0a		beq $8863			beq 	_CLSecond 					; if so go get it
.8859	a5 5c		lda $5c				lda 	NSMantissa0+4 				; copy 4->7
.885b	85 5f		sta $5f				sta 	NSMantissa0+7
.885d	a5 64		lda $64				lda 	NSMantissa1+4
.885f	85 67		sta $67				sta 	NSMantissa1+7
.8861	80 0b		bra $886e			bra 	_CLStart
.8863					_CLSecond:
.8863	c8		iny				iny 								; consume comma
.8864	20 24 89	jsr $8924			jsr 	CLIsDigit 					; digit found
.8867	b0 05		bcs $886e			bcs 	_CLStart 					; if not, continue listing
.8869	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.886b	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger
.886e					_CLStart
.886e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8870	85 30		sta $30				sta 	codePtr
.8872	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8874	85 31		sta $31				sta 	codePtr+1
.8876					_CLLoop:
.8876	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check here, as we want the option of breaking out of long lists.
.8879	f0 27		beq $88a2			beq 	_CLBreak
.887b	b2 30		lda ($30)			lda 	(codePtr)
.887d	f0 20		beq $889f			beq 	_CLExit
.887f	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8881	20 13 89	jsr $8913			jsr 	CLCompareLineNo
.8884	90 0c		bcc $8892			bcc 	_CLNext
.8886	a2 07		ldx #$07			ldx 	#7
.8888	20 13 89	jsr $8913			jsr 	CLCompareLineNo
.888b	f0 02		beq $888f			beq 	_CLDoThisOne
.888d	b0 03		bcs $8892			bcs 	_CLNext
.888f					_CLDoThisOne:
.888f	20 00 89	jsr $8900			jsr 	CLListOneLine 				; routine to list the current line.
.8892					_CLNext:
.8892	18		clc				clc
.8893	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8895	65 30		adc $30				adc 	codePtr
.8897	85 30		sta $30				sta 	codePtr
.8899	90 02		bcc $889d			bcc 	_CREExit
.889b	e6 31		inc $31				inc 	codePtr+1 					; carry
.889d					_CREExit:
.889d	80 d7		bra $8876			bra 	_CLLoop
.889f					_CLExit:
.889f	4c 9f 83	jmp $839f			jmp 	WarmStart
.88a2					_CLBreak:
.88a2	a9 01		lda #$01		lda	#1
.88a4	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.88a7					_CLListProcedure:
.88a7	b1 30		lda ($30),y			lda 	(codePtr),y
.88a9	85 38		sta $38				sta 	zTemp1
.88ab	c8		iny				iny
.88ac	b1 30		lda ($30),y			lda 	(codePtr),y
.88ae	85 39		sta $39				sta 	zTemp1+1
.88b0	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.88b2	85 30		sta $30				sta 	codePtr
.88b4	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.88b6	85 31		sta $31				sta 	codePtr+1
.88b8					_CLLPSearch:
.88b8	b2 30		lda ($30)			lda 	(codePtr)
.88ba	c9 00		cmp #$00			cmp 	#0 							; if zero, end
.88bc	f0 e1		beq $889f			beq 	_CLExit
.88be	a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.88c0	b1 30		lda ($30),y			lda 	(codePtr),y
.88c2	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.88c4	d0 0e		bne $88d4			bne 	_CLLPNext
.88c6	c8		iny				iny 								; check if PROC this.
.88c7	b1 30		lda ($30),y			lda 	(codePtr),y
.88c9	c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.88cb	d0 07		bne $88d4			bne 	_CLLPNext
.88cd	c8		iny				iny
.88ce	b1 30		lda ($30),y			lda 	(codePtr),y
.88d0	c5 39		cmp $39				cmp 	zTemp1+1
.88d2	f0 0d		beq $88e1			beq 	_CLLPFound
.88d4					_CLLPNext:
.88d4	18		clc				clc
.88d5	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88d7	65 30		adc $30				adc 	codePtr
.88d9	85 30		sta $30				sta 	codePtr
.88db	90 02		bcc $88df			bcc 	_CREExit
.88dd	e6 31		inc $31				inc 	codePtr+1 					; carry
.88df					_CREExit:
.88df	80 d7		bra $88b8			bra 	_CLLPSearch
.88e1					_CLLPFound:
.88e1	b2 30		lda ($30)			lda 	(codePtr)
.88e3	f0 ba		beq $889f			beq 	_CLExit
.88e5	a0 03		ldy #$03			ldy 	#3 							; get first keyword
.88e7	b1 30		lda ($30),y			lda 	(codePtr),y
.88e9	48		pha				pha
.88ea	20 00 89	jsr $8900			jsr 	CLListOneLine 				; list line and go forward
.88ed	18		clc				clc
.88ee	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.88f0	65 30		adc $30				adc 	codePtr
.88f2	85 30		sta $30				sta 	codePtr
.88f4	90 02		bcc $88f8			bcc 	_CREExit
.88f6	e6 31		inc $31				inc 	codePtr+1 					; carry
.88f8					_CREExit:
.88f8	68		pla				pla 								; reached ENDPROC ?
.88f9	c9 a8		cmp #$a8			cmp 	#KWD_ENDPROC
.88fb	d0 e4		bne $88e1			bne 	_CLLPFound
.88fd	4c 9f 83	jmp $839f			jmp 	WarmStart
.8900					CLListOneLine:
.8900	20 68 8e	jsr $8e68			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8903	20 1e 80	jsr $801e			jsr 	TKListConvertLine 			; convert line into token Buffer
.8906	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8908	a9 2d		lda #$2d			lda 	#(tokenBuffer & $FF)
.890a	20 7f 8f	jsr $8f7f			jsr 	PrintStringXA
.890d	a9 0d		lda #$0d			lda 	#13 						; new line
.890f	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8912	60		rts				rts
.8913					CLCompareLineNo:
.8913	38		sec				sec
.8914	a0 01		ldy #$01			ldy 	#1
.8916	b1 30		lda ($30),y			lda 	(codePtr),y
.8918	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.891a	85 36		sta $36				sta 	zTemp0
.891c	c8		iny				iny
.891d	b1 30		lda ($30),y			lda 	(codePtr),y
.891f	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.8921	05 36		ora $36				ora 	zTemp0
.8923	60		rts				rts
.8924					CLIsDigit:
.8924	b1 30		lda ($30),y			lda 	(codePtr),y
.8926	c9 30		cmp #$30			cmp 	#"0"
.8928	90 03		bcc $892d			bcc	 	_CLIDExitFalse
.892a	c9 3a		cmp #$3a			cmp 	#"9"+1
.892c	60		rts				rts
.892d					_CLIDExitFalse:
.892d	38		sec				sec
.892e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.892f					Command_LOCAL:
.892f	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8931	20 3d 89	jsr $893d			jsr 	LocaliseNextTerm 			; convert term to a local.
.8934	b1 30		lda ($30),y			lda 	(codePtr),y
.8936	c8		iny				iny
.8937	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8939	f0 f4		beq $892f			beq 	Command_LOCAL 				; if so, localise another variable.
.893b	88		dey				dey 								; unpick pre-get
.893c	60		rts				rts
.893d					LocaliseNextTerm:
.893d	20 74 98	jsr $9874			jsr 	EvaluateTerm 				; evaluate the term
.8940	b5 50		lda $50,x			lda 	NSStatus,x
.8942	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.8944	f0 5c		beq $89a2			beq		_LNTError
.8946	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8948	85 36		sta $36				sta 	zTemp0
.894a	b5 60		lda $60,x			lda 	NSMantissa1,x
.894c	85 37		sta $37				sta  	zTemp0+1
.894e	b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.8950	29 10		and #$10			and 	#NSBIsString
.8952	d0 1e		bne $8972			bne 	_LNTPushString
.8954	5a		phy				phy
.8955	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.8957					_LNTPushNumLoop:
.8957	b1 36		lda ($36),y			lda		(zTemp0),y
.8959	20 ba a6	jsr $a6ba			jsr 	StackPushByte
.895c	c8		iny				iny
.895d	c0 05		cpy #$05			cpy 	#5
.895f	d0 f6		bne $8957			bne 	_LNTPushNumLoop
.8961	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.8963	20 ba a6	jsr $a6ba			jsr 	StackPushByte
.8966	a5 37		lda $37				lda 	zTemp0+1
.8968	20 ba a6	jsr $a6ba			jsr 	StackPushByte
.896b	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.896d	20 ba a6	jsr $a6ba			jsr 	StackPushByte
.8970	7a		ply				ply
.8971	60		rts				rts
.8972					_LNTPushString:
.8972	5a		phy				phy
.8973	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.8975	85 38		sta $38				sta 	zTemp1
.8977	a0 01		ldy #$01			ldy 	#1
.8979	b1 36		lda ($36),y			lda 	(zTemp0),y
.897b	85 39		sta $39				sta 	zTemp1+1
.897d	a0 00		ldy #$00			ldy 	#0 							; output string
.897f	c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.8981	f0 0a		beq $898d			beq 	_LNTStringOut
.8983					_LNTPushStrLoop:
.8983	b1 38		lda ($38),y			lda 	(zTemp1),y
.8985	f0 06		beq $898d			beq 	_LNTStringOut
.8987	20 ba a6	jsr $a6ba			jsr 	StackPushByte
.898a	c8		iny				iny
.898b	80 f6		bra $8983			bra 	_LNTPushStrLoop
.898d					_LNTStringOut:
.898d	98		tya				tya									; output length (chars written).
.898e	20 ba a6	jsr $a6ba			jsr 	StackPushByte
.8991	b5 58		lda $58,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.8993	20 ba a6	jsr $a6ba			jsr 	StackPushByte
.8996	b5 60		lda $60,x			lda 	NSMantissa1,x
.8998	20 ba a6	jsr $a6ba			jsr 	StackPushByte
.899b	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.899d	20 ba a6	jsr $a6ba			jsr 	StackPushByte
.89a0	7a		ply				ply
.89a1	60		rts				rts
.89a2					_LNTError:
.89a2	4c c6 9f	jmp $9fc6			jmp 	SyntaxError
.89a5					LocalPopValue:
.89a5	20 d2 a6	jsr $a6d2			jsr 	StackPopByte
.89a8	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.89aa	d0 17		bne $89c3			bne 	_LPVString
.89ac	20 d2 a6	jsr $a6d2			jsr 	StackPopByte 				; address
.89af	85 37		sta $37				sta 	zTemp0+1
.89b1	20 d2 a6	jsr $a6d2			jsr 	StackPopByte
.89b4	85 36		sta $36				sta 	zTemp0
.89b6	5a		phy				phy
.89b7	a0 04		ldy #$04			ldy 	#4 							; copy back
.89b9					_LPVNumberCopy:
.89b9	20 d2 a6	jsr $a6d2			jsr 	StackPopByte
.89bc	91 36		sta ($36),y			sta 	(zTemp0),y
.89be	88		dey				dey
.89bf	10 f8		bpl $89b9			bpl 	_LPVNumberCopy
.89c1	7a		ply				ply 								; and complete
.89c2	60		rts				rts
.89c3					_LPVString:
.89c3	20 d2 a6	jsr $a6d2			jsr 	StackPopByte 				; address of record copied to zTemp0
.89c6	85 37		sta $37				sta 	zTemp0+1
.89c8	20 d2 a6	jsr $a6d2			jsr 	StackPopByte
.89cb	85 36		sta $36				sta 	zTemp0
.89cd	5a		phy				phy
.89ce	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.89d0	85 38		sta $38				sta 	zTemp1
.89d2	a0 01		ldy #$01			ldy 	#1
.89d4	b1 36		lda ($36),y			lda 	(zTemp0),y
.89d6	85 39		sta $39				sta 	zTemp1+1
.89d8	20 d2 a6	jsr $a6d2			jsr 	StackPopByte 				; # chars to get => y
.89db	a8		tay				tay
.89dc	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.89de	f0 0e		beq $89ee			beq 	_LPVStringCopied
.89e0	a9 00		lda #$00			lda 	#0 							; NULL on end
.89e2	91 38		sta ($38),y			sta 	(zTemp1),y
.89e4					_LPVStringCopy:
.89e4	88		dey				dey
.89e5	30 07		bmi $89ee			bmi 	_LPVStringCopied
.89e7	20 d2 a6	jsr $a6d2			jsr 	StackPopByte
.89ea	91 38		sta ($38),y			sta 	(zTemp1),y
.89ec	80 f6		bra $89e4			bra 	_LPVStringCopy
.89ee					_LPVStringCopied:
.89ee	fa		plx				plx
.89ef	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.89f0					NewCommand:
.89f0	20 f6 89	jsr $89f6			jsr 	NewProgram 					; does the actual NEW.
.89f3	4c 9f 83	jmp $839f			jmp 	WarmStart 					; and warm starts straight away.
.89f6					NewProgram:
.89f6	20 97 a5	jsr $a597			jsr 	MemoryNew
.89f9	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.89fc	20 35 84	jsr $8435			jsr 	ClearCommand 				; clear everything.
.89ff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8a00					CallProcedure:
.8a00	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8a02	b1 30		lda ($30),y			lda 	(codePtr),y
.8a04	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8a06	f0 0c		beq $8a14			beq 	_CPEndParam
.8a08					_CPParamLoop:
.8a08	20 8d 9d	jsr $9d8d			jsr 	EvaluateValue 				; get parameter onto stack
.8a0b	e8		inx				inx 								; bump next stack
.8a0c	b1 30		lda ($30),y			lda 	(codePtr),y
.8a0e	c8		iny				iny
.8a0f	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8a11	f0 f5		beq $8a08			beq 	_CPParamLoop
.8a13	88		dey				dey 								; unpick.
.8a14					_CPEndParam:
.8a14	8e 16 04	stx $0416			stx 	LastParameter 				; save the last parameters index.
.8a17	c8		iny				iny									; skip right bracket
.8a18	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8a1a	20 db a6	jsr $a6db			jsr 	StackOpen
.8a1d	20 20 a7	jsr $a720			jsr 	STKSaveCodePosition 		; save loop position
.8a20	a5 58		lda $58				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8a22	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8a24	a5 60		lda $60				lda 	NSMantissa1
.8a26	85 37		sta $37				sta 	zTemp0+1
.8a28	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8a2a	b2 36		lda ($36)			lda 	(zTemp0)
.8a2c	85 30		sta $30				sta 	safePtr
.8a2e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a30	85 31		sta $31				sta 	safePtr+1
.8a32	c8		iny				iny
.8a33	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a35	85 32		sta $32				sta 	safePtr+2
.8a37	c8		iny				iny
.8a38	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a3a	85 33		sta $33				sta 	safePtr+3
.8a3c	c8		iny				iny 								; get Y offset -> Y
.8a3d	b1 36		lda ($36),y			lda 	(zTemp0),y
.8a3f	a8		tay				tay
.8a40	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8a42	ec 16 04	cpx $0416			cpx	 	LastParameter 				; check zero parameters at the start
.8a45	f0 13		beq $8a5a			beq 	_ParamExit 					; if so, exit.
.8a47					_ParamExtract:
.8a47	ca		dex				dex 								; put a local term on the level before
.8a48	20 3d 89	jsr $893d			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8a4b	20 17 88	jsr $8817			jsr 	AssignVariable 				; assign stacked value to the variable.
.8a4e	e8		inx				inx 								; advance to next parameter to do.
.8a4f	e8		inx				inx
.8a50	ec 16 04	cpx $0416			cpx 	LastParameter 				; are we done ?
.8a53	f0 05		beq $8a5a			beq 	_ParamExit
.8a55	20 15 8f	jsr $8f15			jsr 	CheckComma 					; comma seperating parameters
.8a58	80 ed		bra $8a47			bra 	_ParamExtract
.8a5a					_ParamExit:
.8a5a	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket 			; check )
.8a5d	60		rts				rts 								; and continue from here
.8a5e					Command_ENDPROC:
.8a5e	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.8a60	a2 14		ldx #$14			ldx 	#ERRID_PROC
.8a62	20 08 a7	jsr $a708			jsr 	StackCheckFrame
.8a65	20 31 a7	jsr $a731			jsr 	STKLoadCodePosition 		; restore code position
.8a68	20 fa a6	jsr $a6fa			jsr 	StackClose
.8a6b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.8a6c					Command_Read:
.8a6c	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.8a6e	20 74 98	jsr $9874			jsr 	EvaluateTerm
.8a71	b5 50		lda $50,x			lda 	NSStatus,x
.8a73	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.8a75	f0 4f		beq $8ac6			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.8a77	20 0f 8b	jsr $8b0f			jsr 	SwapDataCodePtrs 			; swap code and data
.8a7a	ad 1c 04	lda $041c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.8a7d	d0 25		bne $8aa4			bne 	_CRContinueData  			; forward for the next one.
.8a7f	b2 30		lda ($30)			lda 	(codePtr)
.8a81	f0 1c		beq $8a9f			beq 	_CRNoData
.8a83					_CRKeepSearching:
.8a83	a9 b4		lda #$b4			lda 	#KWD_DATA 					; scan for instruction
.8a85	a2 80		ldx #$80			ldx 	#KWC_EOL
.8a87	20 05 8e	jsr $8e05			jsr 	ScanForward
.8a8a	c9 b4		cmp #$b4			cmp 	#KWD_DATA 					; found data ?
.8a8c	f0 16		beq $8aa4			beq 	_CRHaveData 				; found it
.8a8e	18		clc				clc
.8a8f	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a91	65 30		adc $30				adc 	codePtr
.8a93	85 30		sta $30				sta 	codePtr
.8a95	90 02		bcc $8a99			bcc 	_CREExit
.8a97	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a99					_CREExit:
.8a99	a0 03		ldy #$03			ldy 	#3 							; start of line.
.8a9b	b2 30		lda ($30)			lda 	(codePtr)
.8a9d	d0 e4		bne $8a83			bne 	_CRKeepSearching
.8a9f					_CRNoData:
.8a9f	a9 0b		lda #$0b		lda	#11
.8aa1	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.8aa4					_CRHaveData:
.8aa4					_CRContinueData:
.8aa4	a2 01		ldx #$01			ldx 	#1
.8aa6	20 8d 9d	jsr $9d8d			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8aa9	ca		dex				dex
.8aaa	20 17 88	jsr $8817			jsr		AssignVariable 				; do the assignment
.8aad	9c 1c 04	stz $041c			stz 	inDataStatement 			; clear in data flag
.8ab0	b1 30		lda ($30),y			lda 	(codePtr),y
.8ab2	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.8ab4	d0 04		bne $8aba			bne 	_CRSwapBack
.8ab6	c8		iny				iny 								; consume comma
.8ab7	ee 1c 04	inc $041c			inc 	inDataStatement 			; set in data statement currently.
.8aba					_CRSwapBack:
.8aba	20 0f 8b	jsr $8b0f			jsr 	SwapDataCodePtrs			; swap them back.
.8abd	b1 30		lda ($30),y			lda 	(codePtr),y
.8abf	c8		iny				iny
.8ac0	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8ac2	f0 a8		beq $8a6c			beq 	Command_Read 				; if so go round again.
.8ac4	88		dey				dey 								; unpick get.
.8ac5	60		rts				rts
.8ac6					_CRSyntax:
.8ac6	4c c6 9f	jmp $9fc6			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8ac9					RemCommand:
.8ac9	b1 30		lda ($30),y			lda 	(codePtr),y
.8acb	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8acd	d0 06		bne $8ad5			bne 	_RMExit
.8acf	c8		iny				iny 								; point to offset
.8ad0	98		tya				tya 								; A = offset position
.8ad1	38		sec				sec 								; add size +1 hence SEC
.8ad2	71 30		adc ($30),y			adc 	(codePtr),y
.8ad4	a8		tay				tay 								; make current position.
.8ad5					_RMExit:
.8ad5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8ad6					Command_REPEAT:
.8ad6	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8ad8	20 db a6	jsr $a6db			jsr 	StackOpen
.8adb	20 20 a7	jsr $a720			jsr 	STKSaveCodePosition 		; save loop position
.8ade	60		rts				rts
.8adf					Command_UNTIL:
.8adf	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8ae1	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8ae3	20 08 a7	jsr $a708			jsr 	StackCheckFrame
.8ae6	a2 00		ldx #$00			ldx 	#0
.8ae8	20 96 9d	jsr $9d96			jsr 	EvaluateNumber 				; work out the number
.8aeb	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; check if zero
.8aee	f0 04		beq $8af4			beq 	_CULoopBack 				; if so keep looping
.8af0	20 fa a6	jsr $a6fa			jsr 	StackClose		 			; return
.8af3	60		rts				rts
.8af4					_CULoopBack:
.8af4	20 31 a7	jsr $a731			jsr 	STKLoadCodePosition 		; loop back
.8af7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8af8					Command_Restore:
.8af8	20 0f 8b	jsr $8b0f			jsr 	SwapDataCodePtrs 			; swap code and data
.8afb	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8afd	85 30		sta $30				sta 	codePtr
.8aff	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b01	85 31		sta $31				sta 	codePtr+1
.8b03	20 0f 8b	jsr $8b0f			jsr 	SwapDataCodePtrs 			; put them back
.8b06	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8b08	8d 1b 04	sta $041b			sta 	dataPointer+4   			; (read checks not EOF)
.8b0b	9c 1c 04	stz $041c			stz 	inDataStatement 			; not in data statement
.8b0e	60		rts				rts
.8b0f					SwapDataCodePtrs:
.8b0f	da		phx				phx
.8b10	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8b12					_SDCPLoop:
.8b12	b5 30		lda $30,x			lda 	safePtr,x
.8b14	48		pha				pha
.8b15	bd 17 04	lda $0417,x			lda 	dataPointer,x
.8b18	95 30		sta $30,x			sta 	safePtr,x
.8b1a	68		pla				pla
.8b1b	9d 17 04	sta $0417,x			sta 	dataPointer,x
.8b1e	ca		dex				dex
.8b1f	10 f1		bpl $8b12			bpl 	_SDCPLoop
.8b21	ad 1b 04	lda $041b			lda 	dataPointer+4 				; swap Y position over.
.8b24	8c 1b 04	sty $041b			sty 	dataPointer+4
.8b27	a8		tay				tay
.8b28	fa		plx				plx
.8b29	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8b2a					EOLCommand:
.8b2a	18		clc				clc
.8b2b	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8b2d	65 30		adc $30				adc 	codePtr
.8b2f	85 30		sta $30				sta 	codePtr
.8b31	90 02		bcc $8b35			bcc 	_CREExit
.8b33	e6 31		inc $31				inc 	codePtr+1 					; carry
.8b35					_CREExit:
.8b35	80 0b		bra $8b42			bra 	RunNewLine
.8b37					CommandRUN:
.8b37	20 35 84	jsr $8435			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8b3a	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8b3c	85 30		sta $30				sta 	codePtr
.8b3e	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8b40	85 31		sta $31				sta 	codePtr+1
.8b42					RUNNewLine:
.8b42	b2 30		lda ($30)			lda 	(codePtr)
.8b44	f0 7b		beq $8bc1			beq 	CRNoProgram         		; no then END.
.8b46	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8b48	9a		txs				txs
.8b49					RUNCodePointerLine:
.8b49	a0 02		ldy #$02			ldy 	#2 							; start of program
.8b4b					_CRIncMainLoop:
.8b4b	0e 13 04	asl $0413			asl 	breakCheck 					; clears 1 time in 8
.8b4e	d0 22		bne $8b72			bne 	_CRNoBreakCheck
.8b50	ce 13 04	dec $0413			dec	 	breakCheck 					; set it back to $FF
.8b53	20 0c 80	jsr $800c			jsr 	EXTBreakCheck 				; break check
.8b56	f0 64		beq $8bbc			beq 	_CRBreak
.8b58	a5 01		lda $01				lda 	1 							; save I/O 0
.8b5a	48		pha				pha
.8b5b	64 01		stz $01				stz 	1 							; access I/O Page 0
.8b5d	38		sec				sec 								; calculate timer - LastTick
.8b5e	ad 59 d6	lda $d659			lda 	$D659
.8b61	aa		tax				tax 								; saving timer in X
.8b62	ed 5b 06	sbc $065b			sbc 	LastTick
.8b65	c9 03		cmp #$03			cmp 	#3
.8b67	90 06		bcc $8b6f			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8b69	8e 5b 06	stx $065b			stx 	LastTick 					; update last timer
.8b6c	20 73 9e	jsr $9e73			jsr 	TickHandler 							; go do the code.
.8b6f					_NoFireTick:
.8b6f	68		pla				pla 								; restore I/O 0
.8b70	85 01		sta $01				sta 	1
.8b72					_CRNoBreakCheck:
.8b72	c8		iny				iny									; next token
.8b73					_CRMainLoop:
.8b73	9c 10 04	stz $0410			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8b76	b1 30		lda ($30),y			lda 	(codePtr),y
.8b78	10 10		bpl $8b8a			bpl 	_CRNotKeyword				; not a token.
.8b7a	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8b7c	b0 04		bcs $8b82			bcs 	_CRIsKeyword
.8b7e	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8b80	b0 34		bcs $8bb6			bcs		_CRSyntaxError
.8b82					_CRIsKeyword:
.8b82	c8		iny				iny 								; consume command
.8b83	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8b84	aa		tax				tax 								; put in X for vector jump
.8b85	20 b9 8b	jsr $8bb9			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8b88	80 e9		bra $8b73			bra 	_CRMainLoop 				; and loop round
.8b8a					_CRNotKeyword:
.8b8a	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8b8c	f0 bd		beq $8b4b			beq 	_CRIncMainLoop
.8b8e	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8b90	90 05		bcc $8b97			bcc 	_CRNotVariable
.8b92					_CRGoLet:
.8b92	20 de 87	jsr $87de			jsr 	LetCommand
.8b95	80 dc		bra $8b73			bra 	_CRMainLoop
.8b97					_CRNotVariable:
.8b97	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8b99	f0 f7		beq $8b92			beq 	_CRGoLet
.8b9b	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8b9d	f0 f3		beq $8b92			beq 	_CRGoLet
.8b9f	c9 21		cmp #$21			cmp 	#KWD_PLING
.8ba1	f0 ef		beq $8b92			beq 	_CRGoLet
.8ba3	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8ba5	f0 09		beq $8bb0			beq 	_CRGoRem
.8ba7	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8ba9	d0 0b		bne $8bb6			bne 	_CRSyntaxError
.8bab	20 20 82	jsr $8220			jsr 	LabelHere
.8bae	80 c3		bra $8b73			bra 	_CRMainLoop
.8bb0					_CRGoRem:
.8bb0	c8		iny				iny
.8bb1	20 c9 8a	jsr $8ac9			jsr 	RemCommand
.8bb4	80 bd		bra $8b73			bra 	_CRMainLoop
.8bb6					_CRSyntaxError:
.8bb6	4c c6 9f	jmp $9fc6			jmp 	SyntaxError
.8bb9					_CRCallVector0:
.8bb9	7c 58 8c	jmp ($8c58,x)			jmp 	(VectorSet0,x)
.8bbc					_CRBreak:
.8bbc	a9 01		lda #$01		lda	#1
.8bbe	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.8bc1					CRNoProgram:
.8bc1	4c 83 85	jmp $8583			jmp 	EndCommand
.8bc4					Shift1Command:
.8bc4	b1 30		lda ($30),y			lda 	(codePtr),y
.8bc6	c8		iny				iny
.8bc7	0a		asl a				asl 	a
.8bc8	aa		tax				tax
.8bc9	7c fe 8c	jmp ($8cfe,x)			jmp 	(VectorSet1,x)
.8bcc					Shift2Command:
.8bcc	b1 30		lda ($30),y			lda 	(codePtr),y
.8bce	c8		iny				iny
.8bcf	0a		asl a				asl 	a
.8bd0	aa		tax				tax
.8bd1	7c 26 8d	jmp ($8d26,x)			jmp 	(VectorSet2,x)
.8bd4					Unused1:
.8bd4					Unused2:
.8bd4					Unused3:
.8bd4					Unused4:
.8bd4	4c c6 9f	jmp $9fc6			jmp 	SyntaxError
>8bd7							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8bd8					VectorSetPunc:
>8bd8	de 91					.word	ShiftLeft                        ; $00 <<
>8bda	c9 8f					.word	BinaryCompareLessEqual           ; $01 <=
>8bdc	bf 8f					.word	BinaryCompareNotEqual            ; $02 <>
>8bde	c6 9f					.word	SyntaxError                      ; $03 !!3
>8be0	c6 9f					.word	SyntaxError                      ; $04 ><
>8be2	d3 8f					.word	BinaryCompareGreaterEqual        ; $05 >=
>8be4	e1 91					.word	ShiftRight                       ; $06 >>
>8be6	c6 9f					.word	SyntaxError                      ; $07 !!7
>8be8	c6 9f					.word	SyntaxError                      ; $08 !!8
>8bea	c6 9f					.word	SyntaxError                      ; $09 !!9
>8bec	c6 9f					.word	SyntaxError                      ; $0a !!10
>8bee	c6 9f					.word	SyntaxError                      ; $0b !!11
>8bf0	c6 9f					.word	SyntaxError                      ; $0c !!12
>8bf2	c6 9f					.word	SyntaxError                      ; $0d !!13
>8bf4	c6 9f					.word	SyntaxError                      ; $0e !!14
>8bf6	c6 9f					.word	SyntaxError                      ; $0f !!15
>8bf8	c6 9f					.word	SyntaxError                      ; $10 @
>8bfa	c6 9f					.word	SyntaxError                      ; $11 !!17
>8bfc	c6 9f					.word	SyntaxError                      ; $12 !!18
>8bfe	c6 9f					.word	SyntaxError                      ; $13 [
>8c00	8a 90					.word	IntegerDivide                    ; $14 \
>8c02	c6 9f					.word	SyntaxError                      ; $15 ]
>8c04	1c 93					.word	EorInteger                       ; $16 ^
>8c06	c6 9f					.word	SyntaxError                      ; $17 _
>8c08	c6 9f					.word	SyntaxError                      ; $18 `
>8c0a	c6 9f					.word	SyntaxError                      ; $19 !!25
>8c0c	c6 9f					.word	SyntaxError                      ; $1a !!26
>8c0e	c6 9f					.word	SyntaxError                      ; $1b {
>8c10	e7 92					.word	OraInteger                       ; $1c |
>8c12	c6 9f					.word	SyntaxError                      ; $1d }
>8c14	c6 9f					.word	SyntaxError                      ; $1e ~
>8c16	c6 9f					.word	SyntaxError                      ; $1f [7m<7F>[m
>8c18	c6 9f					.word	SyntaxError                      ; $20
>8c1a	51 93					.word	WordIndirect                     ; $21 !
>8c1c	c6 9f					.word	SyntaxError                      ; $22 "
>8c1e	c6 9f					.word	SyntaxError                      ; $23 #
>8c20	c6 9f					.word	SyntaxError                      ; $24 $
>8c22	cb 90					.word	IntegerModulus                   ; $25 %
>8c24	b2 92					.word	AndInteger                       ; $26 &
>8c26	c6 9f					.word	SyntaxError                      ; $27 '
>8c28	c6 9f					.word	SyntaxError                      ; $28 (
>8c2a	c6 9f					.word	SyntaxError                      ; $29 )
>8c2c	39 91					.word	MulInteger                       ; $2a *
>8c2e	54 92					.word	AddInteger                       ; $2b +
>8c30	c6 9f					.word	SyntaxError                      ; $2c ,
>8c32	8d 92					.word	SubInteger                       ; $2d -
>8c34	c6 9f					.word	SyntaxError                      ; $2e .
>8c36	0b 95					.word	FDivideCommand                   ; $2f /
>8c38	c6 9f					.word	SyntaxError                      ; $30 0
>8c3a	c6 9f					.word	SyntaxError                      ; $31 1
>8c3c	c6 9f					.word	SyntaxError                      ; $32 2
>8c3e	c6 9f					.word	SyntaxError                      ; $33 3
>8c40	c6 9f					.word	SyntaxError                      ; $34 4
>8c42	c6 9f					.word	SyntaxError                      ; $35 5
>8c44	c6 9f					.word	SyntaxError                      ; $36 6
>8c46	c6 9f					.word	SyntaxError                      ; $37 7
>8c48	c6 9f					.word	SyntaxError                      ; $38 8
>8c4a	c6 9f					.word	SyntaxError                      ; $39 9
>8c4c	c6 9f					.word	SyntaxError                      ; $3a :
>8c4e	c6 9f					.word	SyntaxError                      ; $3b ;
>8c50	ab 8f					.word	BinaryCompareLess                ; $3c <
>8c52	a1 8f					.word	BinaryCompareEqual               ; $3d =
>8c54	b5 8f					.word	BinaryCompareGreater             ; $3e >
>8c56	73 93					.word	ByteIndirect                     ; $3f ?
.8c58					VectorSet0:
>8c58	2a 8b					.word	EOLCommand                       ; $80 !0:EOF
>8c5a	c4 8b					.word	Shift1Command                    ; $81 !1:SH1
>8c5c	cc 8b					.word	Shift2Command                    ; $82 !2:SH2
>8c5e	f0 99					.word	AbsUnary                         ; $83 ABS(
>8c60	fe 99					.word	AllocUnary                       ; $84 ALLOC(
>8c62	6e 9a					.word	AscUnary                         ; $85 ASC(
>8c64	2e 9c					.word	ChrUnary                         ; $86 CHR$(
>8c66	7e 9a					.word	DeekUnary                        ; $87 DEEK(
>8c68	17 a4					.word	UnaryEvent                       ; $88 EVENT(
>8c6a	9d 8f					.word	UnaryFalse                       ; $89 FALSE
>8c6c	90 9a					.word	FracUnary                        ; $8a FRAC(
>8c6e	b3 a3					.word	UnaryHit                         ; $8b HIT(
>8c70	a5 9a					.word	IntUnary                         ; $8c INT(
>8c72	ed 9b					.word	IsValUnary                       ; $8d ISVAL(
>8c74	9b a4					.word	UnaryJoyB                        ; $8e JOYB(
>8c76	74 a4					.word	UnaryJoyX                        ; $8f JOYX(
>8c78	77 a4					.word	UnaryJoyY                        ; $90 JOYY(
>8c7a	01 9d					.word	Unary_Left                       ; $91 LEFT$(
>8c7c	b6 9a					.word	LenUnary                         ; $92 LEN(
>8c7e	d4 9a					.word	Unary_Max                        ; $93 MAX(
>8c80	23 9d					.word	Unary_Mid                        ; $94 MID$(
>8c82	d0 9a					.word	Unary_Min                        ; $95 MIN(
>8c84	1f 9b					.word	Unary_Not                        ; $96 NOT(
>8c86	7b 9a					.word	PeekUnary                        ; $97 PEEK(
>8c88	38 a6					.word	UnaryPlaying                     ; $98 PLAYING(
>8c8a	32 9b					.word	Unary_Random                     ; $99 RANDOM(
>8c8c	0e 9d					.word	Unary_Right                      ; $9a RIGHT$(
>8c8e	4f 9b					.word	Unary_Rnd                        ; $9b RND(
>8c90	c5 9b					.word	SgnUnary                         ; $9c SGN(
>8c92	40 9c					.word	SpcUnary                         ; $9d SPC(
>8c94	5b 9c					.word	Unary_Str                        ; $9e STR$(
>8c96	c1 a4					.word	UnaryTimer                       ; $9f TIMER(
>8c98	92 8f					.word	UnaryTrue                        ; $a0 TRUE
>8c9a	e3 9b					.word	ValUnary                         ; $a1 VAL(
>8c9c	86 85					.word	ForCommand                       ; $a2 FOR
>8c9e	c9 86					.word	IfCommand                        ; $a3 IF
>8ca0	d4 8b					.word	Unused1                          ; $a4 PROC
>8ca2	d6 8a					.word	Command_REPEAT                   ; $a5 REPEAT
>8ca4	7b 8e					.word	Command_WHILE                    ; $a6 WHILE
>8ca6	f2 86					.word	EndIf                            ; $a7 ENDIF
>8ca8	5e 8a					.word	Command_ENDPROC                  ; $a8 ENDPROC
>8caa	38 86					.word	NextCommand                      ; $a9 NEXT
>8cac	d4 8b					.word	Unused4                          ; $aa THEN
>8cae	df 8a					.word	Command_UNTIL                    ; $ab UNTIL
>8cb0	9c 8e					.word	Command_WEND                     ; $ac WEND
>8cb2	c6 9f					.word	SyntaxError                      ; $ad BY
>8cb4	00 84					.word	CallCommand                      ; $ae CALL
>8cb6	67 a1					.word	CircleCommand                    ; $af CIRCLE
>8cb8	35 84					.word	ClearCommand                     ; $b0 CLEAR
>8cba	8d 84					.word	ClearScreen                      ; $b1 CLS
>8cbc	c6 9f					.word	SyntaxError                      ; $b2 COLOR
>8cbe	c6 9f					.word	SyntaxError                      ; $b3 COLOUR
>8cc0	95 84					.word	Command_Data                     ; $b4 DATA
>8cc2	9d 84					.word	DimCommand                       ; $b5 DIM
>8cc4	5d 85					.word	DokeCommand                      ; $b6 DOKE
>8cc6	d4 8b					.word	Unused3                          ; $b7 DOWNTO
>8cc8	eb 86					.word	ElseCode                         ; $b8 ELSE
>8cca	c6 9f					.word	SyntaxError                      ; $b9 FROM
>8ccc	86 a3					.word	GfxCommand                       ; $ba GFX
>8cce	91 86					.word	Command_GOSUB                    ; $bb GOSUB
>8cd0	af 86					.word	GotoCommand                      ; $bc GOTO
>8cd2	c6 9f					.word	SyntaxError                      ; $bd HERE
>8cd4	90 a1					.word	ImageCommand                     ; $be IMAGE
>8cd6	f3 86					.word	Command_Input                    ; $bf INPUT
>8cd8	de 87					.word	LetCommand                       ; $c0 LET
>8cda	e2 a1					.word	LineCommand                      ; $c1 LINE
>8cdc	2f 89					.word	Command_LOCAL                    ; $c2 LOCAL
>8cde	c6 9f					.word	SyntaxError                      ; $c3 OFF
>8ce0	c6 9f					.word	SyntaxError                      ; $c4 ON
>8ce2	c6 9f					.word	SyntaxError                      ; $c5 OUTLINE
>8ce4	d7 a3					.word	PaletteCommand                   ; $c6 PALETTE
>8ce6	db a1					.word	PlotCommand                      ; $c7 PLOT
>8ce8	5a 85					.word	PokeCommand                      ; $c8 POKE
>8cea	fa 86					.word	Command_Print                    ; $c9 PRINT
>8cec	6c 8a					.word	Command_Read                     ; $ca READ
>8cee	63 a1					.word	RectangleCommand                 ; $cb RECT
>8cf0	c9 8a					.word	RemCommand                       ; $cc REM
>8cf2	a1 86					.word	Command_RETURN                   ; $cd RETURN
>8cf4	c6 9f					.word	SyntaxError                      ; $ce SOLID
>8cf6	54 a6					.word	SoundCommand                     ; $cf SOUND
>8cf8	72 a1					.word	SpriteCommand                    ; $d0 SPRITE
>8cfa	ac a1					.word	TextCommand                      ; $d1 TEXT
>8cfc	d4 8b					.word	Unused2                          ; $d2 TO
.8cfe					VectorSet1:
>8cfe	c6 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d00	c6 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d02	c6 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d04	d4 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8d06	f0 83					.word	AssertCommand                    ; $84 ASSERT
>8d08	26 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8d0a	83 85					.word	EndCommand                       ; $86 END
>8d0c	0c a6					.word	Explode                          ; $87 EXPLODE
>8d0e	b8 a4					.word	GoCommand                        ; $88 GO
>8d10	2e 88					.word	Command_List                     ; $89 LIST
>8d12	af a4					.word	LoadCommand                      ; $8a LOAD
>8d14	f0 89					.word	NewCommand                       ; $8b NEW
>8d16	e8 a5					.word	PingCommand                      ; $8c PING
>8d18	f8 8a					.word	Command_Restore                  ; $8d RESTORE
>8d1a	37 8b					.word	CommandRUN                       ; $8e RUN
>8d1c	00 a6					.word	ShootCommand                     ; $8f SHOOT
>8d1e	6b a3					.word	SpritesCtrl                      ; $90 SPRITES
>8d20	ae 8d					.word	StopCommand                      ; $91 STOP
>8d22	aa 8e					.word	WhoCommand                       ; $92 WHO
>8d24	f4 a5					.word	ZapCommand                       ; $93 ZAP
.8d26					VectorSet2:
>8d26	c6 9f					.word	SyntaxError                      ; $80 !0:EOF
>8d28	c6 9f					.word	SyntaxError                      ; $81 !1:SH1
>8d2a	c6 9f					.word	SyntaxError                      ; $82 !2:SH2
>8d2c	85 9e					.word	Assemble_adc                     ; $83 ADC
>8d2e	7d 9e					.word	Assemble_and                     ; $84 AND
>8d30	99 9e					.word	Assemble_asl                     ; $85 ASL
>8d32	03 9f					.word	Assemble_bcc                     ; $86 BCC
>8d34	07 9f					.word	Assemble_bcs                     ; $87 BCS
>8d36	0f 9f					.word	Assemble_beq                     ; $88 BEQ
>8d38	c6 9e					.word	Assemble_bit                     ; $89 BIT
>8d3a	f7 9e					.word	Assemble_bmi                     ; $8a BMI
>8d3c	0b 9f					.word	Assemble_bne                     ; $8b BNE
>8d3e	f3 9e					.word	Assemble_bpl                     ; $8c BPL
>8d40	13 9f					.word	Assemble_bra                     ; $8d BRA
>8d42	17 9f					.word	Assemble_brk                     ; $8e BRK
>8d44	fb 9e					.word	Assemble_bvc                     ; $8f BVC
>8d46	ff 9e					.word	Assemble_bvs                     ; $90 BVS
>8d48	1f 9f					.word	Assemble_clc                     ; $91 CLC
>8d4a	73 9f					.word	Assemble_cld                     ; $92 CLD
>8d4c	33 9f					.word	Assemble_cli                     ; $93 CLI
>8d4e	63 9f					.word	Assemble_clv                     ; $94 CLV
>8d50	91 9e					.word	Assemble_cmp                     ; $95 CMP
>8d52	da 9e					.word	Assemble_cpx                     ; $96 CPX
>8d54	d5 9e					.word	Assemble_cpy                     ; $97 CPY
>8d56	b7 9e					.word	Assemble_dec                     ; $98 DEC
>8d58	6f 9f					.word	Assemble_dex                     ; $99 DEX
>8d5a	4b 9f					.word	Assemble_dey                     ; $9a DEY
>8d5c	81 9e					.word	Assemble_eor                     ; $9b EOR
>8d5e	bc 9e					.word	Assemble_inc                     ; $9c INC
>8d60	7f 9f					.word	Assemble_inx                     ; $9d INX
>8d62	6b 9f					.word	Assemble_iny                     ; $9e INY
>8d64	ee 9e					.word	Assemble_jmp                     ; $9f JMP
>8d66	e9 9e					.word	Assemble_jsr                     ; $a0 JSR
>8d68	8d 9e					.word	Assemble_lda                     ; $a1 LDA
>8d6a	b2 9e					.word	Assemble_ldx                     ; $a2 LDX
>8d6c	d0 9e					.word	Assemble_ldy                     ; $a3 LDY
>8d6e	a3 9e					.word	Assemble_lsr                     ; $a4 LSR
>8d70	83 9f					.word	Assemble_nop                     ; $a5 NOP
>8d72	79 9e					.word	Assemble_ora                     ; $a6 ORA
>8d74	2f 9f					.word	Assemble_pha                     ; $a7 PHA
>8d76	1b 9f					.word	Assemble_php                     ; $a8 PHP
>8d78	77 9f					.word	Assemble_phx                     ; $a9 PHX
>8d7a	37 9f					.word	Assemble_phy                     ; $aa PHY
>8d7c	3f 9f					.word	Assemble_pla                     ; $ab PLA
>8d7e	23 9f					.word	Assemble_plp                     ; $ac PLP
>8d80	8b 9f					.word	Assemble_plx                     ; $ad PLX
>8d82	47 9f					.word	Assemble_ply                     ; $ae PLY
>8d84	9e 9e					.word	Assemble_rol                     ; $af ROL
>8d86	a8 9e					.word	Assemble_ror                     ; $b0 ROR
>8d88	2b 9f					.word	Assemble_rti                     ; $b1 RTI
>8d8a	3b 9f					.word	Assemble_rts                     ; $b2 RTS
>8d8c	95 9e					.word	Assemble_sbc                     ; $b3 SBC
>8d8e	27 9f					.word	Assemble_sec                     ; $b4 SEC
>8d90	87 9f					.word	Assemble_sed                     ; $b5 SED
>8d92	43 9f					.word	Assemble_sei                     ; $b6 SEI
>8d94	89 9e					.word	Assemble_sta                     ; $b7 STA
>8d96	7b 9f					.word	Assemble_stp                     ; $b8 STP
>8d98	ad 9e					.word	Assemble_stx                     ; $b9 STX
>8d9a	cb 9e					.word	Assemble_sty                     ; $ba STY
>8d9c	c1 9e					.word	Assemble_stz                     ; $bb STZ
>8d9e	5f 9f					.word	Assemble_tax                     ; $bc TAX
>8da0	5b 9f					.word	Assemble_tay                     ; $bd TAY
>8da2	e4 9e					.word	Assemble_trb                     ; $be TRB
>8da4	df 9e					.word	Assemble_tsb                     ; $bf TSB
>8da6	67 9f					.word	Assemble_tsx                     ; $c0 TSX
>8da8	4f 9f					.word	Assemble_txa                     ; $c1 TXA
>8daa	57 9f					.word	Assemble_txs                     ; $c2 TXS
>8dac	53 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8dae					StopCommand:
.8dae	a9 08		lda #$08		lda	#8
.8db0	4c 26 8f	jmp $8f26		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8db3					ProcedureScan:
.8db3	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8db5	85 30		sta $30				sta 	codePtr
.8db7	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8db9	85 31		sta $31				sta 	codePtr+1
.8dbb					_PSLoop:
.8dbb	b2 30		lda ($30)			lda 	(codePtr)
.8dbd	f0 42		beq $8e01			beq 	_PSExit
.8dbf	a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.8dc1	b1 30		lda ($30),y			lda 	(codePtr),y
.8dc3	c9 a4		cmp #$a4			cmp 	#KWD_PROC
.8dc5	d0 2d		bne $8df4			bne 	_PSNext
.8dc7	c8		iny				iny 								; get the address of the record to zTemp0 and
.8dc8	b1 30		lda ($30),y			lda 	(codePtr),y
.8dca	29 c0		and #$c0			and 	#$C0
.8dcc	c9 40		cmp #$40			cmp 	#$40
.8dce	d0 32		bne $8e02			bne 	_PSSyntax
.8dd0	b1 30		lda ($30),y			lda 	(codePtr),y
.8dd2	18		clc				clc
.8dd3	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8dd5	85 37		sta $37				sta 	zTemp0+1
.8dd7	c8		iny				iny 								; LSB
.8dd8	b1 30		lda ($30),y			lda 	(codePtr),y
.8dda	85 36		sta $36				sta 	zTemp0
.8ddc	c8		iny				iny 								; character after variable call.
.8ddd	98		tya				tya 								; save Y offset at +7 (exponent slot)
.8dde	a0 07		ldy #$07			ldy 	#7
.8de0	91 36		sta ($36),y			sta 	(zTemp0),y
.8de2	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8de4	a0 02		ldy #$02			ldy 	#2
.8de6	91 36		sta ($36),y			sta 	(zTemp0),y
.8de8	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.8dea					_PSCopy:
.8dea	b5 30		lda $30,x			lda 	safePtr,x
.8dec	c8		iny				iny
.8ded	91 36		sta ($36),y			sta 	(zTemp0),y
.8def	e8		inx				inx
.8df0	e0 04		cpx #$04			cpx 	#4
.8df2	d0 f6		bne $8dea			bne 	_PSCopy
.8df4					_PSNext:
.8df4	18		clc				clc
.8df5	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8df7	65 30		adc $30				adc 	codePtr
.8df9	85 30		sta $30				sta 	codePtr
.8dfb	90 02		bcc $8dff			bcc 	_CREExit
.8dfd	e6 31		inc $31				inc 	codePtr+1 					; carry
.8dff					_CREExit:
.8dff	80 ba		bra $8dbb			bra 	_PSLoop
.8e01					_PSExit:
.8e01	60		rts				rts
.8e02					_PSSyntax:
.8e02	4c c6 9f	jmp $9fc6			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8e05					ScanForward:
.8e05	64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.8e07	86 37		stx $37				stx 	zTemp0+1
.8e09	85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.8e0b					_ScanLoop:
.8e0b	b1 30		lda ($30),y			lda 	(codePtr),y
.8e0d	c8		iny				iny
.8e0e	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8e10	d0 0e		bne $8e20			bne 	_ScanGoNext
.8e12	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8e14	f0 04		beq $8e1a			beq 	_ScanMatch
.8e16	c5 37		cmp $37				cmp 	zTemp0+1
.8e18	d0 06		bne $8e20			bne 	_ScanGoNext
.8e1a					_ScanMatch:
.8e1a	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8e1c	d0 01		bne $8e1f			bne 	_ScanNotEndEOL
.8e1e	88		dey				dey
.8e1f					_ScanNotEndEOL:
.8e1f	60		rts				rts
.8e20					_ScanGoNext:
.8e20	20 25 8e	jsr $8e25			jsr  	ScanForwardOne 				; allows for shifts and so on.
.8e23	80 e6		bra $8e0b			bra 	_ScanLoop
.8e25					ScanForwardOne:
.8e25	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.8e27	90 3e		bcc $8e67			bcc 	_SFWExit
.8e29	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.8e2b	90 18		bcc $8e45			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.8e2d	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.8e2f	b0 2f		bcs $8e60			bcs 	_ScanSkipData
.8e31	c9 a2		cmp #$a2			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8e33	90 32		bcc $8e67			bcc 	_SFWExit 					; if not, ordinary keywords.
.8e35	c9 ad		cmp #$ad			cmp 	#KWC_LAST_STRUCTURE+1
.8e37	b0 2e		bcs $8e67			bcs 	_SFWExit
.8e39	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8e3b	c9 a7		cmp #$a7			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8e3d	b0 28		bcs $8e67			bcs 	_SFWExit
.8e3f	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8e41	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8e43	80 22		bra $8e67			bra 	_SFWExit
.8e45					_ScanSkipOne:
.8e45	c8		iny				iny 								; consume the extra one.
.8e46	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8e48	d0 1d		bne $8e67			bne 	_SFWExit
.8e4a	18		clc				clc
.8e4b	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e4d	65 30		adc $30				adc 	codePtr
.8e4f	85 30		sta $30				sta 	codePtr
.8e51	90 02		bcc $8e55			bcc 	_CREExit
.8e53	e6 31		inc $31				inc 	codePtr+1 					; carry
.8e55					_CREExit:
.8e55	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8e57	b2 30		lda ($30)			lda 	(codePtr)
.8e59	d0 0c		bne $8e67			bne 	_SFWExit 					; if not zero, more to scan
.8e5b	a9 13		lda #$13		lda	#19
.8e5d	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.8e60					_ScanSkipData:
.8e60	88		dey				dey 								; point at data token
.8e61	c8		iny				iny 								; point to offset
.8e62	98		tya				tya 								; A = offset position
.8e63	38		sec				sec 								; add size +1 hence SEC
.8e64	71 30		adc ($30),y			adc 	(codePtr),y
.8e66	a8		tay				tay 								; make current position.
.8e67					_SFWExit:
.8e67	60		rts				rts
.8e68					ScanGetCurrentLineStep:
.8e68	64 38		stz $38				stz 	zTemp1
.8e6a	a0 03		ldy #$03			ldy 	#3
.8e6c					_SGCLSLoop:
.8e6c	b1 30		lda ($30),y			lda 	(codePtr),y
.8e6e	c8		iny				iny
.8e6f	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8e71	f0 05		beq $8e78			beq 	_SGCLSExit
.8e73	20 25 8e	jsr $8e25			jsr 	ScanForwardOne
.8e76	80 f4		bra $8e6c			bra 	_SGCLSLoop
.8e78					_SGCLSExit:
.8e78	a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.8e7a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8e7b					Command_WHILE:
.8e7b	5a		phy				phy 								; save position of the test
.8e7c	a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.8e7e	20 96 9d	jsr $9d96			jsr 	EvaluateNumber
.8e81	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; check if zero
.8e84	f0 0e		beq $8e94			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.8e86	98		tya				tya 								; position *after* test.
.8e87	7a		ply				ply 								; restore position before test, at WHILE
.8e88	88		dey				dey 								; so we execute the WHILE command again.
.8e89	48		pha				pha 								; push after test on the stack
.8e8a	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8e8c	20 db a6	jsr $a6db			jsr 	StackOpen
.8e8f	20 20 a7	jsr $a720			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.8e92	7a		ply				ply 								; restore the position *after* the test
.8e93	60		rts				rts
.8e94					_WHExitLoop:
.8e94	68		pla				pla 								; throw post loop position
.8e95	a9 ac		lda #$ac			lda 	#KWD_WEND 					; scan forward past WEND
.8e97	aa		tax				tax
.8e98	20 05 8e	jsr $8e05			jsr 	ScanForward
.8e9b	60		rts				rts
.8e9c					Command_WEND:
.8e9c	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.8e9e	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.8ea0	20 08 a7	jsr $a708			jsr 	StackCheckFrame
.8ea3	20 31 a7	jsr $a731			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.8ea6	20 fa a6	jsr $a6fa			jsr 	StackClose		 			; erase the frame
.8ea9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/who.asm

.8eaa					WhoCommand:
.8eaa	a2 8e		ldx #$8e			ldx 	#(_WHOMessage >> 8)
.8eac	a9 b2		lda #$b2			lda 	#(_WHOMessage & $FF)
.8eae	20 7f 8f	jsr $8f7f			jsr 	PrintStringXA
.8eb1	60		rts				rts
.8eb2					_WHOMessage:
>8eb2	81						.byte 	$81
>8eb3	42 72 6f 75 67 68 74 20				.text 	"Brought to you by :",13,13
>8ebb	74 6f 20 79 6f 75 20 62 79 20 3a 0d 0d
>8ec8	09 53 74 65 66 61 6e 79				.text 	9,"Stefany Allaire",13
>8ed0	20 41 6c 6c 61 69 72 65 0d
>8ed9	09 4a 65 73 73 69 65 20				.text 	9,"Jessie Oberreuter",13
>8ee1	4f 62 65 72 72 65 75 74 65 72 0d
>8eec	09 50 61 75 6c 20 52 6f				.text 	9,"Paul Robson",13
>8ef4	62 73 6f 6e 0d
>8ef9	09 50 65 74 65 72 20 57				.text 	9,"Peter Weingartner",13
>8f01	65 69 6e 67 61 72 74 6e 65 72 0d
>8f0c	00						.byte 	0

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8f0d					CheckRightBracket:
.8f0d	b1 30		lda ($30),y			lda 	(codePtr),y
.8f0f	c8		iny				iny
.8f10	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8f12	d0 0f		bne $8f23			bne 	CNAFail
.8f14	60		rts				rts
.8f15					CheckComma:
.8f15	b1 30		lda ($30),y			lda 	(codePtr),y
.8f17	c8		iny				iny
.8f18	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8f1a	d0 07		bne $8f23			bne 	CNAFail
.8f1c	60		rts				rts
.8f1d					CheckNextA:
.8f1d	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8f1f	d0 02		bne $8f23			bne 	CNAFail
.8f21	c8		iny				iny 								; skip character
.8f22	60		rts				rts 								; and exit
.8f23					CNAFail:
.8f23	4c c6 9f	jmp $9fc6			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8f26					ErrorHandler:
.8f26	a8		tay				tay 								; find the error text
.8f27	f0 49		beq $8f72			beq 	_EHEnd
.8f29	a2 00		ldx #$00			ldx 	#0
.8f2b	a9 df		lda #$df			lda 	#((ErrorText) & $FF)
.8f2d	85 36		sta $36				sta 	0+zTemp0
.8f2f	a9 9f		lda #$9f			lda 	#((ErrorText) >> 8)
.8f31	85 37		sta $37				sta 	1+zTemp0
.8f33					_EHFind:
.8f33	88		dey				dey 								; keep looking through text
.8f34	f0 0e		beq $8f44			beq 	_EHFound
.8f36					_EHFindZero:
.8f36	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8f38	e6 36		inc $36				inc 	zTemp0
.8f3a	d0 02		bne $8f3e			bne 	_EHFNoCarry
.8f3c	e6 37		inc $37				inc 	zTemp0+1
.8f3e					_EHFNoCarry:
.8f3e	c9 00		cmp #$00			cmp 	#0
.8f40	d0 f4		bne $8f36			bne 	_EHFindZero
.8f42	80 ef		bra $8f33			bra 	_EHFind
.8f44					_EHFound:
.8f44	a5 36		lda $36				lda 	zTemp0 						; print message
.8f46	a6 37		ldx $37				ldx 	zTemp0+1
.8f48	20 7f 8f	jsr $8f7f			jsr 	PrintStringXA
.8f4b	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.8f4d	b1 30		lda ($30),y			lda 	(codePtr),y
.8f4f	d0 05		bne $8f56			bne 	_EHAtMsg
.8f51	c8		iny				iny
.8f52	b1 30		lda ($30),y			lda 	(codePtr),y
.8f54	f0 17		beq $8f6d			beq 	_EHCREnd
.8f56					_EHAtMsg:
.8f56	a2 8f		ldx #$8f			ldx 	#_AtMsg >> 8 				; print " at "
.8f58	a9 75		lda #$75			lda 	#_AtMsg & $FF
.8f5a	20 7f 8f	jsr $8f7f			jsr 	PrintStringXA
.8f5d	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8f5f	b1 30		lda ($30),y			lda 	(codePtr),y
.8f61	48		pha				pha
.8f62	c8		iny				iny
.8f63	b1 30		lda ($30),y			lda 	(codePtr),y
.8f65	aa		tax				tax
.8f66	68		pla				pla
.8f67	20 95 93	jsr $9395			jsr 	ConvertInt16 				; convert XA to string
.8f6a	20 7f 8f	jsr $8f7f			jsr 	PrintStringXA 				; and print it.
.8f6d					_EHCREnd:
.8f6d	a9 0d		lda #$0d			lda 	#13 						; new line
.8f6f	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f72					_EHEnd:
.8f72	4c 9f 83	jmp $839f			jmp 	WarmStart
>8f75	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8f7d	20 00
.8f7f					PrintStringXA:
.8f7f	5a		phy				phy
.8f80	86 37		stx $37				stx 	zTemp0+1
.8f82	85 36		sta $36				sta 	zTemp0
.8f84	a0 00		ldy #$00			ldy 	#0
.8f86					_PSXALoop:
.8f86	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f88	f0 06		beq $8f90			beq 	_PSXAExit
.8f8a	20 03 80	jsr $8003			jsr 	EXTPrintCharacter
.8f8d	c8		iny				iny
.8f8e	80 f6		bra $8f86			bra 	_PSXALoop
.8f90					_PSXAExit:
.8f90	7a		ply				ply
.8f91	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8f92					UnaryTrue:
.8f92	fa		plx				plx
.8f93					ReturnTrue:
.8f93	a9 01		lda #$01			lda 	#1  						; set to 1
.8f95	20 4a 9e	jsr $9e4a			jsr 	NSMSetByte
.8f98	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8f9a	95 50		sta $50,x			sta 	NSStatus,x
.8f9c	60		rts				rts
.8f9d					UnaryFalse:
.8f9d	fa		plx				plx
.8f9e					ReturnFalse:
.8f9e	4c 48 9e	jmp $9e48			jmp 	NSMSetZero 					; set it all to zero
.8fa1					BinaryCompareEqual:
.8fa1	fa		plx				plx
.8fa2	20 dd 8f	jsr $8fdd			jsr 	CompareBaseCode
.8fa5	c9 00		cmp #$00			cmp 	#0
.8fa7	f0 ea		beq $8f93			beq 	ReturnTrue
.8fa9	80 f3		bra $8f9e			bra 	ReturnFalse
.8fab					BinaryCompareLess:
.8fab	fa		plx				plx
.8fac	20 dd 8f	jsr $8fdd			jsr 	CompareBaseCode
.8faf	c9 ff		cmp #$ff			cmp 	#$FF
.8fb1	f0 e0		beq $8f93			beq 	ReturnTrue
.8fb3	80 e9		bra $8f9e			bra 	ReturnFalse
.8fb5					BinaryCompareGreater:
.8fb5	fa		plx				plx
.8fb6	20 dd 8f	jsr $8fdd			jsr 	CompareBaseCode
.8fb9	c9 01		cmp #$01			cmp 	#1
.8fbb	f0 d6		beq $8f93			beq 	ReturnTrue
.8fbd	80 df		bra $8f9e			bra 	ReturnFalse
.8fbf					BinaryCompareNotEqual:
.8fbf	fa		plx				plx
.8fc0	20 dd 8f	jsr $8fdd			jsr 	CompareBaseCode
.8fc3	c9 00		cmp #$00			cmp 	#0
.8fc5	d0 cc		bne $8f93			bne 	ReturnTrue
.8fc7	80 d5		bra $8f9e			bra 	ReturnFalse
.8fc9					BinaryCompareLessEqual:
.8fc9	fa		plx				plx
.8fca	20 dd 8f	jsr $8fdd			jsr 	CompareBaseCode
.8fcd	c9 01		cmp #$01			cmp 	#1
.8fcf	d0 c2		bne $8f93			bne 	ReturnTrue
.8fd1	80 cb		bra $8f9e			bra 	ReturnFalse
.8fd3					BinaryCompareGreaterEqual:
.8fd3	fa		plx				plx
.8fd4	20 dd 8f	jsr $8fdd			jsr 	CompareBaseCode
.8fd7	c9 ff		cmp #$ff			cmp 	#$FF
.8fd9	d0 b8		bne $8f93			bne 	ReturnTrue
.8fdb	80 c1		bra $8f9e			bra 	ReturnFalse
.8fdd					CompareBaseCode:
.8fdd	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; make both values if references.
.8fe0	b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.8fe2	15 51		ora $51,x			ora 	NSStatus+1,x
.8fe4	29 10		and #$10			and 	#NSTString
.8fe6	d0 37		bne $901f			bne 	_CBCString 					; if so do string code, which will check if both.
.8fe8	b5 78		lda $78,x			lda 	NSExponent,x 				; check both are integers
.8fea	15 79		ora $79,x			ora 	NSExponent+1,x
.8fec	d0 34		bne $9022			bne 	_CBCFloat
.8fee	b5 50		lda $50,x			lda 	NSStatus,x
.8ff0	15 51		ora $51,x			ora 	NSStatus+1,x
.8ff2	29 08		and #$08			and 	#NSTFloat
.8ff4	d0 2c		bne $9022			bne 	_CBCFloat
.8ff6	20 25 90	jsr $9025			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.8ff9	e8		inx				inx
.8ffa	20 25 90	jsr $9025			jsr 	CompareFixMinusZero
.8ffd	ca		dex				dex
.8ffe	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.9000	55 51		eor $51,x			eor 	NSStatus+1,x
.9002	10 0a		bpl $900e			bpl 	_CDCSameSign
.9004	b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.9006	30 14		bmi $901c			bmi 	_CBCLess 					; return $FF
.9008					_CBCGreater:
.9008	a9 01		lda #$01			lda 	#1
.900a	60		rts				rts
.900b					_CBCEqual:
.900b	a9 00		lda #$00			lda 	#0
.900d	60		rts				rts
.900e					_CDCSameSign:
.900e	20 3a 92	jsr $923a			jsr 	SubTopTwoStack 				; unsigned subtract
.9011	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; or the mantissa together
.9014	f0 f5		beq $900b			beq 	_CBCEqual 					; -0 == 0
.9016	b5 70		lda $70,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.9018	55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.901a	10 ec		bpl $9008			bpl 	_CBCGreater
.901c					_CBCLess:
.901c	a9 ff		lda #$ff			lda 	#$FF
.901e	60		rts				rts
.901f					_CBCString:
.901f	4c ab 91	jmp $91ab			jmp 	CompareStrings
.9022					_CBCFloat:
.9022	4c f5 94	jmp $94f5			jmp 	CompareFloat
.9025					CompareFixMinusZero:
.9025	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero
.9028	d0 02		bne $902c			bne 	_CFXMZNotZero
.902a	74 50		stz $50,x			stz 	NSStatus,x
.902c					_CFXMZNotZero:
.902c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.902d					StringConcat:
.902d	b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.902f	35 51		and $51,x			and 	NSStatus+1,x
.9031	29 18		and #$18			and 	#NSBTypeMask
.9033	c9 10		cmp #$10			cmp 	#NSTString
.9035	d0 50		bne $9087			bne		_SCType
.9037	64 38		stz $38				stz 	zTemp1 						; counting total length
.9039	e8		inx				inx
.903a	20 58 90	jsr $9058			jsr 	_SCSetupZ0 					; setup for second
.903d	20 61 90	jsr $9061			jsr 	_SCLengthZ0 				; length for second
.9040	ca		dex				dex
.9041	20 58 90	jsr $9058			jsr 	_SCSetupZ0 					; setup for first
.9044	20 61 90	jsr $9061			jsr 	_SCLengthZ0 				; length for first
.9047	a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.9049	20 cb a7	jsr $a7cb			jsr 	StringTempAllocate
.904c	20 78 90	jsr $9078			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.904f	e8		inx				inx
.9050	20 58 90	jsr $9058			jsr 	_SCSetupZ0 					; copy second out
.9053	20 78 90	jsr $9078			jsr 	_SCCopy
.9056	ca		dex				dex
.9057	60		rts				rts
.9058					_SCSetupZ0:
.9058	b5 58		lda $58,x			lda 	NSMantissa0,x
.905a	85 36		sta $36				sta 	zTemp0
.905c	b5 60		lda $60,x			lda 	NSMantissa1,x
.905e	85 37		sta $37				sta 	zTemp0+1
.9060	60		rts				rts
.9061					_SCLengthZ0:
.9061	5a		phy				phy
.9062	a0 00		ldy #$00			ldy 	#0
.9064					_SCLenLoop:
.9064	b1 36		lda ($36),y			lda 	(zTemp0),y
.9066	f0 0e		beq $9076			beq 	_SCLExit
.9068	c8		iny				iny
.9069	e6 38		inc $38				inc 	zTemp1
.906b	a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.906d	c9 fd		cmp #$fd			cmp 	#253
.906f	d0 f3		bne $9064			bne		_SCLenLoop
.9071	a9 09		lda #$09		lda	#9
.9073	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.9076					_SCLExit:
.9076	7a		ply				ply
.9077	60		rts				rts
.9078					_SCCopy:
.9078	5a		phy				phy
.9079	a0 00		ldy #$00			ldy 	#0
.907b					_SCCopyLoop:
.907b	b1 36		lda ($36),y			lda 	(zTemp0),y
.907d	f0 06		beq $9085			beq 	_SCCExit
.907f	20 04 a8	jsr $a804			jsr 	StringTempWrite
.9082	c8		iny				iny
.9083	80 f6		bra $907b			bra 	_SCCopyLoop
.9085					_SCCExit:
.9085	7a		ply				ply
.9086	60		rts				rts
.9087					_SCType:
.9087	4c d0 9f	jmp $9fd0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.908a					IntegerDivide:
.908a	fa		plx				plx
.908b	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.908d	15 51		ora $51,x			ora 	NSStatus+1,x
.908f	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9090	0a		asl a				asl 	a
.9091	10 05		bpl $9098			bpl 	_NotRef
.9093	48		pha				pha
.9094	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9097	68		pla				pla
.9098					_NotRef:
.9098	0a		asl a				asl 	a
.9099	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.909b	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.909d	15 79		ora $79,x			ora 	NSExponent+1,x
.909f	f0 03		beq $90a4			beq 	_IntegerCode 				; if clear, then we have two integers
.90a1	4c d0 9f	jmp $9fd0			jmp 	TypeError 					; anything else, type mismatch.
.90a4					_IntegerCode:
.90a4	20 be 90	jsr $90be			jsr 	CheckDivideZero 			; do div zero check
.90a7	20 f0 90	jsr $90f0			jsr 	Int32Divide 				; do the division
.90aa	20 a1 91	jsr $91a1			jsr 	CalculateSign 				; calculate result sign
.90ad					NSMCopyPlusTwoToZero:
.90ad	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.90af	95 58		sta $58,x			sta 	NSMantissa0,x
.90b1	b5 62		lda $62,x			lda 	NSMantissa1+2,x
.90b3	95 60		sta $60,x			sta 	NSMantissa1,x
.90b5	b5 6a		lda $6a,x			lda 	NSMantissa2+2,x
.90b7	95 68		sta $68,x			sta 	NSMantissa2,x
.90b9	b5 72		lda $72,x			lda 	NSMantissa3+2,x
.90bb	95 70		sta $70,x			sta 	NSMantissa3,x
.90bd	60		rts				rts
.90be					CheckDivideZero:
.90be	e8		inx				inx
.90bf	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero
.90c2	f0 02		beq $90c6			beq 	_CDVError
.90c4	ca		dex				dex
.90c5	60		rts				rts
.90c6					_CDVError:
.90c6	a9 03		lda #$03		lda	#3
.90c8	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.90cb					IntegerModulus:
.90cb	fa		plx				plx
.90cc	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.90ce	15 51		ora $51,x			ora 	NSStatus+1,x
.90d0	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90d1	0a		asl a				asl 	a
.90d2	10 05		bpl $90d9			bpl 	_NotRef
.90d4	48		pha				pha
.90d5	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.90d8	68		pla				pla
.90d9					_NotRef:
.90d9	0a		asl a				asl 	a
.90da	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.90dc	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.90de	15 79		ora $79,x			ora 	NSExponent+1,x
.90e0	f0 03		beq $90e5			beq 	_IntegerCode 				; if clear, then we have two integers
.90e2	4c d0 9f	jmp $9fd0			jmp 	TypeError 					; anything else, type mismatch.
.90e5					_IntegerCode:
.90e5					IntegerModulusNoCheck:
.90e5	20 be 90	jsr $90be			jsr 	CheckDivideZero 			; do div zero check
.90e8	20 f0 90	jsr $90f0			jsr 	Int32Divide 				; do the division
.90eb	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.90ed	56 50		lsr $50,x			lsr 	NSStatus,x
.90ef	60		rts				rts
.90f0					Int32Divide:
.90f0	48		pha				pha 								; save AXY
.90f1	5a		phy				phy
.90f2	20 2b 9e	jsr $9e2b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.90f5	20 44 9e	jsr $9e44			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.90f8	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.90fa					_I32DivideLoop:
.90fa	e8		inx				inx
.90fb	e8		inx				inx
.90fc	20 57 9e	jsr $9e57			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.90ff	ca		dex				dex
.9100	ca		dex				dex
.9101	20 58 9e	jsr $9e58			jsr 	NSMRotateLeft
.9104	20 2f 91	jsr $912f			jsr 	DivideCheckSubtract 		; check if subtract possible
.9107	90 02		bcc $910b			bcc 	_I32DivideNoCarryIn
.9109	f6 5a		inc $5a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.910b					_I32DivideNoCarryIn:
.910b	88		dey				dey 								; loop round till division completed.
.910c	d0 ec		bne $90fa			bne 	_I32DivideLoop
.910e	7a		ply				ply 								; restore AXY and exit
.910f	68		pla				pla
.9110	60		rts				rts
.9111					Int32ShiftDivide:
.9111	48		pha				pha 								; save AY
.9112	5a		phy				phy
.9113	e8		inx				inx 								; clear S[X+2]
.9114	e8		inx				inx
.9115	20 48 9e	jsr $9e48			jsr 	NSMSetZero
.9118	ca		dex				dex
.9119	ca		dex				dex
.911a	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.911c					_I32SDLoop:
.911c	20 2f 91	jsr $912f			jsr 	DivideCheckSubtract 		; check if subtract possible
.911f	e8		inx				inx
.9120	e8		inx				inx
.9121	20 58 9e	jsr $9e58			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.9124	ca		dex				dex
.9125	ca		dex				dex
.9126	20 58 9e	jsr $9e58			jsr 	NSMRotateLeft
.9129	88		dey				dey 	 							; do 31 times
.912a	d0 f0		bne $911c			bne 	_I32SDLoop
.912c	7a		ply				ply 								; restore AY and exit
.912d	68		pla				pla
.912e	60		rts				rts
.912f					DivideCheckSubtract:
.912f	20 3a 92	jsr $923a			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9132	b0 04		bcs $9138			bcs 	_DCSExit 					; if carry set, then could do, exit
.9134	20 20 92	jsr $9220			jsr 	AddTopTwoStack 				; add it back in
.9137	18		clc				clc 								; and return False
.9138					_DCSExit:
.9138	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9139					MulInteger:
.9139	fa		plx				plx
.913a	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.913c	15 51		ora $51,x			ora 	NSStatus+1,x
.913e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.913f	0a		asl a				asl 	a
.9140	10 05		bpl $9147			bpl 	_NotRef
.9142	48		pha				pha
.9143	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9146	68		pla				pla
.9147					_NotRef:
.9147	0a		asl a				asl 	a 							; put MSB of type into A:7
.9148	30 09		bmi $9153			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.914a	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.914c	15 79		ora $79,x			ora 	NSExponent+1,x
.914e	f0 06		beq $9156			beq 	_IntegerCode 				; if clear, then we have two integers
.9150	4c b7 95	jmp $95b7			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9153					_StringData:
.9153	4c da 9f	jmp $9fda			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9156					_IntegerCode:
.9156	20 63 91	jsr $9163			jsr 	MultiplyShort
.9159	c9 00		cmp #$00			cmp 	#0
.915b	f0 05		beq $9162			beq 	_MIExit
.915d	a9 04		lda #$04		lda	#4
.915f	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.9162					_MIExit:
.9162	60		rts				rts
.9163					MultiplyShort:
.9163	5a		phy				phy 								; save Y
.9164	20 2b 9e	jsr $9e2b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9167	20 44 9e	jsr $9e44			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.916a	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.916c					_I32MLoop:
.916c	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.916e	15 62		ora $62,x			ora 	NSMantissa1+2,x
.9170	15 6a		ora $6a,x			ora 	NSMantissa2+2,x
.9172	15 72		ora $72,x			ora 	NSMantissa3+2,x
.9174	f0 25		beq $919b			beq 	_I32MExit 					; exit if zero
.9176	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.9178	29 01		and #$01			and 	#1
.917a	f0 0d		beq $9189			beq 	_I32MNoAdd
.917c	20 20 92	jsr $9220			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.917f	b5 70		lda $70,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9181	10 06		bpl $9189			bpl 	_I32MNoAdd
.9183					_I32ShiftRight:
.9183	20 61 9e	jsr $9e61			jsr 	NSMShiftRight 				; shift S[X] right
.9186	c8		iny				iny 								; increment shift count
.9187	80 09		bra $9192			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9189					_I32MNoAdd:
.9189	34 71		bit $71,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.918b	70 f6		bvs $9183			bvs 	_I32ShiftRight 				; instead.
.918d	e8		inx				inx
.918e	20 57 9e	jsr $9e57			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9191	ca		dex				dex
.9192					_I32MShiftUpper:
.9192	e8		inx				inx 								; shift S[X+2] right
.9193	e8		inx				inx
.9194	20 61 9e	jsr $9e61			jsr 	NSMShiftRight
.9197	ca		dex				dex
.9198	ca		dex				dex
.9199	80 d1		bra $916c			bra 	_I32MLoop 					; try again.
.919b					_I32MExit:
.919b	20 a1 91	jsr $91a1			jsr 	CalculateSign
.919e	98		tya				tya 								; shift in A
.919f	7a		ply				ply 								; restore Y and exit
.91a0	60		rts				rts
.91a1					CalculateSign:
.91a1	b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.91a3	16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.91a5	55 51		eor $51,x			eor 	NSStatus+1,x
.91a7	0a		asl a				asl 	a 							; shift bit 7 into carry
.91a8	76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.91aa	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.91ab					CompareStrings:
.91ab	b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.91ad	35 51		and $51,x			and 	NSStatus+1,x
.91af	29 10		and #$10			and 	#NSBIsString
.91b1	f0 28		beq $91db			beq 	_CSTypeError
.91b3	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.91b5	85 36		sta $36				sta 	zTemp0
.91b7	b5 60		lda $60,x			lda 	NSMantissa1,x
.91b9	85 37		sta $37				sta 	zTemp0+1
.91bb	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.91bd	85 38		sta $38				sta 	zTemp1
.91bf	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.91c1	85 39		sta $39				sta 	zTemp1+1
.91c3	5a		phy				phy 								; save Y so we can access strings
.91c4	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.91c6					_CSLoop:
.91c6	c8		iny				iny
.91c7	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.91c9	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.91cb	d0 06		bne $91d3			bne 	_CSDifferent
.91cd	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.91cf	d0 f5		bne $91c6			bne 	_CSLoop 					; still comparing
.91d1					_CSExit:
.91d1	7a		ply				ply 								; reached end, return zero in A from EOS
.91d2	60		rts				rts
.91d3					_CSDifferent:
.91d3	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.91d5	90 fa		bcc $91d1			bcc		_CSExit
.91d7	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.91d9	80 f6		bra $91d1			bra 	_CSExit
.91db					_CSTypeError:
.91db	4c d0 9f	jmp $9fd0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.91de					ShiftLeft:
.91de	38		sec				sec 								; common code, carry determines which way.
.91df	80 01		bra $91e2			bra 	ShiftMain
.91e1					ShiftRight:
.91e1	18		clc				clc
.91e2					ShiftMain:
.91e2	fa		plx				plx 								; restore X
.91e3	08		php				php 								; save direction
.91e4	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.91e6	15 51		ora $51,x			ora 	NSStatus+1,x
.91e8	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91e9	0a		asl a				asl 	a
.91ea	10 05		bpl $91f1			bpl 	_NotRef
.91ec	48		pha				pha
.91ed	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91f0	68		pla				pla
.91f1					_NotRef:
.91f1	0a		asl a				asl 	a
.91f2	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.91f4	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91f6	15 79		ora $79,x			ora 	NSExponent+1,x
.91f8	f0 03		beq $91fd			beq 	_IntegerCode 				; if clear, then we have two integers
.91fa	4c d0 9f	jmp $9fd0			jmp 	TypeError 					; anything else, type mismatch.
.91fd					_IntegerCode:
.91fd	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; check number < 32
.91ff	29 e0		and #$e0			and 	#$E0
.9201	15 61		ora $61,x			ora 	NSMantissa1+1,x
.9203	15 69		ora $69,x			ora 	NSMantissa2+1,x
.9205	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9207	d0 12		bne $921b			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9209					_SMLoop:
.9209	d6 59		dec $59,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.920b	30 11		bmi $921e			bmi 	_SMExit 					; exit if done.
.920d	28		plp				plp 								; restore direction setting
.920e	08		php				php
.920f	90 05		bcc $9216			bcc 	_SMRight
.9211	20 57 9e	jsr $9e57			jsr 	NSMShiftLeft 				; shift left if CS
.9214	80 f3		bra $9209			bra 	_SMLoop
.9216					_SMRight:
.9216	20 61 9e	jsr $9e61			jsr 	NSMShiftRight 				; shift right if CC
.9219	80 ee		bra $9209			bra 	_SMLoop
.921b					_SMExit0:
.921b	20 48 9e	jsr $9e48			jsr 	NSMSetZero 					; return zero.
.921e					_SMExit:
.921e	28		plp				plp 								; throw direction
.921f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9220					AddTopTwoStack:
.9220	18		clc				clc
.9221	b5 58		lda $58,x			lda		NSMantissa0,x
.9223	75 59		adc $59,x			adc 		NSMantissa0+1,x
.9225	95 58		sta $58,x			sta 	NSMantissa0,x
.9227	b5 60		lda $60,x			lda		NSMantissa1,x
.9229	75 61		adc $61,x			adc 		NSMantissa1+1,x
.922b	95 60		sta $60,x			sta 	NSMantissa1,x
.922d	b5 68		lda $68,x			lda		NSMantissa2,x
.922f	75 69		adc $69,x			adc 		NSMantissa2+1,x
.9231	95 68		sta $68,x			sta 	NSMantissa2,x
.9233	b5 70		lda $70,x			lda		NSMantissa3,x
.9235	75 71		adc $71,x			adc 		NSMantissa3+1,x
.9237	95 70		sta $70,x			sta 	NSMantissa3,x
.9239	60		rts				rts
.923a					SubTopTwoStack:
.923a	38		sec				sec
.923b	b5 58		lda $58,x			lda		NSMantissa0,x
.923d	f5 59		sbc $59,x			sbc 		NSMantissa0+1,x
.923f	95 58		sta $58,x			sta 	NSMantissa0,x
.9241	b5 60		lda $60,x			lda		NSMantissa1,x
.9243	f5 61		sbc $61,x			sbc 		NSMantissa1+1,x
.9245	95 60		sta $60,x			sta 	NSMantissa1,x
.9247	b5 68		lda $68,x			lda		NSMantissa2,x
.9249	f5 69		sbc $69,x			sbc 		NSMantissa2+1,x
.924b	95 68		sta $68,x			sta 	NSMantissa2,x
.924d	b5 70		lda $70,x			lda		NSMantissa3,x
.924f	f5 71		sbc $71,x			sbc 		NSMantissa3+1,x
.9251	95 70		sta $70,x			sta 	NSMantissa3,x
.9253	60		rts				rts
.9254					AddInteger:
.9254	fa		plx				plx
.9255	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9257	15 51		ora $51,x			ora 	NSStatus+1,x
.9259	0a		asl a				asl 	a 							; shift reference bit into sign bit
.925a	0a		asl a				asl 	a
.925b	10 05		bpl $9262			bpl 	_NotRef
.925d	48		pha				pha
.925e	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9261	68		pla				pla
.9262					_NotRef:
.9262	0a		asl a				asl 	a 							; put MSB of type into A:7
.9263	30 09		bmi $926e			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9265	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9267	15 79		ora $79,x			ora 	NSExponent+1,x
.9269	f0 06		beq $9271			beq 	_IntegerCode 				; if clear, then we have two integers
.926b	4c 67 94	jmp $9467			jmp 	FloatingPointAdd 							; otherwise at least one float.
.926e					_StringData:
.926e	4c 2d 90	jmp $902d			jmp 	StringConcat							; at least one string - don't know both are strings.
.9271					_IntegerCode:
.9271					AddCode:
.9271	b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.9273	55 51		eor $51,x			eor 	NSStatus+1,x
.9275	10 a9		bpl $9220			bpl 	AddTopTwoStack
.9277	20 3a 92	jsr $923a			jsr 	SubTopTwoStack 				; do a physical subtraction
.927a	34 70		bit $70,x			bit 	NSMantissa3,x 				; result is +ve, okay
.927c	10 07		bpl $9285			bpl 	_AddExit
.927e	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9280	95 50		sta $50,x			sta 	NSStatus,x
.9282	20 11 9e	jsr $9e11			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.9285					_AddExit:
.9285	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; check for -0
.9288	d0 02		bne $928c			bne 	_AddNonZero
.928a	74 50		stz $50,x			stz 	NSStatus,x
.928c					_AddNonZero:
.928c	60		rts				rts
.928d					SubInteger:
.928d	fa		plx				plx
.928e	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9290	15 51		ora $51,x			ora 	NSStatus+1,x
.9292	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9293	0a		asl a				asl 	a
.9294	10 05		bpl $929b			bpl 	_NotRef
.9296	48		pha				pha
.9297	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.929a	68		pla				pla
.929b					_NotRef:
.929b	0a		asl a				asl 	a 							; put MSB of type into A:7
.929c	30 09		bmi $92a7			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.929e	b5 78		lda $78,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92a0	15 79		ora $79,x			ora 	NSExponent+1,x
.92a2	f0 06		beq $92aa			beq 	_IntegerCode 				; if clear, then we have two integers
.92a4	4c 6c 94	jmp $946c			jmp 	FloatingPointSub 							; otherwise at least one float.
.92a7					_StringData:
.92a7	4c da 9f	jmp $9fda			jmp 	NotDoneError							; at least one string - don't know both are strings.
.92aa					_IntegerCode:
.92aa	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.92ac	49 80		eor #$80			eor 	#$80
.92ae	95 51		sta $51,x			sta 	NSStatus+1,x
.92b0	80 bf		bra $9271			bra 	AddCode 					; and do the same code as add.
.92b2					AndInteger:
.92b2	fa		plx				plx
.92b3	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92b5	15 51		ora $51,x			ora 	NSStatus+1,x
.92b7	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92b8	0a		asl a				asl 	a
.92b9	10 05		bpl $92c0			bpl 	_NotRef
.92bb	48		pha				pha
.92bc	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92bf	68		pla				pla
.92c0					_NotRef:
.92c0	0a		asl a				asl 	a
.92c1	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92c3	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92c5	15 79		ora $79,x			ora 	NSExponent+1,x
.92c7	f0 03		beq $92cc			beq 	_IntegerCode 				; if clear, then we have two integers
.92c9	4c d0 9f	jmp $9fd0			jmp 	TypeError 					; anything else, type mismatch.
.92cc					_IntegerCode:
.92cc	b5 58		lda $58,x			lda		NSMantissa0,x
.92ce	35 59		and $59,x			and 		NSMantissa0+1,x
.92d0	95 58		sta $58,x			sta 	NSMantissa0,x
.92d2	b5 60		lda $60,x			lda		NSMantissa1,x
.92d4	35 61		and $61,x			and 		NSMantissa1+1,x
.92d6	95 60		sta $60,x			sta 	NSMantissa1,x
.92d8	b5 68		lda $68,x			lda		NSMantissa2,x
.92da	35 69		and $69,x			and 		NSMantissa2+1,x
.92dc	95 68		sta $68,x			sta 	NSMantissa2,x
.92de	b5 70		lda $70,x			lda		NSMantissa3,x
.92e0	35 71		and $71,x			and 		NSMantissa3+1,x
.92e2	95 70		sta $70,x			sta 	NSMantissa3,x
.92e4	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.92e6	60		rts				rts
.92e7					OraInteger:
.92e7	fa		plx				plx
.92e8	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.92ea	15 51		ora $51,x			ora 	NSStatus+1,x
.92ec	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92ed	0a		asl a				asl 	a
.92ee	10 05		bpl $92f5			bpl 	_NotRef
.92f0	48		pha				pha
.92f1	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92f4	68		pla				pla
.92f5					_NotRef:
.92f5	0a		asl a				asl 	a
.92f6	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92f8	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92fa	15 79		ora $79,x			ora 	NSExponent+1,x
.92fc	f0 03		beq $9301			beq 	_IntegerCode 				; if clear, then we have two integers
.92fe	4c d0 9f	jmp $9fd0			jmp 	TypeError 					; anything else, type mismatch.
.9301					_IntegerCode:
.9301	b5 58		lda $58,x			lda		NSMantissa0,x
.9303	15 59		ora $59,x			ora 		NSMantissa0+1,x
.9305	95 58		sta $58,x			sta 	NSMantissa0,x
.9307	b5 60		lda $60,x			lda		NSMantissa1,x
.9309	15 61		ora $61,x			ora 		NSMantissa1+1,x
.930b	95 60		sta $60,x			sta 	NSMantissa1,x
.930d	b5 68		lda $68,x			lda		NSMantissa2,x
.930f	15 69		ora $69,x			ora 		NSMantissa2+1,x
.9311	95 68		sta $68,x			sta 	NSMantissa2,x
.9313	b5 70		lda $70,x			lda		NSMantissa3,x
.9315	15 71		ora $71,x			ora 		NSMantissa3+1,x
.9317	95 70		sta $70,x			sta 	NSMantissa3,x
.9319	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.931b	60		rts				rts
.931c					EorInteger:
.931c	fa		plx				plx
.931d	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.931f	15 51		ora $51,x			ora 	NSStatus+1,x
.9321	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9322	0a		asl a				asl 	a
.9323	10 05		bpl $932a			bpl 	_NotRef
.9325	48		pha				pha
.9326	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9329	68		pla				pla
.932a					_NotRef:
.932a	0a		asl a				asl 	a
.932b	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.932d	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.932f	15 79		ora $79,x			ora 	NSExponent+1,x
.9331	f0 03		beq $9336			beq 	_IntegerCode 				; if clear, then we have two integers
.9333	4c d0 9f	jmp $9fd0			jmp 	TypeError 					; anything else, type mismatch.
.9336					_IntegerCode:
.9336	b5 58		lda $58,x			lda		NSMantissa0,x
.9338	55 59		eor $59,x			eor 		NSMantissa0+1,x
.933a	95 58		sta $58,x			sta 	NSMantissa0,x
.933c	b5 60		lda $60,x			lda		NSMantissa1,x
.933e	55 61		eor $61,x			eor 		NSMantissa1+1,x
.9340	95 60		sta $60,x			sta 	NSMantissa1,x
.9342	b5 68		lda $68,x			lda		NSMantissa2,x
.9344	55 69		eor $69,x			eor 		NSMantissa2+1,x
.9346	95 68		sta $68,x			sta 	NSMantissa2,x
.9348	b5 70		lda $70,x			lda		NSMantissa3,x
.934a	55 71		eor $71,x			eor 		NSMantissa3+1,x
.934c	95 70		sta $70,x			sta 	NSMantissa3,x
.934e	74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9350	60		rts				rts
.9351					WordIndirect:
.9351	fa		plx				plx
.9352	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9354	15 51		ora $51,x			ora 	NSStatus+1,x
.9356	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9357	0a		asl a				asl 	a
.9358	10 05		bpl $935f			bpl 	_NotRef
.935a	48		pha				pha
.935b	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.935e	68		pla				pla
.935f					_NotRef:
.935f	0a		asl a				asl 	a
.9360	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9362	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9364	15 79		ora $79,x			ora 	NSExponent+1,x
.9366	f0 03		beq $936b			beq 	_IntegerCode 				; if clear, then we have two integers
.9368	4c d0 9f	jmp $9fd0			jmp 	TypeError 					; anything else, type mismatch.
.936b					_IntegerCode:
.936b	20 71 92	jsr $9271			jsr 	AddCode 					; add the two values
.936e	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9370	95 50		sta $50,x			sta 	NSStatus,x
.9372	60		rts				rts
.9373					ByteIndirect:
.9373	fa		plx				plx
.9374	b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9376	15 51		ora $51,x			ora 	NSStatus+1,x
.9378	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9379	0a		asl a				asl 	a
.937a	10 05		bpl $9381			bpl 	_NotRef
.937c	48		pha				pha
.937d	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9380	68		pla				pla
.9381					_NotRef:
.9381	0a		asl a				asl 	a
.9382	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9384	15 78		ora $78,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9386	15 79		ora $79,x			ora 	NSExponent+1,x
.9388	f0 03		beq $938d			beq 	_IntegerCode 				; if clear, then we have two integers
.938a	4c d0 9f	jmp $9fd0			jmp 	TypeError 					; anything else, type mismatch.
.938d					_IntegerCode:
.938d	20 71 92	jsr $9271			jsr 	AddCode 					; add the two values
.9390	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9392	95 50		sta $50,x			sta 	NSStatus,x
.9394	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9395					ConvertInt16:
.9395	85 58		sta $58				sta 	NSMantissa0 				; set up as 32 bit conversion
.9397	86 60		stx $60				stx 	NSMantissa1
.9399	64 68		stz $68				stz 	NSMantissa2
.939b	64 70		stz $70				stz 	NSMantissa3
.939d	64 50		stz $50				stz 	NSStatus 					; positive integer
.939f	a2 00		ldx #$00			ldx 	#0 							; stack level
.93a1	a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.93a3	80 00		bra $93a5			bra 	ConvertInt32
.93a5					ConvertInt32:
.93a5	5a		phy				phy
.93a6	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.93a8	24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.93aa	10 08		bpl $93b4			bpl 	_CI32NotNeg
.93ac	48		pha				pha
.93ad	a9 2d		lda #$2d			lda 	#'-'
.93af	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.93b2	c8		iny				iny
.93b3	68		pla				pla
.93b4					_CI32NotNeg:
.93b4	20 c2 93	jsr $93c2			jsr 	_CI32DivideConvert 			; recursive conversion
.93b7	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.93b9	99 27 06	sta $0627,y			sta 	NumberBuffer,y
.93bc	7a		ply				ply
.93bd	a2 06		ldx #$06			ldx 	#NumberBuffer >> 8 			; return address in XA
.93bf	a9 27		lda #$27			lda 	#NumberBuffer & $FF
.93c1	60		rts				rts
.93c2					_CI32DivideConvert:
.93c2	e8		inx				inx 								; write to next slot up
.93c3	20 4a 9e	jsr $9e4a			jsr 	NSMSetByte 		 			; write the base out.
.93c6	ca		dex				dex
.93c7	20 f0 90	jsr $90f0			jsr 	Int32Divide 				; divide
.93ca	b5 58		lda $58,x			lda 	NSMantissa0,x 				; save remainder
.93cc	48		pha				pha
.93cd	20 ad 90	jsr $90ad			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.93d0	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; is it zero ?
.93d3	f0 05		beq $93da			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.93d5	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.93d7	20 c2 93	jsr $93c2			jsr 	_CI32DivideConvert 			; and recusrively call.
.93da					_CI32NoRecurse:
.93da	68		pla				pla 								; remainder
.93db	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.93dd	90 02		bcc $93e1			bcc 	_CI32NotHex
.93df	69 26		adc #$26			adc 	#6+32
.93e1					_CI32NotHex:
.93e1	69 30		adc #$30			adc 	#48
.93e3	99 27 06	sta $0627,y			sta 	NumberBuffer,y 				; write out and exit
.93e6	c8		iny				iny
.93e7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.93e8					PrecedenceLevel:
>93e8	04					.byte	 4	; $00 <<
>93e9	02					.byte	 2	; $01 <=
>93ea	02					.byte	 2	; $02 <>
>93eb	00					.byte	 0	; $03 !!3
>93ec	00					.byte	 0	; $04 ><
>93ed	02					.byte	 2	; $05 >=
>93ee	04					.byte	 4	; $06 >>
>93ef	00					.byte	 0	; $07 !!7
>93f0	00					.byte	 0	; $08 !!8
>93f1	00					.byte	 0	; $09 !!9
>93f2	00					.byte	 0	; $0a !!10
>93f3	00					.byte	 0	; $0b !!11
>93f4	00					.byte	 0	; $0c !!12
>93f5	00					.byte	 0	; $0d !!13
>93f6	00					.byte	 0	; $0e !!14
>93f7	00					.byte	 0	; $0f !!15
>93f8	00					.byte	 0	; $10 @
>93f9	00					.byte	 0	; $11 !!17
>93fa	00					.byte	 0	; $12 !!18
>93fb	00					.byte	 0	; $13 [
>93fc	04					.byte	 4	; $14 \
>93fd	00					.byte	 0	; $15 ]
>93fe	01					.byte	 1	; $16 ^
>93ff	00					.byte	 0	; $17 _
>9400	00					.byte	 0	; $18 `
>9401	00					.byte	 0	; $19 !!25
>9402	00					.byte	 0	; $1a !!26
>9403	00					.byte	 0	; $1b {
>9404	01					.byte	 1	; $1c |
>9405	00					.byte	 0	; $1d }
>9406	00					.byte	 0	; $1e ~
>9407	00					.byte	 0	; $1f [7m<7F>[m
>9408	00					.byte	 0	; $20
>9409	05					.byte	 5	; $21 !
>940a	00					.byte	 0	; $22 "
>940b	00					.byte	 0	; $23 #
>940c	05					.byte	 5	; $24 $
>940d	04					.byte	 4	; $25 %
>940e	01					.byte	 1	; $26 &
>940f	00					.byte	 0	; $27 '
>9410	00					.byte	 0	; $28 (
>9411	00					.byte	 0	; $29 )
>9412	04					.byte	 4	; $2a *
>9413	03					.byte	 3	; $2b +
>9414	00					.byte	 0	; $2c ,
>9415	03					.byte	 3	; $2d -
>9416	00					.byte	 0	; $2e .
>9417	04					.byte	 4	; $2f /
>9418	00					.byte	 0	; $30 0
>9419	00					.byte	 0	; $31 1
>941a	00					.byte	 0	; $32 2
>941b	00					.byte	 0	; $33 3
>941c	00					.byte	 0	; $34 4
>941d	00					.byte	 0	; $35 5
>941e	00					.byte	 0	; $36 6
>941f	00					.byte	 0	; $37 7
>9420	00					.byte	 0	; $38 8
>9421	00					.byte	 0	; $39 9
>9422	00					.byte	 0	; $3a :
>9423	00					.byte	 0	; $3b ;
>9424	02					.byte	 2	; $3c <
>9425	02					.byte	 2	; $3d =
>9426	02					.byte	 2	; $3e >
>9427	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9428					EvaluateExpressionAt0:
.9428	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.942a					EvaluateExpression:
.942a	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.942c					EvaluateExpressionAtPrecedence:
.942c	48		pha				pha 								; save precedence level
.942d	20 74 98	jsr $9874			jsr 	EvaluateTerm 				; evaluate term into level X.
.9430	68		pla				pla 								; restore precedence level.
.9431					_EXPRLoop:
.9431	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9433	b1 30		lda ($30),y			lda 	(codePtr),y
.9435	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9437	b0 25		bcs $945e			bcs 	_EXPRExit
.9439	da		phx				phx 								; read the operator precedence
.943a	aa		tax				tax
.943b	bd e8 93	lda $93e8,x			lda 	PrecedenceLevel,x
.943e	fa		plx				plx
.943f	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9441	f0 1b		beq $945e			beq 	_EXPRExit
.9443	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9445	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9447	c5 37		cmp $37				cmp 	zTemp0+1
.9449	b0 13		bcs $945e			bcs		_EXPRExit 					; if current >= operator exit
.944b	48		pha				pha 								; save current precedence.
.944c	b1 30		lda ($30),y			lda 	(codePtr),y
.944e	c8		iny				iny
.944f	48		pha				pha
.9450	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9452	e8		inx				inx 								; work out the right hand side.
.9453	20 2c 94	jsr $942c			jsr 	EvaluateExpressionAtPrecedence
.9456	ca		dex				dex
.9457	68		pla				pla 								; get operator, call the code.
.9458	20 61 94	jsr $9461			jsr 	_EXPRCaller
.945b	68		pla				pla 								; restore precedence level
.945c	80 d3		bra $9431			bra 	_EXPRLoop 					; and go round.
.945e					_EXPRExit:
.945e	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9460	60		rts				rts
.9461					_EXPRCaller:
.9461	da		phx				phx 								; save on stack, first thing is to restore it
.9462	0a		asl a				asl 	a 							; double so can use vectors into X
.9463	aa		tax				tax
.9464	7c d8 8b	jmp ($8bd8,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9467					FloatingPointAdd:
.9467	20 dd 95	jsr $95dd			jsr 	FloatPrepare 				; prepare for floats
.946a	80 09		bra $9475			bra 	FloatAdd
.946c					FloatingPointSub:
.946c	20 dd 95	jsr $95dd			jsr 	FloatPrepare 				; prepare for floats
.946f					FloatSubtract:
.946f	b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9471	49 80		eor #$80			eor 	#$80
.9473	95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9475					FloatAdd:
.9475	48		pha				pha
.9476	5a		phy				phy
.9477	20 ec 95	jsr $95ec			jsr 	NSNormalise 				; normalise S[X]
.947a	f0 51		beq $94cd			beq 	_FAReturn1
.947c	e8		inx				inx 								; normalise S[X+1]
.947d	20 ec 95	jsr $95ec			jsr 	NSNormalise
.9480	ca		dex				dex
.9481	c9 00		cmp #$00			cmp 	#0
.9483	f0 60		beq $94e5			beq 	_FAExit 					; if so, just return A
.9485	b5 78		lda $78,x			lda 	NSExponent,x 				; are the exponents the same ?
.9487	d5 79		cmp $79,x			cmp 	NSExponent+1,x
.9489	f0 18		beq $94a3			beq 	_FAExponentsEqual
.948b	b5 78		lda $78,x			lda 	NSExponent,x 				; work out the larger exponent
.948d	a8		tay				tay
.948e	38		sec				sec 								; do a signed comparison of the exponents.
.948f	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.9491	50 02		bvc $9495			bvc 	_FANoSignedChange
.9493	49 80		eor #$80			eor 	#$80
.9495					_FANoSignedChange:
.9495	29 80		and #$80			and 	#$80
.9497	10 02		bpl $949b			bpl 	_FAHaveMax
.9499	b4 79		ldy $79,x			ldy 	NSExponent+1,x
.949b					_FAHaveMax:
.949b	20 e8 94	jsr $94e8			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.949e	e8		inx				inx
.949f	20 e8 94	jsr $94e8			jsr 	_FAShiftToExponent
.94a2	ca		dex				dex
.94a3					_FAExponentsEqual:
.94a3	b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.94a5	55 51		eor $51,x			eor 	NSStatus+1,x
.94a7	30 0e		bmi $94b7			bmi 	_FADifferentSigns
.94a9	20 20 92	jsr $9220			jsr 	AddTopTwoStack 				; do the add of the mantissae
.94ac	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.94ae	10 35		bpl $94e5			bpl 	_FAExit 					; if no, we are done.
.94b0	20 61 9e	jsr $9e61			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.94b3	f6 78		inc $78,x			inc 	NSExponent,x 				; bump the exponent and exit
.94b5	80 2e		bra $94e5			bra 	_FAExit
.94b7					_FADifferentSigns:
.94b7	20 3a 92	jsr $923a			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.94ba	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the result negative ?
.94bc	10 06		bpl $94c4			bpl 	_FACheckZero 				; if no, check for -0
.94be	20 0a 9e	jsr $9e0a			jsr 	NSMNegate 					; netate result
.94c1	20 11 9e	jsr $9e11			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.94c4					_FACheckZero:
.94c4	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero	 				; check for -0
.94c7	d0 1c		bne $94e5			bne 	_FAExit
.94c9	74 50		stz $50,x			stz 	NSStatus,x
.94cb	80 18		bra $94e5			bra 	_FAExit
.94cd					_FAReturn1:
.94cd	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.94cf	95 58		sta $58,x			sta 	NSMantissa0,x
.94d1	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.94d3	95 60		sta $60,x			sta 	NSMantissa1,x
.94d5	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.94d7	95 68		sta $68,x			sta 	NSMantissa2,x
.94d9	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.94db	95 70		sta $70,x			sta 	NSMantissa3,x
.94dd	b5 79		lda $79,x			lda 	NSExponent+1,x
.94df	95 78		sta $78,x			sta 	NSExponent,x
.94e1	b5 51		lda $51,x			lda 	NSStatus+1,x
.94e3	95 50		sta $50,x			sta 	NSStatus,x
.94e5					_FAExit:
.94e5	7a		ply				ply
.94e6	68		pla				pla
.94e7	60		rts				rts
.94e8					_FAShiftToExponent:
.94e8					_FAShiftToExponent2:
.94e8	98		tya				tya 								; compare Y to exponent
.94e9	d5 78		cmp $78,x			cmp 	NSExponent,x 				; reached the exponent required ?
.94eb	f0 07		beq $94f4			beq 	_FASEExit 					; exit if so.
.94ed	20 61 9e	jsr $9e61			jsr 	NSMShiftRight	 			; shift the mantissa right
.94f0	f6 78		inc $78,x			inc 	NSExponent,x 				; increment exponent
.94f2	80 f4		bra $94e8			bra 	_FAShiftToExponent2
.94f4					_FASEExit:
.94f4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.94f5					CompareFloat:
.94f5	20 6f 94	jsr $946f			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.94f8	b5 60		lda $60,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.94fa	29 f8		and #$f8			and 	#$F8
.94fc	15 68		ora $68,x			ora 	NSMantissa2,x
.94fe	15 70		ora $70,x			ora 	NSMantissa3,x
.9500	f0 08		beq $950a			beq 	_FCExit 					; zero, so approximately identical
.9502	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9504	34 50		bit $50,x			bit 	NSStatus,x
.9506	10 02		bpl $950a			bpl 	_FCExit
.9508					_FCNegative:
.9508	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.950a					_FCExit:
.950a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.950b					FDivideCommand:
.950b	fa		plx				plx	 								; restore stack position
.950c	20 dd 95	jsr $95dd			jsr 	FloatPrepare 				; prepare for floats
.950f					FloatDivide:
.950f	48		pha				pha
.9510	e8		inx				inx
.9511	20 ec 95	jsr $95ec			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9514	ca		dex				dex
.9515	c9 00		cmp #$00			cmp 	#0
.9517	f0 1d		beq $9536			beq 	_FDZero
.9519	20 ec 95	jsr $95ec			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.951c	f0 16		beq $9534			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.951e	20 11 91	jsr $9111			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.9521	20 ad 90	jsr $90ad			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9524	20 ec 95	jsr $95ec			jsr		NSNormalise 				; renormalise
.9527	20 a1 91	jsr $91a1			jsr 	CalculateSign 				; calculate result sign
.952a	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent
.952c	38		sec				sec
.952d	f5 79		sbc $79,x			sbc 	NSExponent+1,x
.952f	38		sec				sec
.9530	e9 1e		sbc #$1e			sbc 	#30
.9532	95 78		sta $78,x			sta 	NSExponent,x
.9534					_FDExit:
.9534	68		pla				pla
.9535	60		rts				rts
.9536					_FDZero:
.9536	a9 03		lda #$03		lda	#3
.9538	4c 26 8f	jmp $8f26		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.953b					FloatFractionalPart:
.953b	5a		phy				phy
.953c	b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.953e	29 7f		and #$7f			and 	#$7F
.9540	95 50		sta $50,x			sta 	NSStatus,x
.9542	20 ec 95	jsr $95ec			jsr 	NSNormalise
.9545	b5 78		lda $78,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9547	38		sec				sec
.9548	e9 e0		sbc #$e0			sbc 	#$E0
.954a	90 29		bcc $9575			bcc 	_FFPExit 					; already fractional
.954c	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.954e	b0 22		bcs $9572			bcs 	_FFPZero
.9550	a8		tay				tay 								; put count to do in Y
.9551	b5 70		lda $70,x			lda 	NSMantissa3,x 				; do each in turn.
.9553	20 77 95	jsr $9577			jsr 	_FFPPartial
.9556	95 70		sta $70,x			sta 	NSMantissa3,x
.9558	b5 68		lda $68,x			lda 	NSMantissa2,x
.955a	20 77 95	jsr $9577			jsr 	_FFPPartial
.955d	95 68		sta $68,x			sta 	NSMantissa2,x
.955f	b5 60		lda $60,x			lda 	NSMantissa1,x
.9561	20 77 95	jsr $9577			jsr 	_FFPPartial
.9564	95 60		sta $60,x			sta 	NSMantissa1,x
.9566	b5 58		lda $58,x			lda 	NSMantissa0,x
.9568	20 77 95	jsr $9577			jsr 	_FFPPartial
.956b	95 58		sta $58,x			sta 	NSMantissa0,x
.956d	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; zeroed check.
.9570	d0 03		bne $9575			bne 	_FFPExit
.9572					_FFPZero:
.9572	20 48 9e	jsr $9e48			jsr 	NSMSetZero
.9575					_FFPExit:
.9575	7a		ply				ply
.9576	60		rts				rts
.9577					_FFPPartial:
.9577	c0 00		cpy #$00			cpy 	#0 							; no more to do
.9579	f0 17		beq $9592			beq 	_FFFPPExit
.957b	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.957d	b0 0c		bcs $958b			bcs 	_FFFPPWholeByte
.957f	5a		phy				phy
.9580					_FFFPPLeft:
.9580	0a		asl a				asl 	a
.9581	88		dey				dey
.9582	d0 fc		bne $9580			bne 	_FFFPPLeft
.9584	7a		ply				ply
.9585					_FFFPPRight:
.9585	4a		lsr a				lsr 	a
.9586	88		dey				dey
.9587	d0 fc		bne $9585			bne 	_FFFPPRight
.9589	80 07		bra $9592			bra 	_FFFPPExit
.958b					_FFFPPWholeByte:
.958b	98		tya				tya 								; subtract 8 from count
.958c	38		sec				sec
.958d	e9 08		sbc #$08			sbc 	#8
.958f	a8		tay				tay
.9590	a9 00		lda #$00			lda 	#0 							; and clear all
.9592					_FFFPPExit:
.9592	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9593					FloatIntegerPart:
.9593	48		pha				pha
.9594	b5 78		lda $78,x			lda 	NSExponent,x 				; is it integer already ?
.9596	f0 1d		beq $95b5			beq 	_FIPExit 					; if so do nothing
.9598	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; is it zero ?
.959b	f0 15		beq $95b2			beq 	_FIPZero 					; if so return zero.
.959d	20 ec 95	jsr $95ec			jsr 	NSNormalise 				; normalise
.95a0	f0 10		beq $95b2			beq 	_FIPZero 					; normalised to zero, exit zero
.95a2					_FIPShift:
.95a2	b5 78		lda $78,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.95a4	10 07		bpl $95ad			bpl 	_FIPCheckZero
.95a6	20 61 9e	jsr $9e61			jsr 	NSMShiftRight 				; shift mantissa right
.95a9	f6 78		inc $78,x			inc 	NSExponent,x 				; bump exponent
.95ab	80 f5		bra $95a2			bra 	_FIPShift
.95ad					_FIPCheckZero:
.95ad	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; avoid -0 problem
.95b0	d0 03		bne $95b5			bne 	_FIPExit 					; set to zero if mantissa zero.
.95b2					_FIPZero:
.95b2	20 48 9e	jsr $9e48			jsr 	NSMSetZero
.95b5					_FIPExit:
.95b5	68		pla				pla
.95b6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.95b7					FloatingPointMultiply:
.95b7	20 dd 95	jsr $95dd			jsr 	FloatPrepare 				; prepare for floats
.95ba					FloatMultiply:
.95ba	48		pha				pha
.95bb	20 ec 95	jsr $95ec			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.95be	f0 18		beq $95d8			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.95c0	e8		inx				inx
.95c1	20 ec 95	jsr $95ec			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.95c4	ca		dex				dex
.95c5	c9 00		cmp #$00			cmp 	#0
.95c7	f0 0c		beq $95d5			beq 	_FDSetZero
.95c9	20 63 91	jsr $9163			jsr 	MultiplyShort 				; calculate the result.
.95cc	75 78		adc $78,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.95ce	18		clc				clc
.95cf	75 79		adc $79,x			adc 	NSExponent+1,x
.95d1	95 78		sta $78,x			sta 	NSExponent,x
.95d3	80 03		bra $95d8			bra 	_FDExit
.95d5					_FDSetZero:
.95d5	20 48 9e	jsr $9e48			jsr 	NSMSetZero 					; return 0
.95d8					_FDExit:
.95d8	20 ec 95	jsr $95ec			jsr 	NSNormalise 				; normalise the result
.95db	68		pla				pla
.95dc	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.95dd					FloatPrepare:
.95dd	20 e8 96	jsr $96e8			jsr 	DereferenceTopTwo 			; dereference the top two values
.95e0	b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.95e2	15 51		ora $51,x			ora 	NSStatus+1,x
.95e4	29 10		and #$10			and 	#NSBIsString
.95e6	d0 01		bne $95e9			bne 	_FDType
.95e8	60		rts				rts
.95e9					_FDType:
.95e9	4c d0 9f	jmp $9fd0			jmp 	TypeError
.95ec					NSNormalise:
.95ec	b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.95ee	29 80		and #$80			and 	#$80
.95f0	09 08		ora #$08			ora 	#NSTFloat
.95f2	95 50		sta $50,x			sta 	NSStatus,x
.95f4	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; if zero exit
.95f7	d0 07		bne $9600			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95f9	16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.95fb	76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.95fd	a9 00		lda #$00			lda 	#0 							; set Z flag
.95ff	60		rts				rts
.9600					_NSNormaliseOptimise:
.9600	b5 70		lda $70,x			lda 	NSMantissa3,x 				; upper byte zero ?
.9602	d0 19		bne $961d			bne 	_NSNormaliseLoop
.9604	b5 68		lda $68,x			lda 	NSMantissa2,x 				; byte normalise
.9606	30 15		bmi $961d			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9608	95 70		sta $70,x			sta 	NSMantissa3,x
.960a	b5 60		lda $60,x			lda 	NSMantissa1,x
.960c	95 68		sta $68,x			sta 	NSMantissa2,x
.960e	b5 58		lda $58,x			lda 	NSMantissa0,x
.9610	95 60		sta $60,x			sta 	NSMantissa1,x
.9612	74 58		stz $58,x			stz 	NSMantissa0,x
.9614	b5 78		lda $78,x			lda 	NSExponent,x
.9616	38		sec				sec
.9617	e9 08		sbc #$08			sbc 	#8
.9619	95 78		sta $78,x			sta 	NSExponent,x
.961b	80 e3		bra $9600			bra 	_NSNormaliseOptimise
.961d					_NSNormaliseLoop:
.961d	34 70		bit $70,x			bit 	NSMantissa3,x 				; bit 30 set ?
.961f	70 07		bvs $9628			bvs 	_NSNExit 					; exit if so with Z flag clear
.9621	20 57 9e	jsr $9e57			jsr 	NSMShiftLeft 				; shift mantissa left
.9624	d6 78		dec $78,x			dec 	NSExponent,x 				; adjust exponent
.9626	80 f5		bra $961d			bra 	_NSNormaliseLoop
.9628					_NSNExit:
.9628	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.962a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.962b					AssignNumber:
.962b	5a		phy				phy
.962c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.962e	85 36		sta $36				sta 	zTemp0
.9630	b5 60		lda $60,x			lda 	NSMantissa1,x
.9632	85 37		sta $37				sta 	zTemp0+1
.9634	b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9636	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9638	95 50		sta $50,x			sta 	NSStatus,x
.963a	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.963c	c9 08		cmp #$08			cmp 	#NSTFloat
.963e	f0 24		beq $9664			beq 	_ANFloat
.9640	b5 79		lda $79,x			lda		NSExponent+1,x 				; is it a float
.9642	f0 03		beq $9647			beq		_ANNotFloat
.9644	4c cb 9f	jmp $9fcb			jmp 	RangeError					; if it is, report an error.
.9647					_ANNotFloat:
.9647	b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.9649	29 03		and #$03			and 	#3
.964b	d0 05		bne $9652			bne 	_ANByteWord
.964d	20 6f 96	jsr $966f			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9650	80 1b		bra $966d			bra 	_ANExit
.9652					_ANByteWord:
.9652	48		pha				pha 								; save count
.9653	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; do byte
.9655	92 36		sta ($36)			sta 	(zTemp0)
.9657	68		pla				pla
.9658	c9 01		cmp #$01			cmp	 	#1
.965a	f0 11		beq $966d			beq 	_ANExit
.965c	b5 61		lda $61,x			lda 	NSMantissa1+1,x 			; do word
.965e	a0 01		ldy #$01			ldy 	#1
.9660	91 36		sta ($36),y			sta 	(zTemp0),y
.9662	80 09		bra $966d			bra 	_ANExit
.9664					_ANFloat:
.9664	20 6f 96	jsr $966f			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9667	b5 79		lda $79,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9669	a0 04		ldy #$04			ldy 	#4
.966b	91 36		sta ($36),y			sta 	(zTemp0),y
.966d					_ANExit:
.966d	7a		ply				ply
.966e	60		rts				rts
.966f					_ANCopy4PackSign:
.966f	a0 03		ldy #$03			ldy 	#3
.9671	b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.9673	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9675	15 71		ora $71,x			ora 	NSMantissa3+1,x
.9677	91 36		sta ($36),y			sta 	(zTemp0),y
.9679	88		dey				dey
.967a	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.967c	91 36		sta ($36),y			sta 	(zTemp0),y
.967e	88		dey				dey
.967f	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9681	91 36		sta ($36),y			sta 	(zTemp0),y
.9683	88		dey				dey
.9684	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9686	91 36		sta ($36),y			sta 	(zTemp0),y
.9688	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9689					AssignString:
.9689	5a		phy				phy
.968a	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.968c	85 38		sta $38				sta 	zTemp1
.968e	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9690	85 39		sta $39				sta 	zTemp1+1
.9692	b5 58		lda $58,x			lda 	NSMantissa0,x
.9694	85 36		sta $36				sta 	zTemp0
.9696	b5 60		lda $60,x			lda 	NSMantissa1,x
.9698	85 37		sta $37				sta 	zTemp0+1
.969a	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.969c	b1 36		lda ($36),y			lda 	(zTemp0),y
.969e	f0 23		beq $96c3			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.96a0	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.96a1	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.96a3	e9 02		sbc #$02			sbc 	#2
.96a5	85 3c		sta $3c				sta 	zsTemp
.96a7	a0 01		ldy #$01			ldy 	#1
.96a9	b1 36		lda ($36),y			lda 	(zTemp0),y
.96ab	e9 00		sbc #$00			sbc 	#0
.96ad	85 3d		sta $3d				sta 	zsTemp+1
.96af	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.96b1					_ASGetLength:
.96b1	c8		iny				iny
.96b2	b1 38		lda ($38),y			lda 	(zTemp1),y
.96b4	d0 fb		bne $96b1			bne 	_ASGetLength
.96b6	98		tya				tya 								; is this length <= current length
.96b7	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.96b9	90 1e		bcc $96d9			bcc 	_ASCopyString
.96bb	f0 1c		beq $96d9			beq 	_ASCopyString
.96bd	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.96bf	a0 01		ldy #$01			ldy 	#1
.96c1	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96c3					_ASNewStringRequired:
.96c3	e8		inx				inx 								; concrete the new string.
.96c4	20 4e a7	jsr $a74e			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.96c7	ca		dex				dex
.96c8	18		clc				clc
.96c9	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96cb	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96cd	92 36		sta ($36)			sta 	(zTemp0)
.96cf	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.96d1	69 00		adc #$00			adc 	#0
.96d3	a0 01		ldy #$01			ldy 	#1
.96d5	91 36		sta ($36),y			sta 	(zTemp0),y
.96d7	80 0d		bra $96e6			bra 	_ASExit
.96d9					_ASCopyString:
.96d9	a0 00		ldy #$00			ldy 	#0
.96db					_ASCopyLoop:
.96db	b1 38		lda ($38),y			lda 	(zTemp1),y
.96dd	c8		iny				iny
.96de	c8		iny				iny
.96df	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96e1	88		dey				dey
.96e2	c9 00		cmp #$00			cmp 	#0
.96e4	d0 f5		bne $96db			bne 	_ASCopyLoop
.96e6					_ASExit:
.96e6	7a		ply				ply
.96e7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96e8					DereferenceTopTwo:
.96e8	e8		inx				inx
.96e9	20 ed 96	jsr $96ed			jsr 	Dereference 				; deref x+1
.96ec	ca		dex				dex  								; falls through to deref x
.96ed					Dereference:
.96ed	b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.96ef	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.96f1	f0 48		beq $973b			beq 	_DRFExit 					; not a reference, so exit.
.96f3	5a		phy				phy
.96f4	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96f6	85 36		sta $36				sta 	zTemp0
.96f8	b5 60		lda $60,x			lda 	NSMantissa1,x
.96fa	85 37		sta $37				sta 	zTemp0+1
.96fc	74 60		stz $60,x			stz 	NSMantissa1,x 				; clear second byte.
.96fe	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.9700	95 58		sta $58,x			sta 	NSMantissa0,x
.9702	b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.9704	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9706	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9708	f0 0e		beq $9718			beq 	_DRFDereferenceTwo
.970a	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.970c	f0 2f		beq $973d			beq 	_DRFFull
.970e	b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9710	29 03		and #$03			and 	#3
.9712	f0 29		beq $973d			beq 	_DRFFull 					; the whole word
.9714	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9716	f0 06		beq $971e			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9718					_DRFDereferenceTwo:
.9718	a0 01		ldy #$01			ldy 	#1
.971a	b1 36		lda ($36),y			lda 	(zTemp0),y
.971c	95 60		sta $60,x			sta 	NSMantissa1,x
.971e					_DRFClear23:
.971e	74 68		stz $68,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9720	74 70		stz $70,x			stz 	NSMantissa3,x
.9722	b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.9724	29 18		and #$18			and 	#NSBTypeMask
.9726	95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9728	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.972a	d0 0e		bne $973a			bne 	_DRFNotString
.972c	b5 58		lda $58,x			lda 	NSMantissa0,x 				; check address is zero
.972e	15 60		ora $60,x			ora 	NSMantissa1,x
.9730	d0 08		bne $973a			bne 	_DRFNotString
.9732	a9 3c		lda #$3c			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9734	95 58		sta $58,x			sta 	NSMantissa0,X
.9736	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9738	95 60		sta $60,x			sta 	NSMantissa1,X
.973a					_DRFNotString
.973a	7a		ply				ply 								; restore Y and exit
.973b					_DRFExit:
.973b	60		rts				rts
.973c					_DRFNullString:
>973c	00						.byte 	0
.973d					_DRFFull:
.973d	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.973f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9741	95 60		sta $60,x			sta 	NSMantissa1,x
.9743	c8		iny				iny
.9744	b1 36		lda ($36),y			lda 	(zTemp0),y
.9746	95 68		sta $68,x			sta 	NSMantissa2,x
.9748	c8		iny				iny
.9749	b1 36		lda ($36),y			lda 	(zTemp0),y
.974b	95 70		sta $70,x			sta 	NSMantissa3,x
.974d	74 78		stz $78,x			stz 	NSExponent,x 				; clear exponent.
.974f	b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.9751	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9753	95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.9755	f0 05		beq $975c			beq 	_DRFNoExponent
.9757	c8		iny				iny 								; if not, read the exponent as well.
.9758	b1 36		lda ($36),y			lda 	(zTemp0),y
.975a	95 78		sta $78,x			sta 	NSExponent,x
.975c					_DRFNoExponent:
.975c	b5 70		lda $70,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.975e	10 0a		bpl $976a			bpl 	_DRFExit2 					; if not, then exit.
.9760	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9762	95 70		sta $70,x			sta 	NSMantissa3,x
.9764	b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9766	09 80		ora #$80			ora 	#NSBIsNegative
.9768	95 50		sta $50,x			sta 	NSStatus,x
.976a					_DRFExit2:
.976a	7a		ply				ply
.976b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.976c					EncodeNumberStart:
.976c	38		sec				sec
.976d	80 01		bra $9770			bra 	EncodeNumberContinue+1
.976f					EncodeNumberContinue:
.976f	18		clc				clc
.9770					EncodeNumber:
.9770	08		php				php 								; save reset flag.
.9771	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9773	f0 12		beq $9787			beq 	_ENIsOkay
.9775	c9 30		cmp #$30			cmp 	#"0"
.9777	90 04		bcc $977d			bcc 	_ENBadNumber
.9779	c9 3a		cmp #$3a			cmp 	#"9"+1
.977b	90 0a		bcc $9787			bcc 	_ENIsOkay
.977d					_ENBadNumber:
.977d	28		plp				plp 								; throw saved reset
.977e	ad 05 04	lda $0405			lda 	EncodeState 				; if in decimal mode, construct final number
.9781	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9783	f0 7b		beq $9800			beq 	_ENConstructFinal
.9785					_ENFail:
.9785	18		clc				clc 								; not allowed
.9786	60		rts				rts
.9787					_ENIsOkay:
.9787	28		plp				plp 								; are we restarting
.9788	90 15		bcc $979f			bcc 	_ENNoRestart
.978a					_ENStartEncode:
.978a	c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.978c	f0 0c		beq $979a			beq 	_ENFirstDP
.978e	29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.9790	20 4a 9e	jsr $9e4a			jsr 	NSMSetByte 					; in single byte mode.
.9793	a9 01		lda #$01			lda 	#ESTA_Low
.9795					_ENExitChange:
.9795	8d 05 04	sta $0405			sta 	EncodeState 				; save new state
.9798	38		sec				sec
.9799	60		rts				rts
.979a					_ENFirstDP:
.979a	20 48 9e	jsr $9e48			jsr 	NSMSetZero 					; clear integer part
.979d	80 3c		bra $97db			bra 	_ESTASwitchFloat			; go straight to float and exi
.979f					_ENNoRestart:
.979f	48		pha				pha 								; save digit or DP on stack.
.97a0	ad 05 04	lda $0405			lda 	EncodeState 				; get current state
.97a3	c9 01		cmp #$01			cmp 	#ESTA_Low
.97a5	f0 09		beq $97b0			beq  	_ESTALowState
.97a7	c9 02		cmp #$02			cmp 	#ESTA_High
.97a9	f0 26		beq $97d1			beq 	_ESTAHighState
.97ab	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.97ad	f0 38		beq $97e7			beq 	_ESTADecimalState
>97af	db						.byte 	$DB 						; causes a break in the emulator
.97b0					_ESTALowState:
.97b0	68		pla				pla 								; get value back
.97b1	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.97b3	f0 26		beq $97db			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.97b5	29 0f		and #$0f			and 	#15 						; make digit
.97b7	8d 06 04	sta $0406			sta 	DigitTemp 					; save it.
.97ba	b5 58		lda $58,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97bc	0a		asl a				asl 	a
.97bd	0a		asl a				asl 	a
.97be	75 58		adc $58,x			adc 	NSMantissa0,x
.97c0	0a		asl a				asl 	a
.97c1	6d 06 04	adc $0406			adc 	DigitTemp
.97c4	95 58		sta $58,x			sta 	NSMantissa0,x
.97c6	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97c8	90 05		bcc $97cf			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97ca	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97cc	8d 05 04	sta $0405			sta 	EncodeState
.97cf					_ESTANoSwitch:
.97cf	38		sec				sec
.97d0	60		rts				rts
.97d1					_ESTAHighState:
.97d1	68		pla				pla 								; get value back
.97d2	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97d4	f0 05		beq $97db			beq 	_ESTASwitchFloat
.97d6	20 34 98	jsr $9834			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97d9	38		sec				sec
.97da	60		rts				rts
.97db					_ESTASwitchFloat:
.97db	9c 07 04	stz $0407			stz 	DecimalCount 				; reset the count of digits - we divide by 10^n at the end.
.97de	e8		inx				inx 								; zero the decimal additive.
.97df	20 48 9e	jsr $9e48			jsr 	NSMSetZero
.97e2	ca		dex				dex
.97e3	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97e5	80 ae		bra $9795			bra 	_ENExitChange
.97e7					_ESTADecimalState:
.97e7	68		pla				pla 								; digit.
.97e8	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97ea	f0 99		beq $9785			beq 	_ENFail
.97ec	e8		inx				inx 								; put digit into fractional part of X+1
.97ed	20 34 98	jsr $9834			jsr 	ESTAShiftDigitIntoMantissa
.97f0	ca		dex				dex
.97f1	ee 07 04	inc $0407			inc 	DecimalCount 				; bump the count of decimals
.97f4	ad 07 04	lda $0407			lda 	DecimalCount 				; too many decimal digits.
.97f7	c9 0b		cmp #$0b			cmp 	#11
.97f9	f0 02		beq $97fd			beq 	_ESTADSFail
.97fb	38		sec				sec
.97fc	60		rts				rts
.97fd					_ESTADSFail:
.97fd	4c cb 9f	jmp $9fcb			jmp 	RangeError
.9800					_ENConstructFinal:
.9800	ad 07 04	lda $0407			lda 	DecimalCount 				; get decimal count
.9803	f0 2d		beq $9832			beq 	_ENCFExit 					; no decimals
.9805	5a		phy				phy
.9806	0a		asl a				asl 	a 							; x 4 and CLC
.9807	0a		asl a				asl 	a
.9808	6d 07 04	adc $0407			adc 	DecimalCount
.980b	a8		tay				tay
.980c	b9 8a 9f	lda $9f8a,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.980f	95 5a		sta $5a,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.9811	b9 8b 9f	lda $9f8b,y			lda 	DecimalScalarTable-5+1,y
.9814	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9816	b9 8c 9f	lda $9f8c,y			lda 	DecimalScalarTable-5+2,y
.9819	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.981b	b9 8d 9f	lda $9f8d,y			lda 	DecimalScalarTable-5+3,y
.981e	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9820	b9 8e 9f	lda $9f8e,y			lda 	DecimalScalarTable-5+4,y
.9823	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9825	a9 08		lda #$08			lda 	#NSTFloat
.9827	95 52		sta $52,x			sta 	NSStatus+2,x
.9829	7a		ply				ply
.982a	e8		inx				inx 								; multiply decimal const by decimal scalar
.982b	20 ba 95	jsr $95ba			jsr 	FloatMultiply
.982e	ca		dex				dex
.982f	20 75 94	jsr $9475			jsr 	FloatAdd 					; add to integer part.
.9832					_ENCFExit:
.9832	18		clc				clc 								; reject the digit.
.9833	60		rts				rts
.9834					ESTAShiftDigitIntoMantissa:
.9834	29 0f		and #$0f			and 	#15 						; save digit
.9836	48		pha				pha
.9837	b5 70		lda $70,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9839	48		pha				pha
.983a	b5 68		lda $68,x			lda 	NSMantissa2,x
.983c	48		pha				pha
.983d	b5 60		lda $60,x			lda 	NSMantissa1,x
.983f	48		pha				pha
.9840	b5 58		lda $58,x			lda 	NSMantissa0,x
.9842	48		pha				pha
.9843	20 57 9e	jsr $9e57			jsr 	NSMShiftLeft 				; x 2
.9846	20 57 9e	jsr $9e57			jsr 	NSMShiftLeft 				; x 4
.9849	18		clc				clc 								; pop mantissa and add
.984a	68		pla				pla
.984b	75 58		adc $58,x			adc 	NSMantissa0,x
.984d	95 58		sta $58,x			sta 	NSMantissa0,x
.984f	68		pla				pla
.9850	75 60		adc $60,x			adc 	NSMantissa1,x
.9852	95 60		sta $60,x			sta 	NSMantissa1,x
.9854	68		pla				pla
.9855	75 68		adc $68,x			adc 	NSMantissa2,x
.9857	95 68		sta $68,x			sta 	NSMantissa2,x
.9859	68		pla				pla
.985a	75 70		adc $70,x			adc 	NSMantissa3,x
.985c	95 70		sta $70,x			sta 	NSMantissa3,x 				; x 5
.985e	20 57 9e	jsr $9e57			jsr 	NSMShiftLeft 				; x 10
.9861	68		pla				pla 								; add digit
.9862	18		clc				clc
.9863	75 58		adc $58,x			adc 	NSMantissa0,x
.9865	95 58		sta $58,x			sta 	NSMantissa0,x
.9867	90 0a		bcc $9873			bcc 	_ESTASDExit
.9869	f6 60		inc $60,x			inc 	NSMantissa1,x
.986b	d0 06		bne $9873			bne 	_ESTASDExit
.986d	f6 68		inc $68,x			inc 	NSMantissa2,x
.986f	d0 02		bne $9873			bne 	_ESTASDExit
.9871	f6 70		inc $70,x			inc 	NSMantissa3,x
.9873					_ESTASDExit:
.9873	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9874					EvaluateTerm:
.9874	b1 30		lda ($30),y			lda 	(codePtr),y
.9876	30 18		bmi $9890			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9878	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.987a	b0 6c		bcs $98e8			bcs 	_ETVariable
.987c	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.987e	90 6b		bcc $98eb			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9880	c9 3a		cmp #$3a			cmp 	#'9'+1
.9882	b0 67		bcs $98eb			bcs 	_ETPuncUnary
.9884	20 6c 97	jsr $976c			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9887					_ETNumber:
.9887	c8		iny				iny 								; keep encoding until we have the numbers
.9888	b1 30		lda ($30),y			lda 	(codePtr),y
.988a	20 6f 97	jsr $976f			jsr 	EncodeNumberContinue
.988d	b0 f8		bcs $9887			bcs 	_ETNumber 					; go back if accepted.
.988f	60		rts				rts
.9890					_ETCheckUnary:
.9890	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9892	f0 3f		beq $98d3			beq 	_ETString
.9894	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9896	f0 12		beq $98aa			beq 	_ETHexConstant
.9898	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.989a	90 0b		bcc $98a7			bcc 	_ETSyntaxError
.989c	c9 a2		cmp #$a2			cmp 	#KWC_LAST_UNARY+1
.989e	b0 07		bcs $98a7			bcs 	_ETSyntaxError
.98a0	da		phx				phx 								; push X on the stack
.98a1	0a		asl a				asl 	a 							; put vector x 2 into X
.98a2	aa		tax				tax
.98a3	c8		iny				iny 								; consume unary function token
.98a4	7c 58 8c	jmp ($8c58,x)			jmp 	(VectorSet0,x) 				; and do it.
.98a7					_ETSyntaxError:
.98a7	4c c6 9f	jmp $9fc6			jmp 	SyntaxError
.98aa					_ETHexConstant:
.98aa	c8		iny				iny 								; skip #
.98ab	c8		iny				iny 								; skip count
.98ac	20 48 9e	jsr $9e48			jsr 	NSMSetZero 					; clear result
.98af					_ETHLoop:
.98af	b1 30		lda ($30),y			lda 	(codePtr),y
.98b1	c8		iny				iny 								; and consume
.98b2	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.98b4	f0 1c		beq $98d2			beq 	_ETHExit
.98b6	48		pha				pha 								; save on stack.
.98b7	20 57 9e	jsr $9e57			jsr 	NSMShiftLeft 				; x 2
.98ba	20 57 9e	jsr $9e57			jsr 	NSMShiftLeft 				; x 4
.98bd	20 57 9e	jsr $9e57			jsr 	NSMShiftLeft 				; x 8
.98c0	20 57 9e	jsr $9e57			jsr 	NSMShiftLeft 				; x 16
.98c3	68		pla				pla 								; ASCII
.98c4	c9 41		cmp #$41			cmp 	#'A'
.98c6	90 02		bcc $98ca			bcc 	_ETHNotChar
.98c8	e9 07		sbc #$07			sbc 	#7
.98ca					_ETHNotChar:
.98ca	29 0f		and #$0f			and 	#15 						; digit now
.98cc	15 58		ora $58,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98ce	95 58		sta $58,x			sta 	NSMantissa0,x
.98d0	80 dd		bra $98af			bra 	_ETHLoop 					; go round.
.98d2					_ETHExit:
.98d2	60		rts				rts
.98d3					_ETString:
.98d3	c8		iny				iny 								; look at length
.98d4	b1 30		lda ($30),y			lda 	(codePtr),y
.98d6	48		pha				pha
.98d7	c8		iny				iny 								; first character
.98d8	20 a4 a5	jsr $a5a4			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98db	68		pla				pla 								; restore count and save
.98dc	85 36		sta $36				sta 	zTemp0
.98de	98		tya				tya 								; add length to Y to skip it.
.98df	18		clc				clc
.98e0	65 36		adc $36				adc 	zTemp0
.98e2	a8		tay				tay
.98e3	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98e5	95 50		sta $50,x			sta 	NSStatus,x
.98e7	60		rts				rts
.98e8					_ETVariable:
.98e8	4c 3d 99	jmp $993d			jmp 	VariableHandler
.98eb					_ETPuncUnary:
.98eb	c8		iny				iny 								; consume the unary character
.98ec	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.98ee	f0 2b		beq $991b			beq 	_ETUnaryNegate
.98f0	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.98f2	f0 36		beq $992a			beq 	_ETDereference
.98f4	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.98f6	f0 3e		beq $9936			beq 	_ETParenthesis
.98f8	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.98fa	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.98fc	f0 06		beq $9904			beq 	_ETIndirection
.98fe	e6 36		inc $36				inc 	zTemp0
.9900	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9902	d0 a3		bne $98a7			bne 	_ETSyntaxError
.9904					_ETIndirection:
.9904	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9906	1a		inc a				inc 	a
.9907	48		pha				pha
.9908	20 74 98	jsr $9874			jsr 	EvaluateTerm				; evaluate the term
.990b	20 ed 96	jsr $96ed			jsr 	Dereference 				; dereference it.
.990e	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.9910	d0 06		bne $9918			bne 	_ETTypeMismatch
.9912	68		pla				pla 								; indirection 1-2
.9913	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9915	95 50		sta $50,x			sta 	NSStatus,x
.9917	60		rts				rts
.9918					_ETTypeMismatch:
.9918	4c d0 9f	jmp $9fd0			jmp 	TypeError
.991b					_ETUnaryNegate:
.991b	20 74 98	jsr $9874			jsr 	EvaluateTerm				; evaluate the term
.991e	20 ed 96	jsr $96ed			jsr 	Dereference 				; dereference it.
.9921	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.9923	29 10		and #$10			and 	#NSTString
.9925	d0 f1		bne $9918			bne 	_ETTypeMismatch
.9927	4c 0a 9e	jmp $9e0a			jmp 	NSMNegate  					; just toggles the sign bit.
.992a					_ETDereference:
.992a	20 74 98	jsr $9874			jsr 	EvaluateTerm				; evaluate the term
.992d	b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.992f	29 20		and #$20			and 	#NSBIsReference
.9931	f0 e5		beq $9918			beq 	_ETTypeMismatch
.9933	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9935	60		rts				rts
.9936					_ETParenthesis:
.9936	20 2a 94	jsr $942a			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9939	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket 			; check for )
.993c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.993d					VariableHandler:
.993d	b1 30		lda ($30),y			lda 	(codePtr),y
.993f	18		clc				clc
.9940	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9942	85 37		sta $37				sta 	zTemp0+1
.9944	c8		iny				iny
.9945	b1 30		lda ($30),y			lda 	(codePtr),y
.9947	85 36		sta $36				sta 	zTemp0
.9949	c8		iny				iny
.994a	18		clc				clc									; copy variable address+3 to mantissa
.994b	69 03		adc #$03			adc 	#3 							; this is the address of the data.
.994d	95 58		sta $58,x			sta 	NSMantissa0,x
.994f	a5 37		lda $37				lda 	zTemp0+1
.9951	69 00		adc #$00			adc 	#0
.9953	95 60		sta $60,x			sta 	NSMantissa1,x
.9955	74 68		stz $68,x			stz 	NSMantissa2,x
.9957	74 70		stz $70,x			stz 	NSMantissa3,x
.9959	74 78		stz $78,x			stz 	NSExponent,x
.995b	5a		phy				phy
.995c	a0 02		ldy #$02			ldy 	#2 							; read type
.995e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9960	7a		ply				ply
.9961	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9963	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9965	95 50		sta $50,x			sta 	NSStatus,x
.9967	29 04		and #$04			and 	#NSBIsArray
.9969	d0 01		bne $996c			bne 	_VHArray
.996b	60		rts				rts
.996c					_VHArray:
.996c	e8		inx				inx
.996d	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9970	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9972	95 51		sta $51,x			sta 	NSStatus+1,x
.9974	b1 30		lda ($30),y			lda 	(codePtr),y
.9976	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9978	d0 06		bne $9980			bne 	_VHNoSecondIndex
.997a	c8		iny				iny 								; skip the comma
.997b	e8		inx				inx
.997c	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.997f	ca		dex				dex
.9980					_VHNoSecondIndex:
.9980	ca		dex				dex 								; set X back.
.9981	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket 			; and check the right bracket.
.9984	5a		phy				phy 								; save position
.9985	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9987	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9989	f0 60		beq $99eb			beq 	_VHBadIndex
.998b	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.998d	85 3e		sta $3e				sta 	zaTemp
.998f	b5 60		lda $60,x			lda 	NSMantissa1,x
.9991	85 3f		sta $3f				sta 	zaTemp+1
.9993	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9995	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9997	f0 02		beq $999b			beq 	_VHHas2Mask
.9999	a9 ff		lda #$ff			lda 	#$FF
.999b					_VHHas2Mask:
.999b	d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.999d	f0 4c		beq $99eb			beq 	_VHBadIndex
.999f	0a		asl a				asl 	a 							; carry will be set if a second index
.99a0	90 08		bcc $99aa			bcc 	_VHCheckFirstIndex
.99a2	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.99a4	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99a6	d5 5a		cmp $5a,x			cmp 	NSMantissa0+2,x
.99a8	90 41		bcc $99eb			bcc 	_VHBadIndex
.99aa					_VHCheckFirstIndex:
.99aa	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.99ac	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99ae	d5 59		cmp $59,x			cmp 	NSMantissa0+1,x
.99b0	90 39		bcc $99eb			bcc 	_VHBadIndex
.99b2	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.99b4	64 37		stz $37				stz 	zTemp0+1
.99b6	b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99b8	30 0e		bmi $99c8			bmi 	_VHNoMultiply
.99ba	da		phx				phx
.99bb	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.99bd	48		pha				pha
.99be	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.99c0	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99c2	1a		inc a				inc 	a 							; add 1 for zero base
.99c3	fa		plx				plx
.99c4	20 f3 9d	jsr $9df3			jsr 	Multiply8x8 				; calculate -> Z0
.99c7	fa		plx				plx
.99c8					_VHNoMultiply:
.99c8	18		clc				clc
.99c9	a5 36		lda $36				lda 	zTemp0
.99cb	75 59		adc $59,x			adc 	NSMantissa0+1,x
.99cd	85 36		sta $36				sta 	zTemp0
.99cf	a5 37		lda $37				lda 	zTemp0+1
.99d1	69 00		adc #$00			adc 	#0
.99d3	85 37		sta $37				sta 	zTemp0+1
.99d5	b5 50		lda $50,x			lda 	NSStatus,x
.99d7	20 38 85	jsr $8538			jsr 	ScaleByBaseType
.99da	18		clc				clc
.99db	b2 3e		lda ($3e)			lda 	(zaTemp)
.99dd	65 36		adc $36				adc 	zTemp0
.99df	95 58		sta $58,x			sta 	NSMantissa0,x
.99e1	a0 01		ldy #$01			ldy 	#1
.99e3	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99e5	65 37		adc $37				adc 	zTemp0+1
.99e7	95 60		sta $60,x			sta 	NSMantissa1,x
.99e9	7a		ply				ply 								; restore position
.99ea	60		rts				rts
.99eb					_VHBadIndex:
.99eb	a9 17		lda #$17		lda	#23
.99ed	4c 26 8f	jmp $8f26		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.99f0					AbsUnary:
.99f0	fa		plx				plx 								; restore stack pos
.99f1	20 96 9d	jsr $9d96			jsr 	EvaluateNumber 				; get a float or int
.99f4	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.99f7	b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.99f9	29 7f		and #$7f			and 	#$7F
.99fb	95 50		sta $50,x			sta 	NSStatus,x
.99fd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.99fe					AllocUnary:
.99fe	fa		plx				plx 								; restore stack pos
.99ff	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger		; get bytes required.
.9a02	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.9a05	da		phx				phx 								; save X/Y
.9a06	5a		phy				phy
.9a07	8a		txa				txa 								; copy X into Y
.9a08	a8		tay				tay
.9a09	b9 60 00	lda $0060,y			lda		NSMantissa1,y 				; get size into XA
.9a0c	aa		tax				tax
.9a0d	b9 58 00	lda $0058,y			lda 	NSMantissa0,y
.9a10	20 1d 9a	jsr $9a1d			jsr 	AllocateXABytes 			; allocate memory
.9a13	99 58 00	sta $0058,y			sta 	NSMantissa0,y 				; write address out.
.9a16	8a		txa				txa 	 							; typing is 16 bit integer.
.9a17	99 60 00	sta $0060,y			sta 	NSMantissa1,y
.9a1a	7a		ply				ply
.9a1b	fa		plx				plx
.9a1c	60		rts				rts
.9a1d					AllocateXABytes:
.9a1d	5a		phy				phy
.9a1e	ac 0c 04	ldy $040c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a21	84 36		sty $36				sty 	zTemp0
.9a23	5a		phy				phy
.9a24	ac 0d 04	ldy $040d			ldy 	lowMemPtr+1
.9a27	84 37		sty $37				sty 	zTemp0+1
.9a29	5a		phy				phy
.9a2a	18		clc				clc 								; add to low memory pointer
.9a2b	6d 0c 04	adc $040c			adc 	lowMemPtr
.9a2e	8d 0c 04	sta $040c			sta 	lowMemPtr
.9a31	8a		txa				txa
.9a32	6d 0d 04	adc $040d			adc 	lowMemPtr+1
.9a35	8d 0d 04	sta $040d			sta 	lowMemPtr+1
.9a38	b0 2f		bcs $9a69			bcs 	CISSMemory
.9a3a	20 5b 9a	jsr $9a5b			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a3d					_ClearMemory:
.9a3d	ad 0c 04	lda $040c			lda 	lowMemPtr 					; cleared all memory allocated
.9a40	c5 36		cmp $36				cmp 	zTemp0
.9a42	d0 07		bne $9a4b			bne 	_CMClearNext
.9a44	ad 0d 04	lda $040d			lda 	lowMemPtr+1
.9a47	c5 37		cmp $37				cmp 	zTemp0+1
.9a49	f0 0c		beq $9a57			beq 	_CMExit
.9a4b					_CMClearNext:
.9a4b	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a4d	92 36		sta ($36)			sta 	(zTemp0)
.9a4f	e6 36		inc $36				inc 	zTemp0
.9a51	d0 ea		bne $9a3d			bne 	_ClearMemory
.9a53	e6 37		inc $37				inc		zTemp0+1
.9a55	80 e6		bra $9a3d			bra 	_ClearMemory
.9a57					_CMExit:
.9a57	fa		plx				plx
.9a58	68		pla				pla
.9a59	7a		ply				ply
.9a5a	60		rts				rts
.9a5b					CheckIdentifierStringSpace:
.9a5b	48		pha				pha
.9a5c	ad 0d 04	lda $040d			lda 	lowMemPtr+1 				; get low memory pointer
.9a5f	18		clc				clc
.9a60	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a62	cd 0f 04	cmp $040f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a65	b0 02		bcs $9a69			bcs 	CISSMemory
.9a67	68		pla				pla
.9a68	60		rts				rts
.9a69					CISSMemory:
.9a69	a9 06		lda #$06		lda	#6
.9a6b	4c 26 8f	jmp $8f26		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a6e					AscUnary:
.9a6e	fa		plx				plx 								; restore stack pos
.9a6f	20 a0 9d	jsr $9da0			jsr 	EvaluateString 				; get a string
.9a72	b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.9a74	20 4a 9e	jsr $9e4a			jsr 	NSMSetByte 					; ASC("") will return zero.
.9a77	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.9a7a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/deekpeek.asm

.9a7b					PeekUnary:
.9a7b	18		clc				clc
.9a7c	80 01		bra $9a7f			bra 	DPUnary
.9a7e					DeekUnary:
.9a7e	38		sec				sec
.9a7f					DPUnary:
.9a7f	fa		plx				plx 								; restore position.
.9a80	08		php				php									; save on stack, CS = Deek, CC = Peek
.9a81	20 c8 9d	jsr $9dc8			jsr		Evaluate16BitInteger 		; address as constant.
.9a84	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.9a87	28		plp				plp 								; function back.
.9a88	a9 21		lda #$21			lda 	#NSBIsReference+NSTInteger+1 ; 1 byte read
.9a8a	90 01		bcc $9a8d			bcc 	_DPUpdate
.9a8c	1a		inc a				inc 	a 							; 2 byte read
.9a8d					_DPUpdate:
.9a8d	95 50		sta $50,x			sta 	NSStatus,x 					; set to 1/2 byte reference.
.9a8f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9a90					FracUnary:
.9a90	fa		plx				plx 								; restore stack pos
.9a91	20 96 9d	jsr $9d96			jsr 	EvaluateNumber 				; get a float or int
.9a94	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.9a97	b5 50		lda $50,x			lda 	NSStatus,x
.9a99	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9a9b	f0 04		beq $9aa1			beq 	_IUZero
.9a9d	20 3b 95	jsr $953b			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.9aa0	60		rts				rts
.9aa1					_IUZero:
.9aa1	20 48 9e	jsr $9e48			jsr 	NSMSetZero
.9aa4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9aa5					IntUnary:
.9aa5	fa		plx				plx 								; restore stack pos
.9aa6	20 96 9d	jsr $9d96			jsr 	EvaluateNumber 				; get a float or int
.9aa9	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.9aac	b5 50		lda $50,x			lda 	NSStatus,x
.9aae	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9ab0	f0 03		beq $9ab5			beq 	_IUExit
.9ab2	20 93 95	jsr $9593			jsr 	FloatIntegerPart 			; if it is get the integer part.
.9ab5					_IUExit:
.9ab5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9ab6					LenUnary:
.9ab6	fa		plx				plx 								; restore stack pos
.9ab7	20 a0 9d	jsr $9da0			jsr 	EvaluateString 				; get a string
.9aba	5a		phy				phy
.9abb	a0 00		ldy #$00			ldy 	#0 							; find length
.9abd					_LenFind:
.9abd	b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.9abf	f0 06		beq $9ac7			beq 	_LenExit
.9ac1	c8		iny				iny
.9ac2	d0 f9		bne $9abd			bne 	_LenFind
.9ac4	4c cb 9f	jmp $9fcb			jmp 	RangeError 					; string > 255 - no trailing NULL.
.9ac7					_LenExit:
.9ac7	98		tya				tya		 							; return length
.9ac8	20 4a 9e	jsr $9e4a			jsr 	NSMSetByte
.9acb	7a		ply				ply
.9acc	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.9acf	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9ad0					Unary_Min:
.9ad0	a9 01		lda #$01			lda 	#1
.9ad2	80 02		bra $9ad6			bra 	UnaryMinMaxMain
.9ad4					Unary_Max:
.9ad4	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9ad6					UnaryMinMaxMain:
.9ad6	fa		plx				plx 								; get index on number stack
.9ad7	48		pha				pha 								; save comparator
.9ad8	20 8d 9d	jsr $9d8d			jsr 	EvaluateValue 				; get the first value.
.9adb					_UMMMLoop:
.9adb	b1 30		lda ($30),y			lda 	(codePtr),y
.9add	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9adf	f0 22		beq $9b03			beq 	_UMMMDone
.9ae1	20 15 8f	jsr $8f15			jsr 	CheckComma 					; must be a comma
.9ae4	e8		inx				inx
.9ae5	20 8d 9d	jsr $9d8d			jsr 	EvaluateValue
.9ae8	ca		dex				dex
.9ae9	20 2b 9e	jsr $9e2b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9aec	e8		inx				inx
.9aed	20 2b 9e	jsr $9e2b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9af0	e8		inx				inx
.9af1	20 dd 8f	jsr $8fdd			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9af4	ca		dex				dex
.9af5	ca		dex				dex
.9af6	85 36		sta $36				sta 	zTemp0 						; save required result
.9af8	68		pla				pla 								; get and save comparator
.9af9	48		pha				pha
.9afa	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9afc	d0 dd		bne $9adb			bne 	_UMMMLoop
.9afe	20 06 9b	jsr $9b06			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9b01	80 d8		bra $9adb			bra 	_UMMMLoop
.9b03					_UMMMDone:
.9b03	68		pla				pla 								; throw the comparator
.9b04	c8		iny				iny 								; skip )
.9b05	60		rts				rts
.9b06					ExpCopyAboveDown:
.9b06	b5 51		lda $51,x			lda 	NSStatus+1,x
.9b08	95 50		sta $50,x			sta 	NSStatus,x
.9b0a	b5 79		lda $79,x			lda 	NSExponent+1,x
.9b0c	95 78		sta $78,x			sta 	NSExponent,x
.9b0e	b5 59		lda $59,x			lda 	NSMantissa0+1,x
.9b10	95 58		sta $58,x			sta 	NSMantissa0,x
.9b12	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.9b14	95 60		sta $60,x			sta 	NSMantissa1,x
.9b16	b5 69		lda $69,x			lda 	NSMantissa2+1,x
.9b18	95 68		sta $68,x			sta 	NSMantissa2,x
.9b1a	b5 71		lda $71,x			lda 	NSMantissa3+1,x
.9b1c	95 70		sta $70,x			sta 	NSMantissa3,x
.9b1e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b1f					Unary_Not:
.9b1f	fa		plx				plx
.9b20	20 b5 9d	jsr $9db5			jsr 	EvaluateInteger 			; get integer
.9b23	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.9b26	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; zero mantissa ?
.9b29	f0 04		beq $9b2f			beq 	_NotZero
.9b2b	20 48 9e	jsr $9e48			jsr 	NSMSetZero
.9b2e	60		rts				rts
.9b2f					_NotZero:
.9b2f	4c 93 8f	jmp $8f93			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b32					Unary_Random:
.9b32	fa		plx				plx
.9b33	20 a4 9b	jsr $9ba4			jsr 	Random32Bit 				; get a random number
.9b36	20 8d 9b	jsr $9b8d			jsr 	URCopyToMantissa  			; put in mantissa
.9b39	b1 30		lda ($30),y			lda 	(codePtr),y
.9b3b	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b3d	f0 08		beq $9b47			beq 	_URNoModulus 				; then we return a random 30 bit number.
.9b3f	e8		inx				inx
.9b40	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b43	ca		dex				dex
.9b44	20 e5 90	jsr $90e5			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.9b47					_URNoModulus:
.9b47	74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.9b49	74 78		stz $78,x			stz 	NSExponent,x
.9b4b	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.9b4e	60		rts				rts
.9b4f					Unary_Rnd:
.9b4f	fa		plx				plx
.9b50	20 96 9d	jsr $9d96			jsr 	EvaluateNumber 				; number to use.
.9b53	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket 			; closing bracket
.9b56	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b59	f0 26		beq $9b81			beq 	_URCopySeed
.9b5b	b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b5d	10 1f		bpl $9b7e			bpl 	_URDontSeed
.9b5f	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b61	49 17		eor #$17			eor 	#$17
.9b63	8d 08 04	sta $0408			sta 	RandomSeed+0
.9b66	b5 60		lda $60,x			lda 	NSMantissa1,x
.9b68	49 a5		eor #$a5			eor 	#$A5
.9b6a	8d 09 04	sta $0409			sta 	RandomSeed+1
.9b6d	b5 68		lda $68,x			lda 	NSMantissa2,x
.9b6f	49 c2		eor #$c2			eor 	#$C2
.9b71	8d 0a 04	sta $040a			sta 	RandomSeed+2
.9b74	b5 70		lda $70,x			lda 	NSMantissa3,x
.9b76	49 9d		eor #$9d			eor 	#$9D
.9b78	8d 0b 04	sta $040b			sta 	RandomSeed+3
.9b7b	20 a4 9b	jsr $9ba4			jsr 	Random32Bit
.9b7e					_URDontSeed:
.9b7e	20 a4 9b	jsr $9ba4			jsr 	Random32Bit 				; generate a number
.9b81					_URCopySeed:
.9b81	20 8d 9b	jsr $9b8d			jsr 	URCopyToMantissa 			; copy into mantissa
.9b84	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9b86	95 78		sta $78,x			sta 	NSExponent,x
.9b88	a9 08		lda #$08			lda 	#NSTFloat
.9b8a	95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.9b8c	60		rts				rts
.9b8d					URCopyToMantissa:
.9b8d	ad 08 04	lda $0408			lda 	RandomSeed+0
.9b90	95 58		sta $58,x			sta 	NSMantissa0,x
.9b92	ad 09 04	lda $0409			lda 	RandomSeed+1
.9b95	95 60		sta $60,x			sta 	NSMantissa1,x
.9b97	ad 0a 04	lda $040a			lda 	RandomSeed+2
.9b9a	95 68		sta $68,x			sta 	NSMantissa2,x
.9b9c	ad 0b 04	lda $040b			lda 	RandomSeed+3
.9b9f	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9ba1	95 70		sta $70,x			sta 	NSMantissa3,x
.9ba3	60		rts				rts
.9ba4					Random32Bit:
.9ba4	5a		phy				phy
.9ba5	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9ba7	ad 08 04	lda $0408			lda 	RandomSeed+0 				; check the seed isn't zero
.9baa	d0 03		bne $9baf			bne 	_Random1
.9bac	a8		tay				tay 								; if so do it 256 times
.9bad	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9baf					_Random1:
.9baf	0a		asl a				asl 	a 							; LSFR RNG
.9bb0	2e 09 04	rol $0409			rol 	RandomSeed+1
.9bb3	2e 0a 04	rol $040a			rol 	RandomSeed+2
.9bb6	2e 0b 04	rol $040b			rol 	RandomSeed+3
.9bb9	90 02		bcc $9bbd			bcc 	_Random2
.9bbb	49 c5		eor #$c5			eor 	#$C5
.9bbd					_Random2:
.9bbd	88		dey				dey
.9bbe	d0 ef		bne $9baf			bne 	_Random1
.9bc0	8d 08 04	sta $0408			sta 	RandomSeed+0
.9bc3	7a		ply				ply
.9bc4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9bc5					SgnUnary:
.9bc5	fa		plx				plx 								; restore stack pos
.9bc6	20 96 9d	jsr $9d96			jsr 	EvaluateNumber 				; get a float or int
.9bc9	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.9bcc	20 6a 9e	jsr $9e6a			jsr 	NSMIsZero 					; if zero
.9bcf	f0 0e		beq $9bdf			beq 	_SGZero  					; return Int Zero
.9bd1	b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.9bd3	48		pha				pha
.9bd4	a9 01		lda #$01			lda 	#1 							; set to 1
.9bd6	20 4a 9e	jsr $9e4a			jsr 	NSMSetByte
.9bd9	68		pla				pla
.9bda	29 80		and #$80			and		#$80 						; copy the sign byte out
.9bdc	95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.9bde	60		rts				rts
.9bdf	20 48 9e	jsr $9e48	_SGZero:jsr 	NSMSetZero
.9be2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9be3					ValUnary:
.9be3	fa		plx				plx 								; restore stack pos
.9be4	20 f9 9b	jsr $9bf9			jsr 	ValMainCode 				; do the main val() code
.9be7	b0 01		bcs $9bea			bcs 	_VUError 					; couldn't convert
.9be9	60		rts				rts
.9bea					_VUError:
.9bea	4c d0 9f	jmp $9fd0			jmp 	TypeError
.9bed					IsValUnary:
.9bed	fa		plx				plx 								; restore stack pos
.9bee	20 f9 9b	jsr $9bf9			jsr 	ValMainCode 				; do the main val() code
.9bf1	b0 03		bcs $9bf6			bcs 	_VUBad
.9bf3	4c 93 8f	jmp $8f93			jmp 	ReturnTrue
.9bf6					_VUBad:
.9bf6	4c 9e 8f	jmp $8f9e			jmp 	ReturnFalse
.9bf9					ValMainCode:
.9bf9	20 a0 9d	jsr $9da0			jsr 	EvaluateString 				; get a string
.9bfc	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket 			; check right bracket present
.9bff					ValEvaluateZTemp0:
.9bff	5a		phy				phy
.9c00	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9c02	f0 17		beq $9c1b			beq 	_VMCFail2
.9c04	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9c06	48		pha				pha 								; save first character
.9c07	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.9c09	d0 01		bne $9c0c			bne 	_VMCStart
.9c0b	c8		iny				iny 								; skip over -
.9c0c					_VMCStart:
.9c0c	38		sec				sec 								; initialise first time round.
.9c0d					_VMCNext:
.9c0d	c8		iny				iny 								; pre-increment
.9c0e	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.9c10	f0 0c		beq $9c1e			beq 	_VMCSuccess 				; successful.
.9c12	20 70 97	jsr $9770			jsr 	EncodeNumber 				; send it to the number-builder
.9c15	90 03		bcc $9c1a			bcc 	_VMCFail 					; if failed, give up.
.9c17	18		clc				clc 								; next time round, countinue
.9c18	80 f3		bra $9c0d			bra 	_VMCNext
.9c1a					_VMCFail:
.9c1a	68		pla				pla
.9c1b					_VMCFail2:
.9c1b	7a		ply				ply
.9c1c	38		sec				sec
.9c1d	60		rts				rts
.9c1e					_VMCSuccess:
.9c1e	a9 00		lda #$00			lda 	#0 							; construct final
.9c20	20 70 97	jsr $9770			jsr 	EncodeNumber 				; by sending a duff value.
.9c23	68		pla				pla 								; if it was -ve
.9c24	c9 2d		cmp #$2d			cmp 	#"-"
.9c26	d0 03		bne $9c2b			bne 	_VMCNotNegative
.9c28	20 0a 9e	jsr $9e0a			jsr		NSMNegate 					; negate it.
.9c2b					_VMCNotNegative:
.9c2b	7a		ply				ply
.9c2c	18		clc				clc
.9c2d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c2e					ChrUnary:
.9c2e	fa		plx				plx 								; restore stack pos
.9c2f	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.9c32	48		pha				pha
.9c33	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.9c36	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c38	20 cb a7	jsr $a7cb			jsr 	StringTempAllocate
.9c3b	68		pla				pla 								; write number to it
.9c3c	20 04 a8	jsr $a804			jsr 	StringTempWrite
.9c3f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c40					SpcUnary:
.9c40	fa		plx				plx 								; restore stack pos
.9c41	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger			; get value
.9c44	5a		phy				phy
.9c45	48		pha				pha 								; save count
.9c46	20 cb a7	jsr $a7cb			jsr 	StringTempAllocate
.9c49	7a		ply				ply 								; to do count in Y
.9c4a					_SpcLoop:
.9c4a	c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.9c4c	f0 08		beq $9c56			beq 	_SpcExit
.9c4e	a9 20		lda #$20			lda 	#32
.9c50	20 04 a8	jsr $a804			jsr 	StringTempWrite
.9c53	88		dey				dey
.9c54	80 f4		bra $9c4a			bra 	_SPCLoop
.9c56					_SpcExit:
.9c56	7a		ply				ply
.9c57	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.9c5a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c5b					Unary_Str:
.9c5b	fa		plx				plx
.9c5c	20 96 9d	jsr $9d96			jsr 	EvaluateNumber  			; get number
.9c5f	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket 			; closing bracket
.9c62	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c64	20 7d 9c	jsr $9c7d			jsr 	ConvertNumberToString 		; do the conversion.
.9c67	a9 21		lda #$21			lda		#33 						; create buffer
.9c69	20 cb a7	jsr $a7cb			jsr 	StringTempAllocate 			; allocate memory
.9c6c	da		phx				phx  								; copy the converted string into the buffer.
.9c6d	a2 00		ldx #$00			ldx 	#0
.9c6f					_USCopy:
.9c6f	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c72	20 04 a8	jsr $a804			jsr 	StringTempWrite
.9c75	e8		inx				inx
.9c76	bd 49 06	lda $0649,x			lda 	DecimalBuffer,x
.9c79	d0 f4		bne $9c6f			bne 	_USCopy
.9c7b	fa		plx				plx
.9c7c	60		rts				rts
.9c7d					ConvertNumberToString:
.9c7d	5a		phy				phy 								; save code position
.9c7e	8d 14 04	sta $0414			sta 	DecimalPlaces	 			; save number of DPs.
.9c81	9c 15 04	stz $0415			stz 	dbOffset 					; offset into decimal buffer = start.
.9c84	b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.9c86	10 09		bpl $9c91			bpl 	_CNTSNotNegative
.9c88	29 7f		and #$7f			and 	#$7F 						; make +ve
.9c8a	95 50		sta $50,x			sta 	NSStatus,x
.9c8c	a9 2d		lda #$2d			lda 	#"-"
.9c8e	20 f2 9c	jsr $9cf2			jsr 	WriteDecimalBuffer
.9c91					_CNTSNotNegative:
.9c91	b5 78		lda $78,x			lda 	NSExponent,x 				; check if decimal
.9c93	f0 12		beq $9ca7			beq 	_CNTSNotFloat
.9c95	e8		inx				inx 								; round up so we don't get too many 6.999999
.9c96	a9 01		lda #$01			lda 	#1
.9c98	20 4a 9e	jsr $9e4a			jsr 	NSMSetByte
.9c9b	ca		dex				dex
.9c9c	b5 78		lda $78,x			lda		NSExponent,x
.9c9e	95 79		sta $79,x			sta 	NSExponent+1,x
.9ca0	a9 08		lda #$08			lda 	#NSTFloat
.9ca2	95 51		sta $51,x			sta 	NSStatus+1,x
.9ca4	20 75 94	jsr $9475			jsr 	FloatAdd
.9ca7					_CNTSNotFloat:
.9ca7	20 d4 9c	jsr $9cd4			jsr 	MakePlusTwoString 			; do the integer part.
.9caa	20 3b 95	jsr $953b			jsr 	FloatFractionalPart 		; get the fractional part
.9cad	20 ec 95	jsr $95ec			jsr 	NSNormalise					; normalise , exit if zero
.9cb0	f0 20		beq $9cd2			beq 	_CNTSExit
.9cb2	a9 2e		lda #$2e			lda 	#"."
.9cb4	20 f2 9c	jsr $9cf2			jsr 	WriteDecimalBuffer 			; write decimal place
.9cb7					_CNTSDecimal:
.9cb7	ce 14 04	dec $0414			dec 	DecimalPlaces 				; done all the decimals
.9cba	30 16		bmi $9cd2			bmi 	_CNTSExit
.9cbc	e8		inx				inx 								; x 10.0
.9cbd	a9 0a		lda #$0a			lda 	#10
.9cbf	20 4a 9e	jsr $9e4a			jsr 	NSMSetByte
.9cc2	a9 08		lda #$08			lda 	#NSTFloat
.9cc4	95 50		sta $50,x			sta 	NSStatus,x
.9cc6	ca		dex				dex
.9cc7	20 ba 95	jsr $95ba			jsr 	FloatMultiply
.9cca	20 d4 9c	jsr $9cd4			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.9ccd	20 3b 95	jsr $953b			jsr 	FloatFractionalPart 		; get the fractional part
.9cd0	80 e5		bra $9cb7			bra 	_CNTSDecimal 				; keep going.
.9cd2					_CNTSExit:
.9cd2	7a		ply				ply
.9cd3	60		rts				rts
.9cd4					MakePlusTwoString:
.9cd4	da		phx				phx
.9cd5	20 2b 9e	jsr $9e2b			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9cd8	e8		inx				inx 								; access it
.9cd9	e8		inx				inx
.9cda	20 93 95	jsr $9593			jsr 	FloatIntegerPart 			; make it an integer
.9cdd	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9cdf	20 a5 93	jsr $93a5			jsr 	ConvertInt32
.9ce2	a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.9ce4					_MPTSCopy:
.9ce4	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9ce7	20 f2 9c	jsr $9cf2			jsr 	WriteDecimalBuffer
.9cea	e8		inx				inx
.9ceb	bd 27 06	lda $0627,x			lda 	NumberBuffer,x
.9cee	d0 f4		bne $9ce4			bne 	_MPTSCopy
.9cf0	fa		plx				plx
.9cf1	60		rts				rts
.9cf2					WriteDecimalBuffer:
.9cf2	da		phx				phx
.9cf3	ae 15 04	ldx $0415			ldx 	dbOffset
.9cf6	9d 49 06	sta $0649,x			sta 	DecimalBuffer,x
.9cf9	9e 4a 06	stz $064a,x			stz 	DecimalBuffer+1,x
.9cfc	ee 15 04	inc $0415			inc 	dbOffset
.9cff	fa		plx				plx
.9d00	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9d01					Unary_Left:
.9d01	fa		plx				plx
.9d02	18		clc				clc 								; only one parameter
.9d03	20 66 9d	jsr $9d66			jsr 	SubstringInitial 			; set up.
.9d06	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9d08	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d0a	74 59		stz $59,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9d0c	80 25		bra $9d33			bra 	SubstringMain
.9d0e					Unary_Right:
.9d0e	fa		plx				plx
.9d0f	18		clc				clc 								; only one parameter
.9d10	20 66 9d	jsr $9d66			jsr 	SubstringInitial 			; set up.
.9d13	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; length => param 2
.9d15	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9d17	b5 78		lda $78,x			lda 	NSExponent,x 				; total length
.9d19	f5 59		sbc $59,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d1b	b0 02		bcs $9d1f			bcs 	_URNotUnderflow
.9d1d	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d1f					_URNotUnderFlow:
.9d1f	95 59		sta $59,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d21	80 10		bra $9d33			bra 	SubStringMain
.9d23					Unary_Mid:
.9d23	fa		plx				plx
.9d24	38		sec				sec 								; two parameters
.9d25	20 66 9d	jsr $9d66			jsr 	SubstringInitial 			; set up.
.9d28	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d2a	f0 04		beq $9d30			beq 	_UMError
.9d2c	d6 59		dec $59,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d2e	80 03		bra $9d33			bra 	SubStringMain
.9d30					_UMError:
.9d30	4c d5 9f	jmp $9fd5			jmp 	ArgumentError
.9d33					SubStringMain:
.9d33	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d35	d5 78		cmp $78,x			cmp 	NSExponent,x
.9d37	b0 27		bcs $9d60			bcs 	_SSMNull 					; if so, return an empty string.
.9d39	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d3b	f0 23		beq $9d60			beq 	_SSMNull 					; return empty string.
.9d3d	18		clc				clc 								; add the offset +1 to the address and
.9d3e	b5 58		lda $58,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.9d40	75 59		adc $59,x			adc 	NSMantissa0+1,x
.9d42	85 36		sta $36				sta 	zTemp0
.9d44	b5 60		lda $60,x			lda	 	NSMantissa1,x
.9d46	69 00		adc #$00			adc 	#0
.9d48	85 37		sta $37				sta 	zTemp0+1
.9d4a					_SSMNoCarry:
.9d4a	b5 5a		lda $5a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d4c	20 cb a7	jsr $a7cb			jsr 	StringTempAllocate 			; allocate that many characters
.9d4f	5a		phy				phy 								; save Y
.9d50	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9d52					_SSMCopy:
.9d52	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9d54	f0 08		beq $9d5e			beq 	_SSMEString 				; no more to copy
.9d56	20 04 a8	jsr $a804			jsr 	StringTempWrite 			; and write it out.
.9d59	c8		iny				iny
.9d5a	d6 5a		dec $5a,x			dec 	NSMantissa0+2,x
.9d5c	d0 f4		bne $9d52			bne 	_SSMCopy
.9d5e					_SSMEString:
.9d5e	7a		ply				ply
.9d5f					_SSMExit:
.9d5f	60		rts				rts
.9d60					_SSMNull:
.9d60	a9 00		lda #$00			lda 	#0
.9d62	20 cb a7	jsr $a7cb			jsr 	StringTempAllocate
.9d65	60		rts				rts
.9d66					SubstringInitial:
.9d66	da		phx				phx 								; save initial stack position
.9d67	08		php				php 								; save carry on stack indicating 2 parameters
.9d68	20 a0 9d	jsr $9da0			jsr 	EvaluateString 				; get a string
.9d6b	5a		phy				phy 								; calculate length to exponent.
.9d6c	a0 ff		ldy #$ff			ldy 	#$FF
.9d6e					_SIFindLength:
.9d6e	c8		iny				iny
.9d6f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9d71	d0 fb		bne $9d6e			bne 	_SIFindLength
.9d73	98		tya				tya
.9d74	95 78		sta $78,x			sta 	NSExponent,x
.9d76	7a		ply				ply
.9d77	e8		inx				inx
.9d78	20 15 8f	jsr $8f15			jsr 	CheckComma 					; comma next
.9d7b	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; get next parameter
.9d7e	28		plp				plp 								; is it the last parameter ?
.9d7f	90 07		bcc $9d88			bcc 	_SSIExit 					; if so, exit.
.9d81	e8		inx				inx
.9d82	20 15 8f	jsr $8f15			jsr 	CheckComma 					; comma next
.9d85	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; get last parameter
.9d88					_SSIExit:
.9d88	fa		plx				plx
.9d89	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket 			; check closing bracket
.9d8c	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9d8d					EvaluateValue:
.9d8d	48		pha				pha
.9d8e	20 2a 94	jsr $942a			jsr		EvaluateExpression 			; expression
.9d91	20 ed 96	jsr $96ed			jsr 	Dereference					; derefernce it
.9d94	68		pla				pla
.9d95	60		rts				rts
.9d96					EvaluateNumber:
.9d96	20 8d 9d	jsr $9d8d			jsr 	EvaluateValue 				; get a value
.9d99	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9d9b	29 10		and #$10			and 	#NSBIsString
.9d9d	d0 13		bne $9db2			bne 	HelperTypeError
.9d9f	60		rts				rts
.9da0					EvaluateString:
.9da0	20 8d 9d	jsr $9d8d			jsr 	EvaluateValue 				; get a value
.9da3	b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.9da5	29 10		and #$10			and 	#NSBIsString
.9da7	f0 09		beq $9db2			beq 	HelperTypeError
.9da9					CopyAddressToTemp0:
.9da9	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9dab	85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.9dad	b5 60		lda $60,x			lda 	NSMantissa1,x
.9daf	85 37		sta $37				sta 	zTemp0+1
.9db1	60		rts				rts
.9db2					HelperTypeError:
.9db2	4c d0 9f	jmp $9fd0			jmp 	TypeError
.9db5					EvaluateInteger:
.9db5	20 96 9d	jsr $9d96			jsr 	EvaluateNumber
.9db8	b5 78		lda $78,x			lda 	NSExponent,x 				; check exponent is zero
.9dba	d0 09		bne $9dc5			bne 	HelperValueError 			; if not, it's a float.
.9dbc	60		rts				rts
.9dbd					EvaluateUnsignedInteger:
.9dbd	20 b5 9d	jsr $9db5			jsr 	EvaluateInteger 			; check integer is +ve
.9dc0	b5 50		lda $50,x			lda 	NSStatus,x
.9dc2	30 01		bmi $9dc5			bmi 	HelperValueError
.9dc4	60		rts				rts
.9dc5					HelperValueError:
.9dc5	4c d5 9f	jmp $9fd5			jmp 	ArgumentError
.9dc8					Evaluate16BitInteger:
.9dc8	20 bd 9d	jsr $9dbd			jsr	 	EvaluateUnsignedInteger		; get integer
.9dcb	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9dcd	15 68		ora $68,x			ora 	NSMantissa2,x
.9dcf	d0 f4		bne $9dc5			bne 	HelperValueError
.9dd1	60		rts				rts
.9dd2					Evaluate16BitIntegerSigned:
.9dd2	20 b5 9d	jsr $9db5			jsr	 	EvaluateInteger				; get integer
.9dd5	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9dd7	15 68		ora $68,x			ora 	NSMantissa2,x
.9dd9	d0 ea		bne $9dc5			bne 	HelperValueError
.9ddb	b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.9ddd	10 03		bpl $9de2			bpl 	_EISNotSigned
.9ddf	20 11 9e	jsr $9e11			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.9de2					_EISNotSigned:
.9de2	60		rts				rts
.9de3					Evaluate8BitInteger:
.9de3	20 bd 9d	jsr $9dbd			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9de6	d0 dd		bne $9dc5			bne 	HelperValueError
.9de8	b5 70		lda $70,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9dea	15 68		ora $68,x			ora 	NSMantissa2,x
.9dec	15 60		ora $60,x			ora 	NSMantissa1,x
.9dee	d0 d5		bne $9dc5			bne 	HelperValueError
.9df0	b5 58		lda $58,x			lda 	NSMantissa0,x
.9df2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9df3					Multiply8x8:
.9df3	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9df4	85 36		sta $36			  	sta 	zTemp0
.9df6	86 37		stx $37				stx 	zTemp0+1
.9df8	a9 00		lda #$00			lda 	#0
.9dfa	a2 08		ldx #$08			ldx 	#8
.9dfc					_M88Loop:
.9dfc	90 03		bcc $9e01			bcc 	_M88NoAdd
.9dfe	18		clc				clc
.9dff	65 37		adc $37				adc 	zTemp0+1
.9e01					_M88NoAdd:
.9e01	6a		ror a				ror 	a
.9e02	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9e04	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9e05	d0 f5		bne $9dfc			bne 	_M88Loop
.9e07	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9e09	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9e0a					NSMNegate:
.9e0a	b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.9e0c	49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.9e0e	95 50		sta $50,x			sta 	NSStatus,x
.9e10	60		rts				rts
.9e11					NSMNegateMantissa:
.9e11	38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.9e12	a9 00		lda #$00			lda 	#0
.9e14	f5 58		sbc $58,x			sbc 	NSMantissa0,x
.9e16	95 58		sta $58,x			sta 	NSMantissa0,x
.9e18	a9 00		lda #$00			lda 	#0
.9e1a	f5 60		sbc $60,x			sbc 	NSMantissa1,x
.9e1c	95 60		sta $60,x			sta 	NSMantissa1,x
.9e1e	a9 00		lda #$00			lda 	#0
.9e20	f5 68		sbc $68,x			sbc 	NSMantissa2,x
.9e22	95 68		sta $68,x			sta 	NSMantissa2,x
.9e24	a9 00		lda #$00			lda 	#0
.9e26	f5 70		sbc $70,x			sbc 	NSMantissa3,x
.9e28	95 70		sta $70,x			sta 	NSMantissa3,x
.9e2a	60		rts				rts
.9e2b					NSMShiftUpTwo:
.9e2b	b5 58		lda $58,x			lda 	NSMantissa0,x
.9e2d	95 5a		sta $5a,x			sta 	NSMantissa0+2,x
.9e2f	b5 60		lda $60,x			lda 	NSMantissa1,x
.9e31	95 62		sta $62,x			sta 	NSMantissa1+2,x
.9e33	b5 68		lda $68,x			lda 	NSMantissa2,x
.9e35	95 6a		sta $6a,x			sta 	NSMantissa2+2,x
.9e37	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e39	95 72		sta $72,x			sta 	NSMantissa3+2,x
.9e3b	b5 78		lda $78,x			lda 	NSExponent,x
.9e3d	95 7a		sta $7a,x			sta 	NSExponent+2,x
.9e3f	b5 50		lda $50,x			lda 	NSStatus,x
.9e41	95 52		sta $52,x			sta 	NSStatus+2,x
.9e43	60		rts				rts
.9e44					NSMSetZeroMantissaOnly:
.9e44	a9 00		lda #$00			lda 	#0
.9e46	80 06		bra $9e4e			bra 	NSMSetMantissa
.9e48					NSMSetZero:
.9e48	a9 00		lda #$00			lda 	#0
.9e4a					NSMSetByte:
.9e4a	74 78		stz $78,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9e4c	74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.9e4e					NSMSetMantissa:
.9e4e	95 58		sta $58,x			sta 	NSMantissa0,x 				; mantissa
.9e50	74 60		stz $60,x			stz 	NSMantissa1,x
.9e52	74 68		stz $68,x			stz 	NSMantissa2,x
.9e54	74 70		stz $70,x			stz 	NSMantissa3,x
.9e56	60		rts				rts
.9e57					NSMShiftLeft:
.9e57	18		clc				clc
.9e58					NSMRotateLeft:
.9e58	36 58		rol $58,x			rol 	NSMantissa0,x
.9e5a	36 60		rol $60,x			rol		NSMantissa1,x
.9e5c	36 68		rol $68,x			rol		NSMantissa2,x
.9e5e	36 70		rol $70,x			rol		NSMantissa3,x
.9e60	60		rts				rts
.9e61					NSMShiftRight:
.9e61	56 70		lsr $70,x			lsr 	NSMantissa3,x
.9e63	76 68		ror $68,x			ror		NSMantissa2,x
.9e65	76 60		ror $60,x			ror		NSMantissa1,x
.9e67	76 58		ror $58,x			ror		NSMantissa0,x
.9e69	60		rts				rts
.9e6a					NSMIsZero:
.9e6a	b5 70		lda $70,x			lda 	NSMantissa3,x
.9e6c	15 68		ora $68,x			ora		NSMantissa2,x
.9e6e	15 60		ora $60,x			ora		NSMantissa1,x
.9e70	15 58		ora $58,x			ora		NSMantissa0,x
.9e72	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.9e73					TickHandler:
.9e73	5a		phy				phy 								; need to preserve Y
.9e74	20 1b 80	jsr $801b			jsr 	SNDUpdate 					; update sound
.9e77	7a		ply				ply
.9e78	60		rts				rts
.065b					LastTick:
>065b							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9e79					Assemble_ora:
.9e79	20 80 80	jsr $8080		jsr	AssembleGroup1
>9e7c	01					.byte $01
.9e7d					Assemble_and:
.9e7d	20 80 80	jsr $8080		jsr	AssembleGroup1
>9e80	21					.byte $21
.9e81					Assemble_eor:
.9e81	20 80 80	jsr $8080		jsr	AssembleGroup1
>9e84	41					.byte $41
.9e85					Assemble_adc:
.9e85	20 80 80	jsr $8080		jsr	AssembleGroup1
>9e88	61					.byte $61
.9e89					Assemble_sta:
.9e89	20 80 80	jsr $8080		jsr	AssembleGroup1
>9e8c	81					.byte $81
.9e8d					Assemble_lda:
.9e8d	20 80 80	jsr $8080		jsr	AssembleGroup1
>9e90	a1					.byte $a1
.9e91					Assemble_cmp:
.9e91	20 80 80	jsr $8080		jsr	AssembleGroup1
>9e94	c1					.byte $c1
.9e95					Assemble_sbc:
.9e95	20 80 80	jsr $8080		jsr	AssembleGroup1
>9e98	e1					.byte $e1
.9e99					Assemble_asl:
.9e99	20 87 80	jsr $8087		jsr	AssembleGroup2
>9e9c	02					.byte $02
>9e9d	75					.byte $75
.9e9e					Assemble_rol:
.9e9e	20 87 80	jsr $8087		jsr	AssembleGroup2
>9ea1	22					.byte $22
>9ea2	75					.byte $75
.9ea3					Assemble_lsr:
.9ea3	20 87 80	jsr $8087		jsr	AssembleGroup2
>9ea6	42					.byte $42
>9ea7	75					.byte $75
.9ea8					Assemble_ror:
.9ea8	20 87 80	jsr $8087		jsr	AssembleGroup2
>9eab	62					.byte $62
>9eac	75					.byte $75
.9ead					Assemble_stx:
.9ead	20 87 80	jsr $8087		jsr	AssembleGroup2
>9eb0	82					.byte $82
>9eb1	50					.byte $50
.9eb2					Assemble_ldx:
.9eb2	20 87 80	jsr $8087		jsr	AssembleGroup2
>9eb5	a2					.byte $a2
>9eb6	d0					.byte $d0
.9eb7					Assemble_dec:
.9eb7	20 87 80	jsr $8087		jsr	AssembleGroup2
>9eba	c2					.byte $c2
>9ebb	55					.byte $55
.9ebc					Assemble_inc:
.9ebc	20 87 80	jsr $8087		jsr	AssembleGroup2
>9ebf	e2					.byte $e2
>9ec0	55					.byte $55
.9ec1					Assemble_stz:
.9ec1	20 87 80	jsr $8087		jsr	AssembleGroup2
>9ec4	60					.byte $60
>9ec5	44					.byte $44
.9ec6					Assemble_bit:
.9ec6	20 87 80	jsr $8087		jsr	AssembleGroup2
>9ec9	20					.byte $20
>9eca	55					.byte $55
.9ecb					Assemble_sty:
.9ecb	20 87 80	jsr $8087		jsr	AssembleGroup2
>9ece	80					.byte $80
>9ecf	54					.byte $54
.9ed0					Assemble_ldy:
.9ed0	20 87 80	jsr $8087		jsr	AssembleGroup2
>9ed3	a0					.byte $a0
>9ed4	d5					.byte $d5
.9ed5					Assemble_cpy:
.9ed5	20 87 80	jsr $8087		jsr	AssembleGroup2
>9ed8	c0					.byte $c0
>9ed9	d4					.byte $d4
.9eda					Assemble_cpx:
.9eda	20 87 80	jsr $8087		jsr	AssembleGroup2
>9edd	e0					.byte $e0
>9ede	d0					.byte $d0
.9edf					Assemble_tsb:
.9edf	20 87 80	jsr $8087		jsr	AssembleGroup2
>9ee2	00					.byte $00
>9ee3	50					.byte $50
.9ee4					Assemble_trb:
.9ee4	20 87 80	jsr $8087		jsr	AssembleGroup2
>9ee7	10					.byte $10
>9ee8	50					.byte $50
.9ee9					Assemble_jsr:
.9ee9	20 87 80	jsr $8087		jsr	AssembleGroup2
>9eec	14					.byte $14
>9eed	10					.byte $10
.9eee					Assemble_jmp:
.9eee	20 87 80	jsr $8087		jsr	AssembleGroup2
>9ef1	40					.byte $40
>9ef2	10					.byte $10
.9ef3					Assemble_bpl:
.9ef3	20 d8 80	jsr $80d8		jsr	AssembleGroup3
>9ef6	10					.byte $10
.9ef7					Assemble_bmi:
.9ef7	20 d8 80	jsr $80d8		jsr	AssembleGroup3
>9efa	30					.byte $30
.9efb					Assemble_bvc:
.9efb	20 d8 80	jsr $80d8		jsr	AssembleGroup3
>9efe	50					.byte $50
.9eff					Assemble_bvs:
.9eff	20 d8 80	jsr $80d8		jsr	AssembleGroup3
>9f02	70					.byte $70
.9f03					Assemble_bcc:
.9f03	20 d8 80	jsr $80d8		jsr	AssembleGroup3
>9f06	90					.byte $90
.9f07					Assemble_bcs:
.9f07	20 d8 80	jsr $80d8		jsr	AssembleGroup3
>9f0a	b0					.byte $b0
.9f0b					Assemble_bne:
.9f0b	20 d8 80	jsr $80d8		jsr	AssembleGroup3
>9f0e	d0					.byte $d0
.9f0f					Assemble_beq:
.9f0f	20 d8 80	jsr $80d8		jsr	AssembleGroup3
>9f12	f0					.byte $f0
.9f13					Assemble_bra:
.9f13	20 d8 80	jsr $80d8		jsr	AssembleGroup3
>9f16	80					.byte $80
.9f17					Assemble_brk:
.9f17	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f1a	00					.byte $00
.9f1b					Assemble_php:
.9f1b	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f1e	08					.byte $08
.9f1f					Assemble_clc:
.9f1f	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f22	18					.byte $18
.9f23					Assemble_plp:
.9f23	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f26	28					.byte $28
.9f27					Assemble_sec:
.9f27	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f2a	38					.byte $38
.9f2b					Assemble_rti:
.9f2b	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f2e	40					.byte $40
.9f2f					Assemble_pha:
.9f2f	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f32	48					.byte $48
.9f33					Assemble_cli:
.9f33	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f36	58					.byte $58
.9f37					Assemble_phy:
.9f37	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f3a	5a					.byte $5a
.9f3b					Assemble_rts:
.9f3b	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f3e	60					.byte $60
.9f3f					Assemble_pla:
.9f3f	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f42	68					.byte $68
.9f43					Assemble_sei:
.9f43	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f46	78					.byte $78
.9f47					Assemble_ply:
.9f47	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f4a	7a					.byte $7a
.9f4b					Assemble_dey:
.9f4b	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f4e	88					.byte $88
.9f4f					Assemble_txa:
.9f4f	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f52	8a					.byte $8a
.9f53					Assemble_tya:
.9f53	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f56	98					.byte $98
.9f57					Assemble_txs:
.9f57	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f5a	9a					.byte $9a
.9f5b					Assemble_tay:
.9f5b	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f5e	a8					.byte $a8
.9f5f					Assemble_tax:
.9f5f	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f62	aa					.byte $aa
.9f63					Assemble_clv:
.9f63	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f66	b8					.byte $b8
.9f67					Assemble_tsx:
.9f67	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f6a	ba					.byte $ba
.9f6b					Assemble_iny:
.9f6b	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f6e	c8					.byte $c8
.9f6f					Assemble_dex:
.9f6f	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f72	ca					.byte $ca
.9f73					Assemble_cld:
.9f73	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f76	d8					.byte $d8
.9f77					Assemble_phx:
.9f77	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f7a	da					.byte $da
.9f7b					Assemble_stp:
.9f7b	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f7e	db					.byte $db
.9f7f					Assemble_inx:
.9f7f	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f82	e8					.byte $e8
.9f83					Assemble_nop:
.9f83	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f86	ea					.byte $ea
.9f87					Assemble_sed:
.9f87	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f8a	f8					.byte $f8
.9f8b					Assemble_plx:
.9f8b	20 0c 81	jsr $810c		jsr	AssembleGroup4
>9f8e	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.9f8f					DecimalScalarTable:
>9f8f	66 66 66 66				.dword $66666666 ; 0.1
>9f93	de					.byte $de
>9f94	1f 85 eb 51				.dword $51eb851f ; 0.01
>9f98	db					.byte $db
>9f99	4c 37 89 41				.dword $4189374c ; 0.001
>9f9d	d8					.byte $d8
>9f9e	ac 8b db 68				.dword $68db8bac ; 0.0001
>9fa2	d4					.byte $d4
>9fa3	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>9fa7	d1					.byte $d1
>9fa8	83 de 1b 43				.dword $431bde83 ; 1e-06
>9fac	ce					.byte $ce
>9fad	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>9fb1	ca					.byte $ca
>9fb2	89 3b e6 55				.dword $55e63b89 ; 1e-08
>9fb6	c7					.byte $c7
>9fb7	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>9fbb	c4					.byte $c4
>9fbc	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>9fc0	c0					.byte $c0
>9fc1	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>9fc5	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.9fc6					SyntaxError:
.9fc6	a9 02		lda #$02		lda	#2
.9fc8	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.9fcb					RangeError:
.9fcb	a9 04		lda #$04		lda	#4
.9fcd	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.9fd0					TypeError:
.9fd0	a9 05		lda #$05		lda	#5
.9fd2	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.9fd5					ArgumentError:
.9fd5	a9 07		lda #$07		lda	#7
.9fd7	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.9fda					NotDoneError:
.9fda	a9 0c		lda #$0c		lda	#12
.9fdc	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.9fdf					ErrorText:
>9fdf	42 72 65 61 6b 00			.text	"Break",0
>9fe5	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>9fed	72 72 6f 72 00
>9ff2	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>9ffa	20 62 79 20 7a 65 72 6f 00
>a003	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a00b	61 6e 67 65 00
>a010	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a018	6d 61 74 63 68 00
>a01e	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a026	65 6d 6f 72 79 00
>a02c	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a034	61 72 67 75 6d 65 6e 74 00
>a03d	53 74 6f 70 00				.text	"Stop",0
>a042	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a04a	6f 6f 20 6c 6f 6e 67 00
>a052	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a05a	6e 20 66 61 69 6c 65 64 00
>a063	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a06b	61 74 61 00
>a06f	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a077	65 6e 74 65 64 00
>a07d	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a085	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a091	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a099	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a0a6	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a0ae	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a0bb	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a0c3	68 6f 75 74 20 57 68 69 6c 65 00
>a0ce	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a0d6	68 6f 75 74 20 46 6f 72 00
>a0df	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a0e7	61 63 6b 20 66 75 6c 6c 00
>a0f0	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a0f8	75 63 74 75 72 65 00
>a0ff	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a107	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a114	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a11c	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a12a	41 72 72 61 79 20 73 69			.text	"Array size",0
>a132	7a 65 00
>a135	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a13d	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a145	52 65 6c 65 61 73 65 20			.text "Release Alpha 11 (05-Dec-22). "
>a14d	41 6c 70 68 61 20 31 31 20 28 30 35 2d 44 65 63
>a15d	2d 32 32 29 2e 20

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a163					RectangleCommand:
.a163	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a165	80 02		bra $a169			bra 	ShapeDrawCmd
.a167					CircleCommand:
.a167	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a169					ShapeDrawCmd:
.a169	20 f3 a1	jsr $a1f3			jsr 	RunGraphicsCommand
.a16c					ShapeDraw:
.a16c	0d 5d 06	ora $065d			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a16f	4c e7 a1	jmp $a1e7			jmp 	ExecuteGraphicCommand	 	; and complete
.a172					SpriteCommand:
.a172	a2 00		ldx #$00			ldx 	#0
.a174	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; get image number.
.a177	5a		phy				phy
.a178	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a17a	a6 58		ldx $58				ldx 	NSMantissa0
.a17c	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a17e	b0 0d		bcs $a18d			bcs 	_SCRange
.a180	a0 ff		ldy #$ff			ldy 	#255
.a182	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a185	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a187	7a		ply				ply
.a188	20 f3 a1	jsr $a1f3			jsr 	RunGraphicsCommand
.a18b	80 5a		bra $a1e7			bra 	ExecuteGraphicCommand
.a18d					_SCRange:
.a18d	4c cb 9f	jmp $9fcb			jmp 	RangeError
.a190					ImageCommand:
.a190	a2 00		ldx #$00			ldx 	#0
.a192	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; get image number.
.a195	20 f3 a1	jsr $a1f3			jsr 	RunGraphicsCommand
.a198					ImageRunDraw:
.a198	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a19a	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a19d	ad 63 06	lda $0663			lda 	gxDrawScale
.a1a0	0a		asl a				asl 	a
.a1a1	0a		asl a				asl 	a
.a1a2	0a		asl a				asl 	a
.a1a3	a8		tay				tay
.a1a4	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a1a6	a6 58		ldx $58				ldx 	NSMantissa0
.a1a8	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1ab	60		rts				rts
.a1ac					TextCommand:
.a1ac	a2 00		ldx #$00			ldx 	#0
.a1ae	20 a0 9d	jsr $9da0			jsr 	EvaluateString 				; get text
.a1b1	20 f3 a1	jsr $a1f3			jsr 	RunGraphicsCommand
.a1b4					TextRunDraw:
.a1b4	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a1b6	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1b9	a0 00		ldy #$00			ldy 	#0
.a1bb					_IRDLoop:
.a1bb	a5 60		lda $60				lda 	NSMantissa1 				; access character
.a1bd	85 37		sta $37				sta 	zTemp0+1
.a1bf	a5 58		lda $58				lda 	NSMantissa0
.a1c1	85 36		sta $36				sta 	zTemp0
.a1c3	b1 36		lda ($36),y			lda 	(zTemp0),y
.a1c5	f0 13		beq $a1da			beq 	_IRDExit
.a1c7	5a		phy				phy									; save string pos
.a1c8	48		pha				pha 								; save char
.a1c9	ad 63 06	lda $0663			lda 	gxDrawScale 				; get scale
.a1cc	0a		asl a				asl 	a
.a1cd	0a		asl a				asl 	a
.a1ce	0a		asl a				asl 	a
.a1cf	a8		tay				tay
.a1d0	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a1d2	fa		plx				plx 								; char to draw
.a1d3	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a1d6	7a		ply				ply 								; restore string pos
.a1d7	c8		iny				iny
.a1d8	90 e1		bcc $a1bb			bcc 	_IRDLoop 					; go back if no error.
.a1da					_IRDExit:
.a1da	60		rts				rts
.a1db					PlotCommand:
.a1db	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a1dd	20 f3 a1	jsr $a1f3			jsr 	RunGraphicsCommand
.a1e0	80 05		bra $a1e7			bra 	ExecuteGraphicCommand
.a1e2					LineCommand:
.a1e2	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a1e4	20 f3 a1	jsr $a1f3			jsr 	RunGraphicsCommand
.a1e7					ExecuteGraphicCommand:
.a1e7	0d 5c 06	ora $065c			ora 	gxCommandID 				; make a full command
.a1ea	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; draw it and exit
.a1ed	b0 01		bcs $a1f0			bcs 	_EGCError
.a1ef	60		rts				rts
.a1f0					_EGCError:
.a1f0	4c c6 9f	jmp $9fc6			jmp 	SyntaxError
.a1f3					RunGraphicsCommand:
.a1f3	8d 5c 06	sta $065c			sta 	gxCommandID					; save TODO graphics command.
.a1f6	68		pla				pla 								; pop handler address
.a1f7	fa		plx				plx
.a1f8	1a		inc a				inc 	a
.a1f9	d0 01		bne $a1fc			bne 	_RGINoCarry
.a1fb	e8		inx				inx
.a1fc					_RGINoCarry:
.a1fc	8d 61 06	sta $0661			sta 	GXHandler
.a1ff	8e 62 06	stx $0662			stx 	GXHandler+1
.a202					_RGICommandLoop:
.a202	b1 30		lda ($30),y			lda 	(codePtr),y
.a204	c8		iny				iny
.a205	c9 d2		cmp #$d2			cmp 	#KWD_TO						; is it TO x,y
.a207	f0 53		beq $a25c			beq 	_RGI_To
.a209	c9 bd		cmp #$bd			cmp 	#KWD_HERE 					; do it here.
.a20b	f0 55		beq $a262			beq 	_RGI_Here
.a20d	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a20f	f0 3d		beq $a24e			beq 	_RGI_Exit
.a211	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a213	f0 39		beq $a24e			beq 	_RGI_Exit
.a215	c9 c5		cmp #$c5			cmp 	#KWD_OUTLINE 				; solid or outline
.a217	f0 3e		beq $a257			beq 	_RGI_Frame
.a219	c9 ce		cmp #$ce			cmp 	#KWD_SOLID
.a21b	f0 33		beq $a250			beq 	_RGI_Solid
.a21d	c9 ad		cmp #$ad			cmp 	#KWD_BY 					; by offset
.a21f	f0 4b		beq $a26c			beq 	_RGI_By
.a221	c9 b9		cmp #$b9			cmp 	#KWD_FROM 					; from
.a223	f0 17		beq $a23c			beq 	_RGI_Move2
.a225	c9 b5		cmp #$b5			cmp 	#KWD_DIM 					; dim (set scale)
.a227	f0 62		beq $a28b			beq 	_RGI_Dim
.a229	c9 b3		cmp #$b3			cmp 	#KWD_COLOUR 				; colour or Color
.a22b	f0 74		beq $a2a1			beq 	_RGI_Colour
.a22d	c9 b2		cmp #$b2			cmp 	#KWD_COLOR
.a22f	f0 70		beq $a2a1			beq 	_RGI_Colour
.a231	ae 5c 06	ldx $065c			ldx 	gxCommandID
.a234	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a236	d0 03		bne $a23b			bne 	_RGI_Move 					; move
.a238	4c c9 a2	jmp $a2c9			jmp		_RGI_SpriteInstructions
.a23b					_RGI_Move:
.a23b	88		dey				dey 								; unpick get.
.a23c					_RGI_Move2:
.a23c	20 ef a2	jsr $a2ef			jsr 	GCGetCoordinatePair 		; move to here
.a23f	20 16 a3	jsr $a316			jsr 	GCCopyPairToStore 			; save
.a242	5a		phy				phy
.a243	20 0c a3	jsr $a30c			jsr 	GCLoadAXY 					; load in
.a246	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a248	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a24b	7a		ply				ply
.a24c	80 b4		bra $a202			bra 	_RGICommandLoop 			; and go round
.a24e					_RGI_Exit:
.a24e	88		dey				dey 								; unpick : / EOL
.a24f	60		rts				rts
.a250					_RGI_Solid:
.a250	a9 02		lda #$02			lda 	#2
.a252	8d 5d 06	sta $065d			sta 	gxFillSolid
.a255	80 ab		bra $a202			bra 	_RGICommandLoop
.a257					_RGI_Frame:
.a257	9c 5d 06	stz $065d			stz 	gxFillSolid
.a25a	80 a6		bra $a202			bra 	_RGICommandLoop
.a25c					_RGI_To:
.a25c	20 ef a2	jsr $a2ef			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a25f	20 16 a3	jsr $a316			jsr 	GCCopyPairToStore
.a262					_RGI_Here:
.a262	5a		phy				phy
.a263	20 0c a3	jsr $a30c			jsr 	GCLoadAXY 					; load it into AXY
.a266	20 c6 a2	jsr $a2c6			jsr 	_RGICallHandler 			; go do whatever it is.
.a269	7a		ply				ply
.a26a	80 96		bra $a202			bra 	_RGICommandLoop 			; and go round
.a26c					_RGI_By:
.a26c	20 fc a2	jsr $a2fc			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a26f	18		clc				clc
.a270	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a272	6d 5e 06	adc $065e			adc 	gxxPos
.a275	8d 5e 06	sta $065e			sta 	gxXPos
.a278	a5 61		lda $61				lda 	NSMantissa1+1
.a27a	6d 5f 06	adc $065f			adc 	gxxPos+1
.a27d	8d 5f 06	sta $065f			sta 	gxXPos+1
.a280	a5 5a		lda $5a				lda 	NSMantissa0+2
.a282	18		clc				clc
.a283	6d 60 06	adc $0660			adc 	gxYPos
.a286	8d 60 06	sta $0660			sta 	gxYPos
.a289	80 d7		bra $a262			bra 	_RGI_Here
.a28b					_RGI_Dim:
.a28b	a2 01		ldx #$01			ldx	 	#1
.a28d	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger
.a290	a5 59		lda $59				lda 	NSMantissa0+1
.a292	c9 00		cmp #$00			cmp 	#0
.a294	f0 2d		beq $a2c3			beq 	_RGIRange
.a296	c9 09		cmp #$09			cmp 	#8+1
.a298	b0 29		bcs $a2c3			bcs		_RGIRange
.a29a	3a		dec a				dec 	a
.a29b	8d 63 06	sta $0663			sta 	gxDrawScale
.a29e	4c 02 a2	jmp $a202			jmp 	_RGICommandLoop
.a2a1					_RGI_Colour:
.a2a1	a2 01		ldx #$01			ldx 	#1 							; colour
.a2a3	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger
.a2a6	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a2a8	20 48 9e	jsr $9e48			jsr 	NSMSetZero
.a2ab	b1 30		lda ($30),y			lda 	(codePtr),y
.a2ad	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a2af	d0 04		bne $a2b5			bne 	_RGICDefaultMode
.a2b1	c8		iny				iny
.a2b2	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger
.a2b5					_RGICDefaultMode:
.a2b5	5a		phy				phy
.a2b6	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a2b8	a6 59		ldx $59				ldx 	NSMantissa0+1
.a2ba	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a2bc	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2bf	7a		ply				ply
.a2c0	4c 02 a2	jmp $a202			jmp 	_RGICommandLoop 			; and go round
.a2c3					_RGIRange:
.a2c3	4c cb 9f	jmp $9fcb			jmp 	RangeError
.a2c6					_RGICallHandler:
.a2c6	6c 61 06	jmp ($0661)			jmp 	(GXHandler)
.a2c9					_RGI_SpriteInstructions:
.a2c9	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a2cb	f0 07		beq $a2d4			beq 	_RGISpriteOff
.a2cd	c9 be		cmp #$be			cmp 	#KWD_IMAGE
.a2cf	f0 13		beq $a2e4			beq 	_RGISetImage
.a2d1	4c 3b a2	jmp $a23b			jmp 	_RGI_Move
.a2d4					_RGISpriteOff:
.a2d4	5a		phy				phy
.a2d5	a0 01		ldy #$01			ldy 	#1
.a2d7	a2 00		ldx #$00			ldx 	#0
.a2d9					_RGIDoCommandLoop:
.a2d9	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a2db	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a2de	7a		ply				ply
.a2df	b0 e2		bcs $a2c3			bcs 	_RGIRange
.a2e1	4c 02 a2	jmp $a202			jmp 	_RGICommandLoop
.a2e4					_RGISetImage:
.a2e4	a2 01		ldx #$01			ldx 	#1
.a2e6	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger
.a2e9	5a		phy				phy
.a2ea	aa		tax				tax
.a2eb	a0 00		ldy #$00			ldy 	#0
.a2ed	80 ea		bra $a2d9			bra 	_RGIDoCommandLoop
.a2ef					GCGetCoordinatePair:
.a2ef	a2 01		ldx #$01			ldx 	#1
.a2f1	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger
.a2f4	20 15 8f	jsr $8f15			jsr 	CheckComma
.a2f7	e8		inx				inx
.a2f8	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger
.a2fb	60		rts				rts
.a2fc					GCSignedCoordinatePair:
.a2fc	a2 01		ldx #$01			ldx 	#1
.a2fe	20 d2 9d	jsr $9dd2			jsr 	Evaluate16BitIntegerSigned
.a301	20 15 8f	jsr $8f15			jsr 	CheckComma
.a304	e8		inx				inx
.a305	20 d2 9d	jsr $9dd2			jsr 	Evaluate16BitIntegerSigned
.a308	60		rts				rts
.a309					_GCCPRange:
.a309	4c cb 9f	jmp $9fcb			jmp 	RangeError
.a30c					GCLoadAXY:
.a30c	ad 5f 06	lda $065f			lda 	gxXPos+1
.a30f	ae 5e 06	ldx $065e			ldx 	gxXPos
.a312	ac 60 06	ldy $0660			ldy 	gxYPos
.a315	60		rts				rts
.a316					GCCopyPairToStore:
.a316	a5 59		lda $59				lda 	NSMantissa0+1 				; copy it into space.
.a318	8d 5e 06	sta $065e			sta 	gxXPos
.a31b	a5 61		lda $61				lda 	NSMantissa1+1
.a31d	8d 5f 06	sta $065f			sta 	gxXPos+1
.a320	a5 5a		lda $5a				lda 	NSMantissa0+2
.a322	8d 60 06	sta $0660			sta 	gxYPos
.a325	60		rts				rts
.065c					gxCommandID:
>065c							.fill 	1
.065d					gxFillSolid:
>065d							.fill 	1
.065e					gxXPos:
>065e							.fill 	2
.0660					gxYPos:
>0660							.fill 	1
.0661					gxHandler:
>0661							.fill 	2
.0663					gxDrawScale:
>0663							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a326					BitmapCtrl:
.a326	b1 30		lda ($30),y			lda 	(codePtr),y
.a328	c8		iny				iny
.a329	a2 01		ldx #$01			ldx 	#1
.a32b	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a32d	f0 11		beq $a340			beq 	BitmapSwitch
.a32f	ca		dex				dex
.a330	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a332	f0 0c		beq $a340			beq 	BitmapSwitch
.a334	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; get the colour
.a337	5a		phy				phy
.a338	aa		tax				tax
.a339	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a33b	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a33e	7a		ply				ply
.a33f	60		rts				rts
.a340					BitmapSwitch:
.a340	5a		phy				phy
.a341	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a343	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a345	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a348	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a34a	a0 00		ldy #$00			ldy 	#0
.a34c	a2 ff		ldx #$ff			ldx 	#$FF
.a34e	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a351	9c 5d 06	stz $065d			stz 	gxFillSolid
.a354	9c 5e 06	stz $065e			stz 	gxXPos
.a357	9c 5f 06	stz $065f			stz 	gxXPos+1
.a35a	9c 60 06	stz $0660			stz 	gxYPos
.a35d	9c 63 06	stz $0663			stz 	gxDrawScale
.a360	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a362	a2 00		ldx #$00			ldx 	#0
.a364	a0 00		ldy #$00			ldy 	#0
.a366	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a369	7a		ply				ply
.a36a	60		rts				rts
.a36b					SpritesCtrl:
.a36b	b1 30		lda ($30),y			lda 	(codePtr),y
.a36d	c8		iny				iny
.a36e	a2 01		ldx #$01			ldx 	#1
.a370	c9 c4		cmp #$c4			cmp 	#KWD_ON
.a372	f0 08		beq $a37c			beq 	SpriteSwitch
.a374	ca		dex				dex
.a375	c9 c3		cmp #$c3			cmp 	#KWD_OFF
.a377	f0 03		beq $a37c			beq 	SpriteSwitch
.a379	4c c6 9f	jmp $9fc6			jmp 	SyntaxError
.a37c					SpriteSwitch:
.a37c	5a		phy				phy
.a37d	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a37f	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a381	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a384	7a		ply				ply
.a385	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a386					GfxCommand:
.a386	a2 00		ldx #$00			ldx 	#0
.a388	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; command
.a38b	20 15 8f	jsr $8f15			jsr 	CheckComma
.a38e	e8		inx				inx
.a38f	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger 		; X
.a392	20 15 8f	jsr $8f15			jsr 	CheckComma
.a395	e8		inx				inx
.a396	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; Y
.a399	a5 61		lda $61				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a39b	4a		lsr a				lsr 	a
.a39c	d0 12		bne $a3b0			bne 	_GfxError
.a39e	26 58		rol $58				rol 	NSMantissa0 				; rotate into command
.a3a0	b0 0e		bcs $a3b0			bcs 	_GfxError 					; bit 7 should have been zero
.a3a2	5a		phy				phy 								; save pos
.a3a3	a5 58		lda $58				lda 	NSMantissa0 				; do the command
.a3a5	a6 59		ldx $59				ldx 	NSMantissa0+1
.a3a7	a4 5a		ldy $5a				ldy 	NSMantissa0+2
.a3a9	20 15 80	jsr $8015			jsr 	GXGraphicDraw
.a3ac	b0 02		bcs $a3b0			bcs 	_GfxError
.a3ae	7a		ply				ply 								; restore pos and exit.
.a3af	60		rts				rts
.a3b0					_GfxError:
.a3b0	4c cb 9f	jmp $9fcb			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a3b3					UnaryHit:
.a3b3	fa		plx				plx
.a3b4	a9 36		lda #$36			lda 	#zTemp0
.a3b6	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a3b9	20 15 8f	jsr $8f15			jsr 	CheckComma
.a3bc	e8		inx				inx
.a3bd	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a3c0	20 0d 8f	jsr $8f0d			jsr		CheckRightBracket
.a3c3	ca		dex				dex 								; fix back up again.
.a3c4	da		phx				phx 								; save X/Y
.a3c5	5a		phy				phy
.a3c6	b4 59		ldy $59,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a3c8	b5 58		lda $58,x			lda 	NSMantissa0,x
.a3ca	aa		tax				tax
.a3cb	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a3cd	20 15 80	jsr $8015			jsr 	GXGraphicDraw 				; calculate result
.a3d0	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a3d1	7a		ply				ply 								; restore XY
.a3d2	fa		plx				plx
.a3d3	20 4a 9e	jsr $9e4a			jsr 	NSMSetByte 					; return the hit result
.a3d6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a3d7					PaletteCommand:
.a3d7	a2 00		ldx #$00			ldx 	#0
.a3d9	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; colour
.a3dc	20 15 8f	jsr $8f15			jsr 	CheckComma
.a3df	e8		inx				inx
.a3e0	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger 		; r
.a3e3	20 15 8f	jsr $8f15			jsr 	CheckComma
.a3e6	e8		inx				inx
.a3e7	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; g
.a3ea	20 15 8f	jsr $8f15			jsr 	CheckComma
.a3ed	e8		inx				inx
.a3ee	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; b
.a3f1	a5 58		lda $58				lda 	NSMantissa0 				; get colour #
.a3f3	85 36		sta $36				sta 	zTemp0
.a3f5	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a3f7	85 37		sta $37				sta 	zTemp0+1
.a3f9	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a3fb	26 37		rol $37				rol	 	zTemp0+1
.a3fd	06 36		asl $36				asl 	zTemp0
.a3ff	26 37		rol $37				rol	 	zTemp0+1
.a401	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a403	85 01		sta $01				sta 	1
.a405	5a		phy				phy
.a406	a5 5b		lda $5b				lda 	NSMantissa0+3 				; fix to r,g,b
.a408	92 36		sta ($36)			sta 	(zTemp0)
.a40a	a0 01		ldy #$01			ldy 	#1
.a40c	a5 5a		lda $5a				lda 	NSMantissa0+2
.a40e	91 36		sta ($36),y			sta 	(zTemp0),y
.a410	a5 59		lda $59				lda 	NSMantissa0+1
.a412	c8		iny				iny
.a413	91 36		sta ($36),y			sta 	(zTemp0),y
.a415	7a		ply				ply
.a416	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a417					UnaryEvent:
.a417	fa		plx				plx
.a418	20 c5 a4	jsr $a4c5			jsr 	TimerToStackX 				; timer in +0
.a41b	e8		inx				inx  								; put reference into +1
.a41c	20 74 98	jsr $9874			jsr 	EvaluateTerm
.a41f	b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.a421	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a423	d0 4c		bne $a471			bne 	_UEType
.a425	e8		inx				inx 								; put the step in +2
.a426	20 15 8f	jsr $8f15			jsr 	CheckComma
.a429	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger
.a42c	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.a42f	ca		dex				dex
.a430	ca		dex				dex
.a431	b5 59		lda $59,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a433	85 36		sta $36				sta 	zTemp0
.a435	b5 61		lda $61,x			lda 	NSMantissa1+1,x
.a437	85 37		sta $37				sta 	zTemp0+1
.a439	5a		phy				phy
.a43a	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a43c	b1 36		lda ($36),y			lda 	(zTemp0),y
.a43e	30 2d		bmi $a46d			bmi 	_UEFalse 					; exit if signed.
.a440	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a442	b5 58		lda $58,x			lda 	NSMantissa0,x
.a444	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a446	c8		iny				iny
.a447	b5 60		lda $60,x			lda 	NSMantissa1,x
.a449	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a44b	c8		iny				iny
.a44c	b5 68		lda $68,x			lda 	NSMantissa2,x
.a44e	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a450	90 1b		bcc $a46d			bcc 	_UEFalse 					; no, return FALSE.
.a452	18		clc				clc
.a453	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a455	b5 58		lda $58,x			lda 	NSMantissa0,x
.a457	75 5a		adc $5a,x			adc 	NSMantissa0+2,x
.a459	91 36		sta ($36),y			sta 	(zTemp0),y
.a45b	c8		iny				iny
.a45c	b5 60		lda $60,x			lda 	NSMantissa1,x
.a45e	75 62		adc $62,x			adc 	NSMantissa1+2,x
.a460	91 36		sta ($36),y			sta 	(zTemp0),y
.a462	c8		iny				iny
.a463	b5 68		lda $68,x			lda 	NSMantissa2,x
.a465	75 6a		adc $6a,x			adc 	NSMantissa2+2,x
.a467	91 36		sta ($36),y			sta 	(zTemp0),y
.a469	7a		ply				ply
.a46a	4c 93 8f	jmp $8f93			jmp 	ReturnTrue
.a46d					_UEFalse:
.a46d	7a		ply				ply 								; restore Y
.a46e	4c 9e 8f	jmp $8f9e			jmp 	ReturnFalse 				; and return False
.a471					_UEType:
.a471	4c d0 9f	jmp $9fd0			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a474					UnaryJoyX:
.a474	18		clc				clc
.a475	80 01		bra $a478			bra 	JoyMain
.a477					UnaryJoyY:
.a477	38		sec				sec
.a478					JoyMain:
.a478	fa		plx				plx 								; get pos
.a479	08		php				php 								; save carry (set for Y)
.a47a	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a47d	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.a480	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a483	28		plp				plp
.a484	90 02		bcc $a488			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a486	4a		lsr a				lsr 	a
.a487	4a		lsr a				lsr 	a
.a488					_JMNoShift:
.a488	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a489	b0 0a		bcs $a495			bcs 	_JMIsRight
.a48b	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a48c	b0 04		bcs $a492			bcs 	_JMIsLeft
.a48e	20 48 9e	jsr $9e48			jsr 	NSMSetZero 					; zero result
.a491	60		rts				rts
.a492					_JMIsLeft:
.a492	4c 93 8f	jmp $8f93			jmp 	ReturnTrue
.a495					_JMIsRight:
.a495	a9 01		lda #$01			lda 	#1
.a497	20 4a 9e	jsr $9e4a			jsr 	NSMSetByte
.a49a	60		rts				rts
.a49b					UnaryJoyB:
.a49b	fa		plx				plx 								; get pos
.a49c	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a49f	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.a4a2	20 0f 80	jsr $800f			jsr 	EXTReadController 			; read the controller.
.a4a5	4a		lsr a				lsr 	a
.a4a6	4a		lsr a				lsr 	a
.a4a7	4a		lsr a				lsr 	a
.a4a8	4a		lsr a				lsr 	a
.a4a9	29 01		and #$01			and 	#1
.a4ab	20 4a 9e	jsr $9e4a			jsr 	NSMSetByte
.a4ae	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a4af					LoadCommand:
.a4af	20 f6 89	jsr $89f6			jsr 	NewProgram
.a4b2	20 ef 82	jsr $82ef			jsr 	BackLoadProgram
.a4b5	4c 9f 83	jmp $839f			jmp 	WarmStart
.a4b8					GoCommand:
.a4b8	20 f6 89	jsr $89f6			jsr 	NewProgram
.a4bb	20 ef 82	jsr $82ef			jsr 	BackLoadProgram
.a4be	4c 37 8b	jmp $8b37			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a4c1					UnaryTimer:
.a4c1	fa		plx				plx
.a4c2	20 0d 8f	jsr $8f0d			jsr 	CheckRightBracket
.a4c5					TimerToStackX:
.a4c5	20 48 9e	jsr $9e48			jsr 	NSMSetZero 					; zero result
.a4c8	64 01		stz $01				stz 	1 							; access I/O
.a4ca	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a4cd	95 58		sta $58,x			sta 	NSMantissa0,x
.a4cf	ad 5a d6	lda $d65a			lda 	$D65A
.a4d2	95 60		sta $60,x			sta 	NSMantissa1,x
.a4d4	ad 5b d6	lda $d65b			lda 	$D65B
.a4d7	95 68		sta $68,x			sta 	NSMantissa2,x
.a4d9	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a4da					MemoryDeleteLine:
.a4da	20 f9 a4	jsr $a4f9			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a4dd	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a4df	a8		tay				tay
.a4e0					_MDDLLoop:
.a4e0	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a4e2	92 30		sta ($30)			sta 	(codePtr)
.a4e4	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a4e6	c5 3a		cmp $3a				cmp 	zTemp2
.a4e8	d0 07		bne $a4f1			bne 	_MDLDLNext
.a4ea	a5 31		lda $31				lda 	codePtr+1
.a4ec	c5 3b		cmp $3b				cmp 	zTemp2+1
.a4ee	d0 01		bne $a4f1			bne 	_MDLDLNext
.a4f0					_MDDLExit:
.a4f0	60		rts				rts
.a4f1					_MDLDLNext:
.a4f1	e6 30		inc $30				inc 	codePtr						; next byte
.a4f3	d0 eb		bne $a4e0			bne 	_MDDLLoop
.a4f5	e6 31		inc $31				inc 	codePtr+1
.a4f7	80 e7		bra $a4e0			bra 	_MDDLLoop
.a4f9					IMemoryFindEnd:
.a4f9	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a4fb	85 3a		sta $3a				sta 	0+zTemp2
.a4fd	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a4ff	85 3b		sta $3b				sta 	1+zTemp2
.a501					_MDLFELoop:
.a501	b2 3a		lda ($3a)			lda 	(zTemp2)
.a503	f0 0b		beq $a510			beq 	_MDLFEExit
.a505	18		clc				clc
.a506	65 3a		adc $3a				adc 	zTemp2
.a508	85 3a		sta $3a				sta 	zTemp2
.a50a	90 f5		bcc $a501			bcc 	_MDLFELoop
.a50c	e6 3b		inc $3b				inc 	zTemp2+1
.a50e	80 f1		bra $a501			bra 	_MDLFELoop
.a510					_MDLFEExit:
.a510	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a511					MemoryInsertLine:
.a511	08		php				php
.a512	20 f9 a4	jsr $a4f9			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a515	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a517	1a		inc a				inc 	a
.a518	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a51a	b0 36		bcs $a552			bcs 	_MDLIError
.a51c	28		plp				plp
.a51d	90 08		bcc $a527			bcc 	_MDLIFound
.a51f	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a521	85 30		sta $30				sta 	codePtr
.a523	a5 3b		lda $3b				lda 	zTemp2+1
.a525	85 31		sta $31				sta 	codePtr+1
.a527					_MDLIFound:
.a527	ad 2a 04	lda $042a			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a52a	a8		tay				tay
.a52b					_MDLIInsert:
.a52b	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a52d	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a52f	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a531	c5 3a		cmp $3a				cmp 	zTemp2
.a533	d0 06		bne $a53b			bne 	_MDLINext
.a535	a5 31		lda $31				lda 	codePtr+1
.a537	c5 3b		cmp $3b				cmp 	zTemp2+1
.a539	f0 0a		beq $a545			beq 	_MDLIHaveSpace
.a53b					_MDLINext:
.a53b	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a53d	d0 02		bne $a541			bne 	_MDLINoBorrow
.a53f	c6 3b		dec $3b				dec 	zTemp2+1
.a541					_MDLINoBorrow:
.a541	c6 3a		dec $3a				dec 	zTemp2
.a543	80 e6		bra $a52b			bra 	_MDLIInsert
.a545					_MDLIHaveSpace:
.a545	ac 2a 04	ldy $042a			ldy 	tokenOffset 				; bytes to copy
.a548	88		dey				dey 								; from offset-1 to 0
.a549					_MDLICopy:
.a549	b9 2a 04	lda $042a,y			lda 	tokenOffset,y
.a54c	91 30		sta ($30),y			sta 	(codePtr),y
.a54e	88		dey				dey
.a54f	10 f8		bpl $a549			bpl 	_MDLICopy
.a551	60		rts				rts
.a552					_MDLIError:
.a552	a9 06		lda #$06		lda	#6
.a554	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.a557					MDLAppendLine:
.a557	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a559	85 36		sta $36				sta 	zTemp0
.a55b	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a55d	85 38		sta $38				sta 	0+zTemp1
.a55f	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a561	85 39		sta $39				sta 	1+zTemp1
.a563	b2 38		lda ($38)			lda 	(zTemp1)
.a565	d0 0a		bne $a571			bne 	_MDLANoInitialise
.a567	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a569	8d 64 06	sta $0664			sta 	0+AppendPointer
.a56c	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a56e	8d 65 06	sta $0665			sta 	1+AppendPointer
.a571					_MDLANoInitialise:
.a571	18		clc				clc
.a572	ad 64 06	lda $0664			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a575	85 38		sta $38				sta 	zTemp1
.a577	72 36		adc ($36)			adc 	(zTemp0)
.a579	8d 64 06	sta $0664			sta 	AppendPointer
.a57c	ad 65 06	lda $0665			lda 	AppendPointer+1
.a57f	85 39		sta $39				sta 	zTemp1+1
.a581	69 00		adc #$00			adc 	#0
.a583	8d 65 06	sta $0665			sta 	AppendPointer+1
.a586	a0 00		ldy #$00			ldy 	#0
.a588					_MDLACopy:
.a588	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a58a	91 38		sta ($38),y			sta 	(zTemp1),y
.a58c	c8		iny				iny
.a58d	98		tya				tya
.a58e	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a590	d0 f6		bne $a588			bne 	_MDLACopy
.a592	a9 00		lda #$00			lda 	#0 							; end of program.
.a594	91 38		sta ($38),y			sta 	(zTemp1),y
.a596	60		rts				rts
.0664					AppendPointer:
>0664							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a597					MemoryNew:
.a597	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a599	85 30		sta $30				sta 	codePtr
.a59b	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a59d	85 31		sta $31				sta 	codePtr+1
.a59f	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a5a1	92 30		sta ($30)			sta 	(codePtr)
.a5a3	60		rts				rts
.a5a4					MemoryInline:
.a5a4	98		tya				tya 								; put address into stack,x
.a5a5	18		clc				clc  								; get the offset, add codePtr
.a5a6	65 30		adc $30				adc 	codePtr
.a5a8	95 58		sta $58,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a5aa	a5 31		lda $31				lda 	codePtr+1
.a5ac	69 00		adc #$00			adc 	#0
.a5ae	95 60		sta $60,x			sta 	NSMantissa1,x
.a5b0	74 68		stz $68,x			stz 	NSMantissa2,x
.a5b2	74 70		stz $70,x			stz 	NSMantissa3,x
.a5b4	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a5b5					MemorySearch:
.a5b5	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a5b7	86 37		stx $37				stx 	zTemp0+1
.a5b9	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5bb	85 30		sta $30				sta 	codePtr
.a5bd	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5bf	85 31		sta $31				sta 	codePtr+1
.a5c1					_MTAXLoop:
.a5c1	b2 30		lda ($30)			lda 	(codePtr)
.a5c3	18		clc				clc
.a5c4	f0 21		beq $a5e7			beq 	_MTAXExit 					; reached end, exit with CC.
.a5c6	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a5c8	b1 30		lda ($30),y			lda 	(codePtr),y
.a5ca	38		sec				sec
.a5cb	e5 36		sbc $36				sbc 	zTemp0
.a5cd	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a5cf	c8		iny				iny 								; do the MSB
.a5d0	b1 30		lda ($30),y			lda 	(codePtr),y
.a5d2	e5 37		sbc $37				sbc 	zTemp0+1
.a5d4	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a5d6	f0 0f		beq $a5e7			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a5d8	b0 0d		bcs $a5e7			bcs 	_MTAXExit 					; current < required exit
.a5da	18		clc				clc
.a5db	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a5dd	65 30		adc $30				adc 	codePtr
.a5df	85 30		sta $30				sta 	codePtr
.a5e1	90 02		bcc $a5e5			bcc 	_CREExit
.a5e3	e6 31		inc $31				inc 	codePtr+1 					; carry
.a5e5					_CREExit:
.a5e5	80 da		bra $a5c1			bra 	_MTAXLoop
.a5e7					_MTAXExit:
.a5e7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/effects.asm

.a5e8					PingCommand:
.a5e8	5a		phy				phy 								; save pos
.a5e9	a9 01		lda #$01			lda 	#1 						; push channel.
.a5eb	48		pha				pha
.a5ec	a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.a5ee	a2 03		ldx #$03			ldx 	#3 						; length
.a5f0	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a5f2	80 24		bra $a618			bra 	SoundEffectCommand
.a5f4					ZapCommand:
.a5f4	5a		phy				phy 								; save pos
.a5f5	a9 01		lda #$01			lda 	#1 						; push channel.
.a5f7	48		pha				pha
.a5f8	a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.a5fa	a2 05		ldx #$05			ldx 	#5 						; length
.a5fc	a0 14		ldy #$14			ldy 	#20 						; slide LSB
.a5fe	80 18		bra $a618			bra 	SoundEffectCommand
.a600					ShootCommand:
.a600	5a		phy				phy 								; save pos
.a601	a9 03		lda #$03			lda 	#3 						; push channel.
.a603	48		pha				pha
.a604	a9 20		lda #$20			lda 	#32 						; pitch LSB
.a606	a2 02		ldx #$02			ldx 	#2 						; length
.a608	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a60a	80 0c		bra $a618			bra 	SoundEffectCommand
.a60c					Explode:
.a60c	5a		phy				phy 								; save pos
.a60d	a9 03		lda #$03			lda 	#3 						; push channel.
.a60f	48		pha				pha
.a610	a9 50		lda #$50			lda 	#80 						; pitch LSB
.a612	a2 05		ldx #$05			ldx 	#5 						; length
.a614	a0 00		ldy #$00			ldy 	#0 						; slide LSB
.a616	80 00		bra $a618			bra 	SoundEffectCommand
.a618					SoundEffectCommand:
.a618	8d 66 06	sta $0666			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.a61b	9c 67 06	stz $0667			stz 	SoundCommandBlock+1
.a61e	a9 0f		lda #$0f			lda 	#15
.a620	8d 68 06	sta $0668			sta 	SoundCommandBlock+2
.a623	8e 69 06	stx $0669			stx 	SoundCommandBlock+3
.a626	8c 6a 06	sty $066a			sty 	SoundCommandBlock+4
.a629	9c 6b 06	stz $066b			stz 	SoundCommandBlock+5
.a62c	68		pla				pla
.a62d	09 10		ora #$10			ora 	#$10  						; execute command $11
.a62f	a2 66		ldx #$66			ldx 	#(SoundCommandBlock & $FF)
.a631	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a633	20 18 80	jsr $8018			jsr 	SNDCommand
.a636	7a		ply				ply
.a637	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a638					UnaryPlaying:
.a638	fa		plx				plx
.a639	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; get channel #
.a63c	48		pha				pha
.a63d	20 0d 8f	jsr $8f0d			jsr		CheckRightBracket
.a640	68		pla				pla
.a641	c9 04		cmp #$04			cmp 	#4
.a643	b0 0c		bcs $a651			bcs 	_UPNotPlaying
.a645	09 20		ora #$20			ora 	#$20 						; query playing ?
.a647	20 18 80	jsr $8018			jsr 	SNDCommand
.a64a	c9 00		cmp #$00			cmp 	#0
.a64c	f0 03		beq $a651			beq 	_UPNotPlaying
.a64e	4c 93 8f	jmp $8f93			jmp 	ReturnTrue
.a651					_UPNotPlaying:
.a651	4c 9e 8f	jmp $8f9e			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a654					SoundCommand:
.a654	b1 30		lda ($30),y			lda 	(codePtr),y
.a656	c9 c3		cmp #$c3			cmp 	#KWD_OFF 					; SOUND OFF ?
.a658	d0 09		bne $a663			bne 	_SNDMain
.a65a	c8		iny				iny 								; skip OFF
.a65b	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a65d	5a		phy				phy
.a65e	20 18 80	jsr $8018			jsr 	SNDCommand
.a661	7a		ply				ply
.a662	60		rts				rts
.a663					_SNDMain:
.a663	a2 00		ldx #$00			ldx 	#0
.a665	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; channel
.a668	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a66a	b0 4b		bcs $a6b7			bcs 	_SndError
.a66c	e8		inx				inx 								; do the rest in slot 1.
.a66d	20 15 8f	jsr $8f15			jsr 	CheckComma
.a670	20 c8 9d	jsr $9dc8			jsr 	Evaluate16BitInteger 		; Pitch
.a673	b5 60		lda $60,x			lda 	NSMantissa1,x 				; must be 10 bit
.a675	c9 10		cmp #$10			cmp 	#16
.a677	b0 3e		bcs $a6b7			bcs 	_SndError
.a679	8d 67 06	sta $0667			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a67c	b5 58		lda $58,x			lda 	NSMantissa0,x
.a67e	8d 66 06	sta $0666			sta 	SoundCommandBlock
.a681	20 15 8f	jsr $8f15			jsr 	CheckComma
.a684	20 e3 9d	jsr $9de3			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a687	8d 69 06	sta $0669			sta 	SoundCommandBlock+3
.a68a	a9 0f		lda #$0f			lda 	#15
.a68c	8d 68 06	sta $0668			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a68f	9c 6a 06	stz $066a			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a692	9c 6b 06	stz $066b			stz 	SoundCommandBlock+5
.a695	b1 30		lda ($30),y			lda 	(codePtr),y
.a697	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a699	d0 0e		bne $a6a9			bne 	_SNDPlay
.a69b	c8		iny				iny
.a69c	20 d2 9d	jsr $9dd2			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a69f	b5 58		lda $58,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a6a1	8d 6a 06	sta $066a			sta 	SoundCommandBlock+4
.a6a4	b5 60		lda $60,x			lda 	NSMantissa1,x
.a6a6	8d 6b 06	sta $066b			sta 	SoundCommandBlock+5
.a6a9					_SNDPlay:
.a6a9	5a		phy				phy
.a6aa	a5 58		lda $58				lda 	NSMantissa0 				; channel.
.a6ac	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a6ae	a2 66		ldx #$66			ldx 	#(SoundCommandBlock & $FF)
.a6b0	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a6b2	20 18 80	jsr $8018			jsr 	SNDCommand
.a6b5	7a		ply				ply
.a6b6	60		rts				rts
.a6b7					_SndError:
.a6b7	4c cb 9f	jmp $9fcb			jmp 	RangeError
.0666					SoundCommandBlock:
>0666							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a6ba					StackPushByte:
.a6ba	48		pha				pha 								; save byte on stack
.a6bb	a5 34		lda $34				lda 	BasicStack 					; decrement basic stack pointer
.a6bd	d0 08		bne $a6c7			bne 	_SPBNoBorrow
.a6bf	c6 35		dec $35				dec 	BasicStack+1 				; borrow
.a6c1	a5 35		lda $35				lda 	BasicStack+1 				; check range.
.a6c3	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6c5	90 06		bcc $a6cd			bcc 	_SPBMemory
.a6c7					_SPBNoBorrow:
.a6c7	c6 34		dec $34				dec 	BasicStack
.a6c9	68		pla				pla 								; get back and write
.a6ca	92 34		sta ($34)			sta 	(BasicStack)
.a6cc	60		rts				rts
.a6cd					_SPBMemory:
.a6cd	a9 12		lda #$12		lda	#18
.a6cf	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.a6d2					StackPopByte:
.a6d2	b2 34		lda ($34)			lda 	(BasicStack) 				; bump the stack pointer.
.a6d4	e6 34		inc $34				inc 	BasicStack
.a6d6	d0 02		bne $a6da			bne 	_SPBNoCarry
.a6d8	e6 35		inc $35				inc 	BasicStack+1
.a6da					_SPBNoCarry:
.a6da	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a6db					StackOpen:
.a6db	48		pha				pha 								; save frame byte
.a6dc	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a6de	0a		asl a				asl 	a 							; claim twice this for storage
.a6df	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a6e1	38		sec				sec 								; so basically subtracting from
.a6e2	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a6e4	85 34		sta $34				sta 	basicStack
.a6e6	b0 09		bcs $a6f1			bcs 	_SONoBorrow
>a6e8	db						.byte 	$DB 						; causes a break in the emulator
.a6e9	c6 35		dec $35				dec 	basicStack+1
.a6eb	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a6ed	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a6ef	90 04		bcc $a6f5			bcc 	_SOMemory
.a6f1					_SONoBorrow:
.a6f1	68		pla				pla 								; get marker back and write at TOS
.a6f2	92 34		sta ($34)			sta 	(basicStack)
.a6f4	60		rts				rts
.a6f5					_SOMemory:
.a6f5	a9 12		lda #$12		lda	#18
.a6f7	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.a6fa					StackClose:
.a6fa	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a6fc	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a6fe	0a		asl a				asl 	a 							; claim twice this.
.a6ff	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a701	85 34		sta $34				sta 	basicStack
.a703	90 02		bcc $a707			bcc 	_SCExit
.a705	e6 35		inc $35				inc 	basicStack+1
.a707					_SCExit:
.a707	60		rts				rts
.a708					StackCheckFrame:
.a708	48		pha				pha
.a709					_StackRemoveLocals:
.a709	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a70b	c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.a70d	b0 05		bcs $a714			bcs 	_SCNoLocal
.a70f	20 a5 89	jsr $89a5			jsr 	LocalPopValue 				; restore the local value
.a712	80 f5		bra $a709			bra 	_StackRemoveLocals 			; gr round again
.a714					_SCNoLocal:
.a714	68		pla				pla 								; get the frame check.
.a715	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a717	29 f0		and #$f0			and 	#$F0 						; check type bits
.a719	d0 01		bne $a71c			bne 	_SCFError 					; different, we have structures mixed up
.a71b	60		rts				rts
.a71c					_SCFError:
.a71c	8a		txa				txa 								; report error X
.a71d	4c 26 8f	jmp $8f26			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a720					STKSaveCodePosition:
.a720	5a		phy				phy
.a721	98		tya				tya 								; save Y
.a722	a0 05		ldy #$05			ldy 	#5
.a724	91 34		sta ($34),y			sta 	(basicStack),y
.a726	88		dey				dey 								; save Code Pointer
.a727					_STKSaveLoop:
.a727	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a72a	91 34		sta ($34),y			sta 	(basicStack),y
.a72c	88		dey				dey
.a72d	d0 f8		bne $a727			bne 	_STKSaveLoop
.a72f	7a		ply				ply
.a730	60		rts				rts
.a731					STKLoadCodePosition:
.a731	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a733					_STKLoadLoop:
.a733	b1 34		lda ($34),y			lda 	(basicStack),y
.a735	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a738	c8		iny				iny
.a739	c0 05		cpy #$05			cpy 	#5
.a73b	d0 f6		bne $a733			bne 	_STKLoadLoop
.a73d	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a73f	a8		tay				tay
.a740	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a741					StackReset:
.a741	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a743	85 34		sta $34				sta 	0+basicStack
.a745	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a747	85 35		sta $35				sta 	1+basicStack
.a749	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a74b	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a74d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a74e					StringConcrete:
.a74e	5a		phy				phy 								; save position on stack
.a74f	20 5b 9a	jsr $9a5b			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a752	b5 58		lda $58,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a754	85 38		sta $38				sta 	zTemp1
.a756	b5 60		lda $60,x			lda 	NSMantissa1,x
.a758	85 39		sta $39				sta 	zTemp1+1
.a75a	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a75c					_SALength:
.a75c	c8		iny				iny
.a75d	b1 38		lda ($38),y			lda 	(zTemp1),y
.a75f	d0 fb		bne $a75c			bne 	_SALength
.a761	c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.a763	b0 3d		bcs $a7a2			bcs 	_SALengthError
.a765	98		tya				tya 				 				; length of the new string
.a766	18		clc				clc
.a767	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a769	90 02		bcc $a76d			bcc 	_SAHaveLength
.a76b	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a76d					_SAHaveLength:
.a76d	48		pha				pha 								; save length.
.a76e	38		sec				sec
.a76f	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a771	6d 0e 04	adc $040e			adc 	StringMemory
.a774	8d 0e 04	sta $040e			sta 	StringMemory
.a777	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a779	95 58		sta $58,x			sta 	NSMantissa0,x 				; update mantissa address
.a77b	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a77d	6d 0f 04	adc $040f			adc 	StringMemory+1
.a780	8d 0f 04	sta $040f			sta 	StringMemory+1
.a783	85 3b		sta $3b				sta 	zTemp2+1
.a785	95 60		sta $60,x			sta 	NSMantissa1,x
.a787	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a788	38		sec				sec
.a789	e9 03		sbc #$03			sbc 	#3
.a78b	92 3a		sta ($3a)			sta 	(zTemp2)
.a78d	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a78f	a0 01		ldy #$01			ldy 	#1
.a791	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a793					_SACopyNewString:
.a793	a0 00		ldy #$00			ldy 	#0
.a795					_SACopyNSLoop:
.a795	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a797	c8		iny				iny 								; write two on in string storage
.a798	c8		iny				iny
.a799	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a79b	88		dey				dey 								; this makes it one one.
.a79c	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a79e	d0 f5		bne $a795			bne 	_SACopyNSLoop
.a7a0	7a		ply				ply
.a7a1	60		rts				rts
.a7a2					_SALengthError:
.a7a2	a9 09		lda #$09		lda	#9
.a7a4	4c 26 8f	jmp $8f26		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a7a7					StringSystemInitialise:
.a7a7	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a7a9	8d 0e 04	sta $040e			sta 	0+StringMemory
.a7ac	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a7ae	8d 0f 04	sta $040f			sta 	1+StringMemory
.a7b1	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a7b4	60		rts				rts
.a7b5					StringSpaceInitialise:
.a7b5	20 5b 9a	jsr $9a5b			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7b8	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a7ba	8d 10 04	sta $0410			sta 	StringInitialised
.a7bd	ad 0e 04	lda $040e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a7c0	8d 11 04	sta $0411			sta 	StringTempPointer 			; so temporary string space is allocated below that.
.a7c3	ad 0f 04	lda $040f			lda 	StringMemory+1
.a7c6	3a		dec a				dec 	a
.a7c7	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7ca	60		rts				rts
.a7cb					StringTempAllocate:
.a7cb	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a7cd	b0 30		bcs $a7ff			bcs 	_STALength
.a7cf	2c 10 04	bit $0410			bit 	StringInitialised 			; already initialised
.a7d2	30 05		bmi $a7d9			bmi 	_STAAllocate
.a7d4	48		pha				pha 								; save value to subtract.
.a7d5	20 b5 a7	jsr $a7b5			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a7d8	68		pla				pla 								; restore it
.a7d9					_STAAllocate:
.a7d9	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a7db	18		clc				clc  								; deliberate allows one more
.a7dc	6d 11 04	adc $0411			adc 	StringTempPointer 			; subtract from temp pointer
.a7df	8d 11 04	sta $0411			sta 	StringTempPointer
.a7e2	95 58		sta $58,x			sta 	NSMantissa0,x 				; address in mantissa
.a7e4	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a7e6	ad 12 04	lda $0412			lda 	StringTempPointer+1
.a7e9	69 ff		adc #$ff			adc 	#$FF
.a7eb	8d 12 04	sta $0412			sta 	StringTempPointer+1
.a7ee	85 3d		sta $3d				sta 	zsTemp+1
.a7f0	95 60		sta $60,x			sta 	NSMantissa1,x
.a7f2	74 68		stz $68,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.a7f4	74 70		stz $70,x			stz 	NSMantissa3,x
.a7f6	a9 10		lda #$10			lda 	#NSTString
.a7f8	95 50		sta $50,x			sta 	NSStatus,x
.a7fa	a9 00		lda #$00			lda 	#0 							; clear the target string
.a7fc	92 3c		sta ($3c)			sta 	(zsTemp)
.a7fe	60		rts				rts
.a7ff					_STALength:
.a7ff	a9 09		lda #$09		lda	#9
.a801	4c 26 8f	jmp $8f26		jmp	ErrorHandler
.a804					StringTempWrite:
.a804	48		pha				pha
.a805	92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.a807	e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.a809	d0 02		bne $a80d			bne 	_STWNoCarry
.a80b	e6 3d		inc $3d				inc 	zsTemp+1
.a80d					_STWNoCarry:
.a80d	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.a80f	92 3c		sta ($3c)			sta 	(zsTemp)
.a811	68		pla				pla
.a812	60		rts				rts

;******  Return to file: _basic.asm

.a813					StartModuleCode:

;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=5					CLICommandLine = CONGreen
=0					CLIFComment = CONBlack
=7					CLIBComment = CONYellow
=9					CLILineNumber = CONBrown
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a813					Export_EXTPrintCharacter:
.a813					PAGEDPrintCharacter:
.a813	48		pha				pha
.a814	da		phx				phx
.a815	5a		phy				phy
.a816	a6 01		ldx $01				ldx 	1
.a818	da		phx				phx
.a819	ac 6d 06	ldy $066d			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a81c	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a81e	30 48		bmi $a868			bmi 	_EXPCColour
.a820	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a822	90 4d		bcc $a871			bcc 	_EXPCControl
.a824	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a826	86 01		stx $01				stx 	1
.a828	91 40		sta ($40),y			sta 	(EXTAddress),y
.a82a	e6 01		inc $01				inc 	1 							; select colour memory
.a82c	ad 6e 06	lda $066e			lda 	EXTTextColour
.a82f	91 40		sta ($40),y			sta 	(EXTAddress),y
.a831	c8		iny				iny 								; advance horizontal position
.a832	8c 6d 06	sty $066d			sty 	EXTColumn
.a835	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth 				; reached RHS ?
.a838	90 63		bcc $a89d			bcc 	_EXPCExit 					; no, then exit.
.a83a					_EXPCCRLF:
.a83a	ee 6c 06	inc $066c			inc 	EXTRow  					; bump row
.a83d	9c 6d 06	stz $066d			stz 	EXTColumn 					; back to column 0
.a840	ad 6c 06	lda $066c			lda 	EXTRow 						; check if reached the bottom ?
.a843	cd 70 06	cmp $0670			cmp 	EXTScreenHeight 			; if so, then scroll.
.a846	f0 18		beq $a860			beq 	_EXPCScroll
.a848	18		clc				clc 								; add width to address.
.a849	a5 40		lda $40				lda 	EXTAddress
.a84b	6d 6f 06	adc $066f			adc 	EXTScreenWidth
.a84e	85 40		sta $40				sta 	EXTAddress
.a850	90 4b		bcc $a89d			bcc 	_EXPCExit
.a852	e6 41		inc $41				inc 	EXTAddress+1
.a854	80 47		bra $a89d			bra 	_EXPCExit
.a856					_EXPCLeft:
.a856	ce 6d 06	dec $066d			dec 	EXTColumn
.a859	10 42		bpl $a89d			bpl 	_EXPCExit
.a85b					_EXPCBegin:
.a85b	9c 6d 06	stz $066d			stz 	EXTColumn
.a85e	80 3d		bra $a89d			bra 	_EXPCExit
.a860					_EXPCScroll:
.a860	ce 6c 06	dec $066c			dec 	EXTRow 						; the height-1 th line.
.a863	20 4e a9	jsr $a94e			jsr 	EXTScreenScroll 			; scroll the screen
.a866	80 35		bra $a89d			bra 	_EXPCExit
.a868					_EXPCColour:
.a868	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a86a	b0 31		bcs $a89d			bcs 	_EXPCExit
.a86c	20 2e a9	jsr $a92e			jsr 	_EXPCHandleColour
.a86f	80 2c		bra $a89d			bra 	_EXPCExit
.a871					_EXPCControl:
.a871	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a873	b0 28		bcs $a89d			bcs 	_EXPCExit
.a875	0a		asl a				asl 	a 							; double into X
.a876	aa		tax				tax
.a877	7c 0c a9	jmp ($a90c,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a87a					_EXPCUp:
.a87a	ad 6c 06	lda $066c			lda 	EXTRow 						; already at top ?
.a87d	f0 1e		beq $a89d			beq 	_EXPCExit
.a87f	ce 6c 06	dec $066c			dec 	EXTRow 						; up one in position/address
.a882	38		sec				sec
.a883	a5 40		lda $40				lda 	EXTAddress
.a885	ed 6f 06	sbc $066f			sbc 	EXTScreenWidth
.a888	85 40		sta $40				sta 	EXTAddress
.a88a	b0 11		bcs $a89d			bcs 	_EXPCExit
.a88c	c6 41		dec $41				dec 	EXTAddress+1
.a88e	80 0d		bra $a89d			bra 	_EXPCExit
.a890					_EXPCRight:
.a890	c8		iny				iny
.a891	8c 6d 06	sty $066d			sty 	EXTColumn
.a894	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth
.a897	d0 04		bne $a89d			bne 	_EXPCExit
.a899	88		dey				dey
.a89a					_EXPCSetColumnY:
.a89a	8c 6d 06	sty $066d			sty 	EXTColumn
.a89d					_EXPCExit:
.a89d	20 a3 a9	jsr $a9a3			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a8a0	68		pla				pla
.a8a1	85 01		sta $01				sta 	1
.a8a3	7a		ply				ply
.a8a4	fa		plx				plx
.a8a5	68		pla				pla
.a8a6	60		rts				rts
.a8a7					_EXPCClearScreen:
.a8a7	20 60 a9	jsr $a960			jsr		EXTClearScreenCode
.a8aa	80 f1		bra $a89d			bra 	_EXPCExit
.a8ac					_EXPCDown:
.a8ac	ad 70 06	lda $0670			lda 	EXTScreenHeight 			; at the bottom
.a8af	3a		dec a				dec 	a
.a8b0	cd 6c 06	cmp $066c			cmp 	EXTRow
.a8b3	f0 e8		beq $a89d			beq 	_EXPCExit
.a8b5	ee 6c 06	inc $066c			inc 	EXTRow 						; down one in position/address
.a8b8	18		clc				clc
.a8b9	a5 40		lda $40				lda 	EXTAddress
.a8bb	6d 6f 06	adc $066f			adc 	EXTScreenWidth
.a8be	85 40		sta $40				sta 	EXTAddress
.a8c0	90 db		bcc $a89d			bcc 	_EXPCExit
.a8c2	e6 41		inc $41				inc 	EXTAddress+1
.a8c4	80 d7		bra $a89d			bra 	_EXPCExit
.a8c6					_EXPCTab:
.a8c6	ad 6d 06	lda $066d			lda 	EXTColumn 					; next tab stop
.a8c9	29 f8		and #$f8			and 	#$F8
.a8cb	18		clc				clc
.a8cc	69 08		adc #$08			adc 	#8
.a8ce	8d 6d 06	sta $066d			sta 	EXTColumn
.a8d1	cd 6f 06	cmp $066f			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a8d4	90 c7		bcc $a89d			bcc 	_EXPCExit
.a8d6	80 10		bra $a8e8			bra 	_EXPCEnd
.a8d8					_EXPCBackSpace:
.a8d8	88		dey				dey
.a8d9	30 c2		bmi $a89d			bmi 	_EXPCExit
.a8db	ce 6d 06	dec $066d			dec 	EXTColumn
.a8de	a9 02		lda #$02			lda 	#2
.a8e0	85 01		sta $01				sta 	1
.a8e2	a9 20		lda #$20			lda 	#32
.a8e4	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8e6	80 b5		bra $a89d			bra 	_EXPCExit
.a8e8					_EXPCEnd:
.a8e8	a9 02		lda #$02			lda 	#2 							; access text screen
.a8ea	85 01		sta $01				sta 	1
.a8ec	ac 6f 06	ldy $066f			ldy 	EXTScreenWidth 				; point to last character
.a8ef	88		dey				dey
.a8f0					_EXPCEndSearch:
.a8f0	88		dey				dey 								; if past start, move to col 0.
.a8f1	30 06		bmi $a8f9			bmi 	_EXPCFound
.a8f3	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.a8f5	c9 20		cmp #$20			cmp 	#' '
.a8f7	f0 f7		beq $a8f0			beq 	_EXPCEndSearch
.a8f9					_EXPCFound:
.a8f9	c8		iny				iny 								; move to following cell.
.a8fa	80 9e		bra $a89a			bra 	_EXPCSetColumnY
.a8fc					_EXPCClearEOL:
.a8fc	a9 02		lda #$02			lda 	#2 							; access character RAM
.a8fe	85 01		sta $01				sta 	1
.a900	a9 20		lda #$20			lda 	#' ' 						; write space
.a902	91 40		sta ($40),y			sta 	(EXTAddress),y
.a904	c8		iny				iny
.a905	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth 				; until RHS of screen.
.a908	90 f2		bcc $a8fc			bcc 	_EXPCClearEOL
.a90a	80 91		bra $a89d			bra 	_EXPCExit
.a90c					_EXPCActionTable:
>a90c	9d a8						.word 	_EXPCExit 					; 00
>a90e	5b a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a910	56 a8						.word 	_EXPCLeft 					; 02 B Left
>a912	9d a8						.word 	_EXPCExit 					; 03 <Break>
>a914	9d a8						.word 	_EXPCExit 					; 04
>a916	e8 a8						.word 	_EXPCEnd 					; 05 E End of Line
>a918	90 a8						.word 	_EXPCRight 					; 06 F Right
>a91a	9d a8						.word 	_EXPCExit 					; 07
>a91c	d8 a8						.word 	_EXPCBackspace 				; 08 H Backspace
>a91e	c6 a8						.word 	_EXPCTab 					; 09 I Tab
>a920	9d a8						.word 	_EXPCExit 					; 0A
>a922	fc a8						.word 	_EXPCClearEOL 				; 0B K Clear to EOL
>a924	a7 a8						.word 	_EXPCClearScreen			; 0C L CLS
>a926	3a a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a928	ac a8						.word 	_EXPCDown 					; 0E N Down
>a92a	9d a8						.word 	_EXPCExit 					; 0F
>a92c	7a a8						.word 	_EXPCUp 					; 10 P Up
.a92e					_EXPCHandleColour
.a92e	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a930	b0 16		bcs $a948			bcs 	_EXPCBackground
.a932	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a933	0a		asl a				asl 	a
.a934	0a		asl a				asl 	a
.a935	0a		asl a				asl 	a
.a936	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a938					_EXPCUpdate:
.a938	48		pha				pha 								; save new colour
.a939	8a		txa				txa 								; get mask
.a93a	2d 6e 06	and $066e			and 	EXTTextColour 				; mask out old.
.a93d	8d 6e 06	sta $066e			sta 	EXTTextColour
.a940	68		pla				pla 								; or in new colour
.a941	0d 6e 06	ora $066e			ora 	EXTTextColour
.a944	8d 6e 06	sta $066e			sta 	EXTTextColour
.a947	60		rts				rts
.a948					_EXPCBackground:
.a948	29 0f		and #$0f			and 	#$0F 						; get the colour
.a94a	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a94c	80 ea		bra $a938			bra 	_EXPCUpdate
.a94e					EXTScreenScroll:
.a94e	a9 02		lda #$02			lda 	#2 							; select text page
.a950	85 01		sta $01				sta 	1
.a952	a9 20		lda #$20			lda		#32 						; fill with space
.a954	20 67 aa	jsr $aa67			jsr 	EXTScrollFill
.a957	e6 01		inc $01				inc 	1 							; select colour page
.a959	ad 6e 06	lda $066e			lda 	EXTTextColour
.a95c	20 67 aa	jsr $aa67			jsr 	EXTScrollFill
.a95f	60		rts				rts
.a960					EXTClearScreenCode:
.a960	a9 02		lda #$02			lda 	#2 							; select text page
.a962	85 01		sta $01				sta 	1
.a964	a9 20		lda #$20			lda		#32 						; fill with space
.a966	20 73 a9	jsr $a973			jsr 	_EXTCSFill
.a969	e6 01		inc $01				inc 	1 							; select colour page
.a96b	ad 6e 06	lda $066e			lda 	EXTTextColour
.a96e	20 73 a9	jsr $a973			jsr 	_EXTCSFill
.a971	80 22		bra $a995			bra 	EXTHomeCursor
.a973					_EXTCSFill:
.a973	aa		tax				tax
.a974	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a976	85 40		sta $40				sta 	EXTAddress
.a978	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a97a	85 41		sta $41				sta 	EXTAddress+1
.a97c					_EXTCSFill1:
.a97c	a0 00		ldy #$00			ldy 	#0
.a97e	8a		txa				txa
.a97f					_EXTCSFill2:
.a97f	91 40		sta ($40),y			sta 	(EXTAddress),y
.a981	c8		iny				iny
.a982	d0 fb		bne $a97f			bne 	_EXTCSFill2
.a984	e6 41		inc $41				inc 	EXTAddress+1
.a986	a5 41		lda $41				lda 	EXTAddress+1
.a988	c9 d2		cmp #$d2			cmp 	#$D2
.a98a	d0 f0		bne $a97c			bne 	_EXTCSFill1
.a98c	8a		txa				txa
.a98d					_EXTCSFill3:
.a98d	91 40		sta ($40),y			sta 	(EXTAddress),y
.a98f	c8		iny				iny
.a990	c0 c0		cpy #$c0			cpy 	#$C0
.a992	d0 f9		bne $a98d			bne 	_EXTCSFill3
.a994	60		rts				rts
.a995					EXTHomeCursor:
.a995	9c 6c 06	stz $066c			stz 	EXTRow 						; reset row & column
.a998	9c 6d 06	stz $066d			stz 	EXTColumn
.a99b	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a99d	85 40		sta $40				sta 	EXTAddress
.a99f	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9a1	85 41		sta $41				sta 	EXTAddress+1
.a9a3					EXTSetHardwareCursor:
.a9a3	64 01		stz $01				stz 	1 							; I/O Page zero
.a9a5	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a9a7	8d 10 d0	sta $d010			sta 	$D010
.a9aa	a9 b1		lda #$b1			lda 	#$B1
.a9ac	8d 12 d0	sta $d012			sta 	$D012
.a9af	ad 6d 06	lda $066d			lda 	EXTColumn
.a9b2	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.a9b5	9c 15 d0	stz $d015			stz 	$D015
.a9b8	ad 6c 06	lda $066c			lda 	EXTRow
.a9bb	8d 16 d0	sta $d016			sta 	$D016
.a9be	9c 17 d0	stz $d017			stz 	$D017
.a9c1	60		rts				rts
.a9c2					Export_EXTInputLine:
.a9c2	48		pha				pha
.a9c3	da		phx				phx
.a9c4	5a		phy				phy
.a9c5	a5 01		lda $01				lda 	1 							; save I/O page
.a9c7	48		pha				pha
.a9c8					_EILLoop:
.a9c8	20 e2 aa	jsr $aae2			jsr 	PagedInputSingleCharacter
.a9cb	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.a9cd	f0 44		beq $aa13			beq 	_EILExit
.a9cf	c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.a9d1	f0 2a		beq $a9fd			beq 	_EILDelete
.a9d3	c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.a9d5	f0 1c		beq $a9f3			beq 	_EILBackspace
.a9d7	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.a9d9	90 12		bcc $a9ed			bcc 	_EILPrintLoop
.a9db	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.a9dd	b0 0e		bcs $a9ed			bcs 	_EILPrintLoop
.a9df	48		pha				pha 								; save character
.a9e0	a9 02		lda #$02			lda 	#2  						; insert a space
.a9e2	85 01		sta $01				sta 	1
.a9e4	20 55 aa	jsr $aa55			jsr 	EXTILInsert 				; insert in text screen
.a9e7	e6 01		inc $01				inc 	1
.a9e9	20 55 aa	jsr $aa55			jsr 	EXTILInsert 				; insert in colour screen
.a9ec	68		pla				pla 								; get character back.
.a9ed					_EILPrintLoop:
.a9ed	20 13 a8	jsr $a813			jsr 	PagedPrintCharacter
.a9f0	80 d6		bra $a9c8			bra 	_EILLoop
.a9f2	60		rts				rts
.a9f3					_EILBackspace:
.a9f3	ad 6d 06	lda $066d			lda 	EXTColumn					; can we backspace ?
.a9f6	f0 d0		beq $a9c8			beq 	_EILLoop
.a9f8	a9 02		lda #$02			lda 	#2 							; move cursor left
.a9fa	20 13 a8	jsr $a813			jsr 	PagedPrintCharacter
.a9fd					_EILDelete
.a9fd	a9 02		lda #$02			lda 	#2 							; text block
.a9ff	85 01		sta $01				sta 	1
.aa01	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.aa03	20 40 aa	jsr $aa40			jsr 	EXTILDelete
.aa06	e6 01		inc $01				inc 	1 							; colour block
.aa08	ac 6d 06	ldy $066d			ldy 	EXTColumn 					; get attribute of last character
.aa0b	88		dey				dey
.aa0c	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa0e	20 40 aa	jsr $aa40			jsr 	EXTILDelete 				; backspace attribute
.aa11	80 b5		bra $a9c8			bra 	_EILLoop 					; and go round.
.aa13					_EILExit:
.aa13	a9 02		lda #$02			lda 	#2 							; switch to page 2
.aa15	85 01		sta $01				sta 	1
.aa17	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa19					_EILScrapeLine:
.aa19	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa1b	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa1e	c8		iny				iny
.aa1f	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth
.aa22	d0 f5		bne $aa19			bne 	_EILScrapeLine
.aa24					_EILTrimSpaces:
.aa24	88		dey				dey
.aa25	f0 08		beq $aa2f			beq 	_EILEndTrim
.aa27	b9 2a 05	lda $052a,y			lda 	lineBuffer,y
.aa2a	c9 20		cmp #$20			cmp 	#' '
.aa2c	f0 f6		beq $aa24			beq 	_EILTrimSpaces
.aa2e	c8		iny				iny 								; trim after non space character.
.aa2f					_EILEndTrim:
.aa2f	a9 00		lda #$00			lda 	#0 							; trim here.
.aa31	99 2a 05	sta $052a,y			sta 	lineBuffer,y
.aa34	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa36	20 13 a8	jsr $a813			jsr 	PagedPrintCharacter
.aa39	68		pla				pla 								; reset I/O page
.aa3a	85 01		sta $01				sta 	1
.aa3c	7a		ply				ply
.aa3d	fa		plx				plx
.aa3e	68		pla				pla
.aa3f	60		rts				rts
.aa40					EXTILDelete:
.aa40	48		pha				pha 								; save the new character
.aa41	ac 6d 06	ldy $066d			ldy 	EXTColumn 					; start copying from here.
.aa44					_EXTDLoop:
.aa44	c8		iny				iny 								; copy one byte down.
.aa45	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa47	88		dey				dey
.aa48	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa4a	c8		iny				iny 								; do till end of line.
.aa4b	cc 6f 06	cpy $066f			cpy 	EXTScreenWidth
.aa4e	90 f4		bcc $aa44			bcc 	_EXTDLoop
.aa50	88		dey				dey 	 							; write in last slot.
.aa51	68		pla				pla
.aa52	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa54	60		rts				rts
.aa55					EXTILInsert:
.aa55	ac 6f 06	ldy $066f			ldy 	EXTScreenWidth 				; end position
.aa58					_EXTILoop:
.aa58	88		dey				dey 								; back one
.aa59	cc 6d 06	cpy $066d			cpy 	EXTColumn 					; exit if reached insert point.
.aa5c	f0 08		beq $aa66			beq 	_EXTIExit
.aa5e	88		dey				dey 								; copy one byte up.
.aa5f	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa61	c8		iny				iny
.aa62	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa64	80 f2		bra $aa58			bra 	_EXTILoop
.aa66					_EXTIExit:
.aa66	60		rts				rts
.aa67					EXTScrollFill:
.aa67	aa		tax				tax									; save value to fill with
.aa68	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aa6a	48		pha				pha
.aa6b	a5 37		lda $37				lda 	zTemp0+1
.aa6d	48		pha				pha
.aa6e	a5 38		lda $38				lda 	zTemp1
.aa70	48		pha				pha
.aa71	a5 39		lda $39				lda 	zTemp1+1
.aa73	48		pha				pha
.aa74	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aa76	85 37		sta $37				sta 	zTemp0+1
.aa78	85 39		sta $39				sta 	zTemp1+1
.aa7a	64 36		stz $36				stz 	zTemp0
.aa7c	ad 6f 06	lda $066f			lda 	EXTScreenWidth
.aa7f	85 38		sta $38				sta 	zTemp1
.aa81	a0 00		ldy #$00			ldy 	#0
.aa83					_EXSFCopy1:
.aa83	b1 38		lda ($38),y			lda 	(zTemp1),y
.aa85	91 36		sta ($36),y			sta 	(zTemp0),y
.aa87	c8		iny				iny
.aa88	d0 f9		bne $aa83			bne 	_EXSFCopy1
.aa8a	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aa8c	e6 39		inc $39				inc 	zTemp1+1
.aa8e	a5 39		lda $39				lda 	zTemp1+1
.aa90	c9 d3		cmp #$d3			cmp 	#$D3
.aa92	d0 ef		bne $aa83			bne 	_EXSFCopy1
.aa94	ac 6f 06	ldy $066f			ldy 	EXTScreenWidth 				; blank the bottom line.
.aa97	8a		txa				txa
.aa98					_EXSFFill1:
.aa98	88		dey				dey
.aa99	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa9b	c0 00		cpy #$00			cpy 	#0
.aa9d	10 f9		bpl $aa98			bpl 	_EXSFFill1
.aa9f	68		pla				pla
.aaa0	85 39		sta $39				sta 	zTemp1+1
.aaa2	68		pla				pla
.aaa3	85 38		sta $38				sta 	zTemp1
.aaa5	68		pla				pla
.aaa6	85 37		sta $37				sta 	zTemp0+1
.aaa8	68		pla				pla
.aaa9	85 36		sta $36				sta 	zTemp0
.aaab	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.066c					EXTRow:
>066c							.fill 	1
.066d					EXTColumn:
>066d							.fill 	1
.066e					EXTTextColour:
>066e							.fill 	1
.066f					EXTScreenWidth:
>066f							.fill 	1
.0670					EXTScreenHeight:
>0670							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.aaac					Export_EXTInitialise:
.aaac	64 01		stz $01				stz 	1 							; Access I/O page 0
.aaae	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.aab1	9c 08 d0	stz $d008			stz 	$D008
.aab4	9c 09 d0	stz $d009			stz 	$D009
.aab7	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.aab9	8d 58 d6	sta $d658			sta 	$D658
.aabc	a9 03		lda #$03			lda 	#3 							; get current text colour from whatever the kernel
.aabe	85 01		sta $01				sta 	1 							; has set it to, looking at top left character
.aac0	ad 00 c0	lda $c000			lda 	$C000
.aac3	8d 6e 06	sta $066e			sta 	EXTTextColour
.aac6	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.aac8	8d 6f 06	sta $066f			sta 	EXTScreenWidth
.aacb	a9 3c		lda #$3c			lda 	#60
.aacd	8d 70 06	sta $0670			sta 	EXTScreenHeight
.aad0	20 95 a9	jsr $a995			jsr 	EXTHomeCursor 				; home cursor
.aad3					_EXMoveDown:
.aad3	a9 0d		lda #$0d			lda 	#13
.aad5	20 13 a8	jsr $a813			jsr 	PAGEDPrintCharacter
.aad8	ad 6c 06	lda $066c			lda 	EXTRow
.aadb	c9 06		cmp #$06			cmp 	#6
.aadd	d0 f4		bne $aad3			bne 	_EXMoveDown
.aadf	64 01		stz $01				stz 	1
.aae1	60		rts				rts
.aae2					Export_EXTInputSingleCharacter:
.aae2					PagedInputSingleCharacter:
.aae2	da		phx				phx
.aae3	5a		phy				phy
.aae4					_EISCWait:
.aae4	a5 01		lda $01				lda 	1 							; save I/O 0
.aae6	48		pha				pha
.aae7	64 01		stz $01				stz 	1 							; access I/O Page 0
.aae9	38		sec				sec 								; calculate timer - LastTick
.aaea	ad 59 d6	lda $d659			lda 	$D659
.aaed	aa		tax				tax 								; saving timer in X
.aaee	ed 5b 06	sbc $065b			sbc 	LastTick
.aaf1	c9 03		cmp #$03			cmp 	#3
.aaf3	90 06		bcc $aafb			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.aaf5	8e 5b 06	stx $065b			stx 	LastTick 					; update last timer
.aaf8	20 c3 be	jsr $bec3			jsr 	PagedSNDUpdate 							; go do the code.
.aafb					_NoFireTick:
.aafb	68		pla				pla 								; restore I/O 0
.aafc	85 01		sta $01				sta 	1
.aafe	20 e4 ff	jsr $ffe4			jsr 	$FFE4 						; get a key
.ab01	c9 00		cmp #$00			cmp 	#0 							; loop back if none pressed.
.ab03	f0 df		beq $aae4			beq 	_EISCWait
.ab05	7a		ply				ply
.ab06	fa		plx				plx
.ab07	60		rts				rts
.ab08					Export_EXTBreakCheck:
.ab08	4c e1 ff	jmp $ffe1			jmp		$FFE1
.ab0b					Export_EXTReadController:
.ab0b	da		phx				phx
.ab0c	a2 00		ldx #$00			ldx 	#0
.ab0e	a9 05		lda #$05			lda 	#(($2D) >> 3)
.ab10	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab13	29 20		and #$20			and 	#($01 << (($2D) & 7))
.ab15	f0 04		beq $ab1b			beq 	_NoSet1
.ab17	8a		txa				txa
.ab18	09 01		ora #$01			ora 	#1
.ab1a	aa		tax				tax
.ab1b					_NoSet1:
.ab1b	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab1d	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab20	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab22	f0 04		beq $ab28			beq 	_NoSet1
.ab24	8a		txa				txa
.ab25	09 02		ora #$02			ora 	#2
.ab27	aa		tax				tax
.ab28					_NoSet1:
.ab28	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab2a	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab2d	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab2f	f0 04		beq $ab35			beq 	_NoSet1
.ab31	8a		txa				txa
.ab32	09 04		ora #$04			ora 	#4
.ab34	aa		tax				tax
.ab35					_NoSet1:
.ab35	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab37	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab3a	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab3c	f0 04		beq $ab42			beq 	_NoSet1
.ab3e	8a		txa				txa
.ab3f	09 08		ora #$08			ora 	#8
.ab41	aa		tax				tax
.ab42					_NoSet1:
.ab42	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab44	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab47	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab49	f0 04		beq $ab4f			beq 	_NoSet1
.ab4b	8a		txa				txa
.ab4c	09 10		ora #$10			ora 	#16
.ab4e	aa		tax				tax
.ab4f					_NoSet1:
.ab4f	8a		txa				txa
.ab50	fa		plx				plx
.ab51	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.ab52					GRVectorTable:
>ab52	a1 ad					.word	GXInitialise             ; $00 Initialise
>ab54	bb ad					.word	GXControlBitmap          ; $01 BitmapCtl
>ab56	03 ae					.word	GXControlSprite          ; $02 SpriteCtl
>ab58	53 ad					.word	GXClearBitmap            ; $03 Clear
>ab5a	92 af					.word	GXSetColourMode          ; $04 Colour
>ab5c	5a b1					.word	GXFontHandler            ; $05 DrawFont
>ab5e	a2 b1					.word	GXSpriteHandler          ; $06 DrawSprite
>ab60	13 b2					.word	GXSelect                 ; $07 SpriteUse
>ab62	3c b2					.word	GXSelectImage            ; $08 SpriteImage
>ab64	c3 b3					.word	GXCollide                ; $09 SpriteCollide
>ab66	05 ac					.word	GRUndefined              ; $0a
>ab68	05 ac					.word	GRUndefined              ; $0b
>ab6a	05 ac					.word	GRUndefined              ; $0c
>ab6c	05 ac					.word	GRUndefined              ; $0d
>ab6e	05 ac					.word	GRUndefined              ; $0e
>ab70	05 ac					.word	GRUndefined              ; $0f
>ab72	05 ac					.word	GRUndefined              ; $10
>ab74	05 ac					.word	GRUndefined              ; $11
>ab76	05 ac					.word	GRUndefined              ; $12
>ab78	05 ac					.word	GRUndefined              ; $13
>ab7a	05 ac					.word	GRUndefined              ; $14
>ab7c	05 ac					.word	GRUndefined              ; $15
>ab7e	05 ac					.word	GRUndefined              ; $16
>ab80	05 ac					.word	GRUndefined              ; $17
>ab82	05 ac					.word	GRUndefined              ; $18
>ab84	05 ac					.word	GRUndefined              ; $19
>ab86	05 ac					.word	GRUndefined              ; $1a
>ab88	05 ac					.word	GRUndefined              ; $1b
>ab8a	05 ac					.word	GRUndefined              ; $1c
>ab8c	05 ac					.word	GRUndefined              ; $1d
>ab8e	05 ac					.word	GRUndefined              ; $1e
>ab90	05 ac					.word	GRUndefined              ; $1f
>ab92	03 ac					.word	GXMove                   ; $20 Move
>ab94	60 ae					.word	GXLine                   ; $21 Line
>ab96	db af					.word	GXFrameRectangle         ; $22 FrameRect
>ab98	d8 af					.word	GXFillRectangle          ; $23 FillRect
>ab9a	0a ac					.word	GXFrameCircle            ; $24 FrameCircle
>ab9c	06 ac					.word	GXFillCircle             ; $25 FillCircle
>ab9e	05 ac					.word	GRUndefined              ; $26
>aba0	05 ac					.word	GRUndefined              ; $27
>aba2	c0 af					.word	GXPlotPoint              ; $28 Plot
>aba4	d2 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$627					gxPixelBuffer = numberBuffer
.0671					gxCurrentX:
>0671							.fill 	2
.0673					gxCurrentY:
>0673							.fill 	2
.0675					gxLastX:
>0675							.fill 	2
.0677					gxLastY:
>0677							.fill 	2
.0679					gxX0:
>0679							.fill 	2
.067b					gxY0:
>067b							.fill 	2
.067d					gxX1:
>067d							.fill 	2
.067f					gxY1:
>067f							.fill 	2
.0681					gxSpritesOn:
>0681							.fill 	1
.0682					gxBitmapsOn:
>0682							.fill 	1
.0683					gxBasePage:
>0683							.fill 	1
.0684					gxSpritePage:
>0684							.fill 	1
.0685					gxHeight:
>0685							.fill 	1
.0686					gxMode:
>0686							.fill 	1
.0687					gxColour:
>0687							.fill 	1
.0688					gxEORValue:
>0688							.fill 	1
.0689					gxANDValue:
>0689							.fill 	1
.068a					gxOriginalLUTValue:
>068a							.fill 	1
.068b					gsOffset:
>068b							.fill 	1
.068c					GSCurrentSpriteID:
>068c							.fill 	1
.068d					GSCurrentSpriteAddr:
>068d							.fill 	2
.068f					GXSpriteOffsetBase:
>068f							.fill 	2
.0691					GXSpriteLow:
>0691							.fill 	64
.06d1					GXSpriteHigh:
>06d1							.fill 	64
.aba6					Export_GXGraphicDraw:
.aba6	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.aba8	b0 06		bcs $abb0			bcs 	_GDCoordinate
.abaa	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.abac	84 37		sty $37				sty 	gxzTemp0+1
.abae	80 4b		bra $abfb			bra 	_GDExecuteA 				; and execute
.abb0					_GDCoordinate:
.abb0	48		pha				pha 								; save AXY
.abb1	da		phx				phx
.abb2	5a		phy				phy
.abb3	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.abb5					_GDCopy1:
.abb5	bd 71 06	lda $0671,x			lda 	gxCurrentX,x
.abb8	9d 75 06	sta $0675,x			sta 	gxLastX,x
.abbb	ca		dex				dex
.abbc	10 f7		bpl $abb5			bpl 	_GDCopy1
.abbe	68		pla				pla 								; update Y
.abbf	8d 73 06	sta $0673			sta 	gxCurrentY
.abc2	9c 74 06	stz $0674			stz 	gxCurrentY+1
.abc5	68		pla				pla
.abc6	8d 71 06	sta $0671			sta 	gxCurrentX
.abc9	68		pla				pla 								; get A (command+X.1) back
.abca	48		pha				pha
.abcb	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.abcd	8d 72 06	sta $0672			sta 	gxCurrentX+1
.abd0	68		pla				pla 								; get command back
.abd1	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abd3	48		pha				pha 								; push back.
.abd4	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abd6	f0 17		beq $abef			beq 	_GDCopyToWorkArea
.abd8	ad 72 06	lda $0672			lda 	gxCurrentX+1 				; X < 256 X okay
.abdb	f0 07		beq $abe4			beq 	_GDCheckY
.abdd	ad 71 06	lda $0671			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abe0	c9 40		cmp #$40			cmp 	#64
.abe2	b0 08		bcs $abec			bcs 	_GDError1
.abe4					_GDCheckY:
.abe4	ad 73 06	lda $0673			lda 	gxCurrentY 					; check Y < Height.
.abe7	cd 85 06	cmp $0685			cmp 	gxHeight
.abea	90 03		bcc $abef			bcc 	_GDCopyToWorkArea
.abec					_GDError1:
.abec	68		pla				pla
.abed					_GDError2:
.abed	38		sec				sec
.abee	60		rts				rts
.abef					_GDCopyToWorkArea:
.abef	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abf1					_GDCopy2:
.abf1	bd 71 06	lda $0671,x			lda 	gxCurrentX,x
.abf4	9d 79 06	sta $0679,x			sta 	gxX0,x
.abf7	ca		dex				dex
.abf8	10 f7		bpl $abf1			bpl 	_GDCopy2
.abfa	68		pla				pla 								; get command
.abfb					_GDExecuteA:
.abfb	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abfd	b0 ee		bcs $abed			bcs 	_GDError2
.abff	aa		tax				tax
.ac00	7c 52 ab	jmp ($ab52,x)			jmp 	(GRVectorTable,x)
.ac03					GXMove:
.ac03	18		clc				clc
.ac04	60		rts				rts
.ac05					GRUndefined:
>ac05	db						.byte 	$DB 						; causes a break in the emulator
.ac06					GXFillCircle:
.ac06	a9 ff		lda #$ff			lda 	#255
.ac08	80 02		bra $ac0c			bra 	GXCircle
.ac0a					GXFrameCircle:
.ac0a	a9 00		lda #$00			lda 	#0
.ac0c					GXCircle:
.ac0c	8d 14 07	sta $0714			sta 	gxIsFillMode					; save Fill flag
.ac0f	ad 82 06	lda $0682			lda 	gxBitmapsOn
.ac12	f0 26		beq $ac3a			beq 	_GXCFail
.ac14	20 6a b4	jsr $b46a			jsr 	GXSortXY 					; topleft/bottomright
.ac17	20 42 b3	jsr $b342			jsr 	GXOpenBitmap 				; start drawing
.ac1a	20 0c ad	jsr $ad0c			jsr 	GXCircleSetup 				; set up for drawing
.ac1d	9c 15 07	stz $0715			stz 	gxYChanged
.ac20					_GXCircleDraw:
.ac20	ad 12 07	lda $0712			lda 	gXCentre					; while x <= y
.ac23	cd 13 07	cmp $0713			cmp 	gYCentre
.ac26	90 0a		bcc $ac32			bcc 	_GXCircleContinue
.ac28	d0 03		bne $ac2d			bne 	_GXNoLast
.ac2a	20 3f ac	jsr $ac3f			jsr 	GXPlot1
.ac2d					_GXNoLast:
.ac2d	20 4a b3	jsr $b34a			jsr 	GXCloseBitmap 				; close the bitmap
.ac30	18		clc				clc
.ac31	60		rts				rts
.ac32					_GXCircleContinue:
.ac32	20 3c ac	jsr $ac3c			jsr 	GXPlot2 					; draw it
.ac35	20 b9 ac	jsr $acb9			jsr 	GXCircleMove 				; adjust the coordinates
.ac38	80 e6		bra $ac20			bra 	_GXCircleDraw
.ac3a					_GXCFail:
.ac3a	38		sec				sec
.ac3b	60		rts				rts
.ac3c					GXPlot2:
.ac3c	20 3f ac	jsr $ac3f			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac3f					GXPlot1:
.ac3f	ad 13 07	lda $0713			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac42	f0 03		beq $ac47			beq 	_GXPlot1Only
.ac44	20 63 ac	jsr $ac63			jsr 	GXPlot0 						; plot and negate
.ac47					_GXPlot1Only:
.ac47	20 63 ac	jsr $ac63			jsr 	GXPlot0 						; twice, undoing negation
.ac4a	ad 12 07	lda $0712			lda 	gXCentre 						; swap X and Y
.ac4d	ae 13 07	ldx $0713			ldx	 	gYCentre
.ac50	8d 13 07	sta $0713			sta 	gYCentre
.ac53	8e 12 07	stx $0712			stx 	gXCentre
.ac56	ad 15 07	lda $0715			lda 	gxYChanged 						; toggle Y Changed flag
.ac59	a9 ff		lda #$ff			lda 	#$FF
.ac5b	8d 15 07	sta $0715			sta 	gxYChanged
.ac5e	60		rts				rts
.ac5f	20 63 ac	jsr $ac63			jsr 	GXPlot0 						; do once
.ac62	60		rts				rts
.ac63	ad 14 07	lda $0714	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac66	f0 05		beq $ac6d			beq 	_GXPlot0Always
.ac68	ad 15 07	lda $0715			lda 	gxYChanged						; fill mode, only draw if changed.
.ac6b	f0 2d		beq $ac9a			beq 	GXPlot0Exit
.ac6d					_GXPlot0Always:
.ac6d	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac6f	ad 13 07	lda $0713			lda 	gYCentre
.ac72	20 9b ac	jsr $ac9b			jsr 	GXSubCopy
.ac75	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac77	ad 12 07	lda $0712			lda 	gXCentre
.ac7a	20 9b ac	jsr $ac9b			jsr 	GXSubCopy
.ac7d	48		pha				pha 									; save last offset X
.ac7e	20 52 b3	jsr $b352			jsr 	GXPositionCalc 					; calculate position/offset.
.ac81	68		pla				pla
.ac82	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac83	85 36		sta $36				sta 	gxzTemp0
.ac85	64 37		stz $37				stz 	gxzTemp0+1
.ac87	26 37		rol $37				rol 	gxzTemp0+1
.ac89	ad 14 07	lda $0714			lda 	gxIsFillMode
.ac8c	69 80		adc #$80			adc 	#128
.ac8e	20 2b b0	jsr $b02b			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac91	38		sec				sec 									; GY = -GY
.ac92	a9 00		lda #$00			lda 	#0
.ac94	ed 13 07	sbc $0713			sbc 	gYCentre
.ac97	8d 13 07	sta $0713			sta 	gYCentre
.ac9a					GXPlot0Exit:
.ac9a	60		rts				rts
.ac9b					GXSubCopy:
.ac9b	85 36		sta $36				sta 	gxzTemp0
.ac9d	64 37		stz $37				stz 	gxzTemp0+1
.ac9f	29 80		and #$80			and 	#$80
.aca1	f0 02		beq $aca5			beq 	_GXNoSx
.aca3	c6 37		dec $37				dec 	gxzTemp0+1
.aca5					_GXNoSx:
.aca5	38		sec				sec
.aca6	bd 7d 06	lda $067d,x			lda 	gXX1,x
.aca9	e5 36		sbc $36				sbc 	gxzTemp0
.acab	9d 79 06	sta $0679,x			sta 	gXX0,x
.acae	bd 7e 06	lda $067e,x			lda 	gXX1+1,x
.acb1	e5 37		sbc $37				sbc 	gxzTemp0+1
.acb3	9d 7a 06	sta $067a,x			sta 	gXX0+1,x
.acb6	a5 36		lda $36				lda 	gxzTemp0 						; return A
.acb8	60		rts				rts
.acb9					GXCircleMove:
.acb9	9c 15 07	stz $0715			stz 	gxYChanged 					; clear Y changed flag
.acbc	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.acbe	10 0d		bpl $accd			bpl 	_GXEMPositive
.acc0	ee 12 07	inc $0712			inc 	gXCentre 					; X++
.acc3	ad 12 07	lda $0712			lda 	gXCentre
.acc6	20 ec ac	jsr $acec			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acc9	a9 06		lda #$06			lda 	#6  						; and add 6
.accb	80 15		bra $ace2			bra 	_GXEMAddD
.accd					_GXEMPositive:
.accd	ee 12 07	inc $0712			inc 	gXCentre					; X++
.acd0	ce 13 07	dec $0713			dec 	gyCentre 					; Y--
.acd3	38		sec				sec 								; calculate X-Y
.acd4	ad 12 07	lda $0712			lda 	gXCentre
.acd7	ed 13 07	sbc $0713			sbc 	gYCentre
.acda	20 ec ac	jsr $acec			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acdd	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acdf	ce 15 07	dec $0715			dec 	gxYChanged
.ace2					_GXEMAddD:
.ace2	18		clc				clc
.ace3	65 38		adc $38				adc 	gxzTemp1
.ace5	85 38		sta $38				sta 	gxzTemp1
.ace7	90 02		bcc $aceb			bcc 	_GXEMNoCarry
.ace9	e6 39		inc $39				inc 	gxzTemp1+1
.aceb					_GXEMNoCarry:
.aceb	60		rts				rts
.acec					_GXAdd4TimesToD:
.acec	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acee	29 80		and #$80			and 	#$80
.acf0	f0 02		beq $acf4			beq 	_GXA4Unsigned
.acf2	a9 ff		lda #$ff			lda 	#$FF
.acf4					_GXA4Unsigned:
.acf4	85 37		sta $37				sta 	gxzTemp0+1
.acf6	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acf8	26 37		rol $37				rol 	gxzTemp0+1
.acfa	06 36		asl $36				asl 	gxzTemp0
.acfc	26 37		rol $37				rol 	gxzTemp0+1
.acfe	18		clc				clc 								; add
.acff	a5 36		lda $36				lda		gxzTemp0
.ad01	65 38		adc $38				adc 	gxzTemp1
.ad03	85 38		sta $38				sta 	gxzTemp1
.ad05	a5 37		lda $37				lda		gxzTemp0+1
.ad07	65 39		adc $39				adc 	gxzTemp1+1
.ad09	85 39		sta $39				sta 	gxzTemp1+1
.ad0b	60		rts				rts
.ad0c					GXCircleSetup:
.ad0c	38		sec				sec
.ad0d	ad 7f 06	lda $067f			lda 	gxY1
.ad10	ed 7b 06	sbc $067b			sbc 	gxY0
.ad13	4a		lsr a				lsr 	a
.ad14	8d 11 07	sta $0711			sta 	gxRadius
.ad17	a2 00		ldx #$00			ldx 	#0
.ad19	20 3b ad	jsr $ad3b			jsr 	_GXCalculateCentre
.ad1c	a2 02		ldx #$02			ldx 	#2
.ad1e	20 3b ad	jsr $ad3b			jsr 	_GXCalculateCentre
.ad21	9c 12 07	stz $0712			stz 	gXCentre
.ad24	ad 11 07	lda $0711			lda 	gxRadius
.ad27	8d 13 07	sta $0713			sta 	gYCentre
.ad2a	0a		asl a				asl 	a 							; R x 2
.ad2b	85 36		sta $36				sta 	gxzTemp0
.ad2d	38		sec				sec
.ad2e	a9 03		lda #$03			lda 	#3
.ad30	e5 36		sbc $36				sbc 	gxzTemp0
.ad32	85 38		sta $38				sta 	gxzTemp1
.ad34	a9 00		lda #$00			lda 	#0
.ad36	e9 00		sbc #$00			sbc 	#0
.ad38	85 39		sta $39				sta 	gxzTemp1+1
.ad3a	60		rts				rts
.ad3b					_GXCalculateCentre:
.ad3b	38		sec				sec
.ad3c	bd 7d 06	lda $067d,x			lda 	gxX1,x
.ad3f	7d 79 06	adc $0679,x			adc 	gXX0,x
.ad42	9d 7d 06	sta $067d,x			sta 	gXX1,x
.ad45	bd 7e 06	lda $067e,x			lda 	gXX1+1,x
.ad48	7d 7a 06	adc $067a,x			adc 	gXX0+1,x
.ad4b	4a		lsr a				lsr 	a
.ad4c	9d 7e 06	sta $067e,x			sta 	gXX1+1,x
.ad4f	7e 7d 06	ror $067d,x			ror 	gXX1,x
.ad52	60		rts				rts
.0711					gxRadius:
>0711							.fill 	1
.0712					gXCentre:
>0712							.fill 	1
.0713					gYCentre:
>0713							.fill 	1
.0714					gxIsFillMode:
>0714							.fill 	1
.0715					gxYChanged:
>0715							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad53					GXClearBitmap:
.ad53	ad 82 06	lda $0682			lda 	gxBitmapsOn 				; check BMP running.
.ad56	f0 24		beq $ad7c			beq 	_GXCBFail
.ad58	20 42 b3	jsr $b342			jsr 	GXOpenBitmap 				; start access
.ad5b	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad5d	ad 85 06	lda $0685			lda 	gxHeight
.ad60	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad62	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad64					_GXCalcLastPage:
.ad64	98		tya				tya 								; add to base page
.ad65	18		clc				clc
.ad66	6d 83 06	adc $0683			adc 	gxBasePage
.ad69	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad6b					_GXClearAll:
.ad6b	20 7e ad	jsr $ad7e			jsr 	_GXClearBlock 				; clear 8k block
.ad6e	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad70	a5 0b		lda $0b				lda 	GXEditSlot
.ad72	cd 83 06	cmp $0683			cmp 	gxBasePage 					; until before base page
.ad75	b0 f4		bcs $ad6b			bcs 	_GXClearAll
.ad77	20 4a b3	jsr $b34a			jsr 	GXCloseBitmap	 			; stop access
.ad7a	18		clc				clc
.ad7b	60		rts				rts
.ad7c					_GXCBFail:
.ad7c	38		sec				sec
.ad7d	60		rts				rts
.ad7e					_GXClearBlock:
.ad7e	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad80	85 38		sta $38				sta 	0+gxzTemp1
.ad82	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad84	85 39		sta $39				sta 	1+gxzTemp1
.ad86					_GXCB0:
.ad86	a5 36		lda $36				lda 	gxzTemp0
.ad88	a0 00		ldy #$00			ldy 	#0
.ad8a					_GXCB1:
.ad8a	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad8c	c8		iny				iny
.ad8d	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad8f	c8		iny				iny
.ad90	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad92	c8		iny				iny
.ad93	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad95	c8		iny				iny
.ad96	d0 f2		bne $ad8a			bne 	_GXCB1
.ad98	e6 39		inc $39				inc 	gxzTemp1+1
.ad9a	a5 39		lda $39				lda 	gxzTemp1+1
.ad9c	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad9e	d0 e6		bne $ad86			bne 	_GXCB0
.ada0	60		rts				rts
.ada1					GXInitialise:
.ada1	64 01		stz $01				stz 	1
.ada3	a9 01		lda #$01			lda 	#1
.ada5	8d 00 d0	sta $d000			sta 	$D000
.ada8	18		clc				clc
.ada9	9c 81 06	stz $0681			stz 	GXSpritesOn
.adac	9c 82 06	stz $0682			stz 	GXBitmapsOn
.adaf	a2 0f		ldx #$0f			ldx 	#15
.adb1					_GXIClear:
.adb1	9e 71 06	stz $0671,x			stz 	gxCurrentX,x
.adb4	ca		dex				dex
.adb5	10 fa		bpl $adb1			bpl 	_GXIClear
.adb7	20 52 ae	jsr $ae52			jsr 	GXClearSpriteStore
.adba	60		rts				rts
.adbb					GXControlBitmap:
.adbb	64 01		stz $01				stz 	1
.adbd	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.adbf	29 01		and #$01			and 	#1 							; set bitmap flag
.adc1	8d 82 06	sta $0682			sta 	gxBitmapsOn
.adc4	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adc5	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adc8	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adca	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.adcc	90 02		bcc $add0			bcc 	_CBNotOn
.adce	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.add0					_CBNotOn:
.add0	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.add3	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.add5	29 07		and #$07			and 	#7
.add7	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adda	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.addc	d0 02		bne $ade0			bne 	_CBNotDefault
.adde	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.ade0					_CBNotDefault:
.ade0	8d 83 06	sta $0683			sta 	gxBasePage
.ade3	20 44 ae	jsr $ae44			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ade6	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.ade8	8d 03 d1	sta $d103			sta 	$D103
.adeb	a5 36		lda $36				lda 	gxzTemp0
.aded	8d 02 d1	sta $d102			sta 	$D102
.adf0	9c 01 d1	stz $d101			stz 	$D101
.adf3	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.adf5	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.adf8	29 01		and #$01			and 	#1
.adfa	f0 02		beq $adfe			beq 	_CBHaveHeight
.adfc	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.adfe					_CBHaveHeight
.adfe	8e 85 06	stx $0685			stx 	gxHeight
.ae01	18		clc				clc
.ae02	60		rts				rts
.ae03					GXControlSprite:
.ae03	64 01		stz $01				stz 	1
.ae05	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ae07	29 01		and #$01			and 	#1 							; set sprites flag
.ae09	8d 81 06	sta $0681			sta 	gxSpritesOn
.ae0c	4a		lsr a				lsr 	a 							; bit 0 into carry.
.ae0d	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.ae10	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.ae12	29 df		and #$df			and 	#$DF 						; clear sprite bit
.ae14	90 02		bcc $ae18			bcc 	_CSNotOn
.ae16	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.ae18					_CSNotOn:
.ae18	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ae1b	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ae1d	d0 02		bne $ae21			bne 	_CSNotDefault
.ae1f	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ae21					_CSNotDefault:
.ae21	8d 84 06	sta $0684			sta 	gxSpritePage
.ae24	20 44 ae	jsr $ae44			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae27	a5 36		lda $36				lda 	zTemp0
.ae29	8d 8f 06	sta $068f			sta 	GXSpriteOffsetBase
.ae2c	a5 37		lda $37				lda 	zTemp0+1
.ae2e	8d 90 06	sta $0690			sta 	GXSpriteOffsetBase+1
.ae31	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae33					_CSClear:
.ae33	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae36	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae39	ca		dex				dex
.ae3a	d0 f7		bne $ae33			bne 	_CSClear
.ae3c	9c 8e 06	stz $068e			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae3f	20 52 ae	jsr $ae52			jsr 	GXClearSpriteStore
.ae42	18		clc				clc
.ae43	60		rts				rts
.ae44					GXCalculateBaseAddress:
.ae44	85 36		sta $36				sta 	gxzTemp0
.ae46	64 37		stz $37				stz 	gxzTemp0+1
.ae48	a9 05		lda #$05			lda 	#5
.ae4a					_GXShift:
.ae4a	06 36		asl $36				asl 	gxzTemp0
.ae4c	26 37		rol $37				rol 	gxzTemp0+1
.ae4e	3a		dec a				dec		a
.ae4f	d0 f9		bne $ae4a			bne 	_GXShift
.ae51	60		rts				rts
.ae52					GXClearSpriteStore:
.ae52	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae54					_GXCSSLoop:
.ae54	9e d1 06	stz $06d1,x			stz 	GXSpriteHigh,x
.ae57	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae59	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.ae5c	ca		dex				dex
.ae5d	10 f5		bpl $ae54			bpl 	_GXCSSLoop
.ae5f	60		rts				rts
.ae60					GXLine:
.ae60	ad 82 06	lda $0682			lda 	GXBitmapsOn
.ae63	f0 28		beq $ae8d			beq 	_GXLFail
.ae65	20 42 b3	jsr $b342			jsr 	GXOpenBitmap
.ae68	20 88 b4	jsr $b488			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae6b	20 33 af	jsr $af33			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae6e	20 52 b3	jsr $b352			jsr 	GXPositionCalc 				; calculate position/offset.
.ae71					_GXDrawLoop:
.ae71	ac 8b 06	ldy $068b			ldy 	gsOffset 					; draw the pixel
.ae74	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae76	2d 89 06	and $0689			and 	gxANDValue
.ae79	4d 88 06	eor $0688			eor 	gxEORValue
.ae7c	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae7e	20 8f ae	jsr $ae8f			jsr 	GXLineIsComplete 			; is the line complete ?
.ae81	f0 05		beq $ae88			beq 	_GXLExit
.ae83	20 aa ae	jsr $aeaa			jsr 	GXLineAdvance 				; code as per advance method
.ae86	80 e9		bra $ae71			bra 	_GXDrawLoop
.ae88					_GXLExit:
.ae88	20 4a b3	jsr $b34a			jsr 	GXCloseBitmap
.ae8b	18		clc				clc
.ae8c	60		rts				rts
.ae8d					_GXLFail:
.ae8d	38		sec				sec
.ae8e	60		rts				rts
.ae8f					GXLineIsComplete:
.ae8f	ad 18 07	lda $0718			lda 	GXIsDiffYLarger 			; is dy larger
.ae92	d0 0f		bne $aea3			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae94	ad 79 06	lda $0679			lda 	GXX0 						; compare X, LSB and MSB
.ae97	4d 7d 06	eor $067d			eor 	GXX1
.ae9a	d0 06		bne $aea2			bne 	_GXLICExit
.ae9c	ad 7a 06	lda $067a			lda 	GXX0+1
.ae9f	4d 7e 06	eor $067e			eor 	GXX1+1
.aea2					_GXLICExit:
.aea2	60		rts				rts
.aea3					_GXLICCompareY:
.aea3	ad 7f 06	lda $067f			lda 	GXY1
.aea6	4d 7b 06	eor $067b			eor 	GXY0
.aea9	60		rts				rts
.aeaa					GXLineAdvance:
.aeaa	18		clc				clc 								; add adjust to position
.aeab	ad 1a 07	lda $071a			lda 	GXPosition
.aeae	6d 1b 07	adc $071b			adc 	GXAdjust
.aeb1	8d 1a 07	sta $071a			sta 	GXPosition
.aeb4	9c 1d 07	stz $071d			stz 	GXAddSelect 				; clear add select flag
.aeb7	b0 05		bcs $aebe			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.aeb9	cd 1c 07	cmp $071c			cmp 	GXTotal 					; if exceeded total
.aebc	90 0a		bcc $aec8			bcc 	_GXLANoExtra
.aebe					_GXLAOverflow:
.aebe	ce 1d 07	dec $071d			dec 	GXAddSelect 				; set addselect to $FF
.aec1	38		sec				sec 								; subtract total and write back
.aec2	ed 1c 07	sbc $071c			sbc 	GXTotal
.aec5	8d 1a 07	sta $071a			sta 	GXPosition
.aec8					_GXLANoExtra:
.aec8	ad 18 07	lda $0718			lda 	GXIsDiffYLarger
.aecb	f0 0d		beq $aeda			beq 	_GXDXLarger
.aecd	20 2c af	jsr $af2c			jsr 	GXIncrementY
.aed0	ad 1d 07	lda $071d			lda 	GXAddSelect
.aed3	f0 10		beq $aee5			beq 	_GXLAExit
.aed5	20 e6 ae	jsr $aee6			jsr 	GXAdjustX
.aed8	80 0b		bra $aee5			bra 	_GXLAExit
.aeda					_GXDXLarger:
.aeda	20 e6 ae	jsr $aee6			jsr 	GXAdjustX
.aedd	ad 1d 07	lda $071d			lda 	GXAddSelect
.aee0	f0 03		beq $aee5			beq 	_GXLAExit
.aee2	20 2c af	jsr $af2c			jsr 	GXIncrementY
.aee5					_GXLAExit:
.aee5	60		rts				rts
.aee6					GXAdjustX:
.aee6	ad 19 07	lda $0719			lda 	GXDXNegative
.aee9	10 25		bpl $af10			bpl 	_GXAXRight
.aeeb	ad 79 06	lda $0679			lda 	GXX0
.aeee	d0 03		bne $aef3			bne 	_GXAXNoBorrow
.aef0	ce 7a 06	dec $067a			dec 	GXX0+1
.aef3					_GXAXNoBorrow:
.aef3	ce 79 06	dec $0679			dec 	GXX0
.aef6	ce 8b 06	dec $068b			dec 	gsOffset 					; pixel left
.aef9	ad 8b 06	lda $068b			lda 	gsOffset
.aefc	c9 ff		cmp #$ff			cmp 	#$FF
.aefe	d0 0f		bne $af0f			bne 	_GXAYExit 					; underflow
.af00	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.af02	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.af04	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.af06	b0 07		bcs $af0f			bcs 	_GXAYExit
.af08	18		clc				clc
.af09	69 20		adc #$20			adc 	#$20 						; fix up
.af0b	85 3d		sta $3d				sta 	gxzScreen+1
.af0d	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.af0f					_GXAYExit:
.af0f	60		rts				rts
.af10					_GXAXRight:
.af10	ee 79 06	inc $0679			inc 	GXX0
.af13	d0 03		bne $af18			bne 	_GXAXNoCarry
.af15	ee 7a 06	inc $067a			inc 	GXX0+1
.af18					_GXAXNoCarry:
.af18	ee 8b 06	inc $068b			inc 	gsOffset 					; pixel right
.af1b	d0 0e		bne $af2b			bne 	_GXAXExit 					; if not overflowed, exit.
.af1d	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.af1f	a5 3d		lda $3d				lda 	gxzScreen+1
.af21	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.af23	90 06		bcc $af2b			bcc 	_GXAXExit
.af25	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af27	85 3d		sta $3d				sta 	gxzScreen+1
.af29	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af2b					_GXAXExit:
.af2b	60		rts				rts
.af2c					GXIncrementY:
.af2c	ee 7b 06	inc $067b			inc 	GXY0
.af2f	20 a8 b3	jsr $b3a8			jsr 	GXMovePositionDown
.af32	60		rts				rts
.af33					GXLineSetup:
.af33	ad 7f 06	lda $067f			lda 	GXY1
.af36	38		sec				sec
.af37	ed 7b 06	sbc $067b			sbc 	GXY0
.af3a	4a		lsr a				lsr 	a
.af3b	8d 17 07	sta $0717			sta 	GXDiffY
.af3e	9c 19 07	stz $0719			stz 	GXDXNegative 				; clear -ve flag
.af41	38		sec				sec
.af42	ad 7d 06	lda $067d			lda 	GXX1
.af45	ed 79 06	sbc $0679			sbc 	GXX0
.af48	8d 16 07	sta $0716			sta 	GXDiffX
.af4b	ad 7e 06	lda $067e			lda 	GXX1+1 						; calculate MSB
.af4e	ed 7a 06	sbc $067a			sbc 	GXX0+1
.af51	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af52	6e 16 07	ror $0716			ror 	GXDiffX
.af55	0a		asl a				asl 	a
.af56	10 0c		bpl $af64			bpl 	_GDXNotNegative
.af58	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af5a	38		sec				sec
.af5b	ed 16 07	sbc $0716			sbc 	GXDiffX
.af5e	8d 16 07	sta $0716			sta 	GXDiffX
.af61	ce 19 07	dec $0719			dec 	GXDXNegative 				; -ve flag = $FF.
.af64					_GDXNotNegative:
.af64	9c 18 07	stz $0718			stz 	GXIsDiffYLarger 			; clear larger flag
.af67	ad 17 07	lda $0717			lda 	GXDiffY 					; set adjust and total.
.af6a	8d 1b 07	sta $071b			sta 	GXAdjust
.af6d	ad 16 07	lda $0716			lda 	GXDiffX
.af70	8d 1c 07	sta $071c			sta 	GXTotal
.af73	ad 17 07	lda $0717			lda 	GXDiffY 					; if dy > dx
.af76	cd 16 07	cmp $0716			cmp 	GXDiffX
.af79	90 0f		bcc $af8a			bcc 	_GDXNotLarger
.af7b	ce 18 07	dec $0718			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af7e	ad 16 07	lda $0716			lda 	GXDiffX 					; set adjust and total other way round
.af81	8d 1b 07	sta $071b			sta 	GXAdjust
.af84	ad 17 07	lda $0717			lda 	GXDiffY
.af87	8d 1c 07	sta $071c			sta 	GXTotal
.af8a					_GDXNotLarger:
.af8a	ad 1c 07	lda $071c			lda 	GXTotal
.af8d	4a		lsr a				lsr 	a
.af8e	8d 1a 07	sta $071a			sta 	GXPosition
.af91	60		rts				rts
.0716					GXDiffX:
>0716							.fill 	1
.0717					GXDiffY:
>0717							.fill 	1
.0718					GXIsDiffYLarger:
>0718							.fill 	1
.0719					GXDXNegative:
>0719							.fill 	1
.071a					GXPosition:
>071a							.fill 	1
.071b					GXAdjust:
>071b							.fill 	1
.071c					GXTotal:
>071c							.fill 	1
.071d					GXAddSelect:
>071d							.fill 	1
.af92					GXSetColourMode:
.af92	a6 36		ldx $36				ldx 	gxzTemp0
.af94	8e 87 06	stx $0687			stx 	gxColour 								; set colour
.af97	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af99	8d 86 06	sta $0686			sta 	gxMode 									; set mode
.af9c	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af9e	9c 89 06	stz $0689			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.afa1	ae 87 06	ldx $0687			ldx 	gxColour
.afa4	8e 88 06	stx $0688			stx 	gxEORValue
.afa7	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.afa9	90 03		bcc $afae			bcc 	_GXSDCNotAndColour
.afab	8e 89 06	stx $0689			stx 	gxANDValue
.afae					_GXSDCNotAndColour:
.afae	d0 03		bne $afb3			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.afb0	9c 88 06	stz $0688			stz 	gxEORValue
.afb3					_GXSDCNotAnd:
.afb3	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.afb4	90 08		bcc $afbe			bcc 	_GXSDCNoFlip
.afb6	ad 89 06	lda $0689			lda	 	gxANDValue
.afb9	49 ff		eor #$ff			eor 	#$FF
.afbb	8d 89 06	sta $0689			sta 	gxANDValue
.afbe					_GXSDCNoFlip:
.afbe	18		clc				clc
.afbf	60		rts				rts
.afc0					GXPlotPoint:
.afc0	20 42 b3	jsr $b342			jsr 	GXOpenBitmap 				; start drawing
.afc3	20 52 b3	jsr $b352			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afc6	ac 8b 06	ldy $068b			ldy 	gsOffset
.afc9	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afcb	2d 89 06	and $0689			and 	gxANDValue
.afce	4d 88 06	eor $0688			eor 	gxEORValue
.afd1	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afd3	20 4a b3	jsr $b34a			jsr 	GXCloseBitmap 				; stop drawing and exit
.afd6	18		clc				clc
.afd7	60		rts				rts
.afd8					GXFillRectangle:
.afd8	38		sec				sec
.afd9	80 01		bra $afdc			bra 	GXRectangle
.afdb					GXFrameRectangle:
.afdb	18		clc				clc
.afdc					GXRectangle:
.afdc	ad 82 06	lda $0682			lda 	gxBitmapsOn
.afdf	f0 35		beq $b016			beq 	_GXRFail
.afe1	08		php				php 								; save Fill flag (CS)
.afe2	20 42 b3	jsr $b342			jsr 	GXOpenBitmap 				; start drawing
.afe5	20 6a b4	jsr $b46a			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afe8	20 52 b3	jsr $b352			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afeb	38		sec				sec 								; sec = Draw line
.afec	20 18 b0	jsr $b018			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afef	ad 7b 06	lda $067b			lda 	gxY0 						; reached end of rectangle ?
.aff2	cd 7f 06	cmp $067f			cmp 	gxY1
.aff5	f0 19		beq $b010			beq 	_GXRectangleExit
.aff7					_GXRectLoop:
.aff7	20 a8 b3	jsr $b3a8			jsr 	GXMovePositionDown 			; down one.
.affa	ee 7b 06	inc $067b			inc 	gxY0 						; change Y pos
.affd	ad 7b 06	lda $067b			lda 	gxY0 						; reached last line
.b000	cd 7f 06	cmp $067f			cmp 	gXY1
.b003	f0 07		beq $b00c			beq 	_GXLastLine
.b005	28		plp				plp 								; get flag back
.b006	08		php				php
.b007	20 18 b0	jsr $b018			jsr 	GXDrawLineX1X0 				; draw horizontal line
.b00a	80 eb		bra $aff7			bra 	_GXRectLoop
.b00c					_GXLastLine:
.b00c	38		sec				sec
.b00d	20 18 b0	jsr $b018			jsr 	GXDrawLineX1X0
.b010					_GXRectangleExit:
.b010	68		pla				pla 								; throw fill flag.
.b011	20 4a b3	jsr $b34a			jsr 	GXCloseBitmap 				; stop drawing and exit
.b014	18		clc				clc
.b015	60		rts				rts
.b016					_GXRFail:
.b016	38		sec				sec
.b017	60		rts				rts
.b018					GXDrawLineX1X0:
.b018	08		php				php 								; save solid/either-end
.b019	38		sec				sec
.b01a	ad 7d 06	lda $067d			lda		gXX1
.b01d	ed 79 06	sbc $0679			sbc 	gXX0
.b020	85 36		sta $36				sta 	gxzTemp0
.b022	ad 7e 06	lda $067e			lda 	gXX1+1
.b025	ed 7a 06	sbc $067a			sbc 	gXX0+1
.b028	85 37		sta $37				sta 	gxzTemp0+1
.b02a	28		plp				plp
.b02b					GXDrawLineTemp0:
.b02b	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b02d	48		pha				pha
.b02e	a5 3d		lda $3d				lda 	gxzScreen+1
.b030	48		pha				pha
.b031	ad 8b 06	lda $068b			lda 	gsOffset
.b034	48		pha				pha
.b035	a5 0b		lda $0b				lda 	GXEditSlot
.b037	48		pha				pha
.b038	ac 8b 06	ldy $068b			ldy 	gsOffset 					; Y offset
.b03b	90 1e		bcc $b05b			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b03d					_GXDLTLine:
.b03d	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b03f	2d 89 06	and $0689			and 	gxANDValue
.b042	4d 88 06	eor $0688			eor 	gxEORValue
.b045	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b047	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b049	d0 04		bne $b04f			bne 	_GXDLTNoBorrow
.b04b	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b04d	30 2e		bmi $b07d			bmi 	_GXDLTExit
.b04f					_GXDLTNoBorrow:
.b04f	c6 36		dec $36				dec 	gxzTemp0
.b051	c8		iny				iny 								; next slot.
.b052	d0 e9		bne $b03d			bne 	_GXDLTLine
.b054	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b056	20 8b b0	jsr $b08b			jsr 	GXDLTCheckWrap				; check for new page.
.b059	80 e2		bra $b03d			bra 	_GXDLTLine
.b05b					_GXDLTEndPoints:
.b05b	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b05d	2d 89 06	and $0689			and 	gxANDValue
.b060	4d 88 06	eor $0688			eor 	gxEORValue
.b063	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b065	98		tya				tya 								; advance to right side
.b066	18		clc				clc
.b067	65 36		adc $36				adc 	gxzTemp0
.b069	a8		tay				tay
.b06a	a5 3d		lda $3d				lda 	gxzScreen+1
.b06c	65 37		adc $37				adc 	gxzTemp0+1
.b06e	85 3d		sta $3d				sta 	gxzScreen+1
.b070	20 8b b0	jsr $b08b			jsr 	GXDLTCheckWrap 			; fix up.
.b073	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b075	2d 89 06	and $0689			and 	gxANDValue
.b078	4d 88 06	eor $0688			eor 	gxEORValue
.b07b	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b07d					_GXDLTExit:
.b07d	68		pla				pla
.b07e	85 0b		sta $0b				sta 	GXEditSlot
.b080	68		pla				pla
.b081	8d 8b 06	sta $068b			sta 	gsOffset
.b084	68		pla				pla
.b085	85 3d		sta $3d				sta 	gxzScreen+1
.b087	68		pla				pla
.b088	85 3c		sta $3c				sta 	gxzScreen
.b08a	60		rts				rts
.b08b					GXDLTCheckWrap:
.b08b	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b08d	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b08f	90 06		bcc $b097			bcc 	_GXDLTCWExit
.b091	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b093	85 3d		sta $3d				sta 	gxzScreen+1
.b095	e6 0b		inc $0b				inc 	GXEditSlot
.b097					_GXDLTCWExit:
.b097	60		rts				rts
.b098					GXDrawGraphicElement:
.b098	8d 1e 07	sta $071e			sta 	gxSize 						; save size
.b09b	3a		dec a				dec 	a
.b09c	8d 1f 07	sta $071f			sta 	gxMask 						; and mask
.b09f	ad 82 06	lda $0682			lda 	gxBitmapsOn 				; check BMP on
.b0a2	f0 67		beq $b10b			beq 	_GXSLFail
.b0a4	ad 7b 06	lda $067b			lda 	gxY0 						; push Y on stack
.b0a7	48		pha				pha
.b0a8	8c 21 07	sty $0721			sty 	gxAcquireVector+1 			; and acquisition vector
.b0ab	8e 20 07	stx $0720			stx 	gxAcquireVector
.b0ae	20 42 b3	jsr $b342			jsr 	gxOpenBitmap 				; open the bitmap.
.b0b1	ad 23 07	lda $0723			lda 	gxUseMode 					; scale bits
.b0b4	4a		lsr a				lsr 	a
.b0b5	4a		lsr a				lsr 	a
.b0b6	4a		lsr a				lsr 	a
.b0b7	29 07		and #$07			and		#7
.b0b9	1a		inc a				inc 	a
.b0ba	8d 22 07	sta $0722			sta 	gxScale
.b0bd	64 38		stz $38				stz 	gxzTemp1					; start first line
.b0bf					_GXGELoop:
.b0bf	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b0c1	2c 23 07	bit $0723			bit 	gxUseMode 					; check for flip.
.b0c4	10 06		bpl $b0cc			bpl		_GXNoVFlip
.b0c6	ad 1f 07	lda $071f			lda 	gxMask
.b0c9	38		sec				sec
.b0ca	e5 38		sbc $38				sbc 	gxzTemp1
.b0cc					_GXNoVFlip:
.b0cc	aa		tax				tax 								; get the Xth line.
.b0cd	20 0d b1	jsr $b10d			jsr 	_GXCallAcquire 				; get that data.
.b0d0	ad 22 07	lda $0722			lda 	gxScale 					; do scale identical copies of that line.
.b0d3	85 39		sta $39				sta 	gxzTemp1+1
.b0d5					_GXGELoop2:
.b0d5	ad 7b 06	lda $067b			lda 	gxY0 						; off screen
.b0d8	cd 85 06	cmp $0685			cmp 	gxHeight
.b0db	b0 10		bcs $b0ed			bcs 	_GXDGEExit
.b0dd	20 10 b1	jsr $b110			jsr 	GXRenderOneLine 			; render line
.b0e0	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0e2	d0 f1		bne $b0d5			bne 	_GXGELoop2
.b0e4	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0e6	a5 38		lda $38				lda 	gxzTemp1
.b0e8	cd 1e 07	cmp $071e			cmp 	gxSize
.b0eb	d0 d2		bne $b0bf			bne 	_GXGELoop
.b0ed					_GXDGEExit:
.b0ed	68		pla				pla 								; restore Y for next time
.b0ee	8d 7b 06	sta $067b			sta 	gxY0
.b0f1	ae 22 07	ldx $0722			ldx 	gxScale 					; get scale (1-8)
.b0f4					_GXShiftLeft:
.b0f4	18		clc				clc
.b0f5	ad 1e 07	lda $071e			lda 	gxSize
.b0f8	6d 79 06	adc $0679			adc 	gxX0
.b0fb	8d 79 06	sta $0679			sta 	gxX0
.b0fe	90 03		bcc $b103			bcc 	_GXSLNoCarry
.b100	ee 7a 06	inc $067a			inc 	gxX0+1
.b103					_GXSLNoCarry:
.b103	ca		dex				dex
.b104	d0 ee		bne $b0f4			bne 	_GXShiftLeft
.b106	20 4a b3	jsr $b34a			jsr 	GXCloseBitmap
.b109	18		clc				clc
.b10a	60		rts				rts
.b10b					_GXSLFail:
.b10b	38		sec				sec
.b10c	60		rts				rts
.b10d					_GXCallAcquire:
.b10d	6c 20 07	jmp ($0720)			jmp 	(gxAcquireVector)
.b110					GXRenderOneLine:
.b110	20 52 b3	jsr $b352			jsr 	GXPositionCalc 				; calculate position/offset.
.b113	ac 8b 06	ldy $068b			ldy 	gsOffset 					; Y contains position.
.b116	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b118					_GXROLLoop1:
.b118	ad 22 07	lda $0722			lda 	gxScale 					; set to do 'scale' times
.b11b	85 3b		sta $3b				sta 	gxzTemp2+1
.b11d					_GXROLLoop2:
.b11d	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b11f	2c 86 06	bit $0686			bit 	gxMode 						; check H Flip
.b122	50 06		bvc $b12a			bvc 	_GXNoHFlip
.b124	ad 1f 07	lda $071f			lda 	gxMask
.b127	38		sec				sec
.b128	e5 3a		sbc $3a				sbc 	gxzTemp2
.b12a					_GXNoHFlip:
.b12a	aa		tax				tax 								; read from the pixel buffer
.b12b	bd 27 06	lda $0627,x			lda 	gxPixelBuffer,x
.b12e	d0 07		bne $b137			bne 	_GXDraw 					; draw if non zero
.b130	ad 23 07	lda $0723			lda 	gxUseMode 					; check to see if solid background
.b133	29 04		and #$04			and 	#4
.b135	f0 0a		beq $b141			beq 	_GXZeroPixel
.b137					_GXDraw:
.b137	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b139	2d 89 06	and $0689			and 	gxANDValue
.b13c	5d 27 06	eor $0627,x			eor 	gxPixelBuffer,x
.b13f	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b141					_GXZeroPixel:
.b141	c8		iny				iny 								; advance pointer
.b142	d0 05		bne $b149			bne 	_GXNoShift
.b144	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b146	20 8b b0	jsr $b08b			jsr 	GXDLTCheckWrap				; check for new page.
.b149					_GXNoShift:
.b149	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b14b	d0 d0		bne $b11d			bne 	_GXROLLoop2
.b14d	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b14f	a5 3a		lda $3a				lda 	gxzTemp2
.b151	cd 1e 07	cmp $071e			cmp 	gxSize
.b154	d0 c2		bne $b118			bne 	_GXROLLoop1
.b156	ee 7b 06	inc $067b			inc 	gxY0
.b159	60		rts				rts
.071e					gxSize:
>071e							.fill 	1
.071f					gxMask:
>071f							.fill 	1
.0720					gxAcquireVector:
>0720							.fill 	2
.0722					gxScale:
>0722							.fill 	1
.0723					gxUseMode:
>0723							.fill 	1
.b15a					GXFontHandler:
.b15a	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b15c	4d 86 06	eor $0686			eor 	gxMode
.b15f	8d 23 07	sta $0723			sta 	gxUseMode
.b162	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b164	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b166	26 37		rol $37				rol	 	gxzTemp0+1
.b168	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b16a	26 37		rol $37				rol	 	gxzTemp0+1
.b16c	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b16e	26 37		rol $37				rol	 	gxzTemp0+1
.b170	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b172	09 c0		ora #$c0			ora 	#$C0
.b174	85 37		sta $37				sta 	gxzTemp0+1
.b176	a9 08		lda #$08			lda 	#8 							; size 8x8
.b178	a2 80		ldx #$80			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b17a	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b17c	20 98 b0	jsr $b098			jsr 	GXDrawGraphicElement
.b17f	60		rts				rts
.b180					GXGetGraphicDataFont:
.b180	8a		txa				txa 								; X->Y
.b181	a8		tay				tay
.b182	a6 01		ldx $01				ldx 	1 							; preserve old value
.b184	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b186	85 01		sta $01				sta 	1
.b188	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b18a	86 01		stx $01				stx 	1 							; put old value back.
.b18c	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b18e					_GXExpand:
.b18e	9e 27 06	stz $0627,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b191	0a		asl a				asl 	a 							; shift bit 7 into C
.b192	90 08		bcc $b19c			bcc 	_GXNoPixel
.b194	48		pha				pha 								; if set, set pixel buffer to current colour.
.b195	ad 87 06	lda $0687			lda 	gxColour
.b198	9d 27 06	sta $0627,x			sta 	gxPixelBuffer,x
.b19b	68		pla				pla
.b19c					_GXNoPixel:
.b19c	e8		inx				inx 								; do the whole byte.
.b19d	e0 08		cpx #$08			cpx 	#8
.b19f	d0 ed		bne $b18e			bne 	_GXExpand
.b1a1	60		rts				rts
.b1a2					GXSpriteHandler:
.b1a2	ad 81 06	lda $0681			lda 	gxSpritesOn 				; sprites on ?
.b1a5	f0 23		beq $b1ca			beq 	_GXSHExit
.b1a7	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b1a9	4d 86 06	eor $0686			eor 	gxMode
.b1ac	8d 23 07	sta $0723			sta 	gxUseMode
.b1af	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b1b1	da		phx				phx
.b1b2	20 42 b3	jsr $b342			jsr 	GXOpenBitmap 				; can access sprite information
.b1b5	68		pla				pla
.b1b6	20 23 b4	jsr $b423			jsr 	GXFindSprite 				; get the sprite address
.b1b9	08		php				php
.b1ba	20 4a b3	jsr $b34a			jsr 	GXCloseBitmap
.b1bd	28		plp				plp
.b1be	b0 0a		bcs $b1ca			bcs		_GXSHExit 					; exit if find failed.
.b1c0	ad 24 07	lda $0724			lda 	GXSizePixels 				; return size
.b1c3	a2 cb		ldx #$cb			ldx 	#GXSpriteAcquire & $FF
.b1c5	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b1c7	20 98 b0	jsr $b098			jsr 	GXDrawGraphicElement
.b1ca					_GXSHExit:
.b1ca	60		rts				rts
.b1cb					GXSpriteAcquire:
.b1cb	ad 84 06	lda $0684			lda 	GXSpritePage				; point to base page
.b1ce	85 0b		sta $0b				sta 	GXEditSlot
.b1d0	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1d2	a9 00		lda #$00			lda 	#0
.b1d4	ae 25 07	ldx $0725			ldx 	GXSizeBits
.b1d7					_GXTimesRowNumber:
.b1d7	18		clc				clc
.b1d8	65 36		adc $36				adc 	zTemp0
.b1da	ca		dex				dex
.b1db	10 fa		bpl $b1d7			bpl 	_GXTimesRowNumber
.b1dd	64 37		stz $37				stz 	gxzTemp0+1
.b1df	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1e0	26 37		rol $37				rol 	gxzTemp0+1
.b1e2	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1e3	26 37		rol $37				rol 	gxzTemp0+1
.b1e5	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1e6	26 37		rol $37				rol 	gxzTemp0+1
.b1e8	85 36		sta $36				sta 	gxzTemp0
.b1ea	18		clc				clc 								; add base address.
.b1eb	a5 36		lda $36				lda 	gxzTemp0
.b1ed	6d 27 07	adc $0727			adc 	GXSpriteOffset
.b1f0	85 36		sta $36				sta 	gxzTemp0
.b1f2	a5 37		lda $37				lda 	gxzTemp0+1
.b1f4	6d 28 07	adc $0728			adc 	GXSpriteOffset+1
.b1f7					_GXSAFindPage:
.b1f7	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1f9	90 06		bcc $b201			bcc 	_GXSAFoundPage
.b1fb	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1fd	e6 0b		inc $0b				inc 	GXEditSlot
.b1ff	80 f6		bra $b1f7			bra 	_GXSAFindPage
.b201					_GXSAFoundPage:
.b201	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b203	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b205	a0 00		ldy #$00			ldy 	#0
.b207					_GXSACopyLoop:
.b207	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b209	99 27 06	sta $0627,y			sta 	gxPixelBuffer,y
.b20c	c8		iny				iny
.b20d	cc 24 07	cpy $0724			cpy 	GXSizePixels
.b210	d0 f5		bne $b207			bne 	_GXSACopyLoop
.b212	60		rts				rts
.b213					GXSelect:
.b213	ad 81 06	lda $0681			lda 	gxSpritesOn
.b216	f0 22		beq $b23a			beq 	_GXSFail
.b218	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b21a	c9 40		cmp #$40			cmp 	#64
.b21c	b0 1c		bcs $b23a			bcs 	_GXSFail
.b21e	8d 8c 06	sta $068c			sta 	GSCurrentSpriteID
.b221	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b223	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b225	06 36		asl $36				asl 	gxzTemp0
.b227	06 36		asl $36				asl 	gxzTemp0
.b229	06 36		asl $36				asl 	gxzTemp0
.b22b	2a		rol a				rol 	a
.b22c	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b22e	8d 8e 06	sta $068e			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b231	85 37		sta $37				sta 	gxzTemp0+1
.b233	a5 36		lda $36				lda 	gxzTemp0
.b235	8d 8d 06	sta $068d			sta 	GSCurrentSpriteAddr
.b238	18		clc				clc
.b239	60		rts				rts
.b23a					_GXSFail:
.b23a	38		sec				sec
.b23b	60		rts				rts
.b23c					GXSelectImage:
.b23c	ad 81 06	lda $0681			lda 	gxSpritesOn
.b23f	f0 74		beq $b2b5			beq 	_GXSIFail
.b241	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b244	f0 6f		beq $b2b5			beq 	_GXSIFail 					; (checking the MSB)
.b246	64 01		stz $01				stz 	1
.b248	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b24a	d0 6b		bne $b2b7			bne 	_GXSIHide
.b24c	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b24e	48		pha				pha
.b24f	20 42 b3	jsr $b342			jsr 	GXOpenBitmap
.b252	68		pla				pla
.b253	20 23 b4	jsr $b423			jsr 	GXFindSprite
.b256	b0 5a		bcs $b2b2			bcs 	_GXSICloseFail 				; no image
.b258	a0 01		ldy #$01			ldy 	#1
.b25a	ad 8d 06	lda $068d			lda 	GSCurrentSpriteAddr
.b25d	85 36		sta $36				sta 	gxzTemp0
.b25f	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1
.b262	85 37		sta $37				sta 	gxzTemp0+1
.b264	ad 27 07	lda $0727			lda 	GXSpriteOffset
.b267	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b269	18		clc				clc
.b26a	ad 28 07	lda $0728			lda 	GXSpriteOffset+1
.b26d	6d 8f 06	adc $068f			adc 	GXSpriteOffsetBase
.b270	c8		iny				iny
.b271	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b273	ad 90 06	lda $0690			lda 	GXSpriteOffsetBase+1
.b276	69 00		adc #$00			adc 	#0
.b278	c8		iny				iny
.b279	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b27b	ad 25 07	lda $0725			lda 	GXSizeBits 					; get raw size
.b27e	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b280	2a		rol a				rol 	a 							; x 2
.b281	0a		asl a				asl 	a 							; x 4
.b282	0a		asl a				asl 	a 							; x 8
.b283	0a		asl a				asl 	a 							; x 16
.b284	0d 26 07	ora $0726			ora 	GXSpriteLUT 				; Or with LUT
.b287	0a		asl a				asl 	a 							; 1 shift
.b288	09 01		ora #$01			ora 	#1 							; enable sprite.
.b28a	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b28c	20 4a b3	jsr $b34a			jsr 	GXCloseBitmap
.b28f	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b292	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b295	29 3f		and #$3f			and 	#$3F
.b297	9d d1 06	sta $06d1,x			sta 	GXSpriteHigh,x
.b29a	ad 25 07	lda $0725			lda 	GXSizeBits 					; get bit size
.b29d	6a		ror a				ror 	a 							; shift into bits 6/7
.b29e	6a		ror a				ror 	a
.b29f	6a		ror a				ror 	a
.b2a0	29 c0		and #$c0			and 	#$C0
.b2a2	1d d1 06	ora $06d1,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b2a5	9d d1 06	sta $06d1,x			sta 	GXSpriteHigh,x
.b2a8	bd 91 06	lda $0691,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b2ab	29 7f		and #$7f			and 	#$7F
.b2ad	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.b2b0	18		clc				clc
.b2b1	60		rts				rts
.b2b2					_GXSICloseFail:
.b2b2	20 4a b3	jsr $b34a			jsr 	GXCloseBitmap
.b2b5					_GXSIFail:
.b2b5	38		sec				sec
.b2b6	60		rts				rts
.b2b7					_GXSIHide:
.b2b7	ad 8d 06	lda $068d			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b2ba	85 36		sta $36				sta 	gxzTemp0
.b2bc	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1
.b2bf	85 37		sta $37				sta 	gxzTemp0+1
.b2c1	a9 00		lda #$00			lda 	#0
.b2c3	92 36		sta ($36)			sta 	(gxzTemp0)
.b2c5	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; get sprite ID
.b2c8	bd 91 06	lda $0691,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2cb	09 80		ora #$80			ora 	#$80
.b2cd	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.b2d0	18		clc				clc
.b2d1	60		rts				rts
.b2d2					GXMoveSprite:
.b2d2	ad 81 06	lda $0681			lda 	gxSpritesOn
.b2d5	f0 65		beq $b33c			beq 	_GXSIFail
.b2d7	ad 8e 06	lda $068e			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2da	f0 60		beq $b33c			beq 	_GXSIFail
.b2dc	85 37		sta $37				sta 	gxzTemp0+1
.b2de	a0 04		ldy #$04			ldy 	#4
.b2e0	ad 8d 06	lda $068d			lda 	GSCurrentSpriteAddr
.b2e3	85 36		sta $36				sta 	gxzTemp0
.b2e5	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2e8	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x
.b2eb	2a		rol a				rol 	a	 						; into bits 0,1.
.b2ec	2a		rol a				rol 	a
.b2ed	2a		rol a				rol 	a
.b2ee	29 03		and #$03			and 	#3
.b2f0	aa		tax				tax
.b2f1	bd 3e b3	lda $b33e,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2f4	48		pha				pha
.b2f5	18		clc				clc
.b2f6	6d 79 06	adc $0679			adc 	gxX0						; copy position.
.b2f9	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2fb	c8		iny				iny
.b2fc	ad 7a 06	lda $067a			lda 	gxX0+1
.b2ff	69 00		adc #$00			adc 	#0
.b301	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b303	c8		iny				iny
.b304	68		pla				pla
.b305	18		clc				clc
.b306	6d 7b 06	adc $067b			adc 	gxY0
.b309	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b30b	a9 00		lda #$00			lda 	#0
.b30d	69 00		adc #$00			adc 	#0
.b30f	c8		iny				iny
.b310	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b312	4e 7a 06	lsr $067a			lsr 	gxX0+1 						; divide X by 4
.b315	6e 79 06	ror $0679			ror 	gxX0
.b318	4e 79 06	lsr $0679			lsr 	gxX0
.b31b	4e 7b 06	lsr $067b			lsr 	gxY0 						; divide Y by 4
.b31e	4e 7b 06	lsr $067b			lsr 	gxY0
.b321	ae 8c 06	ldx $068c			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b324	bd 91 06	lda $0691,x			lda 	GXSpriteLow,x
.b327	29 80		and #$80			and 	#$80
.b329	0d 79 06	ora $0679			ora 	gxX0
.b32c	9d 91 06	sta $0691,x			sta 	GXSpriteLow,x
.b32f	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x
.b332	29 c0		and #$c0			and 	#$C0
.b334	0d 7b 06	ora $067b			ora 	gxY0
.b337	9d d1 06	sta $06d1,x			sta 	GXSpriteHigh,x
.b33a	18		clc				clc
.b33b	60		rts				rts
.b33c					_GXSIFail:
.b33c	38		sec				sec
.b33d	60		rts				rts
.b33e					_GXMSOffset:
>b33e	1c						.byte 	32-8/2
>b33f	18						.byte 	32-16/2
>b340	14						.byte 	32-24/2
>b341	10						.byte 	32-32/2
.b342					GXOpenBitmap:
.b342	78		sei				sei 								; no interrupts here
.b343	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b345	8d 8a 06	sta $068a			sta 	gxOriginalLUTValue
.b348	58		cli				cli
.b349	60		rts				rts
.b34a					GXCloseBitmap:
.b34a	78		sei				sei
.b34b	ad 8a 06	lda $068a			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b34e	85 0b		sta $0b				sta 	GXEditSlot
.b350	58		cli				cli
.b351	60		rts				rts
.b352					GXPositionCalc:
.b352	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b354	48		pha				pha
.b355	ad 7b 06	lda $067b			lda 	GXY0 						; gxzScreen = Y0
.b358	85 3c		sta $3c				sta 	gxzScreen
.b35a	64 3d		stz $3d				stz 	gxzScreen+1
.b35c	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b35e	26 3d		rol $3d				rol 	gxzScreen+1
.b360	06 3c		asl $3c				asl 	gxzScreen
.b362	26 3d		rol $3d				rol 	gxzScreen+1
.b364	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b365	65 3c		adc $3c				adc 	gxzScreen
.b367	85 3c		sta $3c				sta 	gxzScreen
.b369	90 02		bcc $b36d			bcc 	_GXPCNoCarry
.b36b	e6 3d		inc $3d				inc 	gxzScreen+1
.b36d					_GXPCNoCarry:
.b36d	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b36f	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b371	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b373	85 36		sta $36				sta 	gxzTemp0
.b375	64 3d		stz $3d				stz 	gxzScreen+1
.b377	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b379					_GXPCMultiply32:
.b379	06 3c		asl $3c				asl 	gxzScreen
.b37b	26 3d		rol $3d				rol 	gxzScreen+1
.b37d	3a		dec a				dec 	a
.b37e	d0 f9		bne $b379			bne 	_GXPCMultiply32
.b380	18		clc				clc
.b381	ad 79 06	lda $0679			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b384	65 3c		adc $3c				adc 	gxzScreen
.b386	8d 8b 06	sta $068b			sta 	gsOffset
.b389	ad 7a 06	lda $067a			lda 	GXX0+1
.b38c	65 3d		adc $3d				adc 	gxzScreen+1
.b38e	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b390	90 04		bcc $b396			bcc 	_GXPCNoOverflow
.b392	29 1f		and #$1f			and 	#$1F 						; fix it up
.b394	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b396					_GXPCNoOverflow:
.b396	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b398	85 3d		sta $3d				sta 	gxzScreen+1
.b39a	64 3c		stz $3c				stz 	gxzScreen
.b39c	18		clc				clc
.b39d	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b39f	6d 83 06	adc $0683			adc 	gxBasePage 					; by adding the base page
.b3a2	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b3a4	68		pla				pla
.b3a5	85 36		sta $36				sta 	gxzTemp0
.b3a7	60		rts				rts
.b3a8					GXMovePositionDown:
.b3a8	18		clc				clc 								; add 320 to offset/temp+1
.b3a9	ad 8b 06	lda $068b			lda 	gsOffset
.b3ac	69 40		adc #$40			adc 	#64
.b3ae	8d 8b 06	sta $068b			sta 	gsOffset
.b3b1	a5 3d		lda $3d				lda 	gxzScreen+1
.b3b3	69 01		adc #$01			adc 	#1
.b3b5	85 3d		sta $3d				sta 	gxzScreen+1
.b3b7	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b3b9	90 07		bcc $b3c2			bcc 	_GXMPDExit
.b3bb	38		sec				sec  								; next page
.b3bc	e9 20		sbc #$20			sbc 	#$20
.b3be	85 3d		sta $3d				sta 	gxzScreen+1
.b3c0	e6 0b		inc $0b				inc 	GXEditSlot
.b3c2					_GXMPDExit:
.b3c2	60		rts				rts
.b3c3					GXCollide:
.b3c3	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b3c5	aa		tax				tax
.b3c6	05 37		ora $37				ora 	gxzTemp0+1
.b3c8	29 c0		and #$c0			and 	#$C0
.b3ca	38		sec				sec
.b3cb	d0 53		bne $b420			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3cd	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3cf	b9 91 06	lda $0691,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3d2	1d 91 06	ora $0691,x			ora 	GXSpriteLow,x
.b3d5	30 48		bmi $b41f			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3d7	18		clc				clc 								; need to calculate sum of sizes.
.b3d8	b9 d1 06	lda $06d1,y			lda 	GXSpriteHigh,y
.b3db	7d d1 06	adc $06d1,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3de	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3e0	6a		ror a				ror 	a 							; 5/6/7
.b3e1	4a		lsr a				lsr 	a 							; 4/5/6
.b3e2	4a		lsr a				lsr 	a 							; 3/4/5
.b3e3	4a		lsr a				lsr 	a 							; 2/3/4
.b3e4	18		clc				clc
.b3e5	69 08		adc #$08			adc 	#$08
.b3e7	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3e8	4a		lsr a				lsr 	a
.b3e9	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3eb	b9 d1 06	lda $06d1,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3ee	29 3f		and #$3f			and 	#$3F
.b3f0	85 39		sta $39				sta 	gxzTemp1+1
.b3f2	38		sec				sec
.b3f3	bd d1 06	lda $06d1,x			lda 	GXSpriteHigh,x
.b3f6	29 3f		and #$3f			and 	#$3F
.b3f8	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3fa	b0 03		bcs $b3ff			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3fc	49 ff		eor #$ff			eor 	#$FF
.b3fe	1a		inc a				inc 	a
.b3ff					_GXCAbs1:
.b3ff	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b401	b0 1c		bcs $b41f			bcs 	_GXOkayFail
.b403	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b405	38		sec				sec 								; calculate |x1-x0|
.b406	b9 91 06	lda $0691,y			lda 	GXSpriteLow,y
.b409	fd 91 06	sbc $0691,x			sbc 	GXSpriteLow,x
.b40c	b0 03		bcs $b411			bcs 	_GXCAbs2
.b40e	49 ff		eor #$ff			eor 	#$FF
.b410	1a		inc a				inc 	a
.b411					_GXCAbs2:
.b411	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b413	b0 0a		bcs $b41f			bcs 	_GXOkayFail
.b415	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b417	90 02		bcc $b41b			bcc 	_GXCHaveLowest
.b419	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b41b					_GXCHaveLowest:
.b41b	0a		asl a				asl 	a 							; scale to allow for >> 2
.b41c	0a		asl a				asl 	a
.b41d	18		clc				clc
.b41e	60		rts				rts
.b41f					_GXOkayFail:
.b41f	18		clc				clc
.b420					_GXCollideFail:
.b420	a9 ff		lda #$ff			lda 	#$FF
.b422	60		rts				rts
.b423					GXFindSprite:
.b423	aa		tax				tax
.b424	ad 84 06	lda $0684			lda 	GXSpritePage 				; access the base page of the sprite
.b427	85 0b		sta $0b				sta 	GXEditSlot
.b429	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b42c	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b42f	f0 33		beq $b464			beq 	_GXFSFail
.b431	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b434	8d 28 07	sta $0728			sta 	GXSpriteOffset+1
.b437	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b43a	48		pha				pha 								; save twice
.b43b	48		pha				pha
.b43c	29 03		and #$03			and 	#3 							; get sprite size
.b43e	8d 25 07	sta $0725			sta 	GXSizeBits 					; save raw (0-3)
.b441	aa		tax				tax
.b442	bd 66 b4	lda $b466,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b445	8d 24 07	sta $0724			sta 	GXSizePixels 					; save (8/16/24/32)
.b448	68		pla				pla 								; get LUT
.b449	4a		lsr a				lsr		a
.b44a	4a		lsr a				lsr		a
.b44b	29 03		and #$03			and 	#3
.b44d	8d 26 07	sta $0726			sta 	GXSpriteLUT
.b450	68		pla				pla 								; address, neeeds to be x 4
.b451	29 f0		and #$f0			and 	#$F0
.b453	8d 27 07	sta $0727			sta 	GXSpriteOffset
.b456	0e 27 07	asl $0727			asl 	GXSpriteOffset
.b459	2e 28 07	rol $0728			rol 	GXSpriteOffset+1
.b45c	0e 27 07	asl $0727			asl 	GXSpriteOffset
.b45f	2e 28 07	rol $0728			rol 	GXSpriteOffset+1
.b462	18		clc				clc
.b463	60		rts				rts
.b464					_GXFSFail:
.b464	38		sec				sec
.b465	60		rts				rts
.b466					_GXFXSSTTable:
>b466	08 10 18 20					.byte 	8,16,24,32
.0724					GXSizePixels:
>0724							.fill 	1
.0725					GXSizeBits:
>0725							.fill 	1
.0726					GXSpriteLUT:
>0726							.fill 	1
.0727					GXSpriteOffset:
>0727							.fill 	2
.b46a					GXSortXY:
.b46a	20 88 b4	jsr $b488			jsr 	GXSortY 					; will be sorted on Y now
.b46d	ad 79 06	lda $0679			lda 	gxX0 						; compare X0 v X1
.b470	cd 7d 06	cmp $067d			cmp 	gxX1
.b473	ad 7a 06	lda $067a			lda 	gXX0+1
.b476	ed 7e 06	sbc $067e			sbc 	gXX1+1
.b479	90 0c		bcc $b487			bcc 	_GXSXYExit 					; X0 < X1 exit
.b47b	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b47d	a0 04		ldy #$04			ldy 	#4
.b47f	20 9c b4	jsr $b49c			jsr 	GXSwapXY
.b482	e8		inx				inx
.b483	c8		iny				iny
.b484	20 9c b4	jsr $b49c			jsr 	GXSwapXY
.b487					_GXSXYExit:
.b487	60		rts				rts
.b488					GXSortY:
.b488	ad 7b 06	lda $067b			lda 	gxY0 						; if Y0 >= Y1
.b48b	cd 7f 06	cmp $067f			cmp 	gxY1
.b48e	90 0b		bcc $b49b			bcc 	_GXSYSorted
.b490	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b492	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b494					_GXSwap1:
.b494	20 9c b4	jsr $b49c			jsr 	GXSwapXY
.b497	88		dey				dey
.b498	ca		dex				dex
.b499	10 f9		bpl $b494			bpl 	_GXSwap1
.b49b					_GXSYSorted:
.b49b	60		rts				rts
.b49c					GXSwapXY:
.b49c	bd 79 06	lda $0679,x			lda 	gxX0,x
.b49f	48		pha				pha
.b4a0	b9 79 06	lda $0679,y			lda 	gxX0,y
.b4a3	9d 79 06	sta $0679,x			sta 	gxX0,x
.b4a6	68		pla				pla
.b4a7	99 79 06	sta $0679,y			sta 	gxX0,y
.b4aa	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.b4ab					KeywordSet0:
>b4ab	00 65					.text	0,$65,""               ; $80 !0:EOF
>b4ad	00 58					.text	0,$58,""               ; $81 !1:SH1
>b4af	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b4b1	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>b4b7	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>b4bf	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>b4c5	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>b4cc	05 41 44 45 45 4b 28			.text	5,$41,"DEEK("          ; $87 DEEK(
>b4d3	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $88 EVENT(
>b4db	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $89 FALSE
>b4e2	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $8a FRAC(
>b4e9	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8b HIT(
>b4ef	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8c INT(
>b4f5	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8d ISVAL(
>b4fd	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8e JOYB(
>b504	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8f JOYX(
>b50b	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $90 JOYY(
>b512	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $91 LEFT$(
>b51a	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $92 LEN(
>b520	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $93 MAX(
>b526	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $94 MID$(
>b52d	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $95 MIN(
>b533	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $96 NOT(
>b539	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $97 PEEK(
>b540	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $98 PLAYING(
>b548	47 28
>b54a	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $99 RANDOM(
>b552	28
>b553	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $9a RIGHT$(
>b55b	28
>b55c	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $9b RND(
>b562	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9c SGN(
>b568	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9d SPC(
>b56e	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9e STR$(
>b575	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9f TIMER(
>b57d	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $a0 TRUE
>b583	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $a1 VAL(
>b589	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a2 FOR
>b58e	02 8f 49 46				.text	2,$8f,"IF"             ; $a3 IF
>b592	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a4 PROC
>b598	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a5 REPEAT
>b5a0	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a6 WHILE
>b5a7	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a7 ENDIF
>b5ae	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a8 ENDPROC
>b5b6	43
>b5b7	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a9 NEXT
>b5bd	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $aa THEN
>b5c3	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $ab UNTIL
>b5ca	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ac WEND
>b5d0	02 9b 42 59				.text	2,$9b,"BY"             ; $ad BY
>b5d4	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ae CALL
>b5da	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $af CIRCLE
>b5e2	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $b0 CLEAR
>b5e9	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $b1 CLS
>b5ee	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b2 COLOR
>b5f5	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b3 COLOUR
>b5fd	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b4 DATA
>b603	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b5 DIM
>b608	04 23 44 4f 4b 45			.text	4,$23,"DOKE"           ; $b6 DOKE
>b60e	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b7 DOWNTO
>b616	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b8 ELSE
>b61c	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b9 FROM
>b622	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $ba GFX
>b627	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $bb GOSUB
>b62e	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $bc GOTO
>b634	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $bd HERE
>b63a	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $be IMAGE
>b641	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bf INPUT
>b648	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $c0 LET
>b64d	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $c1 LINE
>b653	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $c2 LOCAL
>b65a	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c3 OFF
>b65f	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c4 ON
>b663	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c5 OUTLINE
>b66b	45
>b66c	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c6 PALETTE
>b674	45
>b675	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c7 PLOT
>b67b	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $c8 POKE
>b681	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c9 PRINT
>b688	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $ca READ
>b68e	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $cb RECT
>b694	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $cc REM
>b699	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $cd RETURN
>b6a1	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ce SOLID
>b6a8	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cf SOUND
>b6af	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $d0 SPRITE
>b6b7	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $d1 TEXT
>b6bd	02 a3 54 4f				.text	2,$a3,"TO"             ; $d2 TO
>b6c1	ff					.text	$FF
.b6c2					KeywordSet1:
>b6c2	00 65					.text	0,$65,""               ; $80 !0:EOF
>b6c4	00 58					.text	0,$58,""               ; $81 !1:SH1
>b6c6	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b6c8	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>b6d0	4c 45
>b6d2	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>b6da	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>b6e2	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>b6e7	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $87 EXPLODE
>b6ef	45
>b6f0	02 96 47 4f				.text	2,$96,"GO"             ; $88 GO
>b6f4	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $89 LIST
>b6fa	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $8a LOAD
>b700	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8b NEW
>b705	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $8c PING
>b70b	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8d RESTORE
>b713	45
>b714	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8e RUN
>b719	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $8f SHOOT
>b720	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $90 SPRITES
>b728	53
>b729	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $91 STOP
>b72f	03 ee 57 48 4f				.text	3,$ee,"WHO"            ; $92 WHO
>b734	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $93 ZAP
>b739	ff					.text	$FF
.b73a					KeywordSet2:
>b73a	00 65					.text	0,$65,""               ; $80 !0:EOF
>b73c	00 58					.text	0,$58,""               ; $81 !1:SH1
>b73e	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>b740	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>b745	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>b74a	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>b74f	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>b754	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>b759	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>b75e	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>b763	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>b768	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>b76d	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>b772	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>b777	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>b77c	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>b781	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>b786	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>b78b	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>b790	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>b795	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>b79a	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>b79f	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>b7a4	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>b7a9	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>b7ae	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>b7b3	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>b7b8	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>b7bd	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>b7c2	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>b7c7	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>b7cc	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>b7d1	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>b7d6	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>b7db	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>b7e0	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>b7e5	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>b7ea	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>b7ef	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>b7f4	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>b7f9	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>b7fe	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>b803	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>b808	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>b80d	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>b812	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>b817	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>b81c	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>b821	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>b826	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>b82b	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>b830	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>b835	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>b83a	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>b83f	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>b844	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>b849	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>b84e	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>b853	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>b858	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>b85d	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>b862	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>b867	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>b86c	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>b871	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>b876	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>b87b	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>b880	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>b885	ff					.text	$FF
.b886					Export_TKListConvertLine:
.b886	48		pha				pha 								; save indent on the stack
.b887	9c 1d 04	stz $041d			stz 	tbOffset
.b88a	9c 2d 04	stz $042d			stz 	tokenBuffer
.b88d	9c 29 04	stz $0429			stz 	currentListColour
.b890	a9 89		lda #$89			lda 	#CLILineNumber+$80
.b892	20 0f ba	jsr $ba0f			jsr 	LCLWriteColour
.b895	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b897	b1 30		lda ($30),y			lda 	(codePtr),y
.b899	aa		tax				tax
.b89a	88		dey				dey
.b89b	b1 30		lda ($30),y			lda 	(codePtr),y
.b89d	20 80 ba	jsr $ba80			jsr 	LCLWriteNumberXA
.b8a0	68		pla				pla 								; adjustment to indent
.b8a1	48		pha				pha 								; save on stack
.b8a2	10 0c		bpl $b8b0			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b8a4	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b8a5	6d 26 04	adc $0426			adc 	listIndent
.b8a8	8d 26 04	sta $0426			sta 	listIndent
.b8ab	10 03		bpl $b8b0			bpl 	_LCNoAdjust
.b8ad	9c 26 04	stz $0426			stz 	listIndent
.b8b0					_LCNoAdjust:
.b8b0	18		clc				clc		 							; work out actual indent.
.b8b1	ad 26 04	lda $0426			lda 	listIndent
.b8b4	0a		asl a				asl 	a
.b8b5	69 07		adc #$07			adc 	#7
.b8b7	85 36		sta $36				sta 	zTemp0
.b8b9					_LCPadOut:
.b8b9	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.b8bb	20 18 ba	jsr $ba18			jsr 	LCLWrite
.b8be	ad 1d 04	lda $041d			lda 	tbOffset
.b8c1	c5 36		cmp $36				cmp 	zTemp0
.b8c3	d0 f4		bne $b8b9			bne 	_LCPadOut
.b8c5	a0 03		ldy #$03			ldy 	#3 							; start position.
.b8c7					_LCMainLoop:
.b8c7	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b8c9	20 0f ba	jsr $ba0f			jsr 	LCLWriteColour
.b8cc	b1 30		lda ($30),y			lda 	(codePtr),y
.b8ce	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b8d0	f0 17		beq $b8e9			beq 	_LCExit
.b8d2	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b8d4	90 1e		bcc $b8f4			bcc 	_LCDoubles
.b8d6	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b8d8	90 2a		bcc $b904			bcc 	_LCShiftPunc
.b8da	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b8dc	90 35		bcc $b913			bcc 	_LCPunctuation
.b8de	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b8e0	90 51		bcc $b933			bcc 	_LCIdentifiers
.b8e2	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b8e4	90 73		bcc $b959			bcc 	_LCTokens
.b8e6	4c b9 b9	jmp $b9b9			jmp 	_LCData 					; 254-5 are data objects
.b8e9					_LCExit:
.b8e9	68		pla				pla 								; get old indent adjust
.b8ea	30 07		bmi $b8f3			bmi 	_LCExit2
.b8ec	18		clc				clc 								; add to indent if +ve
.b8ed	6d 26 04	adc $0426			adc 	listIndent
.b8f0	8d 26 04	sta $0426			sta 	listIndent
.b8f3					_LCExit2:
.b8f3	60		rts				rts
.b8f4					_LCDoubles:
.b8f4	48		pha				pha
.b8f5	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b8f6	29 02		and #$02			and 	#2
.b8f8	09 3c		ora #$3c			ora 	#60 						; make < >
.b8fa	20 18 ba	jsr $ba18			jsr 	LCLWrite
.b8fd	68		pla				pla 								; restore, do lower bit
.b8fe	29 03		and #$03			and 	#3
.b900	09 3c		ora #$3c			ora 	#60
.b902	80 0f		bra $b913			bra		_LCPunctuation 				; print, increment, loop
.b904					_LCShiftPunc:
.b904	aa		tax				tax 								; save in X
.b905	29 07		and #$07			and 	#7 							; lower 3 bits
.b907	f0 02		beq $b90b			beq 	_LCNoAdd
.b909	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b90b					_LCNoAdd:
.b90b	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b90d	90 02		bcc $b911			bcc 	_LCNoAdd2
.b90f	09 20		ora #$20			ora 	#32 						; adds $20
.b911					_LCNoAdd2:
.b911	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b913					_LCPunctuation:
.b913	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b915	d0 03		bne $b91a			bne 	_LCPContinue
.b917	20 2e ba	jsr $ba2e			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.b91a					_LCPContinue:
.b91a	c9 2e		cmp #$2e			cmp 	#'.'
.b91c	f0 08		beq $b926			beq 	_LCPIsConstant
.b91e	c9 30		cmp #$30			cmp 	#'0'
.b920	90 0b		bcc $b92d			bcc 	_LCPNotConstant
.b922	c9 3a		cmp #$3a			cmp 	#'9'+1
.b924	b0 07		bcs $b92d			bcs 	_LCPNotConstant
.b926					_LCPIsConstant:
.b926	48		pha				pha
.b927	a9 8d		lda #$8d			lda 	#CLIConstant+$80
.b929	20 0f ba	jsr $ba0f			jsr 	LCLWriteColour
.b92c	68		pla				pla
.b92d					_LCPNotConstant:
.b92d	c8		iny				iny 								; consume character
.b92e	20 18 ba	jsr $ba18			jsr 	LCLWrite 					; write it out.
.b931	80 94		bra $b8c7			bra 	_LCMainLoop 				; go round again.
.b933					_LCIdentifiers:
.b933	18		clc				clc 								; convert to physical address
.b934	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b936	85 37		sta $37				sta 	zTemp0+1
.b938	c8		iny				iny
.b939	b1 30		lda ($30),y			lda 	(codePtr),y
.b93b	85 36		sta $36				sta 	zTemp0
.b93d	c8		iny				iny
.b93e	5a		phy				phy 								; save position
.b93f	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b941	20 0f ba	jsr $ba0f			jsr 	LCLWriteColour
.b944	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.b946					_LCOutIdentifier:
.b946	c8		iny				iny
.b947	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.b949	29 7f		and #$7f			and 	#$7F
.b94b	20 6a ba	jsr $ba6a			jsr 	LCLLowerCase
.b94e	20 18 ba	jsr $ba18			jsr 	LCLWrite
.b951	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b953	10 f1		bpl $b946			bpl 	_LCOutIdentifier
.b955	7a		ply				ply 								; restore position
.b956	4c c7 b8	jmp $b8c7			jmp 	_LCMainLoop
.b959					_LCTokens:
.b959	aa		tax				tax 								; token in X
.b95a	a9 3a		lda #$3a			lda 	#((KeywordSet2) & $FF)
.b95c	85 36		sta $36				sta 	0+zTemp0
.b95e	a9 b7		lda #$b7			lda 	#((KeywordSet2) >> 8)
.b960	85 37		sta $37				sta 	1+zTemp0
.b962	e0 82		cpx #$82			cpx 	#$82
.b964	f0 16		beq $b97c			beq 	_LCUseShift
.b966	a9 c2		lda #$c2			lda 	#((KeywordSet1) & $FF)
.b968	85 36		sta $36				sta 	0+zTemp0
.b96a	a9 b6		lda #$b6			lda 	#((KeywordSet1) >> 8)
.b96c	85 37		sta $37				sta 	1+zTemp0
.b96e	e0 81		cpx #$81			cpx 	#$81
.b970	f0 0a		beq $b97c			beq 	_LCUseShift
.b972	a9 ab		lda #$ab			lda 	#((KeywordSet0) & $FF)
.b974	85 36		sta $36				sta 	0+zTemp0
.b976	a9 b4		lda #$b4			lda 	#((KeywordSet0) >> 8)
.b978	85 37		sta $37				sta 	1+zTemp0
.b97a	80 01		bra $b97d			bra 	_LCNoShift
.b97c					_LCUseShift:
.b97c	c8		iny				iny
.b97d					_LCNoShift:
.b97d	20 42 ba	jsr $ba42			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b980	b1 30		lda ($30),y			lda 	(codePtr),y
.b982	aa		tax				tax 								; into X
.b983					_LCFindText:
.b983	ca		dex				dex
.b984	10 0e		bpl $b994			bpl 	_LCFoundText 				; found text.
.b986	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b988	1a		inc a				inc 	a 							; one extra for size
.b989	38		sec				sec 								; one extra for checksum
.b98a	65 36		adc $36				adc 	zTemp0 						; go to next token
.b98c	85 36		sta $36				sta 	zTemp0
.b98e	90 f3		bcc $b983			bcc 	_LCFindText
.b990	e6 37		inc $37				inc 	zTemp0+1
.b992	80 ef		bra $b983			bra 	_LCFindText
.b994					_LCFoundText:
.b994	5a		phy				phy 								; save List position
.b995	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b997	aa		tax				tax
.b998	a9 83		lda #$83			lda 	#CLIToken+$80
.b99a	20 0f ba	jsr $ba0f			jsr 	LCLWriteColour
.b99d	a0 02		ldy #$02			ldy 	#2
.b99f					_LCCopyToken:
.b99f	b1 36		lda ($36),y			lda 	(zTemp0),y
.b9a1	20 6a ba	jsr $ba6a			jsr 	LCLLowerCase
.b9a4	20 18 ba	jsr $ba18			jsr 	LCLWrite
.b9a7	c8		iny				iny
.b9a8	ca		dex				dex
.b9a9	d0 f4		bne $b99f			bne 	_LCCopyToken
.b9ab	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b9ad	f0 05		beq $b9b4			beq 	_LCNoSpace
.b9af	a9 20		lda #$20			lda 	#' '
.b9b1	20 18 ba	jsr $ba18			jsr 	LCLWrite
.b9b4					_LCNoSpace:
.b9b4	7a		ply				ply 								; restore position.
.b9b5	c8		iny				iny 								; consume token
.b9b6	4c c7 b8	jmp $b8c7			jmp 	_LCMainLoop 				; and go around again.
.b9b9					_LCData:
.b9b9	48		pha				pha 								; save type $FE/$FF
.b9ba	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b9bc	c9 fe		cmp #$fe			cmp 	#$FE
.b9be	f0 22		beq $b9e2			beq 	_LCHaveOpener
.b9c0	a2 22		ldx #$22			ldx 	#'"'
.b9c2	a9 81		lda #$81			lda 	#CLIData+$80
.b9c4	20 0f ba	jsr $ba0f			jsr 	LCLWriteColour
.b9c7	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.b9c9	d0 17		bne $b9e2			bne 	_LCHaveOpener
.b9cb	88		dey				dey 								; what precedes it ?
.b9cc	b1 30		lda ($30),y			lda 	(codePtr),y
.b9ce	c8		iny				iny
.b9cf	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.b9d1	d0 0f		bne $b9e2			bne 	_LCHaveOpener
.b9d3	a9 09		lda #$09			lda 	#9 							; tab
.b9d5	20 18 ba	jsr $ba18			jsr 	LCLWrite
.b9d8	a9 97		lda #$97			lda 	#$90+CLIBComment
.b9da	20 18 ba	jsr $ba18			jsr 	LCLWrite
.b9dd	a9 80		lda #$80			lda 	#CLIFComment+$80
.b9df	20 0f ba	jsr $ba0f			jsr 	LCLWriteColour
.b9e2					_LCHaveOpener:
.b9e2	8a		txa				txa 								; output prefix (# or ")
.b9e3	20 18 ba	jsr $ba18			jsr 	LCLWrite
.b9e6	c8		iny				iny 								; get count
.b9e7	b1 30		lda ($30),y			lda 	(codePtr),y
.b9e9	aa		tax				tax
.b9ea	c8		iny				iny 								; point at first character
.b9eb					_LCOutData:
.b9eb	b1 30		lda ($30),y			lda 	(codePtr),y
.b9ed	c9 00		cmp #$00			cmp 	#0
.b9ef	f0 03		beq $b9f4			beq 	_LCNoPrint
.b9f1	20 18 ba	jsr $ba18			jsr 	LCLWrite
.b9f4					_LCNoPrint:
.b9f4	c8		iny				iny
.b9f5	ca		dex				dex
.b9f6	d0 f3		bne $b9eb			bne 	_LCOutData
.b9f8	68		pla				pla 								; closing " required ?
.b9f9	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.b9fb	d0 0f		bne $ba0c			bne 	_LCNoQuote
.b9fd	a9 22		lda #$22			lda 	#'"'
.b9ff	20 18 ba	jsr $ba18			jsr 	LCLWrite
.ba02	ad 6e 06	lda $066e			lda 	EXTTextColour
.ba05	29 0f		and #$0f			and 	#$0F
.ba07	09 90		ora #$90			ora 	#$90
.ba09	20 18 ba	jsr $ba18			jsr 	LCLWrite
.ba0c					_LCNoQuote:
.ba0c	4c c7 b8	jmp $b8c7			jmp 	_LCMainLoop
.ba0f					LCLWriteColour:
.ba0f	cd 29 04	cmp $0429			cmp 	currentListColour 			; has the colour changed
.ba12	8d 29 04	sta $0429			sta 	currentListColour 			; (update it anyway)
.ba15	d0 01		bne $ba18			bne 	LCLWrite 					; if different, output it
.ba17	60		rts				rts
.ba18					LCLWrite:
.ba18	da		phx				phx
.ba19	ae 1d 04	ldx $041d			ldx 	tbOffset 					; write out make ASCIIZ
.ba1c	9d 2d 04	sta $042d,x			sta 	tokenBuffer,x
.ba1f	9e 2e 04	stz $042e,x			stz 	tokenBuffer+1,x
.ba22	ee 1d 04	inc $041d			inc 	tbOffset 					; bump the position
.ba25	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.ba27	30 03		bmi $ba2c			bmi 	_LCLNoColour
.ba29	8d 27 04	sta $0427			sta 	LCLastCharacter
.ba2c					_LCLNoColour:
.ba2c	fa		plx				plx
.ba2d	60		rts				rts
.ba2e					LCLDeleteLastSpace:
.ba2e	48		pha				pha
.ba2f	da		phx				phx
.ba30	ae 1d 04	ldx $041d			ldx 	tbOffset
.ba33	f0 0a		beq $ba3f			beq 	_LCDLSExit
.ba35	bd 2c 04	lda $042c,x			lda 	tokenBuffer-1,x
.ba38	c9 20		cmp #$20			cmp 	#' '
.ba3a	d0 03		bne $ba3f			bne 	_LCDLSExit
.ba3c	ce 1d 04	dec $041d			dec 	tbOffset
.ba3f					_LCDLSExit:
.ba3f	fa		plx				plx
.ba40	68		pla				pla
.ba41	60		rts				rts
.ba42					LCLCheckSpaceRequired:
.ba42	ad 27 04	lda $0427			lda 	LCLastCharacter 			; check last character
.ba45	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.ba47	f0 1b		beq $ba64			beq 	_LCCSRSpace
.ba49	c9 29		cmp #$29			cmp 	#')'
.ba4b	f0 17		beq $ba64			beq 	_LCCSRSpace
.ba4d	c9 23		cmp #$23			cmp 	#'#'
.ba4f	f0 13		beq $ba64			beq 	_LCCSRSpace
.ba51	20 6a ba	jsr $ba6a			jsr 	LCLLowerCase 				; saves a little effort
.ba54	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.ba56	90 11		bcc $ba69			bcc 	_LCCSRExit
.ba58	c9 3a		cmp #$3a			cmp 	#"9"+1
.ba5a	90 08		bcc $ba64			bcc 	_LCCSRSpace
.ba5c	c9 61		cmp #$61			cmp 	#"a"
.ba5e	90 09		bcc $ba69			bcc 	_LCCSRExit
.ba60	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba62	b0 05		bcs $ba69			bcs 	_LCCSRExit
.ba64					_LCCSRSpace:
.ba64	a9 20		lda #$20			lda 	#' '
.ba66	20 18 ba	jsr $ba18			jsr 	LCLWrite
.ba69					_LCCSRExit:
.ba69	60		rts				rts
.ba6a					LCLLowerCase:
.ba6a	c9 41		cmp #$41			cmp 	#"A"
.ba6c	90 06		bcc $ba74			bcc 	_LCLLCOut
.ba6e	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ba70	b0 02		bcs $ba74			bcs 	_LCLLCOut
.ba72	69 20		adc #$20			adc 	#$20
.ba74					_LCLLCOut:
.ba74	60		rts				rts
.ba75					LCLUpperCase:
.ba75	c9 61		cmp #$61			cmp 	#"a"
.ba77	90 06		bcc $ba7f			bcc 	_LCLUCOut
.ba79	c9 7b		cmp #$7b			cmp 	#"z"+1
.ba7b	b0 02		bcs $ba7f			bcs 	_LCLUCOut
.ba7d	e9 1f		sbc #$1f			sbc 	#$1F
.ba7f					_LCLUCOut:
.ba7f	60		rts				rts
.ba80					LCLWriteNumberXA:
.ba80	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.ba82					_LCLWNLoop1:
.ba82	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.ba84					_LCLWNLoop2:
.ba84	48		pha				pha 								; save initial LSB
.ba85	38		sec				sec
.ba86	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.ba88	f9 b9 ba	sbc $bab9,y			sbc 	_LCLWNTable,y
.ba8b	48		pha				pha
.ba8c	8a		txa				txa
.ba8d	f9 ba ba	sbc $baba,y			sbc 	_LCLWNTable+1,y
.ba90	90 07		bcc $ba99			bcc 	_LCLWNUnderflow
.ba92	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.ba94	aa		tax				tax 								; update X
.ba95	68		pla				pla 								; restore A
.ba96	7a		ply				ply 								; throw original
.ba97	80 eb		bra $ba84			bra 	_LCLWNLoop2 				; try again.
.ba99					_LCLWNUnderflow:
.ba99	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.ba9b	d0 06		bne $baa3			bne 	_LCLWNOut
.ba9d	ad 1d 04	lda $041d			lda 	tbOffset 					; suppress leading zeroes
.baa0	3a		dec a				dec 	a
.baa1	f0 04		beq $baa7			beq 	_LCLWNNext
.baa3					_LCLWNOut:
.baa3	98		tya				tya
.baa4	20 b3 ba	jsr $bab3			jsr 	_LCLWNOutDigit
.baa7					_LCLWNNext:
.baa7	7a		ply				ply 							 	; restore original value.
.baa8	68		pla				pla
.baa9	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.baab	c8		iny				iny
.baac	c8		iny				iny
.baad	84 37		sty $37				sty 	zTemp0+1
.baaf	c0 08		cpy #$08			cpy 	#8 							; done all 4
.bab1	d0 cf		bne $ba82			bne 	_LCLWNLoop1
.bab3					_LCLWNOutDigit:
.bab3	09 30		ora #$30			ora 	#'0'
.bab5	20 18 ba	jsr $ba18			jsr 	LCLWrite
.bab8	60		rts				rts
.bab9					_LCLWNTable:
>bab9	10 27						.word 	10000
>babb	e8 03						.word 	1000
>babd	64 00						.word 	100
>babf	0a 00						.word 	10
.bac1					TOKSearchTable:
.bac1	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.bac3	85 36		sta $36				sta 	zTemp0
.bac5	a0 00		ldy #$00			ldy 	#0
.bac7	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.bac9	85 38		sta $38				sta 	zTemp1
.bacb					_TSTLoop:
.bacb	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.bacd	30 49		bmi $bb18			bmi 	_TSTFail 					; -ve = end of table, so fail.
.bacf	f0 2e		beq $baff			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.bad1	c8		iny				iny 								; get the hash
.bad2	b1 36		lda ($36),y			lda 	(zTemp0),y
.bad4	88		dey				dey
.bad5	cd 03 04	cmp $0403			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.bad8	d0 25		bne $baff			bne 	_TSTNext
.bada	ad 02 04	lda $0402			lda 	identTypeEnd 				; get length of identifier from end-start
.badd	38		sec				sec
.bade	ed 00 04	sbc $0400			sbc 	identStart
.bae1	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.bae3	d0 1a		bne $baff			bne 	_TSTNext
.bae5	5a		phy				phy 								; save Y , we might fail to match.
.bae6	c8		iny				iny 								; point to text
.bae7	c8		iny				iny
.bae8	ae 00 04	ldx $0400			ldx 	identStart 					; offset in line buffer in X
.baeb					_TSTCompareName:
.baeb	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; compare text.
.baee	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.baf0	d0 0c		bne $bafe			bne 	_TSTNextPullY 				; fail, pullY and do next
.baf2	e8		inx				inx
.baf3	c8		iny				iny
.baf4	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; complete match.
.baf7	d0 f2		bne $baeb			bne 	_TSTCompareName
.baf9	7a		ply				ply 								; throw Y
.bafa	a5 38		lda $38				lda 	zTemp1 						; get token #
.bafc	38		sec				sec 								; return with CS = passed.
.bafd	60		rts				rts
.bafe					_TSTNextPullY:
.bafe	7a		ply				ply 								; restore current, fall through.
.baff					_TSTNext:
.baff	e6 38		inc $38				inc 	zTemp1 						; token counter
.bb01	98		tya				tya
.bb02	18		clc				clc
.bb03	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.bb05	1a		inc a				inc 	a 							; +1
.bb06	1a		inc a				inc 	a 							; +2
.bb07	a8		tay				tay
.bb08	10 c1		bpl $bacb			bpl 	_TSTLoop 					; if Y < $80 loop back
.bb0a	98		tya				tya 								; add Y to zTemp0 and reset Y
.bb0b	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.bb0d	18		clc				clc  								; but have tables > 255 bytes
.bb0e	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.bb10	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.bb12	90 b7		bcc $bacb			bcc 	_TSTLoop
.bb14	e6 37		inc $37				inc 	zTemp0+1
.bb16	80 b3		bra $bacb			bra 	_TSTLoop
.bb18					_TSTFail:
.bb18	18		clc				clc
.bb19	60		rts				rts
.bb1a					Export_TKTokeniseLine:
.bb1a	20 a2 bc	jsr $bca2			jsr 	LCLFixLineBufferCase 		; fix line case
.bb1d	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.bb1f	8d 2a 04	sta $042a			sta 	tokenOffset 				; (3 bytes for line number & offset)
.bb22	9c 2b 04	stz $042b			stz 	tokenLineNumber
.bb25	9c 2c 04	stz $042c			stz 	tokenLineNumber+1
.bb28	a2 ff		ldx #$ff			ldx 	#$FF
.bb2a					_TKFindFirst:
.bb2a	e8		inx				inx
.bb2b	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bb2e	f0 79		beq $bba9			beq 	_TKExit
.bb30	c9 20		cmp #$20			cmp 	#' '
.bb32	90 f6		bcc $bb2a			bcc 	_TKFindFirst
.bb34	c9 30		cmp #$30			cmp 	#'0'
.bb36	90 07		bcc $bb3f			bcc 	_TKNoLineNumber
.bb38	c9 3a		cmp #$3a			cmp 	#'9'+1
.bb3a	b0 03		bcs $bb3f			bcs 	_TKNoLineNumber
.bb3c	20 cc bc	jsr $bccc			jsr 	TOKExtractLineNumber
.bb3f					_TKNoLineNumber:
.bb3f					_TKTokeniseLoop:
.bb3f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.bb42	f0 65		beq $bba9			beq 	_TKExit
.bb44	e8		inx				inx
.bb45	c9 20		cmp #$20			cmp 	#' '
.bb47	f0 f6		beq $bb3f			beq 	_TKTokeniseLoop 			; keep looping if space found.
.bb49	ca		dex				dex 								; undo last get, A contains character, X is position.
.bb4a	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.bb4c	f0 61		beq $bbaf			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.bb4e	c9 41		cmp #$41			cmp 	#'A'
.bb50	90 04		bcc $bb56			bcc 	_TKTokenisePunctuation
.bb52	c9 5b		cmp #$5b			cmp 	#'Z'+1
.bb54	90 59		bcc $bbaf			bcc 	_TKTokeniseIdentifier
.bb56					_TKTokenisePunctuation:
.bb56	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.bb58	f0 27		beq $bb81			beq 	_TKString
.bb5a	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.bb5c	f0 28		beq $bb86			beq 	_TKHexConstant
.bb5e	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.bb60	f0 29		beq $bb8b			beq 	_TKCheckDouble
.bb62	c9 3e		cmp #$3e			cmp 	#'>'
.bb64	f0 25		beq $bb8b			beq 	_TKCheckDouble
.bb66					_TKStandardPunctuation:
.bb66	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get the punctuation token back.
.bb69	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.bb6b	90 0e		bcc $bb7b			bcc 	_TKNoShift
.bb6d	48		pha				pha 								; save. we are about to convert this punctuation token from
.bb6e	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.bb70	85 36		sta $36				sta 	zTemp0
.bb72	68		pla				pla
.bb73	29 20		and #$20			and 	#32 						; bit 5
.bb75	4a		lsr a				lsr 	a 							; shift into bit 3
.bb76	4a		lsr a				lsr 	a
.bb77	05 36		ora $36				ora 	zTemp0
.bb79	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.bb7b					_TKNoShift:
.bb7b	20 11 bd	jsr $bd11			jsr 	TOKWriteByte 				; write the punctuation character
.bb7e	e8		inx				inx 								; consume the character
.bb7f	80 be		bra $bb3f			bra 	_TKTokeniseLoop 			; and loop round again.
.bb81					_TKString:
.bb81	20 31 bc	jsr $bc31			jsr 	TOKTokenString
.bb84	80 b9		bra $bb3f			bra 	_TKTokeniseLoop
.bb86					_TKHexConstant:
.bb86	20 6c bc	jsr $bc6c			jsr 	TOKHexConstant
.bb89	80 b4		bra $bb3f			bra 	_TKTokeniseLoop
.bb8b					_TKCheckDouble:
.bb8b	bd 2b 05	lda $052b,x			lda 	lineBuffer+1,x 				; get next character
.bb8e	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.bb90	90 d4		bcc $bb66			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.bb92	c9 3f		cmp #$3f			cmp 	#'>'+1
.bb94	b0 d0		bcs $bb66			bcs 	_TKStandardPunctuation
.bb96	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.bb99	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.bb9b	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.bb9c	7d 2b 05	adc $052b,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.bb9f	38		sec				sec
.bba0	e9 3c		sbc #$3c			sbc 	#'<'
.bba2	20 11 bd	jsr $bd11			jsr 	TOKWriteByte 				; this is in the range 0-7
.bba5	e8		inx				inx 								; consume both
.bba6	e8		inx				inx
.bba7	80 96		bra $bb3f			bra 	_TKTokeniseLoop
.bba9	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.bbab	20 11 bd	jsr $bd11			jsr 	TOKWriteByte
.bbae	60		rts				rts
.bbaf					_TKTokeniseIdentifier:
.bbaf	8e 00 04	stx $0400			stx 	identStart 					; save start
.bbb2	9c 04 04	stz $0404			stz 	identTypeByte 				; zero the type byte
.bbb5					_TKCheckLoop:
.bbb5	e8		inx				inx 								; look at next, we know first is identifier already.
.bbb6	bd 2a 05	lda $052a,x			lda  	lineBuffer,x
.bbb9	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.bbbb	f0 f8		beq $bbb5			beq 	_TKCheckLoop
.bbbd	c9 30		cmp #$30			cmp	 	#"0"
.bbbf	90 0c		bcc $bbcd			bcc 	_TKEndIdentifier
.bbc1	c9 3a		cmp #$3a			cmp 	#"9"+1
.bbc3	90 f0		bcc $bbb5			bcc 	_TKCheckLoop
.bbc5	c9 41		cmp #$41			cmp	 	#"A"
.bbc7	90 04		bcc $bbcd			bcc 	_TKEndIdentifier
.bbc9	c9 5b		cmp #$5b			cmp 	#"Z"+1
.bbcb	90 e8		bcc $bbb5			bcc 	_TKCheckLoop
.bbcd					_TKEndIdentifier:
.bbcd	8e 01 04	stx $0401			stx 	identTypeStart 				; save start of type text (if any !)
.bbd0	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.bbd2	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.bbd4	f0 06		beq $bbdc			beq 	_TKHasTypeCharacter
.bbd6	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.bbd8	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.bbda	d0 07		bne $bbe3			bne 	_TKNoTypeCharacter
.bbdc					_TKHasTypeCharacter:
.bbdc	8c 04 04	sty $0404			sty 	identTypeByte 				; has # or $, save the type
.bbdf	e8		inx				inx 								; consume the type character
.bbe0	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bbe3					_TKNoTypeCharacter:
.bbe3	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.bbe5	d0 09		bne $bbf0			bne 	_TKNoArray
.bbe7	e8		inx				inx 								; skip the (
.bbe8	ad 04 04	lda $0404			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.bbeb	09 04		ora #$04			ora 	#$04
.bbed	8d 04 04	sta $0404			sta 	identTypeByte
.bbf0					_TKNoArray:
.bbf0	8e 02 04	stx $0402			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.bbf3	20 8d bc	jsr $bc8d			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.bbf6	a0 b4		ldy #$b4			ldy 	#(KeywordSet0) >> 8
.bbf8	a9 ab		lda #$ab			lda 	#(KeywordSet0) & $FF
.bbfa	20 c1 ba	jsr $bac1			jsr 	TOKSearchTable
.bbfd	a2 00		ldx #$00			ldx 	#0
.bbff	b0 1f		bcs $bc20			bcs 	_TKFoundToken
.bc01	a0 b6		ldy #$b6			ldy 	#(KeywordSet1) >> 8
.bc03	a9 c2		lda #$c2			lda 	#(KeywordSet1) & $FF
.bc05	20 c1 ba	jsr $bac1			jsr 	TOKSearchTable
.bc08	a2 81		ldx #$81			ldx 	#$81
.bc0a	b0 14		bcs $bc20			bcs 	_TKFoundToken
.bc0c	a0 b7		ldy #$b7			ldy 	#(KeywordSet2) >> 8
.bc0e	a9 3a		lda #$3a			lda 	#(KeywordSet2) & $FF
.bc10	20 c1 ba	jsr $bac1			jsr 	TOKSearchTable
.bc13	a2 82		ldx #$82			ldx 	#$82
.bc15	b0 09		bcs $bc20			bcs 	_TKFoundToken
.bc17	20 1d bd	jsr $bd1d			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.bc1a	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc1d	4c 3f bb	jmp $bb3f			jmp 	_TKTokeniseLoop 			; and go round again.
.bc20					_TKFoundToken:
.bc20	48		pha				pha 								; save token
.bc21	8a		txa				txa 								; shift in X, is there one ?
.bc22	f0 03		beq $bc27			beq 	_TKNoTShift
.bc24	20 11 bd	jsr $bd11			jsr 	TOKWriteByte 				; if so, write it out
.bc27					_TKNoTShift:
.bc27	68		pla				pla 								; restore and write token
.bc28	20 11 bd	jsr $bd11			jsr 	TOKWriteByte
.bc2b	ae 02 04	ldx $0402			ldx 	identTypeEnd 				; X points to following byte
.bc2e	4c 3f bb	jmp $bb3f			jmp 	_TKTokeniseLoop 			; and go round again.
.bc31					TOKTokenString:
.bc31	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.bc33	20 11 bd	jsr $bd11			jsr 	TOKWriteByte
.bc36	e8		inx				inx									; start of quoted string.
.bc37	da		phx				phx 								; push start of string on top
.bc38	ca		dex				dex 								; because we pre-increment
.bc39					_TSFindEnd:
.bc39	e8		inx				inx
.bc3a	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; next character
.bc3d	f0 04		beq $bc43			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.bc3f	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.bc41	d0 f6		bne $bc39			bne 	_TSFindEnd
.bc43					_TSEndOfString:
.bc43	7a		ply				ply  								; so now Y is first character, X is character after end.
.bc44	48		pha				pha 								; save terminating character
.bc45	20 4d bc	jsr $bc4d			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.bc48	68		pla				pla 								; terminating character
.bc49	f0 01		beq $bc4c			beq 	_TSNotQuote					; if it wasn't EOS skip it
.bc4b	e8		inx				inx
.bc4c					_TSNotQuote:
.bc4c	60		rts				rts
.bc4d					TOKWriteBlockXY:
.bc4d	86 36		stx $36				stx 	zTemp0 						; save end character
.bc4f	98		tya				tya 								; use 2's complement to work out the byte size
.bc50	49 ff		eor #$ff			eor 	#$FF
.bc52	38		sec				sec
.bc53	65 36		adc $36				adc 	zTemp0
.bc55	1a		inc a				inc 	a 							; one extra for NULL
.bc56	20 11 bd	jsr $bd11			jsr 	TOKWriteByte
.bc59					_TOBlockLoop:
.bc59	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.bc5b	f0 09		beq $bc66			beq 	_TOBlockExit
.bc5d	b9 2a 05	lda $052a,y			lda 	lineBuffer,y 				; write byte out.
.bc60	20 11 bd	jsr $bd11			jsr 	TOKWriteByte
.bc63	c8		iny				iny
.bc64	80 f3		bra $bc59			bra 	_TOBlockLoop
.bc66					_TOBlockExit:
.bc66	a9 00		lda #$00			lda 	#0 							; add NULL.
.bc68	20 11 bd	jsr $bd11			jsr 	TOKWriteByte
.bc6b	60		rts				rts
.bc6c					TOKHexConstant:
.bc6c	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.bc6e	20 11 bd	jsr $bd11			jsr 	TOKWriteByte
.bc71	e8		inx				inx									; start of quoted string.
.bc72	da		phx				phx 								; push start of constant on top
.bc73	ca		dex				dex
.bc74					_THFindLoop:
.bc74	e8		inx				inx 	 							; this is stored in a block, so find out how long
.bc75	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; the hex constant is.
.bc78	c9 30		cmp #$30			cmp 	#"0"
.bc7a	90 0c		bcc $bc88			bcc 	_THFoundEnd
.bc7c	c9 3a		cmp #$3a			cmp 	#"9"+1
.bc7e	90 f4		bcc $bc74			bcc 	_THFindLoop
.bc80	c9 41		cmp #$41			cmp 	#"A"
.bc82	90 04		bcc $bc88			bcc 	_THFoundEnd
.bc84	c9 47		cmp #$47			cmp 	#"F"+1
.bc86	90 ec		bcc $bc74			bcc 	_THFindLoop
.bc88					_THFoundEnd:
.bc88	7a		ply				ply 								; restore start
.bc89	20 4d bc	jsr $bc4d			jsr 	TOKWriteBlockXY 			; output the block
.bc8c	60		rts				rts
.bc8d					TOKCalculateHash:
.bc8d	da		phx				phx
.bc8e	ae 00 04	ldx $0400			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.bc91	a9 00		lda #$00			lda 	#0
.bc93					_TCHLoop:
.bc93	18		clc				clc
.bc94	7d 2a 05	adc $052a,x			adc 	lineBuffer,x
.bc97	e8		inx				inx
.bc98	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.bc9b	d0 f6		bne $bc93			bne 	_TCHLoop
.bc9d	8d 03 04	sta $0403			sta 	identHash 					; save the hash
.bca0	fa		plx				plx
.bca1	60		rts				rts
.bca2					LCLFixLineBufferCase:
.bca2	a2 00		ldx #$00			ldx 	#0
.bca4					_FLBCLoop:
.bca4	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next character
.bca7	f0 22		beq $bccb			beq 	_FLBCExit 					; end of string.
.bca9	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.bcab	f0 11		beq $bcbe			beq 	_FLBCInQuotes
.bcad	e8		inx				inx
.bcae	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.bcb0	90 f2		bcc $bca4			bcc 	_FLBCLoop
.bcb2	c9 7b		cmp #$7b			cmp 	#'z'+1
.bcb4	b0 ee		bcs $bca4			bcs 	_FLBCLoop
.bcb6	38		sec				sec 								; make U/C
.bcb7	e9 20		sbc #$20			sbc 	#32
.bcb9	9d 29 05	sta $0529,x			sta	 	lineBuffer-1,x 				; write back
.bcbc	80 e6		bra $bca4			bra 	_FLBCLoop
.bcbe					_FLBCInQuotes:
.bcbe	e8		inx				inx 								; advance
.bcbf	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get next
.bcc2	f0 07		beq $bccb			beq 	_FLBCExit 					; exit on EOS
.bcc4	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.bcc6	d0 f6		bne $bcbe			bne 	_FLBCInQuotes
.bcc8	e8		inx				inx 								; skip over it
.bcc9	80 d9		bra $bca4			bra 	_FLBCLoop
.bccb					_FLBCExit:
.bccb	60		rts				rts
.bccc					TOKExtractLineNumber:
.bccc	ad 2c 04	lda $042c			lda 	tokenLineNumber+1 			; push current value on stack
.bccf	48		pha				pha
.bcd0	ad 2b 04	lda $042b			lda 	tokenLineNumber
.bcd3	48		pha				pha
.bcd4	20 0a bd	jsr $bd0a			jsr 	_LCLNTimes2 				; line # x 2
.bcd7	20 0a bd	jsr $bd0a			jsr 	_LCLNTimes2 				; line # x 4
.bcda	18		clc				clc 								; add stacked value
.bcdb	68		pla				pla
.bcdc	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcdf	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bce2	68		pla				pla
.bce3	6d 2c 04	adc $042c			adc 	tokenLineNumber+1
.bce6	8d 2c 04	sta $042c			sta 	tokenLineNumber+1 			; line # x 5
.bce9	20 0a bd	jsr $bd0a			jsr 	_LCLNTimes2 				; line # x 10
.bcec	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; get and consume character
.bcef	e8		inx				inx
.bcf0	29 0f		and #$0f			and 	#15 						; add to line #
.bcf2	18		clc				clc
.bcf3	6d 2b 04	adc $042b			adc 	tokenLineNumber
.bcf6	8d 2b 04	sta $042b			sta 	tokenLineNumber
.bcf9	90 03		bcc $bcfe			bcc 	_TLENNoCarry
.bcfb	ee 2c 04	inc $042c			inc 	tokenLineNumber+1
.bcfe					_TLENNoCarry:
.bcfe	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; more digits ?
.bd01	c9 30		cmp #$30			cmp 	#'0'
.bd03	90 04		bcc $bd09			bcc 	_TLENExit
.bd05	c9 3a		cmp #$3a			cmp 	#'9'+1
.bd07	90 c3		bcc $bccc			bcc 	TOKExtractLineNumber
.bd09					_TLENExit:
.bd09	60		rts				rts
.bd0a					_LCLNTimes2:
.bd0a	0e 2b 04	asl $042b			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.bd0d	2e 2c 04	rol $042c			rol 	tokenLineNumber+1
.bd10	60		rts				rts
.bd11					TOKWriteByte:
.bd11	da		phx				phx
.bd12	ae 2a 04	ldx $042a			ldx 	tokenOffset 				; next slot to write to
.bd15	9d 2a 04	sta $042a,x			sta 	tokenOffset,x 				; write byte out
.bd18	ee 2a 04	inc $042a			inc 	tokenOffset 				; advance slot.
.bd1b	fa		plx				plx
.bd1c	60		rts				rts
.bd1d					TOKCheckCreateVariableRecord:
.bd1d	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.bd1f	85 36		sta $36				sta 	0+zTemp0
.bd21	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.bd23	85 37		sta $37				sta 	1+zTemp0
.bd25					_CCVSearch:
.bd25	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.bd27	f0 2c		beq $bd55			beq 	_CCVFail
.bd29	a0 01		ldy #$01			ldy 	#1 							; read the hash
.bd2b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.bd2d	cd 03 04	cmp $0403			cmp 	identHash 	  				; if not, try the next.
.bd30	d0 16		bne $bd48			bne 	_CCVNext
.bd32	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.bd34	ae 00 04	ldx $0400			ldx 	identStart
.bd37					_CCVCompare:
.bd37	bd 2a 05	lda $052a,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.bd3a	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.bd3c	e8		inx				inx 								; advance pointers
.bd3d	c8		iny				iny
.bd3e	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.bd3f	d0 07		bne $bd48			bne 	_CCVNext  					; didn't match go to next.
.bd41	90 f4		bcc $bd37			bcc 	_CCVCompare 				; not finished yet.
.bd43	ec 02 04	cpx $0402			cpx 	identTypeEnd 				; matched whole thing ?
.bd46	f0 41		beq $bd89			beq 	_CCVFound 					; yes, we were successful
.bd48					_CCVNext:
.bd48	18		clc				clc 								; go to next record.
.bd49	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.bd4b	65 36		adc $36				adc 	zTemp0
.bd4d	85 36		sta $36				sta 	zTemp0
.bd4f	90 d4		bcc $bd25			bcc 	_CCVSearch
.bd51	e6 37		inc $37				inc 	zTemp0+1
.bd53	80 d0		bra $bd25			bra 	_CCVSearch
.bd55					_CCVFail:
.bd55	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.bd57	ad 03 04	lda $0403			lda 	identHash
.bd5a	91 36		sta ($36),y			sta 	(zTemp0),y
.bd5c	c8		iny				iny 								; offset 2 is the type byte
.bd5d	ad 04 04	lda $0404			lda 	identTypeByte
.bd60	91 36		sta ($36),y			sta 	(zTemp0),y
.bd62	c8		iny				iny
.bd63					_CCVData:
.bd63	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.bd65	91 36		sta ($36),y			sta 	(zTemp0),y
.bd67	c8		iny				iny
.bd68	c0 08		cpy #$08			cpy 	#8
.bd6a	90 f7		bcc $bd63			bcc 	_CCVData
.bd6c	ae 00 04	ldx $0400			ldx 	identStart 					; copy name into 8 on.
.bd6f					_CCVCopyName:
.bd6f	bd 2a 05	lda $052a,x			lda 	lineBuffer,x
.bd72	91 36		sta ($36),y			sta 	(zTemp0),y
.bd74	e8		inx				inx
.bd75	c8		iny				iny
.bd76	ec 02 04	cpx $0402			cpx 	identTypeEnd
.bd79	d0 f4		bne $bd6f			bne 	_CCVCopyName
.bd7b	98		tya				tya 								; patch offset
.bd7c	92 36		sta ($36)			sta 	(zTemp0)
.bd7e	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.bd80	91 36		sta ($36),y			sta 	(zTemp0),y
.bd82	88		dey				dey
.bd83	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.bd85	09 80		ora #$80			ora 	#$80
.bd87	91 36		sta ($36),y			sta 	(zTemp0),y
.bd89					_CCVFound:
.bd89	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.bd8b	38		sec				sec
.bd8c	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.bd8e	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.bd90	20 11 bd	jsr $bd11			jsr 	TOKWriteByte
.bd93	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.bd95	20 11 bd	jsr $bd11			jsr 	TOKWriteByte
.bd98	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.bd99					SNDCheckChannel:
.bd99	aa		tax				tax
.bd9a	bd 37 08	lda $0837,x			lda 	SNDTimeLeft,x 				; currently playing a note
.bd9d	d0 38		bne $bdd7			bne 	_SNDCCExit
.bd9f	da		phx				phx 								; save current channel
.bda0	8a		txa				txa 								; put in A
.bda1	20 1d be	jsr $be1d			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.bda4	68		pla				pla 								; channel # in A
.bda5	90 30		bcc $bdd7			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.bda7	a8		tay				tay 								; Y is the channel #
.bda8	bd 2c 07	lda $072c,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.bdab	99 2b 08	sta $082b,y			sta 	SNDPitchLow,y
.bdae	bd 2d 07	lda $072d,x			lda 	SNDQueue+2,x
.bdb1	99 2f 08	sta $082f,y			sta 	SNDPitchHigh,y
.bdb4	bd 2e 07	lda $072e,x			lda 	SNDQueue+3,x
.bdb7	99 33 08	sta $0833,y			sta 	SNDVolume,y
.bdba	bd 2f 07	lda $072f,x			lda 	SNDQueue+4,x
.bdbd	99 37 08	sta $0837,y			sta 	SNDTimeLeft,y
.bdc0	bd 30 07	lda $0730,x			lda 	SNDQueue+5,x
.bdc3	99 3b 08	sta $083b,y			sta 	SNDAdjustLow,y
.bdc6	bd 31 07	lda $0731,x			lda 	SNDQueue+6,x
.bdc9	99 3f 08	sta $083f,y			sta 	SNDAdjustHigh,y
.bdcc	5a		phy				phy 								; save channel #
.bdcd	20 37 be	jsr $be37			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.bdd0	ce 2a 07	dec $072a			dec 	SNDLength 					; reduce the queue length.
.bdd3	68		pla				pla
.bdd4	20 d8 bd	jsr $bdd8			jsr 	SNDUpdateNote 				; update channel A
.bdd7					_SNDCCExit:
.bdd7	60		rts				rts
.bdd8					SNDUpdateNote:
.bdd8	aa		tax				tax 								; so we can access records
.bdd9	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.bdda	0a		asl a				asl 	a
.bddb	0a		asl a				asl 	a
.bddc	0a		asl a				asl 	a
.bddd	0a		asl a				asl 	a
.bdde	8d 29 07	sta $0729			sta 	SNDChannelBits
.bde1	bd 37 08	lda $0837,x			lda 	SNDTimeLeft,x 				; are we silent
.bde4	f0 2e		beq $be14			beq 	_SNDUNIsSilent
.bde6	ad 29 07	lda $0729			lda 	SNDChannelBits 				; push channel bits on stack
.bde9	48		pha				pha
.bdea	bd 2b 08	lda $082b,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.bded	29 0f		and #$0f			and 	#$0F
.bdef	0d 29 07	ora $0729			ora 	SNDChannelBits 				; set channel bits
.bdf2	09 80		ora #$80			ora 	#$80 						; write to pitch register
.bdf4	20 81 be	jsr $be81			jsr 	SNDWritePorts
.bdf7	bd 2f 08	lda $082f,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.bdfa	8d 29 07	sta $0729			sta 	SNDChannelBits
.bdfd	bd 2b 08	lda $082b,x			lda 	SNDPitchLow,x
.be00	4e 29 07	lsr $0729			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.be03	6a		ror a				ror 	a
.be04	4e 29 07	lsr $0729			lsr 	SNDChannelBits
.be07	6a		ror a				ror 	a
.be08	4a		lsr a				lsr 	a 							; put in bits 0-5
.be09	4a		lsr a				lsr 	a
.be0a	20 81 be	jsr $be81			jsr 	SNDWritePorts 				; write as rest of pitch register
.be0d	68		pla				pla
.be0e	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.be10	20 81 be	jsr $be81			jsr 	SNDWritePorts
.be13	60		rts				rts
.be14					_SNDUNIsSilent:
.be14	ad 29 07	lda $0729			lda 	SNDChannelBits 				; channel bits
.be17	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.be19	20 81 be	jsr $be81			jsr 	SNDWritePorts 				; write to the ports
.be1c	60		rts				rts
.be1d					SNDFindNextNoteForA:
.be1d	ac 2a 07	ldy $072a			ldy 	SNDLength 					; queue size into Y
.be20	f0 13		beq $be35			beq 	_SNDFNNFail 				; queue empty.
.be22	a2 00		ldx #$00			ldx 	#0
.be24					_SNDFNNSearch:
.be24	dd 2b 07	cmp $072b,x			cmp 	SNDQueue,x 					; does it match the channel
.be27	38		sec				sec
.be28	f0 0c		beq $be36			beq 	_SNDFNNExit 				; if so exit with CS.
.be2a	e8		inx				inx 								; next queue slot.
.be2b	e8		inx				inx
.be2c	e8		inx				inx
.be2d	e8		inx				inx
.be2e	e8		inx				inx
.be2f	e8		inx				inx
.be30	e8		inx				inx
.be31	e8		inx				inx
.be32	88		dey				dey 								; done the whole queue
.be33	d0 ef		bne $be24			bne 	_SNDFNNSearch 				; no, go back.
.be35					_SNDFNNFail:
.be35	18		clc				clc
.be36					_SNDFNNexit:
.be36	60		rts				rts
.be37					SNDDeleteXFromQueue:
.be37	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.be39	f0 09		beq $be44			beq 	_SNDDXExit
.be3b	bd 33 07	lda $0733,x			lda 	SNDQueue+8,x
.be3e	9d 2b 07	sta $072b,x			sta 	SNDQueue,x
.be41	e8		inx				inx
.be42	80 f3		bra $be37			bra 	SNDDeleteXFromQueue
.be44					_SNDDXExit:
.be44	60		rts				rts
.0729					SNDChannelBits:
>0729							.fill 	1
.be45					SNDQueueRequest:
.be45	86 36		stx $36				stx 	zTemp0						; save queue address
.be47	84 37		sty $37				sty 	zTemp0+1
.be49	ae 2a 07	ldx $072a			ldx 	SNDLength 					; queue is full, can't take any more.
.be4c	e0 20		cpx #$20			cpx 	#SNDQueueSize
.be4e	f0 21		beq $be71			beq 	_SNDQRExit
.be50	29 03		and #$03			and 	#3	 						; channel # and push on stack
.be52	48		pha				pha
.be53	8a		txa				txa  								; get offset in queue buffer/
.be54	0a		asl a				asl 	a
.be55	0a		asl a				asl 	a
.be56	0a		asl a				asl 	a
.be57	aa		tax				tax
.be58	68		pla				pla 								; get back and push again
.be59	48		pha				pha
.be5a	9d 2b 07	sta $072b,x			sta 	SNDQueue+0,x 				; save the channel #
.be5d	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.be5f					_SNDQCopy:
.be5f	b1 36		lda ($36),y			lda 	(zTemp0),y
.be61	e8		inx				inx
.be62	c8		iny				iny
.be63	9d 2b 07	sta $072b,x			sta 	SNDQueue,x
.be66	c0 06		cpy #$06			cpy 	#6
.be68	d0 f5		bne $be5f			bne 	_SNDQCopy
.be6a	ee 2a 07	inc $072a			inc 	SNDLength 					; bump queue length.
.be6d	68		pla				pla 								; get channel # back
.be6e	20 99 bd	jsr $bd99			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.be71					_SNDQRExit:
.be71	60		rts				rts
.be72					SNDSilenceChannel:
.be72	aa		tax				tax 								; zero time left.
.be73	9e 37 08	stz $0837,x			stz 	SNDTimeLeft,x
.be76	0a		asl a				asl 	a 							; shift into position
.be77	0a		asl a				asl 	a
.be78	0a		asl a				asl 	a
.be79	0a		asl a				asl 	a
.be7a	0a		asl a				asl 	a
.be7b	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.be7d	20 81 be	jsr $be81			jsr 	SNDWritePorts
.be80	60		rts				rts
.be81					SNDWritePorts:
.be81	da		phx				phx 								; save X
.be82	a6 01		ldx $01				ldx 	1 							; save I/O status
.be84	64 01		stz $01				stz 	1 							; access I/O page 0
.be86	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.be89	8d 10 d6	sta $d610			sta 	$D610
.be8c	86 01		stx $01				stx 	1 							; restore I/O
.be8e	fa		plx				plx 								; restore X
.be8f	60		rts				rts
.be90					Export_SNDCommand:
.be90	da		phx				phx 								; save XY
.be91	5a		phy				phy
.be92	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.be94	f0 1d		beq $beb3			beq 	_SNDInitialise
.be96	90 28		bcc $bec0			bcc 	_SNDExit
.be98	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.be9a	f0 17		beq $beb3			beq 	_SNDSilence
.be9c	b0 22		bcs $bec0			bcs 	_SNDExit
.be9e	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.bea0	b0 09		bcs $beab			bcs 	_SNDQueryPlay
.bea2	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.bea4	b0 1a		bcs $bec0			bcs 	_SNDExit
.bea6	20 45 be	jsr $be45			jsr 	SNDQueueRequest
.bea9	80 15		bra $bec0			bra 	_SNDExit
.beab					_SNDQueryPlay:
.beab	29 03		and #$03			and 	#3 							; get channel #
.bead	aa		tax				tax
.beae	bd 37 08	lda $0837,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.beb1	80 0d		bra $bec0			bra 	_SNDExit
.beb3					_SNDInitialise:
.beb3					_SNDSilence:
.beb3	9c 2a 07	stz $072a			stz 	SNDLength 					; empty the queue.
.beb6	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.beb8					_SNDSilenceLoop:
.beb8	48		pha				pha
.beb9	20 72 be	jsr $be72			jsr 	SNDSilenceChannel
.bebc	68		pla				pla
.bebd	3a		dec a				dec 	a
.bebe	10 f8		bpl $beb8			bpl 	_SNDSilenceLoop
.bec0					_SNDExit:
.bec0	7a		ply				ply
.bec1	fa		plx				plx
.bec2	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.072a					SNDLength:
>072a							.fill 	1
.072b					SNDQueue:
>072b							.fill 	SNDQueueSize * 8
.082b					SNDPitchLow:
>082b							.fill 	4
.082f					SNDPitchHigh:
>082f							.fill 	4
.0833					SNDVolume:
>0833							.fill 	4
.0837					SNDTimeLeft:
>0837							.fill 	4
.083b					SNDAdjustLow:
>083b							.fill 	4
.083f					SNDAdjustHigh:
>083f							.fill 	4
.bec3					Export_SNDUpdate:
.bec3					PagedSNDUpdate:
.bec3	ad 37 08	lda $0837			lda 	SNDTimeLeft+0 				; look at time remaining
.bec6	f0 05		beq $becd			beq 	_SNDUNot0 					; not playing
.bec8	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.beca	20 ec be	jsr $beec			jsr 	SNDUpdateChannel 			; update it.
.becd					_SNDUNot0:
.becd	ad 38 08	lda $0838			lda 	SNDTimeLeft+1
.bed0	f0 05		beq $bed7			beq 	_SNDUNot1
.bed2	a2 01		ldx #$01			ldx 	#1
.bed4	20 ec be	jsr $beec			jsr 	SNDUpdateChannel
.bed7					_SNDUNot1:
.bed7	ad 39 08	lda $0839			lda 	SNDTimeLeft+2
.beda	f0 05		beq $bee1			beq 	_SNDUNot2
.bedc	a2 02		ldx #$02			ldx 	#2
.bede	20 ec be	jsr $beec			jsr 	SNDUpdateChannel
.bee1					_SNDUNot2:
.bee1	ad 3a 08	lda $083a			lda 	SNDTimeLeft+3
.bee4	f0 05		beq $beeb			beq 	_SNDUNot3
.bee6	a2 03		ldx #$03			ldx 	#3
.bee8	20 ec be	jsr $beec			jsr 	SNDUpdateChannel
.beeb					_SNDUNot3:
.beeb	60		rts				rts
.beec					SNDUpdateChannel:
.beec	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.beee	f0 2c		beq $bf1c			beq 	_SNDUCExit
.bef0	3a		dec a				dec 	a 							; decrement and update timer
.bef1	9d 37 08	sta $0837,x			sta 	SNDTimeLeft,x
.bef4	f0 1d		beq $bf13			beq 	_SNDUCUpdate 				; if zero, silence channel
.bef6	bd 3b 08	lda $083b,x			lda 	SNDAdjustLow,x 				; adjust ?
.bef9	1d 3f 08	ora $083f,x			ora 	SNDAdjustHigh,x
.befc	f0 1e		beq $bf1c			beq 	_SNDUCExit 					; if zero carry on at current tone.
.befe	18		clc				clc 								; add adjust, forcing into a 10 bit range
.beff	bd 2b 08	lda $082b,x			lda 	SNDPitchLow,x
.bf02	7d 3b 08	adc $083b,x			adc 	SNDAdjustLow,x
.bf05	9d 2b 08	sta $082b,x			sta 	SNDPitchLow,x
.bf08	bd 2f 08	lda $082f,x			lda 	SNDPitchHigh,x
.bf0b	7d 3f 08	adc $083f,x			adc 	SNDAdjustHigh,x
.bf0e	29 03		and #$03			and 	#3
.bf10	9d 2f 08	sta $082f,x			sta 	SNDPitchHigh,x
.bf13					_SNDUCUpdate:
.bf13	8a		txa				txa 								; which channel.
.bf14	48		pha				pha
.bf15	20 d8 bd	jsr $bdd8			jsr 	SNDUpdateNote 				; update the current note
.bf18	68		pla				pla
.bf19	20 99 bd	jsr $bd99			jsr 	SNDCheckChannel 			; more to do ?
.bf1c					_SNDUCExit:
.bf1c	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
