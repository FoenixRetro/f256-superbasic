
; 64tass Turbo Assembler Macro V1.57.2900 listing file
; 64tass -D AUTORUN=1 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$38000" "-D SOURCE_ADDRESS=\$3000" "-D SPRITE_ADDRESS=\$30000" -q -b -Wall -c -D "HARDWARE=0 $'\x9'$'\x9'$'\x9'$'\x9'$'\x9'$'\x9'" -L output/basic.lst -l output/basic.lbl -Wall -o basic.rom _basic.asm
; Wed Nov 23 16:32:21 2022

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					AUTORUN=1
=$e000					 MONITOR_ADDRESS=$E000
=$f000					 LOCKOUT_ADDRESS=$F000
=$38000					 BASIC_ADDRESS=$38000
=$3000					 SOURCE_ADDRESS=$3000
=$30000					 SPRITE_ADDRESS=$30000
=0					HARDWARE=0

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30					ZeroPageMandatory = $30
=$400					ZeroPagePreference = $400
=$480					MemoryStorage = $480
=$2000					BasicStart = $2000
=$8000					BasicEnd = $8000
=$8000					CodeStart = $8000
=$1000					VariableSpace = $1000
=$2000					EndVariableSpace = $2000
=8					MathStackSize = 8
=512					BasicStackSize = 512
=3584					BasicStackBase = $1000-BasicStackSize
=80					MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030					codePtr:
>0030							.fill 	4
.0034					basicStack:
>0034							.fill 	2
.0036					zTemp0:
>0036							.fill 	2
.0038					zTemp1:
>0038							.fill 	2
.003a					zTemp2:
>003a							.fill 	2
.003c					zsTemp:
>003c							.fill 	2
.003e					zaTemp:
>003e							.fill 	2
=$30					safePtr = codePtr 							; minimise direct tinkering
=$80					NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20					NSBIsReference = $20 						; bit 5 : is a reference
=$10					NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18					NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03					NSBRefMask = $03 							; bits 0,1 : Bytes of reference, -1 (e.g. 00 = 1 byte, 11 = 4 bytes)
=$04					NSBIsArray = $04
=$00					NSTInteger = $00 							; base types for bits 3..4
=$08					NSTFloat = $08
=$10					NSTString = $10
=$18					NSTProcedure = $18
.0400					NSStatus:
>0400							.fill 	MathStackSize
.0408					NSMantissa0:
>0408							.fill 	MathStackSize 				; (this is my integer mantissa system)
.0410					NSMantissa1:
>0410							.fill 	MathStackSize
.0418					NSMantissa2:
>0418							.fill 	MathStackSize
.0420					NSMantissa3:
>0420							.fill 	MathStackSize
.0428					NSExponent:
>0428							.fill 	MathStackSize
.0480					identStart:
>0480							.fill 	1
.0481					identTypeStart:
>0481							.fill 	1
.0482					identTypeEnd:
>0482							.fill 	1
.0483					identHash:
>0483							.fill 	1
.0484					identTypeByte:
>0484							.fill 	1	 						; (see tokenising.pdf)
.0485					encodeState:
>0485							.fill 	1
.0486					digitTemp:
>0486							.fill 	1
.0487					decimalCount:
>0487							.fill 	1
.0488					randomSeed:
>0488							.fill 	4
.048c					lowMemPtr:
>048c							.fill 	2
.048e					stringMemory:
>048e							.fill 	2
.0490					stringInitialised:
>0490							.fill 	1
.0491					stringTempPointer:
>0491							.fill 	2
.0493					breakCheck:
>0493							.fill 	1
.0494					decimalPlaces:
>0494							.fill 	1
.0495					dbOffset:
>0495							.fill 	1
.0496					lastParameter:
>0496							.fill 	1
.0497					dataPointer:
>0497							.fill 	5
.049c					inDataStatement:
>049c							.fill 	1
.049d					tbOffset:
>049d							.fill 	1
.049e					AssemblerAddress:
>049e							.fill 	2
.04a0					AssemblerControl:
>04a0							.fill 	1
.04a1					ParamStart:
>04a1							.fill 	2
.04a3					IsGroup1:
>04a3							.fill 	1
.04a4					BaseOpcode:
>04a4							.fill 	1
.04a5					ModeMask:
>04a5							.fill 	1
.04a6					listIndent:
>04a6							.fill 	1
.04a7					lcLastCharacter:
>04a7							.fill 	1
.04a8					isInputFlag:
>04a8							.fill 	1
.04a9					tokenOffset:
>04a9							.fill 	1
.04aa					tokenLineNumber:
>04aa							.fill 	2
.04ac					tokenBuffer:
>04ac							.fill 	253
.05a9					lineBuffer:
>05a9							.fill 	MaxLineSize+1
.05fa					numberBuffer:
>05fa							.fill 	34
.061c					decimalBuffer:
>061c							.fill 	16

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80					AM_ISZP = $80
=$40					AM_ISG1 = $40
=$20					AM_ISG2 = $20
=224					AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228					AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40					AM_ACC = AM_ISG2+$08
=108					AM_ABS = AM_ISG1+AM_ISG2+$0C
=208					AM_INDY = AM_ISZP+AM_ISG1+$10
=244					AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120					AM_ABSY = AM_ISG1+AM_ISG2+$18
=124					AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209					AM_IND = AM_ISZP+AM_ISG1+$11
=$80					AM_ZEROY = AM_ISZP
=$01					AM_INDABS = $01
=$02					AM_INDABSX = $02
=192					AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1					ERRID_BREAK = 1
=2					ERRID_SYNTAX = 2
=3					ERRID_DIVZERO = 3
=4					ERRID_RANGE = 4
=5					ERRID_TYPE = 5
=6					ERRID_MEMORY = 6
=7					ERRID_ARGUMENT = 7
=8					ERRID_STOP = 8
=9					ERRID_STRING = 9
=10					ERRID_ASSERT = 10
=11					ERRID_DATA = 11
=12					ERRID_NOTDONE = 12
=13					ERRID_LINE = 13
=14					ERRID_GOSUB = 14
=15					ERRID_REPEAT = 15
=16					ERRID_WHILE = 16
=17					ERRID_FOR = 17
=18					ERRID_STACK = 18
=19					ERRID_STRUCT = 19
=20					ERRID_PROC = 20
=21					ERRID_REDEFINE = 21
=22					ERRID_ARRAYSIZE = 22
=23					ERRID_ARRAYIDX = 23

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00					KWD_LESSLESS                         = $00; $00 <<
=$01					KWD_LESSEQUAL                        = $01; $01 <=
=$02					KWD_LESSGREATER                      = $02; $02 <>
=$03					KWD_PLINGPLING3                      = $03; $03 !!3
=$04					KWD_GREATERLESS                      = $04; $04 ><
=$05					KWD_GREATEREQUAL                     = $05; $05 >=
=$06					KWD_GREATERGREATER                   = $06; $06 >>
=$07					KWD_PLINGPLING7                      = $07; $07 !!7
=$08					KWD_PLINGPLING8                      = $08; $08 !!8
=$09					KWD_PLINGPLING9                      = $09; $09 !!9
=$0a					KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b					KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c					KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d					KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e					KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f					KWD_PLINGPLING15                     = $0f; $0f !!15
=$10					KWD_AT                               = $10; $10 @
=$11					KWD_PLINGPLING17                     = $11; $11 !!17
=$12					KWD_PLINGPLING18                     = $12; $12 !!18
=$13					KWD_LSQPAREN                         = $13; $13 [
=$14					KWD_BACKSLASH                        = $14; $14 \
=$15					KWD_RSQPAREN                         = $15; $15 ]
=$16					KWD_HAT                              = $16; $16 ^
=$17					KWD_UNDERSCORE                       = $17; $17 _
=$18					KWD_BQUOTE                           = $18; $18 `
=$19					KWD_PLINGPLING25                     = $19; $19 !!25
=$1a					KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b					KWD_LCURLY                           = $1b; $1b {
=$1c					KWD_BAR                              = $1c; $1c |
=$1d					KWD_RCURLY                           = $1d; $1d }
=$1e					KWD_TILDE                            = $1e; $1e ~
=$21					KWD_PLING                            = $21; $21 !
=$22					KWD_DQUOTE                           = $22; $22 "
=$23					KWD_HASH                             = $23; $23 #
=$24					KWD_DOLLAR                           = $24; $24 $
=$25					KWD_PERCENT                          = $25; $25 %
=$26					KWD_AMPERSAND                        = $26; $26 &
=$27					KWD_QUOTE                            = $27; $27 '
=$28					KWD_LPAREN                           = $28; $28 (
=$29					KWD_RPAREN                           = $29; $29 )
=$2a					KWD_STAR                             = $2a; $2a *
=$2b					KWD_PLUS                             = $2b; $2b +
=$2c					KWD_COMMA                            = $2c; $2c ,
=$2d					KWD_MINUS                            = $2d; $2d -
=$2e					KWD_PERIOD                           = $2e; $2e .
=$2f					KWD_SLASH                            = $2f; $2f /
=$30					KWD_0                                = $30; $30 0
=$31					KWD_1                                = $31; $31 1
=$32					KWD_2                                = $32; $32 2
=$33					KWD_3                                = $33; $33 3
=$34					KWD_4                                = $34; $34 4
=$35					KWD_5                                = $35; $35 5
=$36					KWD_6                                = $36; $36 6
=$37					KWD_7                                = $37; $37 7
=$38					KWD_8                                = $38; $38 8
=$39					KWD_9                                = $39; $39 9
=$3a					KWD_COLON                            = $3a; $3a :
=$3b					KWD_SEMICOLON                        = $3b; $3b ;
=$3c					KWD_LESS                             = $3c; $3c <
=$3d					KWD_EQUAL                            = $3d; $3d =
=$3e					KWD_GREATER                          = $3e; $3e >
=$3f					KWD_QMARK                            = $3f; $3f ?
=$83					KWD_ABSLPAREN                        = $83; $83 ABS(
=$84					KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85					KWD_ASCLPAREN                        = $85; $85 ASC(
=$86					KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87					KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88					KWD_FALSE                            = $88; $88 FALSE
=$89					KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a					KWD_HITLPAREN                        = $8a; $8a HIT(
=$8b					KWD_INTLPAREN                        = $8b; $8b INT(
=$8c					KWD_ISVALLPAREN                      = $8c; $8c ISVAL(
=$8d					KWD_JOYBLPAREN                       = $8d; $8d JOYB(
=$8e					KWD_JOYXLPAREN                       = $8e; $8e JOYX(
=$8f					KWD_JOYYLPAREN                       = $8f; $8f JOYY(
=$90					KWD_LEFTDOLLARLPAREN                 = $90; $90 LEFT$(
=$91					KWD_LENLPAREN                        = $91; $91 LEN(
=$92					KWD_MAXLPAREN                        = $92; $92 MAX(
=$93					KWD_MIDDOLLARLPAREN                  = $93; $93 MID$(
=$94					KWD_MINLPAREN                        = $94; $94 MIN(
=$95					KWD_NOTLPAREN                        = $95; $95 NOT(
=$96					KWD_PLAYINGLPAREN                    = $96; $96 PLAYING(
=$97					KWD_RANDOMLPAREN                     = $97; $97 RANDOM(
=$98					KWD_RIGHTDOLLARLPAREN                = $98; $98 RIGHT$(
=$99					KWD_RNDLPAREN                        = $99; $99 RND(
=$9a					KWD_SGNLPAREN                        = $9a; $9a SGN(
=$9b					KWD_SPCLPAREN                        = $9b; $9b SPC(
=$9c					KWD_STRDOLLARLPAREN                  = $9c; $9c STR$(
=$9d					KWD_TIMERLPAREN                      = $9d; $9d TIMER(
=$9e					KWD_TRUE                             = $9e; $9e TRUE
=$9f					KWD_VALLPAREN                        = $9f; $9f VAL(
=$a0					KWD_FOR                              = $a0; $a0 FOR
=$a1					KWD_IF                               = $a1; $a1 IF
=$a2					KWD_PROC                             = $a2; $a2 PROC
=$a3					KWD_REPEAT                           = $a3; $a3 REPEAT
=$a4					KWD_WHILE                            = $a4; $a4 WHILE
=$a5					KWD_ENDIF                            = $a5; $a5 ENDIF
=$a6					KWD_ENDPROC                          = $a6; $a6 ENDPROC
=$a7					KWD_NEXT                             = $a7; $a7 NEXT
=$a8					KWD_THEN                             = $a8; $a8 THEN
=$a9					KWD_UNTIL                            = $a9; $a9 UNTIL
=$aa					KWD_WEND                             = $aa; $aa WEND
=$ab					KWD_BY                               = $ab; $ab BY
=$ac					KWD_CALL                             = $ac; $ac CALL
=$ad					KWD_CIRCLE                           = $ad; $ad CIRCLE
=$ae					KWD_CLEAR                            = $ae; $ae CLEAR
=$af					KWD_CLS                              = $af; $af CLS
=$b0					KWD_COLOR                            = $b0; $b0 COLOR
=$b1					KWD_COLOUR                           = $b1; $b1 COLOUR
=$b2					KWD_DATA                             = $b2; $b2 DATA
=$b3					KWD_DIM                              = $b3; $b3 DIM
=$b4					KWD_DOWNTO                           = $b4; $b4 DOWNTO
=$b5					KWD_ELSE                             = $b5; $b5 ELSE
=$b6					KWD_FROM                             = $b6; $b6 FROM
=$b7					KWD_GFX                              = $b7; $b7 GFX
=$b8					KWD_GOSUB                            = $b8; $b8 GOSUB
=$b9					KWD_GOTO                             = $b9; $b9 GOTO
=$ba					KWD_HERE                             = $ba; $ba HERE
=$bb					KWD_IMAGE                            = $bb; $bb IMAGE
=$bc					KWD_INPUT                            = $bc; $bc INPUT
=$bd					KWD_LET                              = $bd; $bd LET
=$be					KWD_LINE                             = $be; $be LINE
=$bf					KWD_LOCAL                            = $bf; $bf LOCAL
=$c0					KWD_OFF                              = $c0; $c0 OFF
=$c1					KWD_ON                               = $c1; $c1 ON
=$c2					KWD_OUTLINE                          = $c2; $c2 OUTLINE
=$c3					KWD_PALETTE                          = $c3; $c3 PALETTE
=$c4					KWD_PLOT                             = $c4; $c4 PLOT
=$c5					KWD_PRINT                            = $c5; $c5 PRINT
=$c6					KWD_READ                             = $c6; $c6 READ
=$c7					KWD_RECT                             = $c7; $c7 RECT
=$c8					KWD_REM                              = $c8; $c8 REM
=$c9					KWD_RETURN                           = $c9; $c9 RETURN
=$ca					KWD_SOLID                            = $ca; $ca SOLID
=$cb					KWD_SOUND                            = $cb; $cb SOUND
=$cc					KWD_SPRITE                           = $cc; $cc SPRITE
=$cd					KWD_TEXT                             = $cd; $cd TEXT
=$ce					KWD_TO                               = $ce; $ce TO

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80					KWC_EOL = $80
=$ff					KWC_STRING = $FF
=$fe					KWC_HEXCONST = $FE
=$a0					KWC_FIRST_STRUCTURE = $a0
=$a5					KWC_FIRST_STRUCTURE_DEC = $a5
=$aa					KWC_LAST_STRUCTURE = $aa
=$83					KWC_FIRST_UNARY = $83
=$9f					KWC_LAST_UNARY = $9f

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0					STK_GOSUB = $E0
=$d0					STK_FOR = $D0
=$c0					STK_REPEAT = $C0
=$b0					STK_PROC = $B0
=$a0					STK_WHILE = $A0
=$01					STK_LOCALN = $01
=$02					STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000	a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.8002	9a		txs				txs
.8003	20 00 ab	jsr $ab00			jsr 	EXTInitialise 				; hardware initialise
.8006	a2 80		ldx #$80			ldx 	#(Prompt >> 8) 				; prompt display
.8008	a9 22		lda #$22			lda 	#(Prompt & $FF)
.800a	20 58 8e	jsr $8e58			jsr 	PrintStringXA
.800d	a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.800f	aa		tax				tax
.8010	a8		tay				tay
.8011	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.8014	a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.8016	20 1a ba	jsr $ba1a			jsr 	SNDCommand
.8019	20 4f 89	jsr $894f			jsr 	NewProgram 					; erase current program
.801c	20 e6 82	jsr $82e6			jsr 	BackloadProgram
.801f	4c 8e 8a	jmp $8a8e			jmp 	CommandRun
>8022	0c 2a 2a 2a 20 46 32 35		Prompt:	.text 	12,"*** F256 Junior SuperBASIC ***",13,13
>802a	36 20 4a 75 6e 69 6f 72 20 53 75 70 65 72 42 41
>803a	53 49 43 20 2a 2a 2a 0d 0d

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8043	42 75 69 6c 74 20 57 65			.text "Built Wednesday 23-Nov-2022. Build 3578."
>804b	64 6e 65 73 64 61 79 20 32 33 2d 4e 6f 76 2d 32
>805b	30 32 32 2e 20 42 75 69 6c 64 20 33 35 37 38 2e

;******  Return to file: ./common/aa.system/00start.asm

>806b	0d 0d 00					.byte 	13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.806e					AssembleGroup1:
.806e	a9 ff		lda #$ff			lda 	#$FF
.8070	8d a5 04	sta $04a5			sta 	ModeMask 					; initialise the mode mask - all for all
.8073	80 02		bra $8077			bra 	AsmGroup12
.8075					AssembleGroup2:
.8075	a9 00		lda #$00			lda 	#$00
.8077					AsmGroup12:
.8077	8d a3 04	sta $04a3			sta 	IsGroup1 					; save the 'group 1' flag
.807a	68		pla				pla 								; pop the return address to access the information following.
.807b	fa		plx				plx
.807c	20 05 81	jsr $8105			jsr 	AccessParameters 			; get opcode and save as base
.807f	8d a4 04	sta $04a4			sta 	BaseOpcode
.8082	ad a3 04	lda $04a3			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8085	d0 08		bne $808f			bne 	_AG12HaveMask
.8087	a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8089	20 0d 81	jsr $810d			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.808c	8d a5 04	sta $04a5			sta 	ModeMask
.808f					_AG12HaveMask:
.808f	20 48 82	jsr $8248			jsr 	TypeAndCalculateOperand 	; get zero page type
.8092	da		phx				phx 								; save found address mode
.8093	20 71 81	jsr $8171			jsr 	AssembleModeX
.8096	fa		plx				plx  								; restore address mode
.8097	b0 0b		bcs $80a4			bcs 	_AG12Exit
.8099	20 a5 80	jsr $80a5			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.809c	20 71 81	jsr $8171			jsr 	AssembleModeX
.809f	b0 03		bcs $80a4			bcs 	_AG12Exit
.80a1	4c 4c a0	jmp $a04c			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.80a4					_AG12Exit:
.80a4	60		rts				rts
.80a5					PromoteToAbsolute:
.80a5	a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.80a7	e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.80a9	f0 19		beq $80c4			beq 	_PTADo
.80ab	a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.80ad	e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.80af	f0 13		beq $80c4			beq 	_PTADo
.80b1	a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.80b3	e0 80		cpx #$80			cpx 	#AM_ZEROY
.80b5	f0 0d		beq $80c4			beq 	_PTADo
.80b7	a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.80b9	e0 d1		cpx #$d1			cpx 	#AM_IND
.80bb	f0 07		beq $80c4			beq 	_PTADo
.80bd	a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.80bf	e0 c0		cpx #$c0			cpx 	#AM_INDX
.80c1	f0 01		beq $80c4			beq 	_PTADo
.80c3	60		rts				rts
.80c4					_PTADo:
.80c4	aa		tax				tax
.80c5	60		rts				rts
.80c6					AssembleGroup3:
.80c6	68		pla				pla 								; get parameters, which is just the opcode.
.80c7	fa		plx				plx
.80c8	20 05 81	jsr $8105			jsr 	AccessParameters 			; get and output opcode
.80cb	20 1d 81	jsr $811d			jsr 	AssemblerWriteByte
.80ce	20 ac 82	jsr $82ac			jsr 	CalculateOperand 			; get a 16 bit operand
.80d1	ad 08 04	lda $0408			lda 	NSMantissa0 				; calculate the offset
.80d4	38		sec				sec
.80d5	ed 9e 04	sbc $049e			sbc 	AssemblerAddress
.80d8	48		pha				pha 								; LSB in A
.80d9	ad 10 04	lda $0410			lda 	NSMantissa1
.80dc	ed 9f 04	sbc $049f			sbc 	AssemblerAddress+1
.80df	aa		tax				tax 								; MSB in X
.80e0	68		pla				pla
.80e1	18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.80e2	69 7f		adc #$7f			adc 	#$7F
.80e4	90 01		bcc $80e7			bcc 	_AG3NoCarry
.80e6	e8		inx				inx
.80e7					_AG3NoCarry:
.80e7	38		sec				sec 								; fix back and write out anyways.
.80e8	e9 80		sbc #$80			sbc 	#$80
.80ea	20 1d 81	jsr $811d			jsr 	AssemblerWriteByte
.80ed	e0 00		cpx #$00			cpx 	#0 							; was it in range
.80ef	f0 0a		beq $80fb			beq 	_AG3Exit
.80f1	ad a0 04	lda $04a0			lda 	AssemblerControl 			; are we allowing bad values ?
.80f4	29 01		and #$01			and 	#1
.80f6	f0 03		beq $80fb			beq 	_AG3Exit
.80f8	4c 51 a0	jmp $a051			jmp 	RangeError 					; no, branch is out of range
.80fb					_AG3Exit:
.80fb	60		rts				rts
.80fc					AssembleGroup4:
.80fc	68		pla				pla 								; pop address
.80fd	fa		plx				plx
.80fe	20 05 81	jsr $8105			jsr 	AccessParameters 			; access and get first
.8101	20 1d 81	jsr $811d			jsr 	AssemblerWriteByte 			; output it.
.8104	60		rts				rts
.8105					AccessParameters:
.8105	8d a1 04	sta $04a1			sta 	ParamStart
.8108	8e a2 04	stx $04a2			stx 	ParamStart+1
.810b	a9 01		lda #$01			lda 	#1
.810d					GetParameter:
.810d	5a		phy				phy
.810e	a8		tay				tay
.810f	ad a1 04	lda $04a1			lda 	ParamStart
.8112	85 36		sta $36				sta 	zTemp0
.8114	ad a2 04	lda $04a2			lda 	ParamStart+1
.8117	85 37		sta $37				sta 	zTemp0+1
.8119	b1 36		lda ($36),y			lda 	(zTemp0),y
.811b	7a		ply				ply
.811c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.811d					AssemblerWriteByte:
.811d	48		pha			pha
.811e	ad a0 04	lda $04a0		lda 	AssemblerControl 				; check printing bytes ?
.8121	29 02		and #$02		and 	#2
.8123	f0 1b		beq $8140		beq 	_AWBNoPrint
.8125	ad 9f 04	lda $049f		lda		AssemblerAddress+1 				; print address
.8128	20 5b 81	jsr $815b		jsr 	PrintHex
.812b	ad 9e 04	lda $049e		lda		AssemblerAddress
.812e	20 5b 81	jsr $815b		jsr 	PrintHex
.8131	a9 20		lda #$20		lda 	#' '
.8133	20 8c a8	jsr $a88c		jsr 	EXTPrintCharacter
.8136	68		pla			pla 									; print byte
.8137	48		pha			pha
.8138	20 5b 81	jsr $815b		jsr 	PrintHex
.813b	a9 0d		lda #$0d		lda 	#13
.813d	20 8c a8	jsr $a88c		jsr 	EXTPrintCharacter
.8140					_AWBNoPrint:
.8140	ad 9e 04	lda $049e		lda		AssemblerAddress				; copy address to zTemp0
.8143	85 36		sta $36			sta 	zTemp0
.8145	ad 9f 04	lda $049f		lda		AssemblerAddress+1
.8148	f0 0e		beq $8158		beq 	_AWBRange
.814a	85 37		sta $37			sta 	zTemp0+1
.814c	68		pla			pla 									; write byte out
.814d	92 36		sta ($36)		sta 	(zTemp0)
.814f	ee 9e 04	inc $049e		inc 	AssemblerAddress 				; bump address
.8152	d0 03		bne $8157		bne 	_AWBNoCarry
.8154	ee 9f 04	inc $049f		inc 	AssemblerAddress+1
.8157					_AWBNoCarry:
.8157	60		rts			rts
.8158					_AWBRange:
.8158	4c 51 a0	jmp $a051		jmp 	RangeError
.815b					PrintHex:
.815b	48		pha				pha
.815c	4a		lsr a				lsr 	a
.815d	4a		lsr a				lsr 	a
.815e	4a		lsr a				lsr 	a
.815f	4a		lsr a				lsr 	a
.8160	20 64 81	jsr $8164			jsr 	_PrintNibble
.8163	68		pla				pla
.8164					_PrintNibble:
.8164	29 0f		and #$0f			and 	#15
.8166	c9 0a		cmp #$0a			cmp 	#10
.8168	90 02		bcc $816c			bcc 	_NoShift
.816a	69 06		adc #$06			adc 	#6
.816c					_NoShift:
.816c	69 30		adc #$30			adc 	#48
.816e	4c 8c a8	jmp $a88c			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.8171					AssembleModeX:
.8171	5a		phy				phy
.8172	ad a3 04	lda $04a3			lda 	IsGroup1
.8175	f0 17		beq $818e			beq 	_AMXGroup2
.8177	8a		txa				txa 							; is it in group # 1
.8178	29 40		and #$40			and 	#AM_ISG1
.817a	f0 50		beq $81cc			beq 	_AMXFail 				; no, give up.
.817c	8a		txa				txa 							; get back.
.817d	29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.817f	e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.8181	d0 22		bne $81a5			bne 	_AMXHaveInfo
.8183	ad a4 04	lda $04a4			lda 	BaseOpcode 				; cannot store immediate.
.8186	c9 81		cmp #$81			cmp 	#$81
.8188	f0 42		beq $81cc			beq 	_AMXFail
.818a	a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.818c	80 17		bra $81a5			bra 	_AMXHaveInfo 			; odd design decision there.
.818e					_AMXGroup2:
.818e	8a		txa				txa 							; is it in group 2 ?
.818f	29 20		and #$20			and 	#AM_ISG2
.8191	f0 39		beq $81cc			beq 	_AMXFail 				; no, give up.
.8193	8a		txa				txa 							; get the offset into Y
.8194	29 1f		and #$1f			and 	#$1F
.8196	4a		lsr a				lsr 	a 						; make it 0-7.
.8197	4a		lsr a				lsr  	a
.8198	a8		tay				tay
.8199	ad a5 04	lda $04a5			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.819c					_AMXCheckOkay:
.819c	0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.819d	88		dey				dey
.819e	10 fc		bpl $819c			bpl 	_AMXCheckOkay
.81a0	90 2a		bcc $81cc			bcc 	_AMXFail 				; not allowed.
.81a2	8a		txa				txa  							; get mask back
.81a3	29 1f		and #$1f			and 	#$1F
.81a5					_AMXHaveInfo:
.81a5	e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.81a7	10 05		bpl $81ae			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.81a9	ac 10 04	ldy $0410			ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.81ac	d0 1e		bne $81cc			bne 	_AMXFail
.81ae					_AMXAnySize:
.81ae	18		clc				clc 							; add offset to the base opcode
.81af	6d a4 04	adc $04a4			adc 	BaseOpcode
.81b2					_AMXOutputCode:
.81b2	20 1d 81	jsr $811d			jsr 	AssemblerWriteByte 		; write the opcode out.
.81b5	e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL A)
.81b7	f0 10		beq $81c9			beq 	_AMXExit
.81b9	ad 08 04	lda $0408			lda 	NSMantissa0 				; write LSB operand
.81bc	20 1d 81	jsr $811d			jsr 	AssemblerWriteByte
.81bf	e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.81c1	30 06		bmi $81c9			bmi 	_AMXExit
.81c3	ad 10 04	lda $0410			lda 	NSMantissa1 			; write MSB operand
.81c6	20 1d 81	jsr $811d			jsr 	AssemblerWriteByte
.81c9					_AMXExit:
.81c9	7a		ply				ply
.81ca	38		sec				sec
.81cb	60		rts				rts
.81cc					_AMXFail:
.81cc	a0 00		ldy #$00			ldy 	#0
.81ce					_AMXCheckOddities:
.81ce	8a		txa				txa
.81cf	d9 f7 81	cmp $81f7,y			cmp 	ExtraOpcode+2,y 		; match address mode
.81d2	d0 16		bne $81ea			bne 	_AMXCONext
.81d4	b9 f5 81	lda $81f5,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.81d7	cd a4 04	cmp $04a4			cmp 	BaseOpcode
.81da	d0 0e		bne $81ea			bne 	_AMXCONext
.81dc	e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.81de	10 05		bpl $81e5			bpl 	_AMXCONotZero
.81e0	ad 10 04	lda $0410			lda 	NSMantissa1
.81e3	d0 05		bne $81ea			bne 	_AMXCONext
.81e5					_AMXCONotZero:
.81e5	b9 f6 81	lda $81f6,y			lda 	ExtraOpcode+1,y 		; get new opcode
.81e8	80 c8		bra $81b2			bra 	_AMXOutputCode 			; and assemble it
.81ea					_AMXCONext:
.81ea	c8		iny				iny
.81eb	c8		iny				iny
.81ec	c8		iny				iny
.81ed	b9 f5 81	lda $81f5,y			lda 	ExtraOpcode+0,y 		; end of table
.81f0	d0 dc		bne $81ce			bne 	_AMXCheckOddities
.81f2					_AMXCOFail:
.81f2	7a		ply				ply
.81f3	18		clc				clc
.81f4	60		rts				rts
.81f5					ExtraOpcode:
>81f5	40 6c 01					.byte $40,$6c,AM_INDABS 	; jmp
>81f8	40 7c 02					.byte $40,$7C,AM_INDABSX 	; jmp
>81fb	a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>81fe	a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>8201	82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>8204	e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>8207	c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>820a	20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>820d	60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>8210	60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>8213	00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.8214					LabelHere:
.8214	c8		iny				iny 								; skip .
.8215	a2 00		ldx #$00			ldx 	#0 							; get a term
.8217	20 88 98	jsr $9888			jsr 	EvaluateTerm 				; get a term
.821a	ad 00 04	lda $0400			lda 	NSStatus 					; needs to be an integer reference.
.821d	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.821f	d0 24		bne $8245			bne 	_ALType
.8221	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.8224	85 36		sta $36				sta 	zTemp0
.8226	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8229	85 37		sta $37				sta 	zTemp0+1
.822b	5a		phy				phy 								; copy address in.
.822c	a0 01		ldy #$01			ldy 	#1
.822e	ad 9e 04	lda $049e			lda	 	AssemblerAddress
.8231	92 36		sta ($36)			sta 	(zTemp0)
.8233	ad 9f 04	lda $049f			lda	 	AssemblerAddress+1
.8236	91 36		sta ($36),y			sta 	(zTemp0),y
.8238	c8		iny				iny
.8239	a9 00		lda #$00			lda 	#0
.823b	91 36		sta ($36),y			sta 	(zTemp0),y
.823d	c8		iny				iny
.823e	91 36		sta ($36),y			sta 	(zTemp0),y
.8240	c8		iny				iny
.8241	91 36		sta ($36),y			sta 	(zTemp0),y
.8243	7a		ply				ply
.8244	60		rts				rts
.8245					_ALType:
.8245	4c 56 a0	jmp $a056			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.8248					TypeAndCalculateOperand:
.8248	b1 30		lda ($30),y			lda 	(codePtr),y
.824a	a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.824c	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.824e	f0 5b		beq $82ab			beq 	_TACOExit
.8250	c9 80		cmp #$80			cmp 	#KWC_EOL
.8252	f0 57		beq $82ab			beq 	_TACOExit
.8254	c8		iny				iny
.8255	a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.8257	c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.8259	f0 51		beq $82ac			beq 	CalculateOperand
.825b	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.825d	f0 1f		beq $827e			beq 	_TACOIndirect
.825f	88		dey				dey 								; undo get of first character
.8260	20 ac 82	jsr $82ac			jsr 	CalculateOperand 			; get operand
.8263	b1 30		lda ($30),y			lda 	(codePtr),y
.8265	a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.8267	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8269	d0 40		bne $82ab			bne 	_TACOExit
.826b	c8		iny				iny
.826c	20 b6 82	jsr $82b6			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.826f	a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.8271	c9 58		cmp #$58			cmp 	#'X'
.8273	f0 36		beq $82ab			beq 	_TACOExit
.8275	a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.8277	c9 59		cmp #$59			cmp 	#'Y'
.8279	f0 30		beq $82ab			beq 	_TACOExit
.827b					_TACOSyntax:
.827b	4c 4c a0	jmp $a04c			jmp 	SyntaxError
.827e					_TACOIndirect:
.827e	20 ac 82	jsr $82ac			jsr 	CalculateOperand 			; get the operand
.8281	b1 30		lda ($30),y			lda 	(codePtr),y
.8283	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8285	f0 17		beq $829e			beq 	_TACOIndX
.8287	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.828a	b1 30		lda ($30),y			lda 	(codePtr),y
.828c	a2 d1		ldx #$d1			ldx 	#AM_IND
.828e	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.8290	d0 19		bne $82ab			bne 	_TACOExit
.8292	c8		iny				iny
.8293	20 b6 82	jsr $82b6			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8296	c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.8298	d0 e1		bne $827b			bne 	_TACOSyntax
.829a	a2 d0		ldx #$d0			ldx 	#AM_INDY
.829c	80 0d		bra $82ab			bra 	_TACOExit
.829e					_TACOIndX:
.829e	c8		iny				iny
.829f	20 b6 82	jsr $82b6			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.82a2	c9 58		cmp #$58			cmp 	#'X' 						; check X
.82a4	d0 d5		bne $827b			bne 	_TACOSyntax
.82a6	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket			; check )
.82a9	a2 c0		ldx #$c0			ldx 	#AM_INDX
.82ab					_TACOExit:
.82ab	60		rts				rts
.82ac					CalculateOperand:
.82ac	48		pha				pha
.82ad	da		phx				phx
.82ae	a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.82b0	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger
.82b3	fa		plx				plx
.82b4	68		pla				pla
.82b5	60		rts				rts
.82b6					TACOCheckXY:
.82b6	b1 30		lda ($30),y			lda 	(codePtr),y
.82b8	29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.82ba	c9 40		cmp #$40			cmp 	#$40
.82bc	d0 21		bne $82df			bne 	_TCXYFail
.82be	b1 30		lda ($30),y			lda 	(codePtr),y
.82c0	18		clc				clc
.82c1	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.82c3	85 37		sta $37				sta 	zTemp0+1
.82c5	c8		iny				iny
.82c6	b1 30		lda ($30),y			lda 	(codePtr),y
.82c8	c8		iny				iny
.82c9	85 36		sta $36				sta 	zTemp0
.82cb	5a		phy				phy 								; save position
.82cc	a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.82ce	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d0	d0 0c		bne $82de			bne 	_TCXYPopFail
.82d2	a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.82d4	b1 36		lda ($36),y			lda 	(zTemp0),y
.82d6	c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.82d8	f0 08		beq $82e2			beq 	_TCXYFound
.82da	c9 d9		cmp #$d9			cmp 	#'Y'+$80
.82dc	f0 04		beq $82e2			beq 	_TCXYFound
.82de					_TCXYPopFail:
.82de	7a		ply				ply
.82df					_TCXYFail:
.82df	a9 00		lda #$00			lda 	#0
.82e1	60		rts				rts
.82e2					_TCXYFound:
.82e2	7a		ply				ply 								; restore position
.82e3	29 7f		and #$7f			and 	#$7F 						; throw bit 7
.82e5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.82e6					BackloadProgram:
.82e6	a9 00		lda #$00			lda 	#((SOURCE_ADDRESS) & $FF)
.82e8	8d 2c 06	sta $062c			sta 	0+BackLoadPointer
.82eb	a9 30		lda #$30			lda 	#((SOURCE_ADDRESS) >> 8)
.82ed	8d 2d 06	sta $062d			sta 	1+BackLoadPointer
.82f0					_BPLoop:
.82f0	a2 ff		ldx #$ff			ldx 	#$FF
.82f2	8e fa ff	stx $fffa			stx 	$FFFA 						; fast mode (autorun on emulator only)
.82f5	20 23 83	jsr $8323			jsr 	BLReadByte 					; read a byte
.82f8	c9 00		cmp #$00			cmp 	#0
.82fa	f0 20		beq $831c			beq 	_BPExit 					; if 0 exit
.82fc	30 1e		bmi $831c			bmi 	_BPExit 					; if -ve exit
.82fe					_BPCopy:
.82fe	e8		inx				inx  								; copy byte into the lineBuffer
.82ff	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.8302	9e aa 05	stz $05aa,x			stz 	lineBuffer+1,x
.8305	20 23 83	jsr $8323			jsr 	BLReadByte 					; read next byte
.8308	30 0a		bmi $8314			bmi 	_BPEndLine 					; -ve = EOL
.830a	c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.830c	d0 02		bne $8310			bne 	_BPNotTab
.830e	a9 20		lda #$20			lda 	#' '
.8310					_BPNotTab:
.8310	c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.8312	b0 ea		bcs $82fe			bcs 	_BPCopy 					; until a control character, should be 13 received.
.8314					_BPEndLine:
.8314	20 aa b6	jsr $b6aa			jsr 	TokeniseLine 				; tokenise the line.
.8317	20 3a 83	jsr $833a			jsr 	EditProgramCode
.831a	80 d4		bra $82f0			bra 	_BPLoop
.831c					_BPExit:
.831c	9c fa ff	stz $fffa			stz 	$FFFA 						; clear fast mode (autorun only)
.831f	20 f8 83	jsr $83f8			jsr 	ClearCommand 				; clear variables etc.
.8322	60		rts				rts
.8323					BLReadByte:
.8323	ad 2c 06	lda $062c			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8326	85 36		sta $36				sta 	zTemp0
.8328	ad 2d 06	lda $062d			lda 	BackLoadPointer+1
.832b	85 37		sta $37				sta 	zTemp0+1
.832d	b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.832f	ee 2c 06	inc $062c			inc 	BackLoadPointer 			; bump pointer
.8332	d0 03		bne $8337			bne 	_BLNoCarry
.8334	ee 2d 06	inc $062d			inc 	BackLoadPointer+1
.8337					_BLNoCarry:
.8337	c9 00		cmp #$00			cmp 	#0
.8339	60		rts				rts
.062c					BackLoadPointer:
>062c							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.833a					EditProgramCode:
.833a	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line.
.833d	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1
.8340	20 70 a6	jsr $a670			jsr 	MemorySearch
.8343	90 05		bcc $834a			bcc 	_EPCNoDelete 				; reached the end don't delete
.8345	d0 03		bne $834a			bne 	_EPCNoDelete 				; found slot but didn't match, no delete
.8347	20 91 a5	jsr $a591			jsr 	MemoryDeleteLine 			; delete the line
.834a					_EPCNoDelete:
.834a	ad ac 04	lda $04ac			lda 	TokenBuffer 				; buffer empty
.834d	c9 80		cmp #$80			cmp 	#KWC_EOL
.834f	f0 0d		beq $835e			beq 	_EPCNoInsert
.8351	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; find the line - it cannot exist.
.8354	ae ab 04	ldx $04ab			ldx 	TokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8357	20 70 a6	jsr $a670			jsr 	MemorySearch
.835a	18		clc				clc 								; insert at this point.
.835b	20 c8 a5	jsr $a5c8			jsr 	MemoryInsertLine 			; insert the line
.835e					_EPCNoInsert:
.835e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.835f					WarmStart:
.835f	a2 ff		ldx #$ff			ldx 	#$FF
.8361	9a		txs				txs
.8362	20 1a aa	jsr $aa1a			jsr 	EXTInputLine 				; get line to lineBuffer
.8365	20 aa b6	jsr $b6aa			jsr 	TokeniseLine 				; tokenise the line
.8368	ad aa 04	lda $04aa			lda 	TokenLineNumber 			; line number ?
.836b	0d ab 04	ora $04ab			ora 	TokenLineNumber+1
.836e	d0 17		bne $8387			bne 	_WSEditCode 				; if so,edit code.
.8370	9c a9 04	stz $04a9			stz 	TokenOffset 				; zero offset, meaning it only runs one line.
.8373	a9 a9		lda #$a9			lda 	#((TokenOffset) & $FF)
.8375	85 30		sta $30				sta 	codePtr
.8377	a9 04		lda #$04			lda 	#((TokenOffset) >> 8)
.8379	85 31		sta $31				sta 	codePtr+1
.837b	ad ac 04	lda $04ac			lda 	TokenBuffer 				; nothing to run
.837e	c9 80		cmp #$80			cmp 	#KWC_EOL
.8380	f0 dd		beq $835f			beq 	WarmStart
.8382	20 a0 8a	jsr $8aa0			jsr 	RUNCodePointerLine 			; execute that line.
.8385	80 d8		bra $835f			bra 	WarmStart
.8387					_WSEditCode:
.8387	20 3a 83	jsr $833a			jsr 	EditProgramCode
.838a	20 f8 83	jsr $83f8			jsr 	ClearCommand
.838d	80 d0		bra $835f			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.838f					AssembleCommand:
.838f	a2 00		ldx #$00			ldx 	#0
.8391	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger 		; start address
.8394	ad 08 04	lda $0408			lda 	NSMantissa0
.8397	8d 9e 04	sta $049e			sta 	AssemblerAddress
.839a	ad 10 04	lda $0410			lda 	NSMantissa1
.839d	8d 9f 04	sta $049f			sta 	AssemblerAddress+1
.83a0	20 ee 8d	jsr $8dee			jsr 	CheckComma
.83a3	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; options
.83a6	ad 08 04	lda $0408			lda 	NSMantissa0
.83a9	8d a0 04	sta $04a0			sta 	AssemblerControl
.83ac	60		rts				rts
.83ad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.83ae					AssertCommand:
.83ae	a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.83b0	20 0e 9e	jsr $9e0e			jsr 	EvaluateInteger 			; the assert test
.83b3	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; exit if result is non zero.
.83b6	d0 05		bne $83bd			bne 	_ACExit
.83b8	a9 0a		lda #$0a		lda	#10
.83ba	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.83bd					_ACExit:
.83bd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.83be					CallCommand:
.83be	a2 00		ldx #$00			ldx 	#0
.83c0	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger
.83c3					_CCClear
.83c3	e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.83c4	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero
.83c7	e0 04		cpx #$04			cpx 	#4
.83c9	d0 f8		bne $83c3			bne 	_CCClear
.83cb	a2 00		ldx #$00			ldx 	#0 							; and keep trying
.83cd					_CCCParam:
.83cd	b1 30		lda ($30),y			lda 	(codePtr),y
.83cf	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.83d1	d0 09		bne $83dc			bne 	_CCCRun6502
.83d3	c8		iny				iny 								; skip comma
.83d4	e8		inx				inx	 								; next level
.83d5	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; get A/X/Y
.83d8	e0 03		cpx #$03			cpx 	#3
.83da	90 f1		bcc $83cd			bcc 	_CCCParam 					; done all 3 ?
.83dc					_CCCRun6502:
.83dc	5a		phy				phy 								; save position
.83dd	ad 10 04	lda $0410			lda 	NSMantissa1 				; put address in zTemp0
.83e0	85 37		sta $37				sta 	zTemp0+1
.83e2	ad 08 04	lda $0408			lda 	NSMantissa0
.83e5	85 36		sta $36				sta 	zTemp0
.83e7	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; get registers
.83ea	ae 0a 04	ldx $040a			ldx 	NSMantissa0+2
.83ed	ac 0b 04	ldy $040b			ldy 	NSMantissa0+3
.83f0	20 f5 83	jsr $83f5			jsr 	_CCCZTemp0 					; call zTemp0
.83f3	7a		ply				ply 								; restore position and exit
.83f4	60		rts				rts
.83f5					_CCCZTemp0:
.83f5	6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/clear.asm

.83f8					ClearCommand:
.83f8	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.83fa	85 36		sta $36				sta 	0+zTemp0
.83fc	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.83fe	85 37		sta $37				sta 	1+zTemp0
.8400					_ClearZeroLoop:
.8400	b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.8402	f0 24		beq $8428			beq 	_ClearZeroEnd
.8404	a0 03		ldy #$03			ldy 	#3 							; erase the variables
.8406	a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.8408					_ClearOneVariable:
.8408	91 36		sta ($36),y			sta 	(zTemp0),y
.840a	c8		iny				iny
.840b	c0 08		cpy #$08			cpy 	#8
.840d	d0 f9		bne $8408			bne 	_ClearOneVariable
.840f	a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.8411	b1 36		lda ($36),y			lda 	(zTemp0),y
.8413	c9 18		cmp #$18			cmp 	#NSTProcedure
.8415	d0 04		bne $841b			bne 	_ClearNotProcedure
.8417	a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.8419	91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.841b					_ClearNotProcedure:
.841b	18		clc				clc 								; go to the next variable
.841c	b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.841e	65 36		adc $36				adc 	zTemp0
.8420	85 36		sta $36				sta 	zTemp0
.8422	90 dc		bcc $8400			bcc 	_ClearZeroLoop
.8424	e6 37		inc $37				inc 	zTemp0+1
.8426	80 d8		bra $8400			bra 	_ClearZeroLoop
.8428					_ClearZeroEnd:
.8428	18		clc				clc
.8429	a5 36		lda $36				lda 	zTemp0
.842b	69 01		adc #$01			adc 	#1
.842d	8d 8c 04	sta $048c			sta 	lowMemPtr
.8430	a5 37		lda $37				lda 	zTemp0+1
.8432	69 00		adc #$00			adc 	#0
.8434	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.8437	20 b1 a7	jsr $a7b1			jsr 	StackReset
.843a	20 1b a8	jsr $a81b			jsr 	StringSystemInitialise
.843d	20 ef 8c	jsr $8cef			jsr 	ProcedureScan
.8440	20 4f 8a	jsr $8a4f			jsr 	Command_Restore
.8443	9c 9e 04	stz $049e			stz 	AssemblerAddress
.8446	9c 9f 04	stz $049f			stz 	AssemblerAddress+1
.8449	9c a0 04	stz $04a0			stz 	AssemblerControl
.844c	20 8b 9a	jsr $9a8b			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.844f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/cls.asm

.8450					ClearScreen:
.8450	5a		phy				phy
.8451	a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.8453	20 8c a8	jsr $a88c			jsr 	EXTPrintCharacter
.8456	7a		ply				ply
.8457	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.8458					Command_Data:
.8458	a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL
.845a	a2 80		ldx #$80			ldx 	#KWC_EOL
.845c	20 41 8d	jsr $8d41			jsr 	ScanForward
.845f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.8460					DimCommand:
.8460	b1 30		lda ($30),y			lda 	(codePtr),y
.8462	29 c0		and #$c0			and 	#$C0
.8464	c9 40		cmp #$40			cmp 	#$40
.8466	d0 7a		bne $84e2			bne 	_DCSyntax
.8468	b1 30		lda ($30),y			lda 	(codePtr),y
.846a	18		clc				clc
.846b	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.846d	85 3f		sta $3f				sta 	zaTemp+1
.846f	c8		iny				iny
.8470	b1 30		lda ($30),y			lda 	(codePtr),y
.8472	c8		iny				iny
.8473	85 3e		sta $3e				sta 	zaTemp
.8475	5a		phy				phy
.8476	a0 02		ldy #$02			ldy 	#2 						; read type byte
.8478	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.847a	29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.847c	c9 18		cmp #$18			cmp 	#NSTProcedure
.847e	f0 62		beq $84e2			beq 	_DCSyntax
.8480	b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.8482	29 04		and #$04			and 	#NSBIsArray
.8484	f0 64		beq $84ea			beq 	_DCType
.8486	a0 04		ldy #$04			ldy 	#4 						; check not already defined
.8488	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.848a	d0 59		bne $84e5			bne 	_DCRedefine
.848c	7a		ply				ply
.848d	20 ed 84	jsr $84ed			jsr 	_DCGetSize 				; get array size, check it.
.8490	5a		phy				phy
.8491	a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.8493	91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.8495	7a		ply				ply 							; is there a second (e.g. ,x)
.8496	b1 30		lda ($30),y			lda 	(codePtr),y
.8498	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.849a	d0 0a		bne $84a6			bne 	_DCOneDimension
.849c	c8		iny				iny 							; skip comma
.849d	20 ed 84	jsr $84ed			jsr 	_DCGetSize 				; get 2nd array size
.84a0	5a		phy				phy
.84a1	a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.84a3	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84a5	7a		ply				ply
.84a6					_DCOneDimension:
.84a6	5a		phy				phy 							; save position
.84a7	a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.84a9	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84ab	aa		tax				tax
.84ac	c8		iny				iny
.84ad	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84af	e8		inx				inx 							; bump them.
.84b0	1a		inc a				inc 	a
.84b1	20 57 9e	jsr $9e57			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.84b4	a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.84b6	29 e0		and #$e0			and 	#$E0
.84b8	d0 23		bne $84dd			bne 	_DCSize
.84ba	a0 02		ldy #$02			ldy 	#2 						; get base type
.84bc	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.84be	20 fb 84	jsr $84fb			jsr 	ScaleByBaseType 		; scale by base type
.84c1	a5 36		lda $36				lda 	zTemp0
.84c3	a6 37		ldx $37				ldx 	zTemp0+1
.84c5	20 4d 9a	jsr $9a4d			jsr 	AllocateXABytes 		; allocate memory
.84c8	a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.84ca	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84cc	c8		iny				iny
.84cd	8a		txa				txa
.84ce	91 3e		sta ($3e),y			sta 	(zaTemp),y
.84d0	7a		ply				ply 							; get position back
.84d1	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket 		; check )
.84d4	b1 30		lda ($30),y			lda 	(codePtr),y
.84d6	c8		iny				iny 							; consume in case
.84d7	c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.84d9	f0 85		beq $8460			beq 	DimCommand
.84db	88		dey				dey 							; undo consume
.84dc	60		rts				rts
.84dd					_DCSize:
.84dd	a9 16		lda #$16		lda	#22
.84df	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.84e2					_DCSyntax:
.84e2	4c 4c a0	jmp $a04c			jmp 	SyntaxError
.84e5					_DCRedefine:
.84e5	a9 15		lda #$15		lda	#21
.84e7	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.84ea					_DCType:
.84ea	4c 56 a0	jmp $a056			jmp 	TypeError
.84ed					_DCGetSize:
.84ed	a2 00		ldx #$00			ldx 	#0 						; get first index.
.84ef	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 	; get array dimension
.84f2	c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.84f4	f0 e7		beq $84dd			beq 	_DCSize
.84f6	c9 fe		cmp #$fe			cmp 	#254
.84f8	f0 e3		beq $84dd			beq 	_DCSize
.84fa	60		rts				rts
.84fb					ScaleByBaseType:
.84fb	29 10		and #$10			and 	#NSBIsString 			; is it string
.84fd	d0 19		bne $8518			bne 	_SBBTString
.84ff	a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8501	48		pha				pha
.8502	a5 36		lda $36				lda 	zTemp0
.8504	48		pha				pha
.8505	06 36		asl $36				asl 	zTemp0 					; x 2
.8507	26 37		rol $37				rol 	zTemp0+1
.8509	06 36		asl $36				asl 	zTemp0 					; x 4
.850b	26 37		rol $37				rol 	zTemp0+1
.850d	68		pla				pla 							; add stacked value = x 5
.850e	65 36		adc $36				adc 	zTemp0
.8510	85 36		sta $36				sta 	zTemp0
.8512	68		pla				pla
.8513	65 37		adc $37				adc 	zTemp0+1
.8515	85 37		sta $37				sta 	zTemp0+1
.8517	60		rts				rts
.8518					_SBBTString:
.8518	06 36		asl $36				asl 	zTemp0
.851a	26 37		rol $37				rol 	zTemp0+1
.851c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.851d					EndCommand:
.851d	4c 5f 83	jmp $835f			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8520					ForCommand:
.8520	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack.
.8522	20 4c a7	jsr $a74c			jsr 	StackOpen
.8525	a2 00		ldx #$00			ldx 	#0
.8527	20 88 98	jsr $9888			jsr 	EvaluateTerm
.852a	bd 00 04	lda $0400,x			lda 	NSStatus,x
.852d	c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.852f	d0 49		bne $857a			bne		_FCError
.8531	a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8533	20 f6 8d	jsr $8df6			jsr 	CheckNextA
.8536	e8		inx				inx
.8537	20 0e 9e	jsr $9e0e			jsr 	EvaluateInteger 			; <from> in +1
.853a	b1 30		lda ($30),y			lda 	(codePtr),y
.853c	c8		iny				iny 								; consume it
.853d	48		pha				pha 								; save on stack for later
.853e	c9 b4		cmp #$b4			cmp 	#KWD_DOWNTO
.8540	f0 04		beq $8546			beq 	_FCNoSyntax
.8542	c9 ce		cmp #$ce			cmp 	#KWD_TO
.8544	d0 37		bne $857d			bne 	_FCSyntaxError
.8546					_FCNoSyntax:
.8546	e8		inx				inx
.8547	20 0e 9e	jsr $9e0e			jsr 	EvaluateInteger
.854a	20 90 a7	jsr $a790			jsr 	STKSaveCodePosition 		; save loop back position
.854d	68		pla				pla 								; restore DOWNTO or TO
.854e	5a		phy				phy 								; save Y on the stack
.854f	49 b4		eor #$b4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8551	f0 02		beq $8555			beq 	_FCNotDownTo
.8553	a9 02		lda #$02			lda 	#2
.8555					_FCNotDownTo:
.8555	3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8556	a0 10		ldy #$10			ldy 	#16
.8558	91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.855a	a0 06		ldy #$06			ldy 	#6
.855c	ad 08 04	lda $0408			lda 	NSMantissa0
.855f	91 34		sta ($34),y			sta 	(basicStack),y
.8561	ad 10 04	lda $0410			lda 	NSMantissa1
.8564	c8		iny				iny
.8565	91 34		sta ($34),y			sta 	(basicStack),y
.8567	a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8569	a2 01		ldx #$01			ldx 	#1
.856b	20 80 85	jsr $8580			jsr 	FCIntegerToStack
.856e	a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8570	a2 02		ldx #$02			ldx 	#2
.8572	20 80 85	jsr $8580			jsr 	FCIntegerToStack
.8575	20 a0 85	jsr $85a0			jsr 	CopyIndexToReference
.8578	7a		ply				ply 								; restore position
.8579	60		rts				rts
.857a					_FCError:
.857a	4c 56 a0	jmp $a056			jmp 	TypeError
.857d					_FCSyntaxError:
.857d	4c 4c a0	jmp $a04c			jmp 	SyntaxError
.8580					FCIntegerToStack:
.8580	3c 00 04	bit $0400,x			bit 	NSStatus,x 					; is the value negative
.8583	10 03		bpl $8588			bpl	 	_FCNotNegative
.8585	20 77 9e	jsr $9e77			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8588					_FCNotNegative:
.8588	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.858b	91 34		sta ($34),y			sta 	(basicStack),y
.858d	c8		iny				iny
.858e	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8591	91 34		sta ($34),y			sta 	(basicStack),y
.8593	c8		iny				iny
.8594	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.8597	91 34		sta ($34),y			sta 	(basicStack),y
.8599	c8		iny				iny
.859a	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.859d	91 34		sta ($34),y			sta 	(basicStack),y
.859f	60		rts				rts
.85a0					CopyIndexToReference:
.85a0	5a		phy				phy
.85a1	a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.85a3	38		sec				sec 								; (because we copy from offset 8)
.85a4	b1 34		lda ($34),y			lda 	(basicStack),y
.85a6	e9 08		sbc #$08			sbc 	#8
.85a8	85 36		sta $36				sta 	zTemp0
.85aa	c8		iny				iny
.85ab	b1 34		lda ($34),y			lda 	(basicStack),y
.85ad	e9 00		sbc #$00			sbc 	#0
.85af	85 37		sta $37				sta 	zTemp0+1
.85b1	a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.85b3	a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.85b5	b1 34		lda ($34),y			lda 	(basicStack),y
.85b7	0a		asl a				asl 	a 							; into carry
.85b8	a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.85ba	90 14		bcc $85d0			bcc 	_CITRNormal
.85bc	38		sec				sec
.85bd					_CITRNegative:
.85bd	a9 00		lda #$00			lda 	#0
.85bf	f1 34		sbc ($34),y			sbc 	(basicStack),y
.85c1	91 36		sta ($36),y			sta 	(zTemp0),y
.85c3	c8		iny				iny
.85c4	ca		dex				dex
.85c5	d0 f6		bne $85bd			bne 	_CITRNegative
.85c7	88		dey				dey 								; look at MSB of mantissa
.85c8	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.85ca	09 80		ora #$80			ora 	#$80
.85cc	91 36		sta ($36),y			sta 	(zTemp0),y
.85ce	7a		ply				ply
.85cf	60		rts				rts
.85d0					_CITRNormal:
.85d0	b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.85d2	91 36		sta ($36),y			sta 	(zTemp0),y
.85d4	c8		iny				iny
.85d5	ca		dex				dex
.85d6	d0 f8		bne $85d0			bne 	_CITRNormal
.85d8	7a		ply				ply 								; and exit.
.85d9	60		rts				rts
.85da					NextCommand:
.85da	a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.85dc	a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.85de	20 78 a7	jsr $a778			jsr 	StackCheckFrame
.85e1	5a		phy				phy
.85e2	a0 10		ldy #$10			ldy 	#16 						; get the step count
.85e4	b1 34		lda ($34),y			lda 	(basicStack),y
.85e6	85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.85e8	30 02		bmi $85ec			bmi 	_NCStepNeg
.85ea	64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.85ec					_NCStepNeg:
.85ec	a0 08		ldy #$08			ldy 	#8 							; offset to bump
.85ee	a2 04		ldx #$04			ldx 	#4 							; count to bump
.85f0	18		clc				clc
.85f1					_NCBump:
.85f1	71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.85f3	91 34		sta ($34),y			sta 	(basicStack),y
.85f5	a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.85f7	c8		iny				iny 								; next byte
.85f8	ca		dex				dex 								; do four times
.85f9	d0 f6		bne $85f1			bne 	_NCBump
.85fb	20 a0 85	jsr $85a0			jsr		CopyIndexToReference		; copy it to the reference variable.
.85fe	a0 10		ldy #$10			ldy 	#16 						; get step count again
.8600	b1 34		lda ($34),y			lda 	(basicStack),y
.8602	0a		asl a				asl 	a 							; sign bit to carry
.8603	a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8605	85 38		sta $38				sta 	zTemp1
.8607	90 02		bcc $860b			bcc 	_NCCompRev 					; use if step is +ve
.8609	a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.860b					_NCCompRev:
.860b	85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.860d	49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.860f	85 39		sta $39				sta 	zTemp1+1
.8611	a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8613	38		sec				sec
.8614					_NCCompare:
.8614	a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8616	b1 34		lda ($34),y			lda 	(basicStack),y
.8618	a4 39		ldy $39				ldy 	zTemp1+1
.861a	f1 34		sbc ($34),y			sbc 	(basicStack),y
.861c	e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.861e	e6 39		inc $39				inc 	zTemp1+1
.8620	ca		dex				dex 								; do it 4 times.
.8621	d0 f1		bne $8614			bne 	_NCCompare
.8623	50 02		bvc $8627			bvc 	_NCNoOverflow 				; convert to signed comparison
.8625	49 80		eor #$80			eor 	#$80
.8627					_NCNoOverflow:
.8627	7a		ply				ply 								; restore Y position
.8628	0a		asl a				asl 	a 							; is bit 7 set.
.8629	90 04		bcc $862f			bcc 	_NCLoopback 				; if no , >= so loop back
.862b	20 6a a7	jsr $a76a			jsr 	StackClose 					; exit the loop
.862e	60		rts				rts
.862f					_NCLoopBack:
.862f	20 a1 a7	jsr $a7a1			jsr 	STKLoadCodePosition 		; loop back
.8632	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8633					Command_GOSUB:
.8633	a2 00		ldx #$00			ldx 	#0
.8635	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8638	a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.863a	20 4c a7	jsr $a74c			jsr 	StackOpen 					; create frame
.863d	20 90 a7	jsr $a790			jsr 	STKSaveCodePosition 		; save current position
.8640	4c 56 86	jmp $8656			jmp 	GotoStackX
.8643					Command_RETURN:
.8643	a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8645	a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8647	20 78 a7	jsr $a778			jsr 	StackCheckFrame
.864a	20 a1 a7	jsr $a7a1			jsr 	STKLoadCodePosition 		; restore code position
.864d	20 6a a7	jsr $a76a			jsr 	StackClose
.8650	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8651					GotoCommand:
.8651	a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8653	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger
.8656					GotoStackX:
.8656	bd 10 04	lda $0410,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8659	48		pha				pha 								; it is slightly inefficient, just in cases.
.865a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.865d	fa		plx				plx
.865e	20 70 a6	jsr $a670			jsr 	MemorySearch 				; transfer to line number AX.
.8661	90 05		bcc $8668			bcc 	_GotoError 					; not found, off end.
.8663	d0 03		bne $8668			bne 	_GotoError 					; not found exactly
.8665	4c 99 8a	jmp $8a99			jmp 	RunNewLine 					; and go straight to new line code.
.8668					_GotoError:
.8668	a9 0d		lda #$0d		lda	#13
.866a	4c ff 8d	jmp $8dff		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.866d					IfCommand:
.866d	a2 00		ldx #$00			ldx 	#0 							; If what.
.866f	20 eb 9d	jsr $9deb			jsr 	EvaluateNumber
.8672	b1 30		lda ($30),y			lda 	(codePtr),y
.8674	c9 a8		cmp #$a8			cmp 	#KWD_THEN  					; could be THEN <stuff> or GOTO
.8676	d0 0a		bne $8682			bne 	_IFStructured
.8678	c8		iny				iny 								; consume THEN
.8679	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; is it zero
.867c	f0 01		beq $867f			beq 	_IfFail 					; if fail, go to next line
.867e	60		rts				rts 								; if THEN just continue
.867f					_IfFail:
.867f	4c 81 8a	jmp $8a81			jmp 	EOLCommand
.8682					_IfStructured:
.8682	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; is it zero
.8685	d0 07		bne $868e			bne 	_IfExit 					; if not, then continue normally.
.8687	a9 b5		lda #$b5			lda 	#KWD_ELSE 					; look for else/endif
.8689	a2 a5		ldx #$a5			ldx 	#KWD_ENDIF
.868b	20 41 8d	jsr $8d41			jsr 	ScanForward 				; and run from there/
.868e					_IfExit:
.868e	60		rts				rts
.868f					ElseCode:
.868f	a9 a5		lda #$a5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8691	aa		tax				tax 								; so just go to the structure exit
.8692	20 41 8d	jsr $8d41			jsr 	ScanForward
.8695	60		rts				rts
.8696					EndIf:
.8696	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8697					Command_Input:
.8697	a9 ff		lda #$ff			lda 	#$FF
.8699	8d a8 04	sta $04a8			sta 	IsInputFlag
.869c	80 03		bra $86a1			bra 	Command_IP_Main
.869e					Command_Print:
.869e	9c a8 04	stz $04a8			stz 	IsInputFlag
.86a1					Command_IP_Main:
.86a1	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.86a2					_CPLoop:
.86a2	08		php				php 								; save last action flag
.86a3	b1 30		lda ($30),y			lda 	(codePtr),y
.86a5	c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.86a7	f0 58		beq $8701			beq 	_CPExit
.86a9	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.86ab	f0 54		beq $8701			beq 	_CPExit
.86ad	68		pla				pla 								; throw last action flag
.86ae	b1 30		lda ($30),y			lda 	(codePtr),y
.86b0	c8		iny				iny
.86b1	c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.86b3	f0 49		beq $86fe			beq 	_CPContinueWithSameLine
.86b5	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.86b7	f0 40		beq $86f9			beq 	_CPTab
.86b9	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.86bb	f0 38		beq $86f5			beq 	_CPNewLine
.86bd	88		dey				dey 								; undo the get.
.86be	20 ac 93	jsr $93ac			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.86c1	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; read the status
.86c4	29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.86c6	f0 0d		beq $86d5			beq 	_CPIsValue
.86c8	ad a8 04	lda $04a8			lda 	IsInputFlag 				; if print, dereference and print.
.86cb	f0 05		beq $86d2			beq 	_CPIsPrint
.86cd	20 0a 87	jsr $870a			jsr 	CIInputValue 				; input a value to the reference
.86d0	80 23		bra $86f5			bra 	_CPNewLine
.86d2					_CPIsPrint:
.86d2	20 cc 96	jsr $96cc			jsr 	Dereference
.86d5					_CPIsValue:
.86d5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a number
.86d8	29 10		and #$10			and 	#NSBIsString
.86da	f0 0b		beq $86e7			beq 	_CPNumber
.86dc	ae 10 04	ldx $0410			ldx 	NSMantissa1 				; string, print the text.
.86df	ad 08 04	lda $0408			lda 	NSMantissa0
.86e2	20 73 87	jsr $8773			jsr 	CPPrintStringXA
.86e5	80 ba		bra $86a1			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.86e7					_CPNumber:
.86e7	a9 05		lda #$05			lda 	#5 							; maximum decimals
.86e9	20 b8 9c	jsr $9cb8			jsr 	ConvertNumberToString 		; convert to string
.86ec	a2 06		ldx #$06			ldx 	#DecimalBuffer >> 8
.86ee	a9 1c		lda #$1c			lda 	#DecimalBuffer & $FF
.86f0	20 73 87	jsr $8773			jsr 	CPPrintStringXA
.86f3	80 ac		bra $86a1			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.86f5					_CPNewLine:
.86f5	a9 0d		lda #$0d			lda 	#13
.86f7	80 02		bra $86fb			bra 	_CPPrintChar
.86f9					_CPTab:
.86f9	a9 09		lda #$09			lda 	#9 							; print TAB
.86fb					_CPPrintChar:
.86fb	20 86 87	jsr $8786			jsr 	CPPrintVector
.86fe					_CPContinueWithSameLine:
.86fe	38		sec				sec 								; loop round with carry set, which
.86ff	80 a1		bra $86a2			bra 	_CPLoop 					; will inhibit final CR
.8701					_CPExit:
.8701	28		plp				plp 								; get last action flag
.8702	b0 05		bcs $8709			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8704	a9 0d		lda #$0d			lda 	#13 						; print new line
.8706	20 86 87	jsr $8786			jsr 	CPPrintVector
.8709					_CPExit2:
.8709	60		rts				rts
.870a					CIInputValue:
.870a	a2 00		ldx #$00			ldx 	#0 							; input a line.
.870c					_CIInputLine:
.870c	20 89 87	jsr $8789			jsr 	CPInputVector 				; get key
.870f	c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8711	f0 1f		beq $8732			beq 	_CIHaveValue
.8713	c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8715	f0 11		beq $8728			beq 	_CIBackspace
.8717	c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8719	90 f1		bcc $870c			bcc 	_CIInputLine
.871b	e0 50		cpx #$50			cpx 	#80 						; max length
.871d	b0 ed		bcs $870c			bcs 	_CIInputLine
.871f	9d a9 05	sta $05a9,x			sta 	lineBuffer,x
.8722	e8		inx				inx
.8723	20 86 87	jsr $8786			jsr 	CPPrintVector 				; echo it.
.8726	80 e4		bra $870c			bra 	_CIInputLine
.8728					_CIBackSpace:
.8728	e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.872a	f0 e0		beq $870c			beq 	_CIInputLine
.872c	20 86 87	jsr $8786			jsr 	CPPrintVector 				; echo it.
.872f	ca		dex				dex
.8730	80 da		bra $870c			bra 	_CIInputLine
.8732					_CIHaveValue:
.8732	9e a9 05	stz $05a9,x			stz 	LineBuffer,x 				; ASCIIZ string now in line buffer.
.8735	ad 00 04	lda $0400			lda 	NSStatus 					; was it a string assignment
.8738	29 10		and #$10			and 	#NSBIsString
.873a	f0 1c		beq $8758			beq 	_CIAssignNumber 			; assign a number
.873c	a2 01		ldx #$01			ldx 	#1
.873e	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.8740	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8743	a9 05		lda #$05			lda 	#lineBuffer >> 8
.8745	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8748	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.874b	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.874e	a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8750	9d 00 04	sta $0400,x			sta  	NSStatus,x
.8753	ca		dex				dex 								; X = 0
.8754	20 c8 87	jsr $87c8			jsr 	AssignVariable
.8757	60		rts				rts
.8758					_CIAssignNumber:
.8758	a9 a9		lda #$a9			lda 	#lineBuffer & $FF 			; set up to point to new string
.875a	85 36		sta $36				sta 	zTemp0
.875c	a9 05		lda #$05			lda 	#lineBuffer >> 8
.875e	85 37		sta $37				sta 	zTemp0+1
.8760	a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8762	20 3a 9c	jsr $9c3a			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8765	90 07		bcc $876e			bcc 	_CIIsOkay
.8767	a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8769	20 86 87	jsr $8786			jsr 	CPPrintVector
.876c	80 9c		bra $870a			bra 	CIInputValue
.876e					_CIIsOkay:
.876e	ca		dex				dex 								; X = 0
.876f	20 c8 87	jsr $87c8			jsr 	AssignVariable
.8772	60		rts				rts
.8773					CPPrintStringXA:
.8773	5a		phy				phy
.8774	86 37		stx $37				stx 	zTemp0+1
.8776	85 36		sta $36				sta 	zTemp0
.8778	a0 00		ldy #$00			ldy 	#0
.877a					_PSXALoop:
.877a	b1 36		lda ($36),y			lda 	(zTemp0),y
.877c	f0 06		beq $8784			beq 	_PSXAExit
.877e	20 86 87	jsr $8786			jsr 	CPPrintVector
.8781	c8		iny				iny
.8782	80 f6		bra $877a			bra 	_PSXALoop
.8784					_PSXAExit:
.8784	7a		ply				ply
.8785	60		rts				rts
.8786					CPPrintVector:
.8786	4c 8c a8	jmp $a88c			jmp 	EXTPrintCharacter
.8789					CPInputVector:
.8789	4c 22 ab	jmp $ab22			jmp 	EXTInputSingleCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.878c					LetCommand:
.878c	a2 00		ldx #$00			ldx 	#0
.878e	b1 30		lda ($30),y			lda 	(codePtr),y
.8790	c9 10		cmp #$10			cmp 	#KWD_AT
.8792	d0 16		bne $87aa			bne 	_LCStandard
.8794	c8		iny				iny 								; skip equal
.8795	20 88 98	jsr $9888			jsr 	EvaluateTerm 				; get a number
.8798	20 cc 96	jsr $96cc			jsr 	Dereference 				; dereference it
.879b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check integer
.879e	49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.87a0	9d 00 04	sta $0400,x			sta 	NSStatus,x
.87a3	29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.87a5	d0 10		bne $87b7			bne 	_LCMain
.87a7	4c 56 a0	jmp $a056			jmp 	TypeError 					; was a reference before.
.87aa					_LCStandard:
.87aa	ad 96 93	lda $9396			lda 	PrecedenceLevel+"*"			; precedence > this
.87ad	20 b0 93	jsr $93b0			jsr 	EvaluateExpressionAtPrecedence
.87b0	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; is it a reference to an array
.87b3	c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.87b5	f0 0e		beq $87c5			beq 	_LetGoProc 					; it's a procedure call.
.87b7					_LCMain:
.87b7	a9 3d		lda #$3d			lda 	#"=" 						; check =
.87b9	20 f6 8d	jsr $8df6			jsr 	CheckNextA
.87bc	e8		inx				inx 								; RHS
.87bd	20 e2 9d	jsr $9de2			jsr 	EvaluateValue
.87c0	ca		dex				dex
.87c1	20 c8 87	jsr $87c8			jsr 	AssignVariable
.87c4	60		rts				rts
.87c5					_LetGoProc:
.87c5	4c 59 89	jmp $8959			jmp 	CallProcedure
.87c8					AssignVariable:
.87c8	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check the string/number type bits match
.87cb	48		pha				pha 								; save a copy
.87cc	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.87cf	29 10		and #$10			and 	#NSBIsString
.87d1	d0 0b		bne $87de			bne 	_ASError
.87d3	68		pla				pla 								; get back
.87d4	29 10		and #$10			and 	#NSBIsString 				; check type
.87d6	d0 03		bne $87db			bne 	_ASString
.87d8	4c f4 95	jmp $95f4			jmp 	AssignNumber
.87db					_ASString:
.87db	4c 62 96	jmp $9662			jmp 	AssignString
.87de					_ASError:
.87de	4c 56 a0	jmp $a056			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.87e1					Command_List:
.87e1	9c a6 04	stz $04a6			stz 	listIndent 					; reset indent.
.87e4	9c 0c 04	stz $040c			stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.87e7	9c 14 04	stz $0414			stz 	NSMantissa1+4
.87ea	a9 ff		lda #$ff			lda 	#$FF
.87ec	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.87ef	8d 17 04	sta $0417			sta 	NSMantissa1+7
.87f2	b1 30		lda ($30),y			lda 	(codePtr),y
.87f4	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.87f6	f0 1e		beq $8816			beq 	_CLSecond
.87f8	20 77 88	jsr $8877			jsr 	CLIsDigit 					; if not digit, list all
.87fb	b0 24		bcs $8821			bcs 	_CLStart
.87fd	a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.87ff	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger
.8802	b1 30		lda ($30),y			lda 	(codePtr),y
.8804	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8806	f0 0e		beq $8816			beq 	_CLSecond 					; if so go get it
.8808	ad 0c 04	lda $040c			lda 	NSMantissa0+4 				; copy 4->7
.880b	8d 0f 04	sta $040f			sta 	NSMantissa0+7
.880e	ad 14 04	lda $0414			lda 	NSMantissa1+4
.8811	8d 17 04	sta $0417			sta 	NSMantissa1+7
.8814	80 0b		bra $8821			bra 	_CLStart
.8816					_CLSecond:
.8816	c8		iny				iny 								; consume comma
.8817	20 77 88	jsr $8877			jsr 	CLIsDigit 					; digit found
.881a	b0 05		bcs $8821			bcs 	_CLStart 					; if not, continue listing
.881c	a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.881e	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger
.8821					_CLStart
.8821	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8823	85 30		sta $30				sta 	codePtr
.8825	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8827	85 31		sta $31				sta 	codePtr+1
.8829					_CLLoop:
.8829	20 42 ab	jsr $ab42			jsr 	EXTBreakCheck 				; break check
.882c	f0 33		beq $8861			beq 	_CLExit
.882e	b2 30		lda ($30)			lda 	(codePtr)
.8830	f0 2f		beq $8861			beq 	_CLExit
.8832	a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8834	20 64 88	jsr $8864			jsr 	CLCompareLineNo
.8837	90 1b		bcc $8854			bcc 	_CLNext
.8839	a2 07		ldx #$07			ldx 	#7
.883b	20 64 88	jsr $8864			jsr 	CLCompareLineNo
.883e	f0 02		beq $8842			beq 	_CLDoThisOne
.8840	b0 12		bcs $8854			bcs 	_CLNext
.8842					_CLDoThisOne:
.8842	20 a4 8d	jsr $8da4			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8845	20 8c b4	jsr $b48c			jsr 	ListConvertLine 			; convert line into token Buffer
.8848	a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.884a	a9 ac		lda #$ac			lda 	#(tokenBuffer & $FF)
.884c	20 58 8e	jsr $8e58			jsr 	PrintStringXA
.884f	a9 0d		lda #$0d			lda 	#13 						; new line
.8851	20 8c a8	jsr $a88c			jsr 	EXTPrintCharacter
.8854					_CLNext:
.8854	18		clc				clc
.8855	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8857	65 30		adc $30				adc 	codePtr
.8859	85 30		sta $30				sta 	codePtr
.885b	90 02		bcc $885f			bcc 	_CREExit
.885d	e6 31		inc $31				inc 	codePtr+1 					; carry
.885f					_CREExit:
.885f	80 c8		bra $8829			bra 	_CLLoop
.8861					_CLExit:
.8861	4c 5f 83	jmp $835f			jmp 	WarmStart
.8864					CLCompareLineNo:
.8864	38		sec				sec
.8865	a0 01		ldy #$01			ldy 	#1
.8867	b1 30		lda ($30),y			lda 	(codePtr),y
.8869	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.886c	85 36		sta $36				sta 	zTemp0
.886e	c8		iny				iny
.886f	b1 30		lda ($30),y			lda 	(codePtr),y
.8871	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.8874	05 36		ora $36				ora 	zTemp0
.8876	60		rts				rts
.8877					CLIsDigit:
.8877	b1 30		lda ($30),y			lda 	(codePtr),y
.8879	c9 30		cmp #$30			cmp 	#"0"
.887b	90 03		bcc $8880			bcc	 	_CLIDExitFalse
.887d	c9 3a		cmp #$3a			cmp 	#"9"+1
.887f	60		rts				rts
.8880					_CLIDExitFalse:
.8880	38		sec				sec
.8881	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8882					Command_LOCAL:
.8882	a2 00		ldx #$00			ldx 	#0 							; at level 0
.8884	20 90 88	jsr $8890			jsr 	LocaliseNextTerm 			; convert term to a local.
.8887	b1 30		lda ($30),y			lda 	(codePtr),y
.8889	c8		iny				iny
.888a	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.888c	f0 f4		beq $8882			beq 	Command_LOCAL
.888e	88		dey				dey 								; unpick pre-get
.888f	60		rts				rts
.8890					LocaliseNextTerm:
.8890	20 88 98	jsr $9888			jsr 	EvaluateTerm 				; evaluate the term
.8893	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8896	29 20		and #$20			and 	#NSBIsReference 			; check it is a reference
.8898	f0 61		beq $88fb			beq		_LNTError
.889a	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.889d	85 36		sta $36				sta 	zTemp0
.889f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.88a2	85 37		sta $37				sta  	zTemp0+1
.88a4	bd 00 04	lda $0400,x			lda 	NSStatus,x
.88a7	29 10		and #$10			and 	#NSBIsString
.88a9	d0 1e		bne $88c9			bne 	_LNTPushString
.88ab	5a		phy				phy
.88ac	a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.88ae					_LNTPushNumLoop:
.88ae	b1 36		lda ($36),y			lda		(zTemp0),y
.88b0	20 2a a7	jsr $a72a			jsr 	StackPushByte
.88b3	c8		iny				iny
.88b4	c0 05		cpy #$05			cpy 	#5
.88b6	d0 f6		bne $88ae			bne 	_LNTPushNumLoop
.88b8	a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.88ba	20 2a a7	jsr $a72a			jsr 	StackPushByte
.88bd	a5 37		lda $37				lda 	zTemp0+1
.88bf	20 2a a7	jsr $a72a			jsr 	StackPushByte
.88c2	a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.88c4	20 2a a7	jsr $a72a			jsr 	StackPushByte
.88c7	7a		ply				ply
.88c8	60		rts				rts
.88c9					_LNTPushString:
.88c9	5a		phy				phy
.88ca	b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.88cc	85 38		sta $38				sta 	zTemp1
.88ce	a0 01		ldy #$01			ldy 	#1
.88d0	b1 36		lda ($36),y			lda 	(zTemp0),y
.88d2	85 39		sta $39				sta 	zTemp1+1
.88d4	a0 00		ldy #$00			ldy 	#0 							; output string
.88d6	c9 00		cmp #$00			cmp 	#0 							; if not assigned strin
.88d8	f0 0a		beq $88e4			beq 	_LNTStringOut
.88da					_LNTPushStrLoop:
.88da	b1 38		lda ($38),y			lda 	(zTemp1),y
.88dc	f0 06		beq $88e4			beq 	_LNTStringOut
.88de	20 2a a7	jsr $a72a			jsr 	StackPushByte
.88e1	c8		iny				iny
.88e2	80 f6		bra $88da			bra 	_LNTPushStrLoop
.88e4					_LNTStringOut:
.88e4	98		tya				tya									; output length
.88e5	20 2a a7	jsr $a72a			jsr 	StackPushByte
.88e8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.88eb	20 2a a7	jsr $a72a			jsr 	StackPushByte
.88ee	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.88f1	20 2a a7	jsr $a72a			jsr 	StackPushByte
.88f4	a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.88f6	20 2a a7	jsr $a72a			jsr 	StackPushByte
.88f9	7a		ply				ply
.88fa	60		rts				rts
.88fb					_LNTError:
.88fb	4c 4c a0	jmp $a04c			jmp 	SyntaxError
.88fe					LocalPopValue:
.88fe	20 43 a7	jsr $a743			jsr 	StackPopByte
.8901	c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8903	d0 17		bne $891c			bne 	_LPVString
.8905	20 43 a7	jsr $a743			jsr 	StackPopByte 				; address
.8908	85 37		sta $37				sta 	zTemp0+1
.890a	20 43 a7	jsr $a743			jsr 	StackPopByte
.890d	85 36		sta $36				sta 	zTemp0
.890f	5a		phy				phy
.8910	a0 04		ldy #$04			ldy 	#4 							; copy back
.8912					_LPVNumberCopy:
.8912	20 43 a7	jsr $a743			jsr 	StackPopByte
.8915	91 36		sta ($36),y			sta 	(zTemp0),y
.8917	88		dey				dey
.8918	10 f8		bpl $8912			bpl 	_LPVNumberCopy
.891a	7a		ply				ply 								; and complete
.891b	60		rts				rts
.891c					_LPVString:
.891c	20 43 a7	jsr $a743			jsr 	StackPopByte 				; address of record => zTemp0
.891f	85 37		sta $37				sta 	zTemp0+1
.8921	20 43 a7	jsr $a743			jsr 	StackPopByte
.8924	85 36		sta $36				sta 	zTemp0
.8926	5a		phy				phy
.8927	b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to => zTemp1
.8929	85 38		sta $38				sta 	zTemp1
.892b	a0 01		ldy #$01			ldy 	#1
.892d	b1 36		lda ($36),y			lda 	(zTemp0),y
.892f	85 39		sta $39				sta 	zTemp1+1
.8931	20 43 a7	jsr $a743			jsr 	StackPopByte 				; # to get => y
.8934	a8		tay				tay
.8935	a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8937	f0 0e		beq $8947			beq 	_LPVStringCopied
.8939	a9 00		lda #$00			lda 	#0 							; NULL on end
.893b	91 38		sta ($38),y			sta 	(zTemp1),y
.893d					_LPVStringCopy:
.893d	88		dey				dey
.893e	30 07		bmi $8947			bmi 	_LPVStringCopied
.8940	20 43 a7	jsr $a743			jsr 	StackPopByte
.8943	91 38		sta ($38),y			sta 	(zTemp1),y
.8945	80 f6		bra $893d			bra 	_LPVStringCopy
.8947					_LPVStringCopied:
.8947	fa		plx				plx
.8948	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8949					NewCommand:
.8949	20 4f 89	jsr $894f			jsr 	NewProgram 					; does the actual NEW.
.894c	4c 5f 83	jmp $835f			jmp 	WarmStart 					; and warm starts straight away.
.894f					NewProgram:
.894f	20 4e a6	jsr $a64e			jsr 	MemoryNew
.8952	9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8955	20 f8 83	jsr $83f8			jsr 	ClearCommand 				; clear everything.
.8958	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2					ParameterStackPos = 2
.8959					CallProcedure:
.8959	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.895b	b1 30		lda ($30),y			lda 	(codePtr),y
.895d	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.895f	f0 0c		beq $896d			beq 	_CPEndParam
.8961					_CPParamLoop:
.8961	20 e2 9d	jsr $9de2			jsr 	EvaluateValue 				; get parameter onto stack
.8964	e8		inx				inx 								; bump next stack
.8965	b1 30		lda ($30),y			lda 	(codePtr),y
.8967	c8		iny				iny
.8968	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.896a	f0 f5		beq $8961			beq 	_CPParamLoop
.896c	88		dey				dey 								; unpick.
.896d					_CPEndParam:
.896d	8e 96 04	stx $0496			stx 	LastParameter 				; save the last parameters index.
.8970	c8		iny				iny									; skip right bracket
.8971	a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8973	20 4c a7	jsr $a74c			jsr 	StackOpen
.8976	20 90 a7	jsr $a790			jsr 	STKSaveCodePosition 		; save loop position
.8979	ad 08 04	lda $0408			lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.897c	85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.897e	ad 10 04	lda $0410			lda 	NSMantissa1
.8981	85 37		sta $37				sta 	zTemp0+1
.8983	a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8985	b2 36		lda ($36)			lda 	(zTemp0)
.8987	85 30		sta $30				sta 	safePtr
.8989	b1 36		lda ($36),y			lda 	(zTemp0),y
.898b	85 31		sta $31				sta 	safePtr+1
.898d	c8		iny				iny
.898e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8990	85 32		sta $32				sta 	safePtr+2
.8992	c8		iny				iny
.8993	b1 36		lda ($36),y			lda 	(zTemp0),y
.8995	85 33		sta $33				sta 	safePtr+3
.8997	c8		iny				iny 								; get Y offset -> Y
.8998	b1 36		lda ($36),y			lda 	(zTemp0),y
.899a	a8		tay				tay
.899b	a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.899d	ec 96 04	cpx $0496			cpx	 	LastParameter 				; check no parameters at the start
.89a0	f0 13		beq $89b5			beq 	_ParamExit 					; if so, exit.
.89a2					_ParamExtract:
.89a2	ca		dex				dex 								; put a local term on the level before
.89a3	20 90 88	jsr $8890			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.89a6	20 c8 87	jsr $87c8			jsr 	AssignVariable 				; assign stacked value to the variable.
.89a9	e8		inx				inx 								; advance to next parameter to do.
.89aa	e8		inx				inx
.89ab	ec 96 04	cpx $0496			cpx 	LastParameter 				; are we done ?
.89ae	f0 05		beq $89b5			beq 	_ParamExit
.89b0	20 ee 8d	jsr $8dee			jsr 	CheckComma 					; comma seperating parameters
.89b3	80 ed		bra $89a2			bra 	_ParamExtract
.89b5					_ParamExit:
.89b5	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket 			; check )
.89b8	60		rts				rts 								; and continue from here
.89b9					Command_ENDPROC:
.89b9	a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.89bb	a2 14		ldx #$14			ldx 	#ERRID_PROC
.89bd	20 78 a7	jsr $a778			jsr 	StackCheckFrame
.89c0	20 a1 a7	jsr $a7a1			jsr 	STKLoadCodePosition 		; restore code position
.89c3	20 6a a7	jsr $a76a			jsr 	StackClose
.89c6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.89c7					Command_Read:
.89c7	a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.89c9	20 88 98	jsr $9888			jsr 	EvaluateTerm
.89cc	bd 00 04	lda $0400,x			lda 	NSStatus,x
.89cf	29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.89d1	f0 4a		beq $8a1d			beq 	_CRSyntax 					; check reference (bit 0)
.89d3	20 66 8a	jsr $8a66			jsr 	SwapDataCodePtrs 			; swap code and data
.89d6	ad 9c 04	lda $049c			lda 	inDataStatement 			; if in a data statement, we don't need to search
.89d9	d0 20		bne $89fb			bne 	_CRContinueData
.89db					_CRKeepSearching:
.89db	a9 b2		lda #$b2			lda 	#KWD_DATA 					; scan for instruction
.89dd	aa		tax				tax
.89de	20 41 8d	jsr $8d41			jsr 	ScanForward
.89e1	c9 b2		cmp #$b2			cmp 	#KWD_DATA 					; found data ?
.89e3	f0 16		beq $89fb			beq 	_CRHaveData 				; found it
.89e5	18		clc				clc
.89e6	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.89e8	65 30		adc $30				adc 	codePtr
.89ea	85 30		sta $30				sta 	codePtr
.89ec	90 02		bcc $89f0			bcc 	_CREExit
.89ee	e6 31		inc $31				inc 	codePtr+1 					; carry
.89f0					_CREExit:
.89f0	a0 03		ldy #$03			ldy 	#3 							; start of line.
.89f2	b2 30		lda ($30)			lda 	(codePtr)
.89f4	d0 e5		bne $89db			bne 	_CRKeepSearching
.89f6	a9 0b		lda #$0b		lda	#11
.89f8	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.89fb					_CRHaveData:
.89fb					_CRContinueData:
.89fb	a2 01		ldx #$01			ldx 	#1
.89fd	20 e2 9d	jsr $9de2			jsr 	EvaluateValue 				; evaluate value into slot # 1
.8a00	ca		dex				dex
.8a01	20 c8 87	jsr $87c8			jsr		AssignVariable 				; do the assignment
.8a04	9c 9c 04	stz $049c			stz 	inDataStatement 			; clear in data
.8a07	b1 30		lda ($30),y			lda 	(codePtr),y
.8a09	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement
.8a0b	d0 04		bne $8a11			bne 	_CRSwapBack
.8a0d	c8		iny				iny 								; consume comma
.8a0e	ee 9c 04	inc $049c			inc 	inDataStatement 			; set in data statement currently.
.8a11					_CRSwapBack:
.8a11	20 66 8a	jsr $8a66			jsr 	SwapDataCodePtrs			; swap them back.
.8a14	b1 30		lda ($30),y			lda 	(codePtr),y
.8a16	c8		iny				iny
.8a17	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a19	f0 ac		beq $89c7			beq 	Command_Read 				; if so go round again.
.8a1b	88		dey				dey 								; unpick get.
.8a1c	60		rts				rts
.8a1d					_CRSyntax:
.8a1d	4c 4c a0	jmp $a04c			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.8a20					RemCommand:
.8a20	b1 30		lda ($30),y			lda 	(codePtr),y
.8a22	c9 ff		cmp #$ff			cmp 	#KWC_STRING
.8a24	d0 06		bne $8a2c			bne 	_RMExit
.8a26	c8		iny				iny 								; point to offset
.8a27	98		tya				tya 								; A = offset position
.8a28	38		sec				sec 								; add size +1 hence SEC
.8a29	71 30		adc ($30),y			adc 	(codePtr),y
.8a2b	a8		tay				tay 								; make current position.
.8a2c					_RMExit:
.8a2c	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.8a2d					Command_REPEAT:
.8a2d	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.8a2f	20 4c a7	jsr $a74c			jsr 	StackOpen
.8a32	20 90 a7	jsr $a790			jsr 	STKSaveCodePosition 		; save loop position
.8a35	60		rts				rts
.8a36					Command_UNTIL:
.8a36	a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.8a38	a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.8a3a	20 78 a7	jsr $a778			jsr 	StackCheckFrame
.8a3d	a2 00		ldx #$00			ldx 	#0
.8a3f	20 eb 9d	jsr $9deb			jsr 	EvaluateNumber 				; work out the number
.8a42	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; check if zero
.8a45	f0 04		beq $8a4b			beq 	_CULoopBack 				; if so keep looping
.8a47	20 6a a7	jsr $a76a			jsr 	StackClose		 			; return
.8a4a	60		rts				rts
.8a4b					_CULoopBack:
.8a4b	20 a1 a7	jsr $a7a1			jsr 	STKLoadCodePosition 		; loop back
.8a4e	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.8a4f					Command_Restore:
.8a4f	20 66 8a	jsr $8a66			jsr 	SwapDataCodePtrs 			; swap code and data
.8a52	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a54	85 30		sta $30				sta 	codePtr
.8a56	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a58	85 31		sta $31				sta 	codePtr+1
.8a5a	20 66 8a	jsr $8a66			jsr 	SwapDataCodePtrs 			; put them back
.8a5d	a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.8a5f	8d 9b 04	sta $049b			sta 	dataPointer+4
.8a62	9c 9c 04	stz $049c			stz 	inDataStatement 			; not in data statement
.8a65	60		rts				rts
.8a66					SwapDataCodePtrs:
.8a66	da		phx				phx
.8a67	a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.8a69					_SDCPLoop:
.8a69	b5 30		lda $30,x			lda 	safePtr,x
.8a6b	48		pha				pha
.8a6c	bd 97 04	lda $0497,x			lda 	dataPointer,x
.8a6f	95 30		sta $30,x			sta 	safePtr,x
.8a71	68		pla				pla
.8a72	9d 97 04	sta $0497,x			sta 	dataPointer,x
.8a75	ca		dex				dex
.8a76	10 f1		bpl $8a69			bpl 	_SDCPLoop
.8a78	ad 9b 04	lda $049b			lda 	dataPointer+4 				; swap Y position over.
.8a7b	8c 9b 04	sty $049b			sty 	dataPointer+4
.8a7e	a8		tay				tay
.8a7f	fa		plx				plx
.8a80	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.8a81					EOLCommand:
.8a81	18		clc				clc
.8a82	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8a84	65 30		adc $30				adc 	codePtr
.8a86	85 30		sta $30				sta 	codePtr
.8a88	90 02		bcc $8a8c			bcc 	_CREExit
.8a8a	e6 31		inc $31				inc 	codePtr+1 					; carry
.8a8c					_CREExit:
.8a8c	80 0b		bra $8a99			bra 	RunNewLine
.8a8e					CommandRUN:
.8a8e	20 f8 83	jsr $83f8			jsr 	ClearCommand 				; clear variable/stacks/etc.
.8a91	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8a93	85 30		sta $30				sta 	codePtr
.8a95	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8a97	85 31		sta $31				sta 	codePtr+1
.8a99					RUNNewLine:
.8a99	b2 30		lda ($30)			lda 	(codePtr)
.8a9b	f0 72		beq $8b0f			beq 	CRNoProgram         		; no then END.
.8a9d	a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.8a9f	9a		txs				txs
.8aa0					RUNCodePointerLine:
.8aa0	a0 02		ldy #$02			ldy 	#2 							; start of program
.8aa2					_CRIncMainLoop:
.8aa2	0e 93 04	asl $0493			asl 	breakCheck 					; clears 1 time in 8
.8aa5	d0 19		bne $8ac0			bne 	_CRNoBreakCheck
.8aa7	20 42 ab	jsr $ab42			jsr 	EXTBreakCheck 				; break check
.8aaa	f0 5e		beq $8b0a			beq 	_CRBreak
.8aac	64 01		stz $01				stz 	1 							; access I/O Page 0
.8aae	38		sec				sec 								; calculate timer - LastTick
.8aaf	ad 59 d6	lda $d659			lda 	$D659
.8ab2	aa		tax				tax 								; saving timer in X
.8ab3	ed 2e 06	sbc $062e			sbc 	LastTick
.8ab6	c9 03		cmp #$03			cmp 	#3
.8ab8	90 06		bcc $8ac0			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.8aba	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.8abd	20 a7 ba	jsr $baa7			jsr 	TickHandler 				; go do the code.
.8ac0					_NoFireTick:
.8ac0					_CRNoBreakCheck:
.8ac0	c8		iny				iny
.8ac1					_CRMainLoop:
.8ac1	9c 90 04	stz $0490			stz 	stringInitialised 			; clear the temporary string initialised flag.
.8ac4	b1 30		lda ($30),y			lda 	(codePtr),y
.8ac6	10 10		bpl $8ad8			bpl 	_CRNotKeyword
.8ac8	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.8aca	b0 04		bcs $8ad0			bcs 	_CRIsKeyword
.8acc	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.8ace	b0 34		bcs $8b04			bcs		_CRSyntaxError
.8ad0					_CRIsKeyword:
.8ad0	c8		iny				iny 								; consume command
.8ad1	0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.8ad2	aa		tax				tax 								; put in X for vector jump
.8ad3	20 07 8b	jsr $8b07			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.8ad6	80 e9		bra $8ac1			bra 	_CRMainLoop 				; and loop round
.8ad8					_CRNotKeyword:
.8ad8	c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.8ada	f0 c6		beq $8aa2			beq 	_CRIncMainLoop
.8adc	c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.8ade	90 05		bcc $8ae5			bcc 	_CRNotVariable
.8ae0					_CRGoLet:
.8ae0	20 8c 87	jsr $878c			jsr 	LetCommand
.8ae3	80 dc		bra $8ac1			bra 	_CRMainLoop
.8ae5					_CRNotVariable:
.8ae5	c9 10		cmp #$10			cmp 	#KWD_AT 					; handle @
.8ae7	f0 f7		beq $8ae0			beq 	_CRGoLet
.8ae9	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.8aeb	f0 f3		beq $8ae0			beq 	_CRGoLet
.8aed	c9 21		cmp #$21			cmp 	#KWD_PLING
.8aef	f0 ef		beq $8ae0			beq 	_CRGoLet
.8af1	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.8af3	f0 09		beq $8afe			beq 	_CRGoRem
.8af5	c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.8af7	d0 0b		bne $8b04			bne 	_CRSyntaxError
.8af9	20 14 82	jsr $8214			jsr 	LabelHere
.8afc	80 c3		bra $8ac1			bra 	_CRMainLoop
.8afe					_CRGoRem:
.8afe	c8		iny				iny
.8aff	20 20 8a	jsr $8a20			jsr 	RemCommand
.8b02	80 bd		bra $8ac1			bra 	_CRMainLoop
.8b04					_CRSyntaxError:
.8b04	4c 4c a0	jmp $a04c			jmp 	SyntaxError
.8b07					_CRCallVector0:
.8b07	7c a6 8b	jmp ($8ba6,x)			jmp 	(VectorSet0,x)
.8b0a					_CRBreak:
.8b0a	a9 01		lda #$01		lda	#1
.8b0c	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.8b0f					CRNoProgram:
.8b0f	4c 1d 85	jmp $851d			jmp 	EndCommand
.8b12					Shift1Command:
.8b12	b1 30		lda ($30),y			lda 	(codePtr),y
.8b14	c8		iny				iny
.8b15	0a		asl a				asl 	a
.8b16	aa		tax				tax
.8b17	7c 44 8c	jmp ($8c44,x)			jmp 	(VectorSet1,x)
.8b1a					Shift2Command:
.8b1a	b1 30		lda ($30),y			lda 	(codePtr),y
.8b1c	c8		iny				iny
.8b1d	0a		asl a				asl 	a
.8b1e	aa		tax				tax
.8b1f	7c 62 8c	jmp ($8c62,x)			jmp 	(VectorSet2,x)
.8b22					Unused1:
.8b22					Unused2:
.8b22					Unused3:
.8b22					Unused4:
.8b22	4c 4c a0	jmp $a04c			jmp 	SyntaxError
>8b25							.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.8b26					VectorSetPunc:
>8b26	ec 90					.word	ShiftLeft                        ; $00 <<
>8b28	a3 8e					.word	BinaryCompareLessEqual           ; $01 <=
>8b2a	99 8e					.word	BinaryCompareNotEqual            ; $02 <>
>8b2c	4c a0					.word	SyntaxError                      ; $03 !!3
>8b2e	4c a0					.word	SyntaxError                      ; $04 ><
>8b30	ad 8e					.word	BinaryCompareGreaterEqual        ; $05 >=
>8b32	ef 90					.word	ShiftRight                       ; $06 >>
>8b34	4c a0					.word	SyntaxError                      ; $07 !!7
>8b36	4c a0					.word	SyntaxError                      ; $08 !!8
>8b38	4c a0					.word	SyntaxError                      ; $09 !!9
>8b3a	4c a0					.word	SyntaxError                      ; $0a !!10
>8b3c	4c a0					.word	SyntaxError                      ; $0b !!11
>8b3e	4c a0					.word	SyntaxError                      ; $0c !!12
>8b40	4c a0					.word	SyntaxError                      ; $0d !!13
>8b42	4c a0					.word	SyntaxError                      ; $0e !!14
>8b44	4c a0					.word	SyntaxError                      ; $0f !!15
>8b46	4c a0					.word	SyntaxError                      ; $10 @
>8b48	4c a0					.word	SyntaxError                      ; $11 !!17
>8b4a	4c a0					.word	SyntaxError                      ; $12 !!18
>8b4c	4c a0					.word	SyntaxError                      ; $13 [
>8b4e	70 8f					.word	IntegerDivide                    ; $14 \
>8b50	4c a0					.word	SyntaxError                      ; $15 ]
>8b52	7d 92					.word	EorInteger                       ; $16 ^
>8b54	4c a0					.word	SyntaxError                      ; $17 _
>8b56	4c a0					.word	SyntaxError                      ; $18 `
>8b58	4c a0					.word	SyntaxError                      ; $19 !!25
>8b5a	4c a0					.word	SyntaxError                      ; $1a !!26
>8b5c	4c a0					.word	SyntaxError                      ; $1b {
>8b5e	37 92					.word	OraInteger                       ; $1c |
>8b60	4c a0					.word	SyntaxError                      ; $1d }
>8b62	4c a0					.word	SyntaxError                      ; $1e ~
>8b64	4c a0					.word	SyntaxError                      ; $1f [7m<7F>[m
>8b66	4c a0					.word	SyntaxError                      ; $20
>8b68	c3 92					.word	WordIndirect                     ; $21 !
>8b6a	4c a0					.word	SyntaxError                      ; $22 "
>8b6c	4c a0					.word	SyntaxError                      ; $23 #
>8b6e	4c a0					.word	SyntaxError                      ; $24 $
>8b70	bd 8f					.word	IntegerModulus                   ; $25 %
>8b72	f1 91					.word	AndInteger                       ; $26 &
>8b74	4c a0					.word	SyntaxError                      ; $27 '
>8b76	4c a0					.word	SyntaxError                      ; $28 (
>8b78	4c a0					.word	SyntaxError                      ; $29 )
>8b7a	32 90					.word	MulInteger                       ; $2a *
>8b7c	83 91					.word	AddInteger                       ; $2b +
>8b7e	4c a0					.word	SyntaxError                      ; $2c ,
>8b80	c6 91					.word	SubInteger                       ; $2d -
>8b82	4c a0					.word	SyntaxError                      ; $2e .
>8b84	ae 94					.word	FDivideCommand                   ; $2f /
>8b86	4c a0					.word	SyntaxError                      ; $30 0
>8b88	4c a0					.word	SyntaxError                      ; $31 1
>8b8a	4c a0					.word	SyntaxError                      ; $32 2
>8b8c	4c a0					.word	SyntaxError                      ; $33 3
>8b8e	4c a0					.word	SyntaxError                      ; $34 4
>8b90	4c a0					.word	SyntaxError                      ; $35 5
>8b92	4c a0					.word	SyntaxError                      ; $36 6
>8b94	4c a0					.word	SyntaxError                      ; $37 7
>8b96	4c a0					.word	SyntaxError                      ; $38 8
>8b98	4c a0					.word	SyntaxError                      ; $39 9
>8b9a	4c a0					.word	SyntaxError                      ; $3a :
>8b9c	4c a0					.word	SyntaxError                      ; $3b ;
>8b9e	85 8e					.word	BinaryCompareLess                ; $3c <
>8ba0	7b 8e					.word	BinaryCompareEqual               ; $3d =
>8ba2	8f 8e					.word	BinaryCompareGreater             ; $3e >
>8ba4	ea 92					.word	ByteIndirect                     ; $3f ?
.8ba6					VectorSet0:
>8ba6	81 8a					.word	EOLCommand                       ; $80 !0:EOF
>8ba8	12 8b					.word	Shift1Command                    ; $81 !1:SH1
>8baa	1a 8b					.word	Shift2Command                    ; $82 !2:SH2
>8bac	1e 9a					.word	AbsUnary                         ; $83 ABS(
>8bae	2e 9a					.word	AllocUnary                       ; $84 ALLOC(
>8bb0	9e 9a					.word	AscUnary                         ; $85 ASC(
>8bb2	69 9c					.word	ChrUnary                         ; $86 CHR$(
>8bb4	bf a4					.word	UnaryEvent                       ; $87 EVENT(
>8bb6	77 8e					.word	UnaryFalse                       ; $88 FALSE
>8bb8	ab 9a					.word	FracUnary                        ; $89 FRAC(
>8bba	55 a4					.word	UnaryHit                         ; $8a HIT(
>8bbc	c1 9a					.word	IntUnary                         ; $8b INT(
>8bbe	28 9c					.word	IsValUnary                       ; $8c ISVAL(
>8bc0	4f a5					.word	UnaryJoyB                        ; $8d JOYB(
>8bc2	28 a5					.word	UnaryJoyX                        ; $8e JOYX(
>8bc4	2b a5					.word	UnaryJoyY                        ; $8f JOYY(
>8bc6	43 9d					.word	Unary_Left                       ; $90 LEFT$(
>8bc8	d3 9a					.word	LenUnary                         ; $91 LEN(
>8bca	f1 9a					.word	Unary_Max                        ; $92 MAX(
>8bcc	6d 9d					.word	Unary_Mid                        ; $93 MID$(
>8bce	ed 9a					.word	Unary_Min                        ; $94 MIN(
>8bd0	48 9b					.word	Unary_Not                        ; $95 NOT(
>8bd2	a3 a6					.word	UnaryPlaying                     ; $96 PLAYING(
>8bd4	5e 9b					.word	Unary_Random                     ; $97 RANDOM(
>8bd6	53 9d					.word	Unary_Right                      ; $98 RIGHT$(
>8bd8	7d 9b					.word	Unary_Rnd                        ; $99 RND(
>8bda	fe 9b					.word	SgnUnary                         ; $9a SGN(
>8bdc	7b 9c					.word	SpcUnary                         ; $9b SPC(
>8bde	96 9c					.word	Unary_Str                        ; $9c STR$(
>8be0	75 a5					.word	UnaryTimer                       ; $9d TIMER(
>8be2	6b 8e					.word	UnaryTrue                        ; $9e TRUE
>8be4	1e 9c					.word	ValUnary                         ; $9f VAL(
>8be6	20 85					.word	ForCommand                       ; $a0 FOR
>8be8	6d 86					.word	IfCommand                        ; $a1 IF
>8bea	22 8b					.word	Unused1                          ; $a2 PROC
>8bec	2d 8a					.word	Command_REPEAT                   ; $a3 REPEAT
>8bee	b7 8d					.word	Command_WHILE                    ; $a4 WHILE
>8bf0	96 86					.word	EndIf                            ; $a5 ENDIF
>8bf2	b9 89					.word	Command_ENDPROC                  ; $a6 ENDPROC
>8bf4	da 85					.word	NextCommand                      ; $a7 NEXT
>8bf6	22 8b					.word	Unused4                          ; $a8 THEN
>8bf8	36 8a					.word	Command_UNTIL                    ; $a9 UNTIL
>8bfa	d8 8d					.word	Command_WEND                     ; $aa WEND
>8bfc	4c a0					.word	SyntaxError                      ; $ab BY
>8bfe	be 83					.word	CallCommand                      ; $ac CALL
>8c00	f7 a1					.word	CircleCommand                    ; $ad CIRCLE
>8c02	f8 83					.word	ClearCommand                     ; $ae CLEAR
>8c04	50 84					.word	ClearScreen                      ; $af CLS
>8c06	4c a0					.word	SyntaxError                      ; $b0 COLOR
>8c08	4c a0					.word	SyntaxError                      ; $b1 COLOUR
>8c0a	58 84					.word	Command_Data                     ; $b2 DATA
>8c0c	60 84					.word	DimCommand                       ; $b3 DIM
>8c0e	22 8b					.word	Unused3                          ; $b4 DOWNTO
>8c10	8f 86					.word	ElseCode                         ; $b5 ELSE
>8c12	4c a0					.word	SyntaxError                      ; $b6 FROM
>8c14	23 a4					.word	GfxCommand                       ; $b7 GFX
>8c16	33 86					.word	Command_GOSUB                    ; $b8 GOSUB
>8c18	51 86					.word	GotoCommand                      ; $b9 GOTO
>8c1a	4c a0					.word	SyntaxError                      ; $ba HERE
>8c1c	21 a2					.word	ImageCommand                     ; $bb IMAGE
>8c1e	97 86					.word	Command_Input                    ; $bc INPUT
>8c20	8c 87					.word	LetCommand                       ; $bd LET
>8c22	76 a2					.word	LineCommand                      ; $be LINE
>8c24	82 88					.word	Command_LOCAL                    ; $bf LOCAL
>8c26	4c a0					.word	SyntaxError                      ; $c0 OFF
>8c28	4c a0					.word	SyntaxError                      ; $c1 ON
>8c2a	4c a0					.word	SyntaxError                      ; $c2 OUTLINE
>8c2c	7b a4					.word	PaletteCommand                   ; $c3 PALETTE
>8c2e	6f a2					.word	PlotCommand                      ; $c4 PLOT
>8c30	9e 86					.word	Command_Print                    ; $c5 PRINT
>8c32	c7 89					.word	Command_Read                     ; $c6 READ
>8c34	f3 a1					.word	RectangleCommand                 ; $c7 RECT
>8c36	20 8a					.word	RemCommand                       ; $c8 REM
>8c38	43 86					.word	Command_RETURN                   ; $c9 RETURN
>8c3a	4c a0					.word	SyntaxError                      ; $ca SOLID
>8c3c	bf a6					.word	SoundCommand                     ; $cb SOUND
>8c3e	02 a2					.word	SpriteCommand                    ; $cc SPRITE
>8c40	3e a2					.word	TextCommand                      ; $cd TEXT
>8c42	22 8b					.word	Unused2                          ; $ce TO
.8c44					VectorSet1:
>8c44	4c a0					.word	SyntaxError                      ; $80 !0:EOF
>8c46	4c a0					.word	SyntaxError                      ; $81 !1:SH1
>8c48	4c a0					.word	SyntaxError                      ; $82 !2:SH2
>8c4a	8f 83					.word	AssembleCommand                  ; $83 ASSEMBLE
>8c4c	ae 83					.word	AssertCommand                    ; $84 ASSERT
>8c4e	c3 a3					.word	BitmapCtrl                       ; $85 BITMAP
>8c50	1d 85					.word	EndCommand                       ; $86 END
>8c52	6c a5					.word	GoCommand                        ; $87 GO
>8c54	e1 87					.word	Command_List                     ; $88 LIST
>8c56	63 a5					.word	LoadCommand                      ; $89 LOAD
>8c58	49 89					.word	NewCommand                       ; $8a NEW
>8c5a	4f 8a					.word	Command_Restore                  ; $8b RESTORE
>8c5c	8e 8a					.word	CommandRUN                       ; $8c RUN
>8c5e	08 a4					.word	SpritesCtrl                      ; $8d SPRITES
>8c60	ea 8c					.word	StopCommand                      ; $8e STOP
.8c62					VectorSet2:
>8c62	4c a0					.word	SyntaxError                      ; $80 !0:EOF
>8c64	4c a0					.word	SyntaxError                      ; $81 !1:SH1
>8c66	4c a0					.word	SyntaxError                      ; $82 !2:SH2
>8c68	0b 9f					.word	Assemble_adc                     ; $83 ADC
>8c6a	03 9f					.word	Assemble_and                     ; $84 AND
>8c6c	1f 9f					.word	Assemble_asl                     ; $85 ASL
>8c6e	89 9f					.word	Assemble_bcc                     ; $86 BCC
>8c70	8d 9f					.word	Assemble_bcs                     ; $87 BCS
>8c72	95 9f					.word	Assemble_beq                     ; $88 BEQ
>8c74	4c 9f					.word	Assemble_bit                     ; $89 BIT
>8c76	7d 9f					.word	Assemble_bmi                     ; $8a BMI
>8c78	91 9f					.word	Assemble_bne                     ; $8b BNE
>8c7a	79 9f					.word	Assemble_bpl                     ; $8c BPL
>8c7c	99 9f					.word	Assemble_bra                     ; $8d BRA
>8c7e	9d 9f					.word	Assemble_brk                     ; $8e BRK
>8c80	81 9f					.word	Assemble_bvc                     ; $8f BVC
>8c82	85 9f					.word	Assemble_bvs                     ; $90 BVS
>8c84	a5 9f					.word	Assemble_clc                     ; $91 CLC
>8c86	f9 9f					.word	Assemble_cld                     ; $92 CLD
>8c88	b9 9f					.word	Assemble_cli                     ; $93 CLI
>8c8a	e9 9f					.word	Assemble_clv                     ; $94 CLV
>8c8c	17 9f					.word	Assemble_cmp                     ; $95 CMP
>8c8e	60 9f					.word	Assemble_cpx                     ; $96 CPX
>8c90	5b 9f					.word	Assemble_cpy                     ; $97 CPY
>8c92	3d 9f					.word	Assemble_dec                     ; $98 DEC
>8c94	f5 9f					.word	Assemble_dex                     ; $99 DEX
>8c96	d1 9f					.word	Assemble_dey                     ; $9a DEY
>8c98	07 9f					.word	Assemble_eor                     ; $9b EOR
>8c9a	42 9f					.word	Assemble_inc                     ; $9c INC
>8c9c	05 a0					.word	Assemble_inx                     ; $9d INX
>8c9e	f1 9f					.word	Assemble_iny                     ; $9e INY
>8ca0	74 9f					.word	Assemble_jmp                     ; $9f JMP
>8ca2	6f 9f					.word	Assemble_jsr                     ; $a0 JSR
>8ca4	13 9f					.word	Assemble_lda                     ; $a1 LDA
>8ca6	38 9f					.word	Assemble_ldx                     ; $a2 LDX
>8ca8	56 9f					.word	Assemble_ldy                     ; $a3 LDY
>8caa	29 9f					.word	Assemble_lsr                     ; $a4 LSR
>8cac	09 a0					.word	Assemble_nop                     ; $a5 NOP
>8cae	ff 9e					.word	Assemble_ora                     ; $a6 ORA
>8cb0	b5 9f					.word	Assemble_pha                     ; $a7 PHA
>8cb2	a1 9f					.word	Assemble_php                     ; $a8 PHP
>8cb4	fd 9f					.word	Assemble_phx                     ; $a9 PHX
>8cb6	bd 9f					.word	Assemble_phy                     ; $aa PHY
>8cb8	c5 9f					.word	Assemble_pla                     ; $ab PLA
>8cba	a9 9f					.word	Assemble_plp                     ; $ac PLP
>8cbc	11 a0					.word	Assemble_plx                     ; $ad PLX
>8cbe	cd 9f					.word	Assemble_ply                     ; $ae PLY
>8cc0	24 9f					.word	Assemble_rol                     ; $af ROL
>8cc2	2e 9f					.word	Assemble_ror                     ; $b0 ROR
>8cc4	b1 9f					.word	Assemble_rti                     ; $b1 RTI
>8cc6	c1 9f					.word	Assemble_rts                     ; $b2 RTS
>8cc8	1b 9f					.word	Assemble_sbc                     ; $b3 SBC
>8cca	ad 9f					.word	Assemble_sec                     ; $b4 SEC
>8ccc	0d a0					.word	Assemble_sed                     ; $b5 SED
>8cce	c9 9f					.word	Assemble_sei                     ; $b6 SEI
>8cd0	0f 9f					.word	Assemble_sta                     ; $b7 STA
>8cd2	01 a0					.word	Assemble_stp                     ; $b8 STP
>8cd4	33 9f					.word	Assemble_stx                     ; $b9 STX
>8cd6	51 9f					.word	Assemble_sty                     ; $ba STY
>8cd8	47 9f					.word	Assemble_stz                     ; $bb STZ
>8cda	e5 9f					.word	Assemble_tax                     ; $bc TAX
>8cdc	e1 9f					.word	Assemble_tay                     ; $bd TAY
>8cde	6a 9f					.word	Assemble_trb                     ; $be TRB
>8ce0	65 9f					.word	Assemble_tsb                     ; $bf TSB
>8ce2	ed 9f					.word	Assemble_tsx                     ; $c0 TSX
>8ce4	d5 9f					.word	Assemble_txa                     ; $c1 TXA
>8ce6	dd 9f					.word	Assemble_txs                     ; $c2 TXS
>8ce8	d9 9f					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.8cea					StopCommand:
.8cea	a9 08		lda #$08		lda	#8
.8cec	4c ff 8d	jmp $8dff		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.8cef					ProcedureScan:
.8cef	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8cf1	85 30		sta $30				sta 	codePtr
.8cf3	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8cf5	85 31		sta $31				sta 	codePtr+1
.8cf7					_PSLoop:
.8cf7	b2 30		lda ($30)			lda 	(codePtr)
.8cf9	f0 42		beq $8d3d			beq 	_PSExit
.8cfb	a0 03		ldy #$03			ldy 	#3 							; is it PROC ?
.8cfd	b1 30		lda ($30),y			lda 	(codePtr),y
.8cff	c9 a2		cmp #$a2			cmp 	#KWD_PROC
.8d01	d0 2d		bne $8d30			bne 	_PSNext
.8d03	c8		iny				iny 								; get the address of the record to zTemp0 and
.8d04	b1 30		lda ($30),y			lda 	(codePtr),y
.8d06	29 c0		and #$c0			and 	#$C0
.8d08	c9 40		cmp #$40			cmp 	#$40
.8d0a	d0 32		bne $8d3e			bne 	_PSSyntax
.8d0c	b1 30		lda ($30),y			lda 	(codePtr),y
.8d0e	18		clc				clc
.8d0f	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8d11	85 37		sta $37				sta 	zTemp0+1
.8d13	c8		iny				iny 								; LSB
.8d14	b1 30		lda ($30),y			lda 	(codePtr),y
.8d16	85 36		sta $36				sta 	zTemp0
.8d18	c8		iny				iny 								; character after variable call.
.8d19	98		tya				tya 								; save Y offset at +7
.8d1a	a0 07		ldy #$07			ldy 	#7
.8d1c	91 36		sta ($36),y			sta 	(zTemp0),y
.8d1e	a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.8d20	a0 02		ldy #$02			ldy 	#2
.8d22	91 36		sta ($36),y			sta 	(zTemp0),y
.8d24	a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr in
.8d26					_PSCopy:
.8d26	b5 30		lda $30,x			lda 	safePtr,x
.8d28	c8		iny				iny
.8d29	91 36		sta ($36),y			sta 	(zTemp0),y
.8d2b	e8		inx				inx
.8d2c	e0 04		cpx #$04			cpx 	#4
.8d2e	d0 f6		bne $8d26			bne 	_PSCopy
.8d30					_PSNext:
.8d30	18		clc				clc
.8d31	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d33	65 30		adc $30				adc 	codePtr
.8d35	85 30		sta $30				sta 	codePtr
.8d37	90 02		bcc $8d3b			bcc 	_CREExit
.8d39	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d3b					_CREExit:
.8d3b	80 ba		bra $8cf7			bra 	_PSLoop
.8d3d					_PSExit:
.8d3d	60		rts				rts
.8d3e					_PSSyntax:
.8d3e	4c 4c a0	jmp $a04c			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.8d41					ScanForward:
.8d41	64 38		stz $38				stz 	zTemp1 						; this is the structure count - goes up with WHILE/FOR
.8d43	86 37		stx $37				stx 	zTemp0+1
.8d45	85 36		sta $36				sta 	zTemp0 						; save XA as the two possible matches.
.8d47					_ScanLoop:
.8d47	b1 30		lda ($30),y			lda 	(codePtr),y
.8d49	c8		iny				iny
.8d4a	a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.8d4c	d0 0e		bne $8d5c			bne 	_ScanGoNext
.8d4e	c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.8d50	f0 04		beq $8d56			beq 	_ScanMatch
.8d52	c5 37		cmp $37				cmp 	zTemp0+1
.8d54	d0 06		bne $8d5c			bne 	_ScanGoNext
.8d56					_ScanMatch:
.8d56	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.8d58	d0 01		bne $8d5b			bne 	_ScanNotEndEOL
.8d5a	88		dey				dey
.8d5b					_ScanNotEndEOL:
.8d5b	60		rts				rts
.8d5c					_ScanGoNext:
.8d5c	20 61 8d	jsr $8d61			jsr  	ScanForwardOne
.8d5f	80 e6		bra $8d47			bra 	_ScanLoop
.8d61					ScanForwardOne:
.8d61	c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, loop back
.8d63	90 3e		bcc $8da3			bcc 	_SFWExit
.8d65	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra.
.8d67	90 18		bcc $8d81			bcc 	_ScanSkipOne
.8d69	c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips
.8d6b	b0 2f		bcs $8d9c			bcs 	_ScanSkipData
.8d6d	c9 a0		cmp #$a0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.8d6f	90 32		bcc $8da3			bcc 	_SFWExit 					; if not, ordinary keywords.
.8d71	c9 ab		cmp #$ab			cmp 	#KWC_LAST_STRUCTURE+1
.8d73	b0 2e		bcs $8da3			bcs 	_SFWExit
.8d75	c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.8d77	c9 a5		cmp #$a5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.8d79	b0 28		bcs $8da3			bcs 	_SFWExit
.8d7b	e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.8d7d	e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.8d7f	80 22		bra $8da3			bra 	_SFWExit
.8d81					_ScanSkipOne:
.8d81	c8		iny				iny 								; consume the extra one.
.8d82	c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.8d84	d0 1d		bne $8da3			bne 	_SFWExit
.8d86	18		clc				clc
.8d87	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8d89	65 30		adc $30				adc 	codePtr
.8d8b	85 30		sta $30				sta 	codePtr
.8d8d	90 02		bcc $8d91			bcc 	_CREExit
.8d8f	e6 31		inc $31				inc 	codePtr+1 					; carry
.8d91					_CREExit:
.8d91	a0 03		ldy #$03			ldy 	#3 							; scan start position.
.8d93	b2 30		lda ($30)			lda 	(codePtr)
.8d95	d0 0c		bne $8da3			bne 	_SFWExit 					; if not zero, more to scan
.8d97	a9 13		lda #$13		lda	#19
.8d99	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.8d9c					_ScanSkipData:
.8d9c	88		dey				dey 								; point at data token
.8d9d	c8		iny				iny 								; point to offset
.8d9e	98		tya				tya 								; A = offset position
.8d9f	38		sec				sec 								; add size +1 hence SEC
.8da0	71 30		adc ($30),y			adc 	(codePtr),y
.8da2	a8		tay				tay 								; make current position.
.8da3					_SFWExit:
.8da3	60		rts				rts
.8da4					ScanGetCurrentLineStep:
.8da4	64 38		stz $38				stz 	zTemp1
.8da6	a0 03		ldy #$03			ldy 	#3
.8da8					_SGCLSLoop:
.8da8	b1 30		lda ($30),y			lda 	(codePtr),y
.8daa	c8		iny				iny
.8dab	c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.8dad	f0 05		beq $8db4			beq 	_SGCLSExit
.8daf	20 61 8d	jsr $8d61			jsr 	ScanForwardOne
.8db2	80 f4		bra $8da8			bra 	_SGCLSLoop
.8db4					_SGCLSExit:
.8db4	a5 38		lda $38				lda 	zTemp1
.8db6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.8db7					Command_WHILE:
.8db7	5a		phy				phy 								; save position of the test
.8db8	a2 00		ldx #$00			ldx 	#0
.8dba	20 eb 9d	jsr $9deb			jsr 	EvaluateNumber 				; work out the number
.8dbd	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; check if zero
.8dc0	f0 0e		beq $8dd0			beq 	_WHExitLoop 				; if so exit the loop
.8dc2	98		tya				tya 								; position *after* test.
.8dc3	7a		ply				ply 								; restore position before test, at WHILE
.8dc4	88		dey				dey
.8dc5	48		pha				pha 								; push after test on the stack
.8dc6	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.8dc8	20 4c a7	jsr $a74c			jsr 	StackOpen
.8dcb	20 90 a7	jsr $a790			jsr 	STKSaveCodePosition 		; save loop position - where the test value is.
.8dce	7a		ply				ply 								; restore the position *after* the test
.8dcf	60		rts				rts
.8dd0					_WHExitLoop:
.8dd0	68		pla				pla 								; throw post loop position
.8dd1	a9 aa		lda #$aa			lda 	#KWD_WEND 					; scan forward past WEND
.8dd3	aa		tax				tax
.8dd4	20 41 8d	jsr $8d41			jsr 	ScanForward
.8dd7	60		rts				rts
.8dd8					Command_WEND:
.8dd8	a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS
.8dda	a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error
.8ddc	20 78 a7	jsr $a778			jsr 	StackCheckFrame
.8ddf	20 a1 a7	jsr $a7a1			jsr 	STKLoadCodePosition 		; loop back
.8de2	20 6a a7	jsr $a76a			jsr 	StackClose		 			; erase the frame
.8de5	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.8de6					CheckRightBracket:
.8de6	b1 30		lda ($30),y			lda 	(codePtr),y
.8de8	c8		iny				iny
.8de9	c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.8deb	d0 0f		bne $8dfc			bne 	CNAFail
.8ded	60		rts				rts
.8dee					CheckComma:
.8dee	b1 30		lda ($30),y			lda 	(codePtr),y
.8df0	c8		iny				iny
.8df1	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.8df3	d0 07		bne $8dfc			bne 	CNAFail
.8df5	60		rts				rts
.8df6					CheckNextA:
.8df6	d1 30		cmp ($30),y			cmp 	(codePtr),y
.8df8	d0 02		bne $8dfc			bne 	CNAFail
.8dfa	c8		iny				iny 								; skip character
.8dfb	60		rts				rts 								; and exit
.8dfc					CNAFail:
.8dfc	4c 4c a0	jmp $a04c			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.8dff					ErrorHandler:
.8dff	a8		tay				tay 								; find the error text
.8e00	f0 49		beq $8e4b			beq 	_EHEnd
.8e02	a2 00		ldx #$00			ldx 	#0
.8e04	a9 65		lda #$65			lda 	#((ErrorText) & $FF)
.8e06	85 36		sta $36				sta 	0+zTemp0
.8e08	a9 a0		lda #$a0			lda 	#((ErrorText) >> 8)
.8e0a	85 37		sta $37				sta 	1+zTemp0
.8e0c					_EHFind:
.8e0c	88		dey				dey 								; found the error text ?
.8e0d	f0 0e		beq $8e1d			beq 	_EHFound
.8e0f					_EHFindZero:
.8e0f	b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.8e11	e6 36		inc $36				inc 	zTemp0
.8e13	d0 02		bne $8e17			bne 	_EHFNoCarry
.8e15	e6 37		inc $37				inc 	zTemp0+1
.8e17					_EHFNoCarry:
.8e17	c9 00		cmp #$00			cmp 	#0
.8e19	d0 f4		bne $8e0f			bne 	_EHFindZero
.8e1b	80 ef		bra $8e0c			bra 	_EHFind
.8e1d					_EHFound:
.8e1d	a5 36		lda $36				lda 	zTemp0 						; print message
.8e1f	a6 37		ldx $37				ldx 	zTemp0+1
.8e21	20 58 8e	jsr $8e58			jsr 	PrintStringXA
.8e24	a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print i
.8e26	b1 30		lda ($30),y			lda 	(codePtr),y
.8e28	d0 05		bne $8e2f			bne 	_EHAtMsg
.8e2a	c8		iny				iny
.8e2b	b1 30		lda ($30),y			lda 	(codePtr),y
.8e2d	f0 17		beq $8e46			beq 	_EHCREnd
.8e2f					_EHAtMsg:
.8e2f	a2 8e		ldx #$8e			ldx 	#_AtMsg >> 8 				; print " at "
.8e31	a9 4e		lda #$4e			lda 	#_AtMsg & $FF
.8e33	20 58 8e	jsr $8e58			jsr 	PrintStringXA
.8e36	a0 01		ldy #$01			ldy 	#1 							; line number into XA
.8e38	b1 30		lda ($30),y			lda 	(codePtr),y
.8e3a	48		pha				pha
.8e3b	c8		iny				iny
.8e3c	b1 30		lda ($30),y			lda 	(codePtr),y
.8e3e	aa		tax				tax
.8e3f	68		pla				pla
.8e40	20 11 93	jsr $9311			jsr 	LCLConvertInt16 				; convert XA to string
.8e43	20 58 8e	jsr $8e58			jsr 	PrintStringXA 				; and print it.
.8e46					_EHCREnd:
.8e46	a9 0d		lda #$0d			lda 	#13 						; new line
.8e48	20 8c a8	jsr $a88c			jsr 	EXTPrintCharacter
.8e4b					_EHEnd:
.8e4b	4c 5f 83	jmp $835f			jmp 	WarmStart
>8e4e	20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>8e56	20 00
.8e58					PrintStringXA:
.8e58	5a		phy				phy
.8e59	86 37		stx $37				stx 	zTemp0+1
.8e5b	85 36		sta $36				sta 	zTemp0
.8e5d	a0 00		ldy #$00			ldy 	#0
.8e5f					_PSXALoop:
.8e5f	b1 36		lda ($36),y			lda 	(zTemp0),y
.8e61	f0 06		beq $8e69			beq 	_PSXAExit
.8e63	20 8c a8	jsr $a88c			jsr 	EXTPrintCharacter
.8e66	c8		iny				iny
.8e67	80 f6		bra $8e5f			bra 	_PSXALoop
.8e69					_PSXAExit:
.8e69	7a		ply				ply
.8e6a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.8e6b					UnaryTrue:
.8e6b	fa		plx				plx
.8e6c					ReturnTrue:
.8e6c	a9 01		lda #$01			lda 	#1  						; set to 1
.8e6e	20 c4 9e	jsr $9ec4			jsr 	NSMSetByte
.8e71	a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.8e73	9d 00 04	sta $0400,x			sta 	NSStatus,x
.8e76	60		rts				rts
.8e77					UnaryFalse:
.8e77	fa		plx				plx
.8e78					ReturnFalse:
.8e78	4c c2 9e	jmp $9ec2			jmp 	NSMSetZero 					; set it all to zero
.8e7b					BinaryCompareEqual:
.8e7b	fa		plx				plx
.8e7c	20 b7 8e	jsr $8eb7			jsr 	CompareBaseCode
.8e7f	c9 00		cmp #$00			cmp 	#0
.8e81	f0 e9		beq $8e6c			beq 	ReturnTrue
.8e83	80 f3		bra $8e78			bra 	ReturnFalse
.8e85					BinaryCompareLess:
.8e85	fa		plx				plx
.8e86	20 b7 8e	jsr $8eb7			jsr 	CompareBaseCode
.8e89	c9 ff		cmp #$ff			cmp 	#$FF
.8e8b	f0 df		beq $8e6c			beq 	ReturnTrue
.8e8d	80 e9		bra $8e78			bra 	ReturnFalse
.8e8f					BinaryCompareGreater:
.8e8f	fa		plx				plx
.8e90	20 b7 8e	jsr $8eb7			jsr 	CompareBaseCode
.8e93	c9 01		cmp #$01			cmp 	#1
.8e95	f0 d5		beq $8e6c			beq 	ReturnTrue
.8e97	80 df		bra $8e78			bra 	ReturnFalse
.8e99					BinaryCompareNotEqual:
.8e99	fa		plx				plx
.8e9a	20 b7 8e	jsr $8eb7			jsr 	CompareBaseCode
.8e9d	c9 00		cmp #$00			cmp 	#0
.8e9f	d0 cb		bne $8e6c			bne 	ReturnTrue
.8ea1	80 d5		bra $8e78			bra 	ReturnFalse
.8ea3					BinaryCompareLessEqual:
.8ea3	fa		plx				plx
.8ea4	20 b7 8e	jsr $8eb7			jsr 	CompareBaseCode
.8ea7	c9 01		cmp #$01			cmp 	#1
.8ea9	d0 c1		bne $8e6c			bne 	ReturnTrue
.8eab	80 cb		bra $8e78			bra 	ReturnFalse
.8ead					BinaryCompareGreaterEqual:
.8ead	fa		plx				plx
.8eae	20 b7 8e	jsr $8eb7			jsr 	CompareBaseCode
.8eb1	c9 ff		cmp #$ff			cmp 	#$FF
.8eb3	d0 b7		bne $8e6c			bne 	ReturnTrue
.8eb5	80 c1		bra $8e78			bra 	ReturnFalse
.8eb7					CompareBaseCode:
.8eb7	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; make both values if references.
.8eba	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if either is a string.
.8ebd	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ec0	29 10		and #$10			and 	#NSTString
.8ec2	d0 40		bne $8f04			bne 	_CBCString
.8ec4	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check both are integers
.8ec7	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8eca	d0 3b		bne $8f07			bne 	_CBCFloat
.8ecc	bd 00 04	lda $0400,x			lda 	NSStatus,x
.8ecf	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8ed2	29 08		and #$08			and 	#NSTFloat
.8ed4	d0 31		bne $8f07			bne 	_CBCFloat
.8ed6	20 0a 8f	jsr $8f0a			jsr 	CompareFixMinusZero
.8ed9	e8		inx				inx
.8eda	20 0a 8f	jsr $8f0a			jsr 	CompareFixMinusZero
.8edd	ca		dex				dex
.8ede	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs different ?
.8ee1	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.8ee4	10 0b		bpl $8ef1			bpl 	_CDCSameSign
.8ee6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if first one is -ve
.8ee9	30 16		bmi $8f01			bmi 	_CBCLess 					; return $FF
.8eeb					_CBCGreater:
.8eeb	a9 01		lda #$01			lda 	#1
.8eed	60		rts				rts
.8eee					_CBCEqual:
.8eee	a9 00		lda #$00			lda 	#0
.8ef0	60		rts				rts
.8ef1					_CDCSameSign:
.8ef1	20 5d 91	jsr $915d			jsr 	SubTopTwoStack 				; unsigned subtract
.8ef4	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; or the mantissa together
.8ef7	f0 f5		beq $8eee			beq 	_CBCEqual 					; -0 == 0
.8ef9	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.8efc	5d 01 04	eor $0401,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.8eff	10 ea		bpl $8eeb			bpl 	_CBCGreater
.8f01					_CBCLess:
.8f01	a9 ff		lda #$ff			lda 	#$FF
.8f03	60		rts				rts
.8f04					_CBCString:
.8f04	4c b3 90	jmp $90b3			jmp 	CompareStrings
.8f07					_CBCFloat:
.8f07	4c 94 94	jmp $9494			jmp 	CompareFloat
.8f0a					CompareFixMinusZero:
.8f0a	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero
.8f0d	d0 03		bne $8f12			bne 	_CFXMZNotZero
.8f0f	9e 00 04	stz $0400,x			stz 	NSStatus,x
.8f12					_CFXMZNotZero:
.8f12	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.8f13					StringConcat:
.8f13	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both strings
.8f16	3d 01 04	and $0401,x			and 	NSStatus+1,x
.8f19	29 18		and #$18			and 	#NSBTypeMask
.8f1b	c9 10		cmp #$10			cmp 	#NSTString
.8f1d	d0 4e		bne $8f6d			bne		_SCType
.8f1f	64 38		stz $38				stz 	zTemp1 						; counting total length
.8f21	e8		inx				inx
.8f22	20 40 8f	jsr $8f40			jsr 	_SCSetupZ0 					; setup for second
.8f25	20 4b 8f	jsr $8f4b			jsr 	_SCLengthZ0 				; length for second
.8f28	ca		dex				dex
.8f29	20 40 8f	jsr $8f40			jsr 	_SCSetupZ0 					; setup for first
.8f2c	20 4b 8f	jsr $8f4b			jsr 	_SCLengthZ0 				; length for first
.8f2f	a5 38		lda $38				lda 	zTemp1 						; allocate memory
.8f31	20 3f a8	jsr $a83f			jsr 	StringTempAllocate
.8f34	20 5e 8f	jsr $8f5e			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.8f37	e8		inx				inx
.8f38	20 40 8f	jsr $8f40			jsr 	_SCSetupZ0 					; copy second out
.8f3b	20 5e 8f	jsr $8f5e			jsr 	_SCCopy
.8f3e	ca		dex				dex
.8f3f	60		rts				rts
.8f40					_SCSetupZ0:
.8f40	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.8f43	85 36		sta $36				sta 	zTemp0
.8f45	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.8f48	85 37		sta $37				sta 	zTemp0+1
.8f4a	60		rts				rts
.8f4b					_SCLengthZ0:
.8f4b	5a		phy				phy
.8f4c	a0 00		ldy #$00			ldy 	#0
.8f4e					_SCLenLoop:
.8f4e	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f50	f0 0a		beq $8f5c			beq 	_SCLExit
.8f52	c8		iny				iny
.8f53	e6 38		inc $38				inc 	zTemp1
.8f55	10 f7		bpl $8f4e			bpl		_SCLenLoop
.8f57	a9 09		lda #$09		lda	#9
.8f59	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.8f5c					_SCLExit:
.8f5c	7a		ply				ply
.8f5d	60		rts				rts
.8f5e					_SCCopy:
.8f5e	5a		phy				phy
.8f5f	a0 00		ldy #$00			ldy 	#0
.8f61					_SCCopyLoop:
.8f61	b1 36		lda ($36),y			lda 	(zTemp0),y
.8f63	f0 06		beq $8f6b			beq 	_SCCExit
.8f65	20 7d a8	jsr $a87d			jsr 	StringTempWrite
.8f68	c8		iny				iny
.8f69	80 f6		bra $8f61			bra 	_SCCopyLoop
.8f6b					_SCCExit:
.8f6b	7a		ply				ply
.8f6c	60		rts				rts
.8f6d					_SCType:
.8f6d	4c 56 a0	jmp $a056			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.8f70					IntegerDivide:
.8f70	fa		plx				plx
.8f71	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8f74	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8f77	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8f78	0a		asl a				asl 	a
.8f79	10 05		bpl $8f80			bpl 	_NotRef
.8f7b	48		pha				pha
.8f7c	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8f7f	68		pla				pla
.8f80					_NotRef:
.8f80	0a		asl a				asl 	a
.8f81	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8f83	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8f86	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8f89	f0 03		beq $8f8e			beq 	_IntegerCode 				; if clear, then we have two integers
.8f8b	4c 56 a0	jmp $a056			jmp 	TypeError 					; anything else, type mismatch.
.8f8e					_IntegerCode:
.8f8e	20 b0 8f	jsr $8fb0			jsr 	CheckDivideZero 			; do div zero check
.8f91	20 e8 8f	jsr $8fe8			jsr 	Int32Divide 				; do the division
.8f94	20 a5 90	jsr $90a5			jsr 	CalculateSign 				; calculate result sign
.8f97					NSMCopyPlusTwoToZero:
.8f97	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.8f9a	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.8f9d	bd 12 04	lda $0412,x			lda 	NSMantissa1+2,x
.8fa0	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.8fa3	bd 1a 04	lda $041a,x			lda 	NSMantissa2+2,x
.8fa6	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.8fa9	bd 22 04	lda $0422,x			lda 	NSMantissa3+2,x
.8fac	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.8faf	60		rts				rts
.8fb0					CheckDivideZero:
.8fb0	e8		inx				inx
.8fb1	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero
.8fb4	f0 02		beq $8fb8			beq 	_CDVError
.8fb6	ca		dex				dex
.8fb7	60		rts				rts
.8fb8					_CDVError:
.8fb8	a9 03		lda #$03		lda	#3
.8fba	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.8fbd					IntegerModulus:
.8fbd	fa		plx				plx
.8fbe	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.8fc1	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.8fc4	0a		asl a				asl 	a 							; shift reference bit into sign bit
.8fc5	0a		asl a				asl 	a
.8fc6	10 05		bpl $8fcd			bpl 	_NotRef
.8fc8	48		pha				pha
.8fc9	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.8fcc	68		pla				pla
.8fcd					_NotRef:
.8fcd	0a		asl a				asl 	a
.8fce	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.8fd0	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.8fd3	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.8fd6	f0 03		beq $8fdb			beq 	_IntegerCode 				; if clear, then we have two integers
.8fd8	4c 56 a0	jmp $a056			jmp 	TypeError 					; anything else, type mismatch.
.8fdb					_IntegerCode:
.8fdb					IntegerModulusNoCheck:
.8fdb	20 b0 8f	jsr $8fb0			jsr 	CheckDivideZero 			; do div zero check
.8fde	20 e8 8f	jsr $8fe8			jsr 	Int32Divide 				; do the division
.8fe1	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.8fe4	5e 00 04	lsr $0400,x			lsr 	NSStatus,x
.8fe7	60		rts				rts
.8fe8					Int32Divide:
.8fe8	48		pha				pha 								; save AXY
.8fe9	5a		phy				phy
.8fea	20 99 9e	jsr $9e99			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.8fed	20 be 9e	jsr $9ebe			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.8ff0	a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.8ff2					_I32DivideLoop:
.8ff2	e8		inx				inx
.8ff3	e8		inx				inx
.8ff4	20 d7 9e	jsr $9ed7			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.8ff7	ca		dex				dex
.8ff8	ca		dex				dex
.8ff9	20 d8 9e	jsr $9ed8			jsr 	NSMRotateLeft
.8ffc	20 28 90	jsr $9028			jsr 	DivideCheckSubtract 		; check if subtract possible
.8fff	90 03		bcc $9004			bcc 	_I32DivideNoCarryIn
.9001	fe 0a 04	inc $040a,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9004					_I32DivideNoCarryIn:
.9004	88		dey				dey 								; loop round till division completed.
.9005	d0 eb		bne $8ff2			bne 	_I32DivideLoop
.9007	7a		ply				ply 								; restore AXY and exit
.9008	68		pla				pla
.9009	60		rts				rts
.900a					Int32ShiftDivide:
.900a	48		pha				pha 								; save AY
.900b	5a		phy				phy
.900c	e8		inx				inx 								; clear S[X+2]
.900d	e8		inx				inx
.900e	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero
.9011	ca		dex				dex
.9012	ca		dex				dex
.9013	a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9015					_I32SDLoop:
.9015	20 28 90	jsr $9028			jsr 	DivideCheckSubtract 		; check if subtract possible
.9018	e8		inx				inx
.9019	e8		inx				inx
.901a	20 d8 9e	jsr $9ed8			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.901d	ca		dex				dex
.901e	ca		dex				dex
.901f	20 d8 9e	jsr $9ed8			jsr 	NSMRotateLeft
.9022	88		dey				dey 	 							; do 31 times
.9023	d0 f0		bne $9015			bne 	_I32SDLoop
.9025	7a		ply				ply 								; restore AY and exit
.9026	68		pla				pla
.9027	60		rts				rts
.9028					DivideCheckSubtract:
.9028	20 5d 91	jsr $915d			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.902b	b0 04		bcs $9031			bcs 	_DCSExit 					; if carry set, then could do, exit
.902d	20 37 91	jsr $9137			jsr 	AddTopTwoStack 				; add it back in
.9030	18		clc				clc 								; and return False
.9031					_DCSExit:
.9031	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9032					MulInteger:
.9032	fa		plx				plx
.9033	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9036	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9039	0a		asl a				asl 	a 							; shift reference bit into sign bit
.903a	0a		asl a				asl 	a
.903b	10 05		bpl $9042			bpl 	_NotRef
.903d	48		pha				pha
.903e	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9041	68		pla				pla
.9042					_NotRef:
.9042	0a		asl a				asl 	a 							; put MSB of type into A:7
.9043	30 0b		bmi $9050			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9045	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9048	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.904b	f0 06		beq $9053			beq 	_IntegerCode 				; if clear, then we have two integers
.904d	4c 6b 95	jmp $956b			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.9050					_StringData:
.9050	4c 60 a0	jmp $a060			jmp 	NotDoneError							; at least one string - don't know both are strings.
.9053					_IntegerCode:
.9053	20 60 90	jsr $9060			jsr 	MultiplyShort
.9056	c9 00		cmp #$00			cmp 	#0
.9058	f0 05		beq $905f			beq 	_MIExit
.905a	a9 04		lda #$04		lda	#4
.905c	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.905f					_MIExit:
.905f	60		rts				rts
.9060					MultiplyShort:
.9060	5a		phy				phy 								; save Y
.9061	20 99 9e	jsr $9e99			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.9064	20 be 9e	jsr $9ebe			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9067	a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9069					_I32MLoop:
.9069	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.906c	1d 12 04	ora $0412,x			ora 	NSMantissa1+2,x
.906f	1d 1a 04	ora $041a,x			ora 	NSMantissa2+2,x
.9072	1d 22 04	ora $0422,x			ora 	NSMantissa3+2,x
.9075	f0 28		beq $909f			beq 	_I32MExit 					; exit if zero
.9077	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.907a	29 01		and #$01			and 	#1
.907c	f0 0e		beq $908c			beq 	_I32MNoAdd
.907e	20 37 91	jsr $9137			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9081	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9084	10 06		bpl $908c			bpl 	_I32MNoAdd
.9086					_I32ShiftRight:
.9086	20 e5 9e	jsr $9ee5			jsr 	NSMShiftRight 				; shift S[X] right
.9089	c8		iny				iny 								; increment shift count
.908a	80 0a		bra $9096			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.908c					_I32MNoAdd:
.908c	3c 21 04	bit $0421,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.908f	70 f5		bvs $9086			bvs 	_I32ShiftRight 				; instead.
.9091	e8		inx				inx
.9092	20 d7 9e	jsr $9ed7			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9095	ca		dex				dex
.9096					_I32MShiftUpper:
.9096	e8		inx				inx 								; shift S[X+2] right
.9097	e8		inx				inx
.9098	20 e5 9e	jsr $9ee5			jsr 	NSMShiftRight
.909b	ca		dex				dex
.909c	ca		dex				dex
.909d	80 ca		bra $9069			bra 	_I32MLoop 					; try again.
.909f					_I32MExit:
.909f	20 a5 90	jsr $90a5			jsr 	CalculateSign
.90a2	98		tya				tya 								; shift in A
.90a3	7a		ply				ply 								; restore Y and exit
.90a4	60		rts				rts
.90a5					CalculateSign:
.90a5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.90a8	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; shift result left
.90ab	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.90ae	0a		asl a				asl 	a 							; shift bit 7 into carry
.90af	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; shift right into status byte.
.90b2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.90b3					CompareStrings:
.90b3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check both are strings
.90b6	3d 01 04	and $0401,x			and 	NSStatus+1,x
.90b9	29 10		and #$10			and 	#NSBIsString
.90bb	f0 2c		beq $90e9			beq 	_CSTypeError
.90bd	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.90c0	85 36		sta $36				sta 	zTemp0
.90c2	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.90c5	85 37		sta $37				sta 	zTemp0+1
.90c7	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.90ca	85 38		sta $38				sta 	zTemp1
.90cc	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.90cf	85 39		sta $39				sta 	zTemp1+1
.90d1	5a		phy				phy 								; save Y so we can access strings
.90d2	a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.90d4					_CSLoop:
.90d4	c8		iny				iny
.90d5	b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.90d7	d1 38		cmp ($38),y			cmp 	(zTemp1),y
.90d9	d0 06		bne $90e1			bne 	_CSDifferent
.90db	c9 00		cmp #$00			cmp 	#0 							; reached end ?
.90dd	d0 f5		bne $90d4			bne 	_CSLoop 					; still comparing
.90df					_CSExit:
.90df	7a		ply				ply 								; reached end, return zero in A from EOS
.90e0	60		rts				rts
.90e1					_CSDifferent:
.90e1	a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.90e3	90 fa		bcc $90df			bcc		_CSExit
.90e5	a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.90e7	80 f6		bra $90df			bra 	_CSExit
.90e9					_CSTypeError:
.90e9	4c 56 a0	jmp $a056			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.90ec					ShiftLeft:
.90ec	38		sec				sec
.90ed	80 01		bra $90f0			bra 	ShiftMain
.90ef					ShiftRight:
.90ef	18		clc				clc
.90f0					ShiftMain:
.90f0	fa		plx				plx 								; restore X
.90f1	08		php				php 								; save direction
.90f2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.90f5	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.90f8	0a		asl a				asl 	a 							; shift reference bit into sign bit
.90f9	0a		asl a				asl 	a
.90fa	10 05		bpl $9101			bpl 	_NotRef
.90fc	48		pha				pha
.90fd	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9100	68		pla				pla
.9101					_NotRef:
.9101	0a		asl a				asl 	a
.9102	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9104	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9107	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.910a	f0 03		beq $910f			beq 	_IntegerCode 				; if clear, then we have two integers
.910c	4c 56 a0	jmp $a056			jmp 	TypeError 					; anything else, type mismatch.
.910f					_IntegerCode:
.910f	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; check number < 32
.9112	29 e0		and #$e0			and 	#$E0
.9114	1d 11 04	ora $0411,x			ora 	NSMantissa1+1,x
.9117	1d 19 04	ora $0419,x			ora 	NSMantissa2+1,x
.911a	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.911d	d0 13		bne $9132			bne 	_SMExit0 					; if >= 32 it will always return zero.
.911f					_SMLoop:
.911f	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9122	30 11		bmi $9135			bmi 	_SMExit 					; exit if done.
.9124	28		plp				plp 								; restore direcition setting
.9125	08		php				php
.9126	90 05		bcc $912d			bcc 	_SMRight
.9128	20 d7 9e	jsr $9ed7			jsr 	NSMShiftLeft 				; shift left if CS
.912b	80 f2		bra $911f			bra 	_SMLoop
.912d					_SMRight:
.912d	20 e5 9e	jsr $9ee5			jsr 	NSMShiftRight 				; shift right if CC
.9130	80 ed		bra $911f			bra 	_SMLoop
.9132					_SMExit0:
.9132	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero 					; return zero.
.9135					_SMExit:
.9135	28		plp				plp 								; throw direction
.9136	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9137					AddTopTwoStack:
.9137	18		clc				clc
.9138	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.913b	7d 09 04	adc $0409,x			adc 		NSMantissa0+1,x
.913e	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9141	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9144	7d 11 04	adc $0411,x			adc 		NSMantissa1+1,x
.9147	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.914a	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.914d	7d 19 04	adc $0419,x			adc 		NSMantissa2+1,x
.9150	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9153	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9156	7d 21 04	adc $0421,x			adc 		NSMantissa3+1,x
.9159	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.915c	60		rts				rts
.915d					SubTopTwoStack:
.915d	38		sec				sec
.915e	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9161	fd 09 04	sbc $0409,x			sbc 		NSMantissa0+1,x
.9164	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9167	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.916a	fd 11 04	sbc $0411,x			sbc 		NSMantissa1+1,x
.916d	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9170	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9173	fd 19 04	sbc $0419,x			sbc 		NSMantissa2+1,x
.9176	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9179	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.917c	fd 21 04	sbc $0421,x			sbc 		NSMantissa3+1,x
.917f	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9182	60		rts				rts
.9183					AddInteger:
.9183	fa		plx				plx
.9184	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9187	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.918a	0a		asl a				asl 	a 							; shift reference bit into sign bit
.918b	0a		asl a				asl 	a
.918c	10 05		bpl $9193			bpl 	_NotRef
.918e	48		pha				pha
.918f	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9192	68		pla				pla
.9193					_NotRef:
.9193	0a		asl a				asl 	a 							; put MSB of type into A:7
.9194	30 0b		bmi $91a1			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9196	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9199	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.919c	f0 06		beq $91a4			beq 	_IntegerCode 				; if clear, then we have two integers
.919e	4c eb 93	jmp $93eb			jmp 	FloatingPointAdd 							; otherwise at least one float.
.91a1					_StringData:
.91a1	4c 13 8f	jmp $8f13			jmp 	StringConcat							; at least one string - don't know both are strings.
.91a4					_IntegerCode:
.91a4					AddCode:
.91a4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.91a7	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.91aa	10 8b		bpl $9137			bpl 	AddTopTwoStack
.91ac	20 5d 91	jsr $915d			jsr 	SubTopTwoStack 				; do a physical subtraction
.91af	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; result is +ve, okay
.91b2	10 09		bpl $91bd			bpl 	_AddExit
.91b4	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.91b7	9d 00 04	sta $0400,x			sta 	NSStatus,x
.91ba	20 77 9e	jsr $9e77			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.91bd					_AddExit:
.91bd	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; check for -0
.91c0	d0 03		bne $91c5			bne 	_AddNonZero
.91c2	9e 00 04	stz $0400,x			stz 	NSStatus,x
.91c5					_AddNonZero:
.91c5	60		rts				rts
.91c6					SubInteger:
.91c6	fa		plx				plx
.91c7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91ca	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91cd	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91ce	0a		asl a				asl 	a
.91cf	10 05		bpl $91d6			bpl 	_NotRef
.91d1	48		pha				pha
.91d2	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.91d5	68		pla				pla
.91d6					_NotRef:
.91d6	0a		asl a				asl 	a 							; put MSB of type into A:7
.91d7	30 0b		bmi $91e4			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.91d9	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.91dc	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.91df	f0 06		beq $91e7			beq 	_IntegerCode 				; if clear, then we have two integers
.91e1	4c f0 93	jmp $93f0			jmp 	FloatingPointSub 							; otherwise at least one float.
.91e4					_StringData:
.91e4	4c 60 a0	jmp $a060			jmp 	NotDoneError							; at least one string - don't know both are strings.
.91e7					_IntegerCode:
.91e7	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate the second value.
.91ea	49 80		eor #$80			eor 	#$80
.91ec	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.91ef	80 b3		bra $91a4			bra 	AddCode 					; and do the same code as add.
.91f1					AndInteger:
.91f1	fa		plx				plx
.91f2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.91f5	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.91f8	0a		asl a				asl 	a 							; shift reference bit into sign bit
.91f9	0a		asl a				asl 	a
.91fa	10 05		bpl $9201			bpl 	_NotRef
.91fc	48		pha				pha
.91fd	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9200	68		pla				pla
.9201					_NotRef:
.9201	0a		asl a				asl 	a
.9202	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9204	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9207	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.920a	f0 03		beq $920f			beq 	_IntegerCode 				; if clear, then we have two integers
.920c	4c 56 a0	jmp $a056			jmp 	TypeError 					; anything else, type mismatch.
.920f					_IntegerCode:
.920f	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9212	3d 09 04	and $0409,x			and 		NSMantissa0+1,x
.9215	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9218	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.921b	3d 11 04	and $0411,x			and 		NSMantissa1+1,x
.921e	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9221	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.9224	3d 19 04	and $0419,x			and 		NSMantissa2+1,x
.9227	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.922a	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.922d	3d 21 04	and $0421,x			and 		NSMantissa3+1,x
.9230	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9233	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.9236	60		rts				rts
.9237					OraInteger:
.9237	fa		plx				plx
.9238	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.923b	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.923e	0a		asl a				asl 	a 							; shift reference bit into sign bit
.923f	0a		asl a				asl 	a
.9240	10 05		bpl $9247			bpl 	_NotRef
.9242	48		pha				pha
.9243	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9246	68		pla				pla
.9247					_NotRef:
.9247	0a		asl a				asl 	a
.9248	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.924a	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.924d	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9250	f0 03		beq $9255			beq 	_IntegerCode 				; if clear, then we have two integers
.9252	4c 56 a0	jmp $a056			jmp 	TypeError 					; anything else, type mismatch.
.9255					_IntegerCode:
.9255	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.9258	1d 09 04	ora $0409,x			ora 		NSMantissa0+1,x
.925b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.925e	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.9261	1d 11 04	ora $0411,x			ora 		NSMantissa1+1,x
.9264	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9267	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.926a	1d 19 04	ora $0419,x			ora 		NSMantissa2+1,x
.926d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9270	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.9273	1d 21 04	ora $0421,x			ora 		NSMantissa3+1,x
.9276	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9279	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.927c	60		rts				rts
.927d					EorInteger:
.927d	fa		plx				plx
.927e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.9281	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.9284	0a		asl a				asl 	a 							; shift reference bit into sign bit
.9285	0a		asl a				asl 	a
.9286	10 05		bpl $928d			bpl 	_NotRef
.9288	48		pha				pha
.9289	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.928c	68		pla				pla
.928d					_NotRef:
.928d	0a		asl a				asl 	a
.928e	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9290	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9293	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9296	f0 03		beq $929b			beq 	_IntegerCode 				; if clear, then we have two integers
.9298	4c 56 a0	jmp $a056			jmp 	TypeError 					; anything else, type mismatch.
.929b					_IntegerCode:
.929b	bd 08 04	lda $0408,x			lda		NSMantissa0,x
.929e	5d 09 04	eor $0409,x			eor 		NSMantissa0+1,x
.92a1	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.92a4	bd 10 04	lda $0410,x			lda		NSMantissa1,x
.92a7	5d 11 04	eor $0411,x			eor 		NSMantissa1+1,x
.92aa	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.92ad	bd 18 04	lda $0418,x			lda		NSMantissa2,x
.92b0	5d 19 04	eor $0419,x			eor 		NSMantissa2+1,x
.92b3	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.92b6	bd 20 04	lda $0420,x			lda		NSMantissa3,x
.92b9	5d 21 04	eor $0421,x			eor 		NSMantissa3+1,x
.92bc	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.92bf	9e 00 04	stz $0400,x			stz	 	NSStatus,x 					; ignore sign.
.92c2	60		rts				rts
.92c3					WordIndirect:
.92c3	fa		plx				plx
.92c4	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92c7	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92ca	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92cb	0a		asl a				asl 	a
.92cc	10 05		bpl $92d3			bpl 	_NotRef
.92ce	48		pha				pha
.92cf	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92d2	68		pla				pla
.92d3					_NotRef:
.92d3	0a		asl a				asl 	a
.92d4	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92d6	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.92d9	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.92dc	f0 03		beq $92e1			beq 	_IntegerCode 				; if clear, then we have two integers
.92de	4c 56 a0	jmp $a056			jmp 	TypeError 					; anything else, type mismatch.
.92e1					_IntegerCode:
.92e1	20 a4 91	jsr $91a4			jsr 	AddCode 					; add the two values
.92e4	a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.92e6	9d 00 04	sta $0400,x			sta 	NSStatus,x
.92e9	60		rts				rts
.92ea					ByteIndirect:
.92ea	fa		plx				plx
.92eb	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; OR the type data together
.92ee	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.92f1	0a		asl a				asl 	a 							; shift reference bit into sign bit
.92f2	0a		asl a				asl 	a
.92f3	10 05		bpl $92fa			bpl 	_NotRef
.92f5	48		pha				pha
.92f6	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.92f9	68		pla				pla
.92fa					_NotRef:
.92fa	0a		asl a				asl 	a
.92fb	29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.92fd	1d 28 04	ora $0428,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9300	1d 29 04	ora $0429,x			ora 	NSExponent+1,x
.9303	f0 03		beq $9308			beq 	_IntegerCode 				; if clear, then we have two integers
.9305	4c 56 a0	jmp $a056			jmp 	TypeError 					; anything else, type mismatch.
.9308					_IntegerCode:
.9308	20 a4 91	jsr $91a4			jsr 	AddCode 					; add the two values
.930b	a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.930d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9310	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.9311					LCLConvertInt16:
.9311	8d 08 04	sta $0408			sta 	NSMantissa0 				; set up as 32 bit conversion
.9314	8e 10 04	stx $0410			stx 	NSMantissa1
.9317	9c 18 04	stz $0418			stz 	NSMantissa2
.931a	9c 20 04	stz $0420			stz 	NSMantissa3
.931d	9c 00 04	stz $0400			stz 	NSStatus 					; positive integer
.9320	a2 00		ldx #$00			ldx 	#0 							; stack level
.9322	a9 0a		lda #$0a			lda 	#10 						; base
.9324	80 00		bra $9326			bra 	ConvertInt32
.9326					ConvertInt32:
.9326	5a		phy				phy
.9327	a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.9329	2c 00 04	bit $0400			bit 	NSStatus 					; output a - if not negative.
.932c	10 08		bpl $9336			bpl 	_CI32NotNeg
.932e	48		pha				pha
.932f	a9 2d		lda #$2d			lda 	#'-'
.9331	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.9334	c8		iny				iny
.9335	68		pla				pla
.9336					_CI32NotNeg:
.9336	20 44 93	jsr $9344			jsr 	_CI32DivideConvert 			; recursive conversion
.9339	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.933b	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y
.933e	7a		ply				ply
.933f	a2 05		ldx #$05			ldx 	#NumberBuffer >> 8
.9341	a9 fa		lda #$fa			lda 	#NumberBuffer & $FF
.9343	60		rts				rts
.9344					_CI32DivideConvert:
.9344	e8		inx				inx 								; write to next slot up
.9345	20 c4 9e	jsr $9ec4			jsr 	NSMSetByte
.9348	ca		dex				dex
.9349	20 e8 8f	jsr $8fe8			jsr 	Int32Divide 				; divide
.934c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; save remainder
.934f	48		pha				pha
.9350	20 97 8f	jsr $8f97			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.9353	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; is it zero ?
.9356	f0 06		beq $935e			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.9358	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.935b	20 44 93	jsr $9344			jsr 	_CI32DivideConvert 			; and recusrively call.
.935e					_CI32NoRecurse:
.935e	68		pla				pla 								; remainder
.935f	c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII
.9361	90 02		bcc $9365			bcc 	_CI32NotHex
.9363	69 26		adc #$26			adc 	#6+32
.9365					_CI32NotHex:
.9365	69 30		adc #$30			adc 	#48
.9367	99 fa 05	sta $05fa,y			sta 	NumberBuffer,y 				; write out and exit
.936a	c8		iny				iny
.936b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.936c					PrecedenceLevel:
>936c	04					.byte	 4	; $00 <<
>936d	02					.byte	 2	; $01 <=
>936e	02					.byte	 2	; $02 <>
>936f	00					.byte	 0	; $03 !!3
>9370	00					.byte	 0	; $04 ><
>9371	02					.byte	 2	; $05 >=
>9372	04					.byte	 4	; $06 >>
>9373	00					.byte	 0	; $07 !!7
>9374	00					.byte	 0	; $08 !!8
>9375	00					.byte	 0	; $09 !!9
>9376	00					.byte	 0	; $0a !!10
>9377	00					.byte	 0	; $0b !!11
>9378	00					.byte	 0	; $0c !!12
>9379	00					.byte	 0	; $0d !!13
>937a	00					.byte	 0	; $0e !!14
>937b	00					.byte	 0	; $0f !!15
>937c	00					.byte	 0	; $10 @
>937d	00					.byte	 0	; $11 !!17
>937e	00					.byte	 0	; $12 !!18
>937f	00					.byte	 0	; $13 [
>9380	04					.byte	 4	; $14 \
>9381	00					.byte	 0	; $15 ]
>9382	01					.byte	 1	; $16 ^
>9383	00					.byte	 0	; $17 _
>9384	00					.byte	 0	; $18 `
>9385	00					.byte	 0	; $19 !!25
>9386	00					.byte	 0	; $1a !!26
>9387	00					.byte	 0	; $1b {
>9388	01					.byte	 1	; $1c |
>9389	00					.byte	 0	; $1d }
>938a	00					.byte	 0	; $1e ~
>938b	00					.byte	 0	; $1f [7m<7F>[m
>938c	00					.byte	 0	; $20
>938d	05					.byte	 5	; $21 !
>938e	00					.byte	 0	; $22 "
>938f	00					.byte	 0	; $23 #
>9390	05					.byte	 5	; $24 $
>9391	04					.byte	 4	; $25 %
>9392	01					.byte	 1	; $26 &
>9393	00					.byte	 0	; $27 '
>9394	00					.byte	 0	; $28 (
>9395	00					.byte	 0	; $29 )
>9396	04					.byte	 4	; $2a *
>9397	03					.byte	 3	; $2b +
>9398	00					.byte	 0	; $2c ,
>9399	03					.byte	 3	; $2d -
>939a	00					.byte	 0	; $2e .
>939b	04					.byte	 4	; $2f /
>939c	00					.byte	 0	; $30 0
>939d	00					.byte	 0	; $31 1
>939e	00					.byte	 0	; $32 2
>939f	00					.byte	 0	; $33 3
>93a0	00					.byte	 0	; $34 4
>93a1	00					.byte	 0	; $35 5
>93a2	00					.byte	 0	; $36 6
>93a3	00					.byte	 0	; $37 7
>93a4	00					.byte	 0	; $38 8
>93a5	00					.byte	 0	; $39 9
>93a6	00					.byte	 0	; $3a :
>93a7	00					.byte	 0	; $3b ;
>93a8	02					.byte	 2	; $3c <
>93a9	02					.byte	 2	; $3d =
>93aa	02					.byte	 2	; $3e >
>93ab	05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.93ac					EvaluateExpressionAt0:
.93ac	a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.93ae					EvaluateExpression:
.93ae	a9 00		lda #$00			lda 	#0 							; lowest precedence level
.93b0					EvaluateExpressionAtPrecedence:
.93b0	48		pha				pha 								; save precedence level
.93b1	20 88 98	jsr $9888			jsr 	EvaluateTerm 				; evaluate term into level X.
.93b4	68		pla				pla 								; restore precedence level.
.93b5					_EXPRLoop:
.93b5	85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.93b7	b1 30		lda ($30),y			lda 	(codePtr),y
.93b9	c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.93bb	b0 25		bcs $93e2			bcs 	_EXPRExit
.93bd	da		phx				phx 								; read the operator precedence
.93be	aa		tax				tax
.93bf	bd 6c 93	lda $936c,x			lda 	PrecedenceLevel,x
.93c2	fa		plx				plx
.93c3	c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.93c5	f0 1b		beq $93e2			beq 	_EXPRExit
.93c7	85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.93c9	a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.93cb	c5 37		cmp $37				cmp 	zTemp0+1
.93cd	b0 13		bcs $93e2			bcs		_EXPRExit 					; if current >= operator exit
.93cf	48		pha				pha 								; save current precedence.
.93d0	b1 30		lda ($30),y			lda 	(codePtr),y
.93d2	c8		iny				iny
.93d3	48		pha				pha
.93d4	a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.93d6	e8		inx				inx 								; work out the right hand side.
.93d7	20 b0 93	jsr $93b0			jsr 	EvaluateExpressionAtPrecedence
.93da	ca		dex				dex
.93db	68		pla				pla 								; get operator, call the code.
.93dc	20 e5 93	jsr $93e5			jsr 	_EXPRCaller
.93df	68		pla				pla 								; restore precedence level
.93e0	80 d3		bra $93b5			bra 	_EXPRLoop 					; and go round.
.93e2					_EXPRExit:
.93e2	a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.93e4	60		rts				rts
.93e5					_EXPRCaller:
.93e5	da		phx				phx 								; save on stack, first thing is to restore it
.93e6	0a		asl a				asl 	a 							; double so can use vectors into X
.93e7	aa		tax				tax
.93e8	7c 26 8b	jmp ($8b26,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.93eb					FloatingPointAdd:
.93eb	20 94 95	jsr $9594			jsr 	FloatPrepare 				; prepare for floats
.93ee	80 0b		bra $93fb			bra 	FloatAdd
.93f0					FloatingPointSub:
.93f0	20 94 95	jsr $9594			jsr 	FloatPrepare 				; prepare for floats
.93f3					FloatSubtract:
.93f3	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; negate FPB
.93f6	49 80		eor #$80			eor 	#$80
.93f8	9d 01 04	sta $0401,x			sta 	NSStatus+1,x				; and fall through.
.93fb					FloatAdd:
.93fb	48		pha				pha
.93fc	5a		phy				phy
.93fd	20 a5 95	jsr $95a5			jsr 	NSNormalise 				; normalise S[X]
.9400	f0 5c		beq $945e			beq 	_FAReturn1
.9402	e8		inx				inx 								; normalise S[X+1]
.9403	20 a5 95	jsr $95a5			jsr 	NSNormalise
.9406	ca		dex				dex
.9407	c9 00		cmp #$00			cmp 	#0
.9409	f0 77		beq $9482			beq 	_FAExit 					; if so, just return A
.940b	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; are the exponents the same ?
.940e	dd 29 04	cmp $0429,x			cmp 	NSExponent+1,x
.9411	f0 1b		beq $942e			beq 	_FAExponentsEqual
.9413	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; work out the larger exponent
.9416	a8		tay				tay
.9417	38		sec				sec 								; do a signed comparison of the exponents.
.9418	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.941b	50 02		bvc $941f			bvc 	_FANoSignedChange
.941d	49 80		eor #$80			eor 	#$80
.941f					_FANoSignedChange:
.941f	29 80		and #$80			and 	#$80
.9421	10 03		bpl $9426			bpl 	_FAHaveMax
.9423	bc 29 04	ldy $0429,x			ldy 	NSExponent+1,x
.9426					_FAHaveMax:
.9426	20 85 94	jsr $9485			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9429	e8		inx				inx
.942a	20 85 94	jsr $9485			jsr 	_FAShiftToExponent
.942d	ca		dex				dex
.942e					_FAExponentsEqual:
.942e	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; are the signs the same
.9431	5d 01 04	eor $0401,x			eor 	NSStatus+1,x
.9434	30 10		bmi $9446			bmi 	_FADifferentSigns
.9436	20 37 91	jsr $9137			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9439	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.943c	10 44		bpl $9482			bpl 	_FAExit 					; if no, we are done.
.943e	20 e5 9e	jsr $9ee5			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9441	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump the exponent and exit
.9444	80 3c		bra $9482			bra 	_FAExit
.9446					_FADifferentSigns:
.9446	20 5d 91	jsr $915d			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9449	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the result negative ?
.944c	10 06		bpl $9454			bpl 	_FACheckZero 				; if no, check for -0
.944e	20 6e 9e	jsr $9e6e			jsr 	NSMNegate 					; netate result
.9451	20 77 9e	jsr $9e77			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9454					_FACheckZero:
.9454	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero	 				; check for -0
.9457	d0 29		bne $9482			bne 	_FAExit
.9459	9e 00 04	stz $0400,x			stz 	NSStatus,x
.945c	80 24		bra $9482			bra 	_FAExit
.945e					_FAReturn1:
.945e	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9461	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9464	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9467	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.946a	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.946d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9470	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9473	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9476	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9479	9d 28 04	sta $0428,x			sta 	NSExponent,x
.947c	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.947f	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9482					_FAExit:
.9482	7a		ply				ply
.9483	68		pla				pla
.9484	60		rts				rts
.9485					_FAShiftToExponent:
.9485					_FAShiftToExponent2:
.9485	98		tya				tya 								; compare Y to exponent
.9486	dd 28 04	cmp $0428,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9489	f0 08		beq $9493			beq 	_FASEExit 					; exit if so.
.948b	20 e5 9e	jsr $9ee5			jsr 	NSMShiftRight	 			; shift the mantissa right
.948e	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; increment exponent
.9491	80 f2		bra $9485			bra 	_FAShiftToExponent2
.9493					_FASEExit:
.9493	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9494					CompareFloat:
.9494	20 f3 93	jsr $93f3			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9497	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.949a	29 f8		and #$f8			and 	#$F8
.949c	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.949f	1d 20 04	ora $0420,x			ora 	NSMantissa3,x
.94a2	f0 09		beq $94ad			beq 	_FCExit 					; zero, so approximately identical
.94a4	a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.94a6	3c 00 04	bit $0400,x			bit 	NSStatus,x
.94a9	10 02		bpl $94ad			bpl 	_FCExit
.94ab					_FCNegative:
.94ab	a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.94ad					_FCExit:
.94ad	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.94ae					FDivideCommand:
.94ae	fa		plx				plx	 								; restore stack position
.94af	20 94 95	jsr $9594			jsr 	FloatPrepare 				; prepare for floats
.94b2					FloatDivide:
.94b2	48		pha				pha
.94b3	e8		inx				inx
.94b4	20 a5 95	jsr $95a5			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.94b7	ca		dex				dex
.94b8	c9 00		cmp #$00			cmp 	#0
.94ba	f0 20		beq $94dc			beq 	_FDZero
.94bc	20 a5 95	jsr $95a5			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.94bf	f0 19		beq $94da			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.94c1	20 0a 90	jsr $900a			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.94c4	20 97 8f	jsr $8f97			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.94c7	20 a5 95	jsr $95a5			jsr		NSNormalise 				; renormalise
.94ca	20 a5 90	jsr $90a5			jsr 	CalculateSign 				; calculate result sign
.94cd	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent
.94d0	38		sec				sec
.94d1	fd 29 04	sbc $0429,x			sbc 	NSExponent+1,x
.94d4	38		sec				sec
.94d5	e9 1e		sbc #$1e			sbc 	#30
.94d7	9d 28 04	sta $0428,x			sta 	NSExponent,x
.94da					_FDExit:
.94da	68		pla				pla
.94db	60		rts				rts
.94dc					_FDZero:
.94dc	a9 03		lda #$03		lda	#3
.94de	4c ff 8d	jmp $8dff		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.94e1					FloatFractionalPart:
.94e1	5a		phy				phy
.94e2	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; take absolute value
.94e5	29 7f		and #$7f			and 	#$7F
.94e7	9d 00 04	sta $0400,x			sta 	NSStatus,x
.94ea	20 a5 95	jsr $95a5			jsr 	NSNormalise
.94ed	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.94f0	38		sec				sec
.94f1	e9 e0		sbc #$e0			sbc 	#$E0
.94f3	90 31		bcc $9526			bcc 	_FFPExit 					; already fractional
.94f5	c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.94f7	b0 2a		bcs $9523			bcs 	_FFPZero
.94f9	a8		tay				tay 								; put count to do in Y
.94fa	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; do each in turn.
.94fd	20 28 95	jsr $9528			jsr 	_FFPPartial
.9500	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9503	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9506	20 28 95	jsr $9528			jsr 	_FFPPartial
.9509	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.950c	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.950f	20 28 95	jsr $9528			jsr 	_FFPPartial
.9512	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9515	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9518	20 28 95	jsr $9528			jsr 	_FFPPartial
.951b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.951e	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; zeroed check.
.9521	d0 03		bne $9526			bne 	_FFPExit
.9523					_FFPZero:
.9523	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero
.9526					_FFPExit:
.9526	7a		ply				ply
.9527	60		rts				rts
.9528					_FFPPartial:
.9528	c0 00		cpy #$00			cpy 	#0 							; no more to do
.952a	f0 17		beq $9543			beq 	_FFFPPExit
.952c	c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.952e	b0 0c		bcs $953c			bcs 	_FFFPPWholeByte
.9530	5a		phy				phy
.9531					_FFFPPLeft:
.9531	0a		asl a				asl 	a
.9532	88		dey				dey
.9533	d0 fc		bne $9531			bne 	_FFFPPLeft
.9535	7a		ply				ply
.9536					_FFFPPRight:
.9536	4a		lsr a				lsr 	a
.9537	88		dey				dey
.9538	d0 fc		bne $9536			bne 	_FFFPPRight
.953a	80 07		bra $9543			bra 	_FFFPPExit
.953c					_FFFPPWholeByte:
.953c	98		tya				tya 								; subtract 8 from count
.953d	38		sec				sec
.953e	e9 08		sbc #$08			sbc 	#8
.9540	a8		tay				tay
.9541	a9 00		lda #$00			lda 	#0 							; and clear all
.9543					_FFFPPExit:
.9543	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9544					FloatIntegerPart:
.9544	48		pha				pha
.9545	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; is it integer already ?
.9548	f0 1f		beq $9569			beq 	_FIPExit 					; if so do nothing
.954a	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; is it zero ?
.954d	f0 17		beq $9566			beq 	_FIPZero 					; if so return zero.
.954f	20 a5 95	jsr $95a5			jsr 	NSNormalise 				; normalise
.9552	f0 12		beq $9566			beq 	_FIPZero 					; normalised to zero, exit zero
.9554					_FIPShift:
.9554	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9557	10 08		bpl $9561			bpl 	_FIPCheckZero
.9559	20 e5 9e	jsr $9ee5			jsr 	NSMShiftRight 				; shift mantissa right
.955c	fe 28 04	inc $0428,x			inc 	NSExponent,x 				; bump exponent
.955f	80 f3		bra $9554			bra 	_FIPShift
.9561					_FIPCheckZero:
.9561	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; avoid -0 problem
.9564	d0 03		bne $9569			bne 	_FIPExit 					; set to zero if mantissa zero.
.9566					_FIPZero:
.9566	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero
.9569					_FIPExit:
.9569	68		pla				pla
.956a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.956b					FloatingPointMultiply:
.956b	20 94 95	jsr $9594			jsr 	FloatPrepare 				; prepare for floats
.956e					FloatMultiply:
.956e	48		pha				pha
.956f	20 a5 95	jsr $95a5			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9572	f0 1b		beq $958f			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9574	e8		inx				inx
.9575	20 a5 95	jsr $95a5			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9578	ca		dex				dex
.9579	c9 00		cmp #$00			cmp 	#0
.957b	f0 0f		beq $958c			beq 	_FDSetZero
.957d	20 60 90	jsr $9060			jsr 	MultiplyShort 				; calculate the result.
.9580	7d 28 04	adc $0428,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9583	18		clc				clc
.9584	7d 29 04	adc $0429,x			adc 	NSExponent+1,x
.9587	9d 28 04	sta $0428,x			sta 	NSExponent,x
.958a	80 03		bra $958f			bra 	_FDExit
.958c					_FDSetZero:
.958c	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero 					; return 0
.958f					_FDExit:
.958f	20 a5 95	jsr $95a5			jsr 	NSNormalise 				; normalise the result
.9592	68		pla				pla
.9593	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9594					FloatPrepare:
.9594	20 c7 96	jsr $96c7			jsr 	DereferenceTopTwo 			; dereference the top two values
.9597	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check ints/floats
.959a	1d 01 04	ora $0401,x			ora 	NSStatus+1,x
.959d	29 10		and #$10			and 	#NSBIsString
.959f	d0 01		bne $95a2			bne 	_FDType
.95a1	60		rts				rts
.95a2					_FDType:
.95a2	4c 56 a0	jmp $a056			jmp 	TypeError
.95a5					NSNormalise:
.95a5	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make float, keep sign
.95a8	29 80		and #$80			and 	#$80
.95aa	09 08		ora #$08			ora 	#NSTFloat
.95ac	9d 00 04	sta $0400,x			sta 	NSStatus,x
.95af	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; if zero exit
.95b2	d0 09		bne $95bd			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.95b4	1e 00 04	asl $0400,x			asl 	NSStatus,x 					; clear the sign bit.
.95b7	7e 00 04	ror $0400,x			ror 	NSStatus,x 					; (no -0)
.95ba	a9 00		lda #$00			lda 	#0 							; set Z flag
.95bc	60		rts				rts
.95bd					_NSNormaliseOptimise:
.95bd	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; upper byte zero ?
.95c0	d0 22		bne $95e4			bne 	_NSNormaliseLoop
.95c2	bd 18 04	lda $0418,x			lda 	NSMantissa2,x 				; byte normalise
.95c5	30 1d		bmi $95e4			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.95c7	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.95ca	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95cd	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.95d0	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.95d3	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.95d6	9e 08 04	stz $0408,x			stz 	NSMantissa0,x
.95d9	bd 28 04	lda $0428,x			lda 	NSExponent,x
.95dc	38		sec				sec
.95dd	e9 08		sbc #$08			sbc 	#8
.95df	9d 28 04	sta $0428,x			sta 	NSExponent,x
.95e2	80 d9		bra $95bd			bra 	_NSNormaliseOptimise
.95e4					_NSNormaliseLoop:
.95e4	3c 20 04	bit $0420,x			bit 	NSMantissa3,x 				; bit 30 set ?
.95e7	70 08		bvs $95f1			bvs 	_NSNExit 					; exit if so with Z flag clear
.95e9	20 d7 9e	jsr $9ed7			jsr 	NSMShiftLeft 				; shift mantissa left
.95ec	de 28 04	dec $0428,x			dec 	NSExponent,x 				; adjust exponent
.95ef	80 f3		bra $95e4			bra 	_NSNormaliseLoop
.95f1					_NSNExit:
.95f1	a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.95f3	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.95f4					AssignNumber:
.95f4	5a		phy				phy
.95f5	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.95f8	85 36		sta $36				sta 	zTemp0
.95fa	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.95fd	85 37		sta $37				sta 	zTemp0+1
.95ff	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear reference bits
.9602	29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9604	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9607	29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9609	c9 08		cmp #$08			cmp 	#NSTFloat
.960b	f0 2a		beq $9637			beq 	_ANFloat
.960d	bd 29 04	lda $0429,x			lda		NSExponent+1,x 				; is it a float
.9610	f0 05		beq $9617			beq		_ANNotFloat
.9612	e8		inx				inx
.9613	20 44 95	jsr $9544			jsr 	FloatIntegerPart 			; make it an integer
.9616	ca		dex				dex
.9617					_ANNotFloat:
.9617	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if byte/word reference.
.961a	29 03		and #$03			and 	#3
.961c	d0 05		bne $9623			bne 	_ANByteWord
.961e	20 43 96	jsr $9643			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9621	80 1e		bra $9641			bra 	_ANExit
.9623					_ANByteWord:
.9623	48		pha				pha 								; save count
.9624	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; do byte
.9627	92 36		sta ($36)			sta 	(zTemp0)
.9629	68		pla				pla
.962a	c9 01		cmp #$01			cmp	 	#1
.962c	f0 13		beq $9641			beq 	_ANExit
.962e	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x 			; do word
.9631	a0 01		ldy #$01			ldy 	#1
.9633	91 36		sta ($36),y			sta 	(zTemp0),y
.9635	80 0a		bra $9641			bra 	_ANExit
.9637					_ANFloat:
.9637	20 43 96	jsr $9643			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.963a	bd 29 04	lda $0429,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.963d	a0 04		ldy #$04			ldy 	#4
.963f	91 36		sta ($36),y			sta 	(zTemp0),y
.9641					_ANExit:
.9641	7a		ply				ply
.9642	60		rts				rts
.9643					_ANCopy4PackSign:
.9643	a0 03		ldy #$03			ldy 	#3
.9645	bd 01 04	lda $0401,x			lda 	NSStatus+1,x 				; sign bit into status
.9648	29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.964a	1d 21 04	ora $0421,x			ora 	NSMantissa3+1,x
.964d	91 36		sta ($36),y			sta 	(zTemp0),y
.964f	88		dey				dey
.9650	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9653	91 36		sta ($36),y			sta 	(zTemp0),y
.9655	88		dey				dey
.9656	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9659	91 36		sta ($36),y			sta 	(zTemp0),y
.965b	88		dey				dey
.965c	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.965f	91 36		sta ($36),y			sta 	(zTemp0),y
.9661	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9662					AssignString:
.9662	5a		phy				phy
.9663	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9666	85 38		sta $38				sta 	zTemp1
.9668	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.966b	85 39		sta $39				sta 	zTemp1+1
.966d	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9670	85 36		sta $36				sta 	zTemp0
.9672	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9675	85 37		sta $37				sta 	zTemp0+1
.9677	a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9679	b1 36		lda ($36),y			lda 	(zTemp0),y
.967b	f0 23		beq $96a0			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.967d	38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.967e	b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9680	e9 02		sbc #$02			sbc 	#2
.9682	85 3c		sta $3c				sta 	zsTemp
.9684	a0 01		ldy #$01			ldy 	#1
.9686	b1 36		lda ($36),y			lda 	(zTemp0),y
.9688	e9 00		sbc #$00			sbc 	#0
.968a	85 3d		sta $3d				sta 	zsTemp+1
.968c	a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.968e					_ASGetLength:
.968e	c8		iny				iny
.968f	b1 38		lda ($38),y			lda 	(zTemp1),y
.9691	d0 fb		bne $968e			bne 	_ASGetLength
.9693	98		tya				tya 								; is this length <= current length
.9694	d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9696	90 20		bcc $96b8			bcc 	_ASCopyString
.9698	f0 1e		beq $96b8			beq 	_ASCopyString
.969a	a9 80		lda #$80			lda 	#$80 						; mark as unused.
.969c	a0 01		ldy #$01			ldy 	#1
.969e	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96a0					_ASNewStringRequired:
.96a0	e8		inx				inx 								; concrete the new string.
.96a1	20 be a7	jsr $a7be			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.96a4	ca		dex				dex
.96a5	18		clc				clc
.96a6	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.96a9	69 02		adc #$02			adc 	#2 							; add two to point at the data.
.96ab	92 36		sta ($36)			sta 	(zTemp0)
.96ad	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.96b0	69 00		adc #$00			adc 	#0
.96b2	a0 01		ldy #$01			ldy 	#1
.96b4	91 36		sta ($36),y			sta 	(zTemp0),y
.96b6	80 0d		bra $96c5			bra 	_ASExit
.96b8					_ASCopyString:
.96b8	a0 00		ldy #$00			ldy 	#0
.96ba					_ASCopyLoop:
.96ba	b1 38		lda ($38),y			lda 	(zTemp1),y
.96bc	c8		iny				iny
.96bd	c8		iny				iny
.96be	91 3c		sta ($3c),y			sta 	(zsTemp),y
.96c0	88		dey				dey
.96c1	c9 00		cmp #$00			cmp 	#0
.96c3	d0 f5		bne $96ba			bne 	_ASCopyLoop
.96c5					_ASExit:
.96c5	7a		ply				ply
.96c6	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.96c7					DereferenceTopTwo:
.96c7	e8		inx				inx
.96c8	20 cc 96	jsr $96cc			jsr 	Dereference 				; deref x+1
.96cb	ca		dex				dex  								; falls through to deref x
.96cc					Dereference:
.96cc	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get the status byte
.96cf	29 20		and #$20			and 	#NSBIsReference 			; shift sign bit to carry, reference to bit 7
.96d1	f0 57		beq $972a			beq 	_DRFExit 					; not a reference
.96d3	5a		phy				phy
.96d4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.96d7	85 36		sta $36				sta 	zTemp0
.96d9	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.96dc	85 37		sta $37				sta 	zTemp0+1
.96de	9e 10 04	stz $0410,x			stz 	NSMantissa1,x 				; clear second byte.
.96e1	b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.96e3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.96e6	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status byte.
.96e9	29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.96eb	c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.96ed	f0 0f		beq $96fe			beq 	_DRFDereferenceTwo
.96ef	c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.96f1	f0 39		beq $972c			beq 	_DRFFull
.96f3	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.96f6	29 03		and #$03			and 	#3
.96f8	f0 32		beq $972c			beq 	_DRFFull 					; the whole word
.96fa	c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.96fc	f0 07		beq $9705			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.96fe					_DRFDereferenceTwo:
.96fe	a0 01		ldy #$01			ldy 	#1
.9700	b1 36		lda ($36),y			lda 	(zTemp0),y
.9702	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9705					_DRFClear23:
.9705	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9708	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.970b	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; make it a value of that type.
.970e	29 18		and #$18			and 	#NSBTypeMask
.9710	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9713	c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9715	d0 12		bne $9729			bne 	_DRFNotString
.9717	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; check address is zero
.971a	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.971d	d0 0a		bne $9729			bne 	_DRFNotString
.971f	a9 2b		lda #$2b			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9721	9d 08 04	sta $0408,x			sta 	NSMantissa0,X
.9724	a9 97		lda #$97			lda 	#_DRFNullString >> 8
.9726	9d 10 04	sta $0410,x			sta 	NSMantissa1,X
.9729					_DRFNotString
.9729	7a		ply				ply 								; restore Y and exit
.972a					_DRFExit:
.972a	60		rts				rts
.972b					_DRFNullString:
>972b	00						.byte 	0
.972c					_DRFFull:
.972c	a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.972e	b1 36		lda ($36),y			lda 	(zTemp0),y
.9730	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9733	c8		iny				iny
.9734	b1 36		lda ($36),y			lda 	(zTemp0),y
.9736	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9739	c8		iny				iny
.973a	b1 36		lda ($36),y			lda 	(zTemp0),y
.973c	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.973f	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; clear exponent.
.9742	bd 00 04	lda $0400,x			lda		NSStatus,x 					; see if type is integer
.9745	29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9747	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; update it back.
.974a	f0 06		beq $9752			beq 	_DRFNoExponent
.974c	c8		iny				iny 								; if not, read the exponent as well.
.974d	b1 36		lda ($36),y			lda 	(zTemp0),y
.974f	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9752					_DRFNoExponent:
.9752	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9755	10 0d		bpl $9764			bpl 	_DRFExit2 					; if not, then exit.
.9757	29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9759	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.975c	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; set the sign flag
.975f	09 80		ora #$80			ora 	#NSBIsNegative
.9761	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9764					_DRFExit2:
.9764	7a		ply				ply
.9765	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1					ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2					ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3					ESTA_Decimal = 3 							; fractional part.
.9766					EncodeNumberStart:
.9766	38		sec				sec
.9767	80 01		bra $976a			bra 	EncodeNumberContinue+1
.9769					EncodeNumberContinue:
.9769	18		clc				clc
.976a					EncodeNumber:
.976a	08		php				php 								; save reset.
.976b	c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.976d	f0 12		beq $9781			beq 	_ENIsOkay
.976f	c9 30		cmp #$30			cmp 	#"0"
.9771	90 04		bcc $9777			bcc 	_ENBadNumber
.9773	c9 3a		cmp #$3a			cmp 	#"9"+1
.9775	90 0a		bcc $9781			bcc 	_ENIsOkay
.9777					_ENBadNumber:
.9777	28		plp				plp 								; throw saved reset
.9778	ad 85 04	lda $0485			lda 	EncodeState 				; decimal mode, construct final number
.977b	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.977d	f0 7e		beq $97fd			beq 	_ENConstructFinal
.977f					_ENFail:
.977f	18		clc				clc 								; not allowed
.9780	60		rts				rts
.9781					_ENIsOkay:
.9781	28		plp				plp 								; are we restarting
.9782	90 15		bcc $9799			bcc 	_ENNoRestart
.9784					_ENStartEncode:
.9784	c9 2e		cmp #$2e			cmp 	#'.'						; first is DP
.9786	f0 0c		beq $9794			beq 	_ENFirstDP
.9788	29 0f		and #$0f			and 	#15 						; put digit in mantissa
.978a	20 c4 9e	jsr $9ec4			jsr 	NSMSetByte
.978d	a9 01		lda #$01			lda 	#ESTA_Low
.978f					_ENExitChange:
.978f	8d 85 04	sta $0485			sta 	EncodeState 				; save new state
.9792	38		sec				sec
.9793	60		rts				rts
.9794					_ENFirstDP:
.9794	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero 					; clear integer part
.9797	80 3f		bra $97d8			bra 	_ESTASwitchFloat			; go straight to float and exi
.9799					_ENNoRestart:
.9799	48		pha				pha 								; save on stack.
.979a	ad 85 04	lda $0485			lda 	EncodeState 				; get current state
.979d	c9 01		cmp #$01			cmp 	#ESTA_Low
.979f	f0 09		beq $97aa			beq  	_ESTALowState
.97a1	c9 02		cmp #$02			cmp 	#ESTA_High
.97a3	f0 29		beq $97ce			beq 	_ESTAHighState
.97a5	c9 03		cmp #$03			cmp 	#ESTA_Decimal
.97a7	f0 3b		beq $97e4			beq 	_ESTADecimalState
>97a9	db						.byte 	$DB 						; causes a break in the emulator
.97aa					_ESTALowState:
.97aa	68		pla				pla 								; get value back
.97ab	c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.97ad	f0 29		beq $97d8			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.97af	29 0f		and #$0f			and 	#15 						; make digit
.97b1	8d 86 04	sta $0486			sta 	DigitTemp 					; save it.
.97b4	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.97b7	0a		asl a				asl 	a
.97b8	0a		asl a				asl 	a
.97b9	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.97bc	0a		asl a				asl 	a
.97bd	6d 86 04	adc $0486			adc 	DigitTemp
.97c0	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.97c3	c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.97c5	90 05		bcc $97cc			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.97c7	a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.97c9	8d 85 04	sta $0485			sta 	EncodeState
.97cc					_ESTANoSwitch:
.97cc	38		sec				sec
.97cd	60		rts				rts
.97ce					_ESTAHighState:
.97ce	68		pla				pla 								; get value back
.97cf	c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.97d1	f0 05		beq $97d8			beq 	_ESTASwitchFloat
.97d3	20 37 98	jsr $9837			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.97d6	38		sec				sec
.97d7	60		rts				rts
.97d8					_ESTASwitchFloat:
.97d8	9c 87 04	stz $0487			stz 	DecimalCount
.97db	e8		inx				inx 								; zero the decimal additive.
.97dc	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero
.97df	ca		dex				dex
.97e0	a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.97e2	80 ab		bra $978f			bra 	_ENExitChange
.97e4					_ESTADecimalState:
.97e4	68		pla				pla 								; digit.
.97e5	c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.97e7	f0 96		beq $977f			beq 	_ENFail
.97e9	e8		inx				inx 								; put digit into fractional part of X+1
.97ea	20 37 98	jsr $9837			jsr 	ESTAShiftDigitIntoMantissa
.97ed	ca		dex				dex
.97ee	ee 87 04	inc $0487			inc 	DecimalCount 				; bump the count of decimals
.97f1	ad 87 04	lda $0487			lda 	DecimalCount
.97f4	c9 0b		cmp #$0b			cmp 	#11
.97f6	f0 02		beq $97fa			beq 	_ESTADSFail
.97f8	38		sec				sec
.97f9	60		rts				rts
.97fa					_ESTADSFail:
.97fa	4c 51 a0	jmp $a051			jmp 	RangeError
.97fd					_ENConstructFinal:
.97fd	ad 87 04	lda $0487			lda 	DecimalCount 				; get decimal count
.9800	f0 33		beq $9835			beq 	_ENCFExit 					; no decimals
.9802	5a		phy				phy
.9803	0a		asl a				asl 	a 							; x 4 and CLC
.9804	0a		asl a				asl 	a
.9805	6d 87 04	adc $0487			adc 	DecimalCount
.9808	a8		tay				tay
.9809	b9 10 a0	lda $a010,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.980c	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.980f	b9 11 a0	lda $a011,y			lda 	DecimalScalarTable-5+1,y
.9812	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9815	b9 12 a0	lda $a012,y			lda 	DecimalScalarTable-5+2,y
.9818	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.981b	b9 13 a0	lda $a013,y			lda 	DecimalScalarTable-5+3,y
.981e	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9821	b9 14 a0	lda $a014,y			lda 	DecimalScalarTable-5+4,y
.9824	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9827	a9 08		lda #$08			lda 	#NSTFloat
.9829	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.982c	7a		ply				ply
.982d	e8		inx				inx 								; multiply decimal const by decimal scalar
.982e	20 6e 95	jsr $956e			jsr 	FloatMultiply
.9831	ca		dex				dex
.9832	20 fb 93	jsr $93fb			jsr 	FloatAdd 					; add to integer part.
.9835					_ENCFExit:
.9835	18		clc				clc 								; reject the digit.
.9836	60		rts				rts
.9837					ESTAShiftDigitIntoMantissa:
.9837	29 0f		and #$0f			and 	#15 						; save digit
.9839	48		pha				pha
.983a	bd 20 04	lda $0420,x			lda 	NSMantissa3,x 				; push mantissa on stack
.983d	48		pha				pha
.983e	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9841	48		pha				pha
.9842	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9845	48		pha				pha
.9846	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9849	48		pha				pha
.984a	20 d7 9e	jsr $9ed7			jsr 	NSMShiftLeft 				; x 2
.984d	20 d7 9e	jsr $9ed7			jsr 	NSMShiftLeft 				; x 4
.9850	18		clc				clc 								; pop mantissa and add
.9851	68		pla				pla
.9852	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9855	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9858	68		pla				pla
.9859	7d 10 04	adc $0410,x			adc 	NSMantissa1,x
.985c	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.985f	68		pla				pla
.9860	7d 18 04	adc $0418,x			adc 	NSMantissa2,x
.9863	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9866	68		pla				pla
.9867	7d 20 04	adc $0420,x			adc 	NSMantissa3,x
.986a	9d 20 04	sta $0420,x			sta 	NSMantissa3,x 				; x 5
.986d	20 d7 9e	jsr $9ed7			jsr 	NSMShiftLeft 				; x 10
.9870	68		pla				pla 								; add digit
.9871	18		clc				clc
.9872	7d 08 04	adc $0408,x			adc 	NSMantissa0,x
.9875	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9878	90 0d		bcc $9887			bcc 	_ESTASDExit
.987a	fe 10 04	inc $0410,x			inc 	NSMantissa1,x
.987d	d0 08		bne $9887			bne 	_ESTASDExit
.987f	fe 18 04	inc $0418,x			inc 	NSMantissa2,x
.9882	d0 03		bne $9887			bne 	_ESTASDExit
.9884	fe 20 04	inc $0420,x			inc 	NSMantissa3,x
.9887					_ESTASDExit:
.9887	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9888					EvaluateTerm:
.9888	b1 30		lda ($30),y			lda 	(codePtr),y
.988a	30 18		bmi $98a4			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.988c	c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.988e	b0 6f		bcs $98ff			bcs 	_ETVariable
.9890	c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9892	90 6e		bcc $9902			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9894	c9 3a		cmp #$3a			cmp 	#'9'+1
.9896	b0 6a		bcs $9902			bcs 	_ETPuncUnary
.9898	20 66 97	jsr $9766			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.989b					_ETNumber:
.989b	c8		iny				iny 								; keep encoding until we have the numbers
.989c	b1 30		lda ($30),y			lda 	(codePtr),y
.989e	20 69 97	jsr $9769			jsr 	EncodeNumberContinue
.98a1	b0 f8		bcs $989b			bcs 	_ETNumber 					; go back if accepted.
.98a3	60		rts				rts
.98a4					_ETCheckUnary:
.98a4	c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.98a6	f0 41		beq $98e9			beq 	_ETString
.98a8	c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.98aa	f0 12		beq $98be			beq 	_ETHexConstant
.98ac	c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.98ae	90 0b		bcc $98bb			bcc 	_ETSyntaxError
.98b0	c9 a0		cmp #$a0			cmp 	#KWC_LAST_UNARY+1
.98b2	b0 07		bcs $98bb			bcs 	_ETSyntaxError
.98b4	da		phx				phx 								; push X on the stack
.98b5	0a		asl a				asl 	a 							; put vector x 2 into X
.98b6	aa		tax				tax
.98b7	c8		iny				iny 								; consume unary function token
.98b8	7c a6 8b	jmp ($8ba6,x)			jmp 	(VectorSet0,x) 				; and do it.
.98bb					_ETSyntaxError:
.98bb	4c 4c a0	jmp $a04c			jmp 	SyntaxError
.98be					_ETHexConstant:
.98be	c8		iny				iny 								; skip #
.98bf	c8		iny				iny 								; skip count
.98c0	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero 					; clear result
.98c3					_ETHLoop:
.98c3	b1 30		lda ($30),y			lda 	(codePtr),y
.98c5	c8		iny				iny 								; and consume
.98c6	c9 00		cmp #$00			cmp 	#0 							; exit if zero
.98c8	f0 1e		beq $98e8			beq 	_ETHExit
.98ca	48		pha				pha 								; save on stack.
.98cb	20 d7 9e	jsr $9ed7			jsr 	NSMShiftLeft 				; x 2
.98ce	20 d7 9e	jsr $9ed7			jsr 	NSMShiftLeft 				; x 4
.98d1	20 d7 9e	jsr $9ed7			jsr 	NSMShiftLeft 				; x 8
.98d4	20 d7 9e	jsr $9ed7			jsr 	NSMShiftLeft 				; x 16
.98d7	68		pla				pla 								; ASCII
.98d8	c9 41		cmp #$41			cmp 	#'A'
.98da	90 02		bcc $98de			bcc 	_ETHNotChar
.98dc	e9 07		sbc #$07			sbc 	#7
.98de					_ETHNotChar:
.98de	29 0f		and #$0f			and 	#15 						; digit now
.98e0	1d 08 04	ora $0408,x			ora 	NSMantissa0,x 				; put in LS Nibble
.98e3	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.98e6	80 db		bra $98c3			bra 	_ETHLoop 					; go round.
.98e8					_ETHExit:
.98e8	60		rts				rts
.98e9					_ETString:
.98e9	c8		iny				iny 								; look at length
.98ea	b1 30		lda ($30),y			lda 	(codePtr),y
.98ec	48		pha				pha
.98ed	c8		iny				iny 								; first character
.98ee	20 5b a6	jsr $a65b			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.98f1	68		pla				pla 								; restore count and save
.98f2	85 36		sta $36				sta 	zTemp0
.98f4	98		tya				tya 								; add length to Y to skip it.
.98f5	18		clc				clc
.98f6	65 36		adc $36				adc 	zTemp0
.98f8	a8		tay				tay
.98f9	a9 10		lda #$10			lda 	#NSTString 					; mark as string
.98fb	9d 00 04	sta $0400,x			sta 	NSStatus,x
.98fe	60		rts				rts
.98ff					_ETVariable:
.98ff	4c 59 99	jmp $9959			jmp 	VariableHandler
.9902					_ETPuncUnary:
.9902	c8		iny				iny 								; consume the unary character
.9903	c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9905	f0 2d		beq $9934			beq 	_ETUnaryNegate
.9907	c9 10		cmp #$10			cmp 	#KWD_AT 					; @ reference -> constant
.9909	f0 39		beq $9944			beq 	_ETDereference
.990b	c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.990d	f0 43		beq $9952			beq 	_ETParenthesis
.990f	64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9911	c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9913	f0 06		beq $991b			beq 	_ETIndirection
.9915	e6 36		inc $36				inc 	zTemp0
.9917	c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9919	d0 a0		bne $98bb			bne 	_ETSyntaxError
.991b					_ETIndirection:
.991b	a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.991d	1a		inc a				inc 	a
.991e	48		pha				pha
.991f	20 88 98	jsr $9888			jsr 	EvaluateTerm				; evaluate the term
.9922	20 cc 96	jsr $96cc			jsr 	Dereference 				; dereference it.
.9925	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a +ve integer.
.9928	d0 07		bne $9931			bne 	_ETTypeMismatch
.992a	68		pla				pla 								; indirection 1-2
.992b	09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.992d	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9930	60		rts				rts
.9931					_ETTypeMismatch:
.9931	4c 56 a0	jmp $a056			jmp 	TypeError
.9934					_ETUnaryNegate:
.9934	20 88 98	jsr $9888			jsr 	EvaluateTerm				; evaluate the term
.9937	20 cc 96	jsr $96cc			jsr 	Dereference 				; dereference it.
.993a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a number
.993d	29 10		and #$10			and 	#NSTString
.993f	d0 f0		bne $9931			bne 	_ETTypeMismatch
.9941	4c 6e 9e	jmp $9e6e			jmp 	NSMNegate  					; just toggles the sign bit.
.9944					_ETDereference:
.9944	20 88 98	jsr $9888			jsr 	EvaluateTerm				; evaluate the term
.9947	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; must be a reference
.994a	29 20		and #$20			and 	#NSBIsReference
.994c	f0 e3		beq $9931			beq 	_ETTypeMismatch
.994e	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer address
.9951	60		rts				rts
.9952					_ETParenthesis:
.9952	20 ae 93	jsr $93ae			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9955	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket 			; check for )
.9958	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9959					VariableHandler:
.9959	b1 30		lda ($30),y			lda 	(codePtr),y
.995b	18		clc				clc
.995c	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.995e	85 37		sta $37				sta 	zTemp0+1
.9960	c8		iny				iny
.9961	b1 30		lda ($30),y			lda 	(codePtr),y
.9963	85 36		sta $36				sta 	zTemp0
.9965	c8		iny				iny
.9966	18		clc				clc									; copy variable address+3 to mantissa
.9967	69 03		adc #$03			adc 	#3
.9969	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.996c	a5 37		lda $37				lda 	zTemp0+1
.996e	69 00		adc #$00			adc 	#0
.9970	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9973	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9976	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9979	9e 28 04	stz $0428,x			stz 	NSExponent,x
.997c	5a		phy				phy
.997d	a0 02		ldy #$02			ldy 	#2 							; read type
.997f	b1 36		lda ($36),y			lda 	(zTemp0),y
.9981	7a		ply				ply
.9982	29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9984	09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9986	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9989	29 04		and #$04			and 	#NSBIsArray
.998b	d0 01		bne $998e			bne 	_VHArray
.998d	60		rts				rts
.998e					_VHArray:
.998e	e8		inx				inx
.998f	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9992	a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9994	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9997	b1 30		lda ($30),y			lda 	(codePtr),y
.9999	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.999b	d0 06		bne $99a3			bne 	_VHNoSecondIndex
.999d	c8		iny				iny 								; skip the comma
.999e	e8		inx				inx
.999f	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.99a2	ca		dex				dex
.99a3					_VHNoSecondIndex:
.99a3	ca		dex				dex 								; set X back.
.99a4	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket 			; and check the right bracket.
.99a7	5a		phy				phy 								; save position
.99a8	a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.99aa	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99ac	f0 6b		beq $9a19			beq 	_VHBadIndex
.99ae	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy record address to zaTemp
.99b1	85 3e		sta $3e				sta 	zaTemp
.99b3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.99b6	85 3f		sta $3f				sta 	zaTemp+1
.99b8	a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.99ba	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99bc	f0 02		beq $99c0			beq 	_VHHas2Mask
.99be	a9 ff		lda #$ff			lda 	#$FF
.99c0					_VHHas2Mask:
.99c0	dd 02 04	cmp $0402,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.99c3	f0 54		beq $9a19			beq 	_VHBadIndex
.99c5	0a		asl a				asl 	a 							; carry will be set if a second index
.99c6	90 09		bcc $99d1			bcc 	_VHCheckFirstIndex
.99c8	a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.99ca	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99cc	dd 0a 04	cmp $040a,x			cmp 	NSMantissa0+2,x
.99cf	90 48		bcc $9a19			bcc 	_VHBadIndex
.99d1					_VHCheckFirstIndex:
.99d1	a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.99d3	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99d5	dd 09 04	cmp $0409,x			cmp 	NSMantissa0+1,x
.99d8	90 3f		bcc $9a19			bcc 	_VHBadIndex
.99da	64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.99dc	64 37		stz $37				stz 	zTemp0+1
.99de	bd 02 04	lda $0402,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.99e1	30 0f		bmi $99f2			bmi 	_VHNoMultiply
.99e3	da		phx				phx
.99e4	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.99e7	48		pha				pha
.99e8	a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.99ea	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.99ec	1a		inc a				inc 	a 							; add 1 for zero base
.99ed	fa		plx				plx
.99ee	20 57 9e	jsr $9e57			jsr 	Multiply8x8 				; calculate -> Z0
.99f1	fa		plx				plx
.99f2					_VHNoMultiply:
.99f2	18		clc				clc
.99f3	a5 36		lda $36				lda 	zTemp0
.99f5	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.99f8	85 36		sta $36				sta 	zTemp0
.99fa	a5 37		lda $37				lda 	zTemp0+1
.99fc	69 00		adc #$00			adc 	#0
.99fe	85 37		sta $37				sta 	zTemp0+1
.9a00	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9a03	20 fb 84	jsr $84fb			jsr 	ScaleByBaseType
.9a06	18		clc				clc
.9a07	b2 3e		lda ($3e)			lda 	(zaTemp)
.9a09	65 36		adc $36				adc 	zTemp0
.9a0b	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9a0e	a0 01		ldy #$01			ldy 	#1
.9a10	b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9a12	65 37		adc $37				adc 	zTemp0+1
.9a14	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9a17	7a		ply				ply 								; restore position
.9a18	60		rts				rts
.9a19					_VHBadIndex:
.9a19	a9 17		lda #$17		lda	#23
.9a1b	4c ff 8d	jmp $8dff		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.9a1e					AbsUnary:
.9a1e	fa		plx				plx 								; restore stack pos
.9a1f	20 eb 9d	jsr $9deb			jsr 	EvaluateNumber 				; get a float or int
.9a22	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.9a25	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; clear the sign bit
.9a28	29 7f		and #$7f			and 	#$7F
.9a2a	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9a2d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.9a2e					AllocUnary:
.9a2e	fa		plx				plx 								; restore stack pos
.9a2f	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger		; get bytes required.
.9a32	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.9a35	da		phx				phx 								; save X/Y
.9a36	5a		phy				phy
.9a37	8a		txa				txa 								; copy X into Y
.9a38	a8		tay				tay
.9a39	b9 10 04	lda $0410,y			lda		NSMantissa1,y 				; get size
.9a3c	aa		tax				tax
.9a3d	b9 08 04	lda $0408,y			lda 	NSMantissa0,y
.9a40	20 4d 9a	jsr $9a4d			jsr 	AllocateXABytes 			; allocate memory
.9a43	99 08 04	sta $0408,y			sta 	NSMantissa0,y 				; write address out.
.9a46	8a		txa				txa
.9a47	99 10 04	sta $0410,y			sta 	NSMantissa1,y
.9a4a	7a		ply				ply
.9a4b	fa		plx				plx
.9a4c	60		rts				rts
.9a4d					AllocateXABytes:
.9a4d	5a		phy				phy
.9a4e	ac 8c 04	ldy $048c			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.9a51	84 36		sty $36				sty 	zTemp0
.9a53	5a		phy				phy
.9a54	ac 8d 04	ldy $048d			ldy 	lowMemPtr+1
.9a57	84 37		sty $37				sty 	zTemp0+1
.9a59	5a		phy				phy
.9a5a	18		clc				clc 								; add to low memory pointer
.9a5b	6d 8c 04	adc $048c			adc 	lowMemPtr
.9a5e	8d 8c 04	sta $048c			sta 	lowMemPtr
.9a61	8a		txa				txa
.9a62	6d 8d 04	adc $048d			adc 	lowMemPtr+1
.9a65	8d 8d 04	sta $048d			sta 	lowMemPtr+1
.9a68	b0 2f		bcs $9a99			bcs 	CISSMemory
.9a6a	20 8b 9a	jsr $9a8b			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.9a6d					_ClearMemory:
.9a6d	ad 8c 04	lda $048c			lda 	lowMemPtr 					; cleared all memory allocated
.9a70	c5 36		cmp $36				cmp 	zTemp0
.9a72	d0 07		bne $9a7b			bne 	_CMClearNext
.9a74	ad 8d 04	lda $048d			lda 	lowMemPtr+1
.9a77	c5 37		cmp $37				cmp 	zTemp0+1
.9a79	f0 0c		beq $9a87			beq 	_CMExit
.9a7b					_CMClearNext:
.9a7b	a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.9a7d	92 36		sta ($36)			sta 	(zTemp0)
.9a7f	e6 36		inc $36				inc 	zTemp0
.9a81	d0 ea		bne $9a6d			bne 	_ClearMemory
.9a83	e6 37		inc $37				inc		zTemp0+1
.9a85	80 e6		bra $9a6d			bra 	_ClearMemory
.9a87					_CMExit:
.9a87	fa		plx				plx
.9a88	68		pla				pla
.9a89	7a		ply				ply
.9a8a	60		rts				rts
.9a8b					CheckIdentifierStringSpace:
.9a8b	48		pha				pha
.9a8c	ad 8d 04	lda $048d			lda 	lowMemPtr+1 				; get low memory pointer
.9a8f	18		clc				clc
.9a90	69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.9a92	cd 8f 04	cmp $048f			cmp 	StringMemory+1 				; is it >= StringMemory
.9a95	b0 02		bcs $9a99			bcs 	CISSMemory
.9a97	68		pla				pla
.9a98	60		rts				rts
.9a99					CISSMemory:
.9a99	a9 06		lda #$06		lda	#6
.9a9b	4c ff 8d	jmp $8dff		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.9a9e					AscUnary:
.9a9e	fa		plx				plx 								; restore stack pos
.9a9f	20 f6 9d	jsr $9df6			jsr 	EvaluateString 				; get a string
.9aa2	b2 36		lda ($36)			lda 	(zTemp0)					; get/return firs character
.9aa4	20 c4 9e	jsr $9ec4			jsr 	NSMSetByte
.9aa7	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.9aaa	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.9aab					FracUnary:
.9aab	fa		plx				plx 								; restore stack pos
.9aac	20 eb 9d	jsr $9deb			jsr 	EvaluateNumber 				; get a float or int
.9aaf	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.9ab2	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9ab5	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9ab7	f0 04		beq $9abd			beq 	_IUZero
.9ab9	20 e1 94	jsr $94e1			jsr 	FloatFractionalPart
.9abc	60		rts				rts
.9abd					_IUZero:
.9abd	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero
.9ac0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.9ac1					IntUnary:
.9ac1	fa		plx				plx 								; restore stack pos
.9ac2	20 eb 9d	jsr $9deb			jsr 	EvaluateNumber 				; get a float or int
.9ac5	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.9ac8	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9acb	29 08		and #$08			and 	#NSTFloat 					; check it is a float
.9acd	f0 03		beq $9ad2			beq 	_IUExit
.9acf	20 44 95	jsr $9544			jsr 	FloatIntegerPart
.9ad2					_IUExit:
.9ad2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.9ad3					LenUnary:
.9ad3	fa		plx				plx 								; restore stack pos
.9ad4	20 f6 9d	jsr $9df6			jsr 	EvaluateString 				; get a string
.9ad7	5a		phy				phy
.9ad8	a0 00		ldy #$00			ldy 	#0 							; find length
.9ada					_LenFind:
.9ada	b1 36		lda ($36),y			lda 	(zTemp0),y
.9adc	f0 06		beq $9ae4			beq 	_LenExit
.9ade	c8		iny				iny
.9adf	d0 f9		bne $9ada			bne 	_LenFind
.9ae1	4c 51 a0	jmp $a051			jmp 	RangeError 					; string > 255
.9ae4					_LenExit:
.9ae4	98		tya				tya
.9ae5	20 c4 9e	jsr $9ec4			jsr 	NSMSetByte
.9ae8	7a		ply				ply
.9ae9	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.9aec	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.9aed					Unary_Min:
.9aed	a9 01		lda #$01			lda 	#1
.9aef	80 02		bra $9af3			bra 	UnaryMinMaxMain
.9af1					Unary_Max:
.9af1	a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.9af3					UnaryMinMaxMain:
.9af3	fa		plx				plx 								; get index on number stack
.9af4	48		pha				pha 								; save comparator
.9af5	20 e2 9d	jsr $9de2			jsr 	EvaluateValue 				; get the first value.
.9af8					_UMMMLoop:
.9af8	b1 30		lda ($30),y			lda 	(codePtr),y
.9afa	c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.9afc	f0 22		beq $9b20			beq 	_UMMMDone
.9afe	20 ee 8d	jsr $8dee			jsr 	CheckComma 					; must be a comma
.9b01	e8		inx				inx
.9b02	20 e2 9d	jsr $9de2			jsr 	EvaluateValue
.9b05	ca		dex				dex
.9b06	20 99 9e	jsr $9e99			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.9b09	e8		inx				inx
.9b0a	20 99 9e	jsr $9e99			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.9b0d	e8		inx				inx
.9b0e	20 b7 8e	jsr $8eb7			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.9b11	ca		dex				dex
.9b12	ca		dex				dex
.9b13	85 36		sta $36				sta 	zTemp0 						; save required result
.9b15	68		pla				pla 								; get and save comparator
.9b16	48		pha				pha
.9b17	c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.9b19	d0 dd		bne $9af8			bne 	_UMMMLoop
.9b1b	20 23 9b	jsr $9b23			jsr 	ExpCopyAboveDown 			; copy next up slot down
.9b1e	80 d8		bra $9af8			bra 	_UMMMLoop
.9b20					_UMMMDone:
.9b20	68		pla				pla 								; throw the comparator
.9b21	c8		iny				iny 								; skip )
.9b22	60		rts				rts
.9b23					ExpCopyAboveDown:
.9b23	bd 01 04	lda $0401,x			lda 	NSStatus+1,x
.9b26	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9b29	bd 29 04	lda $0429,x			lda 	NSExponent+1,x
.9b2c	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9b2f	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x
.9b32	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9b35	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.9b38	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9b3b	bd 19 04	lda $0419,x			lda 	NSMantissa2+1,x
.9b3e	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9b41	bd 21 04	lda $0421,x			lda 	NSMantissa3+1,x
.9b44	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9b47	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.9b48					Unary_Not:
.9b48	fa		plx				plx
.9b49	20 0e 9e	jsr $9e0e			jsr 	EvaluateInteger 			; get integer
.9b4c	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.9b4f	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; zero mantissa ?
.9b52	f0 04		beq $9b58			beq 	_NotZero
.9b54	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero
.9b57	60		rts				rts
.9b58					_NotZero:
.9b58	4c 6c 8e	jmp $8e6c			jmp 	ReturnTrue
.9b5b					_UNBad:
.9b5b	4c 5b a0	jmp $a05b			jmp 	ArgumentError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/rnd.asm

.9b5e					Unary_Random:
.9b5e	fa		plx				plx
.9b5f	20 dd 9b	jsr $9bdd			jsr 	Random32Bit 				; get a random number
.9b62	20 c2 9b	jsr $9bc2			jsr 	URCopyToMantissa  			; put in mantissa
.9b65	b1 30		lda ($30),y			lda 	(codePtr),y
.9b67	c9 29		cmp #$29			cmp 	#KWD_RPAREN
.9b69	f0 08		beq $9b73			beq 	_URNoModulus
.9b6b	e8		inx				inx
.9b6c	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.9b6f	ca		dex				dex
.9b70	20 db 8f	jsr $8fdb			jsr 	IntegerModulusNoCheck 		; calculate modulus
.9b73					_URNoModulus:
.9b73	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; make it an integer positive
.9b76	9e 28 04	stz $0428,x			stz 	NSExponent,x
.9b79	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.9b7c	60		rts				rts
.9b7d					Unary_Rnd:
.9b7d	fa		plx				plx
.9b7e	20 eb 9d	jsr $9deb			jsr 	EvaluateNumber 				; number to use.
.9b81	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket 			; closing bracket
.9b84	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; if zero, then don't generate a new number
.9b87	f0 2b		beq $9bb4			beq 	_URCopySeed
.9b89	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.9b8c	10 23		bpl $9bb1			bpl 	_URDontSeed
.9b8e	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.9b91	49 17		eor #$17			eor 	#$17
.9b93	8d 88 04	sta $0488			sta 	RandomSeed+0
.9b96	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9b99	49 a5		eor #$a5			eor 	#$A5
.9b9b	8d 89 04	sta $0489			sta 	RandomSeed+1
.9b9e	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9ba1	49 c2		eor #$c2			eor 	#$C2
.9ba3	8d 8a 04	sta $048a			sta 	RandomSeed+2
.9ba6	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9ba9	49 9d		eor #$9d			eor 	#$9D
.9bab	8d 8b 04	sta $048b			sta 	RandomSeed+3
.9bae	20 dd 9b	jsr $9bdd			jsr 	Random32Bit
.9bb1					_URDontSeed:
.9bb1	20 dd 9b	jsr $9bdd			jsr 	Random32Bit 				; generate a number.
.9bb4					_URCopySeed:
.9bb4	20 c2 9b	jsr $9bc2			jsr 	URCopyToMantissa 			; copy into mantissa
.9bb7	a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.9bb9	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9bbc	a9 08		lda #$08			lda 	#NSTFloat
.9bbe	9d 00 04	sta $0400,x			sta 	NSStatus,x 					; positive.
.9bc1	60		rts				rts
.9bc2					URCopyToMantissa:
.9bc2	ad 88 04	lda $0488			lda 	RandomSeed+0
.9bc5	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9bc8	ad 89 04	lda $0489			lda 	RandomSeed+1
.9bcb	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9bce	ad 8a 04	lda $048a			lda 	RandomSeed+2
.9bd1	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9bd4	ad 8b 04	lda $048b			lda 	RandomSeed+3
.9bd7	29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.9bd9	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9bdc	60		rts				rts
.9bdd					Random32Bit:
.9bdd	5a		phy				phy
.9bde	a0 07		ldy #$07			ldy 	#7 							; do it 7 times
.9be0	ad 88 04	lda $0488			lda 	RandomSeed+0 				; check the seed isn't zero
.9be3	d0 03		bne $9be8			bne 	_Random1
.9be5	a8		tay				tay 								; if so do it 256 times
.9be6	a9 aa		lda #$aa			lda		#$AA 						; and use this to seed the seed....
.9be8					_Random1:
.9be8	0a		asl a				asl 	a 							; LSFR RNG
.9be9	2e 89 04	rol $0489			rol 	RandomSeed+1
.9bec	2e 8a 04	rol $048a			rol 	RandomSeed+2
.9bef	2e 8b 04	rol $048b			rol 	RandomSeed+3
.9bf2	90 02		bcc $9bf6			bcc 	_Random2
.9bf4	49 c5		eor #$c5			eor 	#$C5
.9bf6					_Random2:
.9bf6	88		dey				dey
.9bf7	d0 ef		bne $9be8			bne 	_Random1
.9bf9	8d 88 04	sta $0488			sta 	RandomSeed+0
.9bfc	7a		ply				ply
.9bfd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.9bfe					SgnUnary:
.9bfe	fa		plx				plx 								; restore stack pos
.9bff	20 eb 9d	jsr $9deb			jsr 	EvaluateNumber 				; get a float or int
.9c02	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.9c05	20 f2 9e	jsr $9ef2			jsr 	NSMIsZero 					; if zero
.9c08	f0 10		beq $9c1a			beq 	_SGZero  					; return Int Zero
.9c0a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; get status w/sign
.9c0d	48		pha				pha
.9c0e	a9 01		lda #$01			lda 	#1 							; set to 1
.9c10	20 c4 9e	jsr $9ec4			jsr 	NSMSetByte
.9c13	68		pla				pla
.9c14	29 80		and #$80			and		#$80 						; copy the sign byte out
.9c16	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9c19	60		rts				rts
.9c1a	20 c2 9e	jsr $9ec2	_SGZero:jsr 	NSMSetZero
.9c1d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.9c1e					ValUnary:
.9c1e	fa		plx				plx 								; restore stack pos
.9c1f	20 34 9c	jsr $9c34			jsr 	ValMainCode 				; do the main val() code
.9c22	b0 01		bcs $9c25			bcs 	_VUError 					; couldn't convert
.9c24	60		rts				rts
.9c25					_VUError:
.9c25	4c 56 a0	jmp $a056			jmp 	TypeError
.9c28					IsValUnary:
.9c28	fa		plx				plx 								; restore stack pos
.9c29	20 34 9c	jsr $9c34			jsr 	ValMainCode 				; do the main val() code
.9c2c	b0 03		bcs $9c31			bcs 	_VUBad
.9c2e	4c 6c 8e	jmp $8e6c			jmp 	ReturnTrue
.9c31					_VUBad:
.9c31	4c 78 8e	jmp $8e78			jmp 	ReturnFalse
.9c34					ValMainCode:
.9c34	20 f6 9d	jsr $9df6			jsr 	EvaluateString 				; get a string
.9c37	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket 			; check right bracket present
.9c3a					ValEvaluateZTemp0:
.9c3a	5a		phy				phy
.9c3b	b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.9c3d	f0 17		beq $9c56			beq 	_VMCFail2
.9c3f	a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.9c41	48		pha				pha 								; save first character
.9c42	c9 2d		cmp #$2d			cmp 	#"-"		 				; is it -
.9c44	d0 01		bne $9c47			bne 	_VMCStart
.9c46	c8		iny				iny 								; skip over -
.9c47					_VMCStart:
.9c47	38		sec				sec 								; initialise first time round.
.9c48					_VMCNext:
.9c48	c8		iny				iny 								; pre-increment
.9c49	b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character
.9c4b	f0 0c		beq $9c59			beq 	_VMCSuccess 				; successful.
.9c4d	20 6a 97	jsr $976a			jsr 	EncodeNumber 				; send it to the number-builder
.9c50	90 03		bcc $9c55			bcc 	_VMCFail 					; if failed, give up.
.9c52	18		clc				clc 								; next time round, countinue
.9c53	80 f3		bra $9c48			bra 	_VMCNext
.9c55					_VMCFail:
.9c55	68		pla				pla
.9c56					_VMCFail2:
.9c56	7a		ply				ply
.9c57	38		sec				sec
.9c58	60		rts				rts
.9c59					_VMCSuccess:
.9c59	a9 00		lda #$00			lda 	#0 							; construct final
.9c5b	20 6a 97	jsr $976a			jsr 	EncodeNumber
.9c5e	68		pla				pla
.9c5f	c9 2d		cmp #$2d			cmp 	#"-"
.9c61	d0 03		bne $9c66			bne 	_VMCNotNegative
.9c63	20 6e 9e	jsr $9e6e			jsr		NSMNegate
.9c66					_VMCNotNegative:
.9c66	7a		ply				ply
.9c67	18		clc				clc
.9c68	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.9c69					ChrUnary:
.9c69	fa		plx				plx 								; restore stack pos
.9c6a	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger			; get value
.9c6d	48		pha				pha
.9c6e	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.9c71	a9 01		lda #$01			lda 	#1 							; allocate space for one char
.9c73	20 3f a8	jsr $a83f			jsr 	StringTempAllocate
.9c76	68		pla				pla 								; write number to it
.9c77	20 7d a8	jsr $a87d			jsr 	StringTempWrite
.9c7a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.9c7b					SpcUnary:
.9c7b	fa		plx				plx 								; restore stack pos
.9c7c	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger			; get value
.9c7f	5a		phy				phy
.9c80	48		pha				pha 								; save count
.9c81	20 3f a8	jsr $a83f			jsr 	StringTempAllocate
.9c84	7a		ply				ply 								; to do count in Y
.9c85					_SpcLoop:
.9c85	c0 00		cpy #$00			cpy 	#0
.9c87	f0 08		beq $9c91			beq 	_SpcExit
.9c89	a9 20		lda #$20			lda 	#32
.9c8b	20 7d a8	jsr $a87d			jsr 	StringTempWrite
.9c8e	88		dey				dey
.9c8f	80 f4		bra $9c85			bra 	_SPCLoop
.9c91					_SpcExit:
.9c91	7a		ply				ply
.9c92	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.9c95	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.9c96					Unary_Str:
.9c96	fa		plx				plx
.9c97	20 eb 9d	jsr $9deb			jsr 	EvaluateNumber  			; get number
.9c9a	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket 			; closing bracket
.9c9d	a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.9c9f	20 b8 9c	jsr $9cb8			jsr 	ConvertNumberToString 		; do the conversion.
.9ca2	a9 21		lda #$21			lda		#33 						; create buffer
.9ca4	20 3f a8	jsr $a83f			jsr 	StringTempAllocate 			; allocate memory
.9ca7	da		phx				phx
.9ca8	a2 00		ldx #$00			ldx 	#0
.9caa					_USCopy:
.9caa	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9cad	20 7d a8	jsr $a87d			jsr 	StringTempWrite
.9cb0	e8		inx				inx
.9cb1	bd 1c 06	lda $061c,x			lda 	DecimalBuffer,x
.9cb4	d0 f4		bne $9caa			bne 	_USCopy
.9cb6	fa		plx				plx
.9cb7	60		rts				rts
.9cb8					ConvertNumberToString:
.9cb8	5a		phy				phy 								; save code position
.9cb9	8d 94 04	sta $0494			sta 	DecimalPlaces	 			; save number of DPs.
.9cbc	9c 95 04	stz $0495			stz 	dbOffset 					; offset into decimal buffer = start.
.9cbf	bd 00 04	lda $0400,x			lda 	NSStatus,x  				; is it -ve.
.9cc2	10 0a		bpl $9cce			bpl 	_CNTSNotNegative
.9cc4	29 7f		and #$7f			and 	#$7F 						; make +ve
.9cc6	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9cc9	a9 2d		lda #$2d			lda 	#"-"
.9ccb	20 34 9d	jsr $9d34			jsr 	WriteDecimalBuffer
.9cce					_CNTSNotNegative:
.9cce	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check if decimal
.9cd1	f0 15		beq $9ce8			beq 	_CNTSNotFloat
.9cd3	e8		inx				inx 								; round up
.9cd4	a9 01		lda #$01			lda 	#1
.9cd6	20 c4 9e	jsr $9ec4			jsr 	NSMSetByte
.9cd9	ca		dex				dex
.9cda	bd 28 04	lda $0428,x			lda		NSExponent,x
.9cdd	9d 29 04	sta $0429,x			sta 	NSExponent+1,x
.9ce0	a9 08		lda #$08			lda 	#NSTFloat
.9ce2	9d 01 04	sta $0401,x			sta 	NSStatus+1,x
.9ce5	20 fb 93	jsr $93fb			jsr 	FloatAdd
.9ce8					_CNTSNotFloat:
.9ce8	20 16 9d	jsr $9d16			jsr 	MakePlusTwoString
.9ceb	20 e1 94	jsr $94e1			jsr 	FloatFractionalPart 		; get the fractional part
.9cee	20 a5 95	jsr $95a5			jsr 	NSNormalise					; normalise , exit if zero
.9cf1	f0 21		beq $9d14			beq 	_CNTSExit
.9cf3	a9 2e		lda #$2e			lda 	#"."
.9cf5	20 34 9d	jsr $9d34			jsr 	WriteDecimalBuffer 			; write decimal place
.9cf8					_CNTSDecimal:
.9cf8	ce 94 04	dec $0494			dec 	DecimalPlaces 				; done all the decimals
.9cfb	30 17		bmi $9d14			bmi 	_CNTSExit
.9cfd	e8		inx				inx 								; x 10.0
.9cfe	a9 0a		lda #$0a			lda 	#10
.9d00	20 c4 9e	jsr $9ec4			jsr 	NSMSetByte
.9d03	a9 08		lda #$08			lda 	#NSTFloat
.9d05	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9d08	ca		dex				dex
.9d09	20 6e 95	jsr $956e			jsr 	FloatMultiply
.9d0c	20 16 9d	jsr $9d16			jsr 	MakePlusTwoString
.9d0f	20 e1 94	jsr $94e1			jsr 	FloatFractionalPart 		; get the fractional part
.9d12	80 e4		bra $9cf8			bra 	_CNTSDecimal 				; keep going.
.9d14					_CNTSExit:
.9d14	7a		ply				ply
.9d15	60		rts				rts
.9d16					MakePlusTwoString:
.9d16	da		phx				phx
.9d17	20 99 9e	jsr $9e99			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.9d1a	e8		inx				inx 								; access it
.9d1b	e8		inx				inx
.9d1c	20 44 95	jsr $9544			jsr 	FloatIntegerPart 			; make it an integer
.9d1f	a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.9d21	20 26 93	jsr $9326			jsr 	ConvertInt32
.9d24	a2 00		ldx #$00			ldx	 	#0
.9d26					_MPTSCopy:
.9d26	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d29	20 34 9d	jsr $9d34			jsr 	WriteDecimalBuffer
.9d2c	e8		inx				inx
.9d2d	bd fa 05	lda $05fa,x			lda 	NumberBuffer,x
.9d30	d0 f4		bne $9d26			bne 	_MPTSCopy
.9d32	fa		plx				plx
.9d33	60		rts				rts
.9d34					WriteDecimalBuffer:
.9d34	da		phx				phx
.9d35	ae 95 04	ldx $0495			ldx 	dbOffset
.9d38	9d 1c 06	sta $061c,x			sta 	DecimalBuffer,x
.9d3b	9e 1d 06	stz $061d,x			stz 	DecimalBuffer+1,x
.9d3e	ee 95 04	inc $0495			inc 	dbOffset
.9d41	fa		plx				plx
.9d42	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.9d43					Unary_Left:
.9d43	fa		plx				plx
.9d44	18		clc				clc 								; only one parameter
.9d45	20 ba 9d	jsr $9dba			jsr 	SubstringInitial 			; set up.
.9d48	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.9d4b	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d4e	9e 09 04	stz $0409,x			stz 	NSMantissa0+1,x 			; Start is zero.
.9d51	80 2c		bra $9d7f			bra 	SubstringMain
.9d53					Unary_Right:
.9d53	fa		plx				plx
.9d54	18		clc				clc 								; only one parameter
.9d55	20 ba 9d	jsr $9dba			jsr 	SubstringInitial 			; set up.
.9d58	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; length => param 2
.9d5b	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9d5e	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; total length
.9d61	fd 09 04	sbc $0409,x			sbc 	NSMantissa0+1,x 			; length - required.
.9d64	b0 02		bcs $9d68			bcs 	_URNotUnderflow
.9d66	a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.9d68					_URNotUnderFlow:
.9d68	9d 09 04	sta $0409,x			sta 	NSMantissa0+1,x 			; this is the start position
.9d6b	80 12		bra $9d7f			bra 	SubStringMain
.9d6d					Unary_Mid:
.9d6d	fa		plx				plx
.9d6e	38		sec				sec 								; two parameters
.9d6f	20 ba 9d	jsr $9dba			jsr 	SubstringInitial 			; set up.
.9d72	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.9d75	f0 05		beq $9d7c			beq 	_UMError
.9d77	de 09 04	dec $0409,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.9d7a	80 03		bra $9d7f			bra 	SubStringMain
.9d7c					_UMError:
.9d7c	4c 5b a0	jmp $a05b			jmp 	ArgumentError
.9d7f					SubStringMain:
.9d7f	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.9d82	dd 28 04	cmp $0428,x			cmp 	NSExponent,x
.9d85	b0 2d		bcs $9db4			bcs 	_SSMNull 					; if so, return an empty string.
.9d87	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.9d8a	f0 28		beq $9db4			beq 	_SSMNull 					; return empty string.
.9d8c	18		clc				clc 								; add the offset +1 to the address and
.9d8d	bd 08 04	lda $0408,x			lda	 	NSMantissa0,x 				; put in zTemp
.9d90	7d 09 04	adc $0409,x			adc 	NSMantissa0+1,x
.9d93	85 36		sta $36				sta 	zTemp0
.9d95	bd 10 04	lda $0410,x			lda	 	NSMantissa1,x
.9d98	69 00		adc #$00			adc 	#0
.9d9a	85 37		sta $37				sta 	zTemp0+1
.9d9c					_SSMNoCarry:
.9d9c	bd 0a 04	lda $040a,x			lda 	NSMantissa0+2,x 			; characters required.
.9d9f	20 3f a8	jsr $a83f			jsr 	StringTempAllocate 			; allocate that many characters
.9da2	5a		phy				phy 								; save Y
.9da3	a0 00		ldy #$00			ldy 	#0 							; start copying in.
.9da5					_SSMCopy:
.9da5	b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.9da7	f0 09		beq $9db2			beq 	_SSMEString 				; no more to copy
.9da9	20 7d a8	jsr $a87d			jsr 	StringTempWrite 			; and write it out.
.9dac	c8		iny				iny
.9dad	de 0a 04	dec $040a,x			dec 	NSMantissa0+2,x
.9db0	d0 f3		bne $9da5			bne 	_SSMCopy
.9db2					_SSMEString:
.9db2	7a		ply				ply
.9db3					_SSMExit:
.9db3	60		rts				rts
.9db4					_SSMNull:
.9db4	a9 00		lda #$00			lda 	#0
.9db6	20 3f a8	jsr $a83f			jsr 	StringTempAllocate
.9db9	60		rts				rts
.9dba					SubstringInitial:
.9dba	da		phx				phx 								; save initial stack position
.9dbb	08		php				php 								; save carry on stack indicating 2 parameters
.9dbc	20 f6 9d	jsr $9df6			jsr 	EvaluateString 				; get a string
.9dbf	5a		phy				phy 								; calculate length to exponent.
.9dc0	a0 ff		ldy #$ff			ldy 	#$FF
.9dc2					_SIFindLength:
.9dc2	c8		iny				iny
.9dc3	b1 36		lda ($36),y			lda 	(zTemp0),y
.9dc5	d0 fb		bne $9dc2			bne 	_SIFindLength
.9dc7	98		tya				tya
.9dc8	9d 28 04	sta $0428,x			sta 	NSExponent,x
.9dcb	7a		ply				ply
.9dcc	e8		inx				inx
.9dcd	20 ee 8d	jsr $8dee			jsr 	CheckComma 					; comma next
.9dd0	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; get next parameter
.9dd3	28		plp				plp 								; is it the last parameter ?
.9dd4	90 07		bcc $9ddd			bcc 	_SSIExit 					; if so, exit.
.9dd6	e8		inx				inx
.9dd7	20 ee 8d	jsr $8dee			jsr 	CheckComma 					; comma next
.9dda	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; get last parameter
.9ddd					_SSIExit:
.9ddd	fa		plx				plx
.9dde	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket 			; check closing bracket
.9de1	60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.9de2					EvaluateValue:
.9de2	48		pha				pha
.9de3	20 ae 93	jsr $93ae			jsr		EvaluateExpression 			; expression
.9de6	20 cc 96	jsr $96cc			jsr 	Dereference					; derefernce it
.9de9	68		pla				pla
.9dea	60		rts				rts
.9deb					EvaluateNumber:
.9deb	20 e2 9d	jsr $9de2			jsr 	EvaluateValue 				; get a value
.9dee	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9df1	29 10		and #$10			and 	#NSBIsString
.9df3	d0 16		bne $9e0b			bne 	HelperTypeError
.9df5	60		rts				rts
.9df6					EvaluateString:
.9df6	20 e2 9d	jsr $9de2			jsr 	EvaluateValue 				; get a value
.9df9	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if string.
.9dfc	29 10		and #$10			and 	#NSBIsString
.9dfe	f0 0b		beq $9e0b			beq 	HelperTypeError
.9e00					CopyAddressToTemp0:
.9e00	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.9e03	85 36		sta $36				sta 	zTemp0
.9e05	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9e08	85 37		sta $37				sta 	zTemp0+1
.9e0a	60		rts				rts
.9e0b					HelperTypeError:
.9e0b	4c 56 a0	jmp $a056			jmp 	TypeError
.9e0e					EvaluateInteger:
.9e0e	20 eb 9d	jsr $9deb			jsr 	EvaluateNumber
.9e11	bd 28 04	lda $0428,x			lda 	NSExponent,x 				; check exponent is zero
.9e14	d0 0a		bne $9e20			bne 	HelperValueError 			; if not, it's a float.
.9e16	60		rts				rts
.9e17					EvaluateUnsignedInteger:
.9e17	20 0e 9e	jsr $9e0e			jsr 	EvaluateInteger 			; check integer is +ve
.9e1a	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e1d	30 01		bmi $9e20			bmi 	HelperValueError
.9e1f	60		rts				rts
.9e20					HelperValueError:
.9e20	4c 5b a0	jmp $a05b			jmp 	ArgumentError
.9e23					Evaluate16BitInteger:
.9e23	20 17 9e	jsr $9e17			jsr	 	EvaluateUnsignedInteger		; get integer
.9e26	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e29	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e2c	d0 f2		bne $9e20			bne 	HelperValueError
.9e2e	60		rts				rts
.9e2f					Evaluate16BitIntegerSigned:
.9e2f	20 0e 9e	jsr $9e0e			jsr	 	EvaluateInteger				; get integer
.9e32	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.9e35	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e38	d0 e6		bne $9e20			bne 	HelperValueError
.9e3a	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; signed ?
.9e3d	10 03		bpl $9e42			bpl 	_EISNotSigned
.9e3f	20 77 9e	jsr $9e77			jsr 	NSMNegateMantissa
.9e42					_EISNotSigned:
.9e42	60		rts				rts
.9e43					Evaluate8BitInteger:
.9e43	20 17 9e	jsr $9e17			jsr	 	EvaluateUnsignedInteger 	; get an integer
.9e46	d0 d8		bne $9e20			bne 	HelperValueError
.9e48	bd 20 04	lda $0420,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.9e4b	1d 18 04	ora $0418,x			ora 	NSMantissa2,x
.9e4e	1d 10 04	ora $0410,x			ora 	NSMantissa1,x
.9e51	d0 cd		bne $9e20			bne 	HelperValueError
.9e53	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e56	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.9e57					Multiply8x8:
.9e57	4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.9e58	85 36		sta $36			  	sta 	zTemp0
.9e5a	86 37		stx $37				stx 	zTemp0+1
.9e5c	a9 00		lda #$00			lda 	#0
.9e5e	a2 08		ldx #$08			ldx 	#8
.9e60					_M88Loop:
.9e60	90 03		bcc $9e65			bcc 	_M88NoAdd
.9e62	18		clc				clc
.9e63	65 37		adc $37				adc 	zTemp0+1
.9e65					_M88NoAdd:
.9e65	6a		ror a				ror 	a
.9e66	66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.9e68	ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.9e69	d0 f5		bne $9e60			bne 	_M88Loop
.9e6b	85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.9e6d	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.9e6e					NSMNegate:
.9e6e	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9e71	49 80		eor #$80			eor 	#NSBIsNegative
.9e73	9d 00 04	sta $0400,x			sta 	NSStatus,x
.9e76	60		rts				rts
.9e77					NSMNegateMantissa:
.9e77	38		sec				sec
.9e78	a9 00		lda #$00			lda 	#0
.9e7a	fd 08 04	sbc $0408,x			sbc 	NSMantissa0,x
.9e7d	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.9e80	a9 00		lda #$00			lda 	#0
.9e82	fd 10 04	sbc $0410,x			sbc 	NSMantissa1,x
.9e85	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.9e88	a9 00		lda #$00			lda 	#0
.9e8a	fd 18 04	sbc $0418,x			sbc 	NSMantissa2,x
.9e8d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.9e90	a9 00		lda #$00			lda 	#0
.9e92	fd 20 04	sbc $0420,x			sbc 	NSMantissa3,x
.9e95	9d 20 04	sta $0420,x			sta 	NSMantissa3,x
.9e98	60		rts				rts
.9e99					NSMShiftUpTwo:
.9e99	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.9e9c	9d 0a 04	sta $040a,x			sta 	NSMantissa0+2,x
.9e9f	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.9ea2	9d 12 04	sta $0412,x			sta 	NSMantissa1+2,x
.9ea5	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.9ea8	9d 1a 04	sta $041a,x			sta 	NSMantissa2+2,x
.9eab	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9eae	9d 22 04	sta $0422,x			sta 	NSMantissa3+2,x
.9eb1	bd 28 04	lda $0428,x			lda 	NSExponent,x
.9eb4	9d 2a 04	sta $042a,x			sta 	NSExponent+2,x
.9eb7	bd 00 04	lda $0400,x			lda 	NSStatus,x
.9eba	9d 02 04	sta $0402,x			sta 	NSStatus+2,x
.9ebd	60		rts				rts
.9ebe					NSMSetZeroMantissaOnly:
.9ebe	a9 00		lda #$00			lda 	#0
.9ec0	80 08		bra $9eca			bra 	NSMSetMantissa
.9ec2					NSMSetZero:
.9ec2	a9 00		lda #$00			lda 	#0
.9ec4					NSMSetByte:
.9ec4	9e 28 04	stz $0428,x			stz 	NSExponent,x 				; zero exponent, as integer.
.9ec7	9e 00 04	stz $0400,x			stz 	NSStatus,x 					; status zero (integer)
.9eca					NSMSetMantissa:
.9eca	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; mantissa
.9ecd	9e 10 04	stz $0410,x			stz 	NSMantissa1,x
.9ed0	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.9ed3	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.9ed6	60		rts				rts
.9ed7					NSMShiftLeft:
.9ed7	18		clc				clc
.9ed8					NSMRotateLeft:
.9ed8	3e 08 04	rol $0408,x			rol 	NSMantissa0,x
.9edb	3e 10 04	rol $0410,x			rol		NSMantissa1,x
.9ede	3e 18 04	rol $0418,x			rol		NSMantissa2,x
.9ee1	3e 20 04	rol $0420,x			rol		NSMantissa3,x
.9ee4	60		rts				rts
.9ee5					NSMShiftRight:
.9ee5	5e 20 04	lsr $0420,x			lsr 	NSMantissa3,x
.9ee8	7e 18 04	ror $0418,x			ror		NSMantissa2,x
.9eeb	7e 10 04	ror $0410,x			ror		NSMantissa1,x
.9eee	7e 08 04	ror $0408,x			ror		NSMantissa0,x
.9ef1	60		rts				rts
.9ef2					NSMIsZero:
.9ef2	bd 20 04	lda $0420,x			lda 	NSMantissa3,x
.9ef5	1d 18 04	ora $0418,x			ora		NSMantissa2,x
.9ef8	1d 10 04	ora $0410,x			ora		NSMantissa1,x
.9efb	1d 08 04	ora $0408,x			ora		NSMantissa0,x
.9efe	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./tick.task/f256/ticktask.asm

.baa7					TickHandler:
.baa7	5a		phy				phy 								; need to preserve Y
.baa8	20 4d ba	jsr $ba4d			jsr 	SNDUpdate 					; update sound
.baab	7a		ply				ply
.baac	60		rts				rts
.062e					LastTick:
>062e							.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.9eff					Assemble_ora:
.9eff	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f02	01					.byte $01
.9f03					Assemble_and:
.9f03	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f06	21					.byte $21
.9f07					Assemble_eor:
.9f07	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f0a	41					.byte $41
.9f0b					Assemble_adc:
.9f0b	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f0e	61					.byte $61
.9f0f					Assemble_sta:
.9f0f	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f12	81					.byte $81
.9f13					Assemble_lda:
.9f13	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f16	a1					.byte $a1
.9f17					Assemble_cmp:
.9f17	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f1a	c1					.byte $c1
.9f1b					Assemble_sbc:
.9f1b	20 6e 80	jsr $806e		jsr	AssembleGroup1
>9f1e	e1					.byte $e1
.9f1f					Assemble_asl:
.9f1f	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f22	02					.byte $02
>9f23	75					.byte $75
.9f24					Assemble_rol:
.9f24	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f27	22					.byte $22
>9f28	75					.byte $75
.9f29					Assemble_lsr:
.9f29	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f2c	42					.byte $42
>9f2d	75					.byte $75
.9f2e					Assemble_ror:
.9f2e	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f31	62					.byte $62
>9f32	75					.byte $75
.9f33					Assemble_stx:
.9f33	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f36	82					.byte $82
>9f37	50					.byte $50
.9f38					Assemble_ldx:
.9f38	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f3b	a2					.byte $a2
>9f3c	d0					.byte $d0
.9f3d					Assemble_dec:
.9f3d	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f40	c2					.byte $c2
>9f41	55					.byte $55
.9f42					Assemble_inc:
.9f42	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f45	e2					.byte $e2
>9f46	55					.byte $55
.9f47					Assemble_stz:
.9f47	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f4a	60					.byte $60
>9f4b	44					.byte $44
.9f4c					Assemble_bit:
.9f4c	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f4f	20					.byte $20
>9f50	55					.byte $55
.9f51					Assemble_sty:
.9f51	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f54	80					.byte $80
>9f55	54					.byte $54
.9f56					Assemble_ldy:
.9f56	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f59	a0					.byte $a0
>9f5a	d5					.byte $d5
.9f5b					Assemble_cpy:
.9f5b	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f5e	c0					.byte $c0
>9f5f	d4					.byte $d4
.9f60					Assemble_cpx:
.9f60	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f63	e0					.byte $e0
>9f64	d0					.byte $d0
.9f65					Assemble_tsb:
.9f65	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f68	00					.byte $00
>9f69	50					.byte $50
.9f6a					Assemble_trb:
.9f6a	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f6d	10					.byte $10
>9f6e	50					.byte $50
.9f6f					Assemble_jsr:
.9f6f	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f72	14					.byte $14
>9f73	10					.byte $10
.9f74					Assemble_jmp:
.9f74	20 75 80	jsr $8075		jsr	AssembleGroup2
>9f77	40					.byte $40
>9f78	10					.byte $10
.9f79					Assemble_bpl:
.9f79	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f7c	10					.byte $10
.9f7d					Assemble_bmi:
.9f7d	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f80	30					.byte $30
.9f81					Assemble_bvc:
.9f81	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f84	50					.byte $50
.9f85					Assemble_bvs:
.9f85	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f88	70					.byte $70
.9f89					Assemble_bcc:
.9f89	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f8c	90					.byte $90
.9f8d					Assemble_bcs:
.9f8d	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f90	b0					.byte $b0
.9f91					Assemble_bne:
.9f91	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f94	d0					.byte $d0
.9f95					Assemble_beq:
.9f95	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f98	f0					.byte $f0
.9f99					Assemble_bra:
.9f99	20 c6 80	jsr $80c6		jsr	AssembleGroup3
>9f9c	80					.byte $80
.9f9d					Assemble_brk:
.9f9d	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fa0	00					.byte $00
.9fa1					Assemble_php:
.9fa1	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fa4	08					.byte $08
.9fa5					Assemble_clc:
.9fa5	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fa8	18					.byte $18
.9fa9					Assemble_plp:
.9fa9	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fac	28					.byte $28
.9fad					Assemble_sec:
.9fad	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fb0	38					.byte $38
.9fb1					Assemble_rti:
.9fb1	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fb4	40					.byte $40
.9fb5					Assemble_pha:
.9fb5	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fb8	48					.byte $48
.9fb9					Assemble_cli:
.9fb9	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fbc	58					.byte $58
.9fbd					Assemble_phy:
.9fbd	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fc0	5a					.byte $5a
.9fc1					Assemble_rts:
.9fc1	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fc4	60					.byte $60
.9fc5					Assemble_pla:
.9fc5	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fc8	68					.byte $68
.9fc9					Assemble_sei:
.9fc9	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fcc	78					.byte $78
.9fcd					Assemble_ply:
.9fcd	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fd0	7a					.byte $7a
.9fd1					Assemble_dey:
.9fd1	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fd4	88					.byte $88
.9fd5					Assemble_txa:
.9fd5	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fd8	8a					.byte $8a
.9fd9					Assemble_tya:
.9fd9	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fdc	98					.byte $98
.9fdd					Assemble_txs:
.9fdd	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fe0	9a					.byte $9a
.9fe1					Assemble_tay:
.9fe1	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fe4	a8					.byte $a8
.9fe5					Assemble_tax:
.9fe5	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fe8	aa					.byte $aa
.9fe9					Assemble_clv:
.9fe9	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9fec	b8					.byte $b8
.9fed					Assemble_tsx:
.9fed	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9ff0	ba					.byte $ba
.9ff1					Assemble_iny:
.9ff1	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9ff4	c8					.byte $c8
.9ff5					Assemble_dex:
.9ff5	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9ff8	ca					.byte $ca
.9ff9					Assemble_cld:
.9ff9	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>9ffc	d8					.byte $d8
.9ffd					Assemble_phx:
.9ffd	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>a000	da					.byte $da
.a001					Assemble_stp:
.a001	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>a004	db					.byte $db
.a005					Assemble_inx:
.a005	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>a008	e8					.byte $e8
.a009					Assemble_nop:
.a009	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>a00c	ea					.byte $ea
.a00d					Assemble_sed:
.a00d	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>a010	f8					.byte $f8
.a011					Assemble_plx:
.a011	20 fc 80	jsr $80fc		jsr	AssembleGroup4
>a014	fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.a015					DecimalScalarTable:
>a015	66 66 66 66				.dword $66666666 ; 0.1
>a019	de					.byte $de
>a01a	1f 85 eb 51				.dword $51eb851f ; 0.01
>a01e	db					.byte $db
>a01f	4c 37 89 41				.dword $4189374c ; 0.001
>a023	d8					.byte $d8
>a024	ac 8b db 68				.dword $68db8bac ; 0.0001
>a028	d4					.byte $d4
>a029	24 d6 e2 53				.dword $53e2d624 ; 1e-05
>a02d	d1					.byte $d1
>a02e	83 de 1b 43				.dword $431bde83 ; 1e-06
>a032	ce					.byte $ce
>a033	6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>a037	ca					.byte $ca
>a038	89 3b e6 55				.dword $55e63b89 ; 1e-08
>a03c	c7					.byte $c7
>a03d	a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>a041	c4					.byte $c4
>a042	67 7f f3 6d				.dword $6df37f67 ; 1e-10
>a046	c0					.byte $c0
>a047	86 ff f5 57				.dword $57f5ff86 ; 1e-11
>a04b	bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.a04c					SyntaxError:
.a04c	a9 02		lda #$02		lda	#2
.a04e	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.a051					RangeError:
.a051	a9 04		lda #$04		lda	#4
.a053	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.a056					TypeError:
.a056	a9 05		lda #$05		lda	#5
.a058	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.a05b					ArgumentError:
.a05b	a9 07		lda #$07		lda	#7
.a05d	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.a060					NotDoneError:
.a060	a9 0c		lda #$0c		lda	#12
.a062	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.a065					ErrorText:
>a065	42 72 65 61 6b 00			.text	"Break",0
>a06b	53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a073	72 72 6f 72 00
>a078	44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a080	20 62 79 20 7a 65 72 6f 00
>a089	4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a091	61 6e 67 65 00
>a096	54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a09e	6d 61 74 63 68 00
>a0a4	4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a0ac	65 6d 6f 72 79 00
>a0b2	49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a0ba	61 72 67 75 6d 65 6e 74 00
>a0c3	53 74 6f 70 00				.text	"Stop",0
>a0c8	53 74 72 69 6e 67 20 74			.text	"String too long",0
>a0d0	6f 6f 20 6c 6f 6e 67 00
>a0d8	41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a0e0	6e 20 66 61 69 6c 65 64 00
>a0e9	4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a0f1	61 74 61 00
>a0f5	55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a0fd	65 6e 74 65 64 00
>a103	4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a10b	6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a117	52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a11f	69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a12c	55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a134	74 68 6f 75 74 20 52 65 70 65 61 74 00
>a141	57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a149	68 6f 75 74 20 57 68 69 6c 65 00
>a154	4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a15c	68 6f 75 74 20 46 6f 72 00
>a165	42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a16d	61 63 6b 20 66 75 6c 6c 00
>a176	4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a17e	75 63 74 75 72 65 00
>a185	45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a18d	77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a19a	41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a1a2	72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a1b0	41 72 72 61 79 20 73 69			.text	"Array size",0
>a1b8	7a 65 00
>a1bb	42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a1c3	79 20 69 6e 64 65 78 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>a1cb	42 75 69 6c 74 20 57 65			.text "Built Wednesday 23-Nov-2022. Build 3578."
>a1d3	64 6e 65 73 64 61 79 20 32 33 2d 4e 6f 76 2d 32
>a1e3	30 32 32 2e 20 42 75 69 6c 64 20 33 35 37 38 2e

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcommand.asm

.a1f3					RectangleCommand:
.a1f3	a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a1f5	80 02		bra $a1f9			bra 	ShapeDrawCmd
.a1f7					CircleCommand:
.a1f7	a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a1f9					ShapeDrawCmd:
.a1f9	20 87 a2	jsr $a287			jsr 	RunGraphicsCommand
.a1fc					ShapeDraw:
.a1fc	0d 30 06	ora $0630			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a1ff	4c 7b a2	jmp $a27b			jmp 	ExecuteGraphicCommand	 	; and complete
.a202					SpriteCommand:
.a202	a2 00		ldx #$00			ldx 	#0
.a204	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; get image number.
.a207	5a		phy				phy
.a208	a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a20a	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a20d	e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a20f	b0 0d		bcs $a21e			bcs 	_SCRange
.a211	a0 ff		ldy #$ff			ldy 	#255
.a213	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a216	a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a218	7a		ply				ply
.a219	20 87 a2	jsr $a287			jsr 	RunGraphicsCommand
.a21c	80 5d		bra $a27b			bra 	ExecuteGraphicCommand
.a21e					_SCRange:
.a21e	4c 51 a0	jmp $a051			jmp 	RangeError
.a221					ImageCommand:
.a221	a2 00		ldx #$00			ldx 	#0
.a223	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; get image number.
.a226	20 87 a2	jsr $a287			jsr 	RunGraphicsCommand
.a229					ImageRunDraw:
.a229	09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a22b	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a22e	ad 36 06	lda $0636			lda 	gxDrawScale
.a231	0a		asl a				asl 	a
.a232	0a		asl a				asl 	a
.a233	0a		asl a				asl 	a
.a234	a8		tay				tay
.a235	a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a237	ae 08 04	ldx $0408			ldx 	NSMantissa0
.a23a	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a23d	60		rts				rts
.a23e					TextCommand:
.a23e	a2 00		ldx #$00			ldx 	#0
.a240	20 f6 9d	jsr $9df6			jsr 	EvaluateString 				; get text
.a243	20 87 a2	jsr $a287			jsr 	RunGraphicsCommand
.a246					TextRunDraw:
.a246	09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a248	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a24b	a0 00		ldy #$00			ldy 	#0
.a24d					_IRDLoop:
.a24d	ad 10 04	lda $0410			lda 	NSMantissa1 				; access character
.a250	85 37		sta $37				sta 	zTemp0+1
.a252	ad 08 04	lda $0408			lda 	NSMantissa0
.a255	85 36		sta $36				sta 	zTemp0
.a257	b1 36		lda ($36),y			lda 	(zTemp0),y
.a259	f0 13		beq $a26e			beq 	_IRDExit
.a25b	5a		phy				phy									; save string pos
.a25c	48		pha				pha 								; save char
.a25d	ad 36 06	lda $0636			lda 	gxDrawScale 				; get scale
.a260	0a		asl a				asl 	a
.a261	0a		asl a				asl 	a
.a262	0a		asl a				asl 	a
.a263	a8		tay				tay
.a264	a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a266	fa		plx				plx 								; char to draw
.a267	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a26a	7a		ply				ply 								; restore string pos
.a26b	c8		iny				iny
.a26c	90 df		bcc $a24d			bcc 	_IRDLoop 					; go back if no error.
.a26e					_IRDExit:
.a26e	60		rts				rts
.a26f					PlotCommand:
.a26f	a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a271	20 87 a2	jsr $a287			jsr 	RunGraphicsCommand
.a274	80 05		bra $a27b			bra 	ExecuteGraphicCommand
.a276					LineCommand:
.a276	a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a278	20 87 a2	jsr $a287			jsr 	RunGraphicsCommand
.a27b					ExecuteGraphicCommand:
.a27b	0d 2f 06	ora $062f			ora 	gxCommandID 				; make a full command
.a27e	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw 				; draw it and exit
.a281	b0 01		bcs $a284			bcs 	_EGCError
.a283	60		rts				rts
.a284					_EGCError:
.a284	4c 4c a0	jmp $a04c			jmp 	SyntaxError
.a287					RunGraphicsCommand:
.a287	8d 2f 06	sta $062f			sta 	gxCommandID					; save TODO graphics command.
.a28a	68		pla				pla 								; pop handler address
.a28b	fa		plx				plx
.a28c	1a		inc a				inc 	a
.a28d	d0 01		bne $a290			bne 	_RGINoCarry
.a28f	e8		inx				inx
.a290					_RGINoCarry:
.a290	8d 34 06	sta $0634			sta 	GXHandler
.a293	8e 35 06	stx $0635			stx 	GXHandler+1
.a296					_RGICommandLoop:
.a296	b1 30		lda ($30),y			lda 	(codePtr),y
.a298	c8		iny				iny
.a299	c9 ce		cmp #$ce			cmp 	#KWD_TO						; is it TO x,y
.a29b	f0 53		beq $a2f0			beq 	_RGI_To
.a29d	c9 ba		cmp #$ba			cmp 	#KWD_HERE 					; do it here.
.a29f	f0 55		beq $a2f6			beq 	_RGI_Here
.a2a1	c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a2a3	f0 3d		beq $a2e2			beq 	_RGI_Exit
.a2a5	c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a2a7	f0 39		beq $a2e2			beq 	_RGI_Exit
.a2a9	c9 c2		cmp #$c2			cmp 	#KWD_OUTLINE 				; solid or outline
.a2ab	f0 3e		beq $a2eb			beq 	_RGI_Frame
.a2ad	c9 ca		cmp #$ca			cmp 	#KWD_SOLID
.a2af	f0 33		beq $a2e4			beq 	_RGI_Solid
.a2b1	c9 ab		cmp #$ab			cmp 	#KWD_BY 					; by offset
.a2b3	f0 4b		beq $a300			beq 	_RGI_By
.a2b5	c9 b6		cmp #$b6			cmp 	#KWD_FROM 					; from
.a2b7	f0 17		beq $a2d0			beq 	_RGI_Move2
.a2b9	c9 b3		cmp #$b3			cmp 	#KWD_DIM 					; dim (set scale)
.a2bb	f0 65		beq $a322			beq 	_RGI_Dim
.a2bd	c9 b1		cmp #$b1			cmp 	#KWD_COLOUR 				; colour or Color
.a2bf	f0 78		beq $a339			beq 	_RGI_Colour
.a2c1	c9 b0		cmp #$b0			cmp 	#KWD_COLOR
.a2c3	f0 74		beq $a339			beq 	_RGI_Colour
.a2c5	ae 2f 06	ldx $062f			ldx 	gxCommandID
.a2c8	e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a2ca	d0 03		bne $a2cf			bne 	_RGI_Move 					; move
.a2cc	4c 63 a3	jmp $a363			jmp		_RGI_SpriteInstructions
.a2cf					_RGI_Move:
.a2cf	88		dey				dey 								; unpick get.
.a2d0					_RGI_Move2:
.a2d0	20 89 a3	jsr $a389			jsr 	GCGetCoordinatePair 		; move to here
.a2d3	20 b0 a3	jsr $a3b0			jsr 	GCCopyPairToStore 			; save
.a2d6	5a		phy				phy
.a2d7	20 a6 a3	jsr $a3a6			jsr 	GCLoadAXY 					; load in
.a2da	09 40		ora #$40			ora 	#GCMD_Move 					; move there
.a2dc	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a2df	7a		ply				ply
.a2e0	80 b4		bra $a296			bra 	_RGICommandLoop 			; and go round
.a2e2					_RGI_Exit:
.a2e2	88		dey				dey 								; unpick : / EOL
.a2e3	60		rts				rts
.a2e4					_RGI_Solid:
.a2e4	a9 02		lda #$02			lda 	#2
.a2e6	8d 30 06	sta $0630			sta 	gxFillSolid
.a2e9	80 ab		bra $a296			bra 	_RGICommandLoop
.a2eb					_RGI_Frame:
.a2eb	9c 30 06	stz $0630			stz 	gxFillSolid
.a2ee	80 a6		bra $a296			bra 	_RGICommandLoop
.a2f0					_RGI_To:
.a2f0	20 89 a3	jsr $a389			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.a2f3	20 b0 a3	jsr $a3b0			jsr 	GCCopyPairToStore
.a2f6					_RGI_Here:
.a2f6	5a		phy				phy
.a2f7	20 a6 a3	jsr $a3a6			jsr 	GCLoadAXY 					; load it into AXY
.a2fa	20 60 a3	jsr $a360			jsr 	_RGICallHandler 			; go do whatever it is.
.a2fd	7a		ply				ply
.a2fe	80 96		bra $a296			bra 	_RGICommandLoop 			; and go round
.a300					_RGI_By:
.a300	20 96 a3	jsr $a396			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.a303	18		clc				clc
.a304	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a307	6d 31 06	adc $0631			adc 	gxxPos
.a30a	8d 31 06	sta $0631			sta 	gxXPos
.a30d	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a310	6d 32 06	adc $0632			adc 	gxxPos+1
.a313	8d 32 06	sta $0632			sta 	gxXPos+1
.a316	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a319	18		clc				clc
.a31a	6d 33 06	adc $0633			adc 	gxYPos
.a31d	8d 33 06	sta $0633			sta 	gxYPos
.a320	80 d4		bra $a2f6			bra 	_RGI_Here
.a322					_RGI_Dim:
.a322	a2 01		ldx #$01			ldx	 	#1
.a324	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger
.a327	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a32a	c9 00		cmp #$00			cmp 	#0
.a32c	f0 2f		beq $a35d			beq 	_RGIRange
.a32e	c9 09		cmp #$09			cmp 	#8+1
.a330	b0 2b		bcs $a35d			bcs		_RGIRange
.a332	3a		dec a				dec 	a
.a333	8d 36 06	sta $0636			sta 	gxDrawScale
.a336	4c 96 a2	jmp $a296			jmp 	_RGICommandLoop
.a339					_RGI_Colour:
.a339	a2 01		ldx #$01			ldx 	#1 							; colour
.a33b	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger
.a33e	a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.a340	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero
.a343	b1 30		lda ($30),y			lda 	(codePtr),y
.a345	c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.a347	d0 04		bne $a34d			bne 	_RGICDefaultMode
.a349	c8		iny				iny
.a34a	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger
.a34d					_RGICDefaultMode:
.a34d	5a		phy				phy
.a34e	a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.a350	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a353	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a356	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a359	7a		ply				ply
.a35a	4c 96 a2	jmp $a296			jmp 	_RGICommandLoop 			; and go round
.a35d					_RGIRange:
.a35d	4c 51 a0	jmp $a051			jmp 	RangeError
.a360					_RGICallHandler:
.a360	6c 34 06	jmp ($0634)			jmp 	(GXHandler)
.a363					_RGI_SpriteInstructions:
.a363	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a365	f0 07		beq $a36e			beq 	_RGISpriteOff
.a367	c9 bb		cmp #$bb			cmp 	#KWD_IMAGE
.a369	f0 13		beq $a37e			beq 	_RGISetImage
.a36b	4c cf a2	jmp $a2cf			jmp 	_RGI_Move
.a36e					_RGISpriteOff:
.a36e	5a		phy				phy
.a36f	a0 01		ldy #$01			ldy 	#1
.a371	a2 00		ldx #$00			ldx 	#0
.a373					_RGIDoCommandLoop:
.a373	a9 10		lda #$10			lda 	#GCMD_SpriteImage
.a375	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a378	7a		ply				ply
.a379	b0 e2		bcs $a35d			bcs 	_RGIRange
.a37b	4c 96 a2	jmp $a296			jmp 	_RGICommandLoop
.a37e					_RGISetImage:
.a37e	a2 01		ldx #$01			ldx 	#1
.a380	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger
.a383	5a		phy				phy
.a384	aa		tax				tax
.a385	a0 00		ldy #$00			ldy 	#0
.a387	80 ea		bra $a373			bra 	_RGIDoCommandLoop
.a389					GCGetCoordinatePair:
.a389	a2 01		ldx #$01			ldx 	#1
.a38b	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger
.a38e	20 ee 8d	jsr $8dee			jsr 	CheckComma
.a391	e8		inx				inx
.a392	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger
.a395	60		rts				rts
.a396					GCSignedCoordinatePair:
.a396	a2 01		ldx #$01			ldx 	#1
.a398	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitIntegerSigned
.a39b	20 ee 8d	jsr $8dee			jsr 	CheckComma
.a39e	e8		inx				inx
.a39f	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitIntegerSigned
.a3a2	60		rts				rts
.a3a3					_GCCPRange:
.a3a3	4c 51 a0	jmp $a051			jmp 	RangeError
.a3a6					GCLoadAXY:
.a3a6	ad 32 06	lda $0632			lda 	gxXPos+1
.a3a9	ae 31 06	ldx $0631			ldx 	gxXPos
.a3ac	ac 33 06	ldy $0633			ldy 	gxYPos
.a3af	60		rts				rts
.a3b0					GCCopyPairToStore:
.a3b0	ad 09 04	lda $0409			lda 	NSMantissa0+1 				; copy it into space.
.a3b3	8d 31 06	sta $0631			sta 	gxXPos
.a3b6	ad 11 04	lda $0411			lda 	NSMantissa1+1
.a3b9	8d 32 06	sta $0632			sta 	gxXPos+1
.a3bc	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a3bf	8d 33 06	sta $0633			sta 	gxYPos
.a3c2	60		rts				rts
.062f					gxCommandID:
>062f							.fill 	1
.0630					gxFillSolid:
>0630							.fill 	1
.0631					gxXPos:
>0631							.fill 	2
.0633					gxYPos:
>0633							.fill 	1
.0634					gxHandler:
>0634							.fill 	2
.0636					gxDrawScale:
>0636							.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gcontrol.asm

.a3c3					BitmapCtrl:
.a3c3	b1 30		lda ($30),y			lda 	(codePtr),y
.a3c5	c8		iny				iny
.a3c6	a2 01		ldx #$01			ldx 	#1
.a3c8	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a3ca	f0 11		beq $a3dd			beq 	BitmapSwitch
.a3cc	ca		dex				dex
.a3cd	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a3cf	f0 0c		beq $a3dd			beq 	BitmapSwitch
.a3d1	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; get the colour
.a3d4	5a		phy				phy
.a3d5	aa		tax				tax
.a3d6	a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.a3d8	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a3db	7a		ply				ply
.a3dc	60		rts				rts
.a3dd					BitmapSwitch:
.a3dd	5a		phy				phy
.a3de	a0 00		ldy #$00			ldy 	#0 							; gfx 1,on/off,0
.a3e0	a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.a3e2	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a3e5	a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.a3e7	a0 00		ldy #$00			ldy 	#0
.a3e9	a2 ff		ldx #$ff			ldx 	#$FF
.a3eb	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a3ee	9c 30 06	stz $0630			stz 	gxFillSolid
.a3f1	9c 31 06	stz $0631			stz 	gxXPos
.a3f4	9c 32 06	stz $0632			stz 	gxXPos+1
.a3f7	9c 33 06	stz $0633			stz 	gxYPos
.a3fa	9c 36 06	stz $0636			stz 	gxDrawScale
.a3fd	a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.a3ff	a2 00		ldx #$00			ldx 	#0
.a401	a0 00		ldy #$00			ldy 	#0
.a403	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a406	7a		ply				ply
.a407	60		rts				rts
.a408					SpritesCtrl:
.a408	b1 30		lda ($30),y			lda 	(codePtr),y
.a40a	c8		iny				iny
.a40b	a2 01		ldx #$01			ldx 	#1
.a40d	c9 c1		cmp #$c1			cmp 	#KWD_ON
.a40f	f0 08		beq $a419			beq 	SpriteSwitch
.a411	ca		dex				dex
.a412	c9 c0		cmp #$c0			cmp 	#KWD_OFF
.a414	f0 03		beq $a419			beq 	SpriteSwitch
.a416	4c 4c a0	jmp $a04c			jmp 	SyntaxError
.a419					SpriteSwitch:
.a419	5a		phy				phy
.a41a	a0 00		ldy #$00			ldy 	#0 							; gfx 2,on/off,0
.a41c	a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.a41e	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a421	7a		ply				ply
.a422	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/gfx.asm

.a423					GfxCommand:
.a423	a2 00		ldx #$00			ldx 	#0
.a425	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; command
.a428	20 ee 8d	jsr $8dee			jsr 	CheckComma
.a42b	e8		inx				inx
.a42c	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger 		; X
.a42f	20 ee 8d	jsr $8dee			jsr 	CheckComma
.a432	e8		inx				inx
.a433	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; Y
.a436	ad 11 04	lda $0411			lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.a439	4a		lsr a				lsr 	a
.a43a	d0 16		bne $a452			bne 	_GfxError
.a43c	2e 08 04	rol $0408			rol 	NSMantissa0 				; rotate into command
.a43f	b0 11		bcs $a452			bcs 	_GfxError 					; bit 7 should have been zero
.a441	5a		phy				phy 								; save pos
.a442	ad 08 04	lda $0408			lda 	NSMantissa0 				; do the command
.a445	ae 09 04	ldx $0409			ldx 	NSMantissa0+1
.a448	ac 0a 04	ldy $040a			ldy 	NSMantissa0+2
.a44b	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw
.a44e	b0 02		bcs $a452			bcs 	_GfxError
.a450	7a		ply				ply 								; restore pos and exit.
.a451	60		rts				rts
.a452					_GfxError:
.a452	4c 51 a0	jmp $a051			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/hit.asm

.a455					UnaryHit:
.a455	fa		plx				plx
.a456	a9 36		lda #$36			lda 	#zTemp0
.a458	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; get sprite number 0
.a45b	20 ee 8d	jsr $8dee			jsr 	CheckComma
.a45e	e8		inx				inx
.a45f	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; get sprite number 1
.a462	20 e6 8d	jsr $8de6			jsr		CheckRightBracket
.a465	ca		dex				dex 								; fix back up again.
.a466	da		phx				phx 								; save X/Y
.a467	5a		phy				phy
.a468	bc 09 04	ldy $0409,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.a46b	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a46e	aa		tax				tax
.a46f	a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.a471	20 8c ab	jsr $ab8c			jsr 	GXGraphicDraw 				; calculate result
.a474	1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.a475	7a		ply				ply 								; restore XY
.a476	fa		plx				plx
.a477	20 c4 9e	jsr $9ec4			jsr 	NSMSetByte 					; return the hit result
.a47a	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/graphics/palette.asm

.a47b					PaletteCommand:
.a47b	a2 00		ldx #$00			ldx 	#0
.a47d	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; colour
.a480	20 ee 8d	jsr $8dee			jsr 	CheckComma
.a483	e8		inx				inx
.a484	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger 		; r
.a487	20 ee 8d	jsr $8dee			jsr 	CheckComma
.a48a	e8		inx				inx
.a48b	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; g
.a48e	20 ee 8d	jsr $8dee			jsr 	CheckComma
.a491	e8		inx				inx
.a492	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; b
.a495	ad 08 04	lda $0408			lda 	NSMantissa0 				; get colour #
.a498	85 36		sta $36				sta 	zTemp0
.a49a	a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.a49c	85 37		sta $37				sta 	zTemp0+1
.a49e	06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.a4a0	26 37		rol $37				rol	 	zTemp0+1
.a4a2	06 36		asl $36				asl 	zTemp0
.a4a4	26 37		rol $37				rol	 	zTemp0+1
.a4a6	a9 01		lda #$01			lda 	#1 							; I/O Page 2
.a4a8	85 01		sta $01				sta 	1
.a4aa	5a		phy				phy
.a4ab	ad 0b 04	lda $040b			lda 	NSMantissa0+3 				; fix to r,g,b
.a4ae	92 36		sta ($36)			sta 	(zTemp0)
.a4b0	a0 01		ldy #$01			ldy 	#1
.a4b2	ad 0a 04	lda $040a			lda 	NSMantissa0+2
.a4b5	91 36		sta ($36),y			sta 	(zTemp0),y
.a4b7	ad 09 04	lda $0409			lda 	NSMantissa0+1
.a4ba	c8		iny				iny
.a4bb	91 36		sta ($36),y			sta 	(zTemp0),y
.a4bd	7a		ply				ply
.a4be	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/event.asm

.a4bf					UnaryEvent:
.a4bf	fa		plx				plx
.a4c0	20 79 a5	jsr $a579			jsr 	TimerToStackX 				; timer in +0
.a4c3	e8		inx				inx  								; put reference into +1
.a4c4	20 88 98	jsr $9888			jsr 	EvaluateTerm
.a4c7	bd 00 04	lda $0400,x			lda 	NSStatus,x 					; check if is integer reference
.a4ca	c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.a4cc	d0 57		bne $a525			bne 	_UEType
.a4ce	e8		inx				inx 								; put the step in +2
.a4cf	20 ee 8d	jsr $8dee			jsr 	CheckComma
.a4d2	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger
.a4d5	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.a4d8	ca		dex				dex
.a4d9	ca		dex				dex
.a4da	bd 09 04	lda $0409,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.a4dd	85 36		sta $36				sta 	zTemp0
.a4df	bd 11 04	lda $0411,x			lda 	NSMantissa1+1,x
.a4e2	85 37		sta $37				sta 	zTemp0+1
.a4e4	5a		phy				phy
.a4e5	a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.a4e7	b1 36		lda ($36),y			lda 	(zTemp0),y
.a4e9	30 36		bmi $a521			bmi 	_UEFalse 					; exit if signed.
.a4eb	a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.a4ed	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a4f0	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.a4f2	c8		iny				iny
.a4f3	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a4f6	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4f8	c8		iny				iny
.a4f9	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a4fc	f1 36		sbc ($36),y			sbc		(zTemp0),y
.a4fe	90 21		bcc $a521			bcc 	_UEFalse 					; no, return FALSE.
.a500	18		clc				clc
.a501	a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.a503	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a506	7d 0a 04	adc $040a,x			adc 	NSMantissa0+2,x
.a509	91 36		sta ($36),y			sta 	(zTemp0),y
.a50b	c8		iny				iny
.a50c	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a50f	7d 12 04	adc $0412,x			adc 	NSMantissa1+2,x
.a512	91 36		sta ($36),y			sta 	(zTemp0),y
.a514	c8		iny				iny
.a515	bd 18 04	lda $0418,x			lda 	NSMantissa2,x
.a518	7d 1a 04	adc $041a,x			adc 	NSMantissa2+2,x
.a51b	91 36		sta ($36),y			sta 	(zTemp0),y
.a51d	7a		ply				ply
.a51e	4c 6c 8e	jmp $8e6c			jmp 	ReturnTrue
.a521					_UEFalse:
.a521	7a		ply				ply 								; restore Y
.a522	4c 78 8e	jmp $8e78			jmp 	ReturnFalse 				; and return False
.a525					_UEType:
.a525	4c 56 a0	jmp $a056			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/joy.asm

.a528					UnaryJoyX:
.a528	18		clc				clc
.a529	80 01		bra $a52c			bra 	JoyMain
.a52b					UnaryJoyY:
.a52b	38		sec				sec
.a52c					JoyMain:
.a52c	fa		plx				plx 								; get pos
.a52d	08		php				php 								; save carry (set for Y)
.a52e	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a531	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.a534	20 45 ab	jsr $ab45			jsr 	EXTReadController 			; read the controller.
.a537	28		plp				plp
.a538	90 02		bcc $a53c			bcc 	_JMNoShift 					; if Y then shift bits 3,2 -> 1,0
.a53a	4a		lsr a				lsr 	a
.a53b	4a		lsr a				lsr 	a
.a53c					_JMNoShift:
.a53c	4a		lsr a				lsr 	a 							; if bit 0 set then right/down e.g. +1
.a53d	b0 0a		bcs $a549			bcs 	_JMIsRight
.a53f	4a		lsr a				lsr 	a 							; if bit 1 set then left/up e.g. -1
.a540	b0 04		bcs $a546			bcs 	_JMIsLeft
.a542	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero 					; zero result
.a545	60		rts				rts
.a546					_JMIsLeft:
.a546	4c 6c 8e	jmp $8e6c			jmp 	ReturnTrue
.a549					_JMIsRight:
.a549	a9 01		lda #$01			lda 	#1
.a54b	20 c4 9e	jsr $9ec4			jsr 	NSMSetByte
.a54e	60		rts				rts
.a54f					UnaryJoyB:
.a54f	fa		plx				plx 								; get pos
.a550	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; ignore the parameter
.a553	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.a556	20 45 ab	jsr $ab45			jsr 	EXTReadController 			; read the controller.
.a559	4a		lsr a				lsr 	a
.a55a	4a		lsr a				lsr 	a
.a55b	4a		lsr a				lsr 	a
.a55c	4a		lsr a				lsr 	a
.a55d	29 01		and #$01			and 	#1
.a55f	20 c4 9e	jsr $9ec4			jsr 	NSMSetByte
.a562	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/load.asm

.a563					LoadCommand:
.a563	20 4f 89	jsr $894f			jsr 	NewProgram
.a566	20 e6 82	jsr $82e6			jsr 	BackLoadProgram
.a569	4c 5f 83	jmp $835f			jmp 	WarmStart
.a56c					GoCommand:
.a56c	20 4f 89	jsr $894f			jsr 	NewProgram
.a56f	20 e6 82	jsr $82e6			jsr 	BackLoadProgram
.a572	4c 8e 8a	jmp $8a8e			jmp 	CommandRun

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/hardware/timer.asm

.a575					UnaryTimer:
.a575	fa		plx				plx
.a576	20 e6 8d	jsr $8de6			jsr 	CheckRightBracket
.a579					TimerToStackX:
.a579	20 c2 9e	jsr $9ec2			jsr 	NSMSetZero 					; zero result
.a57c	64 01		stz $01				stz 	1 							; access I/O
.a57e	ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.a581	9d 08 04	sta $0408,x			sta 	NSMantissa0,x
.a584	ad 5a d6	lda $d65a			lda 	$D65A
.a587	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a58a	ad 5b d6	lda $d65b			lda 	$D65B
.a58d	9d 18 04	sta $0418,x			sta 	NSMantissa2,x
.a590	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/delete.asm

.a591					MemoryDeleteLine:
.a591	20 b0 a5	jsr $a5b0			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a594	b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a596	a8		tay				tay
.a597					_MDDLLoop:
.a597	b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a599	92 30		sta ($30)			sta 	(codePtr)
.a59b	a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a59d	c5 3a		cmp $3a				cmp 	zTemp2
.a59f	d0 07		bne $a5a8			bne 	_MDLDLNext
.a5a1	a5 31		lda $31				lda 	codePtr+1
.a5a3	c5 3b		cmp $3b				cmp 	zTemp2+1
.a5a5	d0 01		bne $a5a8			bne 	_MDLDLNext
.a5a7					_MDDLExit:
.a5a7	60		rts				rts
.a5a8					_MDLDLNext:
.a5a8	e6 30		inc $30				inc 	codePtr						; next byte
.a5aa	d0 eb		bne $a597			bne 	_MDDLLoop
.a5ac	e6 31		inc $31				inc 	codePtr+1
.a5ae	80 e7		bra $a597			bra 	_MDDLLoop
.a5b0					IMemoryFindEnd:
.a5b0	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a5b2	85 3a		sta $3a				sta 	0+zTemp2
.a5b4	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a5b6	85 3b		sta $3b				sta 	1+zTemp2
.a5b8					_MDLFELoop:
.a5b8	b2 3a		lda ($3a)			lda 	(zTemp2)
.a5ba	f0 0b		beq $a5c7			beq 	_MDLFEExit
.a5bc	18		clc				clc
.a5bd	65 3a		adc $3a				adc 	zTemp2
.a5bf	85 3a		sta $3a				sta 	zTemp2
.a5c1	90 f5		bcc $a5b8			bcc 	_MDLFELoop
.a5c3	e6 3b		inc $3b				inc 	zTemp2+1
.a5c5	80 f1		bra $a5b8			bra 	_MDLFELoop
.a5c7					_MDLFEExit:
.a5c7	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/insert.asm

.a5c8					MemoryInsertLine:
.a5c8	08		php				php
.a5c9	20 b0 a5	jsr $a5b0			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a5cc	a5 3b		lda $3b				lda 	zTemp2+1 					; space ?
.a5ce	1a		inc a				inc 	a
.a5cf	c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a5d1	b0 36		bcs $a609			bcs 	_MDLIError
.a5d3	28		plp				plp
.a5d4	90 08		bcc $a5de			bcc 	_MDLIFound
.a5d6	a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append.
.a5d8	85 30		sta $30				sta 	codePtr
.a5da	a5 3b		lda $3b				lda 	zTemp2+1
.a5dc	85 31		sta $31				sta 	codePtr+1
.a5de					_MDLIFound:
.a5de	ad a9 04	lda $04a9			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a5e1	a8		tay				tay
.a5e2					_MDLIInsert:
.a5e2	b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case.
.a5e4	91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a5e6	a5 30		lda $30				lda 	codePtr 					; done insert point ?
.a5e8	c5 3a		cmp $3a				cmp 	zTemp2
.a5ea	d0 06		bne $a5f2			bne 	_MDLINext
.a5ec	a5 31		lda $31				lda 	codePtr+1
.a5ee	c5 3b		cmp $3b				cmp 	zTemp2+1
.a5f0	f0 0a		beq $a5fc			beq 	_MDLIHaveSpace
.a5f2					_MDLINext:
.a5f2	a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards
.a5f4	d0 02		bne $a5f8			bne 	_MDLINoBorrow
.a5f6	c6 3b		dec $3b				dec 	zTemp2+1
.a5f8					_MDLINoBorrow:
.a5f8	c6 3a		dec $3a				dec 	zTemp2
.a5fa	80 e6		bra $a5e2			bra 	_MDLIInsert
.a5fc					_MDLIHaveSpace:
.a5fc	ac a9 04	ldy $04a9			ldy 	tokenOffset 				; bytes to copy
.a5ff	88		dey				dey 								; from offset-1 to 0
.a600					_MDLICopy:
.a600	b9 a9 04	lda $04a9,y			lda 	tokenOffset,y
.a603	91 30		sta ($30),y			sta 	(codePtr),y
.a605	88		dey				dey
.a606	10 f8		bpl $a600			bpl 	_MDLICopy
.a608	60		rts				rts
.a609					_MDLIError:
.a609	a9 06		lda #$06		lda	#6
.a60b	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.a60e					MDLAppendLine:
.a60e	86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a610	85 36		sta $36				sta 	zTemp0
.a612	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a614	85 38		sta $38				sta 	0+zTemp1
.a616	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a618	85 39		sta $39				sta 	1+zTemp1
.a61a	b2 38		lda ($38)			lda 	(zTemp1)
.a61c	d0 0a		bne $a628			bne 	_MDLANoInitialise
.a61e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a620	8d 37 06	sta $0637			sta 	0+AppendPointer
.a623	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a625	8d 38 06	sta $0638			sta 	1+AppendPointer
.a628					_MDLANoInitialise:
.a628	18		clc				clc
.a629	ad 37 06	lda $0637			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a62c	85 38		sta $38				sta 	zTemp1
.a62e	72 36		adc ($36)			adc 	(zTemp0)
.a630	8d 37 06	sta $0637			sta 	AppendPointer
.a633	ad 38 06	lda $0638			lda 	AppendPointer+1
.a636	85 39		sta $39				sta 	zTemp1+1
.a638	69 00		adc #$00			adc 	#0
.a63a	8d 38 06	sta $0638			sta 	AppendPointer+1
.a63d	a0 00		ldy #$00			ldy 	#0
.a63f					_MDLACopy:
.a63f	b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a641	91 38		sta ($38),y			sta 	(zTemp1),y
.a643	c8		iny				iny
.a644	98		tya				tya
.a645	d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a647	d0 f6		bne $a63f			bne 	_MDLACopy
.a649	a9 00		lda #$00			lda 	#0 							; end of program.
.a64b	91 38		sta ($38),y			sta 	(zTemp1),y
.a64d	60		rts				rts
.0637					AppendPointer:
>0637							.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/memory.asm

.a64e					MemoryNew:
.a64e	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a650	85 30		sta $30				sta 	codePtr
.a652	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a654	85 31		sta $31				sta 	codePtr+1
.a656	a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a658	92 30		sta ($30)			sta 	(codePtr)
.a65a	60		rts				rts
.a65b					MemoryInline:
.a65b	98		tya				tya 								; put address into stack,x
.a65c	18		clc				clc  								; get the offset, add codePtr
.a65d	65 30		adc $30				adc 	codePtr
.a65f	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a662	a5 31		lda $31				lda 	codePtr+1
.a664	69 00		adc #$00			adc 	#0
.a666	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a669	9e 18 04	stz $0418,x			stz 	NSMantissa2,x
.a66c	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a66f	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./memory/memory.flat/search.asm

.a670					MemorySearch:
.a670	85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a672	86 37		stx $37				stx 	zTemp0+1
.a674	a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a676	85 30		sta $30				sta 	codePtr
.a678	a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a67a	85 31		sta $31				sta 	codePtr+1
.a67c					_MTAXLoop:
.a67c	b2 30		lda ($30)			lda 	(codePtr)
.a67e	18		clc				clc
.a67f	f0 21		beq $a6a2			beq 	_MTAXExit 					; reached end, exit with CC.
.a681	a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a683	b1 30		lda ($30),y			lda 	(codePtr),y
.a685	38		sec				sec
.a686	e5 36		sbc $36				sbc 	zTemp0
.a688	85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a68a	c8		iny				iny 								; do the MSB
.a68b	b1 30		lda ($30),y			lda 	(codePtr),y
.a68d	e5 37		sbc $37				sbc 	zTemp0+1
.a68f	05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a691	f0 0f		beq $a6a2			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a693	b0 0d		bcs $a6a2			bcs 	_MTAXExit 					; current < required exit
.a695	18		clc				clc
.a696	b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a698	65 30		adc $30				adc 	codePtr
.a69a	85 30		sta $30				sta 	codePtr
.a69c	90 02		bcc $a6a0			bcc 	_CREExit
.a69e	e6 31		inc $31				inc 	codePtr+1 					; carry
.a6a0					_CREExit:
.a6a0	80 da		bra $a67c			bra 	_MTAXLoop
.a6a2					_MTAXExit:
.a6a2	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/playing.asm

.a6a3					UnaryPlaying:
.a6a3	fa		plx				plx
.a6a4	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; get channel #
.a6a7	48		pha				pha
.a6a8	20 e6 8d	jsr $8de6			jsr		CheckRightBracket
.a6ab	68		pla				pla
.a6ac	c9 04		cmp #$04			cmp 	#4
.a6ae	b0 0c		bcs $a6bc			bcs 	_UPNotPlaying
.a6b0	09 20		ora #$20			ora 	#$20 						; query playing ?
.a6b2	20 1a ba	jsr $ba1a			jsr 	SNDCommand
.a6b5	c9 00		cmp #$00			cmp 	#0
.a6b7	f0 03		beq $a6bc			beq 	_UPNotPlaying
.a6b9	4c 6c 8e	jmp $8e6c			jmp 	ReturnTrue
.a6bc					_UPNotPlaying:
.a6bc	4c 78 8e	jmp $8e78			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./module.interface/sound/sound.asm

.a6bf					SoundCommand:
.a6bf	b1 30		lda ($30),y			lda 	(codePtr),y
.a6c1	c9 c0		cmp #$c0			cmp 	#KWD_OFF 					; SOUND OFF ?
.a6c3	d0 09		bne $a6ce			bne 	_SNDMain
.a6c5	c8		iny				iny 								; skip OFF
.a6c6	a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.a6c8	5a		phy				phy
.a6c9	20 1a ba	jsr $ba1a			jsr 	SNDCommand
.a6cc	7a		ply				ply
.a6cd	60		rts				rts
.a6ce					_SNDMain:
.a6ce	a2 00		ldx #$00			ldx 	#0
.a6d0	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; channel
.a6d3	c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.a6d5	b0 50		bcs $a727			bcs 	_SndError
.a6d7	e8		inx				inx 								; do the rest in slot 1.
.a6d8	20 ee 8d	jsr $8dee			jsr 	CheckComma
.a6db	20 23 9e	jsr $9e23			jsr 	Evaluate16BitInteger 		; Pitch
.a6de	bd 10 04	lda $0410,x			lda 	NSMantissa1,x 				; must be 10 bit
.a6e1	c9 10		cmp #$10			cmp 	#16
.a6e3	b0 42		bcs $a727			bcs 	_SndError
.a6e5	8d 3a 06	sta $063a			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.a6e8	bd 08 04	lda $0408,x			lda 	NSMantissa0,x
.a6eb	8d 39 06	sta $0639			sta 	SoundCommandBlock
.a6ee	20 ee 8d	jsr $8dee			jsr 	CheckComma
.a6f1	20 43 9e	jsr $9e43			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.a6f4	8d 3c 06	sta $063c			sta 	SoundCommandBlock+3
.a6f7	a9 0f		lda #$0f			lda 	#15
.a6f9	8d 3b 06	sta $063b			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.a6fc	9c 3d 06	stz $063d			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.a6ff	9c 3e 06	stz $063e			stz 	SoundCommandBlock+5
.a702	b1 30		lda ($30),y			lda 	(codePtr),y
.a704	c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.a706	d0 10		bne $a718			bne 	_SNDPlay
.a708	c8		iny				iny
.a709	20 2f 9e	jsr $9e2f			jsr 	Evaluate16BitIntegerSigned 	; Slide
.a70c	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.a70f	8d 3d 06	sta $063d			sta 	SoundCommandBlock+4
.a712	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a715	8d 3e 06	sta $063e			sta 	SoundCommandBlock+5
.a718					_SNDPlay:
.a718	5a		phy				phy
.a719	ad 08 04	lda $0408			lda 	NSMantissa0 				; channel.
.a71c	09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.a71e	a2 39		ldx #$39			ldx 	#(SoundCommandBlock & $FF)
.a720	a0 06		ldy #$06			ldy 	#(SoundCommandBlock >> 8)
.a722	20 1a ba	jsr $ba1a			jsr 	SNDCommand
.a725	7a		ply				ply
.a726	60		rts				rts
.a727					_SndError:
.a727	4c 51 a0	jmp $a051			jmp 	RangeError
.0639					SoundCommandBlock:
>0639							.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.a72a					StackPushByte:
.a72a	48		pha				pha 								; save byte
.a72b	a5 34		lda $34				lda 	BasicStack
.a72d	d0 09		bne $a738			bne 	_SPBNoBorrow
.a72f	c6 35		dec $35				dec 	BasicStack+1
.a731	48		pha				pha
.a732	a5 35		lda $35				lda 	BasicStack+1
.a734	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a736	90 06		bcc $a73e			bcc 	_SPBMemory
.a738					_SPBNoBorrow:
.a738	c6 34		dec $34				dec 	BasicStack
.a73a	68		pla				pla 								; get back and write
.a73b	92 34		sta ($34)			sta 	(BasicStack)
.a73d	60		rts				rts
.a73e					_SPBMemory:
.a73e	a9 12		lda #$12		lda	#18
.a740	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.a743					StackPopByte:
.a743	b2 34		lda ($34)			lda 	(BasicStack)
.a745	e6 34		inc $34				inc 	BasicStack
.a747	d0 02		bne $a74b			bne 	_SPBNoCarry
.a749	e6 35		inc $35				inc 	BasicStack+1
.a74b					_SPBNoCarry:
.a74b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.a74c					StackOpen:
.a74c	48		pha				pha 								; save frame byte
.a74d	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.a74f	0a		asl a				asl 	a 							; claim twice this for storage
.a750	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.a752	38		sec				sec 								; so basically subtracting from
.a753	65 34		adc $34				adc 	basicStack 	 				; basicStack
.a755	85 34		sta $34				sta 	basicStack
.a757	b0 08		bcs $a761			bcs 	_SONoBorrow
.a759	c6 35		dec $35				dec 	basicStack+1
.a75b	a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.a75d	c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.a75f	90 04		bcc $a765			bcc 	_SOMemory
.a761					_SONoBorrow:
.a761	68		pla				pla 								; get marker back and write at TOS
.a762	92 34		sta ($34)			sta 	(basicStack)
.a764	60		rts				rts
.a765					_SOMemory:
.a765	a9 12		lda #$12		lda	#18
.a767	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.a76a					StackClose:
.a76a	b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.a76c	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.a76e	0a		asl a				asl 	a 							; claim twice this.
.a76f	65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.a771	85 34		sta $34				sta 	basicStack
.a773	90 02		bcc $a777			bcc 	_SCExit
.a775	e6 35		inc $35				inc 	basicStack+1
.a777					_SCExit:
.a777	60		rts				rts
.a778					StackCheckFrame:
.a778	48		pha				pha
.a779					_StackRemoveLocals:
.a779	b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.a77b	c9 03		cmp #$03			cmp 	#STK_LOCALS+1
.a77d	b0 05		bcs $a784			bcs 	_SCNoLocal
.a77f	20 fe 88	jsr $88fe			jsr 	LocalPopValue
.a782	80 f5		bra $a779			bra 	_StackRemoveLocals
.a784					_SCNoLocal:
.a784	68		pla				pla
.a785	52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.a787	29 f0		and #$f0			and 	#$F0 						; check type bits
.a789	d0 01		bne $a78c			bne 	_SCFError 					; different, we have structures mixed up
.a78b	60		rts				rts
.a78c					_SCFError:
.a78c	8a		txa				txa 								; report error X
.a78d	4c ff 8d	jmp $8dff			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.a790					STKSaveCodePosition:
.a790	5a		phy				phy
.a791	98		tya				tya 								; save Y
.a792	a0 05		ldy #$05			ldy 	#5
.a794	91 34		sta ($34),y			sta 	(basicStack),y
.a796	88		dey				dey 								; save Code Pointer
.a797					_STKSaveLoop:
.a797	b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.a79a	91 34		sta ($34),y			sta 	(basicStack),y
.a79c	88		dey				dey
.a79d	d0 f8		bne $a797			bne 	_STKSaveLoop
.a79f	7a		ply				ply
.a7a0	60		rts				rts
.a7a1					STKLoadCodePosition:
.a7a1	a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.a7a3					_STKLoadLoop:
.a7a3	b1 34		lda ($34),y			lda 	(basicStack),y
.a7a5	99 2f 00	sta $002f,y			sta 	safePtr-1,y
.a7a8	c8		iny				iny
.a7a9	c0 05		cpy #$05			cpy 	#5
.a7ab	d0 f6		bne $a7a3			bne 	_STKLoadLoop
.a7ad	b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.a7af	a8		tay				tay
.a7b0	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.a7b1					StackReset:
.a7b1	a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.a7b3	85 34		sta $34				sta 	0+basicStack
.a7b5	a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.a7b7	85 35		sta $35				sta 	1+basicStack
.a7b9	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.a7bb	92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.a7bd	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.a7be					StringConcrete:
.a7be	5a		phy				phy 								; save position on stack
.a7bf	20 8b 9a	jsr $9a8b			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a7c2	bd 08 04	lda $0408,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.a7c5	85 38		sta $38				sta 	zTemp1
.a7c7	bd 10 04	lda $0410,x			lda 	NSMantissa1,x
.a7ca	85 39		sta $39				sta 	zTemp1+1
.a7cc	a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.a7ce					_SALength:
.a7ce	c8		iny				iny
.a7cf	b1 38		lda ($38),y			lda 	(zTemp1),y
.a7d1	d0 fb		bne $a7ce			bne 	_SALength
.a7d3	c0 fd		cpy #$fd			cpy 	#253 						; string too long
.a7d5	b0 3f		bcs $a816			bcs 	_SALengthError
.a7d7	98		tya				tya 				 				; length of the new string
.a7d8	18		clc				clc
.a7d9	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.a7db	90 02		bcc $a7df			bcc 	_SAHaveLength
.a7dd	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.a7df					_SAHaveLength:
.a7df	48		pha				pha 								; save length.
.a7e0	38		sec				sec
.a7e1	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.a7e3	6d 8e 04	adc $048e			adc 	StringMemory
.a7e6	8d 8e 04	sta $048e			sta 	StringMemory
.a7e9	85 3a		sta $3a				sta 	zTemp2 						; update storage address
.a7eb	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; update mantissa address
.a7ee	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.a7f0	6d 8f 04	adc $048f			adc 	StringMemory+1
.a7f3	8d 8f 04	sta $048f			sta 	StringMemory+1
.a7f6	85 3b		sta $3b				sta 	zTemp2+1
.a7f8	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a7fb	68		pla				pla 								; save length-3 (chars allowed) in first byte
.a7fc	38		sec				sec
.a7fd	e9 03		sbc #$03			sbc 	#3
.a7ff	92 3a		sta ($3a)			sta 	(zTemp2)
.a801	a9 00		lda #$00			lda 	#0 							; clear the status byte.
.a803	a0 01		ldy #$01			ldy 	#1
.a805	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a807					_SACopyNewString:
.a807	a0 00		ldy #$00			ldy 	#0
.a809					_SACopyNSLoop:
.a809	b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.a80b	c8		iny				iny 								; write two on in string storage
.a80c	c8		iny				iny
.a80d	91 3a		sta ($3a),y			sta 	(zTemp2),y
.a80f	88		dey				dey 								; this makes it one one.
.a810	c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.a812	d0 f5		bne $a809			bne 	_SACopyNSLoop
.a814	7a		ply				ply
.a815	60		rts				rts
.a816					_SALengthError:
.a816	a9 09		lda #$09		lda	#9
.a818	4c ff 8d	jmp $8dff		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.a81b					StringSystemInitialise:
.a81b	a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.a81d	8d 8e 04	sta $048e			sta 	0+StringMemory
.a820	a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.a822	8d 8f 04	sta $048f			sta 	1+StringMemory
.a825	9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.a828	60		rts				rts
.a829					StringSpaceInitialise:
.a829	20 8b 9a	jsr $9a8b			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.a82c	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.a82e	8d 90 04	sta $0490			sta 	StringInitialised
.a831	ad 8e 04	lda $048e			lda 	StringMemory 				; allocate 256 bytes for one concreted string
.a834	8d 91 04	sta $0491			sta 	StringTempPointer
.a837	ad 8f 04	lda $048f			lda 	StringMemory+1
.a83a	3a		dec a				dec 	a
.a83b	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a83e	60		rts				rts
.a83f					StringTempAllocate:
.a83f	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.a841	b0 35		bcs $a878			bcs 	_STALength
.a843	2c 90 04	bit $0490			bit 	StringInitialised 			; already initialised
.a846	30 05		bmi $a84d			bmi 	_STAAllocate
.a848	48		pha				pha 								; save value to subtract.
.a849	20 29 a8	jsr $a829			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.a84c	68		pla				pla 								; restore it
.a84d					_STAAllocate:
.a84d	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.a84f	18		clc				clc  								; deliberate allows one more
.a850	6d 91 04	adc $0491			adc 	StringTempPointer 			; subtract from temp pointer
.a853	8d 91 04	sta $0491			sta 	StringTempPointer
.a856	9d 08 04	sta $0408,x			sta 	NSMantissa0,x 				; address in mantissa
.a859	85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.a85b	ad 92 04	lda $0492			lda 	StringTempPointer+1
.a85e	69 ff		adc #$ff			adc 	#$FF
.a860	8d 92 04	sta $0492			sta 	StringTempPointer+1
.a863	85 3d		sta $3d				sta 	zsTemp+1
.a865	9d 10 04	sta $0410,x			sta 	NSMantissa1,x
.a868	9e 18 04	stz $0418,x			stz 	NSMantissa2,x 				; set the typing data
.a86b	9e 20 04	stz $0420,x			stz 	NSMantissa3,x
.a86e	a9 10		lda #$10			lda 	#NSTString
.a870	9d 00 04	sta $0400,x			sta 	NSStatus,x
.a873	a9 00		lda #$00			lda 	#0 							; clear the target string
.a875	92 3c		sta ($3c)			sta 	(zsTemp)
.a877	60		rts				rts
.a878					_STALength:
.a878	a9 09		lda #$09		lda	#9
.a87a	4c ff 8d	jmp $8dff		jmp	ErrorHandler
.a87d					StringTempWrite:
.a87d	48		pha				pha
.a87e	92 3c		sta ($3c)			sta 	(zsTemp)
.a880	e6 3c		inc $3c				inc 	zsTemp
.a882	d0 02		bne $a886			bne 	_STWNoCarry
.a884	e6 3d		inc $3d				inc 	zsTemp+1
.a886					_STWNoCarry:
.a886	a9 00		lda #$00			lda 	#0
.a888	92 3c		sta ($3c)			sta 	(zsTemp)
.a88a	68		pla				pla
.a88b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_hardware.module

=1					hardwareIntegrated=1
=0					CONBlack = 0
=1					CONWhite = 1
=2					CONRed = 2
=3					CONCyan = 3
=4					CONPurple = 4
=5					CONGreen = 5
=6					CONBlue = 6
=7					CONYellow = 7
=8					CONOrange = 8
=9					CONBrown = 9
=10					CONYellowGreen = 10
=11					CONRosa = 11
=12					CONBlueGreen = 12
=13					CONLightBlue = 13
=14					CONPink = 14
=15					CONLightGreen = 15
=7					CONForeground = CONYellow
=6					CONBackground = CONBlue
=12					CLINumber = CONBlueGreen
=3					CLIToken = CONCyan
=13					CLIConstant = CONLightBlue
=7					CLIIdentifier = CONYellow
=10					CLIPunctuation = CONYellowGreen
=1					CLIData = CONWhite
.a88c					EXTPrintCharacter:
.a88c	48		pha				pha
.a88d	da		phx				phx
.a88e	5a		phy				phy
.a88f	a6 01		ldx $01				ldx 	1
.a891	da		phx				phx
.a892	ac 40 06	ldy $0640			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.a895	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.a897	30 48		bmi $a8e1			bmi 	_EXPCColour
.a899	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.a89b	90 4d		bcc $a8ea			bcc 	_EXPCControl
.a89d	a2 02		ldx #$02			ldx 	#2 							; select char memory
.a89f	86 01		stx $01				stx 	1
.a8a1	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8a3	e6 01		inc $01				inc 	1 							; select colour memory
.a8a5	ad 41 06	lda $0641			lda 	EXTTextColour
.a8a8	91 40		sta ($40),y			sta 	(EXTAddress),y
.a8aa	c8		iny				iny 								; advance horizontal position
.a8ab	8c 40 06	sty $0640			sty 	EXTColumn
.a8ae	cc 42 06	cpy $0642			cpy 	EXTScreenWidth 				; reached RHS ?
.a8b1	90 66		bcc $a919			bcc 	_EXPCExit 					; no, then exit.
.a8b3					_EXPCCRLF:
.a8b3	ee 3f 06	inc $063f			inc 	EXTRow  					; bump row
.a8b6	9c 40 06	stz $0640			stz 	EXTColumn 					; back to column 0
.a8b9	ad 3f 06	lda $063f			lda 	EXTRow 						; check if reached the bottom ?
.a8bc	cd 43 06	cmp $0643			cmp 	EXTScreenHeight 			; if so, then scroll.
.a8bf	f0 18		beq $a8d9			beq 	_EXPCScroll
.a8c1	18		clc				clc 								; add width to address.
.a8c2	a5 40		lda $40				lda 	EXTAddress
.a8c4	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a8c7	85 40		sta $40				sta 	EXTAddress
.a8c9	90 4e		bcc $a919			bcc 	_EXPCExit
.a8cb	e6 41		inc $41				inc 	EXTAddress+1
.a8cd	80 4a		bra $a919			bra 	_EXPCExit
.a8cf					_EXPCLeft:
.a8cf	ce 40 06	dec $0640			dec 	EXTColumn
.a8d2	10 45		bpl $a919			bpl 	_EXPCExit
.a8d4					_EXPCBegin:
.a8d4	9c 40 06	stz $0640			stz 	EXTColumn
.a8d7	80 40		bra $a919			bra 	_EXPCExit
.a8d9					_EXPCScroll:
.a8d9	ce 3f 06	dec $063f			dec 	EXTRow 						; the height-1 th line.
.a8dc	20 a6 a9	jsr $a9a6			jsr 	EXTScreenScroll 			; scroll the screen
.a8df	80 38		bra $a919			bra 	_EXPCExit
.a8e1					_EXPCColour:
.a8e1	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.a8e3	b0 34		bcs $a919			bcs 	_EXPCExit
.a8e5	20 86 a9	jsr $a986			jsr 	_EXPCHandleColour
.a8e8	80 2f		bra $a919			bra 	_EXPCExit
.a8ea					_EXPCControl:
.a8ea	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.a8ec	b0 2b		bcs $a919			bcs 	_EXPCExit
.a8ee	0a		asl a				asl 	a 							; double into X
.a8ef	aa		tax				tax
.a8f0	7c 64 a9	jmp ($a964,x)			jmp 	(_EXPCActionTable,x) 		; and execute code.
.a8f3					_EXPCUp:
.a8f3	ad 3f 06	lda $063f			lda 	EXTRow 						; already at top ?
.a8f6	f0 21		beq $a919			beq 	_EXPCExit
.a8f8	ce 3f 06	dec $063f			dec 	EXTRow 						; up one in position/address
.a8fb	38		sec				sec
.a8fc	a5 40		lda $40				lda 	EXTAddress
.a8fe	ed 42 06	sbc $0642			sbc 	EXTScreenWidth
.a901	85 40		sta $40				sta 	EXTAddress
.a903	b0 14		bcs $a919			bcs 	_EXPCExit
.a905	c6 41		dec $41				dec 	EXTAddress+1
.a907	80 10		bra $a919			bra 	_EXPCExit
.a909					_EXPCRight:
.a909	c8		iny				iny
.a90a	8c 40 06	sty $0640			sty 	EXTColumn
.a90d	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.a910	d0 07		bne $a919			bne 	_EXPCExit
.a912					_EXPCEnd:
.a912	ad 42 06	lda $0642			lda 	EXTScreenWidth
.a915	3a		dec a				dec 	a
.a916	8d 40 06	sta $0640			sta 	EXTColumn
.a919					_EXPCExit:
.a919	20 fb a9	jsr $a9fb			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.a91c	68		pla				pla
.a91d	85 01		sta $01				sta 	1
.a91f	7a		ply				ply
.a920	fa		plx				plx
.a921	68		pla				pla
.a922	60		rts				rts
.a923					_EXPCClearScreen:
.a923	20 b8 a9	jsr $a9b8			jsr		EXTClearScreenCode
.a926	80 f1		bra $a919			bra 	_EXPCExit
.a928					_EXPCDown:
.a928	ad 43 06	lda $0643			lda 	EXTScreenHeight 			; at the bottom
.a92b	3a		dec a				dec 	a
.a92c	cd 3f 06	cmp $063f			cmp 	EXTRow
.a92f	f0 e8		beq $a919			beq 	_EXPCExit
.a931	ee 3f 06	inc $063f			inc 	EXTRow 						; down one in position/address
.a934	18		clc				clc
.a935	a5 40		lda $40				lda 	EXTAddress
.a937	6d 42 06	adc $0642			adc 	EXTScreenWidth
.a93a	85 40		sta $40				sta 	EXTAddress
.a93c	90 db		bcc $a919			bcc 	_EXPCExit
.a93e	e6 41		inc $41				inc 	EXTAddress+1
.a940	80 d7		bra $a919			bra 	_EXPCExit
.a942					_EXPCTab:
.a942	ad 40 06	lda $0640			lda 	EXTColumn 					; next tab stop
.a945	29 f8		and #$f8			and 	#$F8
.a947	18		clc				clc
.a948	69 08		adc #$08			adc 	#8
.a94a	8d 40 06	sta $0640			sta 	EXTColumn
.a94d	cd 42 06	cmp $0642			cmp 	EXTScreenWidth 				; too far, stick end of line.
.a950	90 c7		bcc $a919			bcc 	_EXPCExit
.a952	80 be		bra $a912			bra 	_EXPCEnd
.a954					_EXPCBackSpace:
.a954	88		dey				dey
.a955	30 c2		bmi $a919			bmi 	_EXPCExit
.a957	ce 40 06	dec $0640			dec 	EXTColumn
.a95a	a9 02		lda #$02			lda 	#2
.a95c	85 01		sta $01				sta 	1
.a95e	a9 20		lda #$20			lda 	#32
.a960	91 40		sta ($40),y			sta 	(EXTAddress),y
.a962	80 b5		bra $a919			bra 	_EXPCExit
.a964					_EXPCActionTable:
>a964	19 a9						.word 	_EXPCExit 					; 00
>a966	d4 a8						.word 	_EXPCBegin 					; 01 A Start of Line
>a968	cf a8						.word 	_EXPCLeft 					; 02 B Left
>a96a	19 a9						.word 	_EXPCExit 					; 03 <Break>
>a96c	19 a9						.word 	_EXPCExit 					; 04
>a96e	12 a9						.word 	_EXPCEnd 					; 05 E End of Line
>a970	09 a9						.word 	_EXPCRight 					; 06 F Right
>a972	19 a9						.word 	_EXPCExit 					; 07
>a974	54 a9						.word 	_EXPCBackspace 				; 08 H Backspace
>a976	42 a9						.word 	_EXPCTab 					; 09 I Tab
>a978	19 a9						.word 	_EXPCExit 					; 0A
>a97a	19 a9						.word 	_EXPCExit 					; 0B
>a97c	23 a9						.word 	_EXPCClearScreen			; 0C L CLS
>a97e	b3 a8						.word 	_EXPCCRLF 					; 0D M CR/LF
>a980	28 a9						.word 	_EXPCDown 					; 0E N Down
>a982	19 a9						.word 	_EXPCExit 					; 0F
>a984	f3 a8						.word 	_EXPCUp 					; 10 P Up
.a986					_EXPCHandleColour
.a986	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.a988	b0 16		bcs $a9a0			bcs 	_EXPCBackground
.a98a	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.a98b	0a		asl a				asl 	a
.a98c	0a		asl a				asl 	a
.a98d	0a		asl a				asl 	a
.a98e	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.a990					_EXPCUpdate:
.a990	48		pha				pha 								; save new colour
.a991	8a		txa				txa 								; get mask
.a992	2d 41 06	and $0641			and 	EXTTextColour 				; mask out old.
.a995	8d 41 06	sta $0641			sta 	EXTTextColour
.a998	68		pla				pla 								; or in new colour
.a999	0d 41 06	ora $0641			ora 	EXTTextColour
.a99c	8d 41 06	sta $0641			sta 	EXTTextColour
.a99f	60		rts				rts
.a9a0					_EXPCBackground:
.a9a0	29 0f		and #$0f			and 	#$0F 						; get the colour
.a9a2	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.a9a4	80 ea		bra $a990			bra 	_EXPCUpdate
.a9a6					EXTScreenScroll:
.a9a6	a9 02		lda #$02			lda 	#2 							; select text page
.a9a8	85 01		sta $01				sta 	1
.a9aa	a9 20		lda #$20			lda		#32 						; fill with space
.a9ac	20 bb aa	jsr $aabb			jsr 	EXTScrollFill
.a9af	e6 01		inc $01				inc 	1 							; select colour page
.a9b1	ad 41 06	lda $0641			lda 	EXTTextColour
.a9b4	20 bb aa	jsr $aabb			jsr 	EXTScrollFill
.a9b7	60		rts				rts
.a9b8					EXTClearScreenCode:
.a9b8	a9 02		lda #$02			lda 	#2 							; select text page
.a9ba	85 01		sta $01				sta 	1
.a9bc	a9 20		lda #$20			lda		#32 						; fill with space
.a9be	20 cb a9	jsr $a9cb			jsr 	_EXTCSFill
.a9c1	e6 01		inc $01				inc 	1 							; select colour page
.a9c3	ad 41 06	lda $0641			lda 	EXTTextColour
.a9c6	20 cb a9	jsr $a9cb			jsr 	_EXTCSFill
.a9c9	80 22		bra $a9ed			bra 	EXTHomeCursor
.a9cb					_EXTCSFill:
.a9cb	aa		tax				tax
.a9cc	a9 00		lda #$00			lda 	#EXTMemory & $FF
.a9ce	85 40		sta $40				sta 	EXTAddress
.a9d0	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9d2	85 41		sta $41				sta 	EXTAddress+1
.a9d4					_EXTCSFill1:
.a9d4	a0 00		ldy #$00			ldy 	#0
.a9d6	8a		txa				txa
.a9d7					_EXTCSFill2:
.a9d7	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9d9	c8		iny				iny
.a9da	d0 fb		bne $a9d7			bne 	_EXTCSFill2
.a9dc	e6 41		inc $41				inc 	EXTAddress+1
.a9de	a5 41		lda $41				lda 	EXTAddress+1
.a9e0	c9 d2		cmp #$d2			cmp 	#$D2
.a9e2	d0 f0		bne $a9d4			bne 	_EXTCSFill1
.a9e4	8a		txa				txa
.a9e5					_EXTCSFill3:
.a9e5	91 40		sta ($40),y			sta 	(EXTAddress),y
.a9e7	c8		iny				iny
.a9e8	c0 c0		cpy #$c0			cpy 	#$C0
.a9ea	d0 f9		bne $a9e5			bne 	_EXTCSFill3
.a9ec	60		rts				rts
.a9ed					EXTHomeCursor:
.a9ed	9c 3f 06	stz $063f			stz 	EXTRow 						; reset row & column
.a9f0	9c 40 06	stz $0640			stz 	EXTColumn
.a9f3	a9 00		lda #$00			lda 	#EXTMemory & $FF 			; set address
.a9f5	85 40		sta $40				sta 	EXTAddress
.a9f7	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.a9f9	85 41		sta $41				sta 	EXTAddress+1
.a9fb					EXTSetHardwareCursor:
.a9fb	64 01		stz $01				stz 	1 							; I/O Page zero
.a9fd	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.a9ff	8d 10 d0	sta $d010			sta 	$D010
.aa02	a9 b1		lda #$b1			lda 	#$B1
.aa04	8d 12 d0	sta $d012			sta 	$D012
.aa07	ad 40 06	lda $0640			lda 	EXTColumn
.aa0a	8d 14 d0	sta $d014			sta 	$D014 						; set cursor position
.aa0d	9c 15 d0	stz $d015			stz 	$D015
.aa10	ad 3f 06	lda $063f			lda 	EXTRow
.aa13	8d 16 d0	sta $d016			sta 	$D016
.aa16	9c 17 d0	stz $d017			stz 	$D017
.aa19	60		rts				rts
.aa1a					EXTInputLine:
.aa1a	48		pha				pha
.aa1b	da		phx				phx
.aa1c	5a		phy				phy
.aa1d	a5 01		lda $01				lda 	1 							; save I/O page
.aa1f	48		pha				pha
.aa20					_EILLoop:
.aa20	20 22 ab	jsr $ab22			jsr 	ExtInputSingleCharacter
.aa23	c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.aa25	f0 40		beq $aa67			beq 	_EILExit
.aa27	c9 08		cmp #$08			cmp 	#8 							; handle backspace
.aa29	f0 1c		beq $aa47			beq 	_EILBackspace
.aa2b	c9 20		cmp #$20			cmp 	#' '						; < space, print it
.aa2d	90 12		bcc $aa41			bcc 	_EILPrintLoop
.aa2f	c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.aa31	b0 0e		bcs $aa41			bcs 	_EILPrintLoop
.aa33	48		pha				pha 								; save character
.aa34	a9 02		lda #$02			lda 	#2  						; insert a space
.aa36	85 01		sta $01				sta 	1
.aa38	20 a9 aa	jsr $aaa9			jsr 	EXTILInsert 				; insert in text screen
.aa3b	e6 01		inc $01				inc 	1
.aa3d	20 a9 aa	jsr $aaa9			jsr 	EXTILInsert 				; insert in colour screen
.aa40	68		pla				pla 								; get character back.
.aa41					_EILPrintLoop:
.aa41	20 8c a8	jsr $a88c			jsr 	ExtPrintCharacter
.aa44	80 da		bra $aa20			bra 	_EILLoop
.aa46	60		rts				rts
.aa47					_EILBackspace:
.aa47	ad 40 06	lda $0640			lda 	EXTColumn					; can we backspace ?
.aa4a	f0 d4		beq $aa20			beq 	_EILLoop
.aa4c	a9 02		lda #$02			lda 	#2 							; move cursor left
.aa4e	20 8c a8	jsr $a88c			jsr 	EXTPrintCharacter
.aa51	a9 02		lda #$02			lda 	#2 							; text block
.aa53	85 01		sta $01				sta 	1
.aa55	a9 20		lda #$20			lda 	#' ' 						; backspace text.
.aa57	20 94 aa	jsr $aa94			jsr 	EXTILDelete
.aa5a	e6 01		inc $01				inc 	1 							; colour block
.aa5c	ac 40 06	ldy $0640			ldy 	EXTColumn 					; get attribute of last character
.aa5f	88		dey				dey
.aa60	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa62	20 94 aa	jsr $aa94			jsr 	EXTILDelete 				; backspace attribute
.aa65	80 b9		bra $aa20			bra 	_EILLoop 					; and go round.
.aa67					_EILExit:
.aa67	a9 02		lda #$02			lda 	#2 							; switch to page 2
.aa69	85 01		sta $01				sta 	1
.aa6b	a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.aa6d					_EILScrapeLine:
.aa6d	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa6f	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa72	c8		iny				iny
.aa73	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aa76	d0 f5		bne $aa6d			bne 	_EILScrapeLine
.aa78					_EILTrimSpaces:
.aa78	88		dey				dey
.aa79	f0 08		beq $aa83			beq 	_EILEndTrim
.aa7b	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y
.aa7e	c9 20		cmp #$20			cmp 	#' '
.aa80	f0 f6		beq $aa78			beq 	_EILTrimSpaces
.aa82	c8		iny				iny 								; trim after non space character.
.aa83					_EILEndTrim:
.aa83	a9 00		lda #$00			lda 	#0 							; trim here.
.aa85	99 a9 05	sta $05a9,y			sta 	lineBuffer,y
.aa88	a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.aa8a	20 8c a8	jsr $a88c			jsr 	ExtPrintCharacter
.aa8d	68		pla				pla 								; reset I/O page
.aa8e	85 01		sta $01				sta 	1
.aa90	7a		ply				ply
.aa91	fa		plx				plx
.aa92	68		pla				pla
.aa93	60		rts				rts
.aa94					EXTILDelete:
.aa94	48		pha				pha 								; save the new character
.aa95	ac 40 06	ldy $0640			ldy 	EXTColumn 					; start copying from here.
.aa98					_EXTDLoop:
.aa98	c8		iny				iny 								; copy one byte down.
.aa99	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aa9b	88		dey				dey
.aa9c	91 40		sta ($40),y			sta 	(EXTAddress),y
.aa9e	c8		iny				iny 								; do till end of line.
.aa9f	cc 42 06	cpy $0642			cpy 	EXTScreenWidth
.aaa2	90 f4		bcc $aa98			bcc 	_EXTDLoop
.aaa4	88		dey				dey 	 							; write in last slot.
.aaa5	68		pla				pla
.aaa6	91 40		sta ($40),y			sta 	(EXTAddress),y
.aaa8	60		rts				rts
.aaa9					EXTILInsert:
.aaa9	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; end position
.aaac					_EXTILoop:
.aaac	88		dey				dey 								; back one
.aaad	cc 40 06	cpy $0640			cpy 	EXTColumn 					; exit if reached insert point.
.aab0	f0 08		beq $aaba			beq 	_EXTIExit
.aab2	88		dey				dey 								; copy one byte up.
.aab3	b1 40		lda ($40),y			lda 	(EXTAddress),y
.aab5	c8		iny				iny
.aab6	91 40		sta ($40),y			sta 	(EXTAddress),y
.aab8	80 f2		bra $aaac			bra 	_EXTILoop
.aaba					_EXTIExit:
.aaba	60		rts				rts
.aabb					EXTScrollFill:
.aabb	aa		tax				tax									; save value to fill with
.aabc	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.aabe	48		pha				pha
.aabf	a5 37		lda $37				lda 	zTemp0+1
.aac1	48		pha				pha
.aac2	a5 38		lda $38				lda 	zTemp1
.aac4	48		pha				pha
.aac5	a5 39		lda $39				lda 	zTemp1+1
.aac7	48		pha				pha
.aac8	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.aaca	85 37		sta $37				sta 	zTemp0+1
.aacc	85 39		sta $39				sta 	zTemp1+1
.aace	64 36		stz $36				stz 	zTemp0
.aad0	ad 42 06	lda $0642			lda 	EXTScreenWidth
.aad3	85 38		sta $38				sta 	zTemp1
.aad5	a0 00		ldy #$00			ldy 	#0
.aad7					_EXSFCopy1:
.aad7	b1 38		lda ($38),y			lda 	(zTemp1),y
.aad9	91 36		sta ($36),y			sta 	(zTemp0),y
.aadb	c8		iny				iny
.aadc	d0 f9		bne $aad7			bne 	_EXSFCopy1
.aade	e6 37		inc $37				inc 	zTemp0+1 					; next page
.aae0	e6 39		inc $39				inc 	zTemp1+1
.aae2	a5 39		lda $39				lda 	zTemp1+1
.aae4	c9 d3		cmp #$d3			cmp 	#$D3
.aae6	d0 ef		bne $aad7			bne 	_EXSFCopy1
.aae8	ac 42 06	ldy $0642			ldy 	EXTScreenWidth 				; blank the bottom line.
.aaeb	8a		txa				txa
.aaec					_EXSFFill1:
.aaec	88		dey				dey
.aaed	91 40		sta ($40),y			sta 	(EXTAddress),y
.aaef	c0 00		cpy #$00			cpy 	#0
.aaf1	10 f9		bpl $aaec			bpl 	_EXSFFill1
.aaf3	68		pla				pla
.aaf4	85 39		sta $39				sta 	zTemp1+1
.aaf6	68		pla				pla
.aaf7	85 38		sta $38				sta 	zTemp1
.aaf9	68		pla				pla
.aafa	85 37		sta $37				sta 	zTemp0+1
.aafc	68		pla				pla
.aafd	85 36		sta $36				sta 	zTemp0
.aaff	60		rts				rts
=$c000					EXTMemory = $C000
=$02					EXTTextPage = $02
=$03					EXTColourPage = $03
=1					EXTDummySpace = 1 							; fake-space for CR character.
=0					EXTCBlack = 0
.063f					EXTRow:
>063f							.fill 	1
.0640					EXTColumn:
>0640							.fill 	1
.0641					EXTTextColour:
>0641							.fill 	1
.0642					EXTScreenWidth:
>0642							.fill 	1
.0643					EXTScreenHeight:
>0643							.fill 	1
.0040					EXTAddress:
>0040							.fill 	2
.ab00					EXTInitialise:
.ab00	64 01		stz $01				stz 	1 							; Access I/O
.ab02	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.ab05	9c 08 d0	stz $d008			stz 	$D008
.ab08	9c 09 d0	stz $d009			stz 	$D009
.ab0b	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.ab0d	8d 58 d6	sta $d658			sta 	$D658
.ab10	a9 76		lda #$76			lda 	#CONForeground * 16 + CONBackground
.ab12	8d 41 06	sta $0641			sta 	EXTTextColour
.ab15	a9 50		lda #$50			lda 	#80 						; set screen dimensions.
.ab17	8d 42 06	sta $0642			sta 	EXTScreenWidth
.ab1a	a9 3c		lda #$3c			lda 	#60
.ab1c	8d 43 06	sta $0643			sta 	EXTScreenHeight
.ab1f	64 01		stz $01				stz 	1
.ab21	60		rts				rts
.ab22					EXTInputSingleCharacter:
.ab22	da		phx				phx
.ab23	5a		phy				phy
.ab24					_EISCWait:
.ab24	64 01		stz $01				stz 	1 							; access I/O Page 0
.ab26	38		sec				sec 								; calculate timer - LastTick
.ab27	ad 59 d6	lda $d659			lda 	$D659
.ab2a	aa		tax				tax 								; saving timer in X
.ab2b	ed 2e 06	sbc $062e			sbc 	LastTick
.ab2e	c9 03		cmp #$03			cmp 	#3
.ab30	90 06		bcc $ab38			bcc 	_NoFireTick 				; if < 3 clocks don't fire.
.ab32	8e 2e 06	stx $062e			stx 	LastTick 					; update last timer
.ab35	20 a7 ba	jsr $baa7			jsr 	TickHandler 				; go do the code.
.ab38					_NoFireTick:
.ab38	20 e4 ff	jsr $ffe4			jsr 	$FFE4
.ab3b	c9 00		cmp #$00			cmp 	#0
.ab3d	f0 e5		beq $ab24			beq 	_EISCWait
.ab3f	7a		ply				ply
.ab40	fa		plx				plx
.ab41	60		rts				rts
.ab42					EXTBreakCheck:
.ab42	4c e1 ff	jmp $ffe1			jmp		$FFE1
.ab45					EXTReadController:
.ab45	da		phx				phx
.ab46	a2 00		ldx #$00			ldx 	#0
.ab48	a9 05		lda #$05			lda 	#(($2D) >> 3)
.ab4a	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab4d	29 20		and #$20			and 	#($01 << (($2D) & 7))
.ab4f	f0 04		beq $ab55			beq 	_NoSet1
.ab51	8a		txa				txa
.ab52	09 01		ora #$01			ora 	#1
.ab54	aa		tax				tax
.ab55					_NoSet1:
.ab55	a9 05		lda #$05			lda 	#(($2C) >> 3)
.ab57	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab5a	29 10		and #$10			and 	#($01 << (($2C) & 7))
.ab5c	f0 04		beq $ab62			beq 	_NoSet1
.ab5e	8a		txa				txa
.ab5f	09 02		ora #$02			ora 	#2
.ab61	aa		tax				tax
.ab62					_NoSet1:
.ab62	a9 06		lda #$06			lda 	#(($32) >> 3)
.ab64	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab67	29 04		and #$04			and 	#($01 << (($32) & 7))
.ab69	f0 04		beq $ab6f			beq 	_NoSet1
.ab6b	8a		txa				txa
.ab6c	09 04		ora #$04			ora 	#4
.ab6e	aa		tax				tax
.ab6f					_NoSet1:
.ab6f	a9 04		lda #$04			lda 	#(($25) >> 3)
.ab71	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab74	29 20		and #$20			and 	#($01 << (($25) & 7))
.ab76	f0 04		beq $ab7c			beq 	_NoSet1
.ab78	8a		txa				txa
.ab79	09 08		ora #$08			ora 	#8
.ab7b	aa		tax				tax
.ab7c					_NoSet1:
.ab7c	a9 04		lda #$04			lda 	#(($26) >> 3)
.ab7e	20 e7 ff	jsr $ffe7			jsr 	$FFE7
.ab81	29 40		and #$40			and 	#($01 << (($26) & 7))
.ab83	f0 04		beq $ab89			beq 	_NoSet1
.ab85	8a		txa				txa
.ab86	09 10		ora #$10			ora 	#16
.ab88	aa		tax				tax
.ab89					_NoSet1:
.ab89	8a		txa				txa
.ab8a	fa		plx				plx
.ab8b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_graphics.module

=1					graphicsIntegrated=1
=0					GCMD_Initialise = 0*2
=2					GCMD_BitmapCtl = 1*2
=4					GCMD_SpriteCtl = 2*2
=6					GCMD_Clear = 3*2
=8					GCMD_Colour = 4*2
=10					GCMD_DrawFont = 5*2
=12					GCMD_DrawSprite = 6*2
=14					GCMD_SpriteUse = 7*2
=16					GCMD_SpriteImage = 8*2
=18					GCMD_SpriteCollide = 9*2
=64					GCMD_Move = 32*2
=66					GCMD_Line = 33*2
=68					GCMD_FrameRect = 34*2
=70					GCMD_FillRect = 35*2
=72					GCMD_FrameCircle = 36*2
=74					GCMD_FillCircle = 37*2
=80					GCMD_Plot = 40*2
=82					GCMD_SpriteMove = 41*2
=42					GRFirstFreeCode = 42
.baad					GRVectorTable:
>baad	87 ad					.word	GXInitialise             ; $00 Initialise
>baaf	a1 ad					.word	GXControlBitmap          ; $01 BitmapCtl
>bab1	e9 ad					.word	GXControlSprite          ; $02 SpriteCtl
>bab3	39 ad					.word	GXClearBitmap            ; $03 Clear
>bab5	78 af					.word	GXSetColourMode          ; $04 Colour
>bab7	40 b1					.word	GXFontHandler            ; $05 DrawFont
>bab9	88 b1					.word	GXSpriteHandler          ; $06 DrawSprite
>babb	f4 b1					.word	GXSelect                 ; $07 SpriteUse
>babd	1d b2					.word	GXSelectImage            ; $08 SpriteImage
>babf	a4 b3					.word	GXCollide                ; $09 SpriteCollide
>bac1	eb ab					.word	GRUndefined              ; $0a
>bac3	eb ab					.word	GRUndefined              ; $0b
>bac5	eb ab					.word	GRUndefined              ; $0c
>bac7	eb ab					.word	GRUndefined              ; $0d
>bac9	eb ab					.word	GRUndefined              ; $0e
>bacb	eb ab					.word	GRUndefined              ; $0f
>bacd	eb ab					.word	GRUndefined              ; $10
>bacf	eb ab					.word	GRUndefined              ; $11
>bad1	eb ab					.word	GRUndefined              ; $12
>bad3	eb ab					.word	GRUndefined              ; $13
>bad5	eb ab					.word	GRUndefined              ; $14
>bad7	eb ab					.word	GRUndefined              ; $15
>bad9	eb ab					.word	GRUndefined              ; $16
>badb	eb ab					.word	GRUndefined              ; $17
>badd	eb ab					.word	GRUndefined              ; $18
>badf	eb ab					.word	GRUndefined              ; $19
>bae1	eb ab					.word	GRUndefined              ; $1a
>bae3	eb ab					.word	GRUndefined              ; $1b
>bae5	eb ab					.word	GRUndefined              ; $1c
>bae7	eb ab					.word	GRUndefined              ; $1d
>bae9	eb ab					.word	GRUndefined              ; $1e
>baeb	eb ab					.word	GRUndefined              ; $1f
>baed	e9 ab					.word	GXMove                   ; $20 Move
>baef	46 ae					.word	GXLine                   ; $21 Line
>baf1	c1 af					.word	GXFrameRectangle         ; $22 FrameRect
>baf3	be af					.word	GXFillRectangle          ; $23 FillRect
>baf5	f0 ab					.word	GXFrameCircle            ; $24 FrameCircle
>baf7	ec ab					.word	GXFillCircle             ; $25 FillCircle
>baf9	eb ab					.word	GRUndefined              ; $26
>bafb	eb ab					.word	GRUndefined              ; $27
>bafd	a6 af					.word	GXPlotPoint              ; $28 Plot
>baff	b3 b2					.word	GXMoveSprite             ; $29 SpriteMove
=3					GXMappingPage = 3
=24576					GXMappingAddress = ($2000 * GXMappingPage)
=11					GXEditSlot = 8 + GXMappingPage
=$36					gxzTemp0 = zTemp0
=$38					gxzTemp1 = zTemp1
=$3a					gxzTemp2 = zTemp2
=$3c					gxzScreen = zsTemp
=$5fa					gxPixelBuffer = numberBuffer
.0644					gxCurrentX:
>0644							.fill 	2
.0646					gxCurrentY:
>0646							.fill 	2
.0648					gxLastX:
>0648							.fill 	2
.064a					gxLastY:
>064a							.fill 	2
.064c					gxX0:
>064c							.fill 	2
.064e					gxY0:
>064e							.fill 	2
.0650					gxX1:
>0650							.fill 	2
.0652					gxY1:
>0652							.fill 	2
.0654					gxSpritesOn:
>0654							.fill 	1
.0655					gxBitmapsOn:
>0655							.fill 	1
.0656					gxBasePage:
>0656							.fill 	1
.0657					gxSpritePage:
>0657							.fill 	1
.0658					gxHeight:
>0658							.fill 	1
.0659					gxMode:
>0659							.fill 	1
.065a					gxColour:
>065a							.fill 	1
.065b					gxEORValue:
>065b							.fill 	1
.065c					gxANDValue:
>065c							.fill 	1
.065d					gxOriginalLUTValue:
>065d							.fill 	1
.065e					gsOffset:
>065e							.fill 	1
.065f					GSCurrentSpriteID:
>065f							.fill 	1
.0660					GSCurrentSpriteAddr:
>0660							.fill 	2
.0662					GXSpriteOffsetBase:
>0662							.fill 	2
.0664					GXSpriteLow:
>0664							.fill 	64
.06a4					GXSpriteHigh:
>06a4							.fill 	64
.ab8c					GXGraphicDraw:
.ab8c	c9 40		cmp #$40			cmp 	#GCMD_Move					; low instructions don't use coordinates
.ab8e	b0 06		bcs $ab96			bcs 	_GDCoordinate
.ab90	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.ab92	84 37		sty $37				sty 	gxzTemp0+1
.ab94	80 4b		bra $abe1			bra 	_GDExecuteA 				; and execute
.ab96					_GDCoordinate:
.ab96	48		pha				pha 								; save AXY
.ab97	da		phx				phx
.ab98	5a		phy				phy
.ab99	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.ab9b					_GDCopy1:
.ab9b	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.ab9e	9d 48 06	sta $0648,x			sta 	gxLastX,x
.aba1	ca		dex				dex
.aba2	10 f7		bpl $ab9b			bpl 	_GDCopy1
.aba4	68		pla				pla 								; update Y
.aba5	8d 46 06	sta $0646			sta 	gxCurrentY
.aba8	9c 47 06	stz $0647			stz 	gxCurrentY+1
.abab	68		pla				pla
.abac	8d 44 06	sta $0644			sta 	gxCurrentX
.abaf	68		pla				pla 								; get A (command+X.1) back
.abb0	48		pha				pha
.abb1	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.abb3	8d 45 06	sta $0645			sta 	gxCurrentX+1
.abb6	68		pla				pla 								; get command back
.abb7	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.abb9	48		pha				pha 								; push back.
.abba	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.abbc	f0 17		beq $abd5			beq 	_GDCopyToWorkArea
.abbe	ad 45 06	lda $0645			lda 	gxCurrentX+1 				; X < 256 X okay
.abc1	f0 07		beq $abca			beq 	_GDCheckY
.abc3	ad 44 06	lda $0644			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.abc6	c9 40		cmp #$40			cmp 	#64
.abc8	b0 08		bcs $abd2			bcs 	_GDError1
.abca					_GDCheckY:
.abca	ad 46 06	lda $0646			lda 	gxCurrentY 					; check Y < Height.
.abcd	cd 58 06	cmp $0658			cmp 	gxHeight
.abd0	90 03		bcc $abd5			bcc 	_GDCopyToWorkArea
.abd2					_GDError1:
.abd2	68		pla				pla
.abd3					_GDError2:
.abd3	38		sec				sec
.abd4	60		rts				rts
.abd5					_GDCopyToWorkArea:
.abd5	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.abd7					_GDCopy2:
.abd7	bd 44 06	lda $0644,x			lda 	gxCurrentX,x
.abda	9d 4c 06	sta $064c,x			sta 	gxX0,x
.abdd	ca		dex				dex
.abde	10 f7		bpl $abd7			bpl 	_GDCopy2
.abe0	68		pla				pla 								; get command
.abe1					_GDExecuteA:
.abe1	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad ?
.abe3	b0 ee		bcs $abd3			bcs 	_GDError2
.abe5	aa		tax				tax
.abe6	7c ad ba	jmp ($baad,x)			jmp 	(GRVectorTable,x)
.abe9					GXMove:
.abe9	18		clc				clc
.abea	60		rts				rts
.abeb					GRUndefined:
>abeb	db						.byte 	$DB 						; causes a break in the emulator
.abec					GXFillCircle:
.abec	a9 ff		lda #$ff			lda 	#255
.abee	80 02		bra $abf2			bra 	GXCircle
.abf0					GXFrameCircle:
.abf0	a9 00		lda #$00			lda 	#0
.abf2					GXCircle:
.abf2	8d e7 06	sta $06e7			sta 	gxIsFillMode					; save Fill flag
.abf5	ad 55 06	lda $0655			lda 	gxBitmapsOn
.abf8	f0 26		beq $ac20			beq 	_GXCFail
.abfa	20 4b b4	jsr $b44b			jsr 	GXSortXY 					; topleft/bottomright
.abfd	20 23 b3	jsr $b323			jsr 	GXOpenBitmap 				; start drawing
.ac00	20 f2 ac	jsr $acf2			jsr 	GXCircleSetup 				; set up for drawing
.ac03	9c e8 06	stz $06e8			stz 	gxYChanged
.ac06					_GXCircleDraw:
.ac06	ad e5 06	lda $06e5			lda 	gXCentre					; while x <= y
.ac09	cd e6 06	cmp $06e6			cmp 	gYCentre
.ac0c	90 0a		bcc $ac18			bcc 	_GXCircleContinue
.ac0e	d0 03		bne $ac13			bne 	_GXNoLast
.ac10	20 25 ac	jsr $ac25			jsr 	GXPlot1
.ac13					_GXNoLast:
.ac13	20 2b b3	jsr $b32b			jsr 	GXCloseBitmap 				; close the bitmap
.ac16	18		clc				clc
.ac17	60		rts				rts
.ac18					_GXCircleContinue:
.ac18	20 22 ac	jsr $ac22			jsr 	GXPlot2 					; draw it
.ac1b	20 9f ac	jsr $ac9f			jsr 	GXCircleMove 				; adjust the coordinates
.ac1e	80 e6		bra $ac06			bra 	_GXCircleDraw
.ac20					_GXCFail:
.ac20	38		sec				sec
.ac21	60		rts				rts
.ac22					GXPlot2:
.ac22	20 25 ac	jsr $ac25			jsr 	GXPlot1 						; plot and swap, fall through does twice
.ac25					GXPlot1:
.ac25	ad e6 06	lda $06e6			lda 	gYCentre 						; if y = 0, don't do it twice (xor)
.ac28	f0 03		beq $ac2d			beq 	_GXPlot1Only
.ac2a	20 49 ac	jsr $ac49			jsr 	GXPlot0 						; plot and negate
.ac2d					_GXPlot1Only:
.ac2d	20 49 ac	jsr $ac49			jsr 	GXPlot0 						; twice, undoing negation
.ac30	ad e5 06	lda $06e5			lda 	gXCentre 						; swap X and Y
.ac33	ae e6 06	ldx $06e6			ldx	 	gYCentre
.ac36	8d e6 06	sta $06e6			sta 	gYCentre
.ac39	8e e5 06	stx $06e5			stx 	gXCentre
.ac3c	ad e8 06	lda $06e8			lda 	gxYChanged 						; toggle Y Changed flag
.ac3f	a9 ff		lda #$ff			lda 	#$FF
.ac41	8d e8 06	sta $06e8			sta 	gxYChanged
.ac44	60		rts				rts
.ac45	20 49 ac	jsr $ac49			jsr 	GXPlot0 						; do once
.ac48	60		rts				rts
.ac49	ad e7 06	lda $06e7	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.ac4c	f0 05		beq $ac53			beq 	_GXPlot0Always
.ac4e	ad e8 06	lda $06e8			lda 	gxYChanged						; fill mode, only draw if changed.
.ac51	f0 2d		beq $ac80			beq 	GXPlot0Exit
.ac53					_GXPlot0Always:
.ac53	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.ac55	ad e6 06	lda $06e6			lda 	gYCentre
.ac58	20 81 ac	jsr $ac81			jsr 	GXSubCopy
.ac5b	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.ac5d	ad e5 06	lda $06e5			lda 	gXCentre
.ac60	20 81 ac	jsr $ac81			jsr 	GXSubCopy
.ac63	48		pha				pha 									; save last offset X
.ac64	20 33 b3	jsr $b333			jsr 	GXPositionCalc 					; calculate position/offset.
.ac67	68		pla				pla
.ac68	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.ac69	85 36		sta $36				sta 	gxzTemp0
.ac6b	64 37		stz $37				stz 	gxzTemp0+1
.ac6d	26 37		rol $37				rol 	gxzTemp0+1
.ac6f	ad e7 06	lda $06e7			lda 	gxIsFillMode
.ac72	69 80		adc #$80			adc 	#128
.ac74	20 11 b0	jsr $b011			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.ac77	38		sec				sec 									; GY = -GY
.ac78	a9 00		lda #$00			lda 	#0
.ac7a	ed e6 06	sbc $06e6			sbc 	gYCentre
.ac7d	8d e6 06	sta $06e6			sta 	gYCentre
.ac80					GXPlot0Exit:
.ac80	60		rts				rts
.ac81					GXSubCopy:
.ac81	85 36		sta $36				sta 	gxzTemp0
.ac83	64 37		stz $37				stz 	gxzTemp0+1
.ac85	29 80		and #$80			and 	#$80
.ac87	f0 02		beq $ac8b			beq 	_GXNoSx
.ac89	c6 37		dec $37				dec 	gxzTemp0+1
.ac8b					_GXNoSx:
.ac8b	38		sec				sec
.ac8c	bd 50 06	lda $0650,x			lda 	gXX1,x
.ac8f	e5 36		sbc $36				sbc 	gxzTemp0
.ac91	9d 4c 06	sta $064c,x			sta 	gXX0,x
.ac94	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ac97	e5 37		sbc $37				sbc 	gxzTemp0+1
.ac99	9d 4d 06	sta $064d,x			sta 	gXX0+1,x
.ac9c	a5 36		lda $36				lda 	gxzTemp0 						; return A
.ac9e	60		rts				rts
.ac9f					GXCircleMove:
.ac9f	9c e8 06	stz $06e8			stz 	gxYChanged 					; clear Y changed flag
.aca2	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.aca4	10 0d		bpl $acb3			bpl 	_GXEMPositive
.aca6	ee e5 06	inc $06e5			inc 	gXCentre 					; X++
.aca9	ad e5 06	lda $06e5			lda 	gXCentre
.acac	20 d2 ac	jsr $acd2			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acaf	a9 06		lda #$06			lda 	#6  						; and add 6
.acb1	80 15		bra $acc8			bra 	_GXEMAddD
.acb3					_GXEMPositive:
.acb3	ee e5 06	inc $06e5			inc 	gXCentre					; X++
.acb6	ce e6 06	dec $06e6			dec 	gyCentre 					; Y--
.acb9	38		sec				sec 								; calculate X-Y
.acba	ad e5 06	lda $06e5			lda 	gXCentre
.acbd	ed e6 06	sbc $06e6			sbc 	gYCentre
.acc0	20 d2 ac	jsr $acd2			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.acc3	a9 0a		lda #$0a			lda 	#10  						; and add 10
.acc5	ce e8 06	dec $06e8			dec 	gxYChanged
.acc8					_GXEMAddD:
.acc8	18		clc				clc
.acc9	65 38		adc $38				adc 	gxzTemp1
.accb	85 38		sta $38				sta 	gxzTemp1
.accd	90 02		bcc $acd1			bcc 	_GXEMNoCarry
.accf	e6 39		inc $39				inc 	gxzTemp1+1
.acd1					_GXEMNoCarry:
.acd1	60		rts				rts
.acd2					_GXAdd4TimesToD:
.acd2	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.acd4	29 80		and #$80			and 	#$80
.acd6	f0 02		beq $acda			beq 	_GXA4Unsigned
.acd8	a9 ff		lda #$ff			lda 	#$FF
.acda					_GXA4Unsigned:
.acda	85 37		sta $37				sta 	gxzTemp0+1
.acdc	06 36		asl $36				asl 	gxzTemp0  					; x 4
.acde	26 37		rol $37				rol 	gxzTemp0+1
.ace0	06 36		asl $36				asl 	gxzTemp0
.ace2	26 37		rol $37				rol 	gxzTemp0+1
.ace4	18		clc				clc 								; add
.ace5	a5 36		lda $36				lda		gxzTemp0
.ace7	65 38		adc $38				adc 	gxzTemp1
.ace9	85 38		sta $38				sta 	gxzTemp1
.aceb	a5 37		lda $37				lda		gxzTemp0+1
.aced	65 39		adc $39				adc 	gxzTemp1+1
.acef	85 39		sta $39				sta 	gxzTemp1+1
.acf1	60		rts				rts
.acf2					GXCircleSetup:
.acf2	38		sec				sec
.acf3	ad 52 06	lda $0652			lda 	gxY1
.acf6	ed 4e 06	sbc $064e			sbc 	gxY0
.acf9	4a		lsr a				lsr 	a
.acfa	8d e4 06	sta $06e4			sta 	gxRadius
.acfd	a2 00		ldx #$00			ldx 	#0
.acff	20 21 ad	jsr $ad21			jsr 	_GXCalculateCentre
.ad02	a2 02		ldx #$02			ldx 	#2
.ad04	20 21 ad	jsr $ad21			jsr 	_GXCalculateCentre
.ad07	9c e5 06	stz $06e5			stz 	gXCentre
.ad0a	ad e4 06	lda $06e4			lda 	gxRadius
.ad0d	8d e6 06	sta $06e6			sta 	gYCentre
.ad10	0a		asl a				asl 	a 							; R x 2
.ad11	85 36		sta $36				sta 	gxzTemp0
.ad13	38		sec				sec
.ad14	a9 03		lda #$03			lda 	#3
.ad16	e5 36		sbc $36				sbc 	gxzTemp0
.ad18	85 38		sta $38				sta 	gxzTemp1
.ad1a	a9 00		lda #$00			lda 	#0
.ad1c	e9 00		sbc #$00			sbc 	#0
.ad1e	85 39		sta $39				sta 	gxzTemp1+1
.ad20	60		rts				rts
.ad21					_GXCalculateCentre:
.ad21	38		sec				sec
.ad22	bd 50 06	lda $0650,x			lda 	gxX1,x
.ad25	7d 4c 06	adc $064c,x			adc 	gXX0,x
.ad28	9d 50 06	sta $0650,x			sta 	gXX1,x
.ad2b	bd 51 06	lda $0651,x			lda 	gXX1+1,x
.ad2e	7d 4d 06	adc $064d,x			adc 	gXX0+1,x
.ad31	4a		lsr a				lsr 	a
.ad32	9d 51 06	sta $0651,x			sta 	gXX1+1,x
.ad35	7e 50 06	ror $0650,x			ror 	gXX1,x
.ad38	60		rts				rts
.06e4					gxRadius:
>06e4							.fill 	1
.06e5					gXCentre:
>06e5							.fill 	1
.06e6					gYCentre:
>06e6							.fill 	1
.06e7					gxIsFillMode:
>06e7							.fill 	1
.06e8					gxYChanged:
>06e8							.fill  	1
=64000					ScreenSize200 = 320 * 200
=76800					ScreenSize240 = 320 * 240
.ad39					GXClearBitmap:
.ad39	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP running.
.ad3c	f0 24		beq $ad62			beq 	_GXCBFail
.ad3e	20 23 b3	jsr $b323			jsr 	GXOpenBitmap 				; start access
.ad41	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear
.ad43	ad 58 06	lda $0658			lda 	gxHeight
.ad46	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.ad48	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.ad4a					_GXCalcLastPage:
.ad4a	98		tya				tya 								; add to base page
.ad4b	18		clc				clc
.ad4c	6d 56 06	adc $0656			adc 	gxBasePage
.ad4f	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.ad51					_GXClearAll:
.ad51	20 64 ad	jsr $ad64			jsr 	_GXClearBlock 				; clear 8k block
.ad54	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.ad56	a5 0b		lda $0b				lda 	GXEditSlot
.ad58	cd 56 06	cmp $0656			cmp 	gxBasePage 					; until before base page
.ad5b	b0 f4		bcs $ad51			bcs 	_GXClearAll
.ad5d	20 2b b3	jsr $b32b			jsr 	GXCloseBitmap	 			; stop access
.ad60	18		clc				clc
.ad61	60		rts				rts
.ad62					_GXCBFail:
.ad62	38		sec				sec
.ad63	60		rts				rts
.ad64					_GXClearBlock:
.ad64	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.ad66	85 38		sta $38				sta 	0+gxzTemp1
.ad68	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.ad6a	85 39		sta $39				sta 	1+gxzTemp1
.ad6c					_GXCB0:
.ad6c	a5 36		lda $36				lda 	gxzTemp0
.ad6e	a0 00		ldy #$00			ldy 	#0
.ad70					_GXCB1:
.ad70	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad72	c8		iny				iny
.ad73	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad75	c8		iny				iny
.ad76	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad78	c8		iny				iny
.ad79	91 38		sta ($38),y			sta 	(gxzTemp1),y
.ad7b	c8		iny				iny
.ad7c	d0 f2		bne $ad70			bne 	_GXCB1
.ad7e	e6 39		inc $39				inc 	gxzTemp1+1
.ad80	a5 39		lda $39				lda 	gxzTemp1+1
.ad82	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.ad84	d0 e6		bne $ad6c			bne 	_GXCB0
.ad86	60		rts				rts
.ad87					GXInitialise:
.ad87	64 01		stz $01				stz 	1
.ad89	a9 01		lda #$01			lda 	#1
.ad8b	8d 00 d0	sta $d000			sta 	$D000
.ad8e	18		clc				clc
.ad8f	9c 54 06	stz $0654			stz 	GXSpritesOn
.ad92	9c 55 06	stz $0655			stz 	GXBitmapsOn
.ad95	a2 0f		ldx #$0f			ldx 	#15
.ad97					_GXIClear:
.ad97	9e 44 06	stz $0644,x			stz 	gxCurrentX,x
.ad9a	ca		dex				dex
.ad9b	10 fa		bpl $ad97			bpl 	_GXIClear
.ad9d	20 38 ae	jsr $ae38			jsr 	GXClearSpriteStore
.ada0	60		rts				rts
.ada1					GXControlBitmap:
.ada1	64 01		stz $01				stz 	1
.ada3	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.ada5	29 01		and #$01			and 	#1 							; set bitmap flag
.ada7	8d 55 06	sta $0655			sta 	gxBitmapsOn
.adaa	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adab	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adae	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adb0	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.adb2	90 02		bcc $adb6			bcc 	_CBNotOn
.adb4	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.adb6					_CBNotOn:
.adb6	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.adb9	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.adbb	29 07		and #$07			and 	#7
.adbd	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.adc0	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.adc2	d0 02		bne $adc6			bne 	_CBNotDefault
.adc4	a9 08		lda #$08			lda 	#8  						; if zero, use 8 e.g. bitmap at $10000
.adc6					_CBNotDefault:
.adc6	8d 56 06	sta $0656			sta 	gxBasePage
.adc9	20 2a ae	jsr $ae2a			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.adcc	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.adce	8d 03 d1	sta $d103			sta 	$D103
.add1	a5 36		lda $36				lda 	gxzTemp0
.add3	8d 02 d1	sta $d102			sta 	$D102
.add6	9c 01 d1	stz $d101			stz 	$D101
.add9	a2 f0		ldx #$f0			ldx 	#240 						; height is 240
.addb	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.adde	29 01		and #$01			and 	#1
.ade0	f0 02		beq $ade4			beq 	_CBHaveHeight
.ade2	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.ade4					_CBHaveHeight
.ade4	8e 58 06	stx $0658			stx 	gxHeight
.ade7	18		clc				clc
.ade8	60		rts				rts
.ade9					GXControlSprite:
.ade9	64 01		stz $01				stz 	1
.adeb	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.aded	29 01		and #$01			and 	#1 							; set sprites flag
.adef	8d 54 06	sta $0654			sta 	gxSpritesOn
.adf2	4a		lsr a				lsr 	a 							; bit 0 into carry.
.adf3	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.adf6	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.adf8	29 df		and #$df			and 	#$DF 						; clear sprite bit
.adfa	90 02		bcc $adfe			bcc 	_CSNotOn
.adfc	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.adfe					_CSNotOn:
.adfe	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.ae01	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.ae03	d0 02		bne $ae07			bne 	_CSNotDefault
.ae05	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.ae07					_CSNotDefault:
.ae07	8d 57 06	sta $0657			sta 	gxSpritePage
.ae0a	20 2a ae	jsr $ae2a			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.ae0d	a5 36		lda $36				lda 	zTemp0
.ae0f	8d 62 06	sta $0662			sta 	GXSpriteOffsetBase
.ae12	a5 37		lda $37				lda 	zTemp0+1
.ae14	8d 63 06	sta $0663			sta 	GXSpriteOffsetBase+1
.ae17	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.ae19					_CSClear:
.ae19	9e 00 d9	stz $d900,x			stz 	$D900,x
.ae1c	9e 00 da	stz $da00,x			stz 	$DA00,x
.ae1f	ca		dex				dex
.ae20	d0 f7		bne $ae19			bne 	_CSClear
.ae22	9c 61 06	stz $0661			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.ae25	20 38 ae	jsr $ae38			jsr 	GXClearSpriteStore
.ae28	18		clc				clc
.ae29	60		rts				rts
.ae2a					GXCalculateBaseAddress:
.ae2a	85 36		sta $36				sta 	gxzTemp0
.ae2c	64 37		stz $37				stz 	gxzTemp0+1
.ae2e	a9 05		lda #$05			lda 	#5
.ae30					_GXShift:
.ae30	06 36		asl $36				asl 	gxzTemp0
.ae32	26 37		rol $37				rol 	gxzTemp0+1
.ae34	3a		dec a				dec		a
.ae35	d0 f9		bne $ae30			bne 	_GXShift
.ae37	60		rts				rts
.ae38					GXClearSpriteStore:
.ae38	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.ae3a					_GXCSSLoop:
.ae3a	9e a4 06	stz $06a4,x			stz 	GXSpriteHigh,x
.ae3d	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.ae3f	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.ae42	ca		dex				dex
.ae43	10 f5		bpl $ae3a			bpl 	_GXCSSLoop
.ae45	60		rts				rts
.ae46					GXLine:
.ae46	ad 55 06	lda $0655			lda 	GXBitmapsOn
.ae49	f0 28		beq $ae73			beq 	_GXLFail
.ae4b	20 23 b3	jsr $b323			jsr 	GXOpenBitmap
.ae4e	20 69 b4	jsr $b469			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.ae51	20 19 af	jsr $af19			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.ae54	20 33 b3	jsr $b333			jsr 	GXPositionCalc 				; calculate position/offset.
.ae57					_GXDrawLoop:
.ae57	ac 5e 06	ldy $065e			ldy 	gsOffset 					; draw the pixel
.ae5a	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.ae5c	2d 5c 06	and $065c			and 	gxANDValue
.ae5f	4d 5b 06	eor $065b			eor 	gxEORValue
.ae62	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.ae64	20 75 ae	jsr $ae75			jsr 	GXLineIsComplete 			; is the line complete ?
.ae67	f0 05		beq $ae6e			beq 	_GXLExit
.ae69	20 90 ae	jsr $ae90			jsr 	GXLineAdvance 				; code as per advance method
.ae6c	80 e9		bra $ae57			bra 	_GXDrawLoop
.ae6e					_GXLExit:
.ae6e	20 2b b3	jsr $b32b			jsr 	GXCloseBitmap
.ae71	18		clc				clc
.ae72	60		rts				rts
.ae73					_GXLFail:
.ae73	38		sec				sec
.ae74	60		rts				rts
.ae75					GXLineIsComplete:
.ae75	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger 			; is dy larger
.ae78	d0 0f		bne $ae89			bne 	_GXLICCompareY 				; if so compare Y1/Y0
.ae7a	ad 4c 06	lda $064c			lda 	GXX0 						; compare X, LSB and MSB
.ae7d	4d 50 06	eor $0650			eor 	GXX1
.ae80	d0 06		bne $ae88			bne 	_GXLICExit
.ae82	ad 4d 06	lda $064d			lda 	GXX0+1
.ae85	4d 51 06	eor $0651			eor 	GXX1+1
.ae88					_GXLICExit:
.ae88	60		rts				rts
.ae89					_GXLICCompareY:
.ae89	ad 52 06	lda $0652			lda 	GXY1
.ae8c	4d 4e 06	eor $064e			eor 	GXY0
.ae8f	60		rts				rts
.ae90					GXLineAdvance:
.ae90	18		clc				clc 								; add adjust to position
.ae91	ad ed 06	lda $06ed			lda 	GXPosition
.ae94	6d ee 06	adc $06ee			adc 	GXAdjust
.ae97	8d ed 06	sta $06ed			sta 	GXPosition
.ae9a	9c f0 06	stz $06f0			stz 	GXAddSelect 				; clear add select flag
.ae9d	b0 05		bcs $aea4			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.ae9f	cd ef 06	cmp $06ef			cmp 	GXTotal 					; if exceeded total
.aea2	90 0a		bcc $aeae			bcc 	_GXLANoExtra
.aea4					_GXLAOverflow:
.aea4	ce f0 06	dec $06f0			dec 	GXAddSelect 				; set addselect to $FF
.aea7	38		sec				sec 								; subtract total and write back
.aea8	ed ef 06	sbc $06ef			sbc 	GXTotal
.aeab	8d ed 06	sta $06ed			sta 	GXPosition
.aeae					_GXLANoExtra:
.aeae	ad eb 06	lda $06eb			lda 	GXIsDiffYLarger
.aeb1	f0 0d		beq $aec0			beq 	_GXDXLarger
.aeb3	20 12 af	jsr $af12			jsr 	GXIncrementY
.aeb6	ad f0 06	lda $06f0			lda 	GXAddSelect
.aeb9	f0 10		beq $aecb			beq 	_GXLAExit
.aebb	20 cc ae	jsr $aecc			jsr 	GXAdjustX
.aebe	80 0b		bra $aecb			bra 	_GXLAExit
.aec0					_GXDXLarger:
.aec0	20 cc ae	jsr $aecc			jsr 	GXAdjustX
.aec3	ad f0 06	lda $06f0			lda 	GXAddSelect
.aec6	f0 03		beq $aecb			beq 	_GXLAExit
.aec8	20 12 af	jsr $af12			jsr 	GXIncrementY
.aecb					_GXLAExit:
.aecb	60		rts				rts
.aecc					GXAdjustX:
.aecc	ad ec 06	lda $06ec			lda 	GXDXNegative
.aecf	10 25		bpl $aef6			bpl 	_GXAXRight
.aed1	ad 4c 06	lda $064c			lda 	GXX0
.aed4	d0 03		bne $aed9			bne 	_GXAXNoBorrow
.aed6	ce 4d 06	dec $064d			dec 	GXX0+1
.aed9					_GXAXNoBorrow:
.aed9	ce 4c 06	dec $064c			dec 	GXX0
.aedc	ce 5e 06	dec $065e			dec 	gsOffset 					; pixel left
.aedf	ad 5e 06	lda $065e			lda 	gsOffset
.aee2	c9 ff		cmp #$ff			cmp 	#$FF
.aee4	d0 0f		bne $aef5			bne 	_GXAYExit 					; underflow
.aee6	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.aee8	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.aeea	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.aeec	b0 07		bcs $aef5			bcs 	_GXAYExit
.aeee	18		clc				clc
.aeef	69 20		adc #$20			adc 	#$20 						; fix up
.aef1	85 3d		sta $3d				sta 	gxzScreen+1
.aef3	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.aef5					_GXAYExit:
.aef5	60		rts				rts
.aef6					_GXAXRight:
.aef6	ee 4c 06	inc $064c			inc 	GXX0
.aef9	d0 03		bne $aefe			bne 	_GXAXNoCarry
.aefb	ee 4d 06	inc $064d			inc 	GXX0+1
.aefe					_GXAXNoCarry:
.aefe	ee 5e 06	inc $065e			inc 	gsOffset 					; pixel right
.af01	d0 0e		bne $af11			bne 	_GXAXExit 					; if not overflowed, exit.
.af03	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.af05	a5 3d		lda $3d				lda 	gxzScreen+1
.af07	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.af09	90 06		bcc $af11			bcc 	_GXAXExit
.af0b	e9 20		sbc #$20			sbc 	#$20 						; fix up
.af0d	85 3d		sta $3d				sta 	gxzScreen+1
.af0f	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.af11					_GXAXExit:
.af11	60		rts				rts
.af12					GXIncrementY:
.af12	ee 4e 06	inc $064e			inc 	GXY0
.af15	20 89 b3	jsr $b389			jsr 	GXMovePositionDown
.af18	60		rts				rts
.af19					GXLineSetup:
.af19	ad 52 06	lda $0652			lda 	GXY1
.af1c	38		sec				sec
.af1d	ed 4e 06	sbc $064e			sbc 	GXY0
.af20	4a		lsr a				lsr 	a
.af21	8d ea 06	sta $06ea			sta 	GXDiffY
.af24	9c ec 06	stz $06ec			stz 	GXDXNegative 				; clear -ve flag
.af27	38		sec				sec
.af28	ad 50 06	lda $0650			lda 	GXX1
.af2b	ed 4c 06	sbc $064c			sbc 	GXX0
.af2e	8d e9 06	sta $06e9			sta 	GXDiffX
.af31	ad 51 06	lda $0651			lda 	GXX1+1 						; calculate MSB
.af34	ed 4d 06	sbc $064d			sbc 	GXX0+1
.af37	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.af38	6e e9 06	ror $06e9			ror 	GXDiffX
.af3b	0a		asl a				asl 	a
.af3c	10 0c		bpl $af4a			bpl 	_GDXNotNegative
.af3e	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.af40	38		sec				sec
.af41	ed e9 06	sbc $06e9			sbc 	GXDiffX
.af44	8d e9 06	sta $06e9			sta 	GXDiffX
.af47	ce ec 06	dec $06ec			dec 	GXDXNegative 				; -ve flag = $FF.
.af4a					_GDXNotNegative:
.af4a	9c eb 06	stz $06eb			stz 	GXIsDiffYLarger 			; clear larger flag
.af4d	ad ea 06	lda $06ea			lda 	GXDiffY 					; set adjust and total.
.af50	8d ee 06	sta $06ee			sta 	GXAdjust
.af53	ad e9 06	lda $06e9			lda 	GXDiffX
.af56	8d ef 06	sta $06ef			sta 	GXTotal
.af59	ad ea 06	lda $06ea			lda 	GXDiffY 					; if dy > dx
.af5c	cd e9 06	cmp $06e9			cmp 	GXDiffX
.af5f	90 0f		bcc $af70			bcc 	_GDXNotLarger
.af61	ce eb 06	dec $06eb			dec 	GXIsDiffYLarger 			; set the dy larger flag
.af64	ad e9 06	lda $06e9			lda 	GXDiffX 					; set adjust and total other way round
.af67	8d ee 06	sta $06ee			sta 	GXAdjust
.af6a	ad ea 06	lda $06ea			lda 	GXDiffY
.af6d	8d ef 06	sta $06ef			sta 	GXTotal
.af70					_GDXNotLarger:
.af70	ad ef 06	lda $06ef			lda 	GXTotal
.af73	4a		lsr a				lsr 	a
.af74	8d ed 06	sta $06ed			sta 	GXPosition
.af77	60		rts				rts
.06e9					GXDiffX:
>06e9							.fill 	1
.06ea					GXDiffY:
>06ea							.fill 	1
.06eb					GXIsDiffYLarger:
>06eb							.fill 	1
.06ec					GXDXNegative:
>06ec							.fill 	1
.06ed					GXPosition:
>06ed							.fill 	1
.06ee					GXAdjust:
>06ee							.fill 	1
.06ef					GXTotal:
>06ef							.fill 	1
.06f0					GXAddSelect:
>06f0							.fill 	1
.af78					GXSetColourMode:
.af78	a6 36		ldx $36				ldx 	gxzTemp0
.af7a	8e 5a 06	stx $065a			stx 	gxColour 								; set colour
.af7d	a5 37		lda $37				lda 	gxzTemp0+1 								;
.af7f	8d 59 06	sta $0659			sta 	gxMode 									; set mode
.af82	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.af84	9c 5c 06	stz $065c			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.af87	ae 5a 06	ldx $065a			ldx 	gxColour
.af8a	8e 5b 06	stx $065b			stx 	gxEORValue
.af8d	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.af8f	90 03		bcc $af94			bcc 	_GXSDCNotAndColour
.af91	8e 5c 06	stx $065c			stx 	gxANDValue
.af94					_GXSDCNotAndColour:
.af94	d0 03		bne $af99			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.af96	9c 5b 06	stz $065b			stz 	gxEORValue
.af99					_GXSDCNotAnd:
.af99	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.af9a	90 08		bcc $afa4			bcc 	_GXSDCNoFlip
.af9c	ad 5c 06	lda $065c			lda	 	gxANDValue
.af9f	49 ff		eor #$ff			eor 	#$FF
.afa1	8d 5c 06	sta $065c			sta 	gxANDValue
.afa4					_GXSDCNoFlip:
.afa4	18		clc				clc
.afa5	60		rts				rts
.afa6					GXPlotPoint:
.afa6	20 23 b3	jsr $b323			jsr 	GXOpenBitmap 				; start drawing
.afa9	20 33 b3	jsr $b333			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afac	ac 5e 06	ldy $065e			ldy 	gsOffset
.afaf	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.afb1	2d 5c 06	and $065c			and 	gxANDValue
.afb4	4d 5b 06	eor $065b			eor 	gxEORValue
.afb7	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.afb9	20 2b b3	jsr $b32b			jsr 	GXCloseBitmap 				; stop drawing and exit
.afbc	18		clc				clc
.afbd	60		rts				rts
.afbe					GXFillRectangle:
.afbe	38		sec				sec
.afbf	80 01		bra $afc2			bra 	GXRectangle
.afc1					GXFrameRectangle:
.afc1	18		clc				clc
.afc2					GXRectangle:
.afc2	ad 55 06	lda $0655			lda 	gxBitmapsOn
.afc5	f0 35		beq $affc			beq 	_GXRFail
.afc7	08		php				php 								; save Fill flag (CS)
.afc8	20 23 b3	jsr $b323			jsr 	GXOpenBitmap 				; start drawing
.afcb	20 4b b4	jsr $b44b			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.afce	20 33 b3	jsr $b333			jsr 	GXPositionCalc 				; setup gxzScreen, gsOffset and the position.
.afd1	38		sec				sec 								; sec = Draw line
.afd2	20 fe af	jsr $affe			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.afd5	ad 4e 06	lda $064e			lda 	gxY0 						; reached end of rectangle ?
.afd8	cd 52 06	cmp $0652			cmp 	gxY1
.afdb	f0 19		beq $aff6			beq 	_GXRectangleExit
.afdd					_GXRectLoop:
.afdd	20 89 b3	jsr $b389			jsr 	GXMovePositionDown 			; down one.
.afe0	ee 4e 06	inc $064e			inc 	gxY0 						; change Y pos
.afe3	ad 4e 06	lda $064e			lda 	gxY0 						; reached last line
.afe6	cd 52 06	cmp $0652			cmp 	gXY1
.afe9	f0 07		beq $aff2			beq 	_GXLastLine
.afeb	28		plp				plp 								; get flag back
.afec	08		php				php
.afed	20 fe af	jsr $affe			jsr 	GXDrawLineX1X0 				; draw horizontal line
.aff0	80 eb		bra $afdd			bra 	_GXRectLoop
.aff2					_GXLastLine:
.aff2	38		sec				sec
.aff3	20 fe af	jsr $affe			jsr 	GXDrawLineX1X0
.aff6					_GXRectangleExit:
.aff6	68		pla				pla 								; throw fill flag.
.aff7	20 2b b3	jsr $b32b			jsr 	GXCloseBitmap 				; stop drawing and exit
.affa	18		clc				clc
.affb	60		rts				rts
.affc					_GXRFail:
.affc	38		sec				sec
.affd	60		rts				rts
.affe					GXDrawLineX1X0:
.affe	08		php				php 								; save solid/either-end
.afff	38		sec				sec
.b000	ad 50 06	lda $0650			lda		gXX1
.b003	ed 4c 06	sbc $064c			sbc 	gXX0
.b006	85 36		sta $36				sta 	gxzTemp0
.b008	ad 51 06	lda $0651			lda 	gXX1+1
.b00b	ed 4d 06	sbc $064d			sbc 	gXX0+1
.b00e	85 37		sta $37				sta 	gxzTemp0+1
.b010	28		plp				plp
.b011					GXDrawLineTemp0:
.b011	a5 3c		lda $3c				lda 	gxzScreen 						; push gxzScreen, gsOffset and GXEditSlot on stack
.b013	48		pha				pha
.b014	a5 3d		lda $3d				lda 	gxzScreen+1
.b016	48		pha				pha
.b017	ad 5e 06	lda $065e			lda 	gsOffset
.b01a	48		pha				pha
.b01b	a5 0b		lda $0b				lda 	GXEditSlot
.b01d	48		pha				pha
.b01e	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y offset
.b021	90 1e		bcc $b041			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.b023					_GXDLTLine:
.b023	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b025	2d 5c 06	and $065c			and 	gxANDValue
.b028	4d 5b 06	eor $065b			eor 	gxEORValue
.b02b	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b02d	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.b02f	d0 04		bne $b035			bne 	_GXDLTNoBorrow
.b031	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.b033	30 2e		bmi $b063			bmi 	_GXDLTExit
.b035					_GXDLTNoBorrow:
.b035	c6 36		dec $36				dec 	gxzTemp0
.b037	c8		iny				iny 								; next slot.
.b038	d0 e9		bne $b023			bne 	_GXDLTLine
.b03a	e6 3d		inc $3d				inc 	gxzScreen+1 					; carry to next
.b03c	20 71 b0	jsr $b071			jsr 	GXDLTCheckWrap				; check for new page.
.b03f	80 e2		bra $b023			bra 	_GXDLTLine
.b041					_GXDLTEndPoints:
.b041	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel
.b043	2d 5c 06	and $065c			and 	gxANDValue
.b046	4d 5b 06	eor $065b			eor 	gxEORValue
.b049	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b04b	98		tya				tya 								; advance to right side
.b04c	18		clc				clc
.b04d	65 36		adc $36				adc 	gxzTemp0
.b04f	a8		tay				tay
.b050	a5 3d		lda $3d				lda 	gxzScreen+1
.b052	65 37		adc $37				adc 	gxzTemp0+1
.b054	85 3d		sta $3d				sta 	gxzScreen+1
.b056	20 71 b0	jsr $b071			jsr 	GXDLTCheckWrap 			; fix up.
.b059	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 					; set pixel on the right
.b05b	2d 5c 06	and $065c			and 	gxANDValue
.b05e	4d 5b 06	eor $065b			eor 	gxEORValue
.b061	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b063					_GXDLTExit:
.b063	68		pla				pla
.b064	85 0b		sta $0b				sta 	GXEditSlot
.b066	68		pla				pla
.b067	8d 5e 06	sta $065e			sta 	gsOffset
.b06a	68		pla				pla
.b06b	85 3d		sta $3d				sta 	gxzScreen+1
.b06d	68		pla				pla
.b06e	85 3c		sta $3c				sta 	gxzScreen
.b070	60		rts				rts
.b071					GXDLTCheckWrap:
.b071	a5 3d		lda $3d				lda 	gxzScreen+1 					; check end of page
.b073	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.b075	90 06		bcc $b07d			bcc 	_GXDLTCWExit
.b077	e9 20		sbc #$20			sbc 	#$20 						; fix up
.b079	85 3d		sta $3d				sta 	gxzScreen+1
.b07b	e6 0b		inc $0b				inc 	GXEditSlot
.b07d					_GXDLTCWExit:
.b07d	60		rts				rts
.b07e					GXDrawGraphicElement:
.b07e	8d f1 06	sta $06f1			sta 	gxSize 						; save size
.b081	3a		dec a				dec 	a
.b082	8d f2 06	sta $06f2			sta 	gxMask 						; and mask
.b085	ad 55 06	lda $0655			lda 	gxBitmapsOn 				; check BMP on
.b088	f0 67		beq $b0f1			beq 	_GXSLFail
.b08a	ad 4e 06	lda $064e			lda 	gxY0 						; push Y on stack
.b08d	48		pha				pha
.b08e	8c f4 06	sty $06f4			sty 	gxAcquireVector+1 			; and acquisition vector
.b091	8e f3 06	stx $06f3			stx 	gxAcquireVector
.b094	20 23 b3	jsr $b323			jsr 	gxOpenBitmap 				; open the bitmap.
.b097	ad f6 06	lda $06f6			lda 	gxUseMode 					; scale bits
.b09a	4a		lsr a				lsr 	a
.b09b	4a		lsr a				lsr 	a
.b09c	4a		lsr a				lsr 	a
.b09d	29 07		and #$07			and		#7
.b09f	1a		inc a				inc 	a
.b0a0	8d f5 06	sta $06f5			sta 	gxScale
.b0a3	64 38		stz $38				stz 	gxzTemp1					; start first line
.b0a5					_GXGELoop:
.b0a5	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.b0a7	2c f6 06	bit $06f6			bit 	gxUseMode 					; check for flip.
.b0aa	10 06		bpl $b0b2			bpl		_GXNoVFlip
.b0ac	ad f2 06	lda $06f2			lda 	gxMask
.b0af	38		sec				sec
.b0b0	e5 38		sbc $38				sbc 	gxzTemp1
.b0b2					_GXNoVFlip:
.b0b2	aa		tax				tax 								; get the Xth line.
.b0b3	20 f3 b0	jsr $b0f3			jsr 	_GXCallAcquire 				; get that data.
.b0b6	ad f5 06	lda $06f5			lda 	gxScale 					; do scale identical copies of that line.
.b0b9	85 39		sta $39				sta 	gxzTemp1+1
.b0bb					_GXGELoop2:
.b0bb	ad 4e 06	lda $064e			lda 	gxY0 						; off screen
.b0be	cd 58 06	cmp $0658			cmp 	gxHeight
.b0c1	b0 10		bcs $b0d3			bcs 	_GXDGEExit
.b0c3	20 f6 b0	jsr $b0f6			jsr 	GXRenderOneLine 			; render line
.b0c6	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.b0c8	d0 f1		bne $b0bb			bne 	_GXGELoop2
.b0ca	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.b0cc	a5 38		lda $38				lda 	gxzTemp1
.b0ce	cd f1 06	cmp $06f1			cmp 	gxSize
.b0d1	d0 d2		bne $b0a5			bne 	_GXGELoop
.b0d3					_GXDGEExit:
.b0d3	68		pla				pla 								; restore Y for next time
.b0d4	8d 4e 06	sta $064e			sta 	gxY0
.b0d7	ae f5 06	ldx $06f5			ldx 	gxScale 					; get scale (1-8)
.b0da					_GXShiftLeft:
.b0da	18		clc				clc
.b0db	ad f1 06	lda $06f1			lda 	gxSize
.b0de	6d 4c 06	adc $064c			adc 	gxX0
.b0e1	8d 4c 06	sta $064c			sta 	gxX0
.b0e4	90 03		bcc $b0e9			bcc 	_GXSLNoCarry
.b0e6	ee 4d 06	inc $064d			inc 	gxX0+1
.b0e9					_GXSLNoCarry:
.b0e9	ca		dex				dex
.b0ea	d0 ee		bne $b0da			bne 	_GXShiftLeft
.b0ec	20 2b b3	jsr $b32b			jsr 	GXCloseBitmap
.b0ef	18		clc				clc
.b0f0	60		rts				rts
.b0f1					_GXSLFail:
.b0f1	38		sec				sec
.b0f2	60		rts				rts
.b0f3					_GXCallAcquire:
.b0f3	6c f3 06	jmp ($06f3)			jmp 	(gxAcquireVector)
.b0f6					GXRenderOneLine:
.b0f6	20 33 b3	jsr $b333			jsr 	GXPositionCalc 				; calculate position/offset.
.b0f9	ac 5e 06	ldy $065e			ldy 	gsOffset 					; Y contains position.
.b0fc	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.b0fe					_GXROLLoop1:
.b0fe	ad f5 06	lda $06f5			lda 	gxScale 					; set to do 'scale' times
.b101	85 3b		sta $3b				sta 	gxzTemp2+1
.b103					_GXROLLoop2:
.b103	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.b105	2c 59 06	bit $0659			bit 	gxMode 						; check H Flip
.b108	50 06		bvc $b110			bvc 	_GXNoHFlip
.b10a	ad f2 06	lda $06f2			lda 	gxMask
.b10d	38		sec				sec
.b10e	e5 3a		sbc $3a				sbc 	gxzTemp2
.b110					_GXNoHFlip:
.b110	aa		tax				tax 								; read from the pixel buffer
.b111	bd fa 05	lda $05fa,x			lda 	gxPixelBuffer,x
.b114	d0 07		bne $b11d			bne 	_GXDraw 					; draw if non zero
.b116	ad f6 06	lda $06f6			lda 	gxUseMode 					; check to see if solid background
.b119	29 04		and #$04			and 	#4
.b11b	f0 0a		beq $b127			beq 	_GXZeroPixel
.b11d					_GXDraw:
.b11d	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.b11f	2d 5c 06	and $065c			and 	gxANDValue
.b122	5d fa 05	eor $05fa,x			eor 	gxPixelBuffer,x
.b125	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.b127					_GXZeroPixel:
.b127	c8		iny				iny 								; advance pointer
.b128	d0 05		bne $b12f			bne 	_GXNoShift
.b12a	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.b12c	20 71 b0	jsr $b071			jsr 	GXDLTCheckWrap				; check for new page.
.b12f					_GXNoShift:
.b12f	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.b131	d0 d0		bne $b103			bne 	_GXROLLoop2
.b133	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.b135	a5 3a		lda $3a				lda 	gxzTemp2
.b137	cd f1 06	cmp $06f1			cmp 	gxSize
.b13a	d0 c2		bne $b0fe			bne 	_GXROLLoop1
.b13c	ee 4e 06	inc $064e			inc 	gxY0
.b13f	60		rts				rts
.06f1					gxSize:
>06f1							.fill 	1
.06f2					gxMask:
>06f2							.fill 	1
.06f3					gxAcquireVector:
>06f3							.fill 	2
.06f5					gxScale:
>06f5							.fill 	1
.06f6					gxUseMode:
>06f6							.fill 	1
.b140					GXFontHandler:
.b140	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b142	4d 59 06	eor $0659			eor 	gxMode
.b145	8d f6 06	sta $06f6			sta 	gxUseMode
.b148	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.b14a	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.b14c	26 37		rol $37				rol	 	gxzTemp0+1
.b14e	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.b150	26 37		rol $37				rol	 	gxzTemp0+1
.b152	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.b154	26 37		rol $37				rol	 	gxzTemp0+1
.b156	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.b158	09 c0		ora #$c0			ora 	#$C0
.b15a	85 37		sta $37				sta 	gxzTemp0+1
.b15c	a9 08		lda #$08			lda 	#8 							; size 8x8
.b15e	a2 66		ldx #$66			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.b160	a0 b1		ldy #$b1			ldy 	#GXGetGraphicDataFont >> 8
.b162	20 7e b0	jsr $b07e			jsr 	GXDrawGraphicElement
.b165	60		rts				rts
.b166					GXGetGraphicDataFont:
.b166	8a		txa				txa 								; X->Y
.b167	a8		tay				tay
.b168	a6 01		ldx $01				ldx 	1 							; preserve old value
.b16a	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.b16c	85 01		sta $01				sta 	1
.b16e	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.b170	86 01		stx $01				stx 	1 							; put old value back.
.b172	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.b174					_GXExpand:
.b174	9e fa 05	stz $05fa,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.b177	0a		asl a				asl 	a 							; shift bit 7 into C
.b178	90 08		bcc $b182			bcc 	_GXNoPixel
.b17a	48		pha				pha 								; if set, set pixel buffer to current colour.
.b17b	ad 5a 06	lda $065a			lda 	gxColour
.b17e	9d fa 05	sta $05fa,x			sta 	gxPixelBuffer,x
.b181	68		pla				pla
.b182					_GXNoPixel:
.b182	e8		inx				inx 								; do the whole byte.
.b183	e0 08		cpx #$08			cpx 	#8
.b185	d0 ed		bne $b174			bne 	_GXExpand
.b187	60		rts				rts
.b188					GXSpriteHandler:
.b188	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.b18a	4d 59 06	eor $0659			eor 	gxMode
.b18d	8d f6 06	sta $06f6			sta 	gxUseMode
.b190	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.b192	da		phx				phx
.b193	20 23 b3	jsr $b323			jsr 	GXOpenBitmap 				; can access sprite information
.b196	68		pla				pla
.b197	20 04 b4	jsr $b404			jsr 	GXFindSprite 				; get the sprite address
.b19a	08		php				php
.b19b	20 2b b3	jsr $b32b			jsr 	GXCloseBitmap
.b19e	28		plp				plp
.b19f	b0 0a		bcs $b1ab			bcs		_GXSHExit 					; exit if find failed.
.b1a1	ad f7 06	lda $06f7			lda 	GXSizePixels 				; return size
.b1a4	a2 ac		ldx #$ac			ldx 	#GXSpriteAcquire & $FF
.b1a6	a0 b1		ldy #$b1			ldy 	#GXSpriteAcquire >> 8
.b1a8	20 7e b0	jsr $b07e			jsr 	GXDrawGraphicElement
.b1ab					_GXSHExit:
.b1ab	60		rts				rts
.b1ac					GXSpriteAcquire:
.b1ac	ad 57 06	lda $0657			lda 	GXSpritePage				; point to base page
.b1af	85 0b		sta $0b				sta 	GXEditSlot
.b1b1	86 36		stx $36				stx 	zTemp0 						; row number x 1,2,3,4
.b1b3	a9 00		lda #$00			lda 	#0
.b1b5	ae f8 06	ldx $06f8			ldx 	GXSizeBits
.b1b8					_GXTimesRowNumber:
.b1b8	18		clc				clc
.b1b9	65 36		adc $36				adc 	zTemp0
.b1bb	ca		dex				dex
.b1bc	10 fa		bpl $b1b8			bpl 	_GXTimesRowNumber
.b1be	64 37		stz $37				stz 	gxzTemp0+1
.b1c0	0a		asl a				asl 	a 							; row x 2,4,6,8
.b1c1	26 37		rol $37				rol 	gxzTemp0+1
.b1c3	0a		asl a				asl 	a 							; row x 4,8,12,16
.b1c4	26 37		rol $37				rol 	gxzTemp0+1
.b1c6	0a		asl a				asl 	a 							; row x 8,16,24,32
.b1c7	26 37		rol $37				rol 	gxzTemp0+1
.b1c9	85 36		sta $36				sta 	gxzTemp0
.b1cb	18		clc				clc 								; add base address.
.b1cc	a5 36		lda $36				lda 	gxzTemp0
.b1ce	6d fa 06	adc $06fa			adc 	GXSpriteOffset
.b1d1	85 36		sta $36				sta 	gxzTemp0
.b1d3	a5 37		lda $37				lda 	gxzTemp0+1
.b1d5	6d fb 06	adc $06fb			adc 	GXSpriteOffset+1
.b1d8					_GXSAFindPage:
.b1d8	c9 20		cmp #$20			cmp 	#$20 						; on this page
.b1da	90 06		bcc $b1e2			bcc 	_GXSAFoundPage
.b1dc	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.b1de	e6 0b		inc $0b				inc 	GXEditSlot
.b1e0	80 f6		bra $b1d8			bra 	_GXSAFindPage
.b1e2					_GXSAFoundPage:
.b1e2	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.b1e4	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.b1e6	a0 00		ldy #$00			ldy 	#0
.b1e8					_GXSACopyLoop:
.b1e8	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.b1ea	99 fa 05	sta $05fa,y			sta 	gxPixelBuffer,y
.b1ed	c8		iny				iny
.b1ee	cc f7 06	cpy $06f7			cpy 	GXSizePixels
.b1f1	d0 f5		bne $b1e8			bne 	_GXSACopyLoop
.b1f3	60		rts				rts
.b1f4					GXSelect:
.b1f4	ad 54 06	lda $0654			lda 	gxSpritesOn
.b1f7	f0 22		beq $b21b			beq 	_GXSFail
.b1f9	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.b1fb	c9 40		cmp #$40			cmp 	#64
.b1fd	b0 1c		bcs $b21b			bcs 	_GXSFail
.b1ff	8d 5f 06	sta $065f			sta 	GSCurrentSpriteID
.b202	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.b204	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.b206	06 36		asl $36				asl 	gxzTemp0
.b208	06 36		asl $36				asl 	gxzTemp0
.b20a	06 36		asl $36				asl 	gxzTemp0
.b20c	2a		rol a				rol 	a
.b20d	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.b20f	8d 61 06	sta $0661			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.b212	85 37		sta $37				sta 	gxzTemp0+1
.b214	a5 36		lda $36				lda 	gxzTemp0
.b216	8d 60 06	sta $0660			sta 	GSCurrentSpriteAddr
.b219	18		clc				clc
.b21a	60		rts				rts
.b21b					_GXSFail:
.b21b	38		sec				sec
.b21c	60		rts				rts
.b21d					GXSelectImage:
.b21d	ad 54 06	lda $0654			lda 	gxSpritesOn
.b220	f0 74		beq $b296			beq 	_GXSIFail
.b222	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b225	f0 6f		beq $b296			beq 	_GXSIFail 					; (checking the MSB)
.b227	64 01		stz $01				stz 	1
.b229	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.b22b	d0 6b		bne $b298			bne 	_GXSIHide
.b22d	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.b22f	48		pha				pha
.b230	20 23 b3	jsr $b323			jsr 	GXOpenBitmap
.b233	68		pla				pla
.b234	20 04 b4	jsr $b404			jsr 	GXFindSprite
.b237	b0 5a		bcs $b293			bcs 	_GXSICloseFail 				; no image
.b239	a0 01		ldy #$01			ldy 	#1
.b23b	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b23e	85 36		sta $36				sta 	gxzTemp0
.b240	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b243	85 37		sta $37				sta 	gxzTemp0+1
.b245	ad fa 06	lda $06fa			lda 	GXSpriteOffset
.b248	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b24a	18		clc				clc
.b24b	ad fb 06	lda $06fb			lda 	GXSpriteOffset+1
.b24e	6d 62 06	adc $0662			adc 	GXSpriteOffsetBase
.b251	c8		iny				iny
.b252	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b254	ad 63 06	lda $0663			lda 	GXSpriteOffsetBase+1
.b257	69 00		adc #$00			adc 	#0
.b259	c8		iny				iny
.b25a	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.b25c	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get raw size
.b25f	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.b261	2a		rol a				rol 	a 							; x 2
.b262	0a		asl a				asl 	a 							; x 4
.b263	0a		asl a				asl 	a 							; x 8
.b264	0a		asl a				asl 	a 							; x 16
.b265	0d f9 06	ora $06f9			ora 	GXSpriteLUT 				; Or with LUT
.b268	0a		asl a				asl 	a 							; 1 shift
.b269	09 01		ora #$01			ora 	#1 							; enable sprite.
.b26b	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.b26d	20 2b b3	jsr $b32b			jsr 	GXCloseBitmap
.b270	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.b273	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x 				; clear upper two bits of size
.b276	29 3f		and #$3f			and 	#$3F
.b278	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b27b	ad f8 06	lda $06f8			lda 	GXSizeBits 					; get bit size
.b27e	6a		ror a				ror 	a 							; shift into bits 6/7
.b27f	6a		ror a				ror 	a
.b280	6a		ror a				ror 	a
.b281	29 c0		and #$c0			and 	#$C0
.b283	1d a4 06	ora $06a4,x			ora 	GXSpriteHigh,x 				; put in  upper 2 bits of sprite data
.b286	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b289	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; clear hidden flag.
.b28c	29 7f		and #$7f			and 	#$7F
.b28e	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b291	18		clc				clc
.b292	60		rts				rts
.b293					_GXSICloseFail:
.b293	20 2b b3	jsr $b32b			jsr 	GXCloseBitmap
.b296					_GXSIFail:
.b296	38		sec				sec
.b297	60		rts				rts
.b298					_GXSIHide:
.b298	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.b29b	85 36		sta $36				sta 	gxzTemp0
.b29d	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1
.b2a0	85 37		sta $37				sta 	gxzTemp0+1
.b2a2	a9 00		lda #$00			lda 	#0
.b2a4	92 36		sta ($36)			sta 	(gxzTemp0)
.b2a6	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get sprite ID
.b2a9	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x 				; set the hidden bit.
.b2ac	09 80		ora #$80			ora 	#$80
.b2ae	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b2b1	18		clc				clc
.b2b2	60		rts				rts
.b2b3					GXMoveSprite:
.b2b3	ad 54 06	lda $0654			lda 	gxSpritesOn
.b2b6	f0 65		beq $b31d			beq 	_GXSIFail
.b2b8	ad 61 06	lda $0661			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.b2bb	f0 60		beq $b31d			beq 	_GXSIFail
.b2bd	85 37		sta $37				sta 	gxzTemp0+1
.b2bf	a0 04		ldy #$04			ldy 	#4
.b2c1	ad 60 06	lda $0660			lda 	GSCurrentSpriteAddr
.b2c4	85 36		sta $36				sta 	gxzTemp0
.b2c6	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.b2c9	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b2cc	2a		rol a				rol 	a	 						; into bits 0,1.
.b2cd	2a		rol a				rol 	a
.b2ce	2a		rol a				rol 	a
.b2cf	29 03		and #$03			and 	#3
.b2d1	aa		tax				tax
.b2d2	bd 1f b3	lda $b31f,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.b2d5	48		pha				pha
.b2d6	18		clc				clc
.b2d7	6d 4c 06	adc $064c			adc 	gxX0						; copy position.
.b2da	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2dc	c8		iny				iny
.b2dd	ad 4d 06	lda $064d			lda 	gxX0+1
.b2e0	69 00		adc #$00			adc 	#0
.b2e2	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2e4	c8		iny				iny
.b2e5	68		pla				pla
.b2e6	18		clc				clc
.b2e7	6d 4e 06	adc $064e			adc 	gxY0
.b2ea	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2ec	a9 00		lda #$00			lda 	#0
.b2ee	69 00		adc #$00			adc 	#0
.b2f0	c8		iny				iny
.b2f1	91 36		sta ($36),y			sta 	(gxzTemp0),y
.b2f3	4e 4d 06	lsr $064d			lsr 	gxX0+1 						; divide X by 4
.b2f6	6e 4c 06	ror $064c			ror 	gxX0
.b2f9	4e 4c 06	lsr $064c			lsr 	gxX0
.b2fc	4e 4e 06	lsr $064e			lsr 	gxY0 						; divide Y by 4
.b2ff	4e 4e 06	lsr $064e			lsr 	gxY0
.b302	ae 5f 06	ldx $065f			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.b305	bd 64 06	lda $0664,x			lda 	GXSpriteLow,x
.b308	29 80		and #$80			and 	#$80
.b30a	0d 4c 06	ora $064c			ora 	gxX0
.b30d	9d 64 06	sta $0664,x			sta 	GXSpriteLow,x
.b310	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b313	29 c0		and #$c0			and 	#$C0
.b315	0d 4e 06	ora $064e			ora 	gxY0
.b318	9d a4 06	sta $06a4,x			sta 	GXSpriteHigh,x
.b31b	18		clc				clc
.b31c	60		rts				rts
.b31d					_GXSIFail:
.b31d	38		sec				sec
.b31e	60		rts				rts
.b31f					_GXMSOffset:
>b31f	1c						.byte 	32-8/2
>b320	18						.byte 	32-16/2
>b321	14						.byte 	32-24/2
>b322	10						.byte 	32-32/2
.b323					GXOpenBitmap:
.b323	78		sei				sei 								; no interrupts here
.b324	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.b326	8d 5d 06	sta $065d			sta 	gxOriginalLUTValue
.b329	58		cli				cli
.b32a	60		rts				rts
.b32b					GXCloseBitmap:
.b32b	78		sei				sei
.b32c	ad 5d 06	lda $065d			lda 	gxOriginalLUTValue 			; restore LUT slot value
.b32f	85 0b		sta $0b				sta 	GXEditSlot
.b331	58		cli				cli
.b332	60		rts				rts
.b333					GXPositionCalc:
.b333	a5 36		lda $36				lda 	gxzTemp0 					; save temp memory slot
.b335	48		pha				pha
.b336	ad 4e 06	lda $064e			lda 	GXY0 						; gxzScreen = Y0
.b339	85 3c		sta $3c				sta 	gxzScreen
.b33b	64 3d		stz $3d				stz 	gxzScreen+1
.b33d	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.b33f	26 3d		rol $3d				rol 	gxzScreen+1
.b341	06 3c		asl $3c				asl 	gxzScreen
.b343	26 3d		rol $3d				rol 	gxzScreen+1
.b345	18		clc				clc 								; gxzScreen = Y0 * 5, as it's still in A
.b346	65 3c		adc $3c				adc 	gxzScreen
.b348	85 3c		sta $3c				sta 	gxzScreen
.b34a	90 02		bcc $b34e			bcc 	_GXPCNoCarry
.b34c	e6 3d		inc $3d				inc 	gxzScreen+1
.b34e					_GXPCNoCarry:
.b34e	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10. Needs to be multiplied by another
.b350	26 3d		rol $3d				rol 	gxzScreen+1 					; 32. At this point the MSB contains the offset
.b352	a5 3d		lda $3d				lda	 	gxzScreen+1 					; so save this in zTemp0 and zero it.
.b354	85 36		sta $36				sta 	gxzTemp0
.b356	64 3d		stz $3d				stz 	gxzScreen+1
.b358	a9 05		lda #$05			lda 	#5 							; now multiply by 32, this puts this in the range 0..8191
.b35a					_GXPCMultiply32:
.b35a	06 3c		asl $3c				asl 	gxzScreen
.b35c	26 3d		rol $3d				rol 	gxzScreen+1
.b35e	3a		dec a				dec 	a
.b35f	d0 f9		bne $b35a			bne 	_GXPCMultiply32
.b361	18		clc				clc
.b362	ad 4c 06	lda $064c			lda 	GXX0 						; add X to this value, put the result in gsOffset, gxzScreen has to be on a page boundary
.b365	65 3c		adc $3c				adc 	gxzScreen
.b367	8d 5e 06	sta $065e			sta 	gsOffset
.b36a	ad 4d 06	lda $064d			lda 	GXX0+1
.b36d	65 3d		adc $3d				adc 	gxzScreen+1
.b36f	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.b371	90 04		bcc $b377			bcc 	_GXPCNoOverflow
.b373	29 1f		and #$1f			and 	#$1F 						; fix it up
.b375	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.b377					_GXPCNoOverflow:
.b377	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.b379	85 3d		sta $3d				sta 	gxzScreen+1
.b37b	64 3c		stz $3c				stz 	gxzScreen
.b37d	18		clc				clc
.b37e	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.b380	6d 56 06	adc $0656			adc 	gxBasePage 					; by adding the base page
.b383	85 0b		sta $0b				sta 	GXEditSlot 				; and map it into memory.
.b385	68		pla				pla
.b386	85 36		sta $36				sta 	gxzTemp0
.b388	60		rts				rts
.b389					GXMovePositionDown:
.b389	18		clc				clc 								; add 320 to offset/temp+1
.b38a	ad 5e 06	lda $065e			lda 	gsOffset
.b38d	69 40		adc #$40			adc 	#64
.b38f	8d 5e 06	sta $065e			sta 	gsOffset
.b392	a5 3d		lda $3d				lda 	gxzScreen+1
.b394	69 01		adc #$01			adc 	#1
.b396	85 3d		sta $3d				sta 	gxzScreen+1
.b398	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page
.b39a	90 07		bcc $b3a3			bcc 	_GXMPDExit
.b39c	38		sec				sec  								; next page
.b39d	e9 20		sbc #$20			sbc 	#$20
.b39f	85 3d		sta $3d				sta 	gxzScreen+1
.b3a1	e6 0b		inc $0b				inc 	GXEditSlot
.b3a3					_GXMPDExit:
.b3a3	60		rts				rts
.b3a4					GXCollide:
.b3a4	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.b3a6	aa		tax				tax
.b3a7	05 37		ora $37				ora 	gxzTemp0+1
.b3a9	29 c0		and #$c0			and 	#$C0
.b3ab	38		sec				sec
.b3ac	d0 53		bne $b401			bne 	_GXCollideFail 				; if either >= 64, fail.
.b3ae	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.b3b0	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y 				; check if either hidden bit is set
.b3b3	1d 64 06	ora $0664,x			ora 	GXSpriteLow,x
.b3b6	30 48		bmi $b400			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.b3b8	18		clc				clc 								; need to calculate sum of sizes.
.b3b9	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y
.b3bc	7d a4 06	adc $06a4,x			adc 	GXSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.b3bf	29 c0		and #$c0			and 	#$C0 					 	; mask off
.b3c1	6a		ror a				ror 	a 							; 5/6/7
.b3c2	4a		lsr a				lsr 	a 							; 4/5/6
.b3c3	4a		lsr a				lsr 	a 							; 3/4/5
.b3c4	4a		lsr a				lsr 	a 							; 2/3/4
.b3c5	18		clc				clc
.b3c6	69 08		adc #$08			adc 	#$08
.b3c8	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.b3c9	4a		lsr a				lsr 	a
.b3ca	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.b3cc	b9 a4 06	lda $06a4,y			lda 	GXSpriteHigh,y 				; calculate y1-y0
.b3cf	29 3f		and #$3f			and 	#$3F
.b3d1	85 39		sta $39				sta 	gxzTemp1+1
.b3d3	38		sec				sec
.b3d4	bd a4 06	lda $06a4,x			lda 	GXSpriteHigh,x
.b3d7	29 3f		and #$3f			and 	#$3F
.b3d9	e5 39		sbc $39				sbc 	gxzTemp1+1
.b3db	b0 03		bcs $b3e0			bcs 	_GXCAbs1 					; calculate |y1-y0|
.b3dd	49 ff		eor #$ff			eor 	#$FF
.b3df	1a		inc a				inc 	a
.b3e0					_GXCAbs1:
.b3e0	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3e2	b0 1c		bcs $b400			bcs 	_GXOkayFail
.b3e4	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.b3e6	38		sec				sec 								; calculate |x1-x0|
.b3e7	b9 64 06	lda $0664,y			lda 	GXSpriteLow,y
.b3ea	fd 64 06	sbc $0664,x			sbc 	GXSpriteLow,x
.b3ed	b0 03		bcs $b3f2			bcs 	_GXCAbs2
.b3ef	49 ff		eor #$ff			eor 	#$FF
.b3f1	1a		inc a				inc 	a
.b3f2					_GXCAbs2:
.b3f2	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.b3f4	b0 0a		bcs $b400			bcs 	_GXOkayFail
.b3f6	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.b3f8	90 02		bcc $b3fc			bcc 	_GXCHaveLowest
.b3fa	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.b3fc					_GXCHaveLowest:
.b3fc	0a		asl a				asl 	a 							; scale to allow for >> 2
.b3fd	0a		asl a				asl 	a
.b3fe	18		clc				clc
.b3ff	60		rts				rts
.b400					_GXOkayFail:
.b400	18		clc				clc
.b401					_GXCollideFail:
.b401	a9 ff		lda #$ff			lda 	#$FF
.b403	60		rts				rts
.b404					GXFindSprite:
.b404	aa		tax				tax
.b405	ad 57 06	lda $0657			lda 	GXSpritePage 				; access the base page of the sprite
.b408	85 0b		sta $0b				sta 	GXEditSlot
.b40a	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; check a valid sprite
.b40d	1d 00 60	ora $6000,x			ora 	GXMappingAddress,x
.b410	f0 33		beq $b445			beq 	_GXFSFail
.b412	bd 00 61	lda $6100,x			lda 	GXMappingAddress+256,x 		; MSB
.b415	8d fb 06	sta $06fb			sta 	GXSpriteOffset+1
.b418	bd 00 60	lda $6000,x			lda 	GXMappingAddress,x 			; LSB
.b41b	48		pha				pha 								; save twice
.b41c	48		pha				pha
.b41d	29 03		and #$03			and 	#3 							; get sprite size
.b41f	8d f8 06	sta $06f8			sta 	GXSizeBits 					; save raw (0-3)
.b422	aa		tax				tax
.b423	bd 47 b4	lda $b447,x			lda 	_GXFXSSTTable,x 			; read sprite size
.b426	8d f7 06	sta $06f7			sta 	GXSizePixels 					; save (8/16/24/32)
.b429	68		pla				pla 								; get LUT
.b42a	4a		lsr a				lsr		a
.b42b	4a		lsr a				lsr		a
.b42c	29 03		and #$03			and 	#3
.b42e	8d f9 06	sta $06f9			sta 	GXSpriteLUT
.b431	68		pla				pla 								; address, neeeds to be x 4
.b432	29 f0		and #$f0			and 	#$F0
.b434	8d fa 06	sta $06fa			sta 	GXSpriteOffset
.b437	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b43a	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b43d	0e fa 06	asl $06fa			asl 	GXSpriteOffset
.b440	2e fb 06	rol $06fb			rol 	GXSpriteOffset+1
.b443	18		clc				clc
.b444	60		rts				rts
.b445					_GXFSFail:
.b445	38		sec				sec
.b446	60		rts				rts
.b447					_GXFXSSTTable:
>b447	08 10 18 20					.byte 	8,16,24,32
.06f7					GXSizePixels:
>06f7							.fill 	1
.06f8					GXSizeBits:
>06f8							.fill 	1
.06f9					GXSpriteLUT:
>06f9							.fill 	1
.06fa					GXSpriteOffset:
>06fa							.fill 	2
.b44b					GXSortXY:
.b44b	20 69 b4	jsr $b469			jsr 	GXSortY 					; will be sorted on Y now
.b44e	ad 4c 06	lda $064c			lda 	gxX0 						; compare X0 v X1
.b451	cd 50 06	cmp $0650			cmp 	gxX1
.b454	ad 4d 06	lda $064d			lda 	gXX0+1
.b457	ed 51 06	sbc $0651			sbc 	gXX1+1
.b45a	90 0c		bcc $b468			bcc 	_GXSXYExit 					; X0 < X1 exit
.b45c	a2 00		ldx #$00			ldx 	#0 							; swap them over
.b45e	a0 04		ldy #$04			ldy 	#4
.b460	20 7d b4	jsr $b47d			jsr 	GXSwapXY
.b463	e8		inx				inx
.b464	c8		iny				iny
.b465	20 7d b4	jsr $b47d			jsr 	GXSwapXY
.b468					_GXSXYExit:
.b468	60		rts				rts
.b469					GXSortY:
.b469	ad 4e 06	lda $064e			lda 	gxY0 						; if Y0 >= Y1
.b46c	cd 52 06	cmp $0652			cmp 	gxY1
.b46f	90 0b		bcc $b47c			bcc 	_GXSYSorted
.b471	a2 03		ldx #$03			ldx 	#3 							; swap 3-0
.b473	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.b475					_GXSwap1:
.b475	20 7d b4	jsr $b47d			jsr 	GXSwapXY
.b478	88		dey				dey
.b479	ca		dex				dex
.b47a	10 f9		bpl $b475			bpl 	_GXSwap1
.b47c					_GXSYSorted:
.b47c	60		rts				rts
.b47d					GXSwapXY:
.b47d	bd 4c 06	lda $064c,x			lda 	gxX0,x
.b480	48		pha				pha
.b481	b9 4c 06	lda $064c,y			lda 	gxX0,y
.b484	9d 4c 06	sta $064c,x			sta 	gxX0,x
.b487	68		pla				pla
.b488	99 4c 06	sta $064c,y			sta 	gxX0,y
.b48b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_tokeniser.module

=1					tokeniserIntegrated=1
.bb01					KeywordSet0:
>bb01	00 65					.text	0,$65,""               ; $80 !0:EOF
>bb03	00 58					.text	0,$58,""               ; $81 !1:SH1
>bb05	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bb07	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>bb0d	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>bb15	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>bb1b	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>bb22	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>bb2a	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>bb31	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>bb38	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8a HIT(
>bb3e	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $8b INT(
>bb44	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $8c ISVAL(
>bb4c	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $8d JOYB(
>bb53	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $8e JOYX(
>bb5a	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $8f JOYY(
>bb61	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $90 LEFT$(
>bb69	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $91 LEN(
>bb6f	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $92 MAX(
>bb75	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $93 MID$(
>bb7c	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $94 MIN(
>bb82	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $95 NOT(
>bb88	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $96 PLAYING(
>bb90	47 28
>bb92	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $97 RANDOM(
>bb9a	28
>bb9b	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $98 RIGHT$(
>bba3	28
>bba4	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $99 RND(
>bbaa	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $9a SGN(
>bbb0	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $9b SPC(
>bbb6	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $9c STR$(
>bbbd	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $9d TIMER(
>bbc5	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $9e TRUE
>bbcb	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $9f VAL(
>bbd1	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $a0 FOR
>bbd6	02 8f 49 46				.text	2,$8f,"IF"             ; $a1 IF
>bbda	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $a2 PROC
>bbe0	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $a3 REPEAT
>bbe8	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $a4 WHILE
>bbef	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $a5 ENDIF
>bbf6	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $a6 ENDPROC
>bbfe	43
>bbff	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $a7 NEXT
>bc05	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $a8 THEN
>bc0b	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $a9 UNTIL
>bc12	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $aa WEND
>bc18	02 9b 42 59				.text	2,$9b,"BY"             ; $ab BY
>bc1c	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $ac CALL
>bc22	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $ad CIRCLE
>bc2a	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $ae CLEAR
>bc31	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $af CLS
>bc36	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $b0 COLOR
>bc3d	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $b1 COLOUR
>bc45	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $b2 DATA
>bc4b	03 da 44 49 4d				.text	3,$da,"DIM"            ; $b3 DIM
>bc50	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $b4 DOWNTO
>bc58	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $b5 ELSE
>bc5e	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $b6 FROM
>bc64	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $b7 GFX
>bc69	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $b8 GOSUB
>bc70	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $b9 GOTO
>bc76	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $ba HERE
>bc7c	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $bb IMAGE
>bc83	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $bc INPUT
>bc8a	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $bd LET
>bc8f	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $be LINE
>bc95	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $bf LOCAL
>bc9c	03 db 4f 46 46				.text	3,$db,"OFF"            ; $c0 OFF
>bca1	02 9d 4f 4e				.text	2,$9d,"ON"             ; $c1 ON
>bca5	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $c2 OUTLINE
>bcad	45
>bcae	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $c3 PALETTE
>bcb6	45
>bcb7	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $c4 PLOT
>bcbd	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $c5 PRINT
>bcc4	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $c6 READ
>bcca	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $c7 RECT
>bcd0	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $c8 REM
>bcd5	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $c9 RETURN
>bcdd	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $ca SOLID
>bce4	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $cb SOUND
>bceb	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $cc SPRITE
>bcf3	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $cd TEXT
>bcf9	02 a3 54 4f				.text	2,$a3,"TO"             ; $ce TO
>bcfd	ff					.text	$FF
.bcfe					KeywordSet1:
>bcfe	00 65					.text	0,$65,""               ; $80 !0:EOF
>bd00	00 58					.text	0,$58,""               ; $81 !1:SH1
>bd02	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bd04	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>bd0c	4c 45
>bd0e	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>bd16	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>bd1e	03 d7 45 4e 44				.text	3,$d7,"END"            ; $86 END
>bd23	02 96 47 4f				.text	2,$96,"GO"             ; $87 GO
>bd27	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $88 LIST
>bd2d	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $89 LOAD
>bd33	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $8a NEW
>bd38	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $8b RESTORE
>bd40	45
>bd41	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $8c RUN
>bd46	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $8d SPRITES
>bd4e	53
>bd4f	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $8e STOP
>bd55	ff					.text	$FF
.bd56					KeywordSet2:
>bd56	00 65					.text	0,$65,""               ; $80 !0:EOF
>bd58	00 58					.text	0,$58,""               ; $81 !1:SH1
>bd5a	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>bd5c	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>bd61	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>bd66	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>bd6b	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>bd70	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>bd75	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>bd7a	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>bd7f	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>bd84	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>bd89	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>bd8e	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>bd93	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>bd98	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>bd9d	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>bda2	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>bda7	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>bdac	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>bdb1	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>bdb6	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>bdbb	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>bdc0	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>bdc5	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>bdca	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>bdcf	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>bdd4	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>bdd9	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>bdde	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>bde3	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>bde8	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>bded	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>bdf2	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>bdf7	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>bdfc	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>be01	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>be06	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>be0b	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>be10	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>be15	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>be1a	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>be1f	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>be24	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>be29	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>be2e	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>be33	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>be38	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>be3d	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>be42	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>be47	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>be4c	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>be51	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>be56	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>be5b	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>be60	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>be65	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>be6a	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>be6f	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>be74	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>be79	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>be7e	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>be83	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>be88	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>be8d	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>be92	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>be97	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>be9c	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>bea1	ff					.text	$FF
.b48c					ListConvertLine:
.b48c	48		pha				pha 								; save indent on the stack
.b48d	9c 9d 04	stz $049d			stz 	tbOffset
.b490	9c ac 04	stz $04ac			stz 	tokenBuffer
.b493	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.b495	b1 30		lda ($30),y			lda 	(codePtr),y
.b497	aa		tax				tax
.b498	88		dey				dey
.b499	b1 30		lda ($30),y			lda 	(codePtr),y
.b49b	20 11 93	jsr $9311			jsr 	LCLConvertInt16
.b49e	85 36		sta $36				sta 	zTemp0 						; copy number into buffer
.b4a0	86 37		stx $37				stx 	zTemp0+1
.b4a2	a9 8c		lda #$8c			lda 	#CLINumber+$80
.b4a4	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b4a7	a0 00		ldy #$00			ldy 	#0
.b4a9					_LCCopyNumber:
.b4a9	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4ab	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b4ae	c8		iny				iny
.b4af	b1 36		lda ($36),y			lda 	(zTemp0),y
.b4b1	d0 f6		bne $b4a9			bne 	_LCCopyNumber
.b4b3	68		pla				pla 								; adjustment to indent
.b4b4	48		pha				pha 								; save on stack
.b4b5	10 0c		bpl $b4c3			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.b4b7	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.b4b8	6d a6 04	adc $04a6			adc 	listIndent
.b4bb	8d a6 04	sta $04a6			sta 	listIndent
.b4be	10 03		bpl $b4c3			bpl 	_LCNoAdjust
.b4c0	9c a6 04	stz $04a6			stz 	listIndent
.b4c3					_LCNoAdjust:
.b4c3	18		clc				clc		 							; work out actual indent.
.b4c4	ad a6 04	lda $04a6			lda 	listIndent
.b4c7	0a		asl a				asl 	a
.b4c8	69 06		adc #$06			adc 	#6
.b4ca	85 36		sta $36				sta 	zTemp0
.b4cc					_LCPadOut:
.b4cc	a9 20		lda #$20			lda 	#' '						; pad out to 6 characters
.b4ce	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b4d1	ad 9d 04	lda $049d			lda 	tbOffset
.b4d4	c5 36		cmp $36				cmp 	zTemp0
.b4d6	d0 f4		bne $b4cc			bne 	_LCPadOut
.b4d8	a0 03		ldy #$03			ldy 	#3 							; start position.
.b4da					_LCMainLoop:
.b4da	a9 8a		lda #$8a			lda 	#CLIPunctuation+$80
.b4dc	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b4df	b1 30		lda ($30),y			lda 	(codePtr),y
.b4e1	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.b4e3	f0 17		beq $b4fc			beq 	_LCExit
.b4e5	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.b4e7	90 1e		bcc $b507			bcc 	_LCDoubles
.b4e9	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.b4eb	90 2a		bcc $b517			bcc 	_LCShiftPunc
.b4ed	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.b4ef	90 35		bcc $b526			bcc 	_LCPunctuation
.b4f1	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.b4f3	90 3e		bcc $b533			bcc 	_LCIdentifiers
.b4f5	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.b4f7	90 5f		bcc $b558			bcc 	_LCTokens
.b4f9	4c b8 b5	jmp $b5b8			jmp 	_LCData 					; 254-5 are data objects
.b4fc					_LCExit:
.b4fc	68		pla				pla 								; get old indent adjust
.b4fd	30 07		bmi $b506			bmi 	_LCExit2
.b4ff	18		clc				clc 								; add to indent if +ve
.b500	6d a6 04	adc $04a6			adc 	listIndent
.b503	8d a6 04	sta $04a6			sta 	listIndent
.b506					_LCExit2:
.b506	60		rts				rts
.b507					_LCDoubles:
.b507	48		pha				pha
.b508	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.b509	29 02		and #$02			and 	#2
.b50b	09 3c		ora #$3c			ora 	#60 						; make < >
.b50d	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b510	68		pla				pla 								; restore, do lower bit
.b511	29 03		and #$03			and 	#3
.b513	09 3c		ora #$3c			ora 	#60
.b515	80 0f		bra $b526			bra		_LCPunctuation 				; print, increment, loop
.b517					_LCShiftPunc:
.b517	aa		tax				tax 								; save in X
.b518	29 07		and #$07			and 	#7 							; lower 3 bits
.b51a	f0 02		beq $b51e			beq 	_LCNoAdd
.b51c	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.b51e					_LCNoAdd:
.b51e	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.b520	90 02		bcc $b524			bcc 	_LCNoAdd2
.b522	09 20		ora #$20			ora 	#32 						; adds $20
.b524					_LCNoAdd2:
.b524	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.b526					_LCPunctuation:
.b526	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.b528	d0 03		bne $b52d			bne 	_LCPContinue
.b52a	20 ff b5	jsr $b5ff			jsr 	LCLDeleteLastSpace
.b52d					_LCPContinue:
.b52d	c8		iny				iny 								; consume character
.b52e	20 e9 b5	jsr $b5e9			jsr 	LCLWrite 					; write it out.
.b531	80 a7		bra $b4da			bra 	_LCMainLoop 				; go round again.
.b533					_LCIdentifiers:
.b533	18		clc				clc 								; convert to physical address
.b534	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.b536	85 37		sta $37				sta 	zTemp0+1
.b538	c8		iny				iny
.b539	b1 30		lda ($30),y			lda 	(codePtr),y
.b53b	85 36		sta $36				sta 	zTemp0
.b53d	c8		iny				iny
.b53e	5a		phy				phy 								; save position
.b53f	a9 87		lda #$87			lda 	#CLIIdentifier+$80
.b541	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b544	a0 07		ldy #$07			ldy 	#7 							; output the identifier.
.b546					_LCOutIdentifier:
.b546	c8		iny				iny
.b547	b1 36		lda ($36),y			lda 	(zTemp0),y
.b549	29 7f		and #$7f			and 	#$7F
.b54b	20 3b b6	jsr $b63b			jsr 	LCLLowerCase
.b54e	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b551	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.b553	10 f1		bpl $b546			bpl 	_LCOutIdentifier
.b555	7a		ply				ply 								; restore position
.b556	80 82		bra $b4da			bra 	_LCMainLoop
.b558					_LCTokens:
.b558	aa		tax				tax 								; token in X
.b559	a9 56		lda #$56			lda 	#((KeywordSet2) & $FF)
.b55b	85 36		sta $36				sta 	0+zTemp0
.b55d	a9 bd		lda #$bd			lda 	#((KeywordSet2) >> 8)
.b55f	85 37		sta $37				sta 	1+zTemp0
.b561	e0 82		cpx #$82			cpx 	#$82
.b563	f0 16		beq $b57b			beq 	_LCUseShift
.b565	a9 fe		lda #$fe			lda 	#((KeywordSet1) & $FF)
.b567	85 36		sta $36				sta 	0+zTemp0
.b569	a9 bc		lda #$bc			lda 	#((KeywordSet1) >> 8)
.b56b	85 37		sta $37				sta 	1+zTemp0
.b56d	e0 81		cpx #$81			cpx 	#$81
.b56f	f0 0a		beq $b57b			beq 	_LCUseShift
.b571	a9 01		lda #$01			lda 	#((KeywordSet0) & $FF)
.b573	85 36		sta $36				sta 	0+zTemp0
.b575	a9 bb		lda #$bb			lda 	#((KeywordSet0) >> 8)
.b577	85 37		sta $37				sta 	1+zTemp0
.b579	80 01		bra $b57c			bra 	_LCNoShift
.b57b					_LCUseShift:
.b57b	c8		iny				iny
.b57c					_LCNoShift:
.b57c	20 13 b6	jsr $b613			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.b57f	b1 30		lda ($30),y			lda 	(codePtr),y
.b581	aa		tax				tax 								; into X
.b582					_LCFindText:
.b582	ca		dex				dex
.b583	10 0e		bpl $b593			bpl 	_LCFoundText 				; found text.
.b585	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.b587	1a		inc a				inc 	a 							; one extra for size
.b588	38		sec				sec 								; one extra for checksum
.b589	65 36		adc $36				adc 	zTemp0 						; go to next token
.b58b	85 36		sta $36				sta 	zTemp0
.b58d	90 f3		bcc $b582			bcc 	_LCFindText
.b58f	e6 37		inc $37				inc 	zTemp0+1
.b591	80 ef		bra $b582			bra 	_LCFindText
.b593					_LCFoundText:
.b593	5a		phy				phy 								; save List position
.b594	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.b596	aa		tax				tax
.b597	a9 83		lda #$83			lda 	#CLIToken+$80
.b599	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b59c	a0 02		ldy #$02			ldy 	#2
.b59e					_LCCopyToken:
.b59e	b1 36		lda ($36),y			lda 	(zTemp0),y
.b5a0	20 3b b6	jsr $b63b			jsr 	LCLLowerCase
.b5a3	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b5a6	c8		iny				iny
.b5a7	ca		dex				dex
.b5a8	d0 f4		bne $b59e			bne 	_LCCopyToken
.b5aa	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.b5ac	f0 05		beq $b5b3			beq 	_LCNoSpace
.b5ae	a9 20		lda #$20			lda 	#' '
.b5b0	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b5b3					_LCNoSpace:
.b5b3	7a		ply				ply 								; restore position.
.b5b4	c8		iny				iny 								; consume token
.b5b5	4c da b4	jmp $b4da			jmp 	_LCMainLoop 				; and go around again.
.b5b8					_LCData:
.b5b8	48		pha				pha 								; save type $FE/$FF
.b5b9	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.b5bb	c9 fe		cmp #$fe			cmp 	#$FE
.b5bd	f0 07		beq $b5c6			beq 	_LCHaveOpener
.b5bf	a2 22		ldx #$22			ldx 	#'"'
.b5c1	a9 81		lda #$81			lda 	#CLIData+$80
.b5c3	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b5c6					_LCHaveOpener:
.b5c6	8a		txa				txa 								; output prefix (# or ")
.b5c7	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b5ca	c8		iny				iny 								; get count
.b5cb	b1 30		lda ($30),y			lda 	(codePtr),y
.b5cd	aa		tax				tax
.b5ce	c8		iny				iny 								; point at first character
.b5cf					_LCOutData:
.b5cf	b1 30		lda ($30),y			lda 	(codePtr),y
.b5d1	c9 00		cmp #$00			cmp 	#0
.b5d3	f0 03		beq $b5d8			beq 	_LCNoPrint
.b5d5	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b5d8					_LCNoPrint:
.b5d8	c8		iny				iny
.b5d9	ca		dex				dex
.b5da	d0 f3		bne $b5cf			bne 	_LCOutData
.b5dc	68		pla				pla 								; closing " required ?
.b5dd	c9 ff		cmp #$ff			cmp 	#$FF
.b5df	d0 05		bne $b5e6			bne 	_LCNoQuote
.b5e1	a9 22		lda #$22			lda 	#'"'
.b5e3	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b5e6					_LCNoQuote:
.b5e6	4c da b4	jmp $b4da			jmp 	_LCMainLoop
.b5e9					LCLWrite:
.b5e9	da		phx				phx
.b5ea	ae 9d 04	ldx $049d			ldx 	tbOffset
.b5ed	9d ac 04	sta $04ac,x			sta 	tokenBuffer,x
.b5f0	9e ad 04	stz $04ad,x			stz 	tokenBuffer+1,x
.b5f3	ee 9d 04	inc $049d			inc 	tbOffset
.b5f6	09 00		ora #$00			ora 	#0 							; don't update if colour data
.b5f8	30 03		bmi $b5fd			bmi 	_LCLNoColour
.b5fa	8d a7 04	sta $04a7			sta 	LCLastCharacter
.b5fd					_LCLNoColour:
.b5fd	fa		plx				plx
.b5fe	60		rts				rts
.b5ff					LCLDeleteLastSpace:
.b5ff	48		pha				pha
.b600	da		phx				phx
.b601	ae 9d 04	ldx $049d			ldx 	tbOffset
.b604	f0 0a		beq $b610			beq 	_LCDLSExit
.b606	bd ab 04	lda $04ab,x			lda 	tokenBuffer-1,x
.b609	c9 20		cmp #$20			cmp 	#' '
.b60b	d0 03		bne $b610			bne 	_LCDLSExit
.b60d	ce 9d 04	dec $049d			dec 	tbOffset
.b610					_LCDLSExit:
.b610	fa		plx				plx
.b611	68		pla				pla
.b612	60		rts				rts
.b613					LCLCheckSpaceRequired:
.b613	ad a7 04	lda $04a7			lda 	LCLastCharacter 			; check last character
.b616	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.b618	f0 1b		beq $b635			beq 	_LCCSRSpace
.b61a	c9 29		cmp #$29			cmp 	#')'
.b61c	f0 17		beq $b635			beq 	_LCCSRSpace
.b61e	c9 23		cmp #$23			cmp 	#'#'
.b620	f0 13		beq $b635			beq 	_LCCSRSpace
.b622	20 3b b6	jsr $b63b			jsr 	LCLLowerCase 				; saves a little effort
.b625	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.b627	90 11		bcc $b63a			bcc 	_LCCSRExit
.b629	c9 3a		cmp #$3a			cmp 	#"9"+1
.b62b	90 08		bcc $b635			bcc 	_LCCSRSpace
.b62d	c9 61		cmp #$61			cmp 	#"a"
.b62f	90 09		bcc $b63a			bcc 	_LCCSRExit
.b631	c9 7b		cmp #$7b			cmp 	#"z"+1
.b633	b0 05		bcs $b63a			bcs 	_LCCSRExit
.b635					_LCCSRSpace:
.b635	a9 20		lda #$20			lda 	#' '
.b637	20 e9 b5	jsr $b5e9			jsr 	LCLWrite
.b63a					_LCCSRExit:
.b63a	60		rts				rts
.b63b					LCLLowerCase:
.b63b	c9 41		cmp #$41			cmp 	#"A"
.b63d	90 06		bcc $b645			bcc 	_LCLLCOut
.b63f	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b641	b0 02		bcs $b645			bcs 	_LCLLCOut
.b643	69 20		adc #$20			adc 	#$20
.b645					_LCLLCOut:
.b645	60		rts				rts
.b646					LCLUpperCase:
.b646	c9 61		cmp #$61			cmp 	#"a"
.b648	90 06		bcc $b650			bcc 	_LCLUCOut
.b64a	c9 7b		cmp #$7b			cmp 	#"z"+1
.b64c	b0 02		bcs $b650			bcs 	_LCLUCOut
.b64e	e9 1f		sbc #$1f			sbc 	#$1F
.b650					_LCLUCOut:
.b650	60		rts				rts
.b651					TOKSearchTable:
.b651	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.b653	85 36		sta $36				sta 	zTemp0
.b655	a0 00		ldy #$00			ldy 	#0
.b657	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.b659	85 38		sta $38				sta 	zTemp1
.b65b					_TSTLoop:
.b65b	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.b65d	30 49		bmi $b6a8			bmi 	_TSTFail 					; -ve = end of table, so fail.
.b65f	f0 2e		beq $b68f			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.b661	c8		iny				iny 								; get the hash
.b662	b1 36		lda ($36),y			lda 	(zTemp0),y
.b664	88		dey				dey
.b665	cd 83 04	cmp $0483			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.b668	d0 25		bne $b68f			bne 	_TSTNext
.b66a	ad 82 04	lda $0482			lda 	identTypeEnd 				; get length of identifier from end-start
.b66d	38		sec				sec
.b66e	ed 80 04	sbc $0480			sbc 	identStart
.b671	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.b673	d0 1a		bne $b68f			bne 	_TSTNext
.b675	5a		phy				phy 								; save Y , we might fail to match.
.b676	c8		iny				iny 								; point to text
.b677	c8		iny				iny
.b678	ae 80 04	ldx $0480			ldx 	identStart 					; offset in line buffer in X
.b67b					_TSTCompareName:
.b67b	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; compare text.
.b67e	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.b680	d0 0c		bne $b68e			bne 	_TSTNextPullY 				; fail, pullY and do next
.b682	e8		inx				inx
.b683	c8		iny				iny
.b684	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; complete match.
.b687	d0 f2		bne $b67b			bne 	_TSTCompareName
.b689	7a		ply				ply 								; throw Y
.b68a	a5 38		lda $38				lda 	zTemp1 						; get token #
.b68c	38		sec				sec 								; return with CS = passed.
.b68d	60		rts				rts
.b68e					_TSTNextPullY:
.b68e	7a		ply				ply 								; restore current, fall through.
.b68f					_TSTNext:
.b68f	e6 38		inc $38				inc 	zTemp1 						; token counter
.b691	98		tya				tya
.b692	18		clc				clc
.b693	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.b695	1a		inc a				inc 	a 							; +1
.b696	1a		inc a				inc 	a 							; +2
.b697	a8		tay				tay
.b698	10 c1		bpl $b65b			bpl 	_TSTLoop 					; if Y < $80 loop back
.b69a	98		tya				tya 								; add Y to zTemp0 and reset Y
.b69b	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.b69d	18		clc				clc  								; but have tables > 255 bytes
.b69e	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.b6a0	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.b6a2	90 b7		bcc $b65b			bcc 	_TSTLoop
.b6a4	e6 37		inc $37				inc 	zTemp0+1
.b6a6	80 b3		bra $b65b			bra 	_TSTLoop
.b6a8					_TSTFail:
.b6a8	18		clc				clc
.b6a9	60		rts				rts
.b6aa					TokeniseLine:
.b6aa	20 32 b8	jsr $b832			jsr 	LCLFixLineBufferCase 		; fix line case
.b6ad	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.b6af	8d a9 04	sta $04a9			sta 	tokenOffset 				; (3 bytes for line number & offset)
.b6b2	9c aa 04	stz $04aa			stz 	tokenLineNumber
.b6b5	9c ab 04	stz $04ab			stz 	tokenLineNumber+1
.b6b8	a2 ff		ldx #$ff			ldx 	#$FF
.b6ba					_TKFindFirst:
.b6ba	e8		inx				inx
.b6bb	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b6be	f0 79		beq $b739			beq 	_TKExit
.b6c0	c9 20		cmp #$20			cmp 	#' '
.b6c2	90 f6		bcc $b6ba			bcc 	_TKFindFirst
.b6c4	c9 30		cmp #$30			cmp 	#'0'
.b6c6	90 07		bcc $b6cf			bcc 	_TKNoLineNumber
.b6c8	c9 3a		cmp #$3a			cmp 	#'9'+1
.b6ca	b0 03		bcs $b6cf			bcs 	_TKNoLineNumber
.b6cc	20 5c b8	jsr $b85c			jsr 	TOKExtractLineNumber
.b6cf					_TKNoLineNumber:
.b6cf					_TKTokeniseLoop:
.b6cf	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.b6d2	f0 65		beq $b739			beq 	_TKExit
.b6d4	e8		inx				inx
.b6d5	c9 20		cmp #$20			cmp 	#' '
.b6d7	f0 f6		beq $b6cf			beq 	_TKTokeniseLoop 			; keep looping if space found.
.b6d9	ca		dex				dex 								; undo last get, A contains character, X is position.
.b6da	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.b6dc	f0 61		beq $b73f			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.b6de	c9 41		cmp #$41			cmp 	#'A'
.b6e0	90 04		bcc $b6e6			bcc 	_TKTokenisePunctuation
.b6e2	c9 5b		cmp #$5b			cmp 	#'Z'+1
.b6e4	90 59		bcc $b73f			bcc 	_TKTokeniseIdentifier
.b6e6					_TKTokenisePunctuation:
.b6e6	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.b6e8	f0 27		beq $b711			beq 	_TKString
.b6ea	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.b6ec	f0 28		beq $b716			beq 	_TKHexConstant
.b6ee	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.b6f0	f0 29		beq $b71b			beq 	_TKCheckDouble
.b6f2	c9 3e		cmp #$3e			cmp 	#'>'
.b6f4	f0 25		beq $b71b			beq 	_TKCheckDouble
.b6f6					_TKStandardPunctuation:
.b6f6	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get the punctuation token back.
.b6f9	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.b6fb	90 0e		bcc $b70b			bcc 	_TKNoShift
.b6fd	48		pha				pha 								; save. we are about to convert this punctuation token from
.b6fe	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.b700	85 36		sta $36				sta 	zTemp0
.b702	68		pla				pla
.b703	29 20		and #$20			and 	#32 						; bit 5
.b705	4a		lsr a				lsr 	a 							; shift into bit 3
.b706	4a		lsr a				lsr 	a
.b707	05 36		ora $36				ora 	zTemp0
.b709	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.b70b					_TKNoShift:
.b70b	20 a1 b8	jsr $b8a1			jsr 	TOKWriteByte 				; write the punctuation character
.b70e	e8		inx				inx 								; consume the character
.b70f	80 be		bra $b6cf			bra 	_TKTokeniseLoop 			; and loop round again.
.b711					_TKString:
.b711	20 c1 b7	jsr $b7c1			jsr 	TOKTokenString
.b714	80 b9		bra $b6cf			bra 	_TKTokeniseLoop
.b716					_TKHexConstant:
.b716	20 fc b7	jsr $b7fc			jsr 	TOKHexConstant
.b719	80 b4		bra $b6cf			bra 	_TKTokeniseLoop
.b71b					_TKCheckDouble:
.b71b	bd aa 05	lda $05aa,x			lda 	lineBuffer+1,x 				; get next character
.b71e	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.b720	90 d4		bcc $b6f6			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.b722	c9 3f		cmp #$3f			cmp 	#'>'+1
.b724	b0 d0		bcs $b6f6			bcs 	_TKStandardPunctuation
.b726	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.b729	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.b72b	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.b72c	7d aa 05	adc $05aa,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.b72f	38		sec				sec
.b730	e9 3c		sbc #$3c			sbc 	#'<'
.b732	20 a1 b8	jsr $b8a1			jsr 	TOKWriteByte 				; this is in the range 0-7
.b735	e8		inx				inx 								; consume both
.b736	e8		inx				inx
.b737	80 96		bra $b6cf			bra 	_TKTokeniseLoop
.b739	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.b73b	20 a1 b8	jsr $b8a1			jsr 	TOKWriteByte
.b73e	60		rts				rts
.b73f					_TKTokeniseIdentifier:
.b73f	8e 80 04	stx $0480			stx 	identStart 					; save start
.b742	9c 84 04	stz $0484			stz 	identTypeByte 				; zero the type byte
.b745					_TKCheckLoop:
.b745	e8		inx				inx 								; look at next, we know first is identifier already.
.b746	bd a9 05	lda $05a9,x			lda  	lineBuffer,x
.b749	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.b74b	f0 f8		beq $b745			beq 	_TKCheckLoop
.b74d	c9 30		cmp #$30			cmp	 	#"0"
.b74f	90 0c		bcc $b75d			bcc 	_TKEndIdentifier
.b751	c9 3a		cmp #$3a			cmp 	#"9"+1
.b753	90 f0		bcc $b745			bcc 	_TKCheckLoop
.b755	c9 41		cmp #$41			cmp	 	#"A"
.b757	90 04		bcc $b75d			bcc 	_TKEndIdentifier
.b759	c9 5b		cmp #$5b			cmp 	#"Z"+1
.b75b	90 e8		bcc $b745			bcc 	_TKCheckLoop
.b75d					_TKEndIdentifier:
.b75d	8e 81 04	stx $0481			stx 	identTypeStart 				; save start of type text (if any !)
.b760	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.b762	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.b764	f0 06		beq $b76c			beq 	_TKHasTypeCharacter
.b766	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.b768	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.b76a	d0 07		bne $b773			bne 	_TKNoTypeCharacter
.b76c					_TKHasTypeCharacter:
.b76c	8c 84 04	sty $0484			sty 	identTypeByte 				; has # or $, save the type
.b76f	e8		inx				inx 								; consume the type character
.b770	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b773					_TKNoTypeCharacter:
.b773	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.b775	d0 09		bne $b780			bne 	_TKNoArray
.b777	e8		inx				inx 								; skip the (
.b778	ad 84 04	lda $0484			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.b77b	09 04		ora #$04			ora 	#$04
.b77d	8d 84 04	sta $0484			sta 	identTypeByte
.b780					_TKNoArray:
.b780	8e 82 04	stx $0482			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.b783	20 1d b8	jsr $b81d			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.b786	a0 bb		ldy #$bb			ldy 	#(KeywordSet0) >> 8
.b788	a9 01		lda #$01			lda 	#(KeywordSet0) & $FF
.b78a	20 51 b6	jsr $b651			jsr 	TOKSearchTable
.b78d	a2 00		ldx #$00			ldx 	#0
.b78f	b0 1f		bcs $b7b0			bcs 	_TKFoundToken
.b791	a0 bc		ldy #$bc			ldy 	#(KeywordSet1) >> 8
.b793	a9 fe		lda #$fe			lda 	#(KeywordSet1) & $FF
.b795	20 51 b6	jsr $b651			jsr 	TOKSearchTable
.b798	a2 81		ldx #$81			ldx 	#$81
.b79a	b0 14		bcs $b7b0			bcs 	_TKFoundToken
.b79c	a0 bd		ldy #$bd			ldy 	#(KeywordSet2) >> 8
.b79e	a9 56		lda #$56			lda 	#(KeywordSet2) & $FF
.b7a0	20 51 b6	jsr $b651			jsr 	TOKSearchTable
.b7a3	a2 82		ldx #$82			ldx 	#$82
.b7a5	b0 09		bcs $b7b0			bcs 	_TKFoundToken
.b7a7	20 ad b8	jsr $b8ad			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.b7aa	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b7ad	4c cf b6	jmp $b6cf			jmp 	_TKTokeniseLoop 			; and go round again.
.b7b0					_TKFoundToken:
.b7b0	48		pha				pha 								; save token
.b7b1	8a		txa				txa 								; shift in X, is there one ?
.b7b2	f0 03		beq $b7b7			beq 	_TKNoTShift
.b7b4	20 a1 b8	jsr $b8a1			jsr 	TOKWriteByte 				; if so, write it out
.b7b7					_TKNoTShift:
.b7b7	68		pla				pla 								; restore and write token
.b7b8	20 a1 b8	jsr $b8a1			jsr 	TOKWriteByte
.b7bb	ae 82 04	ldx $0482			ldx 	identTypeEnd 				; X points to following byte
.b7be	4c cf b6	jmp $b6cf			jmp 	_TKTokeniseLoop 			; and go round again.
.b7c1					TOKTokenString:
.b7c1	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.b7c3	20 a1 b8	jsr $b8a1			jsr 	TOKWriteByte
.b7c6	e8		inx				inx									; start of quoted string.
.b7c7	da		phx				phx 								; push start of string on top
.b7c8	ca		dex				dex 								; because we pre-increment
.b7c9					_TSFindEnd:
.b7c9	e8		inx				inx
.b7ca	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; next character
.b7cd	f0 04		beq $b7d3			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.b7cf	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.b7d1	d0 f6		bne $b7c9			bne 	_TSFindEnd
.b7d3					_TSEndOfString:
.b7d3	7a		ply				ply  								; so now Y is first character, X is character after end.
.b7d4	48		pha				pha 								; save terminating character
.b7d5	20 dd b7	jsr $b7dd			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.b7d8	68		pla				pla 								; terminating character
.b7d9	f0 01		beq $b7dc			beq 	_TSNotQuote					; if it wasn't EOS skip it
.b7db	e8		inx				inx
.b7dc					_TSNotQuote:
.b7dc	60		rts				rts
.b7dd					TOKWriteBlockXY:
.b7dd	86 36		stx $36				stx 	zTemp0 						; save end character
.b7df	98		tya				tya 								; use 2's complement to work out the byte size
.b7e0	49 ff		eor #$ff			eor 	#$FF
.b7e2	38		sec				sec
.b7e3	65 36		adc $36				adc 	zTemp0
.b7e5	1a		inc a				inc 	a 							; one extra for NULL
.b7e6	20 a1 b8	jsr $b8a1			jsr 	TOKWriteByte
.b7e9					_TOBlockLoop:
.b7e9	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.b7eb	f0 09		beq $b7f6			beq 	_TOBlockExit
.b7ed	b9 a9 05	lda $05a9,y			lda 	lineBuffer,y 				; write byte out.
.b7f0	20 a1 b8	jsr $b8a1			jsr 	TOKWriteByte
.b7f3	c8		iny				iny
.b7f4	80 f3		bra $b7e9			bra 	_TOBlockLoop
.b7f6					_TOBlockExit:
.b7f6	a9 00		lda #$00			lda 	#0 							; add NULL.
.b7f8	20 a1 b8	jsr $b8a1			jsr 	TOKWriteByte
.b7fb	60		rts				rts
.b7fc					TOKHexConstant:
.b7fc	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.b7fe	20 a1 b8	jsr $b8a1			jsr 	TOKWriteByte
.b801	e8		inx				inx									; start of quoted string.
.b802	da		phx				phx 								; push start of constant on top
.b803	ca		dex				dex
.b804					_THFindLoop:
.b804	e8		inx				inx 	 							; this is stored in a block, so find out how long
.b805	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; the hex constant is.
.b808	c9 30		cmp #$30			cmp 	#"0"
.b80a	90 0c		bcc $b818			bcc 	_THFoundEnd
.b80c	c9 3a		cmp #$3a			cmp 	#"9"+1
.b80e	90 f4		bcc $b804			bcc 	_THFindLoop
.b810	c9 41		cmp #$41			cmp 	#"A"
.b812	90 04		bcc $b818			bcc 	_THFoundEnd
.b814	c9 47		cmp #$47			cmp 	#"F"+1
.b816	90 ec		bcc $b804			bcc 	_THFindLoop
.b818					_THFoundEnd:
.b818	7a		ply				ply 								; restore start
.b819	20 dd b7	jsr $b7dd			jsr 	TOKWriteBlockXY 			; output the block
.b81c	60		rts				rts
.b81d					TOKCalculateHash:
.b81d	da		phx				phx
.b81e	ae 80 04	ldx $0480			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.b821	a9 00		lda #$00			lda 	#0
.b823					_TCHLoop:
.b823	18		clc				clc
.b824	7d a9 05	adc $05a9,x			adc 	lineBuffer,x
.b827	e8		inx				inx
.b828	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.b82b	d0 f6		bne $b823			bne 	_TCHLoop
.b82d	8d 83 04	sta $0483			sta 	identHash 					; save the hash
.b830	fa		plx				plx
.b831	60		rts				rts
.b832					LCLFixLineBufferCase:
.b832	a2 00		ldx #$00			ldx 	#0
.b834					_FLBCLoop:
.b834	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next character
.b837	f0 22		beq $b85b			beq 	_FLBCExit 					; end of string.
.b839	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.b83b	f0 11		beq $b84e			beq 	_FLBCInQuotes
.b83d	e8		inx				inx
.b83e	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.b840	90 f2		bcc $b834			bcc 	_FLBCLoop
.b842	c9 7b		cmp #$7b			cmp 	#'z'+1
.b844	b0 ee		bcs $b834			bcs 	_FLBCLoop
.b846	38		sec				sec 								; make U/C
.b847	e9 20		sbc #$20			sbc 	#32
.b849	9d a8 05	sta $05a8,x			sta	 	lineBuffer-1,x 				; write back
.b84c	80 e6		bra $b834			bra 	_FLBCLoop
.b84e					_FLBCInQuotes:
.b84e	e8		inx				inx 								; advance
.b84f	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get next
.b852	f0 07		beq $b85b			beq 	_FLBCExit 					; exit on EOS
.b854	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.b856	d0 f6		bne $b84e			bne 	_FLBCInQuotes
.b858	e8		inx				inx 								; skip over it
.b859	80 d9		bra $b834			bra 	_FLBCLoop
.b85b					_FLBCExit:
.b85b	60		rts				rts
.b85c					TOKExtractLineNumber:
.b85c	ad ab 04	lda $04ab			lda 	tokenLineNumber+1 			; push current value on stack
.b85f	48		pha				pha
.b860	ad aa 04	lda $04aa			lda 	tokenLineNumber
.b863	48		pha				pha
.b864	20 9a b8	jsr $b89a			jsr 	_LCLNTimes2 				; line # x 2
.b867	20 9a b8	jsr $b89a			jsr 	_LCLNTimes2 				; line # x 4
.b86a	18		clc				clc 								; add stacked value
.b86b	68		pla				pla
.b86c	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b86f	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b872	68		pla				pla
.b873	6d ab 04	adc $04ab			adc 	tokenLineNumber+1
.b876	8d ab 04	sta $04ab			sta 	tokenLineNumber+1 			; line # x 5
.b879	20 9a b8	jsr $b89a			jsr 	_LCLNTimes2 				; line # x 10
.b87c	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; get and consume character
.b87f	e8		inx				inx
.b880	29 0f		and #$0f			and 	#15 						; add to line #
.b882	18		clc				clc
.b883	6d aa 04	adc $04aa			adc 	tokenLineNumber
.b886	8d aa 04	sta $04aa			sta 	tokenLineNumber
.b889	90 03		bcc $b88e			bcc 	_TLENNoCarry
.b88b	ee ab 04	inc $04ab			inc 	tokenLineNumber+1
.b88e					_TLENNoCarry:
.b88e	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; more digits ?
.b891	c9 30		cmp #$30			cmp 	#'0'
.b893	90 04		bcc $b899			bcc 	_TLENExit
.b895	c9 3a		cmp #$3a			cmp 	#'9'+1
.b897	90 c3		bcc $b85c			bcc 	TOKExtractLineNumber
.b899					_TLENExit:
.b899	60		rts				rts
.b89a					_LCLNTimes2:
.b89a	0e aa 04	asl $04aa			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.b89d	2e ab 04	rol $04ab			rol 	tokenLineNumber+1
.b8a0	60		rts				rts
.b8a1					TOKWriteByte:
.b8a1	da		phx				phx
.b8a2	ae a9 04	ldx $04a9			ldx 	tokenOffset 				; next slot to write to
.b8a5	9d a9 04	sta $04a9,x			sta 	tokenOffset,x 				; write byte out
.b8a8	ee a9 04	inc $04a9			inc 	tokenOffset 				; advance slot.
.b8ab	fa		plx				plx
.b8ac	60		rts				rts
.b8ad					TOKCheckCreateVariableRecord:
.b8ad	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.b8af	85 36		sta $36				sta 	0+zTemp0
.b8b1	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.b8b3	85 37		sta $37				sta 	1+zTemp0
.b8b5					_CCVSearch:
.b8b5	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.b8b7	f0 2c		beq $b8e5			beq 	_CCVFail
.b8b9	a0 01		ldy #$01			ldy 	#1 							; read the hash
.b8bb	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.b8bd	cd 83 04	cmp $0483			cmp 	identHash
.b8c0	d0 16		bne $b8d8			bne 	_CCVNext
.b8c2	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.b8c4	ae 80 04	ldx $0480			ldx 	identStart
.b8c7					_CCVCompare:
.b8c7	bd a9 05	lda $05a9,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.b8ca	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.b8cc	e8		inx				inx 								; advance pointers
.b8cd	c8		iny				iny
.b8ce	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.b8cf	d0 07		bne $b8d8			bne 	_CCVNext  					; didn't match go to next.
.b8d1	90 f4		bcc $b8c7			bcc 	_CCVCompare 				; not finished yet.
.b8d3	ec 82 04	cpx $0482			cpx 	identTypeEnd 				; matched whole thing ?
.b8d6	f0 41		beq $b919			beq 	_CCVFound 					; yes, we were successful
.b8d8					_CCVNext:
.b8d8	18		clc				clc
.b8d9	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.b8db	65 36		adc $36				adc 	zTemp0
.b8dd	85 36		sta $36				sta 	zTemp0
.b8df	90 d4		bcc $b8b5			bcc 	_CCVSearch
.b8e1	e6 37		inc $37				inc 	zTemp0+1
.b8e3	80 d0		bra $b8b5			bra 	_CCVSearch
.b8e5					_CCVFail:
.b8e5	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.b8e7	ad 83 04	lda $0483			lda 	identHash
.b8ea	91 36		sta ($36),y			sta 	(zTemp0),y
.b8ec	c8		iny				iny 								; offset 2 is the type byte
.b8ed	ad 84 04	lda $0484			lda 	identTypeByte
.b8f0	91 36		sta ($36),y			sta 	(zTemp0),y
.b8f2	c8		iny				iny
.b8f3					_CCVData:
.b8f3	a9 00		lda #$00			lda 	#0 							; erase data 3-7
.b8f5	91 36		sta ($36),y			sta 	(zTemp0),y
.b8f7	c8		iny				iny
.b8f8	c0 08		cpy #$08			cpy 	#8
.b8fa	90 f7		bcc $b8f3			bcc 	_CCVData
.b8fc	ae 80 04	ldx $0480			ldx 	identStart 					; copy name into 8 on.
.b8ff					_CCVCopyName:
.b8ff	bd a9 05	lda $05a9,x			lda 	lineBuffer,x
.b902	91 36		sta ($36),y			sta 	(zTemp0),y
.b904	e8		inx				inx
.b905	c8		iny				iny
.b906	ec 82 04	cpx $0482			cpx 	identTypeEnd
.b909	d0 f4		bne $b8ff			bne 	_CCVCopyName
.b90b	98		tya				tya 								; patch offset
.b90c	92 36		sta ($36)			sta 	(zTemp0)
.b90e	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.b910	91 36		sta ($36),y			sta 	(zTemp0),y
.b912	88		dey				dey
.b913	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.b915	09 80		ora #$80			ora 	#$80
.b917	91 36		sta ($36),y			sta 	(zTemp0),y
.b919					_CCVFound:
.b919	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.b91b	38		sec				sec
.b91c	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start
.b91e	09 40		ora #$40			ora 	#$40 						; make it a writeable token
.b920	20 a1 b8	jsr $b8a1			jsr 	TOKWriteByte
.b923	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.b925	20 a1 b8	jsr $b8a1			jsr 	TOKWriteByte
.b928	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/_build/_sound.module

=1					soundIntegrated=1
.b929					SNDCheckChannel:
.b929	aa		tax				tax
.b92a	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; currently playing a note
.b92d	d0 38		bne $b967			bne 	_SNDCCExit
.b92f	da		phx				phx 								; save current channel
.b930	8a		txa				txa 								; put in A
.b931	20 ad b9	jsr $b9ad			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.b934	68		pla				pla 								; channel # in A
.b935	90 30		bcc $b967			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.b937	a8		tay				tay 								; Y is the channel #
.b938	bd ff 06	lda $06ff,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.b93b	99 fe 07	sta $07fe,y			sta 	SNDPitchLow,y
.b93e	bd 00 07	lda $0700,x			lda 	SNDQueue+2,x
.b941	99 02 08	sta $0802,y			sta 	SNDPitchHigh,y
.b944	bd 01 07	lda $0701,x			lda 	SNDQueue+3,x
.b947	99 06 08	sta $0806,y			sta 	SNDVolume,y
.b94a	bd 02 07	lda $0702,x			lda 	SNDQueue+4,x
.b94d	99 0a 08	sta $080a,y			sta 	SNDTimeLeft,y
.b950	bd 03 07	lda $0703,x			lda 	SNDQueue+5,x
.b953	99 0e 08	sta $080e,y			sta 	SNDAdjustLow,y
.b956	bd 04 07	lda $0704,x			lda 	SNDQueue+6,x
.b959	99 12 08	sta $0812,y			sta 	SNDAdjustHigh,y
.b95c	5a		phy				phy 								; save channel #
.b95d	20 c7 b9	jsr $b9c7			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.b960	ce fd 06	dec $06fd			dec 	SNDLength 					; reduce the queue length.
.b963	68		pla				pla
.b964	20 68 b9	jsr $b968			jsr 	SNDUpdateNote 				; update channel A
.b967					_SNDCCExit:
.b967	60		rts				rts
.b968					SNDUpdateNote:
.b968	aa		tax				tax 								; so we can access records
.b969	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.b96a	0a		asl a				asl 	a
.b96b	0a		asl a				asl 	a
.b96c	0a		asl a				asl 	a
.b96d	0a		asl a				asl 	a
.b96e	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b971	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; are we silent
.b974	f0 2e		beq $b9a4			beq 	_SNDUNIsSilent
.b976	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; push channel bits on stack
.b979	48		pha				pha
.b97a	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.b97d	29 0f		and #$0f			and 	#$0F
.b97f	0d fc 06	ora $06fc			ora 	SNDChannelBits 				; set channel bits
.b982	09 80		ora #$80			ora 	#$80 						; write to pitch register
.b984	20 11 ba	jsr $ba11			jsr 	SNDWritePorts
.b987	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.b98a	8d fc 06	sta $06fc			sta 	SNDChannelBits
.b98d	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.b990	4e fc 06	lsr $06fc			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.b993	6a		ror a				ror 	a
.b994	4e fc 06	lsr $06fc			lsr 	SNDChannelBits
.b997	6a		ror a				ror 	a
.b998	4a		lsr a				lsr 	a 							; put in bits 0-5
.b999	4a		lsr a				lsr 	a
.b99a	20 11 ba	jsr $ba11			jsr 	SNDWritePorts 				; write as rest of pitch register
.b99d	68		pla				pla
.b99e	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.b9a0	20 11 ba	jsr $ba11			jsr 	SNDWritePorts
.b9a3	60		rts				rts
.b9a4					_SNDUNIsSilent:
.b9a4	ad fc 06	lda $06fc			lda 	SNDChannelBits 				; channel bits
.b9a7	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.b9a9	20 11 ba	jsr $ba11			jsr 	SNDWritePorts 				; write to the ports
.b9ac	60		rts				rts
.b9ad					SNDFindNextNoteForA:
.b9ad	ac fd 06	ldy $06fd			ldy 	SNDLength 					; queue size into Y
.b9b0	f0 13		beq $b9c5			beq 	_SNDFNNFail 				; queue empty.
.b9b2	a2 00		ldx #$00			ldx 	#0
.b9b4					_SNDFNNSearch:
.b9b4	dd fe 06	cmp $06fe,x			cmp 	SNDQueue,x 					; does it match the channel
.b9b7	38		sec				sec
.b9b8	f0 0c		beq $b9c6			beq 	_SNDFNNExit 				; if so exit with CS.
.b9ba	e8		inx				inx 								; next queue slot.
.b9bb	e8		inx				inx
.b9bc	e8		inx				inx
.b9bd	e8		inx				inx
.b9be	e8		inx				inx
.b9bf	e8		inx				inx
.b9c0	e8		inx				inx
.b9c1	e8		inx				inx
.b9c2	88		dey				dey 								; done the whole queue
.b9c3	d0 ef		bne $b9b4			bne 	_SNDFNNSearch 				; no, go back.
.b9c5					_SNDFNNFail:
.b9c5	18		clc				clc
.b9c6					_SNDFNNexit:
.b9c6	60		rts				rts
.b9c7					SNDDeleteXFromQueue:
.b9c7	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.b9c9	f0 09		beq $b9d4			beq 	_SNDDXExit
.b9cb	bd 06 07	lda $0706,x			lda 	SNDQueue+8,x
.b9ce	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9d1	e8		inx				inx
.b9d2	80 f3		bra $b9c7			bra 	SNDDeleteXFromQueue
.b9d4					_SNDDXExit:
.b9d4	60		rts				rts
.06fc					SNDChannelBits:
>06fc							.fill 	1
.b9d5					SNDQueueRequest:
.b9d5	86 36		stx $36				stx 	zTemp0						; save queue address
.b9d7	84 37		sty $37				sty 	zTemp0+1
.b9d9	ae fd 06	ldx $06fd			ldx 	SNDLength 					; queue is full, can't take any more.
.b9dc	e0 20		cpx #$20			cpx 	#SNDQueueSize
.b9de	f0 21		beq $ba01			beq 	_SNDQRExit
.b9e0	29 03		and #$03			and 	#3	 						; channel # and push on stack
.b9e2	48		pha				pha
.b9e3	8a		txa				txa  								; get offset in queue buffer/
.b9e4	0a		asl a				asl 	a
.b9e5	0a		asl a				asl 	a
.b9e6	0a		asl a				asl 	a
.b9e7	aa		tax				tax
.b9e8	68		pla				pla 								; get back and push again
.b9e9	48		pha				pha
.b9ea	9d fe 06	sta $06fe,x			sta 	SNDQueue+0,x 				; save the channel #
.b9ed	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.b9ef					_SNDQCopy:
.b9ef	b1 36		lda ($36),y			lda 	(zTemp0),y
.b9f1	e8		inx				inx
.b9f2	c8		iny				iny
.b9f3	9d fe 06	sta $06fe,x			sta 	SNDQueue,x
.b9f6	c0 06		cpy #$06			cpy 	#6
.b9f8	d0 f5		bne $b9ef			bne 	_SNDQCopy
.b9fa	ee fd 06	inc $06fd			inc 	SNDLength 					; bump queue length.
.b9fd	68		pla				pla 								; get channel # back
.b9fe	20 29 b9	jsr $b929			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.ba01					_SNDQRExit:
.ba01	60		rts				rts
.ba02					SNDSilenceChannel:
.ba02	aa		tax				tax 								; zero time left.
.ba03	9e 0a 08	stz $080a,x			stz 	SNDTimeLeft,x
.ba06	0a		asl a				asl 	a 							; shift into position
.ba07	0a		asl a				asl 	a
.ba08	0a		asl a				asl 	a
.ba09	0a		asl a				asl 	a
.ba0a	0a		asl a				asl 	a
.ba0b	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.ba0d	20 11 ba	jsr $ba11			jsr 	SNDWritePorts
.ba10	60		rts				rts
.ba11					SNDWritePorts:
.ba11	64 01		stz $01				stz 	1
.ba13	8d 00 d6	sta $d600			sta 	$D600
.ba16	8d 10 d6	sta $d610			sta 	$D610
.ba19	60		rts				rts
.ba1a					SNDCommand:
.ba1a	da		phx				phx
.ba1b	5a		phy				phy
.ba1c	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.ba1e	f0 1d		beq $ba3d			beq 	_SNDInitialise
.ba20	90 28		bcc $ba4a			bcc 	_SNDExit
.ba22	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.ba24	f0 17		beq $ba3d			beq 	_SNDSilence
.ba26	b0 22		bcs $ba4a			bcs 	_SNDExit
.ba28	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.ba2a	b0 09		bcs $ba35			bcs 	_SNDQueryPlay
.ba2c	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.ba2e	b0 1a		bcs $ba4a			bcs 	_SNDExit
.ba30	20 d5 b9	jsr $b9d5			jsr 	SNDQueueRequest
.ba33	80 15		bra $ba4a			bra 	_SNDExit
.ba35					_SNDQueryPlay:
.ba35	29 03		and #$03			and 	#3 							; get channel #
.ba37	aa		tax				tax
.ba38	bd 0a 08	lda $080a,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.ba3b	80 0d		bra $ba4a			bra 	_SNDExit
.ba3d					_SNDInitialise:
.ba3d					_SNDSilence:
.ba3d	9c fd 06	stz $06fd			stz 	SNDLength 					; empty the queue.
.ba40	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.ba42					_SNDSilenceLoop:
.ba42	48		pha				pha
.ba43	20 02 ba	jsr $ba02			jsr 	SNDSilenceChannel
.ba46	68		pla				pla
.ba47	3a		dec a				dec 	a
.ba48	10 f8		bpl $ba42			bpl 	_SNDSilenceLoop
.ba4a					_SNDExit:
.ba4a	7a		ply				ply
.ba4b	fa		plx				plx
.ba4c	60		rts				rts
=32					SNDQueueSize = 32 							; number of queue entries
.06fd					SNDLength:
>06fd							.fill 	1
.06fe					SNDQueue:
>06fe							.fill 	SNDQueueSize * 8
.07fe					SNDPitchLow:
>07fe							.fill 	4
.0802					SNDPitchHigh:
>0802							.fill 	4
.0806					SNDVolume:
>0806							.fill 	4
.080a					SNDTimeLeft:
>080a							.fill 	4
.080e					SNDAdjustLow:
>080e							.fill 	4
.0812					SNDAdjustHigh:
>0812							.fill 	4
.ba4d					SNDUpdate:
.ba4d	ad 0a 08	lda $080a			lda 	SNDTimeLeft+0 				; look at time remaining
.ba50	f0 05		beq $ba57			beq 	_SNDUNot0 					; not playing
.ba52	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.ba54	20 76 ba	jsr $ba76			jsr 	SNDUpdateChannel 			; update it.
.ba57					_SNDUNot0:
.ba57	ad 0b 08	lda $080b			lda 	SNDTimeLeft+1
.ba5a	f0 05		beq $ba61			beq 	_SNDUNot1
.ba5c	a2 01		ldx #$01			ldx 	#1
.ba5e	20 76 ba	jsr $ba76			jsr 	SNDUpdateChannel
.ba61					_SNDUNot1:
.ba61	ad 0c 08	lda $080c			lda 	SNDTimeLeft+2
.ba64	f0 05		beq $ba6b			beq 	_SNDUNot2
.ba66	a2 02		ldx #$02			ldx 	#2
.ba68	20 76 ba	jsr $ba76			jsr 	SNDUpdateChannel
.ba6b					_SNDUNot2:
.ba6b	ad 0d 08	lda $080d			lda 	SNDTimeLeft+3
.ba6e	f0 05		beq $ba75			beq 	_SNDUNot3
.ba70	a2 03		ldx #$03			ldx 	#3
.ba72	20 76 ba	jsr $ba76			jsr 	SNDUpdateChannel
.ba75					_SNDUNot3:
.ba75	60		rts				rts
.ba76					SNDUpdateChannel:
.ba76	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.ba78	f0 2c		beq $baa6			beq 	_SNDUCExit
.ba7a	3a		dec a				dec 	a 							; decrement and update timer
.ba7b	9d 0a 08	sta $080a,x			sta 	SNDTimeLeft,x
.ba7e	f0 1d		beq $ba9d			beq 	_SNDUCUpdate 				; if zero, silence channel
.ba80	bd 0e 08	lda $080e,x			lda 	SNDAdjustLow,x 				; adjust ?
.ba83	1d 12 08	ora $0812,x			ora 	SNDAdjustHigh,x
.ba86	f0 1e		beq $baa6			beq 	_SNDUCExit 					; if zero carry on at current tone.
.ba88	18		clc				clc 								; add adjust, forcing into a 10 bit range
.ba89	bd fe 07	lda $07fe,x			lda 	SNDPitchLow,x
.ba8c	7d 0e 08	adc $080e,x			adc 	SNDAdjustLow,x
.ba8f	9d fe 07	sta $07fe,x			sta 	SNDPitchLow,x
.ba92	bd 02 08	lda $0802,x			lda 	SNDPitchHigh,x
.ba95	7d 12 08	adc $0812,x			adc 	SNDAdjustHigh,x
.ba98	29 03		and #$03			and 	#3
.ba9a	9d 02 08	sta $0802,x			sta 	SNDPitchHigh,x
.ba9d					_SNDUCUpdate:
.ba9d	8a		txa				txa 								; which channel.
.ba9e	48		pha				pha
.ba9f	20 68 b9	jsr $b968			jsr 	SNDUpdateNote 				; update the current note
.baa2	68		pla				pla
.baa3	20 29 b9	jsr $b929			jsr 	SNDCheckChannel 			; more to do ?
.baa6					_SNDUCExit:
.baa6	60		rts				rts

;******  Return to file: _basic.asm


;******  End of listing
