
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass -D AUTORUN=0 "-D MONITOR_ADDRESS=\$E000" "-D LOCKOUT_ADDRESS=\$F000" "-D BASIC_ADDRESS=\$34000" "-D SOURCE_ADDRESS=\$28000" "-D SPRITE_ADDRESS=\$30000" "-D TILEMAP_ADDRESS=\$24000" "-D TILEIMAGES_ADDRESS=\$26000" -q -b -Wall -c -C -D "HARDWARE=0        " -D HARDWARE_GEN=1 -L /Users/lesha/trunk/f256/f256-superbasic-upstream/.build/debug/basic.lst -l /Users/lesha/trunk/f256/f256-superbasic-upstream/.build/debug/basic.lbl -Wall -o /Users/lesha/trunk/f256/f256-superbasic-upstream/.build/basic.rom _basic.asm
; Sat Aug  2 15:41:57 2025

;Offset	;PC	;Hex		;Monitor	;Source

;******  Command line definitions

=0						AUTORUN=0
=$e000						 MONITOR_ADDRESS=$E000
=$f000						 LOCKOUT_ADDRESS=$F000
=$34000						 BASIC_ADDRESS=$34000
=$28000						 SOURCE_ADDRESS=$28000
=$30000						 SPRITE_ADDRESS=$30000
=$24000						 TILEMAP_ADDRESS=$24000
=$26000						 TILEIMAGES_ADDRESS=$26000
=0						HARDWARE=0
=1						HARDWARE_GEN=1

;******  Processing input file: _basic.asm


;******  Processing file: ./common/aa.system/01common.inc

=$30						ZeroPageMandatory = $30
=$50						ZeroPagePreference = $50
=$200						ArgumentStorage = $200
=$400						ControlStorage = $400
=$420						MemoryStorage = $420
=$2000						BasicStart = $2000
=$8000						BasicEnd = $8000
=$8000						CodeStart = $8000
=$1000						VariableSpace = $1000
=$2000						EndVariableSpace = $2000
=16						MathStackSize = 16
=512						BasicStackSize = 512
=3584						BasicStackBase = $1000-BasicStackSize
=80						MaxLineSize = 80

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/02macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/04data.inc

.0030						codePtr:
>0030								.fill 	4
.0034						basicStack:
>0034								.fill 	2
.0036						zTemp0:
>0036								.fill 	2
.0038						zTemp1:
>0038								.fill 	2
.003a						zTemp2:
>003a								.fill 	2
.003c						zsTemp:
>003c								.fill 	2
.003e						zaTemp:
>003e								.fill 	2
=$30						safePtr = codePtr 							; minimise direct tinkering
=$80						NSBIsNegative = $80 						; bit 7 : sign of mantissa (where numeric)
=$20						NSBIsReference = $20 						; bit 5 : is a reference
=$10						NSBIsString = $10 							; bit 4 : set if string (procedures don't go on the stack)
=$18						NSBTypeMask = $18 							; bits 4,3 : 00 int 01 float 10 string 11 procedure
=$03						NSBRefMask = $03 							; bits 0,1 : Bytes of reference, 00 = 4,01 = 1,10=2
=$04						NSBIsArray = $04
=$00						NSTInteger = $00 							; base types for bits 3..4
=$08						NSTFloat = $08
=$10						NSTString = $10
=$18						NSTProcedure = $18
.0050						NSStatus:
>0050								.fill 	MathStackSize
.0060						NSMantissa0:
>0060								.fill 	MathStackSize 				; (this is my integer mantissa system)
.0070						NSMantissa1:
>0070								.fill 	MathStackSize
.0080						NSMantissa2:
>0080								.fill 	MathStackSize
.0090						NSMantissa3:
>0090								.fill 	MathStackSize
.00a0						NSExponent:
>00a0								.fill 	MathStackSize
.0420						identStart:
>0420								.fill 	1
.0421						identTypeStart:
>0421								.fill 	1
.0422						identTypeEnd:
>0422								.fill 	1
.0423						identHash:
>0423								.fill 	1
.0424						identTypeByte:
>0424								.fill 	1	 						; (see tokenising.pdf)
.0425						encodeState:
>0425								.fill 	1
.0426						digitTemp:
>0426								.fill 	1
.0427						decimalCount:
>0427								.fill 	1
.0428						lowMemPtr:
>0428								.fill 	2
.042a						stringMemory:
>042a								.fill 	2
.042c						stringInitialised:
>042c								.fill 	1
.042d						stringTempPointer:
>042d								.fill 	2
.042f						breakCheck:
>042f								.fill 	1
.0430						decimalPlaces:
>0430								.fill 	1
.0431						dbOffset:
>0431								.fill 	1
.0432						lastParameter:
>0432								.fill 	1
.0433						dataPointer:
>0433								.fill 	5
.0438						inDataStatement:
>0438								.fill 	1
.0439						tbOffset:
>0439								.fill 	1
.043a						AssemblerAddress:
>043a								.fill 	2
.043c						AssemblerControl:
>043c								.fill 	1
.043d						ParamStart:
>043d								.fill 	2
.043f						IsGroup1:
>043f								.fill 	1
.0440						BaseOpcode:
>0440								.fill 	1
.0441						ModeMask:
>0441								.fill 	1
.0442						listIndent:
>0442								.fill 	1
.0443						lcLastCharacter:
>0443								.fill 	1
.0444						isPrintFlag:
>0444								.fill 	1
.0445						currentListColour:
>0445								.fill 	1
.0446						tokenOffset:
>0446								.fill 	1
.0447						tokenLineNumber:
>0447								.fill 	2
.0449						tokenBuffer:
>0449								.fill 	253
.0546						lineBuffer:
>0546								.fill 	253
.0643						numberBuffer:
>0643								.fill 	34
.0665						decimalBuffer:
>0665								.fill 	16
.0675						programChanged:
>0675								.fill	1							; tracks whether program has been changed since last save

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/macros.inc


;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/ticktask.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/constants.inc

=$80						AM_ISZP = $80
=$40						AM_ISG1 = $40
=$20						AM_ISG2 = $20
=224						AM_IMMEDIATE = AM_ISZP+AM_ISG1+AM_ISG2+$00
=228						AM_ZEROPAGE = AM_ISZP+AM_ISG1+AM_ISG2+$04
=40						AM_ACC = AM_ISG2+$08
=108						AM_ABS = AM_ISG1+AM_ISG2+$0C
=208						AM_INDY = AM_ISZP+AM_ISG1+$10
=244						AM_ZEROX = AM_ISZP+AM_ISG1+AM_ISG2+$14
=120						AM_ABSY = AM_ISG1+AM_ISG2+$18
=124						AM_ABSX = AM_ISG1+AM_ISG2+$1C
=209						AM_IND = AM_ISZP+AM_ISG1+$11
=$80						AM_ZEROY = AM_ISZP
=$01						AM_INDABS = $01
=$02						AM_INDABSX = $02
=192						AM_INDX = AM_ISZP+AM_ISG1+$00

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/handlers.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.inc

=1						ERRID_BREAK = 1
=2						ERRID_SYNTAX = 2
=3						ERRID_DIVZERO = 3
=4						ERRID_RANGE = 4
=5						ERRID_TYPE = 5
=6						ERRID_MEMORY = 6
=7						ERRID_ARGUMENT = 7
=8						ERRID_STOP = 8
=9						ERRID_STRING = 9
=10						ERRID_ASSERT = 10
=11						ERRID_DATA = 11
=12						ERRID_NOTDONE = 12
=13						ERRID_LINE = 13
=14						ERRID_GOSUB = 14
=15						ERRID_REPEAT = 15
=16						ERRID_WHILE = 16
=17						ERRID_FOR = 17
=18						ERRID_STACK = 18
=19						ERRID_STRUCT = 19
=20						ERRID_PROC = 20
=21						ERRID_REDEFINE = 21
=22						ERRID_ARRAYSIZE = 22
=23						ERRID_ARRAYIDX = 23
=24						ERRID_ARRAYDEC = 24
=25						ERRID_NOTFOUND = 25
=26						ERRID_DRIVEIO = 26
=27						ERRID_VERIFY = 27
=28						ERRID_NOPROGRAM = 28
=29						ERRID_PARAMETERS = 29
=30						ERRID_TOOCOMPLEX = 30
=31						ERRID_INITERROR = 31

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst.inc

=$00						KWD_LESSLESS                         = $00; $00 <<
=$01						KWD_LESSEQUAL                        = $01; $01 <=
=$02						KWD_LESSGREATER                      = $02; $02 <>
=$03						KWD_PLINGPLING3                      = $03; $03 !!3
=$04						KWD_GREATERLESS                      = $04; $04 ><
=$05						KWD_GREATEREQUAL                     = $05; $05 >=
=$06						KWD_GREATERGREATER                   = $06; $06 >>
=$07						KWD_PLINGPLING7                      = $07; $07 !!7
=$08						KWD_PLINGPLING8                      = $08; $08 !!8
=$09						KWD_PLINGPLING9                      = $09; $09 !!9
=$0a						KWD_PLINGPLING10                     = $0a; $0a !!10
=$0b						KWD_PLINGPLING11                     = $0b; $0b !!11
=$0c						KWD_PLINGPLING12                     = $0c; $0c !!12
=$0d						KWD_PLINGPLING13                     = $0d; $0d !!13
=$0e						KWD_PLINGPLING14                     = $0e; $0e !!14
=$0f						KWD_PLINGPLING15                     = $0f; $0f !!15
=$10						KWD_ATCH                             = $10; $10 @
=$11						KWD_PLINGPLING17                     = $11; $11 !!17
=$12						KWD_PLINGPLING18                     = $12; $12 !!18
=$13						KWD_LSQPAREN                         = $13; $13 [
=$14						KWD_BACKSLASH                        = $14; $14 \
=$15						KWD_RSQPAREN                         = $15; $15 ]
=$16						KWD_HAT                              = $16; $16 ^
=$17						KWD_UNDERSCORE                       = $17; $17 _
=$18						KWD_BQUOTE                           = $18; $18 `
=$19						KWD_PLINGPLING25                     = $19; $19 !!25
=$1a						KWD_PLINGPLING26                     = $1a; $1a !!26
=$1b						KWD_LCURLY                           = $1b; $1b {
=$1c						KWD_BAR                              = $1c; $1c |
=$1d						KWD_RCURLY                           = $1d; $1d }
=$1e						KWD_TILDE                            = $1e; $1e ~
=$21						KWD_PLING                            = $21; $21 !
=$22						KWD_DQUOTE                           = $22; $22 "
=$23						KWD_HASH                             = $23; $23 #
=$24						KWD_DOLLAR                           = $24; $24 $
=$25						KWD_PERCENT                          = $25; $25 %
=$26						KWD_AMPERSAND                        = $26; $26 &
=$27						KWD_QUOTE                            = $27; $27 '
=$28						KWD_LPAREN                           = $28; $28 (
=$29						KWD_RPAREN                           = $29; $29 )
=$2a						KWD_STAR                             = $2a; $2a *
=$2b						KWD_PLUS                             = $2b; $2b +
=$2c						KWD_COMMA                            = $2c; $2c ,
=$2d						KWD_MINUS                            = $2d; $2d -
=$2e						KWD_PERIOD                           = $2e; $2e .
=$2f						KWD_SLASH                            = $2f; $2f /
=$30						KWD_0                                = $30; $30 0
=$31						KWD_1                                = $31; $31 1
=$32						KWD_2                                = $32; $32 2
=$33						KWD_3                                = $33; $33 3
=$34						KWD_4                                = $34; $34 4
=$35						KWD_5                                = $35; $35 5
=$36						KWD_6                                = $36; $36 6
=$37						KWD_7                                = $37; $37 7
=$38						KWD_8                                = $38; $38 8
=$39						KWD_9                                = $39; $39 9
=$3a						KWD_COLON                            = $3a; $3a :
=$3b						KWD_SEMICOLON                        = $3b; $3b ;
=$3c						KWD_LESS                             = $3c; $3c <
=$3d						KWD_EQUAL                            = $3d; $3d =
=$3e						KWD_GREATER                          = $3e; $3e >
=$3f						KWD_QMARK                            = $3f; $3f ?
=$83						KWD_ABSLPAREN                        = $83; $83 ABS(
=$84						KWD_ALLOCLPAREN                      = $84; $84 ALLOC(
=$85						KWD_ASCLPAREN                        = $85; $85 ASC(
=$86						KWD_CHRDOLLARLPAREN                  = $86; $86 CHR$(
=$87						KWD_EVENTLPAREN                      = $87; $87 EVENT(
=$88						KWD_FALSE                            = $88; $88 FALSE
=$89						KWD_FRACLPAREN                       = $89; $89 FRAC(
=$8a						KWD_GETDOLLARLPAREN                  = $8a; $8a GET$(
=$8b						KWD_GETLPAREN                        = $8b; $8b GET(
=$8c						KWD_GETDATEDOLLARLPAREN              = $8c; $8c GETDATE$(
=$8d						KWD_GETTIMEDOLLARLPAREN              = $8d; $8d GETTIME$(
=$8e						KWD_HITLPAREN                        = $8e; $8e HIT(
=$8f						KWD_INKEYDOLLARLPAREN                = $8f; $8f INKEY$(
=$90						KWD_INKEYLPAREN                      = $90; $90 INKEY(
=$91						KWD_INTLPAREN                        = $91; $91 INT(
=$92						KWD_ISVALLPAREN                      = $92; $92 ISVAL(
=$93						KWD_ITEMCOUNTLPAREN                  = $93; $93 ITEMCOUNT(
=$94						KWD_ITEMGETDOLLARLPAREN              = $94; $94 ITEMGET$(
=$95						KWD_JOYBLPAREN                       = $95; $95 JOYB(
=$96						KWD_JOYXLPAREN                       = $96; $96 JOYX(
=$97						KWD_JOYYLPAREN                       = $97; $97 JOYY(
=$98						KWD_KEYDOWNLPAREN                    = $98; $98 KEYDOWN(
=$99						KWD_LEFTDOLLARLPAREN                 = $99; $99 LEFT$(
=$9a						KWD_LENLPAREN                        = $9a; $9a LEN(
=$9b						KWD_MAXLPAREN                        = $9b; $9b MAX(
=$9c						KWD_MIDDOLLARLPAREN                  = $9c; $9c MID$(
=$9d						KWD_MINLPAREN                        = $9d; $9d MIN(
=$9e						KWD_NOTLPAREN                        = $9e; $9e NOT(
=$9f						KWD_PEEKLPAREN                       = $9f; $9f PEEK(
=$a0						KWD_PEEKDLPAREN                      = $a0; $a0 PEEKD(
=$a1						KWD_PEEKLLPAREN                      = $a1; $a1 PEEKL(
=$a2						KWD_PEEKWLPAREN                      = $a2; $a2 PEEKW(
=$a3						KWD_PLAYINGLPAREN                    = $a3; $a3 PLAYING(
=$a4						KWD_RANDOMLPAREN                     = $a4; $a4 RANDOM(
=$a5						KWD_RIGHTDOLLARLPAREN                = $a5; $a5 RIGHT$(
=$a6						KWD_RNDLPAREN                        = $a6; $a6 RND(
=$a7						KWD_SCREENDOLLARLPAREN               = $a7; $a7 SCREEN$(
=$a8						KWD_SCREENLPAREN                     = $a8; $a8 SCREEN(
=$a9						KWD_SGNLPAREN                        = $a9; $a9 SGN(
=$aa						KWD_SPCLPAREN                        = $aa; $aa SPC(
=$ab						KWD_STRDOLLARLPAREN                  = $ab; $ab STR$(
=$ac						KWD_TILELPAREN                       = $ac; $ac TILE(
=$ad						KWD_TIMERLPAREN                      = $ad; $ad TIMER(
=$ae						KWD_TRUE                             = $ae; $ae TRUE
=$af						KWD_VALLPAREN                        = $af; $af VAL(
=$b0						KWD_FOR                              = $b0; $b0 FOR
=$b1						KWD_IF                               = $b1; $b1 IF
=$b2						KWD_PROC                             = $b2; $b2 PROC
=$b3						KWD_REPEAT                           = $b3; $b3 REPEAT
=$b4						KWD_WHILE                            = $b4; $b4 WHILE
=$b5						KWD_ENDIF                            = $b5; $b5 ENDIF
=$b6						KWD_ENDPROC                          = $b6; $b6 ENDPROC
=$b7						KWD_NEXT                             = $b7; $b7 NEXT
=$b8						KWD_THEN                             = $b8; $b8 THEN
=$b9						KWD_UNTIL                            = $b9; $b9 UNTIL
=$ba						KWD_WEND                             = $ba; $ba WEND
=$bb						KWD_AT                               = $bb; $bb AT
=$bc						KWD_BY                               = $bc; $bc BY
=$bd						KWD_CALL                             = $bd; $bd CALL
=$be						KWD_CIRCLE                           = $be; $be CIRCLE
=$bf						KWD_CLEAR                            = $bf; $bf CLEAR
=$c0						KWD_COLOR                            = $c0; $c0 COLOR
=$c1						KWD_COLOUR                           = $c1; $c1 COLOUR
=$c2						KWD_DATA                             = $c2; $c2 DATA
=$c3						KWD_DIM                              = $c3; $c3 DIM
=$c4						KWD_DOWNTO                           = $c4; $c4 DOWNTO
=$c5						KWD_ELSE                             = $c5; $c5 ELSE
=$c6						KWD_FROM                             = $c6; $c6 FROM
=$c7						KWD_GFX                              = $c7; $c7 GFX
=$c8						KWD_HERE                             = $c8; $c8 HERE
=$c9						KWD_IMAGE                            = $c9; $c9 IMAGE
=$ca						KWD_LET                              = $ca; $ca LET
=$cb						KWD_LINE                             = $cb; $cb LINE
=$cc						KWD_LOCAL                            = $cc; $cc LOCAL
=$cd						KWD_MEMCOPY                          = $cd; $cd MEMCOPY
=$ce						KWD_OFF                              = $ce; $ce OFF
=$cf						KWD_ON                               = $cf; $cf ON
=$d0						KWD_OUTLINE                          = $d0; $d0 OUTLINE
=$d1						KWD_PALETTE                          = $d1; $d1 PALETTE
=$d2						KWD_PLOT                             = $d2; $d2 PLOT
=$d3						KWD_POKE                             = $d3; $d3 POKE
=$d4						KWD_POKED                            = $d4; $d4 POKED
=$d5						KWD_POKEL                            = $d5; $d5 POKEL
=$d6						KWD_POKEW                            = $d6; $d6 POKEW
=$d7						KWD_READ                             = $d7; $d7 READ
=$d8						KWD_RECT                             = $d8; $d8 RECT
=$d9						KWD_REM                              = $d9; $d9 REM
=$da						KWD_SOLID                            = $da; $da SOLID
=$db						KWD_SOUND                            = $db; $db SOUND
=$dc						KWD_SPRITE                           = $dc; $dc SPRITE
=$dd						KWD_TEXT                             = $dd; $dd TEXT
=$de						KWD_TO                               = $de; $de TO
=$83						KWD1_ASSEMBLE                         = $83; $83 ASSEMBLE
=$84						KWD1_ASSERT                           = $84; $84 ASSERT
=$85						KWD1_BITMAP                           = $85; $85 BITMAP
=$86						KWD1_BLOAD                            = $86; $86 BLOAD
=$87						KWD1_BSAVE                            = $87; $87 BSAVE
=$88						KWD1_CLS                              = $88; $88 CLS
=$89						KWD1_CPRINT                           = $89; $89 CPRINT
=$8a						KWD1_CURSOR                           = $8a; $8a CURSOR
=$8b						KWD1_DIR                              = $8b; $8b DIR
=$8c						KWD1_DRIVE                            = $8c; $8c DRIVE
=$8d						KWD1_END                              = $8d; $8d END
=$8e						KWD1_EXPLODE                          = $8e; $8e EXPLODE
=$8f						KWD1_GO                               = $8f; $8f GO
=$90						KWD1_GOSUB                            = $90; $90 GOSUB
=$91						KWD1_GOTO                             = $91; $91 GOTO
=$92						KWD1_HIMEM                            = $92; $92 HIMEM
=$93						KWD1_INPUT                            = $93; $93 INPUT
=$94						KWD1_LIST                             = $94; $94 LIST
=$95						KWD1_LOAD                             = $95; $95 LOAD
=$96						KWD1_MDELTA                           = $96; $96 MDELTA
=$97						KWD1_MOUSE                            = $97; $97 MOUSE
=$98						KWD1_NEW                              = $98; $98 NEW
=$99						KWD1_OPTION                           = $99; $99 OPTION
=$9a						KWD1_PING                             = $9a; $9a PING
=$9b						KWD1_PRINT                            = $9b; $9b PRINT
=$9c						KWD1_RESTORE                          = $9c; $9c RESTORE
=$9d						KWD1_RETURN                           = $9d; $9d RETURN
=$9e						KWD1_RUN                              = $9e; $9e RUN
=$9f						KWD1_SAVE                             = $9f; $9f SAVE
=$a0						KWD1_SETDATE                          = $a0; $a0 SETDATE
=$a1						KWD1_SETTIME                          = $a1; $a1 SETTIME
=$a2						KWD1_SHOOT                            = $a2; $a2 SHOOT
=$a3						KWD1_SPRITES                          = $a3; $a3 SPRITES
=$a4						KWD1_STOP                             = $a4; $a4 STOP
=$a5						KWD1_TILE                             = $a5; $a5 TILE
=$a6						KWD1_TILES                            = $a6; $a6 TILES
=$a7						KWD1_TRY                              = $a7; $a7 TRY
=$a8						KWD1_VERIFY                           = $a8; $a8 VERIFY
=$a9						KWD1_XGO                              = $a9; $a9 XGO
=$aa						KWD1_XLOAD                            = $aa; $aa XLOAD
=$ab						KWD1_ZAP                              = $ab; $ab ZAP

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/kwdconst0.inc

=$80						KWC_EOL = $80
=$81						KWC_SHIFT1 = $81
=$82						KWC_SHIFT2 = $82
=$ff						KWC_STRING = $FF
=$fe						KWC_HEXCONST = $FE
=$b0						KWC_FIRST_STRUCTURE = $b0
=$b5						KWC_FIRST_STRUCTURE_DEC = $b5
=$ba						KWC_LAST_STRUCTURE = $ba
=$83						KWC_FIRST_UNARY = $83
=$af						KWC_LAST_UNARY = $af

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/access.inc


;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/stack.inc

=$e0						STK_GOSUB = $E0
=$d0						STK_FOR = $D0
=$c0						STK_REPEAT = $C0
=$b0						STK_PROC = $B0
=$a0						STK_WHILE = $A0
=$01						STK_LOCALN = $01
=$02						STK_LOCALS = $02

;******  Return to file: _basic.asm


;******  Processing file: ./common/aa.system/00start.asm

.8000						F256Header:
>8000		f2 56						.text	$f2,$56         			; Signature
>8002		04						.byte   4               			; 4 blocks
>8003		04						.byte   4               			; mount at $8000
>8004		40 80						.word   Boot 	      				; Start here
>8006		01						.byte   1 			               	; version
>8007		00						.byte   0               			; reserved
>8008		00						.byte   0               			; reserved
>8009		00						.byte   0               			; reserved
>800a		62 61 73 69 63 00				.text   "basic",0 					; name of program.
>8010		00						.text   0							; arguments
>8011		54 68 65 20 53 75 70 65				.text	"The SuperBASIC environment.",0	; description
>8019		72 42 41 53 49 43 20 65 6e 76 69 72 6f 6e 6d 65
>8029		6e 74 2e 00
.8040		4c b1 80	jmp $80b1	Boot:	jmp 	Start

;******  Processing file: ./common/aa.system/../../../modules/.build/_exports.module.asm

=1						PagingEnabled = 1
.8043						EXTInitialise:
.8043		e6 0d		inc $0d			inc 8+5
.8045		20 e6 a1	jsr $a1e6		jsr	Export_EXTInitialise
.8048		08		php			php
.8049		c6 0d		dec $0d			dec 8+5
.804b		28		plp			plp
.804c		60		rts			rts
.804d						EXTPrintCharacter:
.804d		e6 0d		inc $0d			inc 8+5
.804f		20 0b a0	jsr $a00b		jsr	Export_EXTPrintCharacter
.8052		08		php			php
.8053		c6 0d		dec $0d			dec 8+5
.8055		28		plp			plp
.8056		60		rts			rts
.8057						EXTPrintNoControl:
.8057		e6 0d		inc $0d			inc 8+5
.8059		20 00 a0	jsr $a000		jsr	Export_EXTPrintNoControl
.805c		08		php			php
.805d		c6 0d		dec $0d			dec 8+5
.805f		28		plp			plp
.8060		60		rts			rts
.8061						EXTScreenAt:
.8061		e6 0d		inc $0d			inc 8+5
.8063		20 e6 a2	jsr $a2e6		jsr	Export_EXTScreenAt
.8066		08		php			php
.8067		c6 0d		dec $0d			dec 8+5
.8069		28		plp			plp
.806a		60		rts			rts
.806b						EXTSetCurrentLine:
.806b		e6 0d		inc $0d			inc 8+5
.806d		20 d1 a1	jsr $a1d1		jsr	Export_EXTSetCurrentLine
.8070		08		php			php
.8071		c6 0d		dec $0d			dec 8+5
.8073		28		plp			plp
.8074		60		rts			rts
.8075						SNDCommand:
.8075		e6 0d		inc $0d			inc 8+5
.8077		20 f7 b9	jsr $b9f7		jsr	Export_SNDCommand
.807a		08		php			php
.807b		c6 0d		dec $0d			dec 8+5
.807d		28		plp			plp
.807e		60		rts			rts
.807f						SNDUpdate:
.807f		e6 0d		inc $0d			inc 8+5
.8081		20 2a ba	jsr $ba2a		jsr	Export_SNDUpdate
.8084		08		php			php
.8085		c6 0d		dec $0d			dec 8+5
.8087		28		plp			plp
.8088		60		rts			rts
.8089						TKInitialise:
.8089		e6 0d		inc $0d			inc 8+5
.808b		20 84 b3	jsr $b384		jsr	Export_TKInitialise
.808e		08		php			php
.808f		c6 0d		dec $0d			dec 8+5
.8091		28		plp			plp
.8092		60		rts			rts
.8093						TKListConvertLine:
.8093		e6 0d		inc $0d			inc 8+5
.8095		20 90 b3	jsr $b390		jsr	Export_TKListConvertLine
.8098		08		php			php
.8099		c6 0d		dec $0d			dec 8+5
.809b		28		plp			plp
.809c		60		rts			rts
.809d						TKTokeniseLine:
.809d		e6 0d		inc $0d			inc 8+5
.809f		20 3c b6	jsr $b63c		jsr	Export_TKTokeniseLine
.80a2		08		php			php
.80a3		c6 0d		dec $0d			dec 8+5
.80a5		28		plp			plp
.80a6		60		rts			rts
.80a7						GXGraphicDraw:
.80a7		e6 0d		inc $0d			inc 8+5
.80a9		20 99 a3	jsr $a399		jsr	Export_GXGraphicDraw
.80ac		08		php			php
.80ad		c6 0d		dec $0d			dec 8+5
.80af		28		plp			plp
.80b0		60		rts			rts

;******  Return to file: ./common/aa.system/00start.asm

.80b1		a2 ff		ldx #$ff	Start:	ldx 	#$FF 						; stack reset
.80b3		9a		txs				txs
.80b4		20 43 80	jsr $8043			jsr 	EXTInitialise 				; hardware initialise
.80b7		a5 00		lda $00				lda 	0  							; turn on editing of MMU LUT
.80b9		09 80		ora #$80			ora 	#$80
.80bb		85 00		sta $00				sta 	0
.80bd		ad 02 20	lda $2002			lda 	$2002 						; if $2002..5 is BT65 then jump to $2000
.80c0		c9 42		cmp #$42			cmp 	#"B"
.80c2		d0 18		bne $80dc			bne 	_NoMachineCode
.80c4		ad 03 20	lda $2003			lda 	$2003
.80c7		c9 54		cmp #$54			cmp 	#"T"
.80c9		d0 11		bne $80dc			bne 	_NoMachineCode
.80cb		ad 04 20	lda $2004			lda 	$2004
.80ce		c9 36		cmp #$36			cmp 	#"6"
.80d0		d0 0a		bne $80dc			bne 	_NoMachineCode
.80d2		ad 05 20	lda $2005			lda 	$2005
.80d5		c9 35		cmp #$35			cmp 	#"5"
.80d7		d0 03		bne $80dc			bne 	_NoMachineCode
.80d9		4c 00 20	jmp $2000			jmp 	$2000
.80dc						_NoMachineCode:
.80dc		a9 00		lda #$00			lda 	#0 							; zero the default drive.
.80de		20 4b 84	jsr $844b			jsr 	KNLSetDrive
.80e1		20 89 80	jsr $8089			jsr 	TKInitialise 				; initialise tokeniser.
.80e4		a9 00		lda #$00			lda 	#0 							; graphics system initialise.
.80e6		aa		tax				tax
.80e7		a8		tay				tay
.80e8		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.80eb		a9 0f		lda #$0f			lda 	#$0F 						; initialise sound system
.80ed		20 75 80	jsr $8075			jsr 	SNDCommand
.80f0		a9 8d		lda #$8d			lda 	#128+13 					; Display FPGA information.
.80f2		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.80f5		a9 09		lda #$09			lda 	#9
.80f7		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.80fa		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.80fd		64 01		stz $01				stz 	1
.80ff		ad ad d6	lda $d6ad			lda 	$D6AD
.8102		20 25 86	jsr $8625			jsr 	PrintHex
.8105		ad ac d6	lda $d6ac			lda 	$D6AC
.8108		20 25 86	jsr $8625			jsr 	PrintHex
.810b		ad ab d6	lda $d6ab			lda 	$D6AB
.810e		20 25 86	jsr $8625			jsr 	PrintHex
.8111		ad aa d6	lda $d6aa			lda 	$D6AA
.8114		20 25 86	jsr $8625			jsr 	PrintHex
.8117		a9 20		lda #$20			lda 	#32
.8119		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.811c		ad a8 d6	lda $d6a8			lda 	$D6A8
.811f		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8122		ad a9 d6	lda $d6a9			lda 	$D6A9
.8125		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8128		a9 0d		lda #$0d			lda 	#13 						; display Kernel information
.812a		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.812d		a9 09		lda #$09			lda 	#9
.812f		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8132		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8135		a9 08		lda #$08			lda 	#$08
.8137		a2 e0		ldx #$e0			ldx 	#$E0
.8139		20 86 95	jsr $9586			jsr 	PrintStringXA
.813c		a2 81		ldx #$81			ldx 	#Prompt >> 8 				; display prompt
.813e		a9 4f		lda #$4f			lda 	#Prompt & $FF
.8140		20 86 95	jsr $9586			jsr 	PrintStringXA
.8143		20 00 83	jsr $8300			jsr 	ResetIOTracking 			; reset the I/O tracking.
.8146		20 4d 8f	jsr $8f4d			jsr 	NewProgram 					; erase current program
.8149		4c 1c 89	jmp $891c			jmp 	WarmStart					; make same size.
.814c		4c 1c 89	jmp $891c			jmp 	WarmStart
>814f		0d				Prompt:	.text 	13

;******  Processing file: ./common/aa.system/../generated/timestamp.asm

>8150		09 09 30 32 2f 30 38 2f			.text 9,9,"02/08/25 1.0"
>8158		32 35 20 31 2e 30

;******  Return to file: ./common/aa.system/00start.asm

>815e		0d 0d 0d 00					.text 	13,13,13,0

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/events.asm

.8162						ProcessEvents:
.8162		20 8f 84	jsr $848f			jsr 	KNLSetEventPointer
.8165		20 09 83	jsr $8309			jsr     GetNextEvent 				; get next event
.8168		b0 53		bcs $81bd			bcs 	_PEExitZ 					; nothing left to process.
.816a		ad be 07	lda $07be			lda 	KNLEvent.type 				; go back if event not key.pressed.
.816d		c9 52		cmp #$52	                cmp     #kernel.event.timer.EXPIRED
.816f		f0 24		beq $8195	                beq     _PEIsTimer
.8171		c9 0a		cmp #$0a			cmp     #kernel.event.key.RELEASED
.8173		f0 27		beq $819c			beq     _PEIsRelease
.8175		c9 08		cmp #$08			cmp 	#kernel.event.key.PRESSED
.8177		d0 e9		bne $8162			bne 	ProcessEvents
.8179		ad c4 07	lda $07c4			lda	KNLEvent.key.flags 			; is KNLEvent.key.flags = 0 ?
.817c		30 20		bmi $819e			bmi 	_PEIsRaw
.817e		d0 e2		bne $8162			bne 	ProcessEvents
.8180		ad c3 07	lda $07c3			lda 	KNLEvent.key.ascii 			; is it Ctrl+C
.8183		c9 03		cmp #$03			cmp 	#3
.8185		f0 33		beq $81ba			beq 	_PEReturnBreak  			; no, keep going.
.8187		da		phx				phx
.8188		ae c1 07	ldx $07c1	                ldx     KNLEvent.key.keyboard
.818b		d0 05		bne $8192	                bne     +
.818d		aa		tax		                tax
.818e		20 07 82	jsr $8207	                jsr     StartRepeatTimerForKey
.8191		8a		txa		                txa
.8192		fa		plx		+               plx
.8193		80 14		bra $81a9			bra 	_PEQueueA
.8195						_PEIsTimer:
.8195		20 2a 82	jsr $822a	                jsr     HandleRepeatTimerEvent
.8198		b0 c8		bcs $8162	                bcs     ProcessEvents
.819a		80 0d		bra $81a9	                bra     _PEQueueA
.819c						_PEIsRelease:
.819c		80 c4		bra $8162	                bra     ProcessEvents
.819e						_PEIsRaw:
.819e		ad c3 07	lda $07c3			lda 	KNLEvent.key.ascii 			; return pseudo ascii value if F1-F12
.81a1		c9 81		cmp #$81			cmp 	#129
.81a3		90 bd		bcc $8162			bcc		ProcessEvents
.81a5		c9 8d		cmp #$8d			cmp 	#140+1
.81a7		b0 b9		bcs $8162			bcs 	ProcessEvents
.81a9						_PEQueueA:
.81a9		da		phx				phx
.81aa		ae 80 06	ldx $0680			ldx 	KeyboardQueueEntries 		; get keyboard queue size into X
.81ad		e0 08		cpx #$08			cpx 	#KBDQueueSize 				; if full, then ignore
.81af		f0 06		beq $81b7			beq 	_PENoQueue
.81b1		9d 78 06	sta $0678,x			sta 	KeyboardQueue,x 			; write into queue
.81b4		ee 80 06	inc $0680			inc 	KeyboardQueueEntries 		; bump count
.81b7						_PENoQueue:
.81b7		fa		plx				plx
.81b8		80 a8		bra $8162			bra 	ProcessEvents
.81ba						_PEReturnBreak:
.81ba		a9 ff		lda #$ff			lda 	#255 						; return with NZ state
.81bc		60		rts				rts
.81bd						_PEExitZ:
.81bd		a9 00		lda #$00			lda 	#0
.81bf		60		rts				rts
.81c0						PopKeyboardQueue:
.81c0		ad 80 06	lda $0680			lda 	KeyboardQueueEntries 		; get keyboard queue entries.
.81c3		f0 17		beq $81dc			beq 	_PKQExit 					; zero, then exit.
.81c5		ad 78 06	lda $0678			lda 	KeyboardQueue 				; save head of keyboard queue
.81c8		48		pha				pha
.81c9		da		phx				phx 								; drop head of queue
.81ca		a2 00		ldx #$00			ldx 	#0
.81cc						_PKQLoop:
.81cc		bd 79 06	lda $0679,x			lda 	KeyboardQueue+1,x 			; shift everything back one.
.81cf		9d 78 06	sta $0678,x			sta 	KeyboardQueue,x  			; not efficient but doesn't matter.
.81d2		e8		inx				inx
.81d3		e0 07		cpx #$07			cpx 	#7
.81d5		d0 f5		bne $81cc			bne 	_PKQLoop
.81d7		fa		plx				plx
.81d8		ce 80 06	dec $0680			dec 	KeyboardQueueEntries 		; one fewer in queue.
.81db		68		pla				pla 								; restore head of queue.
.81dc						_PKQExit:
.81dc		60		rts				rts
.81dd						KNLGetKeyPressed:
.81dd		a5 01		lda $01				lda 	1 							; save I/O 0
.81df		48		pha				pha
.81e0		64 01		stz $01				stz 	1 							; access I/O Page 0
.81e2		38		sec				sec 								; calculate timer - LastTick
.81e3		ad 59 d6	lda $d659			lda 	$D659
.81e6		cd 81 06	cmp $0681			cmp 	LastTick
.81e9		f0 06		beq $81f1			beq 	_NoFireTick 				; if < 3 clocks don't fire.
.81eb		8d 81 06	sta $0681			sta 	LastTick 					; update last timer
.81ee		20 f8 82	jsr $82f8			jsr 	TickHandler 							; go do the code.
.81f1						_NoFireTick:
.81f1		68		pla				pla 								; restore I/O 0
.81f2		85 01		sta $01				sta 	1
.81f4		ad 80 06	lda $0680			lda 	KeyboardQueueEntries 		; something in the queue
.81f7		d0 c7		bne $81c0			bne 	PopKeyboardQueue 			; if so, pop and return it
.81f9		20 62 81	jsr $8162			jsr 	ProcessEvents 				; process any outstanding events
.81fc		a9 00		lda #$00			lda 	#0
.81fe		60		rts				rts
.81ff						KNLGetSingleCharacter:
.81ff		20 dd 81	jsr $81dd			jsr 	KNLGetKeyPressed
.8202		c9 00		cmp #$00			cmp 	#0
.8204		f0 f9		beq $81ff			beq 	KNLGetSingleCharacter
.8206		60		rts				rts
>0000						key             .byte   ?   ; Key-code to repeat.
>0001						cookie          .byte   ?   ; Timer ID.
.8207						StartRepeatTimerForKey
.8207		8d 76 06	sta $0676	                sta     repeat.key
.820a		ee 77 06	inc $0677	                inc     repeat.cookie
.820d		a9 80		lda #$80	                lda     #kernel.args.timer.FRAMES | kernel.args.timer.QUERY
.820f		85 f3		sta $f3		                sta     kernel.args.timer.units
.8211		20 f0 ff	jsr $fff0	                jsr     kernel.Clock.SetTimer
.8214		69 1e		adc #$1e	                adc     #30
.8216		80 04		bra $821c	                bra     ScheduleRepeatEvent
.8218						StopRepeat
.8218		ee 77 06	inc $0677	                inc     repeat.cookie
.821b		60		rts		                rts
.821c						ScheduleRepeatEvent
.821c		85 f4		sta $f4		                sta     kernel.args.timer.absolute
.821e		a9 00		lda #$00	                lda     #kernel.args.timer.FRAMES
.8220		85 f3		sta $f3		                sta     kernel.args.timer.units
.8222		ad 77 06	lda $0677	                lda     repeat.cookie
.8225		85 f5		sta $f5		                sta     kernel.args.timer.cookie
.8227		4c f0 ff	jmp $fff0	                jmp     kernel.Clock.SetTimer
.822a						HandleRepeatTimerEvent
.822a		ad c2 07	lda $07c2	                lda     KNLEvent.timer.cookie
.822d		cd 77 06	cmp $0677	                cmp     repeat.cookie
.8230		f0 02		beq $8234	                beq     _repeat
.8232		38		sec		                sec
.8233		60		rts		                rts
.8234						_repeat
.8234		ad c1 07	lda $07c1	                lda     KNLEvent.timer.value
.8237		18		clc		                clc
.8238		69 03		adc #$03	                adc     #3
.823a		20 1c 82	jsr $821c	                jsr     ScheduleRepeatEvent
.823d		ad 76 06	lda $0676	                lda     repeat.key
.8240		18		clc		                clc
.8241		60		rts		                rts
.0676						repeat:
>0676						key             .byte   ?   ; Key-code to repeat.
>0677						cookie          .byte   ?   ; Timer ID.
=8						KBDQueueSize = 8
.0678						KeyboardQueue:
>0678								.fill 	KBDQueueSize
.0680						KeyboardQueueEntries:
>0680								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/input.asm

.8242						InputLine:
.8242		48		pha				pha
.8243		da		phx				phx
.8244		5a		phy				phy
.8245		a5 01		lda $01				lda 	1 							; save I/O page
.8247		48		pha				pha
.8248						_EILLoop:
.8248		20 ff 81	jsr $81ff			jsr 	KNLGetSingleCharacter 		; get one single character
.824b		c9 0d		cmp #$0d			cmp 	#13 						; scrape line if exit.
.824d		f0 53		beq $82a2			beq 	_EILExit
.824f		c9 04		cmp #$04			cmp 	#4 							; Ctrl+D delete at cursor
.8251		f0 39		beq $828c			beq 	_EILDelete
.8253		c9 08		cmp #$08			cmp 	#8 							; Ctrl+H backspace
.8255		f0 2b		beq $8282			beq 	_EILBackspace
.8257		c9 20		cmp #$20			cmp 	#' '						; < space, print it
.8259		90 21		bcc $827c			bcc 	_EILPrintLoop
.825b		c9 7f		cmp #$7f			cmp 	#$7F 						; if -ve print it
.825d		b0 1d		bcs $827c			bcs 	_EILPrintLoop
.825f		aa		tax				tax 								; save character in X
.8260		a9 02		lda #$02			lda	 	#2 							; screen character memory
.8262		85 01		sta $01				sta 	1
.8264		ac ed 07	ldy $07ed			ldy 	EXTScreenWidth 				; read the last character.
.8267		88		dey				dey
.8268		b1 40		lda ($40),y			lda 	(EXTAddress),y
.826a		c9 20		cmp #$20			cmp 	#' ' 						; if not space then reject.
.826c		d0 da		bne $8248			bne 	_EILLoop
.826e		da		phx				phx 								; save character on stack
.826f		a9 02		lda #$02			lda 	#2  						; insert a space
.8271		85 01		sta $01				sta 	1
.8273		20 e6 82	jsr $82e6			jsr 	EXTILInsert 				; insert in text screen
.8276		e6 01		inc $01				inc 	1
.8278		20 e6 82	jsr $82e6			jsr 	EXTILInsert 				; insert in colour screen
.827b		68		pla				pla 								; get character back.
.827c						_EILPrintLoop:
.827c		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.827f		80 c7		bra $8248			bra 	_EILLoop
.8281		60		rts				rts
.8282						_EILBackspace:
.8282		ad eb 07	lda $07eb			lda 	EXTColumn					; can we backspace ?
.8285		f0 c1		beq $8248			beq 	_EILLoop
.8287		a9 02		lda #$02			lda 	#2 							; move cursor left
.8289		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.828c						_EILDelete
.828c		a9 02		lda #$02			lda 	#2 							; text block
.828e		85 01		sta $01				sta 	1
.8290		a9 20		lda #$20			lda 	#' ' 						; backspace text.
.8292		20 d1 82	jsr $82d1			jsr 	EXTILDelete
.8295		e6 01		inc $01				inc 	1 							; colour block
.8297		ac eb 07	ldy $07eb			ldy 	EXTColumn 					; get attribute of last character
.829a		88		dey				dey
.829b		b1 40		lda ($40),y			lda 	(EXTAddress),y
.829d		20 d1 82	jsr $82d1			jsr 	EXTILDelete 				; backspace attribute
.82a0		80 a6		bra $8248			bra 	_EILLoop 					; and go round.
.82a2						_EILExit:
.82a2		a9 02		lda #$02			lda 	#2 							; switch to page 2
.82a4		85 01		sta $01				sta 	1
.82a6		a0 00		ldy #$00			ldy 	#0 							; copy current line into buffer.
.82a8						_EILScrapeLine:
.82a8		b1 40		lda ($40),y			lda 	(EXTAddress),y
.82aa		99 46 05	sta $0546,y			sta 	lineBuffer,y
.82ad		c8		iny				iny
.82ae		cc ed 07	cpy $07ed			cpy 	EXTScreenWidth
.82b1		d0 f5		bne $82a8			bne 	_EILScrapeLine
.82b3						_EILTrimSpaces:
.82b3		88		dey				dey
.82b4		c0 ff		cpy #$ff			cpy 	#$FF 						; back past the start
.82b6		f0 07		beq $82bf			beq 	_EILEndTrim		 			; zero the input line.
.82b8		b9 46 05	lda $0546,y			lda 	lineBuffer,y
.82bb		c9 20		cmp #$20			cmp 	#' '
.82bd		f0 f4		beq $82b3			beq 	_EILTrimSpaces 				; if fail this found non space character
.82bf						_EILEndTrim:
.82bf		c8		iny				iny 								; trim after non space character.
.82c0		a9 00		lda #$00			lda 	#0 							; trim here.
.82c2		99 46 05	sta $0546,y			sta 	lineBuffer,y
.82c5		a9 0d		lda #$0d			lda 	#13 						; echo the RETURN
.82c7		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.82ca		68		pla				pla 								; reset I/O page
.82cb		85 01		sta $01				sta 	1
.82cd		7a		ply				ply
.82ce		fa		plx				plx
.82cf		68		pla				pla
.82d0		60		rts				rts
.82d1						EXTILDelete:
.82d1		48		pha				pha 								; save the new character
.82d2		ac eb 07	ldy $07eb			ldy 	EXTColumn 					; start copying from here.
.82d5						_EXTDLoop:
.82d5		c8		iny				iny 								; copy one byte down.
.82d6		b1 40		lda ($40),y			lda 	(EXTAddress),y
.82d8		88		dey				dey
.82d9		91 40		sta ($40),y			sta 	(EXTAddress),y
.82db		c8		iny				iny 								; do till end of line.
.82dc		cc ed 07	cpy $07ed			cpy 	EXTScreenWidth
.82df		90 f4		bcc $82d5			bcc 	_EXTDLoop
.82e1		88		dey				dey 	 							; write in last slot.
.82e2		68		pla				pla
.82e3		91 40		sta ($40),y			sta 	(EXTAddress),y
.82e5		60		rts				rts
.82e6						EXTILInsert:
.82e6		ac ed 07	ldy $07ed			ldy 	EXTScreenWidth 				; end position
.82e9						_EXTILoop:
.82e9		88		dey				dey 								; back one
.82ea		cc eb 07	cpy $07eb			cpy 	EXTColumn 					; exit if reached insert point.
.82ed		f0 08		beq $82f7			beq 	_EXTIExit
.82ef		88		dey				dey 								; copy one byte up.
.82f0		b1 40		lda ($40),y			lda 	(EXTAddress),y
.82f2		c8		iny				iny
.82f3		91 40		sta ($40),y			sta 	(EXTAddress),y
.82f5		80 f2		bra $82e9			bra 	_EXTILoop
.82f7						_EXTIExit:
.82f7		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/ticktask.asm

.82f8						TickHandler:
.82f8		da		phx				phx
.82f9		5a		phy				phy 								; need to preserve Y
.82fa		20 7f 80	jsr $807f			jsr 	SNDUpdate 					; update sound
.82fd		7a		ply				ply
.82fe		fa		plx				plx
.82ff		60		rts				rts
.0681						LastTick:
>0681								.fill 		1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/trackio.asm

.8300						ResetIOTracking:
.8300		a2 3a		ldx #$3a			ldx 	#GNEEnd-GNEBegin-1
.8302						_RIOLoop:
.8302		9e 82 06	stz $0682,x			stz 	GNEBegin,x
.8305		ca		dex				dex
.8306		10 fa		bpl $8302			bpl 	_RIOLoop
.8308		60		rts				rts
.8309						GetNextEvent:
.8309		20 00 ff	jsr $ff00			jsr 	kernel.NextEvent 			; get event
.830c		08		php				php									; save yes/no flag.
.830d		b0 29		bcs $8338			bcs 	_GNEExit
.830f		48		pha				pha 								; save registers
.8310		da		phx				phx
.8311		5a		phy				phy
.8312		ad be 07	lda $07be			lda 	KNLEvent.type	 			; check for PRESSED or RELEASED
.8315		c9 08		cmp #$08			cmp 	#kernel.event.key.PRESSED
.8317		f0 04		beq $831d			beq 	_GNEKeyEvent
.8319		c9 0a		cmp #$0a			cmp 	#kernel.event.key.RELEASED
.831b		d0 08		bne $8325			bne 	_GNECheckMouseEvent
.831d						_GNEKeyEvent:
.831d		20 f7 83	jsr $83f7			jsr 	ProcessKeyboardEvent 		; process keyboard up/down.
.8320		20 16 84	jsr $8416			jsr 	UpdateKeyboardJoystick 		; update the keyboard-joystick.
.8323		80 10		bra $8335			bra 	_GNEEventExit
.8325						_GNECheckMouseEvent:
.8325		c9 0c		cmp #$0c			cmp 	#kernel.event.mouse.DELTA 	; check for move events
.8327		d0 05		bne $832e			bne 	_GNENotDelta
.8329		20 3a 83	jsr $833a			jsr 	ProcessMouseDeltaEvent 		; process them.
.832c		80 07		bra $8335			bra 	_GNEEventExit
.832e						_GNENotDelta:
.832e		c9 0e		cmp #$0e			cmp 	#kernel.event.mouse.CLICKS 	; check for click events
.8330		d0 03		bne $8335			bne 	_GNEEventExit
.8332		20 69 83	jsr $8369			jsr 	ProcessMouseClickEvent 		; process them.
.8335						_GNEEventExit:
.8335		7a		ply				ply 								; restore registers
.8336		fa		plx				plx
.8337		68		pla				pla
.8338						_GNEExit:
.8338		28		plp				plp
.8339		60		rts				rts
.833a						ProcessMouseDeltaEvent:
.833a		a2 23		ldx #$23			ldx 	#MouseDeltaX-GNEBegin
.833c		ad c1 07	lda $07c1			lda 	KNLEvent.mouse.delta.x
.833f		20 90 83	jsr $8390			jsr 	PMKAdjustTotal
.8342		20 d3 83	jsr $83d3			jsr 	PMKAddSubtract
.8345		ad c2 07	lda $07c2			lda 	KNLEvent.mouse.delta.y
.8348		20 90 83	jsr $8390			jsr 	PMKAdjustTotal
.834b		20 d3 83	jsr $83d3			jsr 	PMKAddSubtract
.834e		ad c3 07	lda $07c3			lda 	KNLEvent.mouse.delta.z
.8351		20 90 83	jsr $8390			jsr 	PMKAdjustTotal
.8354		20 d3 83	jsr $83d3			jsr 	PMKAddSubtract
.8357		ad c4 07	lda $07c4			lda 	KNLEvent.mouse.delta.buttons
.835a		a2 35		ldx #$35			ldx 	#MouseStatusX-GNEBegin
.835c		20 7e 83	jsr $837e			jsr 	PMKOutputButton
.835f		20 7e 83	jsr $837e			jsr 	PMKOutputButton
.8362		20 7e 83	jsr $837e			jsr 	PMKOutputButton
.8365		20 9f 83	jsr $839f			jsr 	PMKClipMouseCoord
.8368		60		rts				rts
.8369						ProcessMouseClickEvent:
.8369		a2 29		ldx #$29			ldx 	#MouseCountInner-GNEBegin
.836b		ad c1 07	lda $07c1			lda 	KNLEvent.mouse.clicks.inner
.836e		20 d7 83	jsr $83d7			jsr 	PMKAdd
.8371		ad c2 07	lda $07c2			lda 	KNLEvent.mouse.clicks.middle
.8374		20 d7 83	jsr $83d7			jsr 	PMKAdd
.8377		ad c3 07	lda $07c3			lda 	KNLEvent.mouse.clicks.outer
.837a		20 d7 83	jsr $83d7			jsr 	PMKAdd
.837d		60		rts				rts
.837e						PMKOutputButton:
.837e		9e 82 06	stz $0682,x			stz 	GNEBegin,x 					; button to zero
.8381		9e 83 06	stz $0683,x			stz 	GNEBegin+1,x
.8384		6a		ror a				ror 	a 							; shift LSB into carry
.8385		90 06		bcc $838d			bcc 	_PMKOBExit
.8387		de 82 06	dec $0682,x			dec 	GNEBegin,x 					; if set then set to -1
.838a		de 83 06	dec $0683,x			dec 	GNEBegin+1,x
.838d						_PMKOBExit:
.838d		e8		inx				inx  								; next button
.838e		e8		inx				inx
.838f		60		rts				rts
.8390						PMKAdjustTotal:
.8390		48		pha				pha 								; save offset A index X
.8391		da		phx				phx
.8392		48		pha				pha 								; point X to the position
.8393		8a		txa				txa
.8394		18		clc				clc
.8395		69 0c		adc #$0c			adc 	#MousePosX-MouseDeltaX
.8397		aa		tax				tax
.8398		68		pla				pla
.8399		20 d3 83	jsr $83d3			jsr 	PMKAddSubtract 				; reuse the addition code.
.839c		fa		plx				plx 								; restore XA
.839d		68		pla				pla
.839e		60		rts				rts
.839f						PMKClipMouseCoord:
.839f		a2 00		ldx #$00			ldx 	#0
.83a1						_PCMCLoop:
.83a1		bd b2 06	lda $06b2,x			lda 	MousePosX+1,x 				; check if -ve
.83a4		10 06		bpl $83ac			bpl 	_PCMCNotNeg
.83a6		9e b1 06	stz $06b1,x			stz 	MousePosX,x 				; if so zero position.
.83a9		9e b2 06	stz $06b2,x			stz 	MousePosX+1,x
.83ac						_PCMCNotNeg:
.83ac		bd b1 06	lda $06b1,x			lda 	MousePosX,x 				; compare pos vs extent
.83af		dd cd 83	cmp $83cd,x			cmp 	_PCMCExtent,x
.83b2		bd b2 06	lda $06b2,x			lda 	MousePosX+1,x
.83b5		fd ce 83	sbc $83ce,x			sbc 	_PCMCExtent+1,x
.83b8		90 0c		bcc $83c6			bcc 	_PCMCNotOver 				; in range ?
.83ba		bd cd 83	lda $83cd,x			lda 	_PCMCExtent,x 				; no, set to X limit.
.83bd		9d b1 06	sta $06b1,x			sta 	MousePosX,x
.83c0		bd ce 83	lda $83ce,x			lda 	_PCMCExtent+1,x
.83c3		9d b2 06	sta $06b2,x			sta 	MousePosX+1,x
.83c6						_PCMCNotOver:
.83c6		e8		inx				inx
.83c7		e8		inx				inx
.83c8		e0 06		cpx #$06			cpx 	#3*2
.83ca		d0 d5		bne $83a1			bne 	_PCMCLoop
.83cc		60		rts				rts
.83cd						_PCMCExtent:
>83cd		3f 01 ef 00 ff 00				.word 	319,239,255
.83d3						PMKAddSubtract:
.83d3		c9 00		cmp #$00			cmp 	#0 							; subtracting ?
.83d5		30 0e		bmi $83e5			bmi 	PMKSubtract
.83d7						PMKAdd:
.83d7		18		clc				clc
.83d8		7d 82 06	adc $0682,x			adc 	GNEBegin,x
.83db		9d 82 06	sta $0682,x			sta 	GNEBegin,x
.83de		90 14		bcc $83f4			bcc 	PMKExit
.83e0		fe 83 06	inc $0683,x			inc 	GNEBegin+1,x
.83e3		80 0f		bra $83f4			bra 	PMKExit
.83e5						PMKSubtract:
.83e5		18		clc				clc
.83e6		7d 82 06	adc $0682,x			adc 	GNEBegin,x
.83e9		9d 82 06	sta $0682,x			sta 	GNEBegin,x
.83ec		bd 83 06	lda $0683,x			lda 	GNEBegin+1,x
.83ef		69 ff		adc #$ff			adc 	#$FF
.83f1		9d 83 06	sta $0683,x			sta 	GNEBegin+1,x
.83f4						PMKExit:
.83f4		e8		inx				inx 								; next slot ?
.83f5		e8		inx				inx
.83f6		60		rts				rts
.83f7						ProcessKeyboardEvent:
.83f7		ad c2 07	lda $07c2			lda 	KNLEvent.key.raw 			; raw key code.
.83fa		20 37 84	jsr $8437			jsr 	KeyboardConvertXA  			; convert to index in X, mask in A
.83fd		ac be 07	ldy $07be			ldy 	KNLEvent.type
.8400		c0 0a		cpy #$0a			cpy 	#kernel.event.key.RELEASED 	; check if pressed/released
.8402		f0 07		beq $840b			beq 	_PKERelease
.8404		1d 83 06	ora $0683,x			ora 	KeyStatus,x 				; set bit
.8407		9d 83 06	sta $0683,x			sta 	KeyStatus,x
.840a		60		rts				rts
.840b						_PKERelease:
.840b		49 ff		eor #$ff			eor 	#$FF						; clear bit
.840d		3d 83 06	and $0683,x			and 	KeyStatus,x
.8410		9d 83 06	sta $0683,x			sta 	KeyStatus,x
.8413		4c 18 82	jmp $8218			jmp     StopRepeat      ; See events.asm.
.8416						UpdateKeyboardJoystick:
.8416		9c a4 06	stz $06a4			stz 	KeyJoystick
.8419		a2 00		ldx #$00			ldx 	#0
.841b						_UKJLoop:
.841b		bd 32 84	lda $8432,x			lda 	_UKJKeys,x 					; which key
.841e		29 1f		and #$1f			and 	#$1F
.8420		a8		tay				tay
.8421		b9 83 06	lda $0683,y			lda 	KeyStatus,y 				; get status
.8424		29 10		and #$10			and 	#$10 						; letters always bit 4 (actually ASCII of L/C)
.8426		18		clc				clc  								; set C if bit set
.8427		69 ff		adc #$ff			adc 	#$FF
.8429		2e a4 06	rol $06a4			rol 	KeyJoystick 				; shift into place
.842c		e8		inx				inx
.842d		e0 05		cpx #$05			cpx 	#5 							; do all 5
.842f		d0 ea		bne $841b			bne 	_UKJLoop
.8431		60		rts				rts
.8432						_UKJKeys:
>8432		4c 58 5a 4d 4b					.byte	'L','X','Z','M','K'
.8437						KeyboardConvertXA:
.8437		a2 01		ldx #$01			ldx 	#1 							; set the mask temp to %00000001
.8439		8e a3 06	stx $06a3			stx 	KeyMaskTemp
.843c						_KCCALoop:
.843c		18		clc				clc
.843d		69 20		adc #$20			adc 	#$20 						; upper 3 bits are the mask, if causes CS A will be in the range 00-1F
.843f		b0 05		bcs $8446			bcs 	_KCCADone
.8441		0e a3 06	asl $06a3			asl 	KeyMaskTemp 				; shift the mask temp
.8444		80 f6		bra $843c			bra 	_KCCALoop
.8446						_KCCADone:
.8446		aa		tax				tax 								; table entry in X
.8447		ad a3 06	lda $06a3			lda 	KeyMaskTemp 				; mask temp in A.
.844a		60		rts				rts
.0682						GNEBegin:
.0682						CMDMouseFlag:
>0682								.fill 	1
.0683						KeyStatus:
>0683								.fill 	32
.06a3						KeyMaskTemp:
>06a3								.fill 	1
.06a4						KeyJoystick:
>06a4								.fill 	1
.06a5						MouseDeltaX:
>06a5								.fill 	2
.06a7						MouseDeltaY:
>06a7								.fill 	2
.06a9						MouseDeltaZ:
>06a9								.fill 	2
.06ab						MouseCountInner:
>06ab								.fill 	2
.06ad						MouseCountMiddle:
>06ad								.fill 	2
.06af						MouseCountOuter:
>06af								.fill 	2
.06b1						MousePosX:
>06b1								.fill 	2
.06b3						MousePosY:
>06b3								.fill 	2
.06b5						MousePosZ:
>06b5								.fill 	2
.06b7						MouseStatusX:
>06b7								.fill 	2
.06b9						MouseStatusY:
>06b9								.fill 	2
.06bb						MouseStatusZ:
>06bb								.fill 	2
.06bd						GNEEnd:

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/ab.system/wrapper.asm

=56						KERR_GENERAL = kernel.event.file.ERROR 		; Event $38
=50						KERR_CLOSED = kernel.event.file.CLOSED 		; Event $32
=40						KERR_NOTFOUND = kernel.event.file.NOT_FOUND ; Event $28
=48						KERR_EOF = kernel.event.file.EOF 			; Event $30
=64						KNLReadBufferLen = 64 								; read buffer size.
.844b						KNLSetDrive:
.844b		8d bd 07	sta $07bd			sta 	KNLDefaultDrive
.844e		60		rts				rts
.844f						KNLOpenFileWrite:
.844f		48		pha				pha
.8450		a9 01		lda #$01			lda 	#kernel.args.file.open.WRITE
.8452		80 03		bra $8457			bra 	KNLOpenStart
.8454						KNLOpenFileRead:
.8454		48		pha				pha
.8455		a9 00		lda #$00			lda     #kernel.args.file.open.READ ; set READ mode.
.8457						KNLOpenStart:
.8457		85 f5		sta $f5				sta     kernel.args.file.open.mode
.8459		68		pla				pla
.845a		5a		phy				phy
.845b		20 9a 84	jsr $849a			jsr 	KNLSetupFileName
.845e		20 8f 84	jsr $848f			jsr 	KNLSetEventPointer
.8461		ad bd 07	lda $07bd			lda 	KNLDefaultDrive 			; currently drive zero only.
.8464		85 f3		sta $f3				sta 	kernel.args.file.open.drive
.8466		20 5c ff	jsr $ff5c			jsr     kernel.File.Open 			; open the file and exit.
.8469		b0 1c		bcs $8487			bcs     _kernel_error
.846b		a8		tay				tay
.846c						_loop
.846c		20 0c ff	jsr $ff0c			jsr     kernel.Yield    			; event wait
.846f		20 09 83	jsr $8309			jsr     GetNextEvent
.8472		b0 f8		bcs $846c			bcs     _loop
.8474		ad be 07	lda $07be			lda 	KNLEvent.type
.8477		c9 2a		cmp #$2a			cmp     #kernel.event.file.OPENED
.8479		f0 10		beq $848b			beq 	_success
.847b		c9 28		cmp #$28			cmp     #kernel.event.file.NOT_FOUND
.847d		f0 0e		beq $848d			beq 	_exit
.847f		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR
.8481		d0 e9		bne $846c			bne 	_loop
.8483		a9 28		lda #$28			lda		#kernel.event.file.NOT_FOUND
.8485		80 06		bra $848d			bra		_exit
.8487						_kernel_error
.8487		a9 38		lda #$38			lda     #kernel.event.file.ERROR
.8489		80 02		bra $848d			bra		_exit
.848b						_success
.848b		98		tya				tya
.848c		18		clc				clc
.848d						_exit
.848d		7a		ply				ply
.848e		60		rts				rts
.848f						KNLSetEventPointer:
.848f		48		pha				pha
.8490		a9 be		lda #$be			lda     #KNLEvent & $FF 			; tell kernel where to store event data
.8492		85 f0		sta $f0				sta     kernel.args.events+0
.8494		a9 07		lda #$07			lda     #KNLEvent >> 8
.8496		85 f1		sta $f1				sta     kernel.args.events+1
.8498		68		pla				pla
.8499		60		rts				rts
.849a						KNLSetupFileName:
.849a		5a		phy				phy 								; save Y on stack
.849b		85 36		sta $36				sta 	zTemp0 						; save filename position in temp, and in kenrel slot
.849d		86 37		stx $37				stx 	zTemp0+1
.849f		85 fb		sta $fb				sta     kernel.args.file.open.fname+0
.84a1		86 fc		stx $fc				stx     kernel.args.file.open.fname+1
.84a3		a0 ff		ldy #$ff			ldy 	#$FF 						; get the filename length => Kernel slot
.84a5						_KNLGetLength:
.84a5		c8		iny				iny
.84a6		b1 36		lda ($36),y			lda 	(zTemp0),y
.84a8		d0 fb		bne $84a5			bne 	_KNLGetLength
.84aa		84 fd		sty $fd				sty 	kernel.args.file.open.fname_len
.84ac		7a		ply				ply
.84ad		60		rts				rts
.84ae						KNLReadBlock:
.84ae		85 f3		sta $f3				sta     kernel.args.file.read.stream
.84b0		86 f4		stx $f4				stx     kernel.args.file.read.buflen
.84b2		20 60 ff	jsr $ff60			jsr     kernel.File.Read 			; read request
.84b5		a9 38		lda #$38			lda     #kernel.event.file.ERROR    ; Kernel out of events/buffers; shouldn't happen
.84b7		b0 2e		bcs $84e7			bcs     _KGNBExitFail               ; report as general error
.84b9						_KGRBEventLoop:
.84b9		20 0c ff	jsr $ff0c			jsr     kernel.Yield    			; event wait
.84bc		20 09 83	jsr $8309			jsr     GetNextEvent
.84bf		b0 f8		bcs $84b9			bcs     _KGRBEventLoop
.84c1		ad be 07	lda $07be			lda 	KNLEvent.type 				; get event
.84c4		c9 2c		cmp #$2c			cmp     #kernel.event.file.DATA 	; data, return data
.84c6		f0 0a		beq $84d2			beq     _KNLRBGetNextByte
.84c8		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR  	; errors on file i/o, return as appropriate.
.84ca		f0 1b		beq $84e7			beq 	_KGNBExitFail
.84cc		c9 30		cmp #$30			cmp     #kernel.event.file.EOF
.84ce		f0 17		beq $84e7			beq 	_KGNBExitFail
.84d0		80 e7		bra $84b9			bra 	_KGRBEventLoop
.84d2						_KNLRBGetNextByte:
.84d2		a9 bd		lda #$bd			lda     #<KNLReadBuffer 			; Set the target buffer
.84d4		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.84d6		a9 06		lda #$06			lda     #>KNLReadBuffer
.84d8		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.84da		ad c4 07	lda $07c4			lda     KNLEvent.file.data.read 	; Set the target length
.84dd		85 fd		sta $fd				sta     kernel.args.recv.buflen
.84df		20 04 ff	jsr $ff04			jsr     kernel.ReadData		       	; Get the data from the kernel  (Synchronous call, no error)
.84e2		ad c4 07	lda $07c4			lda     KNLEvent.file.data.read 	; Return # of bytes read (in A)
.84e5		18		clc				clc
.84e6		60		rts				rts
.84e7						_KGNBExitFail:
.84e7		38		sec				sec
.84e8		60		rts				rts
.84e9						KNLWriteBlock:
.84e9		da		phx				phx
.84ea		5a		phy				phy
.84eb		85 f3		sta $f3				sta     kernel.args.file.write.stream ; save the stream.
.84ed		a5 36		lda $36				lda     zTemp0 						; save the data location.
.84ef		85 fb		sta $fb				sta     kernel.args.file.write.buf+0
.84f1		a5 37		lda $37				lda     zTemp0+1
.84f3		85 fc		sta $fc				sta     kernel.args.file.write.buf+1
.84f5		86 fd		stx $fd				stx     kernel.args.file.write.buflen ; Set the buffer length
.84f7		20 64 ff	jsr $ff64			jsr     kernel.File.Write 			; write it out.
.84fa		a9 38		lda #$38			lda 	#kernel.event.file.ERROR 	; in case it fails.
.84fc		b0 21		bcs $851f			bcs 	_KWBFailed
.84fe						_KNLWLoop:
.84fe		20 0c ff	jsr $ff0c			jsr     kernel.Yield
.8501		20 09 83	jsr $8309			jsr     GetNextEvent
.8504		b0 f8		bcs $84fe			bcs     _KNLWLoop
.8506		ad be 07	lda $07be			lda     KNLEvent.type 				; various errors.
.8509		c9 32		cmp #$32			cmp     #kernel.event.file.CLOSED
.850b		f0 12		beq $851f			beq 	_KWBFailed
.850d		c9 38		cmp #$38			cmp     #kernel.event.file.ERROR
.850f		f0 0e		beq $851f			beq 	_KWBFailed
.8511		c9 30		cmp #$30			cmp     #kernel.event.file.EOF
.8513		f0 0a		beq $851f			beq 	_KWBFailed
.8515		c9 2e		cmp #$2e			cmp     #kernel.event.file.WROTE 	; wait until block write succeeds
.8517		d0 e5		bne $84fe			bne 	_KNLWLoop
.8519		18		clc				clc
.851a		ad c4 07	lda $07c4			lda    KNLEvent.file.wrote.wrote 	; get bytes written.
.851d		80 01		bra $8520			bra 	_KWBExit
.851f						_KWBFailed:
.851f		38		sec				sec
.8520						_KWBExit:
.8520		7a		ply				ply
.8521		fa		plx				plx
.8522		60		rts				rts
.8523						KNLCloseFile:
.8523		85 f3		sta $f3				sta     kernel.args.file.close.stream
.8525		20 68 ff	jsr $ff68			jsr     kernel.File.Close
.8528		60		rts				rts
.8529						KNLReadController:
.8529		da		phx				phx
.852a		a6 01		ldx $01				ldx 	1 							; save current I/O in X
.852c		64 01		stz $01				stz 	1 							; switch to I/O 0
.852e		ad 00 dc	lda $dc00			lda 	$DC00  						; read VIA register
.8531		49 ff		eor #$ff			eor 	#$FF 						; make active '1'
.8533		0d a4 06	ora $06a4			ora 	KeyJoystick 				; use key joystick.
.8536		86 01		stx $01				stx 	1 							; repair old I/O and exit
.8538		fa		plx				plx
.8539		60		rts				rts
.06bd						KNLReadBuffer:
>06bd								.fill   256
.07bd						KNLDefaultDrive:
>07bd								.byte 	?
.07be						KNLEvent
>07be						type        .byte   ?   ; Enum above
>07bf						buf         .byte   ?   ; page id or zero
>07c0						ext         .byte   ?   ; page id or zero
.07c1						key
>07c1						keyboard    .byte   ?   ; Keyboard ID
>07c2						raw         .byte   ?   ; Raw key ID
>07c3						ascii       .byte   ?   ; ASCII value
>07c4						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.07c1						mouse
.07c1						delta
>07c1						x           .byte   ?
>07c2						y           .byte   ?
>07c3						z           .byte   ?
>07c4						buttons     .byte   ?
.07c1						clicks
>07c1						inner       .byte   ?
>07c2						middle      .byte   ?
>07c3						outer       .byte   ?
.07c1						joystick
>07c1						joy0        .byte   ?
>07c2						joy1        .byte   ?
.07c1						udp
>07c1						token       .byte   ?   ; TODO: break out into fields
.07c1						tcp
>07c1						len         .byte   ?   ; Raw packet length.
.07c1						file
>07c1						stream      .byte   ?
>07c2						cookie      .byte   ?
.07c3						data
>07c3						requested   .byte   ?   ; Requested number of bytes to read
>07c4						read        .byte   ?   ; Number of bytes actually read
.07c3						wrote
>07c3						requested   .byte   ?   ; Requested number of bytes to read
>07c4						wrote       .byte   ?   ; Number of bytes actually read
.07c1						directory
>07c1						stream      .byte   ?
>07c2						cookie      .byte   ?
.07c3						volume
>07c3						len         .byte   ?   ; Length of volname (in buf)
>07c4						flags       .byte   ?   ; block size, text encoding
.07c3						file
>07c3						len         .byte   ?
>07c4						flags       .byte   ?   ; block scale, text encoding, approx size
.07c3						free
>07c3						flags       .byte   ?   ; block scale, text encoding, approx size
.07c1						timer
>07c1						value       .byte   ?
>07c2						cookie      .byte   ?
.07c1						irq
>07c1						group       .byte   ?
>07c2						bitval      .byte   ?

;******  Return to file: _basic.asm


;******  Processing file: ./common/api/api.asm

>ff00						NextEvent   .fill   4   ; Copy the next event into user-space.
>ff04						ReadData    .fill   4   ; Copy primary bulk event data into user-space
>ff08						ReadExt     .fill   4   ; Copy secondary bolk event data into user-space
>ff0c						Yield       .fill   4   ; Give unused time to the kernel.
>ff10						Putch       .fill   4   ; deprecated
>ff14						RunBlock    .fill   4   ; Chain to resident program by block ID.
>ff18						RunNamed    .fill   4   ; Chain to resident program by name.
>ff1c						            .fill   4   ; reserved
>ff20						List        .fill   4   ; Returns a bit-set of available block-accessible devices.
>ff24						GetName     .fill   4   ; Gets the hardware level name of the given block device or media.
>ff28						GetSize     .fill   4   ; Get the number of raw sectors (48 bits) for the given device
>ff2c						Read        .fill   4   ; Read a raw sector (48 bit LBA)
>ff30						Write       .fill   4   ; Write a raw sector (48 bit LBA)
>ff34						Format      .fill   4   ; Perform a low-level format if the media support it.
>ff38						Export      .fill   4   ; Update the FileSystem table with the partition table (if present).
>ff3c						List        .fill   4   ; Returns a bit-set of available logical devices.
>ff40						GetSize     .fill   4   ; Get the size of the partition or logical device in sectors.
>ff44						MkFS        .fill   4   ; Creates a new file-system on the logical device.
>ff48						CheckFS     .fill   4   ; Checks the file-system for errors and corrects them.
>ff4c						Mount       .fill   4   ; Mark the file-system as available for File and Directory operations.
>ff50						Unmount     .fill   4   ; Mark the file-system as unavailable for File and Directory operations.
>ff54						ReadBlock   .fill   4   ; Read a partition-local raw sector on an unmounted device.
>ff58						WriteBlock  .fill   4   ; Write a partition-local raw sector on an unmounted device.
>ff5c						Open        .fill   4   ; Open the given file for read, create, or append.
>ff60						Read        .fill   4   ; Request bytes from a file opened for reading.
>ff64						Write       .fill   4   ; Write bytes to a file opened for create or append.
>ff68						Close       .fill   4   ; Close an open file.
>ff6c						Rename      .fill   4   ; Rename a closed file.
>ff70						Delete      .fill   4   ; Delete a closed file.
>ff74						Seek        .fill   4   ; Seek to a specific position in a file.
>ff78						Open        .fill   4   ; Open a directory for reading.
>ff7c						Read        .fill   4   ; Read a directory entry; may also return VOLUME and FREE events.
>ff80						Close       .fill   4   ; Close a directory once finished reading.
>ff84						MkDir       .fill   4   ; Create a directory
>ff88						RmDir       .fill   4   ; Delete a directory
>ff8c						            .fill   4   ; call gate
>ff90						GetIP       .fill   4   ; Get the local IP address.
>ff94						SetIP       .fill   4   ; Set the local IP address.
>ff98						GetDNS      .fill   4   ; Get the configured DNS IP address.
>ff9c						SetDNS      .fill   4   ; Set the configured DNS IP address.
>ffa0						SendICMP    .fill   4
>ffa4						Match       .fill   4
>ffa8						Init        .fill   4
>ffac						Send        .fill   4
>ffb0						Recv        .fill   4
>ffb4						Open        .fill   4
>ffb8						Accept      .fill   4
>ffbc						Reject      .fill   4
>ffc0						Send        .fill   4
>ffc4						Recv        .fill   4
>ffc8						Close       .fill   4
>ffcc						Reset       .fill   4   ; Re-init the display
>ffd0						GetSize     .fill   4   ; Returns rows/cols in kernel args.
>ffd4						DrawRow     .fill   4   ; Draw text/color buffers left-to-right
>ffd8						DrawColumn  .fill   4   ; Draw text/color buffers top-to-bottom
>ffdc						GetTime     .fill   4
>ffe0						SetTime     .fill   4
>ffe4						            .fill   12  ; 65816 vectors
>fff0						SetTimer    .fill   4
.00f0						args
.00f0						events
>00f0						dest        .word       ?   ; GetNextEvent copies event data here
>00f2						pending     .byte       ?   ; Negative count of pending events
.00f3						end
.00f3						run
>00f3						block_id    .byte   ?
.00f3						recv
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.00f3						fs
.00f3						format
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.00f3						mkfs
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.00f3						file
.00f3						open
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>00f5						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.00f3						read
>00f3						stream      .byte       ?
>00f4						buflen      .byte       ?
.00f3						write
>00f3						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.00f3						seek
>00f3						stream      .byte       ?
>00f4						position    .dword      ?
.00f3						close
>00f3						stream      .byte       ?
.00f3						rename
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.00f3						delete
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>00f5						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.00f3						directory
.00f3						open
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.00f3						read
>00f3						stream      .byte       ?
>00f4						buflen      .byte       ?
.00f3						close
>00f3						stream      .byte       ?
.00f3						mkdir
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.00f3						rmdir
>00f3						drive       .byte       ?
>00f4						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.00f3						display
>00f3						x           .byte       ?   ; coordinate or size
>00f4						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
.00f3						net
=$fb						socket      = args.buf
>00f3						src_port    .word       ?
>00f5						dest_port   .word       ?
>00f7						dest_ip     .fill       4
>00f3						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
.00f3						config
.00f3						timer
>00f3						units       .byte       ?
=0						FRAMES      = 0
=1						SECONDS     = 1
=128						QUERY       = 128
>00f4						absolute    .byte       ?
>00f5						cookie      .byte       ?
=$f8						ext         = $f8
=$fa						extlen      = $fa
=$fb						buf         = $fb
=$fd						buflen      = $fd
=$fe						ptr         = $fe
.0000						events
>0000						dest        .word       ?   ; GetNextEvent copies event data here
>0002						pending     .byte       ?   ; Negative count of pending events
.0003						end
.0003						run
>0003						block_id    .byte   ?
.0003						recv
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0003						fs
.0003						format
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0003						mkfs
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0003						file
.0003						open
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0005						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0003						read
>0003						stream      .byte       ?
>0004						buflen      .byte       ?
.0003						write
>0003						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0003						seek
>0003						stream      .byte       ?
>0004						position    .dword      ?
.0003						close
>0003						stream      .byte       ?
.0003						rename
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.0003						delete
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0005						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0003						directory
.0003						open
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0003						read
>0003						stream      .byte       ?
>0004						buflen      .byte       ?
.0003						close
>0003						stream      .byte       ?
.0003						mkdir
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0003						rmdir
>0003						drive       .byte       ?
>0004						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0003						display
>0003						x           .byte       ?   ; coordinate or size
>0004						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
.0003						net
=$fb						socket      = args.buf
>0003						src_port    .word       ?
>0005						dest_port   .word       ?
>0007						dest_ip     .fill       4
>0003						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
.0003						config
.0003						timer
>0003						units       .byte       ?
=0						FRAMES      = 0
=1						SECONDS     = 1
=128						QUERY       = 128
>0004						absolute    .byte       ?
>0005						cookie      .byte       ?
=$f8						ext         = $f8
=$fa						extlen      = $fa
=$fb						buf         = $fb
=$fd						buflen      = $fd
=$fe						ptr         = $fe
>0000						dest        .word       ?   ; GetNextEvent copies event data here
>0002						pending     .byte       ?   ; Negative count of pending events
.0003						end
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
>0000						block_id    .byte   ?
.0000						format
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0000						mkfs
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						label       = args.buf
=$fd						label_len   = args.buflen
.0000						open
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
.0000						read
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						write
>0000						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
.0000						seek
>0000						stream      .byte       ?
>0001						position    .dword      ?
.0000						close
>0000						stream      .byte       ?
.0000						rename
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
.0000						delete
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fname       = args.buf
=$fd						fname_len   = args.buflen
>0002						mode        .byte       ?
=0						READ        = 0
=1						WRITE       = 1
=2						END         = 2
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
>0000						stream      .byte       ?
=$fb						buf         = args.buf
=$fd						buflen      = args.buflen
>0000						stream      .byte       ?
>0001						position    .dword      ?
>0000						stream      .byte       ?
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						old         = args.buf
=$fd						old_len     = args.buflen
=$f8						new         = args.ext
=$fa						new_len     = args.extlen
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						fnane       = args.buf
=$fd						fname_len   = args.buflen
.0000						open
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0000						read
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
.0000						close
>0000						stream      .byte       ?
.0000						mkdir
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
.0000						rmdir
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
>0000						drive       .byte       ?
>0001						cookie      .byte       ?
=$fb						path        = args.buf
=$fd						path_len    = args.buflen
>0000						stream      .byte       ?
>0001						buflen      .byte       ?
>0000						stream      .byte       ?
>0000						x           .byte       ?   ; coordinate or size
>0001						y           .byte       ?   ; coordinate or size
=$fb						text        = args.buf      ; text
=$f8						color       = args.ext      ; color
=$fb						buf         = args.buf      ; deprecated
=$f8						buf2        = args.ext      ; deprecated
=$fd						buflen      = args.buflen
=$fb						socket      = args.buf
>0000						src_port    .word       ?
>0002						dest_port   .word       ?
>0004						dest_ip     .fill       4
>0000						accepted    .byte       ?
=$f8						buf         = args.ext
=$fa						buflen      = args.extlen
>0000						units       .byte       ?
=0						FRAMES      = 0
=1						SECONDS     = 1
=128						QUERY       = 128
>0001						absolute    .byte       ?
>0002						cookie      .byte       ?
>0000						century     .byte       ?
>0001						year        .byte       ?
>0002						month       .byte       ?
>0003						day         .byte       ?
>0004						hours       .byte       ?
>0005						minutes     .byte       ?
>0006						seconds     .byte       ?
>0007						centis      .byte       ?
.0008						size
>0000						            .word   ?   ; Reserved
>0002						            .word   ?   ; Deprecated
>0004						JOYSTICK    .word   ?   ; Game Controller changes.
>0006						DEVICE      .word   ?   ; Device added/removed.
>0008						PRESSED     .word   ?   ; Key pressed
>000a						RELEASED    .word   ?   ; Key released.
>000c						DELTA       .word   ?   ; Regular mouse move and button state
>000e						CLICKS      .word   ?   ; Click counts
>0010						NAME        .word   ?
>0012						SIZE        .word   ?
>0014						DATA        .word   ?   ; The read request has succeeded.
>0016						WROTE       .word   ?   ; The write request has completed.
>0018						FORMATTED   .word   ?   ; The low-level format has completed.
>001a						ERROR       .word   ?
>001c						SIZE        .word   ?
>001e						CREATED     .word   ?
>0020						CHECKED     .word   ?
>0022						DATA        .word   ?   ; The read request has succeeded.
>0024						WROTE       .word   ?   ; The write request has completed.
>0026						ERROR       .word   ?
>0028						NOT_FOUND   .word   ?   ; The file file was not found.
>002a						OPENED      .word   ?   ; The file was successfully opened.
>002c						DATA        .word   ?   ; The read request has succeeded.
>002e						WROTE       .word   ?   ; The write request has completed.
>0030						EOF         .word   ?   ; All file data has been read.
>0032						CLOSED      .word   ?   ; The close request has completed.
>0034						RENAMED     .word   ?   ; The rename request has completed.
>0036						DELETED     .word   ?   ; The delete request has completed.
>0038						ERROR       .word   ?   ; An error occured; close the file if opened.
>003a						SEEK        .word   ?   ; The seek request has completed.
>003c						OPENED      .word   ?   ; The directory open request succeeded.
>003e						VOLUME      .word   ?   ; A volume record was found.
>0040						FILE        .word   ?   ; A file record was found.
>0042						FREE        .word   ?   ; A file-system free-space record was found.
>0044						EOF         .word   ?   ; All data has been read.
>0046						CLOSED      .word   ?   ; The directory file has been closed.
>0048						ERROR       .word   ?   ; An error occured; user should close.
>004a						CREATED     .word   ?   ; The directory has been created.
>004c						DELETED     .word   ?   ; The directory has been deleted.
>004e						TCP         .word   ?
>0050						UDP         .word   ?
>0052						EXPIRED     .word   ?
>0054						TICK        .word   ?
>0056						IRQ         .word   ?
>0000						type        .byte   ?   ; Enum above
>0001						buf         .byte   ?   ; page id or zero
>0002						ext         .byte   ?   ; page id or zero
.0003						key
>0003						keyboard    .byte   ?   ; Keyboard ID
>0004						raw         .byte   ?   ; Raw key ID
>0005						ascii       .byte   ?   ; ASCII value
>0006						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.0003						mouse
.0003						delta
>0003						x           .byte   ?
>0004						y           .byte   ?
>0005						z           .byte   ?
>0006						buttons     .byte   ?
.0003						clicks
>0003						inner       .byte   ?
>0004						middle      .byte   ?
>0005						outer       .byte   ?
.0003						joystick
>0003						joy0        .byte   ?
>0004						joy1        .byte   ?
.0003						udp
>0003						token       .byte   ?   ; TODO: break out into fields
.0003						tcp
>0003						len         .byte   ?   ; Raw packet length.
.0003						file
>0003						stream      .byte   ?
>0004						cookie      .byte   ?
.0005						data
>0005						requested   .byte   ?   ; Requested number of bytes to read
>0006						read        .byte   ?   ; Number of bytes actually read
.0005						wrote
>0005						requested   .byte   ?   ; Requested number of bytes to read
>0006						wrote       .byte   ?   ; Number of bytes actually read
.0003						directory
>0003						stream      .byte   ?
>0004						cookie      .byte   ?
.0005						volume
>0005						len         .byte   ?   ; Length of volname (in buf)
>0006						flags       .byte   ?   ; block size, text encoding
.0005						file
>0005						len         .byte   ?
>0006						flags       .byte   ?   ; block scale, text encoding, approx size
.0005						free
>0005						flags       .byte   ?   ; block scale, text encoding, approx size
.0003						timer
>0003						value       .byte   ?
>0004						cookie      .byte   ?
.0003						irq
>0003						group       .byte   ?
>0004						bitval      .byte   ?
>0000						keyboard    .byte   ?   ; Keyboard ID
>0001						raw         .byte   ?   ; Raw key ID
>0002						ascii       .byte   ?   ; ASCII value
>0003						flags       .byte   ?   ; Flags (META)
=$80						META        = $80       ; Meta key; no associated ASCII value.
.0000						delta
>0000						x           .byte   ?
>0001						y           .byte   ?
>0002						z           .byte   ?
>0003						buttons     .byte   ?
.0000						clicks
>0000						inner       .byte   ?
>0001						middle      .byte   ?
>0002						outer       .byte   ?
>0000						x           .byte   ?
>0001						y           .byte   ?
>0002						z           .byte   ?
>0003						buttons     .byte   ?
>0000						inner       .byte   ?
>0001						middle      .byte   ?
>0002						outer       .byte   ?
>0000						joy0        .byte   ?
>0001						joy1        .byte   ?
>0000						stream      .byte   ?
>0001						cookie      .byte   ?
.0002						data
>0002						requested   .byte   ?   ; Requested number of bytes to read
>0003						read        .byte   ?   ; Number of bytes actually read
.0002						wrote
>0002						requested   .byte   ?   ; Requested number of bytes to read
>0003						wrote       .byte   ?   ; Number of bytes actually read
>0000						requested   .byte   ?   ; Requested number of bytes to read
>0001						read        .byte   ?   ; Number of bytes actually read
>0000						requested   .byte   ?   ; Requested number of bytes to read
>0001						wrote       .byte   ?   ; Number of bytes actually read
>0000						stream      .byte   ?
>0001						cookie      .byte   ?
.0002						volume
>0002						len         .byte   ?   ; Length of volname (in buf)
>0003						flags       .byte   ?   ; block size, text encoding
.0002						file
>0002						len         .byte   ?
>0003						flags       .byte   ?   ; block scale, text encoding, approx size
.0002						free
>0002						flags       .byte   ?   ; block scale, text encoding, approx size
>0000						len         .byte   ?   ; Length of volname (in buf)
>0001						flags       .byte   ?   ; block size, text encoding
>0000						len         .byte   ?
>0001						flags       .byte   ?   ; block scale, text encoding, approx size
>0000						flags       .byte   ?   ; block scale, text encoding, approx size
>0000						free        .fill   6   ; blocks used/free
>0000						token       .byte   ?   ; TODO: break out into fields
>0000						len         .byte   ?   ; Raw packet length.
>0000						value       .byte   ?
>0001						cookie      .byte   ?
>0000						group       .byte   ?
>0001						bitval      .byte   ?

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/assembler.asm

.853a						AssembleGroup1:
.853a		a9 ff		lda #$ff			lda 	#$FF 						; flag for group 1 / mask.
.853c		8d 41 04	sta $0441			sta 	ModeMask 					; initialise the mode mask - all for all
.853f		80 02		bra $8543			bra 	AsmGroup12
.8541						AssembleGroup2:
.8541		a9 00		lda #$00			lda 	#$00 						; flag for group 2
.8543						AsmGroup12:
.8543		8d 3f 04	sta $043f			sta 	IsGroup1 					; save the 'group 1' flag
.8546		68		pla				pla 								; pop the return address to access the information following.
.8547		fa		plx				plx
.8548		20 cf 85	jsr $85cf			jsr 	AccessParameters 			; get opcode and save as base
.854b		8d 40 04	sta $0440			sta 	BaseOpcode
.854e		ad 3f 04	lda $043f			lda 	IsGroup1 					; skip if group 1 as we don't have a complex mask.
.8551		d0 08		bne $855b			bne 	_AG12HaveMask
.8553		a9 02		lda #$02			lda 	#2 							; if group 2 the second parameter is the mask
.8555		20 d7 85	jsr $85d7			jsr 	GetParameter		 		; e.g. which modes are supported for this operand
.8558		8d 41 04	sta $0441			sta 	ModeMask
.855b						_AG12HaveMask:
.855b		20 0b 87	jsr $870b			jsr 	TypeAndCalculateOperand 	; get zero page type
.855e		da		phx				phx 								; save found address mode
.855f		20 3b 86	jsr $863b			jsr 	AssembleModeX
.8562		fa		plx				plx  								; restore address mode
.8563		b0 0b		bcs $8570			bcs 	_AG12Exit
.8565		20 71 85	jsr $8571			jsr 	PromoteToAbsolute  			; promote ZP to ABS and try that
.8568		20 3b 86	jsr $863b			jsr 	AssembleModeX
.856b		b0 03		bcs $8570			bcs 	_AG12Exit
.856d		4c 08 a6	jmp $a608			jmp 	SyntaxError 				; can't do either, so must be wrong mode/operand.
.8570						_AG12Exit:
.8570		60		rts				rts
.8571						PromoteToAbsolute:
.8571		a9 6c		lda #$6c			lda 	#AM_ABS 					; lda xx
.8573		e0 e4		cpx #$e4			cpx 	#AM_ZEROPAGE
.8575		f0 19		beq $8590			beq 	_PTADo
.8577		a9 7c		lda #$7c			lda 	#AM_ABSX 					; lda xx,X
.8579		e0 f4		cpx #$f4			cpx 	#AM_ZEROX
.857b		f0 13		beq $8590			beq 	_PTADo
.857d		a9 78		lda #$78			lda 	#AM_ABSY 					; lda xx,Y
.857f		e0 80		cpx #$80			cpx 	#AM_ZEROY
.8581		f0 0d		beq $8590			beq 	_PTADo
.8583		a9 01		lda #$01			lda 	#AM_INDABS 					; lda (xx) (jump)
.8585		e0 d1		cpx #$d1			cpx 	#AM_IND
.8587		f0 07		beq $8590			beq 	_PTADo
.8589		a9 02		lda #$02			lda 	#AM_INDABSX 				; lda (xx,x) (jump)
.858b		e0 c0		cpx #$c0			cpx 	#AM_INDX
.858d		f0 01		beq $8590			beq 	_PTADo
.858f		60		rts				rts
.8590						_PTADo:
.8590		aa		tax				tax
.8591		60		rts				rts
.8592						AssembleGroup3:
.8592		68		pla				pla 								; get parameters, which is just the opcode.
.8593		fa		plx				plx
.8594		20 cf 85	jsr $85cf			jsr 	AccessParameters 			; get and output opcode
.8597		20 e7 85	jsr $85e7			jsr 	AssemblerWriteByte
.859a		20 6f 87	jsr $876f			jsr 	CalculateOperand 			; get a 16 bit operand
.859d		a5 60		lda $60				lda 	NSMantissa0 				; calculate the offset
.859f		38		sec				sec
.85a0		ed 3a 04	sbc $043a			sbc 	AssemblerAddress
.85a3		48		pha				pha 								; LSB in A
.85a4		a5 70		lda $70				lda 	NSMantissa1
.85a6		ed 3b 04	sbc $043b			sbc 	AssemblerAddress+1
.85a9		aa		tax				tax 								; MSB in X
.85aa		68		pla				pla
.85ab		18		clc				clc 								; $80 to easy check $80-$7F, plus 1 for offset error
.85ac		69 7f		adc #$7f			adc 	#$7F
.85ae		90 01		bcc $85b1			bcc 	_AG3NoCarry
.85b0		e8		inx				inx
.85b1						_AG3NoCarry:
.85b1		38		sec				sec 								; fix back and write out anyways.
.85b2		e9 80		sbc #$80			sbc 	#$80
.85b4		20 e7 85	jsr $85e7			jsr 	AssemblerWriteByte
.85b7		e0 00		cpx #$00			cpx 	#0 							; was it in range
.85b9		f0 0a		beq $85c5			beq 	_AG3Exit
.85bb		ad 3c 04	lda $043c			lda 	AssemblerControl 			; are we allowing bad values ?
.85be		29 01		and #$01			and 	#1
.85c0		f0 03		beq $85c5			beq 	_AG3Exit
.85c2		4c 0d a6	jmp $a60d			jmp 	RangeError 					; no, branch is out of range
.85c5						_AG3Exit:
.85c5		60		rts				rts
.85c6						AssembleGroup4:
.85c6		68		pla				pla 								; pop address
.85c7		fa		plx				plx
.85c8		20 cf 85	jsr $85cf			jsr 	AccessParameters 			; access and get first
.85cb		20 e7 85	jsr $85e7			jsr 	AssemblerWriteByte 			; output it.
.85ce		60		rts				rts
.85cf						AccessParameters:
.85cf		8d 3d 04	sta $043d			sta 	ParamStart
.85d2		8e 3e 04	stx $043e			stx 	ParamStart+1
.85d5		a9 01		lda #$01			lda 	#1
.85d7						GetParameter:
.85d7		5a		phy				phy
.85d8		a8		tay				tay
.85d9		ad 3d 04	lda $043d			lda 	ParamStart
.85dc		85 36		sta $36				sta 	zTemp0
.85de		ad 3e 04	lda $043e			lda 	ParamStart+1
.85e1		85 37		sta $37				sta 	zTemp0+1
.85e3		b1 36		lda ($36),y			lda 	(zTemp0),y
.85e5		7a		ply				ply
.85e6		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/aswrite.asm

.85e7						AssemblerWriteByte:
.85e7		48		pha			pha
.85e8		ad 3c 04	lda $043c		lda 	AssemblerControl 				; check printing bytes ?
.85eb		29 02		and #$02		and 	#2
.85ed		f0 1b		beq $860a		beq 	_AWBNoPrint
.85ef		ad 3b 04	lda $043b		lda		AssemblerAddress+1 				; print address
.85f2		20 25 86	jsr $8625		jsr 	PrintHex
.85f5		ad 3a 04	lda $043a		lda		AssemblerAddress
.85f8		20 25 86	jsr $8625		jsr 	PrintHex
.85fb		a9 20		lda #$20		lda 	#' '
.85fd		20 4d 80	jsr $804d		jsr 	EXTPrintCharacter
.8600		68		pla			pla 									; print byte
.8601		48		pha			pha
.8602		20 25 86	jsr $8625		jsr 	PrintHex
.8605		a9 0d		lda #$0d		lda 	#13
.8607		20 4d 80	jsr $804d		jsr 	EXTPrintCharacter
.860a						_AWBNoPrint:
.860a		ad 3a 04	lda $043a		lda		AssemblerAddress				; copy address to zTemp0
.860d		85 36		sta $36			sta 	zTemp0
.860f		ad 3b 04	lda $043b		lda		AssemblerAddress+1
.8612		f0 0e		beq $8622		beq 	_AWBRange
.8614		85 37		sta $37			sta 	zTemp0+1
.8616		68		pla			pla 									; write byte out
.8617		92 36		sta ($36)		sta 	(zTemp0)
.8619		ee 3a 04	inc $043a		inc 	AssemblerAddress 				; bump address
.861c		d0 03		bne $8621		bne 	_AWBNoCarry
.861e		ee 3b 04	inc $043b		inc 	AssemblerAddress+1
.8621						_AWBNoCarry:
.8621		60		rts			rts
.8622						_AWBRange:
.8622		4c 0d a6	jmp $a60d		jmp 	RangeError
.8625						PrintHex:
.8625		48		pha				pha
.8626		4a		lsr a				lsr 	a
.8627		4a		lsr a				lsr 	a
.8628		4a		lsr a				lsr 	a
.8629		4a		lsr a				lsr 	a
.862a		20 2e 86	jsr $862e			jsr 	_PrintNibble
.862d		68		pla				pla
.862e						_PrintNibble:
.862e		29 0f		and #$0f			and 	#15
.8630		c9 0a		cmp #$0a			cmp 	#10
.8632		90 02		bcc $8636			bcc 	_NoShift
.8634		69 06		adc #$06			adc 	#6
.8636						_NoShift:
.8636		69 30		adc #$30			adc 	#48
.8638		4c 4d 80	jmp $804d			jmp 	EXTPrintCharacter

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/instruction.asm

.863b						AssembleModeX:
.863b		5a		phy				phy
.863c		ad 3f 04	lda $043f			lda 	IsGroup1
.863f		f0 17		beq $8658			beq 	_AMXGroup2
.8641		8a		txa				txa 							; is it in group # 1
.8642		29 40		and #$40			and 	#AM_ISG1
.8644		f0 4d		beq $8693			beq 	_AMXFail 				; no, give up.
.8646		8a		txa				txa 							; get back.
.8647		29 1f		and #$1f			and 	#$1F 					; this is now the offset.
.8649		e0 e0		cpx #$e0			cpx 	#AM_IMMEDIATE 			; if not immediate, we can continue.
.864b		d0 22		bne $866f			bne 	_AMXHaveInfo
.864d		ad 40 04	lda $0440			lda 	BaseOpcode 				; cannot store immediate.
.8650		c9 81		cmp #$81			cmp 	#$81
.8652		f0 3f		beq $8693			beq 	_AMXFail
.8654		a9 08		lda #$08			lda 	#8 						; if immediate we use offset 8.
.8656		80 17		bra $866f			bra 	_AMXHaveInfo 			; odd design decision there.
.8658						_AMXGroup2:
.8658		8a		txa				txa 							; is it in group 2 ?
.8659		29 20		and #$20			and 	#AM_ISG2
.865b		f0 36		beq $8693			beq 	_AMXFail 				; no, give up.
.865d		8a		txa				txa 							; get the offset into Y
.865e		29 1f		and #$1f			and 	#$1F
.8660		4a		lsr a				lsr 	a 						; make it 0-7.
.8661		4a		lsr a				lsr  	a
.8662		a8		tay				tay
.8663		ad 41 04	lda $0441			lda 	ModeMask 				; shift the modemask left so you can check it against the requested offset
.8666						_AMXCheckOkay:
.8666		0a		asl a				asl 	a 						; shift modemask left enough times to check legitimate.
.8667		88		dey				dey
.8668		10 fc		bpl $8666			bpl 	_AMXCheckOkay
.866a		90 27		bcc $8693			bcc 	_AMXFail 				; not allowed.
.866c		8a		txa				txa  							; get mask back
.866d		29 1f		and #$1f			and 	#$1F
.866f						_AMXHaveInfo:
.866f		e0 00		cpx #$00			cpx 	#$00 					; does it *require* an 8 bit operand
.8671		10 04		bpl $8677			bpl 	_AMXAnySize 			; checking bit 7, the zero page opcode flag.
.8673		a4 70		ldy $70				ldy 	NSMantissa1 			; fail if it is outside range, e.g. the MSB is set.
.8675		d0 1c		bne $8693			bne 	_AMXFail
.8677						_AMXAnySize:
.8677		18		clc				clc 							; add offset to the base opcode
.8678		6d 40 04	adc $0440			adc 	BaseOpcode
.867b						_AMXOutputCode:
.867b		20 e7 85	jsr $85e7			jsr 	AssemblerWriteByte 		; write the opcode out.
.867e		e0 28		cpx #$28			cpx 	#AM_ACC 				; A mode (e.g. ASL)
.8680		f0 0e		beq $8690			beq 	_AMXExit
.8682		a5 60		lda $60				lda 	NSMantissa0 			; write LSB operand
.8684		20 e7 85	jsr $85e7			jsr 	AssemblerWriteByte
.8687		e0 00		cpx #$00			cpx 	#$00 					; zeropage ?
.8689		30 05		bmi $8690			bmi 	_AMXExit
.868b		a5 70		lda $70				lda 	NSMantissa1 			; write MSB operand
.868d		20 e7 85	jsr $85e7			jsr 	AssemblerWriteByte
.8690						_AMXExit:
.8690		7a		ply				ply
.8691		38		sec				sec
.8692		60		rts				rts
.8693						_AMXFail:
.8693		a0 00		ldy #$00			ldy 	#0
.8695						_AMXCheckOddities:
.8695		8a		txa				txa
.8696		d9 bd 86	cmp $86bd,y			cmp 	ExtraOpcode+2,y 		; match address mode
.8699		d0 15		bne $86b0			bne 	_AMXCONext
.869b		b9 bb 86	lda $86bb,y			lda 	ExtraOpcode+0,y 		; do the base opcodes match
.869e		cd 40 04	cmp $0440			cmp 	BaseOpcode
.86a1		d0 0d		bne $86b0			bne 	_AMXCONext
.86a3		e0 00		cpx #$00			cpx 	#$00 					; requires zero page ?
.86a5		10 04		bpl $86ab			bpl 	_AMXCONotZero
.86a7		a5 70		lda $70				lda 	NSMantissa1
.86a9		d0 05		bne $86b0			bne 	_AMXCONext
.86ab						_AMXCONotZero:
.86ab		b9 bc 86	lda $86bc,y			lda 	ExtraOpcode+1,y 		; get new opcode
.86ae		80 cb		bra $867b			bra 	_AMXOutputCode 			; and assemble it
.86b0						_AMXCONext:
.86b0		c8		iny				iny
.86b1		c8		iny				iny
.86b2		c8		iny				iny
.86b3		b9 bb 86	lda $86bb,y			lda 	ExtraOpcode+0,y 		; end of table
.86b6		d0 dd		bne $8695			bne 	_AMXCheckOddities
.86b8						_AMXCOFail:
.86b8		7a		ply				ply
.86b9		18		clc				clc
.86ba		60		rts				rts
.86bb						ExtraOpcode:
>86bb		40 6c 01					.byte $40,$6c,AM_INDABS 	; jump
>86be		40 7c 02					.byte $40,$7C,AM_INDABSX 	; jump
>86c1		a2 be 78					.byte $a2,$BE,AM_ABSY 		; ldx
>86c4		a2 b6 80					.byte $a2,$B6,AM_ZEROY 		; ldx
>86c7		82 96 80					.byte $82,$96,AM_ZEROY 		; stx
>86ca		e2 1a 28					.byte $e2,$1a,AM_ACC 		; inc
>86cd		c2 3a 28					.byte $c2,$3a,AM_ACC 		; dec
>86d0		20 89 e0					.byte $20,$89,AM_IMMEDIATE 	; bit
>86d3		60 9c 6c					.byte $60,$9c,AM_ABS 		; stz
>86d6		60 9e 7c					.byte $60,$9e,AM_ABSX 		; stz
>86d9		00						.byte $00

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/label.asm

.86da						LabelHere:
.86da		c8		iny				iny 								; skip .
.86db		a2 00		ldx #$00			ldx 	#0 							; get a term
.86dd		20 84 9e	jsr $9e84			jsr 	EvaluateTerm
.86e0		a5 50		lda $50				lda 	NSStatus 					; needs to be an integer reference.
.86e2		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.86e4		d0 22		bne $8708			bne 	_ALType 					; otherwise typing error
.86e6		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy reference address to zTemp0
.86e8		85 36		sta $36				sta 	zTemp0 						; (e.g. where we store the address)
.86ea		b5 70		lda $70,x			lda 	NSMantissa1,x
.86ec		85 37		sta $37				sta 	zTemp0+1
.86ee		5a		phy				phy 								; copy address in (64k)
.86ef		a0 01		ldy #$01			ldy 	#1
.86f1		ad 3a 04	lda $043a			lda	 	AssemblerAddress
.86f4		92 36		sta ($36)			sta 	(zTemp0)
.86f6		ad 3b 04	lda $043b			lda	 	AssemblerAddress+1
.86f9		91 36		sta ($36),y			sta 	(zTemp0),y
.86fb		c8		iny				iny
.86fc		a9 00		lda #$00			lda 	#0 							; zero the rest.
.86fe		91 36		sta ($36),y			sta 	(zTemp0),y
.8700		c8		iny				iny
.8701		91 36		sta ($36),y			sta 	(zTemp0),y
.8703		c8		iny				iny
.8704		91 36		sta ($36),y			sta 	(zTemp0),y
.8706		7a		ply				ply
.8707		60		rts				rts
.8708						_ALType:
.8708		4c 12 a6	jmp $a612			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/assembler/operands.asm

.870b						TypeAndCalculateOperand:
.870b		b1 30		lda ($30),y			lda 	(codePtr),y
.870d		a2 28		ldx #$28			ldx 	#AM_ACC 					; ACC if : or EOL
.870f		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8711		f0 5b		beq $876e			beq 	_TACOExit
.8713		c9 80		cmp #$80			cmp 	#KWC_EOL
.8715		f0 57		beq $876e			beq 	_TACOExit
.8717		c8		iny				iny
.8718		a2 e0		ldx #$e0			ldx 	#AM_IMMEDIATE
.871a		c9 23		cmp #$23			cmp 	#KWD_HASH 					; if hash, then immediate - constant.
.871c		f0 51		beq $876f			beq 	CalculateOperand
.871e		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; if ( then check for indirection
.8720		f0 1f		beq $8741			beq 	_TACOIndirect
.8722		88		dey				dey 								; undo get of first character
.8723		20 6f 87	jsr $876f			jsr 	CalculateOperand 			; get operand
.8726		b1 30		lda ($30),y			lda 	(codePtr),y
.8728		a2 e4		ldx #$e4			ldx 	#AM_ZEROPAGE 				; if not, try zero page (then absolute)
.872a		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.872c		d0 40		bne $876e			bne 	_TACOExit
.872e		c8		iny				iny
.872f		20 79 87	jsr $8779			jsr 	TACOCheckXY 				; extract X,Y or 0 (neither) from the variable.
.8732		a2 f4		ldx #$f4			ldx 	#AM_ZEROX 					; check for X
.8734		c9 58		cmp #$58			cmp 	#'X'
.8736		f0 36		beq $876e			beq 	_TACOExit
.8738		a2 80		ldx #$80			ldx 	#AM_ZEROY 					; check for Y
.873a		c9 59		cmp #$59			cmp 	#'Y'
.873c		f0 30		beq $876e			beq 	_TACOExit
.873e						_TACOSyntax:
.873e		4c 08 a6	jmp $a608			jmp 	SyntaxError
.8741						_TACOIndirect:
.8741		20 6f 87	jsr $876f			jsr 	CalculateOperand 			; get the operand
.8744		b1 30		lda ($30),y			lda 	(codePtr),y
.8746		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if , then it must be ,X)
.8748		f0 17		beq $8761			beq 	_TACOIndX
.874a		20 0e 95	jsr $950e			jsr 	CheckRightBracket  			; otherwise must be ) or ),Y
.874d		b1 30		lda ($30),y			lda 	(codePtr),y
.874f		a2 d1		ldx #$d1			ldx 	#AM_IND
.8751		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not comma then exit with (xx)
.8753		d0 19		bne $876e			bne 	_TACOExit
.8755		c8		iny				iny
.8756		20 79 87	jsr $8779			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8759		c9 59		cmp #$59			cmp 	#'Y' 						; check Y
.875b		d0 e1		bne $873e			bne 	_TACOSyntax
.875d		a2 d0		ldx #$d0			ldx 	#AM_INDY
.875f		80 0d		bra $876e			bra 	_TACOExit
.8761						_TACOIndX:
.8761		c8		iny				iny
.8762		20 79 87	jsr $8779			jsr 	TACOCheckXY 				; get the next one as X/Y/0
.8765		c9 58		cmp #$58			cmp 	#'X' 						; check X
.8767		d0 d5		bne $873e			bne 	_TACOSyntax
.8769		20 0e 95	jsr $950e			jsr 	CheckRightBracket			; check )
.876c		a2 c0		ldx #$c0			ldx 	#AM_INDX
.876e						_TACOExit:
.876e		60		rts				rts
.876f						CalculateOperand:
.876f		48		pha				pha
.8770		da		phx				phx
.8771		a2 00		ldx #$00			ldx 	#0 							; get 16 bit integer in Slot 0
.8773		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger
.8776		fa		plx				plx
.8777		68		pla				pla
.8778		60		rts				rts
.8779						TACOCheckXY:
.8779		b1 30		lda ($30),y			lda 	(codePtr),y
.877b		29 c0		and #$c0			and 	#$C0 						; check it is an identifier reference.
.877d		c9 40		cmp #$40			cmp 	#$40
.877f		d0 21		bne $87a2			bne 	_TCXYFail
.8781		b1 30		lda ($30),y			lda 	(codePtr),y
.8783		18		clc				clc
.8784		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.8786		85 37		sta $37				sta 	zTemp0+1
.8788		c8		iny				iny
.8789		b1 30		lda ($30),y			lda 	(codePtr),y
.878b		c8		iny				iny
.878c		85 36		sta $36				sta 	zTemp0
.878e		5a		phy				phy 								; save position
.878f		a0 02		ldy #$02			ldy 	#2 							; type is integer ?
.8791		b1 36		lda ($36),y			lda 	(zTemp0),y
.8793		d0 0c		bne $87a1			bne 	_TCXYPopFail
.8795		a0 08		ldy #$08			ldy 	#8 							; get first character, should have bit 7 set as also last.
.8797		b1 36		lda ($36),y			lda 	(zTemp0),y
.8799		c9 d8		cmp #$d8			cmp 	#'X'+$80 					; should be X or Y
.879b		f0 08		beq $87a5			beq 	_TCXYFound
.879d		c9 d9		cmp #$d9			cmp 	#'Y'+$80
.879f		f0 04		beq $87a5			beq 	_TCXYFound
.87a1						_TCXYPopFail:
.87a1		7a		ply				ply
.87a2						_TCXYFail:
.87a2		a9 00		lda #$00			lda 	#0
.87a4		60		rts				rts
.87a5						_TCXYFound:
.87a5		7a		ply				ply 								; restore position
.87a6		29 7f		and #$7f			and 	#$7F 						; throw bit 7
.87a8		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/backload.asm

.87a9						BackloadProgram:
.87a9		20 4d 8f	jsr $8f4d			jsr 	NewProgram 					; does the actual NEW.
.87ac		a2 88		ldx #$88			ldx 	#_BLLoad >> 8
.87ae		a9 09		lda #$09			lda 	#_BLLoad & $FF
.87b0		20 86 95	jsr $9586			jsr 	PrintStringXA
.87b3		a9 14		lda #$14			lda 	#SOURCE_ADDRESS >> 13 		; start page
.87b5		8d c5 07	sta $07c5			sta 	BackLoadPage
.87b8		a9 00		lda #$00			lda 	#(($6000) & $FF)
.87ba		8d c6 07	sta $07c6			sta 	0+BackLoadPointer
.87bd		a9 60		lda #$60			lda 	#(($6000) >> 8)
.87bf		8d c7 07	sta $07c7			sta 	1+BackLoadPointer
.87c2		9c c8 07	stz $07c8			stz 	BackLoadLast 				; reset backload last.
.87c5		9c c9 07	stz $07c9			stz 	BackLoadLast+1
.87c8		a9 ff		lda #$ff			lda 	#$FF
.87ca		8d fa ff	sta $fffa			sta 	$FFFA
.87cd						_BPLoop:
.87cd		a2 ff		ldx #$ff			ldx 	#$FF
.87cf		20 3e 88	jsr $883e			jsr 	BLReadByte 					; read a byte
.87d2		c9 00		cmp #$00			cmp 	#0
.87d4		f0 2c		beq $8802			beq 	_BPExit 					; if 0 exit
.87d6		30 2a		bmi $8802			bmi 	_BPExit 					; if -ve exit
.87d8						_BPCopy:
.87d8		e8		inx				inx  								; copy byte into the lineBuffer
.87d9		9d 46 05	sta $0546,x			sta 	lineBuffer,x
.87dc		9e 47 05	stz $0547,x			stz 	lineBuffer+1,x
.87df		20 3e 88	jsr $883e			jsr 	BLReadByte 					; read next byte
.87e2		30 0a		bmi $87ee			bmi 	_BPEndLine 					; -ve = EOL
.87e4		c9 09		cmp #$09			cmp 	#9 							; handle TAB, make it space.
.87e6		d0 02		bne $87ea			bne 	_BPNotTab
.87e8		a9 20		lda #$20			lda 	#' '
.87ea						_BPNotTab:
.87ea		c9 20		cmp #$20			cmp 	#' ' 						; < ' ' = EOL
.87ec		b0 ea		bcs $87d8			bcs 	_BPCopy 					; until a control character, should be 13 received.
.87ee						_BPEndLine:
.87ee		20 9d 80	jsr $809d			jsr 	TKTokeniseLine 				; tokenise the line.
.87f1		ad 47 04	lda $0447			lda 	tokenLineNumber 			; line number = 0
.87f4		0d 48 04	ora $0448			ora 	tokenLineNumber+1
.87f7		f0 d4		beq $87cd			beq 	_BPLoop 					; not legal code, blank line or maybe a comment.
.87f9		20 1e 88	jsr $881e			jsr 	BLCheckLast 				; check last backload okay.
.87fc		38		sec				sec 								; append not insert
.87fd		20 4b a8	jsr $a84b			jsr 	MemoryInsertLine 			; append to current program
.8800		80 cb		bra $87cd			bra 	_BPLoop
.8802						_BPExit:
.8802		9c fa ff	stz $fffa			stz 	$FFFA
.8805		20 b3 93	jsr $93b3			jsr 	ClearSystem 				; clear variables etc.
.8808		60		rts				rts
.8809						_BLLoad:
>8809		4c 6f 61 64 69 6e 67 20				.text 	"Loading from Memory",13,0
>8811		66 72 6f 6d 20 4d 65 6d 6f 72 79 0d 00
.881e						BLCheckLast:
.881e		ad c8 07	lda $07c8			lda 	BackLoadLast 				; check last < current
.8821		cd 47 04	cmp $0447			cmp 	tokenLineNumber
.8824		ad c9 07	lda $07c9			lda 	BackLoadLast+1
.8827		ed 48 04	sbc $0448			sbc 	tokenLineNumber+1
.882a		b0 0d		bcs $8839			bcs 	_BLCheckFail
.882c		ad 47 04	lda $0447			lda 	tokenLineNumber 			; update
.882f		8d c8 07	sta $07c8			sta 	BackLoadLast
.8832		ad 48 04	lda $0448			lda 	tokenLineNumber+1
.8835		8d c9 07	sta $07c9			sta 	BackLoadLast+1
.8838		60		rts				rts
.8839						_BLCheckFail:
.8839		a9 02		lda #$02		lda	#2
.883b		4c 27 95	jmp $9527		jmp	ErrorHandler
.883e						BLReadByte:
.883e		da		phx				phx
.883f		a6 0b		ldx $0b				ldx 	8+3 						; save current mapping for $6000 in X
.8841		ad c5 07	lda $07c5			lda 	BackLoadPage	 			; set current page
.8844		85 0b		sta $0b				sta 	8+3
.8846		ad c6 07	lda $07c6			lda 	BackLoadPointer 			; copy pointer to zTemp0
.8849		85 36		sta $36				sta 	zTemp0
.884b		ad c7 07	lda $07c7			lda 	BackLoadPointer+1
.884e		85 37		sta $37				sta 	zTemp0+1
.8850		b2 36		lda ($36)			lda 	(zTemp0) 					; read next byte
.8852		ee c6 07	inc $07c6			inc 	BackLoadPointer 			; bump pointer
.8855		d0 0f		bne $8866			bne 	_BLNoCarry
.8857		ee c7 07	inc $07c7			inc 	BackLoadPointer+1
.885a		10 0a		bpl $8866			bpl 	_BLNoCarry 					; need a new page
.885c		48		pha				pha
.885d		a9 60		lda #$60			lda 	#$60 						; reset pointer
.885f		8d c7 07	sta $07c7			sta 	BackLoadPointer+1
.8862		ee c5 07	inc $07c5			inc 	BackLoadPage 				; next page from source.
.8865		68		pla				pla
.8866						_BLNoCarry:
.8866		86 0b		stx $0b				stx 	8+3 						; restore mapping, then X.
.8868		fa		plx				plx
.8869		c9 00		cmp #$00			cmp 	#0
.886b		60		rts				rts
.07c5						BackLoadPage:
>07c5								.fill  	1
.07c6						BackLoadPointer:
>07c6								.fill 	2
.07c8						BackLoadLast:
>07c8								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/editor.asm

.886c						EditProgramCode:
.886c		ad 47 04	lda $0447			lda 	tokenLineNumber 			; try to find the line.
.886f		ae 48 04	ldx $0448			ldx 	tokenLineNumber+1
.8872		20 ef a8	jsr $a8ef			jsr 	MemorySearch
.8875		90 05		bcc $887c			bcc 	_EPCNoDelete 				; reached the end : don't delete
.8877		d0 03		bne $887c			bne 	_EPCNoDelete 				; found slot but didn't match : no delete
.8879		20 14 a8	jsr $a814			jsr 	MemoryDeleteLine 			; delete the line
.887c						_EPCNoDelete:
.887c		ad 49 04	lda $0449			lda 	tokenBuffer 				; buffer empty - we just want to delete a line.
.887f		c9 80		cmp #$80			cmp 	#KWC_EOL
.8881		f0 0d		beq $8890			beq 	_EPCNoInsert
.8883		ad 47 04	lda $0447			lda 	tokenLineNumber 			; find the line - it cannot exist as we've just deleted it.
.8886		ae 48 04	ldx $0448			ldx 	tokenLineNumber+1 			; so this can't fail, it returns some point in the code.
.8889		20 ef a8	jsr $a8ef			jsr 	MemorySearch
.888c		18		clc				clc 								; insert at this point.
.888d		20 4b a8	jsr $a84b			jsr 	MemoryInsertLine 			; insert the line
.8890						_EPCNoInsert:
.8890		a9 01		lda #$01			lda		#1
.8892		8d 75 06	sta $0675			sta		programChanged				; mark program changed
.8895		60		rts				rts
.8896						ResetTokenBuffer:
.8896		a9 03		lda #$03			lda		#3					; reset the token buffer to empty
.8898		8d 46 04	sta $0446			sta		tokenOffset			; (3 bytes for line number & offset)
.889b		9c 47 04	stz $0447			stz		tokenLineNumber
.889e		9c 48 04	stz $0448			stz		tokenLineNumber+1
.88a1		a9 46		lda #$46			lda 	#((tokenOffset) & $FF)
.88a3		85 30		sta $30				sta 	codePtr
.88a5		a9 04		lda #$04			lda 	#((tokenOffset) >> 8)
.88a7		85 31		sta $31				sta 	codePtr+1
.88a9		60		rts				rts
.88aa						IsDestructiveActionOK:
.88aa		ad 75 06	lda $0675			lda		programChanged
.88ad		f0 31		beq $88e0			beq		_ok_exit
.88af		a2 88		ldx #$88			ldx 	#_continue >> 8 	; print confirmation prompt
.88b1		a9 ee		lda #$ee			lda 	#_continue & $FF
.88b3		20 86 95	jsr $9586			jsr 	PrintStringXA
.88b6						_next_char
.88b6		20 ff 81	jsr $81ff			jsr		KNLGetSingleCharacter
.88b9		c9 79		cmp #$79			cmp		#'y'
.88bb		f0 16		beq $88d3			beq		_ok
.88bd		c9 59		cmp #$59			cmp		#'Y'
.88bf		f0 12		beq $88d3			beq		_ok
.88c1		c9 1b		cmp #$1b			cmp		#27
.88c3		f0 1d		beq $88e2			beq		_not_ok
.88c5		c9 6e		cmp #$6e			cmp		#'n'
.88c7		f0 19		beq $88e2			beq		_not_ok
.88c9		c9 4e		cmp #$4e			cmp		#'N'
.88cb		f0 15		beq $88e2			beq		_not_ok
.88cd		c9 0d		cmp #$0d			cmp		#13
.88cf		f0 11		beq $88e2			beq		_not_ok
.88d1		80 e3		bra $88b6			bra		_next_char
.88d3						_ok:
.88d3		a9 59		lda #$59			lda		#'Y'
.88d5		20 4d 80	jsr $804d			jsr		EXTPrintCharacter
.88d8		a9 0d		lda #$0d			lda		#13
.88da		20 4d 80	jsr $804d			jsr		EXTPrintCharacter
.88dd		9c 75 06	stz $0675			stz		programChanged
.88e0						_ok_exit:
.88e0		18		clc				clc
.88e1		60		rts				rts
.88e2						_not_ok:
.88e2		a9 4e		lda #$4e			lda		#'N'
.88e4		20 4d 80	jsr $804d			jsr		EXTPrintCharacter
.88e7		a9 0d		lda #$0d			lda		#13
.88e9		20 4d 80	jsr $804d			jsr		EXTPrintCharacter
.88ec		38		sec				sec
.88ed		60		rts				rts
.88ee						_continue:
>88ee		50 72 6f 67 72 61 6d 20				.text	"Program has unsaved changes, continue (y/N)? ",0
>88f6		68 61 73 20 75 6e 73 61 76 65 64 20 63 68 61 6e
>8906		67 65 73 2c 20 63 6f 6e 74 69 6e 75 65 20 28 79
>8916		2f 4e 29 3f 20 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/cli/warmstart.asm

.891c						WarmStart:
.891c		a2 ff		ldx #$ff			ldx 	#$FF
.891e		9a		txs				txs
.891f		a9 89		lda #$89			lda 	#CLICommandLine+$80 		; set console colour whatever the current colour is.
.8921		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8924		20 42 82	jsr $8242			jsr 	InputLine 					; get line to lineBuffer
.8927		ad 46 05	lda $0546			lda 	lineBuffer 					; first character is slash
.892a		c9 2f		cmp #$2f			cmp 	#"/"
.892c		d0 07		bne $8935			bne 	_WSNotSlash
.892e		a2 05		ldx #$05			ldx 	#(lineBuffer+1) >> 8 		; boot rest of line.
.8930		a9 47		lda #$47			lda 	#(lineBuffer+1) & $FF
.8932		4c 72 ad	jmp $ad72			jmp 	BootXA
.8935						_WSNotSlash:
.8935		20 9d 80	jsr $809d			jsr 	TKTokeniseLine 				; tokenise the line
.8938		ad 47 04	lda $0447			lda 	tokenLineNumber 			; line number <> 0
.893b		0d 48 04	ora $0448			ora 	tokenLineNumber+1
.893e		d0 17		bne $8957			bne 	_WSEditCode 				; if so,edit code.
.8940		9c 46 04	stz $0446			stz 	tokenOffset 				; zero the "offset", meaning it only runs one line.
.8943		a9 46		lda #$46			lda 	#((tokenOffset) & $FF)
.8945		85 30		sta $30				sta 	codePtr
.8947		a9 04		lda #$04			lda 	#((tokenOffset) >> 8)
.8949		85 31		sta $31				sta 	codePtr+1
.894b		ad 49 04	lda $0449			lda 	tokenBuffer 				; nothing to run
.894e		c9 80		cmp #$80			cmp 	#KWC_EOL
.8950		f0 ca		beq $891c			beq 	WarmStart
.8952		20 08 91	jsr $9108			jsr 	RUNCodePointerLine 			; execute that line.
.8955		80 c5		bra $891c			bra 	WarmStart
.8957						_WSEditCode:
.8957		20 6c 88	jsr $886c			jsr 	EditProgramCode 			; edit the program code
.895a		20 b3 93	jsr $93b3			jsr 	ClearSystem 				; clear all variables etc.
.895d		80 bd		bra $891c			bra 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assemble.asm

.895f						AssembleCommand:
.895f		a2 00		ldx #$00			ldx 	#0
.8961		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger 		; start address
.8964		a5 60		lda $60				lda 	NSMantissa0
.8966		8d 3a 04	sta $043a			sta 	AssemblerAddress
.8969		a5 70		lda $70				lda 	NSMantissa1
.896b		8d 3b 04	sta $043b			sta 	AssemblerAddress+1
.896e		20 16 95	jsr $9516			jsr 	CheckComma
.8971		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; options 0-3
.8974		a5 60		lda $60				lda 	NSMantissa0
.8976		8d 3c 04	sta $043c			sta 	AssemblerControl
.8979		60		rts				rts
.897a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/assert.asm

.897b						AssertCommand:
.897b		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.897d		20 fd a3	jsr $a3fd			jsr 	EvaluateInteger 			; the assert test
.8980		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; exit if result is non zero.
.8983		d0 05		bne $898a			bne 	_ACExit
.8985		a9 0a		lda #$0a		lda	#10
.8987		4c 27 95	jmp $9527		jmp	ErrorHandler
.898a						_ACExit:
.898a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/call.asm

.898b						CallCommand:
.898b		a2 00		ldx #$00			ldx 	#0 							; get the routine address to level 0
.898d		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger
.8990						_CCClear
.8990		e8		inx				inx  								; clear 1,2 and 3 (for A X Y)
.8991		20 90 a4	jsr $a490			jsr 	NSMSetZero 					; these are optional sequentially.
.8994		e0 04		cpx #$04			cpx 	#4
.8996		d0 f8		bne $8990			bne 	_CCClear
.8998		a2 00		ldx #$00			ldx 	#0 							; and keep trying while there are more values.
.899a						_CCCParam:
.899a		b1 30		lda ($30),y			lda 	(codePtr),y
.899c		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.899e		d0 09		bne $89a9			bne 	_CCCRun6502
.89a0		c8		iny				iny 								; skip comma
.89a1		e8		inx				inx	 								; next level
.89a2		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; get A/X/Y
.89a5		e0 03		cpx #$03			cpx 	#3
.89a7		90 f1		bcc $899a			bcc 	_CCCParam 					; done all 3 ?
.89a9						_CCCRun6502:
.89a9		5a		phy				phy 								; save position
.89aa		a5 70		lda $70				lda 	NSMantissa1 				; put address in zTemp0
.89ac		85 37		sta $37				sta 	zTemp0+1
.89ae		a5 60		lda $60				lda 	NSMantissa0
.89b0		85 36		sta $36				sta 	zTemp0
.89b2		a5 61		lda $61				lda 	NSMantissa0+1 				; get registers into A X Y
.89b4		a6 62		ldx $62				ldx 	NSMantissa0+2
.89b6		a4 63		ldy $63				ldy 	NSMantissa0+3
.89b8		20 bd 89	jsr $89bd			jsr 	_CCCZTemp0 					; call zTemp0
.89bb		7a		ply				ply 								; restore position and exit
.89bc		60		rts				rts
.89bd						_CCCZTemp0:
.89bd		6c 36 00	jmp ($0036)			jmp 	(zTemp0)

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/data.asm

.89c0						Command_Data:
.89c0		a9 3a		lda #$3a			lda 	#KWD_COLON 					; advance to colon/EOL, e.g. ignore anything till then.
.89c2		a2 80		ldx #$80			ldx 	#KWC_EOL
.89c4		20 69 94	jsr $9469			jsr 	ScanForward
.89c7		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/dim.asm

.89c8						DimCommand:
.89c8		b1 30		lda ($30),y			lda 	(codePtr),y
.89ca		29 c0		and #$c0			and 	#$C0
.89cc		c9 40		cmp #$40			cmp 	#$40
.89ce		d0 7a		bne $8a4a			bne 	_DCSyntax 				; n o, error.
.89d0		b1 30		lda ($30),y			lda 	(codePtr),y
.89d2		18		clc				clc
.89d3		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.89d5		85 3f		sta $3f				sta 	zaTemp+1
.89d7		c8		iny				iny
.89d8		b1 30		lda ($30),y			lda 	(codePtr),y
.89da		c8		iny				iny
.89db		85 3e		sta $3e				sta 	zaTemp
.89dd		5a		phy				phy
.89de		a0 02		ldy #$02			ldy 	#2 						; read type byte
.89e0		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.89e2		29 18		and #$18			and 	#NSBTypeMask 			; check it's not a procedure
.89e4		c9 18		cmp #$18			cmp 	#NSTProcedure
.89e6		f0 62		beq $8a4a			beq 	_DCSyntax
.89e8		b1 3e		lda ($3e),y			lda 	(zaTemp),y 				; check it's an array
.89ea		29 04		and #$04			and 	#NSBIsArray
.89ec		f0 64		beq $8a52			beq 	_DCType
.89ee		a0 04		ldy #$04			ldy 	#4 						; check not already defined
.89f0		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.89f2		d0 59		bne $8a4d			bne 	_DCRedefine
.89f4		7a		ply				ply
.89f5		20 55 8a	jsr $8a55			jsr 	_DCGetSize 				; get array size, check it.
.89f8		5a		phy				phy
.89f9		a0 05		ldy #$05			ldy 	#5 						; store in first array size slot
.89fb		91 3e		sta ($3e),y			sta 	(zaTemp),y 				; second will be zero.
.89fd		7a		ply				ply 							; is there a second (e.g. ,x)
.89fe		b1 30		lda ($30),y			lda 	(codePtr),y
.8a00		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8a02		d0 0a		bne $8a0e			bne 	_DCOneDimension
.8a04		c8		iny				iny 							; skip comma
.8a05		20 55 8a	jsr $8a55			jsr 	_DCGetSize 				; get 2nd array size
.8a08		5a		phy				phy
.8a09		a0 06		ldy #$06			ldy 	#6 						; store in 2nd array size
.8a0b		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8a0d		7a		ply				ply
.8a0e						_DCOneDimension:
.8a0e		5a		phy				phy 							; save position
.8a0f		a0 05		ldy #$05			ldy 	#5 						; dimensions + 1 in AX (as zero based)
.8a11		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8a13		aa		tax				tax
.8a14		c8		iny				iny
.8a15		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8a17		e8		inx				inx 							; bump them.
.8a18		1a		inc a				inc 	a
.8a19		20 3b a4	jsr $a43b			jsr 	Multiply8x8 			; work out the total number of elements -> zTemp0
.8a1c		a5 37		lda $37				lda 	zTemp0+1 				; don't allow more than 8192 elements whatever
.8a1e		29 e0		and #$e0			and 	#$E0
.8a20		d0 23		bne $8a45			bne 	_DCSize
.8a22		a0 02		ldy #$02			ldy 	#2 						; get base type
.8a24		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.8a26		20 63 8a	jsr $8a63			jsr 	ScaleByBaseType 		; scale by base type
.8a29		a5 36		lda $36				lda 	zTemp0
.8a2b		a6 37		ldx $37				ldx 	zTemp0+1
.8a2d		20 32 a0	jsr $a032			jsr 	AllocateXABytes 		; allocate memory
.8a30		a0 03		ldy #$03			ldy 	#3 						; copy into the address.
.8a32		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8a34		c8		iny				iny
.8a35		8a		txa				txa
.8a36		91 3e		sta ($3e),y			sta 	(zaTemp),y
.8a38		7a		ply				ply 							; get position back
.8a39		20 0e 95	jsr $950e			jsr 	CheckRightBracket 		; check )
.8a3c		b1 30		lda ($30),y			lda 	(codePtr),y
.8a3e		c8		iny				iny 							; consume in case
.8a3f		c9 2c		cmp #$2c			cmp 	#KWD_COMMA		 		; if so do another DIM.
.8a41		f0 85		beq $89c8			beq 	DimCommand
.8a43		88		dey				dey 							; undo consume
.8a44		60		rts				rts
.8a45						_DCSize:
.8a45		a9 16		lda #$16		lda	#22
.8a47		4c 27 95	jmp $9527		jmp	ErrorHandler
.8a4a						_DCSyntax:
.8a4a		4c 08 a6	jmp $a608			jmp 	SyntaxError
.8a4d						_DCRedefine:
.8a4d		a9 15		lda #$15		lda	#21
.8a4f		4c 27 95	jmp $9527		jmp	ErrorHandler
.8a52						_DCType:
.8a52		4c 12 a6	jmp $a612			jmp 	TypeError
.8a55						_DCGetSize:
.8a55		a2 00		ldx #$00			ldx 	#0 						; get first index.
.8a57		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 	; get array dimension
.8a5a		c9 00		cmp #$00			cmp 	#0 						; must be 1-254
.8a5c		f0 e7		beq $8a45			beq 	_DCSize
.8a5e		c9 fe		cmp #$fe			cmp 	#254
.8a60		f0 e3		beq $8a45			beq 	_DCSize
.8a62		60		rts				rts
.8a63						ScaleByBaseType:
.8a63		29 10		and #$10			and 	#NSBIsString 			; is it string
.8a65		d0 19		bne $8a80			bne 	_SBBTString
.8a67		a5 37		lda $37				lda 	zTemp0+1 				; push value on stack
.8a69		48		pha				pha
.8a6a		a5 36		lda $36				lda 	zTemp0
.8a6c		48		pha				pha
.8a6d		06 36		asl $36				asl 	zTemp0 					; x 2
.8a6f		26 37		rol $37				rol 	zTemp0+1
.8a71		06 36		asl $36				asl 	zTemp0 					; x 4
.8a73		26 37		rol $37				rol 	zTemp0+1
.8a75		68		pla				pla 							; add stacked value = x 5
.8a76		65 36		adc $36				adc 	zTemp0
.8a78		85 36		sta $36				sta 	zTemp0
.8a7a		68		pla				pla
.8a7b		65 37		adc $37				adc 	zTemp0+1
.8a7d		85 37		sta $37				sta 	zTemp0+1
.8a7f		60		rts				rts
.8a80						_SBBTString:
.8a80		06 36		asl $36				asl 	zTemp0
.8a82		26 37		rol $37				rol 	zTemp0+1
.8a84		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/end.asm

.8a85						EndCommand:
.8a85		4c 1c 89	jmp $891c			jmp 	WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/for.asm

.8a88						ForCommand:
.8a88		a9 d9		lda #$d9			lda 	#STK_FOR+9 					; allocate 18 bytes on the return stack (see above).
.8a8a		20 d7 b6	jsr $b6d7			jsr 	StackOpen
.8a8d		a2 00		ldx #$00			ldx 	#0
.8a8f		20 84 9e	jsr $9e84			jsr 	EvaluateTerm
.8a92		b5 50		lda $50,x			lda 	NSStatus,x
.8a94		c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.8a96		d0 47		bne $8adf			bne		_FCError
.8a98		a9 3d		lda #$3d			lda 	#KWD_EQUAL 					; =
.8a9a		20 1e 95	jsr $951e			jsr 	CheckNextA
.8a9d		e8		inx				inx
.8a9e		20 fd a3	jsr $a3fd			jsr 	EvaluateInteger 			; <from> in +1
.8aa1		b1 30		lda ($30),y			lda 	(codePtr),y
.8aa3		c8		iny				iny 								; consume it
.8aa4		48		pha				pha 								; save on stack for later
.8aa5		c9 c4		cmp #$c4			cmp 	#KWD_DOWNTO
.8aa7		f0 04		beq $8aad			beq 	_FCNoSyntax
.8aa9		c9 de		cmp #$de			cmp 	#KWD_TO
.8aab		d0 35		bne $8ae2			bne 	_FCSyntaxError
.8aad						_FCNoSyntax:
.8aad		e8		inx				inx
.8aae		20 fd a3	jsr $a3fd			jsr 	EvaluateInteger
.8ab1		20 1c b7	jsr $b71c			jsr 	STKSaveCodePosition 		; save loop back position
.8ab4		68		pla				pla 								; restore DOWNTO or TO
.8ab5		5a		phy				phy 								; save Y on the stack
.8ab6		49 c4		eor #$c4			eor 	#KWD_DOWNTO 				; 0 if DOWNTO, #0 if TO
.8ab8		f0 02		beq $8abc			beq 	_FCNotDownTo
.8aba		a9 02		lda #$02			lda 	#2
.8abc						_FCNotDownTo:
.8abc		3a		dec a				dec 	a 							; 255 if DOWNTO, 1 if TO
.8abd		a0 10		ldy #$10			ldy 	#16
.8abf		91 34		sta ($34),y			sta 	(basicStack),y 				; copy that out to the Basic Stack.
.8ac1		a0 06		ldy #$06			ldy 	#6 							; this is the address of the loop variable.
.8ac3		a5 60		lda $60				lda 	NSMantissa0
.8ac5		91 34		sta ($34),y			sta 	(basicStack),y
.8ac7		a5 70		lda $70				lda 	NSMantissa1
.8ac9		c8		iny				iny
.8aca		91 34		sta ($34),y			sta 	(basicStack),y
.8acc		a0 08		ldy #$08			ldy 	#8 							; set initial index value
.8ace		a2 01		ldx #$01			ldx 	#1
.8ad0		20 e5 8a	jsr $8ae5			jsr 	FCIntegerToStack
.8ad3		a0 0c		ldy #$0c			ldy 	#12 						; set the terminal value
.8ad5		a2 02		ldx #$02			ldx 	#2
.8ad7		20 e5 8a	jsr $8ae5			jsr 	FCIntegerToStack
.8ada		20 00 8b	jsr $8b00			jsr 	CopyIndexToReference
.8add		7a		ply				ply 								; restore position
.8ade		60		rts				rts
.8adf						_FCError:
.8adf		4c 12 a6	jmp $a612			jmp 	TypeError
.8ae2						_FCSyntaxError:
.8ae2		4c 08 a6	jmp $a608			jmp 	SyntaxError
.8ae5						FCIntegerToStack:
.8ae5		34 50		bit $50,x			bit 	NSStatus,x 					; is the value negative
.8ae7		10 03		bpl $8aec			bpl	 	_FCNotNegative
.8ae9		20 59 a4	jsr $a459			jsr 	NSMNegateMantissa 			; if so 2's complement the mantissa
.8aec						_FCNotNegative:
.8aec		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy out to the basic stack
.8aee		91 34		sta ($34),y			sta 	(basicStack),y
.8af0		c8		iny				iny
.8af1		b5 70		lda $70,x			lda 	NSMantissa1,x
.8af3		91 34		sta ($34),y			sta 	(basicStack),y
.8af5		c8		iny				iny
.8af6		b5 80		lda $80,x			lda 	NSMantissa2,x
.8af8		91 34		sta ($34),y			sta 	(basicStack),y
.8afa		c8		iny				iny
.8afb		b5 90		lda $90,x			lda 	NSMantissa3,x
.8afd		91 34		sta ($34),y			sta 	(basicStack),y
.8aff		60		rts				rts
.8b00						CopyIndexToReference:
.8b00		5a		phy				phy
.8b01		a0 06		ldy #$06			ldy 	#6 							; copy address-8 to write to zTemp0
.8b03		38		sec				sec 								; (because we copy from offset 8)
.8b04		b1 34		lda ($34),y			lda 	(basicStack),y
.8b06		e9 08		sbc #$08			sbc 	#8
.8b08		85 36		sta $36				sta 	zTemp0
.8b0a		c8		iny				iny
.8b0b		b1 34		lda ($34),y			lda 	(basicStack),y
.8b0d		e9 00		sbc #$00			sbc 	#0
.8b0f		85 37		sta $37				sta 	zTemp0+1
.8b11		a2 04		ldx #$04			ldx 	#4 							; this is the copy counter/
.8b13		a0 0b		ldy #$0b			ldy 	#8+3 		 				; the MSB of the mantissa
.8b15		b1 34		lda ($34),y			lda 	(basicStack),y
.8b17		0a		asl a				asl 	a 							; into carry
.8b18		a0 08		ldy #$08			ldy 	#8 							; where to copy from.
.8b1a		90 14		bcc $8b30			bcc 	_CITRNormal
.8b1c		38		sec				sec
.8b1d						_CITRNegative:
.8b1d		a9 00		lda #$00			lda 	#0
.8b1f		f1 34		sbc ($34),y			sbc 	(basicStack),y
.8b21		91 36		sta ($36),y			sta 	(zTemp0),y
.8b23		c8		iny				iny
.8b24		ca		dex				dex
.8b25		d0 f6		bne $8b1d			bne 	_CITRNegative
.8b27		88		dey				dey 								; look at MSB of mantissa
.8b28		b1 36		lda ($36),y			lda 	(zTemp0),y 					; set the MSB as negative packed.
.8b2a		09 80		ora #$80			ora 	#$80
.8b2c		91 36		sta ($36),y			sta 	(zTemp0),y
.8b2e		7a		ply				ply
.8b2f		60		rts				rts
.8b30						_CITRNormal:
.8b30		b1 34		lda ($34),y			lda 	(basicStack),y 				; copy without negation.
.8b32		91 36		sta ($36),y			sta 	(zTemp0),y
.8b34		c8		iny				iny
.8b35		ca		dex				dex
.8b36		d0 f8		bne $8b30			bne 	_CITRNormal
.8b38		7a		ply				ply 								; and exit.
.8b39		60		rts				rts
.8b3a						NextCommand:
.8b3a		a9 d9		lda #$d9			lda 	#STK_FOR+9 					; check FOR is TOS
.8b3c		a2 11		ldx #$11			ldx 	#ERRID_FOR 					; this error
.8b3e		20 04 b7	jsr $b704			jsr 	StackCheckFrame
.8b41		5a		phy				phy
.8b42		a0 10		ldy #$10			ldy 	#16 						; get the step count
.8b44		b1 34		lda ($34),y			lda 	(basicStack),y
.8b46		85 36		sta $36				sta 	zTemp0 						; this is the sign extend
.8b48		30 02		bmi $8b4c			bmi 	_NCStepNeg
.8b4a		64 36		stz $36				stz 	zTemp0 						; which is 0 or 255
.8b4c						_NCStepNeg:
.8b4c		a0 08		ldy #$08			ldy 	#8 							; offset to bump
.8b4e		a2 04		ldx #$04			ldx 	#4 							; count to bump
.8b50		18		clc				clc
.8b51						_NCBump:
.8b51		71 34		adc ($34),y			adc 	(basicStack),y 				; add it
.8b53		91 34		sta ($34),y			sta 	(basicStack),y
.8b55		a5 36		lda $36				lda 	zTemp0 						; get sign extend for next time.
.8b57		c8		iny				iny 								; next byte
.8b58		ca		dex				dex 								; do four times
.8b59		d0 f6		bne $8b51			bne 	_NCBump
.8b5b		20 00 8b	jsr $8b00			jsr		CopyIndexToReference		; copy it to the reference variable.
.8b5e		a0 10		ldy #$10			ldy 	#16 						; get step count again
.8b60		b1 34		lda ($34),y			lda 	(basicStack),y
.8b62		0a		asl a				asl 	a 							; sign bit to carry
.8b63		a9 0c		lda #$0c			lda 	#12 						; offset of LHS = terminal offset
.8b65		85 38		sta $38				sta 	zTemp1
.8b67		90 02		bcc $8b6b			bcc 	_NCCompRev 					; use if step is +ve
.8b69		a9 08		lda #$08			lda 	#8 							; now the LHS = index value
.8b6b						_NCCompRev:
.8b6b		85 38		sta $38				sta 	zTemp1 						; so zTemp0 is the index for LHS
.8b6d		49 04		eor #$04			eor 	#(8^12) 					; and zTemp0+1 is the index for RHS
.8b6f		85 39		sta $39				sta 	zTemp1+1
.8b71		a2 04		ldx #$04			ldx 	#4 							; bytes to compare
.8b73		38		sec				sec
.8b74						_NCCompare:
.8b74		a4 38		ldy $38				ldy 	zTemp1 						; do compare using the two indices
.8b76		b1 34		lda ($34),y			lda 	(basicStack),y
.8b78		a4 39		ldy $39				ldy 	zTemp1+1
.8b7a		f1 34		sbc ($34),y			sbc 	(basicStack),y
.8b7c		e6 38		inc $38				inc 	zTemp1 						; bump the indices (inc,dex do not change C or V)
.8b7e		e6 39		inc $39				inc 	zTemp1+1
.8b80		ca		dex				dex 								; do it 4 times.
.8b81		d0 f1		bne $8b74			bne 	_NCCompare
.8b83		50 02		bvc $8b87			bvc 	_NCNoOverflow 				; convert to signed comparison
.8b85		49 80		eor #$80			eor 	#$80
.8b87						_NCNoOverflow:
.8b87		7a		ply				ply 								; restore Y position
.8b88		0a		asl a				asl 	a 							; is bit 7 set.
.8b89		90 04		bcc $8b8f			bcc 	_NCLoopBack 				; if no , >= so loop back
.8b8b		20 f6 b6	jsr $b6f6			jsr 	StackClose 					; exit the loop
.8b8e		60		rts				rts
.8b8f						_NCLoopBack:
.8b8f		20 2d b7	jsr $b72d			jsr 	STKLoadCodePosition 		; loop back
.8b92		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/gosub.asm

.8b93						Command_GOSUB:
.8b93		a2 00		ldx #$00			ldx 	#0
.8b95		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger 		; line number in Stack.0
.8b98		a9 e3		lda #$e3			lda 	#STK_GOSUB+3
.8b9a		20 d7 b6	jsr $b6d7			jsr 	StackOpen 					; create frame
.8b9d		20 1c b7	jsr $b71c			jsr 	STKSaveCodePosition 		; save current position
.8ba0		4c b6 8b	jmp $8bb6			jmp 	GotoStackX
.8ba3						Command_RETURN:
.8ba3		a9 e0		lda #$e0			lda 	#STK_GOSUB 					; check TOS is this
.8ba5		a2 0e		ldx #$0e			ldx 	#ERRID_GOSUB 				; this error
.8ba7		20 04 b7	jsr $b704			jsr 	StackCheckFrame
.8baa		20 2d b7	jsr $b72d			jsr 	STKLoadCodePosition 		; restore code position
.8bad		20 f6 b6	jsr $b6f6			jsr 	StackClose
.8bb0		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/goto.asm

.8bb1						GotoCommand:
.8bb1		a2 00		ldx #$00			ldx 	#0 							; GOTO where
.8bb3		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger
.8bb6						GotoStackX:
.8bb6		b5 70		lda $70,x			lda  	NSMantissa1,x 				; put line # in XA. I'll keep this even though
.8bb8		48		pha				pha 								; it is slightly inefficient, just in cases.
.8bb9		b5 60		lda $60,x			lda 	NSMantissa0,x
.8bbb		fa		plx				plx
.8bbc		20 ef a8	jsr $a8ef			jsr 	MemorySearch 				; transfer to line number AX.
.8bbf		90 05		bcc $8bc6			bcc 	_GotoError 					; not found, off end.
.8bc1		d0 03		bne $8bc6			bne 	_GotoError 					; not found exactly
.8bc3		4c 01 91	jmp $9101			jmp 	RunNewLine 					; and go straight to new line code.
.8bc6						_GotoError:
.8bc6		a9 0d		lda #$0d		lda	#13
.8bc8		4c 27 95	jmp $9527		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/if.asm

.8bcb						IfCommand:
.8bcb		a2 00		ldx #$00			ldx 	#0 							; Get the if test.
.8bcd		20 de a3	jsr $a3de			jsr 	EvaluateNumber
.8bd0		b1 30		lda ($30),y			lda 	(codePtr),y
.8bd2		c9 b8		cmp #$b8			cmp 	#KWD_THEN  					; could be THEN <stuff>
.8bd4		d0 0a		bne $8be0			bne 	_IfStructured 				; we still support it.
.8bd6		c8		iny				iny 								; consume THEN
.8bd7		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; is it zero
.8bda		f0 01		beq $8bdd			beq 	_IfFail 					; if fail, go to next line
.8bdc		60		rts				rts 								; if THEN just continue
.8bdd						_IfFail:
.8bdd		4c dc 90	jmp $90dc			jmp 	EOLCommand
.8be0						_IfStructured:
.8be0		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; is it zero
.8be3		d0 07		bne $8bec			bne 	_IfExit 					; if not, then continue normally.
.8be5		a9 c5		lda #$c5			lda 	#KWD_ELSE 					; look for else/endif
.8be7		a2 b5		ldx #$b5			ldx 	#KWD_ENDIF
.8be9		20 69 94	jsr $9469			jsr 	ScanForward 				; and run from there
.8bec						_IfExit:
.8bec		60		rts				rts
.8bed						ElseCode:
.8bed		a9 b5		lda #$b5			lda 	#KWD_ENDIF 					; else is only run after the if clause succeeds
.8bef		aa		tax				tax 								; so just go to the structure exit
.8bf0		20 69 94	jsr $9469			jsr 	ScanForward
.8bf3		60		rts				rts
.8bf4						EndIf:
.8bf4		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/inputprint.asm

.8bf5						Command_Input:
.8bf5		9c 44 04	stz $0444			stz 	isPrintFlag
.8bf8		80 0c		bra $8c06			bra 	Command_IP_Main
.8bfa						Command_CPrint:
.8bfa		a9 7f		lda #$7f			lda 	#$7F
.8bfc		8d 44 04	sta $0444			sta 	isPrintFlag 				; set input flag to character mode
.8bff		80 05		bra $8c06			bra 	Command_IP_Main
.8c01						Command_Print:
.8c01		a9 ff		lda #$ff			lda 	#$FF
.8c03		8d 44 04	sta $0444			sta 	isPrintFlag 				; set input flag
.8c06						Command_IP_Main:
.8c06		18		clc				clc
.8c07						_CPLoop:
.8c07		08		php				php 								; save last action flag
.8c08		b1 30		lda ($30),y			lda 	(codePtr),y
.8c0a		c9 80		cmp #$80			cmp  	#KWC_EOL 					; end of line or colon, exit now.
.8c0c		f0 5d		beq $8c6b			beq 	_CPExit
.8c0e		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.8c10		f0 59		beq $8c6b			beq 	_CPExit
.8c12		68		pla				pla 								; throw last action flag
.8c13		b1 30		lda ($30),y			lda 	(codePtr),y
.8c15		c8		iny				iny
.8c16		c9 3b		cmp #$3b			cmp 	#KWD_SEMICOLON				; is it a semicolon
.8c18		f0 4e		beq $8c68			beq 	_CPContinueWithSameLine
.8c1a		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; comma
.8c1c		f0 45		beq $8c63			beq 	_CPTab
.8c1e		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; apostrophe (new line)
.8c20		f0 3d		beq $8c5f			beq 	_CPNewLine
.8c22		c9 bb		cmp #$bb			cmp 	#KWD_AT 					; `at` modifier
.8c24		f0 34		beq $8c5a			beq 	_CPAtModifier
.8c26		88		dey				dey 								; undo the get
.8c27		20 2f 9a	jsr $9a2f			jsr 	EvaluateExpressionAt0 		; evaluate expression at 0.
.8c2a		b5 50		lda $50,x			lda 	NSStatus,x 					; read the status
.8c2c		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.8c2e		f0 0d		beq $8c3d			beq 	_CPIsValue 					; no, display it
.8c30		ad 44 04	lda $0444			lda 	isPrintFlag 				; if print, dereference and print
.8c33		d0 05		bne $8c3a			bne 	_CPIsPrint 					; otherwise display.
.8c35		20 74 8c	jsr $8c74			jsr 	CIInputValue 				; input a value to the reference
.8c38		80 25		bra $8c5f			bra 	_CPNewLine
.8c3a						_CPIsPrint:
.8c3a		20 fd 9c	jsr $9cfd			jsr 	Dereference 				; dereference if required.
.8c3d						_CPIsValue:
.8c3d		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a number
.8c3f		29 10		and #$10			and 	#NSBIsString
.8c41		f0 09		beq $8c4c			beq 	_CPNumber
.8c43		a6 70		ldx $70				ldx 	NSMantissa1 				; string, print the text.
.8c45		a5 60		lda $60				lda 	NSMantissa0
.8c47		20 d7 8c	jsr $8cd7			jsr 	CPPrintStringXA
.8c4a		80 ba		bra $8c06			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.8c4c						_CPNumber:
.8c4c		a9 05		lda #$05			lda 	#5 							; maximum decimals
.8c4e		20 c5 a2	jsr $a2c5			jsr 	ConvertNumberToString 		; convert to string (in unary str$() function)
.8c51		a2 06		ldx #$06			ldx 	#decimalBuffer >> 8
.8c53		a9 65		lda #$65			lda 	#decimalBuffer & $FF
.8c55		20 d7 8c	jsr $8cd7			jsr 	CPPrintStringXA 			; print it.
.8c58		80 ac		bra $8c06			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.8c5a						_CPAtModifier:
.8c5a		20 f8 8c	jsr $8cf8			jsr 	CPPrintAt			        ; subroutine to keep `_CPLoop` within branch range
.8c5d		80 a7		bra $8c06			bra 	Command_IP_Main
.8c5f						_CPNewLine:
.8c5f		a9 0d		lda #$0d			lda 	#13
.8c61		80 02		bra $8c65			bra 	_CPPrintCharDirect
.8c63						_CPTab:
.8c63		a9 09		lda #$09			lda 	#9 							; print TAB
.8c65						_CPPrintCharDirect:
.8c65		20 f2 8c	jsr $8cf2			jsr 	CPPVControl 				; print TAB/CR using the non PETSCII
.8c68						_CPContinueWithSameLine:
.8c68		38		sec				sec 								; loop round with carry set, which
.8c69		80 9c		bra $8c07			bra 	_CPLoop 					; will inhibit final CR
.8c6b						_CPExit:
.8c6b		28		plp				plp 								; get last action flag
.8c6c		b0 05		bcs $8c73			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.8c6e		a9 0d		lda #$0d			lda 	#13 						; print new line
.8c70		20 f2 8c	jsr $8cf2			jsr 	CPPVControl
.8c73						_CPExit2:
.8c73		60		rts				rts
.8c74						CIInputValue:
.8c74		a2 00		ldx #$00			ldx 	#0 							; input a line.
.8c76						_CIInputLine:
.8c76		20 f5 8c	jsr $8cf5			jsr 	CPInputVector 				; get key
.8c79		c9 0d		cmp #$0d			cmp 	#13 						; 13 = End
.8c7b		f0 1f		beq $8c9c			beq 	_CIHaveValue
.8c7d		c9 08		cmp #$08			cmp 	#8 							; 8 = BS
.8c7f		f0 11		beq $8c92			beq 	_CIBackspace
.8c81		c9 20		cmp #$20			cmp 	#32 						; ignore other control characters
.8c83		90 f1		bcc $8c76			bcc 	_CIInputLine
.8c85		e0 50		cpx #$50			cpx 	#80 						; max length
.8c87		b0 ed		bcs $8c76			bcs 	_CIInputLine
.8c89		9d 46 05	sta $0546,x			sta 	lineBuffer,x
.8c8c		e8		inx				inx
.8c8d		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter 			; echo it.
.8c90		80 e4		bra $8c76			bra 	_CIInputLine
.8c92						_CIBackspace:
.8c92		e0 00		cpx #$00			cpx 	#0 							; nothing to delete
.8c94		f0 e0		beq $8c76			beq 	_CIInputLine
.8c96		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter 			; echo it.
.8c99		ca		dex				dex
.8c9a		80 da		bra $8c76			bra 	_CIInputLine
.8c9c						_CIHaveValue:
.8c9c		9e 46 05	stz $0546,x			stz 	lineBuffer,x 				; ASCIIZ string now in line buffer.
.8c9f		a5 50		lda $50				lda 	NSStatus 					; was it a string assignment
.8ca1		29 10		and #$10			and 	#NSBIsString
.8ca3		f0 17		beq $8cbc			beq 	_CIAssignNumber 			; assign a number
.8ca5		a2 01		ldx #$01			ldx 	#1
.8ca7		a9 46		lda #$46			lda 	#lineBuffer & $FF 			; set up to point to new string
.8ca9		95 60		sta $60,x			sta 	NSMantissa0,x
.8cab		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8cad		95 70		sta $70,x			sta 	NSMantissa1,x
.8caf		74 80		stz $80,x			stz 	NSMantissa2,x
.8cb1		74 90		stz $90,x			stz 	NSMantissa3,x
.8cb3		a9 10		lda #$10			lda 	#NSBIsString 				; so it becomes a string value
.8cb5		95 50		sta $50,x			sta  	NSStatus,x
.8cb7		ca		dex				dex 								; X = 0
.8cb8		20 57 8d	jsr $8d57			jsr 	AssignVariable
.8cbb		60		rts				rts
.8cbc						_CIAssignNumber:
.8cbc		a9 46		lda #$46			lda 	#lineBuffer & $FF 			; set up to point to new string
.8cbe		85 36		sta $36				sta 	zTemp0
.8cc0		a9 05		lda #$05			lda 	#lineBuffer >> 8
.8cc2		85 37		sta $37				sta 	zTemp0+1
.8cc4		a2 01		ldx #$01			ldx 	#1 							; put in slot 1
.8cc6		20 a5 a1	jsr $a1a5			jsr 	ValEvaluateZTemp0 			; use the VAL() code
.8cc9		90 07		bcc $8cd2			bcc 	_CIIsOkay
.8ccb		a9 3f		lda #$3f			lda 	#"?" 						; error ?
.8ccd		20 ea 8c	jsr $8cea			jsr 	CPPrintVector
.8cd0		80 a2		bra $8c74			bra 	CIInputValue
.8cd2						_CIIsOkay:
.8cd2		ca		dex				dex 								; X = 0
.8cd3		20 57 8d	jsr $8d57			jsr 	AssignVariable
.8cd6		60		rts				rts
.8cd7						CPPrintStringXA:
.8cd7		5a		phy				phy
.8cd8		86 37		stx $37				stx 	zTemp0+1
.8cda		85 36		sta $36				sta 	zTemp0
.8cdc		a0 00		ldy #$00			ldy 	#0
.8cde						_PSXALoop:
.8cde		b1 36		lda ($36),y			lda 	(zTemp0),y
.8ce0		f0 06		beq $8ce8			beq 	_PSXAExit
.8ce2		20 ea 8c	jsr $8cea			jsr 	CPPrintVector
.8ce5		c8		iny				iny
.8ce6		80 f6		bra $8cde			bra 	_PSXALoop
.8ce8						_PSXAExit:
.8ce8		7a		ply				ply
.8ce9		60		rts				rts
.8cea						CPPrintVector:
.8cea		2c 44 04	bit $0444			bit 	isPrintFlag 				; check if char only mode and call appropriate handler
.8ced		30 03		bmi $8cf2			bmi 	CPPVControl
.8cef		4c 57 80	jmp $8057			jmp 	EXTPrintNoControl
.8cf2						CPPVControl:
.8cf2		4c 4d 80	jmp $804d			jmp 	EXTPrintCharacter
.8cf5						CPInputVector:
.8cf5		4c ff 81	jmp $81ff			jmp 	KNLGetSingleCharacter
.8cf8						CPPrintAt:
.8cf8		a2 00		ldx #$00			ldx		#0 							; bottom stack level
.8cfa		20 2b a4	jsr $a42b			jsr		Evaluate8BitInteger         ; parse row into `A`
.8cfd		cd ee 07	cmp $07ee			cmp		EXTScreenHeight				; check if row is within valid range
.8d00		b0 19		bcs $8d1b			bcs		_range_error
.8d02		48		pha				pha									; save it on the stack
.8d03		20 16 95	jsr $9516			jsr		CheckComma					; ensure the next character is a comma
.8d06		20 2b a4	jsr $a42b			jsr		Evaluate8BitInteger			; parse column into `A`
.8d09		cd ed 07	cmp $07ed			cmp		EXTScreenWidth				; check if column is within valid range
.8d0c		b0 0d		bcs $8d1b			bcs		_range_error
.8d0e		8d eb 07	sta $07eb			sta     EXTColumn					; save column into `EXTColumn`
.8d11		68		pla				pla                                 ; restore row into `A`
.8d12		8d ea 07	sta $07ea			sta     EXTRow						; save row into `EXTRow`
.8d15		5a		phy				phy
.8d16		20 6b 80	jsr $806b			jsr 	EXTSetCurrentLine         	; set current line address to `EXTRow`
.8d19		7a		ply		        ply
.8d1a		60		rts				rts
.8d1b						_range_error:
.8d1b		4c 0d a6	jmp $a60d			jmp 	RangeError 					; branch to range error handler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/let.asm

.8d1e						LetCommand:
.8d1e		a2 00		ldx #$00			ldx 	#0
.8d20		b1 30		lda ($30),y			lda 	(codePtr),y
.8d22		c9 10		cmp #$10			cmp 	#KWD_ATCH
.8d24		d0 14		bne $8d3a			bne 	_LCStandard
.8d26		c8		iny				iny 								; skip equal
.8d27		20 84 9e	jsr $9e84			jsr 	EvaluateTerm 				; get a number (the address of the reference)
.8d2a		20 fd 9c	jsr $9cfd			jsr 	Dereference 				; dereference it to a value
.8d2d		b5 50		lda $50,x			lda 	NSStatus,x 					; check integer
.8d2f		49 20		eor #$20			eor 	#NSBIsReference	 			; toggle reference
.8d31		95 50		sta $50,x			sta 	NSStatus,x
.8d33		29 20		and #$20			and 	#NSBIsReference 			; if it is now a reference, continue
.8d35		d0 0f		bne $8d46			bne 	_LCMain
.8d37		4c 12 a6	jmp $a612			jmp 	TypeError 					; was a reference before.
.8d3a						_LCStandard:
.8d3a		ad 19 9a	lda $9a19			lda 	PrecedenceLevel+"*"			; precedence > this
.8d3d		20 33 9a	jsr $9a33			jsr 	EvaluateExpressionAtPrecedence
.8d40		b5 50		lda $50,x			lda 	NSStatus,x 					; is it a reference to an array marked as procedure ?
.8d42		c9 38		cmp #$38			cmp		#NSTProcedure+NSBIsReference
.8d44		f0 0e		beq $8d54			beq 	_LetGoProc 					; it's a procedure call.
.8d46						_LCMain:
.8d46		a9 3d		lda #$3d			lda 	#"=" 						; check =
.8d48		20 1e 95	jsr $951e			jsr 	CheckNextA
.8d4b		e8		inx				inx 								; RHS
.8d4c		20 d5 a3	jsr $a3d5			jsr 	EvaluateValue
.8d4f		ca		dex				dex
.8d50		20 57 8d	jsr $8d57			jsr 	AssignVariable
.8d53		60		rts				rts
.8d54						_LetGoProc:
.8d54		4c a9 8f	jmp $8fa9			jmp 	CallProcedure
.8d57						AssignVariable:
.8d57		b5 50		lda $50,x			lda 	NSStatus,x 					; check the string/number type bits match
.8d59		48		pha				pha 								; save a copy
.8d5a		55 51		eor $51,x			eor 	NSStatus+1,x
.8d5c		29 10		and #$10			and 	#NSBIsString
.8d5e		d0 0b		bne $8d6b			bne 	_ASError
.8d60		68		pla				pla 								; get back
.8d61		29 10		and #$10			and 	#NSBIsString 				; check type
.8d63		d0 03		bne $8d68			bne 	_ASString
.8d65		4c 3b 9c	jmp $9c3b			jmp 	AssignNumber
.8d68						_ASString:
.8d68		4c 99 9c	jmp $9c99			jmp 	AssignString
.8d6b						_ASError:
.8d6b		4c 12 a6	jmp $a612			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/list.asm

.8d6e						Command_List:
.8d6e		9c 42 04	stz $0442			stz 	listIndent 					; reset indent.
.8d71		a9 3f		lda #$3f			lda 	#$3F 						; silence at list.
.8d73		20 75 80	jsr $8075			jsr 	SNDCommand
.8d76		b1 30		lda ($30),y			lda 	(codePtr),y
.8d78		29 c0		and #$c0			and 	#$C0 				 		; if so, we are list procedure() which is a seperate block
.8d7a		c9 40		cmp #$40			cmp 	#$40  						; of code.
.8d7c		f0 72		beq $8df0			beq 	_CLListProcedure
.8d7e		64 64		stz $64				stz		NSMantissa0+4				; set the lower (slot 4) to 0 and upper (slot 7) to $FFFF
.8d80		64 74		stz $74				stz 	NSMantissa1+4 				; these are the default top and bottom.
.8d82		a9 ff		lda #$ff			lda 	#$FF
.8d84		85 67		sta $67				sta 	NSMantissa0+7
.8d86		85 77		sta $77				sta 	NSMantissa1+7
.8d88		b1 30		lda ($30),y			lda 	(codePtr),y
.8d8a		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8d8c		f0 1a		beq $8da8			beq 	_CLSecond
.8d8e		20 76 8e	jsr $8e76			jsr 	CLIsDigit 					; if not digit, list all
.8d91		b0 20		bcs $8db3			bcs 	_CLStart
.8d93		a2 04		ldx #$04			ldx 	#4 							; get 1st range into slot 4
.8d95		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger
.8d98		b1 30		lda ($30),y			lda 	(codePtr),y
.8d9a		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8d9c		f0 0a		beq $8da8			beq 	_CLSecond 					; if so go get it
.8d9e		a5 64		lda $64				lda 	NSMantissa0+4 				; copy 4->7
.8da0		85 67		sta $67				sta 	NSMantissa0+7
.8da2		a5 74		lda $74				lda 	NSMantissa1+4
.8da4		85 77		sta $77				sta 	NSMantissa1+7
.8da6		80 0b		bra $8db3			bra 	_CLStart
.8da8						_CLSecond:
.8da8		c8		iny				iny 								; consume comma
.8da9		20 76 8e	jsr $8e76			jsr 	CLIsDigit 					; digit found
.8dac		b0 05		bcs $8db3			bcs 	_CLStart 					; if not, continue listing
.8dae		a2 07		ldx #$07			ldx 	#7 							; load 2nd range into slot 7
.8db0		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger
.8db3						_CLStart
.8db3		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8db5		85 30		sta $30				sta 	codePtr
.8db7		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8db9		85 31		sta $31				sta 	codePtr+1
.8dbb						_CLLoop:
.8dbb		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.8dbd		f0 03		beq $8dc2			beq 	_NoEvents					; if zero, skip with Z flag set.
.8dbf		20 62 81	jsr $8162			jsr 	ProcessEvents
.8dc2						_NoEvents:
.8dc2		d0 27		bne $8deb			bne 	_CLBreak
.8dc4		b2 30		lda ($30)			lda 	(codePtr)
.8dc6		f0 20		beq $8de8			beq 	_CLExit
.8dc8		a2 04		ldx #$04			ldx 	#4 							; check range every time, line numbers aren't in order.
.8dca		20 65 8e	jsr $8e65			jsr 	CLCompareLineNo
.8dcd		90 0c		bcc $8ddb			bcc 	_CLNext
.8dcf		a2 07		ldx #$07			ldx 	#7
.8dd1		20 65 8e	jsr $8e65			jsr 	CLCompareLineNo
.8dd4		f0 02		beq $8dd8			beq 	_CLDoThisOne
.8dd6		b0 03		bcs $8ddb			bcs 	_CLNext
.8dd8						_CLDoThisOne:
.8dd8		20 52 8e	jsr $8e52			jsr 	CLListOneLine 				; routine to list the current line.
.8ddb						_CLNext:
.8ddb		18		clc				clc
.8ddc		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8dde		65 30		adc $30				adc 	codePtr
.8de0		85 30		sta $30				sta 	codePtr
.8de2		90 02		bcc $8de6			bcc 	_CREExit
.8de4		e6 31		inc $31				inc 	codePtr+1 					; carry
.8de6						_CREExit:
.8de6		80 d3		bra $8dbb			bra 	_CLLoop
.8de8						_CLExit:
.8de8		4c 1c 89	jmp $891c			jmp 	WarmStart
.8deb						_CLBreak:
.8deb		a9 01		lda #$01		lda	#1
.8ded		4c 27 95	jmp $9527		jmp	ErrorHandler
.8df0						_CLListProcedure:
.8df0		b1 30		lda ($30),y			lda 	(codePtr),y
.8df2		85 38		sta $38				sta 	zTemp1
.8df4		c8		iny				iny
.8df5		b1 30		lda ($30),y			lda 	(codePtr),y
.8df7		85 39		sta $39				sta 	zTemp1+1
.8df9		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.8dfb		85 30		sta $30				sta 	codePtr
.8dfd		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.8dff		85 31		sta $31				sta 	codePtr+1
.8e01						_CLLPSearch:
.8e01		b2 30		lda ($30)			lda 	(codePtr)
.8e03		c9 00		cmp #$00			cmp 	#0 							; if zero, end
.8e05		f0 e1		beq $8de8			beq 	_CLExit
.8e07		a0 03		ldy #$03			ldy 	#3 							; check if PROC something
.8e09		b1 30		lda ($30),y			lda 	(codePtr),y
.8e0b		c9 b2		cmp #$b2			cmp 	#KWD_PROC
.8e0d		d0 0e		bne $8e1d			bne 	_CLLPNext
.8e0f		c8		iny				iny 								; check if PROC this.
.8e10		b1 30		lda ($30),y			lda 	(codePtr),y
.8e12		c5 38		cmp $38				cmp 	zTemp1 						; does it match ?
.8e14		d0 07		bne $8e1d			bne 	_CLLPNext
.8e16		c8		iny				iny
.8e17		b1 30		lda ($30),y			lda 	(codePtr),y
.8e19		c5 39		cmp $39				cmp 	zTemp1+1
.8e1b		f0 0d		beq $8e2a			beq 	_CLLPFound
.8e1d						_CLLPNext:
.8e1d		18		clc				clc
.8e1e		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e20		65 30		adc $30				adc 	codePtr
.8e22		85 30		sta $30				sta 	codePtr
.8e24		90 02		bcc $8e28			bcc 	_CREExit
.8e26		e6 31		inc $31				inc 	codePtr+1 					; carry
.8e28						_CREExit:
.8e28		80 d7		bra $8e01			bra 	_CLLPSearch
.8e2a						_CLLPFound:
.8e2a		b2 30		lda ($30)			lda 	(codePtr)
.8e2c		f0 ba		beq $8de8			beq 	_CLExit
.8e2e		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.8e30		f0 03		beq $8e35			beq 	_NoEvents					; if zero, skip with Z flag set.
.8e32		20 62 81	jsr $8162			jsr 	ProcessEvents
.8e35						_NoEvents:
.8e35		d0 b4		bne $8deb			bne 	_CLBreak
.8e37		a0 03		ldy #$03			ldy 	#3 							; get first keyword
.8e39		b1 30		lda ($30),y			lda 	(codePtr),y
.8e3b		48		pha				pha
.8e3c		20 52 8e	jsr $8e52			jsr 	CLListOneLine 				; list line and go forward
.8e3f		18		clc				clc
.8e40		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.8e42		65 30		adc $30				adc 	codePtr
.8e44		85 30		sta $30				sta 	codePtr
.8e46		90 02		bcc $8e4a			bcc 	_CREExit
.8e48		e6 31		inc $31				inc 	codePtr+1 					; carry
.8e4a						_CREExit:
.8e4a		68		pla				pla 								; reached ENDPROC ?
.8e4b		c9 b6		cmp #$b6			cmp 	#KWD_ENDPROC
.8e4d		d0 db		bne $8e2a			bne 	_CLLPFound
.8e4f		4c 1c 89	jmp $891c			jmp 	WarmStart
.8e52						CLListOneLine:
.8e52		20 cc 94	jsr $94cc			jsr 	ScanGetCurrentLineStep 		; get indent adjust.
.8e55		20 93 80	jsr $8093			jsr 	TKListConvertLine 			; convert line into token Buffer
.8e58		a2 04		ldx #$04			ldx 	#(tokenBuffer >> 8) 		; print that line
.8e5a		a9 49		lda #$49			lda 	#(tokenBuffer & $FF)
.8e5c		20 86 95	jsr $9586			jsr 	PrintStringXA
.8e5f		a9 0d		lda #$0d			lda 	#13 						; new line
.8e61		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.8e64		60		rts				rts
.8e65						CLCompareLineNo:
.8e65		38		sec				sec
.8e66		a0 01		ldy #$01			ldy 	#1
.8e68		b1 30		lda ($30),y			lda 	(codePtr),y
.8e6a		f5 60		sbc $60,x			sbc 	NSMantissa0,x
.8e6c		85 36		sta $36				sta 	zTemp0
.8e6e		c8		iny				iny
.8e6f		b1 30		lda ($30),y			lda 	(codePtr),y
.8e71		f5 70		sbc $70,x			sbc 	NSMantissa1,x
.8e73		05 36		ora $36				ora 	zTemp0
.8e75		60		rts				rts
.8e76						CLIsDigit:
.8e76		b1 30		lda ($30),y			lda 	(codePtr),y
.8e78		c9 30		cmp #$30			cmp 	#"0"
.8e7a		90 03		bcc $8e7f			bcc	 	_CLIDExitFalse
.8e7c		c9 3a		cmp #$3a			cmp 	#"9"+1
.8e7e		60		rts				rts
.8e7f						_CLIDExitFalse:
.8e7f		38		sec				sec
.8e80		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/local.asm

.8e81						Command_LOCAL:
.8e81		a2 00		ldx #$00			ldx 	#0 							; at level 0
.8e83		20 8f 8e	jsr $8e8f			jsr 	LocaliseNextTerm 			; convert term to a local.
.8e86		b1 30		lda ($30),y			lda 	(codePtr),y
.8e88		c8		iny				iny
.8e89		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.8e8b		f0 f4		beq $8e81			beq 	Command_LOCAL 				; if so, localise another variable.
.8e8d		88		dey				dey 								; unpick pre-get
.8e8e		60		rts				rts
.8e8f						LocaliseNextTerm:
.8e8f		20 84 9e	jsr $9e84			jsr 	EvaluateTerm 				; evaluate the term
.8e92		b5 50		lda $50,x			lda 	NSStatus,x
.8e94		29 20		and #$20			and 	#NSBIsReference 			; check it is a reference, must be a variable.
.8e96		f0 5c		beq $8ef4			beq		_LNTError
.8e98		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy address of variable to zTemp0
.8e9a		85 36		sta $36				sta 	zTemp0
.8e9c		b5 70		lda $70,x			lda 	NSMantissa1,x
.8e9e		85 37		sta $37				sta  	zTemp0+1
.8ea0		b5 50		lda $50,x			lda 	NSStatus,x 					; figure out what it is.
.8ea2		29 10		and #$10			and 	#NSBIsString
.8ea4		d0 1e		bne $8ec4			bne 	_LNTPushString
.8ea6		5a		phy				phy
.8ea7		a0 00		ldy #$00			ldy 	#0 							; push 0 to 4 inclusive, the number values, on the stack, and zero them as you go.
.8ea9						_LNTPushNumLoop:
.8ea9		b1 36		lda ($36),y			lda		(zTemp0),y
.8eab		20 b6 b6	jsr $b6b6			jsr 	StackPushByte
.8eae		c8		iny				iny
.8eaf		c0 05		cpy #$05			cpy 	#5
.8eb1		d0 f6		bne $8ea9			bne 	_LNTPushNumLoop
.8eb3		a5 36		lda $36				lda 	zTemp0 						; push the actual target address to write on the stack
.8eb5		20 b6 b6	jsr $b6b6			jsr 	StackPushByte
.8eb8		a5 37		lda $37				lda 	zTemp0+1
.8eba		20 b6 b6	jsr $b6b6			jsr 	StackPushByte
.8ebd		a9 01		lda #$01			lda 	#STK_LOCALN 				; push local-number marker.
.8ebf		20 b6 b6	jsr $b6b6			jsr 	StackPushByte
.8ec2		7a		ply				ply
.8ec3		60		rts				rts
.8ec4						_LNTPushString:
.8ec4		5a		phy				phy
.8ec5		b2 36		lda ($36)			lda 	(zTemp0) 					; put address of string in zTemp1
.8ec7		85 38		sta $38				sta 	zTemp1
.8ec9		a0 01		ldy #$01			ldy 	#1
.8ecb		b1 36		lda ($36),y			lda 	(zTemp0),y
.8ecd		85 39		sta $39				sta 	zTemp1+1
.8ecf		a0 00		ldy #$00			ldy 	#0 							; output string
.8ed1		c9 00		cmp #$00			cmp 	#0 							; if not assigned string
.8ed3		f0 0a		beq $8edf			beq 	_LNTStringOut
.8ed5						_LNTPushStrLoop:
.8ed5		b1 38		lda ($38),y			lda 	(zTemp1),y
.8ed7		f0 06		beq $8edf			beq 	_LNTStringOut
.8ed9		20 b6 b6	jsr $b6b6			jsr 	StackPushByte
.8edc		c8		iny				iny
.8edd		80 f6		bra $8ed5			bra 	_LNTPushStrLoop
.8edf						_LNTStringOut:
.8edf		98		tya				tya									; output length (chars written).
.8ee0		20 b6 b6	jsr $b6b6			jsr 	StackPushByte
.8ee3		b5 60		lda $60,x			lda 	NSMantissa0,x 				; output address of the string record *not* the string itself
.8ee5		20 b6 b6	jsr $b6b6			jsr 	StackPushByte
.8ee8		b5 70		lda $70,x			lda 	NSMantissa1,x
.8eea		20 b6 b6	jsr $b6b6			jsr 	StackPushByte
.8eed		a9 02		lda #$02			lda 	#STK_LOCALS 				; push local-string marker.
.8eef		20 b6 b6	jsr $b6b6			jsr 	StackPushByte
.8ef2		7a		ply				ply
.8ef3		60		rts				rts
.8ef4						_LNTError:
.8ef4		4c 08 a6	jmp $a608			jmp 	SyntaxError
.8ef7						LocalPopValue:
.8ef7		20 ce b6	jsr $b6ce			jsr 	StackPopByte
.8efa		c9 01		cmp #$01			cmp 	#STK_LOCALN 				; if not local-N
.8efc		d0 17		bne $8f15			bne 	_LPVString
.8efe		20 ce b6	jsr $b6ce			jsr 	StackPopByte 				; address
.8f01		85 37		sta $37				sta 	zTemp0+1
.8f03		20 ce b6	jsr $b6ce			jsr 	StackPopByte
.8f06		85 36		sta $36				sta 	zTemp0
.8f08		5a		phy				phy
.8f09		a0 04		ldy #$04			ldy 	#4 							; copy back
.8f0b						_LPVNumberCopy:
.8f0b		20 ce b6	jsr $b6ce			jsr 	StackPopByte
.8f0e		91 36		sta ($36),y			sta 	(zTemp0),y
.8f10		88		dey				dey
.8f11		10 f8		bpl $8f0b			bpl 	_LPVNumberCopy
.8f13		7a		ply				ply 								; and complete
.8f14		60		rts				rts
.8f15						_LPVString:
.8f15		20 ce b6	jsr $b6ce			jsr 	StackPopByte 				; address of record copied to zTemp0
.8f18		85 37		sta $37				sta 	zTemp0+1
.8f1a		20 ce b6	jsr $b6ce			jsr 	StackPopByte
.8f1d		85 36		sta $36				sta 	zTemp0
.8f1f		5a		phy				phy
.8f20		b2 36		lda ($36)			lda 	(zTemp0) 					; address to write string to copied to zTemp1
.8f22		85 38		sta $38				sta 	zTemp1
.8f24		a0 01		ldy #$01			ldy 	#1
.8f26		b1 36		lda ($36),y			lda 	(zTemp0),y
.8f28		85 39		sta $39				sta 	zTemp1+1
.8f2a		20 ce b6	jsr $b6ce			jsr 	StackPopByte 				; # chars to get => y
.8f2d		a8		tay				tay
.8f2e		a5 39		lda $39				lda 	zTemp1+1 					; if no target (e.g. was "" originally) exit
.8f30		f0 0e		beq $8f40			beq 	_LPVStringCopied
.8f32		a9 00		lda #$00			lda 	#0 							; NULL on end
.8f34		91 38		sta ($38),y			sta 	(zTemp1),y
.8f36						_LPVStringCopy:
.8f36		88		dey				dey
.8f37		30 07		bmi $8f40			bmi 	_LPVStringCopied
.8f39		20 ce b6	jsr $b6ce			jsr 	StackPopByte
.8f3c		91 38		sta ($38),y			sta 	(zTemp1),y
.8f3e		80 f6		bra $8f36			bra 	_LPVStringCopy
.8f40						_LPVStringCopied:
.8f40		fa		plx				plx
.8f41		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/new.asm

.8f42						NewCommand:
.8f42		20 aa 88	jsr $88aa			jsr		IsDestructiveActionOK
.8f45		b0 03		bcs $8f4a			bcs		_not_ok
.8f47		20 4d 8f	jsr $8f4d			jsr 	NewProgram 					; does the actual NEW.
.8f4a						_not_ok:
.8f4a		4c 1c 89	jmp $891c			jmp 	WarmStart 					; and warm starts straight away.
.8f4d						NewProgram:
.8f4d		20 d1 a8	jsr $a8d1			jsr 	MemoryNew
.8f50		9c 00 10	stz $1000			stz 	VariableSpace 				; erase all variables.
.8f53		20 b3 93	jsr $93b3			jsr 	ClearSystem					; clear everything.
.8f56		9c 75 06	stz $0675			stz		programChanged
.8f59		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/option.asm

.8f5a						OptionCommand:
.8f5a		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8f5c		20 2b a4	jsr $a42b			jsr		Evaluate8BitInteger 		; address
.8f5f		48		pha				pha
.8f60		20 16 95	jsr $9516			jsr 	CheckComma
.8f63		e8		inx				inx
.8f64		20 2b a4	jsr $a42b			jsr		Evaluate8BitInteger 		; data
.8f67		fa		plx				plx
.8f68		9d 00 04	sta $0400,x			sta 	ControlStorage,x
.8f6b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/poke.asm

.8f6c						PokeBCommand:
.8f6c		a9 01		lda #$01			lda 	#1
.8f6e		80 0c		bra $8f7c			bra 	PokeCommand
.8f70						PokeWCommand:
.8f70		a9 02		lda #$02			lda 	#2
.8f72		80 08		bra $8f7c			bra 	PokeCommand
.8f74						PokeLCommand:
.8f74		a9 03		lda #$03			lda 	#3
.8f76		80 04		bra $8f7c			bra 	PokeCommand
.8f78						PokeDCommand:
.8f78		a9 04		lda #$04			lda 	#4
.8f7a		80 00		bra $8f7c			bra 	PokeCommand
.8f7c						PokeCommand:
.8f7c		48		pha				pha 								; save count on stack
.8f7d		a2 00		ldx #$00			ldx 	#0 							; bottom of stack
.8f7f		20 10 a4	jsr $a410			jsr		Evaluate16BitInteger 		; address
.8f82		20 16 95	jsr $9516			jsr 	CheckComma
.8f85		e8		inx				inx
.8f86		20 fd a3	jsr $a3fd			jsr		EvaluateInteger 			; data
.8f89		a5 60		lda $60				lda 	NSMantissa0 				; copy address
.8f8b		85 36		sta $36				sta 	zTemp0
.8f8d		a5 70		lda $70				lda 	NSMantissa1
.8f8f		85 37		sta $37				sta 	zTemp0+1
.8f91		68		pla				pla 								; count -> zTemp1
.8f92		85 38		sta $38				sta 	zTemp1
.8f94		5a		phy				phy 								; save Y position.
.8f95		a0 00		ldy #$00			ldy 	#0 							; index to write
.8f97		a2 00		ldx #$00			ldx 	#0 							; index to read
.8f99						_PCLoop:
.8f99		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; read byte from mantissa and copy out
.8f9b		91 36		sta ($36),y			sta 	(zTemp0),y
.8f9d		c8		iny				iny 								; next byte to write
.8f9e		8a		txa				txa 								; next byte to read - stack layout in 04data.inc
.8f9f		18		clc				clc
.8fa0		69 10		adc #$10			adc 	#MathStackSize
.8fa2		aa		tax				tax
.8fa3		c6 38		dec $38				dec 	zTemp1 						; done them all
.8fa5		d0 f2		bne $8f99			bne 	_PCLoop
.8fa7		7a		ply				ply 								; restore position.
.8fa8		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/procedure.asm

=2						ParameterStackPos = 2
.8fa9						CallProcedure:
.8fa9		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start storing parameters at 2.
.8fab		b1 30		lda ($30),y			lda 	(codePtr),y
.8fad		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.8faf		f0 10		beq $8fc1			beq 	_CPEndParam
.8fb1						_CPParamLoop:
.8fb1		20 d5 a3	jsr $a3d5			jsr 	EvaluateValue 				; get parameter onto stack
.8fb4		e8		inx				inx 								; bump next stack
.8fb5		e0 10		cpx #$10			cpx		#MathStackSize				; check if parameters overflow stack
.8fb7		b0 52		bcs $900b			bge		_TooManyParam
.8fb9		b1 30		lda ($30),y			lda 	(codePtr),y
.8fbb		c8		iny				iny
.8fbc		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if comma, go back and try again.
.8fbe		f0 f1		beq $8fb1			beq 	_CPParamLoop
.8fc0		88		dey				dey 								; unpick.
.8fc1						_CPEndParam:
.8fc1		8e 32 04	stx $0432			stx 	lastParameter 				; save the last parameters index.
.8fc4		c8		iny				iny									; skip right bracket
.8fc5		a9 b3		lda #$b3			lda 	#STK_PROC+3 				; allocate 6 bytes on the return stack.
.8fc7		20 d7 b6	jsr $b6d7			jsr 	StackOpen
.8fca		20 1c b7	jsr $b71c			jsr 	STKSaveCodePosition 		; save loop position
.8fcd		a5 60		lda $60				lda 	NSMantissa0 				; copy variable (e.g. procedure) address to zTemp0
.8fcf		85 36		sta $36				sta 	zTemp0 						; this is the DATA not the RECORD
.8fd1		a5 70		lda $70				lda 	NSMantissa1
.8fd3		85 37		sta $37				sta 	zTemp0+1
.8fd5		a0 01		ldy #$01			ldy 	#1 							; copy code address back.
.8fd7		b2 36		lda ($36)			lda 	(zTemp0)
.8fd9		85 30		sta $30				sta 	safePtr
.8fdb		b1 36		lda ($36),y			lda 	(zTemp0),y
.8fdd		85 31		sta $31				sta 	safePtr+1
.8fdf		c8		iny				iny
.8fe0		b1 36		lda ($36),y			lda 	(zTemp0),y
.8fe2		85 32		sta $32				sta 	safePtr+2
.8fe4		c8		iny				iny
.8fe5		b1 36		lda ($36),y			lda 	(zTemp0),y
.8fe7		85 33		sta $33				sta 	safePtr+3
.8fe9		c8		iny				iny 								; get Y offset -> Y
.8fea		b1 36		lda ($36),y			lda 	(zTemp0),y
.8fec		a8		tay				tay
.8fed		a2 02		ldx #$02			ldx 	#ParameterStackPos 			; start position of parameters
.8fef		ec 32 04	cpx $0432			cpx	 	lastParameter 				; check zero parameters at the start
.8ff2		f0 13		beq $9007			beq 	_ParamExit 					; if so, exit.
.8ff4						_ParamExtract:
.8ff4		ca		dex				dex 								; put a local term on the level before
.8ff5		20 8f 8e	jsr $8e8f			jsr 	LocaliseNextTerm			; also pushes original param value to basic stack
.8ff8		20 57 8d	jsr $8d57			jsr 	AssignVariable 				; assign stacked value to the variable.
.8ffb		e8		inx				inx 								; advance to next parameter to do.
.8ffc		e8		inx				inx
.8ffd		ec 32 04	cpx $0432			cpx 	lastParameter 				; are we done ?
.9000		f0 05		beq $9007			beq 	_ParamExit
.9002		20 16 95	jsr $9516			jsr 	CheckComma 					; comma seperating parameters
.9005		80 ed		bra $8ff4			bra 	_ParamExtract
.9007						_ParamExit:
.9007		20 0e 95	jsr $950e			jsr 	CheckRightBracket 			; check )
.900a		60		rts				rts 								; and continue from here
.900b						_TooManyParam:
.900b								error
.900b		a9 1d		lda #$1d		lda	#29
.900d		4c 27 95	jmp $9527		jmp	ErrorHandler
.9010						Command_ENDPROC:
.9010		a9 b0		lda #$b0			lda 	#STK_PROC 					; check TOS is this
.9012		a2 14		ldx #$14			ldx 	#ERRID_PROC
.9014		20 04 b7	jsr $b704			jsr 	StackCheckFrame
.9017		20 2d b7	jsr $b72d			jsr 	STKLoadCodePosition 		; restore code position
.901a		20 f6 b6	jsr $b6f6			jsr 	StackClose
.901d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/read.asm

.901e						Command_Read:
.901e		a2 00		ldx #$00			ldx 	#0 							; evaluate the term which is the var/array element to assign
.9020		20 84 9e	jsr $9e84			jsr 	EvaluateTerm
.9023		b5 50		lda $50,x			lda 	NSStatus,x
.9025		29 20		and #$20			and 	#NSBIsReference				; get status byte on stack, identifies int, float, string.
.9027		f0 4f		beq $9078			beq 	_CRSyntax 					; check reference (bit 0) fail if not a reference.
.9029		20 c1 90	jsr $90c1			jsr 	SwapDataCodePtrs 			; swap code and data
.902c		ad 38 04	lda $0438			lda 	inDataStatement 			; if in a data statement, we don't need to search
.902f		d0 25		bne $9056			bne 	_CRContinueData  			; forward for the next one.
.9031		b2 30		lda ($30)			lda 	(codePtr)
.9033		f0 1c		beq $9051			beq 	_CRNoData
.9035						_CRKeepSearching:
.9035		a9 c2		lda #$c2			lda 	#KWD_DATA 					; scan for instruction
.9037		a2 80		ldx #$80			ldx 	#KWC_EOL
.9039		20 69 94	jsr $9469			jsr 	ScanForward
.903c		c9 c2		cmp #$c2			cmp 	#KWD_DATA 					; found data ?
.903e		f0 16		beq $9056			beq 	_CRHaveData 				; found it
.9040		18		clc				clc
.9041		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.9043		65 30		adc $30				adc 	codePtr
.9045		85 30		sta $30				sta 	codePtr
.9047		90 02		bcc $904b			bcc 	_CREExit
.9049		e6 31		inc $31				inc 	codePtr+1 					; carry
.904b						_CREExit:
.904b		a0 03		ldy #$03			ldy 	#3 							; start of line.
.904d		b2 30		lda ($30)			lda 	(codePtr)
.904f		d0 e4		bne $9035			bne 	_CRKeepSearching
.9051						_CRNoData:
.9051		a9 0b		lda #$0b		lda	#11
.9053		4c 27 95	jmp $9527		jmp	ErrorHandler
.9056						_CRHaveData:
.9056						_CRContinueData:
.9056		a2 01		ldx #$01			ldx 	#1
.9058		20 d5 a3	jsr $a3d5			jsr 	EvaluateValue 				; evaluate value into slot # 1
.905b		ca		dex				dex
.905c		20 57 8d	jsr $8d57			jsr		AssignVariable 				; do the assignment
.905f		9c 38 04	stz $0438			stz 	inDataStatement 			; clear in data flag
.9062		b1 30		lda ($30),y			lda 	(codePtr),y
.9064		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; if not, end of data statement and exit
.9066		d0 04		bne $906c			bne 	_CRSwapBack
.9068		c8		iny				iny 								; consume comma
.9069		ee 38 04	inc $0438			inc 	inDataStatement 			; set in data statement currently.
.906c						_CRSwapBack:
.906c		20 c1 90	jsr $90c1			jsr 	SwapDataCodePtrs			; swap them back.
.906f		b1 30		lda ($30),y			lda 	(codePtr),y
.9071		c8		iny				iny
.9072		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9074		f0 a8		beq $901e			beq 	Command_Read 				; if so go round again.
.9076		88		dey				dey 								; unpick get.
.9077		60		rts				rts
.9078						_CRSyntax:
.9078		4c 08 a6	jmp $a608			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/rem.asm

.907b						RemCommand:
.907b		b1 30		lda ($30),y			lda 	(codePtr),y
.907d		c9 ff		cmp #$ff			cmp 	#KWC_STRING
.907f		d0 06		bne $9087			bne 	_RMExit
.9081		c8		iny				iny 								; point to offset
.9082		98		tya				tya 								; A = offset position
.9083		38		sec				sec 								; add size +1 hence SEC
.9084		71 30		adc ($30),y			adc 	(codePtr),y
.9086		a8		tay				tay 								; make current position.
.9087						_RMExit:
.9087		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/repeat.asm

.9088						Command_REPEAT:
.9088		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; allocate 6 bytes on the return stack.
.908a		20 d7 b6	jsr $b6d7			jsr 	StackOpen
.908d		20 1c b7	jsr $b71c			jsr 	STKSaveCodePosition 		; save loop position
.9090		60		rts				rts
.9091						Command_UNTIL:
.9091		a9 c3		lda #$c3			lda 	#STK_REPEAT+3 				; check REPEAT is TOS
.9093		a2 0f		ldx #$0f			ldx 	#ERRID_REPEAT 				; this error
.9095		20 04 b7	jsr $b704			jsr 	StackCheckFrame
.9098		a2 00		ldx #$00			ldx 	#0
.909a		20 de a3	jsr $a3de			jsr 	EvaluateNumber 				; work out the number
.909d		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; check if zero
.90a0		f0 04		beq $90a6			beq 	_CULoopBack 				; if so keep looping
.90a2		20 f6 b6	jsr $b6f6			jsr 	StackClose		 			; return
.90a5		60		rts				rts
.90a6						_CULoopBack:
.90a6		20 2d b7	jsr $b72d			jsr 	STKLoadCodePosition 		; loop back
.90a9		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/restore.asm

.90aa						Command_Restore:
.90aa		20 c1 90	jsr $90c1			jsr 	SwapDataCodePtrs 			; swap code and data
.90ad		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.90af		85 30		sta $30				sta 	codePtr
.90b1		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.90b3		85 31		sta $31				sta 	codePtr+1
.90b5		20 c1 90	jsr $90c1			jsr 	SwapDataCodePtrs 			; put them back
.90b8		a9 03		lda #$03			lda 	#3 							; start at offset 3, e.g. first instruction of first line.
.90ba		8d 37 04	sta $0437			sta 	dataPointer+4   			; (read checks not EOF)
.90bd		9c 38 04	stz $0438			stz 	inDataStatement 			; not in data statement
.90c0		60		rts				rts
.90c1						SwapDataCodePtrs:
.90c1		da		phx				phx
.90c2		a2 03		ldx #$03			ldx 	#3 							; swap 32 bit code pointer over
.90c4						_SDCPLoop:
.90c4		b5 30		lda $30,x			lda 	safePtr,x
.90c6		48		pha				pha
.90c7		bd 33 04	lda $0433,x			lda 	dataPointer,x
.90ca		95 30		sta $30,x			sta 	safePtr,x
.90cc		68		pla				pla
.90cd		9d 33 04	sta $0433,x			sta 	dataPointer,x
.90d0		ca		dex				dex
.90d1		10 f1		bpl $90c4			bpl 	_SDCPLoop
.90d3		ad 37 04	lda $0437			lda 	dataPointer+4 				; swap Y position over.
.90d6		8c 37 04	sty $0437			sty 	dataPointer+4
.90d9		a8		tay				tay
.90da		fa		plx				plx
.90db		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/run.asm

.90dc						EOLCommand:
.90dc		18		clc				clc
.90dd		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.90df		65 30		adc $30				adc 	codePtr
.90e1		85 30		sta $30				sta 	codePtr
.90e3		90 02		bcc $90e7			bcc 	_CREExit
.90e5		e6 31		inc $31				inc 	codePtr+1 					; carry
.90e7						_CREExit:
.90e7		80 18		bra $9101			bra 	RunNewLine
.90e9						CommandRUNOptLoad:
.90e9		b1 30		lda ($30),y			lda 	(codePtr),y
.90eb		c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL / : just RUN
.90ed		f0 07		beq $90f6			beq 	RunCurrentProgram
.90ef		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.90f1		f0 03		beq $90f6			beq 	RunCurrentProgram
.90f3		20 4d b0	jsr $b04d			jsr 	LoadFile 					; load expected name file.
.90f6						RunCurrentProgram:
.90f6		20 b3 93	jsr $93b3			jsr 	ClearSystem 				; clear variable/stacks/etc.
.90f9		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.90fb		85 30		sta $30				sta 	codePtr
.90fd		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.90ff		85 31		sta $31				sta 	codePtr+1
.9101						RunNewLine:
.9101		b2 30		lda ($30)			lda 	(codePtr)
.9103		f0 74		beq $9179			beq 	CRNoProgram         		; no then END.
.9105		a2 ff		ldx #$ff			ldx 	#$FF 						; reset stack
.9107		9a		txs				txs
.9108						RUNCodePointerLine:
.9108		a0 02		ldy #$02			ldy 	#2 							; start of program
.910a						_CRIncMainLoop:
.910a		a5 f2		lda $f2				lda 	kernel.args.events.pending 	; load pending event count into accumulator
.910c		f0 03		beq $9111			beq 	_NoEvents					; if zero, skip with Z flag set.
.910e		20 62 81	jsr $8162			jsr 	ProcessEvents
.9111						_NoEvents:
.9111		d0 61		bne $9174			bne 	_CRBreak
.9113		a5 01		lda $01				lda 	1 							; save I/O 0
.9115		48		pha				pha
.9116		64 01		stz $01				stz 	1 							; access I/O Page 0
.9118		38		sec				sec 								; calculate timer - LastTick
.9119		ad 59 d6	lda $d659			lda 	$D659
.911c		cd 81 06	cmp $0681			cmp 	LastTick
.911f		f0 06		beq $9127			beq 	_NoFireTick 				; if < 3 clocks don't fire.
.9121		8d 81 06	sta $0681			sta 	LastTick 					; update last timer
.9124		20 f8 82	jsr $82f8			jsr 	TickHandler 							; go do the code.
.9127						_NoFireTick:
.9127		68		pla				pla 								; restore I/O 0
.9128		85 01		sta $01				sta 	1
.912a						_CRNoBreakCheck:
.912a		c8		iny				iny									; next token
.912b						_CRMainLoop:
.912b		9c 2c 04	stz $042c			stz 	stringInitialised 			; clear the temporary string initialised flag.
.912e		b1 30		lda ($30),y			lda 	(codePtr),y
.9130		10 10		bpl $9142			bpl 	_CRNotKeyword				; not a token.
.9132		c9 b0		cmp #$b0			cmp 	#KWC_LAST_UNARY+1 			; if after unary, legitimate command
.9134		b0 04		bcs $913a			bcs 	_CRIsKeyword
.9136		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if unary, syntax error.
.9138		b0 34		bcs $916e			bcs		_CRSyntaxError
.913a						_CRIsKeyword:
.913a		c8		iny				iny 								; consume command
.913b		0a		asl a				asl 	a 							; double losing the MSB which is '1' as tokens are $80-$FF
.913c		aa		tax				tax 								; put in X for vector jump
.913d		20 71 91	jsr $9171			jsr 	_CRCallVector0 				; call the vector - effectively jsr (vectortable,X)
.9140		80 e9		bra $912b			bra 	_CRMainLoop 				; and loop round
.9142						_CRNotKeyword:
.9142		c9 3a		cmp #$3a			cmp 	#KWD_COLON 					; if a :, consume it and go round.
.9144		f0 c4		beq $910a			beq 	_CRIncMainLoop
.9146		c9 40		cmp #$40			cmp 	#$40 						; variable/call reference
.9148		90 05		bcc $914f			bcc 	_CRNotVariable
.914a						_CRGoLet:
.914a		20 1e 8d	jsr $8d1e			jsr 	LetCommand
.914d		80 dc		bra $912b			bra 	_CRMainLoop
.914f						_CRNotVariable:
.914f		c9 10		cmp #$10			cmp 	#KWD_ATCH 					; handle @
.9151		f0 f7		beq $914a			beq 	_CRGoLet
.9153		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; handle ? !
.9155		f0 f3		beq $914a			beq 	_CRGoLet
.9157		c9 21		cmp #$21			cmp 	#KWD_PLING
.9159		f0 ef		beq $914a			beq 	_CRGoLet
.915b		c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; handle ' (comment)
.915d		f0 09		beq $9168			beq 	_CRGoRem
.915f		c9 2e		cmp #$2e			cmp 	#KWD_PERIOD 				; handle . (assembler label)
.9161		d0 0b		bne $916e			bne 	_CRSyntaxError
.9163		20 da 86	jsr $86da			jsr 	LabelHere
.9166		80 c3		bra $912b			bra 	_CRMainLoop
.9168						_CRGoRem:
.9168		c8		iny				iny
.9169		20 7b 90	jsr $907b			jsr 	RemCommand
.916c		80 bd		bra $912b			bra 	_CRMainLoop
.916e						_CRSyntaxError:
.916e		4c 08 a6	jmp $a608			jmp 	SyntaxError
.9171						_CRCallVector0:
.9171		7c 10 92	jmp ($9210,x)			jmp 	(VectorSet0,x)
.9174						_CRBreak:
.9174		a9 01		lda #$01		lda	#1
.9176		4c 27 95	jmp $9527		jmp	ErrorHandler
.9179						CRNoProgram:
.9179		4c 85 8a	jmp $8a85			jmp 	EndCommand
.917c						Shift1Command:
.917c		b1 30		lda ($30),y			lda 	(codePtr),y
.917e		c8		iny				iny
.917f		0a		asl a				asl 	a
.9180		aa		tax				tax
.9181		7c ce 92	jmp ($92ce,x)			jmp 	(VectorSet1,x)
.9184						Shift2Command:
.9184		b1 30		lda ($30),y			lda 	(codePtr),y
.9186		c8		iny				iny
.9187		0a		asl a				asl 	a
.9188		aa		tax				tax
.9189		7c 26 93	jmp ($9326,x)			jmp 	(VectorSet2,x)
.918c						Unused1:
.918c						Unused2:
.918c						Unused3:
.918c						Unused4:
.918c		4c 08 a6	jmp $a608			jmp 	SyntaxError
>918f								.align 2

;******  Processing file: ./common/commands/../generated/vectors.dat

.9190						VectorSetPunc:
>9190		e5 97					.word	ShiftLeft                        ; $00 <<
>9192		d0 95					.word	BinaryCompareLessEqual           ; $01 <=
>9194		c6 95					.word	BinaryCompareNotEqual            ; $02 <>
>9196		08 a6					.word	SyntaxError                      ; $03 !!3
>9198		08 a6					.word	SyntaxError                      ; $04 ><
>919a		da 95					.word	BinaryCompareGreaterEqual        ; $05 >=
>919c		e8 97					.word	ShiftRight                       ; $06 >>
>919e		08 a6					.word	SyntaxError                      ; $07 !!7
>91a0		08 a6					.word	SyntaxError                      ; $08 !!8
>91a2		08 a6					.word	SyntaxError                      ; $09 !!9
>91a4		08 a6					.word	SyntaxError                      ; $0a !!10
>91a6		08 a6					.word	SyntaxError                      ; $0b !!11
>91a8		08 a6					.word	SyntaxError                      ; $0c !!12
>91aa		08 a6					.word	SyntaxError                      ; $0d !!13
>91ac		08 a6					.word	SyntaxError                      ; $0e !!14
>91ae		08 a6					.word	SyntaxError                      ; $0f !!15
>91b0		08 a6					.word	SyntaxError                      ; $10 @
>91b2		08 a6					.word	SyntaxError                      ; $11 !!17
>91b4		08 a6					.word	SyntaxError                      ; $12 !!18
>91b6		08 a6					.word	SyntaxError                      ; $13 [
>91b8		91 96					.word	IntegerDivide                    ; $14 \
>91ba		08 a6					.word	SyntaxError                      ; $15 ]
>91bc		23 99					.word	EorInteger                       ; $16 ^
>91be		08 a6					.word	SyntaxError                      ; $17 _
>91c0		08 a6					.word	SyntaxError                      ; $18 `
>91c2		08 a6					.word	SyntaxError                      ; $19 !!25
>91c4		08 a6					.word	SyntaxError                      ; $1a !!26
>91c6		08 a6					.word	SyntaxError                      ; $1b {
>91c8		ee 98					.word	OraInteger                       ; $1c |
>91ca		08 a6					.word	SyntaxError                      ; $1d }
>91cc		08 a6					.word	SyntaxError                      ; $1e ~
>91ce		08 a6					.word	SyntaxError                      ; $1f <7F>
>91d0		08 a6					.word	SyntaxError                      ; $20
>91d2		58 99					.word	WordIndirect                     ; $21 !
>91d4		08 a6					.word	SyntaxError                      ; $22 "
>91d6		08 a6					.word	SyntaxError                      ; $23 #
>91d8		08 a6					.word	SyntaxError                      ; $24 $
>91da		d2 96					.word	IntegerModulus                   ; $25 %
>91dc		b9 98					.word	AndInteger                       ; $26 &
>91de		08 a6					.word	SyntaxError                      ; $27 '
>91e0		08 a6					.word	SyntaxError                      ; $28 (
>91e2		08 a6					.word	SyntaxError                      ; $29 )
>91e4		40 97					.word	MulInteger                       ; $2a *
>91e6		5b 98					.word	AddInteger                       ; $2b +
>91e8		08 a6					.word	SyntaxError                      ; $2c ,
>91ea		94 98					.word	SubInteger                       ; $2d -
>91ec		08 a6					.word	SyntaxError                      ; $2e .
>91ee		1b 9b					.word	FDivideCommand                   ; $2f /
>91f0		08 a6					.word	SyntaxError                      ; $30 0
>91f2		08 a6					.word	SyntaxError                      ; $31 1
>91f4		08 a6					.word	SyntaxError                      ; $32 2
>91f6		08 a6					.word	SyntaxError                      ; $33 3
>91f8		08 a6					.word	SyntaxError                      ; $34 4
>91fa		08 a6					.word	SyntaxError                      ; $35 5
>91fc		08 a6					.word	SyntaxError                      ; $36 6
>91fe		08 a6					.word	SyntaxError                      ; $37 7
>9200		08 a6					.word	SyntaxError                      ; $38 8
>9202		08 a6					.word	SyntaxError                      ; $39 9
>9204		08 a6					.word	SyntaxError                      ; $3a :
>9206		08 a6					.word	SyntaxError                      ; $3b ;
>9208		b2 95					.word	BinaryCompareLess                ; $3c <
>920a		a8 95					.word	BinaryCompareEqual               ; $3d =
>920c		bc 95					.word	BinaryCompareGreater             ; $3e >
>920e		7a 99					.word	ByteIndirect                     ; $3f ?
.9210						VectorSet0:
>9210		dc 90					.word	EOLCommand                       ; $80 !0:EOF
>9212		7c 91					.word	Shift1Command                    ; $81 !1:SH1
>9214		84 91					.word	Shift2Command                    ; $82 !2:SH2
>9216		05 a0					.word	AbsUnary                         ; $83 ABS(
>9218		13 a0					.word	AllocUnary                       ; $84 ALLOC(
>921a		83 a0					.word	AscUnary                         ; $85 ASC(
>921c		d4 a1					.word	ChrUnary                         ; $86 CHR$(
>921e		df ad					.word	UnaryEvent                       ; $87 EVENT(
>9220		a4 95					.word	UnaryFalse                       ; $88 FALSE
>9222		90 a0					.word	FracUnary                        ; $89 FRAC(
>9224		05 b5					.word	ChrGet                           ; $8a GET$(
>9226		ea b4					.word	AscGet                           ; $8b GET(
>9228		94 b4					.word	UnaryGetDate                     ; $8c GETDATE$(
>922a		90 b4					.word	UnaryGetTime                     ; $8d GETTIME$(
>922c		38 ac					.word	UnaryHit                         ; $8e HIT(
>922e		0c b5					.word	ChrInkey                         ; $8f INKEY$(
>9230		fa b4					.word	AscInkey                         ; $90 INKEY(
>9232		a5 a0					.word	IntUnary                         ; $91 INT(
>9234		93 a1					.word	IsValUnary                       ; $92 ISVAL(
>9236		e6 a1					.word	ItemCountUnary                   ; $93 ITEMCOUNT(
>9238		0a a2					.word	ItemGetUnary                     ; $94 ITEMGET$(
>923a		67 b2					.word	UnaryJoyB                        ; $95 JOYB(
>923c		40 b2					.word	UnaryJoyX                        ; $96 JOYX(
>923e		43 b2					.word	UnaryJoyY                        ; $97 JOYY(
>9240		25 b5					.word	KeyDown                          ; $98 KEYDOWN(
>9242		49 a3					.word	Unary_Left                       ; $99 LEFT$(
>9244		b6 a0					.word	LenUnary                         ; $9a LEN(
>9246		d4 a0					.word	Unary_Max                        ; $9b MAX(
>9248		6b a3					.word	Unary_Mid                        ; $9c MID$(
>924a		d0 a0					.word	Unary_Min                        ; $9d MIN(
>924c		1f a1					.word	Unary_Not                        ; $9e NOT(
>924e		32 a1					.word	PeekByteUnary                    ; $9f PEEK(
>9250		3e a1					.word	PeekDUnary                       ; $a0 PEEKD(
>9252		3a a1					.word	PeekLUnary                       ; $a1 PEEKL(
>9254		36 a1					.word	PeekWUnary                       ; $a2 PEEKW(
>9256		34 b6					.word	UnaryPlaying                     ; $a3 PLAYING(
>9258		3f b5					.word	Unary_Random                     ; $a4 RANDOM(
>925a		56 a3					.word	Unary_Right                      ; $a5 RIGHT$(
>925c		59 b5					.word	Unary_Rnd                        ; $a6 RND(
>925e		dd b5					.word	ScreenAtStr                      ; $a7 SCREEN$(
>9260		b4 b5					.word	ScreenAt                         ; $a8 SCREEN(
>9262		6b a1					.word	SgnUnary                         ; $a9 SGN(
>9264		88 a2					.word	SpcUnary                         ; $aa SPC(
>9266		a3 a2					.word	Unary_Str                        ; $ab STR$(
>9268		17 ad					.word	TileRead                         ; $ac TILE(
>926a		77 b4					.word	UnaryTimer                       ; $ad TIMER(
>926c		99 95					.word	UnaryTrue                        ; $ae TRUE
>926e		89 a1					.word	ValUnary                         ; $af VAL(
>9270		88 8a					.word	ForCommand                       ; $b0 FOR
>9272		cb 8b					.word	IfCommand                        ; $b1 IF
>9274		8c 91					.word	Unused1                          ; $b2 PROC
>9276		88 90					.word	Command_REPEAT                   ; $b3 REPEAT
>9278		df 94					.word	Command_WHILE                    ; $b4 WHILE
>927a		f4 8b					.word	EndIf                            ; $b5 ENDIF
>927c		10 90					.word	Command_ENDPROC                  ; $b6 ENDPROC
>927e		3a 8b					.word	NextCommand                      ; $b7 NEXT
>9280		8c 91					.word	Unused4                          ; $b8 THEN
>9282		91 90					.word	Command_UNTIL                    ; $b9 UNTIL
>9284		00 95					.word	Command_WEND                     ; $ba WEND
>9286		08 a6					.word	SyntaxError                      ; $bb AT
>9288		08 a6					.word	SyntaxError                      ; $bc BY
>928a		8b 89					.word	CallCommand                      ; $bd CALL
>928c		26 a9					.word	CircleCommand                    ; $be CIRCLE
>928e		08 a6					.word	SyntaxError                      ; $bf CLEAR
>9290		08 a6					.word	SyntaxError                      ; $c0 COLOR
>9292		08 a6					.word	SyntaxError                      ; $c1 COLOUR
>9294		c0 89					.word	Command_Data                     ; $c2 DATA
>9296		c8 89					.word	DimCommand                       ; $c3 DIM
>9298		8c 91					.word	Unused3                          ; $c4 DOWNTO
>929a		ed 8b					.word	ElseCode                         ; $c5 ELSE
>929c		08 a6					.word	SyntaxError                      ; $c6 FROM
>929e		0b ac					.word	GfxCommand                       ; $c7 GFX
>92a0		08 a6					.word	SyntaxError                      ; $c8 HERE
>92a2		4f a9					.word	ImageCommand                     ; $c9 IMAGE
>92a4		1e 8d					.word	LetCommand                       ; $ca LET
>92a6		a1 a9					.word	LineCommand                      ; $cb LINE
>92a8		81 8e					.word	Command_LOCAL                    ; $cc LOCAL
>92aa		79 b2					.word	MCCommand                        ; $cd MEMCOPY
>92ac		08 a6					.word	SyntaxError                      ; $ce OFF
>92ae		08 a6					.word	SyntaxError                      ; $cf ON
>92b0		08 a6					.word	SyntaxError                      ; $d0 OUTLINE
>92b2		5c ac					.word	PaletteCommand                   ; $d1 PALETTE
>92b4		9a a9					.word	PlotCommand                      ; $d2 PLOT
>92b6		6c 8f					.word	PokeBCommand                     ; $d3 POKE
>92b8		78 8f					.word	PokeDCommand                     ; $d4 POKED
>92ba		74 8f					.word	PokeLCommand                     ; $d5 POKEL
>92bc		70 8f					.word	PokeWCommand                     ; $d6 POKEW
>92be		1e 90					.word	Command_Read                     ; $d7 READ
>92c0		22 a9					.word	RectangleCommand                 ; $d8 RECT
>92c2		7b 90					.word	RemCommand                       ; $d9 REM
>92c4		08 a6					.word	SyntaxError                      ; $da SOLID
>92c6		50 b6					.word	SoundCommand                     ; $db SOUND
>92c8		31 a9					.word	SpriteCommand                    ; $dc SPRITE
>92ca		6b a9					.word	TextCommand                      ; $dd TEXT
>92cc		8c 91					.word	Unused2                          ; $de TO
.92ce						VectorSet1:
>92ce		08 a6					.word	SyntaxError                      ; $80 !0:EOF
>92d0		08 a6					.word	SyntaxError                      ; $81 !1:SH1
>92d2		08 a6					.word	SyntaxError                      ; $82 !2:SH2
>92d4		5f 89					.word	AssembleCommand                  ; $83 ASSEMBLE
>92d6		7b 89					.word	AssertCommand                    ; $84 ASSERT
>92d8		fc aa					.word	BitmapCtrl                       ; $85 BITMAP
>92da		3c ae					.word	Command_BLoad                    ; $86 BLOAD
>92dc		e8 ae					.word	Command_BSave                    ; $87 BSAVE
>92de		32 ad					.word	ClearScreen                      ; $88 CLS
>92e0		fa 8b					.word	Command_CPrint                   ; $89 CPRINT
>92e2		3a ad					.word	CursorControl                    ; $8a CURSOR
>92e4		6b af					.word	Command_Dir                      ; $8b DIR
>92e6		3b b0					.word	Command_Drive                    ; $8c DRIVE
>92e8		85 8a					.word	EndCommand                       ; $8d END
>92ea		08 b6					.word	Explode                          ; $8e EXPLODE
>92ec		08 a6					.word	SyntaxError                      ; $8f GO
>92ee		93 8b					.word	Command_GOSUB                    ; $90 GOSUB
>92f0		b1 8b					.word	GotoCommand                      ; $91 GOTO
>92f2		08 a6					.word	SyntaxError                      ; $92 HIMEM
>92f4		f5 8b					.word	Command_Input                    ; $93 INPUT
>92f6		6e 8d					.word	Command_List                     ; $94 LIST
>92f8		42 b0					.word	Command_Load                     ; $95 LOAD
>92fa		8d b3					.word	MouseDeltaStatus                 ; $96 MDELTA
>92fc		89 b3					.word	MouseStatus                      ; $97 MOUSE
>92fe		42 8f					.word	NewCommand                       ; $98 NEW
>9300		5a 8f					.word	OptionCommand                    ; $99 OPTION
>9302		e4 b5					.word	PingCommand                      ; $9a PING
>9304		01 8c					.word	Command_Print                    ; $9b PRINT
>9306		aa 90					.word	Command_Restore                  ; $9c RESTORE
>9308		a3 8b					.word	Command_RETURN                   ; $9d RETURN
>930a		e9 90					.word	CommandRUNOptLoad                ; $9e RUN
>930c		19 b1					.word	Command_Save                     ; $9f SAVE
>930e		03 b4					.word	CommandSetDate                   ; $a0 SETDATE
>9310		07 b4					.word	CommandSetTime                   ; $a1 SETTIME
>9312		fc b5					.word	ShootCommand                     ; $a2 SHOOT
>9314		56 ab					.word	SpritesCtrl                      ; $a3 SPRITES
>9316		ae 93					.word	StopCommand                      ; $a4 STOP
>9318		9c ac					.word	TileCommand                      ; $a5 TILE
>931a		7e ab					.word	TilesCtrl                        ; $a6 TILES
>931c		a3 b1					.word	Command_Try                      ; $a7 TRY
>931e		e0 b1					.word	Command_VERIFY                   ; $a8 VERIFY
>9320		69 ad					.word	XGoCommand                       ; $a9 XGO
>9322		60 ad					.word	XLoadCommand                     ; $aa XLOAD
>9324		f0 b5					.word	ZapCommand                       ; $ab ZAP
.9326						VectorSet2:
>9326		08 a6					.word	SyntaxError                      ; $80 !0:EOF
>9328		08 a6					.word	SyntaxError                      ; $81 !1:SH1
>932a		08 a6					.word	SyntaxError                      ; $82 !2:SH2
>932c		c7 a4					.word	Assemble_adc                     ; $83 ADC
>932e		bf a4					.word	Assemble_and                     ; $84 AND
>9330		db a4					.word	Assemble_asl                     ; $85 ASL
>9332		45 a5					.word	Assemble_bcc                     ; $86 BCC
>9334		49 a5					.word	Assemble_bcs                     ; $87 BCS
>9336		51 a5					.word	Assemble_beq                     ; $88 BEQ
>9338		08 a5					.word	Assemble_bit                     ; $89 BIT
>933a		39 a5					.word	Assemble_bmi                     ; $8a BMI
>933c		4d a5					.word	Assemble_bne                     ; $8b BNE
>933e		35 a5					.word	Assemble_bpl                     ; $8c BPL
>9340		55 a5					.word	Assemble_bra                     ; $8d BRA
>9342		59 a5					.word	Assemble_brk                     ; $8e BRK
>9344		3d a5					.word	Assemble_bvc                     ; $8f BVC
>9346		41 a5					.word	Assemble_bvs                     ; $90 BVS
>9348		61 a5					.word	Assemble_clc                     ; $91 CLC
>934a		b5 a5					.word	Assemble_cld                     ; $92 CLD
>934c		75 a5					.word	Assemble_cli                     ; $93 CLI
>934e		a5 a5					.word	Assemble_clv                     ; $94 CLV
>9350		d3 a4					.word	Assemble_cmp                     ; $95 CMP
>9352		1c a5					.word	Assemble_cpx                     ; $96 CPX
>9354		17 a5					.word	Assemble_cpy                     ; $97 CPY
>9356		f9 a4					.word	Assemble_dec                     ; $98 DEC
>9358		b1 a5					.word	Assemble_dex                     ; $99 DEX
>935a		8d a5					.word	Assemble_dey                     ; $9a DEY
>935c		c3 a4					.word	Assemble_eor                     ; $9b EOR
>935e		fe a4					.word	Assemble_inc                     ; $9c INC
>9360		c1 a5					.word	Assemble_inx                     ; $9d INX
>9362		ad a5					.word	Assemble_iny                     ; $9e INY
>9364		30 a5					.word	Assemble_jmp                     ; $9f JMP
>9366		2b a5					.word	Assemble_jsr                     ; $a0 JSR
>9368		cf a4					.word	Assemble_lda                     ; $a1 LDA
>936a		f4 a4					.word	Assemble_ldx                     ; $a2 LDX
>936c		12 a5					.word	Assemble_ldy                     ; $a3 LDY
>936e		e5 a4					.word	Assemble_lsr                     ; $a4 LSR
>9370		c5 a5					.word	Assemble_nop                     ; $a5 NOP
>9372		bb a4					.word	Assemble_ora                     ; $a6 ORA
>9374		71 a5					.word	Assemble_pha                     ; $a7 PHA
>9376		5d a5					.word	Assemble_php                     ; $a8 PHP
>9378		b9 a5					.word	Assemble_phx                     ; $a9 PHX
>937a		79 a5					.word	Assemble_phy                     ; $aa PHY
>937c		81 a5					.word	Assemble_pla                     ; $ab PLA
>937e		65 a5					.word	Assemble_plp                     ; $ac PLP
>9380		cd a5					.word	Assemble_plx                     ; $ad PLX
>9382		89 a5					.word	Assemble_ply                     ; $ae PLY
>9384		e0 a4					.word	Assemble_rol                     ; $af ROL
>9386		ea a4					.word	Assemble_ror                     ; $b0 ROR
>9388		6d a5					.word	Assemble_rti                     ; $b1 RTI
>938a		7d a5					.word	Assemble_rts                     ; $b2 RTS
>938c		d7 a4					.word	Assemble_sbc                     ; $b3 SBC
>938e		69 a5					.word	Assemble_sec                     ; $b4 SEC
>9390		c9 a5					.word	Assemble_sed                     ; $b5 SED
>9392		85 a5					.word	Assemble_sei                     ; $b6 SEI
>9394		cb a4					.word	Assemble_sta                     ; $b7 STA
>9396		bd a5					.word	Assemble_stp                     ; $b8 STP
>9398		ef a4					.word	Assemble_stx                     ; $b9 STX
>939a		0d a5					.word	Assemble_sty                     ; $ba STY
>939c		03 a5					.word	Assemble_stz                     ; $bb STZ
>939e		a1 a5					.word	Assemble_tax                     ; $bc TAX
>93a0		9d a5					.word	Assemble_tay                     ; $bd TAY
>93a2		26 a5					.word	Assemble_trb                     ; $be TRB
>93a4		21 a5					.word	Assemble_tsb                     ; $bf TSB
>93a6		a9 a5					.word	Assemble_tsx                     ; $c0 TSX
>93a8		91 a5					.word	Assemble_txa                     ; $c1 TXA
>93aa		99 a5					.word	Assemble_txs                     ; $c2 TXS
>93ac		95 a5					.word	Assemble_tya                     ; $c3 TYA

;******  Return to file: ./common/commands/run.asm


;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/stop.asm

.93ae						StopCommand:
.93ae		a9 08		lda #$08		lda	#8
.93b0		4c 27 95	jmp $9527		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/clear.asm

.93b3						ClearSystem:
.93b3		a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.93b5		85 36		sta $36				sta 	0+zTemp0
.93b7		a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.93b9		85 37		sta $37				sta 	1+zTemp0
.93bb						_ClearZeroLoop:
.93bb		b2 36		lda ($36)			lda 	(zTemp0) 					; end of variables if offset is zero.
.93bd		f0 24		beq $93e3			beq 	_ClearZeroEnd
.93bf		a0 03		ldy #$03			ldy 	#3 							; erase the variables
.93c1		a9 00		lda #$00			lda 	#0 							; set all the data to zero.
.93c3						_ClearOneVariable:
.93c3		91 36		sta ($36),y			sta 	(zTemp0),y
.93c5		c8		iny				iny
.93c6		c0 08		cpy #$08			cpy 	#8
.93c8		d0 f9		bne $93c3			bne 	_ClearOneVariable
.93ca		a0 02		ldy #$02			ldy 	#2 							; has it been marked procedure
.93cc		b1 36		lda ($36),y			lda 	(zTemp0),y
.93ce		c9 18		cmp #$18			cmp 	#NSTProcedure
.93d0		d0 04		bne $93d6			bne 	_ClearNotProcedure
.93d2		a9 04		lda #$04			lda 	#NSTInteger+NSBIsArray 		; if so set it back to an integer array
.93d4		91 36		sta ($36),y			sta 	(zTemp0),y 					; will be fixed on the pre-run scan.
.93d6						_ClearNotProcedure:
.93d6		18		clc				clc 								; go to the next variable
.93d7		b2 36		lda ($36)			lda 	(zTemp0) 					; offset to next, add to zTemp0
.93d9		65 36		adc $36				adc 	zTemp0
.93db		85 36		sta $36				sta 	zTemp0
.93dd		90 dc		bcc $93bb			bcc 	_ClearZeroLoop
.93df		e6 37		inc $37				inc 	zTemp0+1
.93e1		80 d8		bra $93bb			bra 	_ClearZeroLoop
.93e3						_ClearZeroEnd:
.93e3		18		clc				clc
.93e4		a5 36		lda $36				lda 	zTemp0
.93e6		69 01		adc #$01			adc 	#1
.93e8		8d 28 04	sta $0428			sta 	lowMemPtr
.93eb		a5 37		lda $37				lda 	zTemp0+1
.93ed		69 00		adc #$00			adc 	#0
.93ef		8d 29 04	sta $0429			sta 	lowMemPtr+1
.93f2		20 3d b7	jsr $b73d			jsr 	StackReset
.93f5		20 a3 b7	jsr $b7a3			jsr 	StringSystemInitialise
.93f8		20 11 94	jsr $9411			jsr 	ProcedureScan
.93fb		20 aa 90	jsr $90aa			jsr 	Command_Restore
.93fe		9c 3a 04	stz $043a			stz 	AssemblerAddress
.9401		9c 3b 04	stz $043b			stz 	AssemblerAddress+1
.9404		9c 3c 04	stz $043c			stz 	AssemblerControl
.9407		9c 80 06	stz $0680			stz 	KeyboardQueueEntries
.940a		20 70 a0	jsr $a070			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.940d		20 e5 aa	jsr $aae5			jsr 	ResetBitmapSpritesTiles
.9410		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/procscan.asm

.9411						ProcedureScan:
.9411		20 c1 90	jsr $90c1			jsr 	SwapDataCodePtrs 			; swap code and data
.9414		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.9416		85 30		sta $30				sta 	codePtr
.9418		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.941a		85 31		sta $31				sta 	codePtr+1
.941c						_PSLoop:
.941c		b2 30		lda ($30)			lda 	(codePtr)
.941e		f0 42		beq $9462			beq 	_PSExit
.9420		a0 03		ldy #$03			ldy 	#3 							; is it PROC at start of line ?
.9422		b1 30		lda ($30),y			lda 	(codePtr),y
.9424		c9 b2		cmp #$b2			cmp 	#KWD_PROC
.9426		d0 2d		bne $9455			bne 	_PSNext
.9428		c8		iny				iny 								; get the address of the record to zTemp0 and
.9429		b1 30		lda ($30),y			lda 	(codePtr),y
.942b		29 c0		and #$c0			and 	#$C0
.942d		c9 40		cmp #$40			cmp 	#$40
.942f		d0 35		bne $9466			bne 	_PSSyntax
.9431		b1 30		lda ($30),y			lda 	(codePtr),y
.9433		18		clc				clc
.9434		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9436		85 37		sta $37				sta 	zTemp0+1
.9438		c8		iny				iny 								; LSB
.9439		b1 30		lda ($30),y			lda 	(codePtr),y
.943b		85 36		sta $36				sta 	zTemp0
.943d		c8		iny				iny 								; character after variable call.
.943e		98		tya				tya 								; save Y offset at +7 (exponent slot)
.943f		a0 07		ldy #$07			ldy 	#7
.9441		91 36		sta ($36),y			sta 	(zTemp0),y
.9443		a9 18		lda #$18			lda 	#NSTProcedure 				; mark it as procedure
.9445		a0 02		ldy #$02			ldy 	#2
.9447		91 36		sta ($36),y			sta 	(zTemp0),y
.9449		a2 00		ldx #$00			ldx 	#0 							; copy code-Ptr into offset 3-6 (mantissa)
.944b						_PSCopy:
.944b		b5 30		lda $30,x			lda 	safePtr,x
.944d		c8		iny				iny
.944e		91 36		sta ($36),y			sta 	(zTemp0),y
.9450		e8		inx				inx
.9451		e0 04		cpx #$04			cpx 	#4
.9453		d0 f6		bne $944b			bne 	_PSCopy
.9455						_PSNext:
.9455		18		clc				clc
.9456		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.9458		65 30		adc $30				adc 	codePtr
.945a		85 30		sta $30				sta 	codePtr
.945c		90 02		bcc $9460			bcc 	_CREExit
.945e		e6 31		inc $31				inc 	codePtr+1 					; carry
.9460						_CREExit:
.9460		80 ba		bra $941c			bra 	_PSLoop
.9462						_PSExit:
.9462		20 c1 90	jsr $90c1			jsr 	SwapDataCodePtrs 			; swap code and data
.9465		60		rts				rts
.9466						_PSSyntax:
.9466		4c 08 a6	jmp $a608			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/utilities/scanforward.asm

.9469						ScanForward:
.9469		64 38		stz $38				stz 	zTemp1 						; zero the structure count - goes up with WHILE/FOR down with WEND/NEXT etc.
.946b		86 37		stx $37				stx 	zTemp0+1
.946d		85 36		sta $36				sta 	zTemp0 						; save X & A as the two possible matches.
.946f						_ScanLoop:
.946f		b1 30		lda ($30),y			lda 	(codePtr),y
.9471		c8		iny				iny
.9472		a6 38		ldx $38				ldx 	zTemp1 						; if the count is > 0 cannot match as in substructure
.9474		d0 0e		bne $9484			bne 	_ScanGoNext
.9476		c5 36		cmp $36				cmp 	zTemp0 						; see if either matches
.9478		f0 04		beq $947e			beq 	_ScanMatch
.947a		c5 37		cmp $37				cmp 	zTemp0+1
.947c		d0 06		bne $9484			bne 	_ScanGoNext
.947e						_ScanMatch:
.947e		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if asked for EOL, backtrack.
.9480		d0 01		bne $9483			bne 	_ScanNotEndEOL
.9482		88		dey				dey
.9483						_ScanNotEndEOL:
.9483		60		rts				rts
.9484						_ScanGoNext:
.9484		20 89 94	jsr $9489			jsr  	ScanForwardOne 				; allows for shifts and so on.
.9487		80 e6		bra $946f			bra 	_ScanLoop
.9489						ScanForwardOne:
.9489		c9 40		cmp #$40			cmp 	#$40 						; if 00-3F, punctuation characters, already done.
.948b		90 3e		bcc $94cb			bcc 	_SFWExit
.948d		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; if 40-82, skip one extra as these are 2 byte
.948f		90 18		bcc $94a9			bcc 	_ScanSkipOne	 			; offsets into the identifier table or shifts.
.9491		c9 fc		cmp #$fc			cmp 	#$FC 						; FC-FF are data skips (hex consts, strings etc.)
.9493		b0 2f		bcs $94c4			bcs 	_ScanSkipData
.9495		c9 b0		cmp #$b0			cmp 	#KWC_FIRST_STRUCTURE 		; structure keyword ?
.9497		90 32		bcc $94cb			bcc 	_SFWExit 					; if not, ordinary keywords.
.9499		c9 bb		cmp #$bb			cmp 	#KWC_LAST_STRUCTURE+1
.949b		b0 2e		bcs $94cb			bcs 	_SFWExit
.949d		c6 38		dec $38				dec 	zTemp1 						; decrement the sructure count
.949f		c9 b5		cmp #$b5			cmp 	#KWC_FIRST_STRUCTURE_DEC 	; back if it is a dec structure (e.g. WEND/NEXT)
.94a1		b0 28		bcs $94cb			bcs 	_SFWExit
.94a3		e6 38		inc $38				inc 	zTemp1 						; so it's an increment structure
.94a5		e6 38		inc $38				inc 	zTemp1 						; twice to undo the dec
.94a7		80 22		bra $94cb			bra 	_SFWExit
.94a9						_ScanSkipOne:
.94a9		c8		iny				iny 								; consume the extra one.
.94aa		c9 80		cmp #$80			cmp 	#KWC_EOL 					; if not EOL loop back
.94ac		d0 1d		bne $94cb			bne 	_SFWExit
.94ae		18		clc				clc
.94af		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.94b1		65 30		adc $30				adc 	codePtr
.94b3		85 30		sta $30				sta 	codePtr
.94b5		90 02		bcc $94b9			bcc 	_CREExit
.94b7		e6 31		inc $31				inc 	codePtr+1 					; carry
.94b9						_CREExit:
.94b9		a0 03		ldy #$03			ldy 	#3 							; scan start position.
.94bb		b2 30		lda ($30)			lda 	(codePtr)
.94bd		d0 0c		bne $94cb			bne 	_SFWExit 					; if not zero, more to scan
.94bf		a9 13		lda #$13		lda	#19
.94c1		4c 27 95	jmp $9527		jmp	ErrorHandler
.94c4						_ScanSkipData:
.94c4		88		dey				dey 								; point at data token
.94c5		c8		iny				iny 								; point to offset
.94c6		98		tya				tya 								; A = offset position
.94c7		38		sec				sec 								; add size +1 hence SEC
.94c8		71 30		adc ($30),y			adc 	(codePtr),y
.94ca		a8		tay				tay 								; make current position.
.94cb						_SFWExit:
.94cb		60		rts				rts
.94cc						ScanGetCurrentLineStep:
.94cc		64 38		stz $38				stz 	zTemp1
.94ce		a0 03		ldy #$03			ldy 	#3
.94d0						_SGCLSLoop:
.94d0		b1 30		lda ($30),y			lda 	(codePtr),y
.94d2		c8		iny				iny
.94d3		c9 80		cmp #$80			cmp 	#KWC_EOL	 				; if EOL exit
.94d5		f0 05		beq $94dc			beq 	_SGCLSExit
.94d7		20 89 94	jsr $9489			jsr 	ScanForwardOne
.94da		80 f4		bra $94d0			bra 	_SGCLSLoop
.94dc						_SGCLSExit:
.94dc		a5 38		lda $38				lda 	zTemp1 						; return the adjustment
.94de		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/commands/while.asm

.94df						Command_WHILE:
.94df		5a		phy				phy 								; save position of the test
.94e0		a2 00		ldx #$00			ldx 	#0 							; work out the while test.
.94e2		20 de a3	jsr $a3de			jsr 	EvaluateNumber
.94e5		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; check if zero
.94e8		f0 0e		beq $94f8			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.94ea		98		tya				tya 								; position *after* test.
.94eb		7a		ply				ply 								; restore position before test, at WHILE
.94ec		88		dey				dey 								; so we execute the WHILE command again.
.94ed		48		pha				pha 								; push after test on the stack
.94ee		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; allocate 6 bytes on the return stack.
.94f0		20 d7 b6	jsr $b6d7			jsr 	StackOpen
.94f3		20 1c b7	jsr $b71c			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.94f6		7a		ply				ply 								; restore the position *after* the test
.94f7		60		rts				rts
.94f8						_WHExitLoop:
.94f8		68		pla				pla 								; throw post loop position
.94f9		a9 ba		lda #$ba			lda 	#KWD_WEND 					; scan forward past WEND
.94fb		aa		tax				tax
.94fc		20 69 94	jsr $9469			jsr 	ScanForward
.94ff		60		rts				rts
.9500						Command_WEND:
.9500		a9 a3		lda #$a3			lda 	#STK_WHILE+3 				; check WHILE is TOS e.g. in a while loop :)
.9502		a2 10		ldx #$10			ldx 	#ERRID_WHILE 				; this error if not.
.9504		20 04 b7	jsr $b704			jsr 	StackCheckFrame
.9507		20 2d b7	jsr $b72d			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.950a		20 f6 b6	jsr $b6f6			jsr 	StackClose		 			; erase the frame
.950d		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/charcheck.asm

.950e						CheckRightBracket:
.950e		b1 30		lda ($30),y			lda 	(codePtr),y
.9510		c8		iny				iny
.9511		c9 29		cmp #$29			cmp 	#KWD_RPAREN 						; exit if matches
.9513		d0 0f		bne $9524			bne 	CNAFail
.9515		60		rts				rts
.9516						CheckComma:
.9516		b1 30		lda ($30),y			lda 	(codePtr),y
.9518		c8		iny				iny
.9519		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 						; exit if matches
.951b		d0 07		bne $9524			bne 	CNAFail
.951d		60		rts				rts
.951e						CheckNextA:
.951e		d1 30		cmp ($30),y			cmp 	(codePtr),y
.9520		d0 02		bne $9524			bne 	CNAFail
.9522		c8		iny				iny 								; skip character
.9523		60		rts				rts 								; and exit
.9524						CNAFail:
.9524		4c 08 a6	jmp $a608			jmp 	SyntaxError

;******  Return to file: _basic.asm


;******  Processing file: ./common/errors/errors.asm

.9527						ErrorHandler:
.9527		48		pha				pha 								; save error #
.9528		a8		tay				tay 								; find the error text
.9529		f0 4e		beq $9579			beq 	_EHEnd
.952b		a2 00		ldx #$00			ldx 	#0
.952d		a9 21		lda #$21			lda 	#((ErrorText) & $FF)
.952f		85 36		sta $36				sta 	0+zTemp0
.9531		a9 a6		lda #$a6			lda 	#((ErrorText) >> 8)
.9533		85 37		sta $37				sta 	1+zTemp0
.9535						_EHFind:
.9535		88		dey				dey 								; keep looking through text
.9536		f0 0e		beq $9546			beq 	_EHFound
.9538						_EHFindZero:
.9538		b2 36		lda ($36)			lda 	(zTemp0) 					; find the next error
.953a		e6 36		inc $36				inc 	zTemp0
.953c		d0 02		bne $9540			bne 	_EHFNoCarry
.953e		e6 37		inc $37				inc 	zTemp0+1
.9540						_EHFNoCarry:
.9540		c9 00		cmp #$00			cmp 	#0
.9542		d0 f4		bne $9538			bne 	_EHFindZero
.9544		80 ef		bra $9535			bra 	_EHFind
.9546						_EHFound:
.9546		a5 36		lda $36				lda 	zTemp0 						; print message
.9548		a6 37		ldx $37				ldx 	zTemp0+1
.954a		20 86 95	jsr $9586			jsr 	PrintStringXA
.954d		68		pla				pla  								; check if error is 'open structure'
.954e		c9 13		cmp #$13			cmp 	#ERRID_STRUCT
.9550		f0 22		beq $9574			beq 	_EHCREnd
.9552		a0 01		ldy #$01			ldy 	#1 							; if line number zero don't print it
.9554		b1 30		lda ($30),y			lda 	(codePtr),y
.9556		d0 05		bne $955d			bne 	_EHAtMsg
.9558		c8		iny				iny
.9559		b1 30		lda ($30),y			lda 	(codePtr),y
.955b		f0 17		beq $9574			beq 	_EHCREnd
.955d						_EHAtMsg:
.955d		a2 95		ldx #$95			ldx 	#_AtMsg >> 8 				; print " at "
.955f		a9 7c		lda #$7c			lda 	#_AtMsg & $FF
.9561		20 86 95	jsr $9586			jsr 	PrintStringXA
.9564		a0 01		ldy #$01			ldy 	#1 							; line number into XA
.9566		b1 30		lda ($30),y			lda 	(codePtr),y
.9568		48		pha				pha
.9569		c8		iny				iny
.956a		b1 30		lda ($30),y			lda 	(codePtr),y
.956c		aa		tax				tax
.956d		68		pla				pla
.956e		20 9c 99	jsr $999c			jsr 	ConvertInt16 				; convert XA to string
.9571		20 86 95	jsr $9586			jsr 	PrintStringXA 				; and print it.
.9574						_EHCREnd:
.9574		a9 0d		lda #$0d			lda 	#13 						; new line
.9576		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.9579						_EHEnd:
.9579		4c 1c 89	jmp $891c			jmp 	WarmStart
>957c		20 61 74 20 6c 69 6e 65		_AtMsg:	.text 	" at line ",0
>9584		20 00
.9586						PrintStringXA:
.9586		5a		phy				phy
.9587		86 37		stx $37				stx 	zTemp0+1
.9589		85 36		sta $36				sta 	zTemp0
.958b		a0 00		ldy #$00			ldy 	#0
.958d						_PSXALoop:
.958d		b1 36		lda ($36),y			lda 	(zTemp0),y
.958f		f0 06		beq $9597			beq 	_PSXAExit
.9591		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.9594		c8		iny				iny
.9595		80 f6		bra $958d			bra 	_PSXALoop
.9597						_PSXAExit:
.9597		7a		ply				ply
.9598		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/compare.asm

.9599						UnaryTrue:
.9599		fa		plx				plx
.959a						ReturnTrue:
.959a		a9 01		lda #$01			lda 	#1  						; set to 1
.959c		20 92 a4	jsr $a492			jsr 	NSMSetByte
.959f		a9 80		lda #$80			lda 	#$80 						; set sign flag, so it is -1
.95a1		95 50		sta $50,x			sta 	NSStatus,x
.95a3		60		rts				rts
.95a4						UnaryFalse:
.95a4		fa		plx				plx
.95a5						ReturnFalse:
.95a5		4c 90 a4	jmp $a490			jmp 	NSMSetZero 					; set it all to zero
.95a8						BinaryCompareEqual:
.95a8		fa		plx				plx
.95a9		20 e4 95	jsr $95e4			jsr 	CompareBaseCode
.95ac		c9 00		cmp #$00			cmp 	#0
.95ae		f0 ea		beq $959a			beq 	ReturnTrue
.95b0		80 f3		bra $95a5			bra 	ReturnFalse
.95b2						BinaryCompareLess:
.95b2		fa		plx				plx
.95b3		20 e4 95	jsr $95e4			jsr 	CompareBaseCode
.95b6		c9 ff		cmp #$ff			cmp 	#$FF
.95b8		f0 e0		beq $959a			beq 	ReturnTrue
.95ba		80 e9		bra $95a5			bra 	ReturnFalse
.95bc						BinaryCompareGreater:
.95bc		fa		plx				plx
.95bd		20 e4 95	jsr $95e4			jsr 	CompareBaseCode
.95c0		c9 01		cmp #$01			cmp 	#1
.95c2		f0 d6		beq $959a			beq 	ReturnTrue
.95c4		80 df		bra $95a5			bra 	ReturnFalse
.95c6						BinaryCompareNotEqual:
.95c6		fa		plx				plx
.95c7		20 e4 95	jsr $95e4			jsr 	CompareBaseCode
.95ca		c9 00		cmp #$00			cmp 	#0
.95cc		d0 cc		bne $959a			bne 	ReturnTrue
.95ce		80 d5		bra $95a5			bra 	ReturnFalse
.95d0						BinaryCompareLessEqual:
.95d0		fa		plx				plx
.95d1		20 e4 95	jsr $95e4			jsr 	CompareBaseCode
.95d4		c9 01		cmp #$01			cmp 	#1
.95d6		d0 c2		bne $959a			bne 	ReturnTrue
.95d8		80 cb		bra $95a5			bra 	ReturnFalse
.95da						BinaryCompareGreaterEqual:
.95da		fa		plx				plx
.95db		20 e4 95	jsr $95e4			jsr 	CompareBaseCode
.95de		c9 ff		cmp #$ff			cmp 	#$FF
.95e0		d0 b8		bne $959a			bne 	ReturnTrue
.95e2		80 c1		bra $95a5			bra 	ReturnFalse
.95e4						CompareBaseCode:
.95e4		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; make both values if references.
.95e7		b5 50		lda $50,x			lda 	NSStatus,x 					; check if either is a string.
.95e9		15 51		ora $51,x			ora 	NSStatus+1,x
.95eb		29 10		and #$10			and 	#NSTString
.95ed		d0 37		bne $9626			bne 	_CBCString 					; if so do string code, which will check if both.
.95ef		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check both are integers
.95f1		15 a1		ora $a1,x			ora 	NSExponent+1,x
.95f3		d0 34		bne $9629			bne 	_CBCFloat
.95f5		b5 50		lda $50,x			lda 	NSStatus,x
.95f7		15 51		ora $51,x			ora 	NSStatus+1,x
.95f9		29 08		and #$08			and 	#NSTFloat
.95fb		d0 2c		bne $9629			bne 	_CBCFloat
.95fd		20 2c 96	jsr $962c			jsr 	CompareFixMinusZero 		; fix up -0 just in cases.
.9600		e8		inx				inx
.9601		20 2c 96	jsr $962c			jsr 	CompareFixMinusZero
.9604		ca		dex				dex
.9605		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs different ?
.9607		55 51		eor $51,x			eor 	NSStatus+1,x
.9609		10 0a		bpl $9615			bpl 	_CDCSameSign
.960b		b5 50		lda $50,x			lda 	NSStatus,x 					; if first one is -ve
.960d		30 14		bmi $9623			bmi 	_CBCLess 					; return $FF
.960f						_CBCGreater:
.960f		a9 01		lda #$01			lda 	#1
.9611		60		rts				rts
.9612						_CBCEqual:
.9612		a9 00		lda #$00			lda 	#0
.9614		60		rts				rts
.9615						_CDCSameSign:
.9615		20 41 98	jsr $9841			jsr 	SubTopTwoStack 				; unsigned subtract
.9618		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; or the mantissa together
.961b		f0 f5		beq $9612			beq 	_CBCEqual 					; -0 == 0
.961d		b5 90		lda $90,x			lda 	NSMantissa3,x 				; sign of the result. if +ve return $01 else return $FF
.961f		55 51		eor $51,x			eor 	NSStatus+1,x 				; however if both were -ve this is inverted
.9621		10 ec		bpl $960f			bpl 	_CBCGreater
.9623						_CBCLess:
.9623		a9 ff		lda #$ff			lda 	#$FF
.9625		60		rts				rts
.9626						_CBCString:
.9626		4c b2 97	jmp $97b2			jmp 	CompareStrings
.9629						_CBCFloat:
.9629		4c 05 9b	jmp $9b05			jmp 	CompareFloat
.962c						CompareFixMinusZero:
.962c		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero
.962f		d0 02		bne $9633			bne 	_CFXMZNotZero
.9631		74 50		stz $50,x			stz 	NSStatus,x
.9633						_CFXMZNotZero:
.9633		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/concat.asm

.9634						StringConcat:
.9634		b5 50		lda $50,x			lda 	NSStatus,x 					; check both strings
.9636		35 51		and $51,x			and 	NSStatus+1,x
.9638		29 18		and #$18			and 	#NSBTypeMask
.963a		c9 10		cmp #$10			cmp 	#NSTString
.963c		d0 50		bne $968e			bne		_SCType
.963e		64 38		stz $38				stz 	zTemp1 						; counting total length
.9640		e8		inx				inx
.9641		20 5f 96	jsr $965f			jsr 	_SCSetupZ0 					; setup for second
.9644		20 68 96	jsr $9668			jsr 	_SCLengthZ0 				; length for second
.9647		ca		dex				dex
.9648		20 5f 96	jsr $965f			jsr 	_SCSetupZ0 					; setup for first
.964b		20 68 96	jsr $9668			jsr 	_SCLengthZ0 				; length for first
.964e		a5 38		lda $38				lda 	zTemp1 						; allocate memory using total.
.9650		20 c7 b7	jsr $b7c7			jsr 	StringTempAllocate
.9653		20 7f 96	jsr $967f			jsr 	_SCCopy 					; copy first out, using zTemp0 from above
.9656		e8		inx				inx
.9657		20 5f 96	jsr $965f			jsr 	_SCSetupZ0 					; copy second out
.965a		20 7f 96	jsr $967f			jsr 	_SCCopy
.965d		ca		dex				dex
.965e		60		rts				rts
.965f						_SCSetupZ0:
.965f		b5 60		lda $60,x			lda 	NSMantissa0,x
.9661		85 36		sta $36				sta 	zTemp0
.9663		b5 70		lda $70,x			lda 	NSMantissa1,x
.9665		85 37		sta $37				sta 	zTemp0+1
.9667		60		rts				rts
.9668						_SCLengthZ0:
.9668		5a		phy				phy
.9669		a0 00		ldy #$00			ldy 	#0
.966b						_SCLenLoop:
.966b		b1 36		lda ($36),y			lda 	(zTemp0),y
.966d		f0 0e		beq $967d			beq 	_SCLExit
.966f		c8		iny				iny
.9670		e6 38		inc $38				inc 	zTemp1
.9672		a5 38		lda $38				lda	 	zTemp1 						; check string too long.
.9674		c9 fd		cmp #$fd			cmp 	#253
.9676		d0 f3		bne $966b			bne		_SCLenLoop
.9678		a9 09		lda #$09		lda	#9
.967a		4c 27 95	jmp $9527		jmp	ErrorHandler
.967d						_SCLExit:
.967d		7a		ply				ply
.967e		60		rts				rts
.967f						_SCCopy:
.967f		5a		phy				phy
.9680		a0 00		ldy #$00			ldy 	#0
.9682						_SCCopyLoop:
.9682		b1 36		lda ($36),y			lda 	(zTemp0),y
.9684		f0 06		beq $968c			beq 	_SCCExit
.9686		20 00 b8	jsr $b800			jsr 	StringTempWrite
.9689		c8		iny				iny
.968a		80 f6		bra $9682			bra 	_SCCopyLoop
.968c						_SCCExit:
.968c		7a		ply				ply
.968d		60		rts				rts
.968e						_SCType:
.968e		4c 12 a6	jmp $a612			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/divide.asm

.9691						IntegerDivide:
.9691		fa		plx				plx
.9692		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9694		15 51		ora $51,x			ora 	NSStatus+1,x
.9696		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9697		0a		asl a				asl 	a
.9698		10 05		bpl $969f			bpl 	_NotRef
.969a		48		pha				pha
.969b		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.969e		68		pla				pla
.969f						_NotRef:
.969f		0a		asl a				asl 	a
.96a0		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.96a2		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.96a4		15 a1		ora $a1,x			ora 	NSExponent+1,x
.96a6		f0 03		beq $96ab			beq 	_IntegerCode 				; if clear, then we have two integers
.96a8		4c 12 a6	jmp $a612			jmp 	TypeError 					; anything else, type mismatch.
.96ab						_IntegerCode:
.96ab		20 c5 96	jsr $96c5			jsr 	CheckDivideZero 			; do div zero check
.96ae		20 f7 96	jsr $96f7			jsr 	Int32Divide 				; do the division
.96b1		20 a8 97	jsr $97a8			jsr 	CalculateSign 				; calculate result sign
.96b4						NSMCopyPlusTwoToZero:
.96b4		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; copy result down from +2
.96b6		95 60		sta $60,x			sta 	NSMantissa0,x
.96b8		b5 72		lda $72,x			lda 	NSMantissa1+2,x
.96ba		95 70		sta $70,x			sta 	NSMantissa1,x
.96bc		b5 82		lda $82,x			lda 	NSMantissa2+2,x
.96be		95 80		sta $80,x			sta 	NSMantissa2,x
.96c0		b5 92		lda $92,x			lda 	NSMantissa3+2,x
.96c2		95 90		sta $90,x			sta 	NSMantissa3,x
.96c4		60		rts				rts
.96c5						CheckDivideZero:
.96c5		e8		inx				inx
.96c6		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero
.96c9		f0 02		beq $96cd			beq 	_CDVError
.96cb		ca		dex				dex
.96cc		60		rts				rts
.96cd						_CDVError:
.96cd		a9 03		lda #$03		lda	#3
.96cf		4c 27 95	jmp $9527		jmp	ErrorHandler
.96d2						IntegerModulus:
.96d2		fa		plx				plx
.96d3		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.96d5		15 51		ora $51,x			ora 	NSStatus+1,x
.96d7		0a		asl a				asl 	a 							; shift reference bit into sign bit
.96d8		0a		asl a				asl 	a
.96d9		10 05		bpl $96e0			bpl 	_NotRef
.96db		48		pha				pha
.96dc		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.96df		68		pla				pla
.96e0						_NotRef:
.96e0		0a		asl a				asl 	a
.96e1		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.96e3		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.96e5		15 a1		ora $a1,x			ora 	NSExponent+1,x
.96e7		f0 03		beq $96ec			beq 	_IntegerCode 				; if clear, then we have two integers
.96e9		4c 12 a6	jmp $a612			jmp 	TypeError 					; anything else, type mismatch.
.96ec						_IntegerCode:
.96ec						IntegerModulusNoCheck:
.96ec		20 c5 96	jsr $96c5			jsr 	CheckDivideZero 			; do div zero check
.96ef		20 f7 96	jsr $96f7			jsr 	Int32Divide 				; do the division
.96f2		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.96f4		56 50		lsr $50,x			lsr 	NSStatus,x
.96f6		60		rts				rts
.96f7						Int32Divide:
.96f7		48		pha				pha 								; save AXY
.96f8		5a		phy				phy
.96f9		20 73 a4	jsr $a473			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.96fc		20 8c a4	jsr $a48c			jsr 	NSMSetZeroMantissaOnly 		; set S[X] to zero
.96ff		a0 20		ldy #$20			ldy 	#32 						; loop 32 times
.9701						_I32DivideLoop:
.9701		e8		inx				inx
.9702		e8		inx				inx
.9703		20 9f a4	jsr $a49f			jsr 	NSMShiftLeft				; shift S[X+2] S[X] left as a 64 bit element
.9706		ca		dex				dex
.9707		ca		dex				dex
.9708		20 a0 a4	jsr $a4a0			jsr 	NSMRotateLeft
.970b		20 36 97	jsr $9736			jsr 	DivideCheckSubtract 		; check if subtract possible
.970e		90 02		bcc $9712			bcc 	_I32DivideNoCarryIn
.9710		f6 62		inc $62,x			inc 	NSMantissa0+2,x 			; if possible, set Mantissa0[X+2].0
.9712						_I32DivideNoCarryIn:
.9712		88		dey				dey 								; loop round till division completed.
.9713		d0 ec		bne $9701			bne 	_I32DivideLoop
.9715		7a		ply				ply 								; restore AXY and exit
.9716		68		pla				pla
.9717		60		rts				rts
.9718						Int32ShiftDivide:
.9718		48		pha				pha 								; save AY
.9719		5a		phy				phy
.971a		e8		inx				inx 								; clear S[X+2]
.971b		e8		inx				inx
.971c		20 90 a4	jsr $a490			jsr 	NSMSetZero
.971f		ca		dex				dex
.9720		ca		dex				dex
.9721		a0 1f		ldy #$1f			ldy 	#31 						; loop 31 times.
.9723						_I32SDLoop:
.9723		20 36 97	jsr $9736			jsr 	DivideCheckSubtract 		; check if subtract possible
.9726		e8		inx				inx
.9727		e8		inx				inx
.9728		20 a0 a4	jsr $a4a0			jsr 	NSMRotateLeft				; shift 64 bit FPA left, rotating carry in
.972b		ca		dex				dex
.972c		ca		dex				dex
.972d		20 a0 a4	jsr $a4a0			jsr 	NSMRotateLeft
.9730		88		dey				dey 	 							; do 31 times
.9731		d0 f0		bne $9723			bne 	_I32SDLoop
.9733		7a		ply				ply 								; restore AY and exit
.9734		68		pla				pla
.9735		60		rts				rts
.9736						DivideCheckSubtract:
.9736		20 41 98	jsr $9841			jsr 	SubTopTwoStack 				; subtract Stack[X+1] from Stack[X+0]
.9739		b0 04		bcs $973f			bcs 	_DCSExit 					; if carry set, then could do, exit
.973b		20 27 98	jsr $9827			jsr 	AddTopTwoStack 				; add it back in
.973e		18		clc				clc 								; and return False
.973f						_DCSExit:
.973f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/multiply.asm

.9740						MulInteger:
.9740		fa		plx				plx
.9741		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9743		15 51		ora $51,x			ora 	NSStatus+1,x
.9745		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9746		0a		asl a				asl 	a
.9747		10 05		bpl $974e			bpl 	_NotRef
.9749		48		pha				pha
.974a		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.974d		68		pla				pla
.974e						_NotRef:
.974e		0a		asl a				asl 	a 							; put MSB of type into A:7
.974f		30 09		bmi $975a			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.9751		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9753		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9755		f0 06		beq $975d			beq 	_IntegerCode 				; if clear, then we have two integers
.9757		4c c7 9b	jmp $9bc7			jmp 	FloatingPointMultiply 							; otherwise at least one float.
.975a						_StringData:
.975a		4c 1c a6	jmp $a61c			jmp 	NotDoneError							; at least one string - don't know both are strings.
.975d						_IntegerCode:
.975d		20 6a 97	jsr $976a			jsr 	MultiplyShort
.9760		c9 00		cmp #$00			cmp 	#0
.9762		f0 05		beq $9769			beq 	_MIExit
.9764		a9 04		lda #$04		lda	#4
.9766		4c 27 95	jmp $9527		jmp	ErrorHandler
.9769						_MIExit:
.9769		60		rts				rts
.976a						MultiplyShort:
.976a		5a		phy				phy 								; save Y
.976b		20 73 a4	jsr $a473			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2]
.976e		20 8c a4	jsr $a48c			jsr 	NSMSetZeroMantissaOnly 		; set mantissa S[X] to zero
.9771		a0 00		ldy #$00			ldy 	#0 							; Y is the shift count.
.9773						_I32MLoop:
.9773		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; check S[X+2] is zero
.9775		15 72		ora $72,x			ora 	NSMantissa1+2,x
.9777		15 82		ora $82,x			ora 	NSMantissa2+2,x
.9779		15 92		ora $92,x			ora 	NSMantissa3+2,x
.977b		f0 25		beq $97a2			beq 	_I32MExit 					; exit if zero
.977d		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; check LSB of n1
.977f		29 01		and #$01			and 	#1
.9781		f0 0d		beq $9790			beq 	_I32MNoAdd
.9783		20 27 98	jsr $9827			jsr 	AddTopTwoStack 				; if so add S[X+1] to S[X+0]
.9786		b5 90		lda $90,x			lda 	NSMantissa3,x 				; has MantissaA overflowed ?
.9788		10 06		bpl $9790			bpl 	_I32MNoAdd
.978a						_I32ShiftRight:
.978a		20 a9 a4	jsr $a4a9			jsr 	NSMShiftRight 				; shift S[X] right
.978d		c8		iny				iny 								; increment shift count
.978e		80 09		bra $9799			bra 	_I32MShiftUpper 			; n2 is doubled by default.
.9790						_I32MNoAdd:
.9790		34 91		bit $91,x			bit 	NSMantissa3+1,x				; if we can't shift S[X+1] left, shift everything right
.9792		70 f6		bvs $978a			bvs 	_I32ShiftRight 				; instead.
.9794		e8		inx				inx
.9795		20 9f a4	jsr $a49f			jsr 	NSMShiftLeft 				; shift additive S[X+1] left
.9798		ca		dex				dex
.9799						_I32MShiftUpper:
.9799		e8		inx				inx 								; shift S[X+2] right
.979a		e8		inx				inx
.979b		20 a9 a4	jsr $a4a9			jsr 	NSMShiftRight
.979e		ca		dex				dex
.979f		ca		dex				dex
.97a0		80 d1		bra $9773			bra 	_I32MLoop 					; try again.
.97a2						_I32MExit:
.97a2		20 a8 97	jsr $97a8			jsr 	CalculateSign
.97a5		98		tya				tya 								; shift in A
.97a6		7a		ply				ply 								; restore Y and exit
.97a7		60		rts				rts
.97a8						CalculateSign:
.97a8		b5 50		lda $50,x			lda 	NSStatus,x 					; sign of result is 0 if same, 1 if different.
.97aa		16 50		asl $50,x			asl 	NSStatus,x 					; shift result left
.97ac		55 51		eor $51,x			eor 	NSStatus+1,x
.97ae		0a		asl a				asl 	a 							; shift bit 7 into carry
.97af		76 50		ror $50,x			ror 	NSStatus,x 					; shift right into status byte.
.97b1		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/scompare.asm

.97b2						CompareStrings:
.97b2		b5 50		lda $50,x			lda 	NSStatus,x 					; check both are strings
.97b4		35 51		and $51,x			and 	NSStatus+1,x
.97b6		29 10		and #$10			and 	#NSBIsString
.97b8		f0 28		beq $97e2			beq 	_CSTypeError
.97ba		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy string addresses to zTemp0/1
.97bc		85 36		sta $36				sta 	zTemp0
.97be		b5 70		lda $70,x			lda 	NSMantissa1,x
.97c0		85 37		sta $37				sta 	zTemp0+1
.97c2		b5 61		lda $61,x			lda 	NSMantissa0+1,x
.97c4		85 38		sta $38				sta 	zTemp1
.97c6		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.97c8		85 39		sta $39				sta 	zTemp1+1
.97ca		5a		phy				phy 								; save Y so we can access strings
.97cb		a0 ff		ldy #$ff			ldy 	#$FF 						; -1 for pre increment.
.97cd						_CSLoop:
.97cd		c8		iny				iny
.97ce		b1 36		lda ($36),y			lda 	(zTemp0),y 					; check if they are the same
.97d0		d1 38		cmp ($38),y			cmp 	(zTemp1),y
.97d2		d0 06		bne $97da			bne 	_CSDifferent
.97d4		c9 00		cmp #$00			cmp 	#0 							; reached end ?
.97d6		d0 f5		bne $97cd			bne 	_CSLoop 					; still comparing
.97d8						_CSExit:
.97d8		7a		ply				ply 								; reached end, return zero in A from EOS
.97d9		60		rts				rts
.97da						_CSDifferent:
.97da		a9 ff		lda #$ff			lda 	#255 						; if < return $FF
.97dc		90 fa		bcc $97d8			bcc		_CSExit
.97de		a9 01		lda #$01			lda 	#1 							; otherwise return 1.
.97e0		80 f6		bra $97d8			bra 	_CSExit
.97e2						_CSTypeError:
.97e2		4c 12 a6	jmp $a612			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/shifts.asm

.97e5						ShiftLeft:
.97e5		38		sec				sec 								; common code, carry determines which way.
.97e6		80 01		bra $97e9			bra 	ShiftMain
.97e8						ShiftRight:
.97e8		18		clc				clc
.97e9						ShiftMain:
.97e9		fa		plx				plx 								; restore X
.97ea		08		php				php 								; save direction
.97eb		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.97ed		15 51		ora $51,x			ora 	NSStatus+1,x
.97ef		0a		asl a				asl 	a 							; shift reference bit into sign bit
.97f0		0a		asl a				asl 	a
.97f1		10 05		bpl $97f8			bpl 	_NotRef
.97f3		48		pha				pha
.97f4		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.97f7		68		pla				pla
.97f8						_NotRef:
.97f8		0a		asl a				asl 	a
.97f9		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.97fb		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.97fd		15 a1		ora $a1,x			ora 	NSExponent+1,x
.97ff		f0 03		beq $9804			beq 	_IntegerCode 				; if clear, then we have two integers
.9801		4c 12 a6	jmp $a612			jmp 	TypeError 					; anything else, type mismatch.
.9804						_IntegerCode:
.9804		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; check number < 32
.9806		29 e0		and #$e0			and 	#$E0
.9808		15 71		ora $71,x			ora 	NSMantissa1+1,x
.980a		15 81		ora $81,x			ora 	NSMantissa2+1,x
.980c		15 91		ora $91,x			ora 	NSMantissa3+1,x
.980e		d0 12		bne $9822			bne 	_SMExit0 					; if >= 32 it will always return zero.
.9810						_SMLoop:
.9810		d6 61		dec $61,x			dec 	NSMantissa0+1,x 			; predecrement, could do << 0
.9812		30 11		bmi $9825			bmi 	_SMExit 					; exit if done.
.9814		28		plp				plp 								; restore direction setting
.9815		08		php				php
.9816		90 05		bcc $981d			bcc 	_SMRight
.9818		20 9f a4	jsr $a49f			jsr 	NSMShiftLeft 				; shift left if CS
.981b		80 f3		bra $9810			bra 	_SMLoop
.981d						_SMRight:
.981d		20 a9 a4	jsr $a4a9			jsr 	NSMShiftRight 				; shift right if CC
.9820		80 ee		bra $9810			bra 	_SMLoop
.9822						_SMExit0:
.9822		20 90 a4	jsr $a490			jsr 	NSMSetZero 					; return zero.
.9825						_SMExit:
.9825		28		plp				plp 								; throw direction
.9826		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/simple.asm

.9827						AddTopTwoStack:
.9827		18		clc				clc
.9828		b5 60		lda $60,x			lda		NSMantissa0,x
.982a		75 61		adc $61,x			adc 		NSMantissa0+1,x
.982c		95 60		sta $60,x			sta 	NSMantissa0,x
.982e		b5 70		lda $70,x			lda		NSMantissa1,x
.9830		75 71		adc $71,x			adc 		NSMantissa1+1,x
.9832		95 70		sta $70,x			sta 	NSMantissa1,x
.9834		b5 80		lda $80,x			lda		NSMantissa2,x
.9836		75 81		adc $81,x			adc 		NSMantissa2+1,x
.9838		95 80		sta $80,x			sta 	NSMantissa2,x
.983a		b5 90		lda $90,x			lda		NSMantissa3,x
.983c		75 91		adc $91,x			adc 		NSMantissa3+1,x
.983e		95 90		sta $90,x			sta 	NSMantissa3,x
.9840		60		rts				rts
.9841						SubTopTwoStack:
.9841		38		sec				sec
.9842		b5 60		lda $60,x			lda		NSMantissa0,x
.9844		f5 61		sbc $61,x			sbc 		NSMantissa0+1,x
.9846		95 60		sta $60,x			sta 	NSMantissa0,x
.9848		b5 70		lda $70,x			lda		NSMantissa1,x
.984a		f5 71		sbc $71,x			sbc 		NSMantissa1+1,x
.984c		95 70		sta $70,x			sta 	NSMantissa1,x
.984e		b5 80		lda $80,x			lda		NSMantissa2,x
.9850		f5 81		sbc $81,x			sbc 		NSMantissa2+1,x
.9852		95 80		sta $80,x			sta 	NSMantissa2,x
.9854		b5 90		lda $90,x			lda		NSMantissa3,x
.9856		f5 91		sbc $91,x			sbc 		NSMantissa3+1,x
.9858		95 90		sta $90,x			sta 	NSMantissa3,x
.985a		60		rts				rts
.985b						AddInteger:
.985b		fa		plx				plx
.985c		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.985e		15 51		ora $51,x			ora 	NSStatus+1,x
.9860		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9861		0a		asl a				asl 	a
.9862		10 05		bpl $9869			bpl 	_NotRef
.9864		48		pha				pha
.9865		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9868		68		pla				pla
.9869						_NotRef:
.9869		0a		asl a				asl 	a 							; put MSB of type into A:7
.986a		30 09		bmi $9875			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.986c		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.986e		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9870		f0 06		beq $9878			beq 	_IntegerCode 				; if clear, then we have two integers
.9872		4c 77 9a	jmp $9a77			jmp 	FloatingPointAdd 							; otherwise at least one float.
.9875						_StringData:
.9875		4c 34 96	jmp $9634			jmp 	StringConcat							; at least one string - don't know both are strings.
.9878						_IntegerCode:
.9878						AddCode:
.9878		b5 50		lda $50,x			lda 	NSStatus,x 					; signs are the same, can just add the mantissae.
.987a		55 51		eor $51,x			eor 	NSStatus+1,x
.987c		10 a9		bpl $9827			bpl 	AddTopTwoStack
.987e		20 41 98	jsr $9841			jsr 	SubTopTwoStack 				; do a physical subtraction
.9881		34 90		bit $90,x			bit 	NSMantissa3,x 				; result is +ve, okay
.9883		10 07		bpl $988c			bpl 	_AddExit
.9885		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign is that of 2nd value
.9887		95 50		sta $50,x			sta 	NSStatus,x
.9889		20 59 a4	jsr $a459			jsr 	NSMNegateMantissa 			; negate the mantissa and exit
.988c						_AddExit:
.988c		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; check for -0
.988f		d0 02		bne $9893			bne 	_AddNonZero
.9891		74 50		stz $50,x			stz 	NSStatus,x
.9893						_AddNonZero:
.9893		60		rts				rts
.9894						SubInteger:
.9894		fa		plx				plx
.9895		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9897		15 51		ora $51,x			ora 	NSStatus+1,x
.9899		0a		asl a				asl 	a 							; shift reference bit into sign bit
.989a		0a		asl a				asl 	a
.989b		10 05		bpl $98a2			bpl 	_NotRef
.989d		48		pha				pha
.989e		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.98a1		68		pla				pla
.98a2						_NotRef:
.98a2		0a		asl a				asl 	a 							; put MSB of type into A:7
.98a3		30 09		bmi $98ae			bmi 	_StringData 				; if the original bit 4 was set then do the string code.
.98a5		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.98a7		15 a1		ora $a1,x			ora 	NSExponent+1,x
.98a9		f0 06		beq $98b1			beq 	_IntegerCode 				; if clear, then we have two integers
.98ab		4c 7c 9a	jmp $9a7c			jmp 	FloatingPointSub 							; otherwise at least one float.
.98ae						_StringData:
.98ae		4c 1c a6	jmp $a61c			jmp 	NotDoneError							; at least one string - don't know both are strings.
.98b1						_IntegerCode:
.98b1		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate the second value.
.98b3		49 80		eor #$80			eor 	#$80
.98b5		95 51		sta $51,x			sta 	NSStatus+1,x
.98b7		80 bf		bra $9878			bra 	AddCode 					; and do the same code as add.
.98b9						AndInteger:
.98b9		fa		plx				plx
.98ba		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.98bc		15 51		ora $51,x			ora 	NSStatus+1,x
.98be		0a		asl a				asl 	a 							; shift reference bit into sign bit
.98bf		0a		asl a				asl 	a
.98c0		10 05		bpl $98c7			bpl 	_NotRef
.98c2		48		pha				pha
.98c3		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.98c6		68		pla				pla
.98c7						_NotRef:
.98c7		0a		asl a				asl 	a
.98c8		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.98ca		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.98cc		15 a1		ora $a1,x			ora 	NSExponent+1,x
.98ce		f0 03		beq $98d3			beq 	_IntegerCode 				; if clear, then we have two integers
.98d0		4c 12 a6	jmp $a612			jmp 	TypeError 					; anything else, type mismatch.
.98d3						_IntegerCode:
.98d3		b5 60		lda $60,x			lda		NSMantissa0,x
.98d5		35 61		and $61,x			and 		NSMantissa0+1,x
.98d7		95 60		sta $60,x			sta 	NSMantissa0,x
.98d9		b5 70		lda $70,x			lda		NSMantissa1,x
.98db		35 71		and $71,x			and 		NSMantissa1+1,x
.98dd		95 70		sta $70,x			sta 	NSMantissa1,x
.98df		b5 80		lda $80,x			lda		NSMantissa2,x
.98e1		35 81		and $81,x			and 		NSMantissa2+1,x
.98e3		95 80		sta $80,x			sta 	NSMantissa2,x
.98e5		b5 90		lda $90,x			lda		NSMantissa3,x
.98e7		35 91		and $91,x			and 		NSMantissa3+1,x
.98e9		95 90		sta $90,x			sta 	NSMantissa3,x
.98eb		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.98ed		60		rts				rts
.98ee						OraInteger:
.98ee		fa		plx				plx
.98ef		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.98f1		15 51		ora $51,x			ora 	NSStatus+1,x
.98f3		0a		asl a				asl 	a 							; shift reference bit into sign bit
.98f4		0a		asl a				asl 	a
.98f5		10 05		bpl $98fc			bpl 	_NotRef
.98f7		48		pha				pha
.98f8		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.98fb		68		pla				pla
.98fc						_NotRef:
.98fc		0a		asl a				asl 	a
.98fd		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.98ff		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9901		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9903		f0 03		beq $9908			beq 	_IntegerCode 				; if clear, then we have two integers
.9905		4c 12 a6	jmp $a612			jmp 	TypeError 					; anything else, type mismatch.
.9908						_IntegerCode:
.9908		b5 60		lda $60,x			lda		NSMantissa0,x
.990a		15 61		ora $61,x			ora 		NSMantissa0+1,x
.990c		95 60		sta $60,x			sta 	NSMantissa0,x
.990e		b5 70		lda $70,x			lda		NSMantissa1,x
.9910		15 71		ora $71,x			ora 		NSMantissa1+1,x
.9912		95 70		sta $70,x			sta 	NSMantissa1,x
.9914		b5 80		lda $80,x			lda		NSMantissa2,x
.9916		15 81		ora $81,x			ora 		NSMantissa2+1,x
.9918		95 80		sta $80,x			sta 	NSMantissa2,x
.991a		b5 90		lda $90,x			lda		NSMantissa3,x
.991c		15 91		ora $91,x			ora 		NSMantissa3+1,x
.991e		95 90		sta $90,x			sta 	NSMantissa3,x
.9920		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9922		60		rts				rts
.9923						EorInteger:
.9923		fa		plx				plx
.9924		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.9926		15 51		ora $51,x			ora 	NSStatus+1,x
.9928		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9929		0a		asl a				asl 	a
.992a		10 05		bpl $9931			bpl 	_NotRef
.992c		48		pha				pha
.992d		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9930		68		pla				pla
.9931						_NotRef:
.9931		0a		asl a				asl 	a
.9932		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9934		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.9936		15 a1		ora $a1,x			ora 	NSExponent+1,x
.9938		f0 03		beq $993d			beq 	_IntegerCode 				; if clear, then we have two integers
.993a		4c 12 a6	jmp $a612			jmp 	TypeError 					; anything else, type mismatch.
.993d						_IntegerCode:
.993d		b5 60		lda $60,x			lda		NSMantissa0,x
.993f		55 61		eor $61,x			eor 		NSMantissa0+1,x
.9941		95 60		sta $60,x			sta 	NSMantissa0,x
.9943		b5 70		lda $70,x			lda		NSMantissa1,x
.9945		55 71		eor $71,x			eor 		NSMantissa1+1,x
.9947		95 70		sta $70,x			sta 	NSMantissa1,x
.9949		b5 80		lda $80,x			lda		NSMantissa2,x
.994b		55 81		eor $81,x			eor 		NSMantissa2+1,x
.994d		95 80		sta $80,x			sta 	NSMantissa2,x
.994f		b5 90		lda $90,x			lda		NSMantissa3,x
.9951		55 91		eor $91,x			eor 		NSMantissa3+1,x
.9953		95 90		sta $90,x			sta 	NSMantissa3,x
.9955		74 50		stz $50,x			stz	 	NSStatus,x 					; ignore sign.
.9957		60		rts				rts
.9958						WordIndirect:
.9958		fa		plx				plx
.9959		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.995b		15 51		ora $51,x			ora 	NSStatus+1,x
.995d		0a		asl a				asl 	a 							; shift reference bit into sign bit
.995e		0a		asl a				asl 	a
.995f		10 05		bpl $9966			bpl 	_NotRef
.9961		48		pha				pha
.9962		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9965		68		pla				pla
.9966						_NotRef:
.9966		0a		asl a				asl 	a
.9967		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.9969		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.996b		15 a1		ora $a1,x			ora 	NSExponent+1,x
.996d		f0 03		beq $9972			beq 	_IntegerCode 				; if clear, then we have two integers
.996f		4c 12 a6	jmp $a612			jmp 	TypeError 					; anything else, type mismatch.
.9972						_IntegerCode:
.9972		20 78 98	jsr $9878			jsr 	AddCode 					; add the two values
.9975		a9 22		lda #$22			lda 	#NSBIsReference+2 			; make a 2 byte reference
.9977		95 50		sta $50,x			sta 	NSStatus,x
.9979		60		rts				rts
.997a						ByteIndirect:
.997a		fa		plx				plx
.997b		b5 50		lda $50,x			lda 	NSStatus,x 					; OR the type data together
.997d		15 51		ora $51,x			ora 	NSStatus+1,x
.997f		0a		asl a				asl 	a 							; shift reference bit into sign bit
.9980		0a		asl a				asl 	a
.9981		10 05		bpl $9988			bpl 	_NotRef
.9983		48		pha				pha
.9984		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; call the dereference code preserving A
.9987		68		pla				pla
.9988						_NotRef:
.9988		0a		asl a				asl 	a
.9989		29 c0		and #$c0			and 	#$C0 						; isolate the type bits which have been shifted
.998b		15 a0		ora $a0,x			ora 	NSExponent,x 				; check if both exponents are zero, e.g. both integers
.998d		15 a1		ora $a1,x			ora 	NSExponent+1,x
.998f		f0 03		beq $9994			beq 	_IntegerCode 				; if clear, then we have two integers
.9991		4c 12 a6	jmp $a612			jmp 	TypeError 					; anything else, type mismatch.
.9994						_IntegerCode:
.9994		20 78 98	jsr $9878			jsr 	AddCode 					; add the two values
.9997		a9 21		lda #$21			lda 	#NSBIsReference+1 			; make a 1 byte reference
.9999		95 50		sta $50,x			sta 	NSStatus,x
.999b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/binary/tostring.asm

.999c						ConvertInt16:
.999c		85 60		sta $60				sta 	NSMantissa0 				; set up as 32 bit conversion
.999e		86 70		stx $70				stx 	NSMantissa1
.99a0		64 80		stz $80				stz 	NSMantissa2
.99a2		64 90		stz $90				stz 	NSMantissa3
.99a4		64 50		stz $50				stz 	NSStatus 					; positive integer
.99a6		a2 00		ldx #$00			ldx 	#0 							; stack level
.99a8		a9 0a		lda #$0a			lda 	#10 						; base 10 decimal.
.99aa		80 00		bra $99ac			bra 	ConvertInt32
.99ac						ConvertInt32:
.99ac		5a		phy				phy
.99ad		a0 00		ldy #$00			ldy  	#0 							; index into buffer.
.99af		24 50		bit $50				bit 	NSStatus 					; output a - if not negative.
.99b1		10 08		bpl $99bb			bpl 	_CI32NotNeg
.99b3		48		pha				pha
.99b4		a9 2d		lda #$2d			lda 	#'-'
.99b6		99 43 06	sta $0643,y			sta 	numberBuffer,y
.99b9		c8		iny				iny
.99ba		68		pla				pla
.99bb						_CI32NotNeg:
.99bb		20 c9 99	jsr $99c9			jsr 	_CI32DivideConvert 			; recursive conversion
.99be		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.99c0		99 43 06	sta $0643,y			sta 	numberBuffer,y
.99c3		7a		ply				ply
.99c4		a2 06		ldx #$06			ldx 	#numberBuffer >> 8 			; return address in XA
.99c6		a9 43		lda #$43			lda 	#numberBuffer & $FF
.99c8		60		rts				rts
.99c9						_CI32DivideConvert:
.99c9		e8		inx				inx 								; write to next slot up
.99ca		20 92 a4	jsr $a492			jsr 	NSMSetByte 		 			; write the base out.
.99cd		ca		dex				dex
.99ce		20 f7 96	jsr $96f7			jsr 	Int32Divide 				; divide
.99d1		b5 60		lda $60,x			lda 	NSMantissa0,x 				; save remainder
.99d3		48		pha				pha
.99d4		20 b4 96	jsr $96b4			jsr 	NSMCopyPlusTwoToZero 		; Copy the divide result into place.
.99d7		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; is it zero ?
.99da		f0 05		beq $99e1			beq 	_CI32NoRecurse 				; if so, don't recursively call.
.99dc		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; this is the base which is not changed by divide
.99de		20 c9 99	jsr $99c9			jsr 	_CI32DivideConvert 			; and recusrively call.
.99e1						_CI32NoRecurse:
.99e1		68		pla				pla 								; remainder
.99e2		c9 0a		cmp #$0a			cmp 	#10 						; convert to ASCII, allowing for hexadecimal.
.99e4		90 02		bcc $99e8			bcc 	_CI32NotHex
.99e6		69 26		adc #$26			adc 	#6+32
.99e8						_CI32NotHex:
.99e8		69 30		adc #$30			adc 	#48
.99ea		99 43 06	sta $0643,y			sta 	numberBuffer,y 				; write out and exit
.99ed		c8		iny				iny
.99ee		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/expression.asm


;******  Processing file: ./common/expressions/../generated/precedence.dat

.99ef						PrecedenceLevel:
>99ef		04					.byte	 4	; $00 <<
>99f0		02					.byte	 2	; $01 <=
>99f1		02					.byte	 2	; $02 <>
>99f2		00					.byte	 0	; $03 !!3
>99f3		00					.byte	 0	; $04 ><
>99f4		02					.byte	 2	; $05 >=
>99f5		04					.byte	 4	; $06 >>
>99f6		00					.byte	 0	; $07 !!7
>99f7		00					.byte	 0	; $08 !!8
>99f8		00					.byte	 0	; $09 !!9
>99f9		00					.byte	 0	; $0a !!10
>99fa		00					.byte	 0	; $0b !!11
>99fb		00					.byte	 0	; $0c !!12
>99fc		00					.byte	 0	; $0d !!13
>99fd		00					.byte	 0	; $0e !!14
>99fe		00					.byte	 0	; $0f !!15
>99ff		00					.byte	 0	; $10 @
>9a00		00					.byte	 0	; $11 !!17
>9a01		00					.byte	 0	; $12 !!18
>9a02		00					.byte	 0	; $13 [
>9a03		04					.byte	 4	; $14 \
>9a04		00					.byte	 0	; $15 ]
>9a05		01					.byte	 1	; $16 ^
>9a06		00					.byte	 0	; $17 _
>9a07		00					.byte	 0	; $18 `
>9a08		00					.byte	 0	; $19 !!25
>9a09		00					.byte	 0	; $1a !!26
>9a0a		00					.byte	 0	; $1b {
>9a0b		01					.byte	 1	; $1c |
>9a0c		00					.byte	 0	; $1d }
>9a0d		00					.byte	 0	; $1e ~
>9a0e		00					.byte	 0	; $1f <7F>
>9a0f		00					.byte	 0	; $20
>9a10		05					.byte	 5	; $21 !
>9a11		00					.byte	 0	; $22 "
>9a12		00					.byte	 0	; $23 #
>9a13		05					.byte	 5	; $24 $
>9a14		04					.byte	 4	; $25 %
>9a15		01					.byte	 1	; $26 &
>9a16		00					.byte	 0	; $27 '
>9a17		00					.byte	 0	; $28 (
>9a18		00					.byte	 0	; $29 )
>9a19		04					.byte	 4	; $2a *
>9a1a		03					.byte	 3	; $2b +
>9a1b		00					.byte	 0	; $2c ,
>9a1c		03					.byte	 3	; $2d -
>9a1d		00					.byte	 0	; $2e .
>9a1e		04					.byte	 4	; $2f /
>9a1f		00					.byte	 0	; $30 0
>9a20		00					.byte	 0	; $31 1
>9a21		00					.byte	 0	; $32 2
>9a22		00					.byte	 0	; $33 3
>9a23		00					.byte	 0	; $34 4
>9a24		00					.byte	 0	; $35 5
>9a25		00					.byte	 0	; $36 6
>9a26		00					.byte	 0	; $37 7
>9a27		00					.byte	 0	; $38 8
>9a28		00					.byte	 0	; $39 9
>9a29		00					.byte	 0	; $3a :
>9a2a		00					.byte	 0	; $3b ;
>9a2b		02					.byte	 2	; $3c <
>9a2c		02					.byte	 2	; $3d =
>9a2d		02					.byte	 2	; $3e >
>9a2e		05					.byte	 5	; $3f ?

;******  Return to file: ./common/expressions/expression.asm

.9a2f						EvaluateExpressionAt0:
.9a2f		a2 00		ldx #$00			ldx 	#0 							; bottom stack level
.9a31						EvaluateExpression:
.9a31		a9 00		lda #$00			lda 	#0 							; lowest precedence level
.9a33						EvaluateExpressionAtPrecedence:
.9a33		48		pha				pha 								; save precedence level
.9a34		20 84 9e	jsr $9e84			jsr 	EvaluateTerm 				; evaluate term into level X.
.9a37		68		pla				pla 								; restore precedence level.
.9a38						_EXPRLoop:
.9a38		85 36		sta $36				sta 	zTemp0 						; save current precedence level.
.9a3a		b1 30		lda ($30),y			lda 	(codePtr),y
.9a3c		c9 40		cmp #$40			cmp		#$40 						; if >= $40 cannot be an operator
.9a3e		b0 25		bcs $9a65			bcs 	_EXPRExit
.9a40		da		phx				phx 								; read the operator precedence
.9a41		aa		tax				tax
.9a42		bd ef 99	lda $99ef,x			lda 	PrecedenceLevel,x
.9a45		fa		plx				plx
.9a46		c9 00		cmp #$00			cmp 	#0							; if zero exit (not an operator)
.9a48		f0 1b		beq $9a65			beq 	_EXPRExit
.9a4a		85 37		sta $37				sta 	zTemp0+1 					; save operator precedence level.
.9a4c		a5 36		lda $36				lda 	zTemp0 						; compare current precedence vs. operator precedence
.9a4e		c5 37		cmp $37				cmp 	zTemp0+1
.9a50		b0 13		bcs $9a65			bcs		_EXPRExit 					; if current >= operator exit
.9a52		48		pha				pha 								; save current precedence.
.9a53		b1 30		lda ($30),y			lda 	(codePtr),y
.9a55		c8		iny				iny
.9a56		48		pha				pha
.9a57		a5 37		lda $37				lda 	zTemp0+1 					; get operator precedence level
.9a59		e8		inx				inx 								; work out the right hand side.
.9a5a		20 33 9a	jsr $9a33			jsr 	EvaluateExpressionAtPrecedence
.9a5d		ca		dex				dex
.9a5e		68		pla				pla 								; get operator, call the code.
.9a5f		20 68 9a	jsr $9a68			jsr 	_EXPRCaller
.9a62		68		pla				pla 								; restore precedence level
.9a63		80 d3		bra $9a38			bra 	_EXPRLoop 					; and go round.
.9a65						_EXPRExit:
.9a65		a5 36		lda $36				lda 	zTemp0 						; A = current precedence level.
.9a67		60		rts				rts
.9a68						_EXPRCaller:
.9a68		e0 10		cpx #$10			cpx		#MathStackSize
.9a6a		b0 06		bcs $9a72			bge		_EXPRTooComplex
.9a6c		da		phx				phx 								; save on stack, first thing is to restore it
.9a6d		0a		asl a				asl 	a 							; double so can use vectors into X
.9a6e		aa		tax				tax
.9a6f		7c 90 91	jmp ($9190,x)			jmp 	(VectorSetPunc,x) 			; and go to the code.
.9a72						_EXPRTooComplex:
.9a72		a9 1e		lda #$1e		lda	#30
.9a74		4c 27 95	jmp $9527		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/addsub.asm

.9a77						FloatingPointAdd:
.9a77		20 ed 9b	jsr $9bed			jsr 	FloatPrepare 				; prepare for floats
.9a7a		80 09		bra $9a85			bra 	FloatAdd
.9a7c						FloatingPointSub:
.9a7c		20 ed 9b	jsr $9bed			jsr 	FloatPrepare 				; prepare for floats
.9a7f						FloatSubtract:
.9a7f		b5 51		lda $51,x			lda 	NSStatus+1,x 				; negate FPB
.9a81		49 80		eor #$80			eor 	#$80
.9a83		95 51		sta $51,x			sta 	NSStatus+1,x				; and fall through.
.9a85						FloatAdd:
.9a85		48		pha				pha
.9a86		5a		phy				phy
.9a87		20 fc 9b	jsr $9bfc			jsr 	NSNormalise 				; normalise S[X]
.9a8a		f0 51		beq $9add			beq 	_FAReturn1
.9a8c		e8		inx				inx 								; normalise S[X+1]
.9a8d		20 fc 9b	jsr $9bfc			jsr 	NSNormalise
.9a90		ca		dex				dex
.9a91		c9 00		cmp #$00			cmp 	#0
.9a93		f0 60		beq $9af5			beq 	_FAExit 					; if so, just return A
.9a95		b5 a0		lda $a0,x			lda 	NSExponent,x 				; are the exponents the same ?
.9a97		d5 a1		cmp $a1,x			cmp 	NSExponent+1,x
.9a99		f0 18		beq $9ab3			beq 	_FAExponentsEqual
.9a9b		b5 a0		lda $a0,x			lda 	NSExponent,x 				; work out the larger exponent
.9a9d		a8		tay				tay
.9a9e		38		sec				sec 								; do a signed comparison of the exponents.
.9a9f		f5 a1		sbc $a1,x			sbc 	NSExponent+1,x
.9aa1		50 02		bvc $9aa5			bvc 	_FANoSignedChange
.9aa3		49 80		eor #$80			eor 	#$80
.9aa5						_FANoSignedChange:
.9aa5		29 80		and #$80			and 	#$80
.9aa7		10 02		bpl $9aab			bpl 	_FAHaveMax
.9aa9		b4 a1		ldy $a1,x			ldy 	NSExponent+1,x
.9aab						_FAHaveMax:
.9aab		20 f8 9a	jsr $9af8			jsr 	_FAShiftToExponent  		; shift both to the exponent in Y
.9aae		e8		inx				inx
.9aaf		20 f8 9a	jsr $9af8			jsr 	_FAShiftToExponent
.9ab2		ca		dex				dex
.9ab3						_FAExponentsEqual:
.9ab3		b5 50		lda $50,x			lda 	NSStatus,x 					; are the signs the same
.9ab5		55 51		eor $51,x			eor 	NSStatus+1,x
.9ab7		30 0e		bmi $9ac7			bmi 	_FADifferentSigns
.9ab9		20 27 98	jsr $9827			jsr 	AddTopTwoStack 				; do the add of the mantissae
.9abc		b5 90		lda $90,x			lda 	NSMantissa3,x 				; do we have an overflow in Mantissa A ?
.9abe		10 35		bpl $9af5			bpl 	_FAExit 					; if no, we are done.
.9ac0		20 a9 a4	jsr $a4a9			jsr 	NSMShiftRight 				; shift A right, renormalising it.
.9ac3		f6 a0		inc $a0,x			inc 	NSExponent,x 				; bump the exponent and exit
.9ac5		80 2e		bra $9af5			bra 	_FAExit
.9ac7						_FADifferentSigns:
.9ac7		20 41 98	jsr $9841			jsr 	SubTopTwoStack 				; subtract mantissa B from A
.9aca		b5 90		lda $90,x			lda 	NSMantissa3,x 				; is the result negative ?
.9acc		10 06		bpl $9ad4			bpl 	_FACheckZero 				; if no, check for -0
.9ace		20 52 a4	jsr $a452			jsr 	NSMNegate 					; netate result
.9ad1		20 59 a4	jsr $a459			jsr 	NSMNegateMantissa 			; negate (2'c) the mantissa
.9ad4						_FACheckZero:
.9ad4		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero	 				; check for -0
.9ad7		d0 1c		bne $9af5			bne 	_FAExit
.9ad9		74 50		stz $50,x			stz 	NSStatus,x
.9adb		80 18		bra $9af5			bra 	_FAExit
.9add						_FAReturn1:
.9add		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; called when S(X) is zero.
.9adf		95 60		sta $60,x			sta 	NSMantissa0,x
.9ae1		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.9ae3		95 70		sta $70,x			sta 	NSMantissa1,x
.9ae5		b5 81		lda $81,x			lda 	NSMantissa2+1,x
.9ae7		95 80		sta $80,x			sta 	NSMantissa2,x
.9ae9		b5 91		lda $91,x			lda 	NSMantissa3+1,x
.9aeb		95 90		sta $90,x			sta 	NSMantissa3,x
.9aed		b5 a1		lda $a1,x			lda 	NSExponent+1,x
.9aef		95 a0		sta $a0,x			sta 	NSExponent,x
.9af1		b5 51		lda $51,x			lda 	NSStatus+1,x
.9af3		95 50		sta $50,x			sta 	NSStatus,x
.9af5						_FAExit:
.9af5		7a		ply				ply
.9af6		68		pla				pla
.9af7		60		rts				rts
.9af8						_FAShiftToExponent:
.9af8						_FAShiftToExponent2:
.9af8		98		tya				tya 								; compare Y to exponent
.9af9		d5 a0		cmp $a0,x			cmp 	NSExponent,x 				; reached the exponent required ?
.9afb		f0 07		beq $9b04			beq 	_FASEExit 					; exit if so.
.9afd		20 a9 a4	jsr $a4a9			jsr 	NSMShiftRight	 			; shift the mantissa right
.9b00		f6 a0		inc $a0,x			inc 	NSExponent,x 				; increment exponent
.9b02		80 f4		bra $9af8			bra 	_FAShiftToExponent2
.9b04						_FASEExit:
.9b04		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/compare.asm

.9b05						CompareFloat:
.9b05		20 7f 9a	jsr $9a7f			jsr 	FloatSubtract 				; Calculate S[X]-S[X+1]
.9b08		b5 70		lda $70,x			lda 	NSMantissa1,x 			 	; so we ignore this - by changing bits checked
.9b0a		29 f8		and #$f8			and 	#$F8
.9b0c		15 80		ora $80,x			ora 	NSMantissa2,x
.9b0e		15 90		ora $90,x			ora 	NSMantissa3,x
.9b10		f0 08		beq $9b1a			beq 	_FCExit 					; zero, so approximately identical
.9b12		a9 01		lda #$01			lda 	#1 							; return +1 if result>0
.9b14		34 50		bit $50,x			bit 	NSStatus,x
.9b16		10 02		bpl $9b1a			bpl 	_FCExit
.9b18						_FCNegative:
.9b18		a9 ff		lda #$ff			lda 	#$FF 						; and return -1 if result<0
.9b1a						_FCExit:
.9b1a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/divide.asm

.9b1b						FDivideCommand:
.9b1b		fa		plx				plx	 								; restore stack position
.9b1c		20 ed 9b	jsr $9bed			jsr 	FloatPrepare 				; prepare for floats
.9b1f						FloatDivide:
.9b1f		48		pha				pha
.9b20		e8		inx				inx
.9b21		20 fc 9b	jsr $9bfc			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9b24		ca		dex				dex
.9b25		c9 00		cmp #$00			cmp 	#0
.9b27		f0 1d		beq $9b46			beq 	_FDZero
.9b29		20 fc 9b	jsr $9bfc			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9b2c		f0 16		beq $9b44			beq 	_FDExit 					; return zero if zero (e.g. zero/something)
.9b2e		20 18 97	jsr $9718			jsr 	Int32ShiftDivide 			; do the shift division for dividing.
.9b31		20 b4 96	jsr $96b4			jsr 	NSMCopyPlusTwoToZero 		; copy the mantissa down
.9b34		20 fc 9b	jsr $9bfc			jsr		NSNormalise 				; renormalise
.9b37		20 a8 97	jsr $97a8			jsr 	CalculateSign 				; calculate result sign
.9b3a		b5 a0		lda $a0,x			lda 	NSExponent,x 				; calculate exponent
.9b3c		38		sec				sec
.9b3d		f5 a1		sbc $a1,x			sbc 	NSExponent+1,x
.9b3f		38		sec				sec
.9b40		e9 1e		sbc #$1e			sbc 	#30
.9b42		95 a0		sta $a0,x			sta 	NSExponent,x
.9b44						_FDExit:
.9b44		68		pla				pla
.9b45		60		rts				rts
.9b46						_FDZero:
.9b46		a9 03		lda #$03		lda	#3
.9b48		4c 27 95	jmp $9527		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/fractional.asm

.9b4b						FloatFractionalPart:
.9b4b		5a		phy				phy
.9b4c		b5 50		lda $50,x			lda 	NSStatus,x 					; take absolute value
.9b4e		29 7f		and #$7f			and 	#$7F
.9b50		95 50		sta $50,x			sta 	NSStatus,x
.9b52		20 fc 9b	jsr $9bfc			jsr 	NSNormalise
.9b55		b5 a0		lda $a0,x			lda 	NSExponent,x 				; calculate exponent-$E0 = digits to blank
.9b57		38		sec				sec
.9b58		e9 e0		sbc #$e0			sbc 	#$E0
.9b5a		90 29		bcc $9b85			bcc 	_FFPExit 					; already fractional
.9b5c		c9 20		cmp #$20			cmp 	#32 						; will be zero as blanking 32+ digits.
.9b5e		b0 22		bcs $9b82			bcs 	_FFPZero
.9b60		a8		tay				tay 								; put count to do in Y
.9b61		b5 90		lda $90,x			lda 	NSMantissa3,x 				; do each in turn.
.9b63		20 87 9b	jsr $9b87			jsr 	_FFPPartial
.9b66		95 90		sta $90,x			sta 	NSMantissa3,x
.9b68		b5 80		lda $80,x			lda 	NSMantissa2,x
.9b6a		20 87 9b	jsr $9b87			jsr 	_FFPPartial
.9b6d		95 80		sta $80,x			sta 	NSMantissa2,x
.9b6f		b5 70		lda $70,x			lda 	NSMantissa1,x
.9b71		20 87 9b	jsr $9b87			jsr 	_FFPPartial
.9b74		95 70		sta $70,x			sta 	NSMantissa1,x
.9b76		b5 60		lda $60,x			lda 	NSMantissa0,x
.9b78		20 87 9b	jsr $9b87			jsr 	_FFPPartial
.9b7b		95 60		sta $60,x			sta 	NSMantissa0,x
.9b7d		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; zeroed check.
.9b80		d0 03		bne $9b85			bne 	_FFPExit
.9b82						_FFPZero:
.9b82		20 90 a4	jsr $a490			jsr 	NSMSetZero
.9b85						_FFPExit:
.9b85		7a		ply				ply
.9b86		60		rts				rts
.9b87						_FFPPartial:
.9b87		c0 00		cpy #$00			cpy 	#0 							; no more to do
.9b89		f0 17		beq $9ba2			beq 	_FFFPPExit
.9b8b		c0 08		cpy #$08			cpy 	#8 							; whole byte to do ?
.9b8d		b0 0c		bcs $9b9b			bcs 	_FFFPPWholeByte
.9b8f		5a		phy				phy
.9b90						_FFFPPLeft:
.9b90		0a		asl a				asl 	a
.9b91		88		dey				dey
.9b92		d0 fc		bne $9b90			bne 	_FFFPPLeft
.9b94		7a		ply				ply
.9b95						_FFFPPRight:
.9b95		4a		lsr a				lsr 	a
.9b96		88		dey				dey
.9b97		d0 fc		bne $9b95			bne 	_FFFPPRight
.9b99		80 07		bra $9ba2			bra 	_FFFPPExit
.9b9b						_FFFPPWholeByte:
.9b9b		98		tya				tya 								; subtract 8 from count
.9b9c		38		sec				sec
.9b9d		e9 08		sbc #$08			sbc 	#8
.9b9f		a8		tay				tay
.9ba0		a9 00		lda #$00			lda 	#0 							; and clear all
.9ba2						_FFFPPExit:
.9ba2		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/integer.asm

.9ba3						FloatIntegerPart:
.9ba3		48		pha				pha
.9ba4		b5 a0		lda $a0,x			lda 	NSExponent,x 				; is it integer already ?
.9ba6		f0 1d		beq $9bc5			beq 	_FIPExit 					; if so do nothing
.9ba8		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; is it zero ?
.9bab		f0 15		beq $9bc2			beq 	_FIPZero 					; if so return zero.
.9bad		20 fc 9b	jsr $9bfc			jsr 	NSNormalise 				; normalise
.9bb0		f0 10		beq $9bc2			beq 	_FIPZero 					; normalised to zero, exit zero
.9bb2						_FIPShift:
.9bb2		b5 a0		lda $a0,x			lda 	NSExponent,x 				; if Exponent >= 0 exit.
.9bb4		10 07		bpl $9bbd			bpl 	_FIPCheckZero
.9bb6		20 a9 a4	jsr $a4a9			jsr 	NSMShiftRight 				; shift mantissa right
.9bb9		f6 a0		inc $a0,x			inc 	NSExponent,x 				; bump exponent
.9bbb		80 f5		bra $9bb2			bra 	_FIPShift
.9bbd						_FIPCheckZero:
.9bbd		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; avoid -0 problem
.9bc0		d0 03		bne $9bc5			bne 	_FIPExit 					; set to zero if mantissa zero.
.9bc2						_FIPZero:
.9bc2		20 90 a4	jsr $a490			jsr 	NSMSetZero
.9bc5						_FIPExit:
.9bc5		68		pla				pla
.9bc6		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/multiply.asm

.9bc7						FloatingPointMultiply:
.9bc7		20 ed 9b	jsr $9bed			jsr 	FloatPrepare 				; prepare for floats
.9bca						FloatMultiply:
.9bca		48		pha				pha
.9bcb		20 fc 9b	jsr $9bfc			jsr 	NSNormalise		 			; normalise S[X] and exit if zero
.9bce		f0 18		beq $9be8			beq 	_FDExit 					; return zero if zero (e.g. zero*something)
.9bd0		e8		inx				inx
.9bd1		20 fc 9b	jsr $9bfc			jsr 	NSNormalise		 			; normalise S[x+1] and error if zero.
.9bd4		ca		dex				dex
.9bd5		c9 00		cmp #$00			cmp 	#0
.9bd7		f0 0c		beq $9be5			beq 	_FDSetZero
.9bd9		20 6a 97	jsr $976a			jsr 	MultiplyShort 				; calculate the result.
.9bdc		75 a0		adc $a0,x			adc 	NSExponent,x 				; calculate exponent including the shift.
.9bde		18		clc				clc
.9bdf		75 a1		adc $a1,x			adc 	NSExponent+1,x
.9be1		95 a0		sta $a0,x			sta 	NSExponent,x
.9be3		80 03		bra $9be8			bra 	_FDExit
.9be5						_FDSetZero:
.9be5		20 90 a4	jsr $a490			jsr 	NSMSetZero 					; return 0
.9be8						_FDExit:
.9be8		20 fc 9b	jsr $9bfc			jsr 	NSNormalise 				; normalise the result
.9beb		68		pla				pla
.9bec		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/float/utility.asm

.9bed						FloatPrepare:
.9bed		20 f8 9c	jsr $9cf8			jsr 	DereferenceTopTwo 			; dereference the top two values
.9bf0		b5 50		lda $50,x			lda 	NSStatus,x 					; check ints/floats, either will do.
.9bf2		15 51		ora $51,x			ora 	NSStatus+1,x
.9bf4		29 10		and #$10			and 	#NSBIsString
.9bf6		d0 01		bne $9bf9			bne 	_FDType
.9bf8		60		rts				rts
.9bf9						_FDType:
.9bf9		4c 12 a6	jmp $a612			jmp 	TypeError
.9bfc						NSNormalise:
.9bfc		b5 50		lda $50,x			lda 	NSStatus,x 					; make float, keep sign
.9bfe		29 80		and #$80			and 	#$80
.9c00		09 08		ora #$08			ora 	#NSTFloat
.9c02		95 50		sta $50,x			sta 	NSStatus,x
.9c04		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; if zero exit
.9c07		d0 07		bne $9c10			bne 	_NSNormaliseOptimise 		; if so, normalise it.
.9c09		16 50		asl $50,x			asl 	NSStatus,x 					; clear the sign bit.
.9c0b		76 50		ror $50,x			ror 	NSStatus,x 					; (no -0)
.9c0d		a9 00		lda #$00			lda 	#0 							; set Z flag
.9c0f		60		rts				rts
.9c10						_NSNormaliseOptimise:
.9c10		b5 90		lda $90,x			lda 	NSMantissa3,x 				; upper byte zero ?
.9c12		d0 19		bne $9c2d			bne 	_NSNormaliseLoop
.9c14		b5 80		lda $80,x			lda 	NSMantissa2,x 				; byte normalise
.9c16		30 15		bmi $9c2d			bmi 	_NSNormaliseLoop 			; can't do it if bit 7 set of 2
.9c18		95 90		sta $90,x			sta 	NSMantissa3,x
.9c1a		b5 70		lda $70,x			lda 	NSMantissa1,x
.9c1c		95 80		sta $80,x			sta 	NSMantissa2,x
.9c1e		b5 60		lda $60,x			lda 	NSMantissa0,x
.9c20		95 70		sta $70,x			sta 	NSMantissa1,x
.9c22		74 60		stz $60,x			stz 	NSMantissa0,x
.9c24		b5 a0		lda $a0,x			lda 	NSExponent,x
.9c26		38		sec				sec
.9c27		e9 08		sbc #$08			sbc 	#8
.9c29		95 a0		sta $a0,x			sta 	NSExponent,x
.9c2b		80 e3		bra $9c10			bra 	_NSNormaliseOptimise
.9c2d						_NSNormaliseLoop:
.9c2d		34 90		bit $90,x			bit 	NSMantissa3,x 				; bit 30 set ?
.9c2f		70 07		bvs $9c38			bvs 	_NSNExit 					; exit if so with Z flag clear
.9c31		20 9f a4	jsr $a49f			jsr 	NSMShiftLeft 				; shift mantissa left
.9c34		d6 a0		dec $a0,x			dec 	NSExponent,x 				; adjust exponent
.9c36		80 f5		bra $9c2d			bra 	_NSNormaliseLoop
.9c38						_NSNExit:
.9c38		a9 ff		lda #$ff			lda 	#$FF 						; clear Z flag
.9c3a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignnumber.asm

.9c3b						AssignNumber:
.9c3b		5a		phy				phy
.9c3c		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy mantissa0/1 to zTemp0
.9c3e		85 36		sta $36				sta 	zTemp0
.9c40		b5 70		lda $70,x			lda 	NSMantissa1,x
.9c42		85 37		sta $37				sta 	zTemp0+1
.9c44		b5 50		lda $50,x			lda 	NSStatus,x 					; clear reference bits
.9c46		29 df		and #$df			and 	#(NSBIsReference ^ $FF)
.9c48		95 50		sta $50,x			sta 	NSStatus,x
.9c4a		29 18		and #$18			and 	#NSBTypeMask				; assigning to a float ?
.9c4c		c9 08		cmp #$08			cmp 	#NSTFloat
.9c4e		f0 24		beq $9c74			beq 	_ANFloat
.9c50		b5 a1		lda $a1,x			lda		NSExponent+1,x 				; is it a float
.9c52		f0 03		beq $9c57			beq		_ANNotFloat
.9c54		4c 0d a6	jmp $a60d			jmp 	RangeError					; if it is, report an error.
.9c57						_ANNotFloat:
.9c57		b5 50		lda $50,x			lda 	NSStatus,x 					; check if byte/word reference.
.9c59		29 03		and #$03			and 	#3
.9c5b		d0 05		bne $9c62			bne 	_ANByteWord
.9c5d		20 7f 9c	jsr $9c7f			jsr 	_ANCopy4PackSign 			; copy all 4 bytes and sign
.9c60		80 1b		bra $9c7d			bra 	_ANExit
.9c62						_ANByteWord:
.9c62		48		pha				pha 								; save count
.9c63		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; do byte
.9c65		92 36		sta ($36)			sta 	(zTemp0)
.9c67		68		pla				pla
.9c68		c9 01		cmp #$01			cmp	 	#1
.9c6a		f0 11		beq $9c7d			beq 	_ANExit
.9c6c		b5 71		lda $71,x			lda 	NSMantissa1+1,x 			; do word
.9c6e		a0 01		ldy #$01			ldy 	#1
.9c70		91 36		sta ($36),y			sta 	(zTemp0),y
.9c72		80 09		bra $9c7d			bra 	_ANExit
.9c74						_ANFloat:
.9c74		20 7f 9c	jsr $9c7f			jsr 	_ANCopy4PackSign 			; write all 4 bytes and packed sign
.9c77		b5 a1		lda $a1,x			lda 	NSExponent+1,x 				; copy exponent to slot 4
.9c79		a0 04		ldy #$04			ldy 	#4
.9c7b		91 36		sta ($36),y			sta 	(zTemp0),y
.9c7d						_ANExit:
.9c7d		7a		ply				ply
.9c7e		60		rts				rts
.9c7f						_ANCopy4PackSign:
.9c7f		a0 03		ldy #$03			ldy 	#3
.9c81		b5 51		lda $51,x			lda 	NSStatus+1,x 				; sign bit into status
.9c83		29 80		and #$80			and 	#$80 						; put into high bit of mantissa 3
.9c85		15 91		ora $91,x			ora 	NSMantissa3+1,x
.9c87		91 36		sta ($36),y			sta 	(zTemp0),y
.9c89		88		dey				dey
.9c8a		b5 81		lda $81,x			lda 	NSMantissa2+1,x
.9c8c		91 36		sta ($36),y			sta 	(zTemp0),y
.9c8e		88		dey				dey
.9c8f		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.9c91		91 36		sta ($36),y			sta 	(zTemp0),y
.9c93		88		dey				dey
.9c94		b5 61		lda $61,x			lda 	NSMantissa0+1,x
.9c96		91 36		sta ($36),y			sta 	(zTemp0),y
.9c98		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/assignstring.asm

.9c99						AssignString:
.9c99		5a		phy				phy
.9c9a		b5 61		lda $61,x			lda 	NSMantissa0+1,x
.9c9c		85 38		sta $38				sta 	zTemp1
.9c9e		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.9ca0		85 39		sta $39				sta 	zTemp1+1
.9ca2		b5 60		lda $60,x			lda 	NSMantissa0,x
.9ca4		85 36		sta $36				sta 	zTemp0
.9ca6		b5 70		lda $70,x			lda 	NSMantissa1,x
.9ca8		85 37		sta $37				sta 	zTemp0+1
.9caa		a0 01		ldy #$01			ldy 	#1 							; the high byte of the target address
.9cac		b1 36		lda ($36),y			lda 	(zTemp0),y
.9cae		f0 23		beq $9cd3			beq 	_ASNewStringRequired 		; if zero, a new string is required.
.9cb0		38		sec				sec 								; put Address-2 in zsTemp - this is the size/status/string record
.9cb1		b2 36		lda ($36)			lda 	(zTemp0) 					; of concreted strings
.9cb3		e9 02		sbc #$02			sbc 	#2
.9cb5		85 3c		sta $3c				sta 	zsTemp
.9cb7		a0 01		ldy #$01			ldy 	#1
.9cb9		b1 36		lda ($36),y			lda 	(zTemp0),y
.9cbb		e9 00		sbc #$00			sbc 	#0
.9cbd		85 3d		sta $3d				sta 	zsTemp+1
.9cbf		a0 ff		ldy #$ff			ldy 	#$FF 						; get length of new string
.9cc1						_ASGetLength:
.9cc1		c8		iny				iny
.9cc2		b1 38		lda ($38),y			lda 	(zTemp1),y
.9cc4		d0 fb		bne $9cc1			bne 	_ASGetLength
.9cc6		98		tya				tya 								; is this length <= current length
.9cc7		d2 3c		cmp ($3c)			cmp 	(zsTemp)
.9cc9		90 1e		bcc $9ce9			bcc 	_ASCopyString
.9ccb		f0 1c		beq $9ce9			beq 	_ASCopyString
.9ccd		a9 80		lda #$80			lda 	#$80 						; mark as unused.
.9ccf		a0 01		ldy #$01			ldy 	#1
.9cd1		91 3c		sta ($3c),y			sta 	(zsTemp),y
.9cd3						_ASNewStringRequired:
.9cd3		e8		inx				inx 								; concrete the new string.
.9cd4		20 4a b7	jsr $b74a			jsr 	StringConcrete				; (breaks zTemp1/2, not zTemp0 and zsTemp)
.9cd7		ca		dex				dex
.9cd8		18		clc				clc
.9cd9		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; copy that new address to the reference.
.9cdb		69 02		adc #$02			adc 	#2 							; add two to point at the data.
.9cdd		92 36		sta ($36)			sta 	(zTemp0)
.9cdf		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.9ce1		69 00		adc #$00			adc 	#0
.9ce3		a0 01		ldy #$01			ldy 	#1
.9ce5		91 36		sta ($36),y			sta 	(zTemp0),y
.9ce7		80 0d		bra $9cf6			bra 	_ASExit
.9ce9						_ASCopyString:
.9ce9		a0 00		ldy #$00			ldy 	#0
.9ceb						_ASCopyLoop:
.9ceb		b1 38		lda ($38),y			lda 	(zTemp1),y
.9ced		c8		iny				iny
.9cee		c8		iny				iny
.9cef		91 3c		sta ($3c),y			sta 	(zsTemp),y
.9cf1		88		dey				dey
.9cf2		c9 00		cmp #$00			cmp 	#0
.9cf4		d0 f5		bne $9ceb			bne 	_ASCopyLoop
.9cf6						_ASExit:
.9cf6		7a		ply				ply
.9cf7		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/dereference.asm

.9cf8						DereferenceTopTwo:
.9cf8		e8		inx				inx
.9cf9		20 fd 9c	jsr $9cfd			jsr 	Dereference 				; deref x+1
.9cfc		ca		dex				dex  								; falls through to deref x
.9cfd						Dereference:
.9cfd		b5 50		lda $50,x			lda 	NSStatus,x 					; get the status byte
.9cff		29 20		and #$20			and 	#NSBIsReference 			; is it a reference
.9d01		f0 48		beq $9d4b			beq 	_DRFExit 					; not a reference, so exit.
.9d03		5a		phy				phy
.9d04		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy address to dereference into zTemp0
.9d06		85 36		sta $36				sta 	zTemp0
.9d08		b5 70		lda $70,x			lda 	NSMantissa1,x
.9d0a		85 37		sta $37				sta 	zTemp0+1
.9d0c		74 70		stz $70,x			stz 	NSMantissa1,x 				; clear second byte.
.9d0e		b2 36		lda ($36)			lda 	(zTemp0) 					; do the first byte
.9d10		95 60		sta $60,x			sta 	NSMantissa0,x
.9d12		b5 50		lda $50,x			lda 	NSStatus,x 					; get status byte.
.9d14		29 18		and #$18			and 	#NSBTypeMask 				; what type is it ?
.9d16		c9 10		cmp #$10			cmp 	#NSTString 					; if string, dereference two
.9d18		f0 0e		beq $9d28			beq 	_DRFDereferenceTwo
.9d1a		c9 08		cmp #$08			cmp 	#NSTFloat 					; if float, do full dereference.
.9d1c		f0 2f		beq $9d4d			beq 	_DRFFull
.9d1e		b5 50		lda $50,x			lda 	NSStatus,x 					; must be integer - how many bytes ?
.9d20		29 03		and #$03			and 	#3
.9d22		f0 29		beq $9d4d			beq 	_DRFFull 					; the whole word
.9d24		c9 01		cmp #$01			cmp 	#1 							; is it 10 (e.g. 2 bytes)
.9d26		f0 06		beq $9d2e			beq		_DRFClear23 				; no, one byte, clear 2 & 3 and exit
.9d28						_DRFDereferenceTwo:
.9d28		a0 01		ldy #$01			ldy 	#1
.9d2a		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d2c		95 70		sta $70,x			sta 	NSMantissa1,x
.9d2e						_DRFClear23:
.9d2e		74 80		stz $80,x			stz 	NSMantissa2,x 				; clear upper bytes, only read 1 or 2 bytes
.9d30		74 90		stz $90,x			stz 	NSMantissa3,x
.9d32		b5 50		lda $50,x			lda 	NSStatus,x 					; make it a value of that type.
.9d34		29 18		and #$18			and 	#NSBTypeMask
.9d36		95 50		sta $50,x			sta 	NSStatus,x 					; and fall through.
.9d38		c9 10		cmp #$10			cmp 	#NSTString  				; is it a string
.9d3a		d0 0e		bne $9d4a			bne 	_DRFNotString
.9d3c		b5 60		lda $60,x			lda 	NSMantissa0,x 				; check address is zero
.9d3e		15 70		ora $70,x			ora 	NSMantissa1,x
.9d40		d0 08		bne $9d4a			bne 	_DRFNotString
.9d42		a9 4c		lda #$4c			lda 	#_DRFNullString & $FF 		; if so, return reference to ""
.9d44		95 60		sta $60,x			sta 	NSMantissa0,x
.9d46		a9 9d		lda #$9d			lda 	#_DRFNullString >> 8
.9d48		95 70		sta $70,x			sta 	NSMantissa1,x
.9d4a						_DRFNotString
.9d4a		7a		ply				ply 								; restore Y and exit
.9d4b						_DRFExit:
.9d4b		60		rts				rts
.9d4c						_DRFNullString:
>9d4c		00						.byte 	0
.9d4d						_DRFFull:
.9d4d		a0 01		ldy #$01			ldy 	#1 							; get remaining 3 bytes.
.9d4f		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d51		95 70		sta $70,x			sta 	NSMantissa1,x
.9d53		c8		iny				iny
.9d54		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d56		95 80		sta $80,x			sta 	NSMantissa2,x
.9d58		c8		iny				iny
.9d59		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d5b		95 90		sta $90,x			sta 	NSMantissa3,x
.9d5d		74 a0		stz $a0,x			stz 	NSExponent,x 				; clear exponent.
.9d5f		b5 50		lda $50,x			lda		NSStatus,x 					; see if type is integer
.9d61		29 18		and #$18			and 	#NSBTypeMask  				; type information only
.9d63		95 50		sta $50,x			sta 	NSStatus,x 					; update it back.
.9d65		f0 05		beq $9d6c			beq 	_DRFNoExponent
.9d67		c8		iny				iny 								; if not, read the exponent as well.
.9d68		b1 36		lda ($36),y			lda 	(zTemp0),y
.9d6a		95 a0		sta $a0,x			sta 	NSExponent,x
.9d6c						_DRFNoExponent:
.9d6c		b5 90		lda $90,x			lda 	NSMantissa3,x 				; is the most significant bit set ?
.9d6e		10 0a		bpl $9d7a			bpl 	_DRFExit2 					; if not, then exit.
.9d70		29 7f		and #$7f			and 	#$7F 						; clear that bit.
.9d72		95 90		sta $90,x			sta 	NSMantissa3,x
.9d74		b5 50		lda $50,x			lda 	NSStatus,x 					; set the sign flag
.9d76		09 80		ora #$80			ora 	#NSBIsNegative
.9d78		95 50		sta $50,x			sta 	NSStatus,x
.9d7a						_DRFExit2:
.9d7a		7a		ply				ply
.9d7b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/number.asm

=1						ESTA_Low = 1 								; state 1 is 1 byte, switches when A >= 24.
=2						ESTA_High = 2 								; loading up to 32 bit integer in the mantissa
=3						ESTA_Decimal = 3 							; fractional part.
.9d7c						EncodeNumberStart:
.9d7c		38		sec				sec
.9d7d		80 01		bra $9d80			bra 	EncodeNumberContinue+1
.9d7f						EncodeNumberContinue:
.9d7f		18		clc				clc
.9d80						EncodeNumber:
.9d80		08		php				php 								; save reset flag.
.9d81		c9 2e		cmp #$2e			cmp 	#"." 						; only accept 0-9 and .
.9d83		f0 12		beq $9d97			beq 	_ENIsOkay
.9d85		c9 30		cmp #$30			cmp 	#"0"
.9d87		90 04		bcc $9d8d			bcc 	_ENBadNumber
.9d89		c9 3a		cmp #$3a			cmp 	#"9"+1
.9d8b		90 0a		bcc $9d97			bcc 	_ENIsOkay
.9d8d						_ENBadNumber:
.9d8d		28		plp				plp 								; throw saved reset
.9d8e		ad 25 04	lda $0425			lda 	encodeState 				; if in decimal mode, construct final number
.9d91		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9d93		f0 7b		beq $9e10			beq 	_ENConstructFinal
.9d95						_ENFail:
.9d95		18		clc				clc 								; not allowed
.9d96		60		rts				rts
.9d97						_ENIsOkay:
.9d97		28		plp				plp 								; are we restarting
.9d98		90 15		bcc $9daf			bcc 	_ENNoRestart
.9d9a						_ENStartEncode:
.9d9a		c9 2e		cmp #$2e			cmp 	#'.'						; first is decimal place, go straight to that.
.9d9c		f0 0c		beq $9daa			beq 	_ENFirstDP
.9d9e		29 0f		and #$0f			and 	#15 						; put digit in mantissa, initially a single digit constant
.9da0		20 92 a4	jsr $a492			jsr 	NSMSetByte 					; in single byte mode.
.9da3		a9 01		lda #$01			lda 	#ESTA_Low
.9da5						_ENExitChange:
.9da5		8d 25 04	sta $0425			sta 	encodeState 				; save new state
.9da8		38		sec				sec
.9da9		60		rts				rts
.9daa						_ENFirstDP:
.9daa		20 90 a4	jsr $a490			jsr 	NSMSetZero 					; clear integer part
.9dad		80 3c		bra $9deb			bra 	_ESTASwitchFloat			; go straight to float and exi
.9daf						_ENNoRestart:
.9daf		48		pha				pha 								; save digit or DP on stack.
.9db0		ad 25 04	lda $0425			lda 	encodeState 				; get current state
.9db3		c9 01		cmp #$01			cmp 	#ESTA_Low
.9db5		f0 09		beq $9dc0			beq  	_ESTALowState
.9db7		c9 02		cmp #$02			cmp 	#ESTA_High
.9db9		f0 26		beq $9de1			beq 	_ESTAHighState
.9dbb		c9 03		cmp #$03			cmp 	#ESTA_Decimal
.9dbd		f0 38		beq $9df7			beq 	_ESTADecimalState
>9dbf		db						.byte 	$DB 						; causes a break in the emulator
.9dc0						_ESTALowState:
.9dc0		68		pla				pla 								; get value back
.9dc1		c9 2e		cmp #$2e			cmp 	#"."						; decimal point
.9dc3		f0 26		beq $9deb			beq 	_ESTASwitchFloat 			; then we need to do the floating point bit
.9dc5		29 0f		and #$0f			and 	#15 						; make digit
.9dc7		8d 26 04	sta $0426			sta 	digitTemp 					; save it.
.9dca		b5 60		lda $60,x			lda 	NSMantissa0,x 				; x mantissa0 x 10 and add it
.9dcc		0a		asl a				asl 	a
.9dcd		0a		asl a				asl 	a
.9dce		75 60		adc $60,x			adc 	NSMantissa0,x
.9dd0		0a		asl a				asl 	a
.9dd1		6d 26 04	adc $0426			adc 	digitTemp
.9dd4		95 60		sta $60,x			sta 	NSMantissa0,x
.9dd6		c9 19		cmp #$19			cmp 	#25 						; if >= 25 cannot guarantee next will be okay
.9dd8		90 05		bcc $9ddf			bcc 	_ESTANoSwitch 				; as could be 25 x 10 + 9
.9dda		a9 02		lda #$02			lda 	#ESTA_High 					; so if so, switch to the high encoding state
.9ddc		8d 25 04	sta $0425			sta 	encodeState
.9ddf						_ESTANoSwitch:
.9ddf		38		sec				sec
.9de0		60		rts				rts
.9de1						_ESTAHighState:
.9de1		68		pla				pla 								; get value back
.9de2		c9 2e		cmp #$2e			cmp 	#"." 						; if DP switch to dloat
.9de4		f0 05		beq $9deb			beq 	_ESTASwitchFloat
.9de6		20 44 9e	jsr $9e44			jsr 	ESTAShiftDigitIntoMantissa 	; a routine does this.
.9de9		38		sec				sec
.9dea		60		rts				rts
.9deb						_ESTASwitchFloat:
.9deb		9c 27 04	stz $0427			stz 	decimalCount 				; reset the count of digits - we divide by 10^n at the end.
.9dee		e8		inx				inx 								; zero the decimal additive.
.9def		20 90 a4	jsr $a490			jsr 	NSMSetZero
.9df2		ca		dex				dex
.9df3		a9 03		lda #$03			lda 	#ESTA_Decimal 				; switch to decimal mode
.9df5		80 ae		bra $9da5			bra 	_ENExitChange
.9df7						_ESTADecimalState:
.9df7		68		pla				pla 								; digit.
.9df8		c9 2e		cmp #$2e			cmp 	#"." 						; fail on 2nd decimal point.
.9dfa		f0 99		beq $9d95			beq 	_ENFail
.9dfc		e8		inx				inx 								; put digit into fractional part of X+1
.9dfd		20 44 9e	jsr $9e44			jsr 	ESTAShiftDigitIntoMantissa
.9e00		ca		dex				dex
.9e01		ee 27 04	inc $0427			inc 	decimalCount 				; bump the count of decimals
.9e04		ad 27 04	lda $0427			lda 	decimalCount 				; too many decimal digits.
.9e07		c9 0b		cmp #$0b			cmp 	#11
.9e09		f0 02		beq $9e0d			beq 	_ESTADSFail
.9e0b		38		sec				sec
.9e0c		60		rts				rts
.9e0d						_ESTADSFail:
.9e0d		4c 0d a6	jmp $a60d			jmp 	RangeError
.9e10						_ENConstructFinal:
.9e10		ad 27 04	lda $0427			lda 	decimalCount 				; get decimal count
.9e13		f0 2d		beq $9e42			beq 	_ENCFExit 					; no decimals
.9e15		5a		phy				phy
.9e16		0a		asl a				asl 	a 							; x 4 and CLC
.9e17		0a		asl a				asl 	a
.9e18		6d 27 04	adc $0427			adc 	decimalCount
.9e1b		a8		tay				tay
.9e1c		b9 cc a5	lda $a5cc,y			lda 	DecimalScalarTable-5,y 		; copy decimal scalar to X+2
.9e1f		95 62		sta $62,x			sta 	NSMantissa0+2,x  			; this is 10^-n
.9e21		b9 cd a5	lda $a5cd,y			lda 	DecimalScalarTable-5+1,y
.9e24		95 72		sta $72,x			sta 	NSMantissa1+2,x
.9e26		b9 ce a5	lda $a5ce,y			lda 	DecimalScalarTable-5+2,y
.9e29		95 82		sta $82,x			sta 	NSMantissa2+2,x
.9e2b		b9 cf a5	lda $a5cf,y			lda 	DecimalScalarTable-5+3,y
.9e2e		95 92		sta $92,x			sta 	NSMantissa3+2,x
.9e30		b9 d0 a5	lda $a5d0,y			lda 	DecimalScalarTable-5+4,y
.9e33		95 a2		sta $a2,x			sta 	NSExponent+2,x
.9e35		a9 08		lda #$08			lda 	#NSTFloat
.9e37		95 52		sta $52,x			sta 	NSStatus+2,x
.9e39		7a		ply				ply
.9e3a		e8		inx				inx 								; multiply decimal const by decimal scalar
.9e3b		20 ca 9b	jsr $9bca			jsr 	FloatMultiply
.9e3e		ca		dex				dex
.9e3f		20 85 9a	jsr $9a85			jsr 	FloatAdd 					; add to integer part.
.9e42						_ENCFExit:
.9e42		18		clc				clc 								; reject the digit.
.9e43		60		rts				rts
.9e44						ESTAShiftDigitIntoMantissa:
.9e44		29 0f		and #$0f			and 	#15 						; save digit
.9e46		48		pha				pha
.9e47		b5 90		lda $90,x			lda 	NSMantissa3,x 				; push mantissa on stack
.9e49		48		pha				pha
.9e4a		b5 80		lda $80,x			lda 	NSMantissa2,x
.9e4c		48		pha				pha
.9e4d		b5 70		lda $70,x			lda 	NSMantissa1,x
.9e4f		48		pha				pha
.9e50		b5 60		lda $60,x			lda 	NSMantissa0,x
.9e52		48		pha				pha
.9e53		20 9f a4	jsr $a49f			jsr 	NSMShiftLeft 				; x 2
.9e56		20 9f a4	jsr $a49f			jsr 	NSMShiftLeft 				; x 4
.9e59		18		clc				clc 								; pop mantissa and add
.9e5a		68		pla				pla
.9e5b		75 60		adc $60,x			adc 	NSMantissa0,x
.9e5d		95 60		sta $60,x			sta 	NSMantissa0,x
.9e5f		68		pla				pla
.9e60		75 70		adc $70,x			adc 	NSMantissa1,x
.9e62		95 70		sta $70,x			sta 	NSMantissa1,x
.9e64		68		pla				pla
.9e65		75 80		adc $80,x			adc 	NSMantissa2,x
.9e67		95 80		sta $80,x			sta 	NSMantissa2,x
.9e69		68		pla				pla
.9e6a		75 90		adc $90,x			adc 	NSMantissa3,x
.9e6c		95 90		sta $90,x			sta 	NSMantissa3,x 				; x 5
.9e6e		20 9f a4	jsr $a49f			jsr 	NSMShiftLeft 				; x 10
.9e71		68		pla				pla 								; add digit
.9e72		18		clc				clc
.9e73		75 60		adc $60,x			adc 	NSMantissa0,x
.9e75		95 60		sta $60,x			sta 	NSMantissa0,x
.9e77		90 0a		bcc $9e83			bcc 	_ESTASDExit
.9e79		f6 70		inc $70,x			inc 	NSMantissa1,x
.9e7b		d0 06		bne $9e83			bne 	_ESTASDExit
.9e7d		f6 80		inc $80,x			inc 	NSMantissa2,x
.9e7f		d0 02		bne $9e83			bne 	_ESTASDExit
.9e81		f6 90		inc $90,x			inc 	NSMantissa3,x
.9e83						_ESTASDExit:
.9e83		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/term.asm

.9e84						EvaluateTerm:
.9e84		b1 30		lda ($30),y			lda 	(codePtr),y
.9e86		30 18		bmi $9ea0			bmi 	_ETCheckUnary 				; unary function ? (text ones)
.9e88		c9 40		cmp #$40			cmp 	#$40 						; 40-7F => identifier reference
.9e8a		b0 6c		bcs $9ef8			bcs 	_ETVariable
.9e8c		c9 30		cmp #$30			cmp 	#'0' 						; is it a number
.9e8e		90 6b		bcc $9efb			bcc 	_ETPuncUnary 				; if not it might be a punctuation unary.
.9e90		c9 3a		cmp #$3a			cmp 	#'9'+1
.9e92		b0 67		bcs $9efb			bcs 	_ETPuncUnary
.9e94		20 7c 9d	jsr $9d7c			jsr 	EncodeNumberStart 			; can't fail as it's 0-9 !
.9e97						_ETNumber:
.9e97		c8		iny				iny 								; keep encoding until we have the numbers
.9e98		b1 30		lda ($30),y			lda 	(codePtr),y
.9e9a		20 7f 9d	jsr $9d7f			jsr 	EncodeNumberContinue
.9e9d		b0 f8		bcs $9e97			bcs 	_ETNumber 					; go back if accepted.
.9e9f		60		rts				rts
.9ea0						_ETCheckUnary:
.9ea0		c9 ff		cmp #$ff			cmp 	#KWC_STRING 				; string token
.9ea2		f0 3f		beq $9ee3			beq 	_ETString
.9ea4		c9 fe		cmp #$fe			cmp 	#KWC_HEXCONST 				; hex constant.
.9ea6		f0 12		beq $9eba			beq 	_ETHexConstant
.9ea8		c9 83		cmp #$83			cmp 	#KWC_FIRST_UNARY 			; check it actually is a unary function
.9eaa		90 0b		bcc $9eb7			bcc 	_ETSyntaxError
.9eac		c9 b0		cmp #$b0			cmp 	#KWC_LAST_UNARY+1
.9eae		b0 07		bcs $9eb7			bcs 	_ETSyntaxError
.9eb0		da		phx				phx 								; push X on the stack
.9eb1		0a		asl a				asl 	a 							; put vector x 2 into X
.9eb2		aa		tax				tax
.9eb3		c8		iny				iny 								; consume unary function token
.9eb4		7c 10 92	jmp ($9210,x)			jmp 	(VectorSet0,x) 				; and do it.
.9eb7						_ETSyntaxError:
.9eb7		4c 08 a6	jmp $a608			jmp 	SyntaxError
.9eba						_ETHexConstant:
.9eba		c8		iny				iny 								; skip #
.9ebb		c8		iny				iny 								; skip count
.9ebc		20 90 a4	jsr $a490			jsr 	NSMSetZero 					; clear result
.9ebf						_ETHLoop:
.9ebf		b1 30		lda ($30),y			lda 	(codePtr),y
.9ec1		c8		iny				iny 								; and consume
.9ec2		c9 00		cmp #$00			cmp 	#0 							; exit if zero
.9ec4		f0 1c		beq $9ee2			beq 	_ETHExit
.9ec6		48		pha				pha 								; save on stack.
.9ec7		20 9f a4	jsr $a49f			jsr 	NSMShiftLeft 				; x 2
.9eca		20 9f a4	jsr $a49f			jsr 	NSMShiftLeft 				; x 4
.9ecd		20 9f a4	jsr $a49f			jsr 	NSMShiftLeft 				; x 8
.9ed0		20 9f a4	jsr $a49f			jsr 	NSMShiftLeft 				; x 16
.9ed3		68		pla				pla 								; ASCII
.9ed4		c9 41		cmp #$41			cmp 	#'A'
.9ed6		90 02		bcc $9eda			bcc 	_ETHNotChar
.9ed8		e9 07		sbc #$07			sbc 	#7
.9eda						_ETHNotChar:
.9eda		29 0f		and #$0f			and 	#15 						; digit now
.9edc		15 60		ora $60,x			ora 	NSMantissa0,x 				; put in LS Nibble
.9ede		95 60		sta $60,x			sta 	NSMantissa0,x
.9ee0		80 dd		bra $9ebf			bra 	_ETHLoop 					; go round.
.9ee2						_ETHExit:
.9ee2		60		rts				rts
.9ee3						_ETString:
.9ee3		c8		iny				iny 								; look at length
.9ee4		b1 30		lda ($30),y			lda 	(codePtr),y
.9ee6		48		pha				pha
.9ee7		c8		iny				iny 								; first character
.9ee8		20 de a8	jsr $a8de			jsr 	MemoryInline 				; put address of string at (code-Ptr),y on stack
.9eeb		68		pla				pla 								; restore count and save
.9eec		85 36		sta $36				sta 	zTemp0
.9eee		98		tya				tya 								; add length to Y to skip it.
.9eef		18		clc				clc
.9ef0		65 36		adc $36				adc 	zTemp0
.9ef2		a8		tay				tay
.9ef3		a9 10		lda #$10			lda 	#NSTString 					; mark as string
.9ef5		95 50		sta $50,x			sta 	NSStatus,x
.9ef7		60		rts				rts
.9ef8						_ETVariable:
.9ef8		4c 4d 9f	jmp $9f4d			jmp 	VariableHandler
.9efb						_ETPuncUnary:
.9efb		c8		iny				iny 								; consume the unary character
.9efc		c9 2d		cmp #$2d			cmp 	#KWD_MINUS 					; unary minus
.9efe		f0 2b		beq $9f2b			beq 	_ETUnaryNegate
.9f00		c9 10		cmp #$10			cmp 	#KWD_ATCH 					; @ reference -> constant
.9f02		f0 36		beq $9f3a			beq 	_ETDereference
.9f04		c9 28		cmp #$28			cmp 	#KWD_LPAREN 				; parenthesis
.9f06		f0 3e		beq $9f46			beq 	_ETParenthesis
.9f08		64 36		stz $36				stz 	zTemp0 						; zTemp0 is the indirection level.
.9f0a		c9 3f		cmp #$3f			cmp 	#KWD_QMARK 					; byte indirection (0) ?
.9f0c		f0 06		beq $9f14			beq 	_ETIndirection
.9f0e		e6 36		inc $36				inc 	zTemp0
.9f10		c9 21		cmp #$21			cmp 	#KWD_PLING					; word indirection (1) \
.9f12		d0 a3		bne $9eb7			bne 	_ETSyntaxError
.9f14						_ETIndirection:
.9f14		a5 36		lda $36				lda 	zTemp0 						; push indirection amount (0-1) => (1-2) on the stack
.9f16		1a		inc a				inc 	a
.9f17		48		pha				pha
.9f18		20 84 9e	jsr $9e84			jsr 	EvaluateTerm				; evaluate the term
.9f1b		20 fd 9c	jsr $9cfd			jsr 	Dereference 				; dereference it.
.9f1e		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a +ve integer.
.9f20		d0 06		bne $9f28			bne 	_ETTypeMismatch
.9f22		68		pla				pla 								; indirection 1-2
.9f23		09 20		ora #$20			ora 	#NSBIsReference 			; make it a reference.
.9f25		95 50		sta $50,x			sta 	NSStatus,x
.9f27		60		rts				rts
.9f28						_ETTypeMismatch:
.9f28		4c 12 a6	jmp $a612			jmp 	TypeError
.9f2b						_ETUnaryNegate:
.9f2b		20 84 9e	jsr $9e84			jsr 	EvaluateTerm				; evaluate the term
.9f2e		20 fd 9c	jsr $9cfd			jsr 	Dereference 				; dereference it.
.9f31		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a number
.9f33		29 10		and #$10			and 	#NSTString
.9f35		d0 f1		bne $9f28			bne 	_ETTypeMismatch
.9f37		4c 52 a4	jmp $a452			jmp 	NSMNegate  					; just toggles the sign bit.
.9f3a						_ETDereference:
.9f3a		20 84 9e	jsr $9e84			jsr 	EvaluateTerm				; evaluate the term
.9f3d		b5 50		lda $50,x			lda 	NSStatus,x 					; must be a reference
.9f3f		29 20		and #$20			and 	#NSBIsReference
.9f41		f0 e5		beq $9f28			beq 	_ETTypeMismatch
.9f43		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer address
.9f45		60		rts				rts
.9f46						_ETParenthesis:
.9f46		20 31 9a	jsr $9a31			jsr 	EvaluateExpression 			; evaluate here, from lowest precedence
.9f49		20 0e 95	jsr $950e			jsr 	CheckRightBracket 			; check for )
.9f4c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/term/variable.asm

.9f4d						VariableHandler:
.9f4d		b1 30		lda ($30),y			lda 	(codePtr),y
.9f4f		18		clc				clc
.9f50		69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.9f52		85 37		sta $37				sta 	zTemp0+1
.9f54		c8		iny				iny
.9f55		b1 30		lda ($30),y			lda 	(codePtr),y
.9f57		85 36		sta $36				sta 	zTemp0
.9f59		c8		iny				iny
.9f5a		18		clc				clc									; copy variable address+3 to mantissa
.9f5b		69 03		adc #$03			adc 	#3 							; this is the address of the data.
.9f5d		95 60		sta $60,x			sta 	NSMantissa0,x
.9f5f		a5 37		lda $37				lda 	zTemp0+1
.9f61		69 00		adc #$00			adc 	#0
.9f63		95 70		sta $70,x			sta 	NSMantissa1,x
.9f65		74 80		stz $80,x			stz 	NSMantissa2,x
.9f67		74 90		stz $90,x			stz 	NSMantissa3,x
.9f69		74 a0		stz $a0,x			stz 	NSExponent,x
.9f6b		5a		phy				phy
.9f6c		a0 02		ldy #$02			ldy 	#2 							; read type
.9f6e		b1 36		lda ($36),y			lda 	(zTemp0),y
.9f70		7a		ply				ply
.9f71		29 1c		and #$1c			and 	#NSBTypeMask+NSBIsArray 	; get type information
.9f73		09 20		ora #$20			ora 	#NSBIsReference 			; make a reference.
.9f75		95 50		sta $50,x			sta 	NSStatus,x
.9f77		29 04		and #$04			and 	#NSBIsArray
.9f79		d0 01		bne $9f7c			bne 	_VHArray
.9f7b		60		rts				rts
.9f7c						_VHArray:
.9f7c		e8		inx				inx
.9f7d		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; get the 1st index.
.9f80		a9 ff		lda #$ff			lda 	#$FF 						; set Status of X+2 to a duff value so we know if we picked it up.
.9f82		95 51		sta $51,x			sta 	NSStatus+1,x
.9f84		b1 30		lda ($30),y			lda 	(codePtr),y
.9f86		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.9f88		d0 06		bne $9f90			bne 	_VHNoSecondIndex
.9f8a		c8		iny				iny 								; skip the comma
.9f8b		e8		inx				inx
.9f8c		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; get the 2nd index.
.9f8f		ca		dex				dex
.9f90						_VHNoSecondIndex:
.9f90		ca		dex				dex 								; set X back.
.9f91		20 0e 95	jsr $950e			jsr 	CheckRightBracket 			; and check the right bracket.
.9f94		5a		phy				phy 								; save position
.9f95		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy record address to zaTemp (moved 6/12/22)
.9f97		85 3e		sta $3e				sta 	zaTemp
.9f99		b5 70		lda $70,x			lda 	NSMantissa1,x
.9f9b		85 3f		sta $3f				sta 	zaTemp+1
.9f9d		a0 02		ldy #$02			ldy 	#2 							; check first index is not-zero, e.g. array defined
.9f9f		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fa1		f0 5d		beq $a000			beq 	_VHBadArray
.9fa3		a0 03		ldy #$03			ldy 	#3 							; get the second index - which is 0 if there is one index.
.9fa5		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fa7		f0 02		beq $9fab			beq 	_VHHas2Mask
.9fa9		a9 ff		lda #$ff			lda 	#$FF
.9fab						_VHHas2Mask:
.9fab		d5 52		cmp $52,x			cmp 	NSStatus+2,x 				; so if they are the same there are the wrong number of indices
.9fad		f0 4c		beq $9ffb			beq 	_VHBadIndex
.9faf		0a		asl a				asl 	a 							; carry will be set if a second index
.9fb0		90 08		bcc $9fba			bcc 	_VHCheckFirstIndex
.9fb2		a0 03		ldy #$03			ldy 	#3 			 				; check the 2nd size >= 2nd index
.9fb4		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fb6		d5 62		cmp $62,x			cmp 	NSMantissa0+2,x
.9fb8		90 41		bcc $9ffb			bcc 	_VHBadIndex
.9fba						_VHCheckFirstIndex:
.9fba		a0 02		ldy #$02			ldy 	#2 			 				; check the 2nd size >= 2nd index
.9fbc		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fbe		d5 61		cmp $61,x			cmp 	NSMantissa0+1,x
.9fc0		90 39		bcc $9ffb			bcc 	_VHBadIndex
.9fc2		64 36		stz $36				stz 	zTemp0 						; clear zTemp0 (if 1 index)
.9fc4		64 37		stz $37				stz 	zTemp0+1
.9fc6		b5 52		lda $52,x			lda 	NSStatus+2,x 				; if only one index provided, don't need to multiply
.9fc8		30 0e		bmi $9fd8			bmi 	_VHNoMultiply
.9fca		da		phx				phx
.9fcb		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; get 2nd index on stack
.9fcd		48		pha				pha
.9fce		a0 02		ldy #$02			ldy 	#2 							; get 1st size in A
.9fd0		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9fd2		1a		inc a				inc 	a 							; add 1 for zero base
.9fd3		fa		plx				plx
.9fd4		20 3b a4	jsr $a43b			jsr 	Multiply8x8 				; calculate -> Z0
.9fd7		fa		plx				plx
.9fd8						_VHNoMultiply:
.9fd8		18		clc				clc
.9fd9		a5 36		lda $36				lda 	zTemp0
.9fdb		75 61		adc $61,x			adc 	NSMantissa0+1,x
.9fdd		85 36		sta $36				sta 	zTemp0
.9fdf		a5 37		lda $37				lda 	zTemp0+1
.9fe1		69 00		adc #$00			adc 	#0
.9fe3		85 37		sta $37				sta 	zTemp0+1
.9fe5		b5 50		lda $50,x			lda 	NSStatus,x
.9fe7		20 63 8a	jsr $8a63			jsr 	ScaleByBaseType
.9fea		18		clc				clc
.9feb		b2 3e		lda ($3e)			lda 	(zaTemp)
.9fed		65 36		adc $36				adc 	zTemp0
.9fef		95 60		sta $60,x			sta 	NSMantissa0,x
.9ff1		a0 01		ldy #$01			ldy 	#1
.9ff3		b1 3e		lda ($3e),y			lda 	(zaTemp),y
.9ff5		65 37		adc $37				adc 	zTemp0+1
.9ff7		95 70		sta $70,x			sta 	NSMantissa1,x
.9ff9		7a		ply				ply 								; restore position
.9ffa		60		rts				rts
.9ffb						_VHBadIndex:
.9ffb		a9 17		lda #$17		lda	#23
.9ffd		4c 27 95	jmp $9527		jmp	ErrorHandler
.a000						_VHBadArray:
.a000		a9 18		lda #$18		lda	#24
.a002		4c 27 95	jmp $9527		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/abs.asm

.a005						AbsUnary:
.a005		fa		plx				plx 								; restore stack pos
.a006		20 de a3	jsr $a3de			jsr 	EvaluateNumber 				; get a float or int
.a009		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.a00c		b5 50		lda $50,x			lda 	NSStatus,x 					; clear the sign bit
.a00e		29 7f		and #$7f			and 	#$7F
.a010		95 50		sta $50,x			sta 	NSStatus,x
.a012		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/alloc.asm

.a013						AllocUnary:
.a013		fa		plx				plx 								; restore stack pos
.a014		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger		; get bytes required.
.a017		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.a01a		da		phx				phx 								; save X/Y
.a01b		5a		phy				phy
.a01c		8a		txa				txa 								; copy X into Y
.a01d		a8		tay				tay
.a01e		b9 70 00	lda $0070,y			lda		NSMantissa1,y 				; get size into XA
.a021		aa		tax				tax
.a022		b9 60 00	lda $0060,y			lda 	NSMantissa0,y
.a025		20 32 a0	jsr $a032			jsr 	AllocateXABytes 			; allocate memory
.a028		99 60 00	sta $0060,y			sta 	NSMantissa0,y 				; write address out.
.a02b		8a		txa				txa 	 							; typing is 16 bit integer.
.a02c		99 70 00	sta $0070,y			sta 	NSMantissa1,y
.a02f		7a		ply				ply
.a030		fa		plx				plx
.a031		60		rts				rts
.a032						AllocateXABytes:
.a032		5a		phy				phy
.a033		ac 28 04	ldy $0428			ldy 	lowMemPtr 					; push current address on stack and to zTemp0
.a036		84 36		sty $36				sty 	zTemp0
.a038		5a		phy				phy
.a039		ac 29 04	ldy $0429			ldy 	lowMemPtr+1
.a03c		84 37		sty $37				sty 	zTemp0+1
.a03e		5a		phy				phy
.a03f		18		clc				clc 								; add to low memory pointer
.a040		6d 28 04	adc $0428			adc 	lowMemPtr
.a043		8d 28 04	sta $0428			sta 	lowMemPtr
.a046		8a		txa				txa
.a047		6d 29 04	adc $0429			adc 	lowMemPtr+1
.a04a		8d 29 04	sta $0429			sta 	lowMemPtr+1
.a04d		b0 2f		bcs $a07e			bcs 	CISSMemory
.a04f		20 70 a0	jsr $a070			jsr 	CheckIdentifierStringSpace 	; check identifier/string space
.a052						_ClearMemory:
.a052		ad 28 04	lda $0428			lda 	lowMemPtr 					; cleared all memory allocated
.a055		c5 36		cmp $36				cmp 	zTemp0
.a057		d0 07		bne $a060			bne 	_CMClearNext
.a059		ad 29 04	lda $0429			lda 	lowMemPtr+1
.a05c		c5 37		cmp $37				cmp 	zTemp0+1
.a05e		f0 0c		beq $a06c			beq 	_CMExit
.a060						_CMClearNext:
.a060		a9 00		lda #$00			lda 	#0 							; clear byte, advance to next.
.a062		92 36		sta ($36)			sta 	(zTemp0)
.a064		e6 36		inc $36				inc 	zTemp0
.a066		d0 ea		bne $a052			bne 	_ClearMemory
.a068		e6 37		inc $37				inc		zTemp0+1
.a06a		80 e6		bra $a052			bra 	_ClearMemory
.a06c						_CMExit:
.a06c		fa		plx				plx
.a06d		68		pla				pla
.a06e		7a		ply				ply
.a06f		60		rts				rts
.a070						CheckIdentifierStringSpace:
.a070		48		pha				pha
.a071		ad 29 04	lda $0429			lda 	lowMemPtr+1 				; get low memory pointer
.a074		18		clc				clc
.a075		69 02		adc #$02			adc 	#2 							; need at least 2 256 byte pages
.a077		cd 2b 04	cmp $042b			cmp 	stringMemory+1 				; is it >= StringMemory
.a07a		b0 02		bcs $a07e			bcs 	CISSMemory
.a07c		68		pla				pla
.a07d		60		rts				rts
.a07e						CISSMemory:
.a07e		a9 06		lda #$06		lda	#6
.a080		4c 27 95	jmp $9527		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/asc.asm

.a083						AscUnary:
.a083		fa		plx				plx 								; restore stack pos
.a084		20 e8 a3	jsr $a3e8			jsr 	EvaluateString 				; get a string
.a087		b2 36		lda ($36)			lda 	(zTemp0)					; get/return first character
.a089		20 92 a4	jsr $a492			jsr 	NSMSetByte 					; ASC("") will return zero.
.a08c		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.a08f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/frac.asm

.a090						FracUnary:
.a090		fa		plx				plx 								; restore stack pos
.a091		20 de a3	jsr $a3de			jsr 	EvaluateNumber 				; get a float or int
.a094		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.a097		b5 50		lda $50,x			lda 	NSStatus,x
.a099		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.a09b		f0 04		beq $a0a1			beq 	_IUZero
.a09d		20 4b 9b	jsr $9b4b			jsr 	FloatFractionalPart 		; if so, get the fractional part.
.a0a0		60		rts				rts
.a0a1						_IUZero:
.a0a1		20 90 a4	jsr $a490			jsr 	NSMSetZero
.a0a4		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/int.asm

.a0a5						IntUnary:
.a0a5		fa		plx				plx 								; restore stack pos
.a0a6		20 de a3	jsr $a3de			jsr 	EvaluateNumber 				; get a float or int
.a0a9		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.a0ac		b5 50		lda $50,x			lda 	NSStatus,x
.a0ae		29 08		and #$08			and 	#NSTFloat 					; check it is a float
.a0b0		f0 03		beq $a0b5			beq 	_IUExit
.a0b2		20 a3 9b	jsr $9ba3			jsr 	FloatIntegerPart 			; if it is get the integer part.
.a0b5						_IUExit:
.a0b5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/len.asm

.a0b6						LenUnary:
.a0b6		fa		plx				plx 								; restore stack pos
.a0b7		20 e8 a3	jsr $a3e8			jsr 	EvaluateString 				; get a string
.a0ba		5a		phy				phy
.a0bb		a0 00		ldy #$00			ldy 	#0 							; find length
.a0bd						_LenFind:
.a0bd		b1 36		lda ($36),y			lda 	(zTemp0),y 					; look for trailing NULL.
.a0bf		f0 06		beq $a0c7			beq 	_LenExit
.a0c1		c8		iny				iny
.a0c2		d0 f9		bne $a0bd			bne 	_LenFind
.a0c4		4c 0d a6	jmp $a60d			jmp 	RangeError 					; string > 255 - no trailing NULL.
.a0c7						_LenExit:
.a0c7		98		tya				tya		 							; return length
.a0c8		20 92 a4	jsr $a492			jsr 	NSMSetByte
.a0cb		7a		ply				ply
.a0cc		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.a0cf		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/minmax.asm

.a0d0						Unary_Min:
.a0d0		a9 01		lda #$01			lda 	#1
.a0d2		80 02		bra $a0d6			bra 	UnaryMinMaxMain
.a0d4						Unary_Max:
.a0d4		a9 ff		lda #$ff			lda 	#$FF 						; value from comparator to cause a write
.a0d6						UnaryMinMaxMain:
.a0d6		fa		plx				plx 								; get index on number stack
.a0d7		48		pha				pha 								; save comparator
.a0d8		20 d5 a3	jsr $a3d5			jsr 	EvaluateValue 				; get the first value.
.a0db						_UMMMLoop:
.a0db		b1 30		lda ($30),y			lda 	(codePtr),y
.a0dd		c9 29		cmp #$29			cmp 	#KWD_RPAREN 				; if right bracket then done.
.a0df		f0 22		beq $a103			beq 	_UMMMDone
.a0e1		20 16 95	jsr $9516			jsr 	CheckComma 					; must be a comma
.a0e4		e8		inx				inx
.a0e5		20 d5 a3	jsr $a3d5			jsr 	EvaluateValue
.a0e8		ca		dex				dex
.a0e9		20 73 a4	jsr $a473			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] (Compare is destructive)
.a0ec		e8		inx				inx
.a0ed		20 73 a4	jsr $a473			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2], original
.a0f0		e8		inx				inx
.a0f1		20 e4 95	jsr $95e4			jsr 	CompareBaseCode 			; part of > = < etc. code, returns 255,0 or 1
.a0f4		ca		dex				dex
.a0f5		ca		dex				dex
.a0f6		85 36		sta $36				sta 	zTemp0 						; save required result
.a0f8		68		pla				pla 								; get and save comparator
.a0f9		48		pha				pha
.a0fa		c5 36		cmp $36				cmp 	zTemp0 						; if the comparator
.a0fc		d0 dd		bne $a0db			bne 	_UMMMLoop
.a0fe		20 06 a1	jsr $a106			jsr 	ExpCopyAboveDown 			; copy next up slot down
.a101		80 d8		bra $a0db			bra 	_UMMMLoop
.a103						_UMMMDone:
.a103		68		pla				pla 								; throw the comparator
.a104		c8		iny				iny 								; skip )
.a105		60		rts				rts
.a106						ExpCopyAboveDown:
.a106		b5 51		lda $51,x			lda 	NSStatus+1,x
.a108		95 50		sta $50,x			sta 	NSStatus,x
.a10a		b5 a1		lda $a1,x			lda 	NSExponent+1,x
.a10c		95 a0		sta $a0,x			sta 	NSExponent,x
.a10e		b5 61		lda $61,x			lda 	NSMantissa0+1,x
.a110		95 60		sta $60,x			sta 	NSMantissa0,x
.a112		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.a114		95 70		sta $70,x			sta 	NSMantissa1,x
.a116		b5 81		lda $81,x			lda 	NSMantissa2+1,x
.a118		95 80		sta $80,x			sta 	NSMantissa2,x
.a11a		b5 91		lda $91,x			lda 	NSMantissa3+1,x
.a11c		95 90		sta $90,x			sta 	NSMantissa3,x
.a11e		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/not.asm

.a11f						Unary_Not:
.a11f		fa		plx				plx
.a120		20 fd a3	jsr $a3fd			jsr 	EvaluateInteger 			; get integer
.a123		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.a126		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; zero mantissa ?
.a129		f0 04		beq $a12f			beq 	_NotZero
.a12b		20 90 a4	jsr $a490			jsr 	NSMSetZero
.a12e		60		rts				rts
.a12f						_NotZero:
.a12f		4c 9a 95	jmp $959a			jmp 	ReturnTrue

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/peek.asm

.a132						PeekByteUnary:
.a132		a9 01		lda #$01			lda 	#1
.a134		80 0a		bra $a140			bra 	PeekUnary
.a136						PeekWUnary:
.a136		a9 02		lda #$02			lda 	#2
.a138		80 06		bra $a140			bra 	PeekUnary
.a13a						PeekLUnary:
.a13a		a9 03		lda #$03			lda 	#3
.a13c		80 02		bra $a140			bra 	PeekUnary
.a13e						PeekDUnary:
.a13e		a9 04		lda #$04			lda 	#4
.a140						PeekUnary:
.a140		fa		plx				plx 								; restore position.
.a141		48		pha				pha 								; save count to copy on stack
.a142		20 10 a4	jsr $a410			jsr		Evaluate16BitInteger 		; address as constant.
.a145		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.a148		b5 60		lda $60,x			lda 	NSMantissa0,x 				; save mantissa in zTemp0 as address
.a14a		85 36		sta $36				sta 	zTemp0
.a14c		b5 70		lda $70,x			lda 	NSMantissa1,x
.a14e		85 37		sta $37				sta 	zTemp0+1
.a150		20 90 a4	jsr $a490			jsr 	NSMSetZero 					; clear the result to zero.
.a153		68		pla				pla 								; count in zTemp2
.a154		85 3a		sta $3a				sta 	zTemp2
.a156		da		phx				phx 								; save stack position and offset of read
.a157		5a		phy				phy
.a158		a0 00		ldy #$00			ldy 	#0 							; byte read offset.
.a15a						_PULoop:
.a15a		b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next byte, write to mantissa0,x
.a15c		95 60		sta $60,x			sta 	NSMantissa0,x 				; we change X not the index before it.
.a15e		c8		iny				iny 								; next byte to write
.a15f		8a		txa				txa 								; next byte to read - stack layout in 04data.inc
.a160		18		clc				clc
.a161		69 10		adc #$10			adc 	#MathStackSize
.a163		aa		tax				tax
.a164		c6 3a		dec $3a				dec 	zTemp2 						; done them all
.a166		d0 f2		bne $a15a			bne 	_PULoop
.a168		7a		ply				ply 								; restore stack/code pos and exit.
.a169		fa		plx				plx
.a16a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/sgn.asm

.a16b						SgnUnary:
.a16b		fa		plx				plx 								; restore stack pos
.a16c		20 de a3	jsr $a3de			jsr 	EvaluateNumber 				; get a float or int
.a16f		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.a172		20 b2 a4	jsr $a4b2			jsr 	NSMIsZero 					; if zero
.a175		f0 0e		beq $a185			beq 	_SGZero  					; return Int Zero
.a177		b5 50		lda $50,x			lda 	NSStatus,x 					; get status w/sign
.a179		48		pha				pha
.a17a		a9 01		lda #$01			lda 	#1 							; set to 1
.a17c		20 92 a4	jsr $a492			jsr 	NSMSetByte
.a17f		68		pla				pla
.a180		29 80		and #$80			and		#$80 						; copy the sign byte out
.a182		95 50		sta $50,x			sta 	NSStatus,x  				; so it will be -1 or 1
.a184		60		rts				rts
.a185		20 90 a4	jsr $a490	_SGZero:jsr 	NSMSetZero
.a188		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/number/val.asm

.a189						ValUnary:
.a189		fa		plx				plx 								; restore stack pos
.a18a		20 9f a1	jsr $a19f			jsr 	ValMainCode 				; do the main val() code
.a18d		b0 01		bcs $a190			bcs 	_VUError 					; couldn't convert
.a18f		60		rts				rts
.a190						_VUError:
.a190		4c 12 a6	jmp $a612			jmp 	TypeError
.a193						IsValUnary:
.a193		fa		plx				plx 								; restore stack pos
.a194		20 9f a1	jsr $a19f			jsr 	ValMainCode 				; do the main val() code
.a197		b0 03		bcs $a19c			bcs 	_VUBad
.a199		4c 9a 95	jmp $959a			jmp 	ReturnTrue
.a19c						_VUBad:
.a19c		4c a5 95	jmp $95a5			jmp 	ReturnFalse
.a19f						ValMainCode:
.a19f		20 e8 a3	jsr $a3e8			jsr 	EvaluateString 				; get a string
.a1a2		20 0e 95	jsr $950e			jsr 	CheckRightBracket 			; check right bracket present
.a1a5						ValEvaluateZTemp0:
.a1a5		5a		phy				phy
.a1a6		b2 36		lda ($36)			lda 	(zTemp0) 					; check not empty string
.a1a8		f0 17		beq $a1c1			beq 	_VMCFail2
.a1aa		a0 ff		ldy #$ff			ldy 	#$FF 						; start position
.a1ac		48		pha				pha 								; save first character
.a1ad		c9 2d		cmp #$2d			cmp 	#"-"		 				; is it - ?
.a1af		d0 01		bne $a1b2			bne 	_VMCStart
.a1b1		c8		iny				iny 								; skip over -
.a1b2						_VMCStart:
.a1b2		38		sec				sec 								; initialise first time round.
.a1b3						_VMCNext:
.a1b3		c8		iny				iny 								; pre-increment
.a1b4		b1 36		lda ($36),y			lda 	(zTemp0),y 					; next character = EOS ?
.a1b6		f0 0c		beq $a1c4			beq 	_VMCSuccess 				; successful.
.a1b8		20 80 9d	jsr $9d80			jsr 	EncodeNumber 				; send it to the number-builder
.a1bb		90 03		bcc $a1c0			bcc 	_VMCFail 					; if failed, give up.
.a1bd		18		clc				clc 								; next time round, countinue
.a1be		80 f3		bra $a1b3			bra 	_VMCNext
.a1c0						_VMCFail:
.a1c0		68		pla				pla
.a1c1						_VMCFail2:
.a1c1		7a		ply				ply
.a1c2		38		sec				sec
.a1c3		60		rts				rts
.a1c4						_VMCSuccess:
.a1c4		a9 00		lda #$00			lda 	#0 							; construct final
.a1c6		20 80 9d	jsr $9d80			jsr 	EncodeNumber 				; by sending a duff value.
.a1c9		68		pla				pla 								; if it was -ve
.a1ca		c9 2d		cmp #$2d			cmp 	#"-"
.a1cc		d0 03		bne $a1d1			bne 	_VMCNotNegative
.a1ce		20 52 a4	jsr $a452			jsr		NSMNegate 					; negate it.
.a1d1						_VMCNotNegative:
.a1d1		7a		ply				ply
.a1d2		18		clc				clc
.a1d3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/chr.asm

.a1d4						ChrUnary:
.a1d4		fa		plx				plx 								; restore stack pos
.a1d5		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger			; get value (chr$(0) returns an empty string)
.a1d8		48		pha				pha
.a1d9		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.a1dc		a9 01		lda #$01			lda 	#1 							; allocate space for one char
.a1de		20 c7 b7	jsr $b7c7			jsr 	StringTempAllocate
.a1e1		68		pla				pla 								; write number to it
.a1e2		20 00 b8	jsr $b800			jsr 	StringTempWrite
.a1e5		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/items.asm

.a1e6						ItemCountUnary:
.a1e6		fa		plx				plx
.a1e7		20 e8 a3	jsr $a3e8			jsr 	EvaluateString
.a1ea		e8		inx				inx
.a1eb		20 5e a2	jsr $a25e			jsr 	ICGetSeperator
.a1ee		ca		dex				dex
.a1ef		20 7f a2	jsr $a27f			jsr 	ICSetPointer 				; zTemp0 = (string)
.a1f2		20 90 a4	jsr $a490			jsr 	NSMSetZero 					; zero the result.
.a1f5		5a		phy				phy
.a1f6		a0 ff		ldy #$ff			ldy 	#$FF 						; loop counting seperators in mantissa
.a1f8						_ICULoop:
.a1f8		c8		iny				iny
.a1f9		b1 36		lda ($36),y			lda 	(zTemp0),y
.a1fb		cd ca 07	cmp $07ca			cmp 	ICSeperator
.a1fe		d0 02		bne $a202			bne 	_ICUNoMatch
.a200		f6 60		inc $60,x			inc 	NSMantissa0,x
.a202						_ICUNoMatch:
.a202		c9 00		cmp #$00			cmp 	#0
.a204		d0 f2		bne $a1f8			bne 	_ICULoop
.a206		f6 60		inc $60,x			inc 	NSMantissa0,x 				; +1
.a208		7a		ply				ply
.a209		60		rts				rts
.a20a						ItemGetUnary:
.a20a		fa		plx				plx
.a20b		20 e8 a3	jsr $a3e8			jsr 	EvaluateString 				; search string
.a20e		20 16 95	jsr $9516			jsr 	CheckComma
.a211		e8		inx				inx 								; get count
.a212		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.a215		c9 00		cmp #$00			cmp 	#0 							; must be > 0, index starts at 1.
.a217		f0 61		beq $a27a			beq 	ICGSRange
.a219		e8		inx				inx 								; get seperator.
.a21a		20 5e a2	jsr $a25e			jsr 	ICGetSeperator
.a21d		ca		dex				dex
.a21e		ca		dex				dex
.a21f		5a		phy				phy
.a220		20 7f a2	jsr $a27f			jsr 	ICSetPointer 				; zTemp0 points to string.
.a223		a0 00		ldy #$00			ldy 	#0
.a225		d6 61		dec $61,x			dec 	NSMantissa0+1,x 			; first element.
.a227		f0 0e		beq $a237			beq 	_IGUFoundStart
.a229						_IGUFindNext:
.a229		b1 36		lda ($36),y			lda 	(zTemp0),y		 			; next
.a22b		f0 4d		beq $a27a			beq 	ICGSRange 					; eol, not found.
.a22d		c8		iny				iny
.a22e		cd ca 07	cmp $07ca			cmp 	ICSeperator 				; until found a seperator (or EOS)
.a231		d0 f6		bne $a229			bne 	_IGUFindNext
.a233		d6 61		dec $61,x			dec 	NSMantissa0+1,x
.a235		d0 f2		bne $a229			bne 	_IGUFindNext
.a237						_IGUFoundStart:
.a237		84 38		sty $38				sty 	zTemp1 						; save start
.a239		88		dey				dey
.a23a						_IGUFindLength:
.a23a		c8		iny				iny 								; forward till seperator/EOS
.a23b		b1 36		lda ($36),y			lda 	(zTemp0),y
.a23d		f0 05		beq $a244			beq 	_IGUFoundLength
.a23f		cd ca 07	cmp $07ca			cmp 	ICSeperator
.a242		d0 f6		bne $a23a			bne 	_IGUFindLength
.a244						_IGUFoundLength:
.a244		84 39		sty $39				sty 	zTemp1+1 					; save end of copy string
.a246		98		tya				tya 								; calculate length of new string.
.a247		38		sec				sec
.a248		e5 38		sbc $38				sbc 	zTemp1
.a24a		20 c7 b7	jsr $b7c7			jsr 	StringTempAllocate 			; allocate bytes for it.
.a24d		a4 38		ldy $38				ldy 	zTemp1
.a24f						_IGUCopySub:
.a24f		c4 39		cpy $39				cpy 	zTemp1+1
.a251		f0 08		beq $a25b			beq 	_IGUCopyOver
.a253		b1 36		lda ($36),y			lda 	(zTemp0),y
.a255		20 00 b8	jsr $b800			jsr 	StringTempWrite
.a258		c8		iny				iny
.a259		80 f4		bra $a24f			bra 	_IGUCopySub
.a25b						_IGUCopyOver:
.a25b		7a		ply				ply
.a25c		60		rts				rts
>a25d		db						.byte 	$DB 						; causes a break in the emulator
.a25e						ICGetSeperator:
.a25e		20 16 95	jsr $9516			jsr 	CheckComma 					; preceding comma
.a261		20 e8 a3	jsr $a3e8			jsr 	EvaluateString 				; seperator string
.a264		20 7f a2	jsr $a27f			jsr 	ICSetPointer 				; access it
.a267		b2 36		lda ($36)			lda 	(zTemp0) 					; get sep char
.a269		8d ca 07	sta $07ca			sta 	ICSeperator
.a26c		f0 0c		beq $a27a			beq 	ICGSRange 					; check LEN(seperator) = 1
.a26e		5a		phy				phy
.a26f		a0 01		ldy #$01			ldy 	#1
.a271		b1 36		lda ($36),y			lda 	(zTemp0),y
.a273		d0 05		bne $a27a			bne 	ICGSRange
.a275		7a		ply				ply
.a276		20 0e 95	jsr $950e			jsr 	CheckRightBracket 			; check following )
.a279		60		rts				rts
.a27a						ICGSRange:
.a27a		a9 04		lda #$04		lda	#4
.a27c		4c 27 95	jmp $9527		jmp	ErrorHandler
.a27f						ICSetPointer:
.a27f		b5 60		lda $60,x			lda 	NSMantissa0,x 				; set zTemp0 to point to it.
.a281		85 36		sta $36				sta 	zTemp0
.a283		b5 70		lda $70,x			lda 	NSMantissa1,x
.a285		85 37		sta $37				sta 	zTemp0+1
.a287		60		rts				rts
.07ca						ICSeperator:
>07ca								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/spc.asm

.a288						SpcUnary:
.a288		fa		plx				plx 								; restore stack pos
.a289		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger			; get value
.a28c		5a		phy				phy
.a28d		48		pha				pha 								; save count
.a28e		20 c7 b7	jsr $b7c7			jsr 	StringTempAllocate
.a291		7a		ply				ply 								; to do count in Y
.a292						_SpcLoop:
.a292		c0 00		cpy #$00			cpy 	#0 							; copy Y spaces in.
.a294		f0 08		beq $a29e			beq 	_SpcExit
.a296		a9 20		lda #$20			lda 	#32
.a298		20 00 b8	jsr $b800			jsr 	StringTempWrite
.a29b		88		dey				dey
.a29c		80 f4		bra $a292			bra 	_SpcLoop
.a29e						_SpcExit:
.a29e		7a		ply				ply
.a29f		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.a2a2		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/str.asm

.a2a3						Unary_Str:
.a2a3		fa		plx				plx
.a2a4		20 de a3	jsr $a3de			jsr 	EvaluateNumber  			; get number
.a2a7		20 0e 95	jsr $950e			jsr 	CheckRightBracket 			; closing bracket
.a2aa		a9 05		lda #$05			lda 	#5 							; maximum decimals, from Basic816
.a2ac		20 c5 a2	jsr $a2c5			jsr 	ConvertNumberToString 		; do the conversion.
.a2af		a9 21		lda #$21			lda		#33 						; create buffer
.a2b1		20 c7 b7	jsr $b7c7			jsr 	StringTempAllocate 			; allocate memory
.a2b4		da		phx				phx  								; copy the converted string into the buffer.
.a2b5		a2 00		ldx #$00			ldx 	#0
.a2b7						_USCopy:
.a2b7		bd 65 06	lda $0665,x			lda 	decimalBuffer,x
.a2ba		20 00 b8	jsr $b800			jsr 	StringTempWrite
.a2bd		e8		inx				inx
.a2be		bd 65 06	lda $0665,x			lda 	decimalBuffer,x
.a2c1		d0 f4		bne $a2b7			bne 	_USCopy
.a2c3		fa		plx				plx
.a2c4		60		rts				rts
.a2c5						ConvertNumberToString:
.a2c5		5a		phy				phy 								; save code position
.a2c6		8d 30 04	sta $0430			sta 	decimalPlaces	 			; save number of DPs.
.a2c9		9c 31 04	stz $0431			stz 	dbOffset 					; offset into decimal buffer = start.
.a2cc		b5 50		lda $50,x			lda 	NSStatus,x  				; is it -ve.
.a2ce		10 09		bpl $a2d9			bpl 	_CNTSNotNegative
.a2d0		29 7f		and #$7f			and 	#$7F 						; make +ve
.a2d2		95 50		sta $50,x			sta 	NSStatus,x
.a2d4		a9 2d		lda #$2d			lda 	#"-"
.a2d6		20 3a a3	jsr $a33a			jsr 	WriteDecimalBuffer
.a2d9						_CNTSNotNegative:
.a2d9		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check if decimal
.a2db		f0 12		beq $a2ef			beq 	_CNTSNotFloat
.a2dd		e8		inx				inx 								; round up so we don't get too many 6.999999
.a2de		a9 01		lda #$01			lda 	#1
.a2e0		20 92 a4	jsr $a492			jsr 	NSMSetByte
.a2e3		ca		dex				dex
.a2e4		b5 a0		lda $a0,x			lda		NSExponent,x
.a2e6		95 a1		sta $a1,x			sta 	NSExponent+1,x
.a2e8		a9 08		lda #$08			lda 	#NSTFloat
.a2ea		95 51		sta $51,x			sta 	NSStatus+1,x
.a2ec		20 85 9a	jsr $9a85			jsr 	FloatAdd
.a2ef						_CNTSNotFloat:
.a2ef		20 1c a3	jsr $a31c			jsr 	MakePlusTwoString 			; do the integer part.
.a2f2		20 4b 9b	jsr $9b4b			jsr 	FloatFractionalPart 		; get the fractional part
.a2f5		20 fc 9b	jsr $9bfc			jsr 	NSNormalise					; normalise , exit if zero
.a2f8		f0 20		beq $a31a			beq 	_CNTSExit
.a2fa		a9 2e		lda #$2e			lda 	#"."
.a2fc		20 3a a3	jsr $a33a			jsr 	WriteDecimalBuffer 			; write decimal place
.a2ff						_CNTSDecimal:
.a2ff		ce 30 04	dec $0430			dec 	decimalPlaces 				; done all the decimals
.a302		30 16		bmi $a31a			bmi 	_CNTSExit
.a304		e8		inx				inx 								; x 10.0
.a305		a9 0a		lda #$0a			lda 	#10
.a307		20 92 a4	jsr $a492			jsr 	NSMSetByte
.a30a		a9 08		lda #$08			lda 	#NSTFloat
.a30c		95 50		sta $50,x			sta 	NSStatus,x
.a30e		ca		dex				dex
.a30f		20 ca 9b	jsr $9bca			jsr 	FloatMultiply
.a312		20 1c a3	jsr $a31c			jsr 	MakePlusTwoString 			; put the integer e.g. next digit out.
.a315		20 4b 9b	jsr $9b4b			jsr 	FloatFractionalPart 		; get the fractional part
.a318		80 e5		bra $a2ff			bra 	_CNTSDecimal 				; keep going.
.a31a						_CNTSExit:
.a31a		7a		ply				ply
.a31b		60		rts				rts
.a31c						MakePlusTwoString:
.a31c		da		phx				phx
.a31d		20 73 a4	jsr $a473			jsr 	NSMShiftUpTwo 				; copy S[X] to S[X+2] - we will use S[X+2] for the intege part.
.a320		e8		inx				inx 								; access it
.a321		e8		inx				inx
.a322		20 a3 9b	jsr $9ba3			jsr 	FloatIntegerPart 			; make it an integer
.a325		a9 0a		lda #$0a			lda 	#10 						; convert it in base 10
.a327		20 ac 99	jsr $99ac			jsr 	ConvertInt32
.a32a		a2 00		ldx #$00			ldx	 	#0 							; write that to the decimal buffer.
.a32c						_MPTSCopy:
.a32c		bd 43 06	lda $0643,x			lda 	numberBuffer,x
.a32f		20 3a a3	jsr $a33a			jsr 	WriteDecimalBuffer
.a332		e8		inx				inx
.a333		bd 43 06	lda $0643,x			lda 	numberBuffer,x
.a336		d0 f4		bne $a32c			bne 	_MPTSCopy
.a338		fa		plx				plx
.a339		60		rts				rts
.a33a						WriteDecimalBuffer:
.a33a		da		phx				phx
.a33b		ae 31 04	ldx $0431			ldx 	dbOffset
.a33e		9d 65 06	sta $0665,x			sta 	decimalBuffer,x
.a341		9e 66 06	stz $0666,x			stz 	decimalBuffer+1,x
.a344		ee 31 04	inc $0431			inc 	dbOffset
.a347		fa		plx				plx
.a348		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/unary/string/substring.asm

.a349						Unary_Left:
.a349		fa		plx				plx
.a34a		18		clc				clc 								; only one parameter
.a34b		20 ae a3	jsr $a3ae			jsr 	SubstringInitial 			; set up.
.a34e		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; Param #1 is the length
.a350		95 62		sta $62,x			sta 	NSMantissa0+2,x
.a352		74 61		stz $61,x			stz 	NSMantissa0+1,x 			; Start is zero.
.a354		80 25		bra $a37b			bra 	SubstringMain
.a356						Unary_Right:
.a356		fa		plx				plx
.a357		18		clc				clc 								; only one parameter
.a358		20 ae a3	jsr $a3ae			jsr 	SubstringInitial 			; set up.
.a35b		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; length => param 2
.a35d		95 62		sta $62,x			sta 	NSMantissa0+2,x
.a35f		b5 a0		lda $a0,x			lda 	NSExponent,x 				; total length
.a361		f5 61		sbc $61,x			sbc 	NSMantissa0+1,x 			; length - required.
.a363		b0 02		bcs $a367			bcs 	_URNotUnderflow
.a365		a9 00		lda #$00			lda 	#0 							; start from the beginning, as something like right$("AB",3)
.a367						_URNotUnderflow:
.a367		95 61		sta $61,x			sta 	NSMantissa0+1,x 			; this is the start position
.a369		80 10		bra $a37b			bra 	SubstringMain
.a36b						Unary_Mid:
.a36b		fa		plx				plx
.a36c		38		sec				sec 								; two parameters
.a36d		20 ae a3	jsr $a3ae			jsr 	SubstringInitial 			; set up.
.a370		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; first parameter is zero ?
.a372		f0 04		beq $a378			beq 	_UMError
.a374		d6 61		dec $61,x			dec 	NSMantissa0+1,x				; reduce initial offset by 1 as MID$(a$,1..) is actually the first character
.a376		80 03		bra $a37b			bra 	SubstringMain
.a378						_UMError:
.a378		4c 17 a6	jmp $a617			jmp 	ArgumentError
.a37b						SubstringMain:
.a37b		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; is the initial offset >= the length
.a37d		d5 a0		cmp $a0,x			cmp 	NSExponent,x
.a37f		b0 27		bcs $a3a8			bcs 	_SSMNull 					; if so, return an empty string.
.a381		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; if copy count is zero
.a383		f0 23		beq $a3a8			beq 	_SSMNull 					; return empty string.
.a385		18		clc				clc 								; add the offset +1 to the address and
.a386		b5 60		lda $60,x			lda	 	NSMantissa0,x 				; put in zTemp, this is the start of the substring to copy.
.a388		75 61		adc $61,x			adc 	NSMantissa0+1,x
.a38a		85 36		sta $36				sta 	zTemp0
.a38c		b5 70		lda $70,x			lda	 	NSMantissa1,x
.a38e		69 00		adc #$00			adc 	#0
.a390		85 37		sta $37				sta 	zTemp0+1
.a392						_SSMNoCarry:
.a392		b5 62		lda $62,x			lda 	NSMantissa0+2,x 			; characters required.
.a394		20 c7 b7	jsr $b7c7			jsr 	StringTempAllocate 			; allocate that many characters
.a397		5a		phy				phy 								; save Y
.a398		a0 00		ldy #$00			ldy 	#0 							; start copying in.
.a39a						_SSMCopy:
.a39a		b1 36		lda ($36),y			lda 	(zTemp0),y 					; get next character
.a39c		f0 08		beq $a3a6			beq 	_SSMEString 				; no more to copy
.a39e		20 00 b8	jsr $b800			jsr 	StringTempWrite 			; and write it out.
.a3a1		c8		iny				iny
.a3a2		d6 62		dec $62,x			dec 	NSMantissa0+2,x
.a3a4		d0 f4		bne $a39a			bne 	_SSMCopy
.a3a6						_SSMEString:
.a3a6		7a		ply				ply
.a3a7						_SSMExit:
.a3a7		60		rts				rts
.a3a8						_SSMNull:
.a3a8		a9 00		lda #$00			lda 	#0
.a3aa		20 c7 b7	jsr $b7c7			jsr 	StringTempAllocate
.a3ad		60		rts				rts
.a3ae						SubstringInitial:
.a3ae		da		phx				phx 								; save initial stack position
.a3af		08		php				php 								; save carry on stack indicating 2 parameters
.a3b0		20 e8 a3	jsr $a3e8			jsr 	EvaluateString 				; get a string
.a3b3		5a		phy				phy 								; calculate length to exponent.
.a3b4		a0 ff		ldy #$ff			ldy 	#$FF
.a3b6						_SIFindLength:
.a3b6		c8		iny				iny
.a3b7		b1 36		lda ($36),y			lda 	(zTemp0),y
.a3b9		d0 fb		bne $a3b6			bne 	_SIFindLength
.a3bb		98		tya				tya
.a3bc		95 a0		sta $a0,x			sta 	NSExponent,x
.a3be		7a		ply				ply
.a3bf		e8		inx				inx
.a3c0		20 16 95	jsr $9516			jsr 	CheckComma 					; comma next
.a3c3		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; get next parameter
.a3c6		28		plp				plp 								; is it the last parameter ?
.a3c7		90 07		bcc $a3d0			bcc 	_SSIExit 					; if so, exit.
.a3c9		e8		inx				inx
.a3ca		20 16 95	jsr $9516			jsr 	CheckComma 					; comma next
.a3cd		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; get last parameter
.a3d0						_SSIExit:
.a3d0		fa		plx				plx
.a3d1		20 0e 95	jsr $950e			jsr 	CheckRightBracket 			; check closing bracket
.a3d4		60		rts				rts 								; exit

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/exprhelper.asm

.a3d5						EvaluateValue:
.a3d5		48		pha				pha
.a3d6		20 31 9a	jsr $9a31			jsr		EvaluateExpression 			; expression
.a3d9		20 fd 9c	jsr $9cfd			jsr 	Dereference					; derefernce it
.a3dc		68		pla				pla
.a3dd		60		rts				rts
.a3de						EvaluateNumber:
.a3de		20 d5 a3	jsr $a3d5			jsr 	EvaluateValue 				; get a value
.a3e1		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.a3e3		29 10		and #$10			and 	#NSBIsString
.a3e5		d0 13		bne $a3fa			bne 	HelperTypeError
.a3e7		60		rts				rts
.a3e8						EvaluateString:
.a3e8		20 d5 a3	jsr $a3d5			jsr 	EvaluateValue 				; get a value
.a3eb		b5 50		lda $50,x			lda 	NSStatus,x 					; check if string.
.a3ed		29 10		and #$10			and 	#NSBIsString
.a3ef		f0 09		beq $a3fa			beq 	HelperTypeError
.a3f1						CopyAddressToTemp0:
.a3f1		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy address -> zTemp0
.a3f3		85 36		sta $36				sta 	zTemp0 						; (so we can do something with it)
.a3f5		b5 70		lda $70,x			lda 	NSMantissa1,x
.a3f7		85 37		sta $37				sta 	zTemp0+1
.a3f9		60		rts				rts
.a3fa						HelperTypeError:
.a3fa		4c 12 a6	jmp $a612			jmp 	TypeError
.a3fd						EvaluateInteger:
.a3fd		20 de a3	jsr $a3de			jsr 	EvaluateNumber
.a400		b5 a0		lda $a0,x			lda 	NSExponent,x 				; check exponent is zero
.a402		d0 09		bne $a40d			bne 	HelperValueError 			; if not, it's a float.
.a404		60		rts				rts
.a405						EvaluateUnsignedInteger:
.a405		20 fd a3	jsr $a3fd			jsr 	EvaluateInteger 			; check integer is +ve
.a408		b5 50		lda $50,x			lda 	NSStatus,x
.a40a		30 01		bmi $a40d			bmi 	HelperValueError
.a40c		60		rts				rts
.a40d						HelperValueError:
.a40d		4c 17 a6	jmp $a617			jmp 	ArgumentError
.a410						Evaluate16BitInteger:
.a410		20 05 a4	jsr $a405			jsr	 	EvaluateUnsignedInteger		; get integer
.a413		b5 90		lda $90,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.a415		15 80		ora $80,x			ora 	NSMantissa2,x
.a417		d0 f4		bne $a40d			bne 	HelperValueError
.a419		60		rts				rts
.a41a						Evaluate16BitIntegerSigned:
.a41a		20 fd a3	jsr $a3fd			jsr	 	EvaluateInteger				; get integer
.a41d		b5 90		lda $90,x			lda 	NSMantissa3,x	 			; bytes 2 & 3 must be zero
.a41f		15 80		ora $80,x			ora 	NSMantissa2,x
.a421		d0 ea		bne $a40d			bne 	HelperValueError
.a423		b5 50		lda $50,x			lda 	NSStatus,x 					; signed ?
.a425		10 03		bpl $a42a			bpl 	_EISNotSigned
.a427		20 59 a4	jsr $a459			jsr 	NSMNegateMantissa 			; makes it an actual 2's complement value.
.a42a						_EISNotSigned:
.a42a		60		rts				rts
.a42b						Evaluate8BitInteger:
.a42b		20 05 a4	jsr $a405			jsr	 	EvaluateUnsignedInteger 	; get an integer
.a42e		d0 dd		bne $a40d			bne 	HelperValueError
.a430		b5 90		lda $90,x			lda 	NSMantissa3,x	 			; bytes 1, 2 & 3 must be zero
.a432		15 80		ora $80,x			ora 	NSMantissa2,x
.a434		15 70		ora $70,x			ora 	NSMantissa1,x
.a436		d0 d5		bne $a40d			bne 	HelperValueError
.a438		b5 60		lda $60,x			lda 	NSMantissa0,x
.a43a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/mult8x8.asm

.a43b						Multiply8x8:
.a43b		4a		lsr a		  		lsr 	a  							; prime the carry bit for the loop
.a43c		85 36		sta $36			  	sta 	zTemp0
.a43e		86 37		stx $37				stx 	zTemp0+1
.a440		a9 00		lda #$00			lda 	#0
.a442		a2 08		ldx #$08			ldx 	#8
.a444						_M88Loop:
.a444		90 03		bcc $a449			bcc 	_M88NoAdd
.a446		18		clc				clc
.a447		65 37		adc $37				adc 	zTemp0+1
.a449						_M88NoAdd:
.a449		6a		ror a				ror 	a
.a44a		66 36		ror $36				ror 	zTemp0  					; pull another bit out for the next iteration
.a44c		ca		dex				dex         						; inc/dec don't modify carry; only shifts and adds do
.a44d		d0 f5		bne $a444			bne 	_M88Loop
.a44f		85 37		sta $37				sta 	zTemp0+1 					; store high 8 bits.
.a451		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/expressions/utility/utility.asm

.a452						NSMNegate:
.a452		b5 50		lda $50,x			lda 	NSStatus,x 					; everything is sign/magnitude usually so just
.a454		49 80		eor #$80			eor 	#NSBIsNegative  			; toggle the negative flag
.a456		95 50		sta $50,x			sta 	NSStatus,x
.a458		60		rts				rts
.a459						NSMNegateMantissa:
.a459		38		sec				sec 								; when we want an actual 32 bit 2's complement value.
.a45a		a9 00		lda #$00			lda 	#0
.a45c		f5 60		sbc $60,x			sbc 	NSMantissa0,x
.a45e		95 60		sta $60,x			sta 	NSMantissa0,x
.a460		a9 00		lda #$00			lda 	#0
.a462		f5 70		sbc $70,x			sbc 	NSMantissa1,x
.a464		95 70		sta $70,x			sta 	NSMantissa1,x
.a466		a9 00		lda #$00			lda 	#0
.a468		f5 80		sbc $80,x			sbc 	NSMantissa2,x
.a46a		95 80		sta $80,x			sta 	NSMantissa2,x
.a46c		a9 00		lda #$00			lda 	#0
.a46e		f5 90		sbc $90,x			sbc 	NSMantissa3,x
.a470		95 90		sta $90,x			sta 	NSMantissa3,x
.a472		60		rts				rts
.a473						NSMShiftUpTwo:
.a473		b5 60		lda $60,x			lda 	NSMantissa0,x
.a475		95 62		sta $62,x			sta 	NSMantissa0+2,x
.a477		b5 70		lda $70,x			lda 	NSMantissa1,x
.a479		95 72		sta $72,x			sta 	NSMantissa1+2,x
.a47b		b5 80		lda $80,x			lda 	NSMantissa2,x
.a47d		95 82		sta $82,x			sta 	NSMantissa2+2,x
.a47f		b5 90		lda $90,x			lda 	NSMantissa3,x
.a481		95 92		sta $92,x			sta 	NSMantissa3+2,x
.a483		b5 a0		lda $a0,x			lda 	NSExponent,x
.a485		95 a2		sta $a2,x			sta 	NSExponent+2,x
.a487		b5 50		lda $50,x			lda 	NSStatus,x
.a489		95 52		sta $52,x			sta 	NSStatus+2,x
.a48b		60		rts				rts
.a48c						NSMSetZeroMantissaOnly:
.a48c		a9 00		lda #$00			lda 	#0
.a48e		80 06		bra $a496			bra 	NSMSetMantissa
.a490						NSMSetZero:
.a490		a9 00		lda #$00			lda 	#0
.a492						NSMSetByte:
.a492		74 a0		stz $a0,x			stz 	NSExponent,x 				; zero exponent, as integer.
.a494		74 50		stz $50,x			stz 	NSStatus,x 					; status zero (integer)
.a496						NSMSetMantissa:
.a496		95 60		sta $60,x			sta 	NSMantissa0,x 				; mantissa
.a498		74 70		stz $70,x			stz 	NSMantissa1,x
.a49a		74 80		stz $80,x			stz 	NSMantissa2,x
.a49c		74 90		stz $90,x			stz 	NSMantissa3,x
.a49e		60		rts				rts
.a49f						NSMShiftLeft:
.a49f		18		clc				clc
.a4a0						NSMRotateLeft:
.a4a0		36 60		rol $60,x			rol 	NSMantissa0,x
.a4a2		36 70		rol $70,x			rol		NSMantissa1,x
.a4a4		36 80		rol $80,x			rol		NSMantissa2,x
.a4a6		36 90		rol $90,x			rol		NSMantissa3,x
.a4a8		60		rts				rts
.a4a9						NSMShiftRight:
.a4a9		56 90		lsr $90,x			lsr 	NSMantissa3,x
.a4ab		76 80		ror $80,x			ror		NSMantissa2,x
.a4ad		76 70		ror $70,x			ror		NSMantissa1,x
.a4af		76 60		ror $60,x			ror		NSMantissa0,x
.a4b1		60		rts				rts
.a4b2						NSMIsZero:
.a4b2		b5 90		lda $90,x			lda 	NSMantissa3,x
.a4b4		15 80		ora $80,x			ora		NSMantissa2,x
.a4b6		15 70		ora $70,x			ora		NSMantissa1,x
.a4b8		15 60		ora $60,x			ora		NSMantissa0,x
.a4ba		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/asmcore.asm

.a4bb						Assemble_ora:
.a4bb		20 3a 85	jsr $853a		jsr	AssembleGroup1
>a4be		01					.byte $01
.a4bf						Assemble_and:
.a4bf		20 3a 85	jsr $853a		jsr	AssembleGroup1
>a4c2		21					.byte $21
.a4c3						Assemble_eor:
.a4c3		20 3a 85	jsr $853a		jsr	AssembleGroup1
>a4c6		41					.byte $41
.a4c7						Assemble_adc:
.a4c7		20 3a 85	jsr $853a		jsr	AssembleGroup1
>a4ca		61					.byte $61
.a4cb						Assemble_sta:
.a4cb		20 3a 85	jsr $853a		jsr	AssembleGroup1
>a4ce		81					.byte $81
.a4cf						Assemble_lda:
.a4cf		20 3a 85	jsr $853a		jsr	AssembleGroup1
>a4d2		a1					.byte $a1
.a4d3						Assemble_cmp:
.a4d3		20 3a 85	jsr $853a		jsr	AssembleGroup1
>a4d6		c1					.byte $c1
.a4d7						Assemble_sbc:
.a4d7		20 3a 85	jsr $853a		jsr	AssembleGroup1
>a4da		e1					.byte $e1
.a4db						Assemble_asl:
.a4db		20 41 85	jsr $8541		jsr	AssembleGroup2
>a4de		02					.byte $02
>a4df		75					.byte $75
.a4e0						Assemble_rol:
.a4e0		20 41 85	jsr $8541		jsr	AssembleGroup2
>a4e3		22					.byte $22
>a4e4		75					.byte $75
.a4e5						Assemble_lsr:
.a4e5		20 41 85	jsr $8541		jsr	AssembleGroup2
>a4e8		42					.byte $42
>a4e9		75					.byte $75
.a4ea						Assemble_ror:
.a4ea		20 41 85	jsr $8541		jsr	AssembleGroup2
>a4ed		62					.byte $62
>a4ee		75					.byte $75
.a4ef						Assemble_stx:
.a4ef		20 41 85	jsr $8541		jsr	AssembleGroup2
>a4f2		82					.byte $82
>a4f3		50					.byte $50
.a4f4						Assemble_ldx:
.a4f4		20 41 85	jsr $8541		jsr	AssembleGroup2
>a4f7		a2					.byte $a2
>a4f8		d0					.byte $d0
.a4f9						Assemble_dec:
.a4f9		20 41 85	jsr $8541		jsr	AssembleGroup2
>a4fc		c2					.byte $c2
>a4fd		55					.byte $55
.a4fe						Assemble_inc:
.a4fe		20 41 85	jsr $8541		jsr	AssembleGroup2
>a501		e2					.byte $e2
>a502		55					.byte $55
.a503						Assemble_stz:
.a503		20 41 85	jsr $8541		jsr	AssembleGroup2
>a506		60					.byte $60
>a507		44					.byte $44
.a508						Assemble_bit:
.a508		20 41 85	jsr $8541		jsr	AssembleGroup2
>a50b		20					.byte $20
>a50c		55					.byte $55
.a50d						Assemble_sty:
.a50d		20 41 85	jsr $8541		jsr	AssembleGroup2
>a510		80					.byte $80
>a511		54					.byte $54
.a512						Assemble_ldy:
.a512		20 41 85	jsr $8541		jsr	AssembleGroup2
>a515		a0					.byte $a0
>a516		d5					.byte $d5
.a517						Assemble_cpy:
.a517		20 41 85	jsr $8541		jsr	AssembleGroup2
>a51a		c0					.byte $c0
>a51b		d4					.byte $d4
.a51c						Assemble_cpx:
.a51c		20 41 85	jsr $8541		jsr	AssembleGroup2
>a51f		e0					.byte $e0
>a520		d0					.byte $d0
.a521						Assemble_tsb:
.a521		20 41 85	jsr $8541		jsr	AssembleGroup2
>a524		00					.byte $00
>a525		50					.byte $50
.a526						Assemble_trb:
.a526		20 41 85	jsr $8541		jsr	AssembleGroup2
>a529		10					.byte $10
>a52a		50					.byte $50
.a52b						Assemble_jsr:
.a52b		20 41 85	jsr $8541		jsr	AssembleGroup2
>a52e		14					.byte $14
>a52f		10					.byte $10
.a530						Assemble_jmp:
.a530		20 41 85	jsr $8541		jsr	AssembleGroup2
>a533		40					.byte $40
>a534		10					.byte $10
.a535						Assemble_bpl:
.a535		20 92 85	jsr $8592		jsr	AssembleGroup3
>a538		10					.byte $10
.a539						Assemble_bmi:
.a539		20 92 85	jsr $8592		jsr	AssembleGroup3
>a53c		30					.byte $30
.a53d						Assemble_bvc:
.a53d		20 92 85	jsr $8592		jsr	AssembleGroup3
>a540		50					.byte $50
.a541						Assemble_bvs:
.a541		20 92 85	jsr $8592		jsr	AssembleGroup3
>a544		70					.byte $70
.a545						Assemble_bcc:
.a545		20 92 85	jsr $8592		jsr	AssembleGroup3
>a548		90					.byte $90
.a549						Assemble_bcs:
.a549		20 92 85	jsr $8592		jsr	AssembleGroup3
>a54c		b0					.byte $b0
.a54d						Assemble_bne:
.a54d		20 92 85	jsr $8592		jsr	AssembleGroup3
>a550		d0					.byte $d0
.a551						Assemble_beq:
.a551		20 92 85	jsr $8592		jsr	AssembleGroup3
>a554		f0					.byte $f0
.a555						Assemble_bra:
.a555		20 92 85	jsr $8592		jsr	AssembleGroup3
>a558		80					.byte $80
.a559						Assemble_brk:
.a559		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a55c		00					.byte $00
.a55d						Assemble_php:
.a55d		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a560		08					.byte $08
.a561						Assemble_clc:
.a561		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a564		18					.byte $18
.a565						Assemble_plp:
.a565		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a568		28					.byte $28
.a569						Assemble_sec:
.a569		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a56c		38					.byte $38
.a56d						Assemble_rti:
.a56d		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a570		40					.byte $40
.a571						Assemble_pha:
.a571		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a574		48					.byte $48
.a575						Assemble_cli:
.a575		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a578		58					.byte $58
.a579						Assemble_phy:
.a579		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a57c		5a					.byte $5a
.a57d						Assemble_rts:
.a57d		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a580		60					.byte $60
.a581						Assemble_pla:
.a581		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a584		68					.byte $68
.a585						Assemble_sei:
.a585		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a588		78					.byte $78
.a589						Assemble_ply:
.a589		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a58c		7a					.byte $7a
.a58d						Assemble_dey:
.a58d		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a590		88					.byte $88
.a591						Assemble_txa:
.a591		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a594		8a					.byte $8a
.a595						Assemble_tya:
.a595		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a598		98					.byte $98
.a599						Assemble_txs:
.a599		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a59c		9a					.byte $9a
.a59d						Assemble_tay:
.a59d		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5a0		a8					.byte $a8
.a5a1						Assemble_tax:
.a5a1		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5a4		aa					.byte $aa
.a5a5						Assemble_clv:
.a5a5		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5a8		b8					.byte $b8
.a5a9						Assemble_tsx:
.a5a9		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5ac		ba					.byte $ba
.a5ad						Assemble_iny:
.a5ad		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5b0		c8					.byte $c8
.a5b1						Assemble_dex:
.a5b1		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5b4		ca					.byte $ca
.a5b5						Assemble_cld:
.a5b5		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5b8		d8					.byte $d8
.a5b9						Assemble_phx:
.a5b9		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5bc		da					.byte $da
.a5bd						Assemble_stp:
.a5bd		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5c0		db					.byte $db
.a5c1						Assemble_inx:
.a5c1		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5c4		e8					.byte $e8
.a5c5						Assemble_nop:
.a5c5		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5c8		ea					.byte $ea
.a5c9						Assemble_sed:
.a5c9		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5cc		f8					.byte $f8
.a5cd						Assemble_plx:
.a5cd		20 c6 85	jsr $85c6		jsr	AssembleGroup4
>a5d0		fa					.byte $fa

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/constants.asm

.a5d1						DecimalScalarTable:
>a5d1		66 66 66 66				.dword $66666666 ; 0.1
>a5d5		de					.byte $de
>a5d6		1f 85 eb 51				.dword $51eb851f ; 0.01
>a5da		db					.byte $db
>a5db		4c 37 89 41				.dword $4189374c ; 0.001
>a5df		d8					.byte $d8
>a5e0		ac 8b db 68				.dword $68db8bac ; 0.0001
>a5e4		d4					.byte $d4
>a5e5		24 d6 e2 53				.dword $53e2d624 ; 1e-05
>a5e9		d1					.byte $d1
>a5ea		83 de 1b 43				.dword $431bde83 ; 1e-06
>a5ee		ce					.byte $ce
>a5ef		6b ca 5f 6b				.dword $6b5fca6b ; 1e-07
>a5f3		ca					.byte $ca
>a5f4		89 3b e6 55				.dword $55e63b89 ; 1e-08
>a5f8		c7					.byte $c7
>a5f9		a1 2f b8 44				.dword $44b82fa1 ; 1e-09
>a5fd		c4					.byte $c4
>a5fe		67 7f f3 6d				.dword $6df37f67 ; 1e-10
>a602		c0					.byte $c0
>a603		86 ff f5 57				.dword $57f5ff86 ; 1e-11
>a607		bd					.byte $bd

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/errors.asm

.a608						SyntaxError:
.a608		a9 02		lda #$02		lda	#2
.a60a		4c 27 95	jmp $9527		jmp	ErrorHandler
.a60d						RangeError:
.a60d		a9 04		lda #$04		lda	#4
.a60f		4c 27 95	jmp $9527		jmp	ErrorHandler
.a612						TypeError:
.a612		a9 05		lda #$05		lda	#5
.a614		4c 27 95	jmp $9527		jmp	ErrorHandler
.a617						ArgumentError:
.a617		a9 07		lda #$07		lda	#7
.a619		4c 27 95	jmp $9527		jmp	ErrorHandler
.a61c						NotDoneError:
.a61c		a9 0c		lda #$0c		lda	#12
.a61e		4c 27 95	jmp $9527		jmp	ErrorHandler
.a621						ErrorText:
>a621		42 72 65 61 6b 00			.text	"Break",0
>a627		53 79 6e 74 61 78 20 65			.text	"Syntax error",0
>a62f		72 72 6f 72 00
>a634		44 69 76 69 73 69 6f 6e			.text	"Division by zero",0
>a63c		20 62 79 20 7a 65 72 6f 00
>a645		4f 75 74 20 6f 66 20 52			.text	"Out of Range",0
>a64d		61 6e 67 65 00
>a652		54 79 70 65 20 6d 69 73			.text	"Type mismatch",0
>a65a		6d 61 74 63 68 00
>a660		4f 75 74 20 6f 66 20 6d			.text	"Out of memory",0
>a668		65 6d 6f 72 79 00
>a66e		49 6c 6c 65 67 61 6c 20			.text	"Illegal argument",0
>a676		61 72 67 75 6d 65 6e 74 00
>a67f		53 74 6f 70 00				.text	"Stop",0
>a684		53 74 72 69 6e 67 20 74			.text	"String too long",0
>a68c		6f 6f 20 6c 6f 6e 67 00
>a694		41 73 73 65 72 74 69 6f			.text	"Assertion failed",0
>a69c		6e 20 66 61 69 6c 65 64 00
>a6a5		4f 75 74 20 6f 66 20 64			.text	"Out of data",0
>a6ad		61 74 61 00
>a6b1		55 6e 69 6d 70 6c 65 6d			.text	"Unimplemented",0
>a6b9		65 6e 74 65 64 00
>a6bf		4e 6f 20 73 75 63 68 20			.text	"No such line number",0
>a6c7		6c 69 6e 65 20 6e 75 6d 62 65 72 00
>a6d3		52 65 74 75 72 6e 20 77			.text	"Return without Gosub",0
>a6db		69 74 68 6f 75 74 20 47 6f 73 75 62 00
>a6e8		55 6e 74 69 6c 20 77 69			.text	"Until without Repeat",0
>a6f0		74 68 6f 75 74 20 52 65 70 65 61 74 00
>a6fd		57 65 6e 64 20 77 69 74			.text	"Wend without While",0
>a705		68 6f 75 74 20 57 68 69 6c 65 00
>a710		4e 65 78 74 20 77 69 74			.text	"Next without For",0
>a718		68 6f 75 74 20 46 6f 72 00
>a721		42 41 53 49 43 20 53 74			.text	"BASIC Stack full",0
>a729		61 63 6b 20 66 75 6c 6c 00
>a732		4f 70 65 6e 20 53 74 72			.text	"Open Structure",0
>a73a		75 63 74 75 72 65 00
>a741		45 6e 64 50 72 6f 63 20			.text	"EndProc without call",0
>a749		77 69 74 68 6f 75 74 20 63 61 6c 6c 00
>a756		41 72 72 61 79 20 61 6c			.text	"Array already defined",0
>a75e		72 65 61 64 79 20 64 65 66 69 6e 65 64 00
>a76c		41 72 72 61 79 20 73 69			.text	"Array size",0
>a774		7a 65 00
>a777		42 61 64 20 61 72 72 61			.text	"Bad array index",0
>a77f		79 20 69 6e 64 65 78 00
>a787		41 72 72 61 79 20 6e 6f			.text	"Array not declared",0
>a78f		74 20 64 65 63 6c 61 72 65 64 00
>a79a		46 69 6c 65 20 6e 6f 74			.text	"File not found",0
>a7a2		20 66 6f 75 6e 64 00
>a7a9		53 74 6f 72 61 67 65 20			.text	"Storage error",0
>a7b1		65 72 72 6f 72 00
>a7b7		56 65 72 69 66 79 20 66			.text	"Verify failed",0
>a7bf		61 69 6c 65 64 00
>a7c5		50 72 6f 67 72 61 6d 20			.text	"Program not found",0
>a7cd		6e 6f 74 20 66 6f 75 6e 64 00
>a7d7		54 6f 6f 20 6d 61 6e 79			.text	"Too many parameters",0
>a7df		20 70 61 72 61 6d 65 74 65 72 73 00
>a7eb		46 6f 72 6d 75 6c 61 20			.text	"Formula too complex",0
>a7f3		74 6f 6f 20 63 6f 6d 70 6c 65 78 00
>a7ff		49 6e 69 74 69 61 6c 69			.text	"Initialization error",0
>a807		7a 61 74 69 6f 6e 20 65 72 72 6f 72 00

;******  Return to file: _basic.asm


;******  Processing file: ./common/generated/timestamp.asm

>f026		09 09 30 32 2f 30 38 2f			.text 9,9,"02/08/25 1.0"
>f02e		32 35 20 31 2e 30

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/delete.asm

.a814						MemoryDeleteLine:
.a814		20 33 a8	jsr $a833			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a817		b2 30		lda ($30)			lda 	(codePtr) 					; size to delete => y
.a819		a8		tay				tay
.a81a						_MDDLLoop:
.a81a		b1 30		lda ($30),y			lda 	(codePtr),y 				; copy down
.a81c		92 30		sta ($30)			sta 	(codePtr)
.a81e		a5 30		lda $30				lda 	codePtr 					; check done the lot.
.a820		c5 3a		cmp $3a				cmp 	zTemp2 						; has codePtr (copyFrom) reached the last byte to copy.
.a822		d0 07		bne $a82b			bne 	_MDLDLNext
.a824		a5 31		lda $31				lda 	codePtr+1
.a826		c5 3b		cmp $3b				cmp 	zTemp2+1
.a828		d0 01		bne $a82b			bne 	_MDLDLNext
.a82a						_MDDLExit:
.a82a		60		rts				rts
.a82b						_MDLDLNext:
.a82b		e6 30		inc $30				inc 	codePtr						; next byte
.a82d		d0 eb		bne $a81a			bne 	_MDDLLoop
.a82f		e6 31		inc $31				inc 	codePtr+1
.a831		80 e7		bra $a81a			bra 	_MDDLLoop
.a833						IMemoryFindEnd:
.a833		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a835		85 3a		sta $3a				sta 	0+zTemp2
.a837		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a839		85 3b		sta $3b				sta 	1+zTemp2
.a83b						_MDLFELoop:
.a83b		b2 3a		lda ($3a)			lda 	(zTemp2) 					; scan forward using offsets.
.a83d		f0 0b		beq $a84a			beq 	_MDLFEExit
.a83f		18		clc				clc
.a840		65 3a		adc $3a				adc 	zTemp2
.a842		85 3a		sta $3a				sta 	zTemp2
.a844		90 f5		bcc $a83b			bcc 	_MDLFELoop
.a846		e6 3b		inc $3b				inc 	zTemp2+1
.a848		80 f1		bra $a83b			bra 	_MDLFELoop
.a84a						_MDLFEExit:
.a84a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/insert.asm

.a84b						MemoryInsertLine:
.a84b		08		php				php
.a84c		20 33 a8	jsr $a833			jsr 	IMemoryFindEnd 				; find end to zTemp2.
.a84f		a5 3b		lda $3b				lda 	zTemp2+1 					; is there space for the new line ?
.a851		1a		inc a				inc 	a
.a852		c9 7f		cmp #$7f			cmp 	#(BasicEnd >> 8)-1
.a854		b0 36		bcs $a88c			bcs 	_MDLIError 					; no, fail.
.a856		28		plp				plp 								; do at a specific point or the end ?
.a857		90 08		bcc $a861			bcc 	_MDLIFound 					; if specific point already set.
.a859		a5 3a		lda $3a				lda 	zTemp2 						; if CS on entry append, so put on the
.a85b		85 30		sta $30				sta 	codePtr 					; end.
.a85d		a5 3b		lda $3b				lda 	zTemp2+1
.a85f		85 31		sta $31				sta 	codePtr+1
.a861						_MDLIFound:
.a861		ad 46 04	lda $0446			lda 	tokenOffset 				; insert gap in Y, the offset, e.g. length of the new line
.a864		a8		tay				tay
.a865						_MDLIInsert:
.a865		b2 3a		lda ($3a)			lda 	(zTemp2) 					; shift one byte up , at least one covers end case (copying link 0)
.a867		91 3a		sta ($3a),y			sta 	(zTemp2),y 					; work from top down.
.a869		a5 30		lda $30				lda 	codePtr 					; reached insert point ?
.a86b		c5 3a		cmp $3a				cmp 	zTemp2
.a86d		d0 06		bne $a875			bne 	_MDLINext
.a86f		a5 31		lda $31				lda 	codePtr+1
.a871		c5 3b		cmp $3b				cmp 	zTemp2+1
.a873		f0 0a		beq $a87f			beq 	_MDLIHaveSpace
.a875						_MDLINext:
.a875		a5 3a		lda $3a				lda 	zTemp2 						; if no, keep zTemp2 going backwards opening up space.
.a877		d0 02		bne $a87b			bne 	_MDLINoBorrow
.a879		c6 3b		dec $3b				dec 	zTemp2+1
.a87b						_MDLINoBorrow:
.a87b		c6 3a		dec $3a				dec 	zTemp2
.a87d		80 e6		bra $a865			bra 	_MDLIInsert
.a87f						_MDLIHaveSpace:
.a87f		ac 46 04	ldy $0446			ldy 	tokenOffset 				; bytes to copy
.a882		88		dey				dey 								; from offset-1 (last written) to the end of the buffer.
.a883						_MDLICopy:
.a883		b9 46 04	lda $0446,y			lda 	tokenOffset,y
.a886		91 30		sta ($30),y			sta 	(codePtr),y
.a888		88		dey				dey
.a889		10 f8		bpl $a883			bpl 	_MDLICopy
.a88b		60		rts				rts
.a88c						_MDLIError:
.a88c		a9 06		lda #$06		lda	#6
.a88e		4c 27 95	jmp $9527		jmp	ErrorHandler
.a891						MDLAppendLine:
.a891		86 37		stx $37				stx 	zTemp0+1 					; save new line at zTemp0
.a893		85 36		sta $36				sta 	zTemp0
.a895		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a897		85 38		sta $38				sta 	0+zTemp1
.a899		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a89b		85 39		sta $39				sta 	1+zTemp1
.a89d		b2 38		lda ($38)			lda 	(zTemp1)
.a89f		d0 0a		bne $a8ab			bne 	_MDLANoInitialise
.a8a1		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a8a3		8d cb 07	sta $07cb			sta 	0+AppendPointer
.a8a6		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a8a8		8d cc 07	sta $07cc			sta 	1+AppendPointer
.a8ab						_MDLANoInitialise:
.a8ab		18		clc				clc
.a8ac		ad cb 07	lda $07cb			lda 	AppendPointer 				; copy append pointer to zTemp1 adding the offset as you go
.a8af		85 38		sta $38				sta 	zTemp1
.a8b1		72 36		adc ($36)			adc 	(zTemp0)
.a8b3		8d cb 07	sta $07cb			sta 	AppendPointer
.a8b6		ad cc 07	lda $07cc			lda 	AppendPointer+1
.a8b9		85 39		sta $39				sta 	zTemp1+1
.a8bb		69 00		adc #$00			adc 	#0
.a8bd		8d cc 07	sta $07cc			sta 	AppendPointer+1
.a8c0		a0 00		ldy #$00			ldy 	#0
.a8c2						_MDLACopy:
.a8c2		b1 36		lda ($36),y			lda 	(zTemp0),y 					; copy new line in
.a8c4		91 38		sta ($38),y			sta 	(zTemp1),y
.a8c6		c8		iny				iny
.a8c7		98		tya				tya
.a8c8		d2 36		cmp ($36)			cmp 	(zTemp0) 					; done whole line
.a8ca		d0 f6		bne $a8c2			bne 	_MDLACopy
.a8cc		a9 00		lda #$00			lda 	#0 							; end of program.
.a8ce		91 38		sta ($38),y			sta 	(zTemp1),y
.a8d0		60		rts				rts
.07cb						AppendPointer:
>07cb								.fill 	2

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/memory.asm

.a8d1						MemoryNew:
.a8d1		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a8d3		85 30		sta $30				sta 	codePtr
.a8d5		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a8d7		85 31		sta $31				sta 	codePtr+1
.a8d9		a9 00		lda #$00			lda 	#0 							; write zero there erasing the program.
.a8db		92 30		sta ($30)			sta 	(codePtr)
.a8dd		60		rts				rts
.a8de						MemoryInline:
.a8de		98		tya				tya 								; put address into stack,x
.a8df		18		clc				clc  								; get the offset, add codePtr
.a8e0		65 30		adc $30				adc 	codePtr
.a8e2		95 60		sta $60,x			sta 	NSMantissa0,x 				; store the result in the mantissa.
.a8e4		a5 31		lda $31				lda 	codePtr+1
.a8e6		69 00		adc #$00			adc 	#0
.a8e8		95 70		sta $70,x			sta 	NSMantissa1,x
.a8ea		74 80		stz $80,x			stz 	NSMantissa2,x
.a8ec		74 90		stz $90,x			stz 	NSMantissa3,x
.a8ee		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/memory/memory.flat/search.asm

.a8ef						MemorySearch:
.a8ef		85 36		sta $36				sta 	zTemp0 						; save line number in zTemp0
.a8f1		86 37		stx $37				stx 	zTemp0+1
.a8f3		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.a8f5		85 30		sta $30				sta 	codePtr
.a8f7		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.a8f9		85 31		sta $31				sta 	codePtr+1
.a8fb						_MTAXLoop:
.a8fb		b2 30		lda ($30)			lda 	(codePtr)
.a8fd		18		clc				clc
.a8fe		f0 21		beq $a921			beq 	_MTAXExit 					; reached end, exit with CC.
.a900		a0 01		ldy #$01			ldy 	#1 							; calculate current line# - requested line#
.a902		b1 30		lda ($30),y			lda 	(codePtr),y
.a904		38		sec				sec
.a905		e5 36		sbc $36				sbc 	zTemp0
.a907		85 38		sta $38				sta 	zTemp1 						; save interim to set Z
.a909		c8		iny				iny 								; do the MSB
.a90a		b1 30		lda ($30),y			lda 	(codePtr),y
.a90c		e5 37		sbc $37				sbc 	zTemp0+1
.a90e		05 38		ora $38				ora 	zTemp1 						; will set Z if result is zero, doesn't affect carry flag
.a910		f0 0f		beq $a921			beq 	_MTAXExit	 				; found so exit (CS will be set)
.a912		b0 0d		bcs $a921			bcs 	_MTAXExit 					; current < required exit
.a914		18		clc				clc
.a915		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.a917		65 30		adc $30				adc 	codePtr
.a919		85 30		sta $30				sta 	codePtr
.a91b		90 02		bcc $a91f			bcc 	_CREExit
.a91d		e6 31		inc $31				inc 	codePtr+1 					; carry
.a91f						_CREExit:
.a91f		80 da		bra $a8fb			bra 	_MTAXLoop
.a921						_MTAXExit:
.a921		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gcommand.asm

.a922						RectangleCommand:
.a922		a9 44		lda #$44			lda 	#GCMD_FrameRect				; frame rectangle
.a924		80 02		bra $a928			bra 	ShapeDrawCmd
.a926						CircleCommand:
.a926		a9 48		lda #$48			lda 	#GCMD_FrameCircle 				; framed circle
.a928						ShapeDrawCmd:
.a928		20 b2 a9	jsr $a9b2			jsr 	RunGraphicsCommand
.a92b						ShapeDraw:
.a92b		0d ce 07	ora $07ce			ora 	gxFillSolid  				; adjust AXY for solid fill.
.a92e		4c a6 a9	jmp $a9a6			jmp 	ExecuteGraphicCommand	 	; and complete
.a931						SpriteCommand:
.a931		a2 00		ldx #$00			ldx 	#0
.a933		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; get image number.
.a936		5a		phy				phy
.a937		a9 0e		lda #$0e			lda 	#GCMD_SpriteUse 			; use that image.
.a939		a6 60		ldx $60				ldx 	NSMantissa0
.a93b		e0 40		cpx #$40			cpx 	#64 						; 0-63 only
.a93d		b0 0d		bcs $a94c			bcs 	_SCRange
.a93f		a0 ff		ldy #$ff			ldy 	#255
.a941		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.a944		a9 52		lda #$52			lda 	#GCMD_SpriteMove
.a946		7a		ply				ply
.a947		20 b2 a9	jsr $a9b2			jsr 	RunGraphicsCommand
.a94a		80 5a		bra $a9a6			bra 	ExecuteGraphicCommand
.a94c						_SCRange:
.a94c		4c 0d a6	jmp $a60d			jmp 	RangeError
.a94f						ImageCommand:
.a94f		a2 00		ldx #$00			ldx 	#0
.a951		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; get image number.
.a954		20 b2 a9	jsr $a9b2			jsr 	RunGraphicsCommand
.a957						ImageRunDraw:
.a957		09 40		ora #$40			ora 	#GCMD_Move					; move cursor
.a959		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.a95c		ad d4 07	lda $07d4			lda 	gxDrawScale
.a95f		0a		asl a				asl 	a
.a960		0a		asl a				asl 	a
.a961		0a		asl a				asl 	a
.a962		a8		tay				tay
.a963		a9 0c		lda #$0c			lda 	#GCMD_DrawSprite 			; image drawing
.a965		a6 60		ldx $60				ldx 	NSMantissa0
.a967		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.a96a		60		rts				rts
.a96b						TextCommand:
.a96b		a2 00		ldx #$00			ldx 	#0
.a96d		20 e8 a3	jsr $a3e8			jsr 	EvaluateString 				; get text
.a970		20 b2 a9	jsr $a9b2			jsr 	RunGraphicsCommand
.a973						TextRunDraw:
.a973		09 40		ora #$40			ora 	#GCMD_Move 					; move cursor
.a975		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.a978		a0 00		ldy #$00			ldy 	#0
.a97a						_IRDLoop:
.a97a		a5 70		lda $70				lda 	NSMantissa1 				; access character
.a97c		85 37		sta $37				sta 	zTemp0+1
.a97e		a5 60		lda $60				lda 	NSMantissa0
.a980		85 36		sta $36				sta 	zTemp0
.a982		b1 36		lda ($36),y			lda 	(zTemp0),y
.a984		f0 13		beq $a999			beq 	_IRDExit
.a986		5a		phy				phy									; save string pos
.a987		48		pha				pha 								; save char
.a988		ad d4 07	lda $07d4			lda 	gxDrawScale 				; get scale
.a98b		0a		asl a				asl 	a
.a98c		0a		asl a				asl 	a
.a98d		0a		asl a				asl 	a
.a98e		a8		tay				tay
.a98f		a9 0a		lda #$0a			lda 	#GCMD_DrawFont 				; char drawing
.a991		fa		plx				plx 								; char to draw
.a992		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.a995		7a		ply				ply 								; restore string pos
.a996		c8		iny				iny
.a997		90 e1		bcc $a97a			bcc 	_IRDLoop 					; go back if no error.
.a999						_IRDExit:
.a999		60		rts				rts
.a99a						PlotCommand:
.a99a		a9 50		lda #$50			lda 	#GCMD_Plot 					; command ID to use
.a99c		20 b2 a9	jsr $a9b2			jsr 	RunGraphicsCommand
.a99f		80 05		bra $a9a6			bra 	ExecuteGraphicCommand
.a9a1						LineCommand:
.a9a1		a9 42		lda #$42			lda 	#GCMD_Line 						; command ID to use
.a9a3		20 b2 a9	jsr $a9b2			jsr 	RunGraphicsCommand
.a9a6						ExecuteGraphicCommand:
.a9a6		0d cd 07	ora $07cd			ora 	gxCommandID 				; make a full command
.a9a9		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw 				; draw it and exit
.a9ac		b0 01		bcs $a9af			bcs 	_EGCError
.a9ae		60		rts				rts
.a9af						_EGCError:
.a9af		4c 08 a6	jmp $a608			jmp 	SyntaxError
.a9b2						RunGraphicsCommand:
.a9b2		8d cd 07	sta $07cd			sta 	gxCommandID					; save TODO graphics command.
.a9b5		68		pla				pla 								; pop handler address
.a9b6		fa		plx				plx
.a9b7		1a		inc a				inc 	a
.a9b8		d0 01		bne $a9bb			bne 	_RGINoCarry
.a9ba		e8		inx				inx
.a9bb						_RGINoCarry:
.a9bb		8d d2 07	sta $07d2			sta 	gxHandler
.a9be		8e d3 07	stx $07d3			stx 	gxHandler+1
.a9c1						_RGICommandLoop:
.a9c1		b1 30		lda ($30),y			lda 	(codePtr),y
.a9c3		c8		iny				iny
.a9c4		c9 de		cmp #$de			cmp 	#KWD_TO						; is it TO x,y
.a9c6		f0 53		beq $aa1b			beq 	_RGI_To
.a9c8		c9 c8		cmp #$c8			cmp 	#KWD_HERE 					; do it here.
.a9ca		f0 55		beq $aa21			beq 	_RGI_Here
.a9cc		c9 80		cmp #$80			cmp 	#KWC_EOL 					; EOL or : , exit
.a9ce		f0 3d		beq $aa0d			beq 	_RGI_Exit
.a9d0		c9 3a		cmp #$3a			cmp 	#KWD_COLON
.a9d2		f0 39		beq $aa0d			beq 	_RGI_Exit
.a9d4		c9 d0		cmp #$d0			cmp 	#KWD_OUTLINE 				; solid or outline
.a9d6		f0 3e		beq $aa16			beq 	_RGI_Frame
.a9d8		c9 da		cmp #$da			cmp 	#KWD_SOLID
.a9da		f0 33		beq $aa0f			beq 	_RGI_Solid
.a9dc		c9 bc		cmp #$bc			cmp 	#KWD_BY 					; by offset
.a9de		f0 4b		beq $aa2b			beq 	_RGI_By
.a9e0		c9 c6		cmp #$c6			cmp 	#KWD_FROM 					; from
.a9e2		f0 17		beq $a9fb			beq 	_RGI_Move2
.a9e4		c9 c3		cmp #$c3			cmp 	#KWD_DIM 					; dim (set scale)
.a9e6		f0 62		beq $aa4a			beq 	_RGI_Dim
.a9e8		c9 c1		cmp #$c1			cmp 	#KWD_COLOUR 				; colour or Color
.a9ea		f0 74		beq $aa60			beq 	_RGI_Colour
.a9ec		c9 c0		cmp #$c0			cmp 	#KWD_COLOR
.a9ee		f0 70		beq $aa60			beq 	_RGI_Colour
.a9f0		ae cd 07	ldx $07cd			ldx 	gxCommandID
.a9f3		e0 52		cpx #$52			cpx 	#GCMD_SpriteMove 			; if not sprite
.a9f5		d0 03		bne $a9fa			bne 	_RGI_Move 					; move
.a9f7		4c 88 aa	jmp $aa88			jmp		_RGI_SpriteInstructions
.a9fa						_RGI_Move:
.a9fa		88		dey				dey 								; unpick get.
.a9fb						_RGI_Move2:
.a9fb		20 ae aa	jsr $aaae			jsr 	GCGetCoordinatePair 		; move to here
.a9fe		20 d5 aa	jsr $aad5			jsr 	GCCopyPairToStore 			; save
.aa01		5a		phy				phy
.aa02		20 cb aa	jsr $aacb			jsr 	GCLoadAXY 					; load in
.aa05		09 40		ora #$40			ora 	#GCMD_Move 					; move there
.aa07		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.aa0a		7a		ply				ply
.aa0b		80 b4		bra $a9c1			bra 	_RGICommandLoop 			; and go round
.aa0d						_RGI_Exit:
.aa0d		88		dey				dey 								; unpick : / EOL
.aa0e		60		rts				rts
.aa0f						_RGI_Solid:
.aa0f		a9 02		lda #$02			lda 	#2
.aa11		8d ce 07	sta $07ce			sta 	gxFillSolid
.aa14		80 ab		bra $a9c1			bra 	_RGICommandLoop
.aa16						_RGI_Frame:
.aa16		9c ce 07	stz $07ce			stz 	gxFillSolid
.aa19		80 a6		bra $a9c1			bra 	_RGICommandLoop
.aa1b						_RGI_To:
.aa1b		20 ae aa	jsr $aaae			jsr 	GCGetCoordinatePair 		; get coordinate pair into slot #1,#2
.aa1e		20 d5 aa	jsr $aad5			jsr 	GCCopyPairToStore
.aa21						_RGI_Here:
.aa21		5a		phy				phy
.aa22		20 cb aa	jsr $aacb			jsr 	GCLoadAXY 					; load it into AXY
.aa25		20 85 aa	jsr $aa85			jsr 	_RGICallHandler 			; go do whatever it is.
.aa28		7a		ply				ply
.aa29		80 96		bra $a9c1			bra 	_RGICommandLoop 			; and go round
.aa2b						_RGI_By:
.aa2b		20 bb aa	jsr $aabb			jsr 	GCSignedCoordinatePair 		; get coordinate pair into slot #1,#2
.aa2e		18		clc				clc
.aa2f		a5 61		lda $61				lda 	NSMantissa0+1 				; copy it into space.
.aa31		6d cf 07	adc $07cf			adc 	gxXPos
.aa34		8d cf 07	sta $07cf			sta 	gxXPos
.aa37		a5 71		lda $71				lda 	NSMantissa1+1
.aa39		6d d0 07	adc $07d0			adc 	gxXPos+1
.aa3c		8d d0 07	sta $07d0			sta 	gxXPos+1
.aa3f		a5 62		lda $62				lda 	NSMantissa0+2
.aa41		18		clc				clc
.aa42		6d d1 07	adc $07d1			adc 	gxYPos
.aa45		8d d1 07	sta $07d1			sta 	gxYPos
.aa48		80 d7		bra $aa21			bra 	_RGI_Here
.aa4a						_RGI_Dim:
.aa4a		a2 01		ldx #$01			ldx	 	#1
.aa4c		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.aa4f		a5 61		lda $61				lda 	NSMantissa0+1
.aa51		c9 00		cmp #$00			cmp 	#0
.aa53		f0 2d		beq $aa82			beq 	_RGIRange
.aa55		c9 09		cmp #$09			cmp 	#8+1
.aa57		b0 29		bcs $aa82			bcs		_RGIRange
.aa59		3a		dec a				dec 	a
.aa5a		8d d4 07	sta $07d4			sta 	gxDrawScale
.aa5d		4c c1 a9	jmp $a9c1			jmp 	_RGICommandLoop
.aa60						_RGI_Colour:
.aa60		a2 01		ldx #$01			ldx 	#1 							; colour
.aa62		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.aa65		a2 02		ldx #$02			ldx 	#2 							; default zero for 2nd parameter
.aa67		20 90 a4	jsr $a490			jsr 	NSMSetZero
.aa6a		b1 30		lda ($30),y			lda 	(codePtr),y
.aa6c		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; check , => mode.
.aa6e		d0 04		bne $aa74			bne 	_RGICDefaultMode
.aa70		c8		iny				iny
.aa71		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.aa74						_RGICDefaultMode:
.aa74		5a		phy				phy
.aa75		a9 08		lda #$08			lda 	#GCMD_Colour 				; set colour.
.aa77		a6 61		ldx $61				ldx 	NSMantissa0+1
.aa79		a4 62		ldy $62				ldy 	NSMantissa0+2
.aa7b		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.aa7e		7a		ply				ply
.aa7f		4c c1 a9	jmp $a9c1			jmp 	_RGICommandLoop 			; and go round
.aa82						_RGIRange:
.aa82		4c 0d a6	jmp $a60d			jmp 	RangeError
.aa85						_RGICallHandler:
.aa85		6c d2 07	jmp ($07d2)			jmp 	(gxHandler)
.aa88						_RGI_SpriteInstructions:
.aa88		c9 ce		cmp #$ce			cmp 	#KWD_OFF
.aa8a		f0 07		beq $aa93			beq 	_RGISpriteOff
.aa8c		c9 c9		cmp #$c9			cmp 	#KWD_IMAGE
.aa8e		f0 13		beq $aaa3			beq 	_RGISetImage
.aa90		4c fa a9	jmp $a9fa			jmp 	_RGI_Move
.aa93						_RGISpriteOff:
.aa93		5a		phy				phy
.aa94		a0 01		ldy #$01			ldy 	#1
.aa96		a2 00		ldx #$00			ldx 	#0
.aa98						_RGIDoCommandLoop:
.aa98		a9 10		lda #$10			lda 	#GCMD_SpriteImage
.aa9a		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.aa9d		7a		ply				ply
.aa9e		b0 e2		bcs $aa82			bcs 	_RGIRange
.aaa0		4c c1 a9	jmp $a9c1			jmp 	_RGICommandLoop
.aaa3						_RGISetImage:
.aaa3		a2 01		ldx #$01			ldx 	#1
.aaa5		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.aaa8		5a		phy				phy
.aaa9		aa		tax				tax
.aaaa		a0 00		ldy #$00			ldy 	#0
.aaac		80 ea		bra $aa98			bra 	_RGIDoCommandLoop
.aaae						GCGetCoordinatePair:
.aaae		a2 01		ldx #$01			ldx 	#1
.aab0		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger
.aab3		20 16 95	jsr $9516			jsr 	CheckComma
.aab6		e8		inx				inx
.aab7		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger
.aaba		60		rts				rts
.aabb						GCSignedCoordinatePair:
.aabb		a2 01		ldx #$01			ldx 	#1
.aabd		20 1a a4	jsr $a41a			jsr 	Evaluate16BitIntegerSigned
.aac0		20 16 95	jsr $9516			jsr 	CheckComma
.aac3		e8		inx				inx
.aac4		20 1a a4	jsr $a41a			jsr 	Evaluate16BitIntegerSigned
.aac7		60		rts				rts
.aac8						_GCCPRange:
.aac8		4c 0d a6	jmp $a60d			jmp 	RangeError
.aacb						GCLoadAXY:
.aacb		ad d0 07	lda $07d0			lda 	gxXPos+1
.aace		ae cf 07	ldx $07cf			ldx 	gxXPos
.aad1		ac d1 07	ldy $07d1			ldy 	gxYPos
.aad4		60		rts				rts
.aad5						GCCopyPairToStore:
.aad5		a5 61		lda $61				lda 	NSMantissa0+1 				; copy it into space.
.aad7		8d cf 07	sta $07cf			sta 	gxXPos
.aada		a5 71		lda $71				lda 	NSMantissa1+1
.aadc		8d d0 07	sta $07d0			sta 	gxXPos+1
.aadf		a5 62		lda $62				lda 	NSMantissa0+2
.aae1		8d d1 07	sta $07d1			sta 	gxYPos
.aae4		60		rts				rts
.07cd						gxCommandID:
>07cd								.fill 	1
.07ce						gxFillSolid:
>07ce								.fill 	1
.07cf						gxXPos:
>07cf								.fill 	2
.07d1						gxYPos:
>07d1								.fill 	1
.07d2						gxHandler:
>07d2								.fill 	2
.07d4						gxDrawScale:
>07d4								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gcontrol.asm

.aae5						ResetBitmapSpritesTiles:
.aae5		9c d5 07	stz $07d5			stz 	BitmapPageNumber
.aae8		9c d6 07	stz $07d6			stz 	SpritePageNumber
.aaeb		9c d7 07	stz $07d7			stz 	TileMapPageNumber
.aaee		9c d8 07	stz $07d8			stz 	TileImagePageNumber
.aaf1		a9 40		lda #$40			lda 	#64
.aaf3		8d d9 07	sta $07d9			sta 	TileMapWidth
.aaf6		a9 20		lda #$20			lda 	#32
.aaf8		8d da 07	sta $07da			sta 	TileMapHeight
.aafb		60		rts				rts
.aafc						BitmapCtrl:
.aafc						BitmapCtrlLoop:
.aafc		b1 30		lda ($30),y			lda 	(codePtr),y
.aafe		c8		iny				iny
.aaff		a2 01		ldx #$01			ldx 	#1
.ab01		c9 cf		cmp #$cf			cmp 	#KWD_ON
.ab03		f0 24		beq $ab29			beq 	BitmapSwitch
.ab05		ca		dex				dex
.ab06		c9 ce		cmp #$ce			cmp 	#KWD_OFF
.ab08		f0 1f		beq $ab29			beq 	BitmapSwitch
.ab0a		c9 bb		cmp #$bb			cmp 	#KWD_AT  					; set address
.ab0c		f0 13		beq $ab21			beq 	BitmapAddress
.ab0e		c9 bf		cmp #$bf			cmp 	#KWD_CLEAR
.ab10		f0 02		beq $ab14			beq 	BitmapClear
.ab12		88		dey				dey
.ab13		60		rts				rts
.ab14						BitmapClear:
.ab14		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; get the colour
.ab17		5a		phy				phy
.ab18		aa		tax				tax
.ab19		a9 06		lda #$06			lda 	#GCMD_Clear					; clear to that colour
.ab1b		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.ab1e		7a		ply				ply
.ab1f		80 db		bra $aafc			bra 	BitmapCtrlLoop
.ab21						BitmapAddress:
.ab21		20 ed ab	jsr $abed			jsr 	GetPageNumber
.ab24		8d d5 07	sta $07d5			sta 	BitmapPageNumber
.ab27		80 d3		bra $aafc			bra 	BitmapCtrlLoop
.ab29						BitmapSwitch:
.ab29		5a		phy				phy
.ab2a		ac d5 07	ldy $07d5			ldy 	BitmapPageNumber 			; gfx 1,on/off,0
.ab2d		a9 02		lda #$02			lda 	#GCMD_BitmapCtl
.ab2f		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.ab32		a9 08		lda #$08			lda 	#GCMD_Colour				; set colour to $FF
.ab34		a0 00		ldy #$00			ldy 	#0
.ab36		a2 ff		ldx #$ff			ldx 	#$FF
.ab38		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.ab3b		9c ce 07	stz $07ce			stz 	gxFillSolid
.ab3e		9c cf 07	stz $07cf			stz 	gxXPos
.ab41		9c d0 07	stz $07d0			stz 	gxXPos+1
.ab44		9c d1 07	stz $07d1			stz 	gxYPos
.ab47		9c d4 07	stz $07d4			stz 	gxDrawScale
.ab4a		a9 40		lda #$40			lda 	#GCMD_Move 						; home cursor
.ab4c		a2 00		ldx #$00			ldx 	#0
.ab4e		a0 00		ldy #$00			ldy 	#0
.ab50		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.ab53		7a		ply				ply
.ab54		80 a6		bra $aafc			bra 	BitmapCtrlLoop
.ab56						SpritesCtrl:
.ab56						SpritesCtrlLoop:
.ab56		b1 30		lda ($30),y			lda 	(codePtr),y
.ab58		c8		iny				iny
.ab59		a2 01		ldx #$01			ldx 	#1
.ab5b		c9 cf		cmp #$cf			cmp 	#KWD_ON
.ab5d		f0 13		beq $ab72			beq 	SpriteSwitch
.ab5f		ca		dex				dex
.ab60		c9 ce		cmp #$ce			cmp 	#KWD_OFF
.ab62		f0 0e		beq $ab72			beq 	SpriteSwitch
.ab64		c9 bb		cmp #$bb			cmp 	#KWD_AT
.ab66		f0 02		beq $ab6a			beq 	SpriteSetAddress
.ab68		88		dey				dey
.ab69		60		rts				rts
.ab6a						SpriteSetAddress:
.ab6a		20 ed ab	jsr $abed			jsr 	GetPageNumber
.ab6d		8d d6 07	sta $07d6			sta 	SpritePageNumber
.ab70		80 e4		bra $ab56			bra 	SpritesCtrlLoop
.ab72						SpriteSwitch:
.ab72		5a		phy				phy
.ab73		ac d6 07	ldy $07d6			ldy 	SpritePageNumber 			; gfx 2,on/off,0
.ab76		a9 04		lda #$04			lda 	#GCMD_SpriteCtl
.ab78		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.ab7b		7a		ply				ply
.ab7c		80 d8		bra $ab56			bra 	SpritesCtrlLoop
.ab7e						TilesCtrl:
.ab7e						TilesCtrlLoop:
.ab7e		b1 30		lda ($30),y			lda 	(codePtr),y
.ab80		c8		iny				iny
.ab81		a2 80		ldx #$80			ldx 	#$80
.ab83		c9 cf		cmp #$cf			cmp 	#KWD_ON
.ab85		f0 34		beq $abbb			beq 	TileSwitch
.ab87		a2 00		ldx #$00			ldx 	#$00
.ab89		c9 ce		cmp #$ce			cmp 	#KWD_OFF
.ab8b		f0 2e		beq $abbb			beq 	TileSwitch
.ab8d		c9 bb		cmp #$bb			cmp 	#KWD_AT
.ab8f		f0 19		beq $abaa			beq 	TileSetAddress
.ab91		c9 c3		cmp #$c3			cmp 	#KWD_DIM
.ab93		f0 02		beq $ab97			beq 	TileSetSize
.ab95		88		dey				dey
.ab96		60		rts				rts
.ab97						TileSetSize:
.ab97		a2 00		ldx #$00			ldx 	#0
.ab99		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.ab9c		8d d9 07	sta $07d9			sta 	TileMapWidth
.ab9f		20 16 95	jsr $9516			jsr 	CheckComma
.aba2		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.aba5		8d da 07	sta $07da			sta 	TileMapHeight
.aba8		80 d4		bra $ab7e			bra 	TilesCtrlLoop
.abaa						TileSetAddress:
.abaa		20 ed ab	jsr $abed			jsr 	GetPageNumber 				; map page
.abad		8d d7 07	sta $07d7			sta 	TileMapPageNumber
.abb0		20 16 95	jsr $9516			jsr 	CheckComma
.abb3		20 ed ab	jsr $abed			jsr 	GetPageNumber 				; image page
.abb6		8d d8 07	sta $07d8			sta 	TileImagePageNumber
.abb9		80 c3		bra $ab7e			bra 	TilesCtrlLoop
.abbb						TileSwitch:
.abbb		5a		phy				phy
.abbc		da		phx				phx 								; set the on/off state and the pages.
.abbd		8a		txa				txa
.abbe		0d d7 07	ora $07d7			ora 	TileMapPageNumber
.abc1		aa		tax				tax
.abc2		ac d8 07	ldy $07d8			ldy 	TileImagePageNumber
.abc5		a9 14		lda #$14			lda 	#GCMD_TileCtl
.abc7		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.abca		fa		plx				plx
.abcb		10 b1		bpl $ab7e			bpl 	TilesCtrlLoop 				; nothing else.
.abcd		a9 16		lda #$16			lda 	#GCMD_TileSize 				; set size of tile map.
.abcf		ae d9 07	ldx $07d9			ldx 	TileMapWidth
.abd2		ac da 07	ldy $07da			ldy 	TileMapHeight
.abd5		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.abd8		a9 18		lda #$18			lda 	#GCMD_TileScrollX 			; reset scroll
.abda		20 e6 ab	jsr $abe6			jsr 	_TileResetScroll
.abdd		a9 1a		lda #$1a			lda 	#GCMD_TileScrollY
.abdf		20 e6 ab	jsr $abe6			jsr 	_TileResetScroll
.abe2		7a		ply				ply
.abe3		4c 7e ab	jmp $ab7e			jmp 	TilesCtrlLoop
.abe6						_TileResetScroll:
.abe6		a2 00		ldx #$00			ldx 	#0
.abe8		a0 00		ldy #$00			ldy 	#0
.abea		4c a7 80	jmp $80a7			jmp 	GXGraphicDraw
.abed						GetPageNumber:
.abed		a2 00		ldx #$00			ldx 	#0
.abef		20 05 a4	jsr $a405			jsr 	EvaluateUnsignedInteger 	; evaluate where to go.
.abf2		a5 70		lda $70				lda 	NSMantissa1 				; check on page
.abf4		29 1f		and #$1f			and 	#$1F
.abf6		05 60		ora $60				ora 	NSMantissa0
.abf8		d0 0c		bne $ac06			bne 	_GPNError
.abfa		a5 80		lda $80				lda 	NSMantissa2
.abfc		06 70		asl $70				asl 	NSMantissa1					; get page number
.abfe		2a		rol a				rol 	a
.abff		06 70		asl $70				asl 	NSMantissa1
.ac01		2a		rol a				rol 	a
.ac02		06 70		asl $70				asl 	NSMantissa1
.ac04		2a		rol a				rol 	a
.ac05		60		rts				rts
.ac06						_GPNError:
.ac06		a9 07		lda #$07		lda	#7
.ac08		4c 27 95	jmp $9527		jmp	ErrorHandler
.07d5						BitmapPageNumber:
>07d5								.fill 	1
.07d6						SpritePageNumber:
>07d6								.fill 	1
.07d7						TileMapPageNumber:
>07d7								.fill 	1
.07d8						TileImagePageNumber:
>07d8								.fill 	1
.07d9						TileMapWidth:
>07d9								.fill 	1
.07da						TileMapHeight:
>07da								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/gfx.asm

.ac0b						GfxCommand:
.ac0b		a2 00		ldx #$00			ldx 	#0
.ac0d		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; command
.ac10		20 16 95	jsr $9516			jsr 	CheckComma
.ac13		e8		inx				inx
.ac14		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger 		; X
.ac17		20 16 95	jsr $9516			jsr 	CheckComma
.ac1a		e8		inx				inx
.ac1b		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; Y
.ac1e		a5 71		lda $71				lda 	NSMantissa1+1  				; shift bit 0 of X into CS, should now be zero
.ac20		4a		lsr a				lsr 	a
.ac21		d0 12		bne $ac35			bne 	_GfxError
.ac23		26 60		rol $60				rol 	NSMantissa0 				; rotate into command
.ac25		b0 0e		bcs $ac35			bcs 	_GfxError 					; bit 7 should have been zero
.ac27		5a		phy				phy 								; save pos
.ac28		a5 60		lda $60				lda 	NSMantissa0 				; do the command
.ac2a		a6 61		ldx $61				ldx 	NSMantissa0+1
.ac2c		a4 62		ldy $62				ldy 	NSMantissa0+2
.ac2e		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.ac31		b0 02		bcs $ac35			bcs 	_GfxError
.ac33		7a		ply				ply 								; restore pos and exit.
.ac34		60		rts				rts
.ac35						_GfxError:
.ac35		4c 0d a6	jmp $a60d			jmp 	RangeError

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/hit.asm

.ac38						UnaryHit:
.ac38		fa		plx				plx
.ac39		a9 36		lda #$36			lda 	#zTemp0
.ac3b		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; get sprite number 0
.ac3e		20 16 95	jsr $9516			jsr 	CheckComma
.ac41		e8		inx				inx
.ac42		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; get sprite number 1
.ac45		20 0e 95	jsr $950e			jsr		CheckRightBracket
.ac48		ca		dex				dex 								; fix back up again.
.ac49		da		phx				phx 								; save X/Y
.ac4a		5a		phy				phy
.ac4b		b4 61		ldy $61,x			ldy 	NSMantissa0+1,x 			; get the sprite numbers into X/Y
.ac4d		b5 60		lda $60,x			lda 	NSMantissa0,x
.ac4f		aa		tax				tax
.ac50		a9 12		lda #$12			lda 	#GCMD_SpriteCollide 		; command check collision.
.ac52		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw 				; calculate result
.ac55		1a		inc a				inc 	a 							; so 255 (fail) -> 0, otherwise 1,2,3,4 pixels etc.
.ac56		7a		ply				ply 								; restore XY
.ac57		fa		plx				plx
.ac58		20 92 a4	jsr $a492			jsr 	NSMSetByte 					; return the hit result
.ac5b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/palette.asm

.ac5c						PaletteCommand:
.ac5c		a2 00		ldx #$00			ldx 	#0
.ac5e		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; colour
.ac61		20 16 95	jsr $9516			jsr 	CheckComma
.ac64		e8		inx				inx
.ac65		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger 		; r
.ac68		20 16 95	jsr $9516			jsr 	CheckComma
.ac6b		e8		inx				inx
.ac6c		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; g
.ac6f		20 16 95	jsr $9516			jsr 	CheckComma
.ac72		e8		inx				inx
.ac73		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; b
.ac76		a5 60		lda $60				lda 	NSMantissa0 				; get colour #
.ac78		85 36		sta $36				sta 	zTemp0
.ac7a		a9 34		lda #$34			lda 	#$D0 >> 2 					; MSB = D0/4
.ac7c		85 37		sta $37				sta 	zTemp0+1
.ac7e		06 36		asl $36				asl 	zTemp0 						; zTemp = $D000+Colour x 4
.ac80		26 37		rol $37				rol	 	zTemp0+1
.ac82		06 36		asl $36				asl 	zTemp0
.ac84		26 37		rol $37				rol	 	zTemp0+1
.ac86		a9 01		lda #$01			lda 	#1 							; I/O Page 2
.ac88		85 01		sta $01				sta 	1
.ac8a		5a		phy				phy
.ac8b		a5 63		lda $63				lda 	NSMantissa0+3 				; fix to r,g,b
.ac8d		92 36		sta ($36)			sta 	(zTemp0)
.ac8f		a0 01		ldy #$01			ldy 	#1
.ac91		a5 62		lda $62				lda 	NSMantissa0+2
.ac93		91 36		sta ($36),y			sta 	(zTemp0),y
.ac95		a5 61		lda $61				lda 	NSMantissa0+1
.ac97		c8		iny				iny
.ac98		91 36		sta ($36),y			sta 	(zTemp0),y
.ac9a		7a		ply				ply
.ac9b		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/graphics/tile.asm

.ac9c						TileCommand:
.ac9c		b1 30		lda ($30),y			lda 	(codePtr),y
.ac9e		c8		iny				iny
.ac9f		c9 bb		cmp #$bb			cmp 	#KWD_AT
.aca1		f0 0a		beq $acad			beq 	_TileSetPos
.aca3		c9 d2		cmp #$d2			cmp 	#KWD_PLOT
.aca5		f0 15		beq $acbc			beq 	_TilePlot
.aca7		c9 de		cmp #$de			cmp 	#KWD_TO
.aca9		f0 40		beq $aceb			beq 	_TileScroll
.acab		88		dey				dey
.acac		60		rts				rts
.acad						_TileSetPos:
.acad		a2 00		ldx #$00			ldx 	#0 							; location to XA
.acaf		20 0b ad	jsr $ad0b			jsr 	TileGetPair
.acb2		5a		phy				phy 								; call routine
.acb3		a8		tay				tay
.acb4		a9 1c		lda #$1c			lda 	#GCMD_TilePos
.acb6		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.acb9		7a		ply				ply
.acba		80 e0		bra $ac9c			bra 	TileCommand 				; loop round
.acbc						_TilePlot:
.acbc		a2 00		ldx #$00			ldx 	#0
.acbe		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; tile to print
.acc1		a9 01		lda #$01			lda 	#1
.acc3		85 61		sta $61				sta 	NSMantissa0+1 				; default repeat count.
.acc5		a2 01		ldx #$01			ldx 	#1
.acc7		b1 30		lda ($30),y			lda 	(codePtr),y
.acc9		c9 cb		cmp #$cb			cmp 	#KWD_LINE
.accb		d0 04		bne $acd1			bne 	_TileNoRepeat
.accd		c8		iny				iny 								; skip LINE
.acce		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; evaluate count
.acd1						_TileNoRepeat:
.acd1						_TileOutLoop:
.acd1		a5 61		lda $61				lda 	NSMantissa0+1 				; complete ?
.acd3		f0 0d		beq $ace2			beq 	_TileCheckAgain 			; check , <repeats>
.acd5		c6 61		dec $61				dec 	NSMantissa0+1 				; dec count
.acd7		a9 1e		lda #$1e			lda 	#GCMD_TileWrite				; set up to write tile.
.acd9		a6 60		ldx $60				ldx 	NSMantissa0
.acdb		5a		phy				phy 								; call preserving Y
.acdc		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.acdf		7a		ply				ply
.ace0		80 ef		bra $acd1			bra 	_TileOutLoop
.ace2						_TileCheckAgain:
.ace2		b1 30		lda ($30),y			lda 	(codePtr),y
.ace4		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.ace6		d0 b4		bne $ac9c			bne 	TileCommand 				; no, do again
.ace8		c8		iny				iny 								; consume comma
.ace9		80 d1		bra $acbc			bra 	_TilePlot 					; and loop round.
.aceb						_TileScroll:
.aceb		a9 18		lda #$18			lda 	#GCMD_TileScrollX 			; do X
.aced		20 fa ac	jsr $acfa			jsr 	_TileSetScroll
.acf0		20 16 95	jsr $9516			jsr 	CheckComma
.acf3		a9 1a		lda #$1a			lda 	#GCMD_TileScrollY 			; do Y
.acf5		20 fa ac	jsr $acfa			jsr 	_TileSetScroll
.acf8		80 a2		bra $ac9c			bra 	TileCommand
.acfa						_TileSetScroll:
.acfa		48		pha				pha 								; save command on stack
.acfb		a2 00		ldx #$00			ldx 	#0 							; get value to scroll to
.acfd		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger
.ad00		68		pla				pla 								; restore command
.ad01		5a		phy				phy 								; save Y code pos
.ad02		a6 60		ldx $60				ldx 	NSMantissa0 				; YX = scroll value
.ad04		a4 70		ldy $70				ldy 	NSMantissa1
.ad06		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw 				; do command
.ad09		7a		ply				ply 								; restore code pos
.ad0a		60		rts				rts
.ad0b						TileGetPair:
.ad0b		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.ad0e		48		pha				pha
.ad0f		20 16 95	jsr $9516			jsr 	CheckComma
.ad12		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.ad15		fa		plx				plx
.ad16		60		rts				rts
.ad17						TileRead:
.ad17		fa		plx				plx 								; current stack pos (where the result goes)
.ad18		da		phx				phx 								; save it back again
.ad19		e8		inx				inx   								; space to evaluate coordinates
.ad1a		20 0b ad	jsr $ad0b			jsr 	TileGetPair 				; X A are the coordinates
.ad1d		5a		phy				phy 								; save code position
.ad1e		a8		tay				tay 								; X Y are the coordinates.
.ad1f		a9 1c		lda #$1c			lda 	#GCMD_TilePos 				; set the read position.
.ad21		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.ad24		a9 20		lda #$20			lda 	#GCMD_TileRead 				; read the tile there
.ad26		20 a7 80	jsr $80a7			jsr 	GXGraphicDraw
.ad29		7a		ply				ply 								; restore code and stack positions
.ad2a		fa		plx				plx
.ad2b		20 92 a4	jsr $a492			jsr 	NSMSetByte 					; set the result.
.ad2e		20 0e 95	jsr $950e			jsr 	CheckRightBracket 			; check for )
.ad31		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/hardware/cls.asm

.ad32						ClearScreen:
.ad32		5a		phy				phy
.ad33		a9 0c		lda #$0c			lda 	#12 						; char code 12 clears the screen.
.ad35		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.ad38		7a		ply				ply
.ad39		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/hardware/cursor.asm

.ad3a						CursorControl:
.ad3a		a2 00		ldx #$00			ldx 	#0
.ad3c		b1 30		lda ($30),y			lda 	(codePtr),y
.ad3e		c8		iny				iny
.ad3f		c9 ce		cmp #$ce			cmp 	#KWD_OFF
.ad41		f0 08		beq $ad4b			beq 	_CCOnOff
.ad43		e8		inx				inx
.ad44		c9 cf		cmp #$cf			cmp 	#KWD_ON
.ad46		f0 03		beq $ad4b			beq 	_CCOnOff
.ad48		4c 08 a6	jmp $a608			jmp 	SyntaxError
.ad4b						_CCOnOff:
.ad4b		a5 01		lda $01				lda 	1 							; save current I/O
.ad4d		48		pha				pha
.ad4e		64 01		stz $01				stz 	1 		 					; page 0.
.ad50		ad 10 d0	lda $d010			lda 	$D010 						; read Cursor control register
.ad53		29 fe		and #$fe			and 	#$FE 						; clear enable bit
.ad55		86 36		stx $36				stx 	zTemp0 						; put bit back in
.ad57		05 36		ora $36				ora 	zTemp0
.ad59		8d 10 d0	sta $d010			sta 	$D010
.ad5c		68		pla				pla 	 							; switch I/O back
.ad5d		85 01		sta $01				sta 	1
.ad5f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/crossdev.asm

.ad60						XLoadCommand:
.ad60		20 4d 8f	jsr $8f4d			jsr 	NewProgram
.ad63		20 a9 87	jsr $87a9			jsr 	BackloadProgram
.ad66		4c 1c 89	jmp $891c			jmp 	WarmStart
.ad69						XGoCommand:
.ad69		20 4d 8f	jsr $8f4d			jsr 	NewProgram
.ad6c		20 a9 87	jsr $87a9			jsr 	BackloadProgram
.ad6f		4c f6 90	jmp $90f6			jmp 	RunCurrentProgram

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/dos.asm

>0200						ArgumentStrings .fill 128
>0280						ArgumentArray   .fill (8+1)*2		; DOS provides a maximum of 8 tokens
.ad72						BootXA:
.ad72		48		pha				pha
.ad73		da		phx				phx
.ad74		20 aa 88	jsr $88aa			jsr		IsDestructiveActionOK
.ad77		fa		plx				plx
.ad78		68		pla				pla
.ad79		90 03		bcc $ad7e			bcc		_action_ok
.ad7b		4c 1c 89	jmp $891c			jmp		WarmStart
.ad7e						_action_ok:
.ad7e		85 36		sta $36				sta		zTemp0+0
.ad80		86 37		stx $37				stx		zTemp0+1
.ad82		a2 00		ldx #$00			ldx		#0
.ad84		a0 00		ldy #$00			ldy		#0
.ad86						_copy_next_string:
.ad86		98		tya				tya
.ad87		18		clc				clc
.ad88		69 00		adc #$00			adc		#<ArgumentStrings
.ad8a		9d 80 02	sta $0280,x			sta		ArgumentArray,x
.ad8d		e8		inx				inx
.ad8e		a9 02		lda #$02			lda		#>ArgumentStrings
.ad90		69 00		adc #$00			adc		#0
.ad92		9d 80 02	sta $0280,x			sta		ArgumentArray,x
.ad95		e8		inx				inx
.ad96						_copy_string:
.ad96		b1 36		lda ($36),y			lda		(zTemp0),y
.ad98		f0 1a		beq $adb4			beq		_copy_done
.ad9a		c9 20		cmp #$20			cmp		#' '
.ad9c		f0 06		beq $ada4			beq		_skip_spaces
.ad9e		99 00 02	sta $0200,y			sta		ArgumentStrings,y
.ada1		c8		iny				iny
.ada2		80 f2		bra $ad96			bra		_copy_string
.ada4						_skip_spaces:
.ada4		a9 00		lda #$00			lda		#0
.ada6		99 00 02	sta $0200,y			sta		ArgumentStrings,y
.ada9		c8		iny				iny
.adaa		b1 36		lda ($36),y			lda		(zTemp0),y
.adac		f0 06		beq $adb4			beq		_copy_done
.adae		c9 20		cmp #$20			cmp		#' '
.adb0		f0 f2		beq $ada4			beq		_skip_spaces
.adb2		80 d2		bra $ad86			bra		_copy_next_string
.adb4						_copy_done:
.adb4		a9 00		lda #$00			lda		#0
.adb6		99 00 02	sta $0200,y			sta		ArgumentStrings,y
.adb9		86 fa		stx $fa				stx		kernel.args.extlen
.adbb		9e 80 02	stz $0280,x			stz		ArgumentArray,x
.adbe		9e 81 02	stz $0281,x			stz		ArgumentArray+1,x
.adc1		a9 80		lda #$80			lda		#<ArgumentArray
.adc3		85 f8		sta $f8				sta		kernel.args.ext
.adc5		a9 02		lda #$02			lda		#>ArgumentArray
.adc7		85 f9		sta $f9				sta		kernel.args.ext+1
.adc9		a9 00		lda #$00			lda		#<ArgumentStrings
.adcb		85 fb		sta $fb				sta		kernel.args.buf
.adcd		a9 02		lda #$02			lda		#>ArgumentStrings
.adcf		85 fc		sta $fc				sta		kernel.args.buf+1
.add1		20 18 ff	jsr $ff18			jsr		kernel.RunNamed
.add4		20 96 88	jsr $8896			jsr		ResetTokenBuffer
.add7		a9 1c		lda #$1c		lda	#28
.add9		4c 27 95	jmp $9527		jmp	ErrorHandler
.addc		4c 1c 89	jmp $891c			jmp		WarmStart

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/event.asm

.addf						UnaryEvent:
.addf		fa		plx				plx
.ade0		20 7b b4	jsr $b47b			jsr 	TimerToStackX 				; timer in +0
.ade3		e8		inx				inx  								; put reference into +1
.ade4		20 84 9e	jsr $9e84			jsr 	EvaluateTerm
.ade7		b5 50		lda $50,x			lda 	NSStatus,x 					; check if is integer reference
.ade9		c9 20		cmp #$20			cmp 	#NSTInteger+NSBIsReference
.adeb		d0 4c		bne $ae39			bne 	_UEType
.aded		e8		inx				inx 								; put the step in +2
.adee		20 16 95	jsr $9516			jsr 	CheckComma
.adf1		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger
.adf4		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.adf7		ca		dex				dex
.adf8		ca		dex				dex
.adf9		b5 61		lda $61,x			lda 	NSMantissa0+1,x 			; copy reference to zTemp0
.adfb		85 36		sta $36				sta 	zTemp0
.adfd		b5 71		lda $71,x			lda 	NSMantissa1+1,x
.adff		85 37		sta $37				sta 	zTemp0+1
.ae01		5a		phy				phy
.ae02		a0 03		ldy #$03			ldy 	#3 							; check bit 7 of last bit, the packed sign bit
.ae04		b1 36		lda ($36),y			lda 	(zTemp0),y
.ae06		30 2d		bmi $ae35			bmi 	_UEFalse 					; exit if signed.
.ae08		a0 00		ldy #$00			ldy 	#0 							; has it timed out (24 bit)
.ae0a		b5 60		lda $60,x			lda 	NSMantissa0,x
.ae0c		d1 36		cmp ($36),y			cmp 	(zTemp0),y
.ae0e		c8		iny				iny
.ae0f		b5 70		lda $70,x			lda 	NSMantissa1,x
.ae11		f1 36		sbc ($36),y			sbc		(zTemp0),y
.ae13		c8		iny				iny
.ae14		b5 80		lda $80,x			lda 	NSMantissa2,x
.ae16		f1 36		sbc ($36),y			sbc		(zTemp0),y
.ae18		90 1b		bcc $ae35			bcc 	_UEFalse 					; no, return FALSE.
.ae1a		18		clc				clc
.ae1b		a0 00		ldy #$00			ldy 	#0 							; work out new value as timer() + step
.ae1d		b5 60		lda $60,x			lda 	NSMantissa0,x
.ae1f		75 62		adc $62,x			adc 	NSMantissa0+2,x
.ae21		91 36		sta ($36),y			sta 	(zTemp0),y
.ae23		c8		iny				iny
.ae24		b5 70		lda $70,x			lda 	NSMantissa1,x
.ae26		75 72		adc $72,x			adc 	NSMantissa1+2,x
.ae28		91 36		sta ($36),y			sta 	(zTemp0),y
.ae2a		c8		iny				iny
.ae2b		b5 80		lda $80,x			lda 	NSMantissa2,x
.ae2d		75 82		adc $82,x			adc 	NSMantissa2+2,x
.ae2f		91 36		sta ($36),y			sta 	(zTemp0),y
.ae31		7a		ply				ply
.ae32		4c 9a 95	jmp $959a			jmp 	ReturnTrue
.ae35						_UEFalse:
.ae35		7a		ply				ply 								; restore Y
.ae36		4c a5 95	jmp $95a5			jmp 	ReturnFalse 				; and return False
.ae39						_UEType:
.ae39		4c 12 a6	jmp $a612			jmp 	TypeError

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/bload.asm

.ae3c						Command_BLoad:
.ae3c		20 47 ae	jsr $ae47			jsr 	BLOADHandler
.ae3f		c9 00		cmp #$00			cmp 	#0
.ae41		d0 01		bne $ae44			bne 	_BLError
.ae43		60		rts				rts
.ae44						_BLError:
.ae44		4c 9b b0	jmp $b09b			jmp 	CLErrorHandler
.ae47						BLOADHandler:
.ae47		a2 00		ldx #$00			ldx 	#0
.ae49		20 e8 a3	jsr $a3e8			jsr 	EvaluateString 				; file name to load
.ae4c		20 16 95	jsr $9516			jsr 	CheckComma 					; consume comma
.ae4f		e8		inx				inx
.ae50		20 fd a3	jsr $a3fd			jsr 	EvaluateInteger 			; load address (full physical address)
.ae53		5a		phy				phy
.ae54		a5 60		lda $60				lda 	NSMantissa0					; file name -> XA
.ae56		a6 70		ldx $70				ldx 	NSMantissa1
.ae58		20 54 84	jsr $8454			jsr 	KNLOpenFileRead 			; open file for reading
.ae5b		b0 50		bcs $aead			bcs 	_BLErrorExit 				; error, so fail.
.ae5d		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.ae60		a2 01		ldx #$01			ldx 	#1 							; address is in slot # 1
.ae62		20 af ae	jsr $aeaf			jsr 	BLOpenPhysicalMemory 		; open for access.
.ae65						_BLReadFile:
.ae65		ad df 07	lda $07df			lda 	BasicFileStream
.ae68		a2 40		ldx #$40			ldx     #KNLReadBufferLen 			; set bytes to read.
.ae6a		20 ae 84	jsr $84ae			jsr 	KNLReadBlock 				; read next block
.ae6d		b0 22		bcs $ae91			bcs 	_BLFileError 				; file error, which might be EOF.
.ae6f		c9 00		cmp #$00			cmp 	#0 							; read nothing.
.ae71		f0 f2		beq $ae65			beq 	_BLReadFile
.ae73		8d dd 07	sta $07dd			sta 	BLCopyCounter 				; counter.
.ae76		ac dc 07	ldy $07dc			ldy 	BLYOffset 					; copy the buffer out here
.ae79		a2 00		ldx #$00			ldx 	#0 							; offset in buffer.
.ae7b						_BLCopyLoop:
.ae7b		bd bd 06	lda $06bd,x			lda 	KNLReadBuffer,x 			; copy byte and advance
.ae7e		91 3a		sta ($3a),y			sta 	(zTemp2),y
.ae80		c8		iny				iny
.ae81		d0 03		bne $ae86			bne 	_BLNoAdjust 				; check changed 256 byte or 8k page.
.ae83		20 d7 ae	jsr $aed7			jsr 	BLAdvancePhysicalMemory
.ae86						_BLNoAdjust:
.ae86		e8		inx				inx
.ae87		ce dd 07	dec $07dd			dec 	BLCopyCounter
.ae8a		d0 ef		bne $ae7b			bne 	_BLCopyLoop
.ae8c		8c dc 07	sty $07dc			sty 	BLYOffset 					; update Y offset
.ae8f		80 d4		bra $ae65			bra 	_BLReadFile 				; go ask for more.
.ae91						_BLFileError:
.ae91		c9 30		cmp #$30			cmp 	#KERR_EOF 					; End of file
.ae93		d0 0d		bne $aea2			bne 	_BLErrorHandler				; no, it's an actual error
.ae95		20 d1 ae	jsr $aed1			jsr 	BLClosePhysicalMemory 		; close the access.
.ae98		ad df 07	lda $07df			lda 	BasicFileStream 			; close the file
.ae9b		20 23 85	jsr $8523			jsr 	KNLCloseFile
.ae9e		a9 00		lda #$00			lda 	#0 							; and return zero.
.aea0		7a		ply				ply
.aea1		60		rts				rts
.aea2						_BLErrorHandler:
.aea2		48		pha				pha 								; save code
.aea3		20 d1 ae	jsr $aed1			jsr 	BLClosePhysicalMemory 		; close access
.aea6		ad df 07	lda $07df			lda 	BasicFileStream 			; close the open file
.aea9		20 23 85	jsr $8523			jsr 	KNLCloseFile
.aeac		68		pla				pla 								; get error code
.aead						_BLErrorExit:
.aead		7a		ply				ply 								; restore position and exit.
.aeae		60		rts				rts
=3						BLAccessPage = 3 							; page to use for actual memory.
.aeaf						BLOpenPhysicalMemory:
.aeaf		a5 0b		lda $0b				lda 	BLAccessPage+8 				; save current mapping
.aeb1		8d db 07	sta $07db			sta 	BLNormalMapping
.aeb4		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy address, 13 bit adjusted for page -> (zTemp2),BLYOffset
.aeb6		8d dc 07	sta $07dc			sta 	BLYOffset 					; zTemp2 0 is *always* zero.
.aeb9		64 3a		stz $3a				stz 	zTemp2
.aebb		b5 70		lda $70,x			lda 	NSMantissa1,x
.aebd		29 1f		and #$1f			and 	#$1F
.aebf		09 60		ora #$60			ora 	#BLAccessPage << 5
.aec1		85 3b		sta $3b				sta 	zTemp2+1
.aec3		b5 80		lda $80,x			lda 	NSMantissa2,x 				; shift M2:M1 right 3 times to give page # required
.aec5		16 70		asl $70,x			asl 	NSMantissa1,x
.aec7		2a		rol a				rol 	a
.aec8		16 70		asl $70,x			asl 	NSMantissa1,x
.aeca		2a		rol a				rol 	a
.aecb		16 70		asl $70,x			asl 	NSMantissa1,x
.aecd		2a		rol a				rol 	a
.aece		85 0b		sta $0b				sta 	BLAccessPage+8 				; access that page
.aed0		60		rts				rts
.aed1						BLClosePhysicalMemory:
.aed1		ad db 07	lda $07db			lda 	BLNormalMapping
.aed4		85 0b		sta $0b				sta 	BLAccessPage+8
.aed6		60		rts				rts
.aed7						BLAdvancePhysicalMemory:
.aed7		48		pha				pha
.aed8		e6 3b		inc $3b				inc		zTemp2+1 					; bump MSB
.aeda		a5 3b		lda $3b				lda 	zTemp2+1
.aedc		c9 80		cmp #$80			cmp 	#(BLAccessPage+1) << 5 		; reached next page ?
.aede		d0 06		bne $aee6			bne 	_BLAPMExit 					; (e.g. end of the mapped page.)
.aee0		e6 0b		inc $0b				inc 	BLAccessPage+8 				; next physical page
.aee2		a9 60		lda #$60			lda 	#BLAccessPage << 5 			; page back to start of transfer page
.aee4		85 3b		sta $3b				sta 	zTemp2+1
.aee6						_BLAPMExit:
.aee6		68		pla				pla
.aee7		60		rts				rts
.07db						BLNormalMapping:
>07db								.fill 	1
.07dc						BLYOffset:
>07dc								.fill 	1
.07dd						BLCopyCounter:
>07dd								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/bsave.asm

.aee8						Command_BSave:
.aee8		20 f3 ae	jsr $aef3			jsr 	BSaveHandler
.aeeb		c9 00		cmp #$00			cmp 	#0
.aeed		d0 01		bne $aef0			bne 	_BSError
.aeef		60		rts				rts
.aef0						_BSError:
.aef0		4c 9b b0	jmp $b09b			jmp 	CLErrorHandler
.aef3						BSaveHandler:
.aef3		a2 00		ldx #$00			ldx 	#0
.aef5		20 e8 a3	jsr $a3e8			jsr 	EvaluateString 				; file name to load
.aef8		20 16 95	jsr $9516			jsr 	CheckComma 					; consume comma
.aefb		e8		inx				inx
.aefc		20 fd a3	jsr $a3fd			jsr 	EvaluateInteger 			; load address (full physical address)
.aeff		20 16 95	jsr $9516			jsr 	CheckComma 					; consume comma
.af02		e8		inx				inx
.af03		20 fd a3	jsr $a3fd			jsr 	EvaluateInteger 			; data length (3 bytes only)
.af06		5a		phy				phy
.af07		a5 60		lda $60				lda 	NSMantissa0					; file name -> XA
.af09		a6 70		ldx $70				ldx 	NSMantissa1
.af0b		20 4f 84	jsr $844f			jsr 	KNLOpenFileWrite 			; open file for reading
.af0e		b0 47		bcs $af57			bcs 	_BSErrorExit 				; error, so fail.
.af10		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.af13		a2 01		ldx #$01			ldx 	#1 							; address is in slot # 1
.af15		20 af ae	jsr $aeaf			jsr 	BLOpenPhysicalMemory 		; open for access.
.af18		a2 00		ldx #$00			ldx 	#0 							; number of bytes in kernel buffer
.af1a		ac dc 07	ldy $07dc			ldy 	BLYOffset 					; used for data offset.
.af1d						_BSWriteToFileLoop:
.af1d		38		sec				sec 								; pre decrement count.
.af1e		a5 62		lda $62				lda 	NSMantissa0+2
.af20		e9 01		sbc #$01			sbc 	#1
.af22		85 62		sta $62				sta 	NSMantissa0+2
.af24		a5 72		lda $72				lda 	NSMantissa1+2
.af26		e9 00		sbc #$00			sbc 	#0
.af28		85 72		sta $72				sta 	NSMantissa1+2
.af2a		a5 82		lda $82				lda 	NSMantissa2+2
.af2c		e9 00		sbc #$00			sbc 	#0
.af2e		85 82		sta $82				sta 	NSMantissa2+2
.af30		30 15		bmi $af47			bmi 	_BSFileComplete 			; undercounted, so exit.
.af32		b1 3a		lda ($3a),y			lda 	(zTemp2),y 					; get byte to save
.af34		9d bd 06	sta $06bd,x			sta 	KNLReadBuffer,x 			; save in the buffer and bump buffer index
.af37		e8		inx				inx
.af38		c8		iny				iny 								; next byte
.af39		d0 03		bne $af3e			bne 	_BSNoCheck
.af3b		20 d7 ae	jsr $aed7			jsr 	BLAdvancePhysicalMemory 	; check not gone to next page.
.af3e						_BSNoCheck:
.af3e		e0 40		cpx #$40			cpx 	#KNLReadBufferLen 			; done the whole buffer
.af40		d0 db		bne $af1d			bne 	_BSWriteToFileLoop 			; no , do the next byte.
.af42		20 59 af	jsr $af59			jsr 	BSFlushBuffer 				; yes, flush the buffer
.af45		80 d6		bra $af1d			bra 	_BSWriteToFileLoop 			; and keep on going
.af47						_BSFileComplete:
.af47		20 59 af	jsr $af59			jsr 	BSFlushBuffer 				; write the buffer remainder.
.af4a		20 d1 ae	jsr $aed1			jsr 	BLClosePhysicalMemory 		; close the access.
.af4d		ad df 07	lda $07df			lda 	BasicFileStream 			; close the file
.af50		20 23 85	jsr $8523			jsr 	KNLCloseFile
.af53		a9 00		lda #$00			lda 	#0
.af55		7a		ply				ply
.af56		60		rts				rts
.af57						_BSErrorExit:
.af57		7a		ply				ply
.af58		60		rts				rts
.af59						BSFlushBuffer:
.af59		e0 00		cpx #$00			cpx 	#0 							; buffer empty ?
.af5b		f0 0d		beq $af6a			beq 	_BSFBExit 					; if so, exit.
.af5d		a9 bd		lda #$bd			lda 	#KNLReadBuffer & $FF 		; where to write from.
.af5f		85 36		sta $36				sta 	zTemp0
.af61		a9 06		lda #$06			lda 	#KNLReadBuffer >> 8
.af63		85 37		sta $37				sta 	zTemp0+1 					; # of bytes in X
.af65		20 5d b1	jsr $b15d			jsr 	CLWriteByteBlock 			; write it.
.af68		a2 00		ldx #$00			ldx 	#0 							; buffer is empty.
.af6a						_BSFBExit:
.af6a		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/dir.asm

.af6b						Command_Dir:
.af6b		ad bd 07	lda $07bd			lda     KNLDefaultDrive				; set drive to list.
.af6e		85 f3		sta $f3				sta     kernel.args.directory.open.drive
.af70		64 fd		stz $fd				stz     kernel.args.directory.open.path_len
.af72		20 78 ff	jsr $ff78			jsr     kernel.Directory.Open
.af75		b0 4f		bcs $afc6			bcs     _CDExit
.af77						_CDEventLoop:
.af77		20 0c ff	jsr $ff0c			jsr     kernel.Yield        		; Polite, not actually needed.
.af7a		20 09 83	jsr $8309			jsr     GetNextEvent
.af7d		b0 f8		bcs $af77			bcs     _CDEventLoop
.af7f		ad be 07	lda $07be			lda     KNLEvent.type
.af82		c9 46		cmp #$46			cmp     #kernel.event.directory.CLOSED
.af84		f0 40		beq $afc6			beq    	_CDExit
.af86		20 8b af	jsr $af8b			jsr     _CDMessages 				; handle various messages
.af89		80 ec		bra $af77			bra     _CDEventLoop
.af8b						_CDMessages:
.af8b		c9 3c		cmp #$3c			cmp     #kernel.event.directory.OPENED
.af8d		f0 15		beq $afa4			beq     _CDEVRead
.af8f		c9 3e		cmp #$3e			cmp     #kernel.event.directory.VOLUME
.af91		f0 19		beq $afac			beq     _CDEVVolume
.af93		c9 40		cmp #$40			cmp     #kernel.event.directory.FILE
.af95		f0 32		beq $afc9			beq     _CDEVFile
.af97		c9 42		cmp #$42			cmp     #kernel.event.directory.FREE
.af99		f0 70		beq $b00b			beq     _CDEVFree
.af9b		c9 44		cmp #$44			cmp     #kernel.event.directory.EOF
.af9d		f0 6e		beq $b00d			beq     _CDEVEOF
.af9f		c9 48		cmp #$48			cmp     #kernel.event.directory.ERROR
.afa1		f0 6a		beq $b00d			beq     _CDEVEOF
.afa3		60		rts				rts
.afa4						_CDEVRead:
.afa4		ad c1 07	lda $07c1			lda     KNLEvent.directory.stream
.afa7		85 f3		sta $f3				sta     kernel.args.directory.read.stream
.afa9		4c 7c ff	jmp $ff7c			jmp     kernel.Directory.Read
.afac						_CDEVVolume:
.afac		a9 5b		lda #$5b			lda 	#"["
.afae		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afb1		ad c3 07	lda $07c3			lda     KNLEvent.directory.volume.len
.afb4		20 15 b0	jsr $b015			jsr     _CDReadData
.afb7		20 86 95	jsr $9586			jsr 	PrintStringXA
.afba		a9 5d		lda #$5d			lda 	#"]"
.afbc		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afbf		a9 0d		lda #$0d			lda 	#13
.afc1		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afc4		80 de		bra $afa4			bra     _CDEVRead
.afc6						_CDExit:
.afc6		4c 1c 89	jmp $891c			jmp 	WarmStart
.afc9						_CDEVFile:
.afc9		a9 20		lda #$20			lda 	#32
.afcb		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afce		ad c3 07	lda $07c3			lda     KNLEvent.directory.file.len
.afd1		48		pha				pha
.afd2		20 15 b0	jsr $b015			jsr     _CDReadData
.afd5		20 86 95	jsr $9586			jsr 	PrintStringXA
.afd8		68		pla				pla
.afd9		49 ff		eor #$ff			eor 	#$FF
.afdb		38		sec				sec
.afdc		69 10		adc #$10			adc 	#16
.afde		aa		tax				tax
.afdf						_CDEVTab:
.afdf		a9 20		lda #$20			lda 	#32
.afe1		20 4d 80	jsr $804d			jsr 	EXTPrintCharacter
.afe4		ca		dex				dex
.afe5		10 f8		bpl $afdf			bpl 	_CDEVTab
.afe7		20 2c b0	jsr $b02c			jsr 	_CDReadExtended
.afea		ad 46 05	lda $0546			lda 	lineBuffer
.afed		ae 47 05	ldx $0547			ldx 	lineBuffer+1
.aff0		20 9c 99	jsr $999c			jsr 	ConvertInt16
.aff3		20 86 95	jsr $9586			jsr 	PrintStringXA
.aff6		a2 af		ldx #$af			ldx 	#_CDEVFMessage >> 8
.aff8		a9 ff		lda #$ff			lda 	#_CDEVFMessage & $FF
.affa		20 86 95	jsr $9586			jsr 	PrintStringXA
.affd		80 a5		bra $afa4			bra     _CDEVRead
.afff						_CDEVFMessage:
>afff		20 62 6c 6f 63 6b 28 73				.text 	" block(s).",13,0
>b007		29 2e 0d 00
.b00b						_CDEVFree:
.b00b		80 00		bra $b00d			bra     _CDEVEOF
.b00d						_CDEVEOF:
.b00d		ad c1 07	lda $07c1			lda     KNLEvent.directory.stream
.b010		85 f3		sta $f3				sta     kernel.args.directory.close.stream
.b012		4c 80 ff	jmp $ff80			jmp     kernel.Directory.Close
.b015						_CDReadData:
.b015		85 fd		sta $fd				sta     kernel.args.recv.buflen
.b017		a9 46		lda #$46			lda     #lineBuffer & $FF
.b019		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.b01b		a9 05		lda #$05			lda     #lineBuffer >> 8
.b01d		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.b01f		20 04 ff	jsr $ff04			jsr     kernel.ReadData
.b022		a6 fd		ldx $fd				ldx     kernel.args.recv.buflen
.b024		9e 46 05	stz $0546,x			stz     lineBuffer,x
.b027		a9 46		lda #$46			lda 	#lineBuffer & $FF
.b029		a2 05		ldx #$05			ldx 	#lineBuffer >> 8
.b02b		60		rts				rts
.b02c						_CDReadExtended:
.b02c		a9 02		lda #$02			lda     #2
.b02e		85 fd		sta $fd				sta     kernel.args.recv.buflen
.b030		a9 46		lda #$46			lda     #lineBuffer & $FF
.b032		85 fb		sta $fb				sta     kernel.args.recv.buf+0
.b034		a9 05		lda #$05			lda     #lineBuffer >> 8
.b036		85 fc		sta $fc				sta     kernel.args.recv.buf+1
.b038		4c 08 ff	jmp $ff08			jmp     kernel.ReadExt

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/drive.asm

.b03b						Command_Drive:
.b03b		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.b03e		20 4b 84	jsr $844b			jsr 	KNLSetDrive
.b041		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/load.asm

.b042						Command_Load:
.b042		20 aa 88	jsr $88aa			jsr		IsDestructiveActionOK
.b045		b0 03		bcs $b04a			bcs		_not_ok
.b047		20 4d b0	jsr $b04d			jsr 	LoadFile
.b04a						_not_ok
.b04a		4c 1c 89	jmp $891c			jmp		WarmStart
.b04d						LoadFile:
.b04d		20 e8 a3	jsr $a3e8			jsr 	EvaluateString 				; file name to load
.b050		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.b052		a5 36		lda $36				lda 	zTemp0
.b054		20 54 84	jsr $8454			jsr 	KNLOpenFileRead 			; open file for reading
.b057		b0 42		bcs $b09b			bcs 	CLErrorHandler 				; error, so fail.
.b059		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.b05c		20 eb b0	jsr $b0eb			jsr     LoadReadByteInit            ; Init reader with the stream
.b05f		20 4d 8f	jsr $8f4d			jsr 	NewProgram 					; does the actual NEW.
.b062		9c de 07	stz $07de			stz 	LoadEOFFlag 				; clear EOF Flag.
.b065						_CLLoop:
.b065		20 a9 b0	jsr $b0a9			jsr 	LoadReadLine 				; get next line.
.b068		f0 10		beq $b07a			beq 	_CLExit 					; end, exit.
.b06a		20 9d 80	jsr $809d			jsr 	TKTokeniseLine 				; tokenise the line.
.b06d		ad 47 04	lda $0447			lda 	tokenLineNumber 			; line number = 0
.b070		0d 48 04	ora $0448			ora 	tokenLineNumber+1
.b073		f0 f0		beq $b065			beq 	_CLLoop 					; not legal code, blank line or maybe a comment.
.b075		20 6c 88	jsr $886c			jsr 	EditProgramCode 			; do the editing etc.
.b078		80 eb		bra $b065			bra 	_CLLoop
.b07a						_CLExit:
.b07a		ad df 07	lda $07df			lda 	BasicFileStream
.b07d		20 23 85	jsr $8523			jsr 	KNLCloseFile
.b080						CLComplete:
.b080		a9 88		lda #$88			lda 	#_CLCMsg & $FF
.b082		a2 b0		ldx #$b0			ldx 	#_CLCMsg >> 8
.b084		20 86 95	jsr $9586			jsr 	PrintStringXA
.b087		60		rts				rts
.b088						_CLCMsg:
>b088		43 6f 6d 70 6c 65 74 65				.text 	"Complete.",13,0
>b090		2e 0d 00
.b093						CLCloseError:
.b093		48		pha				pha
.b094		ad df 07	lda $07df			lda 	BasicFileStream
.b097		20 23 85	jsr $8523			jsr 	KNLCloseFile
.b09a		68		pla				pla
.b09b						CLErrorHandler:
.b09b		c9 28		cmp #$28			cmp 	#KERR_NOTFOUND
.b09d		f0 05		beq $b0a4			beq 	_CLEHNotFound
.b09f		a9 1a		lda #$1a		lda	#26
.b0a1		4c 27 95	jmp $9527		jmp	ErrorHandler
.b0a4						_CLEHNotFound:
.b0a4		a9 19		lda #$19		lda	#25
.b0a6		4c 27 95	jmp $9527		jmp	ErrorHandler
.b0a9						LoadReadLine:
.b0a9		a2 00		ldx #$00			ldx 	#0 							; look for first character non space/ctl
.b0ab		20 c5 b0	jsr $b0c5			jsr 	LoadReadCharacter
.b0ae		f0 14		beq $b0c4			beq 	_LRLExit 					; eof ?
.b0b0		c9 21		cmp #$21			cmp 	#' '+1 						; space control tab skip
.b0b2		90 f5		bcc $b0a9			bcc 	LoadReadLine
.b0b4						_LRLLoop:
.b0b4		9d 46 05	sta $0546,x			sta 	lineBuffer,x 				; write into line buffer
.b0b7		9e 47 05	stz $0547,x			stz 	lineBuffer+1,x 				; make ASCIIZ
.b0ba		e8		inx				inx
.b0bb		20 c5 b0	jsr $b0c5			jsr 	LoadReadCharacter 			; next line
.b0be		c9 20		cmp #$20			cmp 	#32 						; until < space ctrl/eof.
.b0c0		b0 f2		bcs $b0b4			bcs 	_LRLLoop
.b0c2		a9 01		lda #$01			lda 	#1 							; return code 1, okay.
.b0c4						_LRLExit:
.b0c4		60		rts				rts
.b0c5						LoadReadCharacter:
.b0c5		da		phx				phx
.b0c6		5a		phy				phy
.b0c7		ad de 07	lda $07de			lda 	LoadEOFFlag 				; already done EOF.
.b0ca		d0 0c		bne $b0d8			bne 	_LRCIsEOF
.b0cc		20 f5 b0	jsr $b0f5			jsr 	LoadReadByte 				; read a byte
.b0cf		90 09		bcc $b0da			bcc		_LRCExit 					; read okay.
.b0d1		c9 30		cmp #$30			cmp 	#KERR_EOF 					; if error not EOF it's an actual error.
.b0d3		d0 be		bne $b093			bne 	CLCloseError
.b0d5		ce de 07	dec $07de			dec 	LoadEOFFlag
.b0d8						_LRCIsEOF:
.b0d8		a9 00		lda #$00			lda 	#0
.b0da						_LRCExit:
.b0da		c9 09		cmp #$09			cmp 	#9 							; convert tab to space
.b0dc		d0 02		bne $b0e0			bne 	_LRCNotTab
.b0de		a9 20		lda #$20			lda 	#' '
.b0e0						_LRCNotTab:
.b0e0		c9 0a		cmp #$0a			cmp 	#$0A
.b0e2		d0 02		bne $b0e6			bne 	_LRCNotLF
.b0e4		a9 0d		lda #$0d			lda 	#$0D
.b0e6						_LRCNotLF:
.b0e6		7a		ply				ply
.b0e7		fa		plx				plx
.b0e8		c9 00		cmp #$00			cmp 	#0 							; set Z flag if EOF.
.b0ea		60		rts				rts
.b0eb						LoadReadByteInit:
.b0eb		8d e0 07	sta $07e0			sta     LoadFileStream 				; save stream
.b0ee		9c e1 07	stz $07e1			stz     LoadNextCharacter 			; reset buffer
.b0f1		9c e2 07	stz $07e2			stz     LoadEndCharacter
.b0f4		60		rts				rts
.b0f5						LoadReadByte:
.b0f5		da		phx				phx
.b0f6		ae e1 07	ldx $07e1			ldx     LoadNextCharacter 					; all data consumed ?
.b0f9		ec e2 07	cpx $07e2			cpx     LoadEndCharacter
.b0fc		d0 12		bne $b110			bne     _KNLRBGetNextByte
.b0fe		ad e0 07	lda $07e0			lda     LoadFileStream
.b101		a2 40		ldx #$40			ldx     #KNLReadBufferLen 			; set bytes to read.
.b103		20 ae 84	jsr $84ae			jsr     KNLReadBlock 				; read next chunk from the stream
.b106		b0 0f		bcs $b117			bcs     _KNLRBError 				; error has occurred on read.
.b108		8d e2 07	sta $07e2			sta     LoadEndCharacter 						; # read is the number available
.b10b		a2 00		ldx #$00			ldx     #0 							; reset the read pointer.
.b10d		8e e1 07	stx $07e1			stx     LoadNextCharacter
.b110						_KNLRBGetNextByte:
.b110		bd bd 06	lda $06bd,x			lda     KNLReadBuffer,x 			; get the next data item
.b113		ee e1 07	inc $07e1			inc     LoadNextCharacter 					; and advance the index
.b116		18		clc				clc 								; succeeded
.b117						_KNLRBError:
.b117		fa		plx				plx
.b118		60		rts				rts
.07de						LoadEOFFlag:
>07de								.fill 	1
.07df						BasicFileStream:
>07df								.fill 	1
.07e0						LoadFileStream:
>07e0								.byte   ?
.07e1						LoadNextCharacter:
>07e1								.byte   ?
.07e2						LoadEndCharacter:
>07e2								.byte   ?

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/save.asm

.b119						Command_Save:
.b119		20 e8 a3	jsr $a3e8			jsr 	EvaluateString 				; file name to load
.b11c		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.b11e		a5 36		lda $36				lda 	zTemp0
.b120		20 4f 84	jsr $844f			jsr 	KNLOpenFileWrite 			; open file for writing
.b123		b0 35		bcs $b15a			bcs 	CSErrorHandler 				; error, so fail.
.b125		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.b128		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.b12a		85 30		sta $30				sta 	codePtr
.b12c		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.b12e		85 31		sta $31				sta 	codePtr+1
.b130						_CSLoop:
.b130		b2 30		lda ($30)			lda 	(codePtr)
.b132		f0 17		beq $b14b			beq 	_CSExit
.b134		20 7e b1	jsr $b17e			jsr 	CSGetCleanLine
.b137		84 37		sty $37				sty 	zTemp0+1 					; save write address of data
.b139		85 36		sta $36				sta 	zTemp0
.b13b		20 5d b1	jsr $b15d			jsr 	CLWriteByteBlock 			; write the block out.
.b13e		18		clc				clc
.b13f		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.b141		65 30		adc $30				adc 	codePtr
.b143		85 30		sta $30				sta 	codePtr
.b145		90 02		bcc $b149			bcc 	_CREExit
.b147		e6 31		inc $31				inc 	codePtr+1 					; carry
.b149						_CREExit:
.b149		80 e5		bra $b130			bra 	_CSLoop
.b14b						_CSExit:
.b14b		ad df 07	lda $07df			lda 	BasicFileStream 			; close file
.b14e		20 23 85	jsr $8523			jsr 	KNLCloseFile
.b151		20 80 b0	jsr $b080			jsr 	CLComplete 					; display complete message.
.b154		9c 75 06	stz $0675			stz		programChanged				; mark program not changed since save
.b157		4c 1c 89	jmp $891c			jmp 	WarmStart 					; and warm start
.b15a						CSErrorHandler:
.b15a		4c 9b b0	jmp $b09b			jmp 	CLErrorHandler
.b15d						CLWriteByteBlock:
.b15d		e0 00		cpx #$00			cpx 	#0 							; written the lot ?
.b15f		f0 1c		beq $b17d			beq 	_CLWBBExit					; if so, exit
.b161		ad df 07	lda $07df			lda 	BasicFileStream 			; stream to write, count in X
.b164		20 e9 84	jsr $84e9			jsr 	KNLWriteBlock 				; call one write attempt
.b167		b0 f1		bcs $b15a			bcs 	CSErrorHandler 				; error occurred
.b169		85 38		sta $38				sta 	zTemp1 						; save bytes written.
.b16b		8a		txa				txa 								; subtract bytes written from X, total count.
.b16c		38		sec				sec
.b16d		e5 38		sbc $38				sbc 	zTemp1
.b16f		aa		tax				tax
.b170		18		clc				clc 								; advance zTemp0 pointer by bytes written.
.b171		a5 36		lda $36				lda 	zTemp0
.b173		65 38		adc $38				adc 	zTemp1
.b175		85 36		sta $36				sta 	zTemp0
.b177		90 e4		bcc $b15d			bcc 	CLWriteByteBlock
.b179		e6 37		inc $37				inc 	zTemp0+1
.b17b		80 e0		bra $b15d			bra 	CLWriteByteBlock 			; and retry write out.
.b17d						_CLWBBExit:
.b17d		60		rts				rts
.b17e						CSGetCleanLine:
.b17e		a9 00		lda #$00			lda 	#0 							; no indent.
.b180		20 93 80	jsr $8093			jsr 	TKListConvertLine 			; convert line into token Buffer
.b183		a2 00		ldx #$00			ldx 	#0 							; copy stripping controls.
.b185		a0 00		ldy #$00			ldy 	#0
.b187						_CSClean:
.b187		b9 49 04	lda $0449,y			lda 	tokenBuffer,y
.b18a		f0 09		beq $b195			beq 	_CSDoneClean
.b18c		30 04		bmi $b192			bmi 	_CSIgnoreCharacter
.b18e		9d 46 05	sta $0546,x			sta 	lineBuffer,x
.b191		e8		inx				inx
.b192						_CSIgnoreCharacter:
.b192		c8		iny				iny
.b193		80 f2		bra $b187			bra 	_CSClean
.b195						_CSDoneClean:
.b195		a9 0d		lda #$0d			lda 	#13 						; add CR, length now in X and ASCIIZ.
.b197		9d 46 05	sta $0546,x			sta 	lineBuffer,x
.b19a		e8		inx				inx
.b19b		9e 46 05	stz $0546,x			stz 	lineBuffer,x
.b19e		a0 05		ldy #$05			ldy 	#(lineBuffer >> 8) 			; line address in YA
.b1a0		a9 46		lda #$46			lda 	#(lineBuffer & $FF)
.b1a2		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/try.asm

.b1a3						Command_Try:
.b1a3		b1 30		lda ($30),y			lda 	(codePtr),y
.b1a5		c9 81		cmp #$81			cmp 	#KWC_SHIFT1					; can only try in SHIFT_1
.b1a7		d0 0c		bne $b1b5			bne 	_TrySyntax
.b1a9		c8		iny				iny 								; get second
.b1aa		b1 30		lda ($30),y			lda 	(codePtr),y
.b1ac		c8		iny				iny 								; and consume it.
.b1ad		c9 86		cmp #$86			cmp 	#KWD1_BLOAD
.b1af		f0 09		beq $b1ba			beq 	_TryBLoad
.b1b1		c9 87		cmp #$87			cmp	 	#KWD1_BSAVE
.b1b3		f0 0a		beq $b1bf			beq 	_TryBSave
.b1b5						_TrySyntax:
.b1b5		a9 02		lda #$02		lda	#2
.b1b7		4c 27 95	jmp $9527		jmp	ErrorHandler
.b1ba						_TryBLoad:
.b1ba		20 47 ae	jsr $ae47			jsr 	BLOADHandler
.b1bd		80 03		bra $b1c2			bra 	_TryExit
.b1bf						_TryBSave:
.b1bf		20 f3 ae	jsr $aef3			jsr 	BSaveHandler
.b1c2						_TryExit:
.b1c2		48		pha				pha 								; save result
.b1c3		b1 30		lda ($30),y			lda 	(codePtr),y
.b1c5		c8		iny				iny
.b1c6		c9 de		cmp #$de			cmp 	#KWD_TO
.b1c8		d0 eb		bne $b1b5			bne 	_TrySyntax
.b1ca		a2 00		ldx #$00			ldx 	#0 							; get an integer reference.
.b1cc		20 84 9e	jsr $9e84			jsr 	EvaluateTerm
.b1cf		b5 50		lda $50,x			lda 	NSStatus,x
.b1d1		c9 20		cmp #$20			cmp 	#NSBIsReference+NSTInteger 	; do we have an integer 4 byte reference.
.b1d3		d0 e0		bne $b1b5			bne		_TrySyntax
.b1d5		68		pla				pla 								; error code.
.b1d6		a2 01		ldx #$01			ldx	 	#1 							; address in 0, data in 1
.b1d8		20 92 a4	jsr $a492			jsr 	NSMSetByte
.b1db		ca		dex				dex
.b1dc		20 57 8d	jsr $8d57			jsr 	AssignVariable 				; do the assign and exit
.b1df		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/files/verify.asm

.f034						m
.b1e0						Command_VERIFY:
.b1e0		20 e8 a3	jsr $a3e8			jsr 	EvaluateString 				; file name to verify
.b1e3		a6 37		ldx $37				ldx 	zTemp0+1					; zTemp0 -> XA
.b1e5		a5 36		lda $36				lda 	zTemp0
.b1e7		20 54 84	jsr $8454			jsr 	KNLOpenFileRead 			; open file for reading
.b1ea		b0 51		bcs $b23d			bcs 	_CVErrorHandler 			; error, so fail.
.b1ec		8d df 07	sta $07df			sta 	BasicFileStream 			; save the reading stream.
.b1ef		20 eb b0	jsr $b0eb			jsr     LoadReadByteInit            ; Init reader with the stream
.b1f2		9c de 07	stz $07de			stz 	LoadEOFFlag 				; clear EOF Flag.
.b1f5		a9 00		lda #$00			lda 	#((BasicStart) & $FF)
.b1f7		85 30		sta $30				sta 	codePtr
.b1f9		a9 20		lda #$20			lda 	#((BasicStart) >> 8)
.b1fb		85 31		sta $31				sta 	codePtr+1
.b1fd						_CVLoop:
.b1fd		20 a9 b0	jsr $b0a9			jsr 	LoadReadLine 				; get next line.
.b200		f0 27		beq $b229			beq 	_CVExit 					; end, exit.
.b202		20 9d 80	jsr $809d			jsr 	TKTokeniseLine 				; tokenise the line.
.b205		ad 47 04	lda $0447			lda 	tokenLineNumber 			; line number = 0
.b208		0d 48 04	ora $0448			ora 	tokenLineNumber+1
.b20b		f0 f0		beq $b1fd			beq 	_CVLoop 					; not legal code, blank line or maybe a comment.
.b20d		a0 00		ldy #$00			ldy 	#0 							; start compare
.b20f						_CVCompareLoop:
.b20f		b1 30		lda ($30),y			lda 	(codePtr),y
.b211		d9 46 04	cmp $0446,y			cmp 	tokenOffset,y 				; compare against actual code.
.b214		d0 1f		bne $b235			bne 	_CVCompareError
.b216		c8		iny				iny
.b217		cc 46 04	cpy $0446			cpy 	tokenOffset 				; until done whole line of code
.b21a		d0 f3		bne $b20f			bne 	_CVCompareLoop
.b21c		18		clc				clc
.b21d		b2 30		lda ($30)			lda 	(codePtr)					; get offset and add
.b21f		65 30		adc $30				adc 	codePtr
.b221		85 30		sta $30				sta 	codePtr
.b223		90 02		bcc $b227			bcc 	_CREExit
.b225		e6 31		inc $31				inc 	codePtr+1 					; carry
.b227						_CREExit:
.b227		80 d4		bra $b1fd			bra 	_CVLoop
.b229						_CVExit:
.b229		ad df 07	lda $07df			lda 	BasicFileStream
.b22c		20 23 85	jsr $8523			jsr 	KNLCloseFile
.b22f		20 80 b0	jsr $b080			jsr 	CLComplete
.b232		4c 1c 89	jmp $891c			jmp		WarmStart
.b235						_CVCompareError:
.b235		20 96 88	jsr $8896			jsr		ResetTokenBuffer
.b238		a9 1b		lda #$1b		lda	#27
.b23a		4c 27 95	jmp $9527		jmp	ErrorHandler
.b23d						_CVErrorHandler:
.b23d		4c 9b b0	jmp $b09b			jmp 	CLErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/joy.asm

.b240						UnaryJoyX:
.b240		18		clc				clc
.b241		80 01		bra $b244			bra 	JoyMain
.b243						UnaryJoyY:
.b243		38		sec				sec
.b244						JoyMain:
.b244		fa		plx				plx 								; get pos
.b245		08		php				php 								; save carry (set for Y)
.b246		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; ignore the parameter
.b249		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.b24c		20 29 85	jsr $8529			jsr 	KNLReadController 			; read the controller.
.b24f		28		plp				plp
.b250		b0 02		bcs $b254			bcs 	_JMNoShift 					; if X then shift bits 3,2 -> 1,0
.b252		4a		lsr a				lsr 	a
.b253		4a		lsr a				lsr 	a
.b254						_JMNoShift:
.b254		4a		lsr a				lsr 	a 							; if bit 0 set then left/up e.g. -1
.b255		b0 07		bcs $b25e			bcs 	JMIsLeft
.b257		4a		lsr a				lsr 	a 							; if bit 1 set then right/down e.g. +1
.b258		b0 07		bcs $b261			bcs 	JMIsRight
.b25a		20 90 a4	jsr $a490			jsr 	NSMSetZero 					; zero result
.b25d		60		rts				rts
.b25e						JMIsLeft:
.b25e		4c 9a 95	jmp $959a			jmp 	ReturnTrue
.b261						JMIsRight:
.b261		a9 01		lda #$01			lda 	#1
.b263		20 92 a4	jsr $a492			jsr 	NSMSetByte
.b266		60		rts				rts
.b267						UnaryJoyB:
.b267		fa		plx				plx 								; get pos
.b268		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; ignore the parameter
.b26b		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.b26e		20 29 85	jsr $8529			jsr 	KNLReadController 			; read the controller.
.b271		29 10		and #$10			and 	#$10
.b273		d0 e9		bne $b25e			bne 	JMIsLeft
.b275		20 90 a4	jsr $a490			jsr 	NSMSetZero
.b278		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/memcopy.asm

.b279						MCCommand:
.b279		a5 01		lda $01				lda 	1 							; save current I/O ; switch to I/O 0
.b27b		48		pha				pha
.b27c		64 01		stz $01				stz 	1
.b27e		9c 00 df	stz $df00			stz 	$DF00 						; zero control byte.
.b281		a9 81		lda #$81			lda 	#$81 						; standard start byte (DMA Enabled, Start set)
.b283		8d e3 07	sta $07e3			sta 	DMAControlByte
.b286		20 34 b3	jsr $b334			jsr 	MCPosition 					; start position
.b289		a2 04		ldx #$04			ldx 	#4 							; write to source AND $DF04 destination address $DF08
.b28b		20 05 b3	jsr $b305			jsr 	MCCopyAddress
.b28e		a2 08		ldx #$08			ldx 	#8
.b290		20 05 b3	jsr $b305			jsr 	MCCopyAddress
.b293		b1 30		lda ($30),y			lda 	(codePtr),y
.b295		c8		iny				iny
.b296		c9 2c		cmp #$2c			cmp 	#KWD_COMMA 					; , <size>
.b298		f0 09		beq $b2a3			beq 	_MCSize1D
.b29a		c9 d8		cmp #$d8			cmp 	#KWD_RECT 					; RECT <x>,<y>
.b29c		f0 11		beq $b2af			beq 	_MCRect2D
.b29e						_MCSyntax:
.b29e		a9 02		lda #$02		lda	#2
.b2a0		4c 27 95	jmp $9527		jmp	ErrorHandler
.b2a3						_MCSize1D:
.b2a3		a2 00		ldx #$00			ldx 	#0 							; get size
.b2a5		20 fd a3	jsr $a3fd			jsr 	EvaluateInteger
.b2a8		a2 0c		ldx #$0c			ldx 	#$C 						; copy to size $DF0C-E
.b2aa		20 05 b3	jsr $b305			jsr 	MCCopyAddress
.b2ad		80 24		bra $b2d3			bra 	_MCDestination
.b2af						_MCRect2D:
.b2af		a2 0c		ldx #$0c			ldx 	#$C 						; width to $DF0C,D
.b2b1		20 22 b3	jsr $b322			jsr 	MCEvalCopyData16
.b2b4		20 16 95	jsr $9516			jsr 	CheckComma
.b2b7		a2 0e		ldx #$0e			ldx 	#$E 						; height to $DF0E,F
.b2b9		20 22 b3	jsr $b322			jsr 	MCEvalCopyData16
.b2bc		a9 bc		lda #$bc			lda 	#KWD_BY 					; BY keyword.
.b2be		20 1e 95	jsr $951e			jsr 	CheckNextA
.b2c1		a2 10		ldx #$10			ldx 	#$10 						; store source and destination stride
.b2c3		20 22 b3	jsr $b322			jsr 	MCEvalCopyData16
.b2c6		a2 12		ldx #$12			ldx 	#$12
.b2c8		20 29 b3	jsr $b329			jsr 	MCCopyData16
.b2cb		ad e3 07	lda $07e3			lda 	DMAControlByte 				; set bit 4 of DMA control indicating 2D.
.b2ce		09 02		ora #$02			ora 	#$02
.b2d0		8d e3 07	sta $07e3			sta 	DMAControlByte
.b2d3						_MCDestination:
.b2d3		b1 30		lda ($30),y			lda 	(codePtr),y
.b2d5		c8		iny				iny
.b2d6		c9 d3		cmp #$d3			cmp 	#KWD_POKE 					; is it POKE n
.b2d8		f0 0e		beq $b2e8			beq 	_MCDestPoke
.b2da		c9 de		cmp #$de			cmp 	#KWD_TO 					; is it TO n
.b2dc		d0 c0		bne $b29e			bne 	_MCSyntax
.b2de		20 34 b3	jsr $b334			jsr 	MCPosition 					; get target address
.b2e1		a2 08		ldx #$08			ldx 	#8							; copy to target address at $DF08-A
.b2e3		20 05 b3	jsr $b305			jsr 	MCCopyAddress
.b2e6		80 0e		bra $b2f6			bra 	_MCDoDMA 					; and we can go.
.b2e8						_MCDestPoke:
.b2e8		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; POKE what
.b2eb		8d 01 df	sta $df01			sta 	$DF01 						; set the FILL register
.b2ee		ad e3 07	lda $07e3			lda 	DMAControlByte 				; set bit 2 of control byte indicating FILL.
.b2f1		09 04		ora #$04			ora 	#$04
.b2f3		8d e3 07	sta $07e3			sta 	DMAControlByte
.b2f6						_MCDoDMA:
.b2f6		ad e3 07	lda $07e3			lda 	DMAControlByte 				; set the DMA Control byte to go !
.b2f9		8d 00 df	sta $df00			sta 	$DF00
.b2fc						_MCWaitBUSD:
.b2fc		ad 01 df	lda $df01			lda 	$DF01
.b2ff		30 fb		bmi $b2fc			bmi 	_MCWaitBUSD
.b301		68		pla				pla 								; restore I/O.
.b302		85 01		sta $01				sta 	1
.b304		60		rts				rts
.b305						MCCopyAddress:
.b305		a5 80		lda $80				lda 	NSMantissa2 				; check valid vlaue
.b307		29 f8		and #$f8			and 	#$F8
.b309		05 90		ora $90				ora 	NSMantissa3
.b30b		d0 10		bne $b31d			bne 	_MCRange
.b30d		a5 60		lda $60				lda 	NSMantissa0
.b30f		9d 00 df	sta $df00,x			sta 	$DF00,x
.b312		a5 70		lda $70				lda 	NSMantissa1
.b314		9d 01 df	sta $df01,x			sta 	$DF01,x
.b317		a5 80		lda $80				lda 	NSMantissa2
.b319		9d 02 df	sta $df02,x			sta 	$DF02,x
.b31c		60		rts				rts
.b31d						_MCRange:
.b31d		a9 04		lda #$04		lda	#4
.b31f		4c 27 95	jmp $9527		jmp	ErrorHandler
.b322						MCEvalCopyData16:
.b322		da		phx				phx
.b323		a2 00		ldx #$00			ldx 	#0
.b325		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger
.b328		fa		plx				plx
.b329						MCCopyData16:
.b329		a5 60		lda $60				lda 	NSMantissa0
.b32b		9d 00 df	sta $df00,x			sta 	$DF00,x
.b32e		a5 70		lda $70				lda 	NSMantissa1
.b330		9d 01 df	sta $df01,x			sta 	$DF01,x
.b333		60		rts				rts
.b334						MCPosition:
.b334		a2 00		ldx #$00			ldx 	#0 							; get start address.
.b336		b1 30		lda ($30),y			lda 	(codePtr),y
.b338		c9 bb		cmp #$bb			cmp 	#KWD_AT
.b33a		f0 04		beq $b340			beq 	_MCPAt
.b33c		20 fd a3	jsr $a3fd			jsr 	EvaluateInteger
.b33f		60		rts				rts
.b340						_MCPAt:
.b340		c8		iny				iny
.b341		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; X position
.b344		48		pha				pha
.b345		20 16 95	jsr $9516			jsr 	CheckComma
.b348		e8		inx				inx
.b349		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; Y position
.b34c		ca		dex				dex
.b34d		85 70		sta $70				sta 	NSMantissa1 				; put Y x 64 in Mantissa.0
.b34f		64 60		stz $60				stz 	NSMantissa0
.b351		64 80		stz $80				stz 	NSMantissa2
.b353		64 90		stz $90				stz 	NSMantissa3
.b355		46 70		lsr $70				lsr 	NSMantissa1
.b357		66 60		ror $60				ror 	NSMantissa0
.b359		46 70		lsr $70				lsr 	NSMantissa1
.b35b		66 60		ror $60				ror 	NSMantissa0
.b35d		68		pla				pla
.b35e		18		clc				clc
.b35f		65 60		adc $60				adc 	NSMantissa0 				; add X, Y * 256 and the
.b361		85 60		sta $60				sta 	NSMantissa0
.b363		a5 70		lda $70				lda 	NSMantissa1
.b365		65 61		adc $61				adc 	NSMantissa0+1
.b367		85 70		sta $70				sta 	NSMantissa1
.b369		90 02		bcc $b36d			bcc 	_MCPNoCarry
.b36b		e6 80		inc $80				inc 	NSMantissa2
.b36d						_MCPNoCarry:
.b36d		ad 03 09	lda $0903			lda 	gxBasePage
.b370		85 81		sta $81				sta 	NSMantissa2+1
.b372		64 61		stz $61				stz 	NSMantissa0+1
.b374		64 71		stz $71				stz 	NSMantissa1+1
.b376		64 91		stz $91				stz 	NSMantissa3+1
.b378		a2 01		ldx #$01			ldx 	#1
.b37a		20 a9 a4	jsr $a4a9			jsr 	NSMShiftRight
.b37d		20 a9 a4	jsr $a4a9			jsr 	NSMShiftRight
.b380		20 a9 a4	jsr $a4a9			jsr 	NSMShiftRight
.b383		a2 00		ldx #$00			ldx 	#0
.b385		20 27 98	jsr $9827			jsr 	AddTopTwoStack
.b388		60		rts				rts
.07e3						DMAControlByte:
>07e3								.fill 	1

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/mouse.asm

.b389						MouseStatus:
.b389		a9 ff		lda #$ff	        lda     #255
.b38b		80 02		bra $b38f	        bra     MouseCommand
.b38d						MouseDeltaStatus:
.b38d		a9 00		lda #$00	        lda     #0
.b38f						MouseCommand:
.b38f		8d 82 06	sta $0682	        sta     CMDMouseFlag
.b392		a2 00		ldx #$00	        ldx     #0
.b394						_MouseCommandLoop:
.b394		da		phx		        phx                                 ; save slot.
.b395		20 2f 9a	jsr $9a2f	        jsr     EvaluateExpressionAt0       ; evaluate a reference.
.b398		a5 50		lda $50		        lda     NSStatus                    ; check it's a reference.
.b39a		c9 20		cmp #$20	        cmp     #NSBIsReference
.b39c		d0 60		bne $b3fe	        bne     _MouseNotRef
.b39e		b1 30		lda ($30),y			lda 	(codePtr),y
.b3a0		c9 2c		cmp #$2c	        cmp     #KWD_COMMA
.b3a2		d0 01		bne $b3a5	        bne     _MouseNoSkipComma
.b3a4		c8		iny		        iny
.b3a5						_MouseNoSkipComma:
.b3a5		fa		plx		        plx                                 ; restore X
.b3a6		5a		phy		        phy                                 ; save Y
.b3a7		a5 60		lda $60		        lda     NSMantissa0                 ; copy address to zTemp0
.b3a9		85 36		sta $36		        sta     zTemp0
.b3ab		a5 70		lda $70		        lda     NSMantissa1
.b3ad		85 37		sta $37		        sta     zTemp0+1
.b3af		a0 04		ldy #$04	        ldy     #4                          ; set exponent, m3, m2 , m1 , m0
.b3b1		a9 00		lda #$00	        lda     #0
.b3b3		91 36		sta ($36),y	        sta     (zTemp0),y                  ; exponent
.b3b5		88		dey		        dey
.b3b6		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m3
.b3b8		88		dey		        dey
.b3b9		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m2
.b3bb		88		dey		        dey
.b3bc		2c 82 06	bit $0682	        bit     CMDMouseFlag                ; mouse or mdelta command
.b3bf		30 12		bmi $b3d3	        bmi     _MouseMouseCommand
.b3c1						_MouseMDeltaCommand:
.b3c1		bd a5 06	lda $06a5,x	        lda     MouseDeltaX,x
.b3c4		92 36		sta ($36)	        sta     (zTemp0)                    ; m0
.b3c6		bd a6 06	lda $06a6,x	        lda     MouseDeltaX+1,x
.b3c9		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m1
.b3cb		9e a5 06	stz $06a5,x	        stz     MouseDeltaX,x               ; clear entry in current table
.b3ce		9e a6 06	stz $06a6,x	        stz     MouseDeltaX+1,x
.b3d1		80 0a		bra $b3dd	        bra     _MouseProcessData
.b3d3						_MouseMouseCommand:
.b3d3		bd b1 06	lda $06b1,x	        lda     MousePosX,x
.b3d6		92 36		sta ($36)	        sta     (zTemp0)                    ; m0
.b3d8		bd b2 06	lda $06b2,x	        lda     MousePosX+1,x
.b3db		91 36		sta ($36),y	        sta     (zTemp0),y                  ; m1
.b3dd						_MouseProcessData:
.b3dd		b1 36		lda ($36),y	        lda     (zTemp0),y
.b3df		10 15		bpl $b3f6	        bpl     _MouseDataPos               ; signed 16 bit value, so fix up if -ve.
.b3e1		38		sec		        sec                                 ; negate the mantissa 2 bytes
.b3e2		a9 00		lda #$00	        lda     #0
.b3e4		f2 36		sbc ($36)	        sbc     (zTemp0)
.b3e6		92 36		sta ($36)	        sta     (zTemp0)
.b3e8		a9 00		lda #$00	        lda     #0
.b3ea		f1 36		sbc ($36),y	        sbc     (zTemp0),y
.b3ec		91 36		sta ($36),y	        sta     (zTemp0),y
.b3ee		a0 03		ldy #$03	        ldy     #3
.b3f0		b1 36		lda ($36),y	        lda     (zTemp0),y                  ; set upper bit of mantissa
.b3f2		09 80		ora #$80	        ora     #$80
.b3f4		91 36		sta ($36),y	        sta     (zTemp0),y
.b3f6						_MouseDataPos:
.b3f6		7a		ply		        ply                                 ; restore Y.
.b3f7		e8		inx		        inx                                 ; next entry
.b3f8		e8		inx		        inx
.b3f9		e0 0c		cpx #$0c	        cpx     #6*2                        ; done 6 reads to variables.
.b3fb		d0 97		bne $b394	        bne     _MouseCommandLoop
.b3fd		60		rts		        rts
.b3fe						_MouseNotRef:
.b3fe		a9 07		lda #$07		lda	#7
.b400		4c 27 95	jmp $9527		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/setdatetime.asm

.b403						CommandSetDate:
.b403		a9 03		lda #$03			lda 	#3
.b405		80 02		bra $b409			bra 	CSDTMain
.b407						CommandSetTime:
.b407		a9 00		lda #$00			lda 	#0
.b409						CSDTMain:
.b409		48		pha				pha 								; save table offsets 0 or 3
.b40a		a2 00		ldx #$00			ldx 	#0 							; input 3 values.
.b40c		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.b40f		20 16 95	jsr $9516			jsr 	CheckComma
.b412		e8		inx				inx
.b413		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.b416		20 16 95	jsr $9516			jsr 	CheckComma
.b419		e8		inx				inx
.b41a		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger
.b41d		68		pla				pla 								; table offset in Y, saving Y
.b41e		5a		phy				phy
.b41f		a8		tay				tay
.b420		a2 00		ldx #$00			ldx 	#0 							; first number
.b422		a5 01		lda $01				lda 	1 							; save I/O page, switch to zero
.b424		48		pha				pha
.b425		64 01		stz $01				stz 	1
.b427						_CSDTCopy:
.b427		b5 60		lda $60,x			lda 	NSMantissa0,x 				; get first number
.b429		d9 6b b4	cmp $b46b,y			cmp 	RTCWMinValues,y 			; check range
.b42c		90 1b		bcc $b449			bcc 	_CSDTRange
.b42e		d9 71 b4	cmp $b471,y			cmp 	RTCWMaxValues,y
.b431		b0 16		bcs $b449			bcs 	_CSDTRange
.b433		20 4e b4	jsr $b44e			jsr 	CSDTDecimalToBCD
.b436		da		phx				phx 								; save X
.b437		be 65 b4	ldx $b465,y			ldx 	RTCWOffset,y 				; offset in RTC in X
.b43a		9d 90 d6	sta $d690,x			sta 	$D690,x 					; write to RTC
.b43d		fa		plx				plx 								; restore X
.b43e		e8		inx				inx 								; next number
.b43f		c8		iny				iny 								; next table entries
.b440		e0 03		cpx #$03			cpx 	#3 							; until done all 3.
.b442		d0 e3		bne $b427			bne 	_CSDTCopy
.b444		68		pla				pla 								; restore I/O space
.b445		85 01		sta $01				sta 	1
.b447		7a		ply				ply 								; restore code pos and exit.
.b448		60		rts				rts
.b449						_CSDTRange:
.b449		a9 04		lda #$04		lda	#4
.b44b		4c 27 95	jmp $9527		jmp	ErrorHandler
.b44e						CSDTDecimalToBCD:
.b44e		da		phx				phx 								; 10 count in X
.b44f		a2 00		ldx #$00			ldx 	#0
.b451						_CSDTDBLoop:
.b451		c9 0a		cmp #$0a			cmp 	#10 						; < 10 evaluate result.
.b453		90 05		bcc $b45a			bcc 	_CSDTDBExit
.b455		e9 0a		sbc #$0a			sbc 	#10 						; 10 from value
.b457		e8		inx				inx 								; one more 10s.
.b458		80 f7		bra $b451			bra 	_CSDTDBLoop
.b45a						_CSDTDBExit:
.b45a		85 36		sta $36				sta 	zTemp0 						; units
.b45c		8a		txa				txa 								; 10s x 16
.b45d		0a		asl a				asl 	a
.b45e		0a		asl a				asl 	a
.b45f		0a		asl a				asl 	a
.b460		0a		asl a				asl 	a
.b461		05 36		ora $36				ora 	zTemp0 						; BCD result and exit
.b463		fa		plx				plx
.b464		60		rts				rts
.b465						RTCWOffset:
>b465		04 02 00 06 09 0a				.byte 	4,2,0,6,9,10
.b46b						RTCWMinValues:
>b46b		00 00 00 01 01 00				.byte 	0,0,0,1,1,0
.b471						RTCWMaxValues:
>b471		18 3c 3c 20 0d 64				.byte 	24,60,60,32,13,100

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/commands/timer.asm

.b477						UnaryTimer:
.b477		fa		plx				plx
.b478		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.b47b						TimerToStackX:
.b47b		20 90 a4	jsr $a490			jsr 	NSMSetZero 					; zero result
.b47e		64 01		stz $01				stz 	1 							; access I/O
.b480		ad 59 d6	lda $d659			lda 	$D659 						; copy timer in
.b483		95 60		sta $60,x			sta 	NSMantissa0,x
.b485		ad 5a d6	lda $d65a			lda 	$D65A
.b488		95 70		sta $70,x			sta 	NSMantissa1,x
.b48a		ad 5b d6	lda $d65b			lda 	$D65B
.b48d		95 80		sta $80,x			sta 	NSMantissa2,x
.b48f		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/getdatetime.asm

.b490						UnaryGetTime:
.b490		a9 00		lda #$00			lda 	#0
.b492		80 02		bra $b496			bra 	UGDTMain
.b494						UnaryGetDate:
.b494		a9 03		lda #$03			lda 	#3
.b496						UGDTMain:
.b496		fa		plx				plx 								; get stack position back
.b497		48		pha				pha 								; save table offset
.b498		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger			; ignored parameter
.b49b		20 0e 95	jsr $950e			jsr 	CheckRightBracket 			; closing )
.b49e		68		pla				pla 								; table offset in A
.b49f		5a		phy				phy 								; saving Y
.b4a0		a8		tay				tay 								; table offset in Y
.b4a1		a9 08		lda #$08			lda 	#8							; allocate space for 8 chars DD:MM:YY
.b4a3		20 c7 b7	jsr $b7c7			jsr 	StringTempAllocate
.b4a6		a5 01		lda $01				lda 	1 							; save I/O table and switch to I/O page 0
.b4a8		48		pha				pha
.b4a9		64 01		stz $01				stz 	1
.b4ab		20 be b4	jsr $b4be			jsr 	UGDTDigit 					; do XX:YY:ZZ
.b4ae		20 b9 b4	jsr $b4b9			jsr 	UGDTColonDigit
.b4b1		20 b9 b4	jsr $b4b9			jsr 	UGDTColonDigit
.b4b4		68		pla				pla 								; restore I/O select
.b4b5		85 01		sta $01				sta 	1
.b4b7		7a		ply				ply  								; restore code position
.b4b8		60		rts				rts
.b4b9						UGDTColonDigit:
.b4b9		a9 3a		lda #$3a			lda 	#':'
.b4bb		20 00 b8	jsr $b800			jsr 	StringTempWrite
.b4be						UGDTDigit:
.b4be		da		phx				phx 								; save X
.b4bf		b9 de b4	lda $b4de,y			lda 	RTCROffset,y 				; get offset in RTC register
.b4c2		aa		tax				tax
.b4c3		bd 90 d6	lda $d690,x			lda 	$D690,x 					; read RTC register
.b4c6		39 e4 b4	and $b4e4,y			and 	RTCRMask,y 					; and with Mask.
.b4c9		fa		plx				plx
.b4ca		48		pha				pha 								; output in BCD
.b4cb		4a		lsr a				lsr 	a
.b4cc		4a		lsr a				lsr 	a
.b4cd		4a		lsr a				lsr 	a
.b4ce		4a		lsr a				lsr 	a
.b4cf		09 30		ora #$30			ora 	#48
.b4d1		20 00 b8	jsr $b800			jsr 	StringTempWrite
.b4d4		68		pla				pla
.b4d5		29 0f		and #$0f			and 	#15
.b4d7		09 30		ora #$30			ora 	#48
.b4d9		20 00 b8	jsr $b800			jsr 	StringTempWrite
.b4dc		c8		iny				iny
.b4dd		60		rts				rts
.b4de						RTCROffset:
>b4de		04 02 00 06 09 0a				.byte 	4,2,0,6,9,10
.b4e4						RTCRMask:
>b4e4		3f 7f 7f 3f 1f 7f				.byte 	$3F,$7F,$7F,$3F,$1F,$7F

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/getinkey.asm

.b4ea						AscGet:
.b4ea		fa		plx				plx 								; restore stack pos
.b4eb						AscGet2:
.b4eb		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.b4ee		20 ff 81	jsr $81ff			jsr 	KNLGetSingleCharacter
.b4f1		20 92 a4	jsr $a492			jsr 	NSMSetByte
.b4f4		60		rts				rts
.b4f5						_AGBreak:
.b4f5		a9 01		lda #$01		lda	#1
.b4f7		4c 27 95	jmp $9527		jmp	ErrorHandler
.b4fa						AscInkey:
.b4fa		fa		plx				plx 								; restore stack pos
.b4fb						AscInkey2:
.b4fb		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.b4fe		20 dd 81	jsr $81dd			jsr 	KNLGetKeyPressed
.b501		20 92 a4	jsr $a492			jsr 	NSMSetByte
.b504		60		rts				rts
.b505						ChrGet:
.b505		fa		plx				plx
.b506		20 eb b4	jsr $b4eb			jsr 	AscGet2
.b509		4c 10 b5	jmp $b510			jmp 	ChrToString
.b50c						ChrInkey:
.b50c		fa		plx				plx
.b50d		20 fb b4	jsr $b4fb			jsr 	AscInkey2
.b510						ChrToString:
.b510		c9 00		cmp #$00			cmp 	#0 							; if zero, return ""
.b512		f0 0b		beq $b51f			beq 	_GKISNull
.b514		48		pha				pha
.b515		a9 01		lda #$01			lda 	#1 							; allocate space for one char
.b517		20 c7 b7	jsr $b7c7			jsr 	StringTempAllocate
.b51a		68		pla				pla 								; write number to it
.b51b		20 00 b8	jsr $b800			jsr 	StringTempWrite
.b51e		60		rts				rts
.b51f						_GKISNull:
.b51f		a9 00		lda #$00			lda 	#0
.b521		20 c7 b7	jsr $b7c7			jsr 	StringTempAllocate
.b524		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/keydown.asm

.b525						KeyDown:
.b525		20 62 81	jsr $8162			jsr 	ProcessEvents 				; process outstanding events.
.b528		fa		plx				plx 								; restore stack pos
.b529		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; key to check.
.b52c		48		pha				pha 								; check right bracket.
.b52d		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.b530		68		pla				pla
.b531		20 37 84	jsr $8437			jsr 	KeyboardConvertXA 			; get offset and mask.
.b534		3d 83 06	and $0683,x			and 	KeyStatus,x 				; is it zero ?
.b537		f0 03		beq $b53c			beq 	_KeyUp
.b539		4c 9a 95	jmp $959a			jmp 	ReturnTrue
.b53c		4c a5 95	jmp $95a5	_KeyUp:	jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/rnd.asm

.b53f						Unary_Random:
.b53f		fa		plx				plx
.b540		20 90 b5	jsr $b590			jsr 	URCopyToMantissa  			; put random # in mantissa
.b543		b1 30		lda ($30),y			lda 	(codePtr),y
.b545		c9 29		cmp #$29			cmp 	#KWD_RPAREN
.b547		f0 08		beq $b551			beq 	_URNoModulus 				; then we return a random 30 bit number.
.b549		e8		inx				inx
.b54a		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger 		; put modulus value in +1
.b54d		ca		dex				dex
.b54e		20 ec 96	jsr $96ec			jsr 	IntegerModulusNoCheck 		; calculate modulus, so now 0 .. n-1
.b551						_URNoModulus:
.b551		74 50		stz $50,x			stz 	NSStatus,x 					; make it an integer positive
.b553		74 a0		stz $a0,x			stz 	NSExponent,x
.b555		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.b558		60		rts				rts
.b559						Unary_Rnd:
.b559		fa		plx				plx
.b55a		20 de a3	jsr $a3de			jsr 	EvaluateNumber 				; number to use.
.b55d		20 0e 95	jsr $950e			jsr 	CheckRightBracket 			; closing bracket
.b560		b5 50		lda $50,x			lda 	NSStatus,x 					; if -ve, then seed using parameter
.b562		10 20		bpl $b584			bpl 	_URDontSeed
.b564		a5 01		lda $01				lda 	1 							; switch to page 0
.b566		48		pha				pha
.b567		64 01		stz $01				stz 	1
.b569		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy - value to seed butchering it.
.b56b		49 17		eor #$17			eor 	#$17
.b56d		8d a4 d6	sta $d6a4			sta 	$D6A4
.b570		b5 70		lda $70,x			lda 	NSMantissa1,x
.b572		49 a5		eor #$a5			eor 	#$A5
.b574		8d a5 d6	sta $d6a5			sta 	$D6A5
.b577		a9 03		lda #$03			lda 	#3 							; set bit 1 high/low to set seed.
.b579		8d a6 d6	sta $d6a6			sta 	$D6A6
.b57c		a9 01		lda #$01			lda 	#1
.b57e		8d a6 d6	sta $d6a6			sta 	$D6A6
.b581		68		pla				pla
.b582		85 01		sta $01				sta 	1
.b584						_URDontSeed:
.b584		20 90 b5	jsr $b590			jsr 	URCopyToMantissa 			; copy into mantissa
.b587		a9 e2		lda #$e2			lda 	#-30 						; force into 0-1 range
.b589		95 a0		sta $a0,x			sta 	NSExponent,x
.b58b		a9 08		lda #$08			lda 	#NSTFloat
.b58d		95 50		sta $50,x			sta 	NSStatus,x 					; positive float
.b58f		60		rts				rts
.b590						URCopyToMantissa:
.b590		a5 01		lda $01				lda 	1 							; switch to I/O page 1
.b592		48		pha				pha
.b593		64 01		stz $01				stz 	1
.b595		a9 01		lda #$01			lda 	#1
.b597		8d a6 d6	sta $d6a6			sta 	$D6A6 						; enable LFSR
.b59a		ad a4 d6	lda $d6a4			lda 	$D6A4
.b59d		95 60		sta $60,x			sta 	NSMantissa0,x
.b59f		ad a5 d6	lda $d6a5			lda 	$D6A5
.b5a2		95 70		sta $70,x			sta 	NSMantissa1,x
.b5a4		ad a4 d6	lda $d6a4			lda 	$D6A4
.b5a7		95 80		sta $80,x			sta 	NSMantissa2,x
.b5a9		ad a5 d6	lda $d6a5			lda 	$D6A5
.b5ac		29 3f		and #$3f			and 	#$3F 						; make legal mantissa
.b5ae		95 90		sta $90,x			sta 	NSMantissa3,x
.b5b0		68		pla				pla
.b5b1		85 01		sta $01				sta 	1
.b5b3		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/kernel/functions/screen.asm

.b5b4						ScreenAt:
.b5b4		fa		plx				plx 								; restore stack pos
.b5b5						ScreenAtImpl:
.b5b5		20 2b a4	jsr $a42b			jsr		Evaluate8BitInteger         ; parse row into `A`
.b5b8		cd ee 07	cmp $07ee			cmp		EXTScreenHeight				; check if row is within valid range
.b5bb		b0 1d		bcs $b5da			bcs		_range_error
.b5bd		48		pha				pha									; save it on the stack
.b5be		20 16 95	jsr $9516			jsr		CheckComma					; ensure the next character is a comma
.b5c1		20 2b a4	jsr $a42b			jsr		Evaluate8BitInteger			; parse column into `A`
.b5c4		cd ed 07	cmp $07ed			cmp		EXTScreenWidth				; check if column is within valid range
.b5c7		b0 11		bcs $b5da			bcs		_range_error
.b5c9		85 36		sta $36				sta     zTemp0						; save column to `zTemp0`
.b5cb		20 0e 95	jsr $950e			jsr 	CheckRightBracket
.b5ce		68		pla				pla									; restore row into `A`
.b5cf		5a		phy				phy									; save `Y`
.b5d0		a4 36		ldy $36				ldy     zTemp0						; restore column into `Y`
.b5d2		20 61 80	jsr $8061			jsr 	EXTScreenAt					; get screen character at (row, column)
.b5d5		7a		ply				ply									; restore `Y`
.b5d6		20 92 a4	jsr $a492			jsr 	NSMSetByte					; set return type to byte
.b5d9		60		rts				rts
.b5da						_range_error:
.b5da		4c 0d a6	jmp $a60d			jmp 	RangeError 					; branch to range error handler
.b5dd						ScreenAtStr:
.b5dd		fa		plx				plx 								; restore stack pos
.b5de		20 b5 b5	jsr $b5b5			jsr 	ScreenAtImpl
.b5e1		4c 10 b5	jmp $b510			jmp 	ChrToString					; convert character in `A` to string

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/effects.asm

.b5e4						PingCommand:
.b5e4		5a		phy				phy 								; save pos
.b5e5		a9 01		lda #$01			lda 	#1 						; push channel.
.b5e7		48		pha				pha
.b5e8		a9 c8		lda #$c8			lda 	#200 						; pitch LSB
.b5ea		a2 06		ldx #$06			ldx 	#6 						; length
.b5ec		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b5ee		80 24		bra $b614			bra 	SoundEffectCommand
.b5f0						ZapCommand:
.b5f0		5a		phy				phy 								; save pos
.b5f1		a9 01		lda #$01			lda 	#1 						; push channel.
.b5f3		48		pha				pha
.b5f4		a9 ff		lda #$ff			lda 	#255 						; pitch LSB
.b5f6		a2 0a		ldx #$0a			ldx 	#10 						; length
.b5f8		a0 0a		ldy #$0a			ldy 	#10 						; slide LSB
.b5fa		80 18		bra $b614			bra 	SoundEffectCommand
.b5fc						ShootCommand:
.b5fc		5a		phy				phy 								; save pos
.b5fd		a9 03		lda #$03			lda 	#3 						; push channel.
.b5ff		48		pha				pha
.b600		a9 20		lda #$20			lda 	#32 						; pitch LSB
.b602		a2 04		ldx #$04			ldx 	#4 						; length
.b604		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b606		80 0c		bra $b614			bra 	SoundEffectCommand
.b608						Explode:
.b608		5a		phy				phy 								; save pos
.b609		a9 03		lda #$03			lda 	#3 						; push channel.
.b60b		48		pha				pha
.b60c		a9 50		lda #$50			lda 	#80 						; pitch LSB
.b60e		a2 0a		ldx #$0a			ldx 	#10 						; length
.b610		a0 00		ldy #$00			ldy 	#0 						; slide LSB
.b612		80 00		bra $b614			bra 	SoundEffectCommand
.b614						SoundEffectCommand:
.b614		8d e4 07	sta $07e4			sta 	SoundCommandBlock 			; set up the command block in sound.asm
.b617		9c e5 07	stz $07e5			stz 	SoundCommandBlock+1
.b61a		a9 0f		lda #$0f			lda 	#15
.b61c		8d e6 07	sta $07e6			sta 	SoundCommandBlock+2
.b61f		8e e7 07	stx $07e7			stx 	SoundCommandBlock+3
.b622		8c e8 07	sty $07e8			sty 	SoundCommandBlock+4
.b625		9c e9 07	stz $07e9			stz 	SoundCommandBlock+5
.b628		68		pla				pla
.b629		09 10		ora #$10			ora 	#$10  						; execute command $11
.b62b		a2 e4		ldx #$e4			ldx 	#(SoundCommandBlock & $FF)
.b62d		a0 07		ldy #$07			ldy 	#(SoundCommandBlock >> 8)
.b62f		20 75 80	jsr $8075			jsr 	SNDCommand
.b632		7a		ply				ply
.b633		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/playing.asm

.b634						UnaryPlaying:
.b634		fa		plx				plx
.b635		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; get channel #
.b638		48		pha				pha
.b639		20 0e 95	jsr $950e			jsr		CheckRightBracket
.b63c		68		pla				pla
.b63d		c9 04		cmp #$04			cmp 	#4
.b63f		b0 0c		bcs $b64d			bcs 	_UPNotPlaying
.b641		09 20		ora #$20			ora 	#$20 						; query playing ?
.b643		20 75 80	jsr $8075			jsr 	SNDCommand
.b646		c9 00		cmp #$00			cmp 	#0
.b648		f0 03		beq $b64d			beq 	_UPNotPlaying
.b64a		4c 9a 95	jmp $959a			jmp 	ReturnTrue
.b64d						_UPNotPlaying:
.b64d		4c a5 95	jmp $95a5			jmp 	ReturnFalse

;******  Return to file: _basic.asm


;******  Processing file: ./system.f256/module.interfaces/sound/sound.asm

.b650						SoundCommand:
.b650		b1 30		lda ($30),y			lda 	(codePtr),y
.b652		c9 ce		cmp #$ce			cmp 	#KWD_OFF 					; SOUND OFF ?
.b654		d0 09		bne $b65f			bne 	_SNDMain
.b656		c8		iny				iny 								; skip OFF
.b657		a9 3f		lda #$3f			lda 	#$3F 						; call command $3F (silence)
.b659		5a		phy				phy
.b65a		20 75 80	jsr $8075			jsr 	SNDCommand
.b65d		7a		ply				ply
.b65e		60		rts				rts
.b65f						_SNDMain:
.b65f		a2 00		ldx #$00			ldx 	#0
.b661		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; channel
.b664		c9 04		cmp #$04			cmp 	#4 							; must be 0-3
.b666		b0 4b		bcs $b6b3			bcs 	_SndError
.b668		e8		inx				inx 								; do the rest in slot 1.
.b669		20 16 95	jsr $9516			jsr 	CheckComma
.b66c		20 10 a4	jsr $a410			jsr 	Evaluate16BitInteger 		; Pitch
.b66f		b5 70		lda $70,x			lda 	NSMantissa1,x 				; must be 10 bit
.b671		c9 10		cmp #$10			cmp 	#16
.b673		b0 3e		bcs $b6b3			bcs 	_SndError
.b675		8d e5 07	sta $07e5			sta 	SoundCommandBlock+1 		; Pitch (2 bytes + 0)
.b678		b5 60		lda $60,x			lda 	NSMantissa0,x
.b67a		8d e4 07	sta $07e4			sta 	SoundCommandBlock
.b67d		20 16 95	jsr $9516			jsr 	CheckComma
.b680		20 2b a4	jsr $a42b			jsr 	Evaluate8BitInteger 		; Length (1 byte + 3)
.b683		8d e7 07	sta $07e7			sta 	SoundCommandBlock+3
.b686		a9 0f		lda #$0f			lda 	#15
.b688		8d e6 07	sta $07e6			sta 	SoundCommandBlock+2 		; Volume (1 byte + 2)
.b68b		9c e8 07	stz $07e8			stz 	SoundCommandBlock+4 		; default slide (2 bytes +4)
.b68e		9c e9 07	stz $07e9			stz 	SoundCommandBlock+5
.b691		b1 30		lda ($30),y			lda 	(codePtr),y
.b693		c9 2c		cmp #$2c			cmp 	#KWD_COMMA
.b695		d0 0e		bne $b6a5			bne 	_SNDPlay
.b697		c8		iny				iny
.b698		20 1a a4	jsr $a41a			jsr 	Evaluate16BitIntegerSigned 	; Slide
.b69b		b5 60		lda $60,x			lda 	NSMantissa0,x 				; Slide (2 bytes + 4)
.b69d		8d e8 07	sta $07e8			sta 	SoundCommandBlock+4
.b6a0		b5 70		lda $70,x			lda 	NSMantissa1,x
.b6a2		8d e9 07	sta $07e9			sta 	SoundCommandBlock+5
.b6a5						_SNDPlay:
.b6a5		5a		phy				phy
.b6a6		a5 60		lda $60				lda 	NSMantissa0 				; channel.
.b6a8		09 10		ora #$10			ora 	#$10 						; 1x = Queue sound
.b6aa		a2 e4		ldx #$e4			ldx 	#(SoundCommandBlock & $FF)
.b6ac		a0 07		ldy #$07			ldy 	#(SoundCommandBlock >> 8)
.b6ae		20 75 80	jsr $8075			jsr 	SNDCommand
.b6b1		7a		ply				ply
.b6b2		60		rts				rts
.b6b3						_SndError:
.b6b3		4c 0d a6	jmp $a60d			jmp 	RangeError
.07e4						SoundCommandBlock:
>07e4								.fill 	6

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/bytes.asm

.b6b6						StackPushByte:
.b6b6		48		pha				pha 								; save byte on stack
.b6b7		a5 34		lda $34				lda 	basicStack 					; decrement basic stack pointer
.b6b9		d0 08		bne $b6c3			bne 	_SPBNoBorrow
.b6bb		c6 35		dec $35				dec 	basicStack+1 				; borrow
.b6bd		a5 35		lda $35				lda 	basicStack+1 				; check range.
.b6bf		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.b6c1		90 06		bcc $b6c9			bcc 	_SPBMemory
.b6c3						_SPBNoBorrow:
.b6c3		c6 34		dec $34				dec 	basicStack
.b6c5		68		pla				pla 								; get back and write
.b6c6		92 34		sta ($34)			sta 	(basicStack)
.b6c8		60		rts				rts
.b6c9						_SPBMemory:
.b6c9		a9 12		lda #$12		lda	#18
.b6cb		4c 27 95	jmp $9527		jmp	ErrorHandler
.b6ce						StackPopByte:
.b6ce		b2 34		lda ($34)			lda 	(basicStack) 				; bump the stack pointer.
.b6d0		e6 34		inc $34				inc 	basicStack
.b6d2		d0 02		bne $b6d6			bne 	_SPBNoCarry
.b6d4		e6 35		inc $35				inc 	basicStack+1
.b6d6						_SPBNoCarry:
.b6d6		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/frames.asm

.b6d7						StackOpen:
.b6d7		48		pha				pha 								; save frame byte
.b6d8		29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.b6da		0a		asl a				asl 	a 							; claim twice this for storage
.b6db		49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.b6dd		38		sec				sec 								; so basically subtracting from
.b6de		65 34		adc $34				adc 	basicStack 	 				; basicStack
.b6e0		85 34		sta $34				sta 	basicStack
.b6e2		b0 09		bcs $b6ed			bcs 	_SONoBorrow
>b6e4		db						.byte 	$DB 						; causes a break in the emulator
.b6e5		c6 35		dec $35				dec 	basicStack+1
.b6e7		a5 35		lda $35				lda 	basicStack+1 				; have we reached stack overflow
.b6e9		c9 0e		cmp #$0e			cmp 	#BasicStackBase >> 8
.b6eb		90 04		bcc $b6f1			bcc 	_SOMemory
.b6ed						_SONoBorrow:
.b6ed		68		pla				pla 								; get marker back and write at TOS
.b6ee		92 34		sta ($34)			sta 	(basicStack)
.b6f0		60		rts				rts
.b6f1						_SOMemory:
.b6f1		a9 12		lda #$12		lda	#18
.b6f3		4c 27 95	jmp $9527		jmp	ErrorHandler
.b6f6						StackClose:
.b6f6		b2 34		lda ($34)			lda 	(basicStack) 				; get TOS marker
.b6f8		29 0f		and #$0f			and 	#$0F 						; bytes to add back
.b6fa		0a		asl a				asl 	a 							; claim twice this.
.b6fb		65 34		adc $34				adc 	basicStack 					; add to the stack pointer.
.b6fd		85 34		sta $34				sta 	basicStack
.b6ff		90 02		bcc $b703			bcc 	_SCExit
.b701		e6 35		inc $35				inc 	basicStack+1
.b703						_SCExit:
.b703		60		rts				rts
.b704						StackCheckFrame:
.b704		48		pha				pha
.b705						_StackRemoveLocals:
.b705		b2 34		lda ($34)			lda 	(basicStack) 				; check for local, keep popping them
.b707		c9 03		cmp #$03			cmp 	#STK_LOCALS+1 				; is the frame a local ? S or N are 1/0
.b709		b0 05		bcs $b710			bcs 	_SCNoLocal
.b70b		20 f7 8e	jsr $8ef7			jsr 	LocalPopValue 				; restore the local value
.b70e		80 f5		bra $b705			bra 	_StackRemoveLocals 			; gr round again
.b710						_SCNoLocal:
.b710		68		pla				pla 								; get the frame check.
.b711		52 34		eor ($34)			eor 	(basicStack) 				; xor with toS marker
.b713		29 f0		and #$f0			and 	#$F0 						; check type bits
.b715		d0 01		bne $b718			bne 	_SCFError 					; different, we have structures mixed up
.b717		60		rts				rts
.b718						_SCFError:
.b718		8a		txa				txa 								; report error X
.b719		4c 27 95	jmp $9527			jmp 	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/location.asm

.b71c						STKSaveCodePosition:
.b71c		5a		phy				phy
.b71d		98		tya				tya 								; save Y
.b71e		a0 05		ldy #$05			ldy 	#5
.b720		91 34		sta ($34),y			sta 	(basicStack),y
.b722		88		dey				dey 								; save Code Pointer
.b723						_STKSaveLoop:
.b723		b9 2f 00	lda $002f,y			lda 	safePtr-1,y 				; allows us to access the pointer w/out issues.
.b726		91 34		sta ($34),y			sta 	(basicStack),y
.b728		88		dey				dey
.b729		d0 f8		bne $b723			bne 	_STKSaveLoop
.b72b		7a		ply				ply
.b72c		60		rts				rts
.b72d						STKLoadCodePosition:
.b72d		a0 01		ldy #$01			ldy 	#1 							; load code pointer back
.b72f						_STKLoadLoop:
.b72f		b1 34		lda ($34),y			lda 	(basicStack),y
.b731		99 2f 00	sta $002f,y			sta 	safePtr-1,y
.b734		c8		iny				iny
.b735		c0 05		cpy #$05			cpy 	#5
.b737		d0 f6		bne $b72f			bne 	_STKLoadLoop
.b739		b1 34		lda ($34),y			lda 	(basicStack),y 				; get Y offset
.b73b		a8		tay				tay
.b73c		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/stack/setup.asm

.b73d						StackReset:
.b73d		a9 ff		lda #$ff			lda 	#((BasicStackBase+BasicStackSize-1) & $FF)
.b73f		85 34		sta $34				sta 	0+basicStack
.b741		a9 0f		lda #$0f			lda 	#((BasicStackBase+BasicStackSize-1) >> 8)
.b743		85 35		sta $35				sta 	1+basicStack
.b745		a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.b747		92 34		sta ($34)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.b749		60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/concrete.asm

.b74a						StringConcrete:
.b74a		5a		phy				phy 								; save position on stack
.b74b		20 70 a0	jsr $a070			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.b74e		b5 60		lda $60,x			lda 	NSMantissa0,x 				; copy target string to zTemp1
.b750		85 38		sta $38				sta 	zTemp1
.b752		b5 70		lda $70,x			lda 	NSMantissa1,x
.b754		85 39		sta $39				sta 	zTemp1+1
.b756		a0 ff		ldy #$ff			ldy 	#$FF	 					; calculate string length
.b758						_SALength:
.b758		c8		iny				iny
.b759		b1 38		lda ($38),y			lda 	(zTemp1),y
.b75b		d0 fb		bne $b758			bne 	_SALength
.b75d		c0 fd		cpy #$fd			cpy 	#253 						; string too long - cannot concrete.
.b75f		b0 3d		bcs $b79e			bcs 	_SALengthError
.b761		98		tya				tya 				 				; length of the new string
.b762		18		clc				clc
.b763		69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.b765		90 02		bcc $b769			bcc 	_SAHaveLength
.b767		a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.b769						_SAHaveLength:
.b769		48		pha				pha 								; save length.
.b76a		38		sec				sec
.b76b		49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.b76d		6d 2a 04	adc $042a			adc 	stringMemory
.b770		8d 2a 04	sta $042a			sta 	stringMemory
.b773		85 3a		sta $3a				sta 	zTemp2 						; update storage address
.b775		95 60		sta $60,x			sta 	NSMantissa0,x 				; update mantissa address
.b777		a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.b779		6d 2b 04	adc $042b			adc 	stringMemory+1
.b77c		8d 2b 04	sta $042b			sta 	stringMemory+1
.b77f		85 3b		sta $3b				sta 	zTemp2+1
.b781		95 70		sta $70,x			sta 	NSMantissa1,x
.b783		68		pla				pla 								; save length-3 (chars allowed) in first byte
.b784		38		sec				sec
.b785		e9 03		sbc #$03			sbc 	#3
.b787		92 3a		sta ($3a)			sta 	(zTemp2)
.b789		a9 00		lda #$00			lda 	#0 							; clear the status byte.
.b78b		a0 01		ldy #$01			ldy 	#1
.b78d		91 3a		sta ($3a),y			sta 	(zTemp2),y
.b78f						_SACopyNewString:
.b78f		a0 00		ldy #$00			ldy 	#0
.b791						_SACopyNSLoop:
.b791		b1 38		lda ($38),y			lda 	(zTemp1),y 					; get character
.b793		c8		iny				iny 								; write two on in string storage
.b794		c8		iny				iny
.b795		91 3a		sta ($3a),y			sta 	(zTemp2),y
.b797		88		dey				dey 								; this makes it one one.
.b798		c9 00		cmp #$00			cmp 	#0 							; until EOS copied
.b79a		d0 f5		bne $b791			bne 	_SACopyNSLoop
.b79c		7a		ply				ply
.b79d		60		rts				rts
.b79e						_SALengthError:
.b79e		a9 09		lda #$09		lda	#9
.b7a0		4c 27 95	jmp $9527		jmp	ErrorHandler

;******  Return to file: _basic.asm


;******  Processing file: ./common/strings/stringalloc.asm

.b7a3						StringSystemInitialise:
.b7a3		a9 ff		lda #$ff			lda 	#((EndVariableSpace-1) & $FF)
.b7a5		8d 2a 04	sta $042a			sta 	0+stringMemory
.b7a8		a9 1f		lda #$1f			lda 	#((EndVariableSpace-1) >> 8)
.b7aa		8d 2b 04	sta $042b			sta 	1+stringMemory
.b7ad		9c ff 1f	stz $1fff			stz 	EndVariableSpace-1 			; put a zero at the end, so know end of string memory.
.b7b0		60		rts				rts
.b7b1						StringSpaceInitialise:
.b7b1		20 70 a0	jsr $a070			jsr 	CheckIdentifierStringSpace 	; check memory allocation.
.b7b4		a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.b7b6		8d 2c 04	sta $042c			sta 	stringInitialised
.b7b9		ad 2a 04	lda $042a			lda 	stringMemory 				; allocate 256 bytes for one concreted string
.b7bc		8d 2d 04	sta $042d			sta 	stringTempPointer 			; so temporary string space is allocated below that.
.b7bf		ad 2b 04	lda $042b			lda 	stringMemory+1
.b7c2		3a		dec a				dec 	a
.b7c3		8d 2e 04	sta $042e			sta 	stringTempPointer+1
.b7c6		60		rts				rts
.b7c7						StringTempAllocate:
.b7c7		c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.b7c9		b0 30		bcs $b7fb			bcs 	_STALength
.b7cb		2c 2c 04	bit $042c			bit 	stringInitialised 			; already initialised
.b7ce		30 05		bmi $b7d5			bmi 	_STAAllocate
.b7d0		48		pha				pha 								; save value to subtract.
.b7d1		20 b1 b7	jsr $b7b1			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.b7d4		68		pla				pla 								; restore it
.b7d5						_STAAllocate:
.b7d5		49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.b7d7		18		clc				clc  								; deliberate allows one more
.b7d8		6d 2d 04	adc $042d			adc 	stringTempPointer 			; subtract from temp pointer
.b7db		8d 2d 04	sta $042d			sta 	stringTempPointer
.b7de		95 60		sta $60,x			sta 	NSMantissa0,x 				; address in mantissa
.b7e0		85 3c		sta $3c				sta 	zsTemp 						; and zsTemp
.b7e2		ad 2e 04	lda $042e			lda 	stringTempPointer+1
.b7e5		69 ff		adc #$ff			adc 	#$FF
.b7e7		8d 2e 04	sta $042e			sta 	stringTempPointer+1
.b7ea		85 3d		sta $3d				sta 	zsTemp+1
.b7ec		95 70		sta $70,x			sta 	NSMantissa1,x
.b7ee		74 80		stz $80,x			stz 	NSMantissa2,x 				; set the typing data and the upper address bytes.
.b7f0		74 90		stz $90,x			stz 	NSMantissa3,x
.b7f2		a9 10		lda #$10			lda 	#NSTString
.b7f4		95 50		sta $50,x			sta 	NSStatus,x
.b7f6		a9 00		lda #$00			lda 	#0 							; clear the target string
.b7f8		92 3c		sta ($3c)			sta 	(zsTemp)
.b7fa		60		rts				rts
.b7fb						_STALength:
.b7fb		a9 09		lda #$09		lda	#9
.b7fd		4c 27 95	jmp $9527		jmp	ErrorHandler
.b800						StringTempWrite:
.b800		48		pha				pha
.b801		92 3c		sta ($3c)			sta 	(zsTemp) 					; write byte
.b803		e6 3c		inc $3c				inc 	zsTemp 						; bump pointer
.b805		d0 02		bne $b809			bne 	_STWNoCarry
.b807		e6 3d		inc $3d				inc 	zsTemp+1
.b809						_STWNoCarry:
.b809		a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.b80b		92 3c		sta ($3c)			sta 	(zsTemp)
.b80d		68		pla				pla
.b80e		60		rts				rts

;******  Return to file: _basic.asm

.b80f						StartModuleCode:

;******  Processing file: ../modules/.build/hardware.module.asm

=1						hardwareIntegrated=1
=0						CONBlack = 0
=1						CONGrey = 1
=2						CONDarkBlue = 2
=3						CONGreen = 3
=4						CONPurple = 4
=5						CONBrown = 5
=6						CONOrange = 6
=7						CONCyan = 7
=8						CONDarkGrey = 8
=9						CONLightGrey = 9
=10						CONLightBlue = 10
=11						CONLightGreen = 11
=12						CONPink = 12
=13						CONRed = 13
=14						CONYellow = 14
=15						CONWhite = 15
=9						CONForeground = CONLightGrey
=2						CONBackground = CONDarkBlue
=9						CLICommandLine = CONLightGrey
.c000	a000					Export_EXTPrintNoControl:
.c000	a000	48		pha				pha
.c001	a001	da		phx				phx
.c002	a002	5a		phy				phy
.c003	a003	a6 01		ldx $01				ldx 	1
.c005	a005	da		phx				phx
.c006	a006	ac eb 07	ldy $07eb			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.c009	a009	80 11		bra $a01c			bra 	PrintCharacterOnly
.c00b	a00b					Export_EXTPrintCharacter:
.c00b	a00b					PAGEDPrintCharacter:
.c00b	a00b	48		pha				pha
.c00c	a00c	da		phx				phx
.c00d	a00d	5a		phy				phy
.c00e	a00e	a6 01		ldx $01				ldx 	1
.c010	a010	da		phx				phx
.c011	a011	ac eb 07	ldy $07eb			ldy 	EXTColumn 					; Y = Row, e.g. points to character.
.c014	a014	09 00		ora #$00			ora 	#$00 						; check $80-$FF
.c016	a016	30 48		bmi $a060			bmi 	EXPCColour
.c018	a018	c9 20		cmp #$20			cmp 	#$20 						; check $00-$1F
.c01a	a01a	90 4d		bcc $a069			bcc 	EXPCControl
.c01c	a01c					PrintCharacterOnly:
.c01c	a01c	a2 02		ldx #$02			ldx 	#2 							; select char memory
.c01e	a01e	86 01		stx $01				stx 	1
.c020	a020	91 40		sta ($40),y			sta 	(EXTAddress),y
.c022	a022	e6 01		inc $01				inc 	1 							; select colour memory
.c024	a024	ad ec 07	lda $07ec			lda 	EXTTextColour
.c027	a027	91 40		sta ($40),y			sta 	(EXTAddress),y
.c029	a029	c8		iny				iny 								; advance horizontal position
.c02a	a02a	8c eb 07	sty $07eb			sty 	EXTColumn
.c02d	a02d	cc ed 07	cpy $07ed			cpy 	EXTScreenWidth 				; reached RHS ?
.c030	a030	90 63		bcc $a095			bcc 	EXPCExit 					; no, then exit.
.c032	a032					EXPCCRLF:
.c032	a032	ee ea 07	inc $07ea			inc 	EXTRow  					; bump row
.c035	a035	9c eb 07	stz $07eb			stz 	EXTColumn 					; back to column 0
.c038	a038	ad ea 07	lda $07ea			lda 	EXTRow 						; check if reached the bottom ?
.c03b	a03b	cd ee 07	cmp $07ee			cmp 	EXTScreenHeight 			; if so, then scroll.
.c03e	a03e	f0 18		beq $a058			beq 	EXPCScroll
.c040	a040	18		clc				clc 								; add width to address.
.c041	a041	a5 40		lda $40				lda 	EXTAddress
.c043	a043	6d ed 07	adc $07ed			adc 	EXTScreenWidth
.c046	a046	85 40		sta $40				sta 	EXTAddress
.c048	a048	90 4b		bcc $a095			bcc 	EXPCExit
.c04a	a04a	e6 41		inc $41				inc 	EXTAddress+1
.c04c	a04c	80 47		bra $a095			bra 	EXPCExit
.c04e	a04e					EXPCLeft:
.c04e	a04e	ce eb 07	dec $07eb			dec 	EXTColumn
.c051	a051	10 42		bpl $a095			bpl 	EXPCExit
.c053	a053					EXPCBegin:
.c053	a053	9c eb 07	stz $07eb			stz 	EXTColumn
.c056	a056	80 3d		bra $a095			bra 	EXPCExit
.c058	a058					EXPCScroll:
.c058	a058	ce ea 07	dec $07ea			dec 	EXTRow 						; the height-1 th line.
.c05b	a05b	20 47 a1	jsr $a147			jsr 	EXTScreenScroll 			; scroll the screen
.c05e	a05e	80 35		bra $a095			bra 	EXPCExit
.c060	a060					EXPCColour:
.c060	a060	c9 a0		cmp #$a0			cmp 	#$A0						; 80-9F set foreground/background
.c062	a062	b0 31		bcs $a095			bcs 	EXPCExit
.c064	a064	20 27 a1	jsr $a127			jsr 	EXPCHandleColour
.c067	a067	80 2c		bra $a095			bra 	EXPCExit
.c069	a069					EXPCControl:
.c069	a069	c9 11		cmp #$11			cmp 	#$11 						; only handle 00-10.
.c06b	a06b	b0 28		bcs $a095			bcs 	EXPCExit
.c06d	a06d	0a		asl a				asl 	a 							; double into X
.c06e	a06e	aa		tax				tax
.c06f	a06f	7c 05 a1	jmp ($a105,x)			jmp 	(EXPCActionTable,x) 		; and execute code.
.c072	a072					EXPCUp:
.c072	a072	ad ea 07	lda $07ea			lda 	EXTRow 						; already at top ?
.c075	a075	f0 1e		beq $a095			beq 	EXPCExit
.c077	a077	ce ea 07	dec $07ea			dec 	EXTRow 						; up one in position/address
.c07a	a07a	38		sec				sec
.c07b	a07b	a5 40		lda $40				lda 	EXTAddress
.c07d	a07d	ed ed 07	sbc $07ed			sbc 	EXTScreenWidth
.c080	a080	85 40		sta $40				sta 	EXTAddress
.c082	a082	b0 11		bcs $a095			bcs 	EXPCExit
.c084	a084	c6 41		dec $41				dec 	EXTAddress+1
.c086	a086	80 0d		bra $a095			bra 	EXPCExit
.c088	a088					EXPCRight:
.c088	a088	c8		iny				iny
.c089	a089	8c eb 07	sty $07eb			sty 	EXTColumn
.c08c	a08c	cc ed 07	cpy $07ed			cpy 	EXTScreenWidth
.c08f	a08f	d0 04		bne $a095			bne 	EXPCExit
.c091	a091	88		dey				dey
.c092	a092					EXPCSetColumnY:
.c092	a092	8c eb 07	sty $07eb			sty 	EXTColumn
.c095	a095					EXPCExit:
.c095	a095	20 bc a1	jsr $a1bc			jsr 	EXTSetHardwareCursor 		; place the physical cursor.
.c098	a098	68		pla				pla
.c099	a099	85 01		sta $01				sta 	1
.c09b	a09b	7a		ply				ply
.c09c	a09c	fa		plx				plx
.c09d	a09d	68		pla				pla
.c09e	a09e	60		rts				rts
.c09f	a09f					EXPCClearScreen:
.c09f	a09f	20 79 a1	jsr $a179			jsr		EXTClearScreenCode
.c0a2	a0a2	80 f1		bra $a095			bra 	EXPCExit
.c0a4	a0a4					EXPCDown:
.c0a4	a0a4	ad ee 07	lda $07ee			lda 	EXTScreenHeight 			; at the bottom
.c0a7	a0a7	3a		dec a				dec 	a
.c0a8	a0a8	cd ea 07	cmp $07ea			cmp 	EXTRow
.c0ab	a0ab	f0 e8		beq $a095			beq 	EXPCExit
.c0ad	a0ad	ee ea 07	inc $07ea			inc 	EXTRow 						; down one in position/address
.c0b0	a0b0	18		clc				clc
.c0b1	a0b1	a5 40		lda $40				lda 	EXTAddress
.c0b3	a0b3	6d ed 07	adc $07ed			adc 	EXTScreenWidth
.c0b6	a0b6	85 40		sta $40				sta 	EXTAddress
.c0b8	a0b8	90 db		bcc $a095			bcc 	EXPCExit
.c0ba	a0ba	e6 41		inc $41				inc 	EXTAddress+1
.c0bc	a0bc	80 d7		bra $a095			bra 	EXPCExit
.c0be	a0be					EXPCTab:
.c0be	a0be	ad eb 07	lda $07eb			lda 	EXTColumn 					; next tab stop
.c0c1	a0c1	29 f8		and #$f8			and 	#$F8
.c0c3	a0c3	18		clc				clc
.c0c4	a0c4	69 08		adc #$08			adc 	#8
.c0c6	a0c6	8d eb 07	sta $07eb			sta 	EXTColumn
.c0c9	a0c9	cd ed 07	cmp $07ed			cmp 	EXTScreenWidth 				; too far, new line.
.c0cc	a0cc	90 c7		bcc $a095			bcc 	EXPCExit
.c0ce	a0ce	4c 32 a0	jmp $a032			jmp 	EXPCCRLF
.c0d1	a0d1					EXPCBackSpace:
.c0d1	a0d1	88		dey				dey
.c0d2	a0d2	30 c1		bmi $a095			bmi 	EXPCExit
.c0d4	a0d4	ce eb 07	dec $07eb			dec 	EXTColumn
.c0d7	a0d7	a9 02		lda #$02			lda 	#2
.c0d9	a0d9	85 01		sta $01				sta 	1
.c0db	a0db	a9 20		lda #$20			lda 	#32
.c0dd	a0dd	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0df	a0df	80 b4		bra $a095			bra 	EXPCExit
.c0e1	a0e1					EXPCEnd:
.c0e1	a0e1	a9 02		lda #$02			lda 	#2 							; access text screen
.c0e3	a0e3	85 01		sta $01				sta 	1
.c0e5	a0e5	ac ed 07	ldy $07ed			ldy 	EXTScreenWidth 				; point to last character
.c0e8	a0e8	88		dey				dey
.c0e9	a0e9					EXPCEndSearch:
.c0e9	a0e9	88		dey				dey 								; if past start, move to col 0.
.c0ea	a0ea	30 06		bmi $a0f2			bmi 	EXPCFound
.c0ec	a0ec	b1 40		lda ($40),y			lda 	(EXTAddress),y 				; keep going back till non space found
.c0ee	a0ee	c9 20		cmp #$20			cmp 	#' '
.c0f0	a0f0	f0 f7		beq $a0e9			beq 	EXPCEndSearch
.c0f2	a0f2					EXPCFound:
.c0f2	a0f2	c8		iny				iny 								; move to following cell.
.c0f3	a0f3	80 9d		bra $a092			bra 	EXPCSetColumnY
.c0f5	a0f5					EXPCClearEOL:
.c0f5	a0f5	a9 02		lda #$02			lda 	#2 							; access character RAM
.c0f7	a0f7	85 01		sta $01				sta 	1
.c0f9	a0f9	a9 20		lda #$20			lda 	#' ' 						; write space
.c0fb	a0fb	91 40		sta ($40),y			sta 	(EXTAddress),y
.c0fd	a0fd	c8		iny				iny
.c0fe	a0fe	cc ed 07	cpy $07ed			cpy 	EXTScreenWidth 				; until RHS of screen.
.c101	a101	90 f2		bcc $a0f5			bcc 	EXPCClearEOL
.c103	a103	80 90		bra $a095			bra 	EXPCExit
.c105	a105					EXPCActionTable:
>c105	a105	95 a0						.word 	EXPCExit 					; 00
>c107	a107	53 a0						.word 	EXPCBegin 					; 01 A Start of Line
>c109	a109	4e a0						.word 	EXPCLeft 					; 02 B Left
>c10b	a10b	95 a0						.word 	EXPCExit 					; 03 <Break>
>c10d	a10d	95 a0						.word 	EXPCExit 					; 04
>c10f	a10f	e1 a0						.word 	EXPCEnd 					; 05 E End of Line
>c111	a111	88 a0						.word 	EXPCRight 					; 06 F Right
>c113	a113	95 a0						.word 	EXPCExit 					; 07
>c115	a115	d1 a0						.word 	EXPCBackSpace 				; 08 H Backspace
>c117	a117	be a0						.word 	EXPCTab 					; 09 I Tab
>c119	a119	95 a0						.word 	EXPCExit 					; 0A
>c11b	a11b	f5 a0						.word 	EXPCClearEOL 				; 0B K Clear to EOL
>c11d	a11d	9f a0						.word 	EXPCClearScreen			; 0C L CLS
>c11f	a11f	32 a0						.word 	EXPCCRLF 					; 0D M CR/LF
>c121	a121	a4 a0						.word 	EXPCDown 					; 0E N Down
>c123	a123	95 a0						.word 	EXPCExit 					; 0F
>c125	a125	72 a0						.word 	EXPCUp 					; 10 P Up
.c127	a127					EXPCHandleColour:
.c127	a127	c9 90		cmp #$90			cmp 	#$90 						; 8x foreground 9x background
.c129	a129	b0 16		bcs $a141			bcs 	EXPCBackground
.c12b	a12b	0a		asl a				asl 	a 							; shift it 4 bits to the right.
.c12c	a12c	0a		asl a				asl 	a
.c12d	a12d	0a		asl a				asl 	a
.c12e	a12e	0a		asl a				asl 	a
.c12f	a12f	a2 0f		ldx #$0f			ldx 	#$0F 						; Mask in X
.c131	a131					EXPCUpdate:
.c131	a131	48		pha				pha 								; save new colour
.c132	a132	8a		txa				txa 								; get mask
.c133	a133	2d ec 07	and $07ec			and 	EXTTextColour 				; mask out old.
.c136	a136	8d ec 07	sta $07ec			sta 	EXTTextColour
.c139	a139	68		pla				pla 								; or in new colour
.c13a	a13a	0d ec 07	ora $07ec			ora 	EXTTextColour
.c13d	a13d	8d ec 07	sta $07ec			sta 	EXTTextColour
.c140	a140	60		rts				rts
.c141	a141					EXPCBackground:
.c141	a141	29 0f		and #$0f			and 	#$0F 						; get the colour
.c143	a143	a2 f0		ldx #$f0			ldx 	#$F0 						; mask
.c145	a145	80 ea		bra $a131			bra 	EXPCUpdate
.c147	a147					EXTScreenScroll:
.c147	a147	a9 02		lda #$02			lda 	#2 							; select text page
.c149	a149	85 01		sta $01				sta 	1
.c14b	a14b	a9 20		lda #$20			lda		#32 						; fill with space
.c14d	a14d	20 00 a3	jsr $a300			jsr 	EXTScrollFill
.c150	a150	e6 01		inc $01				inc 	1 							; select colour page
.c152	a152	ad ec 07	lda $07ec			lda 	EXTTextColour
.c155	a155	20 00 a3	jsr $a300			jsr 	EXTScrollFill
.c158	a158	60		rts				rts
.c159	a159					PAGEDPrintHex:
.c159	a159	48		pha				pha
.c15a	a15a	a9 20		lda #$20			lda 	#' '
.c15c	a15c	20 0b a0	jsr $a00b			jsr 	PAGEDPrintCharacter
.c15f	a15f	68		pla				pla
.c160	a160	48		pha				pha
.c161	a161	4a		lsr a				lsr 	a
.c162	a162	4a		lsr a				lsr 	a
.c163	a163	4a		lsr a				lsr 	a
.c164	a164	4a		lsr a				lsr 	a
.c165	a165	20 69 a1	jsr $a169			jsr 	_PPHNibble
.c168	a168	68		pla				pla
.c169	a169					_PPHNibble:
.c169	a169	48		pha				pha
.c16a	a16a	29 0f		and #$0f			and 	#15
.c16c	a16c	c9 0a		cmp #$0a			cmp 	#10
.c16e	a16e	90 02		bcc $a172			bcc 	_PPHOut
.c170	a170	69 06		adc #$06			adc 	#6
.c172	a172	69 30		adc #$30	_PPHOut:adc 	#48
.c174	a174	20 0b a0	jsr $a00b			jsr		PAGEDPrintCharacter
.c177	a177	68		pla				pla
.c178	a178	60		rts				rts
.c179	a179					EXTClearScreenCode:
.c179	a179	a9 02		lda #$02			lda 	#2 							; select text page
.c17b	a17b	85 01		sta $01				sta 	1
.c17d	a17d	a9 20		lda #$20			lda		#32 						; fill with space
.c17f	a17f	20 8c a1	jsr $a18c			jsr 	_EXTCSFill
.c182	a182	e6 01		inc $01				inc 	1 							; select color page
.c184	a184	ad ec 07	lda $07ec			lda 	EXTTextColour
.c187	a187	20 8c a1	jsr $a18c			jsr 	_EXTCSFill
.c18a	a18a	80 22		bra $a1ae			bra 	EXTHomeCursor				; home cursor
.c18c	a18c					_EXTCSFill:
.c18c	a18c	aa		tax				tax
.c18d	a18d	a9 00		lda #$00			lda 	#EXTMemory & $FF
.c18f	a18f	85 40		sta $40				sta 	EXTAddress
.c191	a191	a9 c0		lda #$c0			lda 	#EXTMemory >> 8
.c193	a193	85 41		sta $41				sta 	EXTAddress+1
.c195	a195					_EXTCSFill1:
.c195	a195	a0 00		ldy #$00			ldy 	#0
.c197	a197	8a		txa				txa
.c198	a198					_EXTCSFill2:
.c198	a198	91 40		sta ($40),y			sta 	(EXTAddress),y
.c19a	a19a	c8		iny				iny
.c19b	a19b	d0 fb		bne $a198			bne 	_EXTCSFill2
.c19d	a19d	e6 41		inc $41				inc 	EXTAddress+1
.c19f	a19f	a5 41		lda $41				lda 	EXTAddress+1
.c1a1	a1a1	c9 d2		cmp #$d2			cmp 	#$D2
.c1a3	a1a3	d0 f0		bne $a195			bne 	_EXTCSFill1
.c1a5	a1a5	8a		txa				txa
.c1a6	a1a6					_EXTCSFill3:
.c1a6	a1a6	91 40		sta ($40),y			sta 	(EXTAddress),y
.c1a8	a1a8	c8		iny				iny
.c1a9	a1a9	c0 c0		cpy #$c0			cpy 	#$C0
.c1ab	a1ab	d0 f9		bne $a1a6			bne 	_EXTCSFill3
.c1ad	a1ad	60		rts				rts
.c1ae	a1ae					EXTHomeCursor:
.c1ae	a1ae	9c ea 07	stz $07ea			stz 	EXTRow 						; reset row & column
.c1b1	a1b1	9c eb 07	stz $07eb			stz 	EXTColumn
.c1b4	a1b4	a9 00		lda #$00			lda 	#<EXTMemory					; set address in I/O memory
.c1b6	a1b6	85 40		sta $40				sta 	EXTAddress
.c1b8	a1b8	a9 c0		lda #$c0			lda 	#>EXTMemory
.c1ba	a1ba	85 41		sta $41				sta 	EXTAddress+1
.c1bc	a1bc					EXTSetHardwareCursor:
.c1bc	a1bc	64 01		stz $01		        stz 	1 							; I/O Page zero
.c1be	a1be	ad eb 07	lda $07eb	        lda 	EXTColumn
.c1c1	a1c1	8d 14 d0	sta $d014	        sta 	$D014 						; set cursor position
.c1c4	a1c4	9c 15 d0	stz $d015	        stz 	$D015
.c1c7	a1c7	ad ea 07	lda $07ea	        lda 	EXTRow
.c1ca	a1ca	8d 16 d0	sta $d016	        sta 	$D016
.c1cd	a1cd	9c 17 d0	stz $d017	        stz 	$D017
.c1d0	a1d0	60		rts		        rts
.c1d1	a1d1					Export_EXTSetCurrentLine:
.c1d1	a1d1	ad ea 07	lda $07ea			lda     EXTRow						; `A` holds the current row
.c1d4	a1d4	0a		asl a				asl 	a							; multiply row index by 2 to get byte index
.c1d5	a1d5	a8		tay				tay									; `Y` holds the byte index of the row offset
.c1d6	a1d6	18		clc				clc
.c1d7	a1d7	a9 00		lda #$00			lda 	#<EXTMemory					; `A` = low byte of screen memory
.c1d9	a1d9	79 f0 07	adc $07f0,y			adc 	EXTScreenRowOffsets,y		; add the row offset
.c1dc	a1dc	85 40		sta $40				sta 	EXTAddress					; store low byte of the line address
.c1de	a1de	a9 c0		lda #$c0			lda 	#>EXTMemory					; `A` = high byte of screen memory
.c1e0	a1e0	79 f1 07	adc $07f1,y			adc 	EXTScreenRowOffsets+1,y		; add the row offset
.c1e3	a1e3	85 41		sta $41				sta 	EXTAddress+1				; store high byte of the line address
.c1e5	a1e5	60		rts		        rts
=$c000						EXTMemory 		= $C000
=$02						EXTTextPage 	= $02
=$03						EXTColourPage 	= $03
>07ea						EXTRow				.fill 	1
>07eb						EXTColumn			.fill 	1
>07ec						EXTTextColour		.fill 	1
>07ed						EXTScreenWidth		.fill 	1
>07ee						EXTScreenHeight		.fill 	1
>07ef								.align 2
>07f0						EXTScreenRowOffsets	.fill 	128 * 2
>0040						EXTAddress			.fill 	2
.c1e6	a1e6					Export_EXTInitialise:
.c1e6	a1e6	64 01		stz $01				stz 	1 							; Access I/O page 0
.c1e8	a1e8	9c 04 d0	stz $d004			stz 	$D004 						; Disable border
.c1eb	a1eb	9c 08 d0	stz $d008			stz 	$D008
.c1ee	a1ee	9c 09 d0	stz $d009			stz 	$D009
.c1f1	a1f1	a9 09		lda #$09			lda 	#1+8						; Timer On at 70Hz counting up.
.c1f3	a1f3	8d 58 d6	sta $d658			sta 	$D658
.c1f6	a1f6	a9 52		lda #$52			lda 	#$52
.c1f8	a1f8	8d ec 07	sta $07ec			sta 	EXTTextColour
.c1fb	a1fb	a9 50		lda #$50			lda 	#80 						; number of columns
.c1fd	a1fd	8d ed 07	sta $07ed			sta 	EXTScreenWidth
.c200	a200	a9 3c		lda #$3c			lda 	#60							; number of rows
.c202	a202	8d ee 07	sta $07ee			sta 	EXTScreenHeight
.c205	a205	ad ee 07	lda $07ee			lda		EXTScreenHeight				; get screen height
.c208	a208	85 36		sta $36				sta		zTemp0 						; `zTemp0` = row counter
.c20a	a20a	10 05		bpl $a211			bpl		loop_start					; screen height is less then 128, continue
.c20c	a20c	a9 1f		lda #$1f		lda	#31
.c20e	a20e	4c 27 95	jmp $9527		jmp	ErrorHandler
.c211	a211						loop_start:
.c211	a211	64 38		stz $38				stz		zTemp1						; zTemp1 holds the current offset
.c213	a213	64 39		stz $39				stz		zTemp1+1					;
.c215	a215	a0 00		ldy #$00			ldy		#0			  				; `Y` = offset byte index
.c217	a217						next_row:
.c217	a217	a5 38		lda $38				lda		zTemp1						; get low byte of offset
.c219	a219	99 f0 07	sta $07f0,y			sta		EXTScreenRowOffsets,y		; store low byte
.c21c	a21c	c8		iny				iny
.c21d	a21d	a5 39		lda $39				lda		zTemp1+1					; get high byte of offset
.c21f	a21f	99 f0 07	sta $07f0,y			sta		EXTScreenRowOffsets,y		; store high byte
.c222	a222	c8		iny				iny
.c223	a223	18		clc				clc
.c224	a224	a5 38		lda $38				lda		zTemp1						; `A` holds the low byte of offset
.c226	a226	6d ed 07	adc $07ed			adc		EXTScreenWidth				; add screen width
.c229	a229	85 38		sta $38				sta		zTemp1						; store low byte of new offset
.c22b	a22b	90 02		bcc $a22f			bcc		no_carry					; if no carry, we are done
.c22d	a22d	e6 39		inc $39				inc		zTemp1+1					; increment high byte of offset if carry occurred
.c22f	a22f						no_carry:
.c22f	a22f	c6 36		dec $36				dec		zTemp0						; decrement row counter
.c231	a231	d0 e4		bne $a217			bne		next_row					; if not zero, precompute the next row's offset
.c233	a233	a9 05		lda #$05			lda 	#1+4 						; enable cursor
.c235	a235	8d 10 d0	sta $d010			sta 	$D010
.c238	a238	a9 d6		lda #$d6			lda 	#214 						; cursor character
.c23a	a23a	8d 12 d0	sta $d012			sta 	$D012
.c23d	a23d	20 79 a1	jsr $a179			jsr 	EXTClearScreenCode 			; clear the screen and home cursor
.c240	a240					_EXMoveDown:
.c240	a240	a9 0d		lda #$0d			lda 	#13
.c242	a242	20 0b a0	jsr $a00b			jsr 	PAGEDPrintCharacter
.c245	a245	ad ea 07	lda $07ea			lda 	EXTRow
.c248	a248	c9 0a		cmp #$0a			cmp 	#Header_Height-4
.c24a	a24a	d0 f4		bne $a240			bne 	_EXMoveDown
.c24c	a24c	20 52 a2	jsr $a252			jsr 	EXTShowHeader
.c24f	a24f	64 01		stz $01				stz 	1
.c251	a251	60		rts				rts
.c252	a252					EXTShowHeader:
.c252	a252	a5 01		lda $01				lda 	1
.c254	a254	48		pha				pha
.c255	a255	a5 0b		lda $0b				lda 	8+3
.c257	a257	48		pha				pha
.c258	a258	a5 0c		lda $0c				lda 	8+4
.c25a	a25a	18		clc				clc
.c25b	a25b	69 03		adc #$03			adc 	#3
.c25d	a25d	85 0b		sta $0b				sta 	8+3
.c25f	a25f	a2 8d		ldx #$8d			ldx 	#(Header_jchars & $FF)
.c261	a261	a0 61		ldy #$61			ldy 	#(Header_jchars >> 8)-$40
.c263	a263	64 01		stz $01				stz 	1
.c265	a265	ad a7 d6	lda $d6a7			lda 	$D6A7
.c268	a268	29 10		and #$10			and 	#$10
.c26a	a26a	f0 04		beq $a270			beq 	_EXTSHNotK1
.c26c	a26c	a2 1c		ldx #$1c			ldx 	#(Header_kchars & $FF)
.c26e	a26e	a0 65		ldy #$65			ldy 	#(Header_kchars >> 8)-$40
.c270	a270					_EXTSHNotK1:
.c270	a270	a9 02		lda #$02			lda 	#2
.c272	a272	20 a0 a2	jsr $a2a0			jsr 	_ESHCopyBlock
.c275	a275	a2 00		ldx #$00			ldx 	#(Header_jattrs & $FF)
.c277	a277	a0 60		ldy #$60			ldy 	#(Header_jattrs >> 8)-$40
.c279	a279	64 01		stz $01				stz 	1
.c27b	a27b	ad a7 d6	lda $d6a7			lda 	$D6A7
.c27e	a27e	29 10		and #$10			and 	#$10
.c280	a280	f0 04		beq $a286			beq 	_EXTSHNotK2
.c282	a282	a2 bd		ldx #$bd			ldx 	#(Header_kattrs & $FF)
.c284	a284	a0 63		ldy #$63			ldy 	#(Header_kattrs >> 8)-$40
.c286	a286					_EXTSHNotK2:
.c286	a286	a9 03		lda #$03			lda 	#3
.c288	a288	20 a0 a2	jsr $a2a0			jsr 	_ESHCopyBlock
.c28b	a28b	64 01		stz $01				stz 	1
.c28d	a28d	a2 3f		ldx #$3f			ldx 	#16*4-1
.c28f	a28f					_EXTCopyLUT:
.c28f	a28f	bd de 6f	lda $6fde,x			lda 	Header_Palette-$4000,x
.c292	a292	9d 00 d8	sta $d800,x			sta 	$D800,x
.c295	a295	9d 40 d8	sta $d840,x			sta 	$D840,x
.c298	a298	ca		dex				dex
.c299	a299	10 f4		bpl $a28f			bpl 	_EXTCopyLUT
.c29b	a29b	68		pla				pla
.c29c	a29c	85 0b		sta $0b				sta 	8+3
.c29e	a29e	68		pla				pla
.c29f	a29f	60		rts				rts
.c2a0	a2a0					_ESHCopyBlock:
.c2a0	a2a0	85 01		sta $01				sta 	1
.c2a2	a2a2	86 36		stx $36				stx 	zTemp0 						; zTemp0 is RLE packed data
.c2a4	a2a4	84 37		sty $37				sty 	zTemp0+1
.c2a6	a2a6	a9 00		lda #$00			lda 	#(($C000) & $FF)
.c2a8	a2a8	85 38		sta $38				sta 	0+zTemp1
.c2aa	a2aa	a9 c0		lda #$c0			lda 	#(($C000) >> 8)
.c2ac	a2ac	85 39		sta $39				sta 	1+zTemp1
.c2ae	a2ae					_ESHCopyLoop:
.c2ae	a2ae	b2 36		lda ($36)			lda 	(zTemp0) 					; get next character
.c2b0	a2b0	c9 ff		cmp #$ff			cmp 	#Header_RLE 				; packed ?
.c2b2	a2b2	f0 1b		beq $a2cf			beq 	_ESHUnpack
.c2b4	a2b4	92 38		sta ($38)			sta 	(zTemp1) 					; copy it out.
.c2b6	a2b6	a9 01		lda #$01			lda 	#1 							; source add 1
.c2b8	a2b8	a0 01		ldy #$01			ldy 	#1 							; dest add 1
.c2ba	a2ba					_ESHNext:
.c2ba	a2ba	18		clc				clc 								; zTemp0 + A
.c2bb	a2bb	65 36		adc $36				adc 	zTemp0
.c2bd	a2bd	85 36		sta $36				sta 	zTemp0
.c2bf	a2bf	90 02		bcc $a2c3			bcc 	_ESHNoCarry
.c2c1	a2c1	e6 37		inc $37				inc 	zTemp0+1
.c2c3	a2c3					_ESHNoCarry:
.c2c3	a2c3	98		tya				tya 								; zTemp1 + Y
.c2c4	a2c4	18		clc				clc
.c2c5	a2c5	65 38		adc $38				adc 	zTemp1
.c2c7	a2c7	85 38		sta $38				sta 	zTemp1
.c2c9	a2c9	90 e3		bcc $a2ae			bcc 	_ESHCopyLoop
.c2cb	a2cb	e6 39		inc $39				inc 	zTemp1+1
.c2cd	a2cd	80 df		bra $a2ae			bra 	_ESHCopyLoop
.c2cf	a2cf					_ESHUnpack:
.c2cf	a2cf	a0 02		ldy #$02			ldy 	#2 							; get count into X
.c2d1	a2d1	b1 36		lda ($36),y			lda 	(zTemp0),y
.c2d3	a2d3	aa		tax				tax
.c2d4	a2d4	88		dey				dey 								; byte into A
.c2d5	a2d5	b1 36		lda ($36),y			lda 	(zTemp0),y
.c2d7	a2d7	f0 0c		beq $a2e5			beq 	_ESHExit 					; exit if zero.
.c2d9	a2d9	a0 00		ldy #$00			ldy 	#0 							; copy start position
.c2db	a2db					_ESHCopyOut:
.c2db	a2db	91 38		sta ($38),y			sta 	(zTemp1),y
.c2dd	a2dd	c8		iny				iny
.c2de	a2de	ca		dex				dex
.c2df	a2df	d0 fa		bne $a2db			bne 	_ESHCopyOut
.c2e1	a2e1	a9 03		lda #$03			lda 	#3 							; Y is bytes on screen, 3 bytes from source
.c2e3	a2e3	80 d5		bra $a2ba			bra 	_ESHNext
.c2e5	a2e5					_ESHExit:
.c2e5	a2e5	60		rts				rts
.c2e6	a2e6					Export_EXTScreenAt:
.c2e6	a2e6	5a		phy				phy									; save column coordinate on stack
.c2e7	a2e7	0a		asl a				asl 	a							; multiply row index by 2 to get byte index
.c2e8	a2e8	a8		tay				tay									; `Y` holds the byte index of the row offset
.c2e9	a2e9	a9 02		lda #$02			lda 	#2 							; select text page
.c2eb	a2eb	85 01		sta $01				sta 	$0001
.c2ed	a2ed	18		clc				clc
.c2ee	a2ee	a9 00		lda #$00			lda 	#<EXTMemory					; `A` = low byte of screen memory
.c2f0	a2f0	79 f0 07	adc $07f0,y			adc 	EXTScreenRowOffsets,y		; add the row offset
.c2f3	a2f3	85 36		sta $36				sta 	zTemp0						; store low byte of the line address
.c2f5	a2f5	a9 c0		lda #$c0			lda 	#>EXTMemory					; `A` = high byte of screen memory
.c2f7	a2f7	79 f1 07	adc $07f1,y			adc 	EXTScreenRowOffsets+1,y		; add the row offset
.c2fa	a2fa	85 37		sta $37				sta 	zTemp0+1					; store high byte of the line address
.c2fc	a2fc	7a		ply				ply									; restore column index into `Y`
.c2fd	a2fd	b1 36		lda ($36),y			lda 	(zTemp0),y					; zTemp0 + Y = character address
.c2ff	a2ff	60		rts				rts
.c300	a300					EXTScrollFill:
.c300	a300	aa		tax				tax									; save value to fill with
.c301	a301	a5 36		lda $36				lda 	zTemp0 						; save zTemp0 (dest) zTemp1 (src)
.c303	a303	48		pha				pha
.c304	a304	a5 37		lda $37				lda 	zTemp0+1
.c306	a306	48		pha				pha
.c307	a307	a5 38		lda $38				lda 	zTemp1
.c309	a309	48		pha				pha
.c30a	a30a	a5 39		lda $39				lda 	zTemp1+1
.c30c	a30c	48		pha				pha
.c30d	a30d	a9 c0		lda #$c0			lda 	#$C0 						; copy from C000+length to C000
.c30f	a30f	85 37		sta $37				sta 	zTemp0+1
.c311	a311	85 39		sta $39				sta 	zTemp1+1
.c313	a313	64 36		stz $36				stz 	zTemp0
.c315	a315	ad ed 07	lda $07ed			lda 	EXTScreenWidth
.c318	a318	85 38		sta $38				sta 	zTemp1
.c31a	a31a	a0 00		ldy #$00			ldy 	#0
.c31c	a31c					_EXSFCopy1:
.c31c	a31c	b1 38		lda ($38),y			lda 	(zTemp1),y
.c31e	a31e	91 36		sta ($36),y			sta 	(zTemp0),y
.c320	a320	c8		iny				iny
.c321	a321	d0 f9		bne $a31c			bne 	_EXSFCopy1
.c323	a323	e6 37		inc $37				inc 	zTemp0+1 					; next page
.c325	a325	e6 39		inc $39				inc 	zTemp1+1
.c327	a327	a5 39		lda $39				lda 	zTemp1+1
.c329	a329	c9 d3		cmp #$d3			cmp 	#$D3
.c32b	a32b	d0 ef		bne $a31c			bne 	_EXSFCopy1
.c32d	a32d	ac ed 07	ldy $07ed			ldy 	EXTScreenWidth 				; blank the bottom line.
.c330	a330	8a		txa				txa
.c331	a331					_EXSFFill1:
.c331	a331	88		dey				dey
.c332	a332	91 40		sta ($40),y			sta 	(EXTAddress),y
.c334	a334	c0 00		cpy #$00			cpy 	#0
.c336	a336	10 f9		bpl $a331			bpl 	_EXSFFill1
.c338	a338	68		pla				pla
.c339	a339	85 39		sta $39				sta 	zTemp1+1
.c33b	a33b	68		pla				pla
.c33c	a33c	85 38		sta $38				sta 	zTemp1
.c33e	a33e	68		pla				pla
.c33f	a33f	85 37		sta $37				sta 	zTemp0+1
.c341	a341	68		pla				pla
.c342	a342	85 36		sta $36				sta 	zTemp0
.c344	a344	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/.build/graphics.module.asm

=1						graphicsIntegrated=1
=0						GCMD_Initialise = 0*2
=2						GCMD_BitmapCtl = 1*2
=4						GCMD_SpriteCtl = 2*2
=6						GCMD_Clear = 3*2
=8						GCMD_Colour = 4*2
=10						GCMD_DrawFont = 5*2
=12						GCMD_DrawSprite = 6*2
=14						GCMD_SpriteUse = 7*2
=16						GCMD_SpriteImage = 8*2
=18						GCMD_SpriteCollide = 9*2
=20						GCMD_TileCtl = 10*2
=22						GCMD_TileSize = 11*2
=24						GCMD_TileScrollX = 12*2
=26						GCMD_TileScrollY = 13*2
=28						GCMD_TilePos = 14*2
=30						GCMD_TileWrite = 15*2
=32						GCMD_TileRead = 16*2
=64						GCMD_Move = 32*2
=66						GCMD_Line = 33*2
=68						GCMD_FrameRect = 34*2
=70						GCMD_FillRect = 35*2
=72						GCMD_FrameCircle = 36*2
=74						GCMD_FillCircle = 37*2
=80						GCMD_Plot = 40*2
=82						GCMD_SpriteMove = 41*2
=42						GRFirstFreeCode = 42
.c345	a345					GRVectorTable:
>c345	a345	97 a5					.word	GXInitialise             ; $00 Initialise
>c347	a347	be a5					.word	GXControlBitmap          ; $01 BitmapCtl
>c349	a349	06 a6					.word	GXControlSprite          ; $02 SpriteCtl
>c34b	a34b	47 a5					.word	GXClearBitmap            ; $03 Clear
>c34d	a34d	37 a8					.word	GXSetColourMode          ; $04 Colour
>c34f	a34f	56 aa					.word	GXFontHandler            ; $05 DrawFont
>c351	a351	9e aa					.word	GXSpriteHandler          ; $06 DrawSprite
>c353	a353	0f ab					.word	GXSelect                 ; $07 SpriteUse
>c355	a355	38 ab					.word	GXSelectImage            ; $08 SpriteImage
>c357	a357	5d ad					.word	GXCollide                ; $09 SpriteCollide
>c359	a359	47 a6					.word	GXControlTilemap         ; $0a TileCtl
>c35b	a35b	cf a6					.word	GXControlTileSize        ; $0b TileSize
>c35d	a35d	ff a9					.word	GXControlTileScrollX     ; $0c TileScrollX
>c35f	a35f	10 aa					.word	GXControlTileScrollY     ; $0d TileScrollY
>c361	a361	3e ac					.word	GXSelectTile             ; $0e TilePos
>c363	a363	a0 ac					.word	GXSTWriteTile            ; $0f TileWrite
>c365	a365	a3 ac					.word	GXSTReadTile             ; $10 TileRead
>c367	a367	f8 a3					.word	GRUndefined              ; $11
>c369	a369	f8 a3					.word	GRUndefined              ; $12
>c36b	a36b	f8 a3					.word	GRUndefined              ; $13
>c36d	a36d	f8 a3					.word	GRUndefined              ; $14
>c36f	a36f	f8 a3					.word	GRUndefined              ; $15
>c371	a371	f8 a3					.word	GRUndefined              ; $16
>c373	a373	f8 a3					.word	GRUndefined              ; $17
>c375	a375	f8 a3					.word	GRUndefined              ; $18
>c377	a377	f8 a3					.word	GRUndefined              ; $19
>c379	a379	f8 a3					.word	GRUndefined              ; $1a
>c37b	a37b	f8 a3					.word	GRUndefined              ; $1b
>c37d	a37d	f8 a3					.word	GRUndefined              ; $1c
>c37f	a37f	f8 a3					.word	GRUndefined              ; $1d
>c381	a381	f8 a3					.word	GRUndefined              ; $1e
>c383	a383	f8 a3					.word	GRUndefined              ; $1f
>c385	a385	f6 a3					.word	GXMove                   ; $20 Move
>c387	a387	05 a7					.word	GXLine                   ; $21 Line
>c389	a389	80 a8					.word	GXFrameRectangle         ; $22 FrameRect
>c38b	a38b	7d a8					.word	GXFillRectangle          ; $23 FillRect
>c38d	a38d	fe a3					.word	GXFrameCircle            ; $24 FrameCircle
>c38f	a38f	fa a3					.word	GXFillCircle             ; $25 FillCircle
>c391	a391	f8 a3					.word	GRUndefined              ; $26
>c393	a393	f8 a3					.word	GRUndefined              ; $27
>c395	a395	65 a8					.word	GXPlotPoint              ; $28 Plot
>c397	a397	ce ab					.word	GXMoveSprite             ; $29 SpriteMove
=3						GXMappingPage = 3
=24576						GXMappingAddress = ($2000 * GXMappingPage)
=11						GXEditSlot = 8 + GXMappingPage
=$36						gxzTemp0 = zTemp0
=$38						gxzTemp1 = zTemp1
=$3a						gxzTemp2 = zTemp2
=$3c						gxzScreen = zsTemp
=$643						gxPixelBuffer = numberBuffer
.08f0						gxCurrentX:
>08f0								.fill 	2
.08f2						gxCurrentY:
>08f2								.fill 	2
.08f4						gxLastX:
>08f4								.fill 	2
.08f6						gxLastY:
>08f6								.fill 	2
.08f8						gxX0:
>08f8								.fill 	2
.08fa						gxY0:
>08fa								.fill 	2
.08fc						gxX1:
>08fc								.fill 	2
.08fe						gxY1:
>08fe								.fill 	2
.0900						gxSpritesOn:
>0900								.fill 	1
.0901						gxBitmapsOn:
>0901								.fill 	1
.0902						gxTilesOn:
>0902								.fill 	1
.0903						gxBasePage:
>0903								.fill 	1
.0904						gxSpritePage:
>0904								.fill 	1
.0905						gxTileImagePage:
>0905								.fill 	1
.0906						gxTileMapPage:
>0906								.fill 	1
.0907						gxTileMapWidth:
>0907								.fill 	1
.0908						gxTileMapHeight:
>0908								.fill 	1
.0909						gxHeight:
>0909								.fill 	1
.090a						gxMode:
>090a								.fill 	1
.090b						gxColour:
>090b								.fill 	1
.090c						gxEORValue:
>090c								.fill 	1
.090d						gxANDValue:
>090d								.fill 	1
.090e						gxOriginalLUTValue:
>090e								.fill 	1
.090f						gxOffset:
>090f								.fill 	1
.0910						GSCurrentSpriteID:
>0910								.fill 	1
.0911						GSCurrentSpriteAddr:
>0911								.fill 	2
.0913						gxSpriteOffsetBase:
>0913								.fill 	2
.0915						gxSpriteLow:
>0915								.fill 	64
.0955						gxSpriteHigh:
>0955								.fill 	64
.0995						gxTileAccessPage:
>0995								.fill 	1
.0996						gxTileAccessAddress:
>0996								.fill 	2
.c399	a399					Export_GXGraphicDraw:
.c399	a399	c9 40		cmp #$40			cmp 	#GCMD_Move					; low value instructions don't use coordinates
.c39b	a39b	b0 06		bcs $a3a3			bcs 	_GDCoordinate 				; (see graphics.txt)
.c39d	a39d	86 36		stx $36				stx 	gxzTemp0 					; save X/Y
.c39f	a39f	84 37		sty $37				sty 	gxzTemp0+1
.c3a1	a3a1	80 4b		bra $a3ee			bra 	_GDExecuteA 				; and execute
.c3a3	a3a3					_GDCoordinate:
.c3a3	a3a3	48		pha				pha 								; save AXY
.c3a4	a3a4	da		phx				phx
.c3a5	a3a5	5a		phy				phy
.c3a6	a3a6	a2 03		ldx #$03			ldx 	#3 							; copy currentX to lastX
.c3a8	a3a8					_GDCopy1:
.c3a8	a3a8	bd f0 08	lda $08f0,x			lda 	gxCurrentX,x
.c3ab	a3ab	9d f4 08	sta $08f4,x			sta 	gxLastX,x
.c3ae	a3ae	ca		dex				dex
.c3af	a3af	10 f7		bpl $a3a8			bpl 	_GDCopy1
.c3b1	a3b1	68		pla				pla
.c3b2	a3b2	8d f2 08	sta $08f2			sta 	gxCurrentY
.c3b5	a3b5	9c f3 08	stz $08f3			stz 	gxCurrentY+1
.c3b8	a3b8	68		pla				pla
.c3b9	a3b9	8d f0 08	sta $08f0			sta 	gxCurrentX
.c3bc	a3bc	68		pla				pla 								; get A (command+X.1) back
.c3bd	a3bd	48		pha				pha
.c3be	a3be	29 01		and #$01			and 	#1 							; put LSB as MSB of Current.X
.c3c0	a3c0	8d f1 08	sta $08f1			sta 	gxCurrentX+1
.c3c3	a3c3	68		pla				pla 								; get command back
.c3c4	a3c4	29 fe		and #$fe			and 	#$FE 						; lose LSB, chuck the stray X bit
.c3c6	a3c6	48		pha				pha 								; push back.
.c3c7	a3c7	c9 52		cmp #$52			cmp 	#GCMD_SpriteMove 			; move sprite does not clip.
.c3c9	a3c9	f0 17		beq $a3e2			beq 	_GDCopyToWorkArea
.c3cb	a3cb	ad f1 08	lda $08f1			lda 	gxCurrentX+1 				; X < 256 X okay
.c3ce	a3ce	f0 07		beq $a3d7			beq 	_GDCheckY
.c3d0	a3d0	ad f0 08	lda $08f0			lda 	gxCurrentX 					; otherwise X < 320 = 256 + 64
.c3d3	a3d3	c9 40		cmp #$40			cmp 	#64
.c3d5	a3d5	b0 08		bcs $a3df			bcs 	_GDError1
.c3d7	a3d7					_GDCheckY:
.c3d7	a3d7	ad f2 08	lda $08f2			lda 	gxCurrentY 					; check Y < Height.
.c3da	a3da	cd 09 09	cmp $0909			cmp 	gxHeight
.c3dd	a3dd	90 03		bcc $a3e2			bcc 	_GDCopyToWorkArea
.c3df	a3df					_GDError1:
.c3df	a3df	68		pla				pla
.c3e0	a3e0					_GDError2:
.c3e0	a3e0	38		sec				sec
.c3e1	a3e1	60		rts				rts
.c3e2	a3e2					_GDCopyToWorkArea:
.c3e2	a3e2	a2 07		ldx #$07			ldx 	#7 							; copy current and last to gxXY/12 work area
.c3e4	a3e4					_GDCopy2:
.c3e4	a3e4	bd f0 08	lda $08f0,x			lda 	gxCurrentX,x
.c3e7	a3e7	9d f8 08	sta $08f8,x			sta 	gxX0,x
.c3ea	a3ea	ca		dex				dex
.c3eb	a3eb	10 f7		bpl $a3e4			bpl 	_GDCopy2
.c3ed	a3ed	68		pla				pla 								; get command
.c3ee	a3ee					_GDExecuteA:
.c3ee	a3ee	c9 54		cmp #$54			cmp 	#GRFirstFreeCode*2 			; bad command ?
.c3f0	a3f0	b0 ee		bcs $a3e0			bcs 	_GDError2
.c3f2	a3f2	aa		tax				tax 								; go execute the command.
.c3f3	a3f3	7c 45 a3	jmp ($a345,x)			jmp 	(GRVectorTable,x)
.c3f6	a3f6					GXMove:
.c3f6	a3f6	18		clc				clc
.c3f7	a3f7	60		rts				rts
.c3f8	a3f8					GRUndefined:
.c3f8	a3f8	38		sec				sec
.c3f9	a3f9	60		rts				rts
.c3fa	a3fa					GXFillCircle:
.c3fa	a3fa	a9 ff		lda #$ff			lda 	#255 						; A determines fill or not
.c3fc	a3fc	80 02		bra $a400			bra 	GXCircle
.c3fe	a3fe					GXFrameCircle:
.c3fe	a3fe	a9 00		lda #$00			lda 	#0
.c400	a400					GXCircle:
.c400	a400	8d 9b 09	sta $099b			sta 	gxIsFillMode				; save Fill flag
.c403	a403	ad 01 09	lda $0901			lda 	gxBitmapsOn
.c406	a406	f0 26		beq $a42e			beq 	_GXCFail
.c408	a408	20 4b ae	jsr $ae4b			jsr 	GXSortXY 					; topleft/bottomright
.c40b	a40b	20 dc ac	jsr $acdc			jsr 	GXOpenBitmap 				; start drawing
.c40e	a40e	20 00 a5	jsr $a500			jsr 	GXCircleSetup 				; set up for drawing
.c411	a411	9c 9c 09	stz $099c			stz 	gxYChanged
.c414	a414					_GXCircleDraw:
.c414	a414	ad 99 09	lda $0999			lda 	gxxCentre					; while x <= y
.c417	a417	cd 9a 09	cmp $099a			cmp 	gxYCentre
.c41a	a41a	90 0a		bcc $a426			bcc 	_GXCircleContinue
.c41c	a41c	d0 03		bne $a421			bne 	_GXNoLast  					; fix up if x < y
.c41e	a41e	20 33 a4	jsr $a433			jsr 	GXPlot1
.c421	a421					_GXNoLast:
.c421	a421	20 e4 ac	jsr $ace4			jsr 	GXCloseBitmap 				; close the bitmap
.c424	a424	18		clc				clc
.c425	a425	60		rts				rts
.c426	a426					_GXCircleContinue:
.c426	a426	20 30 a4	jsr $a430			jsr 	GXPlot2 					; draw it
.c429	a429	20 ad a4	jsr $a4ad			jsr 	GXCircleMove 				; adjust the coordinates
.c42c	a42c	80 e6		bra $a414			bra 	_GXCircleDraw
.c42e	a42e					_GXCFail:
.c42e	a42e	38		sec				sec
.c42f	a42f	60		rts				rts
.c430	a430					GXPlot2:
.c430	a430	20 33 a4	jsr $a433			jsr 	GXPlot1 						; plot and swap, fall through does twice
.c433	a433					GXPlot1:
.c433	a433	ad 9a 09	lda $099a			lda 	gxYCentre 						; if y = 0, don't do it twice (xor)
.c436	a436	f0 03		beq $a43b			beq 	_GXPlot1Only
.c438	a438	20 57 a4	jsr $a457			jsr 	GXPlot0 						; plot and negate
.c43b	a43b					_GXPlot1Only:
.c43b	a43b	20 57 a4	jsr $a457			jsr 	GXPlot0 						; twice, undoing negation
.c43e	a43e	ad 99 09	lda $0999			lda 	gxxCentre 						; swap X and Y
.c441	a441	ae 9a 09	ldx $099a			ldx	 	gxYCentre
.c444	a444	8d 9a 09	sta $099a			sta 	gxYCentre
.c447	a447	8e 99 09	stx $0999			stx 	gxxCentre
.c44a	a44a	ad 9c 09	lda $099c			lda 	gxYChanged 						; toggle Y Changed flag
.c44d	a44d	a9 ff		lda #$ff			lda 	#$FF
.c44f	a44f	8d 9c 09	sta $099c			sta 	gxYChanged
.c452	a452	60		rts				rts
.c453	a453	20 57 a4	jsr $a457			jsr 	GXPlot0 						; do once
.c456	a456	60		rts				rts
.c457	a457	ad 9b 09	lda $099b	GXPlot0:lda 	gxIsFillMode 					; outline mode, always draw as X or Y will change
.c45a	a45a	f0 05		beq $a461			beq 	_GXPlot0Always
.c45c	a45c	ad 9c 09	lda $099c			lda 	gxYChanged						; fill mode, only draw if changed.
.c45f	a45f	f0 2d		beq $a48e			beq 	GXPlot0Exit
.c461	a461					_GXPlot0Always:
.c461	a461	a2 02		ldx #$02			ldx 	#2 								; copy Y1-A => Y0
.c463	a463	ad 9a 09	lda $099a			lda 	gxYCentre
.c466	a466	20 8f a4	jsr $a48f			jsr 	GXSubCopy
.c469	a469	a2 00		ldx #$00			ldx 	#0 								; copy X1-A => X0,
.c46b	a46b	ad 99 09	lda $0999			lda 	gxxCentre
.c46e	a46e	20 8f a4	jsr $a48f			jsr 	GXSubCopy
.c471	a471	48		pha				pha 									; save last offset X
.c472	a472	20 ec ac	jsr $acec			jsr 	gxPositionCalc 					; calculate position/offset.
.c475	a475	68		pla				pla
.c476	a476	0a		asl a				asl 	a 								; store 2 x last offset in gxzTemp0
.c477	a477	85 36		sta $36				sta 	gxzTemp0
.c479	a479	64 37		stz $37				stz 	gxzTemp0+1
.c47b	a47b	26 37		rol $37				rol 	gxzTemp0+1
.c47d	a47d	ad 9b 09	lda $099b			lda 	gxIsFillMode
.c480	a480	69 80		adc #$80			adc 	#128
.c482	a482	20 d0 a8	jsr $a8d0			jsr 	GXDrawLineTemp0 				; routine from Rectangle.
.c485	a485	38		sec				sec 									; GY = -GY
.c486	a486	a9 00		lda #$00			lda 	#0
.c488	a488	ed 9a 09	sbc $099a			sbc 	gxYCentre
.c48b	a48b	8d 9a 09	sta $099a			sta 	gxYCentre
.c48e	a48e					GXPlot0Exit:
.c48e	a48e	60		rts				rts
.c48f	a48f					GXSubCopy:
.c48f	a48f	85 36		sta $36				sta 	gxzTemp0
.c491	a491	64 37		stz $37				stz 	gxzTemp0+1
.c493	a493	29 80		and #$80			and 	#$80
.c495	a495	f0 02		beq $a499			beq 	_GXNoSx
.c497	a497	c6 37		dec $37				dec 	gxzTemp0+1
.c499	a499					_GXNoSx:
.c499	a499	38		sec				sec
.c49a	a49a	bd fc 08	lda $08fc,x			lda 	gxX1,x
.c49d	a49d	e5 36		sbc $36				sbc 	gxzTemp0
.c49f	a49f	9d f8 08	sta $08f8,x			sta 	gxX0,x
.c4a2	a4a2	bd fd 08	lda $08fd,x			lda 	gxX1+1,x
.c4a5	a4a5	e5 37		sbc $37				sbc 	gxzTemp0+1
.c4a7	a4a7	9d f9 08	sta $08f9,x			sta 	gxX0+1,x
.c4aa	a4aa	a5 36		lda $36				lda 	gxzTemp0 						; return A
.c4ac	a4ac	60		rts				rts
.c4ad	a4ad					GXCircleMove:
.c4ad	a4ad	9c 9c 09	stz $099c			stz 	gxYChanged 					; clear Y changed flag
.c4b0	a4b0	a5 39		lda $39				lda 	gxzTemp1+1 					; check sign of D
.c4b2	a4b2	10 0d		bpl $a4c1			bpl 	_GXEMPositive
.c4b4	a4b4	ee 99 09	inc $0999			inc 	gxxCentre 					; X++
.c4b7	a4b7	ad 99 09	lda $0999			lda 	gxxCentre
.c4ba	a4ba	20 e0 a4	jsr $a4e0			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c4bd	a4bd	a9 06		lda #$06			lda 	#6  						; and add 6
.c4bf	a4bf	80 15		bra $a4d6			bra 	_GXEMAddD
.c4c1	a4c1					_GXEMPositive:
.c4c1	a4c1	ee 99 09	inc $0999			inc 	gxxCentre					; X++
.c4c4	a4c4	ce 9a 09	dec $099a			dec 	gxYCentre 					; Y--
.c4c7	a4c7	38		sec				sec 								; calculate X-Y
.c4c8	a4c8	ad 99 09	lda $0999			lda 	gxxCentre
.c4cb	a4cb	ed 9a 09	sbc $099a			sbc 	gxYCentre
.c4ce	a4ce	20 e0 a4	jsr $a4e0			jsr 	_GXAdd4TimesToD 			; add 4 x A to D
.c4d1	a4d1	a9 0a		lda #$0a			lda 	#10  						; and add 10
.c4d3	a4d3	ce 9c 09	dec $099c			dec 	gxYChanged
.c4d6	a4d6					_GXEMAddD:
.c4d6	a4d6	18		clc				clc
.c4d7	a4d7	65 38		adc $38				adc 	gxzTemp1
.c4d9	a4d9	85 38		sta $38				sta 	gxzTemp1
.c4db	a4db	90 02		bcc $a4df			bcc 	_GXEMNoCarry
.c4dd	a4dd	e6 39		inc $39				inc 	gxzTemp1+1
.c4df	a4df					_GXEMNoCarry:
.c4df	a4df	60		rts				rts
.c4e0	a4e0					_GXAdd4TimesToD:
.c4e0	a4e0	85 36		sta $36				sta 	gxzTemp0 					; make 16 bit signed.
.c4e2	a4e2	29 80		and #$80			and 	#$80
.c4e4	a4e4	f0 02		beq $a4e8			beq 	_GXA4Unsigned
.c4e6	a4e6	a9 ff		lda #$ff			lda 	#$FF
.c4e8	a4e8					_GXA4Unsigned:
.c4e8	a4e8	85 37		sta $37				sta 	gxzTemp0+1
.c4ea	a4ea	06 36		asl $36				asl 	gxzTemp0  					; x 4
.c4ec	a4ec	26 37		rol $37				rol 	gxzTemp0+1
.c4ee	a4ee	06 36		asl $36				asl 	gxzTemp0
.c4f0	a4f0	26 37		rol $37				rol 	gxzTemp0+1
.c4f2	a4f2	18		clc				clc 								; add
.c4f3	a4f3	a5 36		lda $36				lda		gxzTemp0
.c4f5	a4f5	65 38		adc $38				adc 	gxzTemp1
.c4f7	a4f7	85 38		sta $38				sta 	gxzTemp1
.c4f9	a4f9	a5 37		lda $37				lda		gxzTemp0+1
.c4fb	a4fb	65 39		adc $39				adc 	gxzTemp1+1
.c4fd	a4fd	85 39		sta $39				sta 	gxzTemp1+1
.c4ff	a4ff	60		rts				rts
.c500	a500					GXCircleSetup:
.c500	a500	38		sec				sec
.c501	a501	ad fe 08	lda $08fe			lda 	gxY1
.c504	a504	ed fa 08	sbc $08fa			sbc 	gxY0
.c507	a507	4a		lsr a				lsr 	a
.c508	a508	8d 98 09	sta $0998			sta 	gxRadius
.c50b	a50b	a2 00		ldx #$00			ldx 	#0
.c50d	a50d	20 2f a5	jsr $a52f			jsr 	_GXCalculateCentre
.c510	a510	a2 02		ldx #$02			ldx 	#2
.c512	a512	20 2f a5	jsr $a52f			jsr 	_GXCalculateCentre
.c515	a515	9c 99 09	stz $0999			stz 	gxxCentre
.c518	a518	ad 98 09	lda $0998			lda 	gxRadius
.c51b	a51b	8d 9a 09	sta $099a			sta 	gxYCentre
.c51e	a51e	0a		asl a				asl 	a 							; R x 2
.c51f	a51f	85 36		sta $36				sta 	gxzTemp0
.c521	a521	38		sec				sec
.c522	a522	a9 03		lda #$03			lda 	#3
.c524	a524	e5 36		sbc $36				sbc 	gxzTemp0
.c526	a526	85 38		sta $38				sta 	gxzTemp1
.c528	a528	a9 00		lda #$00			lda 	#0
.c52a	a52a	e9 00		sbc #$00			sbc 	#0
.c52c	a52c	85 39		sta $39				sta 	gxzTemp1+1
.c52e	a52e	60		rts				rts
.c52f	a52f					_GXCalculateCentre:
.c52f	a52f	38		sec				sec
.c530	a530	bd fc 08	lda $08fc,x			lda 	gxX1,x
.c533	a533	7d f8 08	adc $08f8,x			adc 	gxX0,x
.c536	a536	9d fc 08	sta $08fc,x			sta 	gxX1,x
.c539	a539	bd fd 08	lda $08fd,x			lda 	gxX1+1,x
.c53c	a53c	7d f9 08	adc $08f9,x			adc 	gxX0+1,x
.c53f	a53f	4a		lsr a				lsr 	a
.c540	a540	9d fd 08	sta $08fd,x			sta 	gxX1+1,x
.c543	a543	7e fc 08	ror $08fc,x			ror 	gxX1,x
.c546	a546	60		rts				rts
.0998						gxRadius:
>0998								.fill 	1
.0999						gxxCentre:
>0999								.fill 	1
.099a						gxYCentre:
>099a								.fill 	1
.099b						gxIsFillMode:
>099b								.fill 	1
.099c						gxYChanged:
>099c								.fill  	1
=64000						ScreenSize200 = 320 * 200
=76800						ScreenSize240 = 320 * 240
.c547	a547					GXClearBitmap:
.c547	a547	ad 01 09	lda $0901			lda 	gxBitmapsOn 				; check BMP turned on.
.c54a	a54a	f0 26		beq $a572			beq 	_GXCBFail
.c54c	a54c	20 dc ac	jsr $acdc			jsr 	GXOpenBitmap 				; start access
.c54f	a54f	a0 07		ldy #$07			ldy 	#ScreenSize200 / 8192 		; X is pages to clear as 2 graphic heights.
.c551	a551	ad 09 09	lda $0909			lda 	gxHeight
.c554	a554	c9 c8		cmp #$c8			cmp 	#200 						; 200 ?
.c556	a556	f0 02		beq $a55a			beq 	_GXCalcLastPage
.c558	a558	a0 09		ldy #$09			ldy 	#ScreenSize240 / 8192
.c55a	a55a					_GXCalcLastPage:
.c55a	a55a	98		tya				tya 								; add to base page
.c55b	a55b	18		clc				clc
.c55c	a55c	6d 03 09	adc $0903			adc 	gxBasePage
.c55f	a55f	85 0b		sta $0b				sta 	GXEditSlot  				; clear from this page back
.c561	a561					_GXClearAll:
.c561	a561	20 74 a5	jsr $a574			jsr 	_GXClearBlock 				; clear 8k block
.c564	a564	c6 0b		dec $0b				dec 	GXEditSlot  				; back to previous
.c566	a566	a5 0b		lda $0b				lda 	GXEditSlot
.c568	a568	cd 03 09	cmp $0903			cmp 	gxBasePage 					; until before base page
.c56b	a56b	b0 f4		bcs $a561			bcs 	_GXClearAll
.c56d	a56d	20 e4 ac	jsr $ace4			jsr 	GXCloseBitmap	 			; stop access
.c570	a570	18		clc				clc
.c571	a571	60		rts				rts
.c572	a572					_GXCBFail:
.c572	a572	38		sec				sec
.c573	a573	60		rts				rts
.c574	a574					_GXClearBlock:
.c574	a574	a9 00		lda #$00			lda 	#((GXMappingAddress) & $FF)
.c576	a576	85 38		sta $38				sta 	0+gxzTemp1
.c578	a578	a9 60		lda #$60			lda 	#((GXMappingAddress) >> 8)
.c57a	a57a	85 39		sta $39				sta 	1+gxzTemp1
.c57c	a57c					_GXCB0:
.c57c	a57c	a5 36		lda $36				lda 	gxzTemp0 					; clear colour
.c57e	a57e	a0 00		ldy #$00			ldy 	#0
.c580	a580					_GXCB1:
.c580	a580	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c582	a582	c8		iny				iny
.c583	a583	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c585	a585	c8		iny				iny
.c586	a586	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c588	a588	c8		iny				iny
.c589	a589	91 38		sta ($38),y			sta 	(gxzTemp1),y
.c58b	a58b	c8		iny				iny
.c58c	a58c	d0 f2		bne $a580			bne 	_GXCB1
.c58e	a58e	e6 39		inc $39				inc 	gxzTemp1+1
.c590	a590	a5 39		lda $39				lda 	gxzTemp1+1
.c592	a592	c9 80		cmp #$80			cmp	 	#(GXMappingAddress >> 8)+$20
.c594	a594	d0 e6		bne $a57c			bne 	_GXCB0
.c596	a596	60		rts				rts
.c597	a597					GXInitialise:
.c597	a597	64 01		stz $01				stz 	1 							; access I/O
.c599	a599	a9 01		lda #$01			lda 	#1 							; reset bitmap address
.c59b	a59b	8d 00 d0	sta $d000			sta 	$D000
.c59e	a59e	18		clc				clc
.c59f	a59f	9c 00 09	stz $0900			stz 	gxSpritesOn					; sprites/bitmaps/tiles off.
.c5a2	a5a2	9c 01 09	stz $0901			stz 	gxBitmapsOn
.c5a5	a5a5	9c 02 09	stz $0902			stz 	gxTilesOn
.c5a8	a5a8	a2 0f		ldx #$0f			ldx 	#15 						; erase work area
.c5aa	a5aa					_GXIClear:
.c5aa	a5aa	9e f0 08	stz $08f0,x			stz 	gxCurrentX,x
.c5ad	a5ad	ca		dex				dex
.c5ae	a5ae	10 fa		bpl $a5aa			bpl 	_GXIClear
.c5b0	a5b0	20 f7 a6	jsr $a6f7			jsr 	GXClearSpriteStore 			; clear sprite backup space.
.c5b3	a5b3	a9 40		lda #$40			lda 	#$40                   		; Layer 0 = Bitmap 0, Layer 1 = Tile map 0
.c5b5	a5b5	8d 02 d0	sta $d002			sta 	$D002
.c5b8	a5b8	a9 15		lda #$15			lda 	#$15                   		; Layer 2 = Tile Map 1
.c5ba	a5ba	8d 03 d0	sta $d003			sta 	$D003
.c5bd	a5bd	60		rts				rts
.c5be	a5be					GXControlBitmap:
.c5be	a5be	64 01		stz $01				stz 	1
.c5c0	a5c0	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c5c2	a5c2	29 01		and #$01			and 	#1 							; get bitmap flag (is enabled)
.c5c4	a5c4	8d 01 09	sta $0901			sta 	gxBitmapsOn
.c5c7	a5c7	4a		lsr a				lsr 	a 							; bit 0 into carry.
.c5c8	a5c8	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c5cb	a5cb	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c5cd	a5cd	29 f7		and #$f7			and 	#$F7 						; clear bitmap bit
.c5cf	a5cf	90 02		bcc $a5d3			bcc 	_CBNotOn
.c5d1	a5d1	09 08		ora #$08			ora 	#$08 						; bitmap on if 1 on 0 off
.c5d3	a5d3					_CBNotOn:
.c5d3	a5d3	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c5d6	a5d6	a5 36		lda $36				lda 	gxzTemp0 					; get control settings (bits 0-2)
.c5d8	a5d8	29 07		and #$07			and 	#7
.c5da	a5da	8d 00 d1	sta $d100			sta 	$D100 						; write in Vicky Bitmap Control Register #0
.c5dd	a5dd	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page requested
.c5df	a5df	d0 02		bne $a5e3			bne 	_CBNotDefault
.c5e1	a5e1	a9 08		lda #$08			lda 	#8  						; if zero, use default 8 e.g. bitmap at $10000
.c5e3	a5e3					_CBNotDefault:
.c5e3	a5e3	8d 03 09	sta $0903			sta 	gxBasePage 					; save as bitmap base page.
.c5e6	a5e6	20 e9 a6	jsr $a6e9			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c5e9	a5e9	a5 37		lda $37				lda 	gxzTemp0+1 					; copy address into Bitmap address registers
.c5eb	a5eb	8d 03 d1	sta $d103			sta 	$D103
.c5ee	a5ee	a5 36		lda $36				lda 	gxzTemp0
.c5f0	a5f0	8d 02 d1	sta $d102			sta 	$D102
.c5f3	a5f3	9c 01 d1	stz $d101			stz 	$D101
.c5f6	a5f6	a2 f0		ldx #$f0			ldx 	#240 						; height is 240 or 200 ?
.c5f8	a5f8	ad 01 d0	lda $d001			lda 	$D001 						; read MCR bit 0
.c5fb	a5fb	29 01		and #$01			and 	#1
.c5fd	a5fd	f0 02		beq $a601			beq 	_CBHaveHeight
.c5ff	a5ff	a2 c8		ldx #$c8			ldx 	#200 						; if bit 0 set 320x200
.c601	a601					_CBHaveHeight
.c601	a601	8e 09 09	stx $0909			stx 	gxHeight
.c604	a604	18		clc				clc
.c605	a605	60		rts				rts
.c606	a606					GXControlSprite:
.c606	a606	64 01		stz $01				stz 	1
.c608	a608	a5 36		lda $36				lda 	gxzTemp0 					; get control bits
.c60a	a60a	29 01		and #$01			and 	#1 							; set sprites flag
.c60c	a60c	8d 00 09	sta $0900			sta 	gxSpritesOn
.c60f	a60f	4a		lsr a				lsr 	a 							; bit 0 into carry
.c610	a610	ad 00 d0	lda $d000			lda 	$D000 						; read Vicky MCR
.c613	a613	09 07		ora #$07			ora 	#7 							; turn graphics, text, textoverlay on.
.c615	a615	29 df		and #$df			and 	#$DF 						; clear sprite bit
.c617	a617	90 02		bcc $a61b			bcc 	_CSNotOn
.c619	a619	09 20		ora #$20			ora 	#$20 						; sprite on if 1 on 0 off
.c61b	a61b					_CSNotOn:
.c61b	a61b	8d 00 d0	sta $d000			sta 	$D000 						; update Vicky MCR
.c61e	a61e	a5 37		lda $37				lda 	gxzTemp0+1 					; get the base page
.c620	a620	d0 02		bne $a624			bne 	_CSNotDefault
.c622	a622	a9 18		lda #$18			lda 	#24  						; if zero, use 24 e.g. sprites at $30000
.c624	a624					_CSNotDefault:
.c624	a624	8d 04 09	sta $0904			sta 	gxSpritePage
.c627	a627	20 e9 a6	jsr $a6e9			jsr 	GXCalculateBaseAddress 	 	; convert page# to address
.c62a	a62a	a5 36		lda $36				lda 	gxzTemp0 					; save this so we know where the sprites are.
.c62c	a62c	8d 13 09	sta $0913			sta 	gxSpriteOffsetBase
.c62f	a62f	a5 37		lda $37				lda 	gxzTemp0+1
.c631	a631	8d 14 09	sta $0914			sta 	gxSpriteOffsetBase+1
.c634	a634	a2 00		ldx #$00			ldx 	#0 							; disable all sprites, clears all sprite memory.
.c636	a636					_CSClear:
.c636	a636	9e 00 d9	stz $d900,x			stz 	$D900,x
.c639	a639	9e 00 da	stz $da00,x			stz 	$DA00,x
.c63c	a63c	ca		dex				dex
.c63d	a63d	d0 f7		bne $a636			bne 	_CSClear
.c63f	a63f	9c 12 09	stz $0912			stz 	GSCurrentSpriteAddr+1 		; no sprite selected.
.c642	a642	20 f7 a6	jsr $a6f7			jsr 	GXClearSpriteStore
.c645	a645	18		clc				clc
.c646	a646	60		rts				rts
.c647	a647					GXControlTilemap:
.c647	a647	64 01		stz $01				stz 	1 							; access I/O
.c649	a649	a5 36		lda $36				lda 	gxzTemp0 					; get the Map Page/Enable
.c64b	a64b	30 0d		bmi $a65a			bmi 	_GXCTOn
.c64d	a64d	ad 00 d0	lda $d000			lda 	$D000 						; turn off bitmap enable bit in MCR
.c650	a650	29 ef		and #$ef			and 	#$EF 						; clear bit 4
.c652	a652	8d 00 d0	sta $d000			sta 	$D000
.c655	a655	9c 02 09	stz $0902			stz 	gxTilesOn 					; clear tiles on flag.
.c658	a658	18		clc				clc
.c659	a659	60		rts				rts
.c65a	a65a					_GXCTOn:
.c65a	a65a	8d 02 09	sta $0902			sta 	gxTilesOn 					; set tiles on flag.
.c65d	a65d	ad 00 d0	lda $d000			lda 	$D000	 					; turn tilemap on
.c660	a660	09 17		ora #$17			ora 	#$17
.c662	a662	8d 00 d0	sta $d000			sta 	$D000
.c665	a665	9c 0c d2	stz $d20c			stz 	$D20C 						; turn off tilemap#1 and tilemap#2
.c668	a668	9c 18 d2	stz $d218			stz 	$D218
.c66b	a66b	a9 40		lda #$40			lda 	#64 						; default size of 64x32
.c66d	a66d	8d 07 09	sta $0907			sta 	gxTileMapWidth
.c670	a670	a9 20		lda #$20			lda		#32
.c672	a672	8d 08 09	sta $0908			sta 	gxTileMapHeight
.c675	a675	ad 02 09	lda $0902			lda 	gxTilesOn 					; set the tile map page
.c678	a678	29 7f		and #$7f			and 	#$7F
.c67a	a67a	d0 02		bne $a67e			bne	 	_GXCTNotMapDefault 			; check for default
.c67c	a67c	a9 12		lda #$12			lda 	#TILEMAP_ADDRESS >> 13
.c67e	a67e					_GXCTNotMapDefault:
.c67e	a67e	8d 06 09	sta $0906			sta 	gxTileMapPage
.c681	a681	a5 37		lda $37				lda 	gxzTemp0+1 					; set the tile image page
.c683	a683	d0 02		bne $a687			bne 	_GXCTNotImgDefault 			; check for default
.c685	a685	a9 13		lda #$13			lda 	#TILEIMAGES_ADDRESS >> 13
.c687	a687					_GXCTNotImgDefault:
.c687	a687	8d 05 09	sta $0905			sta 	gxTileImagePage
.c68a	a68a	a9 11		lda #$11			lda 	#$11 						; set tilemap#0 on and 8x8
.c68c	a68c	8d 00 d2	sta $d200			sta 	$D200
.c68f	a68f	ad 06 09	lda $0906			lda 	gxTileMapPage 				; put tile map address in.
.c692	a692	20 e9 a6	jsr $a6e9			jsr		GXCalculateBaseAddress
.c695	a695	9c 01 d2	stz $d201			stz 	$D201
.c698	a698	a5 36		lda $36				lda 	gxzTemp0
.c69a	a69a	8d 02 d2	sta $d202			sta 	$D202
.c69d	a69d	a5 37		lda $37				lda 	gxzTemp0+1
.c69f	a69f	8d 03 d2	sta $d203			sta 	$D203
.c6a2	a6a2	ad 07 09	lda $0907			lda 	gxTileMapWidth	 			; set tilemap size.
.c6a5	a6a5	8d 04 d2	sta $d204			sta 	$D204
.c6a8	a6a8	ad 08 09	lda $0908			lda 	gxTileMapHeight
.c6ab	a6ab	8d 06 d2	sta $d206			sta 	$D206
.c6ae	a6ae	9c 08 d2	stz $d208			stz 	$D208 						; clear scrolling register
.c6b1	a6b1	9c 09 d2	stz $d209			stz 	$D209
.c6b4	a6b4	9c 0a d2	stz $d20a			stz 	$D20A
.c6b7	a6b7	9c 0b d2	stz $d20b			stz 	$D20B
.c6ba	a6ba	ad 05 09	lda $0905			lda 	gxTileImagePage 			; set the tile image address
.c6bd	a6bd	20 e9 a6	jsr $a6e9			jsr 	GXCalculateBaseAddress
.c6c0	a6c0	9c 80 d2	stz $d280			stz 	$D280
.c6c3	a6c3	a5 36		lda $36				lda 	gxzTemp0
.c6c5	a6c5	8d 81 d2	sta $d281			sta 	$D281
.c6c8	a6c8	a5 37		lda $37				lda 	gxzTemp0+1
.c6ca	a6ca	8d 82 d2	sta $d282			sta 	$D282
.c6cd	a6cd	18		clc				clc
.c6ce	a6ce	60		rts				rts
.c6cf	a6cf					GXControlTileSize:
.c6cf	a6cf	ad 02 09	lda $0902			lda 	gxTilesOn 					; check on
.c6d2	a6d2	38		sec				sec
.c6d3	a6d3	f0 13		beq $a6e8			beq 	_GXCTSExit
.c6d5	a6d5	64 01		stz $01				stz 	1 							; access I/O 0
.c6d7	a6d7	a5 36		lda $36				lda 	gxzTemp0 					; save parameter to registes
.c6d9	a6d9	8d 07 09	sta $0907			sta 	gxTileMapWidth
.c6dc	a6dc	8d 04 d2	sta $d204			sta 	$D204
.c6df	a6df	a5 37		lda $37				lda 	gxzTemp0+1
.c6e1	a6e1	8d 08 09	sta $0908			sta 	gxTileMapHeight
.c6e4	a6e4	8d 06 d2	sta $d206			sta 	$D206
.c6e7	a6e7	18		clc				clc
.c6e8	a6e8					_GXCTSExit:
.c6e8	a6e8	60		rts				rts
.c6e9	a6e9					GXCalculateBaseAddress:
.c6e9	a6e9	85 36		sta $36				sta 	gxzTemp0
.c6eb	a6eb	64 37		stz $37				stz 	gxzTemp0+1
.c6ed	a6ed	a9 05		lda #$05			lda 	#5
.c6ef	a6ef					_GXShift:
.c6ef	a6ef	06 36		asl $36				asl 	gxzTemp0
.c6f1	a6f1	26 37		rol $37				rol 	gxzTemp0+1
.c6f3	a6f3	3a		dec a				dec		a
.c6f4	a6f4	d0 f9		bne $a6ef			bne 	_GXShift
.c6f6	a6f6	60		rts				rts
.c6f7	a6f7					GXClearSpriteStore:
.c6f7	a6f7	a2 3f		ldx #$3f			ldx 	#63 						; erase 64 sprite store elements
.c6f9	a6f9					_GXCSSLoop:
.c6f9	a6f9	9e 55 09	stz $0955,x			stz 	gxSpriteHigh,x
.c6fc	a6fc	a9 80		lda #$80			lda 	#$80 						; set the 'hidden' bit.
.c6fe	a6fe	9d 15 09	sta $0915,x			sta 	gxSpriteLow,x
.c701	a701	ca		dex				dex
.c702	a702	10 f5		bpl $a6f9			bpl 	_GXCSSLoop
.c704	a704	60		rts				rts
.c705	a705					GXLine:
.c705	a705	ad 01 09	lda $0901			lda 	gxBitmapsOn					; check bitmap on.
.c708	a708	f0 28		beq $a732			beq 	_GXLFail
.c70a	a70a	20 dc ac	jsr $acdc			jsr 	GXOpenBitmap 				; access it.
.c70d	a70d	20 69 ae	jsr $ae69			jsr 	GXSortY						; sort pairs so Y1 >= Y0 e.g. top to bottom.
.c710	a710	20 d8 a7	jsr $a7d8			jsr 	GXLineSetup 				; the calculations in the linescanner constructor
.c713	a713	20 ec ac	jsr $acec			jsr 	gxPositionCalc 				; calculate position/offset.
.c716	a716					_GXDrawLoop:
.c716	a716	ac 0f 09	ldy $090f			ldy 	gxOffset 					; draw the pixel
.c719	a719	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c71b	a71b	2d 0d 09	and $090d			and 	gxANDValue
.c71e	a71e	4d 0c 09	eor $090c			eor 	gxEORValue
.c721	a721	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c723	a723	20 34 a7	jsr $a734			jsr 	GXLineIsComplete 			; is the line complete ?
.c726	a726	f0 05		beq $a72d			beq 	_GXLExit
.c728	a728	20 4f a7	jsr $a74f			jsr 	GXLineAdvance 				; code as per advance method
.c72b	a72b	80 e9		bra $a716			bra 	_GXDrawLoop
.c72d	a72d					_GXLExit:
.c72d	a72d	20 e4 ac	jsr $ace4			jsr 	GXCloseBitmap 				; restore and return success.
.c730	a730	18		clc				clc
.c731	a731	60		rts				rts
.c732	a732					_GXLFail:
.c732	a732	38		sec				sec
.c733	a733	60		rts				rts
.c734	a734					GXLineIsComplete:
.c734	a734	ad 9f 09	lda $099f			lda 	gxIsDiffYLarger 			; is dy larger
.c737	a737	d0 0f		bne $a748			bne 	_GXLICCompareY 				; if so compare Y1 versus Y0
.c739	a739	ad f8 08	lda $08f8			lda 	gxX0 						; compare X, LSB and MSB
.c73c	a73c	4d fc 08	eor $08fc			eor 	gxX1
.c73f	a73f	d0 06		bne $a747			bne 	_GXLICExit
.c741	a741	ad f9 08	lda $08f9			lda 	gxX0+1
.c744	a744	4d fd 08	eor $08fd			eor 	gxX1+1
.c747	a747					_GXLICExit:
.c747	a747	60		rts				rts
.c748	a748					_GXLICCompareY:
.c748	a748	ad fe 08	lda $08fe			lda 	gxY1
.c74b	a74b	4d fa 08	eor $08fa			eor 	gxY0
.c74e	a74e	60		rts				rts
.c74f	a74f					GXLineAdvance:
.c74f	a74f	18		clc				clc 								; add adjust to position
.c750	a750	ad a1 09	lda $09a1			lda 	gxPosition
.c753	a753	6d a2 09	adc $09a2			adc 	gxAdjust
.c756	a756	8d a1 09	sta $09a1			sta 	gxPosition
.c759	a759	9c a4 09	stz $09a4			stz 	gxAddSelect 				; clear add select flag
.c75c	a75c	b0 05		bcs $a763			bcs 	_GXLAOverflow 				; if carry out, overflowed.
.c75e	a75e	cd a3 09	cmp $09a3			cmp 	gxTotal 					; if exceeded total
.c761	a761	90 0a		bcc $a76d			bcc 	_GXLANoExtra
.c763	a763					_GXLAOverflow:
.c763	a763	ce a4 09	dec $09a4			dec 	gxAddSelect 				; set addselect to $FF
.c766	a766	38		sec				sec 								; subtract total and write back
.c767	a767	ed a3 09	sbc $09a3			sbc 	gxTotal
.c76a	a76a	8d a1 09	sta $09a1			sta 	gxPosition
.c76d	a76d					_GXLANoExtra:
.c76d	a76d	ad 9f 09	lda $099f			lda 	gxIsDiffYLarger
.c770	a770	f0 0d		beq $a77f			beq 	_GXDXLarger
.c772	a772	20 d1 a7	jsr $a7d1			jsr 	GXIncrementY
.c775	a775	ad a4 09	lda $09a4			lda 	gxAddSelect
.c778	a778	f0 10		beq $a78a			beq 	_GXLAExit
.c77a	a77a	20 8b a7	jsr $a78b			jsr 	gxAdjustX
.c77d	a77d	80 0b		bra $a78a			bra 	_GXLAExit
.c77f	a77f					_GXDXLarger:
.c77f	a77f	20 8b a7	jsr $a78b			jsr 	gxAdjustX
.c782	a782	ad a4 09	lda $09a4			lda 	gxAddSelect
.c785	a785	f0 03		beq $a78a			beq 	_GXLAExit
.c787	a787	20 d1 a7	jsr $a7d1			jsr 	GXIncrementY
.c78a	a78a					_GXLAExit:
.c78a	a78a	60		rts				rts
.c78b	a78b					gxAdjustX:
.c78b	a78b	ad a0 09	lda $09a0			lda 	gxDXNegative
.c78e	a78e	10 25		bpl $a7b5			bpl 	_GXAXRight
.c790	a790	ad f8 08	lda $08f8			lda 	gxX0
.c793	a793	d0 03		bne $a798			bne 	_GXAXNoBorrow
.c795	a795	ce f9 08	dec $08f9			dec 	gxX0+1
.c798	a798					_GXAXNoBorrow:
.c798	a798	ce f8 08	dec $08f8			dec 	gxX0
.c79b	a79b	ce 0f 09	dec $090f			dec 	gxOffset 					; pixel left
.c79e	a79e	ad 0f 09	lda $090f			lda 	gxOffset
.c7a1	a7a1	c9 ff		cmp #$ff			cmp 	#$FF
.c7a3	a7a3	d0 0f		bne $a7b4			bne 	_GXAYExit 					; underflow
.c7a5	a7a5	c6 3d		dec $3d				dec 	gxzScreen+1 					; borrow
.c7a7	a7a7	a5 3d		lda $3d				lda 	gxzScreen+1 					; gone off page
.c7a9	a7a9	c9 60		cmp #$60			cmp 	#GXMappingAddress >> 8
.c7ab	a7ab	b0 07		bcs $a7b4			bcs 	_GXAYExit
.c7ad	a7ad	18		clc				clc
.c7ae	a7ae	69 20		adc #$20			adc 	#$20 						; fix up
.c7b0	a7b0	85 3d		sta $3d				sta 	gxzScreen+1
.c7b2	a7b2	c6 0b		dec $0b				dec 	GXEditSlot 				; back one page
.c7b4	a7b4					_GXAYExit:
.c7b4	a7b4	60		rts				rts
.c7b5	a7b5					_GXAXRight:
.c7b5	a7b5	ee f8 08	inc $08f8			inc 	gxX0
.c7b8	a7b8	d0 03		bne $a7bd			bne 	_GXAXNoCarry
.c7ba	a7ba	ee f9 08	inc $08f9			inc 	gxX0+1
.c7bd	a7bd					_GXAXNoCarry:
.c7bd	a7bd	ee 0f 09	inc $090f			inc 	gxOffset 					; pixel right
.c7c0	a7c0	d0 0e		bne $a7d0			bne 	_GXAXExit 					; if not overflowed, exit.
.c7c2	a7c2	e6 3d		inc $3d				inc 	gxzScreen+1 					; next line
.c7c4	a7c4	a5 3d		lda $3d				lda 	gxzScreen+1
.c7c6	a7c6	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.c7c8	a7c8	90 06		bcc $a7d0			bcc 	_GXAXExit
.c7ca	a7ca	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c7cc	a7cc	85 3d		sta $3d				sta 	gxzScreen+1
.c7ce	a7ce	e6 0b		inc $0b				inc 	GXEditSlot 				; next page
.c7d0	a7d0					_GXAXExit:
.c7d0	a7d0	60		rts				rts
.c7d1	a7d1					GXIncrementY:
.c7d1	a7d1	ee fa 08	inc $08fa			inc 	gxY0
.c7d4	a7d4	20 42 ad	jsr $ad42			jsr 	GXMovePositionDown
.c7d7	a7d7	60		rts				rts
.c7d8	a7d8					GXLineSetup:
.c7d8	a7d8	ad fe 08	lda $08fe			lda 	gxY1
.c7db	a7db	38		sec				sec
.c7dc	a7dc	ed fa 08	sbc $08fa			sbc 	gxY0
.c7df	a7df	4a		lsr a				lsr 	a
.c7e0	a7e0	8d 9e 09	sta $099e			sta 	gxDiffY
.c7e3	a7e3	9c a0 09	stz $09a0			stz 	gxDXNegative 				; clear -ve flag
.c7e6	a7e6	38		sec				sec
.c7e7	a7e7	ad fc 08	lda $08fc			lda 	gxX1
.c7ea	a7ea	ed f8 08	sbc $08f8			sbc 	gxX0
.c7ed	a7ed	8d 9d 09	sta $099d			sta 	gxDiffX
.c7f0	a7f0	ad fd 08	lda $08fd			lda 	gxX1+1 						; calculate MSB
.c7f3	a7f3	ed f9 08	sbc $08f9			sbc 	gxX0+1
.c7f6	a7f6	6a		ror a				ror 	a 							; rotate bit into DiffX halving it
.c7f7	a7f7	6e 9d 09	ror $099d			ror 	gxDiffX
.c7fa	a7fa	0a		asl a				asl 	a
.c7fb	a7fb	10 0c		bpl $a809			bpl 	_GDXNotNegative
.c7fd	a7fd	a9 00		lda #$00			lda 	#0 							; make absolute value of |dx|
.c7ff	a7ff	38		sec				sec
.c800	a800	ed 9d 09	sbc $099d			sbc 	gxDiffX
.c803	a803	8d 9d 09	sta $099d			sta 	gxDiffX
.c806	a806	ce a0 09	dec $09a0			dec 	gxDXNegative 				; -ve flag = $FF.
.c809	a809					_GDXNotNegative:
.c809	a809	9c 9f 09	stz $099f			stz 	gxIsDiffYLarger 			; clear larger flag
.c80c	a80c	ad 9e 09	lda $099e			lda 	gxDiffY 					; set adjust and total.
.c80f	a80f	8d a2 09	sta $09a2			sta 	gxAdjust
.c812	a812	ad 9d 09	lda $099d			lda 	gxDiffX
.c815	a815	8d a3 09	sta $09a3			sta 	gxTotal
.c818	a818	ad 9e 09	lda $099e			lda 	gxDiffY 					; if dy > dx
.c81b	a81b	cd 9d 09	cmp $099d			cmp 	gxDiffX
.c81e	a81e	90 0f		bcc $a82f			bcc 	_GDXNotLarger
.c820	a820	ce 9f 09	dec $099f			dec 	gxIsDiffYLarger 			; set the dy larger flag
.c823	a823	ad 9d 09	lda $099d			lda 	gxDiffX 					; set adjust and total other way round
.c826	a826	8d a2 09	sta $09a2			sta 	gxAdjust
.c829	a829	ad 9e 09	lda $099e			lda 	gxDiffY
.c82c	a82c	8d a3 09	sta $09a3			sta 	gxTotal
.c82f	a82f					_GDXNotLarger:
.c82f	a82f	ad a3 09	lda $09a3			lda 	gxTotal
.c832	a832	4a		lsr a				lsr 	a
.c833	a833	8d a1 09	sta $09a1			sta 	gxPosition
.c836	a836	60		rts				rts
.099d						gxDiffX:
>099d								.fill 	1
.099e						gxDiffY:
>099e								.fill 	1
.099f						gxIsDiffYLarger:
>099f								.fill 	1
.09a0						gxDXNegative:
>09a0								.fill 	1
.09a1						gxPosition:
>09a1								.fill 	1
.09a2						gxAdjust:
>09a2								.fill 	1
.09a3						gxTotal:
>09a3								.fill 	1
.09a4						gxAddSelect:
>09a4								.fill 	1
.c837	a837					GXSetColourMode:
.c837	a837	a6 36		ldx $36				ldx 	gxzTemp0
.c839	a839	8e 0b 09	stx $090b			stx 	gxColour 								; set colour
.c83c	a83c	a5 37		lda $37				lda 	gxzTemp0+1 								;
.c83e	a83e	8d 0a 09	sta $090a			sta 	gxMode 									; set mode
.c841	a841	29 03		and #$03			and 	#3 										; only interested in bits 0-3
.c843	a843	9c 0d 09	stz $090d			stz 	gxANDValue 								; initially AND with 0, and EOR with Colour
.c846	a846	ae 0b 09	ldx $090b			ldx 	gxColour
.c849	a849	8e 0c 09	stx $090c			stx 	gxEORValue
.c84c	a84c	c9 02		cmp #$02			cmp 	#2 										; if mode 2/3 And with colour
.c84e	a84e	90 03		bcc $a853			bcc 	_GXSDCNotAndColour
.c850	a850	8e 0d 09	stx $090d			stx 	gxANDValue
.c853	a853					_GXSDCNotAndColour:
.c853	a853	d0 03		bne $a858			bne 	_GXSDCNotAnd 							; mode 2, Don't EOR with colour
.c855	a855	9c 0c 09	stz $090c			stz 	gxEORValue
.c858	a858					_GXSDCNotAnd:
.c858	a858	4a		lsr a				lsr 	a 										; if bit 0 set, 1's complement AND value
.c859	a859	90 08		bcc $a863			bcc 	_GXSDCNoFlip
.c85b	a85b	ad 0d 09	lda $090d			lda	 	gxANDValue
.c85e	a85e	49 ff		eor #$ff			eor 	#$FF
.c860	a860	8d 0d 09	sta $090d			sta 	gxANDValue
.c863	a863					_GXSDCNoFlip:
.c863	a863	18		clc				clc
.c864	a864	60		rts				rts
.c865	a865					GXPlotPoint:
.c865	a865	20 dc ac	jsr $acdc			jsr 	GXOpenBitmap 				; start drawing
.c868	a868	20 ec ac	jsr $acec			jsr 	gxPositionCalc 				; setup gxzScreen, gxOffset and the position.
.c86b	a86b	ac 0f 09	ldy $090f			ldy 	gxOffset
.c86e	a86e	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 				; set pixel on the right
.c870	a870	2d 0d 09	and $090d			and 	gxANDValue
.c873	a873	4d 0c 09	eor $090c			eor 	gxEORValue
.c876	a876	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c878	a878	20 e4 ac	jsr $ace4			jsr 	GXCloseBitmap 				; stop drawing and exit
.c87b	a87b	18		clc				clc
.c87c	a87c	60		rts				rts
.c87d	a87d					GXFillRectangle:
.c87d	a87d	38		sec				sec 								; pass carry in for fill/frame
.c87e	a87e	80 01		bra $a881			bra 	GXRectangle
.c880	a880					GXFrameRectangle:
.c880	a880	18		clc				clc
.c881	a881					GXRectangle:
.c881	a881	ad 01 09	lda $0901			lda 	gxBitmapsOn 				; exit if off.
.c884	a884	f0 35		beq $a8bb			beq 	_GXRFail
.c886	a886	08		php				php 								; save Fill flag (CS)
.c887	a887	20 dc ac	jsr $acdc			jsr 	GXOpenBitmap 				; start drawing
.c88a	a88a	20 4b ae	jsr $ae4b			jsr 	GXSortXY 					; sort both X and Y so top left/bottom right
.c88d	a88d	20 ec ac	jsr $acec			jsr 	gxPositionCalc 				; setup gxzScreen, gxOffset and the position.
.c890	a890	38		sec				sec 								; sec = Draw line
.c891	a891	20 bd a8	jsr $a8bd			jsr 	GXDrawLineX1X0 				; draw a line length X1-X0
.c894	a894	ad fa 08	lda $08fa			lda 	gxY0 						; reached end of rectangle ?
.c897	a897	cd fe 08	cmp $08fe			cmp 	gxY1 						; e.g. 1 pixel high.
.c89a	a89a	f0 19		beq $a8b5			beq 	_GXRectangleExit
.c89c	a89c					_GXRectLoop:
.c89c	a89c	20 42 ad	jsr $ad42			jsr 	GXMovePositionDown 			; down one.
.c89f	a89f	ee fa 08	inc $08fa			inc 	gxY0 						; change Y pos
.c8a2	a8a2	ad fa 08	lda $08fa			lda 	gxY0 						; reached last line
.c8a5	a8a5	cd fe 08	cmp $08fe			cmp 	gxY1
.c8a8	a8a8	f0 07		beq $a8b1			beq 	_GXLastLine
.c8aa	a8aa	28		plp				plp 								; get flag back for solid/edged
.c8ab	a8ab	08		php				php
.c8ac	a8ac	20 bd a8	jsr $a8bd			jsr 	GXDrawLineX1X0 				; draw horizontal line
.c8af	a8af	80 eb		bra $a89c			bra 	_GXRectLoop
.c8b1	a8b1					_GXLastLine:
.c8b1	a8b1	38		sec				sec
.c8b2	a8b2	20 bd a8	jsr $a8bd			jsr 	GXDrawLineX1X0
.c8b5	a8b5					_GXRectangleExit:
.c8b5	a8b5	68		pla				pla 								; throw fill flag.
.c8b6	a8b6	20 e4 ac	jsr $ace4			jsr 	GXCloseBitmap 				; stop drawing and exit
.c8b9	a8b9	18		clc				clc
.c8ba	a8ba	60		rts				rts
.c8bb	a8bb					_GXRFail:
.c8bb	a8bb	38		sec				sec
.c8bc	a8bc	60		rts				rts
.c8bd	a8bd					GXDrawLineX1X0:
.c8bd	a8bd	08		php				php 								; save solid/either-end
.c8be	a8be	38		sec				sec 								; calculate x1-x0
.c8bf	a8bf	ad fc 08	lda $08fc			lda		gxX1
.c8c2	a8c2	ed f8 08	sbc $08f8			sbc 	gxX0
.c8c5	a8c5	85 36		sta $36				sta 	gxzTemp0
.c8c7	a8c7	ad fd 08	lda $08fd			lda 	gxX1+1
.c8ca	a8ca	ed f9 08	sbc $08f9			sbc 	gxX0+1
.c8cd	a8cd	85 37		sta $37				sta 	gxzTemp0+1
.c8cf	a8cf	28		plp				plp
.c8d0	a8d0					GXDrawLineTemp0:
.c8d0	a8d0	a5 3c		lda $3c				lda 	gxzScreen 					; push gxzScreen, gxOffset and GXEditSlot on stack
.c8d2	a8d2	48		pha				pha
.c8d3	a8d3	a5 3d		lda $3d				lda 	gxzScreen+1
.c8d5	a8d5	48		pha				pha
.c8d6	a8d6	ad 0f 09	lda $090f			lda 	gxOffset
.c8d9	a8d9	48		pha				pha
.c8da	a8da	a5 0b		lda $0b				lda 	GXEditSlot
.c8dc	a8dc	48		pha				pha
.c8dd	a8dd	ac 0f 09	ldy $090f			ldy 	gxOffset 					; Y offset
.c8e0	a8e0	90 1e		bcc $a900			bcc 	_GXDLTEndPoints 			; if CC draw end points only.
.c8e2	a8e2					_GXDLTLine:
.c8e2	a8e2	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 				; set pixel
.c8e4	a8e4	2d 0d 09	and $090d			and 	gxANDValue
.c8e7	a8e7	4d 0c 09	eor $090c			eor 	gxEORValue
.c8ea	a8ea	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c8ec	a8ec	a5 36		lda $36				lda 	gxzTemp0 					; decrement counter
.c8ee	a8ee	d0 04		bne $a8f4			bne 	_GXDLTNoBorrow
.c8f0	a8f0	c6 37		dec $37				dec 	gxzTemp0+1 					; borrow, if goes -ve then exit
.c8f2	a8f2	30 2e		bmi $a922			bmi 	_GXDLTExit
.c8f4	a8f4					_GXDLTNoBorrow:
.c8f4	a8f4	c6 36		dec $36				dec 	gxzTemp0
.c8f6	a8f6	c8		iny				iny 								; next slot.
.c8f7	a8f7	d0 e9		bne $a8e2			bne 	_GXDLTLine
.c8f9	a8f9	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.c8fb	a8fb	20 30 a9	jsr $a930			jsr 	GXDLTCheckWrap				; check for new page.
.c8fe	a8fe	80 e2		bra $a8e2			bra 	_GXDLTLine
.c900	a900					_GXDLTEndPoints:
.c900	a900	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 				; set pixel
.c902	a902	2d 0d 09	and $090d			and 	gxANDValue
.c905	a905	4d 0c 09	eor $090c			eor 	gxEORValue
.c908	a908	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c90a	a90a	98		tya				tya 								; advance to right side
.c90b	a90b	18		clc				clc
.c90c	a90c	65 36		adc $36				adc 	gxzTemp0
.c90e	a90e	a8		tay				tay
.c90f	a90f	a5 3d		lda $3d				lda 	gxzScreen+1
.c911	a911	65 37		adc $37				adc 	gxzTemp0+1
.c913	a913	85 3d		sta $3d				sta 	gxzScreen+1
.c915	a915	20 30 a9	jsr $a930			jsr 	GXDLTCheckWrap 				; fix up.
.c918	a918	b1 3c		lda ($3c),y			lda 	(gxzScreen),y 				; set pixel on the right
.c91a	a91a	2d 0d 09	and $090d			and 	gxANDValue
.c91d	a91d	4d 0c 09	eor $090c			eor 	gxEORValue
.c920	a920	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c922	a922					_GXDLTExit:
.c922	a922	68		pla				pla
.c923	a923	85 0b		sta $0b				sta 	GXEditSlot
.c925	a925	68		pla				pla
.c926	a926	8d 0f 09	sta $090f			sta 	gxOffset
.c929	a929	68		pla				pla
.c92a	a92a	85 3d		sta $3d				sta 	gxzScreen+1
.c92c	a92c	68		pla				pla
.c92d	a92d	85 3c		sta $3c				sta 	gxzScreen
.c92f	a92f	60		rts				rts
.c930	a930					GXDLTCheckWrap:
.c930	a930	a5 3d		lda $3d				lda 	gxzScreen+1 				; check end of page
.c932	a932	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8)
.c934	a934	90 06		bcc $a93c			bcc 	_GXDLTCWExit
.c936	a936	e9 20		sbc #$20			sbc 	#$20 						; fix up
.c938	a938	85 3d		sta $3d				sta 	gxzScreen+1
.c93a	a93a	e6 0b		inc $0b				inc 	GXEditSlot 					; next bitmap vram page.
.c93c	a93c					_GXDLTCWExit:
.c93c	a93c	60		rts				rts
.c93d	a93d					GXDrawGraphicElement:
.c93d	a93d	8d a5 09	sta $09a5			sta 	gxSize 						; save size
.c940	a940	3a		dec a				dec 	a
.c941	a941	8d a6 09	sta $09a6			sta 	gxMask 						; and mask
.c944	a944	ad 01 09	lda $0901			lda 	gxBitmapsOn 				; check BMP on
.c947	a947	f0 67		beq $a9b0			beq 	_GXSLFail
.c949	a949	ad fa 08	lda $08fa			lda 	gxY0 						; push Y on stack
.c94c	a94c	48		pha				pha
.c94d	a94d	8c a8 09	sty $09a8			sty 	gxAcquireVector+1 			; and acquisition vector
.c950	a950	8e a7 09	stx $09a7			stx 	gxAcquireVector
.c953	a953	20 dc ac	jsr $acdc			jsr 	GXOpenBitmap 				; open the bitmap.
.c956	a956	ad aa 09	lda $09aa			lda 	gxUseMode 					; scale bits
.c959	a959	4a		lsr a				lsr 	a
.c95a	a95a	4a		lsr a				lsr 	a
.c95b	a95b	4a		lsr a				lsr 	a
.c95c	a95c	29 07		and #$07			and		#7
.c95e	a95e	1a		inc a				inc 	a
.c95f	a95f	8d a9 09	sta $09a9			sta 	gxScale
.c962	a962	64 38		stz $38				stz 	gxzTemp1					; start first line
.c964	a964					_GXGELoop:
.c964	a964	a5 38		lda $38				lda 	gxzTemp1 					; current line number to read.
.c966	a966	2c aa 09	bit $09aa			bit 	gxUseMode 					; check for flip.
.c969	a969	10 06		bpl $a971			bpl		_GXNoVFlip
.c96b	a96b	ad a6 09	lda $09a6			lda 	gxMask
.c96e	a96e	38		sec				sec
.c96f	a96f	e5 38		sbc $38				sbc 	gxzTemp1
.c971	a971					_GXNoVFlip:
.c971	a971	aa		tax				tax 								; get the Xth line.
.c972	a972	20 b2 a9	jsr $a9b2			jsr 	_GXCallAcquire 				; get that data.
.c975	a975	ad a9 09	lda $09a9			lda 	gxScale 					; do scale identical copies of that line.
.c978	a978	85 39		sta $39				sta 	gxzTemp1+1
.c97a	a97a					_GXGELoop2:
.c97a	a97a	ad fa 08	lda $08fa			lda 	gxY0 						; off screen
.c97d	a97d	cd 09 09	cmp $0909			cmp 	gxHeight
.c980	a980	b0 10		bcs $a992			bcs 	_GXDGEExit
.c982	a982	20 b5 a9	jsr $a9b5			jsr 	GXRenderOneLine 			; render line
.c985	a985	c6 39		dec $39				dec 	gxzTemp1+1 					; scale times.
.c987	a987	d0 f1		bne $a97a			bne 	_GXGELoop2
.c989	a989	e6 38		inc $38				inc 	gxzTemp1 					; done all lines.
.c98b	a98b	a5 38		lda $38				lda 	gxzTemp1
.c98d	a98d	cd a5 09	cmp $09a5			cmp 	gxSize
.c990	a990	d0 d2		bne $a964			bne 	_GXGELoop
.c992	a992					_GXDGEExit:
.c992	a992	68		pla				pla 								; restore Y for next time
.c993	a993	8d fa 08	sta $08fa			sta 	gxY0
.c996	a996	ae a9 09	ldx $09a9			ldx 	gxScale 					; get scale (1-8)
.c999	a999					_GXShiftLeft:
.c999	a999	18		clc				clc
.c99a	a99a	ad a5 09	lda $09a5			lda 	gxSize
.c99d	a99d	6d f8 08	adc $08f8			adc 	gxX0
.c9a0	a9a0	8d f8 08	sta $08f8			sta 	gxX0
.c9a3	a9a3	90 03		bcc $a9a8			bcc 	_GXSLNoCarry
.c9a5	a9a5	ee f9 08	inc $08f9			inc 	gxX0+1
.c9a8	a9a8					_GXSLNoCarry:
.c9a8	a9a8	ca		dex				dex
.c9a9	a9a9	d0 ee		bne $a999			bne 	_GXShiftLeft
.c9ab	a9ab	20 e4 ac	jsr $ace4			jsr 	GXCloseBitmap
.c9ae	a9ae	18		clc				clc
.c9af	a9af	60		rts				rts
.c9b0	a9b0					_GXSLFail:
.c9b0	a9b0	38		sec				sec
.c9b1	a9b1	60		rts				rts
.c9b2	a9b2					_GXCallAcquire:
.c9b2	a9b2	6c a7 09	jmp ($09a7)			jmp 	(gxAcquireVector)
.c9b5	a9b5					GXRenderOneLine:
.c9b5	a9b5	20 ec ac	jsr $acec			jsr 	gxPositionCalc 				; calculate position/offset.
.c9b8	a9b8	ac 0f 09	ldy $090f			ldy 	gxOffset 					; Y contains position.
.c9bb	a9bb	64 3a		stz $3a				stz 	gxzTemp2 					; do size pixels
.c9bd	a9bd					_GXROLLoop1:
.c9bd	a9bd	ad a9 09	lda $09a9			lda 	gxScale 					; set to do 'scale' times
.c9c0	a9c0	85 3b		sta $3b				sta 	gxzTemp2+1
.c9c2	a9c2					_GXROLLoop2:
.c9c2	a9c2	a5 3a		lda $3a				lda 	gxzTemp2 					; get current pixel
.c9c4	a9c4	2c 0a 09	bit $090a			bit 	gxMode 						; check H Flip
.c9c7	a9c7	50 06		bvc $a9cf			bvc 	_GXNoHFlip
.c9c9	a9c9	ad a6 09	lda $09a6			lda 	gxMask
.c9cc	a9cc	38		sec				sec
.c9cd	a9cd	e5 3a		sbc $3a				sbc 	gxzTemp2
.c9cf	a9cf					_GXNoHFlip:
.c9cf	a9cf	aa		tax				tax 								; read from the pixel buffer
.c9d0	a9d0	bd 43 06	lda $0643,x			lda 	gxPixelBuffer,x
.c9d3	a9d3	d0 07		bne $a9dc			bne 	_GXDraw 					; draw if non zero
.c9d5	a9d5	ad aa 09	lda $09aa			lda 	gxUseMode 					; check to see if solid background
.c9d8	a9d8	29 04		and #$04			and 	#4
.c9da	a9da	f0 0a		beq $a9e6			beq 	_GXZeroPixel
.c9dc	a9dc					_GXDraw:
.c9dc	a9dc	b1 3c		lda ($3c),y			lda 	(gxzScreen),y
.c9de	a9de	2d 0d 09	and $090d			and 	gxANDValue
.c9e1	a9e1	5d 43 06	eor $0643,x			eor 	gxPixelBuffer,x
.c9e4	a9e4	91 3c		sta ($3c),y			sta 	(gxzScreen),y
.c9e6	a9e6					_GXZeroPixel:
.c9e6	a9e6	c8		iny				iny 								; advance pointer
.c9e7	a9e7	d0 05		bne $a9ee			bne 	_GXNoShift
.c9e9	a9e9	e6 3d		inc $3d				inc 	gxzScreen+1 				; carry to next
.c9eb	a9eb	20 30 a9	jsr $a930			jsr 	GXDLTCheckWrap				; check for new page.
.c9ee	a9ee					_GXNoShift:
.c9ee	a9ee	c6 3b		dec $3b				dec 	gxzTemp2+1 					; do the inner loop gxScale times.
.c9f0	a9f0	d0 d0		bne $a9c2			bne 	_GXROLLoop2
.c9f2	a9f2	e6 3a		inc $3a				inc 	gxzTemp2 					; next pixel.
.c9f4	a9f4	a5 3a		lda $3a				lda 	gxzTemp2
.c9f6	a9f6	cd a5 09	cmp $09a5			cmp 	gxSize
.c9f9	a9f9	d0 c2		bne $a9bd			bne 	_GXROLLoop1
.c9fb	a9fb	ee fa 08	inc $08fa			inc 	gxY0
.c9fe	a9fe	60		rts				rts
.09a5						gxSize:
>09a5								.fill 	1
.09a6						gxMask:
>09a6								.fill 	1
.09a7						gxAcquireVector:
>09a7								.fill 	2
.09a9						gxScale:
>09a9								.fill 	1
.09aa						gxUseMode:
>09aa								.fill 	1
.c9ff	a9ff					GXControlTileScrollX:
.c9ff	a9ff	ad 07 09	lda $0907			lda 	gxTileMapWidth 				; comparator value (max X tile)
.ca02	aa02	20 21 aa	jsr $aa21			jsr 	GXScrollProcessor 			; scroll processing.
.ca05	aa05	b0 08		bcs $aa0f			bcs 	_GXCTSExit
.ca07	aa07	64 01		stz $01				stz 	1 							; write it out.
.ca09	aa09	8e 08 d2	stx $d208			stx 	$D208
.ca0c	aa0c	8c 09 d2	sty $d209			sty 	$D209
.ca0f	aa0f					_GXCTSExit:
.ca0f	aa0f	60		rts				rts
.ca10	aa10					GXControlTileScrollY:
.ca10	aa10	ad 08 09	lda $0908			lda 	gxTileMapHeight 			; comparator value (max X tile)
.ca13	aa13	20 21 aa	jsr $aa21			jsr 	GXScrollProcessor 			; scroll processing.
.ca16	aa16	b0 08		bcs $aa20			bcs 	_GXCTSExit
.ca18	aa18	64 01		stz $01				stz 	1 							; write it out.
.ca1a	aa1a	8e 0a d2	stx $d20a			stx 	$D20A
.ca1d	aa1d	8c 0b d2	sty $d20b			sty 	$D20B
.ca20	aa20					_GXCTSExit:
.ca20	aa20	60		rts				rts
.ca21	aa21					GXScrollProcessor:
.ca21	aa21	85 38		sta $38				sta 	gxzTemp1 					; save max tile value.
.ca23	aa23	ad 02 09	lda $0902			lda 	gxTilesOn 					; check tile map is on.
.ca26	aa26	38		sec				sec
.ca27	aa27	f0 2c		beq $aa55			beq 	_GXSPExit
.ca29	aa29	64 39		stz $39				stz 	gxzTemp1+1 					; convert tile size to a pixel scroll.
.ca2b	aa2b	a2 03		ldx #$03			ldx 	#3
.ca2d	aa2d					_GXCalcMaxPixelScroll:
.ca2d	aa2d	06 38		asl $38				asl 	gxzTemp1
.ca2f	aa2f	26 39		rol $39				rol 	gxzTemp1+1
.ca31	aa31	ca		dex				dex
.ca32	aa32	d0 f9		bne $aa2d			bne 	_GXCalcMaxPixelScroll
.ca34	aa34	a5 36		lda $36				lda 	gxzTemp0 					; check scroll in range.
.ca36	aa36	c5 38		cmp $38				cmp 	gxzTemp1
.ca38	aa38	a5 37		lda $37				lda 	gxzTemp0+1
.ca3a	aa3a	e5 39		sbc $39				sbc 	gxzTemp1+1
.ca3c	aa3c	b0 17		bcs $aa55			bcs		_GXSPExit
.ca3e	aa3e	a5 36		lda $36				lda 	gxzTemp0 	 				; save fine scroll.
.ca40	aa40	29 07		and #$07			and		#7
.ca42	aa42	85 38		sta $38				sta 	gxzTemp1
.ca44	aa44	06 36		asl $36				asl 	gxzTemp0 					; shift left one, as whole tiles are 8 pixels.
.ca46	aa46	26 37		rol $37				rol 	gxzTemp0+1
.ca48	aa48	a5 37		lda $37				lda 	gxzTemp0+1 					; MSB is the upper byte.
.ca4a	aa4a	29 0f		and #$0f			and 	#$0F
.ca4c	aa4c	a8		tay				tay
.ca4d	aa4d	a5 36		lda $36				lda 	gxzTemp0 					; get coarse scroll
.ca4f	aa4f	29 f0		and #$f0			and 	#$F0
.ca51	aa51	05 38		ora $38				ora 	gxzTemp1 					; OR in fine scroll.
.ca53	aa53	aa		tax				tax 								; return in X
.ca54	aa54	18		clc				clc
.ca55	aa55					_GXSPExit:
.ca55	aa55	60		rts				rts
.ca56	aa56					GXFontHandler:
.ca56	aa56	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.ca58	aa58	4d 0a 09	eor $090a			eor 	gxMode
.ca5b	aa5b	8d aa 09	sta $09aa			sta 	gxUseMode
.ca5e	aa5e	64 37		stz $37				stz 	gxzTemp0+1 					; gxzTemp0 is font #
.ca60	aa60	06 36		asl $36				asl	 	gxzTemp0 					; x 2
.ca62	aa62	26 37		rol $37				rol	 	gxzTemp0+1
.ca64	aa64	06 36		asl $36				asl	 	gxzTemp0 					; x 4
.ca66	aa66	26 37		rol $37				rol	 	gxzTemp0+1
.ca68	aa68	06 36		asl $36				asl	 	gxzTemp0 					; x 8
.ca6a	aa6a	26 37		rol $37				rol	 	gxzTemp0+1
.ca6c	aa6c	a5 37		lda $37				lda 	gxzTemp0+1 					; put in page C0
.ca6e	aa6e	09 c0		ora #$c0			ora 	#$C0
.ca70	aa70	85 37		sta $37				sta 	gxzTemp0+1
.ca72	aa72	a9 08		lda #$08			lda 	#8 							; size 8x8
.ca74	aa74	a2 7c		ldx #$7c			ldx 	#GXGetGraphicDataFont & $FF ; XY = Graphic Data retrieval routine
.ca76	aa76	a0 aa		ldy #$aa			ldy 	#GXGetGraphicDataFont >> 8
.ca78	aa78	20 3d a9	jsr $a93d			jsr 	GXDrawGraphicElement
.ca7b	aa7b	60		rts				rts
.ca7c	aa7c					GXGetGraphicDataFont:
.ca7c	aa7c	8a		txa				txa 								; X->Y
.ca7d	aa7d	a8		tay				tay
.ca7e	aa7e	a6 01		ldx $01				ldx 	1 							; preserve old value
.ca80	aa80	a9 01		lda #$01			lda 	#1 							; access page 1 (font memory)
.ca82	aa82	85 01		sta $01				sta 	1
.ca84	aa84	b1 36		lda ($36),y			lda 	(gxzTemp0),y 				; read the font element.
.ca86	aa86	86 01		stx $01				stx 	1 							; put old value back.
.ca88	aa88	a2 00		ldx #$00			ldx 	#0 							; do 8 times
.ca8a	aa8a					_GXExpand:
.ca8a	aa8a	9e 43 06	stz $0643,x			stz 	gxPixelBuffer,x 			; zero in pixel buffer
.ca8d	aa8d	0a		asl a				asl 	a 							; shift bit 7 into C
.ca8e	aa8e	90 08		bcc $aa98			bcc 	_GXNoPixel
.ca90	aa90	48		pha				pha 								; if set, set pixel buffer to current colour.
.ca91	aa91	ad 0b 09	lda $090b			lda 	gxColour
.ca94	aa94	9d 43 06	sta $0643,x			sta 	gxPixelBuffer,x
.ca97	aa97	68		pla				pla
.ca98	aa98					_GXNoPixel:
.ca98	aa98	e8		inx				inx 								; do the whole byte.
.ca99	aa99	e0 08		cpx #$08			cpx 	#8
.ca9b	aa9b	d0 ed		bne $aa8a			bne 	_GXExpand
.ca9d	aa9d	60		rts				rts
.ca9e	aa9e					GXSpriteHandler:
.ca9e	aa9e	ad 00 09	lda $0900			lda 	gxSpritesOn 				; sprites on ?
.caa1	aaa1	f0 23		beq $aac6			beq 	_GXSHExit
.caa3	aaa3	a5 37		lda $37				lda 	gxzTemp0+1 					; eor with mode
.caa5	aaa5	4d 0a 09	eor $090a			eor 	gxMode
.caa8	aaa8	8d aa 09	sta $09aa			sta 	gxUseMode
.caab	aaab	a6 36		ldx $36				ldx 	gxzTemp0 					; sprite #
.caad	aaad	da		phx				phx
.caae	aaae	20 dc ac	jsr $acdc			jsr 	GXOpenBitmap 				; can access sprite information
.cab1	aab1	68		pla				pla
.cab2	aab2	20 bd ad	jsr $adbd			jsr 	GXFindSprite 				; get the sprite address
.cab5	aab5	08		php				php
.cab6	aab6	20 e4 ac	jsr $ace4			jsr 	GXCloseBitmap
.cab9	aab9	28		plp				plp
.caba	aaba	b0 0a		bcs $aac6			bcs		_GXSHExit 					; exit if find failed.
.cabc	aabc	ad ab 09	lda $09ab			lda 	gxSizePixels 				; return size
.cabf	aabf	a2 c7		ldx #$c7			ldx 	#GXSpriteAcquire & $FF
.cac1	aac1	a0 aa		ldy #$aa			ldy 	#GXSpriteAcquire >> 8
.cac3	aac3	20 3d a9	jsr $a93d			jsr 	GXDrawGraphicElement
.cac6	aac6					_GXSHExit:
.cac6	aac6	60		rts				rts
.cac7	aac7					GXSpriteAcquire:
.cac7	aac7	ad 04 09	lda $0904			lda 	gxSpritePage				; point to base page
.caca	aaca	85 0b		sta $0b				sta 	GXEditSlot
.cacc	aacc	86 36		stx $36				stx 	gxzTemp0 					; row number x 1,2,3,4
.cace	aace	a9 00		lda #$00			lda 	#0
.cad0	aad0	ae ac 09	ldx $09ac			ldx 	gxSizeBits
.cad3	aad3					_GXTimesRowNumber:
.cad3	aad3	18		clc				clc
.cad4	aad4	65 36		adc $36				adc 	gxzTemp0
.cad6	aad6	ca		dex				dex
.cad7	aad7	10 fa		bpl $aad3			bpl 	_GXTimesRowNumber
.cad9	aad9	64 37		stz $37				stz 	gxzTemp0+1
.cadb	aadb	0a		asl a				asl 	a 							; row x 2,4,6,8
.cadc	aadc	26 37		rol $37				rol 	gxzTemp0+1
.cade	aade	0a		asl a				asl 	a 							; row x 4,8,12,16
.cadf	aadf	26 37		rol $37				rol 	gxzTemp0+1
.cae1	aae1	0a		asl a				asl 	a 							; row x 8,16,24,32
.cae2	aae2	26 37		rol $37				rol 	gxzTemp0+1
.cae4	aae4	85 36		sta $36				sta 	gxzTemp0
.cae6	aae6	18		clc				clc 								; add base address.
.cae7	aae7	a5 36		lda $36				lda 	gxzTemp0
.cae9	aae9	6d ae 09	adc $09ae			adc 	gxSpriteOffset
.caec	aaec	85 36		sta $36				sta 	gxzTemp0
.caee	aaee	a5 37		lda $37				lda 	gxzTemp0+1
.caf0	aaf0	6d af 09	adc $09af			adc 	gxSpriteOffset+1
.caf3	aaf3					_GXSAFindPage:
.caf3	aaf3	c9 20		cmp #$20			cmp 	#$20 						; on this page
.caf5	aaf5	90 06		bcc $aafd			bcc 	_GXSAFoundPage
.caf7	aaf7	e9 20		sbc #$20			sbc 	#$20 						; forward one page
.caf9	aaf9	e6 0b		inc $0b				inc 	GXEditSlot
.cafb	aafb	80 f6		bra $aaf3			bra 	_GXSAFindPage
.cafd	aafd					_GXSAFoundPage:
.cafd	aafd	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; physical address of page.
.caff	aaff	85 37		sta $37				sta 	gxzTemp0+1 					; gxzTemp0 now points to the page
.cb01	ab01	a0 00		ldy #$00			ldy 	#0
.cb03	ab03					_GXSACopyLoop:
.cb03	ab03	b1 36		lda ($36),y			lda 	(gxzTemp0),y
.cb05	ab05	99 43 06	sta $0643,y			sta 	gxPixelBuffer,y
.cb08	ab08	c8		iny				iny
.cb09	ab09	cc ab 09	cpy $09ab			cpy 	gxSizePixels
.cb0c	ab0c	d0 f5		bne $ab03			bne 	_GXSACopyLoop
.cb0e	ab0e	60		rts				rts
.cb0f	ab0f					GXSelect:
.cb0f	ab0f	ad 00 09	lda $0900			lda 	gxSpritesOn
.cb12	ab12	f0 22		beq $ab36			beq 	_GXSFail
.cb14	ab14	a5 36		lda $36				lda 	gxzTemp0 					; illegal sprite #
.cb16	ab16	c9 40		cmp #$40			cmp 	#64
.cb18	ab18	b0 1c		bcs $ab36			bcs 	_GXSFail
.cb1a	ab1a	8d 10 09	sta $0910			sta 	GSCurrentSpriteID
.cb1d	ab1d	a4 37		ldy $37				ldy 	gxzTemp0+1 					; control value.
.cb1f	ab1f	a9 00		lda #$00			lda  	#0 							; multiply sprite # x 8 => A
.cb21	ab21	06 36		asl $36				asl 	gxzTemp0
.cb23	ab23	06 36		asl $36				asl 	gxzTemp0
.cb25	ab25	06 36		asl $36				asl 	gxzTemp0
.cb27	ab27	2a		rol a				rol 	a
.cb28	ab28	69 d9		adc #$d9			adc 	#$D9 						; sprite area
.cb2a	ab2a	8d 12 09	sta $0912			sta 	GSCurrentSpriteAddr+1 		; address to GSCurrentSprite and gxzTemp
.cb2d	ab2d	85 37		sta $37				sta 	gxzTemp0+1
.cb2f	ab2f	a5 36		lda $36				lda 	gxzTemp0
.cb31	ab31	8d 11 09	sta $0911			sta 	GSCurrentSpriteAddr
.cb34	ab34	18		clc				clc
.cb35	ab35	60		rts				rts
.cb36	ab36					_GXSFail:
.cb36	ab36	38		sec				sec
.cb37	ab37	60		rts				rts
.cb38	ab38					GXSelectImage:
.cb38	ab38	ad 00 09	lda $0900			lda 	gxSpritesOn
.cb3b	ab3b	f0 74		beq $abb1			beq 	_GXSIFail
.cb3d	ab3d	ad 12 09	lda $0912			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.cb40	ab40	f0 6f		beq $abb1			beq 	_GXSIFail 					; (checking the MSB)
.cb42	ab42	64 01		stz $01				stz 	1
.cb44	ab44	a5 37		lda $37				lda 	gxzTemp0+1 					; push show/hide on the stack.
.cb46	ab46	d0 6b		bne $abb3			bne 	_GXSIHide
.cb48	ab48	a5 36		lda $36				lda 	gxzTemp0 					; sprite image
.cb4a	ab4a	48		pha				pha
.cb4b	ab4b	20 dc ac	jsr $acdc			jsr 	GXOpenBitmap
.cb4e	ab4e	68		pla				pla
.cb4f	ab4f	20 bd ad	jsr $adbd			jsr 	GXFindSprite
.cb52	ab52	b0 5a		bcs $abae			bcs 	_GXSICloseFail 				; no image
.cb54	ab54	a0 01		ldy #$01			ldy 	#1
.cb56	ab56	ad 11 09	lda $0911			lda 	GSCurrentSpriteAddr
.cb59	ab59	85 36		sta $36				sta 	gxzTemp0
.cb5b	ab5b	ad 12 09	lda $0912			lda 	GSCurrentSpriteAddr+1
.cb5e	ab5e	85 37		sta $37				sta 	gxzTemp0+1
.cb60	ab60	ad ae 09	lda $09ae			lda 	gxSpriteOffset
.cb63	ab63	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.cb65	ab65	18		clc				clc
.cb66	ab66	ad af 09	lda $09af			lda 	gxSpriteOffset+1
.cb69	ab69	6d 13 09	adc $0913			adc 	gxSpriteOffsetBase
.cb6c	ab6c	c8		iny				iny
.cb6d	ab6d	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.cb6f	ab6f	ad 14 09	lda $0914			lda 	gxSpriteOffsetBase+1
.cb72	ab72	69 00		adc #$00			adc 	#0
.cb74	ab74	c8		iny				iny
.cb75	ab75	91 36		sta ($36),y			sta	 	(gxzTemp0),y
.cb77	ab77	ad ac 09	lda $09ac			lda 	gxSizeBits 					; get raw size
.cb7a	ab7a	49 03		eor #$03			eor 	#3 							; make it right (00=32 etc.)
.cb7c	ab7c	2a		rol a				rol 	a 							; x 2
.cb7d	ab7d	0a		asl a				asl 	a 							; x 4
.cb7e	ab7e	0a		asl a				asl 	a 							; x 8
.cb7f	ab7f	0a		asl a				asl 	a 							; x 16
.cb80	ab80	0d ad 09	ora $09ad			ora 	gxSpriteLUT 				; Or with LUT
.cb83	ab83	0a		asl a				asl 	a 							; 1 shift
.cb84	ab84	09 01		ora #$01			ora 	#1 							; enable sprite.
.cb86	ab86	92 36		sta ($36)			sta 	(gxzTemp0) 					; and write back
.cb88	ab88	20 e4 ac	jsr $ace4			jsr 	GXCloseBitmap
.cb8b	ab8b	ae 10 09	ldx $0910			ldx 	GSCurrentSpriteID 			; point to sprite entries.
.cb8e	ab8e	bd 55 09	lda $0955,x			lda 	gxSpriteHigh,x 				; clear upper two bits of size
.cb91	ab91	29 3f		and #$3f			and 	#$3F
.cb93	ab93	9d 55 09	sta $0955,x			sta 	gxSpriteHigh,x
.cb96	ab96	ad ac 09	lda $09ac			lda 	gxSizeBits 					; get bit size
.cb99	ab99	6a		ror a				ror 	a 							; shift into bits 6/7
.cb9a	ab9a	6a		ror a				ror 	a
.cb9b	ab9b	6a		ror a				ror 	a
.cb9c	ab9c	29 c0		and #$c0			and 	#$C0
.cb9e	ab9e	1d 55 09	ora $0955,x			ora 	gxSpriteHigh,x 				; put in  upper 2 bits of sprite data
.cba1	aba1	9d 55 09	sta $0955,x			sta 	gxSpriteHigh,x
.cba4	aba4	bd 15 09	lda $0915,x			lda 	gxSpriteLow,x 				; clear hidden flag.
.cba7	aba7	29 7f		and #$7f			and 	#$7F
.cba9	aba9	9d 15 09	sta $0915,x			sta 	gxSpriteLow,x
.cbac	abac	18		clc				clc
.cbad	abad	60		rts				rts
.cbae	abae					_GXSICloseFail:
.cbae	abae	20 e4 ac	jsr $ace4			jsr 	GXCloseBitmap
.cbb1	abb1					_GXSIFail:
.cbb1	abb1	38		sec				sec
.cbb2	abb2	60		rts				rts
.cbb3	abb3					_GXSIHide:
.cbb3	abb3	ad 11 09	lda $0911			lda 	GSCurrentSpriteAddr  		; get Sprite h/w address and write there
.cbb6	abb6	85 36		sta $36				sta 	gxzTemp0
.cbb8	abb8	ad 12 09	lda $0912			lda 	GSCurrentSpriteAddr+1
.cbbb	abbb	85 37		sta $37				sta 	gxzTemp0+1
.cbbd	abbd	a9 00		lda #$00			lda 	#0
.cbbf	abbf	92 36		sta ($36)			sta 	(gxzTemp0)
.cbc1	abc1	ae 10 09	ldx $0910			ldx 	GSCurrentSpriteID 			; get sprite ID
.cbc4	abc4	bd 15 09	lda $0915,x			lda 	gxSpriteLow,x 				; set the hidden bit.
.cbc7	abc7	09 80		ora #$80			ora 	#$80
.cbc9	abc9	9d 15 09	sta $0915,x			sta 	gxSpriteLow,x
.cbcc	abcc	18		clc				clc
.cbcd	abcd	60		rts				rts
.cbce	abce					GXMoveSprite:
.cbce	abce	ad 00 09	lda $0900			lda 	gxSpritesOn
.cbd1	abd1	f0 65		beq $ac38			beq 	_GXSIFail
.cbd3	abd3	ad 12 09	lda $0912			lda 	GSCurrentSpriteAddr+1 		; check sprite selected
.cbd6	abd6	f0 60		beq $ac38			beq 	_GXSIFail
.cbd8	abd8	85 37		sta $37				sta 	gxzTemp0+1
.cbda	abda	a0 04		ldy #$04			ldy 	#4
.cbdc	abdc	ad 11 09	lda $0911			lda 	GSCurrentSpriteAddr
.cbdf	abdf	85 36		sta $36				sta 	gxzTemp0
.cbe1	abe1	ae 10 09	ldx $0910			ldx 	GSCurrentSpriteID 			; get the size from the upper two bits
.cbe4	abe4	bd 55 09	lda $0955,x			lda 	gxSpriteHigh,x
.cbe7	abe7	2a		rol a				rol 	a	 						; into bits 0,1.
.cbe8	abe8	2a		rol a				rol 	a
.cbe9	abe9	2a		rol a				rol 	a
.cbea	abea	29 03		and #$03			and 	#3
.cbec	abec	aa		tax				tax
.cbed	abed	bd 3a ac	lda $ac3a,x			lda 	_GXMSOffset,x 				; get 32-SpriteSize/2
.cbf0	abf0	48		pha				pha
.cbf1	abf1	18		clc				clc
.cbf2	abf2	6d f8 08	adc $08f8			adc 	gxX0						; copy position.
.cbf5	abf5	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cbf7	abf7	c8		iny				iny
.cbf8	abf8	ad f9 08	lda $08f9			lda 	gxX0+1
.cbfb	abfb	69 00		adc #$00			adc 	#0
.cbfd	abfd	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cbff	abff	c8		iny				iny
.cc00	ac00	68		pla				pla
.cc01	ac01	18		clc				clc
.cc02	ac02	6d fa 08	adc $08fa			adc 	gxY0
.cc05	ac05	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cc07	ac07	a9 00		lda #$00			lda 	#0
.cc09	ac09	69 00		adc #$00			adc 	#0
.cc0b	ac0b	c8		iny				iny
.cc0c	ac0c	91 36		sta ($36),y			sta 	(gxzTemp0),y
.cc0e	ac0e	4e f9 08	lsr $08f9			lsr 	gxX0+1 						; divide X by 4
.cc11	ac11	6e f8 08	ror $08f8			ror 	gxX0
.cc14	ac14	4e f8 08	lsr $08f8			lsr 	gxX0
.cc17	ac17	4e fa 08	lsr $08fa			lsr 	gxY0 						; divide Y by 4
.cc1a	ac1a	4e fa 08	lsr $08fa			lsr 	gxY0
.cc1d	ac1d	ae 10 09	ldx $0910			ldx 	GSCurrentSpriteID 			; copy X/4 and Y/4 into the status bytes
.cc20	ac20	bd 15 09	lda $0915,x			lda 	gxSpriteLow,x
.cc23	ac23	29 80		and #$80			and 	#$80
.cc25	ac25	0d f8 08	ora $08f8			ora 	gxX0
.cc28	ac28	9d 15 09	sta $0915,x			sta 	gxSpriteLow,x
.cc2b	ac2b	bd 55 09	lda $0955,x			lda 	gxSpriteHigh,x
.cc2e	ac2e	29 c0		and #$c0			and 	#$C0
.cc30	ac30	0d fa 08	ora $08fa			ora 	gxY0
.cc33	ac33	9d 55 09	sta $0955,x			sta 	gxSpriteHigh,x
.cc36	ac36	18		clc				clc
.cc37	ac37	60		rts				rts
.cc38	ac38					_GXSIFail:
.cc38	ac38	38		sec				sec
.cc39	ac39	60		rts				rts
.cc3a	ac3a					_GXMSOffset:
>cc3a	ac3a	1c						.byte 	32-8/2
>cc3b	ac3b	18						.byte 	32-16/2
>cc3c	ac3c	14						.byte 	32-24/2
>cc3d	ac3d	10						.byte 	32-32/2
.cc3e	ac3e					GXSelectTile:
.cc3e	ac3e	ad 02 09	lda $0902			lda 	gxTilesOn 					; check tilemap in use
.cc41	ac41	f0 4b		beq $ac8e			beq 	_GXSFail
.cc43	ac43	a5 36		lda $36				lda 	gxzTemp0 					; check X and Y in range
.cc45	ac45	cd 07 09	cmp $0907			cmp 	gxTileMapWidth
.cc48	ac48	b0 44		bcs $ac8e			bcs 	_GXSFail
.cc4a	ac4a	a5 37		lda $37				lda 	gxzTemp0+1
.cc4c	ac4c	cd 08 09	cmp $0908			cmp 	gxTileMapHeight
.cc4f	ac4f	b0 3d		bcs $ac8e			bcs 	_GXSFail
.cc51	ac51	ad 06 09	lda $0906			lda 	gxTileMapPage 				; page to access = tile access page.
.cc54	ac54	8d 95 09	sta $0995			sta 	gxTileAccessPage
.cc57	ac57	ae 07 09	ldx $0907			ldx 	gxTileMapWidth 				; YX is the additive, e.g. shifted left. gxzTemp0+1 is shifted right.
.cc5a	ac5a	a0 00		ldy #$00			ldy 	#0
.cc5c	ac5c	a5 36		lda $36				lda 	gxzTemp0 					; initial result is X
.cc5e	ac5e	8d 96 09	sta $0996			sta 	gxTileAccessAddress
.cc61	ac61	9c 97 09	stz $0997			stz  	gxTileAccessAddress+1
.cc64	ac64					_GXSTMultiply:
.cc64	ac64	46 37		lsr $37				lsr 	gxzTemp0+1 					; shift Y right
.cc66	ac66	90 0f		bcc $ac77			bcc 	_GXSTNoAdd 					; add if CS
.cc68	ac68	18		clc				clc 								; add YX to result
.cc69	ac69	8a		txa				txa
.cc6a	ac6a	6d 96 09	adc $0996			adc 	gxTileAccessAddress
.cc6d	ac6d	8d 96 09	sta $0996			sta 	gxTileAccessAddress
.cc70	ac70	98		tya				tya
.cc71	ac71	6d 97 09	adc $0997			adc 	gxTileAccessAddress+1
.cc74	ac74	8d 97 09	sta $0997			sta 	gxTileAccessAddress+1
.cc77	ac77					_GXSTNoAdd:
.cc77	ac77	8a		txa				txa 								; shift YX left
.cc78	ac78	0a		asl a				asl 	a
.cc79	ac79	aa		tax				tax
.cc7a	ac7a	98		tya				tya
.cc7b	ac7b	2a		rol a				rol 	a
.cc7c	ac7c	a8		tay				tay
.cc7d	ac7d	a5 37		lda $37				lda 	gxzTemp0+1 					; multiply complete
.cc7f	ac7f	d0 e3		bne $ac64			bne 	_GXSTMultiply
.cc81	ac81	0e 96 09	asl $0996			asl 	gxTileAccessAddress 		; double it, as it is a word array.
.cc84	ac84	2e 97 09	rol $0997			rol 	gxTileAccessAddress+1
.cc87	ac87					_GXSTFixAddressLoop:
.cc87	ac87	20 90 ac	jsr $ac90			jsr 	GXSTFixAddress
.cc8a	ac8a	b0 fb		bcs $ac87			bcs 	_GXSTFixAddressLoop
.cc8c	ac8c	18		clc				clc
.cc8d	ac8d	60		rts				rts
.cc8e	ac8e					_GXSFail:
.cc8e	ac8e	38		sec				sec
.cc8f	ac8f	60		rts				rts
.cc90	ac90					GXSTFixAddress:
.cc90	ac90	48		pha				pha
.cc91	ac91	ad 97 09	lda $0997			lda 	gxTileAccessAddress+1 		; in legal page range e.g. $0000-$1FFF
.cc94	ac94	c9 20		cmp #$20			cmp 	#$20
.cc96	ac96	90 06		bcc $ac9e			bcc 	_GXSTFAExit
.cc98	ac98	e9 20		sbc #$20			sbc 	#$20 						; adjust address
.cc9a	ac9a	ee 95 09	inc $0995			inc 	gxTileAccessPage 			; adjust page up.
.cc9d	ac9d	38		sec				sec
.cc9e	ac9e					_GXSTFAExit:
.cc9e	ac9e	68		pla				pla
.cc9f	ac9f	60		rts				rts
.cca0	aca0					GXSTWriteTile:
.cca0	aca0	38		sec				sec 								; CS = update flag
.cca1	aca1	80 01		bra $aca4			bra 	GXSTTileAccess
.cca3	aca3					GXSTReadTile:
.cca3	aca3	18		clc				clc
.cca4	aca4					GXSTTileAccess:
.cca4	aca4	a5 0b		lda $0b				lda 	GXEditSlot 					; save oroginal page
.cca6	aca6	48		pha				pha
.cca7	aca7	08		php				php 								; save update flag
.cca8	aca8	ad 95 09	lda $0995			lda 	gxTileAccessPage 			; access the tile page.
.ccab	acab	85 0b		sta $0b				sta 	GXEditSlot
.ccad	acad	a6 36		ldx $36				ldx 	gxzTemp0 					; X = New value
.ccaf	acaf	ad 96 09	lda $0996			lda 	gxTileAccessAddress 		; set gxzTemp0 to point there
.ccb2	acb2	85 36		sta $36				sta 	gxzTemp0
.ccb4	acb4	ad 97 09	lda $0997			lda 	gxTileAccessAddress+1
.ccb7	acb7	09 60		ora #$60			ora 	#(GXMappingAddress >> 8)
.ccb9	acb9	85 37		sta $37				sta 	gxzTemp0+1
.ccbb	acbb	28		plp				plp 								; get flag
.ccbc	acbc	90 09		bcc $acc7			bcc 	_GXSNoUpdate 				; updating the tile map ?
.ccbe	acbe	8a		txa				txa 								; new value
.ccbf	acbf	92 36		sta ($36)			sta 	(gxzTemp0) 					; write it out, as a word.
.ccc1	acc1	a0 01		ldy #$01			ldy 	#1
.ccc3	acc3	a9 00		lda #$00			lda 	#0
.ccc5	acc5	91 36		sta ($36),y			sta 	(gxzTemp0),y
.ccc7	acc7					_GXSNoUpdate:
.ccc7	acc7	b2 36		lda ($36)			lda 	(gxzTemp0) 					; read the value
.ccc9	acc9	fa		plx				plx 								; restore old page
.ccca	acca	86 0b		stx $0b				stx 	GXEditSlot
.cccc	accc	ee 96 09	inc $0996			inc 	gxTileAccessAddress 		; advance tile ptr by 2 - will always be even.
.cccf	accf	ee 96 09	inc $0996			inc 	gxTileAccessAddress
.ccd2	acd2	d0 03		bne $acd7			bne 	_GXSNoCarry
.ccd4	acd4	ee 97 09	inc $0997			inc 	gxTileAccessAddress+1
.ccd7	acd7					_GXSNoCarry:
.ccd7	acd7	20 90 ac	jsr $ac90			jsr 	GXSTFixAddress 				; fix address if required.
.ccda	acda	18		clc				clc 								; return with ok flag.
.ccdb	acdb	60		rts				rts
.ccdc	acdc					GXOpenBitmap:
.ccdc	acdc	78		sei				sei 								; no interrupts here
.ccdd	acdd	a5 0b		lda $0b				lda 	GXEditSlot 					; Save the original LUT slot value
.ccdf	acdf	8d 0e 09	sta $090e			sta 	gxOriginalLUTValue
.cce2	ace2	58		cli				cli
.cce3	ace3	60		rts				rts
.cce4	ace4					GXCloseBitmap:
.cce4	ace4	78		sei				sei
.cce5	ace5	ad 0e 09	lda $090e			lda 	gxOriginalLUTValue 			; restore LUT slot value
.cce8	ace8	85 0b		sta $0b				sta 	GXEditSlot
.ccea	acea	58		cli				cli
.cceb	aceb	60		rts				rts
.ccec	acec					gxPositionCalc:
.ccec	acec	a5 36		lda $36				lda 	gxzTemp0 						; save temp memory slot
.ccee	acee	48		pha				pha
.ccef	acef	ad fa 08	lda $08fa			lda 	gxY0 							; gxzScreen = Y0
.ccf2	acf2	85 3c		sta $3c				sta 	gxzScreen
.ccf4	acf4	64 3d		stz $3d				stz 	gxzScreen+1
.ccf6	acf6	06 3c		asl $3c				asl 	gxzScreen 						; gxzScreen = Y0 * 4
.ccf8	acf8	26 3d		rol $3d				rol 	gxzScreen+1
.ccfa	acfa	06 3c		asl $3c				asl 	gxzScreen
.ccfc	acfc	26 3d		rol $3d				rol 	gxzScreen+1
.ccfe	acfe	18		clc				clc 									; gxzScreen = Y0 * 5, as it's still in A
.ccff	acff	65 3c		adc $3c				adc 	gxzScreen
.cd01	ad01	85 3c		sta $3c				sta 	gxzScreen
.cd03	ad03	90 02		bcc $ad07			bcc 	_GXPCNoCarry
.cd05	ad05	e6 3d		inc $3d				inc 	gxzScreen+1
.cd07	ad07					_GXPCNoCarry:
.cd07	ad07	06 3c		asl $3c				asl 	gxzScreen 						; now Y0 * 10
.cd09	ad09	26 3d		rol $3d				rol 	gxzScreen+1
.cd0b	ad0b	a5 3d		lda $3d				lda	 	gxzScreen+1
.cd0d	ad0d	85 36		sta $36				sta 	gxzTemp0 						; the page offset.
.cd0f	ad0f	64 3d		stz $3d				stz 	gxzScreen+1
.cd11	ad11	a9 05		lda #$05			lda 	#5 								; now multiply by 32, this puts this in the range 0..8191
.cd13	ad13					_GXPCMultiply32:
.cd13	ad13	06 3c		asl $3c				asl 	gxzScreen
.cd15	ad15	26 3d		rol $3d				rol 	gxzScreen+1
.cd17	ad17	3a		dec a				dec 	a
.cd18	ad18	d0 f9		bne $ad13			bne 	_GXPCMultiply32
.cd1a	ad1a	18		clc				clc
.cd1b	ad1b	ad f8 08	lda $08f8			lda 	gxX0 						; add X to this value, put the result in gxOffset, gxzScreen has to be on a page boundary
.cd1e	ad1e	65 3c		adc $3c				adc 	gxzScreen
.cd20	ad20	8d 0f 09	sta $090f			sta 	gxOffset
.cd23	ad23	ad f9 08	lda $08f9			lda 	gxX0+1
.cd26	ad26	65 3d		adc $3d				adc 	gxzScreen+1
.cd28	ad28	c9 20		cmp #$20			cmp 	#$20 						; has it overflowed into the next one ?
.cd2a	ad2a	90 04		bcc $ad30			bcc 	_GXPCNoOverflow
.cd2c	ad2c	29 1f		and #$1f			and 	#$1F 						; fix it up
.cd2e	ad2e	e6 36		inc $36				inc 	gxzTemp0 					; add 1 to the page number
.cd30	ad30					_GXPCNoOverflow:
.cd30	ad30	09 60		ora #$60			ora 	#(GXMappingAddress >> 8) 	; make it the address mapped in.
.cd32	ad32	85 3d		sta $3d				sta 	gxzScreen+1
.cd34	ad34	64 3c		stz $3c				stz 	gxzScreen
.cd36	ad36	18		clc				clc
.cd37	ad37	a5 36		lda $36				lda 	gxzTemp0 					; get the page number
.cd39	ad39	6d 03 09	adc $0903			adc 	gxBasePage 					; by adding the base page
.cd3c	ad3c	85 0b		sta $0b				sta 	GXEditSlot 					; and map it into memory.
.cd3e	ad3e	68		pla				pla
.cd3f	ad3f	85 36		sta $36				sta 	gxzTemp0
.cd41	ad41	60		rts				rts
.cd42	ad42					GXMovePositionDown:
.cd42	ad42	18		clc				clc 								; add 320 to offset/temp+1
.cd43	ad43	ad 0f 09	lda $090f			lda 	gxOffset
.cd46	ad46	69 40		adc #$40			adc 	#64
.cd48	ad48	8d 0f 09	sta $090f			sta 	gxOffset
.cd4b	ad4b	a5 3d		lda $3d				lda 	gxzScreen+1
.cd4d	ad4d	69 01		adc #$01			adc 	#1
.cd4f	ad4f	85 3d		sta $3d				sta 	gxzScreen+1
.cd51	ad51	c9 80		cmp #$80			cmp 	#((GXMappingAddress+$2000) >> 8) ; on to the next page ?
.cd53	ad53	90 07		bcc $ad5c			bcc 	_GXMPDExit
.cd55	ad55	38		sec				sec  								; next page, adjust address
.cd56	ad56	e9 20		sbc #$20			sbc 	#$20
.cd58	ad58	85 3d		sta $3d				sta 	gxzScreen+1
.cd5a	ad5a	e6 0b		inc $0b				inc 	GXEditSlot 					; bump page
.cd5c	ad5c					_GXMPDExit:
.cd5c	ad5c	60		rts				rts
.cd5d	ad5d					GXCollide:
.cd5d	ad5d	a5 36		lda $36				lda 	gxzTemp0 					; check if sprite numbers are legal.
.cd5f	ad5f	aa		tax				tax
.cd60	ad60	05 37		ora $37				ora 	gxzTemp0+1
.cd62	ad62	29 c0		and #$c0			and 	#$C0
.cd64	ad64	38		sec				sec
.cd65	ad65	d0 53		bne $adba			bne 	_GXCollideFail 				; if either >= 64, fail.
.cd67	ad67	a4 37		ldy $37				ldy 	gxzTemp0+1 					; at this point X is 1st sprite and Y is 2nd sprite.
.cd69	ad69	b9 15 09	lda $0915,y			lda 	gxSpriteLow,y 				; check if either hidden bit is set
.cd6c	ad6c	1d 15 09	ora $0915,x			ora 	gxSpriteLow,x
.cd6f	ad6f	30 48		bmi $adb9			bmi 	_GXOkayFail 				; if either hidden, then they cannot collide.
.cd71	ad71	18		clc				clc 								; need to calculate sum of sizes.
.cd72	ad72	b9 55 09	lda $0955,y			lda 	gxSpriteHigh,y
.cd75	ad75	7d 55 09	adc $0955,x			adc 	gxSpriteHigh,x 				; at this point, CS, Bit 6 and 7 contain that sum.
.cd78	ad78	29 c0		and #$c0			and 	#$C0 					 	; mask off
.cd7a	ad7a	6a		ror a				ror 	a 							; 5/6/7
.cd7b	ad7b	4a		lsr a				lsr 	a 							; 4/5/6
.cd7c	ad7c	4a		lsr a				lsr 	a 							; 3/4/5
.cd7d	ad7d	4a		lsr a				lsr 	a 							; 2/3/4
.cd7e	ad7e	18		clc				clc
.cd7f	ad7f	69 08		adc #$08			adc 	#$08
.cd81	ad81	4a		lsr a				lsr 	a 							; adjust because all coordinates are divided by 4 to store.
.cd82	ad82	4a		lsr a				lsr 	a
.cd83	ad83	85 38		sta $38				sta 	gxzTemp1 					; so the difference between the centres has to be less than this.
.cd85	ad85	b9 55 09	lda $0955,y			lda 	gxSpriteHigh,y 				; calculate y1-y0
.cd88	ad88	29 3f		and #$3f			and 	#$3F
.cd8a	ad8a	85 39		sta $39				sta 	gxzTemp1+1
.cd8c	ad8c	38		sec				sec
.cd8d	ad8d	bd 55 09	lda $0955,x			lda 	gxSpriteHigh,x
.cd90	ad90	29 3f		and #$3f			and 	#$3F
.cd92	ad92	e5 39		sbc $39				sbc 	gxzTemp1+1
.cd94	ad94	b0 03		bcs $ad99			bcs 	_GXCAbs1 					; calculate |y1-y0|
.cd96	ad96	49 ff		eor #$ff			eor 	#$FF
.cd98	ad98	1a		inc a				inc 	a
.cd99	ad99					_GXCAbs1:
.cd99	ad99	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cd9b	ad9b	b0 1c		bcs $adb9			bcs 	_GXOkayFail
.cd9d	ad9d	85 39		sta $39				sta 	gxzTemp1+1 					; save |y1-y0|
.cd9f	ad9f	38		sec				sec 								; calculate |x1-x0|
.cda0	ada0	b9 15 09	lda $0915,y			lda 	gxSpriteLow,y
.cda3	ada3	fd 15 09	sbc $0915,x			sbc 	gxSpriteLow,x
.cda6	ada6	b0 03		bcs $adab			bcs 	_GXCAbs2
.cda8	ada8	49 ff		eor #$ff			eor 	#$FF
.cdaa	adaa	1a		inc a				inc 	a
.cdab	adab					_GXCAbs2:
.cdab	adab	c5 38		cmp $38				cmp 	gxzTemp1 					; if >= difference then no overlap
.cdad	adad	b0 0a		bcs $adb9			bcs 	_GXOkayFail
.cdaf	adaf	c5 39		cmp $39				cmp 	gxzTemp1+1 					; is it less than the previous one.
.cdb1	adb1	90 02		bcc $adb5			bcc 	_GXCHaveLowest
.cdb3	adb3	a5 39		lda $39				lda 	gxzTemp1+1 					; if not, that's the smallest difference.
.cdb5	adb5					_GXCHaveLowest:
.cdb5	adb5	0a		asl a				asl 	a 							; scale to allow for >> 2
.cdb6	adb6	0a		asl a				asl 	a
.cdb7	adb7	18		clc				clc
.cdb8	adb8	60		rts				rts
.cdb9	adb9					_GXOkayFail:
.cdb9	adb9	18		clc				clc
.cdba	adba					_GXCollideFail:
.cdba	adba	a9 ff		lda #$ff			lda 	#$FF
.cdbc	adbc	60		rts				rts
.cdbd	adbd					GXFindSprite:
.cdbd	adbd	aa		tax				tax  								; sprite index in X
.cdbe	adbe	9c ae 09	stz $09ae			stz 	gxSpriteOffset 				; sprite offset is the offset in the sprite list.
.cdc1	adc1	9c af 09	stz $09af			stz 	gxSpriteOffset+1
.cdc4	adc4	64 38		stz $38				stz 	gxzTemp1 					; zTemp1 is the address in memory, given the current selected page.
.cdc6	adc6	a9 60		lda #$60			lda 	#GXMappingAddress >> 8
.cdc8	adc8	85 39		sta $39				sta 	gxzTemp1+1
.cdca	adca	ad 04 09	lda $0904			lda 	gxSpritePage 				; and point to the sprite page.
.cdcd	adcd	85 0b		sta $0b				sta 	GXEditSlot
.cdcf	adcf	b2 38		lda ($38)			lda 	(gxzTemp1) 					; get the first sprite record header, identifying the format.
.cdd1	add1	c9 11		cmp #$11			cmp 	#$11						; should be $11
.cdd3	add3	d0 6c		bne $ae41			bne 	_GXFSFail 					; if not, fail
.cdd5	add5	20 27 ae	jsr $ae27			jsr 	_GXFSIncrement 				; increment pointers.
.cdd8	add8					_GXFindLoop:
.cdd8	add8	b2 38		lda ($38)			lda 	(gxzTemp1) 					; reached the end, if so then failed.
.cdda	adda	c9 80		cmp #$80			cmp 	#$80
.cddc	addc	f0 63		beq $ae41			beq 	_GXFSFail
.cdde	adde	e0 00		cpx #$00			cpx 	#0 							; if zero, then found.
.cde0	ade0	f0 2c		beq $ae0e			beq 	_GXFSFound
.cde2	ade2	ca		dex				dex 								; decrement count.
.cde3	ade3	0a		asl a				asl 	a 							; index into table
.cde4	ade4	a8		tay				tay 								; so we can look it up.
.cde5	ade5	18		clc				clc 								; add LSB
.cde6	ade6	ad ae 09	lda $09ae			lda 	gxSpriteOffset
.cde9	ade9	79 43 ae	adc $ae43,y			adc 	_GXFSSizeTable,y
.cdec	adec	8d ae 09	sta $09ae			sta 	gxSpriteOffset 				; these two should move in lock step.
.cdef	adef	85 38		sta $38				sta 	gxzTemp1
.cdf1	adf1	90 05		bcc $adf8			bcc 	_GXNextNoCarry 				; adjust for carry as we add the MSB seperately.
.cdf3	adf3	ee af 09	inc $09af			inc 	gxSpriteOffset+1
.cdf6	adf6	e6 39		inc $39				inc 	gxzTemp1+1
.cdf8	adf8					_GXNextNoCarry:
.cdf8	adf8	18		clc				clc
.cdf9	adf9	a5 39		lda $39				lda 	gxzTemp1+1 					; add MSB
.cdfb	adfb	79 44 ae	adc $ae44,y			adc 	_GXFSSizeTable+1,y
.cdfe	adfe	85 39		sta $39				sta 	gxzTemp1+1
.ce00	ae00	ad af 09	lda $09af			lda 	gxSpriteOffset+1
.ce03	ae03	79 44 ae	adc $ae44,y			adc 	_GXFSSizeTable+1,y
.ce06	ae06	8d af 09	sta $09af			sta 	gxSpriteOffset+1
.ce09	ae09	20 33 ae	jsr $ae33			jsr 	_GXFSNormalise 				; and normalise the page address.
.ce0c	ae0c	80 ca		bra $add8			bra 	_GXFindLoop 				; and go round again.
.ce0e	ae0e					_GXFSFound:
.ce0e	ae0e	b2 38		lda ($38)			lda 	(gxzTemp1)					; get the bit size (e.g. 0-3)
.ce10	ae10	8d ac 09	sta $09ac			sta 	gxSizeBits
.ce13	ae13	1a		inc a				inc 	a 							; 1,2,3,4 - calculating pixel size
.ce14	ae14	0a		asl a				asl 	a 							; 2,4,6,8
.ce15	ae15	0a		asl a				asl 	a 							; 4,8,12,16
.ce16	ae16	0a		asl a				asl 	a 							; 8,16,24,32
.ce17	ae17	8d ab 09	sta $09ab			sta 	gxSizePixels
.ce1a	ae1a	20 27 ae	jsr $ae27			jsr 	_GXFSIncrement 				; and to the LUT
.ce1d	ae1d	b2 38		lda ($38)			lda 	(gxzTemp1) 					; copy that out.
.ce1f	ae1f	8d ad 09	sta $09ad			sta 	gxSpriteLUT
.ce22	ae22	20 27 ae	jsr $ae27			jsr 	_GXFSIncrement 				; and it now points to the first graphic data byte
.ce25	ae25	18		clc				clc
.ce26	ae26	60		rts				rts
.ce27	ae27					_GXFSIncrement:
.ce27	ae27	ee ae 09	inc $09ae			inc 	gxSpriteOffset 				; these two should move in sync
.ce2a	ae2a	e6 38		inc $38				inc 	gxzTemp1
.ce2c	ae2c	d0 05		bne $ae33			bne 	_GXFSNormalise
.ce2e	ae2e	ee af 09	inc $09af			inc 	gxSpriteOffset+1
.ce31	ae31	e6 39		inc $39				inc 	gxzTemp1+1
.ce33	ae33					_GXFSNormalise:
.ce33	ae33	a5 39		lda $39				lda 	gxzTemp1+1 					; are we out of range.
.ce35	ae35	c9 80		cmp #$80			cmp 	#(GXMappingAddress >> 8)+$20
.ce37	ae37	90 07		bcc $ae40			bcc 	_GXFSOkay
.ce39	ae39	e6 0b		inc $0b				inc 	GXEditSlot 					; next 8k page
.ce3b	ae3b	38		sec				sec 								; adjust page address back
.ce3c	ae3c	e9 20		sbc #$20			sbc 	#$20
.ce3e	ae3e	85 39		sta $39				sta 	gxzTemp1+1
.ce40	ae40					_GXFSOkay:
.ce40	ae40	60		rts				rts
.ce41	ae41					_GXFSFail:
.ce41	ae41	38		sec				sec
.ce42	ae42	60		rts				rts
.ce43	ae43					_GXFSSizeTable:
>ce43	ae43	42 00 02 01 42 02 02 04				.word 	8*8+2,16*16+2,24*24+2,32*32+2
.09ab						gxSizePixels:
>09ab								.fill 	1
.09ac						gxSizeBits:
>09ac								.fill 	1
.09ad						gxSpriteLUT:
>09ad								.fill 	1
.09ae						gxSpriteOffset:
>09ae								.fill 	2
.ce4b	ae4b					GXSortXY:
.ce4b	ae4b	20 69 ae	jsr $ae69			jsr 	GXSortY 					; will be sorted on Y now
.ce4e	ae4e	ad f8 08	lda $08f8			lda 	gxX0 						; compare X0 v X1
.ce51	ae51	cd fc 08	cmp $08fc			cmp 	gxX1
.ce54	ae54	ad f9 08	lda $08f9			lda 	gxX0+1
.ce57	ae57	ed fd 08	sbc $08fd			sbc 	gxX1+1
.ce5a	ae5a	90 0c		bcc $ae68			bcc 	_GXSXYExit 					; X0 < X1 exit
.ce5c	ae5c	a2 00		ldx #$00			ldx 	#0 							; swap them over
.ce5e	ae5e	a0 04		ldy #$04			ldy 	#4
.ce60	ae60	20 7d ae	jsr $ae7d			jsr 	GXSwapXY
.ce63	ae63	e8		inx				inx
.ce64	ae64	c8		iny				iny
.ce65	ae65	20 7d ae	jsr $ae7d			jsr 	GXSwapXY
.ce68	ae68					_GXSXYExit:
.ce68	ae68	60		rts				rts
.ce69	ae69					GXSortY:
.ce69	ae69	ad fa 08	lda $08fa			lda 	gxY0 						; if Y0 >= Y1
.ce6c	ae6c	cd fe 08	cmp $08fe			cmp 	gxY1
.ce6f	ae6f	90 0b		bcc $ae7c			bcc 	_GXSYSorted
.ce71	ae71	a2 03		ldx #$03			ldx 	#3 							; swap 3-0 - for lines we want to sort but keep lines together
.ce73	ae73	a0 07		ldy #$07			ldy 	#7 							; with 4-7
.ce75	ae75					_GXSwap1:
.ce75	ae75	20 7d ae	jsr $ae7d			jsr 	GXSwapXY
.ce78	ae78	88		dey				dey
.ce79	ae79	ca		dex				dex
.ce7a	ae7a	10 f9		bpl $ae75			bpl 	_GXSwap1
.ce7c	ae7c					_GXSYSorted:
.ce7c	ae7c	60		rts				rts
.ce7d	ae7d					GXSwapXY:
.ce7d	ae7d	bd f8 08	lda $08f8,x			lda 	gxX0,x
.ce80	ae80	48		pha				pha
.ce81	ae81	b9 f8 08	lda $08f8,y			lda 	gxX0,y
.ce84	ae84	9d f8 08	sta $08f8,x			sta 	gxX0,x
.ce87	ae87	68		pla				pla
.ce88	ae88	99 f8 08	sta $08f8,y			sta 	gxX0,y
.ce8b	ae8b	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/.build/tokeniser.module.asm

=1						tokeniserIntegrated=1
.ce8c	ae8c					KeywordSet0:
>ce8c	ae8c	00 65					.text	0,$65,""               ; $80 !0:EOF
>ce8e	ae8e	00 58					.text	0,$58,""               ; $81 !1:SH1
>ce90	ae90	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>ce92	ae92	04 fe 41 42 53 28			.text	4,$fe,"ABS("           ; $83 ABS(
>ce98	ae98	06 93 41 4c 4c 4f 43 28			.text	6,$93,"ALLOC("         ; $84 ALLOC(
>cea0	aea0	04 ff 41 53 43 28			.text	4,$ff,"ASC("           ; $85 ASC(
>cea6	aea6	05 29 43 48 52 24 28			.text	5,$29,"CHR$("          ; $86 CHR$(
>cead	aead	06 aa 45 56 45 4e 54 28			.text	6,$aa,"EVENT("         ; $87 EVENT(
>ceb5	aeb5	05 6b 46 41 4c 53 45			.text	5,$6b,"FALSE"          ; $88 FALSE
>cebc	aebc	05 44 46 52 41 43 28			.text	5,$44,"FRAC("          ; $89 FRAC(
>cec3	aec3	05 2c 47 45 54 24 28			.text	5,$2c,"GET$("          ; $8a GET$(
>ceca	aeca	04 08 47 45 54 28			.text	4,$08,"GET("           ; $8b GET(
>ced0	aed0	09 4a 47 45 54 44 41 54			.text	9,$4a,"GETDATE$("      ; $8c GETDATE$(
>ced8	aed8	45 24 28
>cedb	aedb	09 5b 47 45 54 54 49 4d			.text	9,$5b,"GETTIME$("      ; $8d GETTIME$(
>cee3	aee3	45 24 28
>cee6	aee6	04 0d 48 49 54 28			.text	4,$0d,"HIT("           ; $8e HIT(
>ceec	aeec	07 cc 49 4e 4b 45 59 24			.text	7,$cc,"INKEY$("        ; $8f INKEY$(
>cef4	aef4	28
>cef5	aef5	06 a8 49 4e 4b 45 59 28			.text	6,$a8,"INKEY("         ; $90 INKEY(
>cefd	aefd	04 13 49 4e 54 28			.text	4,$13,"INT("           ; $91 INT(
>cf03	af03	06 a7 49 53 56 41 4c 28			.text	6,$a7,"ISVAL("         ; $92 ISVAL(
>cf0b	af0b	0a e0 49 54 45 4d 43 4f			.text	10,$e0,"ITEMCOUNT("     ; $93 ITEMCOUNT(
>cf13	af13	55 4e 54 28
>cf17	af17	09 5b 49 54 45 4d 47 45			.text	9,$5b,"ITEMGET$("      ; $94 ITEMGET$(
>cf1f	af1f	54 24 28
>cf22	af22	05 5c 4a 4f 59 42 28			.text	5,$5c,"JOYB("          ; $95 JOYB(
>cf29	af29	05 72 4a 4f 59 58 28			.text	5,$72,"JOYX("          ; $96 JOYX(
>cf30	af30	05 73 4a 4f 59 59 28			.text	5,$73,"JOYY("          ; $97 JOYY(
>cf37	af37	08 49 4b 45 59 44 4f 57			.text	8,$49,"KEYDOWN("       ; $98 KEYDOWN(
>cf3f	af3f	4e 28
>cf41	af41	06 77 4c 45 46 54 24 28			.text	6,$77,"LEFT$("         ; $99 LEFT$(
>cf49	af49	04 07 4c 45 4e 28			.text	4,$07,"LEN("           ; $9a LEN(
>cf4f	af4f	04 0e 4d 41 58 28			.text	4,$0e,"MAX("           ; $9b MAX(
>cf55	af55	05 26 4d 49 44 24 28			.text	5,$26,"MID$("          ; $9c MID$(
>cf5c	af5c	04 0c 4d 49 4e 28			.text	4,$0c,"MIN("           ; $9d MIN(
>cf62	af62	04 19 4e 4f 54 28			.text	4,$19,"NOT("           ; $9e NOT(
>cf68	af68	05 4d 50 45 45 4b 28			.text	5,$4d,"PEEK("          ; $9f PEEK(
>cf6f	af6f	06 91 50 45 45 4b 44 28			.text	6,$91,"PEEKD("         ; $a0 PEEKD(
>cf77	af77	06 99 50 45 45 4b 4c 28			.text	6,$99,"PEEKL("         ; $a1 PEEKL(
>cf7f	af7f	06 a4 50 45 45 4b 57 28			.text	6,$a4,"PEEKW("         ; $a2 PEEKW(
>cf87	af87	08 3c 50 4c 41 59 49 4e			.text	8,$3c,"PLAYING("       ; $a3 PLAYING(
>cf8f	af8f	47 28
>cf91	af91	07 e9 52 41 4e 44 4f 4d			.text	7,$e9,"RANDOM("        ; $a4 RANDOM(
>cf99	af99	28
>cf9a	af9a	07 ca 52 49 47 48 54 24			.text	7,$ca,"RIGHT$("        ; $a5 RIGHT$(
>cfa2	afa2	28
>cfa3	afa3	04 0c 52 4e 44 28			.text	4,$0c,"RND("           ; $a6 RND(
>cfa9	afa9	08 0c 53 43 52 45 45 4e			.text	8,$0c,"SCREEN$("       ; $a7 SCREEN$(
>cfb1	afb1	24 28
>cfb3	afb3	07 e8 53 43 52 45 45 4e			.text	7,$e8,"SCREEN("        ; $a8 SCREEN(
>cfbb	afbb	28
>cfbc	afbc	04 10 53 47 4e 28			.text	4,$10,"SGN("           ; $a9 SGN(
>cfc2	afc2	04 0e 53 50 43 28			.text	4,$0e,"SPC("           ; $aa SPC(
>cfc8	afc8	05 45 53 54 52 24 28			.text	5,$45,"STR$("          ; $ab STR$(
>cfcf	afcf	05 56 54 49 4c 45 28			.text	5,$56,"TILE("          ; $ac TILE(
>cfd6	afd6	06 a9 54 49 4d 45 52 28			.text	6,$a9,"TIMER("         ; $ad TIMER(
>cfde	afde	04 40 54 52 55 45			.text	4,$40,"TRUE"           ; $ae TRUE
>cfe4	afe4	04 0b 56 41 4c 28			.text	4,$0b,"VAL("           ; $af VAL(
>cfea	afea	03 e7 46 4f 52				.text	3,$e7,"FOR"            ; $b0 FOR
>cfef	afef	02 8f 49 46				.text	2,$8f,"IF"             ; $b1 IF
>cff3	aff3	04 34 50 52 4f 43			.text	4,$34,"PROC"           ; $b2 PROC
>cff9	aff9	06 c1 52 45 50 45 41 54			.text	6,$c1,"REPEAT"         ; $b3 REPEAT
>d001	b001	05 79 57 48 49 4c 45			.text	5,$79,"WHILE"          ; $b4 WHILE
>d008	b008	05 66 45 4e 44 49 46			.text	5,$66,"ENDIF"          ; $b5 ENDIF
>d00f	b00f	07 0b 45 4e 44 50 52 4f			.text	7,$0b,"ENDPROC"        ; $b6 ENDPROC
>d017	b017	43
>d018	b018	04 3f 4e 45 58 54			.text	4,$3f,"NEXT"           ; $b7 NEXT
>d01e	b01e	04 2f 54 48 45 4e			.text	4,$2f,"THEN"           ; $b8 THEN
>d024	b024	05 8c 55 4e 54 49 4c			.text	5,$8c,"UNTIL"          ; $b9 UNTIL
>d02b	b02b	04 2e 57 45 4e 44			.text	4,$2e,"WEND"           ; $ba WEND
>d031	b031	02 95 41 54				.text	2,$95,"AT"             ; $bb AT
>d035	b035	02 9b 42 59				.text	2,$9b,"BY"             ; $bc BY
>d039	b039	04 1c 43 41 4c 4c			.text	4,$1c,"CALL"           ; $bd CALL
>d03f	b03f	06 b2 43 49 52 43 4c 45			.text	6,$b2,"CIRCLE"         ; $be CIRCLE
>d047	b047	05 67 43 4c 45 41 52			.text	5,$67,"CLEAR"          ; $bf CLEAR
>d04e	b04e	05 7f 43 4f 4c 4f 52			.text	5,$7f,"COLOR"          ; $c0 COLOR
>d055	b055	06 d4 43 4f 4c 4f 55 52			.text	6,$d4,"COLOUR"         ; $c1 COLOUR
>d05d	b05d	04 1a 44 41 54 41			.text	4,$1a,"DATA"           ; $c2 DATA
>d063	b063	03 da 44 49 4d				.text	3,$da,"DIM"            ; $c3 DIM
>d068	b068	06 db 44 4f 57 4e 54 4f			.text	6,$db,"DOWNTO"         ; $c4 DOWNTO
>d070	b070	04 29 45 4c 53 45			.text	4,$29,"ELSE"           ; $c5 ELSE
>d076	b076	04 34 46 52 4f 4d			.text	4,$34,"FROM"           ; $c6 FROM
>d07c	b07c	03 e5 47 46 58				.text	3,$e5,"GFX"            ; $c7 GFX
>d081	b081	04 24 48 45 52 45			.text	4,$24,"HERE"           ; $c8 HERE
>d087	b087	05 63 49 4d 41 47 45			.text	5,$63,"IMAGE"          ; $c9 IMAGE
>d08e	b08e	03 e5 4c 45 54				.text	3,$e5,"LET"            ; $ca LET
>d093	b093	04 28 4c 49 4e 45			.text	4,$28,"LINE"           ; $cb LINE
>d099	b099	05 6b 4c 4f 43 41 4c			.text	5,$6b,"LOCAL"          ; $cc LOCAL
>d0a0	b0a0	07 1a 4d 45 4d 43 4f 50			.text	7,$1a,"MEMCOPY"        ; $cd MEMCOPY
>d0a8	b0a8	59
>d0a9	b0a9	03 db 4f 46 46				.text	3,$db,"OFF"            ; $ce OFF
>d0ae	b0ae	02 9d 4f 4e				.text	2,$9d,"ON"             ; $cf ON
>d0b2	b0b2	07 20 4f 55 54 4c 49 4e			.text	7,$20,"OUTLINE"        ; $d0 OUTLINE
>d0ba	b0ba	45
>d0bb	b0bb	07 0f 50 41 4c 45 54 54			.text	7,$0f,"PALETTE"        ; $d1 PALETTE
>d0c3	b0c3	45
>d0c4	b0c4	04 3f 50 4c 4f 54			.text	4,$3f,"PLOT"           ; $d2 PLOT
>d0ca	b0ca	04 2f 50 4f 4b 45			.text	4,$2f,"POKE"           ; $d3 POKE
>d0d0	b0d0	05 73 50 4f 4b 45 44			.text	5,$73,"POKED"          ; $d4 POKED
>d0d7	b0d7	05 7b 50 4f 4b 45 4c			.text	5,$7b,"POKEL"          ; $d5 POKEL
>d0de	b0de	05 86 50 4f 4b 45 57			.text	5,$86,"POKEW"          ; $d6 POKEW
>d0e5	b0e5	04 1c 52 45 41 44			.text	4,$1c,"READ"           ; $d7 READ
>d0eb	b0eb	04 2e 52 45 43 54			.text	4,$2e,"RECT"           ; $d8 RECT
>d0f1	b0f1	03 e4 52 45 4d				.text	3,$e4,"REM"            ; $d9 REM
>d0f6	b0f6	05 7b 53 4f 4c 49 44			.text	5,$7b,"SOLID"          ; $da SOLID
>d0fd	b0fd	05 89 53 4f 55 4e 44			.text	5,$89,"SOUND"          ; $db SOUND
>d104	b104	06 d7 53 50 52 49 54 45			.text	6,$d7,"SPRITE"         ; $dc SPRITE
>d10c	b10c	04 45 54 45 58 54			.text	4,$45,"TEXT"           ; $dd TEXT
>d112	b112	02 a3 54 4f				.text	2,$a3,"TO"             ; $de TO
>d116	b116	ff					.text	$FF
.d117	b117					KeywordSet1:
>d117	b117	00 65					.text	0,$65,""               ; $80 !0:EOF
>d119	b119	00 58					.text	0,$58,""               ; $81 !1:SH1
>d11b	b11b	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>d11d	b11d	08 4c 41 53 53 45 4d 42			.text	8,$4c,"ASSEMBLE"       ; $83 ASSEMBLE
>d125	b125	4c 45
>d127	b127	06 d2 41 53 53 45 52 54			.text	6,$d2,"ASSERT"         ; $84 ASSERT
>d12f	b12f	06 bd 42 49 54 4d 41 50			.text	6,$bd,"BITMAP"         ; $85 BITMAP
>d137	b137	05 62 42 4c 4f 41 44			.text	5,$62,"BLOAD"          ; $86 BLOAD
>d13e	b13e	05 71 42 53 41 56 45			.text	5,$71,"BSAVE"          ; $87 BSAVE
>d145	b145	03 e2 43 4c 53				.text	3,$e2,"CLS"            ; $88 CLS
>d14a	b14a	06 d0 43 50 52 49 4e 54			.text	6,$d0,"CPRINT"         ; $89 CPRINT
>d152	b152	06 de 43 55 52 53 4f 52			.text	6,$de,"CURSOR"         ; $8a CURSOR
>d15a	b15a	03 df 44 49 52				.text	3,$df,"DIR"            ; $8b DIR
>d15f	b15f	05 7a 44 52 49 56 45			.text	5,$7a,"DRIVE"          ; $8c DRIVE
>d166	b166	03 d7 45 4e 44				.text	3,$d7,"END"            ; $8d END
>d16b	b16b	07 11 45 58 50 4c 4f 44			.text	7,$11,"EXPLODE"        ; $8e EXPLODE
>d173	b173	45
>d174	b174	02 96 47 4f				.text	2,$96,"GO"             ; $8f GO
>d178	b178	05 80 47 4f 53 55 42			.text	5,$80,"GOSUB"          ; $90 GOSUB
>d17f	b17f	04 39 47 4f 54 4f			.text	4,$39,"GOTO"           ; $91 GOTO
>d185	b185	05 70 48 49 4d 45 4d			.text	5,$70,"HIMEM"          ; $92 HIMEM
>d18c	b18c	05 90 49 4e 50 55 54			.text	5,$90,"INPUT"          ; $93 INPUT
>d193	b193	04 3c 4c 49 53 54			.text	4,$3c,"LIST"           ; $94 LIST
>d199	b199	04 20 4c 4f 41 44			.text	4,$20,"LOAD"           ; $95 LOAD
>d19f	b19f	06 b7 4d 44 45 4c 54 41			.text	6,$b7,"MDELTA"         ; $96 MDELTA
>d1a7	b1a7	05 89 4d 4f 55 53 45			.text	5,$89,"MOUSE"          ; $97 MOUSE
>d1ae	b1ae	03 ea 4e 45 57				.text	3,$ea,"NEW"            ; $98 NEW
>d1b3	b1b3	06 d9 4f 50 54 49 4f 4e			.text	6,$d9,"OPTION"         ; $99 OPTION
>d1bb	b1bb	04 2e 50 49 4e 47			.text	4,$2e,"PING"           ; $9a PING
>d1c1	b1c1	05 8d 50 52 49 4e 54			.text	5,$8d,"PRINT"          ; $9b PRINT
>d1c8	b1c8	07 24 52 45 53 54 4f 52			.text	7,$24,"RESTORE"        ; $9c RESTORE
>d1d0	b1d0	45
>d1d1	b1d1	06 e0 52 45 54 55 52 4e			.text	6,$e0,"RETURN"         ; $9d RETURN
>d1d9	b1d9	03 f5 52 55 4e				.text	3,$f5,"RUN"            ; $9e RUN
>d1de	b1de	04 2f 53 41 56 45			.text	4,$2f,"SAVE"           ; $9f SAVE
>d1e4	b1e4	07 0a 53 45 54 44 41 54			.text	7,$0a,"SETDATE"        ; $a0 SETDATE
>d1ec	b1ec	45
>d1ed	b1ed	07 1b 53 45 54 54 49 4d			.text	7,$1b,"SETTIME"        ; $a1 SETTIME
>d1f5	b1f5	45
>d1f6	b1f6	05 8d 53 48 4f 4f 54			.text	5,$8d,"SHOOT"          ; $a2 SHOOT
>d1fd	b1fd	07 2a 53 50 52 49 54 45			.text	7,$2a,"SPRITES"        ; $a3 SPRITES
>d205	b205	53
>d206	b206	04 46 53 54 4f 50			.text	4,$46,"STOP"           ; $a4 STOP
>d20c	b20c	04 2e 54 49 4c 45			.text	4,$2e,"TILE"           ; $a5 TILE
>d212	b212	05 81 54 49 4c 45 53			.text	5,$81,"TILES"          ; $a6 TILES
>d219	b219	03 ff 54 52 59				.text	3,$ff,"TRY"            ; $a7 TRY
>d21e	b21e	06 d5 56 45 52 49 46 59			.text	6,$d5,"VERIFY"         ; $a8 VERIFY
>d226	b226	03 ee 58 47 4f				.text	3,$ee,"XGO"            ; $a9 XGO
>d22b	b22b	05 78 58 4c 4f 41 44			.text	5,$78,"XLOAD"          ; $aa XLOAD
>d232	b232	03 eb 5a 41 50				.text	3,$eb,"ZAP"            ; $ab ZAP
>d237	b237	ff					.text	$FF
.d238	b238					KeywordSet2:
>d238	b238	00 65					.text	0,$65,""               ; $80 !0:EOF
>d23a	b23a	00 58					.text	0,$58,""               ; $81 !1:SH1
>d23c	b23c	00 5a					.text	0,$5a,""               ; $82 !2:SH2
>d23e	b23e	03 c8 41 44 43				.text	3,$c8,"ADC"            ; $83 ADC
>d243	b243	03 d3 41 4e 44				.text	3,$d3,"AND"            ; $84 AND
>d248	b248	03 e0 41 53 4c				.text	3,$e0,"ASL"            ; $85 ASL
>d24d	b24d	03 c8 42 43 43				.text	3,$c8,"BCC"            ; $86 BCC
>d252	b252	03 d8 42 43 53				.text	3,$d8,"BCS"            ; $87 BCS
>d257	b257	03 d8 42 45 51				.text	3,$d8,"BEQ"            ; $88 BEQ
>d25c	b25c	03 df 42 49 54				.text	3,$df,"BIT"            ; $89 BIT
>d261	b261	03 d8 42 4d 49				.text	3,$d8,"BMI"            ; $8a BMI
>d266	b266	03 d5 42 4e 45				.text	3,$d5,"BNE"            ; $8b BNE
>d26b	b26b	03 de 42 50 4c				.text	3,$de,"BPL"            ; $8c BPL
>d270	b270	03 d5 42 52 41				.text	3,$d5,"BRA"            ; $8d BRA
>d275	b275	03 df 42 52 4b				.text	3,$df,"BRK"            ; $8e BRK
>d27a	b27a	03 db 42 56 43				.text	3,$db,"BVC"            ; $8f BVC
>d27f	b27f	03 eb 42 56 53				.text	3,$eb,"BVS"            ; $90 BVS
>d284	b284	03 d2 43 4c 43				.text	3,$d2,"CLC"            ; $91 CLC
>d289	b289	03 d3 43 4c 44				.text	3,$d3,"CLD"            ; $92 CLD
>d28e	b28e	03 d8 43 4c 49				.text	3,$d8,"CLI"            ; $93 CLI
>d293	b293	03 e5 43 4c 56				.text	3,$e5,"CLV"            ; $94 CLV
>d298	b298	03 e0 43 4d 50				.text	3,$e0,"CMP"            ; $95 CMP
>d29d	b29d	03 eb 43 50 58				.text	3,$eb,"CPX"            ; $96 CPX
>d2a2	b2a2	03 ec 43 50 59				.text	3,$ec,"CPY"            ; $97 CPY
>d2a7	b2a7	03 cc 44 45 43				.text	3,$cc,"DEC"            ; $98 DEC
>d2ac	b2ac	03 e1 44 45 58				.text	3,$e1,"DEX"            ; $99 DEX
>d2b1	b2b1	03 e2 44 45 59				.text	3,$e2,"DEY"            ; $9a DEY
>d2b6	b2b6	03 e6 45 4f 52				.text	3,$e6,"EOR"            ; $9b EOR
>d2bb	b2bb	03 da 49 4e 43				.text	3,$da,"INC"            ; $9c INC
>d2c0	b2c0	03 ef 49 4e 58				.text	3,$ef,"INX"            ; $9d INX
>d2c5	b2c5	03 f0 49 4e 59				.text	3,$f0,"INY"            ; $9e INY
>d2ca	b2ca	03 e7 4a 4d 50				.text	3,$e7,"JMP"            ; $9f JMP
>d2cf	b2cf	03 ef 4a 53 52				.text	3,$ef,"JSR"            ; $a0 JSR
>d2d4	b2d4	03 d1 4c 44 41				.text	3,$d1,"LDA"            ; $a1 LDA
>d2d9	b2d9	03 e8 4c 44 58				.text	3,$e8,"LDX"            ; $a2 LDX
>d2de	b2de	03 e9 4c 44 59				.text	3,$e9,"LDY"            ; $a3 LDY
>d2e3	b2e3	03 f1 4c 53 52				.text	3,$f1,"LSR"            ; $a4 LSR
>d2e8	b2e8	03 ed 4e 4f 50				.text	3,$ed,"NOP"            ; $a5 NOP
>d2ed	b2ed	03 e2 4f 52 41				.text	3,$e2,"ORA"            ; $a6 ORA
>d2f2	b2f2	03 d9 50 48 41				.text	3,$d9,"PHA"            ; $a7 PHA
>d2f7	b2f7	03 e8 50 48 50				.text	3,$e8,"PHP"            ; $a8 PHP
>d2fc	b2fc	03 f0 50 48 58				.text	3,$f0,"PHX"            ; $a9 PHX
>d301	b301	03 f1 50 48 59				.text	3,$f1,"PHY"            ; $aa PHY
>d306	b306	03 dd 50 4c 41				.text	3,$dd,"PLA"            ; $ab PLA
>d30b	b30b	03 ec 50 4c 50				.text	3,$ec,"PLP"            ; $ac PLP
>d310	b310	03 f4 50 4c 58				.text	3,$f4,"PLX"            ; $ad PLX
>d315	b315	03 f5 50 4c 59				.text	3,$f5,"PLY"            ; $ae PLY
>d31a	b31a	03 ed 52 4f 4c				.text	3,$ed,"ROL"            ; $af ROL
>d31f	b31f	03 f3 52 4f 52				.text	3,$f3,"ROR"            ; $b0 ROR
>d324	b324	03 ef 52 54 49				.text	3,$ef,"RTI"            ; $b1 RTI
>d329	b329	03 f9 52 54 53				.text	3,$f9,"RTS"            ; $b2 RTS
>d32e	b32e	03 d8 53 42 43				.text	3,$d8,"SBC"            ; $b3 SBC
>d333	b333	03 db 53 45 43				.text	3,$db,"SEC"            ; $b4 SEC
>d338	b338	03 dc 53 45 44				.text	3,$dc,"SED"            ; $b5 SED
>d33d	b33d	03 e1 53 45 49				.text	3,$e1,"SEI"            ; $b6 SEI
>d342	b342	03 e8 53 54 41				.text	3,$e8,"STA"            ; $b7 STA
>d347	b347	03 f7 53 54 50				.text	3,$f7,"STP"            ; $b8 STP
>d34c	b34c	03 ff 53 54 58				.text	3,$ff,"STX"            ; $b9 STX
>d351	b351	03 00 53 54 59				.text	3,$00,"STY"            ; $ba STY
>d356	b356	03 01 53 54 5a				.text	3,$01,"STZ"            ; $bb STZ
>d35b	b35b	03 ed 54 41 58				.text	3,$ed,"TAX"            ; $bc TAX
>d360	b360	03 ee 54 41 59				.text	3,$ee,"TAY"            ; $bd TAY
>d365	b365	03 e8 54 52 42				.text	3,$e8,"TRB"            ; $be TRB
>d36a	b36a	03 e9 54 53 42				.text	3,$e9,"TSB"            ; $bf TSB
>d36f	b36f	03 ff 54 53 58				.text	3,$ff,"TSX"            ; $c0 TSX
>d374	b374	03 ed 54 58 41				.text	3,$ed,"TXA"            ; $c1 TXA
>d379	b379	03 ff 54 58 53				.text	3,$ff,"TXS"            ; $c2 TXS
>d37e	b37e	03 ee 54 59 41				.text	3,$ee,"TYA"            ; $c3 TYA
>d383	b383	ff					.text	$FF
.d384	b384					Export_TKInitialise:
.d384	b384	a2 07		ldx #$07			ldx 	#7
.d386	b386					_ETKISetDefault:
.d386	b386	bd db b5	lda $b5db,x			lda 	CLIDefault,x
.d389	b389	9d 00 04	sta $0400,x			sta 	CLIFComment,x
.d38c	b38c	ca		dex				dex
.d38d	b38d	10 f7		bpl $b386			bpl 	_ETKISetDefault
.d38f	b38f	60		rts				rts
.d390	b390					Export_TKListConvertLine:
.d390	b390	48		pha				pha 								; save indent on the stack
.d391	b391	9c 39 04	stz $0439			stz 	tbOffset
.d394	b394	9c 49 04	stz $0449			stz 	tokenBuffer
.d397	b397	9c 45 04	stz $0445			stz 	currentListColour
.d39a	b39a	ad 02 04	lda $0402			lda 	CLILineNumber
.d39d	b39d	20 25 b5	jsr $b525			jsr 	LCLWriteColour
.d3a0	b3a0	a0 02		ldy #$02			ldy 	#2 							; convert line number to string
.d3a2	b3a2	b1 30		lda ($30),y			lda 	(codePtr),y
.d3a4	b3a4	aa		tax				tax
.d3a5	b3a5	88		dey				dey
.d3a6	b3a6	b1 30		lda ($30),y			lda 	(codePtr),y
.d3a8	b3a8	20 9a b5	jsr $b59a			jsr 	LCLWriteNumberXA
.d3ab	b3ab	68		pla				pla 								; adjustment to indent
.d3ac	b3ac	48		pha				pha 								; save on stack
.d3ad	b3ad	10 0c		bpl $b3bb			bpl 	_LCNoAdjust 				; don't adjust indent if +ve, do after.
.d3af	b3af	18		clc				clc 								; add to list indent and make 0 if goes -ve.
.d3b0	b3b0	6d 42 04	adc $0442			adc 	listIndent
.d3b3	b3b3	8d 42 04	sta $0442			sta 	listIndent
.d3b6	b3b6	10 03		bpl $b3bb			bpl 	_LCNoAdjust
.d3b8	b3b8	9c 42 04	stz $0442			stz 	listIndent
.d3bb	b3bb					_LCNoAdjust:
.d3bb	b3bb	18		clc				clc		 							; work out actual indent.
.d3bc	b3bc	ad 42 04	lda $0442			lda 	listIndent
.d3bf	b3bf	0a		asl a				asl 	a
.d3c0	b3c0	69 07		adc #$07			adc 	#7
.d3c2	b3c2	85 36		sta $36				sta 	zTemp0
.d3c4	b3c4					_LCPadOut:
.d3c4	b3c4	a9 20		lda #$20			lda 	#' '						; pad out to 6+indent characters
.d3c6	b3c6	20 32 b5	jsr $b532			jsr 	LCLWrite
.d3c9	b3c9	ad 39 04	lda $0439			lda 	tbOffset
.d3cc	b3cc	c5 36		cmp $36				cmp 	zTemp0
.d3ce	b3ce	d0 f4		bne $b3c4			bne 	_LCPadOut
.d3d0	b3d0	a0 03		ldy #$03			ldy 	#3 							; start position.
.d3d2	b3d2					_LCMainLoop:
.d3d2	b3d2	ad 06 04	lda $0406			lda 	CLIPunctuation
.d3d5	b3d5	20 25 b5	jsr $b525			jsr 	LCLWriteColour
.d3d8	b3d8	b1 30		lda ($30),y			lda 	(codePtr),y
.d3da	b3da	c9 80		cmp #$80			cmp 	#KWC_EOL 					; end of line ?
.d3dc	b3dc	f0 17		beq $b3f5			beq 	_LCExit
.d3de	b3de	c9 10		cmp #$10			cmp 	#16 						; 0-5 are the double punctuations
.d3e0	b3e0	90 1e		bcc $b400			bcc 	_LCDoubles
.d3e2	b3e2	c9 20		cmp #$20			cmp 	#32 						; 16-31 are shifted punctuation from 64-91
.d3e4	b3e4	90 2a		bcc $b410			bcc 	_LCShiftPunc
.d3e6	b3e6	c9 40		cmp #$40			cmp 	#64 						; 32-64 are as stored, punc and digits
.d3e8	b3e8	90 35		bcc $b41f			bcc 	_LCPunctuation
.d3ea	b3ea	c9 80		cmp #$80			cmp 	#128 						; 64-127 are variable identifiers.
.d3ec	b3ec	90 52		bcc $b440			bcc 	_LCIdentifiers
.d3ee	b3ee	c9 fe		cmp #$fe			cmp 	#254 						; 128-253 are tokenised words
.d3f0	b3f0	90 75		bcc $b467			bcc 	_LCTokens
.d3f2	b3f2	4c c8 b4	jmp $b4c8			jmp 	_LCData 					; 254-5 are data objects
.d3f5	b3f5					_LCExit:
.d3f5	b3f5	68		pla				pla 								; get old indent adjust
.d3f6	b3f6	30 07		bmi $b3ff			bmi 	_LCExit2
.d3f8	b3f8	18		clc				clc 								; add to indent if +ve
.d3f9	b3f9	6d 42 04	adc $0442			adc 	listIndent
.d3fc	b3fc	8d 42 04	sta $0442			sta 	listIndent
.d3ff	b3ff					_LCExit2:
.d3ff	b3ff	60		rts				rts
.d400	b400					_LCDoubles:
.d400	b400	48		pha				pha
.d401	b401	4a		lsr a				lsr 	a 							; put bit 2 into bit 1
.d402	b402	29 02		and #$02			and 	#2
.d404	b404	09 3c		ora #$3c			ora 	#60 						; make < >
.d406	b406	20 32 b5	jsr $b532			jsr 	LCLWrite
.d409	b409	68		pla				pla 								; restore, do lower bit
.d40a	b40a	29 03		and #$03			and 	#3
.d40c	b40c	09 3c		ora #$3c			ora 	#60
.d40e	b40e	80 0f		bra $b41f			bra		_LCPunctuation 				; print, increment, loop
.d410	b410					_LCShiftPunc:
.d410	b410	aa		tax				tax 								; save in X
.d411	b411	29 07		and #$07			and 	#7 							; lower 3 bits
.d413	b413	f0 02		beq $b417			beq 	_LCNoAdd
.d415	b415	09 18		ora #$18			ora 	#24 						; adds $18 to it.
.d417	b417					_LCNoAdd:
.d417	b417	e0 18		cpx #$18			cpx 	#24 						; if >= 24 add $20
.d419	b419	90 02		bcc $b41d			bcc 	_LCNoAdd2
.d41b	b41b	09 20		ora #$20			ora 	#32 						; adds $20
.d41d	b41d					_LCNoAdd2:
.d41d	b41d	09 40		ora #$40			ora 	#$40 						; shift into 64-127 range and fall through.
.d41f	b41f					_LCPunctuation:
.d41f	b41f	c9 3a		cmp #$3a			cmp 	#':' 						; check if :
.d421	b421	d0 03		bne $b426			bne 	_LCPContinue
.d423	b423	20 48 b5	jsr $b548			jsr 	LCLDeleteLastSpace 			; if so delete any preceding spaces
.d426	b426					_LCPContinue:
.d426	b426	c9 2e		cmp #$2e			cmp 	#'.'
.d428	b428	f0 08		beq $b432			beq 	_LCPIsConstant
.d42a	b42a	c9 30		cmp #$30			cmp 	#'0'
.d42c	b42c	90 0c		bcc $b43a			bcc 	_LCPNotConstant
.d42e	b42e	c9 3a		cmp #$3a			cmp 	#'9'+1
.d430	b430	b0 08		bcs $b43a			bcs 	_LCPNotConstant
.d432	b432					_LCPIsConstant:
.d432	b432	48		pha				pha
.d433	b433	ad 04 04	lda $0404			lda 	CLIConstant
.d436	b436	20 25 b5	jsr $b525			jsr 	LCLWriteColour
.d439	b439	68		pla				pla
.d43a	b43a					_LCPNotConstant:
.d43a	b43a	c8		iny				iny 								; consume character
.d43b	b43b	20 32 b5	jsr $b532			jsr 	LCLWrite 					; write it out.
.d43e	b43e	80 92		bra $b3d2			bra 	_LCMainLoop 				; go round again.
.d440	b440					_LCIdentifiers:
.d440	b440	18		clc				clc 								; convert to physical address
.d441	b441	69 d0		adc #$d0			adc 	#((VariableSpace >> 8) - $40) & $FF
.d443	b443	85 37		sta $37				sta 	zTemp0+1
.d445	b445	c8		iny				iny
.d446	b446	b1 30		lda ($30),y			lda 	(codePtr),y
.d448	b448	85 36		sta $36				sta 	zTemp0
.d44a	b44a	c8		iny				iny
.d44b	b44b	5a		phy				phy 								; save position
.d44c	b44c	ad 05 04	lda $0405			lda 	CLIIdentifier
.d44f	b44f	20 25 b5	jsr $b525			jsr 	LCLWriteColour
.d452	b452	a0 07		ldy #$07			ldy 	#7 							; output the identifier at +8
.d454	b454					_LCOutIdentifier:
.d454	b454	c8		iny				iny
.d455	b455	b1 36		lda ($36),y			lda 	(zTemp0),y					; bit 7 set = end.
.d457	b457	29 7f		and #$7f			and 	#$7F
.d459	b459	20 84 b5	jsr $b584			jsr 	LCLLowerCase
.d45c	b45c	20 32 b5	jsr $b532			jsr 	LCLWrite
.d45f	b45f	b1 36		lda ($36),y			lda 	(zTemp0),y				 	; ends when bit 7 set.
.d461	b461	10 f1		bpl $b454			bpl 	_LCOutIdentifier
.d463	b463	7a		ply				ply 								; restore position
.d464	b464	4c d2 b3	jmp $b3d2			jmp 	_LCMainLoop
.d467	b467					_LCTokens:
.d467	b467	aa		tax				tax 								; token in X
.d468	b468	a9 38		lda #$38			lda 	#((KeywordSet2) & $FF)
.d46a	b46a	85 36		sta $36				sta 	0+zTemp0
.d46c	b46c	a9 b2		lda #$b2			lda 	#((KeywordSet2) >> 8)
.d46e	b46e	85 37		sta $37				sta 	1+zTemp0
.d470	b470	e0 82		cpx #$82			cpx 	#$82
.d472	b472	f0 16		beq $b48a			beq 	_LCUseShift
.d474	b474	a9 17		lda #$17			lda 	#((KeywordSet1) & $FF)
.d476	b476	85 36		sta $36				sta 	0+zTemp0
.d478	b478	a9 b1		lda #$b1			lda 	#((KeywordSet1) >> 8)
.d47a	b47a	85 37		sta $37				sta 	1+zTemp0
.d47c	b47c	e0 81		cpx #$81			cpx 	#$81
.d47e	b47e	f0 0a		beq $b48a			beq 	_LCUseShift
.d480	b480	a9 8c		lda #$8c			lda 	#((KeywordSet0) & $FF)
.d482	b482	85 36		sta $36				sta 	0+zTemp0
.d484	b484	a9 ae		lda #$ae			lda 	#((KeywordSet0) >> 8)
.d486	b486	85 37		sta $37				sta 	1+zTemp0
.d488	b488	80 01		bra $b48b			bra 	_LCNoShift
.d48a	b48a					_LCUseShift:
.d48a	b48a	c8		iny				iny
.d48b	b48b					_LCNoShift:
.d48b	b48b	20 5c b5	jsr $b55c			jsr 	LCLCheckSpaceRequired 		; do we need a space ?
.d48e	b48e	b1 30		lda ($30),y			lda 	(codePtr),y
.d490	b490	aa		tax				tax 								; into X
.d491	b491					_LCFindText:
.d491	b491	ca		dex				dex
.d492	b492	10 0e		bpl $b4a2			bpl 	_LCFoundText 				; found text.
.d494	b494	b2 36		lda ($36)			lda 	(zTemp0) 					; length of text
.d496	b496	1a		inc a				inc 	a 							; one extra for size
.d497	b497	38		sec				sec 								; one extra for checksum
.d498	b498	65 36		adc $36				adc 	zTemp0 						; go to next token
.d49a	b49a	85 36		sta $36				sta 	zTemp0
.d49c	b49c	90 f3		bcc $b491			bcc 	_LCFindText
.d49e	b49e	e6 37		inc $37				inc 	zTemp0+1
.d4a0	b4a0	80 ef		bra $b491			bra 	_LCFindText
.d4a2	b4a2					_LCFoundText:
.d4a2	b4a2	5a		phy				phy 								; save List position
.d4a3	b4a3	b2 36		lda ($36)			lda 	(zTemp0)					; count to print
.d4a5	b4a5	aa		tax				tax
.d4a6	b4a6	ad 03 04	lda $0403			lda 	CLIToken
.d4a9	b4a9	20 25 b5	jsr $b525			jsr 	LCLWriteColour
.d4ac	b4ac	a0 02		ldy #$02			ldy 	#2
.d4ae	b4ae					_LCCopyToken:
.d4ae	b4ae	b1 36		lda ($36),y			lda 	(zTemp0),y
.d4b0	b4b0	20 84 b5	jsr $b584			jsr 	LCLLowerCase
.d4b3	b4b3	20 32 b5	jsr $b532			jsr 	LCLWrite
.d4b6	b4b6	c8		iny				iny
.d4b7	b4b7	ca		dex				dex
.d4b8	b4b8	d0 f4		bne $b4ae			bne 	_LCCopyToken
.d4ba	b4ba	c9 28		cmp #$28			cmp 	#"(" 						; if last char not ( print a space
.d4bc	b4bc	f0 05		beq $b4c3			beq 	_LCNoSpace
.d4be	b4be	a9 20		lda #$20			lda 	#' '
.d4c0	b4c0	20 32 b5	jsr $b532			jsr 	LCLWrite
.d4c3	b4c3					_LCNoSpace:
.d4c3	b4c3	7a		ply				ply 								; restore position.
.d4c4	b4c4	c8		iny				iny 								; consume token
.d4c5	b4c5	4c d2 b3	jmp $b3d2			jmp 	_LCMainLoop 				; and go around again.
.d4c8	b4c8					_LCData:
.d4c8	b4c8	48		pha				pha 								; save type $FE/$FF
.d4c9	b4c9	a2 24		ldx #$24			ldx 	#'$' 						; figure out $ or "
.d4cb	b4cb	c9 fe		cmp #$fe			cmp 	#$FE
.d4cd	b4cd	f0 29		beq $b4f8			beq 	_LCHaveOpener
.d4cf	b4cf	a2 22		ldx #$22			ldx 	#'"'
.d4d1	b4d1	ad 07 04	lda $0407			lda 	CLIData
.d4d4	b4d4	20 25 b5	jsr $b525			jsr 	LCLWriteColour
.d4d7	b4d7	c0 04		cpy #$04			cpy 	#4 							; must be 2nd thing on line
.d4d9	b4d9	d0 1d		bne $b4f8			bne 	_LCHaveOpener
.d4db	b4db	88		dey				dey 								; what precedes it ?
.d4dc	b4dc	b1 30		lda ($30),y			lda 	(codePtr),y
.d4de	b4de	c8		iny				iny
.d4df	b4df	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; if quote
.d4e1	b4e1	d0 15		bne $b4f8			bne 	_LCHaveOpener
.d4e3	b4e3	a9 09		lda #$09			lda 	#9 							; tab
.d4e5	b4e5	20 32 b5	jsr $b532			jsr 	LCLWrite
.d4e8	b4e8	ad 01 04	lda $0401			lda 	CLIBComment
.d4eb	b4eb	30 0b		bmi $b4f8			bmi 	_LCHaveOpener
.d4ed	b4ed	09 90		ora #$90			ora 	#$90
.d4ef	b4ef	20 32 b5	jsr $b532			jsr 	LCLWrite
.d4f2	b4f2	ad 00 04	lda $0400			lda 	CLIFComment
.d4f5	b4f5	20 25 b5	jsr $b525			jsr 	LCLWriteColour
.d4f8	b4f8					_LCHaveOpener:
.d4f8	b4f8	8a		txa				txa 								; output prefix (# or ")
.d4f9	b4f9	20 32 b5	jsr $b532			jsr 	LCLWrite
.d4fc	b4fc	c8		iny				iny 								; get count
.d4fd	b4fd	b1 30		lda ($30),y			lda 	(codePtr),y
.d4ff	b4ff	aa		tax				tax
.d500	b500	c8		iny				iny 								; point at first character
.d501	b501					_LCOutData:
.d501	b501	b1 30		lda ($30),y			lda 	(codePtr),y
.d503	b503	c9 00		cmp #$00			cmp 	#0
.d505	b505	f0 03		beq $b50a			beq 	_LCNoPrint
.d507	b507	20 32 b5	jsr $b532			jsr 	LCLWrite
.d50a	b50a					_LCNoPrint:
.d50a	b50a	c8		iny				iny
.d50b	b50b	ca		dex				dex
.d50c	b50c	d0 f3		bne $b501			bne 	_LCOutData
.d50e	b50e	68		pla				pla 								; closing " required ?
.d50f	b50f	c9 ff		cmp #$ff			cmp 	#$FF 						; not required for hex constant.
.d511	b511	d0 0f		bne $b522			bne 	_LCNoQuote
.d513	b513	a9 22		lda #$22			lda 	#'"'
.d515	b515	20 32 b5	jsr $b532			jsr 	LCLWrite
.d518	b518	ad ec 07	lda $07ec			lda 	EXTTextColour
.d51b	b51b	29 0f		and #$0f			and 	#$0F
.d51d	b51d	09 90		ora #$90			ora 	#$90
.d51f	b51f	20 32 b5	jsr $b532			jsr 	LCLWrite
.d522	b522					_LCNoQuote:
.d522	b522	4c d2 b3	jmp $b3d2			jmp 	_LCMainLoop
.d525	b525					LCLWriteColour:
.d525	b525	29 0f		and #$0f			and 	#$0F
.d527	b527	09 80		ora #$80			ora 	#$80
.d529	b529	cd 45 04	cmp $0445			cmp 	currentListColour 			; has the colour changed
.d52c	b52c	8d 45 04	sta $0445			sta 	currentListColour 			; (update it anyway)
.d52f	b52f	d0 01		bne $b532			bne 	LCLWrite 					; if different, output it
.d531	b531	60		rts				rts
.d532	b532					LCLWrite:
.d532	b532	da		phx				phx
.d533	b533	ae 39 04	ldx $0439			ldx 	tbOffset 					; write out make ASCIIZ
.d536	b536	9d 49 04	sta $0449,x			sta 	tokenBuffer,x
.d539	b539	9e 4a 04	stz $044a,x			stz 	tokenBuffer+1,x
.d53c	b53c	ee 39 04	inc $0439			inc 	tbOffset 					; bump the position
.d53f	b53f	09 00		ora #$00			ora 	#0 							; don't update last character if colour data
.d541	b541	30 03		bmi $b546			bmi 	_LCLNoColour
.d543	b543	8d 43 04	sta $0443			sta 	lcLastCharacter
.d546	b546					_LCLNoColour:
.d546	b546	fa		plx				plx
.d547	b547	60		rts				rts
.d548	b548					LCLDeleteLastSpace:
.d548	b548	48		pha				pha
.d549	b549	da		phx				phx
.d54a	b54a	ae 39 04	ldx $0439			ldx 	tbOffset
.d54d	b54d	f0 0a		beq $b559			beq 	_LCDLSExit
.d54f	b54f	bd 48 04	lda $0448,x			lda 	tokenBuffer-1,x
.d552	b552	c9 20		cmp #$20			cmp 	#' '
.d554	b554	d0 03		bne $b559			bne 	_LCDLSExit
.d556	b556	ce 39 04	dec $0439			dec 	tbOffset
.d559	b559					_LCDLSExit:
.d559	b559	fa		plx				plx
.d55a	b55a	68		pla				pla
.d55b	b55b	60		rts				rts
.d55c	b55c					LCLCheckSpaceRequired:
.d55c	b55c	ad 43 04	lda $0443			lda 	lcLastCharacter 			; check last character
.d55f	b55f	c9 24		cmp #$24			cmp 	#'$' 						; $ # and ) require that token space.
.d561	b561	f0 1b		beq $b57e			beq 	_LCCSRSpace
.d563	b563	c9 29		cmp #$29			cmp 	#')'
.d565	b565	f0 17		beq $b57e			beq 	_LCCSRSpace
.d567	b567	c9 23		cmp #$23			cmp 	#'#'
.d569	b569	f0 13		beq $b57e			beq 	_LCCSRSpace
.d56b	b56b	20 84 b5	jsr $b584			jsr 	LCLLowerCase 				; saves a little effort
.d56e	b56e	c9 30		cmp #$30			cmp 	#"0" 						; check if it was 0-9 A-Z a-z if so need space.
.d570	b570	90 11		bcc $b583			bcc 	_LCCSRExit
.d572	b572	c9 3a		cmp #$3a			cmp 	#"9"+1
.d574	b574	90 08		bcc $b57e			bcc 	_LCCSRSpace
.d576	b576	c9 61		cmp #$61			cmp 	#"a"
.d578	b578	90 09		bcc $b583			bcc 	_LCCSRExit
.d57a	b57a	c9 7b		cmp #$7b			cmp 	#"z"+1
.d57c	b57c	b0 05		bcs $b583			bcs 	_LCCSRExit
.d57e	b57e					_LCCSRSpace:
.d57e	b57e	a9 20		lda #$20			lda 	#' '
.d580	b580	20 32 b5	jsr $b532			jsr 	LCLWrite
.d583	b583					_LCCSRExit:
.d583	b583	60		rts				rts
.d584	b584					LCLLowerCase:
.d584	b584	c9 41		cmp #$41			cmp 	#"A"
.d586	b586	90 06		bcc $b58e			bcc 	_LCLLCOut
.d588	b588	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d58a	b58a	b0 02		bcs $b58e			bcs 	_LCLLCOut
.d58c	b58c	69 20		adc #$20			adc 	#$20
.d58e	b58e					_LCLLCOut:
.d58e	b58e	60		rts				rts
.d58f	b58f					LCLUpperCase:
.d58f	b58f	c9 61		cmp #$61			cmp 	#"a"
.d591	b591	90 06		bcc $b599			bcc 	_LCLUCOut
.d593	b593	c9 7b		cmp #$7b			cmp 	#"z"+1
.d595	b595	b0 02		bcs $b599			bcs 	_LCLUCOut
.d597	b597	e9 1f		sbc #$1f			sbc 	#$1F
.d599	b599					_LCLUCOut:
.d599	b599	60		rts				rts
.d59a	b59a					LCLWriteNumberXA:
.d59a	b59a	64 37		stz $37				stz 	zTemp0+1 					; index into digit table.
.d59c	b59c					_LCLWNLoop1:
.d59c	b59c	64 36		stz $36				stz 	zTemp0 						; subtraction count.
.d59e	b59e					_LCLWNLoop2:
.d59e	b59e	48		pha				pha 								; save initial LSB
.d59f	b59f	38		sec				sec
.d5a0	b5a0	a4 37		ldy $37				ldy 	zTemp0+1 					; position in table.
.d5a2	b5a2	f9 d3 b5	sbc $b5d3,y			sbc 	_LCLWNTable,y
.d5a5	b5a5	48		pha				pha
.d5a6	b5a6	8a		txa				txa
.d5a7	b5a7	f9 d4 b5	sbc $b5d4,y			sbc 	_LCLWNTable+1,y
.d5aa	b5aa	90 07		bcc $b5b3			bcc 	_LCLWNUnderflow
.d5ac	b5ac	e6 36		inc $36				inc 	zTemp0  					; subtracted one without borrow.
.d5ae	b5ae	aa		tax				tax 								; update X
.d5af	b5af	68		pla				pla 								; restore A
.d5b0	b5b0	7a		ply				ply 								; throw original
.d5b1	b5b1	80 eb		bra $b59e			bra 	_LCLWNLoop2 				; try again.
.d5b3	b5b3					_LCLWNUnderflow:
.d5b3	b5b3	a4 36		ldy $36				ldy 	zTemp0 						; count of subtractions.
.d5b5	b5b5	d0 06		bne $b5bd			bne 	_LCLWNOut
.d5b7	b5b7	ad 39 04	lda $0439			lda 	tbOffset 					; suppress leading zeroes
.d5ba	b5ba	3a		dec a				dec 	a
.d5bb	b5bb	f0 04		beq $b5c1			beq 	_LCLWNNext
.d5bd	b5bd					_LCLWNOut:
.d5bd	b5bd	98		tya				tya
.d5be	b5be	20 cd b5	jsr $b5cd			jsr 	_LCLWNOutDigit
.d5c1	b5c1					_LCLWNNext:
.d5c1	b5c1	7a		ply				ply 							 	; restore original value.
.d5c2	b5c2	68		pla				pla
.d5c3	b5c3	a4 37		ldy $37				ldy 	zTemp0+1  					; bump the index
.d5c5	b5c5	c8		iny				iny
.d5c6	b5c6	c8		iny				iny
.d5c7	b5c7	84 37		sty $37				sty 	zTemp0+1
.d5c9	b5c9	c0 08		cpy #$08			cpy 	#8 							; done all 4
.d5cb	b5cb	d0 cf		bne $b59c			bne 	_LCLWNLoop1
.d5cd	b5cd					_LCLWNOutDigit:
.d5cd	b5cd	09 30		ora #$30			ora 	#'0'
.d5cf	b5cf	20 32 b5	jsr $b532			jsr 	LCLWrite
.d5d2	b5d2	60		rts				rts
.d5d3	b5d3					_LCLWNTable:
>d5d3	b5d3	10 27						.word 	10000
>d5d5	b5d5	e8 03						.word 	1000
>d5d7	b5d7	64 00						.word 	100
>d5d9	b5d9	0a 00						.word 	10
.d5db	b5db					CLIDefault:
>d5db	b5db	05 0e 0d 06 07 0e 0c 0f				.byte	CONBrown, CONYellow, CONRed, CONOrange, CONCyan, CONYellow, CONPink, CONWhite
=1024						CLIFComment = ControlStorage + 0
=1025						CLIBComment = ControlStorage + 1
=1026						CLILineNumber = ControlStorage + 2
=1027						CLIToken = ControlStorage + 3
=1028						CLIConstant = ControlStorage + 4
=1029						CLIIdentifier = ControlStorage + 5
=1030						CLIPunctuation = ControlStorage + 6
=1031						CLIData = ControlStorage + 7
.d5e3	b5e3					TOKSearchTable:
.d5e3	b5e3	84 37		sty $37				sty 	zTemp0+1 					; (zTemp0),y points to current token being tested.
.d5e5	b5e5	85 36		sta $36				sta 	zTemp0
.d5e7	b5e7	a0 00		ldy #$00			ldy 	#0
.d5e9	b5e9	a9 80		lda #$80			lda 	#$80 						; token # so we know which one we are looking at
.d5eb	b5eb	85 38		sta $38				sta 	zTemp1
.d5ed	b5ed					_TSTLoop:
.d5ed	b5ed	b1 36		lda ($36),y			lda 	(zTemp0),y 					; length, 0 (skip) -ve (end)
.d5ef	b5ef	30 49		bmi $b63a			bmi 	_TSTFail 					; -ve = end of table, so fail.
.d5f1	b5f1	f0 2e		beq $b621			beq 	_TSTNext 					; zero, check next as it's a dummy (e.g. EOL, SHIFT)
.d5f3	b5f3	c8		iny				iny 								; get the hash
.d5f4	b5f4	b1 36		lda ($36),y			lda 	(zTemp0),y
.d5f6	b5f6	88		dey				dey
.d5f7	b5f7	cd 23 04	cmp $0423			cmp 	identHash 					; check they match with the identifier hash, if not go to next
.d5fa	b5fa	d0 25		bne $b621			bne 	_TSTNext
.d5fc	b5fc	ad 22 04	lda $0422			lda 	identTypeEnd 				; get length of identifier from end-start
.d5ff	b5ff	38		sec				sec
.d600	b600	ed 20 04	sbc $0420			sbc 	identStart
.d603	b603	d1 36		cmp ($36),y			cmp 	(zTemp0),y 					; compare against the length in the table, no match, then return.
.d605	b605	d0 1a		bne $b621			bne 	_TSTNext
.d607	b607	5a		phy				phy 								; save Y , we might fail to match.
.d608	b608	c8		iny				iny 								; point to text
.d609	b609	c8		iny				iny
.d60a	b60a	ae 20 04	ldx $0420			ldx 	identStart 					; offset in line buffer in X
.d60d	b60d					_TSTCompareName:
.d60d	b60d	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; compare text.
.d610	b610	d1 36		cmp ($36),y			cmp 	(zTemp0),y
.d612	b612	d0 0c		bne $b620			bne 	_TSTNextPullY 				; fail, pullY and do next
.d614	b614	e8		inx				inx
.d615	b615	c8		iny				iny
.d616	b616	ec 22 04	cpx $0422			cpx 	identTypeEnd 				; complete match.
.d619	b619	d0 f2		bne $b60d			bne 	_TSTCompareName
.d61b	b61b	7a		ply				ply 								; throw Y
.d61c	b61c	a5 38		lda $38				lda 	zTemp1 						; get token #
.d61e	b61e	38		sec				sec 								; return with CS = passed.
.d61f	b61f	60		rts				rts
.d620	b620					_TSTNextPullY:
.d620	b620	7a		ply				ply 								; restore current, fall through.
.d621	b621					_TSTNext:
.d621	b621	e6 38		inc $38				inc 	zTemp1 						; token counter
.d623	b623	98		tya				tya
.d624	b624	18		clc				clc
.d625	b625	71 36		adc ($36),y			adc 	(zTemp0),y 					; add [Length] + 2 to Y
.d627	b627	1a		inc a				inc 	a 							; +1
.d628	b628	1a		inc a				inc 	a 							; +2
.d629	b629	a8		tay				tay
.d62a	b62a	10 c1		bpl $b5ed			bpl 	_TSTLoop 					; if Y < $80 loop back
.d62c	b62c	98		tya				tya 								; add Y to zTemp0 and reset Y
.d62d	b62d	a0 00		ldy #$00			ldy 	#0   						; so we can use Y to search fast
.d62f	b62f	18		clc				clc  								; but have tables > 255 bytes
.d630	b630	65 36		adc $36				adc 	zTemp0 						; when Y gets >= 128 we reset Y
.d632	b632	85 36		sta $36				sta 	zTemp0 						; and adjust the table pointer/
.d634	b634	90 b7		bcc $b5ed			bcc 	_TSTLoop
.d636	b636	e6 37		inc $37				inc 	zTemp0+1
.d638	b638	80 b3		bra $b5ed			bra 	_TSTLoop
.d63a	b63a					_TSTFail:
.d63a	b63a	18		clc				clc
.d63b	b63b	60		rts				rts
.d63c	b63c					Export_TKTokeniseLine:
.d63c	b63c	20 09 b8	jsr $b809			jsr 	LCLFixLineBufferCase 		; fix line case
.d63f	b63f	a9 03		lda #$03			lda 	#3 							; reset the token buffer to empty
.d641	b641	8d 46 04	sta $0446			sta 	tokenOffset 				; (3 bytes for line number & offset)
.d644	b644	9c 47 04	stz $0447			stz 	tokenLineNumber
.d647	b647	9c 48 04	stz $0448			stz 	tokenLineNumber+1
.d64a	b64a	a2 ff		ldx #$ff			ldx 	#$FF
.d64c	b64c					_TKFindFirst:
.d64c	b64c	e8		inx				inx
.d64d	b64d	bd 46 05	lda $0546,x			lda 	lineBuffer,x
.d650	b650	f0 62		beq $b6b4			beq 	_TKExit
.d652	b652	c9 20		cmp #$20			cmp 	#' '
.d654	b654	90 f6		bcc $b64c			bcc 	_TKFindFirst
.d656	b656	c9 30		cmp #$30			cmp 	#'0'
.d658	b658	90 07		bcc $b661			bcc 	_TKNoLineNumber
.d65a	b65a	c9 3a		cmp #$3a			cmp 	#'9'+1
.d65c	b65c	b0 03		bcs $b661			bcs 	_TKNoLineNumber
.d65e	b65e	20 33 b8	jsr $b833			jsr 	TOKExtractLineNumber
.d661	b661					_TKNoLineNumber:
.d661	b661					_TKTokeniseLoop:
.d661	b661	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; next character, exit if zero EOL.
.d664	b664	f0 4e		beq $b6b4			beq 	_TKExit
.d666	b666	e8		inx				inx
.d667	b667	c9 20		cmp #$20			cmp 	#' '
.d669	b669	f0 f6		beq $b661			beq 	_TKTokeniseLoop 			; keep looping if space found.
.d66b	b66b	ca		dex				dex 								; undo last get, A contains character, X is position.
.d66c	b66c	c9 5f		cmp #$5f			cmp 	#'_'						; _ A-Z is identifier *or* token
.d66e	b66e	f0 68		beq $b6d8			beq 	_TKTokeniseIdentifier 		; (already case converted outside string constants)
.d670	b670	c9 41		cmp #$41			cmp 	#'A'
.d672	b672	90 04		bcc $b678			bcc 	_TKTokenisePunctuation
.d674	b674	c9 5b		cmp #$5b			cmp 	#'Z'+1
.d676	b676	90 60		bcc $b6d8			bcc 	_TKTokeniseIdentifier
.d678	b678					_TKTokenisePunctuation:
.d678	b678	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.d67a	b67a	f0 2e		beq $b6aa			beq 	_TKString
.d67c	b67c	c9 24		cmp #$24			cmp 	#'$'						; hexadecimal constant ($ only appears at end of identifiers)
.d67e	b67e	f0 2f		beq $b6af			beq 	_TKHexConstant
.d680	b680	c9 3c		cmp #$3c			cmp 	#'<' 						; check for < > handlers - these are for <> <= >= >> <<
.d682	b682	f0 36		beq $b6ba			beq 	_TKCheckDouble
.d684	b684	c9 3e		cmp #$3e			cmp 	#'>'
.d686	b686	f0 32		beq $b6ba			beq 	_TKCheckDouble
.d688	b688					_TKStandardPunctuation:
.d688	b688	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; get the punctuation token back.
.d68b	b68b	c9 40		cmp #$40			cmp 	#64 						; are we >= 64
.d68d	b68d	90 0e		bcc $b69d			bcc 	_TKNoShift
.d68f	b68f	48		pha				pha 								; save. we are about to convert this punctuation token from
.d690	b690	29 07		and #$07			and 	#7 							; lower 3 bits in zTemp0
.d692	b692	85 36		sta $36				sta 	zTemp0
.d694	b694	68		pla				pla
.d695	b695	29 20		and #$20			and 	#32 						; bit 5
.d697	b697	4a		lsr a				lsr 	a 							; shift into bit 3
.d698	b698	4a		lsr a				lsr 	a
.d699	b699	05 36		ora $36				ora 	zTemp0
.d69b	b69b	09 10		ora #$10			ora 	#$10						; now in the range 16-31
.d69d	b69d					_TKNoShift:
.d69d	b69d	20 78 b8	jsr $b878			jsr 	TOKWriteByte 				; write the punctuation character
.d6a0	b6a0	e8		inx				inx 								; consume the character
.d6a1	b6a1	c9 27		cmp #$27			cmp 	#KWD_QUOTE 					; quote found ?
.d6a3	b6a3	d0 bc		bne $b661			bne 	_TKTokeniseLoop 			; and loop round again.
.d6a5	b6a5	20 6b b7	jsr $b76b			jsr 	TOKCheckComment 			; comment checl
.d6a8	b6a8	80 b7		bra $b661			bra 	_TKTokeniseLoop
.d6aa	b6aa					_TKString:
.d6aa	b6aa	20 98 b7	jsr $b798			jsr 	TOKTokenString
.d6ad	b6ad	80 b2		bra $b661			bra 	_TKTokeniseLoop
.d6af	b6af					_TKHexConstant:
.d6af	b6af	20 d3 b7	jsr $b7d3			jsr 	TOKHexConstant
.d6b2	b6b2	80 ad		bra $b661			bra 	_TKTokeniseLoop
.d6b4	b6b4	a9 80		lda #$80	_TKExit:lda 	#KWC_EOL 					; write end of line byte
.d6b6	b6b6	20 78 b8	jsr $b878			jsr 	TOKWriteByte
.d6b9	b6b9	60		rts				rts
.d6ba	b6ba					_TKCheckDouble:
.d6ba	b6ba	bd 47 05	lda $0547,x			lda 	lineBuffer+1,x 				; get next character
.d6bd	b6bd	c9 3c		cmp #$3c			cmp 	#'<'						; if not < = > which are ASCII consecutive go back
.d6bf	b6bf	90 c7		bcc $b688			bcc 	_TKStandardPunctuation 		; and do the normal punctuation handler.
.d6c1	b6c1	c9 3f		cmp #$3f			cmp 	#'>'+1
.d6c3	b6c3	b0 c3		bcs $b688			bcs 	_TKStandardPunctuation
.d6c5	b6c5	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; this is < (60) or > (62)
.d6c8	b6c8	29 02		and #$02			and 	#2 							; now < (0) or > (2)
.d6ca	b6ca	0a		asl a				asl 	a 							; now < (0) or > (4), CC also
.d6cb	b6cb	7d 47 05	adc $0547,x			adc 	lineBuffer+1,x 				; add < = > codes - < code
.d6ce	b6ce	38		sec				sec
.d6cf	b6cf	e9 3c		sbc #$3c			sbc 	#'<'
.d6d1	b6d1	20 78 b8	jsr $b878			jsr 	TOKWriteByte 				; this is in the range 0-7
.d6d4	b6d4	e8		inx				inx 								; consume both
.d6d5	b6d5	e8		inx				inx
.d6d6	b6d6	80 89		bra $b661			bra 	_TKTokeniseLoop
.d6d8	b6d8					_TKTokeniseIdentifier:
.d6d8	b6d8	8e 20 04	stx $0420			stx 	identStart 					; save start
.d6db	b6db	9c 24 04	stz $0424			stz 	identTypeByte 				; zero the type byte
.d6de	b6de					_TKCheckLoop:
.d6de	b6de	e8		inx				inx 								; look at next, we know first is identifier already.
.d6df	b6df	bd 46 05	lda $0546,x			lda  	lineBuffer,x
.d6e2	b6e2	c9 5f		cmp #$5f			cmp 	#"_" 						; legal char _ 0-9 A-Z
.d6e4	b6e4	f0 f8		beq $b6de			beq 	_TKCheckLoop
.d6e6	b6e6	c9 30		cmp #$30			cmp	 	#"0"
.d6e8	b6e8	90 0c		bcc $b6f6			bcc 	_TKEndIdentifier
.d6ea	b6ea	c9 3a		cmp #$3a			cmp 	#"9"+1
.d6ec	b6ec	90 f0		bcc $b6de			bcc 	_TKCheckLoop
.d6ee	b6ee	c9 41		cmp #$41			cmp	 	#"A"
.d6f0	b6f0	90 04		bcc $b6f6			bcc 	_TKEndIdentifier
.d6f2	b6f2	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d6f4	b6f4	90 e8		bcc $b6de			bcc 	_TKCheckLoop
.d6f6	b6f6					_TKEndIdentifier:
.d6f6	b6f6	8e 21 04	stx $0421			stx 	identTypeStart 				; save start of type text (if any !)
.d6f9	b6f9	a0 08		ldy #$08			ldy 	#$08 						; this is the identifier type byte for #
.d6fb	b6fb	c9 23		cmp #$23			cmp 	#"#"						; followed by #
.d6fd	b6fd	f0 06		beq $b705			beq 	_TKHasTypeCharacter
.d6ff	b6ff	a0 10		ldy #$10			ldy 	#$10 						; this is the identifier type byte for $
.d701	b701	c9 24		cmp #$24			cmp 	#"$"						; followed by $ or #
.d703	b703	d0 07		bne $b70c			bne 	_TKNoTypeCharacter
.d705	b705					_TKHasTypeCharacter:
.d705	b705	8c 24 04	sty $0424			sty 	identTypeByte 				; has # or $, save the type
.d708	b708	e8		inx				inx 								; consume the type character
.d709	b709	bd 46 05	lda $0546,x			lda 	lineBuffer,x
.d70c	b70c					_TKNoTypeCharacter:
.d70c	b70c	c9 28		cmp #$28			cmp 	#"("						; is it open parenthesis (e.g. array)
.d70e	b70e	d0 09		bne $b719			bne 	_TKNoArray
.d710	b710	e8		inx				inx 								; skip the (
.d711	b711	ad 24 04	lda $0424			lda 	identTypeByte 				; set bit 2 (e.g. array) in type byte
.d714	b714	09 04		ora #$04			ora 	#$04
.d716	b716	8d 24 04	sta $0424			sta 	identTypeByte
.d719	b719					_TKNoArray:
.d719	b719	8e 22 04	stx $0422			stx 	identTypeEnd 				; save end marker, e.g. continue from here.
.d71c	b71c	20 f4 b7	jsr $b7f4			jsr 	TOKCalculateHash 			; calculate the has for those tokens
.d71f	b71f	a0 ae		ldy #$ae			ldy 	#(KeywordSet0) >> 8
.d721	b721	a9 8c		lda #$8c			lda 	#(KeywordSet0) & $FF
.d723	b723	20 e3 b5	jsr $b5e3			jsr 	TOKSearchTable
.d726	b726	a2 00		ldx #$00			ldx 	#0
.d728	b728	b0 1f		bcs $b749			bcs 	_TKFoundToken
.d72a	b72a	a0 b1		ldy #$b1			ldy 	#(KeywordSet1) >> 8
.d72c	b72c	a9 17		lda #$17			lda 	#(KeywordSet1) & $FF
.d72e	b72e	20 e3 b5	jsr $b5e3			jsr 	TOKSearchTable
.d731	b731	a2 81		ldx #$81			ldx 	#$81
.d733	b733	b0 14		bcs $b749			bcs 	_TKFoundToken
.d735	b735	a0 b2		ldy #$b2			ldy 	#(KeywordSet2) >> 8
.d737	b737	a9 38		lda #$38			lda 	#(KeywordSet2) & $FF
.d739	b739	20 e3 b5	jsr $b5e3			jsr 	TOKSearchTable
.d73c	b73c	a2 82		ldx #$82			ldx 	#$82
.d73e	b73e	b0 09		bcs $b749			bcs 	_TKFoundToken
.d740	b740	20 84 b8	jsr $b884			jsr 	TOKCheckCreateVariableRecord ; failed all, it's a variable, create record if does not exist.
.d743	b743	ae 22 04	ldx $0422			ldx 	identTypeEnd 				; X points to following byte
.d746	b746	4c 61 b6	jmp $b661			jmp 	_TKTokeniseLoop 			; and go round again.
.d749	b749					_TKFoundToken:
.d749	b749	48		pha				pha 								; save token
.d74a	b74a	8a		txa				txa 								; shift in X, is there one ?
.d74b	b74b	f0 03		beq $b750			beq 	_TKNoTShift
.d74d	b74d	20 78 b8	jsr $b878			jsr 	TOKWriteByte 				; if so, write it out
.d750	b750					_TKNoTShift:
.d750	b750	68		pla				pla 								; restore and write token
.d751	b751	20 78 b8	jsr $b878			jsr 	TOKWriteByte
.d754	b754	e0 00		cpx #$00			cpx 	#0 							; check for REM and '
.d756	b756	d0 0d		bne $b765			bne 	_TKNotRem 			 		; not shifted ?
.d758	b758	c9 d9		cmp #$d9			cmp 	#KWD_REM
.d75a	b75a	d0 09		bne $b765			bne 	_TKNotRem
.d75c	b75c	ae 22 04	ldx $0422			ldx 	identTypeEnd 				; check if comment follows.
.d75f	b75f	20 6b b7	jsr $b76b			jsr 	TOKCheckComment
.d762	b762	4c 61 b6	jmp $b661			jmp 	_TKTokeniseLoop
.d765	b765					_TKNotRem:
.d765	b765	ae 22 04	ldx $0422			ldx 	identTypeEnd 				; X points to following byte
.d768	b768	4c 61 b6	jmp $b661			jmp 	_TKTokeniseLoop 			; and go round again.
.d76b	b76b					TOKCheckComment:
.d76b	b76b	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; skip over space
.d76e	b76e	e8		inx				inx
.d76f	b76f	c9 20		cmp #$20			cmp 	#' '
.d771	b771	f0 f8		beq $b76b			beq 	TOKCheckComment
.d773	b773	ca		dex				dex 								; first non space character
.d774	b774	c9 22		cmp #$22			cmp 	#'"'						; quote mark
.d776	b776	f0 1f		beq $b797			beq 	_TOKCCExit 					; then we are okay
.d778	b778	c9 00		cmp #$00			cmp 	#0 							; EOL
.d77a	b77a	f0 1b		beq $b797			beq 	_TOKCCExit 					; then we are okay
.d77c	b77c	da		phx				phx
.d77d	b77d					_TOKCCLowerCase:
.d77d	b77d	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; about making it lower case it all, but I thought
.d780	b780	c9 41		cmp #$41			cmp 	#"A"		 				; that was a bit risky. So it's converted to L/C here.
.d782	b782	90 09		bcc $b78d			bcc 	_TOKKCNotUC
.d784	b784	c9 5b		cmp #$5b			cmp 	#"Z"+1
.d786	b786	b0 05		bcs $b78d			bcs 	_TOKKCNotUC
.d788	b788	49 20		eor #$20			eor 	#$20
.d78a	b78a	9d 46 05	sta $0546,x			sta 	lineBuffer,x
.d78d	b78d					_TOKKCNotUC:
.d78d	b78d	e8		inx				inx
.d78e	b78e	c9 00		cmp #$00			cmp 	#0
.d790	b790	d0 eb		bne $b77d			bne 	_TOKCCLowerCase
.d792	b792	fa		plx				plx
.d793	b793	ca		dex				dex 								; tokenise string expects initial skip.
.d794	b794	20 98 b7	jsr $b798			jsr 	TOKTokenString 				; tokenise rest of line as a string.
.d797	b797					_TOKCCExit:
.d797	b797	60		rts				rts
.d798	b798					TOKTokenString:
.d798	b798	a9 ff		lda #$ff			lda 	#KWC_STRING 				; string token.
.d79a	b79a	20 78 b8	jsr $b878			jsr 	TOKWriteByte
.d79d	b79d	e8		inx				inx									; start of quoted string.
.d79e	b79e	da		phx				phx 								; push start of string on top
.d79f	b79f	ca		dex				dex 								; because we pre-increment
.d7a0	b7a0					_TSFindEnd:
.d7a0	b7a0	e8		inx				inx
.d7a1	b7a1	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; next character
.d7a4	b7a4	f0 04		beq $b7aa			beq 	_TSEndOfString 				; no matching quote, we don't mind.
.d7a6	b7a6	c9 22		cmp #$22			cmp 	#'"' 						; go back if quote not found
.d7a8	b7a8	d0 f6		bne $b7a0			bne 	_TSFindEnd
.d7aa	b7aa					_TSEndOfString:
.d7aa	b7aa	7a		ply				ply  								; so now Y is first character, X is character after end.
.d7ab	b7ab	48		pha				pha 								; save terminating character
.d7ac	b7ac	20 b4 b7	jsr $b7b4			jsr 	TOKWriteBlockXY 			; write X to Y as a data block
.d7af	b7af	68		pla				pla 								; terminating character
.d7b0	b7b0	f0 01		beq $b7b3			beq 	_TSNotQuote					; if it wasn't EOS skip it
.d7b2	b7b2	e8		inx				inx
.d7b3	b7b3					_TSNotQuote:
.d7b3	b7b3	60		rts				rts
.d7b4	b7b4					TOKWriteBlockXY:
.d7b4	b7b4	86 36		stx $36				stx 	zTemp0 						; save end character
.d7b6	b7b6	98		tya				tya 								; use 2's complement to work out the byte size
.d7b7	b7b7	49 ff		eor #$ff			eor 	#$FF
.d7b9	b7b9	38		sec				sec
.d7ba	b7ba	65 36		adc $36				adc 	zTemp0
.d7bc	b7bc	1a		inc a				inc 	a 							; one extra for NULL
.d7bd	b7bd	20 78 b8	jsr $b878			jsr 	TOKWriteByte
.d7c0	b7c0					_TOBlockLoop:
.d7c0	b7c0	c4 36		cpy $36				cpy 	zTemp0 						; exit if reached the end
.d7c2	b7c2	f0 09		beq $b7cd			beq 	_TOBlockExit
.d7c4	b7c4	b9 46 05	lda $0546,y			lda 	lineBuffer,y 				; write byte out.
.d7c7	b7c7	20 78 b8	jsr $b878			jsr 	TOKWriteByte
.d7ca	b7ca	c8		iny				iny
.d7cb	b7cb	80 f3		bra $b7c0			bra 	_TOBlockLoop
.d7cd	b7cd					_TOBlockExit:
.d7cd	b7cd	a9 00		lda #$00			lda 	#0 							; add NULL.
.d7cf	b7cf	20 78 b8	jsr $b878			jsr 	TOKWriteByte
.d7d2	b7d2	60		rts				rts
.d7d3	b7d3					TOKHexConstant:
.d7d3	b7d3	a9 fe		lda #$fe			lda 	#KWC_HEXCONST 				; hex constant token.
.d7d5	b7d5	20 78 b8	jsr $b878			jsr 	TOKWriteByte
.d7d8	b7d8	e8		inx				inx									; start of quoted string.
.d7d9	b7d9	da		phx				phx 								; push start of constant on top
.d7da	b7da	ca		dex				dex
.d7db	b7db					_THFindLoop:
.d7db	b7db	e8		inx				inx 	 							; this is stored in a block, so find out how long
.d7dc	b7dc	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; the hex constant is.
.d7df	b7df	c9 30		cmp #$30			cmp 	#"0"
.d7e1	b7e1	90 0c		bcc $b7ef			bcc 	_THFoundEnd
.d7e3	b7e3	c9 3a		cmp #$3a			cmp 	#"9"+1
.d7e5	b7e5	90 f4		bcc $b7db			bcc 	_THFindLoop
.d7e7	b7e7	c9 41		cmp #$41			cmp 	#"A"
.d7e9	b7e9	90 04		bcc $b7ef			bcc 	_THFoundEnd
.d7eb	b7eb	c9 47		cmp #$47			cmp 	#"F"+1
.d7ed	b7ed	90 ec		bcc $b7db			bcc 	_THFindLoop
.d7ef	b7ef					_THFoundEnd:
.d7ef	b7ef	7a		ply				ply 								; restore start
.d7f0	b7f0	20 b4 b7	jsr $b7b4			jsr 	TOKWriteBlockXY 			; output the block
.d7f3	b7f3	60		rts				rts
.d7f4	b7f4					TOKCalculateHash:
.d7f4	b7f4	da		phx				phx
.d7f5	b7f5	ae 20 04	ldx $0420			ldx 	identStart 					; needs to be same as in tokens.py - simple sum at present.
.d7f8	b7f8	a9 00		lda #$00			lda 	#0
.d7fa	b7fa					_TCHLoop:
.d7fa	b7fa	18		clc				clc
.d7fb	b7fb	7d 46 05	adc $0546,x			adc 	lineBuffer,x
.d7fe	b7fe	e8		inx				inx
.d7ff	b7ff	ec 22 04	cpx $0422			cpx 	identTypeEnd 				; do the whole thing including type and array markers.
.d802	b802	d0 f6		bne $b7fa			bne 	_TCHLoop
.d804	b804	8d 23 04	sta $0423			sta 	identHash 					; save the hash
.d807	b807	fa		plx				plx
.d808	b808	60		rts				rts
.d809	b809					LCLFixLineBufferCase:
.d809	b809	a2 00		ldx #$00			ldx 	#0
.d80b	b80b					_FLBCLoop:
.d80b	b80b	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; get next character
.d80e	b80e	f0 22		beq $b832			beq 	_FLBCExit 					; end of string.
.d810	b810	c9 22		cmp #$22			cmp 	#'"'						; quote, go to in quotes
.d812	b812	f0 11		beq $b825			beq 	_FLBCInQuotes
.d814	b814	e8		inx				inx
.d815	b815	c9 61		cmp #$61			cmp 	#'a'						; needs capitalising ?
.d817	b817	90 f2		bcc $b80b			bcc 	_FLBCLoop
.d819	b819	c9 7b		cmp #$7b			cmp 	#'z'+1
.d81b	b81b	b0 ee		bcs $b80b			bcs 	_FLBCLoop
.d81d	b81d	38		sec				sec 								; make U/C
.d81e	b81e	e9 20		sbc #$20			sbc 	#32
.d820	b820	9d 45 05	sta $0545,x			sta	 	lineBuffer-1,x 				; write back
.d823	b823	80 e6		bra $b80b			bra 	_FLBCLoop
.d825	b825					_FLBCInQuotes:
.d825	b825	e8		inx				inx 								; advance
.d826	b826	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; get next
.d829	b829	f0 07		beq $b832			beq 	_FLBCExit 					; exit on EOS
.d82b	b82b	c9 22		cmp #$22			cmp 	#'"' 				 		; until " found
.d82d	b82d	d0 f6		bne $b825			bne 	_FLBCInQuotes
.d82f	b82f	e8		inx				inx 								; skip over it
.d830	b830	80 d9		bra $b80b			bra 	_FLBCLoop
.d832	b832					_FLBCExit:
.d832	b832	60		rts				rts
.d833	b833					TOKExtractLineNumber:
.d833	b833	ad 48 04	lda $0448			lda 	tokenLineNumber+1 			; push current value on stack
.d836	b836	48		pha				pha
.d837	b837	ad 47 04	lda $0447			lda 	tokenLineNumber
.d83a	b83a	48		pha				pha
.d83b	b83b	20 71 b8	jsr $b871			jsr 	_LCLNTimes2 				; line # x 2
.d83e	b83e	20 71 b8	jsr $b871			jsr 	_LCLNTimes2 				; line # x 4
.d841	b841	18		clc				clc 								; add stacked value
.d842	b842	68		pla				pla
.d843	b843	6d 47 04	adc $0447			adc 	tokenLineNumber
.d846	b846	8d 47 04	sta $0447			sta 	tokenLineNumber
.d849	b849	68		pla				pla
.d84a	b84a	6d 48 04	adc $0448			adc 	tokenLineNumber+1
.d84d	b84d	8d 48 04	sta $0448			sta 	tokenLineNumber+1 			; line # x 5
.d850	b850	20 71 b8	jsr $b871			jsr 	_LCLNTimes2 				; line # x 10
.d853	b853	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; get and consume character
.d856	b856	e8		inx				inx
.d857	b857	29 0f		and #$0f			and 	#15 						; add to line #
.d859	b859	18		clc				clc
.d85a	b85a	6d 47 04	adc $0447			adc 	tokenLineNumber
.d85d	b85d	8d 47 04	sta $0447			sta 	tokenLineNumber
.d860	b860	90 03		bcc $b865			bcc 	_TLENNoCarry
.d862	b862	ee 48 04	inc $0448			inc 	tokenLineNumber+1
.d865	b865					_TLENNoCarry:
.d865	b865	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; more digits ?
.d868	b868	c9 30		cmp #$30			cmp 	#'0'
.d86a	b86a	90 04		bcc $b870			bcc 	_TLENExit
.d86c	b86c	c9 3a		cmp #$3a			cmp 	#'9'+1
.d86e	b86e	90 c3		bcc $b833			bcc 	TOKExtractLineNumber
.d870	b870					_TLENExit:
.d870	b870	60		rts				rts
.d871	b871					_LCLNTimes2:
.d871	b871	0e 47 04	asl $0447			asl 	tokenLineNumber 			; doubles tokenLineNumber.
.d874	b874	2e 48 04	rol $0448			rol 	tokenLineNumber+1
.d877	b877	60		rts				rts
.d878	b878					TOKWriteByte:
.d878	b878	da		phx				phx
.d879	b879	ae 46 04	ldx $0446			ldx 	tokenOffset 				; next slot to write to
.d87c	b87c	9d 46 04	sta $0446,x			sta 	tokenOffset,x 				; write byte out
.d87f	b87f	ee 46 04	inc $0446			inc 	tokenOffset 				; advance slot.
.d882	b882	fa		plx				plx
.d883	b883	60		rts				rts
.d884	b884					TOKCheckCreateVariableRecord:
.d884	b884	a9 00		lda #$00			lda 	#((VariableSpace) & $FF)
.d886	b886	85 36		sta $36				sta 	0+zTemp0
.d888	b888	a9 10		lda #$10			lda 	#((VariableSpace) >> 8)
.d88a	b88a	85 37		sta $37				sta 	1+zTemp0
.d88c	b88c					_CCVSearch:
.d88c	b88c	b2 36		lda ($36)			lda 	(zTemp0) 					; end of list
.d88e	b88e	f0 2c		beq $b8bc			beq 	_CCVFail
.d890	b890	a0 01		ldy #$01			ldy 	#1 							; read the hash
.d892	b892	b1 36		lda ($36),y			lda 	(zTemp0),y 					; does it match ?
.d894	b894	cd 23 04	cmp $0423			cmp 	identHash 	  				; if not, try the next.
.d897	b897	d0 16		bne $b8af			bne 	_CCVNext
.d899	b899	a0 08		ldy #$08			ldy 	#8 							; name in variable record
.d89b	b89b	ae 20 04	ldx $0420			ldx 	identStart
.d89e	b89e					_CCVCompare:
.d89e	b89e	bd 46 05	lda $0546,x			lda 	lineBuffer,x 				; xor them. zero if the same, except
.d8a1	b8a1	51 36		eor ($36),y			eor 	(zTemp0),y 					; bit 7 is used for EOS.
.d8a3	b8a3	e8		inx				inx 								; advance pointers
.d8a4	b8a4	c8		iny				iny
.d8a5	b8a5	0a		asl a				asl 	a 							; A = 0 if they match, CS if end.
.d8a6	b8a6	d0 07		bne $b8af			bne 	_CCVNext  					; didn't match go to next.
.d8a8	b8a8	90 f4		bcc $b89e			bcc 	_CCVCompare 				; not finished yet.
.d8aa	b8aa	ec 22 04	cpx $0422			cpx 	identTypeEnd 				; matched whole thing ?
.d8ad	b8ad	f0 41		beq $b8f0			beq 	_CCVFound 					; yes, we were successful
.d8af	b8af					_CCVNext:
.d8af	b8af	18		clc				clc 								; go to next record.
.d8b0	b8b0	b2 36		lda ($36)			lda 	(zTemp0) 					; add offset to pointer
.d8b2	b8b2	65 36		adc $36				adc 	zTemp0
.d8b4	b8b4	85 36		sta $36				sta 	zTemp0
.d8b6	b8b6	90 d4		bcc $b88c			bcc 	_CCVSearch
.d8b8	b8b8	e6 37		inc $37				inc 	zTemp0+1
.d8ba	b8ba	80 d0		bra $b88c			bra 	_CCVSearch
.d8bc	b8bc					_CCVFail:
.d8bc	b8bc	a0 01		ldy #$01			ldy 	#1 							; create the new record. Offset 1 is hash
.d8be	b8be	ad 23 04	lda $0423			lda 	identHash
.d8c1	b8c1	91 36		sta ($36),y			sta 	(zTemp0),y
.d8c3	b8c3	c8		iny				iny 								; offset 2 is the type byte
.d8c4	b8c4	ad 24 04	lda $0424			lda 	identTypeByte
.d8c7	b8c7	91 36		sta ($36),y			sta 	(zTemp0),y
.d8c9	b8c9	c8		iny				iny
.d8ca	b8ca					_CCVData:
.d8ca	b8ca	a9 00		lda #$00			lda 	#0 							; erase data 3-7 (the 5 value bytes)
.d8cc	b8cc	91 36		sta ($36),y			sta 	(zTemp0),y
.d8ce	b8ce	c8		iny				iny
.d8cf	b8cf	c0 08		cpy #$08			cpy 	#8
.d8d1	b8d1	90 f7		bcc $b8ca			bcc 	_CCVData
.d8d3	b8d3	ae 20 04	ldx $0420			ldx 	identStart 					; copy name into 8 on.
.d8d6	b8d6					_CCVCopyName:
.d8d6	b8d6	bd 46 05	lda $0546,x			lda 	lineBuffer,x
.d8d9	b8d9	91 36		sta ($36),y			sta 	(zTemp0),y
.d8db	b8db	e8		inx				inx
.d8dc	b8dc	c8		iny				iny
.d8dd	b8dd	ec 22 04	cpx $0422			cpx 	identTypeEnd
.d8e0	b8e0	d0 f4		bne $b8d6			bne 	_CCVCopyName
.d8e2	b8e2	98		tya				tya 								; patch offset
.d8e3	b8e3	92 36		sta ($36)			sta 	(zTemp0)
.d8e5	b8e5	a9 00		lda #$00			lda 	#0 							; offset for next is zero.
.d8e7	b8e7	91 36		sta ($36),y			sta 	(zTemp0),y
.d8e9	b8e9	88		dey				dey
.d8ea	b8ea	b1 36		lda ($36),y			lda 	(zTemp0),y 					; set bit 7 of last bit
.d8ec	b8ec	09 80		ora #$80			ora 	#$80
.d8ee	b8ee	91 36		sta ($36),y			sta 	(zTemp0),y
.d8f0	b8f0					_CCVFound:
.d8f0	b8f0	a5 37		lda $37				lda 	zTemp0+1 					; write out MSB
.d8f2	b8f2	38		sec				sec
.d8f3	b8f3	e9 10		sbc #$10			sbc 	#(VariableSpace >> 8) 		; offset from the start of the variable token
.d8f5	b8f5	09 40		ora #$40			ora 	#$40 						; make it a writeable token $4000-$7FFF
.d8f7	b8f7	20 78 b8	jsr $b878			jsr 	TOKWriteByte
.d8fa	b8fa	a5 36		lda $36				lda 	zTemp0 						; write out LSB
.d8fc	b8fc	20 78 b8	jsr $b878			jsr 	TOKWriteByte
.d8ff	b8ff	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/.build/sound.module.asm

=1						soundIntegrated=1
.d900	b900					SNDCheckChannel:
.d900	b900	aa		tax				tax
.d901	b901	bd be 0a	lda $0abe,x			lda 	SNDTimeLeft,x 				; currently playing a note
.d904	b904	d0 38		bne $b93e			bne 	_SNDCCExit
.d906	b906	da		phx				phx 								; save current channel
.d907	b907	8a		txa				txa 								; put in A
.d908	b908	20 84 b9	jsr $b984			jsr 	SNDFindNextNoteForA 		; is there a note for A in the queue ?
.d90b	b90b	68		pla				pla 								; channel # in A
.d90c	b90c	90 30		bcc $b93e			bcc 	_SNDCCExit  				; nothing in the queue for this channel, exit.
.d90e	b90e	a8		tay				tay 								; Y is the channel #
.d90f	b90f	bd b3 09	lda $09b3,x			lda 	SNDQueue+1,x 				; copy data into the slot.
.d912	b912	99 b2 0a	sta $0ab2,y			sta 	SNDPitchLow,y
.d915	b915	bd b4 09	lda $09b4,x			lda 	SNDQueue+2,x
.d918	b918	99 b6 0a	sta $0ab6,y			sta 	SNDPitchHigh,y
.d91b	b91b	bd b5 09	lda $09b5,x			lda 	SNDQueue+3,x
.d91e	b91e	99 ba 0a	sta $0aba,y			sta 	SNDVolume,y
.d921	b921	bd b6 09	lda $09b6,x			lda 	SNDQueue+4,x
.d924	b924	99 be 0a	sta $0abe,y			sta 	SNDTimeLeft,y
.d927	b927	bd b7 09	lda $09b7,x			lda 	SNDQueue+5,x
.d92a	b92a	99 c2 0a	sta $0ac2,y			sta 	SNDAdjustLow,y
.d92d	b92d	bd b8 09	lda $09b8,x			lda 	SNDQueue+6,x
.d930	b930	99 c6 0a	sta $0ac6,y			sta 	SNDAdjustHigh,y
.d933	b933	5a		phy				phy 								; save channel #
.d934	b934	20 9e b9	jsr $b99e			jsr 	SNDDeleteXFromQueue 		; delete record at X from queue
.d937	b937	ce b1 09	dec $09b1			dec 	SNDLength 					; reduce the queue length.
.d93a	b93a	68		pla				pla
.d93b	b93b	20 3f b9	jsr $b93f			jsr 	SNDUpdateNote 				; update channel A
.d93e	b93e					_SNDCCExit:
.d93e	b93e	60		rts				rts
.d93f	b93f					SNDUpdateNote:
.d93f	b93f	aa		tax				tax 								; so we can access records
.d940	b940	0a		asl a				asl 	a 							; convert it to a channel bit pair in 5,6
.d941	b941	0a		asl a				asl 	a
.d942	b942	0a		asl a				asl 	a
.d943	b943	0a		asl a				asl 	a
.d944	b944	0a		asl a				asl 	a
.d945	b945	8d b0 09	sta $09b0			sta 	SNDChannelBits
.d948	b948	bd be 0a	lda $0abe,x			lda 	SNDTimeLeft,x 				; are we silent
.d94b	b94b	f0 2e		beq $b97b			beq 	_SNDUNIsSilent
.d94d	b94d	ad b0 09	lda $09b0			lda 	SNDChannelBits 				; push channel bits on stack
.d950	b950	48		pha				pha
.d951	b951	bd b2 0a	lda $0ab2,x			lda 	SNDPitchLow,x 				; get 4 lowest bits of pitch.
.d954	b954	29 0f		and #$0f			and 	#$0F
.d956	b956	0d b0 09	ora $09b0			ora 	SNDChannelBits 				; set channel bits
.d959	b959	09 80		ora #$80			ora 	#$80 						; write to pitch register
.d95b	b95b	20 e8 b9	jsr $b9e8			jsr 	SNDWritePorts
.d95e	b95e	bd b6 0a	lda $0ab6,x			lda 	SNDPitchHigh,x 				; pitch high => channel temp.
.d961	b961	8d b0 09	sta $09b0			sta 	SNDChannelBits
.d964	b964	bd b2 0a	lda $0ab2,x			lda 	SNDPitchLow,x
.d967	b967	4e b0 09	lsr $09b0			lsr 	SNDChannelBits 				; shift 2 LSBs into MSB of A
.d96a	b96a	6a		ror a				ror 	a
.d96b	b96b	4e b0 09	lsr $09b0			lsr 	SNDChannelBits
.d96e	b96e	6a		ror a				ror 	a
.d96f	b96f	4a		lsr a				lsr 	a 							; put in bits 0-5
.d970	b970	4a		lsr a				lsr 	a
.d971	b971	20 e8 b9	jsr $b9e8			jsr 	SNDWritePorts 				; write as rest of pitch register
.d974	b974	68		pla				pla
.d975	b975	09 90		ora #$90			ora 	#$90 						; set to write minimum attentuation.
.d977	b977	20 e8 b9	jsr $b9e8			jsr 	SNDWritePorts
.d97a	b97a	60		rts				rts
.d97b	b97b					_SNDUNIsSilent:
.d97b	b97b	ad b0 09	lda $09b0			lda 	SNDChannelBits 				; channel bits
.d97e	b97e	09 9f		ora #$9f			ora 	#$9F 						; maximum attenuation
.d980	b980	20 e8 b9	jsr $b9e8			jsr 	SNDWritePorts 				; write to the ports
.d983	b983	60		rts				rts
.d984	b984					SNDFindNextNoteForA:
.d984	b984	ac b1 09	ldy $09b1			ldy 	SNDLength 					; queue size into Y
.d987	b987	f0 13		beq $b99c			beq 	_SNDFNNFail 				; queue empty.
.d989	b989	a2 00		ldx #$00			ldx 	#0
.d98b	b98b					_SNDFNNSearch:
.d98b	b98b	dd b2 09	cmp $09b2,x			cmp 	SNDQueue,x 					; does it match the channel
.d98e	b98e	38		sec				sec
.d98f	b98f	f0 0c		beq $b99d			beq 	_SNDFNNExit 				; if so exit with CS.
.d991	b991	e8		inx				inx 								; next queue slot.
.d992	b992	e8		inx				inx
.d993	b993	e8		inx				inx
.d994	b994	e8		inx				inx
.d995	b995	e8		inx				inx
.d996	b996	e8		inx				inx
.d997	b997	e8		inx				inx
.d998	b998	e8		inx				inx
.d999	b999	88		dey				dey 								; done the whole queue
.d99a	b99a	d0 ef		bne $b98b			bne 	_SNDFNNSearch 				; no, go back.
.d99c	b99c					_SNDFNNFail:
.d99c	b99c	18		clc				clc
.d99d	b99d					_SNDFNNExit:
.d99d	b99d	60		rts				rts
.d99e	b99e					SNDDeleteXFromQueue:
.d99e	b99e	e0 f8		cpx #$f8			cpx 	#SNDQueueSize*8-8 			; reached the end.
.d9a0	b9a0	f0 09		beq $b9ab			beq 	_SNDDXExit
.d9a2	b9a2	bd ba 09	lda $09ba,x			lda 	SNDQueue+8,x
.d9a5	b9a5	9d b2 09	sta $09b2,x			sta 	SNDQueue,x
.d9a8	b9a8	e8		inx				inx
.d9a9	b9a9	80 f3		bra $b99e			bra 	SNDDeleteXFromQueue
.d9ab	b9ab					_SNDDXExit:
.d9ab	b9ab	60		rts				rts
.09b0						SNDChannelBits:
>09b0								.fill 	1
.d9ac	b9ac					SNDQueueRequest:
.d9ac	b9ac	86 36		stx $36				stx 	zTemp0						; save queue address
.d9ae	b9ae	84 37		sty $37				sty 	zTemp0+1
.d9b0	b9b0	ae b1 09	ldx $09b1			ldx 	SNDLength 					; queue is full, can't take any more.
.d9b3	b9b3	e0 20		cpx #$20			cpx 	#SNDQueueSize
.d9b5	b9b5	f0 21		beq $b9d8			beq 	_SNDQRExit
.d9b7	b9b7	29 03		and #$03			and 	#3	 						; channel # and push on stack
.d9b9	b9b9	48		pha				pha
.d9ba	b9ba	8a		txa				txa  								; get offset in queue buffer/
.d9bb	b9bb	0a		asl a				asl 	a
.d9bc	b9bc	0a		asl a				asl 	a
.d9bd	b9bd	0a		asl a				asl 	a
.d9be	b9be	aa		tax				tax
.d9bf	b9bf	68		pla				pla 								; get back and push again
.d9c0	b9c0	48		pha				pha
.d9c1	b9c1	9d b2 09	sta $09b2,x			sta 	SNDQueue+0,x 				; save the channel #
.d9c4	b9c4	a0 00		ldy #$00			ldy 	#0 							; copy the rest in.
.d9c6	b9c6					_SNDQCopy:
.d9c6	b9c6	b1 36		lda ($36),y			lda 	(zTemp0),y
.d9c8	b9c8	e8		inx				inx
.d9c9	b9c9	c8		iny				iny
.d9ca	b9ca	9d b2 09	sta $09b2,x			sta 	SNDQueue,x
.d9cd	b9cd	c0 06		cpy #$06			cpy 	#6
.d9cf	b9cf	d0 f5		bne $b9c6			bne 	_SNDQCopy
.d9d1	b9d1	ee b1 09	inc $09b1			inc 	SNDLength 					; bump queue length.
.d9d4	b9d4	68		pla				pla 								; get channel # back
.d9d5	b9d5	20 00 b9	jsr $b900			jsr 	SNDCheckChannel 			; check if channel needs refreshing.
.d9d8	b9d8					_SNDQRExit:
.d9d8	b9d8	60		rts				rts
.d9d9	b9d9					SNDSilenceChannel:
.d9d9	b9d9	aa		tax				tax 								; zero time left.
.d9da	b9da	9e be 0a	stz $0abe,x			stz 	SNDTimeLeft,x
.d9dd	b9dd	0a		asl a				asl 	a 							; shift into position
.d9de	b9de	0a		asl a				asl 	a
.d9df	b9df	0a		asl a				asl 	a
.d9e0	b9e0	0a		asl a				asl 	a
.d9e1	b9e1	0a		asl a				asl 	a
.d9e2	b9e2	09 9f		ora #$9f			ora 	#$9F 						; write register attenuation $F
.d9e4	b9e4	20 e8 b9	jsr $b9e8			jsr 	SNDWritePorts
.d9e7	b9e7	60		rts				rts
.d9e8	b9e8					SNDWritePorts:
.d9e8	b9e8	da		phx				phx 								; save X
.d9e9	b9e9	a6 01		ldx $01				ldx 	1 							; save I/O status
.d9eb	b9eb	64 01		stz $01				stz 	1 							; access I/O page 0
.d9ed	b9ed	8d 00 d6	sta $d600			sta 	$D600 						; write to both
.d9f0	b9f0	8d 10 d6	sta $d610			sta 	$D610
.d9f3	b9f3	86 01		stx $01				stx 	1 							; restore I/O
.d9f5	b9f5	fa		plx				plx 								; restore X
.d9f6	b9f6	60		rts				rts
.d9f7	b9f7					Export_SNDCommand:
.d9f7	b9f7	da		phx				phx 								; save XY
.d9f8	b9f8	5a		phy				phy
.d9f9	b9f9	c9 0f		cmp #$0f			cmp 	#$0F 						; $0F is initialise
.d9fb	b9fb	f0 1d		beq $ba1a			beq 	_SNDInitialise
.d9fd	b9fd	90 28		bcc $ba27			bcc 	_SNDExit
.d9ff	b9ff	c9 3f		cmp #$3f			cmp 	#$3F 						; $3F is silence all
.da01	ba01	f0 17		beq $ba1a			beq 	_SNDSilence
.da03	ba03	b0 22		bcs $ba27			bcs 	_SNDExit
.da05	ba05	c9 20		cmp #$20			cmp 	#$20 						; $2x is check playing => A
.da07	ba07	b0 09		bcs $ba12			bcs 	_SNDQueryPlay
.da09	ba09	c9 14		cmp #$14			cmp 	#$14 						; $10-$13 is queue sound
.da0b	ba0b	b0 1a		bcs $ba27			bcs 	_SNDExit
.da0d	ba0d	20 ac b9	jsr $b9ac			jsr 	SNDQueueRequest
.da10	ba10	80 15		bra $ba27			bra 	_SNDExit
.da12	ba12					_SNDQueryPlay:
.da12	ba12	29 03		and #$03			and 	#3 							; get channel #
.da14	ba14	aa		tax				tax
.da15	ba15	bd be 0a	lda $0abe,x			lda 	SNDTimeLeft,x 				; read time left, if zero then silent
.da18	ba18	80 0d		bra $ba27			bra 	_SNDExit
.da1a	ba1a					_SNDInitialise:
.da1a	ba1a					_SNDSilence:
.da1a	ba1a	9c b1 09	stz $09b1			stz 	SNDLength 					; empty the queue.
.da1d	ba1d	a9 03		lda #$03			lda 	#$3 						; silence channel 0-3.
.da1f	ba1f					_SNDSilenceLoop:
.da1f	ba1f	48		pha				pha
.da20	ba20	20 d9 b9	jsr $b9d9			jsr 	SNDSilenceChannel
.da23	ba23	68		pla				pla
.da24	ba24	3a		dec a				dec 	a
.da25	ba25	10 f8		bpl $ba1f			bpl 	_SNDSilenceLoop
.da27	ba27					_SNDExit:
.da27	ba27	7a		ply				ply
.da28	ba28	fa		plx				plx
.da29	ba29	60		rts				rts
=32						SNDQueueSize = 32 							; number of queue entries
.09b1						SNDLength:
>09b1								.fill 	1
.09b2						SNDQueue:
>09b2								.fill 	SNDQueueSize * 8
.0ab2						SNDPitchLow:
>0ab2								.fill 	4
.0ab6						SNDPitchHigh:
>0ab6								.fill 	4
.0aba						SNDVolume:
>0aba								.fill 	4
.0abe						SNDTimeLeft:
>0abe								.fill 	4
.0ac2						SNDAdjustLow:
>0ac2								.fill 	4
.0ac6						SNDAdjustHigh:
>0ac6								.fill 	4
.da2a	ba2a					Export_SNDUpdate:
.da2a	ba2a					PagedSNDUpdate:
.da2a	ba2a	ad be 0a	lda $0abe			lda 	SNDTimeLeft+0 				; look at time remaining
.da2d	ba2d	f0 05		beq $ba34			beq 	_SNDUNot0 					; not playing
.da2f	ba2f	a2 00		ldx #$00			ldx 	#0 							; so we know which channel to update
.da31	ba31	20 53 ba	jsr $ba53			jsr 	SNDUpdateChannel 			; update it.
.da34	ba34					_SNDUNot0:
.da34	ba34	ad bf 0a	lda $0abf			lda 	SNDTimeLeft+1
.da37	ba37	f0 05		beq $ba3e			beq 	_SNDUNot1
.da39	ba39	a2 01		ldx #$01			ldx 	#1
.da3b	ba3b	20 53 ba	jsr $ba53			jsr 	SNDUpdateChannel
.da3e	ba3e					_SNDUNot1:
.da3e	ba3e	ad c0 0a	lda $0ac0			lda 	SNDTimeLeft+2
.da41	ba41	f0 05		beq $ba48			beq 	_SNDUNot2
.da43	ba43	a2 02		ldx #$02			ldx 	#2
.da45	ba45	20 53 ba	jsr $ba53			jsr 	SNDUpdateChannel
.da48	ba48					_SNDUNot2:
.da48	ba48	ad c1 0a	lda $0ac1			lda 	SNDTimeLeft+3
.da4b	ba4b	f0 05		beq $ba52			beq 	_SNDUNot3
.da4d	ba4d	a2 03		ldx #$03			ldx 	#3
.da4f	ba4f	20 53 ba	jsr $ba53			jsr 	SNDUpdateChannel
.da52	ba52					_SNDUNot3:
.da52	ba52	60		rts				rts
.da53	ba53					SNDUpdateChannel:
.da53	ba53	c9 ff		cmp #$ff			cmp 	#$FF 						; sound $FF play forever until turned off manually
.da55	ba55	f0 2c		beq $ba83			beq 	_SNDUCExit
.da57	ba57	3a		dec a				dec 	a 							; decrement and update timer
.da58	ba58	9d be 0a	sta $0abe,x			sta 	SNDTimeLeft,x
.da5b	ba5b	f0 1d		beq $ba7a			beq 	_SNDUCUpdate 				; if zero, silence channel
.da5d	ba5d	bd c2 0a	lda $0ac2,x			lda 	SNDAdjustLow,x 				; adjust ?
.da60	ba60	1d c6 0a	ora $0ac6,x			ora 	SNDAdjustHigh,x
.da63	ba63	f0 1e		beq $ba83			beq 	_SNDUCExit 					; if zero carry on at current tone.
.da65	ba65	18		clc				clc 								; add adjust, forcing into a 10 bit range
.da66	ba66	bd b2 0a	lda $0ab2,x			lda 	SNDPitchLow,x
.da69	ba69	7d c2 0a	adc $0ac2,x			adc 	SNDAdjustLow,x
.da6c	ba6c	9d b2 0a	sta $0ab2,x			sta 	SNDPitchLow,x
.da6f	ba6f	bd b6 0a	lda $0ab6,x			lda 	SNDPitchHigh,x
.da72	ba72	7d c6 0a	adc $0ac6,x			adc 	SNDAdjustHigh,x
.da75	ba75	29 03		and #$03			and 	#3
.da77	ba77	9d b6 0a	sta $0ab6,x			sta 	SNDPitchHigh,x
.da7a	ba7a					_SNDUCUpdate:
.da7a	ba7a	8a		txa				txa 								; which channel.
.da7b	ba7b	48		pha				pha
.da7c	ba7c	20 3f b9	jsr $b93f			jsr 	SNDUpdateNote 				; update the current note
.da7f	ba7f	68		pla				pla
.da80	ba80	20 00 b9	jsr $b900			jsr 	SNDCheckChannel 			; more to do ?
.da83	ba83					_SNDUCExit:
.da83	ba83	60		rts				rts

;******  Return to file: _basic.asm


;******  Processing file: ../modules/.build/kernel.module.asm

=1						kernelIntegrated=1

;******  Return to file: _basic.asm


;******  Processing file: ../modules/hardware/header/.build/headerdata.dat

=14						Header_Height = 14
=255						Header_RLE = 255
.e000	a000					Asset_jattrs:
>e000	a000	ff f2 58 f2 ff d8 07 d8			.byte	255,242,88,242,255,216,7,216,255,242,2,242,255,216,6,216,255,242,2,242,255,216,8,216,255,242,2,242,255,216,6,216,255,242,9,242,210,210,242,242,255,210,7,210,255,242,17,242,104,104,255,242,7,242,104,104,255,242,4,242,104,104,242,242,104,104,255,242,8,242,104,104,255,242,4,242,104,104,255,242,8,242,210,210,242,242,210,210,255,242,4,242,210,210,255,242,16,242,232,232,255,242,14,242,232,232,242,242,232,232,255,242,8,242,232,232,255,242,15,242,210,210,242,242,210,210,255,242,4,242,210,210,255,242,16,242,255,56,5,56,255,242,4,242,255,56,6,56,255,242,2,242,255,56,7,56,255,242,2,242,255,56,7,56,255,242,9,242,210,210,242,242,255,210,7,210,255,242,17,242,120,120,255,242,7,242,120,120,255,242,15,242,120,120,242,242,120,120,255,242,4,242,120,120,242,242,210,210,255,242,4,242,210,210,242,242,210,210,255,242,2,242,210,210,255,242,18,242,168,168,255,242,7,242,168,168,255,242,8,242,168,168,255,242,4,242,168,168,242,242,168,168,255,242,4,242,168,168,242,242,210,210,255,242,4,242,210,210,242,242,210,210,255,242,3,242,210,210,255,242,17,242,72,72,255,242,7,242,255,72,8,72,255,242,2,242,255,72,6,72,255,242,3,242,255,72,6,72,255,242,3,242,255,210,6,210,255,242,2,242,210,210,255,242,4,242,210,210,255,242,87,242,255,114,80,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,255,114,80,114,255,0
>e008	a008	ff f2 02 f2 ff d8 06 d8 ff f2 02 f2 ff d8 08 d8
>e018	a018	ff f2 02 f2 ff d8 06 d8 ff f2 09 f2 d2 d2 f2 f2
>e028	a028	ff d2 07 d2 ff f2 11 f2 68 68 ff f2 07 f2 68 68
>e038	a038	ff f2 04 f2 68 68 f2 f2 68 68 ff f2 08 f2 68 68
>e048	a048	ff f2 04 f2 68 68 ff f2 08 f2 d2 d2 f2 f2 d2 d2
>e058	a058	ff f2 04 f2 d2 d2 ff f2 10 f2 e8 e8 ff f2 0e f2
>e068	a068	e8 e8 f2 f2 e8 e8 ff f2 08 f2 e8 e8 ff f2 0f f2
>e078	a078	d2 d2 f2 f2 d2 d2 ff f2 04 f2 d2 d2 ff f2 10 f2
>e088	a088	ff 38 05 38 ff f2 04 f2 ff 38 06 38 ff f2 02 f2
>e098	a098	ff 38 07 38 ff f2 02 f2 ff 38 07 38 ff f2 09 f2
>e0a8	a0a8	d2 d2 f2 f2 ff d2 07 d2 ff f2 11 f2 78 78 ff f2
>e0b8	a0b8	07 f2 78 78 ff f2 0f f2 78 78 f2 f2 78 78 ff f2
>e0c8	a0c8	04 f2 78 78 f2 f2 d2 d2 ff f2 04 f2 d2 d2 f2 f2
>e0d8	a0d8	d2 d2 ff f2 02 f2 d2 d2 ff f2 12 f2 a8 a8 ff f2
>e0e8	a0e8	07 f2 a8 a8 ff f2 08 f2 a8 a8 ff f2 04 f2 a8 a8
>e0f8	a0f8	f2 f2 a8 a8 ff f2 04 f2 a8 a8 f2 f2 d2 d2 ff f2
>e108	a108	04 f2 d2 d2 f2 f2 d2 d2 ff f2 03 f2 d2 d2 ff f2
>e118	a118	11 f2 48 48 ff f2 07 f2 ff 48 08 48 ff f2 02 f2
>e128	a128	ff 48 06 48 ff f2 03 f2 ff 48 06 48 ff f2 03 f2
>e138	a138	ff d2 06 d2 ff f2 02 f2 d2 d2 ff f2 04 f2 d2 d2
>e148	a148	ff f2 57 f2 ff 72 50 72 ff e2 1b e2 72 ff 92 04
>e158	a158	92 ff 72 12 72 ff c2 18 c2 72 72 ff e2 1b e2 72
>e168	a168	ff 92 04 92 ff 72 12 72 ff c2 18 c2 72 72 ff e2
>e178	a178	1b e2 72 ff 92 04 92 ff 72 12 72 ff c2 18 c2 ff
>e188	a188	72 50 72 ff 00
.e18d	a18d					Asset_jchars:
>e18d	a18d	ff 20 58 20 ff 08 07 08			.byte	255,32,88,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,9,32,252,252,32,32,255,252,7,252,255,32,17,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,255,32,8,32,252,252,32,32,252,252,255,32,4,32,252,252,255,32,16,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,15,32,252,252,32,32,252,252,255,32,4,32,252,252,255,32,16,32,255,8,5,8,255,32,4,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,7,8,255,32,9,32,252,252,32,32,255,252,7,252,255,32,17,32,8,8,255,32,7,32,8,8,255,32,15,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,252,252,255,32,4,32,252,252,32,32,252,252,255,32,2,32,252,252,255,32,18,32,8,8,255,32,7,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,252,252,255,32,4,32,252,252,32,32,252,252,255,32,3,32,252,252,255,32,17,32,8,8,255,32,7,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,3,32,255,8,6,8,255,32,3,32,255,252,6,252,255,32,2,32,252,252,255,32,4,32,252,252,255,32,87,32,160,255,150,27,150,155,255,150,22,150,155,255,150,24,150,161,130,72,97,114,100,119,97,114,101,255,32,19,32,130,215,50,48,50,51,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,45,106,114,255,32,2,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,215,50,48,50,51,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,215,50,48,50,51,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,162,255,150,27,150,157,255,150,22,150,157,255,150,24,150,163,255,0
>e195	a195	ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08 08 08
>e1a5	a1a5	ff 20 02 20 ff 08 06 08 ff 20 09 20 fc fc 20 20
>e1b5	a1b5	ff fc 07 fc ff 20 11 20 08 08 ff 20 07 20 08 08
>e1c5	a1c5	ff 20 04 20 08 08 20 20 08 08 ff 20 08 20 08 08
>e1d5	a1d5	ff 20 04 20 08 08 ff 20 08 20 fc fc 20 20 fc fc
>e1e5	a1e5	ff 20 04 20 fc fc ff 20 10 20 08 08 ff 20 0e 20
>e1f5	a1f5	08 08 20 20 08 08 ff 20 08 20 08 08 ff 20 0f 20
>e205	a205	fc fc 20 20 fc fc ff 20 04 20 fc fc ff 20 10 20
>e215	a215	ff 08 05 08 ff 20 04 20 ff 08 06 08 ff 20 02 20
>e225	a225	ff 08 07 08 ff 20 02 20 ff 08 07 08 ff 20 09 20
>e235	a235	fc fc 20 20 ff fc 07 fc ff 20 11 20 08 08 ff 20
>e245	a245	07 20 08 08 ff 20 0f 20 08 08 20 20 08 08 ff 20
>e255	a255	04 20 08 08 20 20 fc fc ff 20 04 20 fc fc 20 20
>e265	a265	fc fc ff 20 02 20 fc fc ff 20 12 20 08 08 ff 20
>e275	a275	07 20 08 08 ff 20 08 20 08 08 ff 20 04 20 08 08
>e285	a285	20 20 08 08 ff 20 04 20 08 08 20 20 fc fc ff 20
>e295	a295	04 20 fc fc 20 20 fc fc ff 20 03 20 fc fc ff 20
>e2a5	a2a5	11 20 08 08 ff 20 07 20 ff 08 08 08 ff 20 02 20
>e2b5	a2b5	ff 08 06 08 ff 20 03 20 ff 08 06 08 ff 20 03 20
>e2c5	a2c5	ff fc 06 fc ff 20 02 20 fc fc ff 20 04 20 fc fc
>e2d5	a2d5	ff 20 57 20 a0 ff 96 1b 96 9b ff 96 16 96 9b ff
>e2e5	a2e5	96 18 96 a1 82 48 61 72 64 77 61 72 65 ff 20 13
>e2f5	a2f5	20 82 d7 32 30 32 33 20 53 74 65 66 61 6e 79 20
>e305	a305	41 6c 6c 61 69 72 65 20 20 82 63 32 35 36 66 6f
>e315	a315	65 6e 69 78 2e 63 6f 6d 2f 66 32 35 36 2d 6a 72
>e325	a325	ff 20 02 20 82 82 4d 69 63 72 6f 4b 65 72 6e 65
>e335	a335	6c ff 20 10 20 82 d7 32 30 32 33 20 4a 65 73 73
>e345	a345	69 65 20 4f 62 65 72 72 65 75 74 65 72 82 47 61
>e355	a355	64 67 65 74 40 48 61 63 6b 77 72 65 6e 63 68 4c
>e365	a365	61 62 73 2e 63 6f 6d 82 82 53 75 70 65 72 42 41
>e375	a375	53 49 43 ff 20 11 20 82 d7 32 30 32 33 20 50 61
>e385	a385	75 6c 20 52 6f 62 73 6f 6e ff 20 05 20 82 50 61
>e395	a395	75 6c 40 52 6f 62 73 6f 6e 73 2e 6f 72 67 2e 75
>e3a5	a3a5	6b ff 20 05 20 82 a2 ff 96 1b 96 9d ff 96 16 96
>e3b5	a3b5	9d ff 96 18 96 a3 ff 00
.e3bd	a3bd					Asset_kattrs:
>e3bd	a3bd	ff f2 5e f2 ff d8 07 d8			.byte	255,242,94,242,255,216,7,216,255,242,2,242,255,216,6,216,255,242,2,242,255,216,8,216,255,242,2,242,255,216,6,216,255,242,2,242,210,210,255,242,3,242,210,210,255,242,28,242,104,104,255,242,7,242,104,104,255,242,4,242,104,104,242,242,104,104,255,242,8,242,104,104,255,242,4,242,104,104,242,242,210,210,255,242,2,242,210,210,255,242,29,242,232,232,255,242,14,242,232,232,242,242,232,232,255,242,8,242,232,232,255,242,8,242,210,210,242,242,210,210,255,242,30,242,255,56,5,56,255,242,4,242,255,56,6,56,255,242,2,242,255,56,7,56,255,242,2,242,255,56,7,56,255,242,2,242,255,210,4,210,255,242,31,242,120,120,255,242,7,242,120,120,255,242,15,242,113,113,242,242,113,113,255,242,4,242,113,113,242,242,210,210,242,242,210,210,255,242,30,242,168,168,255,242,7,242,168,168,255,242,8,242,168,168,255,242,4,242,168,168,242,242,168,168,255,242,4,242,168,168,242,242,210,210,255,242,2,242,210,210,255,242,29,242,72,72,255,242,7,242,255,72,8,72,255,242,2,242,255,72,6,72,255,242,3,242,255,72,6,72,255,242,2,242,210,210,255,242,3,242,210,210,255,242,93,242,255,114,80,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,255,114,80,114,255,0
>e3c5	a3c5	ff f2 02 f2 ff d8 06 d8 ff f2 02 f2 ff d8 08 d8
>e3d5	a3d5	ff f2 02 f2 ff d8 06 d8 ff f2 02 f2 d2 d2 ff f2
>e3e5	a3e5	03 f2 d2 d2 ff f2 1c f2 68 68 ff f2 07 f2 68 68
>e3f5	a3f5	ff f2 04 f2 68 68 f2 f2 68 68 ff f2 08 f2 68 68
>e405	a405	ff f2 04 f2 68 68 f2 f2 d2 d2 ff f2 02 f2 d2 d2
>e415	a415	ff f2 1d f2 e8 e8 ff f2 0e f2 e8 e8 f2 f2 e8 e8
>e425	a425	ff f2 08 f2 e8 e8 ff f2 08 f2 d2 d2 f2 f2 d2 d2
>e435	a435	ff f2 1e f2 ff 38 05 38 ff f2 04 f2 ff 38 06 38
>e445	a445	ff f2 02 f2 ff 38 07 38 ff f2 02 f2 ff 38 07 38
>e455	a455	ff f2 02 f2 ff d2 04 d2 ff f2 1f f2 78 78 ff f2
>e465	a465	07 f2 78 78 ff f2 0f f2 71 71 f2 f2 71 71 ff f2
>e475	a475	04 f2 71 71 f2 f2 d2 d2 f2 f2 d2 d2 ff f2 1e f2
>e485	a485	a8 a8 ff f2 07 f2 a8 a8 ff f2 08 f2 a8 a8 ff f2
>e495	a495	04 f2 a8 a8 f2 f2 a8 a8 ff f2 04 f2 a8 a8 f2 f2
>e4a5	a4a5	d2 d2 ff f2 02 f2 d2 d2 ff f2 1d f2 48 48 ff f2
>e4b5	a4b5	07 f2 ff 48 08 48 ff f2 02 f2 ff 48 06 48 ff f2
>e4c5	a4c5	03 f2 ff 48 06 48 ff f2 02 f2 d2 d2 ff f2 03 f2
>e4d5	a4d5	d2 d2 ff f2 5d f2 ff 72 50 72 ff e2 1b e2 72 ff
>e4e5	a4e5	92 04 92 ff 72 12 72 ff c2 18 c2 72 72 ff e2 1b
>e4f5	a4f5	e2 72 ff 92 04 92 ff 72 12 72 ff c2 18 c2 72 72
>e505	a505	ff e2 1b e2 72 ff 92 04 92 ff 72 12 72 ff c2 18
>e515	a515	c2 ff 72 50 72 ff 00
.e51c	a51c					Asset_kchars:
>e51c	a51c	ff 20 5e 20 ff 08 07 08			.byte	255,32,94,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,2,32,180,180,255,32,3,32,180,180,255,32,28,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,180,180,255,32,2,32,180,180,255,32,29,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,8,32,180,180,32,32,180,180,255,32,30,32,255,8,5,8,255,32,4,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,7,8,255,32,2,32,255,180,4,180,255,32,31,32,8,8,255,32,7,32,8,8,255,32,15,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,180,180,32,32,180,180,255,32,30,32,8,8,255,32,7,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,180,180,255,32,2,32,180,180,255,32,29,32,8,8,255,32,7,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,3,32,255,8,6,8,255,32,2,32,180,180,255,32,3,32,180,180,255,32,93,32,188,255,150,27,150,155,255,150,22,150,155,255,150,24,150,189,130,72,97,114,100,119,97,114,101,255,32,19,32,130,215,50,48,50,51,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,45,106,114,255,32,2,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,215,50,48,50,51,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,215,50,48,50,51,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,190,255,150,27,150,157,255,150,22,150,157,255,150,24,150,191,255,0
>e524	a524	ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08 08 08
>e534	a534	ff 20 02 20 ff 08 06 08 ff 20 02 20 b4 b4 ff 20
>e544	a544	03 20 b4 b4 ff 20 1c 20 08 08 ff 20 07 20 08 08
>e554	a554	ff 20 04 20 08 08 20 20 08 08 ff 20 08 20 08 08
>e564	a564	ff 20 04 20 08 08 20 20 b4 b4 ff 20 02 20 b4 b4
>e574	a574	ff 20 1d 20 08 08 ff 20 0e 20 08 08 20 20 08 08
>e584	a584	ff 20 08 20 08 08 ff 20 08 20 b4 b4 20 20 b4 b4
>e594	a594	ff 20 1e 20 ff 08 05 08 ff 20 04 20 ff 08 06 08
>e5a4	a5a4	ff 20 02 20 ff 08 07 08 ff 20 02 20 ff 08 07 08
>e5b4	a5b4	ff 20 02 20 ff b4 04 b4 ff 20 1f 20 08 08 ff 20
>e5c4	a5c4	07 20 08 08 ff 20 0f 20 08 08 20 20 08 08 ff 20
>e5d4	a5d4	04 20 08 08 20 20 b4 b4 20 20 b4 b4 ff 20 1e 20
>e5e4	a5e4	08 08 ff 20 07 20 08 08 ff 20 08 20 08 08 ff 20
>e5f4	a5f4	04 20 08 08 20 20 08 08 ff 20 04 20 08 08 20 20
>e604	a604	b4 b4 ff 20 02 20 b4 b4 ff 20 1d 20 08 08 ff 20
>e614	a614	07 20 ff 08 08 08 ff 20 02 20 ff 08 06 08 ff 20
>e624	a624	03 20 ff 08 06 08 ff 20 02 20 b4 b4 ff 20 03 20
>e634	a634	b4 b4 ff 20 5d 20 bc ff 96 1b 96 9b ff 96 16 96
>e644	a644	9b ff 96 18 96 bd 82 48 61 72 64 77 61 72 65 ff
>e654	a654	20 13 20 82 d7 32 30 32 33 20 53 74 65 66 61 6e
>e664	a664	79 20 41 6c 6c 61 69 72 65 20 20 82 63 32 35 36
>e674	a674	66 6f 65 6e 69 78 2e 63 6f 6d 2f 66 32 35 36 2d
>e684	a684	6a 72 ff 20 02 20 82 82 4d 69 63 72 6f 4b 65 72
>e694	a694	6e 65 6c ff 20 10 20 82 d7 32 30 32 33 20 4a 65
>e6a4	a6a4	73 73 69 65 20 4f 62 65 72 72 65 75 74 65 72 82
>e6b4	a6b4	47 61 64 67 65 74 40 48 61 63 6b 77 72 65 6e 63
>e6c4	a6c4	68 4c 61 62 73 2e 63 6f 6d 82 82 53 75 70 65 72
>e6d4	a6d4	42 41 53 49 43 ff 20 11 20 82 d7 32 30 32 33 20
>e6e4	a6e4	50 61 75 6c 20 52 6f 62 73 6f 6e ff 20 05 20 82
>e6f4	a6f4	50 61 75 6c 40 52 6f 62 73 6f 6e 73 2e 6f 72 67
>e704	a704	2e 75 6b ff 20 05 20 82 be ff 96 1b 96 9d ff 96
>e714	a714	16 96 9d ff 96 18 96 bf ff 00
.e71e	a71e					Asset_j2attrs:
>e71e	a71e	ff f2 3f f2 ff 02 02 02			.byte	255,242,63,242,255,2,2,2,255,34,4,34,255,242,2,242,34,34,2,2,255,242,64,242,255,2,2,2,255,34,2,34,242,47,242,242,47,255,242,2,242,2,255,242,5,242,255,216,6,216,255,242,2,242,255,216,5,216,255,242,2,242,255,216,7,216,255,242,2,242,255,216,5,216,255,242,8,242,210,210,242,242,255,210,6,210,255,242,2,242,255,2,2,2,34,34,242,242,31,255,242,4,242,2,2,255,242,5,242,104,104,255,242,6,242,104,104,255,242,3,242,104,104,242,242,104,104,255,242,7,242,104,104,255,242,3,242,104,104,255,242,7,242,210,210,242,242,210,210,255,242,3,242,210,210,242,242,255,2,2,2,34,34,47,242,242,47,242,47,242,34,2,2,255,242,5,242,232,232,255,242,12,242,232,232,242,242,232,232,255,242,7,242,232,232,255,242,13,242,210,210,242,242,210,210,255,242,3,242,210,210,242,242,255,2,2,2,34,34,242,18,47,242,47,242,34,34,2,2,255,242,5,242,255,56,4,56,255,242,4,242,255,56,5,56,255,242,2,242,255,56,6,56,255,242,2,242,255,56,6,56,255,242,8,242,210,210,242,242,255,210,6,210,255,242,2,242,255,2,2,2,255,34,2,34,47,242,47,47,255,34,2,34,2,2,255,242,5,242,120,120,255,242,6,242,120,120,255,242,13,242,120,120,242,242,120,120,255,242,3,242,120,120,242,242,210,210,255,242,3,242,210,210,242,242,210,210,242,242,210,210,255,242,3,242,255,2,2,2,34,242,47,242,47,255,242,4,242,2,2,255,242,5,242,168,168,255,242,6,242,168,168,255,242,7,242,168,168,255,242,3,242,168,168,242,242,168,168,255,242,3,242,168,168,242,242,210,210,255,242,3,242,210,210,242,242,210,210,255,242,2,242,210,210,255,242,2,242,255,2,2,2,34,47,242,242,47,242,47,47,242,34,2,2,255,242,5,242,72,72,255,242,6,242,255,72,7,72,255,242,2,242,255,72,5,72,255,242,3,242,255,72,5,72,255,242,3,242,255,210,5,210,255,242,2,242,210,210,255,242,3,242,210,210,242,242,255,2,2,2,47,255,242,3,242,47,242,242,34,34,2,2,255,242,68,242,47,255,242,2,242,255,34,4,34,2,2,242,255,114,80,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,114,114,255,226,27,226,114,255,146,4,146,255,114,18,114,255,194,24,194,114,255,0
>e726	a726	ff 22 04 22 ff f2 02 f2 22 22 02 02 ff f2 40 f2
>e736	a736	ff 02 02 02 ff 22 02 22 f2 2f f2 f2 2f ff f2 02
>e746	a746	f2 02 ff f2 05 f2 ff d8 06 d8 ff f2 02 f2 ff d8
>e756	a756	05 d8 ff f2 02 f2 ff d8 07 d8 ff f2 02 f2 ff d8
>e766	a766	05 d8 ff f2 08 f2 d2 d2 f2 f2 ff d2 06 d2 ff f2
>e776	a776	02 f2 ff 02 02 02 22 22 f2 f2 1f ff f2 04 f2 02
>e786	a786	02 ff f2 05 f2 68 68 ff f2 06 f2 68 68 ff f2 03
>e796	a796	f2 68 68 f2 f2 68 68 ff f2 07 f2 68 68 ff f2 03
>e7a6	a7a6	f2 68 68 ff f2 07 f2 d2 d2 f2 f2 d2 d2 ff f2 03
>e7b6	a7b6	f2 d2 d2 f2 f2 ff 02 02 02 22 22 2f f2 f2 2f f2
>e7c6	a7c6	2f f2 22 02 02 ff f2 05 f2 e8 e8 ff f2 0c f2 e8
>e7d6	a7d6	e8 f2 f2 e8 e8 ff f2 07 f2 e8 e8 ff f2 0d f2 d2
>e7e6	a7e6	d2 f2 f2 d2 d2 ff f2 03 f2 d2 d2 f2 f2 ff 02 02
>e7f6	a7f6	02 22 22 f2 12 2f f2 2f f2 22 22 02 02 ff f2 05
>e806	a806	f2 ff 38 04 38 ff f2 04 f2 ff 38 05 38 ff f2 02
>e816	a816	f2 ff 38 06 38 ff f2 02 f2 ff 38 06 38 ff f2 08
>e826	a826	f2 d2 d2 f2 f2 ff d2 06 d2 ff f2 02 f2 ff 02 02
>e836	a836	02 ff 22 02 22 2f f2 2f 2f ff 22 02 22 02 02 ff
>e846	a846	f2 05 f2 78 78 ff f2 06 f2 78 78 ff f2 0d f2 78
>e856	a856	78 f2 f2 78 78 ff f2 03 f2 78 78 f2 f2 d2 d2 ff
>e866	a866	f2 03 f2 d2 d2 f2 f2 d2 d2 f2 f2 d2 d2 ff f2 03
>e876	a876	f2 ff 02 02 02 22 f2 2f f2 2f ff f2 04 f2 02 02
>e886	a886	ff f2 05 f2 a8 a8 ff f2 06 f2 a8 a8 ff f2 07 f2
>e896	a896	a8 a8 ff f2 03 f2 a8 a8 f2 f2 a8 a8 ff f2 03 f2
>e8a6	a8a6	a8 a8 f2 f2 d2 d2 ff f2 03 f2 d2 d2 f2 f2 d2 d2
>e8b6	a8b6	ff f2 02 f2 d2 d2 ff f2 02 f2 ff 02 02 02 22 2f
>e8c6	a8c6	f2 f2 2f f2 2f 2f f2 22 02 02 ff f2 05 f2 48 48
>e8d6	a8d6	ff f2 06 f2 ff 48 07 48 ff f2 02 f2 ff 48 05 48
>e8e6	a8e6	ff f2 03 f2 ff 48 05 48 ff f2 03 f2 ff d2 05 d2
>e8f6	a8f6	ff f2 02 f2 d2 d2 ff f2 03 f2 d2 d2 f2 f2 ff 02
>e906	a906	02 02 2f ff f2 03 f2 2f f2 f2 22 22 02 02 ff f2
>e916	a916	44 f2 2f ff f2 02 f2 ff 22 04 22 02 02 f2 ff 72
>e926	a926	50 72 ff e2 1b e2 72 ff 92 04 92 ff 72 12 72 ff
>e936	a936	c2 18 c2 72 72 ff e2 1b e2 72 ff 92 04 92 ff 72
>e946	a946	12 72 ff c2 18 c2 72 72 ff e2 1b e2 72 ff 92 04
>e956	a956	92 ff 72 12 72 ff c2 18 c2 72 ff 00
.e962	a962					Asset_j2chars:
>e962	a962	ff 20 42 20 ff 07 04 07			.byte	255,32,66,32,255,7,4,7,1,1,241,7,7,255,32,69,32,255,7,2,7,175,235,7,7,238,241,110,100,255,32,6,32,255,8,6,8,255,32,2,32,255,8,5,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,5,8,255,32,8,32,252,252,32,32,255,252,6,252,255,32,5,32,7,7,232,7,44,9,7,7,136,255,32,8,32,8,8,255,32,6,32,8,8,255,32,3,32,8,8,32,32,8,8,255,32,7,32,8,8,255,32,3,32,8,8,255,32,7,32,252,252,32,32,252,252,255,32,3,32,252,252,255,32,4,32,7,7,239,185,235,231,7,240,239,7,255,32,7,32,8,8,255,32,12,32,8,8,32,32,8,8,255,32,7,32,8,8,255,32,13,32,252,252,32,32,252,252,255,32,3,32,252,252,255,32,4,32,7,7,235,240,231,7,44,231,7,7,255,32,7,32,255,8,4,8,255,32,4,32,255,8,5,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,6,8,255,32,8,32,252,252,32,32,255,252,6,252,255,32,5,32,255,7,2,7,231,7,240,228,255,7,2,7,255,32,7,32,8,8,255,32,6,32,8,8,255,32,13,32,8,8,32,32,8,8,255,32,3,32,8,8,32,32,252,252,255,32,3,32,252,252,32,32,252,252,32,32,252,252,255,32,6,32,7,240,231,7,240,178,95,1,1,148,255,32,7,32,8,8,255,32,6,32,8,8,255,32,7,32,8,8,255,32,3,32,8,8,32,32,8,8,255,32,3,32,8,8,32,32,252,252,255,32,3,32,252,252,32,32,252,252,255,32,2,32,252,252,255,32,5,32,7,178,7,7,238,7,183,45,241,7,255,32,7,32,8,8,255,32,6,32,255,8,7,8,255,32,2,32,255,8,5,8,255,32,3,32,255,8,5,8,255,32,3,32,255,252,5,252,255,32,2,32,252,252,255,32,3,32,252,252,255,32,4,32,231,255,7,2,7,8,236,11,153,7,7,255,32,66,32,116,104,101,244,176,10,13,14,255,7,4,7,255,32,2,32,160,255,150,27,150,155,255,150,22,150,155,255,150,24,150,161,130,72,97,114,100,119,97,114,101,255,32,19,32,130,215,50,48,50,51,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,45,106,114,255,32,2,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,215,50,48,50,51,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,215,50,48,50,51,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,255,0
>e96a	a96a	01 01 f1 07 07 ff 20 45 20 ff 07 02 07 af eb 07
>e97a	a97a	07 ee f1 6e 64 ff 20 06 20 ff 08 06 08 ff 20 02
>e98a	a98a	20 ff 08 05 08 ff 20 02 20 ff 08 07 08 ff 20 02
>e99a	a99a	20 ff 08 05 08 ff 20 08 20 fc fc 20 20 ff fc 06
>e9aa	a9aa	fc ff 20 05 20 07 07 e8 07 2c 09 07 07 88 ff 20
>e9ba	a9ba	08 20 08 08 ff 20 06 20 08 08 ff 20 03 20 08 08
>e9ca	a9ca	20 20 08 08 ff 20 07 20 08 08 ff 20 03 20 08 08
>e9da	a9da	ff 20 07 20 fc fc 20 20 fc fc ff 20 03 20 fc fc
>e9ea	a9ea	ff 20 04 20 07 07 ef b9 eb e7 07 f0 ef 07 ff 20
>e9fa	a9fa	07 20 08 08 ff 20 0c 20 08 08 20 20 08 08 ff 20
>ea0a	aa0a	07 20 08 08 ff 20 0d 20 fc fc 20 20 fc fc ff 20
>ea1a	aa1a	03 20 fc fc ff 20 04 20 07 07 eb f0 e7 07 2c e7
>ea2a	aa2a	07 07 ff 20 07 20 ff 08 04 08 ff 20 04 20 ff 08
>ea3a	aa3a	05 08 ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08
>ea4a	aa4a	06 08 ff 20 08 20 fc fc 20 20 ff fc 06 fc ff 20
>ea5a	aa5a	05 20 ff 07 02 07 e7 07 f0 e4 ff 07 02 07 ff 20
>ea6a	aa6a	07 20 08 08 ff 20 06 20 08 08 ff 20 0d 20 08 08
>ea7a	aa7a	20 20 08 08 ff 20 03 20 08 08 20 20 fc fc ff 20
>ea8a	aa8a	03 20 fc fc 20 20 fc fc 20 20 fc fc ff 20 06 20
>ea9a	aa9a	07 f0 e7 07 f0 b2 5f 01 01 94 ff 20 07 20 08 08
>eaaa	aaaa	ff 20 06 20 08 08 ff 20 07 20 08 08 ff 20 03 20
>eaba	aaba	08 08 20 20 08 08 ff 20 03 20 08 08 20 20 fc fc
>eaca	aaca	ff 20 03 20 fc fc 20 20 fc fc ff 20 02 20 fc fc
>eada	aada	ff 20 05 20 07 b2 07 07 ee 07 b7 2d f1 07 ff 20
>eaea	aaea	07 20 08 08 ff 20 06 20 ff 08 07 08 ff 20 02 20
>eafa	aafa	ff 08 05 08 ff 20 03 20 ff 08 05 08 ff 20 03 20
>eb0a	ab0a	ff fc 05 fc ff 20 02 20 fc fc ff 20 03 20 fc fc
>eb1a	ab1a	ff 20 04 20 e7 ff 07 02 07 08 ec 0b 99 07 07 ff
>eb2a	ab2a	20 42 20 74 68 65 f4 b0 0a 0d 0e ff 07 04 07 ff
>eb3a	ab3a	20 02 20 a0 ff 96 1b 96 9b ff 96 16 96 9b ff 96
>eb4a	ab4a	18 96 a1 82 48 61 72 64 77 61 72 65 ff 20 13 20
>eb5a	ab5a	82 d7 32 30 32 33 20 53 74 65 66 61 6e 79 20 41
>eb6a	ab6a	6c 6c 61 69 72 65 20 20 82 63 32 35 36 66 6f 65
>eb7a	ab7a	6e 69 78 2e 63 6f 6d 2f 66 32 35 36 2d 6a 72 ff
>eb8a	ab8a	20 02 20 82 82 4d 69 63 72 6f 4b 65 72 6e 65 6c
>eb9a	ab9a	ff 20 10 20 82 d7 32 30 32 33 20 4a 65 73 73 69
>ebaa	abaa	65 20 4f 62 65 72 72 65 75 74 65 72 82 47 61 64
>ebba	abba	67 65 74 40 48 61 63 6b 77 72 65 6e 63 68 4c 61
>ebca	abca	62 73 2e 63 6f 6d 82 82 53 75 70 65 72 42 41 53
>ebda	abda	49 43 ff 20 11 20 82 d7 32 30 32 33 20 50 61 75
>ebea	abea	6c 20 52 6f 62 73 6f 6e ff 20 05 20 82 50 61 75
>ebfa	abfa	6c 40 52 6f 62 73 6f 6e 73 2e 6f 72 67 2e 75 6b
>ec0a	ac0a	ff 20 05 20 82 ff 00
.ec11	ac11					Asset_k2attrs:
>ec11	ac11	ff f2 5a f2 ff d8 07 d8			.byte	255,242,90,242,255,216,7,216,255,242,2,242,255,216,6,216,255,242,2,242,255,216,8,216,255,242,2,242,255,216,6,216,255,242,2,242,210,210,162,162,242,255,210,2,210,255,242,9,242,210,255,242,17,242,104,104,255,242,7,242,104,104,255,242,4,242,104,104,242,242,104,104,255,242,8,242,104,104,255,242,4,242,104,104,242,242,210,210,162,162,18,255,210,2,210,255,242,9,242,210,255,242,17,242,232,232,255,242,14,242,232,232,242,242,232,232,255,242,8,242,232,232,255,242,8,242,210,210,162,162,210,210,242,210,255,242,9,242,210,255,242,17,242,255,56,5,56,255,242,4,242,255,56,6,56,255,242,2,242,255,56,7,56,255,242,2,242,255,56,7,56,255,242,2,242,255,210,4,210,242,242,210,255,242,9,242,210,255,242,17,242,120,120,255,242,7,242,120,120,255,242,15,242,120,120,242,242,120,120,255,242,4,242,120,120,242,242,255,210,2,210,162,210,210,242,210,255,242,28,242,168,168,255,242,7,242,168,168,255,242,8,242,168,168,255,242,4,242,168,168,242,242,168,168,255,242,4,242,168,168,242,242,255,210,2,210,162,18,210,210,18,255,242,28,242,72,72,255,242,7,242,255,72,8,72,255,242,2,242,255,72,6,72,255,242,3,242,255,72,6,72,255,242,2,242,255,210,2,210,162,242,210,210,18,255,242,97,242,255,114,80,114,255,226,27,226,114,255,178,4,178,114,255,178,6,178,114,255,178,6,178,255,114,2,114,255,178,21,178,255,194,2,194,114,114,255,226,27,226,114,255,178,4,178,114,255,178,5,178,114,255,178,9,178,114,255,178,24,178,114,114,255,226,27,226,114,255,178,4,178,114,255,178,3,178,114,255,178,5,178,255,114,6,114,255,178,18,178,255,194,5,194,255,114,80,114,255,0
>ec19	ac19	ff f2 02 f2 ff d8 06 d8 ff f2 02 f2 ff d8 08 d8
>ec29	ac29	ff f2 02 f2 ff d8 06 d8 ff f2 02 f2 d2 d2 a2 a2
>ec39	ac39	f2 ff d2 02 d2 ff f2 09 f2 d2 ff f2 11 f2 68 68
>ec49	ac49	ff f2 07 f2 68 68 ff f2 04 f2 68 68 f2 f2 68 68
>ec59	ac59	ff f2 08 f2 68 68 ff f2 04 f2 68 68 f2 f2 d2 d2
>ec69	ac69	a2 a2 12 ff d2 02 d2 ff f2 09 f2 d2 ff f2 11 f2
>ec79	ac79	e8 e8 ff f2 0e f2 e8 e8 f2 f2 e8 e8 ff f2 08 f2
>ec89	ac89	e8 e8 ff f2 08 f2 d2 d2 a2 a2 d2 d2 f2 d2 ff f2
>ec99	ac99	09 f2 d2 ff f2 11 f2 ff 38 05 38 ff f2 04 f2 ff
>eca9	aca9	38 06 38 ff f2 02 f2 ff 38 07 38 ff f2 02 f2 ff
>ecb9	acb9	38 07 38 ff f2 02 f2 ff d2 04 d2 f2 f2 d2 ff f2
>ecc9	acc9	09 f2 d2 ff f2 11 f2 78 78 ff f2 07 f2 78 78 ff
>ecd9	acd9	f2 0f f2 78 78 f2 f2 78 78 ff f2 04 f2 78 78 f2
>ece9	ace9	f2 ff d2 02 d2 a2 d2 d2 f2 d2 ff f2 1c f2 a8 a8
>ecf9	acf9	ff f2 07 f2 a8 a8 ff f2 08 f2 a8 a8 ff f2 04 f2
>ed09	ad09	a8 a8 f2 f2 a8 a8 ff f2 04 f2 a8 a8 f2 f2 ff d2
>ed19	ad19	02 d2 a2 12 d2 d2 12 ff f2 1c f2 48 48 ff f2 07
>ed29	ad29	f2 ff 48 08 48 ff f2 02 f2 ff 48 06 48 ff f2 03
>ed39	ad39	f2 ff 48 06 48 ff f2 02 f2 ff d2 02 d2 a2 f2 d2
>ed49	ad49	d2 12 ff f2 61 f2 ff 72 50 72 ff e2 1b e2 72 ff
>ed59	ad59	b2 04 b2 72 ff b2 06 b2 72 ff b2 06 b2 ff 72 02
>ed69	ad69	72 ff b2 15 b2 ff c2 02 c2 72 72 ff e2 1b e2 72
>ed79	ad79	ff b2 04 b2 72 ff b2 05 b2 72 ff b2 09 b2 72 ff
>ed89	ad89	b2 18 b2 72 72 ff e2 1b e2 72 ff b2 04 b2 72 ff
>ed99	ad99	b2 03 b2 72 ff b2 05 b2 ff 72 06 72 ff b2 12 b2
>eda9	ada9	ff c2 05 c2 ff 72 50 72 ff 00
.edb3	adb3					Asset_k2chars:
>edb3	adb3	ff 20 5a 20 ff 08 07 08			.byte	255,32,90,32,255,8,7,8,255,32,2,32,255,8,6,8,255,32,2,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,2,32,180,180,255,32,2,32,180,180,32,255,180,6,180,255,32,21,32,8,8,255,32,7,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,180,180,255,32,2,32,180,180,255,32,5,32,180,180,255,32,21,32,8,8,255,32,14,32,8,8,32,32,8,8,255,32,8,32,8,8,255,32,8,32,180,180,32,32,180,180,255,32,6,32,180,180,255,32,21,32,255,8,5,8,255,32,4,32,255,8,6,8,255,32,2,32,255,8,7,8,255,32,2,32,255,8,7,8,255,32,2,32,255,180,4,180,255,32,2,32,255,180,6,180,255,32,21,32,8,8,255,32,7,32,8,8,255,32,15,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,255,180,2,180,32,180,180,32,32,255,180,2,180,255,32,25,32,8,8,255,32,7,32,8,8,255,32,8,32,8,8,255,32,4,32,8,8,32,32,8,8,255,32,4,32,8,8,32,32,255,180,2,180,32,32,180,180,32,255,180,2,180,255,32,25,32,8,8,255,32,7,32,255,8,8,8,255,32,2,32,255,8,6,8,255,32,3,32,255,8,6,8,255,32,2,32,255,180,2,180,32,32,180,180,32,255,180,6,180,255,32,90,32,160,255,150,27,150,155,255,150,22,150,155,255,150,24,150,161,130,72,97,114,100,119,97,114,101,255,32,19,32,130,215,50,48,50,52,32,83,116,101,102,97,110,121,32,65,108,108,97,105,114,101,32,32,130,99,50,53,54,102,111,101,110,105,120,46,99,111,109,47,102,50,53,54,107,50,255,32,3,32,130,130,77,105,99,114,111,75,101,114,110,101,108,255,32,16,32,130,215,50,48,50,52,32,74,101,115,115,105,101,32,79,98,101,114,114,101,117,116,101,114,130,71,97,100,103,101,116,64,72,97,99,107,119,114,101,110,99,104,76,97,98,115,46,99,111,109,130,130,83,117,112,101,114,66,65,83,73,67,255,32,17,32,130,215,50,48,50,52,32,80,97,117,108,32,82,111,98,115,111,110,255,32,5,32,130,80,97,117,108,64,82,111,98,115,111,110,115,46,111,114,103,46,117,107,255,32,5,32,130,162,255,150,27,150,157,255,150,22,150,157,255,150,24,150,163,255,0
>edbb	adbb	ff 20 02 20 ff 08 06 08 ff 20 02 20 ff 08 08 08
>edcb	adcb	ff 20 02 20 ff 08 06 08 ff 20 02 20 b4 b4 ff 20
>eddb	addb	02 20 b4 b4 20 ff b4 06 b4 ff 20 15 20 08 08 ff
>edeb	adeb	20 07 20 08 08 ff 20 04 20 08 08 20 20 08 08 ff
>edfb	adfb	20 08 20 08 08 ff 20 04 20 08 08 20 20 b4 b4 ff
>ee0b	ae0b	20 02 20 b4 b4 ff 20 05 20 b4 b4 ff 20 15 20 08
>ee1b	ae1b	08 ff 20 0e 20 08 08 20 20 08 08 ff 20 08 20 08
>ee2b	ae2b	08 ff 20 08 20 b4 b4 20 20 b4 b4 ff 20 06 20 b4
>ee3b	ae3b	b4 ff 20 15 20 ff 08 05 08 ff 20 04 20 ff 08 06
>ee4b	ae4b	08 ff 20 02 20 ff 08 07 08 ff 20 02 20 ff 08 07
>ee5b	ae5b	08 ff 20 02 20 ff b4 04 b4 ff 20 02 20 ff b4 06
>ee6b	ae6b	b4 ff 20 15 20 08 08 ff 20 07 20 08 08 ff 20 0f
>ee7b	ae7b	20 08 08 20 20 08 08 ff 20 04 20 08 08 20 20 ff
>ee8b	ae8b	b4 02 b4 20 b4 b4 20 20 ff b4 02 b4 ff 20 19 20
>ee9b	ae9b	08 08 ff 20 07 20 08 08 ff 20 08 20 08 08 ff 20
>eeab	aeab	04 20 08 08 20 20 08 08 ff 20 04 20 08 08 20 20
>eebb	aebb	ff b4 02 b4 20 20 b4 b4 20 ff b4 02 b4 ff 20 19
>eecb	aecb	20 08 08 ff 20 07 20 ff 08 08 08 ff 20 02 20 ff
>eedb	aedb	08 06 08 ff 20 03 20 ff 08 06 08 ff 20 02 20 ff
>eeeb	aeeb	b4 02 b4 20 20 b4 b4 20 ff b4 06 b4 ff 20 5a 20
>eefb	aefb	a0 ff 96 1b 96 9b ff 96 16 96 9b ff 96 18 96 a1
>ef0b	af0b	82 48 61 72 64 77 61 72 65 ff 20 13 20 82 d7 32
>ef1b	af1b	30 32 34 20 53 74 65 66 61 6e 79 20 41 6c 6c 61
>ef2b	af2b	69 72 65 20 20 82 63 32 35 36 66 6f 65 6e 69 78
>ef3b	af3b	2e 63 6f 6d 2f 66 32 35 36 6b 32 ff 20 03 20 82
>ef4b	af4b	82 4d 69 63 72 6f 4b 65 72 6e 65 6c ff 20 10 20
>ef5b	af5b	82 d7 32 30 32 34 20 4a 65 73 73 69 65 20 4f 62
>ef6b	af6b	65 72 72 65 75 74 65 72 82 47 61 64 67 65 74 40
>ef7b	af7b	48 61 63 6b 77 72 65 6e 63 68 4c 61 62 73 2e 63
>ef8b	af8b	6f 6d 82 82 53 75 70 65 72 42 41 53 49 43 ff 20
>ef9b	af9b	11 20 82 d7 32 30 32 34 20 50 61 75 6c 20 52 6f
>efab	afab	62 73 6f 6e ff 20 05 20 82 50 61 75 6c 40 52 6f
>efbb	afbb	62 73 6f 6e 73 2e 6f 72 67 2e 75 6b ff 20 05 20
>efcb	afcb	82 a2 ff 96 1b 96 9d ff 96 16 96 9d ff 96 18 96
>efdb	afdb	a3 ff 00
=$a000							Header_jattrs = Asset_jattrs
=$a18d							Header_jchars = Asset_jchars
=$a3bd							Header_kattrs = Asset_kattrs
=$a51c							Header_kchars = Asset_kchars
.efde	afde					Header_Palette:
>efde	afde	00 00 00 00				.dword $000000
>efe2	afe2	66 66 66 00				.dword $666666
>efe6	afe6	aa 00 00 00				.dword $0000aa
>efea	afea	00 aa 00 00				.dword $00aa00
>efee	afee	ea 41 c0 00				.dword $c041ea
>eff2	aff2	00 48 87 00				.dword $874800
>eff6	aff6	00 9c ff 00				.dword $ff9c00
>effa	affa	ff db 57 00				.dword $57dbff
>effe	affe	28 3f 3f 00				.dword $3f3f28
>f002	b002	8a aa aa 00				.dword $aaaa8a
>f006	b006	ff 55 55 00				.dword $5555ff
>f00a	b00a	55 ff 55 00				.dword $55ff55
>f00e	b00e	ed 8d ff 00				.dword $ff8ded
>f012	b012	00 00 ff 00				.dword $ff0000
>f016	b016	55 ff ff 00				.dword $ffff55
>f01a	b01a	ff ff ff 00				.dword $ffffff
>f01e	b01e	ff ff ff 00				.dword $ffffff
>f022	b022	ff ff ff 00				.dword $ffffff

;******  Return to file: _basic.asm


;******  End of listing
